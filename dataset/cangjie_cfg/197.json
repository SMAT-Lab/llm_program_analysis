{
  "name": "197.cj",
  "type": "File",
  "blocks": [],
  "functions": [],
  "classes": [
    {
      "name": "_DEFAULT_CANG_CLASS",
      "type": "Class",
      "blocks": [],
      "functions": [
        {
          "name": "SplitCurrentState",
          "type": "Function",
          "blocks": [
            {
              "id": 133924175552496,
              "label": "",
              "successors": [
                {
                  "id": 133924152227200,
                  "label": "Array<(Vertex<V, G>, Vertex<V, G>)>(\n        numberOfStateWires,\n        { i : Int64 =>\n            let joinEdge = coreEdge.NextEdgeLeft(i).getOrThrow().GetEdge()\n            let joinSourceLeft = joinEdge.GetSource(0)\n            let (left, right) = joinSourceLeft.SplitVertex()\n            rewriteStartingElements.put(VERTEX(left))\n            rewriteEndingElements.put(EDGE(joinEdge))\n            (left, right)\n        }\n    )",
                  "successors": [
                    {
                      "id": 133924175552544,
                      "label": "return",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "GetCoreSourceVertices",
          "type": "Function",
          "blocks": [
            {
              "id": 133924175554560,
              "label": "",
              "successors": [
                {
                  "id": 133924152227344,
                  "label": "Array<Vertex<V, G>>(\n        coreEdge.GetArity(),\n        { i : Int64 =>\n            // Check which partition of sources this belongs to\n            if(i < numberOfStateWires) {\n                // This is a vertex from the state\n                // We grab the existing state vertex\n                splitStateVertices[i][0]\n            } else {\n                // This is a vertex from the inputs\n                // We create the input edge and grab its target\n                // Get the signal\n                let input = inputSignals[i - numberOfStateWires]\n                let (inputLabel, inputSubgraph) =\n                    match(input) {\n                        case DEFINITE(signal) =>\n                            // Make a label\n                            let signalLabel = GetSignalLabel<V, G>(signal)\n                            let signalSubgraph = if(signal.GetWidth() == 1) {\n                                None<InterfacedHypergraph<V, G>>\n                            } else {\n                                MakeSignal<V, G>(signal)\n                            }\n                            (signalLabel, signalSubgraph)\n                        case PARTIAL(pi) =>\n                            let partialLabel = Label<V, G>.PARTIAL(pi)\n                            let partialSubgraph =\n                                None<InterfacedHypergraph<V, G>>\n                            (partialLabel, partialSubgraph)\n                    }\n                let inputTarget = Vertex<V, G>(input.GetWidth(), None)\n                // Create the signal\n                let inputEdge = Edge(\n                    inputLabel, Array<Vertex<V, G>>(), [inputTarget],\n                    inputSubgraph, coreEdge.GetGraph()\n                )\n                // The target of this edge will need to be traversed\n                // during rewriting\n                rewriteStartingElements.put(VERTEX(inputTarget))\n                inputTarget\n            }\n        }\n    )",
                  "successors": [
                    {
                      "id": 133924175554608,
                      "label": "return",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "CreateOutputJoinEdges",
          "type": "Function",
          "blocks": [
            {
              "id": 133924175556000,
              "label": "",
              "successors": [
                {
                  "id": 133924152227488,
                  "label": "mapi(\n        { v : Vertex<V, G>, i : Int64 =>\n            // Split this vertex, as we are going to insert a register\n            let (leftVertex, rightVertex) = v.SplitVertex()\n            let outputWidth = v.GetWidth()\n            let delayTarget = Vertex<V, G>(outputWidth, Some(graph))\n            let delayEdge = Edge(\n                DELAY(outputWidth), [leftVertex], [delayTarget], None, graph\n            )\n            latestDelayVertices[i] = leftVertex\n            // Create the instant component for this register\n            let outputTarget = Vertex<V, G>(outputWidth, Some(graph))\n            latestInstantVertices[i] = outputTarget\n            // Create the join for this register\n            let joinEdge = Edge(\n                JOIN(outputWidth), [outputTarget, delayTarget],\n                [rightVertex], None, graph\n            )\n            rewriteEndingElements.put(VERTEX(outputTarget))\n            joinEdge\n        }, latestDelayVertices\n    )",
                  "successors": [
                    {
                      "id": 133924175556048,
                      "label": "return",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "GetCoreTargetVertices",
          "type": "Function",
          "blocks": [
            {
              "id": 133924175557344,
              "label": "",
              "successors": [
                {
                  "id": 133924152227632,
                  "label": "Array<Vertex<V, G>>(coreEdge.GetCoarity())",
                  "successors": [
                    {
                      "id": 133924152227680,
                      "label": "{\n        i : Int64 =>\n            // The targets of the cloned core edge are paritioned between\n            // the state transition and the outputs. If we are getting the\n            // target for a state transition, we just use the right vertex\n            // of the split state we made earlier. If we are getting the\n            // target for an output, we split the corresponding output\n            // vertex and insert a register, the instnat component of which\n            // is the target we are getting.\n            if(i < numberOfStateWires) {\n                splitStateVertices[i][1]\n            } else {\n                latestInstantVertices[i - numberOfStateWires]\n            }\n    }",
                      "successors": [
                        {
                          "id": 133924175557392,
                          "label": "return",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "GetOutputData",
          "type": "Function",
          "blocks": [
            {
              "id": 133924175558400,
              "label": "",
              "successors": [
                {
                  "id": 133924152227824,
                  "label": "map(\n        { f =>\n            let term = GetOutputTerm(f.GetOutput(0).GetVertex())\n            OutputData<V, G>(term, f)\n        }, outputSubgraphs\n    )",
                  "successors": [
                    {
                      "id": 133924175558448,
                      "label": "return",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "UpdateInputOutputHistory",
          "type": "Function",
          "blocks": [
            {
              "id": 133924175559504,
              "label": "",
              "successors": [
                {
                  "id": 133924152227968,
                  "label": "let outputData = GetOutputData(outputSubgraphs)",
                  "successors": [
                    {
                      "id": 133924152228016,
                      "label": "history.inputHistoryPerTick.append(inputSignals)",
                      "successors": [
                        {
                          "id": 133924152228064,
                          "label": "history.outputHistoryPerTick.append(outputData)",
                          "successors": [
                            {
                              "id": 133924152228112,
                              "label": "let inputOutput = InputOutput(inputSignals, outputData)",
                              "successors": [
                                {
                                  "id": 133924152228160,
                                  "label": "history.inputOutputHistoryPerTick.append(inputOutput)",
                                  "successors": [
                                    {
                                      "id": 133924152228208,
                                      "label": "for (i in 0..graph.GetArity() )",
                                      "successors": [
                                        {
                                          "id": 133924152228496,
                                          "label": "history.inputHistoryPerPort[i].append(inputSignals[i])",
                                          "successors": [
                                            {
                                              "id": 133924152228208
                                            }
                                          ]
                                        },
                                        {
                                          "id": 133924152228304,
                                          "label": "for (i in 0..graph.GetCoarity() )",
                                          "successors": [
                                            {
                                              "id": 133924152228736,
                                              "label": "history.outputHistoryPerPort[i].append(outputData[i])",
                                              "successors": [
                                                {
                                                  "id": 133924152228304
                                                }
                                              ]
                                            },
                                            {
                                              "id": 133924175559552,
                                              "label": "return",
                                              "successors": []
                                            }
                                          ]
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "CollapseSingleOutput",
          "type": "Function",
          "blocks": [
            {
              "id": 133924175560608,
              "label": "",
              "successors": [
                {
                  "id": 133924152228784,
                  "label": "let (subgraph, _) = rootVertex.GetGraph().CollapseSubgraph(\n        Array<TentacleOrigin<V, G>>(),\n        [FROM_EDGE(rootVertex.GetInEdge().getOrThrow())],\n        \"${label.GetName()}[${index}] @ ${tick}\"\n    )",
                  "successors": [
                    {
                      "id": 133924152228832,
                      "label": "subgraph",
                      "successors": [
                        {
                          "id": 133924175560656,
                          "label": "return",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "CollapseOutputs",
          "type": "Function",
          "blocks": [
            {
              "id": 133924175807632,
              "label": "",
              "successors": [
                {
                  "id": 133924152228976,
                  "label": "mapi(\n        { e : Edge<V, G>, i : Int64 =>\n            CollapseSingleOutput(e.GetSource(0), label, tick, i)\n        },\n        joinEdges\n    )",
                  "successors": [
                    {
                      "id": 133924175807680,
                      "label": "return",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "PerformCycle",
          "type": "Function",
          "blocks": [
            {
              "id": 133924175809360,
              "label": "",
              "successors": [
                {
                  "id": 133924152229120,
                  "label": "AssertHasInputs(graph, inputSignals.size)",
                  "successors": [
                    {
                      "id": 133924152229168,
                      "label": "let rewriteStartingElements = HashSet<TraversalElement<V, G>>()",
                      "successors": [
                        {
                          "id": 133924152229216,
                          "label": "let rewriteEndingElements = HashSet<TraversalElement<V, G>>()",
                          "successors": [
                            {
                              "id": 133924152229264,
                              "label": "let splitJoinVertices = SplitCurrentState(\n        coreEdge, numberOfStateWires,\n        rewriteStartingElements, rewriteEndingElements\n    )",
                              "successors": [
                                {
                                  "id": 133924152229312,
                                  "label": "let currentJoinEdges = CreateOutputJoinEdges(\n        graph.GetGraph(), latestDelayVertices, latestInstantVertices,\n        rewriteEndingElements\n    )",
                                  "successors": [
                                    {
                                      "id": 133924152229360,
                                      "label": "let coreCopyInputs = GetCoreSourceVertices(\n        coreEdge, numberOfStateWires, inputSignals, splitJoinVertices,\n        rewriteStartingElements\n    )",
                                      "successors": [
                                        {
                                          "id": 133924152229408,
                                          "label": "let coreCopyOutputs = GetCoreTargetVertices(\n        coreEdge, numberOfStateWires, splitJoinVertices, latestInstantVertices\n    )",
                                          "successors": [
                                            {
                                              "id": 133924152229456,
                                              "label": "let coreCopyEdge = coreEdge.Clone(\n        coreCopyInputs, coreCopyOutputs, graph.GetGraph()\n    )",
                                              "successors": [
                                                {
                                                  "id": 133924152229504,
                                                  "label": "RewriteCombinational(\n        signature, graph, rewriteStartingElements, rewriteEndingElements,\n        copyBlackBoxes: true, allInstantaneous: true, debug: debug, draw: draw\n    )",
                                                  "successors": [
                                                    {
                                                      "id": 133924152229552,
                                                      "label": "let outputSubgraphs = CollapseOutputs(\n        currentJoinEdges, graph.GetLabel(), history.GetCurrentTick()\n    )",
                                                      "successors": [
                                                        {
                                                          "id": 133924152229600,
                                                          "label": "UpdateInputOutputHistory(\n        graph, inputSignals, outputSubgraphs, history\n    )",
                                                          "successors": [
                                                            {
                                                              "id": 133924175809408,
                                                              "label": "return",
                                                              "successors": []
                                                            }
                                                          ]
                                                        }
                                                      ]
                                                    }
                                                  ]
                                                }
                                              ]
                                            }
                                          ]
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "functions": [],
          "classes": []
        }
      ],
      "classes": []
    },
    {
      "name": "Evaluator<V, G>",
      "type": "Class",
      "blocks": [],
      "functions": [
        {
          "name": "PerformCycle",
          "type": "Function",
          "blocks": [
            {
              "id": 133924175819056,
              "label": "",
              "successors": [
                {
                  "id": 133924152229792,
                  "label": "AssertHasInputs(this.graph, inputs.size)",
                  "successors": [
                    {
                      "id": 133924152229840,
                      "label": "let inputSignals = mapi(\n            { v : Int64, i : Int64 =>\n                V.DecToSignal(\n                    v, width: this.graph.GetInput(i).GetWidth(), signed: signed\n                )\n            },\n            inputs\n        )",
                      "successors": [
                        {
                          "id": 133924152393792,
                          "label": "this.PerformCycle(inputSignals, debug: debug, draw: draw)",
                          "successors": [
                            {
                              "id": 133924175819104,
                              "label": "return",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "PerformCycle",
          "type": "Function",
          "blocks": [
            {
              "id": 133924175819824,
              "label": "",
              "successors": [
                {
                  "id": 133924152393936,
                  "label": "AssertHasInputs(this.graph, 1)",
                  "successors": [
                    {
                      "id": 133924152393984,
                      "label": "this.PerformCycle([input], signed: signed, debug: debug, draw: draw)",
                      "successors": [
                        {
                          "id": 133924175819872,
                          "label": "return",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "PerformCycles",
          "type": "Function",
          "blocks": [
            {
              "id": 133924175820688,
              "label": "",
              "successors": [
                {
                  "id": 133924152394128,
                  "label": "AssertHasInputs(this.graph, inputs.size)",
                  "successors": [
                    {
                      "id": 133924152394176,
                      "label": "for (_ in 0..ticks )",
                      "successors": [
                        {
                          "id": 133924152394464,
                          "label": "PerformCycle(inputs, signed: signed, debug: debug, draw: draw)",
                          "successors": [
                            {
                              "id": 133924152394176
                            }
                          ]
                        },
                        {
                          "id": 133924175820736,
                          "label": "return",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "PerformCycles",
          "type": "Function",
          "blocks": [
            {
              "id": 133924175821504,
              "label": "",
              "successors": [
                {
                  "id": 133924152394512,
                  "label": "AssertHasInputs(this.graph, 1)",
                  "successors": [
                    {
                      "id": 133924152394560,
                      "label": "for (_ in 0..ticks )",
                      "successors": [
                        {
                          "id": 133924152394848,
                          "label": "PerformCycle(input, signed: signed, debug: debug, draw: draw)",
                          "successors": [
                            {
                              "id": 133924152394560
                            }
                          ]
                        },
                        {
                          "id": 133924175821552,
                          "label": "return",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "functions": [],
          "classes": []
        }
      ],
      "classes": []
    }
  ]
}