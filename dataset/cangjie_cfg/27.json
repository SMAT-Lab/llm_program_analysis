[
  "Edge 0: [Source] func inCharSpecifiers(cs: Array<CharSpecifier>, c: Rune, options: MatchOptions): Bool { ... => [Target] case CharSpecifier.SingleChar(cs) => if (charsEq(c, cs, options.",
  "Edge 1: [Source] func inCharSpecifiers(cs: Array<CharSpecifier>, c: Rune, options: MatchOptions): Bool { ... => [Target] case CharSpecifier.CharRange(start, end) => if (!options.",
  "Edge 2: [Source] func fillTodo(\n    todo: ArrayList<(PathWrapper, Int64)>,\n    patterns: Array<Pattern>,\n    idx: Int,\n    path: PathWrapper,\n    options: MatchOptions\n): Unit { ... => [Target] case Some(s) => let special = s == \".\" || s == \"..\"\n            let nextPath = if (curDir) {\n                Path(s)\n            } else {\n                path.path.join(s)\n            }\n            let nextPathWrapper: PathWrapper\n            try {\n                nextPathWrapper = PathWrapper(nextPath)\n            } catch (e: FSException) {\n                return\n            }\n            if ((special && isDir) || !special) {\n                add(todo, nextPathWrapper)\n            }",
  "Edge 3: [Source] func fillTodo(\n    todo: ArrayList<(PathWrapper, Int64)>,\n    patterns: Array<Pattern>,\n    idx: Int,\n    path: PathWrapper,\n    options: MatchOptions\n): Unit { ... => [Target] case None => if (isDir) {\n                let dirFiles = Directory.readFrom(path.path)\n                let dirs = ArrayList<PathWrapper>()\n                for (e in dirFiles) {\n                    if (curDir) {\n                        dirs.append(PathWrapper(Path(e.path.fileName), e.isDirectory()))\n                    } else {\n                        dirs.append(PathWrapper(e.path, e.isDirectory()))\n                    }\n                }\n                var children = dirs.iterator()\n                if (options.requireLiteralLeadingDot) {\n                    children = children.filter {\n                        c => !(c.path.fileName.startsWith(\".\"))\n                    }\n                }\n                let cc = ArrayList<PathWrapper>()\n                for (c in children) {\n                    cc.append(c)\n                }\n                cc.sortBy {\n                    l: PathWrapper, r: PathWrapper => if (l.path.fileName > r.path.fileName) {\n                        Ordering.GT\n                    } else if (l.path.fileName < r.path.fileName) {\n                        Ordering.LT\n                    } else {\n                        Ordering.EQ\n                    }\n                }\n\n                for (c in cc) {\n                    todo.append((c, idx))\n                }\n\n                if (!pattern.tokens.isEmpty() && pattern.tokens[0] == PatternToken.Char(r'.')) {\n                    for (sp in [\".\", \"..\"]) {\n                        if (pattern.matchesWith(sp, options)) {\n                            add(todo, PathWrapper(path.path.join(sp)))\n                        }\n                    }\n                }\n            }\n    }\n}",
  "Edge 4: [Source] public func globWith(pattern: String, options: MatchOptions): Paths { ... => [Target] case Some(r) => root = r\n            foundRoot = true",
  "Edge 5: [Source] public func globWith(pattern: String, options: MatchOptions): Paths { ... => [Target] case None => root = \".\"\n            foundRoot = false\n    }\n\n    let dirPatterns = ArrayList<Pattern>()\n    let skip = if (foundRoot) {\n        root.size\n    } else {\n        0\n    }\n    let components = pattern[(min(skip, pattern.size))..].split(isSeparator)\n    for (c in components) {\n        dirPatterns.append(Pattern(c))\n    }\n\n    if (foundRoot && root.size == pattern.size) {\n        dirPatterns.append(Pattern(\"\"))\n    }\n\n    let lastIsSeparator = if (pattern.size > 0) {\n        let ra = pattern.toRuneArray()\n        isSeparator(ra[ra.size - 1])\n    } else {\n        false\n    }\n\n    return Paths(\n        dirPatterns.toArray(),\n        lastIsSeparator,\n        options,\n        ArrayList<(PathWrapper, Int64)>(),\n        PathWrapper(Path(root))\n    )\n}",
  "Edge 6: [Source] init(pattern: String) { ... => [Target] case r'?' => tokens.append(PatternToken.AnyChar)\n                    i++",
  "Edge 7: [Source] init(pattern: String) { ... => [Target] case r'*' => let old = i\n\n                    while (i < chars.size && chars[i] == r'*') {\n                        i++\n                    }\n\n                    let count = i - old\n\n                    if (count > 2) {\n                        throw PatternException(old + 2, ERROR_WILDCARDS)\n                    } else if (count == 2) {\n                        let is_valid = if (i == 2 || isSeparator(chars[i - count - 1])) {\n                            if (i < chars.size && isSeparator(chars[i])) {\n                                i++\n                                true\n                            } else if (i == chars.size) {\n                                true\n                            } else {\n                                throw PatternException(i, ERROR_RECURSIVE_WILDCARDS)\n                            }\n                        } else {\n                            throw PatternException(old - 1, ERROR_RECURSIVE_WILDCARDS)\n                        }\n\n                        if (is_valid) {\n                            let tokens_len = tokens.size\n\n                            if (!(tokens_len > 1 && tokens.get(tokens_len - 1) == PatternToken.AnyRecursiveSequence)) {\n                                is_recursive = true\n                                tokens.append(PatternToken.AnyRecursiveSequence)\n                            }\n                        }\n                    } else {\n                        tokens.append(PatternToken.AnySequence)\n                    }",
  "Edge 8: [Source] init(pattern: String) { ... => [Target] case r'[' => if (i + 4 <= chars.size && chars[i + 1] == r'!') {\n                        match (chars[i + 3..].indexOf(r']')) {",
  "Edge 9: [Source] init(pattern: String) { ... => [Target] case None => ()",
  "Edge 10: [Source] init(pattern: String) { ... => [Target] case Some(j) => let subChars = chars[i + 2..i + 3 + j]\n                                let cs = parseCharSpecifiers(subChars)\n                                tokens.append(PatternToken.AnyExcept(cs))\n                                i += 4 + j\n                                continue\n                        }\n                    } else if (i + 3 <= chars.size && chars[i + 1] != r'!') {\n                        match (chars[i + 2..].indexOf(r']')) {",
  "Edge 11: [Source] init(pattern: String) { ... => [Target] case None => ()",
  "Edge 12: [Source] init(pattern: String) { ... => [Target] case Some(j) => let subChars = chars[i + 1..i + 2 + j]\n                                let cs = parseCharSpecifiers(subChars)\n                                tokens.append(PatternToken.AnyWithin(cs))\n                                i += 3 + j\n                                continue\n                        }\n                    }\n\n                    throw PatternException(i, ERROR_INVALID_RANGE)",
  "Edge 13: [Source] init(pattern: String) { ... => [Target] case c => tokens.append(PatternToken.Char(c))\n                    i++\n            }\n        }\n\n        this.original = pattern\n        this.tokens = tokens\n        this.isRecursive = is_recursive\n    }",
  "Edge 14: [Source] public func matchesFrom(\n        followsSeparator: Bool,\n        file: CharsIterator,\n        i: Int,\n        options: MatchOptions\n    ): MatchResult { ... => [Target] case AnySequence | AnyRecursiveSequence => match (this.matchesFrom(fs, file.clone(), i + ti + 1, options)) {",
  "Edge 15: [Source] public func matchesFrom(\n        followsSeparator: Bool,\n        file: CharsIterator,\n        i: Int,\n        options: MatchOptions\n    ): MatchResult { ... => [Target] case MatchResult.SubPatternDoesntMatch => ()",
  "Edge 16: [Source] public func matchesFrom(\n        followsSeparator: Bool,\n        file: CharsIterator,\n        i: Int,\n        options: MatchOptions\n    ): MatchResult { ... => [Target] case m => return m\n                    }\n\n                    while (let Some(c) <- file.next()) {\n                        if (fs && options.requireLiteralLeadingDot && c == r'.') {\n                            return MatchResult.SubPatternDoesntMatch\n                        }\n                        fs = isSeparator(c)\n                        match (token) {",
  "Edge 17: [Source] public func matchesFrom(\n        followsSeparator: Bool,\n        file: CharsIterator,\n        i: Int,\n        options: MatchOptions\n    ): MatchResult { ... => [Target] case PatternToken.AnyRecursiveSequence => if (!fs) {\n                                    continue\n                                }",
  "Edge 18: [Source] public func matchesFrom(\n        followsSeparator: Bool,\n        file: CharsIterator,\n        i: Int,\n        options: MatchOptions\n    ): MatchResult { ... => [Target] case PatternToken.AnySequence => if (options.requireLiteralSeparator && fs) {\n                                    return MatchResult.SubPatternDoesntMatch\n                                }",
  "Edge 19: [Source] public func matchesFrom(\n        followsSeparator: Bool,\n        file: CharsIterator,\n        i: Int,\n        options: MatchOptions\n    ): MatchResult { ... => [Target] case _ => ()\n                        }\n\n                        match (this.matchesFrom(fs, file.clone(), i + ti + 1, options)) {",
  "Edge 20: [Source] public func matchesFrom(\n        followsSeparator: Bool,\n        file: CharsIterator,\n        i: Int,\n        options: MatchOptions\n    ): MatchResult { ... => [Target] case MatchResult.SubPatternDoesntMatch => ()",
  "Edge 21: [Source] public func matchesFrom(\n        followsSeparator: Bool,\n        file: CharsIterator,\n        i: Int,\n        options: MatchOptions\n    ): MatchResult { ... => [Target] case m => return m\n                        }\n                    }",
  "Edge 22: [Source] public func matchesFrom(\n        followsSeparator: Bool,\n        file: CharsIterator,\n        i: Int,\n        options: MatchOptions\n    ): MatchResult { ... => [Target] case _ => let c = match (file.next()) {",
  "Edge 23: [Source] public func matchesFrom(\n        followsSeparator: Bool,\n        file: CharsIterator,\n        i: Int,\n        options: MatchOptions\n    ): MatchResult { ... => [Target] case Some(c) => c",
  "Edge 24: [Source] public func matchesFrom(\n        followsSeparator: Bool,\n        file: CharsIterator,\n        i: Int,\n        options: MatchOptions\n    ): MatchResult { ... => [Target] case None => return MatchResult.EntirePatternDoesntMatch\n                    }\n\n                    let is_sep = isSeparator(c)\n\n                    if (!match (token) {",
  "Edge 25: [Source] public func matchesFrom(\n        followsSeparator: Bool,\n        file: CharsIterator,\n        i: Int,\n        options: MatchOptions\n    ): MatchResult { ... => [Target] case PatternToken.AnyChar | PatternToken.AnyWithin(_) | AnyExcept(_) => if ((options.requireLiteralSeparator && is_sep) || (fs && options.requireLiteralLeadingDot &&\n                                c == r'.')) {\n                                false\n                            } else {\n                                true\n                            }",
  "Edge 26: [Source] public func matchesFrom(\n        followsSeparator: Bool,\n        file: CharsIterator,\n        i: Int,\n        options: MatchOptions\n    ): MatchResult { ... => [Target] case _ => true\n                    }) {\n                        return MatchResult.SubPatternDoesntMatch\n                    }\n\n                    if (!match (token) {",
  "Edge 27: [Source] public func matchesFrom(\n        followsSeparator: Bool,\n        file: CharsIterator,\n        i: Int,\n        options: MatchOptions\n    ): MatchResult { ... => [Target] case PatternToken.AnyChar => true",
  "Edge 28: [Source] public func matchesFrom(\n        followsSeparator: Bool,\n        file: CharsIterator,\n        i: Int,\n        options: MatchOptions\n    ): MatchResult { ... => [Target] case PatternToken.AnyWithin(cs) => inCharSpecifiers(cs, c, options)",
  "Edge 29: [Source] public func matchesFrom(\n        followsSeparator: Bool,\n        file: CharsIterator,\n        i: Int,\n        options: MatchOptions\n    ): MatchResult { ... => [Target] case PatternToken.AnyExcept(cs) => !inCharSpecifiers(cs, c, options)",
  "Edge 30: [Source] public func matchesFrom(\n        followsSeparator: Bool,\n        file: CharsIterator,\n        i: Int,\n        options: MatchOptions\n    ): MatchResult { ... => [Target] case PatternToken.Char(tc) => charsEq(c, tc, options.",
  "Edge 31: [Source] public func matchesFrom(\n        followsSeparator: Bool,\n        file: CharsIterator,\n        i: Int,\n        options: MatchOptions\n    ): MatchResult { ... => [Target] case _ => throw Exception(\"unreachable\")\n                    }) {\n                        return MatchResult.SubPatternDoesntMatch\n                    }\n                    fs = is_sep\n            }\n        }\n\n        if (file.next().isNone()) {\n            return MatchResult.Match\n        } else {\n            return MatchResult.SubPatternDoesntMatch\n        }\n    }",
  "Edge 32: [Source] func toCharString(): Option<String> { ... => [Target] case Char(c) => ret.append(c)",
  "Edge 33: [Source] func toCharString(): Option<String> { ... => [Target] case _ => return None\n            }\n        }\n        return ret.toString()\n    }"
]