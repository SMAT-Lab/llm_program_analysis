[
  "Edge 0: [Source] protected func drawDataSet(c: CanvasRenderingContext2D, dataSet: WaterfallDataSet, index: Int64): Unit { ... => [Target] case Style.STROKE => c.stroke();",
  "Edge 1: [Source] protected func drawDataSet(c: CanvasRenderingContext2D, dataSet: WaterfallDataSet, index: Int64): Unit { ... => [Target] case _ => c.fill();\n                }\n                c.closePath();\n            }\n        }\n        // initialize the buffer\n        let buffer: WaterfallBuffer = this.mBarBuffers[index];\n        buffer.setPhases(phaseX, phaseY);\n        buffer.setDataSet(index);\n        buffer.setInverted(this.mChart.isInverted(dataSet.getAxisDependency()));\n        let waterfallData: ?WaterfallData = this.mChart.getWaterfallData();\n        if (let Some(data) <- waterfallData) {\n            buffer.setBarWidth(data.getBarWidth());\n        }\n        let tempArray: Array<Float64> = buffer.buffer.toArray()\n        buffer.feed(dataSet);\n        if (let Some(t) <- trans) {\n            t.pointValuesToPixel(tempArray);\n        }\n        let fills: ?ArrayList<Fill> = dataSet.getFills()()\n        let isCustomFill: Bool = fills.isSome() && fills().size > 0\n        let isSingleColor: Bool = dataSet.getColors().size == 1\n        let isInverted: Bool = this.mChart.isInverted(dataSet.getAxisDependency())\n        if (isSingleColor) {\n            this.mRenderPaint.setColor(Color(dataSet.getColor()));\n            if (dataSet.getOpacity().size != 0) {\n                this.mRenderPaint.setFilter(dataSet.getOpacity());\n            }\n        }\n        let maxTop = buffer.getArrayTop()[buffer.getArrayTop().size - 1];\n        let minBottom = buffer.getArrayBottom()[0];\n        if (dataSet.getEnableMaxOrMinHighlightColor()) {\n            for (i in 0..Int64(min((ceil(Float64(dataSet.getEntryCount()) * phaseX)), Float64(dataSet.getEntryCount())))) {\n                let e: WaterfallEntry = dataSet.getEntryForIndex(i)\n                this.initMaxAndMinHighlightData(e, dataSet, maxTop, minBottom);\n            }\n        }\n        // 获取Y轴刻度范围数据\n        let yAxisSegmentList = dataSet.getYAxisSegmentationColors();\n        var j: Int64 = 0\n        var pos: Int64 = 0\n        while (j < buffer.size()) {\n            if (this.mViewPortHandler.isNone() || !this.mViewPortHandler().isInBoundsLeft(buffer.buffer[j + 2])) {\n                j += 4\n                continue;\n            }\n            if (this.mViewPortHandler.isNone() || !this.mViewPortHandler().isInBoundsRight(buffer.buffer[j])) {\n                break\n            }\n            if (!isSingleColor) {\n                // Set the color for the currently drawn value. If the index\n                // is out of bounds, reuse colors.\n                this.mRenderPaint.setColor(Color(dataSet.getColor(pos)));\n            }\n            if (isCustomFill) {\n                let fill: Fill = dataSet.getFill(pos);\n                fill.fillRect(c, this.mRenderPaint, buffer.buffer[j], buffer.buffer[j + 1], buffer.buffer[j + 2],\n                    buffer.buffer[j + 3], if (isInverted) {\n                    FillDirection.DOWN\n                } else {\n                    FillDirection.UP\n                });\n            } else {\n                Utils.resetContext2DStyle(c, this.mRenderPaint);\n                let left: Float64 = buffer.buffer[j];\n                let bottom: Float64 = buffer.buffer[j + 1];\n                let right: Float64 = buffer.buffer[j + 2];\n                let top: Float64 = buffer.buffer[j + 3];\n                //绘制数据\n                let radius = (right - left) / 2.0;\n                if (abs(top - bottom) > (right - left)) {\n                    this.drawRoundedRectangles(c, left, top, right, bottom, radius);\n                } else {\n                    this.drawCircle(c, left, top, radius);\n                }\n                let e: WaterfallEntry = dataSet.getEntryForIndex(j / 4)\n                //绘制Y轴刻度范围图\n                for (i in 0..yAxisSegmentList.size) {\n                    let h = yAxisSegmentList[i];\n                    //canvas画布的y轴与图表的y轴方向相反\n                    var maxY = h.getMinY();\n                    var minY = h.getMaxY();\n                    if (maxY > e.getMaxY() || (minY < e.getMaxY() && minY < e.getMinY())) {\n                        continue;\n                    }\n                    maxY = if (maxY <= e.getMinY()) {\n                        e.getMinY()\n                    } else {\n                        maxY\n                    };\n                    minY = if (minY >= e.getMaxY()) {\n                        e.getMaxY()\n                    } else {\n                        minY\n                    };\n                    let yArray = [0.0, minY, 0.0, maxY];\n                    trans?.pointValuesToPixel(yArray)\n                    if (abs(yArray[1] - yArray[3]) > (right - left)) {\n                        c.save();\n                        //c.fillStyle = h.getColor();\n                        this.newMethod(c, left, right, radius, yArray, e, minY, maxY);\n                        c.restore();\n                    } else {\n                        if (h.getMaxY() > e.getMaxY() || h.getMinY() < e.getMinY()) {\n                            continue;\n                        }\n                        c.save();\n                        //c.fillStyle = h.getColor();\n                        if (yArray[3] + 2.0 * radius > bottom) {\n                            this.drawCircle(c, left, bottom - 2.0 * radius, radius);\n                        } else {\n                            this.drawCircle(c, left, yArray[3], radius);\n                        }\n                        c.restore();\n                    }\n                }\n                let highlights = e.getHighlights();\n                let topNum = this.getHighlightTop(e);\n                //绘制标记点\n                for (i in 0..highlights.size) {\n                    let h = highlights[i];\n                    //canvas画布的y轴与图表的y轴方向相反\n                    let maxY = h.getMinY();\n                    let minY = h.getMaxY();\n                    let yArray = [0.0, minY, 0.0, maxY];\n                    trans?.pointValuesToPixel(yArray)\n                    if (abs(yArray[1] - yArray[3]) > (right - left)) {\n                        c.save();\n                        //c.fillStyle = h.getColor();\n                        if (e.getHighlights().size == 1) {\n                            this.drawRoundedRectangles(c, left, yArray[1], right, yArray[3], radius);\n                        } else {\n                            this.drawHighlights(c, left, radius, yArray, i, right, h, topNum);\n                        }\n                        c.restore();\n                    } else {\n                        c.save();\n                        //c.fillStyle = h.getColor();\n                        if (yArray[3] + 2.0 * radius > bottom) {\n                            this.drawCircle(c, left, bottom - 2.0 * radius, radius);\n                        } else {\n                            this.drawCircle(c, left, yArray[3], radius);\n                        }\n                        c.restore();\n                    }\n                }\n            }\n            if (drawBorder) {\n                Utils.resetContext2DStyle(c, this.mBarBorderPaint);\n                c.beginPath();\n                c.rect(buffer.buffer[j], buffer.buffer[j + 1], buffer.buffer[j + 2] - buffer.buffer[j],\n                    buffer.buffer[j + 3] - buffer.buffer[j + 1]);\n                c.stroke();\n                c.closePath();\n            }\n            pos++\n            j += 4\n        }\n        dataSet.setMaxTopHighlightEXIST(false);\n        dataSet.setMinBottomHighlightEXIST(false);\n    }"
]