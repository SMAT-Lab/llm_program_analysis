{
  "type": "file",
  "name": "190.ts",
  "label": "190.ts",
  "start_line": -1,
  "end_line": 242,
  "classes": [
    {
      "type": "class",
      "name": "%dflt",
      "label": "%dflt",
      "start_line": -1,
      "end_line": 242,
      "functions": [
        {
          "type": "function",
          "name": "%dflt",
          "label": "%dflt",
          "start_line": -1,
          "end_line": 242,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/190.ts: %dflt\nlocalRequire = staticinvoke <@%unk/%unk: .createRequire()>(__filename)\nload = undefined\nreturn",
              "start_line": 1,
              "end_line": 242,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": ""
        },
        {
          "type": "function",
          "name": "clone",
          "label": "clone",
          "start_line": 1,
          "end_line": 16,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "obj = parameter0: UnknownKeyword\nthis = this: @ts_files/190.ts: %dflt",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%0 = staticinvoke <@%unk/%unk: .serialize()>(obj)\n%1 = staticinvoke <@%unk/%unk: .deserialize()>(%0)\nreturn %1",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": []
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "block",
              "name": "Block?",
              "label": "%2 = instanceinvoke JSON.<@%unk/%unk: .stringify()>(obj)\n%3 = instanceinvoke JSON.<@%unk/%unk: .parse()>(%2)\n%4 = <unknown>%3\nreturn %4",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "return",
                  "start_line": 18,
                  "end_line": 242,
                  "successors": []
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "function clone(obj: unknown): unknown {\n  try {\n    return deserialize(serialize(obj));\n  } catch {\n    return JSON.parse(JSON.stringify(obj)) as unknown;\n  }\n}"
        },
        {
          "type": "function",
          "name": "findProjectTarget",
          "label": "findProjectTarget",
          "start_line": 1,
          "end_line": 30,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "workspace = parameter0: workspaces.WorkspaceDefinition\nproject = parameter1: string\ntarget = parameter2: string\nthis = this: @ts_files/190.ts: %dflt\n%0 = workspace.<@%unk/%unk: .projects>\nprojectDefinition = instanceinvoke %0.<@%unk/%unk: .get()>(project)\n%1 = !projectDefinition\nif %1 != 0",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%2 = new @%unk/%unk: Error\n%3 = 'Project \"' + project\n%4 = %3 + '\" does not exist.'\ninstanceinvoke %2.<@%unk/%unk: Error.constructor()>(%4)\nthrow %2",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "%5 = projectDefinition.<@%unk/%unk: .targets>\ntargetDefinition = instanceinvoke %5.<@%unk/%unk: .get()>(target)\n%6 = !targetDefinition\nif %6 != 0",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "%7 = new @%unk/%unk: Error\ninstanceinvoke %7.<@%unk/%unk: Error.constructor()>('Project target does not exist.')\nthrow %7",
                          "start_line": 1,
                          "end_line": 1,
                          "successors": [
                            {
                              "type": "block",
                              "name": "Block?",
                              "label": "return targetDefinition",
                              "start_line": 43,
                              "end_line": 59,
                              "successors": []
                            }
                          ]
                        },
                        {
                          "type": "blockRef",
                          "label": "(RepeatedBlock)"
                        }
                      ]
                    }
                  ]
                },
                {
                  "type": "blockRef",
                  "label": "(RepeatedBlock)"
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "function findProjectTarget(\n  workspace: workspaces.WorkspaceDefinition,\n  project: string,\n  target: string,\n): workspaces.TargetDefinition {\n  const projectDefinition = workspace.projects.get(project);\n  if (!projectDefinition) {\n    throw new Error(`Project \"${project}\" does not exist.`);\n  }\n  const targetDefinition = projectDefinition.targets.get(target);\n  if (!targetDefinition) {\n    throw new Error('Project target does not exist.');\n  }\n  return targetDefinition;\n}"
        },
        {
          "type": "function",
          "name": "loadEsmModule",
          "label": "loadEsmModule",
          "start_line": 1,
          "end_line": 215,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "modulePath = parameter0: string|URL\nthis = this: @ts_files/190.ts: %dflt\n%0 = new @%unk/%unk: Function\ninstanceinvoke %0.<@%unk/%unk: Function.constructor()>('modulePath', 'return import(modulePath);')\nload = load ?? <Exclude<unknown,undefined>>%0\n%1 = staticinvoke <@%unk/%unk: .load()>(modulePath)\nreturn %1",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "export function loadEsmModule<T>(modulePath: string | URL): Promise<T> {\n  load ??= new Function('modulePath', `return import(modulePath);`) as Exclude<\n    typeof load,\n    undefined\n  >;\n  return load(modulePath);\n}"
        },
        {
          "type": "function",
          "name": "getBuilder",
          "label": "getBuilder",
          "start_line": 1,
          "end_line": 223,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "builderPath = parameter0: string\nthis = this: @ts_files/190.ts: %dflt\n%0 = instanceinvoke path.<@%unk/%unk: .extname()>(builderPath)\nif %0 == '.mjs'",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%1 = staticinvoke <@%unk/%unk: .pathToFileURL()>(builderPath)\n%2 = staticinvoke <@ts_files/190.ts: %dflt.loadEsmModule(string|URL)>(%1)\n%3 = await %2\n%4 = %3.<@%unk/%unk: .default>\nreturn %4",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": []
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "if %0 == '.cjs'",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "%5 = staticinvoke <@%unk/%unk: .localRequire()>(builderPath)\nreturn %5",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": []
                    },
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "%6 = staticinvoke <@%unk/%unk: .localRequire()>(builderPath)\nreturn %6",
                          "start_line": 1,
                          "end_line": 1,
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "block",
              "name": "Block?",
              "label": "e = caughtexception: unknown\n%7 = <NodeJS.ErrnoException>e\n%8 = %7.<@%unk/%unk: .code>\nif %8 === 'ERR_REQUIRE_ESM'",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%9 = staticinvoke <@%unk/%unk: .pathToFileURL()>(builderPath)\n%10 = staticinvoke <@ts_files/190.ts: %dflt.loadEsmModule(string|URL)>(%9)\n%11 = await %10\n%12 = %11.<@%unk/%unk: .default>\nreturn %12",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "return",
                      "start_line": 18,
                      "end_line": 242,
                      "successors": []
                    }
                  ]
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "throw e",
                  "start_line": 244,
                  "end_line": 244,
                  "successors": [
                    {
                      "type": "blockRef",
                      "label": "(RepeatedBlock)"
                    }
                  ]
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "async function getBuilder(builderPath: string): Promise<any> {\n  switch (path.extname(builderPath)) {\n    case '.mjs':\n      // Load the ESM configuration file using the TypeScript dynamic import workaround.\n      // Once TypeScript provides support for keeping the dynamic import this workaround can be\n      // changed to a direct dynamic import.\n      return (await loadEsmModule<{ default: unknown }>(pathToFileURL(builderPath))).default;\n    case '.cjs':\n      return localRequire(builderPath);\n    default:\n      // The file could be either CommonJS or ESM.\n      // CommonJS is tried first then ESM if loading fails.\n      try {\n        return localRequire(builderPath);\n      } catch (e) {\n        if ((e as NodeJS.ErrnoException).code === 'ERR_REQUIRE_ESM') {\n          // Load the ESM configuration file using the TypeScript dynamic import workaround.\n          // Once TypeScript provides support for keeping the dynamic import this workaround can be\n          // changed to a direct dynamic import.\n          return (await loadEsmModule<{ default: unknown }>(pathToFileURL(builderPath))).default;\n        }\n        throw e;\n      }\n  }\n}"
        }
      ],
      "classes": [],
      "blocks": [],
      "simplified_code": ""
    },
    {
      "type": "class",
      "name": "WorkspaceHost",
      "label": "WorkspaceHost",
      "start_line": 0,
      "end_line": 23,
      "functions": [
        {
          "type": "function",
          "name": "getBuilderName",
          "label": "getBuilderName",
          "start_line": 0,
          "end_line": 0,
          "blocks": [],
          "functions": [],
          "classes": [],
          "simplified_code": "getBuilderName(project: string, target: string): Promise<string>;"
        },
        {
          "type": "function",
          "name": "getMetadata",
          "label": "getMetadata",
          "start_line": 0,
          "end_line": 0,
          "blocks": [],
          "functions": [],
          "classes": [],
          "simplified_code": "getMetadata(project: string): Promise<json.JsonObject>;"
        },
        {
          "type": "function",
          "name": "getOptions",
          "label": "getOptions",
          "start_line": 0,
          "end_line": 0,
          "blocks": [],
          "functions": [],
          "classes": [],
          "simplified_code": "getOptions(project: string, target: string, configuration?: string): Promise<json.JsonObject>;"
        },
        {
          "type": "function",
          "name": "hasTarget",
          "label": "hasTarget",
          "start_line": 0,
          "end_line": 0,
          "blocks": [],
          "functions": [],
          "classes": [],
          "simplified_code": "hasTarget(project: string, target: string): Promise<boolean>;"
        },
        {
          "type": "function",
          "name": "getDefaultConfigurationName",
          "label": "getDefaultConfigurationName",
          "start_line": 0,
          "end_line": 0,
          "blocks": [],
          "functions": [],
          "classes": [],
          "simplified_code": "getDefaultConfigurationName(project: string, target: string): Promise<string | undefined>;"
        }
      ],
      "classes": [],
      "blocks": [],
      "simplified_code": "export interface WorkspaceHost {\n  getBuilderName(project: string, target: string): Promise<string>;\n  getMetadata(project: string): Promise<json.JsonObject>;\n  getOptions(project: string, target: string, configuration?: string): Promise<json.JsonObject>;\n  hasTarget(project: string, target: string): Promise<boolean>;\n  getDefaultConfigurationName(project: string, target: string): Promise<string | undefined>;\n}"
    },
    {
      "type": "class",
      "name": "WorkspaceNodeModulesArchitectHost",
      "label": "WorkspaceNodeModulesArchitectHost",
      "start_line": 1,
      "end_line": 202,
      "functions": [
        {
          "type": "function",
          "name": "constructor",
          "label": "constructor",
          "start_line": 1,
          "end_line": 49,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "instanceinvoke this.<@ts_files/190.ts: WorkspaceNodeModulesArchitectHost.%instInit()>()\nworkspaceOrHost = parameter0: workspaces.WorkspaceDefinition|@ts_files/190.ts: WorkspaceHost\n_root = parameter1: string\nthis = this: @ts_files/190.ts: WorkspaceNodeModulesArchitectHost\nif undefined != 0",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "this.<@ts_files/190.ts: WorkspaceNodeModulesArchitectHost.workspaceHost> = workspaceOrHost",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "return",
                      "start_line": 18,
                      "end_line": 242,
                      "successors": []
                    }
                  ]
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%0 = new @ts_files/190.ts: %AC$WorkspaceNodeModulesArchitectHost$constructor$2\ninstanceinvoke %0.<@ts_files/190.ts: %AC$WorkspaceNodeModulesArchitectHost$constructor$2.constructor()>()\nthis.<@ts_files/190.ts: WorkspaceNodeModulesArchitectHost.workspaceHost> = %0",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "blockRef",
                      "label": "(RepeatedBlock)"
                    }
                  ]
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "constructor(\n    workspaceOrHost: workspaces.WorkspaceDefinition | WorkspaceHost,\n    protected _root: string,\n  ) {\n    if ('getBuilderName' in workspaceOrHost) {\n      this.workspaceHost = workspaceOrHost;\n    } else {\n      this.workspaceHost = {\n        async getBuilderName(project, target) {\n          const targetDefinition = findProjectTarget(workspaceOrHost, project, target);\n          return targetDefinition.builder;\n        },\n        async getOptions(project, target, configuration) {\n          const targetDefinition = findProjectTarget(workspaceOrHost, project, target);\n          if (configuration === undefined) {\n            return (targetDefinition.options ?? {}) as json.JsonObject;\n          }\n          if (!targetDefinition.configurations?.[configuration]) {\n            throw new Error(`Configuration '${configuration}' is not set in the workspace.`);\n          }\n          return (targetDefinition.configurations?.[configuration] ?? {}) as json.JsonObject;\n        },\n        async getMetadata(project) {\n          const projectDefinition = workspaceOrHost.projects.get(project);\n          if (!projectDefinition) {\n            throw new Error(`Project \"${project}\" does not exist.`);\n          }\n          return {\n            root: projectDefinition.root,\n            sourceRoot: projectDefinition.sourceRoot,\n            prefix: projectDefinition.prefix,\n            ...(clone(workspaceOrHost.extensions) as {}),\n            ...(clone(projectDefinition.extensions) as {}),\n          } as unknown as json.JsonObject;\n        },\n        async hasTarget(project, target) {\n          return !!workspaceOrHost.projects.get(project)?.targets.has(target);\n        },\n        async getDefaultConfigurationName(project, target) {\n          return workspaceOrHost.projects.get(project)?.targets.get(target)?.defaultConfiguration;\n        },\n      };\n    }\n  }"
        },
        {
          "type": "function",
          "name": "getBuilderNameForTarget",
          "label": "getBuilderNameForTarget",
          "start_line": 1,
          "end_line": 93,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "target = parameter0: Target\nthis = this: @ts_files/190.ts: WorkspaceNodeModulesArchitectHost\n%0 = target.<@%unk/%unk: .project>\n%1 = target.<@%unk/%unk: .target>\n%2 = this.<@ts_files/190.ts: WorkspaceNodeModulesArchitectHost.workspaceHost>\n%3 = instanceinvoke %2.<@ts_files/190.ts: WorkspaceHost.getBuilderName(string, string)>(%0, %1)\nreturn %3",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "async getBuilderNameForTarget(target: Target) {\n    return this.workspaceHost.getBuilderName(target.project, target.target);\n  }"
        },
        {
          "type": "function",
          "name": "resolveBuilder",
          "label": "resolveBuilder",
          "start_line": 1,
          "end_line": 96,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "builderStr = parameter0: string\nbasePath = parameter1: unknown\nseenBuilders = parameter2: Set<string>\nthis = this: @ts_files/190.ts: WorkspaceNodeModulesArchitectHost\n%0 = instanceinvoke seenBuilders.<@%unk/%unk: .has()>(builderStr)\nif %0 != 0",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%1 = new @%unk/%unk: Error\n%2 = newarray (unknown|string)[2]\n%2[0] = ...seenBuilders\n%2[1] = builderStr\n%3 = 'Circular builder alias references detected: ' + %2\ninstanceinvoke %1.<@%unk/%unk: Error.constructor()>(%3)\nthrow %1",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "%4 = instanceinvoke builderStr.<@%unk/%unk: .split()>(':', 2)\npackageName = %4[0]\nbuilderName = %4[1]\n%5 = !builderName\nif %5 != 0",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "%6 = new @%unk/%unk: Error\ninstanceinvoke %6.<@%unk/%unk: Error.constructor()>('No builder name specified.')\nthrow %6",
                          "start_line": 1,
                          "end_line": 1,
                          "successors": [
                            {
                              "type": "block",
                              "name": "Block?",
                              "label": "%7 = packageName + '/package.json'\n%8 = new @ts_files/190.ts: %AC$WorkspaceNodeModulesArchitectHost$resolveBuilder$6\ninstanceinvoke %8.<@ts_files/190.ts: %AC$WorkspaceNodeModulesArchitectHost$resolveBuilder$6.constructor()>()\npackageJsonPath = instanceinvoke localRequire.<@%unk/%unk: .resolve()>(%7, %8)\n%9 = staticinvoke <@%unk/%unk: .readFileSync()>(packageJsonPath, 'utf-8')\n%10 = instanceinvoke JSON.<@%unk/%unk: .parse()>(%9)\npackageJson = <@ts_files/190.ts: %AC$7>%10\nbuildersManifestRawPath = packageJson.<@ts_files/190.ts: %AC$7.builders'>\n%11 = !buildersManifestRawPath\nif %11 != 0",
                              "start_line": 1,
                              "end_line": 1,
                              "successors": [
                                {
                                  "type": "block",
                                  "name": "Block?",
                                  "label": "%12 = new @%unk/%unk: Error\n%13 = instanceinvoke JSON.<@%unk/%unk: .stringify()>(packageName)\n%14 = 'Package ' + %13\n%15 = %14 + ' has no builders defined.'\ninstanceinvoke %12.<@%unk/%unk: Error.constructor()>(%15)\nthrow %12",
                                  "start_line": 1,
                                  "end_line": 1,
                                  "successors": [
                                    {
                                      "type": "block",
                                      "name": "Block?",
                                      "label": "buildersManifestPath = instanceinvoke path.<@%unk/%unk: .normalize()>(buildersManifestRawPath)\n%16 = instanceinvoke path.<@%unk/%unk: .isAbsolute()>(buildersManifestRawPath)\n%17 = instanceinvoke buildersManifestRawPath.<@%unk/%unk: .startsWith()>('..')\n%18 = %16 || %17\nif %18 != false",
                                      "start_line": 1,
                                      "end_line": 1,
                                      "successors": [
                                        {
                                          "type": "block",
                                          "name": "Block?",
                                          "label": "%19 = new @%unk/%unk: Error\n%20 = 'Package \"' + packageName\n%21 = %20 + '\" has an invalid builders manifest path: \"'\n%22 = %21 + buildersManifestRawPath\n%23 = %22 + '\"'\ninstanceinvoke %19.<@%unk/%unk: Error.constructor()>(%23)\nthrow %19",
                                          "start_line": 1,
                                          "end_line": 1,
                                          "successors": [
                                            {
                                              "type": "block",
                                              "name": "Block?",
                                              "label": "%24 = instanceinvoke path.<@%unk/%unk: .dirname()>(packageJsonPath)\nbuildersManifestPath = instanceinvoke path.<@%unk/%unk: .join()>(%24, buildersManifestPath)\n%25 = staticinvoke <@%unk/%unk: .readFileSync()>(buildersManifestPath, 'utf-8')\n%26 = instanceinvoke JSON.<@%unk/%unk: .parse()>(%25)\nbuildersManifest = <BuilderSchema>%26\nbuildersManifestDirectory = instanceinvoke path.<@%unk/%unk: .dirname()>(buildersManifestPath)\n%27 = buildersManifest.<@%unk/%unk: .builders>\nbuilder = %27.<@%unk/%unk: .builderName>\n%28 = !builder\nif %28 != 0",
                                              "start_line": 1,
                                              "end_line": 1,
                                              "successors": [
                                                {
                                                  "type": "block",
                                                  "name": "Block?",
                                                  "label": "%29 = new @%unk/%unk: Error\n%30 = instanceinvoke JSON.<@%unk/%unk: .stringify()>(builderStr)\n%31 = 'Cannot find builder ' + %30\n%32 = %31 + '.'\ninstanceinvoke %29.<@%unk/%unk: Error.constructor()>(%32)\nthrow %29",
                                                  "start_line": 1,
                                                  "end_line": 1,
                                                  "successors": [
                                                    {
                                                      "type": "block",
                                                      "name": "Block?",
                                                      "label": "if typeof builder === 'string'",
                                                      "start_line": 1,
                                                      "end_line": 1,
                                                      "successors": [
                                                        {
                                                          "type": "block",
                                                          "name": "Block?",
                                                          "label": "%33 = instanceinvoke path.<@%unk/%unk: .dirname()>(packageJsonPath)\n%34 = new @%unk/%unk: Set\ninstanceinvoke %34.<@%unk/%unk: Set.constructor()>()\n%35 = seenBuilders ?? %34\n%36 = instanceinvoke %35.<@%unk/%unk: .add()>(builderStr)\n%37 = instanceinvoke this.<@ts_files/190.ts: WorkspaceNodeModulesArchitectHost.resolveBuilder(string, unknown, Set<string>)>(builder, %33, %36)\nreturn %37",
                                                          "start_line": 1,
                                                          "end_line": 1,
                                                          "successors": []
                                                        },
                                                        {
                                                          "type": "block",
                                                          "name": "Block?",
                                                          "label": "%38 = builder.<@%unk/%unk: .implementation>\n%39 = builder.<@%unk/%unk: .implementation>\n%40 = instanceinvoke path.<@%unk/%unk: .normalize()>(%39)\nimplementationPath = %38 && %40\n%41 = !implementationPath\nif %41 != false",
                                                          "start_line": 1,
                                                          "end_line": 1,
                                                          "successors": [
                                                            {
                                                              "type": "block",
                                                              "name": "Block?",
                                                              "label": "%42 = new @%unk/%unk: Error\n%43 = 'Could not find the implementation for builder ' + builderStr\ninstanceinvoke %42.<@%unk/%unk: Error.constructor()>(%43)\nthrow %42",
                                                              "start_line": 1,
                                                              "end_line": 1,
                                                              "successors": [
                                                                {
                                                                  "type": "block",
                                                                  "name": "Block?",
                                                                  "label": "%44 = instanceinvoke path.<@%unk/%unk: .isAbsolute()>(implementationPath)\n%45 = instanceinvoke implementationPath.<@%unk/%unk: .startsWith()>('..')\n%46 = %44 || %45\nif %46 != false",
                                                                  "start_line": 1,
                                                                  "end_line": 1,
                                                                  "successors": [
                                                                    {
                                                                      "type": "block",
                                                                      "name": "Block?",
                                                                      "label": "%47 = new @%unk/%unk: Error\n%48 = builder.<@%unk/%unk: .implementation>\n%49 = 'Package \"' + packageName\n%50 = %49 + '\" has an invalid builder implementation path: \"'\n%51 = %50 + builderName\n%52 = %51 + '\" --> \"'\n%53 = %52 + %48\n%54 = %53 + '\"'\ninstanceinvoke %47.<@%unk/%unk: Error.constructor()>(%54)\nthrow %47",
                                                                      "start_line": 1,
                                                                      "end_line": 1,
                                                                      "successors": [
                                                                        {
                                                                          "type": "block",
                                                                          "name": "Block?",
                                                                          "label": "%55 = builder.<@%unk/%unk: .schema>\n%56 = builder.<@%unk/%unk: .schema>\n%57 = instanceinvoke path.<@%unk/%unk: .normalize()>(%56)\nschemaPath = %55 && %57\n%58 = !schemaPath\nif %58 != false",
                                                                          "start_line": 1,
                                                                          "end_line": 1,
                                                                          "successors": [
                                                                            {
                                                                              "type": "block",
                                                                              "name": "Block?",
                                                                              "label": "%59 = new @%unk/%unk: Error\n%60 = 'Could not find the schema for builder ' + builderStr\ninstanceinvoke %59.<@%unk/%unk: Error.constructor()>(%60)\nthrow %59",
                                                                              "start_line": 1,
                                                                              "end_line": 1,
                                                                              "successors": [
                                                                                {
                                                                                  "type": "block",
                                                                                  "name": "Block?",
                                                                                  "label": "%61 = instanceinvoke path.<@%unk/%unk: .isAbsolute()>(schemaPath)\n%62 = instanceinvoke schemaPath.<@%unk/%unk: .startsWith()>('..')\n%63 = %61 || %62\nif %63 != false",
                                                                                  "start_line": 1,
                                                                                  "end_line": 1,
                                                                                  "successors": [
                                                                                    {
                                                                                      "type": "block",
                                                                                      "name": "Block?",
                                                                                      "label": "%64 = new @%unk/%unk: Error\n%65 = builder.<@%unk/%unk: .schema>\n%66 = 'Package \"' + packageName\n%67 = %66 + '\" has an invalid builder implementation path: \"'\n%68 = %67 + builderName\n%69 = %68 + '\" --> \"'\n%70 = %69 + %65\n%71 = %70 + '\"'\ninstanceinvoke %64.<@%unk/%unk: Error.constructor()>(%71)\nthrow %64",
                                                                                      "start_line": 1,
                                                                                      "end_line": 1,
                                                                                      "successors": [
                                                                                        {
                                                                                          "type": "block",
                                                                                          "name": "Block?",
                                                                                          "label": "%72 = instanceinvoke path.<@%unk/%unk: .join()>(buildersManifestDirectory, schemaPath)\nschemaText = staticinvoke <@%unk/%unk: .readFileSync()>(%72, 'utf-8')\n%73 = new @ts_files/190.ts: %AC$WorkspaceNodeModulesArchitectHost$resolveBuilder$8\ninstanceinvoke %73.<@ts_files/190.ts: %AC$WorkspaceNodeModulesArchitectHost$resolveBuilder$8.constructor()>()\n%74 = instanceinvoke Promise.<@%unk/%unk: .resolve()>(%73)\nreturn %74",
                                                                                          "start_line": 1,
                                                                                          "end_line": 1,
                                                                                          "successors": []
                                                                                        }
                                                                                      ]
                                                                                    },
                                                                                    {
                                                                                      "type": "blockRef",
                                                                                      "label": "(RepeatedBlock)"
                                                                                    }
                                                                                  ]
                                                                                }
                                                                              ]
                                                                            },
                                                                            {
                                                                              "type": "blockRef",
                                                                              "label": "(RepeatedBlock)"
                                                                            }
                                                                          ]
                                                                        }
                                                                      ]
                                                                    },
                                                                    {
                                                                      "type": "blockRef",
                                                                      "label": "(RepeatedBlock)"
                                                                    }
                                                                  ]
                                                                }
                                                              ]
                                                            },
                                                            {
                                                              "type": "blockRef",
                                                              "label": "(RepeatedBlock)"
                                                            }
                                                          ]
                                                        }
                                                      ]
                                                    }
                                                  ]
                                                },
                                                {
                                                  "type": "blockRef",
                                                  "label": "(RepeatedBlock)"
                                                }
                                              ]
                                            }
                                          ]
                                        },
                                        {
                                          "type": "blockRef",
                                          "label": "(RepeatedBlock)"
                                        }
                                      ]
                                    }
                                  ]
                                },
                                {
                                  "type": "blockRef",
                                  "label": "(RepeatedBlock)"
                                }
                              ]
                            }
                          ]
                        },
                        {
                          "type": "blockRef",
                          "label": "(RepeatedBlock)"
                        }
                      ]
                    }
                  ]
                },
                {
                  "type": "blockRef",
                  "label": "(RepeatedBlock)"
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "resolveBuilder(\n    builderStr: string,\n    basePath = this._root,\n    seenBuilders?: Set<string>,\n  ): Promise<NodeModulesBuilderInfo> {\n    if (seenBuilders?.has(builderStr)) {\n      throw new Error(\n        'Circular builder alias references detected: ' + [...seenBuilders, builderStr],\n      );\n    }\n    const [packageName, builderName] = builderStr.split(':', 2);\n    if (!builderName) {\n      throw new Error('No builder name specified.');\n    }\n    // Resolve and load the builders manifest from the package's `builders` field, if present\n    const packageJsonPath = localRequire.resolve(packageName + '/package.json', {\n      paths: [basePath],\n    });\n    const packageJson = JSON.parse(readFileSync(packageJsonPath, 'utf-8')) as { builders?: string };\n    const buildersManifestRawPath = packageJson['builders'];\n    if (!buildersManifestRawPath) {\n      throw new Error(`Package ${JSON.stringify(packageName)} has no builders defined.`);\n    }\n    let buildersManifestPath = path.normalize(buildersManifestRawPath);\n    if (path.isAbsolute(buildersManifestRawPath) || buildersManifestRawPath.startsWith('..')) {\n      throw new Error(\n        `Package \"${packageName}\" has an invalid builders manifest path: \"${buildersManifestRawPath}\"`,\n      );\n    }\n    buildersManifestPath = path.join(path.dirname(packageJsonPath), buildersManifestPath);\n    const buildersManifest = JSON.parse(\n      readFileSync(buildersManifestPath, 'utf-8'),\n    ) as BuilderSchema;\n    const buildersManifestDirectory = path.dirname(buildersManifestPath);\n    // Attempt to locate an entry for the specified builder by name\n    const builder = buildersManifest.builders?.[builderName];\n    if (!builder) {\n      throw new Error(`Cannot find builder ${JSON.stringify(builderStr)}.`);\n    }\n    // Resolve alias reference if entry is a string\n    if (typeof builder === 'string') {\n      return this.resolveBuilder(\n        builder,\n        path.dirname(packageJsonPath),\n        (seenBuilders ?? new Set()).add(builderStr),\n      );\n    }\n    // Determine builder implementation path (relative within package only)\n    const implementationPath = builder.implementation && path.normalize(builder.implementation);\n    if (!implementationPath) {\n      throw new Error('Could not find the implementation for builder ' + builderStr);\n    }\n    if (path.isAbsolute(implementationPath) || implementationPath.startsWith('..')) {\n      throw new Error(\n        `Package \"${packageName}\" has an invalid builder implementation path: \"${builderName}\" --> \"${builder.implementation}\"`,\n      );\n    }\n    // Determine builder option schema path (relative within package only)\n    const schemaPath = builder.schema && path.normalize(builder.schema);\n    if (!schemaPath) {\n      throw new Error('Could not find the schema for builder ' + builderStr);\n    }\n    if (path.isAbsolute(schemaPath) || schemaPath.startsWith('..')) {\n      throw new Error(\n        `Package \"${packageName}\" has an invalid builder implementation path: \"${builderName}\" --> \"${builder.schema}\"`,\n      );\n    }\n    const schemaText = readFileSync(path.join(buildersManifestDirectory, schemaPath), 'utf-8');\n    return Promise.resolve({\n      name: builderStr,\n      builderName,\n      description: builder['description'],\n      optionSchema: JSON.parse(schemaText) as json.schema.JsonSchema,\n      import: path.join(buildersManifestDirectory, implementationPath),\n    });\n  }"
        },
        {
          "type": "function",
          "name": "getCurrentDirectory",
          "label": "getCurrentDirectory",
          "start_line": 1,
          "end_line": 172,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/190.ts: WorkspaceNodeModulesArchitectHost\n%0 = instanceinvoke process.<@%unk/%unk: .cwd()>()\nreturn %0",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "async getCurrentDirectory() {\n    return process.cwd();\n  }"
        },
        {
          "type": "function",
          "name": "getWorkspaceRoot",
          "label": "getWorkspaceRoot",
          "start_line": 1,
          "end_line": 175,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/190.ts: WorkspaceNodeModulesArchitectHost\n%0 = this.<@ts_files/190.ts: WorkspaceNodeModulesArchitectHost._root>\nreturn %0",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "async getWorkspaceRoot() {\n    return this._root;\n  }"
        },
        {
          "type": "function",
          "name": "getOptionsForTarget",
          "label": "getOptionsForTarget",
          "start_line": 1,
          "end_line": 178,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "target = parameter0: Target\nthis = this: @ts_files/190.ts: WorkspaceNodeModulesArchitectHost\n%0 = target.<@%unk/%unk: .project>\n%1 = target.<@%unk/%unk: .target>\n%2 = this.<@ts_files/190.ts: WorkspaceNodeModulesArchitectHost.workspaceHost>\n%3 = instanceinvoke %2.<@ts_files/190.ts: WorkspaceHost.hasTarget(string, string)>(%0, %1)\n%4 = !await %3\nif %4 != 0",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "return null",
                  "start_line": 180,
                  "end_line": 180,
                  "successors": []
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%5 = target.<@%unk/%unk: .project>\n%6 = target.<@%unk/%unk: .target>\n%7 = this.<@ts_files/190.ts: WorkspaceNodeModulesArchitectHost.workspaceHost>\n%8 = instanceinvoke %7.<@ts_files/190.ts: WorkspaceHost.getOptions(string, string, string)>(%5, %6)\noptions = await %8\n%9 = target.<@%unk/%unk: .configuration>\n%10 = target.<@%unk/%unk: .project>\n%11 = target.<@%unk/%unk: .target>\n%12 = this.<@ts_files/190.ts: WorkspaceNodeModulesArchitectHost.workspaceHost>\n%13 = instanceinvoke %12.<@ts_files/190.ts: WorkspaceHost.getDefaultConfigurationName(string, string)>(%10, %11)\ntargetConfiguration = %9 || await %13\nif targetConfiguration != false",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "%14 = instanceinvoke targetConfiguration.<@%unk/%unk: .split()>(',')\nconfigurations = instanceinvoke %14.<@%unk/%unk: .map()>(%AM0$getOptionsForTarget)\n%15 = instanceinvoke configurations.<@%unk/%unk: .iterator()>()",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "%16 = instanceinvoke %15.<@%unk/%unk: .next()>()\n%17 = %16.<@ES2015/BuiltinClass: IteratorResult.done>\nif %17 == true",
                          "start_line": 1,
                          "end_line": 1,
                          "successors": [
                            {
                              "type": "block",
                              "name": "Block?",
                              "label": "%18 = %16.<@ES2015/BuiltinClass: IteratorResult.value>\nconfiguration = <string>%18\n%19 = new @ts_files/190.ts: %AC$WorkspaceNodeModulesArchitectHost$getOptionsForTarget$9\ninstanceinvoke %19.<@ts_files/190.ts: %AC$WorkspaceNodeModulesArchitectHost$getOptionsForTarget$9.constructor()>()\noptions = %19",
                              "start_line": 1,
                              "end_line": 1,
                              "successors": [
                                {
                                  "type": "blockRef",
                                  "label": "(RepeatedBlock)"
                                }
                              ]
                            },
                            {
                              "type": "block",
                              "name": "Block?",
                              "label": "%20 = staticinvoke <@ts_files/190.ts: %dflt.clone(UnknownKeyword)>(options)\n%21 = <json.JsonObject>%20\nreturn %21",
                              "start_line": 1,
                              "end_line": 1,
                              "successors": []
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "type": "blockRef",
                      "label": "(RepeatedBlock)"
                    }
                  ]
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "async getOptionsForTarget(target: Target): Promise<json.JsonObject | null> {\n    if (!(await this.workspaceHost.hasTarget(target.project, target.target))) {\n      return null;\n    }\n    let options = await this.workspaceHost.getOptions(target.project, target.target);\n    const targetConfiguration =\n      target.configuration ||\n      (await this.workspaceHost.getDefaultConfigurationName(target.project, target.target));\n    if (targetConfiguration) {\n      const configurations = targetConfiguration.split(',').map((c) => c.trim());\n      for (const configuration of configurations) {\n        options = {\n          ...options,\n          ...(await this.workspaceHost.getOptions(target.project, target.target, configuration)),\n        };\n      }\n    }\n    return clone(options) as json.JsonObject;\n  }"
        },
        {
          "type": "function",
          "name": "getProjectMetadata",
          "label": "getProjectMetadata",
          "start_line": 1,
          "end_line": 197,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "target = parameter0: Target|string\nthis = this: @ts_files/190.ts: WorkspaceNodeModulesArchitectHost\nif typeof target === 'string'",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "projectName = target",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "%1 = this.<@ts_files/190.ts: WorkspaceNodeModulesArchitectHost.workspaceHost>\nmetadata = instanceinvoke %1.<@ts_files/190.ts: WorkspaceHost.getMetadata(string)>(projectName)\nreturn metadata",
                      "start_line": 1,
                      "end_line": 200,
                      "successors": []
                    }
                  ]
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "projectName = target.<@%unk/%unk: .project>",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "blockRef",
                      "label": "(RepeatedBlock)"
                    }
                  ]
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "async getProjectMetadata(target: Target | string): Promise<json.JsonObject | null> {\n    const projectName = typeof target === 'string' ? target : target.project;\n    const metadata = this.workspaceHost.getMetadata(projectName);\n    return metadata;\n  }"
        },
        {
          "type": "function",
          "name": "loadBuilder",
          "label": "loadBuilder",
          "start_line": 1,
          "end_line": 202,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "info = parameter0: NodeModulesBuilderInfo\nthis = this: @ts_files/190.ts: WorkspaceNodeModulesArchitectHost\n%0 = info.<@%unk/%unk: .import>\n%1 = staticinvoke <@ts_files/190.ts: %dflt.getBuilder(string)>(%0)\nbuilder = await %1\n%2 = builder.<@%unk/%unk: .BuilderSymbol>\nif %2 != 0",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "return builder",
                  "start_line": 205,
                  "end_line": 209,
                  "successors": []
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%3 = builder.<@%unk/%unk: .default>\n%4 = %3.<@%unk/%unk: .BuilderSymbol>\nif %4 != 0",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "%5 = builder.<@%unk/%unk: .default>\nreturn %5",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": []
                    },
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "%6 = new @%unk/%unk: Error\ninstanceinvoke %6.<@%unk/%unk: Error.constructor()>('Builder is not a builder')\nthrow %6\nreturn",
                      "start_line": 1,
                      "end_line": 242,
                      "successors": []
                    }
                  ]
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "async loadBuilder(info: NodeModulesBuilderInfo): Promise<Builder> {\n    const builder = await getBuilder(info.import);\n    if (builder[BuilderSymbol]) {\n      return builder;\n    }\n    // Default handling code is for old builders that incorrectly export `default` with non-ESM module\n    if (builder?.default[BuilderSymbol]) {\n      return builder.default;\n    }\n    throw new Error('Builder is not a builder');\n  }"
        },
        {
          "type": "function",
          "name": "%AM0$getOptionsForTarget",
          "label": "%AM0$getOptionsForTarget",
          "start_line": 1,
          "end_line": 187,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "c = parameter0: unknown\nthis = this: @ts_files/190.ts: WorkspaceNodeModulesArchitectHost\n%0 = instanceinvoke c.<@%unk/%unk: .trim()>()\nreturn %0",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "(c) => c.trim()"
        }
      ],
      "classes": [],
      "blocks": [],
      "simplified_code": "export class WorkspaceNodeModulesArchitectHost implements ArchitectHost<NodeModulesBuilderInfo> {\n  private workspaceHost: WorkspaceHost;\n  constructor(workspaceHost: WorkspaceHost, _root: string);\n  constructor(workspace: workspaces.WorkspaceDefinition, _root: string);\n  constructor(\n    workspaceOrHost: workspaces.WorkspaceDefinition | WorkspaceHost,\n    protected _root: string,\n  ) {\n    if ('getBuilderName' in workspaceOrHost) {\n      this.workspaceHost = workspaceOrHost;\n    } else {\n      this.workspaceHost = {\n        async getBuilderName(project, target) {\n          const targetDefinition = findProjectTarget(workspaceOrHost, project, target);\n          return targetDefinition.builder;\n        },\n        async getOptions(project, target, configuration) {\n          const targetDefinition = findProjectTarget(workspaceOrHost, project, target);\n          if (configuration === undefined) {\n            return (targetDefinition.options ?? {}) as json.JsonObject;\n          }\n          if (!targetDefinition.configurations?.[configuration]) {\n            throw new Error(`Configuration '${configuration}' is not set in the workspace.`);\n          }\n          return (targetDefinition.configurations?.[configuration] ?? {}) as json.JsonObject;\n        },\n        async getMetadata(project) {\n          const projectDefinition = workspaceOrHost.projects.get(project);\n          if (!projectDefinition) {\n            throw new Error(`Project \"${project}\" does not exist.`);\n          }\n          return {\n            root: projectDefinition.root,\n            sourceRoot: projectDefinition.sourceRoot,\n            prefix: projectDefinition.prefix,\n            ...(clone(workspaceOrHost.extensions) as {}),\n            ...(clone(projectDefinition.extensions) as {}),\n          } as unknown as json.JsonObject;\n        },\n        async hasTarget(project, target) {\n          return !!workspaceOrHost.projects.get(project)?.targets.has(target);\n        },\n        async getDefaultConfigurationName(project, target) {\n          return workspaceOrHost.projects.get(project)?.targets.get(target)?.defaultConfiguration;\n        },\n      };\n    }\n  }\n  async getBuilderNameForTarget(target: Target) {\n    return this.workspaceHost.getBuilderName(target.project, target.target);\n  }\n  resolveBuilder(\n    builderStr: string,\n    basePath = this._root,\n    seenBuilders?: Set<string>,\n  ): Promise<NodeModulesBuilderInfo> {\n    if (seenBuilders?.has(builderStr)) {\n      throw new Error(\n        'Circular builder alias references detected: ' + [...seenBuilders, builderStr],\n      );\n    }\n    const [packageName, builderName] = builderStr.split(':', 2);\n    if (!builderName) {\n      throw new Error('No builder name specified.');\n    }\n    // Resolve and load the builders manifest from the package's `builders` field, if present\n    const packageJsonPath = localRequire.resolve(packageName + '/package.json', {\n      paths: [basePath],\n    });\n    const packageJson = JSON.parse(readFileSync(packageJsonPath, 'utf-8')) as { builders?: string };\n    const buildersManifestRawPath = packageJson['builders'];\n    if (!buildersManifestRawPath) {\n      throw new Error(`Package ${JSON.stringify(packageName)} has no builders defined.`);\n    }\n    let buildersManifestPath = path.normalize(buildersManifestRawPath);\n    if (path.isAbsolute(buildersManifestRawPath) || buildersManifestRawPath.startsWith('..')) {\n      throw new Error(\n        `Package \"${packageName}\" has an invalid builders manifest path: \"${buildersManifestRawPath}\"`,\n      );\n    }\n    buildersManifestPath = path.join(path.dirname(packageJsonPath), buildersManifestPath);\n    const buildersManifest = JSON.parse(\n      readFileSync(buildersManifestPath, 'utf-8'),\n    ) as BuilderSchema;\n    const buildersManifestDirectory = path.dirname(buildersManifestPath);\n    // Attempt to locate an entry for the specified builder by name\n    const builder = buildersManifest.builders?.[builderName];\n    if (!builder) {\n      throw new Error(`Cannot find builder ${JSON.stringify(builderStr)}.`);\n    }\n    // Resolve alias reference if entry is a string\n    if (typeof builder === 'string') {\n      return this.resolveBuilder(\n        builder,\n        path.dirname(packageJsonPath),\n        (seenBuilders ?? new Set()).add(builderStr),\n      );\n    }\n    // Determine builder implementation path (relative within package only)\n    const implementationPath = builder.implementation && path.normalize(builder.implementation);\n    if (!implementationPath) {\n      throw new Error('Could not find the implementation for builder ' + builderStr);\n    }\n    if (path.isAbsolute(implementationPath) || implementationPath.startsWith('..')) {\n      throw new Error(\n        `Package \"${packageName}\" has an invalid builder implementation path: \"${builderName}\" --> \"${builder.implementation}\"`,\n      );\n    }\n    // Determine builder option schema path (relative within package only)\n    const schemaPath = builder.schema && path.normalize(builder.schema);\n    if (!schemaPath) {\n      throw new Error('Could not find the schema for builder ' + builderStr);\n    }\n    if (path.isAbsolute(schemaPath) || schemaPath.startsWith('..')) {\n      throw new Error(\n        `Package \"${packageName}\" has an invalid builder implementation path: \"${builderName}\" --> \"${builder.schema}\"`,\n      );\n    }\n    const schemaText = readFileSync(path.join(buildersManifestDirectory, schemaPath), 'utf-8');\n    return Promise.resolve({\n      name: builderStr,\n      builderName,\n      description: builder['description'],\n      optionSchema: JSON.parse(schemaText) as json.schema.JsonSchema,\n      import: path.join(buildersManifestDirectory, implementationPath),\n    });\n  }\n  async getCurrentDirectory() {\n    return process.cwd();\n  }\n  async getWorkspaceRoot() {\n    return this._root;\n  }\n  async getOptionsForTarget(target: Target): Promise<json.JsonObject | null> {\n    if (!(await this.workspaceHost.hasTarget(target.project, target.target))) {\n      return null;\n    }\n    let options = await this.workspaceHost.getOptions(target.project, target.target);\n    const targetConfiguration =\n      target.configuration ||\n      (await this.workspaceHost.getDefaultConfigurationName(target.project, target.target));\n    if (targetConfiguration) {\n      const configurations = targetConfiguration.split(',').map((c) => c.trim());\n      for (const configuration of configurations) {\n        options = {\n          ...options,\n          ...(await this.workspaceHost.getOptions(target.project, target.target, configuration)),\n        };\n      }\n    }\n    return clone(options) as json.JsonObject;\n  }\n  async getProjectMetadata(target: Target | string): Promise<json.JsonObject | null> {\n    const projectName = typeof target === 'string' ? target : target.project;\n    const metadata = this.workspaceHost.getMetadata(projectName);\n    return metadata;\n  }\n  async loadBuilder(info: NodeModulesBuilderInfo): Promise<Builder> {\n    const builder = await getBuilder(info.import);\n    if (builder[BuilderSymbol]) {\n      return builder;\n    }\n    // Default handling code is for old builders that incorrectly export `default` with non-ESM module\n    if (builder?.default[BuilderSymbol]) {\n      return builder.default;\n    }\n    throw new Error('Builder is not a builder');\n  }\n}"
    },
    {
      "type": "class",
      "name": "%AC$0",
      "label": "%AC$0",
      "start_line": 229,
      "end_line": 229,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{ default: unknown }"
    },
    {
      "type": "class",
      "name": "%AC$1",
      "label": "%AC$1",
      "start_line": 242,
      "end_line": 242,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{ default: unknown }"
    },
    {
      "type": "class",
      "name": "%AC$%AC$WorkspaceNodeModulesArchitectHost$constructor$2$getOptions$3",
      "label": "%AC$%AC$WorkspaceNodeModulesArchitectHost$constructor$2$getOptions$3",
      "start_line": 64,
      "end_line": 64,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{}"
    },
    {
      "type": "class",
      "name": "%AC$%AC$WorkspaceNodeModulesArchitectHost$constructor$2$getOptions$4",
      "label": "%AC$%AC$WorkspaceNodeModulesArchitectHost$constructor$2$getOptions$4",
      "start_line": 69,
      "end_line": 69,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{}"
    },
    {
      "type": "class",
      "name": "%AC$%AC$WorkspaceNodeModulesArchitectHost$constructor$2$getMetadata$5",
      "label": "%AC$%AC$WorkspaceNodeModulesArchitectHost$constructor$2$getMetadata$5",
      "start_line": 76,
      "end_line": 76,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n            root: projectDefinition.root,\n            sourceRoot: projectDefinition.sourceRoot,\n            prefix: projectDefinition.prefix,\n            ...(clone(workspaceOrHost.extensions) as {}),\n            ...(clone(projectDefinition.extensions) as {}),\n          }"
    },
    {
      "type": "class",
      "name": "%AC$WorkspaceNodeModulesArchitectHost$constructor$2",
      "label": "%AC$WorkspaceNodeModulesArchitectHost$constructor$2",
      "start_line": 1,
      "end_line": 87,
      "functions": [
        {
          "type": "function",
          "name": "getBuilderName",
          "label": "getBuilderName",
          "start_line": 1,
          "end_line": 57,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "project = parameter0: unknown\ntarget = parameter1: unknown\nthis = this: @ts_files/190.ts: WorkspaceNodeModulesArchitectHost\ntargetDefinition = staticinvoke <@ts_files/190.ts: %dflt.findProjectTarget(workspaces.WorkspaceDefinition, string, string)>(workspaceOrHost, project, target)\n%0 = targetDefinition.<@%unk/%unk: .builder>\nreturn %0",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "async getBuilderName(project, target) {\n          const targetDefinition = findProjectTarget(workspaceOrHost, project, target);\n          return targetDefinition.builder;\n        }"
        },
        {
          "type": "function",
          "name": "getOptions",
          "label": "getOptions",
          "start_line": 1,
          "end_line": 61,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "project = parameter0: unknown\ntarget = parameter1: unknown\nconfiguration = parameter2: unknown\nthis = this: @ts_files/190.ts: WorkspaceNodeModulesArchitectHost\ntargetDefinition = staticinvoke <@ts_files/190.ts: %dflt.findProjectTarget(workspaces.WorkspaceDefinition, string, string)>(workspaceOrHost, project, target)\nif configuration === undefined",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%0 = targetDefinition.<@%unk/%unk: .options>\n%1 = new @ts_files/190.ts: %AC$%AC$WorkspaceNodeModulesArchitectHost$constructor$2$getOptions$3\ninstanceinvoke %1.<@ts_files/190.ts: %AC$%AC$WorkspaceNodeModulesArchitectHost$constructor$2$getOptions$3.constructor()>()\n%2 = %0 ?? %1\n%3 = <@ts_files/190.ts: %AC$%AC$WorkspaceNodeModulesArchitectHost$constructor$2$getOptions$3>%2\nreturn %3",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": []
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%4 = targetDefinition.<@%unk/%unk: .configurations>\n%5 = %4.<@%unk/%unk: .configuration>\n%6 = !%5\nif %6 != 0",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "%7 = new @%unk/%unk: Error\n%8 = 'Configuration '' + configuration\n%9 = %8 + '' is not set in the workspace.'\ninstanceinvoke %7.<@%unk/%unk: Error.constructor()>(%9)\nthrow %7",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "%10 = targetDefinition.<@%unk/%unk: .configurations>\n%11 = %10.<@%unk/%unk: .configuration>\n%12 = new @ts_files/190.ts: %AC$%AC$WorkspaceNodeModulesArchitectHost$constructor$2$getOptions$4\ninstanceinvoke %12.<@ts_files/190.ts: %AC$%AC$WorkspaceNodeModulesArchitectHost$constructor$2$getOptions$4.constructor()>()\n%13 = %11 ?? %12\n%14 = <@ts_files/190.ts: %AC$%AC$WorkspaceNodeModulesArchitectHost$constructor$2$getOptions$4>%13\nreturn %14",
                          "start_line": 1,
                          "end_line": 1,
                          "successors": []
                        }
                      ]
                    },
                    {
                      "type": "blockRef",
                      "label": "(RepeatedBlock)"
                    }
                  ]
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "async getOptions(project, target, configuration) {\n          const targetDefinition = findProjectTarget(workspaceOrHost, project, target);\n          if (configuration === undefined) {\n            return (targetDefinition.options ?? {}) as json.JsonObject;\n          }\n          if (!targetDefinition.configurations?.[configuration]) {\n            throw new Error(`Configuration '${configuration}' is not set in the workspace.`);\n          }\n          return (targetDefinition.configurations?.[configuration] ?? {}) as json.JsonObject;\n        }"
        },
        {
          "type": "function",
          "name": "getMetadata",
          "label": "getMetadata",
          "start_line": 1,
          "end_line": 71,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "project = parameter0: unknown\nthis = this: @ts_files/190.ts: WorkspaceNodeModulesArchitectHost\n%0 = workspaceOrHost.<@%unk/%unk: .projects>\nprojectDefinition = instanceinvoke %0.<@%unk/%unk: .get()>(project)\n%1 = !projectDefinition\nif %1 != 0",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%2 = new @%unk/%unk: Error\n%3 = 'Project \"' + project\n%4 = %3 + '\" does not exist.'\ninstanceinvoke %2.<@%unk/%unk: Error.constructor()>(%4)\nthrow %2",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "%5 = new @ts_files/190.ts: %AC$%AC$WorkspaceNodeModulesArchitectHost$constructor$2$getMetadata$5\ninstanceinvoke %5.<@ts_files/190.ts: %AC$%AC$WorkspaceNodeModulesArchitectHost$constructor$2$getMetadata$5.constructor()>()\n%6 = <@ts_files/190.ts: %AC$%AC$WorkspaceNodeModulesArchitectHost$constructor$2$getMetadata$5>%5\n%7 = <@ts_files/190.ts: %AC$%AC$WorkspaceNodeModulesArchitectHost$constructor$2$getMetadata$5>%6\nreturn %7",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": []
                    }
                  ]
                },
                {
                  "type": "blockRef",
                  "label": "(RepeatedBlock)"
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "async getMetadata(project) {\n          const projectDefinition = workspaceOrHost.projects.get(project);\n          if (!projectDefinition) {\n            throw new Error(`Project \"${project}\" does not exist.`);\n          }\n          return {\n            root: projectDefinition.root,\n            sourceRoot: projectDefinition.sourceRoot,\n            prefix: projectDefinition.prefix,\n            ...(clone(workspaceOrHost.extensions) as {}),\n            ...(clone(projectDefinition.extensions) as {}),\n          } as unknown as json.JsonObject;\n        }"
        },
        {
          "type": "function",
          "name": "hasTarget",
          "label": "hasTarget",
          "start_line": 1,
          "end_line": 84,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "project = parameter0: unknown\ntarget = parameter1: unknown\nthis = this: @ts_files/190.ts: WorkspaceNodeModulesArchitectHost\n%0 = workspaceOrHost.<@%unk/%unk: .projects>\n%1 = instanceinvoke %0.<@%unk/%unk: .get()>(project)\n%2 = %1.<@%unk/%unk: .targets>\n%3 = instanceinvoke %2.<@%unk/%unk: .has()>(target)\n%4 = !%3\n%5 = !%4\nreturn %5",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "async hasTarget(project, target) {\n          return !!workspaceOrHost.projects.get(project)?.targets.has(target);\n        }"
        },
        {
          "type": "function",
          "name": "getDefaultConfigurationName",
          "label": "getDefaultConfigurationName",
          "start_line": 1,
          "end_line": 87,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "project = parameter0: unknown\ntarget = parameter1: unknown\nthis = this: @ts_files/190.ts: WorkspaceNodeModulesArchitectHost\n%0 = workspaceOrHost.<@%unk/%unk: .projects>\n%1 = instanceinvoke %0.<@%unk/%unk: .get()>(project)\n%2 = %1.<@%unk/%unk: .targets>\n%3 = instanceinvoke %2.<@%unk/%unk: .get()>(target)\n%4 = %3.<@%unk/%unk: .defaultConfiguration>\nreturn %4",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "async getDefaultConfigurationName(project, target) {\n          return workspaceOrHost.projects.get(project)?.targets.get(target)?.defaultConfiguration;\n        }"
        }
      ],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n        async getBuilderName(project, target) {\n          const targetDefinition = findProjectTarget(workspaceOrHost, project, target);\n          return targetDefinition.builder;\n        },\n        async getOptions(project, target, configuration) {\n          const targetDefinition = findProjectTarget(workspaceOrHost, project, target);\n          if (configuration === undefined) {\n            return (targetDefinition.options ?? {}) as json.JsonObject;\n          }\n          if (!targetDefinition.configurations?.[configuration]) {\n            throw new Error(`Configuration '${configuration}' is not set in the workspace.`);\n          }\n          return (targetDefinition.configurations?.[configuration] ?? {}) as json.JsonObject;\n        },\n        async getMetadata(project) {\n          const projectDefinition = workspaceOrHost.projects.get(project);\n          if (!projectDefinition) {\n            throw new Error(`Project \"${project}\" does not exist.`);\n          }\n          return {\n            root: projectDefinition.root,\n            sourceRoot: projectDefinition.sourceRoot,\n            prefix: projectDefinition.prefix,\n            ...(clone(workspaceOrHost.extensions) as {}),\n            ...(clone(projectDefinition.extensions) as {}),\n          } as unknown as json.JsonObject;\n        },\n        async hasTarget(project, target) {\n          return !!workspaceOrHost.projects.get(project)?.targets.has(target);\n        },\n        async getDefaultConfigurationName(project, target) {\n          return workspaceOrHost.projects.get(project)?.targets.get(target)?.defaultConfiguration;\n        },\n      }"
    },
    {
      "type": "class",
      "name": "%AC$WorkspaceNodeModulesArchitectHost$resolveBuilder$6",
      "label": "%AC$WorkspaceNodeModulesArchitectHost$resolveBuilder$6",
      "start_line": 111,
      "end_line": 111,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n      paths: [basePath],\n    }"
    },
    {
      "type": "class",
      "name": "%AC$7",
      "label": "%AC$7",
      "start_line": 114,
      "end_line": 114,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{ builders?: string }"
    },
    {
      "type": "class",
      "name": "%AC$WorkspaceNodeModulesArchitectHost$resolveBuilder$8",
      "label": "%AC$WorkspaceNodeModulesArchitectHost$resolveBuilder$8",
      "start_line": 164,
      "end_line": 164,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n      name: builderStr,\n      builderName,\n      description: builder['description'],\n      optionSchema: JSON.parse(schemaText) as json.schema.JsonSchema,\n      import: path.join(buildersManifestDirectory, implementationPath),\n    }"
    },
    {
      "type": "class",
      "name": "%AC$WorkspaceNodeModulesArchitectHost$getOptionsForTarget$9",
      "label": "%AC$WorkspaceNodeModulesArchitectHost$getOptionsForTarget$9",
      "start_line": 189,
      "end_line": 189,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n          ...options,\n          ...(await this.workspaceHost.getOptions(target.project, target.target, configuration)),\n        }"
    }
  ],
  "functions": [],
  "blocks": [],
  "simplified_code": "import { json, workspaces } from '@angular-devkit/core';\nimport { readFileSync } from 'node:fs';\nimport { createRequire } from 'node:module';\nimport * as path from 'node:path';\nimport { pathToFileURL } from 'node:url';\nimport { deserialize, serialize } from 'node:v8';\nimport { BuilderInfo } from '../src';\nimport { Schema as BuilderSchema } from '../src/builders-schema';\nimport { Target } from '../src/input-schema';\nimport { ArchitectHost, Builder, BuilderSymbol } from '../src/internal';\n// TODO_ESM: Update to use import.meta.url\nconst localRequire = createRequire(__filename);\nexport type NodeModulesBuilderInfo = BuilderInfo & {\n  import: string;\n};\nfunction clone(obj: unknown): unknown {\n  try {\n    return deserialize(serialize(obj));\n  } catch {\n    return JSON.parse(JSON.stringify(obj)) as unknown;\n  }\n}\nexport interface WorkspaceHost {\n  getBuilderName(project: string, target: string): Promise<string>;\n  getMetadata(project: string): Promise<json.JsonObject>;\n  getOptions(project: string, target: string, configuration?: string): Promise<json.JsonObject>;\n  hasTarget(project: string, target: string): Promise<boolean>;\n  getDefaultConfigurationName(project: string, target: string): Promise<string | undefined>;\n}\nfunction findProjectTarget(\n  workspace: workspaces.WorkspaceDefinition,\n  project: string,\n  target: string,\n): workspaces.TargetDefinition {\n  const projectDefinition = workspace.projects.get(project);\n  if (!projectDefinition) {\n    throw new Error(`Project \"${project}\" does not exist.`);\n  }\n  const targetDefinition = projectDefinition.targets.get(target);\n  if (!targetDefinition) {\n    throw new Error('Project target does not exist.');\n  }\n  return targetDefinition;\n}\nexport class WorkspaceNodeModulesArchitectHost implements ArchitectHost<NodeModulesBuilderInfo> {\n  private workspaceHost: WorkspaceHost;\n  constructor(workspaceHost: WorkspaceHost, _root: string);\n  constructor(workspace: workspaces.WorkspaceDefinition, _root: string);\n  constructor(\n    workspaceOrHost: workspaces.WorkspaceDefinition | WorkspaceHost,\n    protected _root: string,\n  ) {\n    if ('getBuilderName' in workspaceOrHost) {\n      this.workspaceHost = workspaceOrHost;\n    } else {\n      this.workspaceHost = {\n        async getBuilderName(project, target) {\n          const targetDefinition = findProjectTarget(workspaceOrHost, project, target);\n          return targetDefinition.builder;\n        },\n        async getOptions(project, target, configuration) {\n          const targetDefinition = findProjectTarget(workspaceOrHost, project, target);\n          if (configuration === undefined) {\n            return (targetDefinition.options ?? {}) as json.JsonObject;\n          }\n          if (!targetDefinition.configurations?.[configuration]) {\n            throw new Error(`Configuration '${configuration}' is not set in the workspace.`);\n          }\n          return (targetDefinition.configurations?.[configuration] ?? {}) as json.JsonObject;\n        },\n        async getMetadata(project) {\n          const projectDefinition = workspaceOrHost.projects.get(project);\n          if (!projectDefinition) {\n            throw new Error(`Project \"${project}\" does not exist.`);\n          }\n          return {\n            root: projectDefinition.root,\n            sourceRoot: projectDefinition.sourceRoot,\n            prefix: projectDefinition.prefix,\n            ...(clone(workspaceOrHost.extensions) as {}),\n            ...(clone(projectDefinition.extensions) as {}),\n          } as unknown as json.JsonObject;\n        },\n        async hasTarget(project, target) {\n          return !!workspaceOrHost.projects.get(project)?.targets.has(target);\n        },\n        async getDefaultConfigurationName(project, target) {\n          return workspaceOrHost.projects.get(project)?.targets.get(target)?.defaultConfiguration;\n        },\n      };\n    }\n  }\n  async getBuilderNameForTarget(target: Target) {\n    return this.workspaceHost.getBuilderName(target.project, target.target);\n  }\n  resolveBuilder(\n    builderStr: string,\n    basePath = this._root,\n    seenBuilders?: Set<string>,\n  ): Promise<NodeModulesBuilderInfo> {\n    if (seenBuilders?.has(builderStr)) {\n      throw new Error(\n        'Circular builder alias references detected: ' + [...seenBuilders, builderStr],\n      );\n    }\n    const [packageName, builderName] = builderStr.split(':', 2);\n    if (!builderName) {\n      throw new Error('No builder name specified.');\n    }\n    // Resolve and load the builders manifest from the package's `builders` field, if present\n    const packageJsonPath = localRequire.resolve(packageName + '/package.json', {\n      paths: [basePath],\n    });\n    const packageJson = JSON.parse(readFileSync(packageJsonPath, 'utf-8')) as { builders?: string };\n    const buildersManifestRawPath = packageJson['builders'];\n    if (!buildersManifestRawPath) {\n      throw new Error(`Package ${JSON.stringify(packageName)} has no builders defined.`);\n    }\n    let buildersManifestPath = path.normalize(buildersManifestRawPath);\n    if (path.isAbsolute(buildersManifestRawPath) || buildersManifestRawPath.startsWith('..')) {\n      throw new Error(\n        `Package \"${packageName}\" has an invalid builders manifest path: \"${buildersManifestRawPath}\"`,\n      );\n    }\n    buildersManifestPath = path.join(path.dirname(packageJsonPath), buildersManifestPath);\n    const buildersManifest = JSON.parse(\n      readFileSync(buildersManifestPath, 'utf-8'),\n    ) as BuilderSchema;\n    const buildersManifestDirectory = path.dirname(buildersManifestPath);\n    // Attempt to locate an entry for the specified builder by name\n    const builder = buildersManifest.builders?.[builderName];\n    if (!builder) {\n      throw new Error(`Cannot find builder ${JSON.stringify(builderStr)}.`);\n    }\n    // Resolve alias reference if entry is a string\n    if (typeof builder === 'string') {\n      return this.resolveBuilder(\n        builder,\n        path.dirname(packageJsonPath),\n        (seenBuilders ?? new Set()).add(builderStr),\n      );\n    }\n    // Determine builder implementation path (relative within package only)\n    const implementationPath = builder.implementation && path.normalize(builder.implementation);\n    if (!implementationPath) {\n      throw new Error('Could not find the implementation for builder ' + builderStr);\n    }\n    if (path.isAbsolute(implementationPath) || implementationPath.startsWith('..')) {\n      throw new Error(\n        `Package \"${packageName}\" has an invalid builder implementation path: \"${builderName}\" --> \"${builder.implementation}\"`,\n      );\n    }\n    // Determine builder option schema path (relative within package only)\n    const schemaPath = builder.schema && path.normalize(builder.schema);\n    if (!schemaPath) {\n      throw new Error('Could not find the schema for builder ' + builderStr);\n    }\n    if (path.isAbsolute(schemaPath) || schemaPath.startsWith('..')) {\n      throw new Error(\n        `Package \"${packageName}\" has an invalid builder implementation path: \"${builderName}\" --> \"${builder.schema}\"`,\n      );\n    }\n    const schemaText = readFileSync(path.join(buildersManifestDirectory, schemaPath), 'utf-8');\n    return Promise.resolve({\n      name: builderStr,\n      builderName,\n      description: builder['description'],\n      optionSchema: JSON.parse(schemaText) as json.schema.JsonSchema,\n      import: path.join(buildersManifestDirectory, implementationPath),\n    });\n  }\n  async getCurrentDirectory() {\n    return process.cwd();\n  }\n  async getWorkspaceRoot() {\n    return this._root;\n  }\n  async getOptionsForTarget(target: Target): Promise<json.JsonObject | null> {\n    if (!(await this.workspaceHost.hasTarget(target.project, target.target))) {\n      return null;\n    }\n    let options = await this.workspaceHost.getOptions(target.project, target.target);\n    const targetConfiguration =\n      target.configuration ||\n      (await this.workspaceHost.getDefaultConfigurationName(target.project, target.target));\n    if (targetConfiguration) {\n      const configurations = targetConfiguration.split(',').map((c) => c.trim());\n      for (const configuration of configurations) {\n        options = {\n          ...options,\n          ...(await this.workspaceHost.getOptions(target.project, target.target, configuration)),\n        };\n      }\n    }\n    return clone(options) as json.JsonObject;\n  }\n  async getProjectMetadata(target: Target | string): Promise<json.JsonObject | null> {\n    const projectName = typeof target === 'string' ? target : target.project;\n    const metadata = this.workspaceHost.getMetadata(projectName);\n    return metadata;\n  }\n  async loadBuilder(info: NodeModulesBuilderInfo): Promise<Builder> {\n    const builder = await getBuilder(info.import);\n    if (builder[BuilderSymbol]) {\n      return builder;\n    }\n    // Default handling code is for old builders that incorrectly export `default` with non-ESM module\n    if (builder?.default[BuilderSymbol]) {\n      return builder.default;\n    }\n    throw new Error('Builder is not a builder');\n  }\n}\nlet load: (<T>(modulePath: string | URL) => Promise<T>) | undefined;\nexport function loadEsmModule<T>(modulePath: string | URL): Promise<T> {\n  load ??= new Function('modulePath', `return import(modulePath);`) as Exclude<\n    typeof load,\n    undefined\n  >;\n  return load(modulePath);\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nasync function getBuilder(builderPath: string): Promise<any> {\n  switch (path.extname(builderPath)) {\n    case '.mjs':\n      // Load the ESM configuration file using the TypeScript dynamic import workaround.\n      // Once TypeScript provides support for keeping the dynamic import this workaround can be\n      // changed to a direct dynamic import.\n      return (await loadEsmModule<{ default: unknown }>(pathToFileURL(builderPath))).default;\n    case '.cjs':\n      return localRequire(builderPath);\n    default:\n      // The file could be either CommonJS or ESM.\n      // CommonJS is tried first then ESM if loading fails.\n      try {\n        return localRequire(builderPath);\n      } catch (e) {\n        if ((e as NodeJS.ErrnoException).code === 'ERR_REQUIRE_ESM') {\n          // Load the ESM configuration file using the TypeScript dynamic import workaround.\n          // Once TypeScript provides support for keeping the dynamic import this workaround can be\n          // changed to a direct dynamic import.\n          return (await loadEsmModule<{ default: unknown }>(pathToFileURL(builderPath))).default;\n        }\n        throw e;\n      }\n  }\n}"
}