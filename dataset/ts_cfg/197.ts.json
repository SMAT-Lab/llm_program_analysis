{
  "type": "file",
  "name": "197.ts",
  "label": "197.ts",
  "start_line": -1,
  "end_line": 798,
  "classes": [
    {
      "type": "class",
      "name": "%dflt",
      "label": "%dflt",
      "start_line": -1,
      "end_line": 798,
      "functions": [
        {
          "type": "function",
          "name": "%dflt",
          "label": "%dflt",
          "start_line": -1,
          "end_line": 684,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\nstaticinvoke <@%unk/%unk: .describe()>('view insertion', %AM0)\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": ""
        },
        {
          "type": "function",
          "name": "%AM2$%AM1$%AM0",
          "label": "%AM2$%AM1$%AM0",
          "start_line": 1,
          "end_line": 684,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\n_counter = 0\n%0 = new @ts_files/197.ts: %AC$%dflt$%AM2$%AM1$%AM0$0\ninstanceinvoke %0.<@ts_files/197.ts: %AC$%dflt$%AM2$%AM1$%AM0$0.constructor()>()\ninstanceinvoke TestBed.<@%unk/%unk: .configureTestingModule()>(%0)\nfixture = instanceinvoke TestBed.<@%unk/%unk: .createComponent()>(App)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\napp = fixture.<@%unk/%unk: .componentInstance>\n%1 = app.<@%unk/%unk: .view0>\n%2 = app.<@%unk/%unk: .container>\n%3 = instanceinvoke %2.<@%unk/%unk: .indexOf()>(%1)\n%4 = staticinvoke <@%unk/%unk: .expect()>(%3)\ninstanceinvoke %4.<@%unk/%unk: .toBe()>(0)\n%5 = app.<@%unk/%unk: .view1>\n%6 = app.<@%unk/%unk: .container>\n%7 = instanceinvoke %6.<@%unk/%unk: .indexOf()>(%5)\n%8 = staticinvoke <@%unk/%unk: .expect()>(%7)\ninstanceinvoke %8.<@%unk/%unk: .toBe()>(1)\n%9 = app.<@%unk/%unk: .view2>\n%10 = app.<@%unk/%unk: .container>\n%11 = instanceinvoke %10.<@%unk/%unk: .indexOf()>(%9)\n%12 = staticinvoke <@%unk/%unk: .expect()>(%11)\ninstanceinvoke %12.<@%unk/%unk: .toBe()>(2)\n%13 = app.<@%unk/%unk: .view3>\n%14 = app.<@%unk/%unk: .container>\n%15 = instanceinvoke %14.<@%unk/%unk: .indexOf()>(%13)\n%16 = staticinvoke <@%unk/%unk: .expect()>(%15)\ninstanceinvoke %16.<@%unk/%unk: .toBe()>(3)\n%17 = fixture.<@%unk/%unk: .nativeElement>\n%18 = %17.<@%unk/%unk: .textContent>\n%19 = staticinvoke <@%unk/%unk: .expect()>(%18)\ninstanceinvoke %19.<@%unk/%unk: .toBe()>('created1created0created3created2')\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      let _counter = 0;\n      @Component({\n        selector: 'increment-comp',\n        template: `<span>created{{counter}}</span>`,\n        standalone: false,\n      })\n      class IncrementComp {\n        counter = _counter++;\n      }\n      @Component({\n        template: `\n              <ng-template #simple><increment-comp></increment-comp></ng-template>\n              <div #container></div>\n            `,\n        standalone: false,\n      })\n      class App {\n        @ViewChild('container', {read: ViewContainerRef, static: true})\n        container: ViewContainerRef = null!;\n        @ViewChild('simple', {read: TemplateRef, static: true}) simple: TemplateRef<any> = null!;\n        view0: EmbeddedViewRef<any> = null!;\n        view1: EmbeddedViewRef<any> = null!;\n        view2: EmbeddedViewRef<any> = null!;\n        view3: EmbeddedViewRef<any> = null!;\n        constructor(public changeDetector: ChangeDetectorRef) {}\n        ngAfterViewInit() {\n          // insert at the front\n          this.view1 = this.container.createEmbeddedView(this.simple); // \"created0\"\n          // insert at the front again\n          this.view0 = this.container.createEmbeddedView(this.simple, {}, 0); // \"created1\"\n          // insert at the end\n          this.view3 = this.container.createEmbeddedView(this.simple); // \"created2\"\n          // insert in the middle\n          this.view2 = this.container.createEmbeddedView(this.simple, {}, 2); // \"created3\"\n          // We need to run change detection here to avoid\n          // ExpressionChangedAfterItHasBeenCheckedError because of the value updating in\n          // increment-comp\n          this.changeDetector.detectChanges();\n        }\n      }\n      TestBed.configureTestingModule({\n        declarations: [App, IncrementComp],\n      });\n      const fixture = TestBed.createComponent(App);\n      fixture.detectChanges();\n      const app = fixture.componentInstance;\n      expect(app.container.indexOf(app.view0)).toBe(0);\n      expect(app.container.indexOf(app.view1)).toBe(1);\n      expect(app.container.indexOf(app.view2)).toBe(2);\n      expect(app.container.indexOf(app.view3)).toBe(3);\n      // The text in each component differs based on *when* it was created.\n      expect(fixture.nativeElement.textContent).toBe('created1created0created3created2');\n    }"
        },
        {
          "type": "function",
          "name": "%AM1$%AM0",
          "label": "%AM1$%AM0",
          "start_line": 1,
          "end_line": 684,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\nstaticinvoke <@%unk/%unk: .it()>('should insert into an empty container, at the front, in the middle, and at the end', %AM2$%AM1$%AM0)\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n    it('should insert into an empty container, at the front, in the middle, and at the end', () => {\n      let _counter = 0;\n      @Component({\n        selector: 'increment-comp',\n        template: `<span>created{{counter}}</span>`,\n        standalone: false,\n      })\n      class IncrementComp {\n        counter = _counter++;\n      }\n      @Component({\n        template: `\n              <ng-template #simple><increment-comp></increment-comp></ng-template>\n              <div #container></div>\n            `,\n        standalone: false,\n      })\n      class App {\n        @ViewChild('container', {read: ViewContainerRef, static: true})\n        container: ViewContainerRef = null!;\n        @ViewChild('simple', {read: TemplateRef, static: true}) simple: TemplateRef<any> = null!;\n        view0: EmbeddedViewRef<any> = null!;\n        view1: EmbeddedViewRef<any> = null!;\n        view2: EmbeddedViewRef<any> = null!;\n        view3: EmbeddedViewRef<any> = null!;\n        constructor(public changeDetector: ChangeDetectorRef) {}\n        ngAfterViewInit() {\n          // insert at the front\n          this.view1 = this.container.createEmbeddedView(this.simple); // \"created0\"\n          // insert at the front again\n          this.view0 = this.container.createEmbeddedView(this.simple, {}, 0); // \"created1\"\n          // insert at the end\n          this.view3 = this.container.createEmbeddedView(this.simple); // \"created2\"\n          // insert in the middle\n          this.view2 = this.container.createEmbeddedView(this.simple, {}, 2); // \"created3\"\n          // We need to run change detection here to avoid\n          // ExpressionChangedAfterItHasBeenCheckedError because of the value updating in\n          // increment-comp\n          this.changeDetector.detectChanges();\n        }\n      }\n      TestBed.configureTestingModule({\n        declarations: [App, IncrementComp],\n      });\n      const fixture = TestBed.createComponent(App);\n      fixture.detectChanges();\n      const app = fixture.componentInstance;\n      expect(app.container.indexOf(app.view0)).toBe(0);\n      expect(app.container.indexOf(app.view1)).toBe(1);\n      expect(app.container.indexOf(app.view2)).toBe(2);\n      expect(app.container.indexOf(app.view3)).toBe(3);\n      // The text in each component differs based on *when* it was created.\n      expect(fixture.nativeElement.textContent).toBe('created1created0created3created2');\n    });\n  }"
        },
        {
          "type": "function",
          "name": "%AM4$%AM3$%AM0",
          "label": "%AM4$%AM3$%AM0",
          "start_line": 1,
          "end_line": 684,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\n%0 = new @ts_files/197.ts: %AC$%dflt$%AM4$%AM3$%AM0$1\ninstanceinvoke %0.<@ts_files/197.ts: %AC$%dflt$%AM4$%AM3$%AM0$1.constructor()>()\ninstanceinvoke TestBed.<@%unk/%unk: .configureTestingModule()>(%0)\nfixture = instanceinvoke TestBed.<@%unk/%unk: .createComponent()>(App)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\napp = fixture.<@%unk/%unk: .componentInstance>\n%1 = app.<@%unk/%unk: .view0>\n%2 = app.<@%unk/%unk: .container>\n%3 = instanceinvoke %2.<@%unk/%unk: .indexOf()>(%1)\n%4 = staticinvoke <@%unk/%unk: .expect()>(%3)\ninstanceinvoke %4.<@%unk/%unk: .toBe()>(0)\n%5 = app.<@%unk/%unk: .view1>\n%6 = app.<@%unk/%unk: .container>\n%7 = instanceinvoke %6.<@%unk/%unk: .indexOf()>(%5)\n%8 = staticinvoke <@%unk/%unk: .expect()>(%7)\ninstanceinvoke %8.<@%unk/%unk: .toBe()>(1)\n%9 = app.<@%unk/%unk: .view2>\n%10 = app.<@%unk/%unk: .container>\n%11 = instanceinvoke %10.<@%unk/%unk: .indexOf()>(%9)\n%12 = staticinvoke <@%unk/%unk: .expect()>(%11)\ninstanceinvoke %12.<@%unk/%unk: .toBe()>(2)\n%13 = app.<@%unk/%unk: .view3>\n%14 = app.<@%unk/%unk: .container>\n%15 = instanceinvoke %14.<@%unk/%unk: .indexOf()>(%13)\n%16 = staticinvoke <@%unk/%unk: .expect()>(%15)\ninstanceinvoke %16.<@%unk/%unk: .toBe()>(3)\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      @Component({\n        template: `\n              <ng-template #empty></ng-template>\n              <div #container></div>\n            `,\n        standalone: false,\n      })\n      class App {\n        @ViewChild('container', {read: ViewContainerRef}) container: ViewContainerRef = null!;\n        @ViewChild('empty', {read: TemplateRef}) empty: TemplateRef<any> = null!;\n        view0: EmbeddedViewRef<any> = null!;\n        view1: EmbeddedViewRef<any> = null!;\n        view2: EmbeddedViewRef<any> = null!;\n        view3: EmbeddedViewRef<any> = null!;\n        ngAfterViewInit() {\n          // insert at the front\n          this.view1 = this.container.createEmbeddedView(this.empty);\n          // insert at the front again\n          this.view0 = this.container.createEmbeddedView(this.empty, {}, 0);\n          // insert at the end\n          this.view3 = this.container.createEmbeddedView(this.empty);\n          // insert in the middle\n          this.view2 = this.container.createEmbeddedView(this.empty, {}, 2);\n        }\n      }\n      TestBed.configureTestingModule({\n        declarations: [App],\n      });\n      const fixture = TestBed.createComponent(App);\n      fixture.detectChanges();\n      const app = fixture.componentInstance;\n      expect(app.container.indexOf(app.view0)).toBe(0);\n      expect(app.container.indexOf(app.view1)).toBe(1);\n      expect(app.container.indexOf(app.view2)).toBe(2);\n      expect(app.container.indexOf(app.view3)).toBe(3);\n    }"
        },
        {
          "type": "function",
          "name": "%AM3$%AM0",
          "label": "%AM3$%AM0",
          "start_line": 1,
          "end_line": 684,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\nstaticinvoke <@%unk/%unk: .it()>('should insert into an empty container, at the front, in the middle, and at the end', %AM4$%AM3$%AM0)\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n    it('should insert into an empty container, at the front, in the middle, and at the end', () => {\n      @Component({\n        template: `\n              <ng-template #empty></ng-template>\n              <div #container></div>\n            `,\n        standalone: false,\n      })\n      class App {\n        @ViewChild('container', {read: ViewContainerRef}) container: ViewContainerRef = null!;\n        @ViewChild('empty', {read: TemplateRef}) empty: TemplateRef<any> = null!;\n        view0: EmbeddedViewRef<any> = null!;\n        view1: EmbeddedViewRef<any> = null!;\n        view2: EmbeddedViewRef<any> = null!;\n        view3: EmbeddedViewRef<any> = null!;\n        ngAfterViewInit() {\n          // insert at the front\n          this.view1 = this.container.createEmbeddedView(this.empty);\n          // insert at the front again\n          this.view0 = this.container.createEmbeddedView(this.empty, {}, 0);\n          // insert at the end\n          this.view3 = this.container.createEmbeddedView(this.empty);\n          // insert in the middle\n          this.view2 = this.container.createEmbeddedView(this.empty, {}, 2);\n        }\n      }\n      TestBed.configureTestingModule({\n        declarations: [App],\n      });\n      const fixture = TestBed.createComponent(App);\n      fixture.detectChanges();\n      const app = fixture.componentInstance;\n      expect(app.container.indexOf(app.view0)).toBe(0);\n      expect(app.container.indexOf(app.view1)).toBe(1);\n      expect(app.container.indexOf(app.view2)).toBe(2);\n      expect(app.container.indexOf(app.view3)).toBe(3);\n    });\n  }"
        },
        {
          "type": "function",
          "name": "%AM6$%AM5$%AM0",
          "label": "%AM6$%AM5$%AM0",
          "start_line": 1,
          "end_line": 684,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\n%0 = new @ts_files/197.ts: %AC$%dflt$%AM6$%AM5$%AM0$2\ninstanceinvoke %0.<@ts_files/197.ts: %AC$%dflt$%AM6$%AM5$%AM0$2.constructor()>()\ninstanceinvoke TestBed.<@%unk/%unk: .configureTestingModule()>(%0)\nfixture = instanceinvoke TestBed.<@%unk/%unk: .createComponent()>(App)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%1 = instanceinvoke By.<@%unk/%unk: .directive()>(Comp)\n%2 = fixture.<@%unk/%unk: .debugElement>\n%3 = instanceinvoke %2.<@%unk/%unk: .query()>(%1)\n%4 = %3.<@%unk/%unk: .injector>\ncomp = instanceinvoke %4.<@%unk/%unk: .get()>(Comp)\n%5 = comp.<@%unk/%unk: .view0>\n%6 = comp.<@%unk/%unk: .container>\n%7 = instanceinvoke %6.<@%unk/%unk: .indexOf()>(%5)\n%8 = staticinvoke <@%unk/%unk: .expect()>(%7)\ninstanceinvoke %8.<@%unk/%unk: .toBe()>(0)\n%9 = comp.<@%unk/%unk: .view1>\n%10 = comp.<@%unk/%unk: .container>\n%11 = instanceinvoke %10.<@%unk/%unk: .indexOf()>(%9)\n%12 = staticinvoke <@%unk/%unk: .expect()>(%11)\ninstanceinvoke %12.<@%unk/%unk: .toBe()>(1)\n%13 = comp.<@%unk/%unk: .view2>\n%14 = comp.<@%unk/%unk: .container>\n%15 = instanceinvoke %14.<@%unk/%unk: .indexOf()>(%13)\n%16 = staticinvoke <@%unk/%unk: .expect()>(%15)\ninstanceinvoke %16.<@%unk/%unk: .toBe()>(2)\n%17 = comp.<@%unk/%unk: .view3>\n%18 = comp.<@%unk/%unk: .container>\n%19 = instanceinvoke %18.<@%unk/%unk: .indexOf()>(%17)\n%20 = staticinvoke <@%unk/%unk: .expect()>(%19)\ninstanceinvoke %20.<@%unk/%unk: .toBe()>(3)\n%21 = fixture.<@%unk/%unk: .nativeElement>\n%22 = %21.<@%unk/%unk: .textContent>\n%23 = staticinvoke <@%unk/%unk: .expect()>(%22)\ninstanceinvoke %23.<@%unk/%unk: .toBe()>('test')\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      @Component({\n        selector: 'comp',\n        template: `\n                  <ng-template #projection><ng-content></ng-content></ng-template>\n                  <div #container></div>\n                `,\n        standalone: false,\n      })\n      class Comp {\n        @ViewChild('container', {read: ViewContainerRef}) container: ViewContainerRef = null!;\n        @ViewChild('projection', {read: TemplateRef}) projection: TemplateRef<any> = null!;\n        view0: EmbeddedViewRef<any> = null!;\n        view1: EmbeddedViewRef<any> = null!;\n        view2: EmbeddedViewRef<any> = null!;\n        view3: EmbeddedViewRef<any> = null!;\n        ngAfterViewInit() {\n          // insert at the front\n          this.view1 = this.container.createEmbeddedView(this.projection);\n          // insert at the front again\n          this.view0 = this.container.createEmbeddedView(this.projection, {}, 0);\n          // insert at the end\n          this.view3 = this.container.createEmbeddedView(this.projection);\n          // insert in the middle\n          this.view2 = this.container.createEmbeddedView(this.projection, {}, 2);\n        }\n      }\n      @Component({\n        template: `\n          <comp>test</comp>\n        `,\n        standalone: false,\n      })\n      class App {}\n      TestBed.configureTestingModule({\n        declarations: [App, Comp],\n      });\n      const fixture = TestBed.createComponent(App);\n      fixture.detectChanges();\n      const comp = fixture.debugElement.query(By.directive(Comp)).injector.get(Comp);\n      expect(comp.container.indexOf(comp.view0)).toBe(0);\n      expect(comp.container.indexOf(comp.view1)).toBe(1);\n      expect(comp.container.indexOf(comp.view2)).toBe(2);\n      expect(comp.container.indexOf(comp.view3)).toBe(3);\n      // Both ViewEngine and Ivy only honor one of the inserted ng-content components, even though\n      // all are inserted.\n      expect(fixture.nativeElement.textContent).toBe('test');\n    }"
        },
        {
          "type": "function",
          "name": "%AM5$%AM0",
          "label": "%AM5$%AM0",
          "start_line": 1,
          "end_line": 684,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\nstaticinvoke <@%unk/%unk: .it()>('should insert into an empty container, at the front, in the middle, and at the end', %AM6$%AM5$%AM0)\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n    it('should insert into an empty container, at the front, in the middle, and at the end', () => {\n      @Component({\n        selector: 'comp',\n        template: `\n                  <ng-template #projection><ng-content></ng-content></ng-template>\n                  <div #container></div>\n                `,\n        standalone: false,\n      })\n      class Comp {\n        @ViewChild('container', {read: ViewContainerRef}) container: ViewContainerRef = null!;\n        @ViewChild('projection', {read: TemplateRef}) projection: TemplateRef<any> = null!;\n        view0: EmbeddedViewRef<any> = null!;\n        view1: EmbeddedViewRef<any> = null!;\n        view2: EmbeddedViewRef<any> = null!;\n        view3: EmbeddedViewRef<any> = null!;\n        ngAfterViewInit() {\n          // insert at the front\n          this.view1 = this.container.createEmbeddedView(this.projection);\n          // insert at the front again\n          this.view0 = this.container.createEmbeddedView(this.projection, {}, 0);\n          // insert at the end\n          this.view3 = this.container.createEmbeddedView(this.projection);\n          // insert in the middle\n          this.view2 = this.container.createEmbeddedView(this.projection, {}, 2);\n        }\n      }\n      @Component({\n        template: `\n          <comp>test</comp>\n        `,\n        standalone: false,\n      })\n      class App {}\n      TestBed.configureTestingModule({\n        declarations: [App, Comp],\n      });\n      const fixture = TestBed.createComponent(App);\n      fixture.detectChanges();\n      const comp = fixture.debugElement.query(By.directive(Comp)).injector.get(Comp);\n      expect(comp.container.indexOf(comp.view0)).toBe(0);\n      expect(comp.container.indexOf(comp.view1)).toBe(1);\n      expect(comp.container.indexOf(comp.view2)).toBe(2);\n      expect(comp.container.indexOf(comp.view3)).toBe(3);\n      // Both ViewEngine and Ivy only honor one of the inserted ng-content components, even though\n      // all are inserted.\n      expect(fixture.nativeElement.textContent).toBe('test');\n    });\n  }"
        },
        {
          "type": "function",
          "name": "%AM8$%AM7$%AM0",
          "label": "%AM8$%AM7$%AM0",
          "start_line": 1,
          "end_line": 684,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\n%0 = new @ts_files/197.ts: %AC$%dflt$%AM8$%AM7$%AM0$3\ninstanceinvoke %0.<@ts_files/197.ts: %AC$%dflt$%AM8$%AM7$%AM0$3.constructor()>()\ninstanceinvoke TestBed.<@%unk/%unk: .configureTestingModule()>(%0)\nfixture = instanceinvoke TestBed.<@%unk/%unk: .createComponent()>(App)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\napp = fixture.<@%unk/%unk: .componentInstance>\n%1 = app.<@%unk/%unk: .view0>\n%2 = app.<@%unk/%unk: .container>\n%3 = instanceinvoke %2.<@%unk/%unk: .indexOf()>(%1)\n%4 = staticinvoke <@%unk/%unk: .expect()>(%3)\ninstanceinvoke %4.<@%unk/%unk: .toBe()>(0)\n%5 = app.<@%unk/%unk: .view1>\n%6 = app.<@%unk/%unk: .container>\n%7 = instanceinvoke %6.<@%unk/%unk: .indexOf()>(%5)\n%8 = staticinvoke <@%unk/%unk: .expect()>(%7)\ninstanceinvoke %8.<@%unk/%unk: .toBe()>(1)\n%9 = app.<@%unk/%unk: .view2>\n%10 = app.<@%unk/%unk: .container>\n%11 = instanceinvoke %10.<@%unk/%unk: .indexOf()>(%9)\n%12 = staticinvoke <@%unk/%unk: .expect()>(%11)\ninstanceinvoke %12.<@%unk/%unk: .toBe()>(2)\n%13 = app.<@%unk/%unk: .view3>\n%14 = app.<@%unk/%unk: .container>\n%15 = instanceinvoke %14.<@%unk/%unk: .indexOf()>(%13)\n%16 = staticinvoke <@%unk/%unk: .expect()>(%15)\ninstanceinvoke %16.<@%unk/%unk: .toBe()>(3)\n%17 = instanceinvoke By.<@%unk/%unk: .css()>('div.dynamic')\n%18 = fixture.<@%unk/%unk: .debugElement>\n%19 = instanceinvoke %18.<@%unk/%unk: .queryAll()>(%17)\n%20 = %19.<@%unk/%unk: .length>\n%21 = staticinvoke <@%unk/%unk: .expect()>(%20)\ninstanceinvoke %21.<@%unk/%unk: .toBe()>(4)\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      @Component({\n        template: `\n                  <ng-template #subContainer><div class=\"dynamic\" *ngIf=\"true\">test</div></ng-template>\n                  <div #container></div>\n                `,\n        standalone: false,\n      })\n      class App {\n        @ViewChild('container', {read: ViewContainerRef}) container: ViewContainerRef = null!;\n        @ViewChild('subContainer', {read: TemplateRef}) subContainer: TemplateRef<any> = null!;\n        view0: EmbeddedViewRef<any> = null!;\n        view1: EmbeddedViewRef<any> = null!;\n        view2: EmbeddedViewRef<any> = null!;\n        view3: EmbeddedViewRef<any> = null!;\n        constructor(public changeDetectorRef: ChangeDetectorRef) {}\n        ngAfterViewInit() {\n          // insert at the front\n          this.view1 = this.container.createEmbeddedView(this.subContainer, null, 0);\n          // insert at the front again\n          this.view0 = this.container.createEmbeddedView(this.subContainer, null, 0);\n          // insert at the end\n          this.view3 = this.container.createEmbeddedView(this.subContainer, null, 2);\n          // insert in the middle\n          this.view2 = this.container.createEmbeddedView(this.subContainer, null, 2);\n          // We need to run change detection here to avoid\n          // ExpressionChangedAfterItHasBeenCheckedError because of the value getting passed to ngIf\n          // in the template.\n          this.changeDetectorRef.detectChanges();\n        }\n      }\n      TestBed.configureTestingModule({\n        declarations: [App],\n        imports: [CommonModule],\n      });\n      const fixture = TestBed.createComponent(App);\n      fixture.detectChanges();\n      const app = fixture.componentInstance;\n      expect(app.container.indexOf(app.view0)).toBe(0);\n      expect(app.container.indexOf(app.view1)).toBe(1);\n      expect(app.container.indexOf(app.view2)).toBe(2);\n      expect(app.container.indexOf(app.view3)).toBe(3);\n      expect(fixture.debugElement.queryAll(By.css('div.dynamic')).length).toBe(4);\n    }"
        },
        {
          "type": "function",
          "name": "%AM7$%AM0",
          "label": "%AM7$%AM0",
          "start_line": 1,
          "end_line": 684,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\nstaticinvoke <@%unk/%unk: .it()>('should insert into an empty container, at the front, in the middle, and at the end', %AM8$%AM7$%AM0)\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n    it('should insert into an empty container, at the front, in the middle, and at the end', () => {\n      @Component({\n        template: `\n                  <ng-template #subContainer><div class=\"dynamic\" *ngIf=\"true\">test</div></ng-template>\n                  <div #container></div>\n                `,\n        standalone: false,\n      })\n      class App {\n        @ViewChild('container', {read: ViewContainerRef}) container: ViewContainerRef = null!;\n        @ViewChild('subContainer', {read: TemplateRef}) subContainer: TemplateRef<any> = null!;\n        view0: EmbeddedViewRef<any> = null!;\n        view1: EmbeddedViewRef<any> = null!;\n        view2: EmbeddedViewRef<any> = null!;\n        view3: EmbeddedViewRef<any> = null!;\n        constructor(public changeDetectorRef: ChangeDetectorRef) {}\n        ngAfterViewInit() {\n          // insert at the front\n          this.view1 = this.container.createEmbeddedView(this.subContainer, null, 0);\n          // insert at the front again\n          this.view0 = this.container.createEmbeddedView(this.subContainer, null, 0);\n          // insert at the end\n          this.view3 = this.container.createEmbeddedView(this.subContainer, null, 2);\n          // insert in the middle\n          this.view2 = this.container.createEmbeddedView(this.subContainer, null, 2);\n          // We need to run change detection here to avoid\n          // ExpressionChangedAfterItHasBeenCheckedError because of the value getting passed to ngIf\n          // in the template.\n          this.changeDetectorRef.detectChanges();\n        }\n      }\n      TestBed.configureTestingModule({\n        declarations: [App],\n        imports: [CommonModule],\n      });\n      const fixture = TestBed.createComponent(App);\n      fixture.detectChanges();\n      const app = fixture.componentInstance;\n      expect(app.container.indexOf(app.view0)).toBe(0);\n      expect(app.container.indexOf(app.view1)).toBe(1);\n      expect(app.container.indexOf(app.view2)).toBe(2);\n      expect(app.container.indexOf(app.view3)).toBe(3);\n      expect(fixture.debugElement.queryAll(By.css('div.dynamic')).length).toBe(4);\n    });\n  }"
        },
        {
          "type": "function",
          "name": "%AM11$%AM10$%AM9$%AM0",
          "label": "%AM11$%AM10$%AM9$%AM0",
          "start_line": 1,
          "end_line": 684,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\n%0 = new @ts_files/197.ts: %AC$%dflt$%AM11$%AM10$%AM9$%AM0$4\ninstanceinvoke %0.<@ts_files/197.ts: %AC$%dflt$%AM11$%AM10$%AM9$%AM0$4.constructor()>()\ninstanceinvoke TestBed.<@%unk/%unk: .configureTestingModule()>(%0)\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n        TestBed.configureTestingModule({\n          declarations: [TestCmpt, ViewInsertingDir],\n          imports: [CommonModule],\n        });\n      }"
        },
        {
          "type": "function",
          "name": "%createAndInsertViews$%AM10$%AM9$%AM0",
          "label": "%createAndInsertViews$%AM10$%AM9$%AM0",
          "start_line": 1,
          "end_line": 246,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "beforeTpl = parameter0: string\nthis = this: @ts_files/197.ts: %dflt\n%0 = '\n          <ng-template #insert>insert</ng-template>\n          <ng-template #before>' + beforeTpl\n%1 = %0 + '</ng-template>\n          <div><ng-template #vi=\"vi\" viewInserting></ng-template></div>\n        '\ninstanceinvoke TestBed.<@%unk/%unk: .overrideTemplate()>(TestCmpt, %1)\nfixture = instanceinvoke TestBed.<@%unk/%unk: .createComponent()>(TestCmpt)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%2 = fixture.<@%unk/%unk: .componentInstance>\ninstanceinvoke %2.<@%unk/%unk: .insert()>()\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%3 = fixture.<@%unk/%unk: .nativeElement>\nreturn %3",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "function createAndInsertViews(beforeTpl: string): any {\n        TestBed.overrideTemplate(\n          TestCmpt,\n          `\n          <ng-template #insert>insert</ng-template>\n          <ng-template #before>${beforeTpl}</ng-template>\n          <div><ng-template #vi=\"vi\" viewInserting></ng-template></div>\n        `,\n        );\n        const fixture = TestBed.createComponent(TestCmpt);\n        fixture.detectChanges();\n        fixture.componentInstance.insert();\n        fixture.detectChanges();\n        return fixture.nativeElement;\n      }"
        },
        {
          "type": "function",
          "name": "%AM12$%AM10$%AM9$%AM0",
          "label": "%AM12$%AM10$%AM9$%AM0",
          "start_line": 1,
          "end_line": 684,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\n%0 = staticinvoke <@%unk/%unk: .createAndInsertViews()>('|before')\n%1 = %0.<@%unk/%unk: .textContent>\n%2 = staticinvoke <@%unk/%unk: .expect()>(%1)\ninstanceinvoke %2.<@%unk/%unk: .toBe()>('insert|before')\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n        expect(createAndInsertViews('|before').textContent).toBe('insert|before');\n      }"
        },
        {
          "type": "function",
          "name": "%AM13$%AM10$%AM9$%AM0",
          "label": "%AM13$%AM10$%AM9$%AM0",
          "start_line": 1,
          "end_line": 684,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\n%0 = staticinvoke <@%unk/%unk: .createAndInsertViews()>('<span>|before</span>')\n%1 = %0.<@%unk/%unk: .textContent>\n%2 = staticinvoke <@%unk/%unk: .expect()>(%1)\ninstanceinvoke %2.<@%unk/%unk: .toBe()>('insert|before')\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n        expect(createAndInsertViews('<span>|before</span>').textContent).toBe('insert|before');\n      }"
        },
        {
          "type": "function",
          "name": "%AM14$%AM10$%AM9$%AM0",
          "label": "%AM14$%AM10$%AM9$%AM0",
          "start_line": 1,
          "end_line": 684,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\n%0 = staticinvoke <@%unk/%unk: .createAndInsertViews()>('\n          <ng-container>\n            <ng-container>|before</ng-container>\n          </ng-container>\n        ')\n%1 = %0.<@%unk/%unk: .textContent>\n%2 = staticinvoke <@%unk/%unk: .expect()>(%1)\ninstanceinvoke %2.<@%unk/%unk: .toBe()>('insert|before')\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n        expect(\n          createAndInsertViews(`\n          <ng-container>\n            <ng-container>|before</ng-container>\n          </ng-container>\n        `).textContent,\n        ).toBe('insert|before');\n      }"
        },
        {
          "type": "function",
          "name": "%AM15$%AM10$%AM9$%AM0",
          "label": "%AM15$%AM10$%AM9$%AM0",
          "start_line": 1,
          "end_line": 684,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\n%0 = staticinvoke <@%unk/%unk: .createAndInsertViews()>('<ng-container></ng-container>|before')\n%1 = %0.<@%unk/%unk: .textContent>\n%2 = staticinvoke <@%unk/%unk: .expect()>(%1)\ninstanceinvoke %2.<@%unk/%unk: .toBe()>('insert|before')\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n        expect(createAndInsertViews(`<ng-container></ng-container>|before`).textContent).toBe(\n          'insert|before',\n        );\n      }"
        },
        {
          "type": "function",
          "name": "%AM16$%AM10$%AM9$%AM0",
          "label": "%AM16$%AM10$%AM9$%AM0",
          "start_line": 1,
          "end_line": 684,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\n%0 = staticinvoke <@%unk/%unk: .createAndInsertViews()>('<ng-container i18n>{minutes, plural, =0 {just now} =1 {one minute ago} other {|before}}</ng-container>')\n%1 = %0.<@%unk/%unk: .textContent>\n%2 = staticinvoke <@%unk/%unk: .expect()>(%1)\ninstanceinvoke %2.<@%unk/%unk: .toBe()>('insert|before')\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n        expect(\n          createAndInsertViews(\n            `<ng-container i18n>{minutes, plural, =0 {just now} =1 {one minute ago} other {|before}}</ng-container>`,\n          ).textContent,\n        ).toBe('insert|before');\n      }"
        },
        {
          "type": "function",
          "name": "%AM17$%AM10$%AM9$%AM0",
          "label": "%AM17$%AM10$%AM9$%AM0",
          "start_line": 1,
          "end_line": 684,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\n%0 = staticinvoke <@%unk/%unk: .createAndInsertViews()>('<ng-template [ngIf]=\"true\">|before</ng-template>')\n%1 = %0.<@%unk/%unk: .textContent>\n%2 = staticinvoke <@%unk/%unk: .expect()>(%1)\ninstanceinvoke %2.<@%unk/%unk: .toBe()>('insert|before')\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n        expect(\n          createAndInsertViews(`<ng-template [ngIf]=\"true\">|before</ng-template>`).textContent,\n        ).toBe('insert|before');\n      }"
        },
        {
          "type": "function",
          "name": "%AM18$%AM10$%AM9$%AM0",
          "label": "%AM18$%AM10$%AM9$%AM0",
          "start_line": 1,
          "end_line": 684,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\n%0 = staticinvoke <@%unk/%unk: .createAndInsertViews()>('<ng-template [ngIf]=\"true\"></ng-template>|before')\n%1 = %0.<@%unk/%unk: .textContent>\n%2 = staticinvoke <@%unk/%unk: .expect()>(%1)\ninstanceinvoke %2.<@%unk/%unk: .toBe()>('insert|before')\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n        expect(\n          createAndInsertViews(`<ng-template [ngIf]=\"true\"></ng-template>|before`).textContent,\n        ).toBe('insert|before');\n      }"
        },
        {
          "type": "function",
          "name": "%AM19$%AM10$%AM9$%AM0",
          "label": "%AM19$%AM10$%AM9$%AM0",
          "start_line": 1,
          "end_line": 684,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\n%0 = staticinvoke <@%unk/%unk: .createAndInsertViews()>('\n          <ng-container [ngTemplateOutlet]=\"after\">|before</ng-container>\n          <ng-template #after>|after</ng-template>\n        ')\n%1 = %0.<@%unk/%unk: .textContent>\n%2 = staticinvoke <@%unk/%unk: .expect()>(%1)\ninstanceinvoke %2.<@%unk/%unk: .toBe()>('insert|before|after')\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n        expect(\n          createAndInsertViews(`\n          <ng-container [ngTemplateOutlet]=\"after\">|before</ng-container>\n          <ng-template #after>|after</ng-template>\n        `).textContent,\n        ).toBe('insert|before|after');\n      }"
        },
        {
          "type": "function",
          "name": "%AM20$%AM10$%AM9$%AM0",
          "label": "%AM20$%AM10$%AM9$%AM0",
          "start_line": 1,
          "end_line": 684,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\n%0 = staticinvoke <@%unk/%unk: .createAndInsertViews()>('\n          <div [ngTemplateOutlet]=\"after\">|before</div>\n          <ng-template #after>|after</ng-template>\n        ')\n%1 = %0.<@%unk/%unk: .textContent>\n%2 = staticinvoke <@%unk/%unk: .expect()>(%1)\ninstanceinvoke %2.<@%unk/%unk: .toBe()>('insert|before|after')\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n        expect(\n          createAndInsertViews(`\n          <div [ngTemplateOutlet]=\"after\">|before</div>\n          <ng-template #after>|after</ng-template>\n        `).textContent,\n        ).toBe('insert|before|after');\n      }"
        },
        {
          "type": "function",
          "name": "%AM21$%AM10$%AM9$%AM0",
          "label": "%AM21$%AM10$%AM9$%AM0",
          "start_line": 1,
          "end_line": 684,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\n%0 = staticinvoke <@%unk/%unk: .createAndInsertViews()>('<ng-content></ng-content>|before')\n%1 = %0.<@%unk/%unk: .textContent>\n%2 = staticinvoke <@%unk/%unk: .expect()>(%1)\ninstanceinvoke %2.<@%unk/%unk: .toBe()>('insert|before')\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n        expect(createAndInsertViews(`<ng-content></ng-content>|before`).textContent).toBe(\n          'insert|before',\n        );\n      }"
        },
        {
          "type": "function",
          "name": "%AM22$%AM10$%AM9$%AM0",
          "label": "%AM22$%AM10$%AM9$%AM0",
          "start_line": 1,
          "end_line": 684,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\n%0 = staticinvoke <@%unk/%unk: .createAndInsertViews()>('\n          <ng-template [ngIf]=\"true\">\n            <ng-container>\n              <ng-container>\n                <ng-template [ngIf]=\"true\">|before</ng-template>\n              </ng-container>\n            </ng-container>\n          </ng-template>\n        ')\n%1 = %0.<@%unk/%unk: .textContent>\n%2 = staticinvoke <@%unk/%unk: .expect()>(%1)\ninstanceinvoke %2.<@%unk/%unk: .toBe()>('insert|before')\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n        expect(\n          createAndInsertViews(`\n          <ng-template [ngIf]=\"true\">\n            <ng-container>\n              <ng-container>\n                <ng-template [ngIf]=\"true\">|before</ng-template>\n              </ng-container>\n            </ng-container>\n          </ng-template>\n        `).textContent,\n        ).toBe('insert|before');\n      }"
        },
        {
          "type": "function",
          "name": "%AM23$%AM10$%AM9$%AM0",
          "label": "%AM23$%AM10$%AM9$%AM0",
          "start_line": 1,
          "end_line": 684,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\n%0 = new @ts_files/197.ts: %AC$%dflt$%AM23$%AM10$%AM9$%AM0$5\ninstanceinvoke %0.<@ts_files/197.ts: %AC$%dflt$%AM23$%AM10$%AM9$%AM0$5.constructor()>()\ninstanceinvoke TestBed.<@%unk/%unk: .configureTestingModule()>(%0)\nfixture = instanceinvoke TestBed.<@%unk/%unk: .createComponent()>(AppComponent)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%1 = fixture.<@%unk/%unk: .nativeElement>\n%2 = %1.<@%unk/%unk: .textContent>\n%3 = staticinvoke <@%unk/%unk: .expect()>(%2)\ninstanceinvoke %3.<@%unk/%unk: .toBe()>('start|test|end')\n%4 = fixture.<@%unk/%unk: .componentInstance>\n%4.<@%unk/%unk: .insertTpl> = true\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%5 = fixture.<@%unk/%unk: .nativeElement>\n%6 = %5.<@%unk/%unk: .textContent>\n%7 = staticinvoke <@%unk/%unk: .expect()>(%6)\ninstanceinvoke %7.<@%unk/%unk: .toBe()>('start|testtest|end')\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n        @Component({\n          selector: 'app-root',\n          template: `\n            <div>start|</div>\n            <ng-container [ngTemplateOutlet]=\"insertTpl ? tpl : null\"></ng-container>\n            <ng-container [ngTemplateOutlet]=\"tpl\"></ng-container>\n            <div>|end</div>\n            <ng-template #tpl>test</ng-template>\n          `,\n          standalone: false,\n        })\n        class AppComponent {\n          insertTpl = false;\n        }\n        TestBed.configureTestingModule({\n          declarations: [AppComponent],\n          imports: [CommonModule],\n        });\n        const fixture = TestBed.createComponent(AppComponent);\n        fixture.detectChanges();\n        expect(fixture.nativeElement.textContent).toBe('start|test|end');\n        fixture.componentInstance.insertTpl = true;\n        fixture.detectChanges();\n        expect(fixture.nativeElement.textContent).toBe('start|testtest|end');\n      }"
        },
        {
          "type": "function",
          "name": "%AM10$%AM9$%AM0",
          "label": "%AM10$%AM9$%AM0",
          "start_line": 1,
          "end_line": 684,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\nstaticinvoke <@%unk/%unk: .beforeEach()>(%AM11$%AM10$%AM9$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should insert before a view with the text node as the first root node', %AM12$%AM10$%AM9$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should insert before a view with the element as the first root node', %AM13$%AM10$%AM9$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should insert before a view with the ng-container as the first root node', %AM14$%AM10$%AM9$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should insert before a view with the empty ng-container as the first root node', %AM15$%AM10$%AM9$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should insert before a view with ICU container inside a ng-container as the first root node', %AM16$%AM10$%AM9$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should insert before a view with a container as the first root node', %AM17$%AM10$%AM9$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should insert before a view with an empty container as the first root node', %AM18$%AM10$%AM9$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should insert before a view with a ng-container where ViewContainerRef is injected', %AM19$%AM10$%AM9$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should insert before a view with an element where ViewContainerRef is injected', %AM20$%AM10$%AM9$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should insert before a view with an empty projection as the first root node', %AM21$%AM10$%AM9$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should insert before a view with complex node structure', %AM22$%AM10$%AM9$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should insert before a ng-container with a ViewContainerRef on it', %AM23$%AM10$%AM9$%AM0)\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      @Component({\n        selector: 'test-cmpt',\n        template: '',\n        standalone: false,\n      })\n      class TestCmpt {\n        @ViewChild('before', {static: true}) beforeTpl!: TemplateRef<{}>;\n        @ViewChild('insert', {static: true}) insertTpl!: TemplateRef<{}>;\n        @ViewChild('vi', {static: true}) viewInsertingDir!: ViewInsertingDir;\n        minutes = 10;\n        insert() {\n          const beforeView = this.beforeTpl.createEmbeddedView({});\n          // change-detect the \"before view\" to create all child views\n          beforeView.detectChanges();\n          this.viewInsertingDir.insert(beforeView, this.insertTpl);\n        }\n      }\n      beforeEach(() => {\n        TestBed.configureTestingModule({\n          declarations: [TestCmpt, ViewInsertingDir],\n          imports: [CommonModule],\n        });\n      });\n      function createAndInsertViews(beforeTpl: string): any {\n        TestBed.overrideTemplate(\n          TestCmpt,\n          `\n          <ng-template #insert>insert</ng-template>\n          <ng-template #before>${beforeTpl}</ng-template>\n          <div><ng-template #vi=\"vi\" viewInserting></ng-template></div>\n        `,\n        );\n        const fixture = TestBed.createComponent(TestCmpt);\n        fixture.detectChanges();\n        fixture.componentInstance.insert();\n        fixture.detectChanges();\n        return fixture.nativeElement;\n      }\n      it('should insert before a view with the text node as the first root node', () => {\n        expect(createAndInsertViews('|before').textContent).toBe('insert|before');\n      });\n      it('should insert before a view with the element as the first root node', () => {\n        expect(createAndInsertViews('<span>|before</span>').textContent).toBe('insert|before');\n      });\n      it('should insert before a view with the ng-container as the first root node', () => {\n        expect(\n          createAndInsertViews(`\n          <ng-container>\n            <ng-container>|before</ng-container>\n          </ng-container>\n        `).textContent,\n        ).toBe('insert|before');\n      });\n      it('should insert before a view with the empty ng-container as the first root node', () => {\n        expect(createAndInsertViews(`<ng-container></ng-container>|before`).textContent).toBe(\n          'insert|before',\n        );\n      });\n      it('should insert before a view with ICU container inside a ng-container as the first root node', () => {\n        expect(\n          createAndInsertViews(\n            `<ng-container i18n>{minutes, plural, =0 {just now} =1 {one minute ago} other {|before}}</ng-container>`,\n          ).textContent,\n        ).toBe('insert|before');\n      });\n      it('should insert before a view with a container as the first root node', () => {\n        expect(\n          createAndInsertViews(`<ng-template [ngIf]=\"true\">|before</ng-template>`).textContent,\n        ).toBe('insert|before');\n      });\n      it('should insert before a view with an empty container as the first root node', () => {\n        expect(\n          createAndInsertViews(`<ng-template [ngIf]=\"true\"></ng-template>|before`).textContent,\n        ).toBe('insert|before');\n      });\n      it('should insert before a view with a ng-container where ViewContainerRef is injected', () => {\n        expect(\n          createAndInsertViews(`\n          <ng-container [ngTemplateOutlet]=\"after\">|before</ng-container>\n          <ng-template #after>|after</ng-template>\n        `).textContent,\n        ).toBe('insert|before|after');\n      });\n      it('should insert before a view with an element where ViewContainerRef is injected', () => {\n        expect(\n          createAndInsertViews(`\n          <div [ngTemplateOutlet]=\"after\">|before</div>\n          <ng-template #after>|after</ng-template>\n        `).textContent,\n        ).toBe('insert|before|after');\n      });\n      it('should insert before a view with an empty projection as the first root node', () => {\n        expect(createAndInsertViews(`<ng-content></ng-content>|before`).textContent).toBe(\n          'insert|before',\n        );\n      });\n      it('should insert before a view with complex node structure', () => {\n        expect(\n          createAndInsertViews(`\n          <ng-template [ngIf]=\"true\">\n            <ng-container>\n              <ng-container>\n                <ng-template [ngIf]=\"true\">|before</ng-template>\n              </ng-container>\n            </ng-container>\n          </ng-template>\n        `).textContent,\n        ).toBe('insert|before');\n      });\n      it('should insert before a ng-container with a ViewContainerRef on it', () => {\n        @Component({\n          selector: 'app-root',\n          template: `\n            <div>start|</div>\n            <ng-container [ngTemplateOutlet]=\"insertTpl ? tpl : null\"></ng-container>\n            <ng-container [ngTemplateOutlet]=\"tpl\"></ng-container>\n            <div>|end</div>\n            <ng-template #tpl>test</ng-template>\n          `,\n          standalone: false,\n        })\n        class AppComponent {\n          insertTpl = false;\n        }\n        TestBed.configureTestingModule({\n          declarations: [AppComponent],\n          imports: [CommonModule],\n        });\n        const fixture = TestBed.createComponent(AppComponent);\n        fixture.detectChanges();\n        expect(fixture.nativeElement.textContent).toBe('start|test|end');\n        fixture.componentInstance.insertTpl = true;\n        fixture.detectChanges();\n        expect(fixture.nativeElement.textContent).toBe('start|testtest|end');\n      });\n    }"
        },
        {
          "type": "function",
          "name": "%AM25$%AM24$%AM9$%AM0",
          "label": "%AM25$%AM24$%AM9$%AM0",
          "start_line": 1,
          "end_line": 684,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\n%0 = new @ts_files/197.ts: %AC$%dflt$%AM25$%AM24$%AM9$%AM0$6\ninstanceinvoke %0.<@ts_files/197.ts: %AC$%dflt$%AM25$%AM24$%AM9$%AM0$6.constructor()>()\ninstanceinvoke TestBed.<@%unk/%unk: .configureTestingModule()>(%0)\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n        TestBed.configureTestingModule({\n          declarations: [ViewInsertingDir, WithContentCmpt, TestCmpt],\n          imports: [CommonModule],\n        });\n      }"
        },
        {
          "type": "function",
          "name": "%AM26$%AM24$%AM9$%AM0",
          "label": "%AM26$%AM24$%AM9$%AM0",
          "start_line": 1,
          "end_line": 684,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\ninstanceinvoke TestBed.<@%unk/%unk: .overrideTemplate()>(TestCmpt, '<with-content #wc>|before</with-content>')\nfixture = instanceinvoke TestBed.<@%unk/%unk: .createComponent()>(TestCmpt)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%0 = fixture.<@%unk/%unk: .componentInstance>\n%1 = %0.<@%unk/%unk: .withContentCmpt>\ninstanceinvoke %1.<@%unk/%unk: .insert()>()\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%2 = fixture.<@%unk/%unk: .nativeElement>\n%3 = %2.<@%unk/%unk: .textContent>\n%4 = staticinvoke <@%unk/%unk: .expect()>(%3)\ninstanceinvoke %4.<@%unk/%unk: .toBe()>('insert|before')\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n        TestBed.overrideTemplate(TestCmpt, `<with-content #wc>|before</with-content>`);\n        const fixture = TestBed.createComponent(TestCmpt);\n        fixture.detectChanges();\n        fixture.componentInstance.withContentCmpt.insert();\n        fixture.detectChanges();\n        expect(fixture.nativeElement.textContent).toBe('insert|before');\n      }"
        },
        {
          "type": "function",
          "name": "%AM27$%AM24$%AM9$%AM0",
          "label": "%AM27$%AM24$%AM9$%AM0",
          "start_line": 1,
          "end_line": 684,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\ninstanceinvoke TestBed.<@%unk/%unk: .overrideTemplate()>(TestCmpt, '<with-content #wc><ng-template [ngIf]=\"true\">|before</ng-template></with-content>')\nfixture = instanceinvoke TestBed.<@%unk/%unk: .createComponent()>(TestCmpt)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%0 = fixture.<@%unk/%unk: .componentInstance>\n%1 = %0.<@%unk/%unk: .withContentCmpt>\ninstanceinvoke %1.<@%unk/%unk: .insert()>()\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%2 = fixture.<@%unk/%unk: .nativeElement>\n%3 = %2.<@%unk/%unk: .textContent>\n%4 = staticinvoke <@%unk/%unk: .expect()>(%3)\ninstanceinvoke %4.<@%unk/%unk: .toBe()>('insert|before')\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n        TestBed.overrideTemplate(\n          TestCmpt,\n          `<with-content #wc><ng-template [ngIf]=\"true\">|before</ng-template></with-content>`,\n        );\n        const fixture = TestBed.createComponent(TestCmpt);\n        fixture.detectChanges();\n        fixture.componentInstance.withContentCmpt.insert();\n        fixture.detectChanges();\n        expect(fixture.nativeElement.textContent).toBe('insert|before');\n      }"
        },
        {
          "type": "function",
          "name": "%AM24$%AM9$%AM0",
          "label": "%AM24$%AM9$%AM0",
          "start_line": 1,
          "end_line": 684,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\nstaticinvoke <@%unk/%unk: .beforeEach()>(%AM25$%AM24$%AM9$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should insert before a view with projected text nodes', %AM26$%AM24$%AM9$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should insert before a view with projected container', %AM27$%AM24$%AM9$%AM0)\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      @Component({\n        selector: 'with-content',\n        template: `\n          <ng-template #insert>insert</ng-template>\n          <ng-template #before><ng-content></ng-content></ng-template>\n          <div><ng-template #vi=\"vi\" viewInserting></ng-template></div>\n        `,\n        standalone: false,\n      })\n      class WithContentCmpt {\n        @ViewChild('insert', {static: true}) insertTpl!: TemplateRef<{}>;\n        @ViewChild('before', {static: true}) beforeTpl!: TemplateRef<{}>;\n        @ViewChild('vi', {static: true}) viewInsertingDir!: ViewInsertingDir;\n        insert() {\n          const beforeView = this.beforeTpl.createEmbeddedView({});\n          // change-detect the \"before view\" to create all child views\n          beforeView.detectChanges();\n          this.viewInsertingDir.insert(beforeView, this.insertTpl);\n        }\n      }\n      @Component({\n        selector: 'test-cmpt',\n        template: '',\n        standalone: false,\n      })\n      class TestCmpt {\n        @ViewChild('wc', {static: true}) withContentCmpt!: WithContentCmpt;\n      }\n      beforeEach(() => {\n        TestBed.configureTestingModule({\n          declarations: [ViewInsertingDir, WithContentCmpt, TestCmpt],\n          imports: [CommonModule],\n        });\n      });\n      it('should insert before a view with projected text nodes', () => {\n        TestBed.overrideTemplate(TestCmpt, `<with-content #wc>|before</with-content>`);\n        const fixture = TestBed.createComponent(TestCmpt);\n        fixture.detectChanges();\n        fixture.componentInstance.withContentCmpt.insert();\n        fixture.detectChanges();\n        expect(fixture.nativeElement.textContent).toBe('insert|before');\n      });\n      it('should insert before a view with projected container', () => {\n        TestBed.overrideTemplate(\n          TestCmpt,\n          `<with-content #wc><ng-template [ngIf]=\"true\">|before</ng-template></with-content>`,\n        );\n        const fixture = TestBed.createComponent(TestCmpt);\n        fixture.detectChanges();\n        fixture.componentInstance.withContentCmpt.insert();\n        fixture.detectChanges();\n        expect(fixture.nativeElement.textContent).toBe('insert|before');\n      });\n    }"
        },
        {
          "type": "function",
          "name": "%AM29$%AM28$%AM9$%AM0",
          "label": "%AM29$%AM28$%AM9$%AM0",
          "start_line": 1,
          "end_line": 684,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\n%0 = new @ts_files/197.ts: %AC$%dflt$%AM29$%AM28$%AM9$%AM0$7\ninstanceinvoke %0.<@ts_files/197.ts: %AC$%dflt$%AM29$%AM28$%AM9$%AM0$7.constructor()>()\ninstanceinvoke TestBed.<@%unk/%unk: .configureTestingModule()>(%0)\nfixture = instanceinvoke TestBed.<@%unk/%unk: .createComponent()>(TestCmpt)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%1 = fixture.<@%unk/%unk: .componentInstance>\ninstanceinvoke %1.<@%unk/%unk: .insert()>()\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%2 = fixture.<@%unk/%unk: .nativeElement>\n%3 = %2.<@%unk/%unk: .textContent>\n%4 = staticinvoke <@%unk/%unk: .expect()>(%3)\ninstanceinvoke %4.<@%unk/%unk: .toBe()>('insert|before')\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n        @Component({\n          selector: 'test-cmpt',\n          template: `\n                <ng-template #insert>insert</ng-template>\n                <div><ng-template #vi=\"vi\" viewInserting></ng-template></div>\n              `,\n          standalone: false,\n        })\n        class TestCmpt {\n          @ViewChild('insert', {static: true}) insertTpl!: TemplateRef<{}>;\n          @ViewChild('vi', {static: true}) viewInsertingDir!: ViewInsertingDir;\n          constructor(\n            private _vcr: ViewContainerRef,\n            private _injector: Injector,\n          ) {}\n          insert() {\n            // create a dynamic component view to act as an \"insert before\" view\n            const beforeView = this._vcr.createComponent(DynamicComponent, {\n              injector: this._injector,\n            }).hostView;\n            // change-detect the \"before view\" to create all child views\n            beforeView.detectChanges();\n            this.viewInsertingDir.insert(beforeView, this.insertTpl);\n          }\n        }\n        TestBed.configureTestingModule({\n          declarations: [TestCmpt, ViewInsertingDir, DynamicComponent],\n        });\n        const fixture = TestBed.createComponent(TestCmpt);\n        fixture.detectChanges();\n        fixture.componentInstance.insert();\n        fixture.detectChanges();\n        expect(fixture.nativeElement.textContent).toBe('insert|before');\n      }"
        },
        {
          "type": "function",
          "name": "%AM28$%AM9$%AM0",
          "label": "%AM28$%AM9$%AM0",
          "start_line": 1,
          "end_line": 684,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\nstaticinvoke <@%unk/%unk: .it()>('should insert in front a dynamic component view', %AM29$%AM28$%AM9$%AM0)\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      @Directive({\n        selector: '[viewInserting]',\n        exportAs: 'vi',\n        standalone: false,\n      })\n      class ViewInsertingDir {\n        constructor(private _vcRef: ViewContainerRef) {}\n        insert(beforeView: ViewRef, insertTpl: TemplateRef<{}>) {\n          this._vcRef.insert(beforeView, 0);\n          this._vcRef.createEmbeddedView(insertTpl, {}, 0);\n        }\n      }\n      @Component({\n        selector: 'dynamic-cmpt',\n        template: '|before',\n        standalone: false,\n      })\n      class DynamicComponent {}\n      it('should insert in front a dynamic component view', () => {\n        @Component({\n          selector: 'test-cmpt',\n          template: `\n                <ng-template #insert>insert</ng-template>\n                <div><ng-template #vi=\"vi\" viewInserting></ng-template></div>\n              `,\n          standalone: false,\n        })\n        class TestCmpt {\n          @ViewChild('insert', {static: true}) insertTpl!: TemplateRef<{}>;\n          @ViewChild('vi', {static: true}) viewInsertingDir!: ViewInsertingDir;\n          constructor(\n            private _vcr: ViewContainerRef,\n            private _injector: Injector,\n          ) {}\n          insert() {\n            // create a dynamic component view to act as an \"insert before\" view\n            const beforeView = this._vcr.createComponent(DynamicComponent, {\n              injector: this._injector,\n            }).hostView;\n            // change-detect the \"before view\" to create all child views\n            beforeView.detectChanges();\n            this.viewInsertingDir.insert(beforeView, this.insertTpl);\n          }\n        }\n        TestBed.configureTestingModule({\n          declarations: [TestCmpt, ViewInsertingDir, DynamicComponent],\n        });\n        const fixture = TestBed.createComponent(TestCmpt);\n        fixture.detectChanges();\n        fixture.componentInstance.insert();\n        fixture.detectChanges();\n        expect(fixture.nativeElement.textContent).toBe('insert|before');\n      });\n    }"
        },
        {
          "type": "function",
          "name": "%AM9$%AM0",
          "label": "%AM9$%AM0",
          "start_line": 1,
          "end_line": 684,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\nstaticinvoke <@%unk/%unk: .describe()>('before embedded view', %AM10$%AM9$%AM0)\nstaticinvoke <@%unk/%unk: .describe()>('before embedded view with projection', %AM24$%AM9$%AM0)\nstaticinvoke <@%unk/%unk: .describe()>('before component view', %AM28$%AM9$%AM0)\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n    @Directive({\n      selector: '[viewInserting]',\n      exportAs: 'vi',\n      standalone: false,\n    })\n    class ViewInsertingDir {\n      constructor(private _vcRef: ViewContainerRef) {}\n      insert(beforeView: ViewRef, insertTpl: TemplateRef<{}>) {\n        this._vcRef.insert(beforeView, 0);\n        this._vcRef.createEmbeddedView(insertTpl, {}, 0);\n      }\n    }\n    describe('before embedded view', () => {\n      @Component({\n        selector: 'test-cmpt',\n        template: '',\n        standalone: false,\n      })\n      class TestCmpt {\n        @ViewChild('before', {static: true}) beforeTpl!: TemplateRef<{}>;\n        @ViewChild('insert', {static: true}) insertTpl!: TemplateRef<{}>;\n        @ViewChild('vi', {static: true}) viewInsertingDir!: ViewInsertingDir;\n        minutes = 10;\n        insert() {\n          const beforeView = this.beforeTpl.createEmbeddedView({});\n          // change-detect the \"before view\" to create all child views\n          beforeView.detectChanges();\n          this.viewInsertingDir.insert(beforeView, this.insertTpl);\n        }\n      }\n      beforeEach(() => {\n        TestBed.configureTestingModule({\n          declarations: [TestCmpt, ViewInsertingDir],\n          imports: [CommonModule],\n        });\n      });\n      function createAndInsertViews(beforeTpl: string): any {\n        TestBed.overrideTemplate(\n          TestCmpt,\n          `\n          <ng-template #insert>insert</ng-template>\n          <ng-template #before>${beforeTpl}</ng-template>\n          <div><ng-template #vi=\"vi\" viewInserting></ng-template></div>\n        `,\n        );\n        const fixture = TestBed.createComponent(TestCmpt);\n        fixture.detectChanges();\n        fixture.componentInstance.insert();\n        fixture.detectChanges();\n        return fixture.nativeElement;\n      }\n      it('should insert before a view with the text node as the first root node', () => {\n        expect(createAndInsertViews('|before').textContent).toBe('insert|before');\n      });\n      it('should insert before a view with the element as the first root node', () => {\n        expect(createAndInsertViews('<span>|before</span>').textContent).toBe('insert|before');\n      });\n      it('should insert before a view with the ng-container as the first root node', () => {\n        expect(\n          createAndInsertViews(`\n          <ng-container>\n            <ng-container>|before</ng-container>\n          </ng-container>\n        `).textContent,\n        ).toBe('insert|before');\n      });\n      it('should insert before a view with the empty ng-container as the first root node', () => {\n        expect(createAndInsertViews(`<ng-container></ng-container>|before`).textContent).toBe(\n          'insert|before',\n        );\n      });\n      it('should insert before a view with ICU container inside a ng-container as the first root node', () => {\n        expect(\n          createAndInsertViews(\n            `<ng-container i18n>{minutes, plural, =0 {just now} =1 {one minute ago} other {|before}}</ng-container>`,\n          ).textContent,\n        ).toBe('insert|before');\n      });\n      it('should insert before a view with a container as the first root node', () => {\n        expect(\n          createAndInsertViews(`<ng-template [ngIf]=\"true\">|before</ng-template>`).textContent,\n        ).toBe('insert|before');\n      });\n      it('should insert before a view with an empty container as the first root node', () => {\n        expect(\n          createAndInsertViews(`<ng-template [ngIf]=\"true\"></ng-template>|before`).textContent,\n        ).toBe('insert|before');\n      });\n      it('should insert before a view with a ng-container where ViewContainerRef is injected', () => {\n        expect(\n          createAndInsertViews(`\n          <ng-container [ngTemplateOutlet]=\"after\">|before</ng-container>\n          <ng-template #after>|after</ng-template>\n        `).textContent,\n        ).toBe('insert|before|after');\n      });\n      it('should insert before a view with an element where ViewContainerRef is injected', () => {\n        expect(\n          createAndInsertViews(`\n          <div [ngTemplateOutlet]=\"after\">|before</div>\n          <ng-template #after>|after</ng-template>\n        `).textContent,\n        ).toBe('insert|before|after');\n      });\n      it('should insert before a view with an empty projection as the first root node', () => {\n        expect(createAndInsertViews(`<ng-content></ng-content>|before`).textContent).toBe(\n          'insert|before',\n        );\n      });\n      it('should insert before a view with complex node structure', () => {\n        expect(\n          createAndInsertViews(`\n          <ng-template [ngIf]=\"true\">\n            <ng-container>\n              <ng-container>\n                <ng-template [ngIf]=\"true\">|before</ng-template>\n              </ng-container>\n            </ng-container>\n          </ng-template>\n        `).textContent,\n        ).toBe('insert|before');\n      });\n      it('should insert before a ng-container with a ViewContainerRef on it', () => {\n        @Component({\n          selector: 'app-root',\n          template: `\n            <div>start|</div>\n            <ng-container [ngTemplateOutlet]=\"insertTpl ? tpl : null\"></ng-container>\n            <ng-container [ngTemplateOutlet]=\"tpl\"></ng-container>\n            <div>|end</div>\n            <ng-template #tpl>test</ng-template>\n          `,\n          standalone: false,\n        })\n        class AppComponent {\n          insertTpl = false;\n        }\n        TestBed.configureTestingModule({\n          declarations: [AppComponent],\n          imports: [CommonModule],\n        });\n        const fixture = TestBed.createComponent(AppComponent);\n        fixture.detectChanges();\n        expect(fixture.nativeElement.textContent).toBe('start|test|end');\n        fixture.componentInstance.insertTpl = true;\n        fixture.detectChanges();\n        expect(fixture.nativeElement.textContent).toBe('start|testtest|end');\n      });\n    });\n    describe('before embedded view with projection', () => {\n      @Component({\n        selector: 'with-content',\n        template: `\n          <ng-template #insert>insert</ng-template>\n          <ng-template #before><ng-content></ng-content></ng-template>\n          <div><ng-template #vi=\"vi\" viewInserting></ng-template></div>\n        `,\n        standalone: false,\n      })\n      class WithContentCmpt {\n        @ViewChild('insert', {static: true}) insertTpl!: TemplateRef<{}>;\n        @ViewChild('before', {static: true}) beforeTpl!: TemplateRef<{}>;\n        @ViewChild('vi', {static: true}) viewInsertingDir!: ViewInsertingDir;\n        insert() {\n          const beforeView = this.beforeTpl.createEmbeddedView({});\n          // change-detect the \"before view\" to create all child views\n          beforeView.detectChanges();\n          this.viewInsertingDir.insert(beforeView, this.insertTpl);\n        }\n      }\n      @Component({\n        selector: 'test-cmpt',\n        template: '',\n        standalone: false,\n      })\n      class TestCmpt {\n        @ViewChild('wc', {static: true}) withContentCmpt!: WithContentCmpt;\n      }\n      beforeEach(() => {\n        TestBed.configureTestingModule({\n          declarations: [ViewInsertingDir, WithContentCmpt, TestCmpt],\n          imports: [CommonModule],\n        });\n      });\n      it('should insert before a view with projected text nodes', () => {\n        TestBed.overrideTemplate(TestCmpt, `<with-content #wc>|before</with-content>`);\n        const fixture = TestBed.createComponent(TestCmpt);\n        fixture.detectChanges();\n        fixture.componentInstance.withContentCmpt.insert();\n        fixture.detectChanges();\n        expect(fixture.nativeElement.textContent).toBe('insert|before');\n      });\n      it('should insert before a view with projected container', () => {\n        TestBed.overrideTemplate(\n          TestCmpt,\n          `<with-content #wc><ng-template [ngIf]=\"true\">|before</ng-template></with-content>`,\n        );\n        const fixture = TestBed.createComponent(TestCmpt);\n        fixture.detectChanges();\n        fixture.componentInstance.withContentCmpt.insert();\n        fixture.detectChanges();\n        expect(fixture.nativeElement.textContent).toBe('insert|before');\n      });\n    });\n    describe('before component view', () => {\n      @Directive({\n        selector: '[viewInserting]',\n        exportAs: 'vi',\n        standalone: false,\n      })\n      class ViewInsertingDir {\n        constructor(private _vcRef: ViewContainerRef) {}\n        insert(beforeView: ViewRef, insertTpl: TemplateRef<{}>) {\n          this._vcRef.insert(beforeView, 0);\n          this._vcRef.createEmbeddedView(insertTpl, {}, 0);\n        }\n      }\n      @Component({\n        selector: 'dynamic-cmpt',\n        template: '|before',\n        standalone: false,\n      })\n      class DynamicComponent {}\n      it('should insert in front a dynamic component view', () => {\n        @Component({\n          selector: 'test-cmpt',\n          template: `\n                <ng-template #insert>insert</ng-template>\n                <div><ng-template #vi=\"vi\" viewInserting></ng-template></div>\n              `,\n          standalone: false,\n        })\n        class TestCmpt {\n          @ViewChild('insert', {static: true}) insertTpl!: TemplateRef<{}>;\n          @ViewChild('vi', {static: true}) viewInsertingDir!: ViewInsertingDir;\n          constructor(\n            private _vcr: ViewContainerRef,\n            private _injector: Injector,\n          ) {}\n          insert() {\n            // create a dynamic component view to act as an \"insert before\" view\n            const beforeView = this._vcr.createComponent(DynamicComponent, {\n              injector: this._injector,\n            }).hostView;\n            // change-detect the \"before view\" to create all child views\n            beforeView.detectChanges();\n            this.viewInsertingDir.insert(beforeView, this.insertTpl);\n          }\n        }\n        TestBed.configureTestingModule({\n          declarations: [TestCmpt, ViewInsertingDir, DynamicComponent],\n        });\n        const fixture = TestBed.createComponent(TestCmpt);\n        fixture.detectChanges();\n        fixture.componentInstance.insert();\n        fixture.detectChanges();\n        expect(fixture.nativeElement.textContent).toBe('insert|before');\n      });\n    });\n  }"
        },
        {
          "type": "function",
          "name": "%AM31$%AM30$%AM0",
          "label": "%AM31$%AM30$%AM0",
          "start_line": 1,
          "end_line": 684,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\n%0 = new @ts_files/197.ts: %AC$%dflt$%AM31$%AM30$%AM0$8\ninstanceinvoke %0.<@ts_files/197.ts: %AC$%dflt$%AM31$%AM30$%AM0$8.constructor()>()\ninstanceinvoke TestBed.<@%unk/%unk: .configureTestingModule()>(%0)\nfixture = instanceinvoke TestBed.<@%unk/%unk: .createComponent()>(AppComponent)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%1 = fixture.<@%unk/%unk: .nativeElement>\n%2 = %1.<@%unk/%unk: .textContent>\n%3 = staticinvoke <@%unk/%unk: .expect()>(%2)\ninstanceinvoke %3.<@%unk/%unk: .toBe()>('start||end|click')\n%4 = fixture.<@%unk/%unk: .componentInstance>\ninstanceinvoke %4.<@%unk/%unk: .click()>()\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%5 = fixture.<@%unk/%unk: .nativeElement>\n%6 = %5.<@%unk/%unk: .textContent>\n%7 = staticinvoke <@%unk/%unk: .expect()>(%6)\ninstanceinvoke %7.<@%unk/%unk: .toBe()>('start|dynamic|end|click')\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      @Component({\n        selector: 'dynamic-cmpt',\n        template: 'dynamic',\n        standalone: false,\n      })\n      class DynamicComponent {}\n      @Component({\n        selector: 'app-root',\n        template: `\n            <div>start|</div>\n            <ng-container #container></ng-container>\n            <div>|end</div>\n            <div (click)=\"click()\" >|click</div>\n        `,\n        standalone: false,\n      })\n      class AppComponent {\n        @ViewChild('container', {read: ViewContainerRef, static: true}) vcr!: ViewContainerRef;\n        click() {\n          this.vcr.createComponent(DynamicComponent);\n        }\n      }\n      TestBed.configureTestingModule({\n        declarations: [AppComponent, DynamicComponent],\n      });\n      const fixture = TestBed.createComponent(AppComponent);\n      fixture.detectChanges();\n      expect(fixture.nativeElement.textContent).toBe('start||end|click');\n      fixture.componentInstance.click();\n      fixture.detectChanges();\n      expect(fixture.nativeElement.textContent).toBe('start|dynamic|end|click');\n    }"
        },
        {
          "type": "function",
          "name": "%AM32$%AM30$%AM0",
          "label": "%AM32$%AM30$%AM0",
          "start_line": 1,
          "end_line": 684,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\n%0 = new @ts_files/197.ts: %AC$%dflt$%AM32$%AM30$%AM0$9\ninstanceinvoke %0.<@ts_files/197.ts: %AC$%dflt$%AM32$%AM30$%AM0$9.constructor()>()\ninstanceinvoke TestBed.<@%unk/%unk: .configureTestingModule()>(%0)\nfixture = instanceinvoke TestBed.<@%unk/%unk: .createComponent()>(AppComponent)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%1 = fixture.<@%unk/%unk: .nativeElement>\n%2 = %1.<@%unk/%unk: .textContent>\n%3 = staticinvoke <@%unk/%unk: .expect()>(%2)\ninstanceinvoke %3.<@%unk/%unk: .toBe()>('container start||container end|click')\n%4 = fixture.<@%unk/%unk: .componentInstance>\ninstanceinvoke %4.<@%unk/%unk: .click()>()\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%5 = fixture.<@%unk/%unk: .nativeElement>\n%6 = %5.<@%unk/%unk: .textContent>\n%7 = staticinvoke <@%unk/%unk: .expect()>(%6)\ninstanceinvoke %7.<@%unk/%unk: .toBe()>('container start|test|container end|click')\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      @Component({\n        selector: 'app-root',\n        template: `\n        <div>container start|</div>\n        <ng-container #container></ng-container>\n        <div>|container end</div>\n        <ng-template #template >test</ng-template>\n        <div (click)=\"click()\" >|click</div>\n        `,\n        standalone: false,\n      })\n      class AppComponent {\n        @ViewChild('container', {read: ViewContainerRef, static: true}) vcr!: ViewContainerRef;\n        @ViewChild('template', {read: TemplateRef, static: true}) template!: TemplateRef<any>;\n        click() {\n          this.vcr.createEmbeddedView(this.template, undefined, 0);\n        }\n      }\n      TestBed.configureTestingModule({\n        declarations: [AppComponent],\n      });\n      const fixture = TestBed.createComponent(AppComponent);\n      fixture.detectChanges();\n      expect(fixture.nativeElement.textContent).toBe('container start||container end|click');\n      fixture.componentInstance.click();\n      fixture.detectChanges();\n      expect(fixture.nativeElement.textContent).toBe('container start|test|container end|click');\n    }"
        },
        {
          "type": "function",
          "name": "%AM33$%AM30$%AM0",
          "label": "%AM33$%AM30$%AM0",
          "start_line": 1,
          "end_line": 684,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\n%0 = new @ts_files/197.ts: %AC$%dflt$%AM33$%AM30$%AM0$10\ninstanceinvoke %0.<@ts_files/197.ts: %AC$%dflt$%AM33$%AM30$%AM0$10.constructor()>()\ninstanceinvoke TestBed.<@%unk/%unk: .configureTestingModule()>(%0)\nfixture = instanceinvoke TestBed.<@%unk/%unk: .createComponent()>(AppComponent)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%1 = fixture.<@%unk/%unk: .nativeElement>\n%2 = %1.<@%unk/%unk: .textContent>\n%3 = instanceinvoke %2.<@%unk/%unk: .trim()>()\n%4 = staticinvoke <@%unk/%unk: .expect()>(%3)\ninstanceinvoke %4.<@%unk/%unk: .toContain()>('1')\n%6 = newarray (number)[2]\n%6[0] = 2\n%6[1] = 1\n%5 = fixture.<@%unk/%unk: .componentInstance>\n%5.<@%unk/%unk: .items> = %6\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%7 = fixture.<@%unk/%unk: .nativeElement>\n%8 = %7.<@%unk/%unk: .textContent>\n%9 = instanceinvoke %8.<@%unk/%unk: .trim()>()\n%10 = staticinvoke <@%unk/%unk: .expect()>(%9)\ninstanceinvoke %10.<@%unk/%unk: .toContain()>('2  1')\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      @Component({\n        selector: 'app-root',\n        template: `\n          <ng-template #parameterListItem let-parameter=\"parameter\">\n            {{parameter}}\n          </ng-template>\n          <ng-container *ngFor=\"let parameter of items;\"\n            [ngTemplateOutlet]=\"parameterListItem\"\n            [ngTemplateOutletContext]=\"{parameter:parameter}\">\n          </ng-container>\n        `,\n        standalone: false,\n      })\n      class AppComponent {\n        items = [1];\n      }\n      TestBed.configureTestingModule({\n        declarations: [AppComponent],\n        imports: [CommonModule],\n      });\n      const fixture = TestBed.createComponent(AppComponent);\n      fixture.detectChanges();\n      expect(fixture.nativeElement.textContent.trim()).toContain('1');\n      fixture.componentInstance.items = [2, 1];\n      fixture.detectChanges();\n      expect(fixture.nativeElement.textContent.trim()).toContain('2  1');\n    }"
        },
        {
          "type": "function",
          "name": "%AM30$%AM0",
          "label": "%AM30$%AM0",
          "start_line": 1,
          "end_line": 684,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\nstaticinvoke <@%unk/%unk: .it()>('should insert component views into ViewContainerRef injected by querying <ng-container>', %AM31$%AM30$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should insert embedded views into ViewContainerRef injected by querying <ng-container>', %AM32$%AM30$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should properly insert before views in a ViewContainerRef injected on ng-container', %AM33$%AM30$%AM0)\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n    // https://github.com/angular/angular/issues/31971\n    it('should insert component views into ViewContainerRef injected by querying <ng-container>', () => {\n      @Component({\n        selector: 'dynamic-cmpt',\n        template: 'dynamic',\n        standalone: false,\n      })\n      class DynamicComponent {}\n      @Component({\n        selector: 'app-root',\n        template: `\n            <div>start|</div>\n            <ng-container #container></ng-container>\n            <div>|end</div>\n            <div (click)=\"click()\" >|click</div>\n        `,\n        standalone: false,\n      })\n      class AppComponent {\n        @ViewChild('container', {read: ViewContainerRef, static: true}) vcr!: ViewContainerRef;\n        click() {\n          this.vcr.createComponent(DynamicComponent);\n        }\n      }\n      TestBed.configureTestingModule({\n        declarations: [AppComponent, DynamicComponent],\n      });\n      const fixture = TestBed.createComponent(AppComponent);\n      fixture.detectChanges();\n      expect(fixture.nativeElement.textContent).toBe('start||end|click');\n      fixture.componentInstance.click();\n      fixture.detectChanges();\n      expect(fixture.nativeElement.textContent).toBe('start|dynamic|end|click');\n    });\n    // https://github.com/angular/angular/issues/33679\n    it('should insert embedded views into ViewContainerRef injected by querying <ng-container>', () => {\n      @Component({\n        selector: 'app-root',\n        template: `\n        <div>container start|</div>\n        <ng-container #container></ng-container>\n        <div>|container end</div>\n        <ng-template #template >test</ng-template>\n        <div (click)=\"click()\" >|click</div>\n        `,\n        standalone: false,\n      })\n      class AppComponent {\n        @ViewChild('container', {read: ViewContainerRef, static: true}) vcr!: ViewContainerRef;\n        @ViewChild('template', {read: TemplateRef, static: true}) template!: TemplateRef<any>;\n        click() {\n          this.vcr.createEmbeddedView(this.template, undefined, 0);\n        }\n      }\n      TestBed.configureTestingModule({\n        declarations: [AppComponent],\n      });\n      const fixture = TestBed.createComponent(AppComponent);\n      fixture.detectChanges();\n      expect(fixture.nativeElement.textContent).toBe('container start||container end|click');\n      fixture.componentInstance.click();\n      fixture.detectChanges();\n      expect(fixture.nativeElement.textContent).toBe('container start|test|container end|click');\n    });\n    it('should properly insert before views in a ViewContainerRef injected on ng-container', () => {\n      @Component({\n        selector: 'app-root',\n        template: `\n          <ng-template #parameterListItem let-parameter=\"parameter\">\n            {{parameter}}\n          </ng-template>\n          <ng-container *ngFor=\"let parameter of items;\"\n            [ngTemplateOutlet]=\"parameterListItem\"\n            [ngTemplateOutletContext]=\"{parameter:parameter}\">\n          </ng-container>\n        `,\n        standalone: false,\n      })\n      class AppComponent {\n        items = [1];\n      }\n      TestBed.configureTestingModule({\n        declarations: [AppComponent],\n        imports: [CommonModule],\n      });\n      const fixture = TestBed.createComponent(AppComponent);\n      fixture.detectChanges();\n      expect(fixture.nativeElement.textContent.trim()).toContain('1');\n      fixture.componentInstance.items = [2, 1];\n      fixture.detectChanges();\n      expect(fixture.nativeElement.textContent.trim()).toContain('2  1');\n    });\n  }"
        },
        {
          "type": "function",
          "name": "%AM36$%AM35$%AM34$%AM0",
          "label": "%AM36$%AM35$%AM34$%AM0",
          "start_line": 1,
          "end_line": 684,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\ninstanceinvoke TestBed.<@%unk/%unk: .createComponent()>(TestCmpt)\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n        TestBed.createComponent(TestCmpt);\n      }"
        },
        {
          "type": "function",
          "name": "%AM37$%AM35$%AM34$%AM0",
          "label": "%AM37$%AM35$%AM34$%AM0",
          "start_line": 1,
          "end_line": 684,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\ninstanceinvoke TestBed.<@%unk/%unk: .createComponent()>(TestCmpt)\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n        TestBed.createComponent(TestCmpt);\n      }"
        },
        {
          "type": "function",
          "name": "%AM35$%AM34$%AM0",
          "label": "%AM35$%AM34$%AM0",
          "start_line": 1,
          "end_line": 684,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\n%0 = new @ts_files/197.ts: %AC$%dflt$%AM35$%AM34$%AM0$11\ninstanceinvoke %0.<@ts_files/197.ts: %AC$%dflt$%AM35$%AM34$%AM0$11.constructor()>()\ninstanceinvoke TestBed.<@%unk/%unk: .configureTestingModule()>(%0)\n%1 = staticinvoke <@%unk/%unk: .expect()>(%AM36$%AM35$%AM34$%AM0)\ninstanceinvoke %1.<@%unk/%unk: .toThrowError()>('Error in a constructor')\n%2 = staticinvoke <@%unk/%unk: .expect()>(%AM37$%AM35$%AM34$%AM0)\ninstanceinvoke %2.<@%unk/%unk: .toThrowError()>('Error in a constructor')\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      @Directive({\n        selector: '[failInConstructorAlways]',\n        standalone: false,\n      })\n      class FailInConstructorAlways {\n        constructor() {\n          throw new Error('Error in a constructor');\n        }\n      }\n      @Component({\n        template: `<div failInConstructorAlways></div>`,\n        standalone: false,\n      })\n      class TestCmpt {}\n      TestBed.configureTestingModule({\n        declarations: [TestCmpt, FailInConstructorAlways],\n      });\n      expect(() => {\n        TestBed.createComponent(TestCmpt);\n      }).toThrowError('Error in a constructor');\n      expect(() => {\n        TestBed.createComponent(TestCmpt);\n      }).toThrowError('Error in a constructor');\n    }"
        },
        {
          "type": "function",
          "name": "%AM39$%AM38$%AM34$%AM0",
          "label": "%AM39$%AM38$%AM34$%AM0",
          "start_line": 1,
          "end_line": 684,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\ninstanceinvoke TestBed.<@%unk/%unk: .createComponent()>(TestCmpt)\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n        TestBed.createComponent(TestCmpt);\n      }"
        },
        {
          "type": "function",
          "name": "%AM38$%AM34$%AM0",
          "label": "%AM38$%AM34$%AM0",
          "start_line": 1,
          "end_line": 684,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\nfirstRun = true\n%0 = new @ts_files/197.ts: %AC$%dflt$%AM38$%AM34$%AM0$12\ninstanceinvoke %0.<@ts_files/197.ts: %AC$%dflt$%AM38$%AM34$%AM0$12.constructor()>()\ninstanceinvoke TestBed.<@%unk/%unk: .configureTestingModule()>(%0)\n%1 = staticinvoke <@%unk/%unk: .expect()>(%AM39$%AM38$%AM34$%AM0)\ninstanceinvoke %1.<@%unk/%unk: .toThrowError()>('Error in a constructor')\nfixture = instanceinvoke TestBed.<@%unk/%unk: .createComponent()>(TestCmpt)\n%2 = fixture.<@%unk/%unk: .nativeElement>\n%3 = %2.<@%unk/%unk: .textContent>\n%4 = staticinvoke <@%unk/%unk: .expect()>(%3)\ninstanceinvoke %4.<@%unk/%unk: .toContain()>('OK')\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      let firstRun = true;\n      @Directive({\n        selector: '[failInConstructorOnce]',\n        standalone: false,\n      })\n      class FailInConstructorOnce {\n        constructor() {\n          if (firstRun) {\n            firstRun = false;\n            throw new Error('Error in a constructor');\n          }\n        }\n      }\n      @Component({\n        template: `<div failInConstructorOnce>OK</div>`,\n        standalone: false,\n      })\n      class TestCmpt {}\n      TestBed.configureTestingModule({\n        declarations: [TestCmpt, FailInConstructorOnce],\n      });\n      expect(() => {\n        TestBed.createComponent(TestCmpt);\n      }).toThrowError('Error in a constructor');\n      const fixture = TestBed.createComponent(TestCmpt);\n      expect(fixture.nativeElement.textContent).toContain('OK');\n    }"
        },
        {
          "type": "function",
          "name": "%AM41$%AM40$%AM34$%AM0",
          "label": "%AM41$%AM40$%AM34$%AM0",
          "start_line": 1,
          "end_line": 684,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\ninstanceinvoke TestBed.<@%unk/%unk: .createComponent()>(TestCmpt)\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n        TestBed.createComponent(TestCmpt);\n      }"
        },
        {
          "type": "function",
          "name": "%AM42$%AM40$%AM34$%AM0",
          "label": "%AM42$%AM40$%AM34$%AM0",
          "start_line": 1,
          "end_line": 684,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\ninstanceinvoke TestBed.<@%unk/%unk: .createComponent()>(TestCmpt)\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n        TestBed.createComponent(TestCmpt);\n      }"
        },
        {
          "type": "function",
          "name": "%AM40$%AM34$%AM0",
          "label": "%AM40$%AM34$%AM0",
          "start_line": 1,
          "end_line": 684,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\n%0 = new @ts_files/197.ts: %AC$%dflt$%AM40$%AM34$%AM0$13\ninstanceinvoke %0.<@ts_files/197.ts: %AC$%dflt$%AM40$%AM34$%AM0$13.constructor()>()\ninstanceinvoke TestBed.<@%unk/%unk: .configureTestingModule()>(%0)\n%1 = staticinvoke <@%unk/%unk: .expect()>(%AM41$%AM40$%AM34$%AM0)\ninstanceinvoke %1.<@%unk/%unk: .toThrowError()>('Error in an input')\n%2 = staticinvoke <@%unk/%unk: .expect()>(%AM42$%AM40$%AM34$%AM0)\ninstanceinvoke %2.<@%unk/%unk: .toThrowError()>('Error in an input')\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      @Directive({\n        selector: '[failInInputAlways]',\n        standalone: false,\n      })\n      class FailInInputAlways {\n        @Input()\n        set failInInputAlways(_: string) {\n          throw new Error('Error in an input');\n        }\n      }\n      @Component({\n        template: `<div failInInputAlways=\"static\"></div>`,\n        standalone: false,\n      })\n      class TestCmpt {}\n      TestBed.configureTestingModule({\n        declarations: [TestCmpt, FailInInputAlways],\n      });\n      expect(() => {\n        TestBed.createComponent(TestCmpt);\n      }).toThrowError('Error in an input');\n      expect(() => {\n        TestBed.createComponent(TestCmpt);\n      }).toThrowError('Error in an input');\n    }"
        },
        {
          "type": "function",
          "name": "%AM44$%AM43$%AM34$%AM0",
          "label": "%AM44$%AM43$%AM34$%AM0",
          "start_line": 1,
          "end_line": 684,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\ninstanceinvoke TestBed.<@%unk/%unk: .createComponent()>(TestCmpt)\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n        TestBed.createComponent(TestCmpt);\n      }"
        },
        {
          "type": "function",
          "name": "%AM45$%AM43$%AM34$%AM0",
          "label": "%AM45$%AM43$%AM34$%AM0",
          "start_line": 1,
          "end_line": 684,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\ninstanceinvoke TestBed.<@%unk/%unk: .createComponent()>(TestCmpt)\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n        TestBed.createComponent(TestCmpt);\n      }"
        },
        {
          "type": "function",
          "name": "%AM43$%AM34$%AM0",
          "label": "%AM43$%AM34$%AM0",
          "start_line": 1,
          "end_line": 684,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\n%0 = new @ts_files/197.ts: %AC$%dflt$%AM43$%AM34$%AM0$14\ninstanceinvoke %0.<@ts_files/197.ts: %AC$%dflt$%AM43$%AM34$%AM0$14.constructor()>()\ninstanceinvoke TestBed.<@%unk/%unk: .configureTestingModule()>(%0)\n%1 = staticinvoke <@%unk/%unk: .expect()>(%AM44$%AM43$%AM34$%AM0)\ninstanceinvoke %1.<@%unk/%unk: .toThrowError()>('Error in static query setter')\n%2 = staticinvoke <@%unk/%unk: .expect()>(%AM45$%AM43$%AM34$%AM0)\ninstanceinvoke %2.<@%unk/%unk: .toThrowError()>('Error in static query setter')\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      @Directive({\n        selector: '[someDir]',\n        standalone: false,\n      })\n      class SomeDirective {}\n      @Component({\n        template: `<div someDir></div>`,\n        standalone: false,\n      })\n      class TestCmpt {\n        @ViewChild(SomeDirective, {static: true})\n        set directive(_: SomeDirective) {\n          throw new Error('Error in static query setter');\n        }\n      }\n      TestBed.configureTestingModule({\n        declarations: [TestCmpt, SomeDirective],\n      });\n      expect(() => {\n        TestBed.createComponent(TestCmpt);\n      }).toThrowError('Error in static query setter');\n      expect(() => {\n        TestBed.createComponent(TestCmpt);\n      }).toThrowError('Error in static query setter');\n    }"
        },
        {
          "type": "function",
          "name": "%AM47$%AM46$%AM34$%AM0",
          "label": "%AM47$%AM46$%AM34$%AM0",
          "start_line": 1,
          "end_line": 698,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\ninstanceinvoke TestBed.<@%unk/%unk: .createComponent()>(TestCmpt)\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n        TestBed.createComponent(TestCmpt);\n      }"
        },
        {
          "type": "function",
          "name": "%AM46$%AM34$%AM0",
          "label": "%AM46$%AM34$%AM0",
          "start_line": 1,
          "end_line": 684,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\nhasThrown = false\n%0 = new @ts_files/197.ts: %AC$%dflt$%AM46$%AM34$%AM0$15\ninstanceinvoke %0.<@ts_files/197.ts: %AC$%dflt$%AM46$%AM34$%AM0$15.constructor()>()\ninstanceinvoke TestBed.<@%unk/%unk: .configureTestingModule()>(%0)\n%1 = staticinvoke <@%unk/%unk: .expect()>(%AM47$%AM46$%AM34$%AM0)\ninstanceinvoke %1.<@%unk/%unk: .toThrowError()>('Error in static query setter')\nfixture = instanceinvoke TestBed.<@%unk/%unk: .createComponent()>(TestCmpt)\n%2 = fixture.<@%unk/%unk: .componentInstance>\n%3 = %2.<@%unk/%unk: .directive>\n%4 = staticinvoke <@%unk/%unk: .expect()>(%3)\ninstanceinvoke %4.<@%unk/%unk: .toBeInstanceOf()>(SomeDirective)\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      let hasThrown = false;\n      @Directive({\n        selector: '[someDir]',\n        standalone: false,\n      })\n      class SomeDirective {}\n      @Component({\n        template: `<div someDir></div>`,\n        standalone: false,\n      })\n      class TestCmpt {\n        @ViewChild(SomeDirective, {static: true})\n        get directive() {\n          return this._directive;\n        }\n        set directive(directiveInstance: SomeDirective) {\n          if (!hasThrown) {\n            hasThrown = true;\n            throw new Error('Error in static query setter');\n          }\n          this._directive = directiveInstance;\n        }\n        private _directive!: SomeDirective;\n      }\n      TestBed.configureTestingModule({\n        declarations: [TestCmpt, SomeDirective],\n      });\n      expect(() => {\n        TestBed.createComponent(TestCmpt);\n      }).toThrowError('Error in static query setter');\n      const fixture = TestBed.createComponent(TestCmpt);\n      expect(fixture.componentInstance.directive).toBeInstanceOf(SomeDirective);\n    }"
        },
        {
          "type": "function",
          "name": "%AM49$%AM48$%AM34$%AM0",
          "label": "%AM49$%AM48$%AM34$%AM0",
          "start_line": 1,
          "end_line": 727,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\ninstanceinvoke TestBed.<@%unk/%unk: .createComponent()>(App)\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n        TestBed.createComponent(App);\n      }"
        },
        {
          "type": "function",
          "name": "%AM48$%AM34$%AM0",
          "label": "%AM48$%AM34$%AM0",
          "start_line": 1,
          "end_line": 704,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\nhasThrown = false\n%0 = new @ts_files/197.ts: %AC$%dflt$%AM48$%AM34$%AM0$16\ninstanceinvoke %0.<@ts_files/197.ts: %AC$%dflt$%AM48$%AM34$%AM0$16.constructor()>()\ninstanceinvoke TestBed.<@%unk/%unk: .configureTestingModule()>(%0)\n%1 = staticinvoke <@%unk/%unk: .expect()>(%AM49$%AM48$%AM34$%AM0)\ninstanceinvoke %1.<@%unk/%unk: .toThrowError()>('Error in a constructor')\nfixture = instanceinvoke TestBed.<@%unk/%unk: .createComponent()>(App)\n%2 = fixture.<@%unk/%unk: .nativeElement>\n%3 = %2.<@%unk/%unk: .textContent>\n%4 = staticinvoke <@%unk/%unk: .expect()>(%3)\ninstanceinvoke %4.<@%unk/%unk: .toContain()>('OKOKOK')\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      let hasThrown = false;\n      @Component({\n        selector: 'test',\n        template: `<ng-content></ng-content>OK`,\n        standalone: false,\n      })\n      class TestCmpt {\n        constructor() {\n          if (!hasThrown) {\n            hasThrown = true;\n            throw new Error('Error in a constructor');\n          }\n        }\n      }\n      @Component({\n        template: `<test><test><test></test></test></test>`,\n        standalone: false,\n      })\n      class App {}\n      TestBed.configureTestingModule({\n        declarations: [App, TestCmpt],\n      });\n      expect(() => {\n        TestBed.createComponent(App);\n      }).toThrowError('Error in a constructor');\n      const fixture = TestBed.createComponent(App);\n      expect(fixture.nativeElement.textContent).toContain('OKOKOK');\n    }"
        },
        {
          "type": "function",
          "name": "%AM51$%AM50$%AM34$%AM0",
          "label": "%AM51$%AM50$%AM34$%AM0",
          "start_line": 1,
          "end_line": 757,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\ninstanceinvoke TestBed.<@%unk/%unk: .createComponent()>(TestCmpt)\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n        TestBed.createComponent(TestCmpt);\n      }"
        },
        {
          "type": "function",
          "name": "%AM50$%AM34$%AM0",
          "label": "%AM50$%AM34$%AM0",
          "start_line": 1,
          "end_line": 733,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\nfirstRun = true\n%0 = new @ts_files/197.ts: %AC$%dflt$%AM50$%AM34$%AM0$17\ninstanceinvoke %0.<@ts_files/197.ts: %AC$%dflt$%AM50$%AM34$%AM0$17.constructor()>()\ninstanceinvoke TestBed.<@%unk/%unk: .configureTestingModule()>(%0)\n%1 = staticinvoke <@%unk/%unk: .expect()>(%AM51$%AM50$%AM34$%AM0)\ninstanceinvoke %1.<@%unk/%unk: .toThrowError()>('Error in a constructor')\nfixture = instanceinvoke TestBed.<@%unk/%unk: .createComponent()>(TestCmpt)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%2 = fixture.<@%unk/%unk: .nativeElement>\n%3 = %2.<@%unk/%unk: .textContent>\n%4 = staticinvoke <@%unk/%unk: .expect()>(%3)\ninstanceinvoke %4.<@%unk/%unk: .toContain()>('0')\n%5 = fixture.<@%unk/%unk: .componentInstance>\n%5.<@%unk/%unk: .value> = 1\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%6 = fixture.<@%unk/%unk: .nativeElement>\n%7 = %6.<@%unk/%unk: .textContent>\n%8 = staticinvoke <@%unk/%unk: .expect()>(%7)\ninstanceinvoke %8.<@%unk/%unk: .toContain()>('1')\n%9 = fixture.<@%unk/%unk: .componentInstance>\n%9.<@%unk/%unk: .value> = 2\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%10 = fixture.<@%unk/%unk: .nativeElement>\n%11 = %10.<@%unk/%unk: .textContent>\n%12 = staticinvoke <@%unk/%unk: .expect()>(%11)\ninstanceinvoke %12.<@%unk/%unk: .toContain()>('2')\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      let firstRun = true;\n      @Directive({\n        selector: '[failInConstructorOnce]',\n        standalone: false,\n      })\n      class FailInConstructorOnce {\n        constructor() {\n          if (firstRun) {\n            firstRun = false;\n            throw new Error('Error in a constructor');\n          }\n        }\n      }\n      @Component({\n        template: `<div failInConstructorOnce>{{value}}</div>`,\n        standalone: false,\n      })\n      class TestCmpt {\n        value = 0;\n      }\n      TestBed.configureTestingModule({\n        declarations: [TestCmpt, FailInConstructorOnce],\n      });\n      expect(() => {\n        TestBed.createComponent(TestCmpt);\n      }).toThrowError('Error in a constructor');\n      const fixture = TestBed.createComponent(TestCmpt);\n      fixture.detectChanges();\n      expect(fixture.nativeElement.textContent).toContain('0');\n      fixture.componentInstance.value = 1;\n      fixture.detectChanges();\n      expect(fixture.nativeElement.textContent).toContain('1');\n      fixture.componentInstance.value = 2;\n      fixture.detectChanges();\n      expect(fixture.nativeElement.textContent).toContain('2');\n    }"
        },
        {
          "type": "function",
          "name": "%AM53$%AM52$%AM34$%AM0",
          "label": "%AM53$%AM52$%AM34$%AM0",
          "start_line": 1,
          "end_line": 798,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\n%0 = fixture.<@%unk/%unk: .componentInstance>\ninstanceinvoke %0.<@%unk/%unk: .insertTemplate()>()\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n        fixture.componentInstance.insertTemplate();\n        fixture.detectChanges();\n      }"
        },
        {
          "type": "function",
          "name": "%AM52$%AM34$%AM0",
          "label": "%AM52$%AM34$%AM0",
          "start_line": 1,
          "end_line": 770,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\n%0 = new @ts_files/197.ts: %AC$%dflt$%AM52$%AM34$%AM0$18\ninstanceinvoke %0.<@ts_files/197.ts: %AC$%dflt$%AM52$%AM34$%AM0$18.constructor()>()\ninstanceinvoke TestBed.<@%unk/%unk: .configureTestingModule()>(%0)\nfixture = instanceinvoke TestBed.<@%unk/%unk: .createComponent()>(App)\ntryRender = %AM53$%AM52$%AM34$%AM0\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%1 = staticinvoke <@%unk/%unk: .expect()>(tryRender)\ninstanceinvoke %1.<@%unk/%unk: .toThrowError()>(/No provider for DoesNotExist/)\n%2 = staticinvoke <@%unk/%unk: .expect()>(tryRender)\ninstanceinvoke %2.<@%unk/%unk: .toThrowError()>(/No provider for DoesNotExist/)\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      // Intentionally hasn't been added to `providers` so that it throws a DI error.\n      @Injectable()\n      class DoesNotExist {}\n      @Directive({\n        selector: 'dir',\n        standalone: false,\n      })\n      class Dir {\n        constructor(willCauseError: DoesNotExist) {}\n      }\n      @Component({\n        template: `\n          <ng-template #broken>\n            <dir></dir>\n          </ng-template>\n        `,\n        standalone: false,\n      })\n      class App {\n        @ViewChild('broken') template!: TemplateRef<unknown>;\n        constructor(private _viewContainerRef: ViewContainerRef) {}\n        insertTemplate() {\n          this._viewContainerRef.createEmbeddedView(this.template);\n        }\n      }\n      TestBed.configureTestingModule({declarations: [App, Dir]});\n      const fixture = TestBed.createComponent(App);\n      const tryRender = () => {\n        fixture.componentInstance.insertTemplate();\n        fixture.detectChanges();\n      };\n      fixture.detectChanges();\n      // We try to render the same template twice to ensure that we get consistent error messages.\n      expect(tryRender).toThrowError(/No provider for DoesNotExist/);\n      expect(tryRender).toThrowError(/No provider for DoesNotExist/);\n    }"
        },
        {
          "type": "function",
          "name": "%AM34$%AM0",
          "label": "%AM34$%AM0",
          "start_line": 1,
          "end_line": 684,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\nstaticinvoke <@%unk/%unk: .it()>('should consistently report errors raised a directive constructor', %AM35$%AM34$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should render even if a directive constructor throws in the first create pass', %AM38$%AM34$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should consistently report errors raised a directive input setter', %AM40$%AM34$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should consistently report errors raised a static query setter', %AM43$%AM34$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should match a static query, even if its setter throws in the first create pass', %AM46$%AM34$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should render a recursive component if it throws during the first creation pass', %AM48$%AM34$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should continue detecting changes if a directive throws in its constructor', %AM50$%AM34$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should consistently report errors raised by createEmbeddedView', %AM52$%AM34$%AM0)\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n    it('should consistently report errors raised a directive constructor', () => {\n      @Directive({\n        selector: '[failInConstructorAlways]',\n        standalone: false,\n      })\n      class FailInConstructorAlways {\n        constructor() {\n          throw new Error('Error in a constructor');\n        }\n      }\n      @Component({\n        template: `<div failInConstructorAlways></div>`,\n        standalone: false,\n      })\n      class TestCmpt {}\n      TestBed.configureTestingModule({\n        declarations: [TestCmpt, FailInConstructorAlways],\n      });\n      expect(() => {\n        TestBed.createComponent(TestCmpt);\n      }).toThrowError('Error in a constructor');\n      expect(() => {\n        TestBed.createComponent(TestCmpt);\n      }).toThrowError('Error in a constructor');\n    });\n    it('should render even if a directive constructor throws in the first create pass', () => {\n      let firstRun = true;\n      @Directive({\n        selector: '[failInConstructorOnce]',\n        standalone: false,\n      })\n      class FailInConstructorOnce {\n        constructor() {\n          if (firstRun) {\n            firstRun = false;\n            throw new Error('Error in a constructor');\n          }\n        }\n      }\n      @Component({\n        template: `<div failInConstructorOnce>OK</div>`,\n        standalone: false,\n      })\n      class TestCmpt {}\n      TestBed.configureTestingModule({\n        declarations: [TestCmpt, FailInConstructorOnce],\n      });\n      expect(() => {\n        TestBed.createComponent(TestCmpt);\n      }).toThrowError('Error in a constructor');\n      const fixture = TestBed.createComponent(TestCmpt);\n      expect(fixture.nativeElement.textContent).toContain('OK');\n    });\n    it('should consistently report errors raised a directive input setter', () => {\n      @Directive({\n        selector: '[failInInputAlways]',\n        standalone: false,\n      })\n      class FailInInputAlways {\n        @Input()\n        set failInInputAlways(_: string) {\n          throw new Error('Error in an input');\n        }\n      }\n      @Component({\n        template: `<div failInInputAlways=\"static\"></div>`,\n        standalone: false,\n      })\n      class TestCmpt {}\n      TestBed.configureTestingModule({\n        declarations: [TestCmpt, FailInInputAlways],\n      });\n      expect(() => {\n        TestBed.createComponent(TestCmpt);\n      }).toThrowError('Error in an input');\n      expect(() => {\n        TestBed.createComponent(TestCmpt);\n      }).toThrowError('Error in an input');\n    });\n    it('should consistently report errors raised a static query setter', () => {\n      @Directive({\n        selector: '[someDir]',\n        standalone: false,\n      })\n      class SomeDirective {}\n      @Component({\n        template: `<div someDir></div>`,\n        standalone: false,\n      })\n      class TestCmpt {\n        @ViewChild(SomeDirective, {static: true})\n        set directive(_: SomeDirective) {\n          throw new Error('Error in static query setter');\n        }\n      }\n      TestBed.configureTestingModule({\n        declarations: [TestCmpt, SomeDirective],\n      });\n      expect(() => {\n        TestBed.createComponent(TestCmpt);\n      }).toThrowError('Error in static query setter');\n      expect(() => {\n        TestBed.createComponent(TestCmpt);\n      }).toThrowError('Error in static query setter');\n    });\n    it('should match a static query, even if its setter throws in the first create pass', () => {\n      let hasThrown = false;\n      @Directive({\n        selector: '[someDir]',\n        standalone: false,\n      })\n      class SomeDirective {}\n      @Component({\n        template: `<div someDir></div>`,\n        standalone: false,\n      })\n      class TestCmpt {\n        @ViewChild(SomeDirective, {static: true})\n        get directive() {\n          return this._directive;\n        }\n        set directive(directiveInstance: SomeDirective) {\n          if (!hasThrown) {\n            hasThrown = true;\n            throw new Error('Error in static query setter');\n          }\n          this._directive = directiveInstance;\n        }\n        private _directive!: SomeDirective;\n      }\n      TestBed.configureTestingModule({\n        declarations: [TestCmpt, SomeDirective],\n      });\n      expect(() => {\n        TestBed.createComponent(TestCmpt);\n      }).toThrowError('Error in static query setter');\n      const fixture = TestBed.createComponent(TestCmpt);\n      expect(fixture.componentInstance.directive).toBeInstanceOf(SomeDirective);\n    });\n    it('should render a recursive component if it throws during the first creation pass', () => {\n      let hasThrown = false;\n      @Component({\n        selector: 'test',\n        template: `<ng-content></ng-content>OK`,\n        standalone: false,\n      })\n      class TestCmpt {\n        constructor() {\n          if (!hasThrown) {\n            hasThrown = true;\n            throw new Error('Error in a constructor');\n          }\n        }\n      }\n      @Component({\n        template: `<test><test><test></test></test></test>`,\n        standalone: false,\n      })\n      class App {}\n      TestBed.configureTestingModule({\n        declarations: [App, TestCmpt],\n      });\n      expect(() => {\n        TestBed.createComponent(App);\n      }).toThrowError('Error in a constructor');\n      const fixture = TestBed.createComponent(App);\n      expect(fixture.nativeElement.textContent).toContain('OKOKOK');\n    });\n    it('should continue detecting changes if a directive throws in its constructor', () => {\n      let firstRun = true;\n      @Directive({\n        selector: '[failInConstructorOnce]',\n        standalone: false,\n      })\n      class FailInConstructorOnce {\n        constructor() {\n          if (firstRun) {\n            firstRun = false;\n            throw new Error('Error in a constructor');\n          }\n        }\n      }\n      @Component({\n        template: `<div failInConstructorOnce>{{value}}</div>`,\n        standalone: false,\n      })\n      class TestCmpt {\n        value = 0;\n      }\n      TestBed.configureTestingModule({\n        declarations: [TestCmpt, FailInConstructorOnce],\n      });\n      expect(() => {\n        TestBed.createComponent(TestCmpt);\n      }).toThrowError('Error in a constructor');\n      const fixture = TestBed.createComponent(TestCmpt);\n      fixture.detectChanges();\n      expect(fixture.nativeElement.textContent).toContain('0');\n      fixture.componentInstance.value = 1;\n      fixture.detectChanges();\n      expect(fixture.nativeElement.textContent).toContain('1');\n      fixture.componentInstance.value = 2;\n      fixture.detectChanges();\n      expect(fixture.nativeElement.textContent).toContain('2');\n    });\n    it('should consistently report errors raised by createEmbeddedView', () => {\n      // Intentionally hasn't been added to `providers` so that it throws a DI error.\n      @Injectable()\n      class DoesNotExist {}\n      @Directive({\n        selector: 'dir',\n        standalone: false,\n      })\n      class Dir {\n        constructor(willCauseError: DoesNotExist) {}\n      }\n      @Component({\n        template: `\n          <ng-template #broken>\n            <dir></dir>\n          </ng-template>\n        `,\n        standalone: false,\n      })\n      class App {\n        @ViewChild('broken') template!: TemplateRef<unknown>;\n        constructor(private _viewContainerRef: ViewContainerRef) {}\n        insertTemplate() {\n          this._viewContainerRef.createEmbeddedView(this.template);\n        }\n      }\n      TestBed.configureTestingModule({declarations: [App, Dir]});\n      const fixture = TestBed.createComponent(App);\n      const tryRender = () => {\n        fixture.componentInstance.insertTemplate();\n        fixture.detectChanges();\n      };\n      fixture.detectChanges();\n      // We try to render the same template twice to ensure that we get consistent error messages.\n      expect(tryRender).toThrowError(/No provider for DoesNotExist/);\n      expect(tryRender).toThrowError(/No provider for DoesNotExist/);\n    });\n  }"
        },
        {
          "type": "function",
          "name": "%AM0",
          "label": "%AM0",
          "start_line": 1,
          "end_line": 684,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/197.ts: %dflt\nstaticinvoke <@%unk/%unk: .describe()>('of a simple template', %AM1$%AM0)\nstaticinvoke <@%unk/%unk: .describe()>('of an empty template', %AM3$%AM0)\nstaticinvoke <@%unk/%unk: .describe()>('of an ng-content projection', %AM5$%AM0)\nstaticinvoke <@%unk/%unk: .describe()>('of another container like ngIf', %AM7$%AM0)\nstaticinvoke <@%unk/%unk: .describe()>('before another view', %AM9$%AM0)\nstaticinvoke <@%unk/%unk: .describe()>('non-regression', %AM30$%AM0)\nstaticinvoke <@%unk/%unk: .describe()>('create mode error handling', %AM34$%AM0)\nreturn",
              "start_line": 1,
              "end_line": 684,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n  describe('of a simple template', () => {\n    it('should insert into an empty container, at the front, in the middle, and at the end', () => {\n      let _counter = 0;\n      @Component({\n        selector: 'increment-comp',\n        template: `<span>created{{counter}}</span>`,\n        standalone: false,\n      })\n      class IncrementComp {\n        counter = _counter++;\n      }\n      @Component({\n        template: `\n              <ng-template #simple><increment-comp></increment-comp></ng-template>\n              <div #container></div>\n            `,\n        standalone: false,\n      })\n      class App {\n        @ViewChild('container', {read: ViewContainerRef, static: true})\n        container: ViewContainerRef = null!;\n        @ViewChild('simple', {read: TemplateRef, static: true}) simple: TemplateRef<any> = null!;\n        view0: EmbeddedViewRef<any> = null!;\n        view1: EmbeddedViewRef<any> = null!;\n        view2: EmbeddedViewRef<any> = null!;\n        view3: EmbeddedViewRef<any> = null!;\n        constructor(public changeDetector: ChangeDetectorRef) {}\n        ngAfterViewInit() {\n          // insert at the front\n          this.view1 = this.container.createEmbeddedView(this.simple); // \"created0\"\n          // insert at the front again\n          this.view0 = this.container.createEmbeddedView(this.simple, {}, 0); // \"created1\"\n          // insert at the end\n          this.view3 = this.container.createEmbeddedView(this.simple); // \"created2\"\n          // insert in the middle\n          this.view2 = this.container.createEmbeddedView(this.simple, {}, 2); // \"created3\"\n          // We need to run change detection here to avoid\n          // ExpressionChangedAfterItHasBeenCheckedError because of the value updating in\n          // increment-comp\n          this.changeDetector.detectChanges();\n        }\n      }\n      TestBed.configureTestingModule({\n        declarations: [App, IncrementComp],\n      });\n      const fixture = TestBed.createComponent(App);\n      fixture.detectChanges();\n      const app = fixture.componentInstance;\n      expect(app.container.indexOf(app.view0)).toBe(0);\n      expect(app.container.indexOf(app.view1)).toBe(1);\n      expect(app.container.indexOf(app.view2)).toBe(2);\n      expect(app.container.indexOf(app.view3)).toBe(3);\n      // The text in each component differs based on *when* it was created.\n      expect(fixture.nativeElement.textContent).toBe('created1created0created3created2');\n    });\n  });\n  describe('of an empty template', () => {\n    it('should insert into an empty container, at the front, in the middle, and at the end', () => {\n      @Component({\n        template: `\n              <ng-template #empty></ng-template>\n              <div #container></div>\n            `,\n        standalone: false,\n      })\n      class App {\n        @ViewChild('container', {read: ViewContainerRef}) container: ViewContainerRef = null!;\n        @ViewChild('empty', {read: TemplateRef}) empty: TemplateRef<any> = null!;\n        view0: EmbeddedViewRef<any> = null!;\n        view1: EmbeddedViewRef<any> = null!;\n        view2: EmbeddedViewRef<any> = null!;\n        view3: EmbeddedViewRef<any> = null!;\n        ngAfterViewInit() {\n          // insert at the front\n          this.view1 = this.container.createEmbeddedView(this.empty);\n          // insert at the front again\n          this.view0 = this.container.createEmbeddedView(this.empty, {}, 0);\n          // insert at the end\n          this.view3 = this.container.createEmbeddedView(this.empty);\n          // insert in the middle\n          this.view2 = this.container.createEmbeddedView(this.empty, {}, 2);\n        }\n      }\n      TestBed.configureTestingModule({\n        declarations: [App],\n      });\n      const fixture = TestBed.createComponent(App);\n      fixture.detectChanges();\n      const app = fixture.componentInstance;\n      expect(app.container.indexOf(app.view0)).toBe(0);\n      expect(app.container.indexOf(app.view1)).toBe(1);\n      expect(app.container.indexOf(app.view2)).toBe(2);\n      expect(app.container.indexOf(app.view3)).toBe(3);\n    });\n  });\n  describe('of an ng-content projection', () => {\n    it('should insert into an empty container, at the front, in the middle, and at the end', () => {\n      @Component({\n        selector: 'comp',\n        template: `\n                  <ng-template #projection><ng-content></ng-content></ng-template>\n                  <div #container></div>\n                `,\n        standalone: false,\n      })\n      class Comp {\n        @ViewChild('container', {read: ViewContainerRef}) container: ViewContainerRef = null!;\n        @ViewChild('projection', {read: TemplateRef}) projection: TemplateRef<any> = null!;\n        view0: EmbeddedViewRef<any> = null!;\n        view1: EmbeddedViewRef<any> = null!;\n        view2: EmbeddedViewRef<any> = null!;\n        view3: EmbeddedViewRef<any> = null!;\n        ngAfterViewInit() {\n          // insert at the front\n          this.view1 = this.container.createEmbeddedView(this.projection);\n          // insert at the front again\n          this.view0 = this.container.createEmbeddedView(this.projection, {}, 0);\n          // insert at the end\n          this.view3 = this.container.createEmbeddedView(this.projection);\n          // insert in the middle\n          this.view2 = this.container.createEmbeddedView(this.projection, {}, 2);\n        }\n      }\n      @Component({\n        template: `\n          <comp>test</comp>\n        `,\n        standalone: false,\n      })\n      class App {}\n      TestBed.configureTestingModule({\n        declarations: [App, Comp],\n      });\n      const fixture = TestBed.createComponent(App);\n      fixture.detectChanges();\n      const comp = fixture.debugElement.query(By.directive(Comp)).injector.get(Comp);\n      expect(comp.container.indexOf(comp.view0)).toBe(0);\n      expect(comp.container.indexOf(comp.view1)).toBe(1);\n      expect(comp.container.indexOf(comp.view2)).toBe(2);\n      expect(comp.container.indexOf(comp.view3)).toBe(3);\n      // Both ViewEngine and Ivy only honor one of the inserted ng-content components, even though\n      // all are inserted.\n      expect(fixture.nativeElement.textContent).toBe('test');\n    });\n  });\n  describe('of another container like ngIf', () => {\n    it('should insert into an empty container, at the front, in the middle, and at the end', () => {\n      @Component({\n        template: `\n                  <ng-template #subContainer><div class=\"dynamic\" *ngIf=\"true\">test</div></ng-template>\n                  <div #container></div>\n                `,\n        standalone: false,\n      })\n      class App {\n        @ViewChild('container', {read: ViewContainerRef}) container: ViewContainerRef = null!;\n        @ViewChild('subContainer', {read: TemplateRef}) subContainer: TemplateRef<any> = null!;\n        view0: EmbeddedViewRef<any> = null!;\n        view1: EmbeddedViewRef<any> = null!;\n        view2: EmbeddedViewRef<any> = null!;\n        view3: EmbeddedViewRef<any> = null!;\n        constructor(public changeDetectorRef: ChangeDetectorRef) {}\n        ngAfterViewInit() {\n          // insert at the front\n          this.view1 = this.container.createEmbeddedView(this.subContainer, null, 0);\n          // insert at the front again\n          this.view0 = this.container.createEmbeddedView(this.subContainer, null, 0);\n          // insert at the end\n          this.view3 = this.container.createEmbeddedView(this.subContainer, null, 2);\n          // insert in the middle\n          this.view2 = this.container.createEmbeddedView(this.subContainer, null, 2);\n          // We need to run change detection here to avoid\n          // ExpressionChangedAfterItHasBeenCheckedError because of the value getting passed to ngIf\n          // in the template.\n          this.changeDetectorRef.detectChanges();\n        }\n      }\n      TestBed.configureTestingModule({\n        declarations: [App],\n        imports: [CommonModule],\n      });\n      const fixture = TestBed.createComponent(App);\n      fixture.detectChanges();\n      const app = fixture.componentInstance;\n      expect(app.container.indexOf(app.view0)).toBe(0);\n      expect(app.container.indexOf(app.view1)).toBe(1);\n      expect(app.container.indexOf(app.view2)).toBe(2);\n      expect(app.container.indexOf(app.view3)).toBe(3);\n      expect(fixture.debugElement.queryAll(By.css('div.dynamic')).length).toBe(4);\n    });\n  });\n  describe('before another view', () => {\n    @Directive({\n      selector: '[viewInserting]',\n      exportAs: 'vi',\n      standalone: false,\n    })\n    class ViewInsertingDir {\n      constructor(private _vcRef: ViewContainerRef) {}\n      insert(beforeView: ViewRef, insertTpl: TemplateRef<{}>) {\n        this._vcRef.insert(beforeView, 0);\n        this._vcRef.createEmbeddedView(insertTpl, {}, 0);\n      }\n    }\n    describe('before embedded view', () => {\n      @Component({\n        selector: 'test-cmpt',\n        template: '',\n        standalone: false,\n      })\n      class TestCmpt {\n        @ViewChild('before', {static: true}) beforeTpl!: TemplateRef<{}>;\n        @ViewChild('insert', {static: true}) insertTpl!: TemplateRef<{}>;\n        @ViewChild('vi', {static: true}) viewInsertingDir!: ViewInsertingDir;\n        minutes = 10;\n        insert() {\n          const beforeView = this.beforeTpl.createEmbeddedView({});\n          // change-detect the \"before view\" to create all child views\n          beforeView.detectChanges();\n          this.viewInsertingDir.insert(beforeView, this.insertTpl);\n        }\n      }\n      beforeEach(() => {\n        TestBed.configureTestingModule({\n          declarations: [TestCmpt, ViewInsertingDir],\n          imports: [CommonModule],\n        });\n      });\n      function createAndInsertViews(beforeTpl: string): any {\n        TestBed.overrideTemplate(\n          TestCmpt,\n          `\n          <ng-template #insert>insert</ng-template>\n          <ng-template #before>${beforeTpl}</ng-template>\n          <div><ng-template #vi=\"vi\" viewInserting></ng-template></div>\n        `,\n        );\n        const fixture = TestBed.createComponent(TestCmpt);\n        fixture.detectChanges();\n        fixture.componentInstance.insert();\n        fixture.detectChanges();\n        return fixture.nativeElement;\n      }\n      it('should insert before a view with the text node as the first root node', () => {\n        expect(createAndInsertViews('|before').textContent).toBe('insert|before');\n      });\n      it('should insert before a view with the element as the first root node', () => {\n        expect(createAndInsertViews('<span>|before</span>').textContent).toBe('insert|before');\n      });\n      it('should insert before a view with the ng-container as the first root node', () => {\n        expect(\n          createAndInsertViews(`\n          <ng-container>\n            <ng-container>|before</ng-container>\n          </ng-container>\n        `).textContent,\n        ).toBe('insert|before');\n      });\n      it('should insert before a view with the empty ng-container as the first root node', () => {\n        expect(createAndInsertViews(`<ng-container></ng-container>|before`).textContent).toBe(\n          'insert|before',\n        );\n      });\n      it('should insert before a view with ICU container inside a ng-container as the first root node', () => {\n        expect(\n          createAndInsertViews(\n            `<ng-container i18n>{minutes, plural, =0 {just now} =1 {one minute ago} other {|before}}</ng-container>`,\n          ).textContent,\n        ).toBe('insert|before');\n      });\n      it('should insert before a view with a container as the first root node', () => {\n        expect(\n          createAndInsertViews(`<ng-template [ngIf]=\"true\">|before</ng-template>`).textContent,\n        ).toBe('insert|before');\n      });\n      it('should insert before a view with an empty container as the first root node', () => {\n        expect(\n          createAndInsertViews(`<ng-template [ngIf]=\"true\"></ng-template>|before`).textContent,\n        ).toBe('insert|before');\n      });\n      it('should insert before a view with a ng-container where ViewContainerRef is injected', () => {\n        expect(\n          createAndInsertViews(`\n          <ng-container [ngTemplateOutlet]=\"after\">|before</ng-container>\n          <ng-template #after>|after</ng-template>\n        `).textContent,\n        ).toBe('insert|before|after');\n      });\n      it('should insert before a view with an element where ViewContainerRef is injected', () => {\n        expect(\n          createAndInsertViews(`\n          <div [ngTemplateOutlet]=\"after\">|before</div>\n          <ng-template #after>|after</ng-template>\n        `).textContent,\n        ).toBe('insert|before|after');\n      });\n      it('should insert before a view with an empty projection as the first root node', () => {\n        expect(createAndInsertViews(`<ng-content></ng-content>|before`).textContent).toBe(\n          'insert|before',\n        );\n      });\n      it('should insert before a view with complex node structure', () => {\n        expect(\n          createAndInsertViews(`\n          <ng-template [ngIf]=\"true\">\n            <ng-container>\n              <ng-container>\n                <ng-template [ngIf]=\"true\">|before</ng-template>\n              </ng-container>\n            </ng-container>\n          </ng-template>\n        `).textContent,\n        ).toBe('insert|before');\n      });\n      it('should insert before a ng-container with a ViewContainerRef on it', () => {\n        @Component({\n          selector: 'app-root',\n          template: `\n            <div>start|</div>\n            <ng-container [ngTemplateOutlet]=\"insertTpl ? tpl : null\"></ng-container>\n            <ng-container [ngTemplateOutlet]=\"tpl\"></ng-container>\n            <div>|end</div>\n            <ng-template #tpl>test</ng-template>\n          `,\n          standalone: false,\n        })\n        class AppComponent {\n          insertTpl = false;\n        }\n        TestBed.configureTestingModule({\n          declarations: [AppComponent],\n          imports: [CommonModule],\n        });\n        const fixture = TestBed.createComponent(AppComponent);\n        fixture.detectChanges();\n        expect(fixture.nativeElement.textContent).toBe('start|test|end');\n        fixture.componentInstance.insertTpl = true;\n        fixture.detectChanges();\n        expect(fixture.nativeElement.textContent).toBe('start|testtest|end');\n      });\n    });\n    describe('before embedded view with projection', () => {\n      @Component({\n        selector: 'with-content',\n        template: `\n          <ng-template #insert>insert</ng-template>\n          <ng-template #before><ng-content></ng-content></ng-template>\n          <div><ng-template #vi=\"vi\" viewInserting></ng-template></div>\n        `,\n        standalone: false,\n      })\n      class WithContentCmpt {\n        @ViewChild('insert', {static: true}) insertTpl!: TemplateRef<{}>;\n        @ViewChild('before', {static: true}) beforeTpl!: TemplateRef<{}>;\n        @ViewChild('vi', {static: true}) viewInsertingDir!: ViewInsertingDir;\n        insert() {\n          const beforeView = this.beforeTpl.createEmbeddedView({});\n          // change-detect the \"before view\" to create all child views\n          beforeView.detectChanges();\n          this.viewInsertingDir.insert(beforeView, this.insertTpl);\n        }\n      }\n      @Component({\n        selector: 'test-cmpt',\n        template: '',\n        standalone: false,\n      })\n      class TestCmpt {\n        @ViewChild('wc', {static: true}) withContentCmpt!: WithContentCmpt;\n      }\n      beforeEach(() => {\n        TestBed.configureTestingModule({\n          declarations: [ViewInsertingDir, WithContentCmpt, TestCmpt],\n          imports: [CommonModule],\n        });\n      });\n      it('should insert before a view with projected text nodes', () => {\n        TestBed.overrideTemplate(TestCmpt, `<with-content #wc>|before</with-content>`);\n        const fixture = TestBed.createComponent(TestCmpt);\n        fixture.detectChanges();\n        fixture.componentInstance.withContentCmpt.insert();\n        fixture.detectChanges();\n        expect(fixture.nativeElement.textContent).toBe('insert|before');\n      });\n      it('should insert before a view with projected container', () => {\n        TestBed.overrideTemplate(\n          TestCmpt,\n          `<with-content #wc><ng-template [ngIf]=\"true\">|before</ng-template></with-content>`,\n        );\n        const fixture = TestBed.createComponent(TestCmpt);\n        fixture.detectChanges();\n        fixture.componentInstance.withContentCmpt.insert();\n        fixture.detectChanges();\n        expect(fixture.nativeElement.textContent).toBe('insert|before');\n      });\n    });\n    describe('before component view', () => {\n      @Directive({\n        selector: '[viewInserting]',\n        exportAs: 'vi',\n        standalone: false,\n      })\n      class ViewInsertingDir {\n        constructor(private _vcRef: ViewContainerRef) {}\n        insert(beforeView: ViewRef, insertTpl: TemplateRef<{}>) {\n          this._vcRef.insert(beforeView, 0);\n          this._vcRef.createEmbeddedView(insertTpl, {}, 0);\n        }\n      }\n      @Component({\n        selector: 'dynamic-cmpt',\n        template: '|before',\n        standalone: false,\n      })\n      class DynamicComponent {}\n      it('should insert in front a dynamic component view', () => {\n        @Component({\n          selector: 'test-cmpt',\n          template: `\n                <ng-template #insert>insert</ng-template>\n                <div><ng-template #vi=\"vi\" viewInserting></ng-template></div>\n              `,\n          standalone: false,\n        })\n        class TestCmpt {\n          @ViewChild('insert', {static: true}) insertTpl!: TemplateRef<{}>;\n          @ViewChild('vi', {static: true}) viewInsertingDir!: ViewInsertingDir;\n          constructor(\n            private _vcr: ViewContainerRef,\n            private _injector: Injector,\n          ) {}\n          insert() {\n            // create a dynamic component view to act as an \"insert before\" view\n            const beforeView = this._vcr.createComponent(DynamicComponent, {\n              injector: this._injector,\n            }).hostView;\n            // change-detect the \"before view\" to create all child views\n            beforeView.detectChanges();\n            this.viewInsertingDir.insert(beforeView, this.insertTpl);\n          }\n        }\n        TestBed.configureTestingModule({\n          declarations: [TestCmpt, ViewInsertingDir, DynamicComponent],\n        });\n        const fixture = TestBed.createComponent(TestCmpt);\n        fixture.detectChanges();\n        fixture.componentInstance.insert();\n        fixture.detectChanges();\n        expect(fixture.nativeElement.textContent).toBe('insert|before');\n      });\n    });\n  });\n  describe('non-regression', () => {\n    // https://github.com/angular/angular/issues/31971\n    it('should insert component views into ViewContainerRef injected by querying <ng-container>', () => {\n      @Component({\n        selector: 'dynamic-cmpt',\n        template: 'dynamic',\n        standalone: false,\n      })\n      class DynamicComponent {}\n      @Component({\n        selector: 'app-root',\n        template: `\n            <div>start|</div>\n            <ng-container #container></ng-container>\n            <div>|end</div>\n            <div (click)=\"click()\" >|click</div>\n        `,\n        standalone: false,\n      })\n      class AppComponent {\n        @ViewChild('container', {read: ViewContainerRef, static: true}) vcr!: ViewContainerRef;\n        click() {\n          this.vcr.createComponent(DynamicComponent);\n        }\n      }\n      TestBed.configureTestingModule({\n        declarations: [AppComponent, DynamicComponent],\n      });\n      const fixture = TestBed.createComponent(AppComponent);\n      fixture.detectChanges();\n      expect(fixture.nativeElement.textContent).toBe('start||end|click');\n      fixture.componentInstance.click();\n      fixture.detectChanges();\n      expect(fixture.nativeElement.textContent).toBe('start|dynamic|end|click');\n    });\n    // https://github.com/angular/angular/issues/33679\n    it('should insert embedded views into ViewContainerRef injected by querying <ng-container>', () => {\n      @Component({\n        selector: 'app-root',\n        template: `\n        <div>container start|</div>\n        <ng-container #container></ng-container>\n        <div>|container end</div>\n        <ng-template #template >test</ng-template>\n        <div (click)=\"click()\" >|click</div>\n        `,\n        standalone: false,\n      })\n      class AppComponent {\n        @ViewChild('container', {read: ViewContainerRef, static: true}) vcr!: ViewContainerRef;\n        @ViewChild('template', {read: TemplateRef, static: true}) template!: TemplateRef<any>;\n        click() {\n          this.vcr.createEmbeddedView(this.template, undefined, 0);\n        }\n      }\n      TestBed.configureTestingModule({\n        declarations: [AppComponent],\n      });\n      const fixture = TestBed.createComponent(AppComponent);\n      fixture.detectChanges();\n      expect(fixture.nativeElement.textContent).toBe('container start||container end|click');\n      fixture.componentInstance.click();\n      fixture.detectChanges();\n      expect(fixture.nativeElement.textContent).toBe('container start|test|container end|click');\n    });\n    it('should properly insert before views in a ViewContainerRef injected on ng-container', () => {\n      @Component({\n        selector: 'app-root',\n        template: `\n          <ng-template #parameterListItem let-parameter=\"parameter\">\n            {{parameter}}\n          </ng-template>\n          <ng-container *ngFor=\"let parameter of items;\"\n            [ngTemplateOutlet]=\"parameterListItem\"\n            [ngTemplateOutletContext]=\"{parameter:parameter}\">\n          </ng-container>\n        `,\n        standalone: false,\n      })\n      class AppComponent {\n        items = [1];\n      }\n      TestBed.configureTestingModule({\n        declarations: [AppComponent],\n        imports: [CommonModule],\n      });\n      const fixture = TestBed.createComponent(AppComponent);\n      fixture.detectChanges();\n      expect(fixture.nativeElement.textContent.trim()).toContain('1');\n      fixture.componentInstance.items = [2, 1];\n      fixture.detectChanges();\n      expect(fixture.nativeElement.textContent.trim()).toContain('2  1');\n    });\n  });\n  describe('create mode error handling', () => {\n    it('should consistently report errors raised a directive constructor', () => {\n      @Directive({\n        selector: '[failInConstructorAlways]',\n        standalone: false,\n      })\n      class FailInConstructorAlways {\n        constructor() {\n          throw new Error('Error in a constructor');\n        }\n      }\n      @Component({\n        template: `<div failInConstructorAlways></div>`,\n        standalone: false,\n      })\n      class TestCmpt {}\n      TestBed.configureTestingModule({\n        declarations: [TestCmpt, FailInConstructorAlways],\n      });\n      expect(() => {\n        TestBed.createComponent(TestCmpt);\n      }).toThrowError('Error in a constructor');\n      expect(() => {\n        TestBed.createComponent(TestCmpt);\n      }).toThrowError('Error in a constructor');\n    });\n    it('should render even if a directive constructor throws in the first create pass', () => {\n      let firstRun = true;\n      @Directive({\n        selector: '[failInConstructorOnce]',\n        standalone: false,\n      })\n      class FailInConstructorOnce {\n        constructor() {\n          if (firstRun) {\n            firstRun = false;\n            throw new Error('Error in a constructor');\n          }\n        }\n      }\n      @Component({\n        template: `<div failInConstructorOnce>OK</div>`,\n        standalone: false,\n      })\n      class TestCmpt {}\n      TestBed.configureTestingModule({\n        declarations: [TestCmpt, FailInConstructorOnce],\n      });\n      expect(() => {\n        TestBed.createComponent(TestCmpt);\n      }).toThrowError('Error in a constructor');\n      const fixture = TestBed.createComponent(TestCmpt);\n      expect(fixture.nativeElement.textContent).toContain('OK');\n    });\n    it('should consistently report errors raised a directive input setter', () => {\n      @Directive({\n        selector: '[failInInputAlways]',\n        standalone: false,\n      })\n      class FailInInputAlways {\n        @Input()\n        set failInInputAlways(_: string) {\n          throw new Error('Error in an input');\n        }\n      }\n      @Component({\n        template: `<div failInInputAlways=\"static\"></div>`,\n        standalone: false,\n      })\n      class TestCmpt {}\n      TestBed.configureTestingModule({\n        declarations: [TestCmpt, FailInInputAlways],\n      });\n      expect(() => {\n        TestBed.createComponent(TestCmpt);\n      }).toThrowError('Error in an input');\n      expect(() => {\n        TestBed.createComponent(TestCmpt);\n      }).toThrowError('Error in an input');\n    });\n    it('should consistently report errors raised a static query setter', () => {\n      @Directive({\n        selector: '[someDir]',\n        standalone: false,\n      })\n      class SomeDirective {}\n      @Component({\n        template: `<div someDir></div>`,\n        standalone: false,\n      })\n      class TestCmpt {\n        @ViewChild(SomeDirective, {static: true})\n        set directive(_: SomeDirective) {\n          throw new Error('Error in static query setter');\n        }\n      }\n      TestBed.configureTestingModule({\n        declarations: [TestCmpt, SomeDirective],\n      });\n      expect(() => {\n        TestBed.createComponent(TestCmpt);\n      }).toThrowError('Error in static query setter');\n      expect(() => {\n        TestBed.createComponent(TestCmpt);\n      }).toThrowError('Error in static query setter');\n    });\n    it('should match a static query, even if its setter throws in the first create pass', () => {\n      let hasThrown = false;\n      @Directive({\n        selector: '[someDir]',\n        standalone: false,\n      })\n      class SomeDirective {}\n      @Component({\n        template: `<div someDir></div>`,\n        standalone: false,\n      })\n      class TestCmpt {\n        @ViewChild(SomeDirective, {static: true})\n        get directive() {\n          return this._directive;\n        }\n        set directive(directiveInstance: SomeDirective) {\n          if (!hasThrown) {\n            hasThrown = true;\n            throw new Error('Error in static query setter');\n          }\n          this._directive = directiveInstance;\n        }\n        private _directive!: SomeDirective;\n      }\n      TestBed.configureTestingModule({\n        declarations: [TestCmpt, SomeDirective],\n      });\n      expect(() => {\n        TestBed.createComponent(TestCmpt);\n      }).toThrowError('Error in static query setter');\n      const fixture = TestBed.createComponent(TestCmpt);\n      expect(fixture.componentInstance.directive).toBeInstanceOf(SomeDirective);\n    });\n    it('should render a recursive component if it throws during the first creation pass', () => {\n      let hasThrown = false;\n      @Component({\n        selector: 'test',\n        template: `<ng-content></ng-content>OK`,\n        standalone: false,\n      })\n      class TestCmpt {\n        constructor() {\n          if (!hasThrown) {\n            hasThrown = true;\n            throw new Error('Error in a constructor');\n          }\n        }\n      }\n      @Component({\n        template: `<test><test><test></test></test></test>`,\n        standalone: false,\n      })\n      class App {}\n      TestBed.configureTestingModule({\n        declarations: [App, TestCmpt],\n      });\n      expect(() => {\n        TestBed.createComponent(App);\n      }).toThrowError('Error in a constructor');\n      const fixture = TestBed.createComponent(App);\n      expect(fixture.nativeElement.textContent).toContain('OKOKOK');\n    });\n    it('should continue detecting changes if a directive throws in its constructor', () => {\n      let firstRun = true;\n      @Directive({\n        selector: '[failInConstructorOnce]',\n        standalone: false,\n      })\n      class FailInConstructorOnce {\n        constructor() {\n          if (firstRun) {\n            firstRun = false;\n            throw new Error('Error in a constructor');\n          }\n        }\n      }\n      @Component({\n        template: `<div failInConstructorOnce>{{value}}</div>`,\n        standalone: false,\n      })\n      class TestCmpt {\n        value = 0;\n      }\n      TestBed.configureTestingModule({\n        declarations: [TestCmpt, FailInConstructorOnce],\n      });\n      expect(() => {\n        TestBed.createComponent(TestCmpt);\n      }).toThrowError('Error in a constructor');\n      const fixture = TestBed.createComponent(TestCmpt);\n      fixture.detectChanges();\n      expect(fixture.nativeElement.textContent).toContain('0');\n      fixture.componentInstance.value = 1;\n      fixture.detectChanges();\n      expect(fixture.nativeElement.textContent).toContain('1');\n      fixture.componentInstance.value = 2;\n      fixture.detectChanges();\n      expect(fixture.nativeElement.textContent).toContain('2');\n    });\n    it('should consistently report errors raised by createEmbeddedView', () => {\n      // Intentionally hasn't been added to `providers` so that it throws a DI error.\n      @Injectable()\n      class DoesNotExist {}\n      @Directive({\n        selector: 'dir',\n        standalone: false,\n      })\n      class Dir {\n        constructor(willCauseError: DoesNotExist) {}\n      }\n      @Component({\n        template: `\n          <ng-template #broken>\n            <dir></dir>\n          </ng-template>\n        `,\n        standalone: false,\n      })\n      class App {\n        @ViewChild('broken') template!: TemplateRef<unknown>;\n        constructor(private _viewContainerRef: ViewContainerRef) {}\n        insertTemplate() {\n          this._viewContainerRef.createEmbeddedView(this.template);\n        }\n      }\n      TestBed.configureTestingModule({declarations: [App, Dir]});\n      const fixture = TestBed.createComponent(App);\n      const tryRender = () => {\n        fixture.componentInstance.insertTemplate();\n        fixture.detectChanges();\n      };\n      fixture.detectChanges();\n      // We try to render the same template twice to ensure that we get consistent error messages.\n      expect(tryRender).toThrowError(/No provider for DoesNotExist/);\n      expect(tryRender).toThrowError(/No provider for DoesNotExist/);\n    });\n  });\n}"
        }
      ],
      "classes": [],
      "blocks": [],
      "simplified_code": ""
    },
    {
      "type": "class",
      "name": "%AC$%dflt$%AM2$%AM1$%AM0$0",
      "label": "%AC$%dflt$%AM2$%AM1$%AM0$0",
      "start_line": 60,
      "end_line": 60,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n        declarations: [App, IncrementComp],\n      }"
    },
    {
      "type": "class",
      "name": "%AC$%dflt$%AM4$%AM3$%AM0$1",
      "label": "%AC$%dflt$%AM4$%AM3$%AM0$1",
      "start_line": 101,
      "end_line": 101,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n        declarations: [App],\n      }"
    },
    {
      "type": "class",
      "name": "%AC$%dflt$%AM6$%AM5$%AM0$2",
      "label": "%AC$%dflt$%AM6$%AM5$%AM0$2",
      "start_line": 148,
      "end_line": 148,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n        declarations: [App, Comp],\n      }"
    },
    {
      "type": "class",
      "name": "%AC$%dflt$%AM8$%AM7$%AM0$3",
      "label": "%AC$%dflt$%AM8$%AM7$%AM0$3",
      "start_line": 195,
      "end_line": 195,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n        declarations: [App],\n        imports: [CommonModule],\n      }"
    },
    {
      "type": "class",
      "name": "%AC$%dflt$%AM11$%AM10$%AM9$%AM0$4",
      "label": "%AC$%dflt$%AM11$%AM10$%AM9$%AM0$4",
      "start_line": 241,
      "end_line": 241,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n          declarations: [TestCmpt, ViewInsertingDir],\n          imports: [CommonModule],\n        }"
    },
    {
      "type": "class",
      "name": "%AC$%dflt$%AM23$%AM10$%AM9$%AM0$5",
      "label": "%AC$%dflt$%AM23$%AM10$%AM9$%AM0$5",
      "start_line": 347,
      "end_line": 347,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n          declarations: [AppComponent],\n          imports: [CommonModule],\n        }"
    },
    {
      "type": "class",
      "name": "%AC$%dflt$%AM25$%AM24$%AM9$%AM0$6",
      "label": "%AC$%dflt$%AM25$%AM24$%AM9$%AM0$6",
      "start_line": 389,
      "end_line": 389,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n          declarations: [ViewInsertingDir, WithContentCmpt, TestCmpt],\n          imports: [CommonModule],\n        }"
    },
    {
      "type": "class",
      "name": "%AC$%dflt$%AM29$%AM28$%AM9$%AM0$7",
      "label": "%AC$%dflt$%AM29$%AM28$%AM9$%AM0$7",
      "start_line": 459,
      "end_line": 459,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n          declarations: [TestCmpt, ViewInsertingDir, DynamicComponent],\n        }"
    },
    {
      "type": "class",
      "name": "%AC$%dflt$%AM31$%AM30$%AM0$8",
      "label": "%AC$%dflt$%AM31$%AM30$%AM0$8",
      "start_line": 495,
      "end_line": 495,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n        declarations: [AppComponent, DynamicComponent],\n      }"
    },
    {
      "type": "class",
      "name": "%AC$%dflt$%AM32$%AM30$%AM0$9",
      "label": "%AC$%dflt$%AM32$%AM30$%AM0$9",
      "start_line": 525,
      "end_line": 525,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n        declarations: [AppComponent],\n      }"
    },
    {
      "type": "class",
      "name": "%AC$%dflt$%AM33$%AM30$%AM0$10",
      "label": "%AC$%dflt$%AM33$%AM30$%AM0$10",
      "start_line": 552,
      "end_line": 552,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n        declarations: [AppComponent],\n        imports: [CommonModule],\n      }"
    },
    {
      "type": "class",
      "name": "%AC$%dflt$%AM35$%AM34$%AM0$11",
      "label": "%AC$%dflt$%AM35$%AM34$%AM0$11",
      "start_line": 580,
      "end_line": 580,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n        declarations: [TestCmpt, FailInConstructorAlways],\n      }"
    },
    {
      "type": "class",
      "name": "%AC$%dflt$%AM38$%AM34$%AM0$12",
      "label": "%AC$%dflt$%AM38$%AM34$%AM0$12",
      "start_line": 609,
      "end_line": 609,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n        declarations: [TestCmpt, FailInConstructorOnce],\n      }"
    },
    {
      "type": "class",
      "name": "%AC$%dflt$%AM40$%AM34$%AM0$13",
      "label": "%AC$%dflt$%AM40$%AM34$%AM0$13",
      "start_line": 634,
      "end_line": 634,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n        declarations: [TestCmpt, FailInInputAlways],\n      }"
    },
    {
      "type": "class",
      "name": "%AC$%dflt$%AM43$%AM34$%AM0$14",
      "label": "%AC$%dflt$%AM43$%AM34$%AM0$14",
      "start_line": 660,
      "end_line": 660,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n        declarations: [TestCmpt, SomeDirective],\n      }"
    },
    {
      "type": "class",
      "name": "%AC$%dflt$%AM46$%AM34$%AM0$15",
      "label": "%AC$%dflt$%AM46$%AM34$%AM0$15",
      "start_line": 695,
      "end_line": 695,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n        declarations: [TestCmpt, SomeDirective],\n      }"
    },
    {
      "type": "class",
      "name": "%AC$%dflt$%AM48$%AM34$%AM0$16",
      "label": "%AC$%dflt$%AM48$%AM34$%AM0$16",
      "start_line": 724,
      "end_line": 724,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n        declarations: [App, TestCmpt],\n      }"
    },
    {
      "type": "class",
      "name": "%AC$%dflt$%AM50$%AM34$%AM0$17",
      "label": "%AC$%dflt$%AM50$%AM34$%AM0$17",
      "start_line": 754,
      "end_line": 754,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n        declarations: [TestCmpt, FailInConstructorOnce],\n      }"
    },
    {
      "type": "class",
      "name": "%AC$%dflt$%AM52$%AM34$%AM0$18",
      "label": "%AC$%dflt$%AM52$%AM34$%AM0$18",
      "start_line": 796,
      "end_line": 796,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{declarations: [App, Dir]}"
    }
  ],
  "functions": [],
  "blocks": [],
  "simplified_code": "import {CommonModule} from '@angular/common';\nimport {\n  ChangeDetectorRef,\n  Component,\n  Directive,\n  EmbeddedViewRef,\n  Injectable,\n  Injector,\n  Input,\n  TemplateRef,\n  ViewChild,\n  ViewContainerRef,\n  ViewRef,\n} from '@angular/core';\nimport {TestBed} from '@angular/core/testing';\nimport {By} from '@angular/platform-browser';\ndescribe('view insertion', () => {\n  describe('of a simple template', () => {\n    it('should insert into an empty container, at the front, in the middle, and at the end', () => {\n      let _counter = 0;\n      @Component({\n        selector: 'increment-comp',\n        template: `<span>created{{counter}}</span>`,\n        standalone: false,\n      })\n      class IncrementComp {\n        counter = _counter++;\n      }\n      @Component({\n        template: `\n              <ng-template #simple><increment-comp></increment-comp></ng-template>\n              <div #container></div>\n            `,\n        standalone: false,\n      })\n      class App {\n        @ViewChild('container', {read: ViewContainerRef, static: true})\n        container: ViewContainerRef = null!;\n        @ViewChild('simple', {read: TemplateRef, static: true}) simple: TemplateRef<any> = null!;\n        view0: EmbeddedViewRef<any> = null!;\n        view1: EmbeddedViewRef<any> = null!;\n        view2: EmbeddedViewRef<any> = null!;\n        view3: EmbeddedViewRef<any> = null!;\n        constructor(public changeDetector: ChangeDetectorRef) {}\n        ngAfterViewInit() {\n          // insert at the front\n          this.view1 = this.container.createEmbeddedView(this.simple); // \"created0\"\n          // insert at the front again\n          this.view0 = this.container.createEmbeddedView(this.simple, {}, 0); // \"created1\"\n          // insert at the end\n          this.view3 = this.container.createEmbeddedView(this.simple); // \"created2\"\n          // insert in the middle\n          this.view2 = this.container.createEmbeddedView(this.simple, {}, 2); // \"created3\"\n          // We need to run change detection here to avoid\n          // ExpressionChangedAfterItHasBeenCheckedError because of the value updating in\n          // increment-comp\n          this.changeDetector.detectChanges();\n        }\n      }\n      TestBed.configureTestingModule({\n        declarations: [App, IncrementComp],\n      });\n      const fixture = TestBed.createComponent(App);\n      fixture.detectChanges();\n      const app = fixture.componentInstance;\n      expect(app.container.indexOf(app.view0)).toBe(0);\n      expect(app.container.indexOf(app.view1)).toBe(1);\n      expect(app.container.indexOf(app.view2)).toBe(2);\n      expect(app.container.indexOf(app.view3)).toBe(3);\n      // The text in each component differs based on *when* it was created.\n      expect(fixture.nativeElement.textContent).toBe('created1created0created3created2');\n    });\n  });\n  describe('of an empty template', () => {\n    it('should insert into an empty container, at the front, in the middle, and at the end', () => {\n      @Component({\n        template: `\n              <ng-template #empty></ng-template>\n              <div #container></div>\n            `,\n        standalone: false,\n      })\n      class App {\n        @ViewChild('container', {read: ViewContainerRef}) container: ViewContainerRef = null!;\n        @ViewChild('empty', {read: TemplateRef}) empty: TemplateRef<any> = null!;\n        view0: EmbeddedViewRef<any> = null!;\n        view1: EmbeddedViewRef<any> = null!;\n        view2: EmbeddedViewRef<any> = null!;\n        view3: EmbeddedViewRef<any> = null!;\n        ngAfterViewInit() {\n          // insert at the front\n          this.view1 = this.container.createEmbeddedView(this.empty);\n          // insert at the front again\n          this.view0 = this.container.createEmbeddedView(this.empty, {}, 0);\n          // insert at the end\n          this.view3 = this.container.createEmbeddedView(this.empty);\n          // insert in the middle\n          this.view2 = this.container.createEmbeddedView(this.empty, {}, 2);\n        }\n      }\n      TestBed.configureTestingModule({\n        declarations: [App],\n      });\n      const fixture = TestBed.createComponent(App);\n      fixture.detectChanges();\n      const app = fixture.componentInstance;\n      expect(app.container.indexOf(app.view0)).toBe(0);\n      expect(app.container.indexOf(app.view1)).toBe(1);\n      expect(app.container.indexOf(app.view2)).toBe(2);\n      expect(app.container.indexOf(app.view3)).toBe(3);\n    });\n  });\n  describe('of an ng-content projection', () => {\n    it('should insert into an empty container, at the front, in the middle, and at the end', () => {\n      @Component({\n        selector: 'comp',\n        template: `\n                  <ng-template #projection><ng-content></ng-content></ng-template>\n                  <div #container></div>\n                `,\n        standalone: false,\n      })\n      class Comp {\n        @ViewChild('container', {read: ViewContainerRef}) container: ViewContainerRef = null!;\n        @ViewChild('projection', {read: TemplateRef}) projection: TemplateRef<any> = null!;\n        view0: EmbeddedViewRef<any> = null!;\n        view1: EmbeddedViewRef<any> = null!;\n        view2: EmbeddedViewRef<any> = null!;\n        view3: EmbeddedViewRef<any> = null!;\n        ngAfterViewInit() {\n          // insert at the front\n          this.view1 = this.container.createEmbeddedView(this.projection);\n          // insert at the front again\n          this.view0 = this.container.createEmbeddedView(this.projection, {}, 0);\n          // insert at the end\n          this.view3 = this.container.createEmbeddedView(this.projection);\n          // insert in the middle\n          this.view2 = this.container.createEmbeddedView(this.projection, {}, 2);\n        }\n      }\n      @Component({\n        template: `\n          <comp>test</comp>\n        `,\n        standalone: false,\n      })\n      class App {}\n      TestBed.configureTestingModule({\n        declarations: [App, Comp],\n      });\n      const fixture = TestBed.createComponent(App);\n      fixture.detectChanges();\n      const comp = fixture.debugElement.query(By.directive(Comp)).injector.get(Comp);\n      expect(comp.container.indexOf(comp.view0)).toBe(0);\n      expect(comp.container.indexOf(comp.view1)).toBe(1);\n      expect(comp.container.indexOf(comp.view2)).toBe(2);\n      expect(comp.container.indexOf(comp.view3)).toBe(3);\n      // Both ViewEngine and Ivy only honor one of the inserted ng-content components, even though\n      // all are inserted.\n      expect(fixture.nativeElement.textContent).toBe('test');\n    });\n  });\n  describe('of another container like ngIf', () => {\n    it('should insert into an empty container, at the front, in the middle, and at the end', () => {\n      @Component({\n        template: `\n                  <ng-template #subContainer><div class=\"dynamic\" *ngIf=\"true\">test</div></ng-template>\n                  <div #container></div>\n                `,\n        standalone: false,\n      })\n      class App {\n        @ViewChild('container', {read: ViewContainerRef}) container: ViewContainerRef = null!;\n        @ViewChild('subContainer', {read: TemplateRef}) subContainer: TemplateRef<any> = null!;\n        view0: EmbeddedViewRef<any> = null!;\n        view1: EmbeddedViewRef<any> = null!;\n        view2: EmbeddedViewRef<any> = null!;\n        view3: EmbeddedViewRef<any> = null!;\n        constructor(public changeDetectorRef: ChangeDetectorRef) {}\n        ngAfterViewInit() {\n          // insert at the front\n          this.view1 = this.container.createEmbeddedView(this.subContainer, null, 0);\n          // insert at the front again\n          this.view0 = this.container.createEmbeddedView(this.subContainer, null, 0);\n          // insert at the end\n          this.view3 = this.container.createEmbeddedView(this.subContainer, null, 2);\n          // insert in the middle\n          this.view2 = this.container.createEmbeddedView(this.subContainer, null, 2);\n          // We need to run change detection here to avoid\n          // ExpressionChangedAfterItHasBeenCheckedError because of the value getting passed to ngIf\n          // in the template.\n          this.changeDetectorRef.detectChanges();\n        }\n      }\n      TestBed.configureTestingModule({\n        declarations: [App],\n        imports: [CommonModule],\n      });\n      const fixture = TestBed.createComponent(App);\n      fixture.detectChanges();\n      const app = fixture.componentInstance;\n      expect(app.container.indexOf(app.view0)).toBe(0);\n      expect(app.container.indexOf(app.view1)).toBe(1);\n      expect(app.container.indexOf(app.view2)).toBe(2);\n      expect(app.container.indexOf(app.view3)).toBe(3);\n      expect(fixture.debugElement.queryAll(By.css('div.dynamic')).length).toBe(4);\n    });\n  });\n  describe('before another view', () => {\n    @Directive({\n      selector: '[viewInserting]',\n      exportAs: 'vi',\n      standalone: false,\n    })\n    class ViewInsertingDir {\n      constructor(private _vcRef: ViewContainerRef) {}\n      insert(beforeView: ViewRef, insertTpl: TemplateRef<{}>) {\n        this._vcRef.insert(beforeView, 0);\n        this._vcRef.createEmbeddedView(insertTpl, {}, 0);\n      }\n    }\n    describe('before embedded view', () => {\n      @Component({\n        selector: 'test-cmpt',\n        template: '',\n        standalone: false,\n      })\n      class TestCmpt {\n        @ViewChild('before', {static: true}) beforeTpl!: TemplateRef<{}>;\n        @ViewChild('insert', {static: true}) insertTpl!: TemplateRef<{}>;\n        @ViewChild('vi', {static: true}) viewInsertingDir!: ViewInsertingDir;\n        minutes = 10;\n        insert() {\n          const beforeView = this.beforeTpl.createEmbeddedView({});\n          // change-detect the \"before view\" to create all child views\n          beforeView.detectChanges();\n          this.viewInsertingDir.insert(beforeView, this.insertTpl);\n        }\n      }\n      beforeEach(() => {\n        TestBed.configureTestingModule({\n          declarations: [TestCmpt, ViewInsertingDir],\n          imports: [CommonModule],\n        });\n      });\n      function createAndInsertViews(beforeTpl: string): any {\n        TestBed.overrideTemplate(\n          TestCmpt,\n          `\n          <ng-template #insert>insert</ng-template>\n          <ng-template #before>${beforeTpl}</ng-template>\n          <div><ng-template #vi=\"vi\" viewInserting></ng-template></div>\n        `,\n        );\n        const fixture = TestBed.createComponent(TestCmpt);\n        fixture.detectChanges();\n        fixture.componentInstance.insert();\n        fixture.detectChanges();\n        return fixture.nativeElement;\n      }\n      it('should insert before a view with the text node as the first root node', () => {\n        expect(createAndInsertViews('|before').textContent).toBe('insert|before');\n      });\n      it('should insert before a view with the element as the first root node', () => {\n        expect(createAndInsertViews('<span>|before</span>').textContent).toBe('insert|before');\n      });\n      it('should insert before a view with the ng-container as the first root node', () => {\n        expect(\n          createAndInsertViews(`\n          <ng-container>\n            <ng-container>|before</ng-container>\n          </ng-container>\n        `).textContent,\n        ).toBe('insert|before');\n      });\n      it('should insert before a view with the empty ng-container as the first root node', () => {\n        expect(createAndInsertViews(`<ng-container></ng-container>|before`).textContent).toBe(\n          'insert|before',\n        );\n      });\n      it('should insert before a view with ICU container inside a ng-container as the first root node', () => {\n        expect(\n          createAndInsertViews(\n            `<ng-container i18n>{minutes, plural, =0 {just now} =1 {one minute ago} other {|before}}</ng-container>`,\n          ).textContent,\n        ).toBe('insert|before');\n      });\n      it('should insert before a view with a container as the first root node', () => {\n        expect(\n          createAndInsertViews(`<ng-template [ngIf]=\"true\">|before</ng-template>`).textContent,\n        ).toBe('insert|before');\n      });\n      it('should insert before a view with an empty container as the first root node', () => {\n        expect(\n          createAndInsertViews(`<ng-template [ngIf]=\"true\"></ng-template>|before`).textContent,\n        ).toBe('insert|before');\n      });\n      it('should insert before a view with a ng-container where ViewContainerRef is injected', () => {\n        expect(\n          createAndInsertViews(`\n          <ng-container [ngTemplateOutlet]=\"after\">|before</ng-container>\n          <ng-template #after>|after</ng-template>\n        `).textContent,\n        ).toBe('insert|before|after');\n      });\n      it('should insert before a view with an element where ViewContainerRef is injected', () => {\n        expect(\n          createAndInsertViews(`\n          <div [ngTemplateOutlet]=\"after\">|before</div>\n          <ng-template #after>|after</ng-template>\n        `).textContent,\n        ).toBe('insert|before|after');\n      });\n      it('should insert before a view with an empty projection as the first root node', () => {\n        expect(createAndInsertViews(`<ng-content></ng-content>|before`).textContent).toBe(\n          'insert|before',\n        );\n      });\n      it('should insert before a view with complex node structure', () => {\n        expect(\n          createAndInsertViews(`\n          <ng-template [ngIf]=\"true\">\n            <ng-container>\n              <ng-container>\n                <ng-template [ngIf]=\"true\">|before</ng-template>\n              </ng-container>\n            </ng-container>\n          </ng-template>\n        `).textContent,\n        ).toBe('insert|before');\n      });\n      it('should insert before a ng-container with a ViewContainerRef on it', () => {\n        @Component({\n          selector: 'app-root',\n          template: `\n            <div>start|</div>\n            <ng-container [ngTemplateOutlet]=\"insertTpl ? tpl : null\"></ng-container>\n            <ng-container [ngTemplateOutlet]=\"tpl\"></ng-container>\n            <div>|end</div>\n            <ng-template #tpl>test</ng-template>\n          `,\n          standalone: false,\n        })\n        class AppComponent {\n          insertTpl = false;\n        }\n        TestBed.configureTestingModule({\n          declarations: [AppComponent],\n          imports: [CommonModule],\n        });\n        const fixture = TestBed.createComponent(AppComponent);\n        fixture.detectChanges();\n        expect(fixture.nativeElement.textContent).toBe('start|test|end');\n        fixture.componentInstance.insertTpl = true;\n        fixture.detectChanges();\n        expect(fixture.nativeElement.textContent).toBe('start|testtest|end');\n      });\n    });\n    describe('before embedded view with projection', () => {\n      @Component({\n        selector: 'with-content',\n        template: `\n          <ng-template #insert>insert</ng-template>\n          <ng-template #before><ng-content></ng-content></ng-template>\n          <div><ng-template #vi=\"vi\" viewInserting></ng-template></div>\n        `,\n        standalone: false,\n      })\n      class WithContentCmpt {\n        @ViewChild('insert', {static: true}) insertTpl!: TemplateRef<{}>;\n        @ViewChild('before', {static: true}) beforeTpl!: TemplateRef<{}>;\n        @ViewChild('vi', {static: true}) viewInsertingDir!: ViewInsertingDir;\n        insert() {\n          const beforeView = this.beforeTpl.createEmbeddedView({});\n          // change-detect the \"before view\" to create all child views\n          beforeView.detectChanges();\n          this.viewInsertingDir.insert(beforeView, this.insertTpl);\n        }\n      }\n      @Component({\n        selector: 'test-cmpt',\n        template: '',\n        standalone: false,\n      })\n      class TestCmpt {\n        @ViewChild('wc', {static: true}) withContentCmpt!: WithContentCmpt;\n      }\n      beforeEach(() => {\n        TestBed.configureTestingModule({\n          declarations: [ViewInsertingDir, WithContentCmpt, TestCmpt],\n          imports: [CommonModule],\n        });\n      });\n      it('should insert before a view with projected text nodes', () => {\n        TestBed.overrideTemplate(TestCmpt, `<with-content #wc>|before</with-content>`);\n        const fixture = TestBed.createComponent(TestCmpt);\n        fixture.detectChanges();\n        fixture.componentInstance.withContentCmpt.insert();\n        fixture.detectChanges();\n        expect(fixture.nativeElement.textContent).toBe('insert|before');\n      });\n      it('should insert before a view with projected container', () => {\n        TestBed.overrideTemplate(\n          TestCmpt,\n          `<with-content #wc><ng-template [ngIf]=\"true\">|before</ng-template></with-content>`,\n        );\n        const fixture = TestBed.createComponent(TestCmpt);\n        fixture.detectChanges();\n        fixture.componentInstance.withContentCmpt.insert();\n        fixture.detectChanges();\n        expect(fixture.nativeElement.textContent).toBe('insert|before');\n      });\n    });\n    describe('before component view', () => {\n      @Directive({\n        selector: '[viewInserting]',\n        exportAs: 'vi',\n        standalone: false,\n      })\n      class ViewInsertingDir {\n        constructor(private _vcRef: ViewContainerRef) {}\n        insert(beforeView: ViewRef, insertTpl: TemplateRef<{}>) {\n          this._vcRef.insert(beforeView, 0);\n          this._vcRef.createEmbeddedView(insertTpl, {}, 0);\n        }\n      }\n      @Component({\n        selector: 'dynamic-cmpt',\n        template: '|before',\n        standalone: false,\n      })\n      class DynamicComponent {}\n      it('should insert in front a dynamic component view', () => {\n        @Component({\n          selector: 'test-cmpt',\n          template: `\n                <ng-template #insert>insert</ng-template>\n                <div><ng-template #vi=\"vi\" viewInserting></ng-template></div>\n              `,\n          standalone: false,\n        })\n        class TestCmpt {\n          @ViewChild('insert', {static: true}) insertTpl!: TemplateRef<{}>;\n          @ViewChild('vi', {static: true}) viewInsertingDir!: ViewInsertingDir;\n          constructor(\n            private _vcr: ViewContainerRef,\n            private _injector: Injector,\n          ) {}\n          insert() {\n            // create a dynamic component view to act as an \"insert before\" view\n            const beforeView = this._vcr.createComponent(DynamicComponent, {\n              injector: this._injector,\n            }).hostView;\n            // change-detect the \"before view\" to create all child views\n            beforeView.detectChanges();\n            this.viewInsertingDir.insert(beforeView, this.insertTpl);\n          }\n        }\n        TestBed.configureTestingModule({\n          declarations: [TestCmpt, ViewInsertingDir, DynamicComponent],\n        });\n        const fixture = TestBed.createComponent(TestCmpt);\n        fixture.detectChanges();\n        fixture.componentInstance.insert();\n        fixture.detectChanges();\n        expect(fixture.nativeElement.textContent).toBe('insert|before');\n      });\n    });\n  });\n  describe('non-regression', () => {\n    // https://github.com/angular/angular/issues/31971\n    it('should insert component views into ViewContainerRef injected by querying <ng-container>', () => {\n      @Component({\n        selector: 'dynamic-cmpt',\n        template: 'dynamic',\n        standalone: false,\n      })\n      class DynamicComponent {}\n      @Component({\n        selector: 'app-root',\n        template: `\n            <div>start|</div>\n            <ng-container #container></ng-container>\n            <div>|end</div>\n            <div (click)=\"click()\" >|click</div>\n        `,\n        standalone: false,\n      })\n      class AppComponent {\n        @ViewChild('container', {read: ViewContainerRef, static: true}) vcr!: ViewContainerRef;\n        click() {\n          this.vcr.createComponent(DynamicComponent);\n        }\n      }\n      TestBed.configureTestingModule({\n        declarations: [AppComponent, DynamicComponent],\n      });\n      const fixture = TestBed.createComponent(AppComponent);\n      fixture.detectChanges();\n      expect(fixture.nativeElement.textContent).toBe('start||end|click');\n      fixture.componentInstance.click();\n      fixture.detectChanges();\n      expect(fixture.nativeElement.textContent).toBe('start|dynamic|end|click');\n    });\n    // https://github.com/angular/angular/issues/33679\n    it('should insert embedded views into ViewContainerRef injected by querying <ng-container>', () => {\n      @Component({\n        selector: 'app-root',\n        template: `\n        <div>container start|</div>\n        <ng-container #container></ng-container>\n        <div>|container end</div>\n        <ng-template #template >test</ng-template>\n        <div (click)=\"click()\" >|click</div>\n        `,\n        standalone: false,\n      })\n      class AppComponent {\n        @ViewChild('container', {read: ViewContainerRef, static: true}) vcr!: ViewContainerRef;\n        @ViewChild('template', {read: TemplateRef, static: true}) template!: TemplateRef<any>;\n        click() {\n          this.vcr.createEmbeddedView(this.template, undefined, 0);\n        }\n      }\n      TestBed.configureTestingModule({\n        declarations: [AppComponent],\n      });\n      const fixture = TestBed.createComponent(AppComponent);\n      fixture.detectChanges();\n      expect(fixture.nativeElement.textContent).toBe('container start||container end|click');\n      fixture.componentInstance.click();\n      fixture.detectChanges();\n      expect(fixture.nativeElement.textContent).toBe('container start|test|container end|click');\n    });\n    it('should properly insert before views in a ViewContainerRef injected on ng-container', () => {\n      @Component({\n        selector: 'app-root',\n        template: `\n          <ng-template #parameterListItem let-parameter=\"parameter\">\n            {{parameter}}\n          </ng-template>\n          <ng-container *ngFor=\"let parameter of items;\"\n            [ngTemplateOutlet]=\"parameterListItem\"\n            [ngTemplateOutletContext]=\"{parameter:parameter}\">\n          </ng-container>\n        `,\n        standalone: false,\n      })\n      class AppComponent {\n        items = [1];\n      }\n      TestBed.configureTestingModule({\n        declarations: [AppComponent],\n        imports: [CommonModule],\n      });\n      const fixture = TestBed.createComponent(AppComponent);\n      fixture.detectChanges();\n      expect(fixture.nativeElement.textContent.trim()).toContain('1');\n      fixture.componentInstance.items = [2, 1];\n      fixture.detectChanges();\n      expect(fixture.nativeElement.textContent.trim()).toContain('2  1');\n    });\n  });\n  describe('create mode error handling', () => {\n    it('should consistently report errors raised a directive constructor', () => {\n      @Directive({\n        selector: '[failInConstructorAlways]',\n        standalone: false,\n      })\n      class FailInConstructorAlways {\n        constructor() {\n          throw new Error('Error in a constructor');\n        }\n      }\n      @Component({\n        template: `<div failInConstructorAlways></div>`,\n        standalone: false,\n      })\n      class TestCmpt {}\n      TestBed.configureTestingModule({\n        declarations: [TestCmpt, FailInConstructorAlways],\n      });\n      expect(() => {\n        TestBed.createComponent(TestCmpt);\n      }).toThrowError('Error in a constructor');\n      expect(() => {\n        TestBed.createComponent(TestCmpt);\n      }).toThrowError('Error in a constructor');\n    });\n    it('should render even if a directive constructor throws in the first create pass', () => {\n      let firstRun = true;\n      @Directive({\n        selector: '[failInConstructorOnce]',\n        standalone: false,\n      })\n      class FailInConstructorOnce {\n        constructor() {\n          if (firstRun) {\n            firstRun = false;\n            throw new Error('Error in a constructor');\n          }\n        }\n      }\n      @Component({\n        template: `<div failInConstructorOnce>OK</div>`,\n        standalone: false,\n      })\n      class TestCmpt {}\n      TestBed.configureTestingModule({\n        declarations: [TestCmpt, FailInConstructorOnce],\n      });\n      expect(() => {\n        TestBed.createComponent(TestCmpt);\n      }).toThrowError('Error in a constructor');\n      const fixture = TestBed.createComponent(TestCmpt);\n      expect(fixture.nativeElement.textContent).toContain('OK');\n    });\n    it('should consistently report errors raised a directive input setter', () => {\n      @Directive({\n        selector: '[failInInputAlways]',\n        standalone: false,\n      })\n      class FailInInputAlways {\n        @Input()\n        set failInInputAlways(_: string) {\n          throw new Error('Error in an input');\n        }\n      }\n      @Component({\n        template: `<div failInInputAlways=\"static\"></div>`,\n        standalone: false,\n      })\n      class TestCmpt {}\n      TestBed.configureTestingModule({\n        declarations: [TestCmpt, FailInInputAlways],\n      });\n      expect(() => {\n        TestBed.createComponent(TestCmpt);\n      }).toThrowError('Error in an input');\n      expect(() => {\n        TestBed.createComponent(TestCmpt);\n      }).toThrowError('Error in an input');\n    });\n    it('should consistently report errors raised a static query setter', () => {\n      @Directive({\n        selector: '[someDir]',\n        standalone: false,\n      })\n      class SomeDirective {}\n      @Component({\n        template: `<div someDir></div>`,\n        standalone: false,\n      })\n      class TestCmpt {\n        @ViewChild(SomeDirective, {static: true})\n        set directive(_: SomeDirective) {\n          throw new Error('Error in static query setter');\n        }\n      }\n      TestBed.configureTestingModule({\n        declarations: [TestCmpt, SomeDirective],\n      });\n      expect(() => {\n        TestBed.createComponent(TestCmpt);\n      }).toThrowError('Error in static query setter');\n      expect(() => {\n        TestBed.createComponent(TestCmpt);\n      }).toThrowError('Error in static query setter');\n    });\n    it('should match a static query, even if its setter throws in the first create pass', () => {\n      let hasThrown = false;\n      @Directive({\n        selector: '[someDir]',\n        standalone: false,\n      })\n      class SomeDirective {}\n      @Component({\n        template: `<div someDir></div>`,\n        standalone: false,\n      })\n      class TestCmpt {\n        @ViewChild(SomeDirective, {static: true})\n        get directive() {\n          return this._directive;\n        }\n        set directive(directiveInstance: SomeDirective) {\n          if (!hasThrown) {\n            hasThrown = true;\n            throw new Error('Error in static query setter');\n          }\n          this._directive = directiveInstance;\n        }\n        private _directive!: SomeDirective;\n      }\n      TestBed.configureTestingModule({\n        declarations: [TestCmpt, SomeDirective],\n      });\n      expect(() => {\n        TestBed.createComponent(TestCmpt);\n      }).toThrowError('Error in static query setter');\n      const fixture = TestBed.createComponent(TestCmpt);\n      expect(fixture.componentInstance.directive).toBeInstanceOf(SomeDirective);\n    });\n    it('should render a recursive component if it throws during the first creation pass', () => {\n      let hasThrown = false;\n      @Component({\n        selector: 'test',\n        template: `<ng-content></ng-content>OK`,\n        standalone: false,\n      })\n      class TestCmpt {\n        constructor() {\n          if (!hasThrown) {\n            hasThrown = true;\n            throw new Error('Error in a constructor');\n          }\n        }\n      }\n      @Component({\n        template: `<test><test><test></test></test></test>`,\n        standalone: false,\n      })\n      class App {}\n      TestBed.configureTestingModule({\n        declarations: [App, TestCmpt],\n      });\n      expect(() => {\n        TestBed.createComponent(App);\n      }).toThrowError('Error in a constructor');\n      const fixture = TestBed.createComponent(App);\n      expect(fixture.nativeElement.textContent).toContain('OKOKOK');\n    });\n    it('should continue detecting changes if a directive throws in its constructor', () => {\n      let firstRun = true;\n      @Directive({\n        selector: '[failInConstructorOnce]',\n        standalone: false,\n      })\n      class FailInConstructorOnce {\n        constructor() {\n          if (firstRun) {\n            firstRun = false;\n            throw new Error('Error in a constructor');\n          }\n        }\n      }\n      @Component({\n        template: `<div failInConstructorOnce>{{value}}</div>`,\n        standalone: false,\n      })\n      class TestCmpt {\n        value = 0;\n      }\n      TestBed.configureTestingModule({\n        declarations: [TestCmpt, FailInConstructorOnce],\n      });\n      expect(() => {\n        TestBed.createComponent(TestCmpt);\n      }).toThrowError('Error in a constructor');\n      const fixture = TestBed.createComponent(TestCmpt);\n      fixture.detectChanges();\n      expect(fixture.nativeElement.textContent).toContain('0');\n      fixture.componentInstance.value = 1;\n      fixture.detectChanges();\n      expect(fixture.nativeElement.textContent).toContain('1');\n      fixture.componentInstance.value = 2;\n      fixture.detectChanges();\n      expect(fixture.nativeElement.textContent).toContain('2');\n    });\n    it('should consistently report errors raised by createEmbeddedView', () => {\n      // Intentionally hasn't been added to `providers` so that it throws a DI error.\n      @Injectable()\n      class DoesNotExist {}\n      @Directive({\n        selector: 'dir',\n        standalone: false,\n      })\n      class Dir {\n        constructor(willCauseError: DoesNotExist) {}\n      }\n      @Component({\n        template: `\n          <ng-template #broken>\n            <dir></dir>\n          </ng-template>\n        `,\n        standalone: false,\n      })\n      class App {\n        @ViewChild('broken') template!: TemplateRef<unknown>;\n        constructor(private _viewContainerRef: ViewContainerRef) {}\n        insertTemplate() {\n          this._viewContainerRef.createEmbeddedView(this.template);\n        }\n      }\n      TestBed.configureTestingModule({declarations: [App, Dir]});\n      const fixture = TestBed.createComponent(App);\n      const tryRender = () => {\n        fixture.componentInstance.insertTemplate();\n        fixture.detectChanges();\n      };\n      fixture.detectChanges();\n      // We try to render the same template twice to ensure that we get consistent error messages.\n      expect(tryRender).toThrowError(/No provider for DoesNotExist/);\n      expect(tryRender).toThrowError(/No provider for DoesNotExist/);\n    });\n  });\n});"
}