{
  "type": "file",
  "name": "184.ts",
  "label": "184.ts",
  "start_line": -1,
  "end_line": 245,
  "classes": [
    {
      "type": "class",
      "name": "%dflt",
      "label": "%dflt",
      "start_line": -1,
      "end_line": 244,
      "functions": [
        {
          "type": "function",
          "name": "%dflt",
          "label": "%dflt",
          "start_line": -1,
          "end_line": 244,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/184.ts: %dflt\n__pulumiType = 'sst:cloudflare:Remix'\nRemix.<@ts_files/184.ts: Remix.__pulumiType> = __pulumiType\nreturn",
              "start_line": 1,
              "end_line": 244,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": ""
        }
      ],
      "classes": [],
      "blocks": [],
      "simplified_code": ""
    },
    {
      "type": "class",
      "name": "RemixArgs",
      "label": "RemixArgs",
      "start_line": 19,
      "end_line": 19,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "export interface RemixArgs extends SsrSiteArgs {\n  assets?: SsrSiteArgs[\"assets\"];\n  buildCommand?: SsrSiteArgs[\"buildCommand\"];\n  domain?: SsrSiteArgs[\"domain\"];\n  environment?: SsrSiteArgs[\"environment\"];\n  link?: SsrSiteArgs[\"link\"];\n  path?: SsrSiteArgs[\"path\"];\n}"
    },
    {
      "type": "class",
      "name": "Remix",
      "label": "Remix",
      "start_line": 1,
      "end_line": 243,
      "functions": [
        {
          "type": "function",
          "name": "constructor",
          "label": "constructor",
          "start_line": 1,
          "end_line": 31,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "instanceinvoke this.<@ts_files/184.ts: Remix.%instInit()>()\n%5 = this.<@ts_files/184.ts: Remix.urn>\n%6 = this.<@ts_files/184.ts: Remix.url>\n%7 = <Output<string>>%6\ninstanceinvoke Hint.<@%unk/%unk: .register()>(%5, %7)",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%8 = new @ts_files/184.ts: %AC$Remix$constructor$0\ninstanceinvoke %8.<@ts_files/184.ts: %AC$Remix$constructor$0.constructor()>()\ninstanceinvoke this.<@%unk/%unk: .registerOutputs()>(%8)\nreturn",
                  "start_line": 1,
                  "end_line": 244,
                  "successors": []
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "block",
              "name": "Block?",
              "label": "name = parameter0: string\nargs = parameter1: @ts_files/184.ts: RemixArgs\nopts = parameter2: ComponentResourceOptions\nthis = this: @ts_files/184.ts: Remix\nstaticinvoke <@%unk/%unk: .super()>(__pulumiType, name, args, opts)\nparent = this\n%0 = staticinvoke <@%unk/%unk: .prepare()>(args)\nsitePath = %0.<@%unk/%unk: .sitePath>\nisUsingVite = staticinvoke <@ts_files/184.ts: Remix.%checkIsUsingVite$constructor([sitePath])>(%closures0)\nstorage = staticinvoke <@%unk/%unk: .createKvStorage()>(parent, name, args)\nif $dev != 0",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "outputPath = sitePath",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "%2 = staticinvoke <@%unk/%unk: .loadBuildOutput()>()\nbuildMeta = %2.<@%unk/%unk: .buildMeta>\nplan = staticinvoke <@ts_files/184.ts: Remix.%buildPlan$constructor([isUsingVite, outputPath, buildMeta])>(%closures2)\n%3 = staticinvoke <@%unk/%unk: .createRouter()>(parent, name, args, outputPath, storage, plan)\nrouter = %3.<@%unk/%unk: .router>\nserver = %3.<@%unk/%unk: .server>\nthis.<@ts_files/184.ts: Remix.assets> = storage\nthis.<@ts_files/184.ts: Remix.router> = router\nthis.<@ts_files/184.ts: Remix.server> = server\n%4 = !$dev\nif %4 != 0",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "blockRef",
                          "label": "(RepeatedBlock)"
                        },
                        {
                          "type": "blockRef",
                          "label": "(RepeatedBlock)"
                        }
                      ]
                    }
                  ]
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "outputPath = staticinvoke <@%unk/%unk: .buildApp()>(parent, name, args, sitePath)",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "blockRef",
                      "label": "(RepeatedBlock)"
                    }
                  ]
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "constructor(\n    name: string,\n    args: RemixArgs = {},\n    opts: ComponentResourceOptions = {},\n  ) {\n    super(__pulumiType, name, args, opts);\n    const parent = this;\n    const { sitePath } = prepare(args);\n    const isUsingVite = checkIsUsingVite();\n    const storage = createKvStorage(parent, name, args);\n    const outputPath = $dev ? sitePath : buildApp(parent, name, args, sitePath);\n    const { buildMeta } = loadBuildOutput();\n    const plan = buildPlan();\n    const { router, server } = createRouter(\n      parent,\n      name,\n      args,\n      outputPath,\n      storage,\n      plan,\n    );\n    this.assets = storage;\n    this.router = router;\n    this.server = server;\n    if (!$dev) {\n      Hint.register(this.urn, this.url as Output<string>);\n    }\n    this.registerOutputs({\n      _metadata: {\n        mode: $dev ? \"placeholder\" : \"deployed\",\n        path: sitePath,\n        url: this.url,\n      },\n    });\n    function checkIsUsingVite() {\n      return sitePath.apply(\n        (sitePath) =>\n          fs.existsSync(path.join(sitePath, \"vite.config.ts\")) ||\n          fs.existsSync(path.join(sitePath, \"vite.config.js\")),\n      );\n    }\n    function loadBuildOutput() {\n      return {\n        buildMeta: $dev ? loadBuildMetadataPlaceholder() : loadBuildMetadata(),\n      };\n    }\n    function loadBuildMetadata() {\n      return all([outputPath, isUsingVite]).apply(\n        ([outputPath, isUsingVite]) => {\n          // The path for all files that need to be in the \"/\" directory (static assets)\n          // is different when using Vite. These will be located in the \"build/client\"\n          // path of the output. It will be the \"public\" folder when using remix config.\n          const assetsPath = isUsingVite\n            ? path.join(\"build\", \"client\")\n            : \"public\";\n          const assetsVersionedSubDir = isUsingVite ? undefined : \"build\";\n          return {\n            assetsPath,\n            assetsVersionedSubDir,\n            // create 1 behaviour for each top level asset file/folder\n            staticRoutes: fs\n              .readdirSync(path.join(outputPath, assetsPath), {\n                withFileTypes: true,\n              })\n              .map((item) =>\n                item.isDirectory() ? `${item.name}/(.*)` : item.name,\n              ),\n          };\n        },\n      );\n    }\n    function loadBuildMetadataPlaceholder() {\n      return {\n        assetsPath: \"placeholder\",\n        assetsVersionedSubDir: undefined,\n        staticRoutes: [],\n      };\n    }\n    function buildPlan() {\n      return all([isUsingVite, outputPath, buildMeta]).apply(\n        ([isUsingVite, outputPath, buildMeta]) => {\n          return validatePlan({\n            server: createServerLambdaBundle(isUsingVite, outputPath),\n            assets: {\n              copy: [\n                {\n                  from: buildMeta.assetsPath,\n                  to: \"\",\n                  cached: true,\n                  versionedSubDir: buildMeta.assetsVersionedSubDir,\n                },\n              ],\n            },\n            routes: [\n              {\n                regex: pathToRegexp(buildMeta.staticRoutes).source,\n                origin: \"assets\" as const,\n              },\n              {\n                regex: pathToRegexp(\"(.*)\").source,\n                origin: \"server\" as const,\n              },\n            ],\n          });\n        },\n      );\n    }\n    function createServerLambdaBundle(\n      isUsingVite: boolean,\n      outputPath: string,\n    ) {\n      // Create a Lambda@Edge handler for the Remix server bundle.\n      //\n      // Note: Remix does perform their own internal ESBuild process, but it\n      // doesn't bundle 3rd party dependencies by default. In the interest of\n      // keeping deployments seamless for users we will create a server bundle\n      // with all dependencies included. We will still need to consider how to\n      // address any need for external dependencies, although I think we should\n      // possibly consider this at a later date.\n      // In this path we are assuming that the Remix build only outputs the\n      // \"core server build\". We can safely assume this as we have guarded the\n      // remix.config.js to ensure it matches our expectations for the build\n      // configuration.\n      // We need to ensure that the \"core server build\" is wrapped with an\n      // appropriate Lambda@Edge handler. We will utilise an internal asset\n      // template to create this wrapper within the \"core server build\" output\n      // directory.\n      // Ensure build directory exists\n      const buildPath = path.join(outputPath, \"build\");\n      fs.mkdirSync(buildPath, { recursive: true });\n      // Copy the server lambda handler and pre-append the build injection based\n      // on the config file used.\n      const content = [\n        // When using Vite config, the output build will be \"server/index.js\"\n        // and when using Remix config it will be `server.js`.\n        //isUsingVite\n        //  ? `import * as remixServerBuild from \"./server/index.js\";`\n        //  : `import * as remixServerBuild from \"./index.js\";`,\n        //`import { createRequestHandler } from \"@remix-run/cloudflare\";`,\n        //`import * as remixServerBuild from \"./server\";`,\n        //`import { createRequestHandler } from \"@remix-run/cloudflare\";`,\n        //`export default {`,\n        //`  async fetch(request) {`,\n        //`    const requestHandler = createRequestHandler(remixServerBuild);`,\n        //`    return await requestHandler(request);`,\n        //`  },`,\n        //`};`,\n        `import { createRequestHandler } from \"@remix-run/cloudflare\";`,\n        `import * as build from \"./server/index.js\";`,\n        `export default {`,\n        `  async fetch(request) {`,\n        `    console.log(\"fetch\");`,\n        `    console.log(\"build\", build);`,\n        `    console.log(\"build mode\", build.mode);`,\n        `    const handleRequest = createRequestHandler(build);`,\n        `    console.log(\"handleRequest\", handleRequest);`,\n        `    return await handleRequest(request);`,\n        `  },`,\n        `};`,\n      ].join(\"\\n\");\n      fs.writeFileSync(path.join(buildPath, \"server.ts\"), content);\n      const nodeBuiltInModulesPlugin: Plugin = {\n        name: \"node:built-in:modules\",\n        setup(build) {\n          build.onResolve({ filter: /^(util|stream)$/ }, ({ kind, path }) => {\n            // this plugin converts `require(\"node:*\")` calls, those are the only ones that\n            // need updating (esm imports to \"node:*\" are totally valid), so here we tag with the\n            // node-buffer namespace only imports that are require calls\n            return kind === \"require-call\"\n              ? { path, namespace: \"node-built-in-modules\" }\n              : undefined;\n          });\n          // we convert the imports we tagged with the node-built-in-modules namespace so that instead of `require(\"node:*\")`\n          // they import from `export * from \"node:*\";`\n          build.onLoad(\n            { filter: /.*/, namespace: \"node-built-in-modules\" },\n            ({ path }) => {\n              return {\n                contents: `export * from 'node:${path}'`,\n                loader: \"js\",\n              };\n            },\n          );\n        },\n      };\n      return {\n        handler: path.join(buildPath, \"server.ts\"),\n        build: {\n          esbuild: {\n            define: {\n              process: JSON.stringify({\n                env: {\n                  //NODE_ENV: \"production\",\n                  NODE_ENV: \"development\",\n                },\n              }),\n            },\n            plugins: [nodeBuiltInModulesPlugin],\n          },\n        },\n      };\n    }\n  }"
        },
        {
          "type": "function",
          "name": "Get-url",
          "label": "Get-url",
          "start_line": 1,
          "end_line": 234,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/184.ts: Remix\n%0 = this.<@ts_files/184.ts: Remix.router>\n%1 = %0.<@%unk/%unk: .url>\nreturn %1",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "public get url() {\n    return this.router.url;\n  }"
        },
        {
          "type": "function",
          "name": "Get-nodes",
          "label": "Get-nodes",
          "start_line": 1,
          "end_line": 237,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/184.ts: Remix\n%0 = new @ts_files/184.ts: %AC$Remix$Get-nodes$23\ninstanceinvoke %0.<@ts_files/184.ts: %AC$Remix$Get-nodes$23.constructor()>()\nreturn %0",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "public get nodes() {\n    return {\n      server: this.server,\n      assets: this.assets,\n    };\n  }"
        },
        {
          "type": "function",
          "name": "getSSTLink",
          "label": "getSSTLink",
          "start_line": 1,
          "end_line": 243,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/184.ts: Remix\n%0 = new @ts_files/184.ts: %AC$Remix$getSSTLink$24\ninstanceinvoke %0.<@ts_files/184.ts: %AC$Remix$getSSTLink$24.constructor()>()\nreturn %0",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "public getSSTLink() {\n    return {\n      properties: {\n        url: this.url,\n      },\n    };\n  }"
        },
        {
          "type": "function",
          "name": "%AM0$%checkIsUsingVite$constructor",
          "label": "%AM0$%checkIsUsingVite$constructor",
          "start_line": 1,
          "end_line": 67,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "sitePath = parameter0: unknown\nthis = this: @ts_files/184.ts: Remix\n%0 = instanceinvoke path.<@%unk/%unk: .join()>(sitePath, 'vite.config.ts')\n%1 = instanceinvoke fs.<@%unk/%unk: .existsSync()>(%0)\n%2 = instanceinvoke path.<@%unk/%unk: .join()>(sitePath, 'vite.config.js')\n%3 = instanceinvoke fs.<@%unk/%unk: .existsSync()>(%2)\n%4 = %1 || %3\nreturn %4",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "(sitePath) =>\n          fs.existsSync(path.join(sitePath, \"vite.config.ts\")) ||\n          fs.existsSync(path.join(sitePath, \"vite.config.js\"))"
        },
        {
          "type": "function",
          "name": "%checkIsUsingVite$constructor",
          "label": "%checkIsUsingVite$constructor",
          "start_line": 1,
          "end_line": 65,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "%closures0 = parameter0: [sitePath]\nsitePath = %closures0.sitePath\nthis = this: @ts_files/184.ts: Remix\n%0 = instanceinvoke sitePath.<@%unk/%unk: .apply()>(%AM0$%checkIsUsingVite$constructor)\nreturn %0",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "function checkIsUsingVite() {\n      return sitePath.apply(\n        (sitePath) =>\n          fs.existsSync(path.join(sitePath, \"vite.config.ts\")) ||\n          fs.existsSync(path.join(sitePath, \"vite.config.js\")),\n      );\n    }"
        },
        {
          "type": "function",
          "name": "%loadBuildOutput$constructor",
          "label": "%loadBuildOutput$constructor",
          "start_line": 1,
          "end_line": 72,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/184.ts: Remix\n%0 = new @ts_files/184.ts: %AC$Remix$%loadBuildOutput$constructor$2\ninstanceinvoke %0.<@ts_files/184.ts: %AC$Remix$%loadBuildOutput$constructor$2.constructor()>()\nreturn %0",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "function loadBuildOutput() {\n      return {\n        buildMeta: $dev ? loadBuildMetadataPlaceholder() : loadBuildMetadata(),\n      };\n    }"
        },
        {
          "type": "function",
          "name": "%AM1$%loadBuildMetadata$constructor",
          "label": "%AM1$%loadBuildMetadata$constructor",
          "start_line": 1,
          "end_line": 79,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "ArrayBindingPattern = parameter0: unknown\nthis = this: @ts_files/184.ts: Remix\nif isUsingVite != 0",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "assetsPath = instanceinvoke path.<@%unk/%unk: .join()>('build', 'client')",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "if isUsingVite != 0",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "assetsVersionedSubDir = undefined",
                          "start_line": 1,
                          "end_line": 1,
                          "successors": [
                            {
                              "type": "block",
                              "name": "Block?",
                              "label": "%2 = new @ts_files/184.ts: %AC$Remix$%AM1$%loadBuildMetadata$constructor$3\ninstanceinvoke %2.<@ts_files/184.ts: %AC$Remix$%AM1$%loadBuildMetadata$constructor$3.constructor()>()\nreturn %2",
                              "start_line": 1,
                              "end_line": 1,
                              "successors": []
                            }
                          ]
                        },
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "assetsVersionedSubDir = 'build'",
                          "start_line": 1,
                          "end_line": 1,
                          "successors": [
                            {
                              "type": "blockRef",
                              "label": "(RepeatedBlock)"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "assetsPath = 'public'",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "blockRef",
                      "label": "(RepeatedBlock)"
                    }
                  ]
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "([outputPath, isUsingVite]) => {\n          // The path for all files that need to be in the \"/\" directory (static assets)\n          // is different when using Vite. These will be located in the \"build/client\"\n          // path of the output. It will be the \"public\" folder when using remix config.\n          const assetsPath = isUsingVite\n            ? path.join(\"build\", \"client\")\n            : \"public\";\n          const assetsVersionedSubDir = isUsingVite ? undefined : \"build\";\n          return {\n            assetsPath,\n            assetsVersionedSubDir,\n            // create 1 behaviour for each top level asset file/folder\n            staticRoutes: fs\n              .readdirSync(path.join(outputPath, assetsPath), {\n                withFileTypes: true,\n              })\n              .map((item) =>\n                item.isDirectory() ? `${item.name}/(.*)` : item.name,\n              ),\n          };\n        }"
        },
        {
          "type": "function",
          "name": "%loadBuildMetadata$constructor",
          "label": "%loadBuildMetadata$constructor",
          "start_line": 1,
          "end_line": 77,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "%closures1 = parameter0: [outputPath, isUsingVite]\noutputPath = %closures1.outputPath\nisUsingVite = %closures1.isUsingVite\nthis = this: @ts_files/184.ts: Remix\n%0 = newarray (unknown)[2]\n%0[0] = outputPath\n%0[1] = isUsingVite\n%1 = staticinvoke <@%unk/%unk: .all()>(%0)\n%2 = instanceinvoke %1.<@%unk/%unk: .apply()>(%AM1$%loadBuildMetadata$constructor)\nreturn %2",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "function loadBuildMetadata() {\n      return all([outputPath, isUsingVite]).apply(\n        ([outputPath, isUsingVite]) => {\n          // The path for all files that need to be in the \"/\" directory (static assets)\n          // is different when using Vite. These will be located in the \"build/client\"\n          // path of the output. It will be the \"public\" folder when using remix config.\n          const assetsPath = isUsingVite\n            ? path.join(\"build\", \"client\")\n            : \"public\";\n          const assetsVersionedSubDir = isUsingVite ? undefined : \"build\";\n          return {\n            assetsPath,\n            assetsVersionedSubDir,\n            // create 1 behaviour for each top level asset file/folder\n            staticRoutes: fs\n              .readdirSync(path.join(outputPath, assetsPath), {\n                withFileTypes: true,\n              })\n              .map((item) =>\n                item.isDirectory() ? `${item.name}/(.*)` : item.name,\n              ),\n          };\n        },\n      );\n    }"
        },
        {
          "type": "function",
          "name": "%loadBuildMetadataPlaceholder$constructor",
          "label": "%loadBuildMetadataPlaceholder$constructor",
          "start_line": 1,
          "end_line": 102,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/184.ts: Remix\n%0 = new @ts_files/184.ts: %AC$Remix$%loadBuildMetadataPlaceholder$constructor$5\ninstanceinvoke %0.<@ts_files/184.ts: %AC$Remix$%loadBuildMetadataPlaceholder$constructor$5.constructor()>()\nreturn %0",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "function loadBuildMetadataPlaceholder() {\n      return {\n        assetsPath: \"placeholder\",\n        assetsVersionedSubDir: undefined,\n        staticRoutes: [],\n      };\n    }"
        },
        {
          "type": "function",
          "name": "%AM2$%buildPlan$constructor",
          "label": "%AM2$%buildPlan$constructor",
          "start_line": 1,
          "end_line": 111,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "ArrayBindingPattern = parameter0: unknown\nthis = this: @ts_files/184.ts: Remix\n%0 = new @ts_files/184.ts: %AC$Remix$%AM2$%buildPlan$constructor$6\ninstanceinvoke %0.<@ts_files/184.ts: %AC$Remix$%AM2$%buildPlan$constructor$6.constructor()>()\n%1 = staticinvoke <@%unk/%unk: .validatePlan()>(%0)\nreturn %1",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "([isUsingVite, outputPath, buildMeta]) => {\n          return validatePlan({\n            server: createServerLambdaBundle(isUsingVite, outputPath),\n            assets: {\n              copy: [\n                {\n                  from: buildMeta.assetsPath,\n                  to: \"\",\n                  cached: true,\n                  versionedSubDir: buildMeta.assetsVersionedSubDir,\n                },\n              ],\n            },\n            routes: [\n              {\n                regex: pathToRegexp(buildMeta.staticRoutes).source,\n                origin: \"assets\" as const,\n              },\n              {\n                regex: pathToRegexp(\"(.*)\").source,\n                origin: \"server\" as const,\n              },\n            ],\n          });\n        }"
        },
        {
          "type": "function",
          "name": "%buildPlan$constructor",
          "label": "%buildPlan$constructor",
          "start_line": 1,
          "end_line": 109,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "%closures2 = parameter0: [isUsingVite, outputPath, buildMeta]\nisUsingVite = %closures2.isUsingVite\noutputPath = %closures2.outputPath\nbuildMeta = %closures2.buildMeta\nthis = this: @ts_files/184.ts: Remix\n%0 = newarray (unknown)[3]\n%0[0] = isUsingVite\n%0[1] = outputPath\n%0[2] = buildMeta\n%1 = staticinvoke <@%unk/%unk: .all()>(%0)\n%2 = instanceinvoke %1.<@%unk/%unk: .apply()>(%AM2$%buildPlan$constructor)\nreturn %2",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "function buildPlan() {\n      return all([isUsingVite, outputPath, buildMeta]).apply(\n        ([isUsingVite, outputPath, buildMeta]) => {\n          return validatePlan({\n            server: createServerLambdaBundle(isUsingVite, outputPath),\n            assets: {\n              copy: [\n                {\n                  from: buildMeta.assetsPath,\n                  to: \"\",\n                  cached: true,\n                  versionedSubDir: buildMeta.assetsVersionedSubDir,\n                },\n              ],\n            },\n            routes: [\n              {\n                regex: pathToRegexp(buildMeta.staticRoutes).source,\n                origin: \"assets\" as const,\n              },\n              {\n                regex: pathToRegexp(\"(.*)\").source,\n                origin: \"server\" as const,\n              },\n            ],\n          });\n        },\n      );\n    }"
        },
        {
          "type": "function",
          "name": "%createServerLambdaBundle$constructor",
          "label": "%createServerLambdaBundle$constructor",
          "start_line": 1,
          "end_line": 138,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "isUsingVite = parameter0: boolean\noutputPath = parameter1: string\nthis = this: @ts_files/184.ts: Remix\nbuildPath = instanceinvoke path.<@%unk/%unk: .join()>(outputPath, 'build')\n%0 = new @ts_files/184.ts: %AC$Remix$%createServerLambdaBundle$constructor$11\ninstanceinvoke %0.<@ts_files/184.ts: %AC$Remix$%createServerLambdaBundle$constructor$11.constructor()>()\ninstanceinvoke fs.<@%unk/%unk: .mkdirSync()>(buildPath, %0)\n%1 = newarray (string)[12]\n%1[0] = 'import { createRequestHandler } from \"@remix-run/cloudflare\";'\n%1[1] = 'import * as build from \"./server/index.js\";'\n%1[2] = 'export default {'\n%1[3] = '  async fetch(request) {'\n%1[4] = '    console.log(\"fetch\");'\n%1[5] = '    console.log(\"build\", build);'\n%1[6] = '    console.log(\"build mode\", build.mode);'\n%1[7] = '    const handleRequest = createRequestHandler(build);'\n%1[8] = '    console.log(\"handleRequest\", handleRequest);'\n%1[9] = '    return await handleRequest(request);'\n%1[10] = '  },'\n%1[11] = '};'\ncontent = instanceinvoke %1.<@%unk/%unk: .join()>('\n')\n%2 = instanceinvoke path.<@%unk/%unk: .join()>(buildPath, 'server.ts')\ninstanceinvoke fs.<@%unk/%unk: .writeFileSync()>(%2, content)\n%3 = new @ts_files/184.ts: %AC$Remix$%createServerLambdaBundle$constructor$12\ninstanceinvoke %3.<@ts_files/184.ts: %AC$Remix$%createServerLambdaBundle$constructor$12.constructor()>()\nnodeBuiltInModulesPlugin = %3\n%4 = new @ts_files/184.ts: %AC$Remix$%createServerLambdaBundle$constructor$17\ninstanceinvoke %4.<@ts_files/184.ts: %AC$Remix$%createServerLambdaBundle$constructor$17.constructor()>()\nreturn %4",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "function createServerLambdaBundle(\n      isUsingVite: boolean,\n      outputPath: string,\n    ) {\n      // Create a Lambda@Edge handler for the Remix server bundle.\n      //\n      // Note: Remix does perform their own internal ESBuild process, but it\n      // doesn't bundle 3rd party dependencies by default. In the interest of\n      // keeping deployments seamless for users we will create a server bundle\n      // with all dependencies included. We will still need to consider how to\n      // address any need for external dependencies, although I think we should\n      // possibly consider this at a later date.\n      // In this path we are assuming that the Remix build only outputs the\n      // \"core server build\". We can safely assume this as we have guarded the\n      // remix.config.js to ensure it matches our expectations for the build\n      // configuration.\n      // We need to ensure that the \"core server build\" is wrapped with an\n      // appropriate Lambda@Edge handler. We will utilise an internal asset\n      // template to create this wrapper within the \"core server build\" output\n      // directory.\n      // Ensure build directory exists\n      const buildPath = path.join(outputPath, \"build\");\n      fs.mkdirSync(buildPath, { recursive: true });\n      // Copy the server lambda handler and pre-append the build injection based\n      // on the config file used.\n      const content = [\n        // When using Vite config, the output build will be \"server/index.js\"\n        // and when using Remix config it will be `server.js`.\n        //isUsingVite\n        //  ? `import * as remixServerBuild from \"./server/index.js\";`\n        //  : `import * as remixServerBuild from \"./index.js\";`,\n        //`import { createRequestHandler } from \"@remix-run/cloudflare\";`,\n        //`import * as remixServerBuild from \"./server\";`,\n        //`import { createRequestHandler } from \"@remix-run/cloudflare\";`,\n        //`export default {`,\n        //`  async fetch(request) {`,\n        //`    const requestHandler = createRequestHandler(remixServerBuild);`,\n        //`    return await requestHandler(request);`,\n        //`  },`,\n        //`};`,\n        `import { createRequestHandler } from \"@remix-run/cloudflare\";`,\n        `import * as build from \"./server/index.js\";`,\n        `export default {`,\n        `  async fetch(request) {`,\n        `    console.log(\"fetch\");`,\n        `    console.log(\"build\", build);`,\n        `    console.log(\"build mode\", build.mode);`,\n        `    const handleRequest = createRequestHandler(build);`,\n        `    console.log(\"handleRequest\", handleRequest);`,\n        `    return await handleRequest(request);`,\n        `  },`,\n        `};`,\n      ].join(\"\\n\");\n      fs.writeFileSync(path.join(buildPath, \"server.ts\"), content);\n      const nodeBuiltInModulesPlugin: Plugin = {\n        name: \"node:built-in:modules\",\n        setup(build) {\n          build.onResolve({ filter: /^(util|stream)$/ }, ({ kind, path }) => {\n            // this plugin converts `require(\"node:*\")` calls, those are the only ones that\n            // need updating (esm imports to \"node:*\" are totally valid), so here we tag with the\n            // node-buffer namespace only imports that are require calls\n            return kind === \"require-call\"\n              ? { path, namespace: \"node-built-in-modules\" }\n              : undefined;\n          });\n          // we convert the imports we tagged with the node-built-in-modules namespace so that instead of `require(\"node:*\")`\n          // they import from `export * from \"node:*\";`\n          build.onLoad(\n            { filter: /.*/, namespace: \"node-built-in-modules\" },\n            ({ path }) => {\n              return {\n                contents: `export * from 'node:${path}'`,\n                loader: \"js\",\n              };\n            },\n          );\n        },\n      };\n      return {\n        handler: path.join(buildPath, \"server.ts\"),\n        build: {\n          esbuild: {\n            define: {\n              process: JSON.stringify({\n                env: {\n                  //NODE_ENV: \"production\",\n                  NODE_ENV: \"development\",\n                },\n              }),\n            },\n            plugins: [nodeBuiltInModulesPlugin],\n          },\n        },\n      };\n    }"
        }
      ],
      "classes": [],
      "blocks": [],
      "simplified_code": "export class Remix extends Component implements Link.Linkable {\n  private assets: Kv;\n  private router: Output<Worker>;\n  private server: Output<Worker>;\n  constructor(\n    name: string,\n    args: RemixArgs = {},\n    opts: ComponentResourceOptions = {},\n  ) {\n    super(__pulumiType, name, args, opts);\n    const parent = this;\n    const { sitePath } = prepare(args);\n    const isUsingVite = checkIsUsingVite();\n    const storage = createKvStorage(parent, name, args);\n    const outputPath = $dev ? sitePath : buildApp(parent, name, args, sitePath);\n    const { buildMeta } = loadBuildOutput();\n    const plan = buildPlan();\n    const { router, server } = createRouter(\n      parent,\n      name,\n      args,\n      outputPath,\n      storage,\n      plan,\n    );\n    this.assets = storage;\n    this.router = router;\n    this.server = server;\n    if (!$dev) {\n      Hint.register(this.urn, this.url as Output<string>);\n    }\n    this.registerOutputs({\n      _metadata: {\n        mode: $dev ? \"placeholder\" : \"deployed\",\n        path: sitePath,\n        url: this.url,\n      },\n    });\n    function checkIsUsingVite() {\n      return sitePath.apply(\n        (sitePath) =>\n          fs.existsSync(path.join(sitePath, \"vite.config.ts\")) ||\n          fs.existsSync(path.join(sitePath, \"vite.config.js\")),\n      );\n    }\n    function loadBuildOutput() {\n      return {\n        buildMeta: $dev ? loadBuildMetadataPlaceholder() : loadBuildMetadata(),\n      };\n    }\n    function loadBuildMetadata() {\n      return all([outputPath, isUsingVite]).apply(\n        ([outputPath, isUsingVite]) => {\n          // The path for all files that need to be in the \"/\" directory (static assets)\n          // is different when using Vite. These will be located in the \"build/client\"\n          // path of the output. It will be the \"public\" folder when using remix config.\n          const assetsPath = isUsingVite\n            ? path.join(\"build\", \"client\")\n            : \"public\";\n          const assetsVersionedSubDir = isUsingVite ? undefined : \"build\";\n          return {\n            assetsPath,\n            assetsVersionedSubDir,\n            // create 1 behaviour for each top level asset file/folder\n            staticRoutes: fs\n              .readdirSync(path.join(outputPath, assetsPath), {\n                withFileTypes: true,\n              })\n              .map((item) =>\n                item.isDirectory() ? `${item.name}/(.*)` : item.name,\n              ),\n          };\n        },\n      );\n    }\n    function loadBuildMetadataPlaceholder() {\n      return {\n        assetsPath: \"placeholder\",\n        assetsVersionedSubDir: undefined,\n        staticRoutes: [],\n      };\n    }\n    function buildPlan() {\n      return all([isUsingVite, outputPath, buildMeta]).apply(\n        ([isUsingVite, outputPath, buildMeta]) => {\n          return validatePlan({\n            server: createServerLambdaBundle(isUsingVite, outputPath),\n            assets: {\n              copy: [\n                {\n                  from: buildMeta.assetsPath,\n                  to: \"\",\n                  cached: true,\n                  versionedSubDir: buildMeta.assetsVersionedSubDir,\n                },\n              ],\n            },\n            routes: [\n              {\n                regex: pathToRegexp(buildMeta.staticRoutes).source,\n                origin: \"assets\" as const,\n              },\n              {\n                regex: pathToRegexp(\"(.*)\").source,\n                origin: \"server\" as const,\n              },\n            ],\n          });\n        },\n      );\n    }\n    function createServerLambdaBundle(\n      isUsingVite: boolean,\n      outputPath: string,\n    ) {\n      // Create a Lambda@Edge handler for the Remix server bundle.\n      //\n      // Note: Remix does perform their own internal ESBuild process, but it\n      // doesn't bundle 3rd party dependencies by default. In the interest of\n      // keeping deployments seamless for users we will create a server bundle\n      // with all dependencies included. We will still need to consider how to\n      // address any need for external dependencies, although I think we should\n      // possibly consider this at a later date.\n      // In this path we are assuming that the Remix build only outputs the\n      // \"core server build\". We can safely assume this as we have guarded the\n      // remix.config.js to ensure it matches our expectations for the build\n      // configuration.\n      // We need to ensure that the \"core server build\" is wrapped with an\n      // appropriate Lambda@Edge handler. We will utilise an internal asset\n      // template to create this wrapper within the \"core server build\" output\n      // directory.\n      // Ensure build directory exists\n      const buildPath = path.join(outputPath, \"build\");\n      fs.mkdirSync(buildPath, { recursive: true });\n      // Copy the server lambda handler and pre-append the build injection based\n      // on the config file used.\n      const content = [\n        // When using Vite config, the output build will be \"server/index.js\"\n        // and when using Remix config it will be `server.js`.\n        //isUsingVite\n        //  ? `import * as remixServerBuild from \"./server/index.js\";`\n        //  : `import * as remixServerBuild from \"./index.js\";`,\n        //`import { createRequestHandler } from \"@remix-run/cloudflare\";`,\n        //`import * as remixServerBuild from \"./server\";`,\n        //`import { createRequestHandler } from \"@remix-run/cloudflare\";`,\n        //`export default {`,\n        //`  async fetch(request) {`,\n        //`    const requestHandler = createRequestHandler(remixServerBuild);`,\n        //`    return await requestHandler(request);`,\n        //`  },`,\n        //`};`,\n        `import { createRequestHandler } from \"@remix-run/cloudflare\";`,\n        `import * as build from \"./server/index.js\";`,\n        `export default {`,\n        `  async fetch(request) {`,\n        `    console.log(\"fetch\");`,\n        `    console.log(\"build\", build);`,\n        `    console.log(\"build mode\", build.mode);`,\n        `    const handleRequest = createRequestHandler(build);`,\n        `    console.log(\"handleRequest\", handleRequest);`,\n        `    return await handleRequest(request);`,\n        `  },`,\n        `};`,\n      ].join(\"\\n\");\n      fs.writeFileSync(path.join(buildPath, \"server.ts\"), content);\n      const nodeBuiltInModulesPlugin: Plugin = {\n        name: \"node:built-in:modules\",\n        setup(build) {\n          build.onResolve({ filter: /^(util|stream)$/ }, ({ kind, path }) => {\n            // this plugin converts `require(\"node:*\")` calls, those are the only ones that\n            // need updating (esm imports to \"node:*\" are totally valid), so here we tag with the\n            // node-buffer namespace only imports that are require calls\n            return kind === \"require-call\"\n              ? { path, namespace: \"node-built-in-modules\" }\n              : undefined;\n          });\n          // we convert the imports we tagged with the node-built-in-modules namespace so that instead of `require(\"node:*\")`\n          // they import from `export * from \"node:*\";`\n          build.onLoad(\n            { filter: /.*/, namespace: \"node-built-in-modules\" },\n            ({ path }) => {\n              return {\n                contents: `export * from 'node:${path}'`,\n                loader: \"js\",\n              };\n            },\n          );\n        },\n      };\n      return {\n        handler: path.join(buildPath, \"server.ts\"),\n        build: {\n          esbuild: {\n            define: {\n              process: JSON.stringify({\n                env: {\n                  //NODE_ENV: \"production\",\n                  NODE_ENV: \"development\",\n                },\n              }),\n            },\n            plugins: [nodeBuiltInModulesPlugin],\n          },\n        },\n      };\n    }\n  }\n  public get url() {\n    return this.router.url;\n  }\n  public get nodes() {\n    return {\n      server: this.server,\n      assets: this.assets,\n    };\n  }\n  public getSSTLink() {\n    return {\n      properties: {\n        url: this.url,\n      },\n    };\n  }\n}"
    },
    {
      "type": "class",
      "name": "%AC$%AC$Remix$constructor$0$%instInit$1",
      "label": "%AC$%AC$Remix$constructor$0$%instInit$1",
      "start_line": 59,
      "end_line": 59,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n        mode: $dev ? \"placeholder\" : \"deployed\",\n        path: sitePath,\n        url: this.url,\n      }"
    },
    {
      "type": "class",
      "name": "%AC$Remix$constructor$0",
      "label": "%AC$Remix$constructor$0",
      "start_line": 58,
      "end_line": 58,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n      _metadata: {\n        mode: $dev ? \"placeholder\" : \"deployed\",\n        path: sitePath,\n        url: this.url,\n      },\n    }"
    },
    {
      "type": "class",
      "name": "%AC$Remix$%loadBuildOutput$constructor$2",
      "label": "%AC$Remix$%loadBuildOutput$constructor$2",
      "start_line": 73,
      "end_line": 73,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n        buildMeta: $dev ? loadBuildMetadataPlaceholder() : loadBuildMetadata(),\n      }"
    },
    {
      "type": "class",
      "name": "%AC$%AC$Remix$%AM1$%loadBuildMetadata$constructor$3$%instInit$4",
      "label": "%AC$%AC$Remix$%AM1$%loadBuildMetadata$constructor$3$%instInit$4",
      "start_line": 92,
      "end_line": 92,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n                withFileTypes: true,\n              }"
    },
    {
      "type": "class",
      "name": "%AC$Remix$%AM1$%loadBuildMetadata$constructor$3",
      "label": "%AC$Remix$%AM1$%loadBuildMetadata$constructor$3",
      "start_line": 1,
      "end_line": 95,
      "functions": [
        {
          "type": "function",
          "name": "%AM0$%instInit",
          "label": "%AM0$%instInit",
          "start_line": 1,
          "end_line": 95,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "item = parameter0: unknown\nthis = this: @ts_files/184.ts: Remix\n%0 = instanceinvoke item.<@%unk/%unk: .isDirectory()>()\nif %0 != 0\nConditionalOperatorIfTrue0\n%1 = item.<@%unk/%unk: .name>\n%2 = %1 + '/(.*)'\n%3 = %2\nConditionalOperatorIfFalse0\n%3 = item.<@%unk/%unk: .name>\nConditionalOperatorEnd0\nreturn %3",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "(item) =>\n                item.isDirectory() ? `${item.name}/(.*)` : item.name"
        }
      ],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n            assetsPath,\n            assetsVersionedSubDir,\n            // create 1 behaviour for each top level asset file/folder\n            staticRoutes: fs\n              .readdirSync(path.join(outputPath, assetsPath), {\n                withFileTypes: true,\n              })\n              .map((item) =>\n                item.isDirectory() ? `${item.name}/(.*)` : item.name,\n              ),\n          }"
    },
    {
      "type": "class",
      "name": "%AC$Remix$%loadBuildMetadataPlaceholder$constructor$5",
      "label": "%AC$Remix$%loadBuildMetadataPlaceholder$constructor$5",
      "start_line": 103,
      "end_line": 103,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n        assetsPath: \"placeholder\",\n        assetsVersionedSubDir: undefined,\n        staticRoutes: [],\n      }"
    },
    {
      "type": "class",
      "name": "%AC$%AC$%AC$Remix$%AM2$%buildPlan$constructor$6$%instInit$7$%instInit$8",
      "label": "%AC$%AC$%AC$Remix$%AM2$%buildPlan$constructor$6$%instInit$7$%instInit$8",
      "start_line": 116,
      "end_line": 116,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n                  from: buildMeta.assetsPath,\n                  to: \"\",\n                  cached: true,\n                  versionedSubDir: buildMeta.assetsVersionedSubDir,\n                }"
    },
    {
      "type": "class",
      "name": "%AC$%AC$Remix$%AM2$%buildPlan$constructor$6$%instInit$7",
      "label": "%AC$%AC$Remix$%AM2$%buildPlan$constructor$6$%instInit$7",
      "start_line": 114,
      "end_line": 114,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n              copy: [\n                {\n                  from: buildMeta.assetsPath,\n                  to: \"\",\n                  cached: true,\n                  versionedSubDir: buildMeta.assetsVersionedSubDir,\n                },\n              ],\n            }"
    },
    {
      "type": "class",
      "name": "%AC$%AC$Remix$%AM2$%buildPlan$constructor$6$%instInit$9",
      "label": "%AC$%AC$Remix$%AM2$%buildPlan$constructor$6$%instInit$9",
      "start_line": 125,
      "end_line": 125,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n                regex: pathToRegexp(buildMeta.staticRoutes).source,\n                origin: \"assets\" as const,\n              }"
    },
    {
      "type": "class",
      "name": "%AC$%AC$Remix$%AM2$%buildPlan$constructor$6$%instInit$10",
      "label": "%AC$%AC$Remix$%AM2$%buildPlan$constructor$6$%instInit$10",
      "start_line": 129,
      "end_line": 129,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n                regex: pathToRegexp(\"(.*)\").source,\n                origin: \"server\" as const,\n              }"
    },
    {
      "type": "class",
      "name": "%AC$Remix$%AM2$%buildPlan$constructor$6",
      "label": "%AC$Remix$%AM2$%buildPlan$constructor$6",
      "start_line": 112,
      "end_line": 112,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n            server: createServerLambdaBundle(isUsingVite, outputPath),\n            assets: {\n              copy: [\n                {\n                  from: buildMeta.assetsPath,\n                  to: \"\",\n                  cached: true,\n                  versionedSubDir: buildMeta.assetsVersionedSubDir,\n                },\n              ],\n            },\n            routes: [\n              {\n                regex: pathToRegexp(buildMeta.staticRoutes).source,\n                origin: \"assets\" as const,\n              },\n              {\n                regex: pathToRegexp(\"(.*)\").source,\n                origin: \"server\" as const,\n              },\n            ],\n          }"
    },
    {
      "type": "class",
      "name": "%AC$Remix$%createServerLambdaBundle$constructor$11",
      "label": "%AC$Remix$%createServerLambdaBundle$constructor$11",
      "start_line": 160,
      "end_line": 160,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{ recursive: true }"
    },
    {
      "type": "class",
      "name": "%AC$%AC$Remix$%createServerLambdaBundle$constructor$12$setup$13",
      "label": "%AC$%AC$Remix$%createServerLambdaBundle$constructor$12$setup$13",
      "start_line": 195,
      "end_line": 195,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{ filter: /^(util|stream)$/ }"
    },
    {
      "type": "class",
      "name": "%AC$%AC$Remix$%createServerLambdaBundle$constructor$12$%AM0$setup$14",
      "label": "%AC$%AC$Remix$%createServerLambdaBundle$constructor$12$%AM0$setup$14",
      "start_line": 200,
      "end_line": 200,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{ path, namespace: \"node-built-in-modules\" }"
    },
    {
      "type": "class",
      "name": "%AC$%AC$Remix$%createServerLambdaBundle$constructor$12$setup$15",
      "label": "%AC$%AC$Remix$%createServerLambdaBundle$constructor$12$setup$15",
      "start_line": 206,
      "end_line": 206,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{ filter: /.*/, namespace: \"node-built-in-modules\" }"
    },
    {
      "type": "class",
      "name": "%AC$%AC$Remix$%createServerLambdaBundle$constructor$12$%AM1$setup$16",
      "label": "%AC$%AC$Remix$%createServerLambdaBundle$constructor$12$%AM1$setup$16",
      "start_line": 208,
      "end_line": 208,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n                contents: `export * from 'node:${path}'`,\n                loader: \"js\",\n              }"
    },
    {
      "type": "class",
      "name": "%AC$Remix$%createServerLambdaBundle$constructor$12",
      "label": "%AC$Remix$%createServerLambdaBundle$constructor$12",
      "start_line": 1,
      "end_line": 244,
      "functions": [
        {
          "type": "function",
          "name": "%AM0$setup",
          "label": "%AM0$setup",
          "start_line": 1,
          "end_line": 195,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "ObjectBindingPattern = parameter0: unknown\nthis = this: @ts_files/184.ts: Remix\nif kind === 'require-call'",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%0 = new @ts_files/184.ts: %AC$%AC$Remix$%createServerLambdaBundle$constructor$12$%AM0$setup$14\ninstanceinvoke %0.<@ts_files/184.ts: %AC$%AC$Remix$%createServerLambdaBundle$constructor$12$%AM0$setup$14.constructor()>()\n%1 = %0",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "return %1",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": []
                    }
                  ]
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%1 = undefined",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "blockRef",
                      "label": "(RepeatedBlock)"
                    }
                  ]
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "({ kind, path }) => {\n            // this plugin converts `require(\"node:*\")` calls, those are the only ones that\n            // need updating (esm imports to \"node:*\" are totally valid), so here we tag with the\n            // node-buffer namespace only imports that are require calls\n            return kind === \"require-call\"\n              ? { path, namespace: \"node-built-in-modules\" }\n              : undefined;\n          }"
        },
        {
          "type": "function",
          "name": "%AM1$setup",
          "label": "%AM1$setup",
          "start_line": 1,
          "end_line": 207,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "ObjectBindingPattern = parameter0: unknown\nthis = this: @ts_files/184.ts: Remix\n%0 = new @ts_files/184.ts: %AC$%AC$Remix$%createServerLambdaBundle$constructor$12$%AM1$setup$16\ninstanceinvoke %0.<@ts_files/184.ts: %AC$%AC$Remix$%createServerLambdaBundle$constructor$12$%AM1$setup$16.constructor()>()\nreturn %0",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "({ path }) => {\n              return {\n                contents: `export * from 'node:${path}'`,\n                loader: \"js\",\n              };\n            }"
        },
        {
          "type": "function",
          "name": "setup",
          "label": "setup",
          "start_line": 1,
          "end_line": 244,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "build = parameter0: unknown\nthis = this: @ts_files/184.ts: Remix\n%0 = new @ts_files/184.ts: %AC$%AC$Remix$%createServerLambdaBundle$constructor$12$setup$13\ninstanceinvoke %0.<@ts_files/184.ts: %AC$%AC$Remix$%createServerLambdaBundle$constructor$12$setup$13.constructor()>()\ninstanceinvoke build.<@%unk/%unk: .onResolve()>(%0, %AM0$setup)\n%1 = new @ts_files/184.ts: %AC$%AC$Remix$%createServerLambdaBundle$constructor$12$setup$15\ninstanceinvoke %1.<@ts_files/184.ts: %AC$%AC$Remix$%createServerLambdaBundle$constructor$12$setup$15.constructor()>()\ninstanceinvoke build.<@%unk/%unk: .onLoad()>(%1, %AM1$setup)\nreturn",
              "start_line": 1,
              "end_line": 244,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "setup(build) {\n          build.onResolve({ filter: /^(util|stream)$/ }, ({ kind, path }) => {\n            // this plugin converts `require(\"node:*\")` calls, those are the only ones that\n            // need updating (esm imports to \"node:*\" are totally valid), so here we tag with the\n            // node-buffer namespace only imports that are require calls\n            return kind === \"require-call\"\n              ? { path, namespace: \"node-built-in-modules\" }\n              : undefined;\n          });\n          // we convert the imports we tagged with the node-built-in-modules namespace so that instead of `require(\"node:*\")`\n          // they import from `export * from \"node:*\";`\n          build.onLoad(\n            { filter: /.*/, namespace: \"node-built-in-modules\" },\n            ({ path }) => {\n              return {\n                contents: `export * from 'node:${path}'`,\n                loader: \"js\",\n              };\n            },\n          );\n        }"
        }
      ],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n        name: \"node:built-in:modules\",\n        setup(build) {\n          build.onResolve({ filter: /^(util|stream)$/ }, ({ kind, path }) => {\n            // this plugin converts `require(\"node:*\")` calls, those are the only ones that\n            // need updating (esm imports to \"node:*\" are totally valid), so here we tag with the\n            // node-buffer namespace only imports that are require calls\n            return kind === \"require-call\"\n              ? { path, namespace: \"node-built-in-modules\" }\n              : undefined;\n          });\n          // we convert the imports we tagged with the node-built-in-modules namespace so that instead of `require(\"node:*\")`\n          // they import from `export * from \"node:*\";`\n          build.onLoad(\n            { filter: /.*/, namespace: \"node-built-in-modules\" },\n            ({ path }) => {\n              return {\n                contents: `export * from 'node:${path}'`,\n                loader: \"js\",\n              };\n            },\n          );\n        },\n      }"
    },
    {
      "type": "class",
      "name": "%AC$%AC$%AC$%AC$%AC$%AC$Remix$%createServerLambdaBundle$constructor$17$%instInit$18$%instInit$19$%instInit$20$%instInit$21$%instInit$22",
      "label": "%AC$%AC$%AC$%AC$%AC$%AC$Remix$%createServerLambdaBundle$constructor$17$%instInit$18$%instInit$19$%instInit$20$%instInit$21$%instInit$22",
      "start_line": 222,
      "end_line": 222,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n                  //NODE_ENV: \"production\",\n                  NODE_ENV: \"development\",\n                }"
    },
    {
      "type": "class",
      "name": "%AC$%AC$%AC$%AC$%AC$Remix$%createServerLambdaBundle$constructor$17$%instInit$18$%instInit$19$%instInit$20$%instInit$21",
      "label": "%AC$%AC$%AC$%AC$%AC$Remix$%createServerLambdaBundle$constructor$17$%instInit$18$%instInit$19$%instInit$20$%instInit$21",
      "start_line": 221,
      "end_line": 221,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n                env: {\n                  //NODE_ENV: \"production\",\n                  NODE_ENV: \"development\",\n                },\n              }"
    },
    {
      "type": "class",
      "name": "%AC$%AC$%AC$%AC$Remix$%createServerLambdaBundle$constructor$17$%instInit$18$%instInit$19$%instInit$20",
      "label": "%AC$%AC$%AC$%AC$Remix$%createServerLambdaBundle$constructor$17$%instInit$18$%instInit$19$%instInit$20",
      "start_line": 220,
      "end_line": 220,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n              process: JSON.stringify({\n                env: {\n                  //NODE_ENV: \"production\",\n                  NODE_ENV: \"development\",\n                },\n              }),\n            }"
    },
    {
      "type": "class",
      "name": "%AC$%AC$%AC$Remix$%createServerLambdaBundle$constructor$17$%instInit$18$%instInit$19",
      "label": "%AC$%AC$%AC$Remix$%createServerLambdaBundle$constructor$17$%instInit$18$%instInit$19",
      "start_line": 219,
      "end_line": 219,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n            define: {\n              process: JSON.stringify({\n                env: {\n                  //NODE_ENV: \"production\",\n                  NODE_ENV: \"development\",\n                },\n              }),\n            },\n            plugins: [nodeBuiltInModulesPlugin],\n          }"
    },
    {
      "type": "class",
      "name": "%AC$%AC$Remix$%createServerLambdaBundle$constructor$17$%instInit$18",
      "label": "%AC$%AC$Remix$%createServerLambdaBundle$constructor$17$%instInit$18",
      "start_line": 218,
      "end_line": 218,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n          esbuild: {\n            define: {\n              process: JSON.stringify({\n                env: {\n                  //NODE_ENV: \"production\",\n                  NODE_ENV: \"development\",\n                },\n              }),\n            },\n            plugins: [nodeBuiltInModulesPlugin],\n          },\n        }"
    },
    {
      "type": "class",
      "name": "%AC$Remix$%createServerLambdaBundle$constructor$17",
      "label": "%AC$Remix$%createServerLambdaBundle$constructor$17",
      "start_line": 216,
      "end_line": 216,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n        handler: path.join(buildPath, \"server.ts\"),\n        build: {\n          esbuild: {\n            define: {\n              process: JSON.stringify({\n                env: {\n                  //NODE_ENV: \"production\",\n                  NODE_ENV: \"development\",\n                },\n              }),\n            },\n            plugins: [nodeBuiltInModulesPlugin],\n          },\n        },\n      }"
    },
    {
      "type": "class",
      "name": "%AC$Remix$Get-nodes$23",
      "label": "%AC$Remix$Get-nodes$23",
      "start_line": 238,
      "end_line": 238,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n      server: this.server,\n      assets: this.assets,\n    }"
    },
    {
      "type": "class",
      "name": "%AC$%AC$Remix$getSSTLink$24$%instInit$25",
      "label": "%AC$%AC$Remix$getSSTLink$24$%instInit$25",
      "start_line": 245,
      "end_line": 245,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n        url: this.url,\n      }"
    },
    {
      "type": "class",
      "name": "%AC$Remix$getSSTLink$24",
      "label": "%AC$Remix$getSSTLink$24",
      "start_line": 244,
      "end_line": 244,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n      properties: {\n        url: this.url,\n      },\n    }"
    }
  ],
  "functions": [],
  "blocks": [],
  "simplified_code": "import fs from \"fs\";\nimport path from \"path\";\nimport { ComponentResourceOptions, Output, all } from \"@pulumi/pulumi\";\nimport {\n  SsrSiteArgs,\n  createKvStorage,\n  createRouter,\n  prepare,\n  validatePlan,\n} from \"./ssr-site.js\";\nimport { Component } from \"../component.js\";\nimport { Hint } from \"../hint.js\";\nimport { Link } from \"../link.js\";\nimport { Kv } from \"./kv.js\";\nimport { buildApp } from \"../base/base-ssr-site.js\";\nimport { Worker } from \"./worker.js\";\nimport { Plugin } from \"esbuild\";\nimport { pathToRegexp } from \"../../util/path-to-regex.js\";\nexport interface RemixArgs extends SsrSiteArgs {\n  assets?: SsrSiteArgs[\"assets\"];\n  buildCommand?: SsrSiteArgs[\"buildCommand\"];\n  domain?: SsrSiteArgs[\"domain\"];\n  environment?: SsrSiteArgs[\"environment\"];\n  link?: SsrSiteArgs[\"link\"];\n  path?: SsrSiteArgs[\"path\"];\n}\nexport class Remix extends Component implements Link.Linkable {\n  private assets: Kv;\n  private router: Output<Worker>;\n  private server: Output<Worker>;\n  constructor(\n    name: string,\n    args: RemixArgs = {},\n    opts: ComponentResourceOptions = {},\n  ) {\n    super(__pulumiType, name, args, opts);\n    const parent = this;\n    const { sitePath } = prepare(args);\n    const isUsingVite = checkIsUsingVite();\n    const storage = createKvStorage(parent, name, args);\n    const outputPath = $dev ? sitePath : buildApp(parent, name, args, sitePath);\n    const { buildMeta } = loadBuildOutput();\n    const plan = buildPlan();\n    const { router, server } = createRouter(\n      parent,\n      name,\n      args,\n      outputPath,\n      storage,\n      plan,\n    );\n    this.assets = storage;\n    this.router = router;\n    this.server = server;\n    if (!$dev) {\n      Hint.register(this.urn, this.url as Output<string>);\n    }\n    this.registerOutputs({\n      _metadata: {\n        mode: $dev ? \"placeholder\" : \"deployed\",\n        path: sitePath,\n        url: this.url,\n      },\n    });\n    function checkIsUsingVite() {\n      return sitePath.apply(\n        (sitePath) =>\n          fs.existsSync(path.join(sitePath, \"vite.config.ts\")) ||\n          fs.existsSync(path.join(sitePath, \"vite.config.js\")),\n      );\n    }\n    function loadBuildOutput() {\n      return {\n        buildMeta: $dev ? loadBuildMetadataPlaceholder() : loadBuildMetadata(),\n      };\n    }\n    function loadBuildMetadata() {\n      return all([outputPath, isUsingVite]).apply(\n        ([outputPath, isUsingVite]) => {\n          // The path for all files that need to be in the \"/\" directory (static assets)\n          // is different when using Vite. These will be located in the \"build/client\"\n          // path of the output. It will be the \"public\" folder when using remix config.\n          const assetsPath = isUsingVite\n            ? path.join(\"build\", \"client\")\n            : \"public\";\n          const assetsVersionedSubDir = isUsingVite ? undefined : \"build\";\n          return {\n            assetsPath,\n            assetsVersionedSubDir,\n            // create 1 behaviour for each top level asset file/folder\n            staticRoutes: fs\n              .readdirSync(path.join(outputPath, assetsPath), {\n                withFileTypes: true,\n              })\n              .map((item) =>\n                item.isDirectory() ? `${item.name}/(.*)` : item.name,\n              ),\n          };\n        },\n      );\n    }\n    function loadBuildMetadataPlaceholder() {\n      return {\n        assetsPath: \"placeholder\",\n        assetsVersionedSubDir: undefined,\n        staticRoutes: [],\n      };\n    }\n    function buildPlan() {\n      return all([isUsingVite, outputPath, buildMeta]).apply(\n        ([isUsingVite, outputPath, buildMeta]) => {\n          return validatePlan({\n            server: createServerLambdaBundle(isUsingVite, outputPath),\n            assets: {\n              copy: [\n                {\n                  from: buildMeta.assetsPath,\n                  to: \"\",\n                  cached: true,\n                  versionedSubDir: buildMeta.assetsVersionedSubDir,\n                },\n              ],\n            },\n            routes: [\n              {\n                regex: pathToRegexp(buildMeta.staticRoutes).source,\n                origin: \"assets\" as const,\n              },\n              {\n                regex: pathToRegexp(\"(.*)\").source,\n                origin: \"server\" as const,\n              },\n            ],\n          });\n        },\n      );\n    }\n    function createServerLambdaBundle(\n      isUsingVite: boolean,\n      outputPath: string,\n    ) {\n      // Create a Lambda@Edge handler for the Remix server bundle.\n      //\n      // Note: Remix does perform their own internal ESBuild process, but it\n      // doesn't bundle 3rd party dependencies by default. In the interest of\n      // keeping deployments seamless for users we will create a server bundle\n      // with all dependencies included. We will still need to consider how to\n      // address any need for external dependencies, although I think we should\n      // possibly consider this at a later date.\n      // In this path we are assuming that the Remix build only outputs the\n      // \"core server build\". We can safely assume this as we have guarded the\n      // remix.config.js to ensure it matches our expectations for the build\n      // configuration.\n      // We need to ensure that the \"core server build\" is wrapped with an\n      // appropriate Lambda@Edge handler. We will utilise an internal asset\n      // template to create this wrapper within the \"core server build\" output\n      // directory.\n      // Ensure build directory exists\n      const buildPath = path.join(outputPath, \"build\");\n      fs.mkdirSync(buildPath, { recursive: true });\n      // Copy the server lambda handler and pre-append the build injection based\n      // on the config file used.\n      const content = [\n        // When using Vite config, the output build will be \"server/index.js\"\n        // and when using Remix config it will be `server.js`.\n        //isUsingVite\n        //  ? `import * as remixServerBuild from \"./server/index.js\";`\n        //  : `import * as remixServerBuild from \"./index.js\";`,\n        //`import { createRequestHandler } from \"@remix-run/cloudflare\";`,\n        //`import * as remixServerBuild from \"./server\";`,\n        //`import { createRequestHandler } from \"@remix-run/cloudflare\";`,\n        //`export default {`,\n        //`  async fetch(request) {`,\n        //`    const requestHandler = createRequestHandler(remixServerBuild);`,\n        //`    return await requestHandler(request);`,\n        //`  },`,\n        //`};`,\n        `import { createRequestHandler } from \"@remix-run/cloudflare\";`,\n        `import * as build from \"./server/index.js\";`,\n        `export default {`,\n        `  async fetch(request) {`,\n        `    console.log(\"fetch\");`,\n        `    console.log(\"build\", build);`,\n        `    console.log(\"build mode\", build.mode);`,\n        `    const handleRequest = createRequestHandler(build);`,\n        `    console.log(\"handleRequest\", handleRequest);`,\n        `    return await handleRequest(request);`,\n        `  },`,\n        `};`,\n      ].join(\"\\n\");\n      fs.writeFileSync(path.join(buildPath, \"server.ts\"), content);\n      const nodeBuiltInModulesPlugin: Plugin = {\n        name: \"node:built-in:modules\",\n        setup(build) {\n          build.onResolve({ filter: /^(util|stream)$/ }, ({ kind, path }) => {\n            // this plugin converts `require(\"node:*\")` calls, those are the only ones that\n            // need updating (esm imports to \"node:*\" are totally valid), so here we tag with the\n            // node-buffer namespace only imports that are require calls\n            return kind === \"require-call\"\n              ? { path, namespace: \"node-built-in-modules\" }\n              : undefined;\n          });\n          // we convert the imports we tagged with the node-built-in-modules namespace so that instead of `require(\"node:*\")`\n          // they import from `export * from \"node:*\";`\n          build.onLoad(\n            { filter: /.*/, namespace: \"node-built-in-modules\" },\n            ({ path }) => {\n              return {\n                contents: `export * from 'node:${path}'`,\n                loader: \"js\",\n              };\n            },\n          );\n        },\n      };\n      return {\n        handler: path.join(buildPath, \"server.ts\"),\n        build: {\n          esbuild: {\n            define: {\n              process: JSON.stringify({\n                env: {\n                  //NODE_ENV: \"production\",\n                  NODE_ENV: \"development\",\n                },\n              }),\n            },\n            plugins: [nodeBuiltInModulesPlugin],\n          },\n        },\n      };\n    }\n  }\n  public get url() {\n    return this.router.url;\n  }\n  public get nodes() {\n    return {\n      server: this.server,\n      assets: this.assets,\n    };\n  }\n  public getSSTLink() {\n    return {\n      properties: {\n        url: this.url,\n      },\n    };\n  }\n}\nconst __pulumiType = \"sst:cloudflare:Remix\";\n// @ts-expect-error\nRemix.__pulumiType = __pulumiType;"
}