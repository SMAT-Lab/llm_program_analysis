{
  "type": "file",
  "name": "143.ts",
  "label": "143.ts",
  "start_line": -1,
  "end_line": 261,
  "classes": [
    {
      "type": "class",
      "name": "%dflt",
      "label": "%dflt",
      "start_line": -1,
      "end_line": 261,
      "functions": [
        {
          "type": "function",
          "name": "%dflt",
          "label": "%dflt",
          "start_line": -1,
          "end_line": 261,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/143.ts: %dflt\n%0 = newarray (any)[0]\nTMP_TRANSFORM = <any[]>%0\nreturn",
              "start_line": 1,
              "end_line": 261,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": ""
        },
        {
          "type": "function",
          "name": "transformPoints",
          "label": "transformPoints",
          "start_line": 1,
          "end_line": 10,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "points = parameter0: number[][]\ntransform = parameter1: matrix.MatrixArray\nthis = this: @ts_files/143.ts: %dflt\np = 0",
              "start_line": 1,
              "end_line": 10,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%0 = points.<@%unk/%unk: .length>\nif p < %0",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "%1 = points[p]\n%2 = points[p]\ninstanceinvoke vec2.<@%unk/%unk: .applyTransform()>(%1, %2, transform)\np = p + 1",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "blockRef",
                          "label": "(RepeatedBlock)"
                        }
                      ]
                    },
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "return",
                      "start_line": 23,
                      "end_line": 261,
                      "successors": []
                    }
                  ]
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "function transformPoints(points: number[][], transform: matrix.MatrixArray) {\n    for (let p = 0; p < points.length; p++) {\n        vec2.applyTransform(points[p], points[p], transform);\n    }\n}"
        },
        {
          "type": "function",
          "name": "updateBBoxFromPoints",
          "label": "updateBBoxFromPoints",
          "start_line": 1,
          "end_line": 203,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "points = parameter0: ArrayLike<number>[]\nmin = parameter1: vec2.VectorArray\nmax = parameter2: vec2.VectorArray\nprojection = parameter3: GeoProjection\nthis = this: @ts_files/143.ts: %dflt\ni = 0",
              "start_line": 1,
              "end_line": 203,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%0 = points.<@%unk/%unk: .length>\nif i < %0",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "p = points[i]\nif projection != 0",
                      "start_line": 21,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "%1 = <number[]>p\np = instanceinvoke projection.<@%unk/%unk: .project()>(%1)",
                          "start_line": 1,
                          "end_line": 1,
                          "successors": [
                            {
                              "type": "block",
                              "name": "Block?",
                              "label": "%2 = p.<@%unk/%unk: .0>\n%3 = staticinvoke <@%unk/%unk: .isFinite()>(%2)\n%4 = p && %3\n%5 = p.<@%unk/%unk: .1>\n%6 = staticinvoke <@%unk/%unk: .isFinite()>(%5)\n%7 = %4 && %6\nif %7 != false",
                              "start_line": 1,
                              "end_line": 1,
                              "successors": [
                                {
                                  "type": "block",
                                  "name": "Block?",
                                  "label": "%8 = <vec2.VectorArray>p\ninstanceinvoke vec2.<@%unk/%unk: .min()>(min, min, %8)\n%9 = <vec2.VectorArray>p\ninstanceinvoke vec2.<@%unk/%unk: .max()>(max, max, %9)",
                                  "start_line": 1,
                                  "end_line": 1,
                                  "successors": [
                                    {
                                      "type": "block",
                                      "name": "Block?",
                                      "label": "i = i + 1",
                                      "start_line": 1,
                                      "end_line": 1,
                                      "successors": [
                                        {
                                          "type": "blockRef",
                                          "label": "(RepeatedBlock)"
                                        }
                                      ]
                                    }
                                  ]
                                },
                                {
                                  "type": "blockRef",
                                  "label": "(RepeatedBlock)"
                                }
                              ]
                            }
                          ]
                        },
                        {
                          "type": "blockRef",
                          "label": "(RepeatedBlock)"
                        }
                      ]
                    },
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "return",
                      "start_line": 23,
                      "end_line": 261,
                      "successors": []
                    }
                  ]
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "function updateBBoxFromPoints(\n    points: ArrayLike<number>[],\n    min: vec2.VectorArray,\n    max: vec2.VectorArray,\n    projection: GeoProjection\n) {\n    for (let i = 0; i < points.length; i++) {\n        let p = points[i];\n        if (projection) {\n            // projection may return null point.\n            p = projection.project(p as number[]);\n        }\n        if (p && isFinite(p[0]) && isFinite(p[1])) {\n            vec2.min(min, min, p as vec2.VectorArray);\n            vec2.max(max, max, p as vec2.VectorArray);\n        }\n    }\n}"
        },
        {
          "type": "function",
          "name": "centroid",
          "label": "centroid",
          "start_line": 1,
          "end_line": 203,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "points = parameter0: number[][]\nthis = this: @ts_files/143.ts: %dflt\nsignedArea = 0\ncx = 0\ncy = 0\nlen = points.<@%unk/%unk: .length>\n%0 = len - 1\n%1 = points[%0]\nx0 = %1[0]\n%2 = len - 1\n%3 = points[%2]\ny0 = %3[1]\ni = 0",
              "start_line": 1,
              "end_line": 203,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "if i < len",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "%4 = points[i]\nx1 = %4[0]\n%5 = points[i]\ny1 = %5[1]\n%6 = x0 * y1\n%7 = x1 * y0\na = %6 - %7\nsignedArea = signedArea + a\n%8 = x0 + x1\ncx = cx + %8 * a\n%9 = y0 + y1\ncy = cy + %9 * a\nx0 = x1\ny0 = y1\ni = i + 1",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "blockRef",
                          "label": "(RepeatedBlock)"
                        }
                      ]
                    },
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "if signedArea != 0",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "%10 = cx / signedArea\n%11 = %10 / 3\n%12 = cy / signedArea\n%13 = %12 / 3\n%14 = newarray (number)[3]\n%14[0] = %11\n%14[1] = %13\n%14[2] = signedArea\n%15 = %14",
                          "start_line": 1,
                          "end_line": 1,
                          "successors": [
                            {
                              "type": "block",
                              "name": "Block?",
                              "label": "return %15",
                              "start_line": 1,
                              "end_line": 1,
                              "successors": []
                            }
                          ]
                        },
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "%16 = points[0]\n%17 = %16[0]\n%18 = %17 || 0\n%19 = points[0]\n%20 = %19[1]\n%21 = %20 || 0\n%22 = newarray (boolean)[2]\n%22[0] = %18\n%22[1] = %21\n%15 = %22",
                          "start_line": 1,
                          "end_line": 1,
                          "successors": [
                            {
                              "type": "blockRef",
                              "label": "(RepeatedBlock)"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "function centroid(points: number[][]) {\n    let signedArea = 0;\n    let cx = 0;\n    let cy = 0;\n    const len = points.length;\n    let x0 = points[len - 1][0];\n    let y0 = points[len - 1][1];\n    // Polygon should been closed.\n    for (let i = 0; i < len; i++) {\n        const x1 = points[i][0];\n        const y1 = points[i][1];\n        const a = x0 * y1 - x1 * y0;\n        signedArea += a;\n        cx += (x0 + x1) * a;\n        cy += (y0 + y1) * a;\n        x0 = x1;\n        y0 = y1;\n    }\n    return signedArea\n        ? [cx / signedArea / 3, cy / signedArea / 3, signedArea]\n        : [points[0][0] || 0, points[0][1] || 0];\n}"
        }
      ],
      "classes": [],
      "blocks": [],
      "simplified_code": ""
    },
    {
      "type": "class",
      "name": "Region",
      "label": "Region",
      "start_line": 0,
      "end_line": 261,
      "functions": [
        {
          "type": "function",
          "name": "constructor",
          "label": "constructor",
          "start_line": 1,
          "end_line": 261,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "instanceinvoke this.<@ts_files/143.ts: Region.%instInit()>()\nname = parameter0: string\nthis = this: @ts_files/143.ts: Region\nthis.<@ts_files/143.ts: Region.name> = name\nreturn",
              "start_line": 1,
              "end_line": 261,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "constructor(\n        name: string\n    ) {\n        this.name = name;\n    }"
        },
        {
          "type": "function",
          "name": "setCenter",
          "label": "setCenter",
          "start_line": 1,
          "end_line": 261,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "center = parameter0: number[]\nthis = this: @ts_files/143.ts: Region\nthis.<@ts_files/143.ts: Region._center> = center\nreturn",
              "start_line": 1,
              "end_line": 261,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "setCenter(center: number[]) {\n        this._center = center;\n    }"
        },
        {
          "type": "function",
          "name": "getCenter",
          "label": "getCenter",
          "start_line": 1,
          "end_line": 67,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/143.ts: Region\ncenter = this.<@ts_files/143.ts: Region._center>\n%0 = !center\nif %0 != 0",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%1 = instanceinvoke this.<@ts_files/143.ts: Region.calcCenter()>()\nthis.<@ts_files/143.ts: Region._center> = %1\ncenter = this.<@ts_files/143.ts: Region._center>",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "return center",
                      "start_line": 74,
                      "end_line": 261,
                      "successors": []
                    }
                  ]
                },
                {
                  "type": "blockRef",
                  "label": "(RepeatedBlock)"
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "getCenter() {\n        let center = this._center;\n        if (!center) {\n            // In most cases there are no need to calculate this center.\n            // So calculate only when called.\n            center = this._center = this.calcCenter();\n        }\n        return center;\n    }"
        },
        {
          "type": "function",
          "name": "calcCenter",
          "label": "calcCenter",
          "start_line": 0,
          "end_line": 0,
          "blocks": [],
          "functions": [],
          "classes": [],
          "simplified_code": "abstract calcCenter(): number[];"
        }
      ],
      "classes": [],
      "blocks": [],
      "simplified_code": "export abstract class Region {\n    readonly name: string;\n    readonly type: 'geoJSON' | 'geoSVG';\n    protected _center: number[];\n    protected _rect: BoundingRect;\n    constructor(\n        name: string\n    ) {\n        this.name = name;\n    }\n    setCenter(center: number[]) {\n        this._center = center;\n    }\n    getCenter() {\n        let center = this._center;\n        if (!center) {\n            // In most cases there are no need to calculate this center.\n            // So calculate only when called.\n            center = this._center = this.calcCenter();\n        }\n        return center;\n    }\n    abstract calcCenter(): number[];\n}"
    },
    {
      "type": "class",
      "name": "GeoJSONPolygonGeometry",
      "label": "GeoJSONPolygonGeometry",
      "start_line": 1,
      "end_line": 261,
      "functions": [
        {
          "type": "function",
          "name": "constructor",
          "label": "constructor",
          "start_line": 1,
          "end_line": 261,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "instanceinvoke this.<@ts_files/143.ts: GeoJSONPolygonGeometry.%instInit()>()\nexterior = parameter0: number[][]\ninteriors = parameter1: number[][][]\nthis = this: @ts_files/143.ts: GeoJSONPolygonGeometry\nthis.<@ts_files/143.ts: GeoJSONPolygonGeometry.exterior> = exterior\nthis.<@ts_files/143.ts: GeoJSONPolygonGeometry.interiors> = interiors\nreturn",
              "start_line": 1,
              "end_line": 261,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "constructor(exterior: number[][], interiors: number[][][]) {\n        this.exterior = exterior;\n        this.interiors = interiors;\n    }"
        }
      ],
      "classes": [],
      "blocks": [],
      "simplified_code": "export class GeoJSONPolygonGeometry {\n    readonly type = 'polygon';\n    exterior: number[][];\n    interiors?: number[][][];\n    constructor(exterior: number[][], interiors: number[][][]) {\n        this.exterior = exterior;\n        this.interiors = interiors;\n    }\n}"
    },
    {
      "type": "class",
      "name": "GeoJSONLineStringGeometry",
      "label": "GeoJSONLineStringGeometry",
      "start_line": 1,
      "end_line": 261,
      "functions": [
        {
          "type": "function",
          "name": "constructor",
          "label": "constructor",
          "start_line": 1,
          "end_line": 261,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "instanceinvoke this.<@ts_files/143.ts: GeoJSONLineStringGeometry.%instInit()>()\npoints = parameter0: number[][][]\nthis = this: @ts_files/143.ts: GeoJSONLineStringGeometry\nthis.<@ts_files/143.ts: GeoJSONLineStringGeometry.points> = points\nreturn",
              "start_line": 1,
              "end_line": 261,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "constructor(points: number[][][]) {\n        this.points = points;\n    }"
        }
      ],
      "classes": [],
      "blocks": [],
      "simplified_code": "export class GeoJSONLineStringGeometry {\n    readonly type = 'linestring';\n    points: number[][][];\n    constructor(points: number[][][]) {\n        this.points = points;\n    }\n}"
    },
    {
      "type": "class",
      "name": "GeoJSONRegion",
      "label": "GeoJSONRegion",
      "start_line": 1,
      "end_line": 261,
      "functions": [
        {
          "type": "function",
          "name": "constructor",
          "label": "constructor",
          "start_line": 1,
          "end_line": 261,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "instanceinvoke this.<@ts_files/143.ts: GeoJSONRegion.%instInit()>()\nname = parameter0: string\ngeometries = parameter1: IndexedAccessType\ncp = parameter2: IndexedAccessType\nthis = this: @ts_files/143.ts: GeoJSONRegion\nstaticinvoke <@%unk/%unk: .super()>(name)\nthis.<@ts_files/143.ts: GeoJSONRegion.geometries> = geometries\n%0 = cp.<@%unk/%unk: .0>\n%1 = cp.<@%unk/%unk: .1>\n%2 = newarray (unknown)[2]\n%2[0] = %0\n%2[1] = %1\n%3 = cp && %2\nthis.<@ts_files/143.ts: Region._center> = %3\nreturn",
              "start_line": 1,
              "end_line": 261,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "constructor(\n        name: string,\n        geometries: GeoJSONRegion['geometries'],\n        cp: GeoJSON['features'][0]['properties']['cp']\n    ) {\n        super(name);\n        this.geometries = geometries;\n        this._center = cp && [cp[0], cp[1]];\n    }"
        },
        {
          "type": "function",
          "name": "calcCenter",
          "label": "calcCenter",
          "start_line": 1,
          "end_line": 203,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/143.ts: GeoJSONRegion\ngeometries = this.<@ts_files/143.ts: GeoJSONRegion.geometries>\nlargestGeo = undefined\nlargestGeoSize = 0\ni = 0",
              "start_line": 1,
              "end_line": 203,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%0 = geometries.<@%unk/%unk: .length>\nif i < %0",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "%1 = geometries[i]\ngeo = <@ts_files/143.ts: GeoJSONPolygonGeometry>%1\nexterior = geo.<@ts_files/143.ts: GeoJSONPolygonGeometry.exterior>\n%2 = exterior.<@%unk/%unk: .length>\nsize = exterior && %2\nif size > largestGeoSize",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "largestGeo = geo\nlargestGeoSize = size",
                          "start_line": 119,
                          "end_line": 120,
                          "successors": [
                            {
                              "type": "block",
                              "name": "Block?",
                              "label": "i = i + 1",
                              "start_line": 1,
                              "end_line": 1,
                              "successors": [
                                {
                                  "type": "blockRef",
                                  "label": "(RepeatedBlock)"
                                }
                              ]
                            }
                          ]
                        },
                        {
                          "type": "blockRef",
                          "label": "(RepeatedBlock)"
                        }
                      ]
                    },
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "if largestGeo != undefined",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "%3 = largestGeo.<@ts_files/143.ts: GeoJSONPolygonGeometry.exterior>\n%4 = staticinvoke <@ts_files/143.ts: %dflt.centroid(number[][])>(%3)\nreturn %4",
                          "start_line": 1,
                          "end_line": 1,
                          "successors": []
                        },
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "rect = instanceinvoke this.<@ts_files/143.ts: GeoJSONRegion.getBoundingRect(GeoProjection)>()\n%5 = rect.<@%unk/%unk: .x>\n%6 = rect.<@%unk/%unk: .width>\n%7 = %6 / 2\n%8 = %5 + %7\n%9 = rect.<@%unk/%unk: .y>\n%10 = rect.<@%unk/%unk: .height>\n%11 = %10 / 2\n%12 = %9 + %11\n%13 = newarray (unknown)[2]\n%13[0] = %8\n%13[1] = %12\nreturn %13",
                          "start_line": 1,
                          "end_line": 1,
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "calcCenter() {\n        const geometries = this.geometries;\n        let largestGeo: GeoJSONPolygonGeometry;\n        let largestGeoSize = 0;\n        for (let i = 0; i < geometries.length; i++) {\n            const geo = geometries[i] as GeoJSONPolygonGeometry;\n            const exterior = geo.exterior;\n            // Simple trick to use points count instead of polygon area as region size.\n            // Ignore linestring\n            const size = exterior && exterior.length;\n            if (size > largestGeoSize) {\n                largestGeo = geo;\n                largestGeoSize = size;\n            }\n        }\n        if (largestGeo) {\n            return centroid(largestGeo.exterior);\n        }\n        // from bounding rect by default.\n        const rect = this.getBoundingRect();\n        return [\n            rect.x + rect.width / 2,\n            rect.y + rect.height / 2\n        ];\n    }"
        },
        {
          "type": "function",
          "name": "getBoundingRect",
          "label": "getBoundingRect",
          "start_line": 1,
          "end_line": 133,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "projection = parameter0: GeoProjection\nthis = this: @ts_files/143.ts: GeoJSONRegion\nrect = this.<@ts_files/143.ts: Region._rect>\n%0 = !projection\n%1 = rect && %0\nif %1 != false",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "return rect",
                  "start_line": 137,
                  "end_line": 163,
                  "successors": []
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%2 = newarray (unknown)[2]\n%2[0] = Infinity\n%2[1] = Infinity\nmin = %2\n%3 = -Infinity\n%4 = -Infinity\n%5 = newarray (unknown)[2]\n%5[0] = %3\n%5[1] = %4\nmax = %5\ngeometries = this.<@ts_files/143.ts: GeoJSONRegion.geometries>\nstaticinvoke <@%unk/%unk: .each()>(geometries, %AM0$getBoundingRect)\n%6 = min[0]\n%7 = staticinvoke <@%unk/%unk: .isFinite()>(%6)\n%8 = min[1]\n%9 = staticinvoke <@%unk/%unk: .isFinite()>(%8)\n%10 = %7 && %9\n%11 = max[0]\n%12 = staticinvoke <@%unk/%unk: .isFinite()>(%11)\n%13 = %10 && %12\n%14 = max[1]\n%15 = staticinvoke <@%unk/%unk: .isFinite()>(%14)\n%16 = %13 && %15\n%17 = !%16\nif %17 != false",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "max[1] = 0\n%18 = max[1]\nmax[0] = %18\n%19 = max[0]\nmin[1] = %19\n%20 = min[1]\nmin[0] = %20",
                      "start_line": 155,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "%21 = new @%unk/%unk: BoundingRect\n%22 = min[0]\n%23 = min[1]\n%24 = max[0]\n%25 = min[0]\n%26 = %24 - %25\n%27 = max[1]\n%28 = min[1]\n%29 = %27 - %28\ninstanceinvoke %21.<@%unk/%unk: BoundingRect.constructor()>(%22, %23, %26, %29)\nrect = %21\n%30 = !projection\nif %30 != 0",
                          "start_line": 1,
                          "end_line": 1,
                          "successors": [
                            {
                              "type": "block",
                              "name": "Block?",
                              "label": "this.<@ts_files/143.ts: Region._rect> = rect",
                              "start_line": 1,
                              "end_line": 1,
                              "successors": [
                                {
                                  "type": "block",
                                  "name": "Block?",
                                  "label": "return rect",
                                  "start_line": 137,
                                  "end_line": 163,
                                  "successors": []
                                }
                              ]
                            },
                            {
                              "type": "blockRef",
                              "label": "(RepeatedBlock)"
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "type": "blockRef",
                      "label": "(RepeatedBlock)"
                    }
                  ]
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "getBoundingRect(projection?: GeoProjection): BoundingRect {\n        let rect = this._rect;\n        // Always recalculate if using projection.\n        if (rect && !projection) {\n            return rect;\n        }\n        const min = [Infinity, Infinity];\n        const max = [-Infinity, -Infinity];\n        const geometries = this.geometries;\n        each(geometries, geo => {\n            if (geo.type === 'polygon') {\n                // Doesn't consider hole\n                updateBBoxFromPoints(geo.exterior, min, max, projection);\n            }\n            else {\n                each(geo.points, (points) => {\n                    updateBBoxFromPoints(points, min, max, projection);\n                });\n            }\n        });\n        // Normalie invalid bounding.\n        if (!(isFinite(min[0]) && isFinite(min[1]) && isFinite(max[0]) && isFinite(max[1]))) {\n            min[0] = min[1] = max[0] = max[1] = 0;\n        }\n        rect = new BoundingRect(\n            min[0], min[1], max[0] - min[0], max[1] - min[1]\n        );\n        if (!projection) {\n            this._rect = rect;\n        }\n        return rect;\n    }"
        },
        {
          "type": "function",
          "name": "contain",
          "label": "contain",
          "start_line": 1,
          "end_line": 165,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "coord = parameter0: number[]\nthis = this: @ts_files/143.ts: GeoJSONRegion\nrect = instanceinvoke this.<@ts_files/143.ts: GeoJSONRegion.getBoundingRect(GeoProjection)>()\ngeometries = this.<@ts_files/143.ts: GeoJSONRegion.geometries>\n%0 = coord[0]\n%1 = coord[1]\n%2 = instanceinvoke rect.<@%unk/%unk: .contain()>(%0, %1)\n%3 = !%2\nif %3 != 0",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "return false",
                  "start_line": 169,
                  "end_line": 189,
                  "successors": []
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "return false",
                  "start_line": 169,
                  "end_line": 189,
                  "successors": []
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "contain(coord: number[]): boolean {\n        const rect = this.getBoundingRect();\n        const geometries = this.geometries;\n        if (!rect.contain(coord[0], coord[1])) {\n            return false;\n        }\n        loopGeo: for (let i = 0, len = geometries.length; i < len; i++) {\n            const geo = geometries[i];\n            // Only support polygon.\n            if (geo.type !== 'polygon') {\n                continue;\n            }\n            const exterior = geo.exterior;\n            const interiors = geo.interiors;\n            if (polygonContain.contain(exterior, coord[0], coord[1])) {\n                // Not in the region if point is in the hole.\n                for (let k = 0; k < (interiors ? interiors.length : 0); k++) {\n                    if (polygonContain.contain(interiors[k], coord[0], coord[1])) {\n                        continue loopGeo;\n                    }\n                }\n                return true;\n            }\n        }\n        return false;\n    }"
        },
        {
          "type": "function",
          "name": "transformTo",
          "label": "transformTo",
          "start_line": 1,
          "end_line": 191,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "x = parameter0: number\ny = parameter1: number\nwidth = parameter2: number\nheight = parameter3: number\nthis = this: @ts_files/143.ts: GeoJSONRegion\nrect = instanceinvoke this.<@ts_files/143.ts: GeoJSONRegion.getBoundingRect(GeoProjection)>()\n%0 = rect.<@%unk/%unk: .width>\n%1 = rect.<@%unk/%unk: .height>\naspect = %0 / %1\n%2 = !width\nif %2 != 0",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "width = aspect * height",
                  "start_line": 195,
                  "end_line": 195,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "%4 = new @%unk/%unk: BoundingRect\ninstanceinvoke %4.<@%unk/%unk: BoundingRect.constructor()>(x, y, width, height)\ntarget = %4\ntransform = instanceinvoke rect.<@%unk/%unk: .calculateTransform()>(target)\ngeometries = this.<@ts_files/143.ts: GeoJSONRegion.geometries>\ni = 0",
                      "start_line": 1,
                      "end_line": 203,
                      "successors": [
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "%5 = geometries.<@%unk/%unk: .length>\nif i < %5",
                          "start_line": 1,
                          "end_line": 1,
                          "successors": [
                            {
                              "type": "block",
                              "name": "Block?",
                              "label": "geo = geometries[i]\n%6 = geo.<@%unk/%unk: .type>\nif %6 === 'polygon'",
                              "start_line": 113,
                              "end_line": 1,
                              "successors": [
                                {
                                  "type": "block",
                                  "name": "Block?",
                                  "label": "%7 = geo.<@%unk/%unk: .exterior>\nstaticinvoke <@ts_files/143.ts: %dflt.transformPoints(number[][], matrix.MatrixArray)>(%7, transform)\n%8 = geo.<@%unk/%unk: .interiors>\nstaticinvoke <@%unk/%unk: .each()>(%8, %AM2$transformTo)",
                                  "start_line": 1,
                                  "end_line": 1,
                                  "successors": [
                                    {
                                      "type": "block",
                                      "name": "Block?",
                                      "label": "i = i + 1",
                                      "start_line": 1,
                                      "end_line": 1,
                                      "successors": [
                                        {
                                          "type": "blockRef",
                                          "label": "(RepeatedBlock)"
                                        }
                                      ]
                                    }
                                  ]
                                },
                                {
                                  "type": "block",
                                  "name": "Block?",
                                  "label": "%9 = geo.<@%unk/%unk: .points>\nstaticinvoke <@%unk/%unk: .each()>(%9, %AM3$transformTo)",
                                  "start_line": 1,
                                  "end_line": 1,
                                  "successors": [
                                    {
                                      "type": "blockRef",
                                      "label": "(RepeatedBlock)"
                                    }
                                  ]
                                }
                              ]
                            },
                            {
                              "type": "block",
                              "name": "Block?",
                              "label": "rect = this.<@ts_files/143.ts: Region._rect>\ninstanceinvoke rect.<@%unk/%unk: .copy()>(target)\n%10 = rect.<@%unk/%unk: .x>\n%11 = rect.<@%unk/%unk: .width>\n%12 = %11 / 2\n%13 = %10 + %12\n%14 = rect.<@%unk/%unk: .y>\n%15 = rect.<@%unk/%unk: .height>\n%16 = %15 / 2\n%17 = %14 + %16\n%18 = newarray (unknown)[2]\n%18[0] = %13\n%18[1] = %17\nthis.<@ts_files/143.ts: Region._center> = %18\nreturn",
                              "start_line": 1,
                              "end_line": 261,
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%3 = !height\nif %3 != 0",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "height = width / aspect",
                      "start_line": 198,
                      "end_line": 198,
                      "successors": [
                        {
                          "type": "blockRef",
                          "label": "(RepeatedBlock)"
                        }
                      ]
                    },
                    {
                      "type": "blockRef",
                      "label": "(RepeatedBlock)"
                    }
                  ]
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "transformTo(x: number, y: number, width: number, height: number): void {\n        let rect = this.getBoundingRect();\n        const aspect = rect.width / rect.height;\n        if (!width) {\n            width = aspect * height;\n        }\n        else if (!height) {\n            height = width / aspect;\n        }\n        const target = new BoundingRect(x, y, width, height);\n        const transform = rect.calculateTransform(target);\n        const geometries = this.geometries;\n        for (let i = 0; i < geometries.length; i++) {\n            const geo = geometries[i];\n            if (geo.type === 'polygon') {\n                transformPoints(geo.exterior, transform);\n                each(geo.interiors, interior => {\n                    transformPoints(interior, transform);\n                });\n            }\n            else {\n                each(geo.points, points => {\n                    transformPoints(points, transform);\n                });\n            }\n        }\n        rect = this._rect;\n        rect.copy(target);\n        // Update center\n        this._center = [\n            rect.x + rect.width / 2,\n            rect.y + rect.height / 2\n        ];\n    }"
        },
        {
          "type": "function",
          "name": "cloneShallow",
          "label": "cloneShallow",
          "start_line": 1,
          "end_line": 230,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "name = parameter0: string\nthis = this: @ts_files/143.ts: GeoJSONRegion\n%0 = name == null\nname = this.<@ts_files/143.ts: Region.name>\n%1 = %0 && name\n%2 = new @ts_files/143.ts: GeoJSONRegion\n%3 = this.<@ts_files/143.ts: GeoJSONRegion.geometries>\n%4 = this.<@ts_files/143.ts: Region._center>\ninstanceinvoke %2.<@ts_files/143.ts: GeoJSONRegion.constructor(string, IndexedAccessType, IndexedAccessType)>(name, %3, %4)\nnewRegion = %2\n%5 = this.<@ts_files/143.ts: Region._rect>\nnewRegion.<@ts_files/143.ts: Region._rect> = %5\nnewRegion.<@ts_files/143.ts: GeoJSONRegion.transformTo> = null\nreturn newRegion",
              "start_line": 1,
              "end_line": 230,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "cloneShallow(name: string): GeoJSONRegion {\n        name == null && (name = this.name);\n        const newRegion = new GeoJSONRegion(name, this.geometries, this._center);\n        newRegion._rect = this._rect;\n        newRegion.transformTo = null; // Simply avoid to be called.\n        return newRegion;\n    }"
        },
        {
          "type": "function",
          "name": "%AM1$%AM0$getBoundingRect",
          "label": "%AM1$%AM0$getBoundingRect",
          "start_line": 1,
          "end_line": 261,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "points = parameter0: unknown\nthis = this: @ts_files/143.ts: GeoJSONRegion\nstaticinvoke <@ts_files/143.ts: %dflt.updateBBoxFromPoints(ArrayLike<number>[], vec2.VectorArray, vec2.VectorArray, GeoProjection)>(points, min, max, projection)\nreturn",
              "start_line": 1,
              "end_line": 261,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "(points) => {\n                    updateBBoxFromPoints(points, min, max, projection);\n                }"
        },
        {
          "type": "function",
          "name": "%AM0$getBoundingRect",
          "label": "%AM0$getBoundingRect",
          "start_line": 1,
          "end_line": 142,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "%closures0 = parameter0: [min, max, projection]\ngeo = parameter1: unknown\nmin = %closures0.min\nmax = %closures0.max\nprojection = %closures0.projection\nthis = this: @ts_files/143.ts: GeoJSONRegion\n%0 = geo.<@%unk/%unk: .type>\nif %0 === 'polygon'",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%1 = geo.<@%unk/%unk: .exterior>\nstaticinvoke <@ts_files/143.ts: %dflt.updateBBoxFromPoints(ArrayLike<number>[], vec2.VectorArray, vec2.VectorArray, GeoProjection)>(%1, min, max, projection)",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "return",
                      "start_line": 23,
                      "end_line": 261,
                      "successors": []
                    }
                  ]
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%2 = geo.<@%unk/%unk: .points>\nstaticinvoke <@%unk/%unk: .each()>(%2, %AM1$%AM0$getBoundingRect)",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "blockRef",
                      "label": "(RepeatedBlock)"
                    }
                  ]
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "geo => {\n            if (geo.type === 'polygon') {\n                // Doesn't consider hole\n                updateBBoxFromPoints(geo.exterior, min, max, projection);\n            }\n            else {\n                each(geo.points, (points) => {\n                    updateBBoxFromPoints(points, min, max, projection);\n                });\n            }\n        }"
        },
        {
          "type": "function",
          "name": "%AM2$transformTo",
          "label": "%AM2$transformTo",
          "start_line": 1,
          "end_line": 261,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "%closures0 = parameter0: [transform]\ninterior = parameter1: unknown\ntransform = %closures0.transform\nthis = this: @ts_files/143.ts: GeoJSONRegion\nstaticinvoke <@ts_files/143.ts: %dflt.transformPoints(number[][], matrix.MatrixArray)>(interior, transform)\nreturn",
              "start_line": 1,
              "end_line": 261,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "interior => {\n                    transformPoints(interior, transform);\n                }"
        },
        {
          "type": "function",
          "name": "%AM3$transformTo",
          "label": "%AM3$transformTo",
          "start_line": 1,
          "end_line": 261,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "%closures1 = parameter0: [transform]\npoints = parameter1: unknown\ntransform = %closures1.transform\nthis = this: @ts_files/143.ts: GeoJSONRegion\nstaticinvoke <@ts_files/143.ts: %dflt.transformPoints(number[][], matrix.MatrixArray)>(points, transform)\nreturn",
              "start_line": 1,
              "end_line": 261,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "points => {\n                    transformPoints(points, transform);\n                }"
        }
      ],
      "classes": [],
      "blocks": [],
      "simplified_code": "export class GeoJSONRegion extends Region {\n    readonly type = 'geoJSON';\n    readonly geometries: (GeoJSONPolygonGeometry | GeoJSONLineStringGeometry)[];\n    // Injected outside.\n    properties: GeoJSON['features'][0]['properties'];\n    constructor(\n        name: string,\n        geometries: GeoJSONRegion['geometries'],\n        cp: GeoJSON['features'][0]['properties']['cp']\n    ) {\n        super(name);\n        this.geometries = geometries;\n        this._center = cp && [cp[0], cp[1]];\n    }\n    calcCenter() {\n        const geometries = this.geometries;\n        let largestGeo: GeoJSONPolygonGeometry;\n        let largestGeoSize = 0;\n        for (let i = 0; i < geometries.length; i++) {\n            const geo = geometries[i] as GeoJSONPolygonGeometry;\n            const exterior = geo.exterior;\n            // Simple trick to use points count instead of polygon area as region size.\n            // Ignore linestring\n            const size = exterior && exterior.length;\n            if (size > largestGeoSize) {\n                largestGeo = geo;\n                largestGeoSize = size;\n            }\n        }\n        if (largestGeo) {\n            return centroid(largestGeo.exterior);\n        }\n        // from bounding rect by default.\n        const rect = this.getBoundingRect();\n        return [\n            rect.x + rect.width / 2,\n            rect.y + rect.height / 2\n        ];\n    }\n    getBoundingRect(projection?: GeoProjection): BoundingRect {\n        let rect = this._rect;\n        // Always recalculate if using projection.\n        if (rect && !projection) {\n            return rect;\n        }\n        const min = [Infinity, Infinity];\n        const max = [-Infinity, -Infinity];\n        const geometries = this.geometries;\n        each(geometries, geo => {\n            if (geo.type === 'polygon') {\n                // Doesn't consider hole\n                updateBBoxFromPoints(geo.exterior, min, max, projection);\n            }\n            else {\n                each(geo.points, (points) => {\n                    updateBBoxFromPoints(points, min, max, projection);\n                });\n            }\n        });\n        // Normalie invalid bounding.\n        if (!(isFinite(min[0]) && isFinite(min[1]) && isFinite(max[0]) && isFinite(max[1]))) {\n            min[0] = min[1] = max[0] = max[1] = 0;\n        }\n        rect = new BoundingRect(\n            min[0], min[1], max[0] - min[0], max[1] - min[1]\n        );\n        if (!projection) {\n            this._rect = rect;\n        }\n        return rect;\n    }\n    contain(coord: number[]): boolean {\n        const rect = this.getBoundingRect();\n        const geometries = this.geometries;\n        if (!rect.contain(coord[0], coord[1])) {\n            return false;\n        }\n        loopGeo: for (let i = 0, len = geometries.length; i < len; i++) {\n            const geo = geometries[i];\n            // Only support polygon.\n            if (geo.type !== 'polygon') {\n                continue;\n            }\n            const exterior = geo.exterior;\n            const interiors = geo.interiors;\n            if (polygonContain.contain(exterior, coord[0], coord[1])) {\n                // Not in the region if point is in the hole.\n                for (let k = 0; k < (interiors ? interiors.length : 0); k++) {\n                    if (polygonContain.contain(interiors[k], coord[0], coord[1])) {\n                        continue loopGeo;\n                    }\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    transformTo(x: number, y: number, width: number, height: number): void {\n        let rect = this.getBoundingRect();\n        const aspect = rect.width / rect.height;\n        if (!width) {\n            width = aspect * height;\n        }\n        else if (!height) {\n            height = width / aspect;\n        }\n        const target = new BoundingRect(x, y, width, height);\n        const transform = rect.calculateTransform(target);\n        const geometries = this.geometries;\n        for (let i = 0; i < geometries.length; i++) {\n            const geo = geometries[i];\n            if (geo.type === 'polygon') {\n                transformPoints(geo.exterior, transform);\n                each(geo.interiors, interior => {\n                    transformPoints(interior, transform);\n                });\n            }\n            else {\n                each(geo.points, points => {\n                    transformPoints(points, transform);\n                });\n            }\n        }\n        rect = this._rect;\n        rect.copy(target);\n        // Update center\n        this._center = [\n            rect.x + rect.width / 2,\n            rect.y + rect.height / 2\n        ];\n    }\n    cloneShallow(name: string): GeoJSONRegion {\n        name == null && (name = this.name);\n        const newRegion = new GeoJSONRegion(name, this.geometries, this._center);\n        newRegion._rect = this._rect;\n        newRegion.transformTo = null; // Simply avoid to be called.\n        return newRegion;\n    }\n}"
    },
    {
      "type": "class",
      "name": "GeoSVGRegion",
      "label": "GeoSVGRegion",
      "start_line": 1,
      "end_line": 261,
      "functions": [
        {
          "type": "function",
          "name": "constructor",
          "label": "constructor",
          "start_line": 1,
          "end_line": 261,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "instanceinvoke this.<@ts_files/143.ts: GeoSVGRegion.%instInit()>()\nname = parameter0: string\nelOnlyForCalculate = parameter1: Element\nthis = this: @ts_files/143.ts: GeoSVGRegion\nstaticinvoke <@%unk/%unk: .super()>(name)\nthis.<@ts_files/143.ts: GeoSVGRegion._elOnlyForCalculate> = elOnlyForCalculate\nreturn",
              "start_line": 1,
              "end_line": 261,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "constructor(\n        name: string,\n        elOnlyForCalculate: Element\n    ) {\n        super(name);\n        this._elOnlyForCalculate = elOnlyForCalculate;\n    }"
        },
        {
          "type": "function",
          "name": "calcCenter",
          "label": "calcCenter",
          "start_line": 1,
          "end_line": 254,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/143.ts: GeoSVGRegion\nel = this.<@ts_files/143.ts: GeoSVGRegion._elOnlyForCalculate>\nrect = instanceinvoke el.<@%unk/%unk: .getBoundingRect()>()\n%0 = rect.<@%unk/%unk: .x>\n%1 = rect.<@%unk/%unk: .width>\n%2 = %1 / 2\n%3 = %0 + %2\n%4 = rect.<@%unk/%unk: .y>\n%5 = rect.<@%unk/%unk: .height>\n%6 = %5 / 2\n%7 = %4 + %6\n%8 = newarray (unknown)[2]\n%8[0] = %3\n%8[1] = %7\ncenter = %8\nmat = instanceinvoke matrix.<@%unk/%unk: .identity()>(TMP_TRANSFORM)\ntarget = el",
              "start_line": 1,
              "end_line": 254,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%9 = <GeoSVGGraphicRoot>target\n%10 = %9.<@%unk/%unk: .isGeoSVGGraphicRoot>\n%11 = !%10\n%12 = target && %11\nif %12 != false",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "%13 = instanceinvoke target.<@%unk/%unk: .getLocalTransform()>()\ninstanceinvoke matrix.<@%unk/%unk: .mul()>(mat, %13, mat)\ntarget = target.<@%unk/%unk: .parent>",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "blockRef",
                          "label": "(RepeatedBlock)"
                        }
                      ]
                    },
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "instanceinvoke matrix.<@%unk/%unk: .invert()>(mat, mat)\ninstanceinvoke vec2.<@%unk/%unk: .applyTransform()>(center, center, mat)\nreturn center",
                      "start_line": 1,
                      "end_line": 261,
                      "successors": []
                    }
                  ]
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "calcCenter(): number[] {\n        const el = this._elOnlyForCalculate;\n        const rect = el.getBoundingRect();\n        const center = [\n            rect.x + rect.width / 2,\n            rect.y + rect.height / 2\n        ];\n        const mat = matrix.identity(TMP_TRANSFORM);\n        let target = el;\n        while (target && !(target as GeoSVGGraphicRoot).isGeoSVGGraphicRoot) {\n            matrix.mul(mat, target.getLocalTransform(), mat);\n            target = target.parent;\n        }\n        matrix.invert(mat, mat);\n        vec2.applyTransform(center, center, mat);\n        return center;\n    }"
        }
      ],
      "classes": [],
      "blocks": [],
      "simplified_code": "export class GeoSVGRegion extends Region {\n    readonly type = 'geoSVG';\n    // Can only be used to calculate, but not be modified.\n    // Because this el may not belong to this view,\n    // but been displaying on some other view.\n    private _elOnlyForCalculate: Element;\n    constructor(\n        name: string,\n        elOnlyForCalculate: Element\n    ) {\n        super(name);\n        this._elOnlyForCalculate = elOnlyForCalculate;\n    }\n    calcCenter(): number[] {\n        const el = this._elOnlyForCalculate;\n        const rect = el.getBoundingRect();\n        const center = [\n            rect.x + rect.width / 2,\n            rect.y + rect.height / 2\n        ];\n        const mat = matrix.identity(TMP_TRANSFORM);\n        let target = el;\n        while (target && !(target as GeoSVGGraphicRoot).isGeoSVGGraphicRoot) {\n            matrix.mul(mat, target.getLocalTransform(), mat);\n            target = target.parent;\n        }\n        matrix.invert(mat, mat);\n        vec2.applyTransform(center, center, mat);\n        return center;\n    }\n}"
    }
  ],
  "functions": [],
  "blocks": [],
  "simplified_code": "import BoundingRect from 'zrender/src/core/BoundingRect';\nimport * as vec2 from 'zrender/src/core/vector';\nimport * as polygonContain from 'zrender/src/contain/polygon';\nimport { GeoJSON, GeoProjection, GeoSVGGraphicRoot } from './geoTypes';\nimport * as matrix from 'zrender/src/core/matrix';\nimport Element from 'zrender/src/Element';\nimport { each } from 'zrender/src/core/util';\nconst TMP_TRANSFORM = [] as number[];\nfunction transformPoints(points: number[][], transform: matrix.MatrixArray) {\n    for (let p = 0; p < points.length; p++) {\n        vec2.applyTransform(points[p], points[p], transform);\n    }\n}\nfunction updateBBoxFromPoints(\n    points: ArrayLike<number>[],\n    min: vec2.VectorArray,\n    max: vec2.VectorArray,\n    projection: GeoProjection\n) {\n    for (let i = 0; i < points.length; i++) {\n        let p = points[i];\n        if (projection) {\n            // projection may return null point.\n            p = projection.project(p as number[]);\n        }\n        if (p && isFinite(p[0]) && isFinite(p[1])) {\n            vec2.min(min, min, p as vec2.VectorArray);\n            vec2.max(max, max, p as vec2.VectorArray);\n        }\n    }\n}\nfunction centroid(points: number[][]) {\n    let signedArea = 0;\n    let cx = 0;\n    let cy = 0;\n    const len = points.length;\n    let x0 = points[len - 1][0];\n    let y0 = points[len - 1][1];\n    // Polygon should been closed.\n    for (let i = 0; i < len; i++) {\n        const x1 = points[i][0];\n        const y1 = points[i][1];\n        const a = x0 * y1 - x1 * y0;\n        signedArea += a;\n        cx += (x0 + x1) * a;\n        cy += (y0 + y1) * a;\n        x0 = x1;\n        y0 = y1;\n    }\n    return signedArea\n        ? [cx / signedArea / 3, cy / signedArea / 3, signedArea]\n        : [points[0][0] || 0, points[0][1] || 0];\n}\nexport abstract class Region {\n    readonly name: string;\n    readonly type: 'geoJSON' | 'geoSVG';\n    protected _center: number[];\n    protected _rect: BoundingRect;\n    constructor(\n        name: string\n    ) {\n        this.name = name;\n    }\n    setCenter(center: number[]) {\n        this._center = center;\n    }\n    getCenter() {\n        let center = this._center;\n        if (!center) {\n            // In most cases there are no need to calculate this center.\n            // So calculate only when called.\n            center = this._center = this.calcCenter();\n        }\n        return center;\n    }\n    abstract calcCenter(): number[];\n}\nexport class GeoJSONPolygonGeometry {\n    readonly type = 'polygon';\n    exterior: number[][];\n    interiors?: number[][][];\n    constructor(exterior: number[][], interiors: number[][][]) {\n        this.exterior = exterior;\n        this.interiors = interiors;\n    }\n}\nexport class GeoJSONLineStringGeometry {\n    readonly type = 'linestring';\n    points: number[][][];\n    constructor(points: number[][][]) {\n        this.points = points;\n    }\n}\nexport class GeoJSONRegion extends Region {\n    readonly type = 'geoJSON';\n    readonly geometries: (GeoJSONPolygonGeometry | GeoJSONLineStringGeometry)[];\n    // Injected outside.\n    properties: GeoJSON['features'][0]['properties'];\n    constructor(\n        name: string,\n        geometries: GeoJSONRegion['geometries'],\n        cp: GeoJSON['features'][0]['properties']['cp']\n    ) {\n        super(name);\n        this.geometries = geometries;\n        this._center = cp && [cp[0], cp[1]];\n    }\n    calcCenter() {\n        const geometries = this.geometries;\n        let largestGeo: GeoJSONPolygonGeometry;\n        let largestGeoSize = 0;\n        for (let i = 0; i < geometries.length; i++) {\n            const geo = geometries[i] as GeoJSONPolygonGeometry;\n            const exterior = geo.exterior;\n            // Simple trick to use points count instead of polygon area as region size.\n            // Ignore linestring\n            const size = exterior && exterior.length;\n            if (size > largestGeoSize) {\n                largestGeo = geo;\n                largestGeoSize = size;\n            }\n        }\n        if (largestGeo) {\n            return centroid(largestGeo.exterior);\n        }\n        // from bounding rect by default.\n        const rect = this.getBoundingRect();\n        return [\n            rect.x + rect.width / 2,\n            rect.y + rect.height / 2\n        ];\n    }\n    getBoundingRect(projection?: GeoProjection): BoundingRect {\n        let rect = this._rect;\n        // Always recalculate if using projection.\n        if (rect && !projection) {\n            return rect;\n        }\n        const min = [Infinity, Infinity];\n        const max = [-Infinity, -Infinity];\n        const geometries = this.geometries;\n        each(geometries, geo => {\n            if (geo.type === 'polygon') {\n                // Doesn't consider hole\n                updateBBoxFromPoints(geo.exterior, min, max, projection);\n            }\n            else {\n                each(geo.points, (points) => {\n                    updateBBoxFromPoints(points, min, max, projection);\n                });\n            }\n        });\n        // Normalie invalid bounding.\n        if (!(isFinite(min[0]) && isFinite(min[1]) && isFinite(max[0]) && isFinite(max[1]))) {\n            min[0] = min[1] = max[0] = max[1] = 0;\n        }\n        rect = new BoundingRect(\n            min[0], min[1], max[0] - min[0], max[1] - min[1]\n        );\n        if (!projection) {\n            this._rect = rect;\n        }\n        return rect;\n    }\n    contain(coord: number[]): boolean {\n        const rect = this.getBoundingRect();\n        const geometries = this.geometries;\n        if (!rect.contain(coord[0], coord[1])) {\n            return false;\n        }\n        loopGeo: for (let i = 0, len = geometries.length; i < len; i++) {\n            const geo = geometries[i];\n            // Only support polygon.\n            if (geo.type !== 'polygon') {\n                continue;\n            }\n            const exterior = geo.exterior;\n            const interiors = geo.interiors;\n            if (polygonContain.contain(exterior, coord[0], coord[1])) {\n                // Not in the region if point is in the hole.\n                for (let k = 0; k < (interiors ? interiors.length : 0); k++) {\n                    if (polygonContain.contain(interiors[k], coord[0], coord[1])) {\n                        continue loopGeo;\n                    }\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    transformTo(x: number, y: number, width: number, height: number): void {\n        let rect = this.getBoundingRect();\n        const aspect = rect.width / rect.height;\n        if (!width) {\n            width = aspect * height;\n        }\n        else if (!height) {\n            height = width / aspect;\n        }\n        const target = new BoundingRect(x, y, width, height);\n        const transform = rect.calculateTransform(target);\n        const geometries = this.geometries;\n        for (let i = 0; i < geometries.length; i++) {\n            const geo = geometries[i];\n            if (geo.type === 'polygon') {\n                transformPoints(geo.exterior, transform);\n                each(geo.interiors, interior => {\n                    transformPoints(interior, transform);\n                });\n            }\n            else {\n                each(geo.points, points => {\n                    transformPoints(points, transform);\n                });\n            }\n        }\n        rect = this._rect;\n        rect.copy(target);\n        // Update center\n        this._center = [\n            rect.x + rect.width / 2,\n            rect.y + rect.height / 2\n        ];\n    }\n    cloneShallow(name: string): GeoJSONRegion {\n        name == null && (name = this.name);\n        const newRegion = new GeoJSONRegion(name, this.geometries, this._center);\n        newRegion._rect = this._rect;\n        newRegion.transformTo = null; // Simply avoid to be called.\n        return newRegion;\n    }\n}\nexport class GeoSVGRegion extends Region {\n    readonly type = 'geoSVG';\n    // Can only be used to calculate, but not be modified.\n    // Because this el may not belong to this view,\n    // but been displaying on some other view.\n    private _elOnlyForCalculate: Element;\n    constructor(\n        name: string,\n        elOnlyForCalculate: Element\n    ) {\n        super(name);\n        this._elOnlyForCalculate = elOnlyForCalculate;\n    }\n    calcCenter(): number[] {\n        const el = this._elOnlyForCalculate;\n        const rect = el.getBoundingRect();\n        const center = [\n            rect.x + rect.width / 2,\n            rect.y + rect.height / 2\n        ];\n        const mat = matrix.identity(TMP_TRANSFORM);\n        let target = el;\n        while (target && !(target as GeoSVGGraphicRoot).isGeoSVGGraphicRoot) {\n            matrix.mul(mat, target.getLocalTransform(), mat);\n            target = target.parent;\n        }\n        matrix.invert(mat, mat);\n        vec2.applyTransform(center, center, mat);\n        return center;\n    }\n}"
}