{
  "type": "file",
  "name": "44.ts",
  "label": "44.ts",
  "start_line": -1,
  "end_line": 665,
  "classes": [
    {
      "type": "class",
      "name": "%dflt",
      "label": "%dflt",
      "start_line": -1,
      "end_line": 599,
      "functions": [
        {
          "type": "function",
          "name": "%dflt",
          "label": "%dflt",
          "start_line": -1,
          "end_line": 599,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/44.ts: %dflt\nTAG = 'EventPipeline'\nreturn",
              "start_line": 1,
              "end_line": 599,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": ""
        }
      ],
      "classes": [],
      "blocks": [],
      "simplified_code": ""
    },
    {
      "type": "class",
      "name": "Matrix4TransitWithMatrix4x4",
      "label": "Matrix4TransitWithMatrix4x4",
      "start_line": 27,
      "end_line": 27,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "export interface Matrix4TransitWithMatrix4x4 extends Matrix4.Matrix4Transit {\n  matrix4x4: number[];\n}"
    },
    {
      "type": "class",
      "name": "AnimationOption",
      "label": "AnimationOption",
      "start_line": 31,
      "end_line": 31,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "export interface AnimationOption {\n  duration: number,\n  curve: Curve\n}"
    },
    {
      "type": "class",
      "name": "EventPipeline",
      "label": "EventPipeline",
      "start_line": 1,
      "end_line": 665,
      "functions": [
        {
          "type": "function",
          "name": "constructor",
          "label": "constructor",
          "start_line": 1,
          "end_line": 109,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "instanceinvoke this.<@ts_files/44.ts: EventPipeline.%instInit()>()\nbroadCastParam = parameter0: Broadcast\nitem = parameter1: UserFileDataItem\ntimeStamp = parameter2: string\nupdateMatrix = parameter3: Function\nthis = this: @ts_files/44.ts: EventPipeline\nthis.<@ts_files/44.ts: EventPipeline.broadCast> = broadCastParam\nthis.<@ts_files/44.ts: EventPipeline.item> = item\nthis.<@ts_files/44.ts: EventPipeline.timeStamp> = timeStamp\nthis.<@ts_files/44.ts: EventPipeline.updateMatrix> = updateMatrix\n%0 = this.<@ts_files/44.ts: EventPipeline.item>\n%1 = %0.<@%unk/%unk: .imgWidth>\nif %1 === 0",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%2 = MediaConstants.<@%unk/%unk: .DEFAULT_SIZE>",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "this.<@ts_files/44.ts: EventPipeline.width> = %2\n%4 = this.<@ts_files/44.ts: EventPipeline.item>\n%5 = %4.<@%unk/%unk: .imgHeight>\nif %5 === 0",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "%6 = MediaConstants.<@%unk/%unk: .DEFAULT_SIZE>",
                          "start_line": 1,
                          "end_line": 1,
                          "successors": [
                            {
                              "type": "block",
                              "name": "Block?",
                              "label": "this.<@ts_files/44.ts: EventPipeline.height> = %6\ninstanceinvoke this.<@ts_files/44.ts: EventPipeline.evaluateScales()>()\nreturn",
                              "start_line": 1,
                              "end_line": 599,
                              "successors": []
                            }
                          ]
                        },
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "%7 = this.<@ts_files/44.ts: EventPipeline.item>\n%6 = %7.<@%unk/%unk: .imgHeight>",
                          "start_line": 1,
                          "end_line": 1,
                          "successors": [
                            {
                              "type": "blockRef",
                              "label": "(RepeatedBlock)"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%3 = this.<@ts_files/44.ts: EventPipeline.item>\n%2 = %3.<@%unk/%unk: .imgWidth>",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "blockRef",
                      "label": "(RepeatedBlock)"
                    }
                  ]
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "constructor(broadCastParam: Broadcast, item: UserFileDataItem, timeStamp: string, updateMatrix: Function) {\n    this.broadCast = broadCastParam;\n    this.item = item;\n    this.timeStamp = timeStamp;\n    this.updateMatrix = updateMatrix;\n    this.width = this.item.imgWidth === 0 ? MediaConstants.DEFAULT_SIZE : this.item.imgWidth;\n    this.height = this.item.imgHeight === 0 ? MediaConstants.DEFAULT_SIZE : this.item.imgHeight;\n    this.evaluateScales();\n  }"
        },
        {
          "type": "function",
          "name": "onDataChanged",
          "label": "onDataChanged",
          "start_line": 1,
          "end_line": 119,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "item = parameter0: UserFileDataItem\nthis = this: @ts_files/44.ts: EventPipeline\nthis.<@ts_files/44.ts: EventPipeline.item> = item\n%0 = this.<@ts_files/44.ts: EventPipeline.item>\n%1 = %0.<@%unk/%unk: .imgWidth>\nif %1 === 0",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%2 = MediaConstants.<@%unk/%unk: .DEFAULT_SIZE>",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "this.<@ts_files/44.ts: EventPipeline.width> = %2\n%4 = this.<@ts_files/44.ts: EventPipeline.item>\n%5 = %4.<@%unk/%unk: .imgHeight>\nif %5 === 0",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "%6 = MediaConstants.<@%unk/%unk: .DEFAULT_SIZE>",
                          "start_line": 1,
                          "end_line": 1,
                          "successors": [
                            {
                              "type": "block",
                              "name": "Block?",
                              "label": "this.<@ts_files/44.ts: EventPipeline.height> = %6\ninstanceinvoke this.<@ts_files/44.ts: EventPipeline.evaluateScales()>()\nreturn",
                              "start_line": 1,
                              "end_line": 599,
                              "successors": []
                            }
                          ]
                        },
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "%7 = this.<@ts_files/44.ts: EventPipeline.item>\n%6 = %7.<@%unk/%unk: .imgHeight>",
                          "start_line": 1,
                          "end_line": 1,
                          "successors": [
                            {
                              "type": "blockRef",
                              "label": "(RepeatedBlock)"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%3 = this.<@ts_files/44.ts: EventPipeline.item>\n%2 = %3.<@%unk/%unk: .imgWidth>",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "blockRef",
                      "label": "(RepeatedBlock)"
                    }
                  ]
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "onDataChanged(item: UserFileDataItem): void {\n    this.item = item;\n    this.width = this.item.imgWidth === 0 ? MediaConstants.DEFAULT_SIZE : this.item.imgWidth;\n    this.height = this.item.imgHeight === 0 ? MediaConstants.DEFAULT_SIZE : this.item.imgHeight;\n    this.evaluateScales();\n  }"
        },
        {
          "type": "function",
          "name": "setDefaultScale",
          "label": "setDefaultScale",
          "start_line": 1,
          "end_line": 599,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "scale = parameter0: unknown\nthis = this: @ts_files/44.ts: EventPipeline\nthis.<@ts_files/44.ts: EventPipeline.defaultScale> = scale\nthis.<@ts_files/44.ts: EventPipeline.lastScale> = scale\nreturn",
              "start_line": 1,
              "end_line": 599,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "setDefaultScale(scale): void {\n    this.defaultScale = scale;\n    this.lastScale = scale;\n  }"
        },
        {
          "type": "function",
          "name": "onComponentSizeChanged",
          "label": "onComponentSizeChanged",
          "start_line": 1,
          "end_line": 599,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/44.ts: EventPipeline\ninstanceinvoke this.<@ts_files/44.ts: EventPipeline.evaluateScales()>()\nreturn",
              "start_line": 1,
              "end_line": 599,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "onComponentSizeChanged(): void {\n    this.evaluateScales();\n  }"
        },
        {
          "type": "function",
          "name": "onTouch",
          "label": "onTouch",
          "start_line": 1,
          "end_line": 135,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "event = parameter0: TouchEvent\nthis = this: @ts_files/44.ts: EventPipeline\n%0 = event.<@%unk/%unk: .type>\n%1 = 'onTouch trigger: ' + %0\n%2 = %1 + ', '\n%3 = this.<@ts_files/44.ts: EventPipeline.isInAnimation>\n%4 = %2 + %3\n%5 = %4 + ', '\n%6 = this.<@ts_files/44.ts: EventPipeline.isExiting>\n%7 = %5 + %6\ninstanceinvoke Log.<@%unk/%unk: .debug()>(TAG, %7)\n%8 = this.<@ts_files/44.ts: EventPipeline.isInAnimation>\n%9 = this.<@ts_files/44.ts: EventPipeline.isExiting>\n%10 = %8 || %9\nif %10 != false",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "return",
                  "start_line": 104,
                  "end_line": 599,
                  "successors": []
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%11 = event.<@%unk/%unk: .type>\n%12 = TouchType.<@%unk/%unk: .Down>\n%13 = %11 === %12\n%14 = event.<@%unk/%unk: .type>\n%15 = TouchType.<@%unk/%unk: .Up>\n%16 = %14 === %15\n%17 = %13 || %16\nif %17 != false",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "instanceinvoke this.<@ts_files/44.ts: EventPipeline.emitDirectionChange()>()",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "%18 = event.<@%unk/%unk: .type>\n%19 = TouchType.<@%unk/%unk: .Up>\nif %18 === %19",
                          "start_line": 1,
                          "end_line": 1,
                          "successors": [
                            {
                              "type": "block",
                              "name": "Block?",
                              "label": "%20 = instanceinvoke this.<@ts_files/44.ts: EventPipeline.evaluateOffset()>()\nthis.<@ts_files/44.ts: EventPipeline.lastOffset> = %20\n%21 = this.<@ts_files/44.ts: EventPipeline.lastScale>\n%22 = this.<@ts_files/44.ts: EventPipeline.scale>\n%23 = %21 * %22\nthis.<@ts_files/44.ts: EventPipeline.lastScale> = %23\nthis.<@ts_files/44.ts: EventPipeline.scale> = 1\n%24 = newarray (number)[2]\n%24[0] = 0\n%24[1] = 0\nthis.<@ts_files/44.ts: EventPipeline.offset> = %24",
                              "start_line": 1,
                              "end_line": 1,
                              "successors": [
                                {
                                  "type": "block",
                                  "name": "Block?",
                                  "label": "return",
                                  "start_line": 104,
                                  "end_line": 599,
                                  "successors": []
                                }
                              ]
                            },
                            {
                              "type": "blockRef",
                              "label": "(RepeatedBlock)"
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "type": "blockRef",
                      "label": "(RepeatedBlock)"
                    }
                  ]
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "onTouch(event: TouchEvent): void {\n    Log.debug(TAG, 'onTouch trigger: ' + event.type + ', ' + this.isInAnimation + ', ' + this.isExiting);\n    if (this.isInAnimation || this.isExiting) {\n      return;\n    }\n    if (event.type === TouchType.Down || event.type === TouchType.Up) {\n      this.emitDirectionChange();\n    }\n\n    if (event.type === TouchType.Up) {\n      this.lastOffset = this.evaluateOffset();\n      this.lastScale = this.lastScale * this.scale;\n      this.scale = 1;\n      this.offset = [0, 0];\n    }\n  }"
        },
        {
          "type": "function",
          "name": "emitDirectionChange",
          "label": "emitDirectionChange",
          "start_line": 1,
          "end_line": 152,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/44.ts: EventPipeline\ndirection = undefined\n%0 = this.<@ts_files/44.ts: EventPipeline.lastScale>\n%1 = this.<@ts_files/44.ts: EventPipeline.scale>\nscale = %0 * %1\n%2 = Constants.<@%unk/%unk: .RESERVED_DIGITS>\n%3 = instanceinvoke scale.<@%unk/%unk: .toFixed()>(%2)\n%4 = staticinvoke <@%unk/%unk: .Number()>(%3)\n%5 = Constants.<@%unk/%unk: .RESERVED_DIGITS>\n%6 = this.<@ts_files/44.ts: EventPipeline.defaultScale>\n%7 = instanceinvoke %6.<@%unk/%unk: .toFixed()>(%5)\n%8 = staticinvoke <@%unk/%unk: .Number()>(%7)\nisEnlarged = %4 > %8\n%9 = this.<@ts_files/44.ts: EventPipeline.hasReachLeft>\n%10 = !%9\n%11 = this.<@ts_files/44.ts: EventPipeline.hasReachRight>\n%12 = !%11\n%13 = %10 && %12\n%14 = %13 && isEnlarged\nif %14 != false",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "direction = PanDirection.<@%unk/%unk: .All>",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "%33 = this.<@ts_files/44.ts: EventPipeline.hasReachLeft>\n%34 = 'emitDirectionChange reaches: ' + %33\n%35 = %34 + ', '\n%36 = this.<@ts_files/44.ts: EventPipeline.hasReachRight>\n%37 = %35 + %36\n%38 = %37 + ', '\n%39 = this.<@ts_files/44.ts: EventPipeline.hasReachTop>\n%40 = %38 + %39\n%41 = %40 + ', '\n%42 = this.<@ts_files/44.ts: EventPipeline.hasReachBottom>\n%43 = %41 + %42\n%44 = %43 + ', scale '\n%45 = %44 + scale\n%46 = %45 + ', direction: '\n%47 = %46 + direction\ninstanceinvoke Log.<@%unk/%unk: .info()>(TAG, %47)\n%48 = this.<@ts_files/44.ts: EventPipeline.isExiting>\nif %48 != false",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "return",
                          "start_line": 104,
                          "end_line": 599,
                          "successors": []
                        },
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "%49 = PanDirection.<@%unk/%unk: .Vertical>\n%50 = <number>%49\n%51 = direction === %50\n%52 = PanDirection.<@%unk/%unk: .Vertical>\n%53 = <number>%52\n%54 = PanDirection.<@%unk/%unk: .Left>\n%55 = <number>%54\n%56 = %53 | %55\n%57 = direction === %56\n%58 = %51 || %57\n%59 = PanDirection.<@%unk/%unk: .Vertical>\n%60 = <number>%59\n%61 = PanDirection.<@%unk/%unk: .Right>\n%62 = <number>%61\n%63 = %60 | %62\n%64 = direction === %63\n%65 = %58 || %64\nif %65 != false",
                          "start_line": 1,
                          "end_line": 1,
                          "successors": [
                            {
                              "type": "block",
                              "name": "Block?",
                              "label": "%66 = Constants.<@%unk/%unk: .SET_DISABLE_SWIPE>\n%67 = newarray (boolean)[1]\n%67[0] = false\n%68 = this.<@ts_files/44.ts: EventPipeline.broadCast>\ninstanceinvoke %68.<@%unk/%unk: .emit()>(%66, %67)",
                              "start_line": 1,
                              "end_line": 1,
                              "successors": [
                                {
                                  "type": "block",
                                  "name": "Block?",
                                  "label": "%72 = Constants.<@%unk/%unk: .DIRECTION_CHANGE>\n%73 = this.<@ts_files/44.ts: EventPipeline.item>\n%74 = %73.<@%unk/%unk: .uri>\n%75 = %72 + %74\n%76 = this.<@ts_files/44.ts: EventPipeline.timeStamp>\n%77 = %75 + %76\n%78 = newarray (number)[1]\n%78[0] = direction\n%79 = this.<@ts_files/44.ts: EventPipeline.broadCast>\ninstanceinvoke %79.<@%unk/%unk: .emit()>(%77, %78)\nreturn",
                                  "start_line": 1,
                                  "end_line": 599,
                                  "successors": []
                                }
                              ]
                            },
                            {
                              "type": "block",
                              "name": "Block?",
                              "label": "%69 = Constants.<@%unk/%unk: .SET_DISABLE_SWIPE>\n%70 = newarray (boolean)[1]\n%70[0] = true\n%71 = this.<@ts_files/44.ts: EventPipeline.broadCast>\ninstanceinvoke %71.<@%unk/%unk: .emit()>(%69, %70)",
                              "start_line": 1,
                              "end_line": 1,
                              "successors": [
                                {
                                  "type": "blockRef",
                                  "label": "(RepeatedBlock)"
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%15 = this.<@ts_files/44.ts: EventPipeline.hasReachLeft>\n%16 = !%15\n%17 = this.<@ts_files/44.ts: EventPipeline.hasReachRight>\n%18 = %16 && %17\n%19 = %18 && isEnlarged\nif %19 != false",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "%20 = PanDirection.<@%unk/%unk: .Vertical>\n%21 = <number>%20\n%22 = PanDirection.<@%unk/%unk: .Right>\n%23 = <number>%22\ndirection = %21 | %23",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "blockRef",
                          "label": "(RepeatedBlock)"
                        }
                      ]
                    },
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "%24 = this.<@ts_files/44.ts: EventPipeline.hasReachLeft>\n%25 = this.<@ts_files/44.ts: EventPipeline.hasReachRight>\n%26 = !%25\n%27 = %24 && %26\n%28 = %27 && isEnlarged\nif %28 != false",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "%29 = PanDirection.<@%unk/%unk: .Vertical>\n%30 = <number>%29\n%31 = PanDirection.<@%unk/%unk: .Left>\n%32 = <number>%31\ndirection = %30 | %32",
                          "start_line": 1,
                          "end_line": 1,
                          "successors": [
                            {
                              "type": "blockRef",
                              "label": "(RepeatedBlock)"
                            }
                          ]
                        },
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "direction = PanDirection.<@%unk/%unk: .Vertical>",
                          "start_line": 1,
                          "end_line": 1,
                          "successors": [
                            {
                              "type": "blockRef",
                              "label": "(RepeatedBlock)"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "private emitDirectionChange(): void {\n\n    /**\n     * reachLeft reachRight scale>1，only five possible situations（when scale<=1,reachLeft、reachRight is true）：\n     * T T T：Vertical\n     * T T F：Vertical（initial state）\n     * T F T：Vertical | Left\n     * F T T：Vertical | Right\n     * F F T：All\n     */\n    let direction;\n    let scale = this.lastScale * this.scale;\n    let isEnlarged = Number(scale.toFixed(Constants.RESERVED_DIGITS)) > Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS));\n    if (!this.hasReachLeft && !this.hasReachRight && isEnlarged) {\n      direction = PanDirection.All;\n    } else if (!this.hasReachLeft && this.hasReachRight && isEnlarged) {\n      direction = (PanDirection.Vertical as number) | (PanDirection.Right as number);\n    } else if (this.hasReachLeft && !this.hasReachRight && isEnlarged) {\n      direction = (PanDirection.Vertical as number) | (PanDirection.Left as number);\n    } else {\n      direction = PanDirection.Vertical;\n    }\n\n    Log.info(TAG, 'emitDirectionChange reaches: ' + this.hasReachLeft + ', ' + this.hasReachRight + ', ' + this.hasReachTop + ', ' + this.hasReachBottom +\n    ', scale ' + scale + ', direction: ' + direction);\n    if (this.isExiting) {\n      return;\n    }\n\n    if (direction === (PanDirection.Vertical as number) || direction === ((PanDirection.Vertical as number) | (PanDirection.Left as number)) ||\n    direction === ((PanDirection.Vertical as number) | (PanDirection.Right as number))) {\n      this.broadCast.emit(Constants.SET_DISABLE_SWIPE, [false]);\n    } else {\n      this.broadCast.emit(Constants.SET_DISABLE_SWIPE, [true]);\n    }\n    this.broadCast.emit(Constants.DIRECTION_CHANGE + this.item.uri + this.timeStamp, [direction]);\n  }"
        },
        {
          "type": "function",
          "name": "evaluateOffset",
          "label": "evaluateOffset",
          "start_line": 1,
          "end_line": 190,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/44.ts: EventPipeline\n%0 = this.<@ts_files/44.ts: EventPipeline.lastOffset>\n%1 = 'evaluateOffset lastOffset: ' + %0\n%2 = %1 + ', offset: '\n%3 = this.<@ts_files/44.ts: EventPipeline.offset>\n%4 = %2 + %3\ninstanceinvoke Log.<@%unk/%unk: .info()>(TAG, %4)\n%5 = this.<@ts_files/44.ts: EventPipeline.center>\n%6 = %5[0]\n%7 = Constants.<@%unk/%unk: .CENTER_DEFAULT>\n%8 = %6 - %7\n%9 = this.<@ts_files/44.ts: EventPipeline.componentWidth>\n%10 = %8 * %9\n%11 = this.<@ts_files/44.ts: EventPipeline.defaultScale>\n%12 = this.<@ts_files/44.ts: EventPipeline.scale>\n%13 = %11 - %12\n%14 = %10 * %13\n%15 = this.<@ts_files/44.ts: EventPipeline.lastScale>\ncenterX = %14 * %15\n%16 = this.<@ts_files/44.ts: EventPipeline.center>\n%17 = %16[1]\n%18 = Constants.<@%unk/%unk: .CENTER_DEFAULT>\n%19 = %17 - %18\n%20 = this.<@ts_files/44.ts: EventPipeline.componentHeight>\n%21 = %19 * %20\n%22 = this.<@ts_files/44.ts: EventPipeline.defaultScale>\n%23 = this.<@ts_files/44.ts: EventPipeline.scale>\n%24 = %22 - %23\n%25 = %21 * %24\n%26 = this.<@ts_files/44.ts: EventPipeline.lastScale>\ncenterY = %25 * %26\n%27 = this.<@ts_files/44.ts: EventPipeline.lastOffset>\n%28 = %27[0]\n%29 = this.<@ts_files/44.ts: EventPipeline.offset>\n%30 = %29[0]\n%31 = %28 + %30\noffsetX = %31 + centerX\n%32 = this.<@ts_files/44.ts: EventPipeline.lastOffset>\n%33 = %32[1]\n%34 = this.<@ts_files/44.ts: EventPipeline.offset>\n%35 = %34[1]\n%36 = %33 + %35\noffsetY = %36 + centerY\n%37 = 'evaluateOffset offsetX: ' + offsetX\n%38 = %37 + ', offsetY: '\n%39 = %38 + offsetY\ninstanceinvoke Log.<@%unk/%unk: .debug()>(TAG, %39)\n%40 = newarray (unknown)[2]\n%40[0] = offsetX\n%40[1] = offsetY\nreturn %40",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "private evaluateOffset(): number[] {\n    Log.info(TAG, 'evaluateOffset lastOffset: ' + this.lastOffset + ', offset: ' + this.offset);\n    let centerX = (this.center[0] - Constants.CENTER_DEFAULT) * this.componentWidth * (this.defaultScale - this.scale) * this.lastScale;\n    let centerY = (this.center[1] - Constants.CENTER_DEFAULT) * this.componentHeight * (this.defaultScale - this.scale) * this.lastScale;\n    let offsetX = this.lastOffset[0] + this.offset[0] + centerX;\n    let offsetY = this.lastOffset[1] + this.offset[1] + centerY;\n    Log.debug(TAG, 'evaluateOffset offsetX: ' + offsetX + ', offsetY: ' + offsetY);\n    return [offsetX, offsetY];\n  }"
        },
        {
          "type": "function",
          "name": "emitTouchEvent",
          "label": "emitTouchEvent",
          "start_line": 1,
          "end_line": 200,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/44.ts: EventPipeline\noffset = undefined\n%0 = this.<@ts_files/44.ts: EventPipeline.lastScale>\n%1 = this.<@ts_files/44.ts: EventPipeline.scale>\nscale = %0 * %1\n%2 = Constants.<@%unk/%unk: .RESERVED_DIGITS>\n%3 = instanceinvoke scale.<@%unk/%unk: .toFixed()>(%2)\n%4 = staticinvoke <@%unk/%unk: .Number()>(%3)\n%5 = Constants.<@%unk/%unk: .RESERVED_DIGITS>\n%6 = this.<@ts_files/44.ts: EventPipeline.defaultScale>\n%7 = instanceinvoke %6.<@%unk/%unk: .toFixed()>(%5)\n%8 = staticinvoke <@%unk/%unk: .Number()>(%7)\nif %4 > %8",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "limits = instanceinvoke this.<@ts_files/44.ts: EventPipeline.evaluateOffsetRange(number)>(scale)\noffset = instanceinvoke this.<@ts_files/44.ts: EventPipeline.evaluateOffset()>()\n%9 = offset[0]\n%10 = limits[0]\n%11 = limits[1]\n%12 = instanceinvoke MathUtils.<@%unk/%unk: .clamp()>(%9, %10, %11)\noffset[0] = %12\n%13 = Constants.<@%unk/%unk: .RESERVED_DIGITS>\n%14 = instanceinvoke scale.<@%unk/%unk: .toFixed()>(%13)\n%15 = staticinvoke <@%unk/%unk: .Number()>(%14)\n%16 = Constants.<@%unk/%unk: .RESERVED_DIGITS>\n%17 = this.<@ts_files/44.ts: EventPipeline.defaultScale>\n%18 = instanceinvoke %17.<@%unk/%unk: .toFixed()>(%16)\n%19 = staticinvoke <@%unk/%unk: .Number()>(%18)\nif %15 > %19",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "%20 = offset[1]\n%21 = limits[2]\n%22 = limits[3]\n%23 = instanceinvoke MathUtils.<@%unk/%unk: .clamp()>(%20, %21, %22)\noffset[1] = %23",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "moveX = offset[0]\nmoveY = offset[1]\n%28 = 'emitTouchEvent moveX: ' + moveX\n%29 = %28 + ', moveY: '\n%30 = %29 + moveY\ninstanceinvoke Log.<@%unk/%unk: .debug()>(TAG, %30)\n%31 = new @ts_files/44.ts: %AC$EventPipeline$emitTouchEvent$0\ninstanceinvoke %31.<@ts_files/44.ts: %AC$EventPipeline$emitTouchEvent$0.constructor()>()\nscaleOption = %31\n%32 = new @ts_files/44.ts: %AC$EventPipeline$emitTouchEvent$1\ninstanceinvoke %32.<@ts_files/44.ts: %AC$EventPipeline$emitTouchEvent$1.constructor()>()\ntranslateOption = %32\n%33 = instanceinvoke Matrix4.<@%unk/%unk: .identity()>()\n%34 = instanceinvoke %33.<@%unk/%unk: .scale()>(scaleOption)\n%35 = instanceinvoke %34.<@%unk/%unk: .translate()>(translateOption)\nmatrix = instanceinvoke %35.<@%unk/%unk: .copy()>()\n%36 = this.<@ts_files/44.ts: EventPipeline.lastOffset>\n%37 = 'emitTouchEvent lastOffset: ' + %36\n%38 = %37 + ', offset: '\n%39 = this.<@ts_files/44.ts: EventPipeline.offset>\n%40 = %38 + %39\n%41 = %40 + ',center: '\n%42 = this.<@ts_files/44.ts: EventPipeline.center>\n%43 = %41 + %42\n%44 = %43 + ', scale: '\n%45 = this.<@ts_files/44.ts: EventPipeline.lastScale>\n%46 = %44 + %45\n%47 = %46 + ', '\n%48 = this.<@ts_files/44.ts: EventPipeline.scale>\n%49 = %47 + %48\ninstanceinvoke Log.<@%unk/%unk: .debug()>(TAG, %49)\ninstanceinvoke this.<@%unk/%unk: .updateMatrix()>(matrix)\ninstanceinvoke this.<@ts_files/44.ts: EventPipeline.evaluateBounds()>()\nreturn",
                          "start_line": 219,
                          "end_line": 599,
                          "successors": []
                        }
                      ]
                    },
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "%24 = limits[2]\n%25 = offset[1]\n%26 = instanceinvoke Math.<@%unk/%unk: .max()>(%24, %25)\noffset[1] = %26",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "blockRef",
                          "label": "(RepeatedBlock)"
                        }
                      ]
                    }
                  ]
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%27 = newarray (number)[2]\n%27[0] = 0\n%27[1] = 0\noffset = %27",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "blockRef",
                      "label": "(RepeatedBlock)"
                    }
                  ]
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "private emitTouchEvent(): void {\n    let offset: number[];\n    let scale = this.lastScale * this.scale;\n    if (Number(scale.toFixed(Constants.RESERVED_DIGITS)) > Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) {\n      let limits = this.evaluateOffsetRange(scale);\n      offset = this.evaluateOffset();\n      // the offset in the X direction is always limited for non shrinking scenes\n      offset[0] = MathUtils.clamp(offset[0], limits[0], limits[1]);\n      if (Number(scale.toFixed(Constants.RESERVED_DIGITS)) > Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) {\n        // cannot pull down to return, limit y\n        offset[1] = MathUtils.clamp(offset[1], limits[2], limits[3]);\n      } else {\n        // can pull down to return to the scene, and only limit y to drag upward, limit the lower bound\n        offset[1] = Math.max(limits[2], offset[1]);\n      }\n    } else {\n      // When zooming in, adjust the zoom center to the display center point\n      offset = [0, 0];\n    }\n    let moveX = offset[0];\n    let moveY = offset[1];\n    Log.debug(TAG, 'emitTouchEvent moveX: ' + moveX + ', moveY: ' + moveY);\n    let scaleOption: Matrix4.ScaleOption = {\n      x: scale,\n      y: scale,\n    };\n    let translateOption: Matrix4.TranslateOption = {\n      x: moveX,\n      y: moveY\n    };\n    let matrix = Matrix4.identity()\n      .scale(scaleOption)\n      .translate(translateOption)\n      .copy();\n    Log.debug(TAG, 'emitTouchEvent lastOffset: ' + this.lastOffset + ', offset: ' + this.offset +\n    ',center: ' + this.center + ', scale: ' + this.lastScale + ', ' + this.scale);\n    this.updateMatrix(matrix);\n    this.evaluateBounds();\n  }"
        },
        {
          "type": "function",
          "name": "evaluateScales",
          "label": "evaluateScales",
          "start_line": 1,
          "end_line": 240,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/44.ts: EventPipeline\n%0 = this.<@ts_files/44.ts: EventPipeline.width>\n%1 = this.<@ts_files/44.ts: EventPipeline.componentHeight>\n%2 = %0 * %1\n%3 = this.<@ts_files/44.ts: EventPipeline.componentWidth>\n%4 = this.<@ts_files/44.ts: EventPipeline.height>\n%5 = %3 * %4\nif %2 < %5",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%6 = this.<@ts_files/44.ts: EventPipeline.height>\n%7 = this.<@ts_files/44.ts: EventPipeline.componentHeight>\n%8 = %6 / %7\nthis.<@ts_files/44.ts: EventPipeline.maxScale> = %8\n%9 = this.<@ts_files/44.ts: EventPipeline.componentWidth>\n%10 = this.<@ts_files/44.ts: EventPipeline.height>\n%11 = %9 * %10\n%12 = this.<@ts_files/44.ts: EventPipeline.width>\n%13 = %11 / %12\n%14 = this.<@ts_files/44.ts: EventPipeline.componentHeight>\n%15 = %13 / %14\nthis.<@ts_files/44.ts: EventPipeline.doubleTapScale> = %15\n%16 = this.<@ts_files/44.ts: EventPipeline.componentHeight>\n%17 = this.<@ts_files/44.ts: EventPipeline.width>\n%18 = %16 * %17\n%19 = this.<@ts_files/44.ts: EventPipeline.height>\n%20 = %18 / %19\n%21 = this.<@ts_files/44.ts: EventPipeline.componentWidth>\n%22 = %20 / %21\n%23 = 1 - %22\n%24 = Constants.<@%unk/%unk: .NUMBER_2>\n%25 = %23 / %24\nthis.<@ts_files/44.ts: EventPipeline.leftMost> = %25\nthis.<@ts_files/44.ts: EventPipeline.topMost> = 0",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "%56 = this.<@ts_files/44.ts: EventPipeline.maxScale>\n%57 = Constants.<@%unk/%unk: .COMPONENT_SCALE_CEIL>\n%58 = instanceinvoke Math.<@%unk/%unk: .max()>(%56, %57)\nthis.<@ts_files/44.ts: EventPipeline.maxScale> = %58\n%59 = this.<@ts_files/44.ts: EventPipeline.doubleTapScale>\n%60 = this.<@ts_files/44.ts: EventPipeline.maxScale>\nif %59 > %60",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "%61 = this.<@ts_files/44.ts: EventPipeline.doubleTapScale>\n%62 = Constants.<@%unk/%unk: .MAX_SCALE_EXTRA_FACTOR>\n%63 = %61 * %62\nthis.<@ts_files/44.ts: EventPipeline.maxScale> = %63",
                          "start_line": 1,
                          "end_line": 1,
                          "successors": [
                            {
                              "type": "block",
                              "name": "Block?",
                              "label": "%64 = this.<@ts_files/44.ts: EventPipeline.width>\n%65 = 'evaluateScales: ' + %64\n%66 = %65 + '*'\n%67 = this.<@ts_files/44.ts: EventPipeline.height>\n%68 = %66 + %67\n%69 = %68 + ' &'\n%70 = this.<@ts_files/44.ts: EventPipeline.componentWidth>\n%71 = %69 + %70\n%72 = %71 + '*'\n%73 = this.<@ts_files/44.ts: EventPipeline.componentHeight>\n%74 = %72 + %73\n%75 = %74 + ',max: '\n%76 = this.<@ts_files/44.ts: EventPipeline.maxScale>\n%77 = %75 + %76\n%78 = %77 + ', most: ['\n%79 = this.<@ts_files/44.ts: EventPipeline.leftMost>\n%80 = %78 + %79\n%81 = %80 + ','\n%82 = this.<@ts_files/44.ts: EventPipeline.topMost>\n%83 = %81 + %82\n%84 = %83 + '], double: '\n%85 = this.<@ts_files/44.ts: EventPipeline.doubleTapScale>\n%86 = %84 + %85\ninstanceinvoke Log.<@%unk/%unk: .debug()>(TAG, %86)\nreturn",
                              "start_line": 1,
                              "end_line": 599,
                              "successors": []
                            }
                          ]
                        },
                        {
                          "type": "blockRef",
                          "label": "(RepeatedBlock)"
                        }
                      ]
                    }
                  ]
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%26 = this.<@ts_files/44.ts: EventPipeline.width>\n%27 = this.<@ts_files/44.ts: EventPipeline.componentHeight>\n%28 = %26 * %27\n%29 = this.<@ts_files/44.ts: EventPipeline.componentWidth>\n%30 = this.<@ts_files/44.ts: EventPipeline.height>\n%31 = %29 * %30\nif %28 === %31",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "%32 = Constants.<@%unk/%unk: .SAME_RATIO_SCALE_FACTOR>\nthis.<@ts_files/44.ts: EventPipeline.doubleTapScale> = %32\n%33 = this.<@ts_files/44.ts: EventPipeline.doubleTapScale>\n%34 = Constants.<@%unk/%unk: .MAX_SCALE_EXTRA_FACTOR>\n%35 = %33 * %34\nthis.<@ts_files/44.ts: EventPipeline.maxScale> = %35\nthis.<@ts_files/44.ts: EventPipeline.leftMost> = 0\nthis.<@ts_files/44.ts: EventPipeline.topMost> = 0",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "blockRef",
                          "label": "(RepeatedBlock)"
                        }
                      ]
                    },
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "%36 = this.<@ts_files/44.ts: EventPipeline.width>\n%37 = this.<@ts_files/44.ts: EventPipeline.componentWidth>\n%38 = %36 / %37\nthis.<@ts_files/44.ts: EventPipeline.maxScale> = %38\n%39 = this.<@ts_files/44.ts: EventPipeline.componentHeight>\n%40 = this.<@ts_files/44.ts: EventPipeline.width>\n%41 = %39 * %40\n%42 = this.<@ts_files/44.ts: EventPipeline.height>\n%43 = %41 / %42\n%44 = this.<@ts_files/44.ts: EventPipeline.componentWidth>\n%45 = %43 / %44\nthis.<@ts_files/44.ts: EventPipeline.doubleTapScale> = %45\nthis.<@ts_files/44.ts: EventPipeline.leftMost> = 0\n%46 = this.<@ts_files/44.ts: EventPipeline.componentWidth>\n%47 = this.<@ts_files/44.ts: EventPipeline.height>\n%48 = %46 * %47\n%49 = this.<@ts_files/44.ts: EventPipeline.width>\n%50 = %48 / %49\n%51 = this.<@ts_files/44.ts: EventPipeline.componentHeight>\n%52 = %50 / %51\n%53 = 1 - %52\n%54 = Constants.<@%unk/%unk: .NUMBER_2>\n%55 = %53 / %54\nthis.<@ts_files/44.ts: EventPipeline.topMost> = %55",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "blockRef",
                          "label": "(RepeatedBlock)"
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "private evaluateScales(): void {\n    if (this.width * this.componentHeight < this.componentWidth * this.height) {\n      // The aspect ratio is less than the display aspect ratio of the control\n      // the height of the control is equal to the height of the picture\n      this.maxScale = this.height / this.componentHeight;\n      // Double click the enlarged scale to ensure that the left and right boundaries are filled\n      this.doubleTapScale = this.componentWidth * this.height / this.width / this.componentHeight;\n      // leftMost = (1 - dspW / compW) / 2 = (1 - compH * imgW / imgH / compW) / 2\n      this.leftMost = (1 - this.componentHeight * this.width / this.height / this.componentWidth) / Constants.NUMBER_2;\n      this.topMost = 0.0;\n    } else if (this.width * this.componentHeight === this.componentWidth * this.height) {\n      // The aspect ratio is equal to the display aspect ratio of the control\n      this.doubleTapScale = Constants.SAME_RATIO_SCALE_FACTOR;\n      this.maxScale = this.doubleTapScale * Constants.MAX_SCALE_EXTRA_FACTOR;\n      this.leftMost = 0;\n      this.topMost = 0;\n    } else {\n      // The aspect ratio is greater than the display aspect ratio of the control\n      // the width of the control is equal to the width of the picture\n      this.maxScale = this.width / this.componentWidth;\n      // Double click the enlarged scale to ensure that the top and bottom fill the boundary\n      this.doubleTapScale = this.componentHeight * this.width / this.height / this.componentWidth;\n      this.leftMost = 0.0;\n      this.topMost = (1 - this.componentWidth * this.height / this.width / this.componentHeight) / Constants.NUMBER_2;\n    }\n\n    this.maxScale = Math.max(this.maxScale, Constants.COMPONENT_SCALE_CEIL);\n    if (this.doubleTapScale > this.maxScale) {\n      this.maxScale = this.doubleTapScale * Constants.MAX_SCALE_EXTRA_FACTOR;\n    }\n    Log.debug(TAG, 'evaluateScales: ' + this.width + '*' + this.height + ' &' +\n    this.componentWidth + '*' + this.componentHeight +\n    ',max: ' + this.maxScale + ', most: [' + this.leftMost + ',' + this.topMost + '], double: ' + this.doubleTapScale);\n  }"
        },
        {
          "type": "function",
          "name": "evaluateCompBounds",
          "label": "evaluateCompBounds",
          "start_line": 1,
          "end_line": 353,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/44.ts: EventPipeline\n%0 = this.<@ts_files/44.ts: EventPipeline.lastScale>\n%1 = this.<@ts_files/44.ts: EventPipeline.scale>\nscale = %0 * %1\noffset = instanceinvoke this.<@ts_files/44.ts: EventPipeline.evaluateOffset()>()\n%2 = offset[0]\n%3 = this.<@ts_files/44.ts: EventPipeline.componentWidth>\n%4 = Constants.<@%unk/%unk: .RESERVED_DIGITS>\n%5 = instanceinvoke scale.<@%unk/%unk: .toFixed()>(%4)\n%6 = staticinvoke <@%unk/%unk: .Number()>(%5)\n%7 = Constants.<@%unk/%unk: .RESERVED_DIGITS>\n%8 = this.<@ts_files/44.ts: EventPipeline.defaultScale>\n%9 = instanceinvoke %8.<@%unk/%unk: .toFixed()>(%7)\n%10 = staticinvoke <@%unk/%unk: .Number()>(%9)\n%11 = %6 - %10\n%12 = %3 * %11\n%13 = Constants.<@%unk/%unk: .NUMBER_2>\n%14 = %12 / %13\n%15 = %2 - %14\n%16 = offset[1]\n%17 = this.<@ts_files/44.ts: EventPipeline.componentHeight>\n%18 = Constants.<@%unk/%unk: .RESERVED_DIGITS>\n%19 = instanceinvoke scale.<@%unk/%unk: .toFixed()>(%18)\n%20 = staticinvoke <@%unk/%unk: .Number()>(%19)\n%21 = Constants.<@%unk/%unk: .RESERVED_DIGITS>\n%22 = this.<@ts_files/44.ts: EventPipeline.defaultScale>\n%23 = instanceinvoke %22.<@%unk/%unk: .toFixed()>(%21)\n%24 = staticinvoke <@%unk/%unk: .Number()>(%23)\n%25 = %20 - %24\n%26 = %17 * %25\n%27 = Constants.<@%unk/%unk: .NUMBER_2>\n%28 = %26 / %27\n%29 = %16 - %28\n%30 = newarray (unknown)[2]\n%30[0] = %15\n%30[1] = %29\nresult = %30\n%31 = 'evaluateCompBounds: ' + result\ninstanceinvoke Log.<@%unk/%unk: .debug()>(TAG, %31)\nreturn result",
              "start_line": 1,
              "end_line": 353,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "private evaluateCompBounds(): number[] {\n    let scale = this.lastScale * this.scale;\n    let offset = this.evaluateOffset();\n    let result: number[] = [\n      offset[0] - this.componentWidth * (Number(scale.toFixed(Constants.RESERVED_DIGITS)) - Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) / Constants.NUMBER_2,\n      offset[1] - this.componentHeight * (Number(scale.toFixed(Constants.RESERVED_DIGITS)) - Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) / Constants.NUMBER_2\n    ];\n    Log.debug(TAG, 'evaluateCompBounds: ' + result);\n    return result;\n  }"
        },
        {
          "type": "function",
          "name": "evaluateImgDisplaySize",
          "label": "evaluateImgDisplaySize",
          "start_line": 1,
          "end_line": 286,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/44.ts: EventPipeline\nscreenScale = 1\n%0 = this.<@ts_files/44.ts: EventPipeline.componentWidth>\n%1 = this.<@ts_files/44.ts: EventPipeline.item>\n%2 = %1.<@%unk/%unk: .imgWidth>\nwidthScale = %0 / %2\n%3 = this.<@ts_files/44.ts: EventPipeline.componentHeight>\n%4 = this.<@ts_files/44.ts: EventPipeline.item>\n%5 = %4.<@%unk/%unk: .imgHeight>\nheightScale = %3 / %5\nif widthScale > heightScale",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "screenScale = heightScale",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "%7 = this.<@ts_files/44.ts: EventPipeline.lastScale>\n%8 = this.<@ts_files/44.ts: EventPipeline.scale>\n%9 = %7 * %8\nscale = %9 * screenScale\nimgDisplayWidth = 0\nimgDisplayHeight = 0\n%10 = this.<@ts_files/44.ts: EventPipeline.width>\nimgDisplayWidth = %10 * scale\n%11 = this.<@ts_files/44.ts: EventPipeline.height>\nimgDisplayHeight = %11 * scale\n%12 = newarray (number)[2]\n%12[0] = imgDisplayWidth\n%12[1] = imgDisplayHeight\nreturn %12",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": []
                    }
                  ]
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "screenScale = widthScale",
                  "start_line": 290,
                  "end_line": 346,
                  "successors": [
                    {
                      "type": "blockRef",
                      "label": "(RepeatedBlock)"
                    }
                  ]
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "private evaluateImgDisplaySize(): number[] {\n    let screenScale = 1;\n    let widthScale = this.componentWidth / this.item.imgWidth;\n    let heightScale = this.componentHeight / this.item.imgHeight;\n    screenScale = widthScale > heightScale ? heightScale : widthScale;\n    let scale = this.lastScale * this.scale * screenScale;\n    let imgDisplayWidth = 0;\n    let imgDisplayHeight = 0;\n    imgDisplayWidth = this.width * scale;\n    imgDisplayHeight = this.height * scale;\n    return [imgDisplayWidth, imgDisplayHeight];\n  }"
        },
        {
          "type": "function",
          "name": "evaluateImgDisplayBounds",
          "label": "evaluateImgDisplayBounds",
          "start_line": 1,
          "end_line": 299,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/44.ts: EventPipeline\n%0 = this.<@ts_files/44.ts: EventPipeline.lastScale>\n%1 = this.<@ts_files/44.ts: EventPipeline.scale>\nscale = %0 * %1\nleftTop = instanceinvoke this.<@ts_files/44.ts: EventPipeline.evaluateCompBounds()>()\nimgDisplaySize = instanceinvoke this.<@ts_files/44.ts: EventPipeline.evaluateImgDisplaySize()>()\nimgDisplayWidth = imgDisplaySize[0]\nimgDisplayHeight = imgDisplaySize[1]\nimgLeftBound = 0\nimgTopBound = 0\n%2 = this.<@ts_files/44.ts: EventPipeline.width>\n%3 = this.<@ts_files/44.ts: EventPipeline.height>\n%4 = %2 / %3\n%5 = this.<@ts_files/44.ts: EventPipeline.componentWidth>\n%6 = this.<@ts_files/44.ts: EventPipeline.componentHeight>\n%7 = %5 / %6\nif %4 > %7",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "imgLeftBound = leftTop[0]\n%8 = leftTop[1]\n%9 = this.<@ts_files/44.ts: EventPipeline.componentHeight>\n%10 = %9 * scale\n%11 = %10 - imgDisplayHeight\n%12 = Constants.<@%unk/%unk: .NUMBER_2>\n%13 = %11 / %12\nimgTopBound = %8 + %13",
                  "start_line": 312,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "%20 = newarray (number)[2]\n%20[0] = imgLeftBound\n%20[1] = imgTopBound\nreturn %20",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": []
                    }
                  ]
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%14 = this.<@ts_files/44.ts: EventPipeline.componentWidth>\n%15 = %14 * scale\n%16 = %15 - imgDisplayWidth\n%17 = Constants.<@%unk/%unk: .NUMBER_2>\n%18 = %16 / %17\n%19 = leftTop[0]\nimgLeftBound = %18 + %19\nimgTopBound = leftTop[1]",
                  "start_line": 1,
                  "end_line": 319,
                  "successors": [
                    {
                      "type": "blockRef",
                      "label": "(RepeatedBlock)"
                    }
                  ]
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "private evaluateImgDisplayBounds(): number[] {\n    // For the left boundary of the component,\n    // the offset caused by amplification is - compw * (scale-1) / 2,\n    // plus the offset of the gesture to obtain the left boundary of the control.\n    // The same is true for the upper boundary\n    let scale = this.lastScale * this.scale;\n    let leftTop = this.evaluateCompBounds();\n    let imgDisplaySize: number[] = this.evaluateImgDisplaySize();\n    let imgDisplayWidth = imgDisplaySize[0];\n    let imgDisplayHeight = imgDisplaySize[1];\n    let imgLeftBound = 0;\n    let imgTopBound = 0;\n    if (this.width / this.height > this.componentWidth / this.componentHeight) {\n      imgLeftBound = leftTop[0];\n      imgTopBound = leftTop[1] + (this.componentHeight * scale - imgDisplayHeight) / Constants.NUMBER_2;\n    } else {\n      // Control width minus the picture width, divided by 2,\n      // you can get the distance from the left of the picture to the left of the control.\n      // Plus offsetX is the left boundary of the picture currently displayed\n      imgLeftBound = (this.componentWidth * scale - imgDisplayWidth) / Constants.NUMBER_2 + leftTop[0];\n      imgTopBound = leftTop[1];\n    }\n    return [imgLeftBound, imgTopBound];\n  }"
        },
        {
          "type": "function",
          "name": "evaluateBounds",
          "label": "evaluateBounds",
          "start_line": 1,
          "end_line": 599,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/44.ts: EventPipeline\nimgDisplaySize = instanceinvoke this.<@ts_files/44.ts: EventPipeline.evaluateImgDisplaySize()>()\nimgDisplayWidth = imgDisplaySize[0]\nimgDisplayBounds = instanceinvoke this.<@ts_files/44.ts: EventPipeline.evaluateImgDisplayBounds()>()\nimgLeftBound = imgDisplayBounds[0]\n%0 = -1\n%1 = imgLeftBound > %0\nthis.<@ts_files/44.ts: EventPipeline.hasReachLeft> = %1\n%2 = imgLeftBound + imgDisplayWidth\n%3 = this.<@ts_files/44.ts: EventPipeline.componentWidth>\n%4 = %3 + 1\n%5 = %2 < %4\nthis.<@ts_files/44.ts: EventPipeline.hasReachRight> = %5\nreturn",
              "start_line": 1,
              "end_line": 599,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "private evaluateBounds(): void {\n    let imgDisplaySize: number[] = this.evaluateImgDisplaySize();\n    let imgDisplayWidth = imgDisplaySize[0];\n\n    let imgDisplayBounds = this.evaluateImgDisplayBounds();\n    let imgLeftBound = imgDisplayBounds[0];\n    this.hasReachLeft = imgLeftBound > -1;\n    this.hasReachRight = imgLeftBound + imgDisplayWidth < this.componentWidth + 1;\n  }"
        },
        {
          "type": "function",
          "name": "evaluateOffsetRange",
          "label": "evaluateOffsetRange",
          "start_line": 1,
          "end_line": 341,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "scale = parameter0: number\nthis = this: @ts_files/44.ts: EventPipeline\n%0 = newarray (number)[4]\n%0[0] = 0\n%0[1] = 0\n%0[2] = 0\n%0[3] = 0\nresult = %0\nscreenScale = 1\n%1 = this.<@ts_files/44.ts: EventPipeline.componentWidth>\n%2 = this.<@ts_files/44.ts: EventPipeline.item>\n%3 = %2.<@%unk/%unk: .imgWidth>\nwidthScale = %1 / %3\n%4 = this.<@ts_files/44.ts: EventPipeline.componentHeight>\n%5 = this.<@ts_files/44.ts: EventPipeline.item>\n%6 = %5.<@%unk/%unk: .imgHeight>\nheightScale = %4 / %6\nif widthScale > heightScale",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "screenScale = heightScale",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "%8 = screenScale * scale\n%9 = this.<@ts_files/44.ts: EventPipeline.width>\n%10 = %8 * %9\n%11 = this.<@ts_files/44.ts: EventPipeline.componentWidth>\n%12 = %10 - %11\n%13 = Constants.<@%unk/%unk: .NUMBER_2>\nleft = %12 / %13\n%14 = screenScale * scale\n%15 = this.<@ts_files/44.ts: EventPipeline.height>\n%16 = %14 * %15\n%17 = this.<@ts_files/44.ts: EventPipeline.componentHeight>\n%18 = %16 - %17\n%19 = Constants.<@%unk/%unk: .NUMBER_2>\ntop = %18 / %19\ntop = instanceinvoke Math.<@%unk/%unk: .max()>(top, 0)\nleft = instanceinvoke Math.<@%unk/%unk: .max()>(left, 0)\n%20 = -left\n%21 = -top\n%22 = newarray (unknown)[4]\n%22[0] = %20\n%22[1] = left\n%22[2] = %21\n%22[3] = top\nresult = %22\n%23 = 'evaluateOffsetRange scale: ' + scale\n%24 = %23 + ', defaultScale: '\n%25 = this.<@ts_files/44.ts: EventPipeline.defaultScale>\n%26 = %24 + %25\n%27 = %26 + ', result: '\n%28 = %27 + result\ninstanceinvoke Log.<@%unk/%unk: .debug()>(TAG, %28)\nreturn result",
                      "start_line": 1,
                      "end_line": 353,
                      "successors": []
                    }
                  ]
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "screenScale = widthScale",
                  "start_line": 290,
                  "end_line": 346,
                  "successors": [
                    {
                      "type": "blockRef",
                      "label": "(RepeatedBlock)"
                    }
                  ]
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "private evaluateOffsetRange(scale: number): number[] {\n    let result: number[] = [0, 0, 0, 0];\n    let screenScale = 1;\n    let widthScale = this.componentWidth / this.item.imgWidth;\n    let heightScale = this.componentHeight / this.item.imgHeight;\n    screenScale = widthScale > heightScale ? heightScale : widthScale;\n    let left = (screenScale * scale * this.width - this.componentWidth) / Constants.NUMBER_2;\n    let top = (screenScale * scale * this.height - this.componentHeight) / Constants.NUMBER_2;\n    top = Math.max(top, 0);\n    left = Math.max(left, 0);\n    result = [-left, left, -top, top];\n    Log.debug(TAG, 'evaluateOffsetRange scale: ' + scale + ', defaultScale: ' + this.defaultScale + ', result: ' + result);\n    return result;\n  }"
        },
        {
          "type": "function",
          "name": "emitPullDownToBackEvent",
          "label": "emitPullDownToBackEvent",
          "start_line": 1,
          "end_line": 356,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/44.ts: EventPipeline\ninstanceinvoke Log.<@%unk/%unk: .debug()>(TAG, 'emitPullDownToBackEvent')\n%0 = this.<@ts_files/44.ts: EventPipeline.isExiting>\nif %0 != false",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%1 = this.<@ts_files/44.ts: EventPipeline.isExiting>\n%2 = 'emitPullDownToBack isExiting: ' + %1\ninstanceinvoke Log.<@%unk/%unk: .info()>(TAG, %2)\nreturn",
                  "start_line": 1,
                  "end_line": 599,
                  "successors": []
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%3 = Constants.<@%unk/%unk: .PULL_DOWN_END>\n%4 = newarray (any)[0]\n%5 = this.<@ts_files/44.ts: EventPipeline.broadCast>\ninstanceinvoke %5.<@%unk/%unk: .emit()>(%3, %4)\nthis.<@ts_files/44.ts: EventPipeline.isExiting> = true\nreturn",
                  "start_line": 1,
                  "end_line": 599,
                  "successors": []
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "private emitPullDownToBackEvent(): void {\n    Log.debug(TAG, 'emitPullDownToBackEvent');\n    if (this.isExiting) {\n      Log.info(TAG, 'emitPullDownToBack isExiting: ' + this.isExiting);\n      return;\n    }\n    this.broadCast.emit(Constants.PULL_DOWN_END, []);\n    this.isExiting = true;\n  }"
        },
        {
          "type": "function",
          "name": "emitPullDownCancelEvent",
          "label": "emitPullDownCancelEvent",
          "start_line": 1,
          "end_line": 599,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/44.ts: EventPipeline\ninstanceinvoke Log.<@%unk/%unk: .debug()>(TAG, 'emitPullDownCancelEvent')\n%0 = Constants.<@%unk/%unk: .PULL_DOWN_CANCEL>\n%1 = newarray (any)[0]\n%2 = this.<@ts_files/44.ts: EventPipeline.broadCast>\ninstanceinvoke %2.<@%unk/%unk: .emit()>(%0, %1)\nreturn",
              "start_line": 1,
              "end_line": 599,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "private emitPullDownCancelEvent(): void {\n    Log.debug(TAG, 'emitPullDownCancelEvent');\n    this.broadCast.emit(Constants.PULL_DOWN_CANCEL, []);\n  }"
        },
        {
          "type": "function",
          "name": "onMoveStart",
          "label": "onMoveStart",
          "start_line": 1,
          "end_line": 371,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "offsetX = parameter0: number\noffsetY = parameter1: number\nthis = this: @ts_files/44.ts: EventPipeline\n%0 = this.<@ts_files/44.ts: EventPipeline.isInAnimation>\n%1 = this.<@ts_files/44.ts: EventPipeline.isExiting>\n%2 = %0 || %1\nif %2 != false",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "return",
                  "start_line": 104,
                  "end_line": 599,
                  "successors": []
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%3 = newarray (number)[2]\n%3[0] = 0\n%3[1] = 0\nthis.<@ts_files/44.ts: EventPipeline.offset> = %3\ninstanceinvoke this.<@ts_files/44.ts: EventPipeline.evaluateBounds()>()\n%4 = this.<@ts_files/44.ts: EventPipeline.lastScale>\n%5 = this.<@ts_files/44.ts: EventPipeline.scale>\nscale = %4 * %5\n%6 = Constants.<@%unk/%unk: .RESERVED_DIGITS>\n%7 = instanceinvoke scale.<@%unk/%unk: .toFixed()>(%6)\n%8 = staticinvoke <@%unk/%unk: .Number()>(%7)\n%9 = Constants.<@%unk/%unk: .RESERVED_DIGITS>\n%10 = this.<@ts_files/44.ts: EventPipeline.defaultScale>\n%11 = instanceinvoke %10.<@%unk/%unk: .toFixed()>(%9)\n%12 = staticinvoke <@%unk/%unk: .Number()>(%11)\nif %8 > %12",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "%13 = Constants.<@%unk/%unk: .HIDE_BARS>\n%14 = newarray (any)[0]\n%15 = this.<@ts_files/44.ts: EventPipeline.broadCast>\ninstanceinvoke %15.<@%unk/%unk: .emit()>(%13, %14)",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "%16 = Constants.<@%unk/%unk: .RESERVED_DIGITS>\n%17 = instanceinvoke scale.<@%unk/%unk: .toFixed()>(%16)\n%18 = Constants.<@%unk/%unk: .RESERVED_DIGITS>\n%19 = this.<@ts_files/44.ts: EventPipeline.defaultScale>\n%20 = instanceinvoke %19.<@%unk/%unk: .toFixed()>(%18)\n%21 = %17 === %20\n%22 = offsetY > 0\n%23 = %21 && %22\nif %23 != false",
                          "start_line": 1,
                          "end_line": 1,
                          "successors": [
                            {
                              "type": "block",
                              "name": "Block?",
                              "label": "%24 = Constants.<@%unk/%unk: .PULL_DOWN_START>\n%25 = newarray (any)[0]\n%26 = this.<@ts_files/44.ts: EventPipeline.broadCast>\ninstanceinvoke %26.<@%unk/%unk: .emit()>(%24, %25)",
                              "start_line": 1,
                              "end_line": 1,
                              "successors": [
                                {
                                  "type": "block",
                                  "name": "Block?",
                                  "label": "return",
                                  "start_line": 104,
                                  "end_line": 599,
                                  "successors": []
                                }
                              ]
                            },
                            {
                              "type": "blockRef",
                              "label": "(RepeatedBlock)"
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "type": "blockRef",
                      "label": "(RepeatedBlock)"
                    }
                  ]
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "onMoveStart(offsetX: number, offsetY: number): void {\n    if (this.isInAnimation || this.isExiting) {\n      return;\n    }\n    // Reset offset at the beginning of dragging to prevent jumping\n    this.offset = [0, 0];\n    this.evaluateBounds();\n    let scale = this.lastScale * this.scale;\n    if (Number(scale.toFixed(Constants.RESERVED_DIGITS)) > Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) {\n      // Hide bars with zoom drag\n      this.broadCast.emit(Constants.HIDE_BARS, []);\n    }\n    if (scale.toFixed(Constants.RESERVED_DIGITS) === this.defaultScale.toFixed(Constants.RESERVED_DIGITS) && offsetY > 0) {\n      // Drop down return to hide details first\n      this.broadCast.emit(Constants.PULL_DOWN_START, []);\n    }\n  }"
        },
        {
          "type": "function",
          "name": "onMove",
          "label": "onMove",
          "start_line": 1,
          "end_line": 395,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "offsetX = parameter0: number\noffsetY = parameter1: number\nthis = this: @ts_files/44.ts: EventPipeline\n%0 = this.<@ts_files/44.ts: EventPipeline.isInAnimation>\n%1 = this.<@ts_files/44.ts: EventPipeline.isExiting>\n%2 = %0 || %1\nif %2 != false",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "return",
                  "start_line": 104,
                  "end_line": 599,
                  "successors": []
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%3 = this.<@ts_files/44.ts: EventPipeline.lastScale>\n%4 = this.<@ts_files/44.ts: EventPipeline.scale>\nscale = %3 * %4\nlimits = instanceinvoke this.<@ts_files/44.ts: EventPipeline.evaluateOffsetRange(number)>(scale)\n%5 = this.<@ts_files/44.ts: EventPipeline.lastOffset>\n%6 = %5[0]\n%7 = this.<@ts_files/44.ts: EventPipeline.center>\n%8 = %7[0]\n%9 = Constants.<@%unk/%unk: .CENTER_DEFAULT>\n%10 = %8 - %9\n%11 = this.<@ts_files/44.ts: EventPipeline.componentWidth>\n%12 = %10 * %11\n%13 = this.<@ts_files/44.ts: EventPipeline.defaultScale>\n%14 = this.<@ts_files/44.ts: EventPipeline.scale>\n%15 = %13 - %14\n%16 = %12 * %15\n%17 = this.<@ts_files/44.ts: EventPipeline.lastScale>\n%18 = %16 * %17\nmeasureX = %6 + %18\n%19 = this.<@ts_files/44.ts: EventPipeline.lastOffset>\n%20 = %19[1]\n%21 = this.<@ts_files/44.ts: EventPipeline.center>\n%22 = %21[1]\n%23 = Constants.<@%unk/%unk: .CENTER_DEFAULT>\n%24 = %22 - %23\n%25 = this.<@ts_files/44.ts: EventPipeline.componentHeight>\n%26 = %24 * %25\n%27 = this.<@ts_files/44.ts: EventPipeline.defaultScale>\n%28 = this.<@ts_files/44.ts: EventPipeline.scale>\n%29 = %27 - %28\n%30 = %26 * %29\n%31 = this.<@ts_files/44.ts: EventPipeline.lastScale>\n%32 = %30 * %31\nmeasureY = %20 + %32\nmoveX = offsetX\nmoveY = offsetY\noffX = measureX + moveX\noffY = measureY + moveY\n%33 = Constants.<@%unk/%unk: .RESERVED_DIGITS>\n%34 = instanceinvoke scale.<@%unk/%unk: .toFixed()>(%33)\n%35 = staticinvoke <@%unk/%unk: .Number()>(%34)\n%36 = Constants.<@%unk/%unk: .RESERVED_DIGITS>\n%37 = this.<@ts_files/44.ts: EventPipeline.defaultScale>\n%38 = instanceinvoke %37.<@%unk/%unk: .toFixed()>(%36)\n%39 = staticinvoke <@%unk/%unk: .Number()>(%38)\nif %35 > %39",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "%40 = limits[0]\n%41 = limits[1]\noffX = instanceinvoke MathUtils.<@%unk/%unk: .clamp()>(offX, %40, %41)\n%42 = Constants.<@%unk/%unk: .RESERVED_DIGITS>\n%43 = instanceinvoke scale.<@%unk/%unk: .toFixed()>(%42)\n%44 = staticinvoke <@%unk/%unk: .Number()>(%43)\n%45 = Constants.<@%unk/%unk: .RESERVED_DIGITS>\n%46 = this.<@ts_files/44.ts: EventPipeline.defaultScale>\n%47 = instanceinvoke %46.<@%unk/%unk: .toFixed()>(%45)\n%48 = staticinvoke <@%unk/%unk: .Number()>(%47)\nif %44 > %48",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "%49 = Constants.<@%unk/%unk: .NUMBER_2>\n%50 = limits[%49]\n%51 = Constants.<@%unk/%unk: .NUMBER_3>\n%52 = limits[%51]\noffY = instanceinvoke MathUtils.<@%unk/%unk: .clamp()>(offY, %50, %52)",
                          "start_line": 1,
                          "end_line": 1,
                          "successors": [
                            {
                              "type": "block",
                              "name": "Block?",
                              "label": "tmpX = offX - measureX\ntmpY = offY - measureY\n%55 = newarray (unknown)[2]\n%55[0] = tmpX\n%55[1] = tmpY\nthis.<@ts_files/44.ts: EventPipeline.offset> = %55\ninstanceinvoke this.<@ts_files/44.ts: EventPipeline.emitTouchEvent()>()\nreturn",
                              "start_line": 420,
                              "end_line": 599,
                              "successors": []
                            }
                          ]
                        },
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "%53 = Constants.<@%unk/%unk: .NUMBER_2>\n%54 = limits[%53]\noffY = instanceinvoke Math.<@%unk/%unk: .max()>(%54, offY)",
                          "start_line": 1,
                          "end_line": 1,
                          "successors": [
                            {
                              "type": "blockRef",
                              "label": "(RepeatedBlock)"
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "type": "blockRef",
                      "label": "(RepeatedBlock)"
                    }
                  ]
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "onMove(offsetX: number, offsetY: number): void {\n    if (this.isInAnimation || this.isExiting) {\n      return;\n    }\n    let scale = this.lastScale * this.scale;\n    let limits = this.evaluateOffsetRange(scale);\n    let measureX = this.lastOffset[0] + (this.center[0] - Constants.CENTER_DEFAULT) * this.componentWidth\n    * (this.defaultScale - this.scale) * this.lastScale;\n    let measureY = this.lastOffset[1] + (this.center[1] - Constants.CENTER_DEFAULT) * this.componentHeight\n    * (this.defaultScale - this.scale) * this.lastScale;\n    let moveX = offsetX;\n    let moveY = offsetY;\n    let offX = measureX + moveX;\n    let offY = measureY + moveY;\n    if (Number(scale.toFixed(Constants.RESERVED_DIGITS)) > Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) {\n      // The offset in the X direction is always limited for non shrinking scenes\n      offX = MathUtils.clamp(offX, limits[0], limits[1]);\n      if (Number(scale.toFixed(Constants.RESERVED_DIGITS)) > Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) {\n        // cannot drop down to return to the scene, limit y\n        offY = MathUtils.clamp(offY, limits[Constants.NUMBER_2], limits[Constants.NUMBER_3]);\n      } else {\n        // pull down to return to the scene, and only limit y to drag upward, that is, limit the lower bound\n        offY = Math.max(limits[Constants.NUMBER_2], offY);\n      }\n    }\n    let tmpX = offX - measureX;\n    let tmpY = offY - measureY;\n    this.offset = [tmpX, tmpY];\n    this.emitTouchEvent();\n  }"
        },
        {
          "type": "function",
          "name": "onMoveEnd",
          "label": "onMoveEnd",
          "start_line": 1,
          "end_line": 426,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "offsetX = parameter0: unknown\noffsetY = parameter1: unknown\nthis = this: @ts_files/44.ts: EventPipeline\n%0 = this.<@ts_files/44.ts: EventPipeline.isInAnimation>\n%1 = this.<@ts_files/44.ts: EventPipeline.isExiting>\n%2 = %0 || %1\nif %2 != false",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "return",
                  "start_line": 104,
                  "end_line": 599,
                  "successors": []
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%3 = this.<@ts_files/44.ts: EventPipeline.lastScale>\n%4 = this.<@ts_files/44.ts: EventPipeline.scale>\nscale = %3 * %4\n%5 = 'onMoveEnd: scale is ' + scale\n%6 = %5 + ' offsetY is '\n%7 = %6 + offsetY\ninstanceinvoke Log.<@%unk/%unk: .debug()>(TAG, %7)\n%8 = Constants.<@%unk/%unk: .RESERVED_DIGITS>\n%9 = instanceinvoke scale.<@%unk/%unk: .toFixed()>(%8)\n%10 = Constants.<@%unk/%unk: .RESERVED_DIGITS>\n%11 = this.<@ts_files/44.ts: EventPipeline.defaultScale>\n%12 = instanceinvoke %11.<@%unk/%unk: .toFixed()>(%10)\n%13 = %9 === %12\n%14 = Constants.<@%unk/%unk: .PULL_DOWN_THRESHOLD>\n%15 = offsetY > %14\n%16 = %13 && %15\nif %16 != false",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "instanceinvoke this.<@ts_files/44.ts: EventPipeline.emitPullDownToBackEvent()>()",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "return",
                          "start_line": 104,
                          "end_line": 599,
                          "successors": []
                        }
                      ]
                    },
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "%17 = Constants.<@%unk/%unk: .RESERVED_DIGITS>\n%18 = instanceinvoke scale.<@%unk/%unk: .toFixed()>(%17)\n%19 = Constants.<@%unk/%unk: .RESERVED_DIGITS>\n%20 = this.<@ts_files/44.ts: EventPipeline.defaultScale>\n%21 = instanceinvoke %20.<@%unk/%unk: .toFixed()>(%19)\nif %18 === %21",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "%22 = new @ts_files/44.ts: %AC$EventPipeline$onMoveEnd$2\ninstanceinvoke %22.<@ts_files/44.ts: %AC$EventPipeline$onMoveEnd$2.constructor()>()\nscaleOption = %22\n%23 = instanceinvoke Matrix4.<@%unk/%unk: .identity()>()\n%24 = instanceinvoke %23.<@%unk/%unk: .scale()>(scaleOption)\n%25 = instanceinvoke %24.<@%unk/%unk: .copy()>()\n%26 = <@ts_files/44.ts: Matrix4TransitWithMatrix4x4>%25\ninstanceinvoke this.<@ts_files/44.ts: EventPipeline.startAnimation(@ts_files/44.ts: Matrix4TransitWithMatrix4x4)>(%26)\ninstanceinvoke this.<@ts_files/44.ts: EventPipeline.emitPullDownCancelEvent()>()",
                          "start_line": 1,
                          "end_line": 1,
                          "successors": [
                            {
                              "type": "blockRef",
                              "label": "(RepeatedBlock)"
                            }
                          ]
                        },
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "instanceinvoke this.<@ts_files/44.ts: EventPipeline.emitDirectionChange()>()",
                          "start_line": 1,
                          "end_line": 1,
                          "successors": [
                            {
                              "type": "blockRef",
                              "label": "(RepeatedBlock)"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "onMoveEnd(offsetX, offsetY): void {\n    if (this.isInAnimation || this.isExiting) {\n      return;\n    }\n    let scale = this.lastScale * this.scale;\n    Log.debug(TAG, 'onMoveEnd: scale is ' + scale + ' offsetY is ' + offsetY);\n    if (scale.toFixed(Constants.RESERVED_DIGITS) === this.defaultScale.toFixed(Constants.RESERVED_DIGITS) && offsetY > Constants.PULL_DOWN_THRESHOLD) {\n      this.emitPullDownToBackEvent();\n    } else if (scale.toFixed(Constants.RESERVED_DIGITS) === this.defaultScale.toFixed(Constants.RESERVED_DIGITS)) {\n      // The reset animation is triggered when the threshold is not reached\n      let scaleOption: Matrix4.ScaleOption = {\n        x: this.defaultScale,\n        y: this.defaultScale\n      };\n      this.startAnimation(Matrix4.identity().scale(scaleOption).copy() as Matrix4TransitWithMatrix4x4);\n      this.emitPullDownCancelEvent();\n    } else {\n      this.emitDirectionChange();\n    }\n  }"
        },
        {
          "type": "function",
          "name": "onScaleStart",
          "label": "onScaleStart",
          "start_line": 1,
          "end_line": 447,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "scale = parameter0: number\ncenterX = parameter1: number\ncenterY = parameter2: number\nthis = this: @ts_files/44.ts: EventPipeline\n%0 = this.<@ts_files/44.ts: EventPipeline.isInAnimation>\n%1 = 'onScaleStart: ' + %0\n%2 = %1 + ', '\n%3 = this.<@ts_files/44.ts: EventPipeline.isExiting>\n%4 = %2 + %3\ninstanceinvoke Log.<@%unk/%unk: .info()>(TAG, %4)\n%5 = this.<@ts_files/44.ts: EventPipeline.isInAnimation>\n%6 = this.<@ts_files/44.ts: EventPipeline.isExiting>\n%7 = %5 || %6\nif %7 != false",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "return",
                  "start_line": 104,
                  "end_line": 599,
                  "successors": []
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "this.<@ts_files/44.ts: EventPipeline.scale> = 1\ninstanceinvoke this.<@ts_files/44.ts: EventPipeline.evaluateBounds()>()\n%8 = Constants.<@%unk/%unk: .HIDE_BARS>\n%9 = newarray (any)[0]\n%10 = this.<@ts_files/44.ts: EventPipeline.broadCast>\ninstanceinvoke %10.<@%unk/%unk: .emit()>(%8, %9)\n%11 = instanceinvoke this.<@ts_files/44.ts: EventPipeline.evaluateCenter(number, number)>(centerX, centerY)\nthis.<@ts_files/44.ts: EventPipeline.center> = %11\nreturn",
                  "start_line": 1,
                  "end_line": 599,
                  "successors": []
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "onScaleStart(scale: number, centerX: number, centerY: number): void {\n    Log.info(TAG, 'onScaleStart: ' + this.isInAnimation + ', ' + this.isExiting);\n    if (this.isInAnimation || this.isExiting) {\n      return;\n    }\n    this.scale = 1;\n    this.evaluateBounds();\n    // Adjust action bar status\n    this.broadCast.emit(Constants.HIDE_BARS, []);\n    this.center = this.evaluateCenter(centerX, centerY);\n  }"
        },
        {
          "type": "function",
          "name": "evaluateCenter",
          "label": "evaluateCenter",
          "start_line": 1,
          "end_line": 466,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "centerX = parameter0: number\ncenterY = parameter1: number\nthis = this: @ts_files/44.ts: EventPipeline\n%0 = this.<@ts_files/44.ts: EventPipeline.lastScale>\n%1 = this.<@ts_files/44.ts: EventPipeline.scale>\nscale = %0 * %1\nleftTop = instanceinvoke this.<@ts_files/44.ts: EventPipeline.evaluateCompBounds()>()\n%2 = leftTop[0]\n%3 = centerX - %2\n%4 = this.<@ts_files/44.ts: EventPipeline.componentWidth>\n%5 = %4 * scale\n%6 = %3 / %5\n%7 = this.<@ts_files/44.ts: EventPipeline.leftMost>\n%8 = this.<@ts_files/44.ts: EventPipeline.leftMost>\n%9 = 1 - %8\ncxRelativeToComp = instanceinvoke MathUtils.<@%unk/%unk: .clamp()>(%6, %7, %9)\n%10 = leftTop[1]\n%11 = centerY - %10\n%12 = this.<@ts_files/44.ts: EventPipeline.componentHeight>\n%13 = %12 * scale\n%14 = %11 / %13\n%15 = this.<@ts_files/44.ts: EventPipeline.topMost>\n%16 = this.<@ts_files/44.ts: EventPipeline.topMost>\n%17 = 1 - %16\ncyRelativeToComp = instanceinvoke MathUtils.<@%unk/%unk: .clamp()>(%14, %15, %17)\nimgDisplaySize = instanceinvoke this.<@ts_files/44.ts: EventPipeline.evaluateImgDisplaySize()>()\nimgDisplayWidth = imgDisplaySize[0]\nimgDisplayHeight = imgDisplaySize[1]\nimgDisplayBounds = instanceinvoke this.<@ts_files/44.ts: EventPipeline.evaluateImgDisplayBounds()>()\nimgLeftBound = imgDisplayBounds[0]\nimgTopBound = imgDisplayBounds[1]\n%18 = this.<@ts_files/44.ts: EventPipeline.width>\n%19 = this.<@ts_files/44.ts: EventPipeline.height>\n%20 = %18 / %19\n%21 = this.<@ts_files/44.ts: EventPipeline.componentWidth>\n%22 = this.<@ts_files/44.ts: EventPipeline.componentHeight>\n%23 = %21 / %22\nif %20 > %23",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%24 = centerY < imgTopBound\n%25 = imgTopBound + imgDisplayHeight\n%26 = centerY > %25\n%27 = %24 || %26\nif %27 != false",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "cyRelativeToComp = Constants.<@%unk/%unk: .CENTER_DEFAULT>",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "%28 = newarray (unknown)[2]\n%28[0] = cxRelativeToComp\n%28[1] = cyRelativeToComp\ncenter = %28\n%29 = 'evaluateCenter center: ' + center\n%30 = %29 + ', '\n%31 = %30 + centerX\n%32 = %31 + ','\n%33 = %32 + centerY\n%34 = %33 + ',size: '\n%35 = %34 + imgDisplaySize\n%36 = %35 + ', bounds: '\n%37 = %36 + imgDisplayBounds\n%38 = %37 + ', leftTop: '\n%39 = %38 + leftTop\n%40 = %39 + ',compSize: '\n%41 = this.<@ts_files/44.ts: EventPipeline.componentWidth>\n%42 = %41 * scale\n%43 = %40 + %42\n%44 = %43 + ','\n%45 = this.<@ts_files/44.ts: EventPipeline.componentHeight>\n%46 = %45 * scale\n%47 = %44 + %46\ninstanceinvoke Log.<@%unk/%unk: .debug()>(TAG, %47)\nreturn center",
                          "start_line": 1,
                          "end_line": 502,
                          "successors": []
                        }
                      ]
                    },
                    {
                      "type": "blockRef",
                      "label": "(RepeatedBlock)"
                    }
                  ]
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%48 = centerX < imgLeftBound\n%49 = imgLeftBound + imgDisplayWidth\n%50 = centerX > %49\n%51 = %48 || %50\nif %51 != false",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "cxRelativeToComp = Constants.<@%unk/%unk: .CENTER_DEFAULT>",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "blockRef",
                          "label": "(RepeatedBlock)"
                        }
                      ]
                    },
                    {
                      "type": "blockRef",
                      "label": "(RepeatedBlock)"
                    }
                  ]
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "private evaluateCenter(centerX: number, centerY: number): number[] {\n    // Calculate the coordinates of the upper left corner of the control relative to\n    // the upper left corner of the current display\n    let scale = this.lastScale * this.scale;\n    let leftTop = this.evaluateCompBounds();\n\n    // Get the touch coordinates relative to the control\n    let cxRelativeToComp = MathUtils.clamp((centerX - leftTop[0])\n    / (this.componentWidth * scale), this.leftMost, 1 - this.leftMost);\n    let cyRelativeToComp = MathUtils.clamp((centerY - leftTop[1])\n    / (this.componentHeight * scale), this.topMost, 1 - this.topMost);\n\n    let imgDisplaySize: number[] = this.evaluateImgDisplaySize();\n    let imgDisplayWidth = imgDisplaySize[0];\n    let imgDisplayHeight = imgDisplaySize[1];\n\n    let imgDisplayBounds = this.evaluateImgDisplayBounds();\n    let imgLeftBound = imgDisplayBounds[0];\n    let imgTopBound = imgDisplayBounds[1];\n\n    // When the touch center point is outside the picture display area, take the midpoint\n    if (this.width / this.height > this.componentWidth / this.componentHeight) {\n      if (centerY < imgTopBound || centerY > imgTopBound + imgDisplayHeight) {\n        cyRelativeToComp = Constants.CENTER_DEFAULT;\n      }\n    } else {\n      if (centerX < imgLeftBound || centerX > imgLeftBound + imgDisplayWidth) {\n        cxRelativeToComp = Constants.CENTER_DEFAULT;\n      }\n    }\n\n    // Calculate the percentage of the center point of the touch\n    let center: number[] = [cxRelativeToComp, cyRelativeToComp];\n    Log.debug(TAG, 'evaluateCenter center: ' + center + ', ' + centerX + ',' + centerY +\n    ',size: ' + imgDisplaySize + ', bounds: ' + imgDisplayBounds + ', leftTop: ' + leftTop +\n    ',compSize: ' + this.componentWidth * scale + ',' + this.componentHeight * scale);\n    return center;\n  }"
        },
        {
          "type": "function",
          "name": "onScale",
          "label": "onScale",
          "start_line": 1,
          "end_line": 505,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "scale = parameter0: number\nthis = this: @ts_files/44.ts: EventPipeline\n%0 = this.<@ts_files/44.ts: EventPipeline.isInAnimation>\n%1 = 'onScale: ' + %0\n%2 = %1 + ', '\n%3 = this.<@ts_files/44.ts: EventPipeline.isExiting>\n%4 = %2 + %3\n%5 = %4 + ', scale: '\n%6 = %5 + scale\ninstanceinvoke Log.<@%unk/%unk: .debug()>(TAG, %6)\n%7 = this.<@ts_files/44.ts: EventPipeline.isInAnimation>\n%8 = this.<@ts_files/44.ts: EventPipeline.isExiting>\n%9 = %7 || %8\nif %9 != false",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "return",
                  "start_line": 104,
                  "end_line": 599,
                  "successors": []
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "instanceinvoke this.<@ts_files/44.ts: EventPipeline.evaluateBounds()>()\nthis.<@ts_files/44.ts: EventPipeline.scale> = scale\n%10 = this.<@ts_files/44.ts: EventPipeline.lastScale>\n%11 = %10 * scale\n%12 = Constants.<@%unk/%unk: .COMPONENT_SCALE_FLOOR>\nif %11 <= %12",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "%13 = Constants.<@%unk/%unk: .COMPONENT_SCALE_FLOOR>\n%14 = this.<@ts_files/44.ts: EventPipeline.lastScale>\n%15 = %13 / %14\nthis.<@ts_files/44.ts: EventPipeline.scale> = %15",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "%16 = this.<@ts_files/44.ts: EventPipeline.lastScale>\n%17 = %16 * scale\n%18 = this.<@ts_files/44.ts: EventPipeline.maxScale>\n%19 = Constants.<@%unk/%unk: .OVER_SCALE_EXTRA_FACTOR>\n%20 = %18 * %19\nif %17 >= %20",
                          "start_line": 1,
                          "end_line": 1,
                          "successors": [
                            {
                              "type": "block",
                              "name": "Block?",
                              "label": "%21 = this.<@ts_files/44.ts: EventPipeline.maxScale>\n%22 = Constants.<@%unk/%unk: .OVER_SCALE_EXTRA_FACTOR>\n%23 = %21 * %22\n%24 = this.<@ts_files/44.ts: EventPipeline.lastScale>\n%25 = %23 / %24\nthis.<@ts_files/44.ts: EventPipeline.scale> = %25",
                              "start_line": 1,
                              "end_line": 1,
                              "successors": [
                                {
                                  "type": "block",
                                  "name": "Block?",
                                  "label": "instanceinvoke this.<@ts_files/44.ts: EventPipeline.emitTouchEvent()>()\nreturn",
                                  "start_line": 1,
                                  "end_line": 599,
                                  "successors": []
                                }
                              ]
                            },
                            {
                              "type": "blockRef",
                              "label": "(RepeatedBlock)"
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "type": "blockRef",
                      "label": "(RepeatedBlock)"
                    }
                  ]
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "onScale(scale: number): void {\n    Log.debug(TAG, 'onScale: ' + this.isInAnimation + ', ' + this.isExiting + ', scale: ' + scale);\n    if (this.isInAnimation || this.isExiting) {\n      return;\n    }\n    this.evaluateBounds();\n    this.scale = scale;\n    if (this.lastScale * scale <= Constants.COMPONENT_SCALE_FLOOR) {\n      this.scale = Constants.COMPONENT_SCALE_FLOOR / this.lastScale;\n    }\n    if (this.lastScale * scale >= this.maxScale * Constants.OVER_SCALE_EXTRA_FACTOR) {\n      this.scale = this.maxScale * Constants.OVER_SCALE_EXTRA_FACTOR / this.lastScale;\n    }\n    this.emitTouchEvent();\n  }"
        },
        {
          "type": "function",
          "name": "onScaleEnd",
          "label": "onScaleEnd",
          "start_line": 1,
          "end_line": 521,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/44.ts: EventPipeline\n%0 = this.<@ts_files/44.ts: EventPipeline.isInAnimation>\n%1 = 'onScaleEnd: ' + %0\n%2 = %1 + ', '\n%3 = this.<@ts_files/44.ts: EventPipeline.isExiting>\n%4 = %2 + %3\ninstanceinvoke Log.<@%unk/%unk: .info()>(TAG, %4)\n%5 = this.<@ts_files/44.ts: EventPipeline.isInAnimation>\n%6 = this.<@ts_files/44.ts: EventPipeline.isExiting>\n%7 = %5 || %6\nif %7 != false",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "return",
                  "start_line": 104,
                  "end_line": 599,
                  "successors": []
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "instanceinvoke this.<@ts_files/44.ts: EventPipeline.evaluateBounds()>()\n%8 = this.<@ts_files/44.ts: EventPipeline.lastScale>\n%9 = this.<@ts_files/44.ts: EventPipeline.scale>\nscale = %8 * %9\n%10 = Constants.<@%unk/%unk: .RESERVED_DIGITS>\n%11 = instanceinvoke scale.<@%unk/%unk: .toFixed()>(%10)\n%12 = staticinvoke <@%unk/%unk: .Number()>(%11)\n%13 = Constants.<@%unk/%unk: .RESERVED_DIGITS>\n%14 = this.<@ts_files/44.ts: EventPipeline.defaultScale>\n%15 = instanceinvoke %14.<@%unk/%unk: .toFixed()>(%13)\n%16 = staticinvoke <@%unk/%unk: .Number()>(%15)\n%17 = %12 >= %16\n%18 = this.<@ts_files/44.ts: EventPipeline.maxScale>\n%19 = scale <= %18\n%20 = %17 && %19\nif %20 != false",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "%21 = 'does not need to do animation: ' + scale\ninstanceinvoke Log.<@%unk/%unk: .info()>(TAG, %21)\ninstanceinvoke this.<@ts_files/44.ts: EventPipeline.emitDirectionChange()>()\nreturn",
                      "start_line": 1,
                      "end_line": 599,
                      "successors": []
                    },
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "animationEndMatrix = null\n%22 = Constants.<@%unk/%unk: .RESERVED_DIGITS>\n%23 = instanceinvoke scale.<@%unk/%unk: .toFixed()>(%22)\n%24 = staticinvoke <@%unk/%unk: .Number()>(%23)\n%25 = Constants.<@%unk/%unk: .RESERVED_DIGITS>\n%26 = this.<@ts_files/44.ts: EventPipeline.defaultScale>\n%27 = instanceinvoke %26.<@%unk/%unk: .toFixed()>(%25)\n%28 = staticinvoke <@%unk/%unk: .Number()>(%27)\nif %24 <= %28",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "%29 = new @ts_files/44.ts: %AC$EventPipeline$onScaleEnd$3\ninstanceinvoke %29.<@ts_files/44.ts: %AC$EventPipeline$onScaleEnd$3.constructor()>()\nscaleOption = %29\n%30 = instanceinvoke Matrix4.<@%unk/%unk: .identity()>()\n%31 = instanceinvoke %30.<@%unk/%unk: .scale()>(scaleOption)\nanimationEndMatrix = instanceinvoke %31.<@%unk/%unk: .copy()>()",
                          "start_line": 1,
                          "end_line": 1,
                          "successors": [
                            {
                              "type": "block",
                              "name": "Block?",
                              "label": "%34 = <@ts_files/44.ts: Matrix4TransitWithMatrix4x4>animationEndMatrix\ninstanceinvoke this.<@ts_files/44.ts: EventPipeline.startAnimation(@ts_files/44.ts: Matrix4TransitWithMatrix4x4)>(%34)\nreturn",
                              "start_line": 1,
                              "end_line": 599,
                              "successors": []
                            }
                          ]
                        },
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "%32 = this.<@ts_files/44.ts: EventPipeline.maxScale>\n%33 = this.<@ts_files/44.ts: EventPipeline.center>\nanimationEndMatrix = instanceinvoke this.<@ts_files/44.ts: EventPipeline.evaluateAnimeMatrix(number, number[])>(%32, %33)",
                          "start_line": 1,
                          "end_line": 1,
                          "successors": [
                            {
                              "type": "blockRef",
                              "label": "(RepeatedBlock)"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "onScaleEnd(): void {\n    Log.info(TAG, 'onScaleEnd: ' + this.isInAnimation + ', ' + this.isExiting);\n    if (this.isInAnimation || this.isExiting) {\n      return;\n    }\n    this.evaluateBounds();\n    let scale = this.lastScale * this.scale;\n    if (Number(scale.toFixed(Constants.RESERVED_DIGITS)) >= Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS)) && scale <= this.maxScale) {\n      Log.info(TAG, 'does not need to do animation: ' + scale);\n      this.emitDirectionChange();\n      return;\n    }\n    let animationEndMatrix: Matrix4.Matrix4Transit = null;\n    if (Number(scale.toFixed(Constants.RESERVED_DIGITS)) <= Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) {\n      // Zoom out too small to trigger the restored animation\n      let scaleOption: Matrix4.ScaleOption = {\n        x: this.defaultScale,\n        y: this.defaultScale\n      };\n      animationEndMatrix = Matrix4.identity().scale(scaleOption).copy();\n    } else {\n      // Do the animation of retracting maxScale when zooming in\n      animationEndMatrix = this.evaluateAnimeMatrix(this.maxScale, this.center);\n    }\n    this.startAnimation(animationEndMatrix as Matrix4TransitWithMatrix4x4);\n  }"
        },
        {
          "type": "function",
          "name": "evaluateAnimeMatrix",
          "label": "evaluateAnimeMatrix",
          "start_line": 1,
          "end_line": 548,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "scale = parameter0: number\ncenter = parameter1: number[]\nthis = this: @ts_files/44.ts: EventPipeline\n%0 = this.<@ts_files/44.ts: EventPipeline.lastOffset>\n%1 = %0[0]\n%2 = this.<@ts_files/44.ts: EventPipeline.offset>\n%3 = %2[0]\n%4 = %1 + %3\n%5 = center[0]\n%6 = Constants.<@%unk/%unk: .CENTER_DEFAULT>\n%7 = %5 - %6\n%8 = this.<@ts_files/44.ts: EventPipeline.componentWidth>\n%9 = %7 * %8\n%10 = this.<@ts_files/44.ts: EventPipeline.defaultScale>\n%11 = this.<@ts_files/44.ts: EventPipeline.lastScale>\n%12 = scale / %11\n%13 = %10 - %12\n%14 = %9 * %13\n%15 = this.<@ts_files/44.ts: EventPipeline.lastScale>\n%16 = %14 * %15\n%17 = %4 + %16\n%18 = this.<@ts_files/44.ts: EventPipeline.lastOffset>\n%19 = %18[1]\n%20 = this.<@ts_files/44.ts: EventPipeline.offset>\n%21 = %20[1]\n%22 = %19 + %21\n%23 = center[1]\n%24 = Constants.<@%unk/%unk: .CENTER_DEFAULT>\n%25 = %23 - %24\n%26 = this.<@ts_files/44.ts: EventPipeline.componentHeight>\n%27 = %25 * %26\n%28 = this.<@ts_files/44.ts: EventPipeline.defaultScale>\n%29 = this.<@ts_files/44.ts: EventPipeline.lastScale>\n%30 = scale / %29\n%31 = %28 - %30\n%32 = %27 * %31\n%33 = this.<@ts_files/44.ts: EventPipeline.lastScale>\n%34 = %32 * %33\n%35 = %22 + %34\n%36 = newarray (unknown)[2]\n%36[0] = %17\n%36[1] = %35\noffset = %36\n%37 = Constants.<@%unk/%unk: .RESERVED_DIGITS>\n%38 = instanceinvoke scale.<@%unk/%unk: .toFixed()>(%37)\n%39 = staticinvoke <@%unk/%unk: .Number()>(%38)\n%40 = Constants.<@%unk/%unk: .RESERVED_DIGITS>\n%41 = this.<@ts_files/44.ts: EventPipeline.defaultScale>\n%42 = instanceinvoke %41.<@%unk/%unk: .toFixed()>(%40)\n%43 = staticinvoke <@%unk/%unk: .Number()>(%42)\nif %39 > %43",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "limits = instanceinvoke this.<@ts_files/44.ts: EventPipeline.evaluateOffsetRange(number)>(scale)\n%44 = offset[0]\n%45 = limits[0]\n%46 = limits[1]\n%47 = instanceinvoke MathUtils.<@%unk/%unk: .clamp()>(%44, %45, %46)\noffset[0] = %47\n%48 = Constants.<@%unk/%unk: .RESERVED_DIGITS>\n%49 = instanceinvoke scale.<@%unk/%unk: .toFixed()>(%48)\n%50 = staticinvoke <@%unk/%unk: .Number()>(%49)\n%51 = Constants.<@%unk/%unk: .RESERVED_DIGITS>\n%52 = this.<@ts_files/44.ts: EventPipeline.defaultScale>\n%53 = instanceinvoke %52.<@%unk/%unk: .toFixed()>(%51)\n%54 = staticinvoke <@%unk/%unk: .Number()>(%53)\nif %50 > %54",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "%55 = offset[1]\n%56 = Constants.<@%unk/%unk: .NUMBER_2>\n%57 = limits[%56]\n%58 = Constants.<@%unk/%unk: .NUMBER_3>\n%59 = limits[%58]\n%60 = instanceinvoke MathUtils.<@%unk/%unk: .clamp()>(%55, %57, %59)\noffset[1] = %60",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "%66 = new @ts_files/44.ts: %AC$EventPipeline$evaluateAnimeMatrix$4\ninstanceinvoke %66.<@ts_files/44.ts: %AC$EventPipeline$evaluateAnimeMatrix$4.constructor()>()\nscaleOption = %66\n%67 = new @ts_files/44.ts: %AC$EventPipeline$evaluateAnimeMatrix$5\ninstanceinvoke %67.<@ts_files/44.ts: %AC$EventPipeline$evaluateAnimeMatrix$5.constructor()>()\ntranslateOption = %67\n%68 = instanceinvoke Matrix4.<@%unk/%unk: .identity()>()\n%69 = instanceinvoke %68.<@%unk/%unk: .copy()>()\n%70 = instanceinvoke %69.<@%unk/%unk: .scale()>(scaleOption)\n%71 = instanceinvoke %70.<@%unk/%unk: .translate()>(translateOption)\nanimationEndMatrix = instanceinvoke %71.<@%unk/%unk: .copy()>()\n%72 = 'evaluateAnimeMatrix scale:' + scale\n%73 = %72 + ', center:'\n%74 = %73 + center\ninstanceinvoke Log.<@%unk/%unk: .debug()>(TAG, %74)\nreturn animationEndMatrix",
                          "start_line": 1,
                          "end_line": 585,
                          "successors": []
                        }
                      ]
                    },
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "%61 = Constants.<@%unk/%unk: .NUMBER_2>\n%62 = limits[%61]\n%63 = offset[1]\n%64 = instanceinvoke Math.<@%unk/%unk: .max()>(%62, %63)\noffset[1] = %64",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "blockRef",
                          "label": "(RepeatedBlock)"
                        }
                      ]
                    }
                  ]
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%65 = newarray (number)[2]\n%65[0] = 0\n%65[1] = 0\noffset = %65",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "blockRef",
                      "label": "(RepeatedBlock)"
                    }
                  ]
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "private evaluateAnimeMatrix(scale: number, center: number[]): Matrix4.Matrix4Transit {\n    let offset: number[] = [\n      this.lastOffset[0] + this.offset[0] + (center[0] - Constants.CENTER_DEFAULT) * this.componentWidth\n      * (this.defaultScale - scale / this.lastScale) * this.lastScale,\n      this.lastOffset[1] + this.offset[1] + (center[1] - Constants.CENTER_DEFAULT) * this.componentHeight\n      * (this.defaultScale - scale / this.lastScale) * this.lastScale\n    ];\n    if (Number(scale.toFixed(Constants.RESERVED_DIGITS)) > Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) {\n      let limits = this.evaluateOffsetRange(scale);\n      // The offset in the X direction is always limited for non shrinking scenes\n      offset[0] = MathUtils.clamp(offset[0], limits[0], limits[1]);\n      if (Number(scale.toFixed(Constants.RESERVED_DIGITS)) > Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) {\n        // Cannot drop down to return to the scene, limit y\n        offset[1] = MathUtils.clamp(offset[1], limits[Constants.NUMBER_2], limits[Constants.NUMBER_3]);\n      } else {\n        // You can pull down to return to the scene, and only limit y to drag upward,\n        // that is, limit the lower bound\n        offset[1] = Math.max(limits[Constants.NUMBER_2], offset[1]);\n      }\n    } else {\n      // When zooming in, adjust the zoom center to the display center point\n      offset = [0, 0];\n    }\n    let scaleOption: Matrix4.ScaleOption = {\n      x: scale,\n      y: scale,\n    };\n    let translateOption: Matrix4.TranslateOption = {\n      x: offset[0],\n      y: offset[1]\n    };\n    let animationEndMatrix = Matrix4.identity()\n      .copy()\n      .scale(scaleOption)\n      .translate(translateOption)\n      .copy();\n    Log.debug(TAG, 'evaluateAnimeMatrix scale:' + scale + ', center:' + center);\n    return animationEndMatrix;\n  }"
        },
        {
          "type": "function",
          "name": "onDoubleTap",
          "label": "onDoubleTap",
          "start_line": 1,
          "end_line": 596,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "centerX = parameter0: number\ncenterY = parameter1: number\nthis = this: @ts_files/44.ts: EventPipeline\n%0 = this.<@ts_files/44.ts: EventPipeline.isInAnimation>\n%1 = this.<@ts_files/44.ts: EventPipeline.isExiting>\n%2 = %0 || %1\nif %2 != false",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%3 = this.<@ts_files/44.ts: EventPipeline.isInAnimation>\n%4 = 'onDoubleTap not avaliable: ' + %3\n%5 = %4 + ', '\n%6 = this.<@ts_files/44.ts: EventPipeline.isExiting>\n%7 = %5 + %6\ninstanceinvoke Log.<@%unk/%unk: .debug()>(TAG, %7)\nreturn",
                  "start_line": 1,
                  "end_line": 599,
                  "successors": []
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%8 = Constants.<@%unk/%unk: .HIDE_BARS>\n%9 = newarray (any)[0]\n%10 = this.<@ts_files/44.ts: EventPipeline.broadCast>\ninstanceinvoke %10.<@%unk/%unk: .emit()>(%8, %9)\nmatrix = undefined\n%11 = this.<@ts_files/44.ts: EventPipeline.lastScale>\n%12 = 'onDoubleTap lastScale: ' + %11\n%13 = %12 + ', scale: '\n%14 = this.<@ts_files/44.ts: EventPipeline.scale>\n%15 = %13 + %14\n%16 = %15 + ', defaultScale: '\n%17 = this.<@ts_files/44.ts: EventPipeline.defaultScale>\n%18 = %16 + %17\ninstanceinvoke Log.<@%unk/%unk: .debug()>(TAG, %18)\n%19 = Constants.<@%unk/%unk: .RESERVED_DIGITS>\n%20 = this.<@ts_files/44.ts: EventPipeline.lastScale>\n%21 = instanceinvoke %20.<@%unk/%unk: .toFixed()>(%19)\n%22 = staticinvoke <@%unk/%unk: .Number()>(%21)\n%23 = this.<@ts_files/44.ts: EventPipeline.scale>\n%24 = %22 * %23\n%25 = Constants.<@%unk/%unk: .RESERVED_DIGITS>\n%26 = this.<@ts_files/44.ts: EventPipeline.defaultScale>\n%27 = instanceinvoke %26.<@%unk/%unk: .toFixed()>(%25)\n%28 = staticinvoke <@%unk/%unk: .Number()>(%27)\nif %24 > %28",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "%29 = new @ts_files/44.ts: %AC$EventPipeline$onDoubleTap$6\ninstanceinvoke %29.<@ts_files/44.ts: %AC$EventPipeline$onDoubleTap$6.constructor()>()\nscaleOption = %29\n%30 = instanceinvoke Matrix4.<@%unk/%unk: .identity()>()\n%31 = instanceinvoke %30.<@%unk/%unk: .scale()>(scaleOption)\n%32 = instanceinvoke %31.<@%unk/%unk: .copy()>()\nmatrix = <@ts_files/44.ts: Matrix4TransitWithMatrix4x4>%32",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "%49 = matrix.<@ts_files/44.ts: Matrix4TransitWithMatrix4x4.matrix4x4>\n%50 = 'onDoubleTap matrix: ' + %49\ninstanceinvoke Log.<@%unk/%unk: .debug()>(TAG, %50)\ninstanceinvoke this.<@ts_files/44.ts: EventPipeline.startAnimation(@ts_files/44.ts: Matrix4TransitWithMatrix4x4)>(matrix)\nreturn",
                          "start_line": 1,
                          "end_line": 599,
                          "successors": []
                        }
                      ]
                    },
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "center = instanceinvoke this.<@ts_files/44.ts: EventPipeline.evaluateCenter(number, number)>(centerX, centerY)\n%33 = this.<@ts_files/44.ts: EventPipeline.width>\n%34 = this.<@ts_files/44.ts: EventPipeline.height>\n%35 = %33 / %34\n%36 = this.<@ts_files/44.ts: EventPipeline.componentWidth>\n%37 = this.<@ts_files/44.ts: EventPipeline.componentHeight>\n%38 = %36 / %37\nif %35 < %38",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "%39 = Constants.<@%unk/%unk: .CENTER_DEFAULT>\n%40 = center[1]\n%41 = newarray (unknown)[2]\n%41[0] = %39\n%41[1] = %40\ncenter = %41",
                          "start_line": 1,
                          "end_line": 1,
                          "successors": [
                            {
                              "type": "block",
                              "name": "Block?",
                              "label": "%45 = this.<@ts_files/44.ts: EventPipeline.doubleTapScale>\n%46 = this.<@ts_files/44.ts: EventPipeline.defaultScale>\n%47 = %45 * %46\n%48 = instanceinvoke this.<@ts_files/44.ts: EventPipeline.evaluateAnimeMatrix(number, number[])>(%47, center)\nmatrix = <@ts_files/44.ts: Matrix4TransitWithMatrix4x4>%48",
                              "start_line": 1,
                              "end_line": 1,
                              "successors": [
                                {
                                  "type": "blockRef",
                                  "label": "(RepeatedBlock)"
                                }
                              ]
                            }
                          ]
                        },
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "%42 = center[0]\n%43 = Constants.<@%unk/%unk: .CENTER_DEFAULT>\n%44 = newarray (unknown)[2]\n%44[0] = %42\n%44[1] = %43\ncenter = %44",
                          "start_line": 1,
                          "end_line": 1,
                          "successors": [
                            {
                              "type": "blockRef",
                              "label": "(RepeatedBlock)"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "onDoubleTap(centerX: number, centerY: number): void {\n    if (this.isInAnimation || this.isExiting) {\n      Log.debug(TAG, 'onDoubleTap not avaliable: ' + this.isInAnimation + ', ' + this.isExiting);\n      return;\n    }\n    // Adjust action bar status\n    this.broadCast.emit(Constants.HIDE_BARS, []);\n    let matrix: Matrix4TransitWithMatrix4x4;\n    Log.debug(TAG, 'onDoubleTap lastScale: ' + this.lastScale + ', scale: ' + this.scale + ', defaultScale: ' + this.defaultScale);\n    if (Number(this.lastScale.toFixed(Constants.RESERVED_DIGITS)) * this.scale > Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) {\n      // Scale to original state when scale is greater than 1\n      let scaleOption: Matrix4.ScaleOption = {\n        x: this.defaultScale,\n        y: this.defaultScale\n      };\n      matrix = Matrix4.identity().scale(scaleOption).copy() as Matrix4TransitWithMatrix4x4;\n    } else {\n      // The zoom in status calculates the zoom in center according to the click position\n      let center = this.evaluateCenter(centerX, centerY);\n      // When the picture aspect ratio is less than the control aspect ratio,\n      // centerX is set to 0.5,\n      // whereas centerY is set to 0.5 to ensure that\n      // the short side is close to the side after double clicking and enlarging\n      if (this.width / this.height < this.componentWidth / this.componentHeight) {\n        center = [Constants.CENTER_DEFAULT, center[1]];\n      } else {\n        center = [center[0], Constants.CENTER_DEFAULT];\n      }\n      matrix = this.evaluateAnimeMatrix(this.doubleTapScale * this.defaultScale, center) as Matrix4TransitWithMatrix4x4;\n    }\n    Log.debug(TAG, 'onDoubleTap matrix: ' + matrix.matrix4x4);\n    this.startAnimation(matrix);\n  }"
        },
        {
          "type": "function",
          "name": "reset",
          "label": "reset",
          "start_line": 1,
          "end_line": 630,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/44.ts: EventPipeline\n%0 = newarray (number)[2]\n%0[0] = 0\n%0[1] = 0\nthis.<@ts_files/44.ts: EventPipeline.lastOffset> = %0\n%1 = newarray (number)[2]\n%1[0] = 0\n%1[1] = 0\nthis.<@ts_files/44.ts: EventPipeline.offset> = %1\nthis.<@ts_files/44.ts: EventPipeline.lastScale> = 1\nthis.<@ts_files/44.ts: EventPipeline.scale> = 1\nthis.<@ts_files/44.ts: EventPipeline.hasReachLeft> = true\nthis.<@ts_files/44.ts: EventPipeline.hasReachRight> = true\nthis.<@ts_files/44.ts: EventPipeline.hasReachTop> = true\nthis.<@ts_files/44.ts: EventPipeline.hasReachBottom> = true\nthis.<@ts_files/44.ts: EventPipeline.isInAnimation> = false\nthis.<@ts_files/44.ts: EventPipeline.isExiting> = false\ninstanceinvoke this.<@ts_files/44.ts: EventPipeline.emitDirectionChange()>()\nreturn",
              "start_line": 1,
              "end_line": 599,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "reset(): void {\n    this.lastOffset = [0, 0];\n    this.offset = [0, 0];\n    this.lastScale = 1.0;\n    this.scale = 1;\n    this.hasReachLeft = true;\n    this.hasReachRight = true;\n    this.hasReachTop = true;\n    this.hasReachBottom = true;\n    this.isInAnimation = false;\n    this.isExiting = false;\n    this.emitDirectionChange();\n  }"
        },
        {
          "type": "function",
          "name": "onDisAppear",
          "label": "onDisAppear",
          "start_line": 1,
          "end_line": 644,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/44.ts: EventPipeline\ninstanceinvoke Log.<@%unk/%unk: .info()>(TAG, 'onDisAppear')\nreturn",
              "start_line": 1,
              "end_line": 599,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "onDisAppear(): void {\n    Log.info(TAG, 'onDisAppear');\n  }"
        },
        {
          "type": "function",
          "name": "startAnimation",
          "label": "startAnimation",
          "start_line": 1,
          "end_line": 648,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "animationEndMatrix = parameter0: @ts_files/44.ts: Matrix4TransitWithMatrix4x4\nthis = this: @ts_files/44.ts: EventPipeline\nthis.<@ts_files/44.ts: EventPipeline.isInAnimation> = true\n%0 = new @ts_files/44.ts: %AC$EventPipeline$startAnimation$7\ninstanceinvoke %0.<@ts_files/44.ts: %AC$EventPipeline$startAnimation$7.constructor()>()\nanimationOption = %0\n%1 = animationEndMatrix.<@ts_files/44.ts: Matrix4TransitWithMatrix4x4.matrix4x4>\n%2 = 'animationEndMatrix: ' + %1\ninstanceinvoke Log.<@%unk/%unk: .debug()>(TAG, %2)\n%3 = Constants.<@%unk/%unk: .ANIMATION_EVENT>\n%4 = this.<@ts_files/44.ts: EventPipeline.item>\n%5 = %4.<@%unk/%unk: .uri>\n%6 = %3 + %5\n%7 = this.<@ts_files/44.ts: EventPipeline.timeStamp>\n%8 = %6 + %7\n%9 = newarray (@ts_files/44.ts: AnimationOption|@ts_files/44.ts: Matrix4TransitWithMatrix4x4)[2]\n%9[0] = animationOption\n%9[1] = animationEndMatrix\n%10 = this.<@ts_files/44.ts: EventPipeline.broadCast>\ninstanceinvoke %10.<@%unk/%unk: .emit()>(%8, %9)\nreturn",
              "start_line": 1,
              "end_line": 599,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "private startAnimation(animationEndMatrix: Matrix4TransitWithMatrix4x4): void {\n    this.isInAnimation = true;\n    let animationOption: AnimationOption = {\n      duration: Constants.OVER_SCALE_ANIME_DURATION,\n      curve: Curve.Ease\n    };\n    Log.debug(TAG, 'animationEndMatrix: ' + animationEndMatrix.matrix4x4);\n    this.broadCast.emit(Constants.ANIMATION_EVENT + this.item.uri + this.timeStamp, [animationOption, animationEndMatrix]);\n  }"
        },
        {
          "type": "function",
          "name": "onAnimationEnd",
          "label": "onAnimationEnd",
          "start_line": 1,
          "end_line": 665,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "animationEndMatrix = parameter0: @ts_files/44.ts: Matrix4TransitWithMatrix4x4\nthis = this: @ts_files/44.ts: EventPipeline\nif animationEndMatrix != null",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%0 = animationEndMatrix.<@ts_files/44.ts: Matrix4TransitWithMatrix4x4.matrix4x4>\n%1 = 'onAnimationEnd: ' + %0\ninstanceinvoke Log.<@%unk/%unk: .info()>(TAG, %1)\n%2 = animationEndMatrix.<@ts_files/44.ts: Matrix4TransitWithMatrix4x4.matrix4x4>\n%3 = %2[0]\nthis.<@ts_files/44.ts: EventPipeline.lastScale> = %3\nthis.<@ts_files/44.ts: EventPipeline.scale> = 1\n%4 = animationEndMatrix.<@ts_files/44.ts: Matrix4TransitWithMatrix4x4.matrix4x4>\n%5 = Constants.<@%unk/%unk: .NUMBER_12>\n%6 = %4[%5]\n%7 = animationEndMatrix.<@ts_files/44.ts: Matrix4TransitWithMatrix4x4.matrix4x4>\n%8 = Constants.<@%unk/%unk: .NUMBER_13>\n%9 = %7[%8]\n%10 = newarray (unknown)[2]\n%10[0] = %6\n%10[1] = %9\nthis.<@ts_files/44.ts: EventPipeline.lastOffset> = %10\n%11 = newarray (number)[2]\n%11[0] = 0\n%11[1] = 0\nthis.<@ts_files/44.ts: EventPipeline.offset> = %11\ninstanceinvoke this.<@ts_files/44.ts: EventPipeline.evaluateBounds()>()\nthis.<@ts_files/44.ts: EventPipeline.isInAnimation> = false\ninstanceinvoke this.<@ts_files/44.ts: EventPipeline.emitDirectionChange()>()",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "return",
                      "start_line": 104,
                      "end_line": 599,
                      "successors": []
                    }
                  ]
                },
                {
                  "type": "blockRef",
                  "label": "(RepeatedBlock)"
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "onAnimationEnd(animationEndMatrix: Matrix4TransitWithMatrix4x4): void {\n    if (animationEndMatrix != null) {\n      Log.info(TAG, 'onAnimationEnd: ' + animationEndMatrix.matrix4x4);\n      this.lastScale = animationEndMatrix.matrix4x4[0];\n      this.scale = 1;\n      this.lastOffset = [animationEndMatrix.matrix4x4[Constants.NUMBER_12], animationEndMatrix.matrix4x4[Constants.NUMBER_13]];\n      this.offset = [0, 0];\n      this.evaluateBounds();\n      this.isInAnimation = false;\n      this.emitDirectionChange();\n    }\n  }"
        }
      ],
      "classes": [],
      "blocks": [],
      "simplified_code": "export class EventPipeline {\n\n  // last offset\n  private lastOffset: number[] = [0, 0];\n\n  // offset\n  private offset: number[] = [0, 0];\n\n  // default scale\n  private defaultScale = 1.0;\n\n  // last scale\n  private lastScale = 1.0;\n\n  // scale\n  private scale = 1.0;\n\n  // the zoom center point is a percentage position relative to the control, not an absolute position\n  private center: number[] = [Constants.CENTER_DEFAULT, Constants.CENTER_DEFAULT];\n\n  // leftmost zoom Center，(1 - leftMost)is rightmost zoom Center\n  private leftMost = 0.0;\n\n  // top zoom center，(1 - topMost)is bottom zoom center\n  private topMost = 0.0;\n\n  // double tap scale\n  private doubleTapScale = 1.0;\n\n  // max scale\n  private maxScale = 1.0;\n\n  // has reached the far left\n  private hasReachLeft = true;\n\n  // has reached the far right\n  private hasReachRight = true;\n\n  // has reached the far top\n  private hasReachTop = true;\n\n  // has reached the far bottom\n  private hasReachBottom = true;\n\n  // Broadcast\n  private broadCast: Broadcast;\n\n  // item\n  private item: UserFileDataItem;\n\n  // timeStamp\n  private timeStamp: string;\n\n  // width\n  private width: number;\n\n  // height\n  private height: number;\n\n  // Large display control width\n  private componentWidth: number = vp2px(screenManager.getWinWidth());\n\n  // Large display control height\n  private componentHeight = vp2px(screenManager.getWinHeight());\n\n  // is now in animation\n  private isInAnimation = false;\n\n  // pull down to return flag to prevent multiple triggers\n  private isExiting = false;\n\n  private updateMatrix: Function;\n\n  constructor(broadCastParam: Broadcast, item: UserFileDataItem, timeStamp: string, updateMatrix: Function) {\n    this.broadCast = broadCastParam;\n    this.item = item;\n    this.timeStamp = timeStamp;\n    this.updateMatrix = updateMatrix;\n    this.width = this.item.imgWidth === 0 ? MediaConstants.DEFAULT_SIZE : this.item.imgWidth;\n    this.height = this.item.imgHeight === 0 ? MediaConstants.DEFAULT_SIZE : this.item.imgHeight;\n    this.evaluateScales();\n  }\n\n  onDataChanged(item: UserFileDataItem): void {\n    this.item = item;\n    this.width = this.item.imgWidth === 0 ? MediaConstants.DEFAULT_SIZE : this.item.imgWidth;\n    this.height = this.item.imgHeight === 0 ? MediaConstants.DEFAULT_SIZE : this.item.imgHeight;\n    this.evaluateScales();\n  }\n\n  setDefaultScale(scale): void {\n    this.defaultScale = scale;\n    this.lastScale = scale;\n  }\n\n  onComponentSizeChanged(): void {\n    this.evaluateScales();\n  }\n\n  onTouch(event: TouchEvent): void {\n    Log.debug(TAG, 'onTouch trigger: ' + event.type + ', ' + this.isInAnimation + ', ' + this.isExiting);\n    if (this.isInAnimation || this.isExiting) {\n      return;\n    }\n    if (event.type === TouchType.Down || event.type === TouchType.Up) {\n      this.emitDirectionChange();\n    }\n\n    if (event.type === TouchType.Up) {\n      this.lastOffset = this.evaluateOffset();\n      this.lastScale = this.lastScale * this.scale;\n      this.scale = 1;\n      this.offset = [0, 0];\n    }\n  }\n\n  private emitDirectionChange(): void {\n\n    /**\n     * reachLeft reachRight scale>1，only five possible situations（when scale<=1,reachLeft、reachRight is true）：\n     * T T T：Vertical\n     * T T F：Vertical（initial state）\n     * T F T：Vertical | Left\n     * F T T：Vertical | Right\n     * F F T：All\n     */\n    let direction;\n    let scale = this.lastScale * this.scale;\n    let isEnlarged = Number(scale.toFixed(Constants.RESERVED_DIGITS)) > Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS));\n    if (!this.hasReachLeft && !this.hasReachRight && isEnlarged) {\n      direction = PanDirection.All;\n    } else if (!this.hasReachLeft && this.hasReachRight && isEnlarged) {\n      direction = (PanDirection.Vertical as number) | (PanDirection.Right as number);\n    } else if (this.hasReachLeft && !this.hasReachRight && isEnlarged) {\n      direction = (PanDirection.Vertical as number) | (PanDirection.Left as number);\n    } else {\n      direction = PanDirection.Vertical;\n    }\n\n    Log.info(TAG, 'emitDirectionChange reaches: ' + this.hasReachLeft + ', ' + this.hasReachRight + ', ' + this.hasReachTop + ', ' + this.hasReachBottom +\n    ', scale ' + scale + ', direction: ' + direction);\n    if (this.isExiting) {\n      return;\n    }\n\n    if (direction === (PanDirection.Vertical as number) || direction === ((PanDirection.Vertical as number) | (PanDirection.Left as number)) ||\n    direction === ((PanDirection.Vertical as number) | (PanDirection.Right as number))) {\n      this.broadCast.emit(Constants.SET_DISABLE_SWIPE, [false]);\n    } else {\n      this.broadCast.emit(Constants.SET_DISABLE_SWIPE, [true]);\n    }\n    this.broadCast.emit(Constants.DIRECTION_CHANGE + this.item.uri + this.timeStamp, [direction]);\n  }\n\n  private evaluateOffset(): number[] {\n    Log.info(TAG, 'evaluateOffset lastOffset: ' + this.lastOffset + ', offset: ' + this.offset);\n    let centerX = (this.center[0] - Constants.CENTER_DEFAULT) * this.componentWidth * (this.defaultScale - this.scale) * this.lastScale;\n    let centerY = (this.center[1] - Constants.CENTER_DEFAULT) * this.componentHeight * (this.defaultScale - this.scale) * this.lastScale;\n    let offsetX = this.lastOffset[0] + this.offset[0] + centerX;\n    let offsetY = this.lastOffset[1] + this.offset[1] + centerY;\n    Log.debug(TAG, 'evaluateOffset offsetX: ' + offsetX + ', offsetY: ' + offsetY);\n    return [offsetX, offsetY];\n  }\n\n  private emitTouchEvent(): void {\n    let offset: number[];\n    let scale = this.lastScale * this.scale;\n    if (Number(scale.toFixed(Constants.RESERVED_DIGITS)) > Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) {\n      let limits = this.evaluateOffsetRange(scale);\n      offset = this.evaluateOffset();\n      // the offset in the X direction is always limited for non shrinking scenes\n      offset[0] = MathUtils.clamp(offset[0], limits[0], limits[1]);\n      if (Number(scale.toFixed(Constants.RESERVED_DIGITS)) > Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) {\n        // cannot pull down to return, limit y\n        offset[1] = MathUtils.clamp(offset[1], limits[2], limits[3]);\n      } else {\n        // can pull down to return to the scene, and only limit y to drag upward, limit the lower bound\n        offset[1] = Math.max(limits[2], offset[1]);\n      }\n    } else {\n      // When zooming in, adjust the zoom center to the display center point\n      offset = [0, 0];\n    }\n    let moveX = offset[0];\n    let moveY = offset[1];\n    Log.debug(TAG, 'emitTouchEvent moveX: ' + moveX + ', moveY: ' + moveY);\n    let scaleOption: Matrix4.ScaleOption = {\n      x: scale,\n      y: scale,\n    };\n    let translateOption: Matrix4.TranslateOption = {\n      x: moveX,\n      y: moveY\n    };\n    let matrix = Matrix4.identity()\n      .scale(scaleOption)\n      .translate(translateOption)\n      .copy();\n    Log.debug(TAG, 'emitTouchEvent lastOffset: ' + this.lastOffset + ', offset: ' + this.offset +\n    ',center: ' + this.center + ', scale: ' + this.lastScale + ', ' + this.scale);\n    this.updateMatrix(matrix);\n    this.evaluateBounds();\n  }\n\n  private evaluateScales(): void {\n    if (this.width * this.componentHeight < this.componentWidth * this.height) {\n      // The aspect ratio is less than the display aspect ratio of the control\n      // the height of the control is equal to the height of the picture\n      this.maxScale = this.height / this.componentHeight;\n      // Double click the enlarged scale to ensure that the left and right boundaries are filled\n      this.doubleTapScale = this.componentWidth * this.height / this.width / this.componentHeight;\n      // leftMost = (1 - dspW / compW) / 2 = (1 - compH * imgW / imgH / compW) / 2\n      this.leftMost = (1 - this.componentHeight * this.width / this.height / this.componentWidth) / Constants.NUMBER_2;\n      this.topMost = 0.0;\n    } else if (this.width * this.componentHeight === this.componentWidth * this.height) {\n      // The aspect ratio is equal to the display aspect ratio of the control\n      this.doubleTapScale = Constants.SAME_RATIO_SCALE_FACTOR;\n      this.maxScale = this.doubleTapScale * Constants.MAX_SCALE_EXTRA_FACTOR;\n      this.leftMost = 0;\n      this.topMost = 0;\n    } else {\n      // The aspect ratio is greater than the display aspect ratio of the control\n      // the width of the control is equal to the width of the picture\n      this.maxScale = this.width / this.componentWidth;\n      // Double click the enlarged scale to ensure that the top and bottom fill the boundary\n      this.doubleTapScale = this.componentHeight * this.width / this.height / this.componentWidth;\n      this.leftMost = 0.0;\n      this.topMost = (1 - this.componentWidth * this.height / this.width / this.componentHeight) / Constants.NUMBER_2;\n    }\n\n    this.maxScale = Math.max(this.maxScale, Constants.COMPONENT_SCALE_CEIL);\n    if (this.doubleTapScale > this.maxScale) {\n      this.maxScale = this.doubleTapScale * Constants.MAX_SCALE_EXTRA_FACTOR;\n    }\n    Log.debug(TAG, 'evaluateScales: ' + this.width + '*' + this.height + ' &' +\n    this.componentWidth + '*' + this.componentHeight +\n    ',max: ' + this.maxScale + ', most: [' + this.leftMost + ',' + this.topMost + '], double: ' + this.doubleTapScale);\n  }\n\n  private evaluateCompBounds(): number[] {\n    let scale = this.lastScale * this.scale;\n    let offset = this.evaluateOffset();\n    let result: number[] = [\n      offset[0] - this.componentWidth * (Number(scale.toFixed(Constants.RESERVED_DIGITS)) - Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) / Constants.NUMBER_2,\n      offset[1] - this.componentHeight * (Number(scale.toFixed(Constants.RESERVED_DIGITS)) - Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) / Constants.NUMBER_2\n    ];\n    Log.debug(TAG, 'evaluateCompBounds: ' + result);\n    return result;\n  }\n\n  private evaluateImgDisplaySize(): number[] {\n    let screenScale = 1;\n    let widthScale = this.componentWidth / this.item.imgWidth;\n    let heightScale = this.componentHeight / this.item.imgHeight;\n    screenScale = widthScale > heightScale ? heightScale : widthScale;\n    let scale = this.lastScale * this.scale * screenScale;\n    let imgDisplayWidth = 0;\n    let imgDisplayHeight = 0;\n    imgDisplayWidth = this.width * scale;\n    imgDisplayHeight = this.height * scale;\n    return [imgDisplayWidth, imgDisplayHeight];\n  }\n\n  private evaluateImgDisplayBounds(): number[] {\n    // For the left boundary of the component,\n    // the offset caused by amplification is - compw * (scale-1) / 2,\n    // plus the offset of the gesture to obtain the left boundary of the control.\n    // The same is true for the upper boundary\n    let scale = this.lastScale * this.scale;\n    let leftTop = this.evaluateCompBounds();\n    let imgDisplaySize: number[] = this.evaluateImgDisplaySize();\n    let imgDisplayWidth = imgDisplaySize[0];\n    let imgDisplayHeight = imgDisplaySize[1];\n    let imgLeftBound = 0;\n    let imgTopBound = 0;\n    if (this.width / this.height > this.componentWidth / this.componentHeight) {\n      imgLeftBound = leftTop[0];\n      imgTopBound = leftTop[1] + (this.componentHeight * scale - imgDisplayHeight) / Constants.NUMBER_2;\n    } else {\n      // Control width minus the picture width, divided by 2,\n      // you can get the distance from the left of the picture to the left of the control.\n      // Plus offsetX is the left boundary of the picture currently displayed\n      imgLeftBound = (this.componentWidth * scale - imgDisplayWidth) / Constants.NUMBER_2 + leftTop[0];\n      imgTopBound = leftTop[1];\n    }\n    return [imgLeftBound, imgTopBound];\n  }\n\n  // Calculate picture display boundary\n  private evaluateBounds(): void {\n    let imgDisplaySize: number[] = this.evaluateImgDisplaySize();\n    let imgDisplayWidth = imgDisplaySize[0];\n\n    let imgDisplayBounds = this.evaluateImgDisplayBounds();\n    let imgLeftBound = imgDisplayBounds[0];\n    this.hasReachLeft = imgLeftBound > -1;\n    this.hasReachRight = imgLeftBound + imgDisplayWidth < this.componentWidth + 1;\n  }\n\n  /**\n   * Calculate the upper and lower bounds of offset in X and Y directions under the current scale\n   *\n   * @param scale The display magnification of the current control, usually this.lastScale * this.scale\n   * @returns 0&1 X-direction offset lower & upper bound, 2&3 Y-direction offset lower & upper bound\n   */\n  private evaluateOffsetRange(scale: number): number[] {\n    let result: number[] = [0, 0, 0, 0];\n    let screenScale = 1;\n    let widthScale = this.componentWidth / this.item.imgWidth;\n    let heightScale = this.componentHeight / this.item.imgHeight;\n    screenScale = widthScale > heightScale ? heightScale : widthScale;\n    let left = (screenScale * scale * this.width - this.componentWidth) / Constants.NUMBER_2;\n    let top = (screenScale * scale * this.height - this.componentHeight) / Constants.NUMBER_2;\n    top = Math.max(top, 0);\n    left = Math.max(left, 0);\n    result = [-left, left, -top, top];\n    Log.debug(TAG, 'evaluateOffsetRange scale: ' + scale + ', defaultScale: ' + this.defaultScale + ', result: ' + result);\n    return result;\n  }\n\n  private emitPullDownToBackEvent(): void {\n    Log.debug(TAG, 'emitPullDownToBackEvent');\n    if (this.isExiting) {\n      Log.info(TAG, 'emitPullDownToBack isExiting: ' + this.isExiting);\n      return;\n    }\n    this.broadCast.emit(Constants.PULL_DOWN_END, []);\n    this.isExiting = true;\n  }\n\n  private emitPullDownCancelEvent(): void {\n    Log.debug(TAG, 'emitPullDownCancelEvent');\n    this.broadCast.emit(Constants.PULL_DOWN_CANCEL, []);\n  }\n\n  onMoveStart(offsetX: number, offsetY: number): void {\n    if (this.isInAnimation || this.isExiting) {\n      return;\n    }\n    // Reset offset at the beginning of dragging to prevent jumping\n    this.offset = [0, 0];\n    this.evaluateBounds();\n    let scale = this.lastScale * this.scale;\n    if (Number(scale.toFixed(Constants.RESERVED_DIGITS)) > Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) {\n      // Hide bars with zoom drag\n      this.broadCast.emit(Constants.HIDE_BARS, []);\n    }\n    if (scale.toFixed(Constants.RESERVED_DIGITS) === this.defaultScale.toFixed(Constants.RESERVED_DIGITS) && offsetY > 0) {\n      // Drop down return to hide details first\n      this.broadCast.emit(Constants.PULL_DOWN_START, []);\n    }\n  }\n\n  /**\n   * Each callback returns the displacement relative to the start point of the gesture\n   *\n   * @param offsetX offsetX\n   * @param offsetY offsetY\n   */\n  onMove(offsetX: number, offsetY: number): void {\n    if (this.isInAnimation || this.isExiting) {\n      return;\n    }\n    let scale = this.lastScale * this.scale;\n    let limits = this.evaluateOffsetRange(scale);\n    let measureX = this.lastOffset[0] + (this.center[0] - Constants.CENTER_DEFAULT) * this.componentWidth\n    * (this.defaultScale - this.scale) * this.lastScale;\n    let measureY = this.lastOffset[1] + (this.center[1] - Constants.CENTER_DEFAULT) * this.componentHeight\n    * (this.defaultScale - this.scale) * this.lastScale;\n    let moveX = offsetX;\n    let moveY = offsetY;\n    let offX = measureX + moveX;\n    let offY = measureY + moveY;\n    if (Number(scale.toFixed(Constants.RESERVED_DIGITS)) > Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) {\n      // The offset in the X direction is always limited for non shrinking scenes\n      offX = MathUtils.clamp(offX, limits[0], limits[1]);\n      if (Number(scale.toFixed(Constants.RESERVED_DIGITS)) > Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) {\n        // cannot drop down to return to the scene, limit y\n        offY = MathUtils.clamp(offY, limits[Constants.NUMBER_2], limits[Constants.NUMBER_3]);\n      } else {\n        // pull down to return to the scene, and only limit y to drag upward, that is, limit the lower bound\n        offY = Math.max(limits[Constants.NUMBER_2], offY);\n      }\n    }\n    let tmpX = offX - measureX;\n    let tmpY = offY - measureY;\n    this.offset = [tmpX, tmpY];\n    this.emitTouchEvent();\n  }\n\n  onMoveEnd(offsetX, offsetY): void {\n    if (this.isInAnimation || this.isExiting) {\n      return;\n    }\n    let scale = this.lastScale * this.scale;\n    Log.debug(TAG, 'onMoveEnd: scale is ' + scale + ' offsetY is ' + offsetY);\n    if (scale.toFixed(Constants.RESERVED_DIGITS) === this.defaultScale.toFixed(Constants.RESERVED_DIGITS) && offsetY > Constants.PULL_DOWN_THRESHOLD) {\n      this.emitPullDownToBackEvent();\n    } else if (scale.toFixed(Constants.RESERVED_DIGITS) === this.defaultScale.toFixed(Constants.RESERVED_DIGITS)) {\n      // The reset animation is triggered when the threshold is not reached\n      let scaleOption: Matrix4.ScaleOption = {\n        x: this.defaultScale,\n        y: this.defaultScale\n      };\n      this.startAnimation(Matrix4.identity().scale(scaleOption).copy() as Matrix4TransitWithMatrix4x4);\n      this.emitPullDownCancelEvent();\n    } else {\n      this.emitDirectionChange();\n    }\n  }\n\n  onScaleStart(scale: number, centerX: number, centerY: number): void {\n    Log.info(TAG, 'onScaleStart: ' + this.isInAnimation + ', ' + this.isExiting);\n    if (this.isInAnimation || this.isExiting) {\n      return;\n    }\n    this.scale = 1;\n    this.evaluateBounds();\n    // Adjust action bar status\n    this.broadCast.emit(Constants.HIDE_BARS, []);\n    this.center = this.evaluateCenter(centerX, centerY);\n  }\n\n  /**\n   * Calculates the percentage position of the current zoom center relative to the control\n   *\n   * @param centerX The absolute position of the touch point on the screen\n   * @param centerY The absolute position of the touch point on the screen\n   * @returns The percentage position of the current zoom center relative to the control\n   */\n  private evaluateCenter(centerX: number, centerY: number): number[] {\n    // Calculate the coordinates of the upper left corner of the control relative to\n    // the upper left corner of the current display\n    let scale = this.lastScale * this.scale;\n    let leftTop = this.evaluateCompBounds();\n\n    // Get the touch coordinates relative to the control\n    let cxRelativeToComp = MathUtils.clamp((centerX - leftTop[0])\n    / (this.componentWidth * scale), this.leftMost, 1 - this.leftMost);\n    let cyRelativeToComp = MathUtils.clamp((centerY - leftTop[1])\n    / (this.componentHeight * scale), this.topMost, 1 - this.topMost);\n\n    let imgDisplaySize: number[] = this.evaluateImgDisplaySize();\n    let imgDisplayWidth = imgDisplaySize[0];\n    let imgDisplayHeight = imgDisplaySize[1];\n\n    let imgDisplayBounds = this.evaluateImgDisplayBounds();\n    let imgLeftBound = imgDisplayBounds[0];\n    let imgTopBound = imgDisplayBounds[1];\n\n    // When the touch center point is outside the picture display area, take the midpoint\n    if (this.width / this.height > this.componentWidth / this.componentHeight) {\n      if (centerY < imgTopBound || centerY > imgTopBound + imgDisplayHeight) {\n        cyRelativeToComp = Constants.CENTER_DEFAULT;\n      }\n    } else {\n      if (centerX < imgLeftBound || centerX > imgLeftBound + imgDisplayWidth) {\n        cxRelativeToComp = Constants.CENTER_DEFAULT;\n      }\n    }\n\n    // Calculate the percentage of the center point of the touch\n    let center: number[] = [cxRelativeToComp, cyRelativeToComp];\n    Log.debug(TAG, 'evaluateCenter center: ' + center + ', ' + centerX + ',' + centerY +\n    ',size: ' + imgDisplaySize + ', bounds: ' + imgDisplayBounds + ', leftTop: ' + leftTop +\n    ',compSize: ' + this.componentWidth * scale + ',' + this.componentHeight * scale);\n    return center;\n  }\n\n  onScale(scale: number): void {\n    Log.debug(TAG, 'onScale: ' + this.isInAnimation + ', ' + this.isExiting + ', scale: ' + scale);\n    if (this.isInAnimation || this.isExiting) {\n      return;\n    }\n    this.evaluateBounds();\n    this.scale = scale;\n    if (this.lastScale * scale <= Constants.COMPONENT_SCALE_FLOOR) {\n      this.scale = Constants.COMPONENT_SCALE_FLOOR / this.lastScale;\n    }\n    if (this.lastScale * scale >= this.maxScale * Constants.OVER_SCALE_EXTRA_FACTOR) {\n      this.scale = this.maxScale * Constants.OVER_SCALE_EXTRA_FACTOR / this.lastScale;\n    }\n    this.emitTouchEvent();\n  }\n\n  onScaleEnd(): void {\n    Log.info(TAG, 'onScaleEnd: ' + this.isInAnimation + ', ' + this.isExiting);\n    if (this.isInAnimation || this.isExiting) {\n      return;\n    }\n    this.evaluateBounds();\n    let scale = this.lastScale * this.scale;\n    if (Number(scale.toFixed(Constants.RESERVED_DIGITS)) >= Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS)) && scale <= this.maxScale) {\n      Log.info(TAG, 'does not need to do animation: ' + scale);\n      this.emitDirectionChange();\n      return;\n    }\n    let animationEndMatrix: Matrix4.Matrix4Transit = null;\n    if (Number(scale.toFixed(Constants.RESERVED_DIGITS)) <= Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) {\n      // Zoom out too small to trigger the restored animation\n      let scaleOption: Matrix4.ScaleOption = {\n        x: this.defaultScale,\n        y: this.defaultScale\n      };\n      animationEndMatrix = Matrix4.identity().scale(scaleOption).copy();\n    } else {\n      // Do the animation of retracting maxScale when zooming in\n      animationEndMatrix = this.evaluateAnimeMatrix(this.maxScale, this.center);\n    }\n    this.startAnimation(animationEndMatrix as Matrix4TransitWithMatrix4x4);\n  }\n\n  private evaluateAnimeMatrix(scale: number, center: number[]): Matrix4.Matrix4Transit {\n    let offset: number[] = [\n      this.lastOffset[0] + this.offset[0] + (center[0] - Constants.CENTER_DEFAULT) * this.componentWidth\n      * (this.defaultScale - scale / this.lastScale) * this.lastScale,\n      this.lastOffset[1] + this.offset[1] + (center[1] - Constants.CENTER_DEFAULT) * this.componentHeight\n      * (this.defaultScale - scale / this.lastScale) * this.lastScale\n    ];\n    if (Number(scale.toFixed(Constants.RESERVED_DIGITS)) > Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) {\n      let limits = this.evaluateOffsetRange(scale);\n      // The offset in the X direction is always limited for non shrinking scenes\n      offset[0] = MathUtils.clamp(offset[0], limits[0], limits[1]);\n      if (Number(scale.toFixed(Constants.RESERVED_DIGITS)) > Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) {\n        // Cannot drop down to return to the scene, limit y\n        offset[1] = MathUtils.clamp(offset[1], limits[Constants.NUMBER_2], limits[Constants.NUMBER_3]);\n      } else {\n        // You can pull down to return to the scene, and only limit y to drag upward,\n        // that is, limit the lower bound\n        offset[1] = Math.max(limits[Constants.NUMBER_2], offset[1]);\n      }\n    } else {\n      // When zooming in, adjust the zoom center to the display center point\n      offset = [0, 0];\n    }\n    let scaleOption: Matrix4.ScaleOption = {\n      x: scale,\n      y: scale,\n    };\n    let translateOption: Matrix4.TranslateOption = {\n      x: offset[0],\n      y: offset[1]\n    };\n    let animationEndMatrix = Matrix4.identity()\n      .copy()\n      .scale(scaleOption)\n      .translate(translateOption)\n      .copy();\n    Log.debug(TAG, 'evaluateAnimeMatrix scale:' + scale + ', center:' + center);\n    return animationEndMatrix;\n  }\n\n  /**\n   * Double click to trigger zoom.\n   * If the current scale is less than or equal to 1, zoom to doubleTapScale;\n   * If the current scale is greater than 1, scale to 1;\n   *\n   * @param centerX the location of double click\n   * @param centerY the location of double click\n   */\n  onDoubleTap(centerX: number, centerY: number): void {\n    if (this.isInAnimation || this.isExiting) {\n      Log.debug(TAG, 'onDoubleTap not avaliable: ' + this.isInAnimation + ', ' + this.isExiting);\n      return;\n    }\n    // Adjust action bar status\n    this.broadCast.emit(Constants.HIDE_BARS, []);\n    let matrix: Matrix4TransitWithMatrix4x4;\n    Log.debug(TAG, 'onDoubleTap lastScale: ' + this.lastScale + ', scale: ' + this.scale + ', defaultScale: ' + this.defaultScale);\n    if (Number(this.lastScale.toFixed(Constants.RESERVED_DIGITS)) * this.scale > Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) {\n      // Scale to original state when scale is greater than 1\n      let scaleOption: Matrix4.ScaleOption = {\n        x: this.defaultScale,\n        y: this.defaultScale\n      };\n      matrix = Matrix4.identity().scale(scaleOption).copy() as Matrix4TransitWithMatrix4x4;\n    } else {\n      // The zoom in status calculates the zoom in center according to the click position\n      let center = this.evaluateCenter(centerX, centerY);\n      // When the picture aspect ratio is less than the control aspect ratio,\n      // centerX is set to 0.5,\n      // whereas centerY is set to 0.5 to ensure that\n      // the short side is close to the side after double clicking and enlarging\n      if (this.width / this.height < this.componentWidth / this.componentHeight) {\n        center = [Constants.CENTER_DEFAULT, center[1]];\n      } else {\n        center = [center[0], Constants.CENTER_DEFAULT];\n      }\n      matrix = this.evaluateAnimeMatrix(this.doubleTapScale * this.defaultScale, center) as Matrix4TransitWithMatrix4x4;\n    }\n    Log.debug(TAG, 'onDoubleTap matrix: ' + matrix.matrix4x4);\n    this.startAnimation(matrix);\n  }\n\n  reset(): void {\n    this.lastOffset = [0, 0];\n    this.offset = [0, 0];\n    this.lastScale = 1.0;\n    this.scale = 1;\n    this.hasReachLeft = true;\n    this.hasReachRight = true;\n    this.hasReachTop = true;\n    this.hasReachBottom = true;\n    this.isInAnimation = false;\n    this.isExiting = false;\n    this.emitDirectionChange();\n  }\n\n  onDisAppear(): void {\n    Log.info(TAG, 'onDisAppear');\n  }\n\n  private startAnimation(animationEndMatrix: Matrix4TransitWithMatrix4x4): void {\n    this.isInAnimation = true;\n    let animationOption: AnimationOption = {\n      duration: Constants.OVER_SCALE_ANIME_DURATION,\n      curve: Curve.Ease\n    };\n    Log.debug(TAG, 'animationEndMatrix: ' + animationEndMatrix.matrix4x4);\n    this.broadCast.emit(Constants.ANIMATION_EVENT + this.item.uri + this.timeStamp, [animationOption, animationEndMatrix]);\n  }\n\n  /**\n   * At the end of the animation,\n   * refresh the current parameter values according to the end transformation matrix to ensure continuity and\n   * prevent jumping during the next gesture operation\n   *\n   * @param animationEndMatrix Transformation matrix at end\n   */\n  onAnimationEnd(animationEndMatrix: Matrix4TransitWithMatrix4x4): void {\n    if (animationEndMatrix != null) {\n      Log.info(TAG, 'onAnimationEnd: ' + animationEndMatrix.matrix4x4);\n      this.lastScale = animationEndMatrix.matrix4x4[0];\n      this.scale = 1;\n      this.lastOffset = [animationEndMatrix.matrix4x4[Constants.NUMBER_12], animationEndMatrix.matrix4x4[Constants.NUMBER_13]];\n      this.offset = [0, 0];\n      this.evaluateBounds();\n      this.isInAnimation = false;\n      this.emitDirectionChange();\n    }\n  }\n}"
    },
    {
      "type": "class",
      "name": "%AC$EventPipeline$emitTouchEvent$0",
      "label": "%AC$EventPipeline$emitTouchEvent$0",
      "start_line": 222,
      "end_line": 222,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n      x: scale,\n      y: scale,\n    }"
    },
    {
      "type": "class",
      "name": "%AC$EventPipeline$emitTouchEvent$1",
      "label": "%AC$EventPipeline$emitTouchEvent$1",
      "start_line": 226,
      "end_line": 226,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n      x: moveX,\n      y: moveY\n    }"
    },
    {
      "type": "class",
      "name": "%AC$EventPipeline$onMoveEnd$2",
      "label": "%AC$EventPipeline$onMoveEnd$2",
      "start_line": 436,
      "end_line": 436,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n        x: this.defaultScale,\n        y: this.defaultScale\n      }"
    },
    {
      "type": "class",
      "name": "%AC$EventPipeline$onScaleEnd$3",
      "label": "%AC$EventPipeline$onScaleEnd$3",
      "start_line": 536,
      "end_line": 536,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n        x: this.defaultScale,\n        y: this.defaultScale\n      }"
    },
    {
      "type": "class",
      "name": "%AC$EventPipeline$evaluateAnimeMatrix$4",
      "label": "%AC$EventPipeline$evaluateAnimeMatrix$4",
      "start_line": 571,
      "end_line": 571,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n      x: scale,\n      y: scale,\n    }"
    },
    {
      "type": "class",
      "name": "%AC$EventPipeline$evaluateAnimeMatrix$5",
      "label": "%AC$EventPipeline$evaluateAnimeMatrix$5",
      "start_line": 575,
      "end_line": 575,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n      x: offset[0],\n      y: offset[1]\n    }"
    },
    {
      "type": "class",
      "name": "%AC$EventPipeline$onDoubleTap$6",
      "label": "%AC$EventPipeline$onDoubleTap$6",
      "start_line": 607,
      "end_line": 607,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n        x: this.defaultScale,\n        y: this.defaultScale\n      }"
    },
    {
      "type": "class",
      "name": "%AC$EventPipeline$startAnimation$7",
      "label": "%AC$EventPipeline$startAnimation$7",
      "start_line": 650,
      "end_line": 650,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n      duration: Constants.OVER_SCALE_ANIME_DURATION,\n      curve: Curve.Ease\n    }"
    }
  ],
  "functions": [],
  "blocks": [],
  "simplified_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Matrix4 from '@ohos.matrix4';\nimport { UserFileDataItem } from '../base/UserFileDataItem';\nimport { Log } from '../utils/Log';\nimport { Broadcast } from './Broadcast';\nimport { MathUtils } from '../utils/MathUtils';\nimport { Constants } from '../constants/BrowserConstants';\nimport { screenManager } from './ScreenManager';\nimport { MediaConstants } from '../constants/MediaConstants';\n\nconst TAG = 'EventPipeline'\n\nexport interface Matrix4TransitWithMatrix4x4 extends Matrix4.Matrix4Transit {\n  matrix4x4: number[];\n}\n\nexport interface AnimationOption {\n  duration: number,\n  curve: Curve\n}\n\nexport class EventPipeline {\n\n  // last offset\n  private lastOffset: number[] = [0, 0];\n\n  // offset\n  private offset: number[] = [0, 0];\n\n  // default scale\n  private defaultScale = 1.0;\n\n  // last scale\n  private lastScale = 1.0;\n\n  // scale\n  private scale = 1.0;\n\n  // the zoom center point is a percentage position relative to the control, not an absolute position\n  private center: number[] = [Constants.CENTER_DEFAULT, Constants.CENTER_DEFAULT];\n\n  // leftmost zoom Center，(1 - leftMost)is rightmost zoom Center\n  private leftMost = 0.0;\n\n  // top zoom center，(1 - topMost)is bottom zoom center\n  private topMost = 0.0;\n\n  // double tap scale\n  private doubleTapScale = 1.0;\n\n  // max scale\n  private maxScale = 1.0;\n\n  // has reached the far left\n  private hasReachLeft = true;\n\n  // has reached the far right\n  private hasReachRight = true;\n\n  // has reached the far top\n  private hasReachTop = true;\n\n  // has reached the far bottom\n  private hasReachBottom = true;\n\n  // Broadcast\n  private broadCast: Broadcast;\n\n  // item\n  private item: UserFileDataItem;\n\n  // timeStamp\n  private timeStamp: string;\n\n  // width\n  private width: number;\n\n  // height\n  private height: number;\n\n  // Large display control width\n  private componentWidth: number = vp2px(screenManager.getWinWidth());\n\n  // Large display control height\n  private componentHeight = vp2px(screenManager.getWinHeight());\n\n  // is now in animation\n  private isInAnimation = false;\n\n  // pull down to return flag to prevent multiple triggers\n  private isExiting = false;\n\n  private updateMatrix: Function;\n\n  constructor(broadCastParam: Broadcast, item: UserFileDataItem, timeStamp: string, updateMatrix: Function) {\n    this.broadCast = broadCastParam;\n    this.item = item;\n    this.timeStamp = timeStamp;\n    this.updateMatrix = updateMatrix;\n    this.width = this.item.imgWidth === 0 ? MediaConstants.DEFAULT_SIZE : this.item.imgWidth;\n    this.height = this.item.imgHeight === 0 ? MediaConstants.DEFAULT_SIZE : this.item.imgHeight;\n    this.evaluateScales();\n  }\n\n  onDataChanged(item: UserFileDataItem): void {\n    this.item = item;\n    this.width = this.item.imgWidth === 0 ? MediaConstants.DEFAULT_SIZE : this.item.imgWidth;\n    this.height = this.item.imgHeight === 0 ? MediaConstants.DEFAULT_SIZE : this.item.imgHeight;\n    this.evaluateScales();\n  }\n\n  setDefaultScale(scale): void {\n    this.defaultScale = scale;\n    this.lastScale = scale;\n  }\n\n  onComponentSizeChanged(): void {\n    this.evaluateScales();\n  }\n\n  onTouch(event: TouchEvent): void {\n    Log.debug(TAG, 'onTouch trigger: ' + event.type + ', ' + this.isInAnimation + ', ' + this.isExiting);\n    if (this.isInAnimation || this.isExiting) {\n      return;\n    }\n    if (event.type === TouchType.Down || event.type === TouchType.Up) {\n      this.emitDirectionChange();\n    }\n\n    if (event.type === TouchType.Up) {\n      this.lastOffset = this.evaluateOffset();\n      this.lastScale = this.lastScale * this.scale;\n      this.scale = 1;\n      this.offset = [0, 0];\n    }\n  }\n\n  private emitDirectionChange(): void {\n\n    /**\n     * reachLeft reachRight scale>1，only five possible situations（when scale<=1,reachLeft、reachRight is true）：\n     * T T T：Vertical\n     * T T F：Vertical（initial state）\n     * T F T：Vertical | Left\n     * F T T：Vertical | Right\n     * F F T：All\n     */\n    let direction;\n    let scale = this.lastScale * this.scale;\n    let isEnlarged = Number(scale.toFixed(Constants.RESERVED_DIGITS)) > Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS));\n    if (!this.hasReachLeft && !this.hasReachRight && isEnlarged) {\n      direction = PanDirection.All;\n    } else if (!this.hasReachLeft && this.hasReachRight && isEnlarged) {\n      direction = (PanDirection.Vertical as number) | (PanDirection.Right as number);\n    } else if (this.hasReachLeft && !this.hasReachRight && isEnlarged) {\n      direction = (PanDirection.Vertical as number) | (PanDirection.Left as number);\n    } else {\n      direction = PanDirection.Vertical;\n    }\n\n    Log.info(TAG, 'emitDirectionChange reaches: ' + this.hasReachLeft + ', ' + this.hasReachRight + ', ' + this.hasReachTop + ', ' + this.hasReachBottom +\n    ', scale ' + scale + ', direction: ' + direction);\n    if (this.isExiting) {\n      return;\n    }\n\n    if (direction === (PanDirection.Vertical as number) || direction === ((PanDirection.Vertical as number) | (PanDirection.Left as number)) ||\n    direction === ((PanDirection.Vertical as number) | (PanDirection.Right as number))) {\n      this.broadCast.emit(Constants.SET_DISABLE_SWIPE, [false]);\n    } else {\n      this.broadCast.emit(Constants.SET_DISABLE_SWIPE, [true]);\n    }\n    this.broadCast.emit(Constants.DIRECTION_CHANGE + this.item.uri + this.timeStamp, [direction]);\n  }\n\n  private evaluateOffset(): number[] {\n    Log.info(TAG, 'evaluateOffset lastOffset: ' + this.lastOffset + ', offset: ' + this.offset);\n    let centerX = (this.center[0] - Constants.CENTER_DEFAULT) * this.componentWidth * (this.defaultScale - this.scale) * this.lastScale;\n    let centerY = (this.center[1] - Constants.CENTER_DEFAULT) * this.componentHeight * (this.defaultScale - this.scale) * this.lastScale;\n    let offsetX = this.lastOffset[0] + this.offset[0] + centerX;\n    let offsetY = this.lastOffset[1] + this.offset[1] + centerY;\n    Log.debug(TAG, 'evaluateOffset offsetX: ' + offsetX + ', offsetY: ' + offsetY);\n    return [offsetX, offsetY];\n  }\n\n  private emitTouchEvent(): void {\n    let offset: number[];\n    let scale = this.lastScale * this.scale;\n    if (Number(scale.toFixed(Constants.RESERVED_DIGITS)) > Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) {\n      let limits = this.evaluateOffsetRange(scale);\n      offset = this.evaluateOffset();\n      // the offset in the X direction is always limited for non shrinking scenes\n      offset[0] = MathUtils.clamp(offset[0], limits[0], limits[1]);\n      if (Number(scale.toFixed(Constants.RESERVED_DIGITS)) > Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) {\n        // cannot pull down to return, limit y\n        offset[1] = MathUtils.clamp(offset[1], limits[2], limits[3]);\n      } else {\n        // can pull down to return to the scene, and only limit y to drag upward, limit the lower bound\n        offset[1] = Math.max(limits[2], offset[1]);\n      }\n    } else {\n      // When zooming in, adjust the zoom center to the display center point\n      offset = [0, 0];\n    }\n    let moveX = offset[0];\n    let moveY = offset[1];\n    Log.debug(TAG, 'emitTouchEvent moveX: ' + moveX + ', moveY: ' + moveY);\n    let scaleOption: Matrix4.ScaleOption = {\n      x: scale,\n      y: scale,\n    };\n    let translateOption: Matrix4.TranslateOption = {\n      x: moveX,\n      y: moveY\n    };\n    let matrix = Matrix4.identity()\n      .scale(scaleOption)\n      .translate(translateOption)\n      .copy();\n    Log.debug(TAG, 'emitTouchEvent lastOffset: ' + this.lastOffset + ', offset: ' + this.offset +\n    ',center: ' + this.center + ', scale: ' + this.lastScale + ', ' + this.scale);\n    this.updateMatrix(matrix);\n    this.evaluateBounds();\n  }\n\n  private evaluateScales(): void {\n    if (this.width * this.componentHeight < this.componentWidth * this.height) {\n      // The aspect ratio is less than the display aspect ratio of the control\n      // the height of the control is equal to the height of the picture\n      this.maxScale = this.height / this.componentHeight;\n      // Double click the enlarged scale to ensure that the left and right boundaries are filled\n      this.doubleTapScale = this.componentWidth * this.height / this.width / this.componentHeight;\n      // leftMost = (1 - dspW / compW) / 2 = (1 - compH * imgW / imgH / compW) / 2\n      this.leftMost = (1 - this.componentHeight * this.width / this.height / this.componentWidth) / Constants.NUMBER_2;\n      this.topMost = 0.0;\n    } else if (this.width * this.componentHeight === this.componentWidth * this.height) {\n      // The aspect ratio is equal to the display aspect ratio of the control\n      this.doubleTapScale = Constants.SAME_RATIO_SCALE_FACTOR;\n      this.maxScale = this.doubleTapScale * Constants.MAX_SCALE_EXTRA_FACTOR;\n      this.leftMost = 0;\n      this.topMost = 0;\n    } else {\n      // The aspect ratio is greater than the display aspect ratio of the control\n      // the width of the control is equal to the width of the picture\n      this.maxScale = this.width / this.componentWidth;\n      // Double click the enlarged scale to ensure that the top and bottom fill the boundary\n      this.doubleTapScale = this.componentHeight * this.width / this.height / this.componentWidth;\n      this.leftMost = 0.0;\n      this.topMost = (1 - this.componentWidth * this.height / this.width / this.componentHeight) / Constants.NUMBER_2;\n    }\n\n    this.maxScale = Math.max(this.maxScale, Constants.COMPONENT_SCALE_CEIL);\n    if (this.doubleTapScale > this.maxScale) {\n      this.maxScale = this.doubleTapScale * Constants.MAX_SCALE_EXTRA_FACTOR;\n    }\n    Log.debug(TAG, 'evaluateScales: ' + this.width + '*' + this.height + ' &' +\n    this.componentWidth + '*' + this.componentHeight +\n    ',max: ' + this.maxScale + ', most: [' + this.leftMost + ',' + this.topMost + '], double: ' + this.doubleTapScale);\n  }\n\n  private evaluateCompBounds(): number[] {\n    let scale = this.lastScale * this.scale;\n    let offset = this.evaluateOffset();\n    let result: number[] = [\n      offset[0] - this.componentWidth * (Number(scale.toFixed(Constants.RESERVED_DIGITS)) - Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) / Constants.NUMBER_2,\n      offset[1] - this.componentHeight * (Number(scale.toFixed(Constants.RESERVED_DIGITS)) - Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) / Constants.NUMBER_2\n    ];\n    Log.debug(TAG, 'evaluateCompBounds: ' + result);\n    return result;\n  }\n\n  private evaluateImgDisplaySize(): number[] {\n    let screenScale = 1;\n    let widthScale = this.componentWidth / this.item.imgWidth;\n    let heightScale = this.componentHeight / this.item.imgHeight;\n    screenScale = widthScale > heightScale ? heightScale : widthScale;\n    let scale = this.lastScale * this.scale * screenScale;\n    let imgDisplayWidth = 0;\n    let imgDisplayHeight = 0;\n    imgDisplayWidth = this.width * scale;\n    imgDisplayHeight = this.height * scale;\n    return [imgDisplayWidth, imgDisplayHeight];\n  }\n\n  private evaluateImgDisplayBounds(): number[] {\n    // For the left boundary of the component,\n    // the offset caused by amplification is - compw * (scale-1) / 2,\n    // plus the offset of the gesture to obtain the left boundary of the control.\n    // The same is true for the upper boundary\n    let scale = this.lastScale * this.scale;\n    let leftTop = this.evaluateCompBounds();\n    let imgDisplaySize: number[] = this.evaluateImgDisplaySize();\n    let imgDisplayWidth = imgDisplaySize[0];\n    let imgDisplayHeight = imgDisplaySize[1];\n    let imgLeftBound = 0;\n    let imgTopBound = 0;\n    if (this.width / this.height > this.componentWidth / this.componentHeight) {\n      imgLeftBound = leftTop[0];\n      imgTopBound = leftTop[1] + (this.componentHeight * scale - imgDisplayHeight) / Constants.NUMBER_2;\n    } else {\n      // Control width minus the picture width, divided by 2,\n      // you can get the distance from the left of the picture to the left of the control.\n      // Plus offsetX is the left boundary of the picture currently displayed\n      imgLeftBound = (this.componentWidth * scale - imgDisplayWidth) / Constants.NUMBER_2 + leftTop[0];\n      imgTopBound = leftTop[1];\n    }\n    return [imgLeftBound, imgTopBound];\n  }\n\n  // Calculate picture display boundary\n  private evaluateBounds(): void {\n    let imgDisplaySize: number[] = this.evaluateImgDisplaySize();\n    let imgDisplayWidth = imgDisplaySize[0];\n\n    let imgDisplayBounds = this.evaluateImgDisplayBounds();\n    let imgLeftBound = imgDisplayBounds[0];\n    this.hasReachLeft = imgLeftBound > -1;\n    this.hasReachRight = imgLeftBound + imgDisplayWidth < this.componentWidth + 1;\n  }\n\n  /**\n   * Calculate the upper and lower bounds of offset in X and Y directions under the current scale\n   *\n   * @param scale The display magnification of the current control, usually this.lastScale * this.scale\n   * @returns 0&1 X-direction offset lower & upper bound, 2&3 Y-direction offset lower & upper bound\n   */\n  private evaluateOffsetRange(scale: number): number[] {\n    let result: number[] = [0, 0, 0, 0];\n    let screenScale = 1;\n    let widthScale = this.componentWidth / this.item.imgWidth;\n    let heightScale = this.componentHeight / this.item.imgHeight;\n    screenScale = widthScale > heightScale ? heightScale : widthScale;\n    let left = (screenScale * scale * this.width - this.componentWidth) / Constants.NUMBER_2;\n    let top = (screenScale * scale * this.height - this.componentHeight) / Constants.NUMBER_2;\n    top = Math.max(top, 0);\n    left = Math.max(left, 0);\n    result = [-left, left, -top, top];\n    Log.debug(TAG, 'evaluateOffsetRange scale: ' + scale + ', defaultScale: ' + this.defaultScale + ', result: ' + result);\n    return result;\n  }\n\n  private emitPullDownToBackEvent(): void {\n    Log.debug(TAG, 'emitPullDownToBackEvent');\n    if (this.isExiting) {\n      Log.info(TAG, 'emitPullDownToBack isExiting: ' + this.isExiting);\n      return;\n    }\n    this.broadCast.emit(Constants.PULL_DOWN_END, []);\n    this.isExiting = true;\n  }\n\n  private emitPullDownCancelEvent(): void {\n    Log.debug(TAG, 'emitPullDownCancelEvent');\n    this.broadCast.emit(Constants.PULL_DOWN_CANCEL, []);\n  }\n\n  onMoveStart(offsetX: number, offsetY: number): void {\n    if (this.isInAnimation || this.isExiting) {\n      return;\n    }\n    // Reset offset at the beginning of dragging to prevent jumping\n    this.offset = [0, 0];\n    this.evaluateBounds();\n    let scale = this.lastScale * this.scale;\n    if (Number(scale.toFixed(Constants.RESERVED_DIGITS)) > Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) {\n      // Hide bars with zoom drag\n      this.broadCast.emit(Constants.HIDE_BARS, []);\n    }\n    if (scale.toFixed(Constants.RESERVED_DIGITS) === this.defaultScale.toFixed(Constants.RESERVED_DIGITS) && offsetY > 0) {\n      // Drop down return to hide details first\n      this.broadCast.emit(Constants.PULL_DOWN_START, []);\n    }\n  }\n\n  /**\n   * Each callback returns the displacement relative to the start point of the gesture\n   *\n   * @param offsetX offsetX\n   * @param offsetY offsetY\n   */\n  onMove(offsetX: number, offsetY: number): void {\n    if (this.isInAnimation || this.isExiting) {\n      return;\n    }\n    let scale = this.lastScale * this.scale;\n    let limits = this.evaluateOffsetRange(scale);\n    let measureX = this.lastOffset[0] + (this.center[0] - Constants.CENTER_DEFAULT) * this.componentWidth\n    * (this.defaultScale - this.scale) * this.lastScale;\n    let measureY = this.lastOffset[1] + (this.center[1] - Constants.CENTER_DEFAULT) * this.componentHeight\n    * (this.defaultScale - this.scale) * this.lastScale;\n    let moveX = offsetX;\n    let moveY = offsetY;\n    let offX = measureX + moveX;\n    let offY = measureY + moveY;\n    if (Number(scale.toFixed(Constants.RESERVED_DIGITS)) > Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) {\n      // The offset in the X direction is always limited for non shrinking scenes\n      offX = MathUtils.clamp(offX, limits[0], limits[1]);\n      if (Number(scale.toFixed(Constants.RESERVED_DIGITS)) > Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) {\n        // cannot drop down to return to the scene, limit y\n        offY = MathUtils.clamp(offY, limits[Constants.NUMBER_2], limits[Constants.NUMBER_3]);\n      } else {\n        // pull down to return to the scene, and only limit y to drag upward, that is, limit the lower bound\n        offY = Math.max(limits[Constants.NUMBER_2], offY);\n      }\n    }\n    let tmpX = offX - measureX;\n    let tmpY = offY - measureY;\n    this.offset = [tmpX, tmpY];\n    this.emitTouchEvent();\n  }\n\n  onMoveEnd(offsetX, offsetY): void {\n    if (this.isInAnimation || this.isExiting) {\n      return;\n    }\n    let scale = this.lastScale * this.scale;\n    Log.debug(TAG, 'onMoveEnd: scale is ' + scale + ' offsetY is ' + offsetY);\n    if (scale.toFixed(Constants.RESERVED_DIGITS) === this.defaultScale.toFixed(Constants.RESERVED_DIGITS) && offsetY > Constants.PULL_DOWN_THRESHOLD) {\n      this.emitPullDownToBackEvent();\n    } else if (scale.toFixed(Constants.RESERVED_DIGITS) === this.defaultScale.toFixed(Constants.RESERVED_DIGITS)) {\n      // The reset animation is triggered when the threshold is not reached\n      let scaleOption: Matrix4.ScaleOption = {\n        x: this.defaultScale,\n        y: this.defaultScale\n      };\n      this.startAnimation(Matrix4.identity().scale(scaleOption).copy() as Matrix4TransitWithMatrix4x4);\n      this.emitPullDownCancelEvent();\n    } else {\n      this.emitDirectionChange();\n    }\n  }\n\n  onScaleStart(scale: number, centerX: number, centerY: number): void {\n    Log.info(TAG, 'onScaleStart: ' + this.isInAnimation + ', ' + this.isExiting);\n    if (this.isInAnimation || this.isExiting) {\n      return;\n    }\n    this.scale = 1;\n    this.evaluateBounds();\n    // Adjust action bar status\n    this.broadCast.emit(Constants.HIDE_BARS, []);\n    this.center = this.evaluateCenter(centerX, centerY);\n  }\n\n  /**\n   * Calculates the percentage position of the current zoom center relative to the control\n   *\n   * @param centerX The absolute position of the touch point on the screen\n   * @param centerY The absolute position of the touch point on the screen\n   * @returns The percentage position of the current zoom center relative to the control\n   */\n  private evaluateCenter(centerX: number, centerY: number): number[] {\n    // Calculate the coordinates of the upper left corner of the control relative to\n    // the upper left corner of the current display\n    let scale = this.lastScale * this.scale;\n    let leftTop = this.evaluateCompBounds();\n\n    // Get the touch coordinates relative to the control\n    let cxRelativeToComp = MathUtils.clamp((centerX - leftTop[0])\n    / (this.componentWidth * scale), this.leftMost, 1 - this.leftMost);\n    let cyRelativeToComp = MathUtils.clamp((centerY - leftTop[1])\n    / (this.componentHeight * scale), this.topMost, 1 - this.topMost);\n\n    let imgDisplaySize: number[] = this.evaluateImgDisplaySize();\n    let imgDisplayWidth = imgDisplaySize[0];\n    let imgDisplayHeight = imgDisplaySize[1];\n\n    let imgDisplayBounds = this.evaluateImgDisplayBounds();\n    let imgLeftBound = imgDisplayBounds[0];\n    let imgTopBound = imgDisplayBounds[1];\n\n    // When the touch center point is outside the picture display area, take the midpoint\n    if (this.width / this.height > this.componentWidth / this.componentHeight) {\n      if (centerY < imgTopBound || centerY > imgTopBound + imgDisplayHeight) {\n        cyRelativeToComp = Constants.CENTER_DEFAULT;\n      }\n    } else {\n      if (centerX < imgLeftBound || centerX > imgLeftBound + imgDisplayWidth) {\n        cxRelativeToComp = Constants.CENTER_DEFAULT;\n      }\n    }\n\n    // Calculate the percentage of the center point of the touch\n    let center: number[] = [cxRelativeToComp, cyRelativeToComp];\n    Log.debug(TAG, 'evaluateCenter center: ' + center + ', ' + centerX + ',' + centerY +\n    ',size: ' + imgDisplaySize + ', bounds: ' + imgDisplayBounds + ', leftTop: ' + leftTop +\n    ',compSize: ' + this.componentWidth * scale + ',' + this.componentHeight * scale);\n    return center;\n  }\n\n  onScale(scale: number): void {\n    Log.debug(TAG, 'onScale: ' + this.isInAnimation + ', ' + this.isExiting + ', scale: ' + scale);\n    if (this.isInAnimation || this.isExiting) {\n      return;\n    }\n    this.evaluateBounds();\n    this.scale = scale;\n    if (this.lastScale * scale <= Constants.COMPONENT_SCALE_FLOOR) {\n      this.scale = Constants.COMPONENT_SCALE_FLOOR / this.lastScale;\n    }\n    if (this.lastScale * scale >= this.maxScale * Constants.OVER_SCALE_EXTRA_FACTOR) {\n      this.scale = this.maxScale * Constants.OVER_SCALE_EXTRA_FACTOR / this.lastScale;\n    }\n    this.emitTouchEvent();\n  }\n\n  onScaleEnd(): void {\n    Log.info(TAG, 'onScaleEnd: ' + this.isInAnimation + ', ' + this.isExiting);\n    if (this.isInAnimation || this.isExiting) {\n      return;\n    }\n    this.evaluateBounds();\n    let scale = this.lastScale * this.scale;\n    if (Number(scale.toFixed(Constants.RESERVED_DIGITS)) >= Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS)) && scale <= this.maxScale) {\n      Log.info(TAG, 'does not need to do animation: ' + scale);\n      this.emitDirectionChange();\n      return;\n    }\n    let animationEndMatrix: Matrix4.Matrix4Transit = null;\n    if (Number(scale.toFixed(Constants.RESERVED_DIGITS)) <= Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) {\n      // Zoom out too small to trigger the restored animation\n      let scaleOption: Matrix4.ScaleOption = {\n        x: this.defaultScale,\n        y: this.defaultScale\n      };\n      animationEndMatrix = Matrix4.identity().scale(scaleOption).copy();\n    } else {\n      // Do the animation of retracting maxScale when zooming in\n      animationEndMatrix = this.evaluateAnimeMatrix(this.maxScale, this.center);\n    }\n    this.startAnimation(animationEndMatrix as Matrix4TransitWithMatrix4x4);\n  }\n\n  private evaluateAnimeMatrix(scale: number, center: number[]): Matrix4.Matrix4Transit {\n    let offset: number[] = [\n      this.lastOffset[0] + this.offset[0] + (center[0] - Constants.CENTER_DEFAULT) * this.componentWidth\n      * (this.defaultScale - scale / this.lastScale) * this.lastScale,\n      this.lastOffset[1] + this.offset[1] + (center[1] - Constants.CENTER_DEFAULT) * this.componentHeight\n      * (this.defaultScale - scale / this.lastScale) * this.lastScale\n    ];\n    if (Number(scale.toFixed(Constants.RESERVED_DIGITS)) > Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) {\n      let limits = this.evaluateOffsetRange(scale);\n      // The offset in the X direction is always limited for non shrinking scenes\n      offset[0] = MathUtils.clamp(offset[0], limits[0], limits[1]);\n      if (Number(scale.toFixed(Constants.RESERVED_DIGITS)) > Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) {\n        // Cannot drop down to return to the scene, limit y\n        offset[1] = MathUtils.clamp(offset[1], limits[Constants.NUMBER_2], limits[Constants.NUMBER_3]);\n      } else {\n        // You can pull down to return to the scene, and only limit y to drag upward,\n        // that is, limit the lower bound\n        offset[1] = Math.max(limits[Constants.NUMBER_2], offset[1]);\n      }\n    } else {\n      // When zooming in, adjust the zoom center to the display center point\n      offset = [0, 0];\n    }\n    let scaleOption: Matrix4.ScaleOption = {\n      x: scale,\n      y: scale,\n    };\n    let translateOption: Matrix4.TranslateOption = {\n      x: offset[0],\n      y: offset[1]\n    };\n    let animationEndMatrix = Matrix4.identity()\n      .copy()\n      .scale(scaleOption)\n      .translate(translateOption)\n      .copy();\n    Log.debug(TAG, 'evaluateAnimeMatrix scale:' + scale + ', center:' + center);\n    return animationEndMatrix;\n  }\n\n  /**\n   * Double click to trigger zoom.\n   * If the current scale is less than or equal to 1, zoom to doubleTapScale;\n   * If the current scale is greater than 1, scale to 1;\n   *\n   * @param centerX the location of double click\n   * @param centerY the location of double click\n   */\n  onDoubleTap(centerX: number, centerY: number): void {\n    if (this.isInAnimation || this.isExiting) {\n      Log.debug(TAG, 'onDoubleTap not avaliable: ' + this.isInAnimation + ', ' + this.isExiting);\n      return;\n    }\n    // Adjust action bar status\n    this.broadCast.emit(Constants.HIDE_BARS, []);\n    let matrix: Matrix4TransitWithMatrix4x4;\n    Log.debug(TAG, 'onDoubleTap lastScale: ' + this.lastScale + ', scale: ' + this.scale + ', defaultScale: ' + this.defaultScale);\n    if (Number(this.lastScale.toFixed(Constants.RESERVED_DIGITS)) * this.scale > Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) {\n      // Scale to original state when scale is greater than 1\n      let scaleOption: Matrix4.ScaleOption = {\n        x: this.defaultScale,\n        y: this.defaultScale\n      };\n      matrix = Matrix4.identity().scale(scaleOption).copy() as Matrix4TransitWithMatrix4x4;\n    } else {\n      // The zoom in status calculates the zoom in center according to the click position\n      let center = this.evaluateCenter(centerX, centerY);\n      // When the picture aspect ratio is less than the control aspect ratio,\n      // centerX is set to 0.5,\n      // whereas centerY is set to 0.5 to ensure that\n      // the short side is close to the side after double clicking and enlarging\n      if (this.width / this.height < this.componentWidth / this.componentHeight) {\n        center = [Constants.CENTER_DEFAULT, center[1]];\n      } else {\n        center = [center[0], Constants.CENTER_DEFAULT];\n      }\n      matrix = this.evaluateAnimeMatrix(this.doubleTapScale * this.defaultScale, center) as Matrix4TransitWithMatrix4x4;\n    }\n    Log.debug(TAG, 'onDoubleTap matrix: ' + matrix.matrix4x4);\n    this.startAnimation(matrix);\n  }\n\n  reset(): void {\n    this.lastOffset = [0, 0];\n    this.offset = [0, 0];\n    this.lastScale = 1.0;\n    this.scale = 1;\n    this.hasReachLeft = true;\n    this.hasReachRight = true;\n    this.hasReachTop = true;\n    this.hasReachBottom = true;\n    this.isInAnimation = false;\n    this.isExiting = false;\n    this.emitDirectionChange();\n  }\n\n  onDisAppear(): void {\n    Log.info(TAG, 'onDisAppear');\n  }\n\n  private startAnimation(animationEndMatrix: Matrix4TransitWithMatrix4x4): void {\n    this.isInAnimation = true;\n    let animationOption: AnimationOption = {\n      duration: Constants.OVER_SCALE_ANIME_DURATION,\n      curve: Curve.Ease\n    };\n    Log.debug(TAG, 'animationEndMatrix: ' + animationEndMatrix.matrix4x4);\n    this.broadCast.emit(Constants.ANIMATION_EVENT + this.item.uri + this.timeStamp, [animationOption, animationEndMatrix]);\n  }\n\n  /**\n   * At the end of the animation,\n   * refresh the current parameter values according to the end transformation matrix to ensure continuity and\n   * prevent jumping during the next gesture operation\n   *\n   * @param animationEndMatrix Transformation matrix at end\n   */\n  onAnimationEnd(animationEndMatrix: Matrix4TransitWithMatrix4x4): void {\n    if (animationEndMatrix != null) {\n      Log.info(TAG, 'onAnimationEnd: ' + animationEndMatrix.matrix4x4);\n      this.lastScale = animationEndMatrix.matrix4x4[0];\n      this.scale = 1;\n      this.lastOffset = [animationEndMatrix.matrix4x4[Constants.NUMBER_12], animationEndMatrix.matrix4x4[Constants.NUMBER_13]];\n      this.offset = [0, 0];\n      this.evaluateBounds();\n      this.isInAnimation = false;\n      this.emitDirectionChange();\n    }\n  }\n}\n"
}