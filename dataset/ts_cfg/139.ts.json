{
  "type": "file",
  "name": "139.ts",
  "label": "139.ts",
  "start_line": -1,
  "end_line": 1479,
  "classes": [
    {
      "type": "class",
      "name": "%dflt",
      "label": "%dflt",
      "start_line": -1,
      "end_line": 1475,
      "functions": [
        {
          "type": "function",
          "name": "%dflt",
          "label": "%dflt",
          "start_line": -1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\ninitialTooltipMessage = 'initial tooltip message'\nstaticinvoke <@%unk/%unk: .describe()>('MatTooltip', %AM0)\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": ""
        },
        {
          "type": "function",
          "name": "assertTooltipInstance",
          "label": "assertTooltipInstance",
          "start_line": 1,
          "end_line": 1469,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "tooltip = parameter0: MatTooltip\nshouldExist = parameter1: boolean\nthis = this: @ts_files/139.ts: %dflt\n%0 = tooltip.<@%unk/%unk: ._tooltipInstance>\n%1 = !%0\n%2 = !%1\n%3 = staticinvoke <@%unk/%unk: .expect()>(%2)\ninstanceinvoke %3.<@%unk/%unk: .toBe()>(shouldExist)\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "function assertTooltipInstance(tooltip: MatTooltip, shouldExist: boolean): void {\n  // Note that we have to cast this to a boolean, because Jasmine will go into an infinite loop\n  // if it tries to stringify the `_tooltipInstance` when an assertion fails. The infinite loop\n  // happens due to the `_tooltipInstance` having a circular structure.\n  expect(!!tooltip._tooltipInstance).toBe(shouldExist);\n}"
        },
        {
          "type": "function",
          "name": "finishCurrentTooltipAnimation",
          "label": "finishCurrentTooltipAnimation",
          "start_line": 1,
          "end_line": 1475,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "overlayContainer = parameter0: HTMLElement\nisVisible = parameter1: boolean\nthis = this: @ts_files/139.ts: %dflt\ntooltip = instanceinvoke overlayContainer.<@%unk/%unk: .querySelector()>('.mat-mdc-tooltip')\nevent = staticinvoke <@%unk/%unk: .createFakeEvent()>('animationend')\n%0 = new @ts_files/139.ts: %AC$%dflt$finishCurrentTooltipAnimation$33\ninstanceinvoke %0.<@ts_files/139.ts: %AC$%dflt$finishCurrentTooltipAnimation$33.constructor()>()\ninstanceinvoke Object.<@%unk/%unk: .defineProperty()>(event, 'animationName', %0)\nstaticinvoke <@%unk/%unk: .dispatchEvent()>(tooltip, event)\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "function finishCurrentTooltipAnimation(overlayContainer: HTMLElement, isVisible: boolean) {\n  const tooltip = overlayContainer.querySelector('.mat-mdc-tooltip')!;\n  const event = createFakeEvent('animationend');\n  Object.defineProperty(event, 'animationName', {\n    get: () => `mat-mdc-tooltip-${isVisible ? 'show' : 'hide'}`,\n  });\n  dispatchEvent(tooltip, event);\n}"
        },
        {
          "type": "function",
          "name": "%AM2$%AM1$%AM0",
          "label": "%AM2$%AM1$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "oc = parameter0: OverlayContainer\nfm = parameter1: FocusMonitor\npl = parameter2: Platform\nthis = this: @ts_files/139.ts: %dflt\noverlayContainerElement = instanceinvoke oc.<@%unk/%unk: .getContainerElement()>()\nfocusMonitor = fm\nplatform = pl\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "(oc: OverlayContainer, fm: FocusMonitor, pl: Platform) => {\n        overlayContainerElement = oc.getContainerElement();\n        focusMonitor = fm;\n        platform = pl;\n      }"
        },
        {
          "type": "function",
          "name": "%AM1$%AM0",
          "label": "%AM1$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\n%0 = new @ts_files/139.ts: %AC$%dflt$%AM1$%AM0$1\ninstanceinvoke %0.<@ts_files/139.ts: %AC$%dflt$%AM1$%AM0$1.constructor()>()\ninstanceinvoke TestBed.<@%unk/%unk: .configureTestingModule()>(%0)\n%1 = newarray (unknown)[3]\n%1[0] = OverlayContainer\n%1[1] = FocusMonitor\n%1[2] = Platform\n%2 = staticinvoke <@%unk/%unk: .inject()>(%1, %AM2$%AM1$%AM0)\nstaticinvoke <@%unk/%unk: .%2()>()\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n    TestBed.configureTestingModule({\n      imports: [\n        MatTooltipModule,\n        OverlayModule,\n        BasicTooltipDemo,\n        ScrollableTooltipDemo,\n        OnPushTooltipDemo,\n        DynamicTooltipsDemo,\n        TooltipOnTextFields,\n        TooltipOnDraggableElement,\n        DataBoundAriaLabelTooltip,\n      ],\n      providers: [\n        {\n          provide: Directionality,\n          useFactory: () => {\n            return (dir = {value: 'ltr', change: new Subject()});\n          },\n        },\n      ],\n    });\n    inject(\n      [OverlayContainer, FocusMonitor, Platform],\n      (oc: OverlayContainer, fm: FocusMonitor, pl: Platform) => {\n        overlayContainerElement = oc.getContainerElement();\n        focusMonitor = fm;\n        platform = pl;\n      },\n    )();\n  }"
        },
        {
          "type": "function",
          "name": "%AM4$%AM3$%AM0",
          "label": "%AM4$%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\nfixture = instanceinvoke TestBed.<@%unk/%unk: .createComponent()>(BasicTooltipDemo)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>()\n%0 = instanceinvoke By.<@%unk/%unk: .css()>('button')\n%1 = fixture.<@%unk/%unk: .debugElement>\nbuttonDebugElement = instanceinvoke %1.<@%unk/%unk: .query()>(%0)\nbuttonElement = buttonDebugElement.<@%unk/%unk: .nativeElement>\n%2 = buttonDebugElement.<@%unk/%unk: .injector>\ntooltipDirective = instanceinvoke %2.<@%unk/%unk: .get()>(MatTooltip)\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      tick();\n      buttonDebugElement = fixture.debugElement.query(By.css('button'))!;\n      buttonElement = buttonDebugElement.nativeElement;\n      tooltipDirective = buttonDebugElement.injector.get<MatTooltip>(MatTooltip);\n    }"
        },
        {
          "type": "function",
          "name": "%AM5$%AM3$%AM0",
          "label": "%AM5$%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\nstaticinvoke <@ts_files/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)>(tooltipDirective, false)\ninstanceinvoke tooltipDirective.<@%unk/%unk: .show()>()\nstaticinvoke <@%unk/%unk: .tick()>(0)\n%0 = instanceinvoke tooltipDirective.<@%unk/%unk: ._isTooltipVisible()>()\n%1 = staticinvoke <@%unk/%unk: .expect()>(%0)\ninstanceinvoke %1.<@%unk/%unk: .toBe()>(true)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@ts_files/139.ts: %dflt.finishCurrentTooltipAnimation(HTMLElement, boolean)>(overlayContainerElement, true)\n%2 = instanceinvoke overlayContainerElement.<@%unk/%unk: .querySelector()>('.mat-mdc-tooltip')\ntooltipElement = <HTMLElement>%2\n%3 = staticinvoke <@%unk/%unk: .expect()>(tooltipElement instanceof HTMLElement)\ninstanceinvoke %3.<@%unk/%unk: .toBe()>(true)\n%4 = tooltipElement.<@%unk/%unk: .classList>\n%5 = staticinvoke <@%unk/%unk: .expect()>(%4)\ninstanceinvoke %5.<@%unk/%unk: .toContain()>('mat-mdc-tooltip-show')\n%6 = overlayContainerElement.<@%unk/%unk: .textContent>\n%7 = staticinvoke <@%unk/%unk: .expect()>(%6)\ninstanceinvoke %7.<@%unk/%unk: .toContain()>(initialTooltipMessage)\ntooltipDelay = 1000\ninstanceinvoke tooltipDirective.<@%unk/%unk: .hide()>(tooltipDelay)\n%8 = instanceinvoke tooltipDirective.<@%unk/%unk: ._isTooltipVisible()>()\n%9 = staticinvoke <@%unk/%unk: .expect()>(%8)\ninstanceinvoke %9.<@%unk/%unk: .toBe()>(true)\nstaticinvoke <@%unk/%unk: .tick()>(tooltipDelay)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%10 = instanceinvoke tooltipDirective.<@%unk/%unk: ._isTooltipVisible()>()\n%11 = staticinvoke <@%unk/%unk: .expect()>(%10)\ninstanceinvoke %11.<@%unk/%unk: .toBe()>(false)\nstaticinvoke <@ts_files/139.ts: %dflt.finishCurrentTooltipAnimation(HTMLElement, boolean)>(overlayContainerElement, false)\nstaticinvoke <@ts_files/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)>(tooltipDirective, false)\nstaticinvoke <@%unk/%unk: .flush()>()\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.show();\n      tick(0); // Tick for the show delay (default is 0)\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      fixture.detectChanges();\n      // Wait until animation has finished\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      // Make sure tooltip is shown to the user and animation has finished.\n      const tooltipElement = overlayContainerElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;\n      expect(tooltipElement instanceof HTMLElement).toBe(true);\n      expect(tooltipElement.classList).toContain('mat-mdc-tooltip-show');\n      expect(overlayContainerElement.textContent).toContain(initialTooltipMessage);\n      // After hide is called, a timeout delay is created that will to hide the tooltip.\n      const tooltipDelay = 1000;\n      tooltipDirective.hide(tooltipDelay);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      // After the tooltip delay elapses, expect that the tooltip is not visible.\n      tick(tooltipDelay);\n      fixture.detectChanges();\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      // On animation complete, should expect that the tooltip has been detached.\n      finishCurrentTooltipAnimation(overlayContainerElement, false);\n      assertTooltipInstance(tooltipDirective, false);\n      flush();\n    }"
        },
        {
          "type": "function",
          "name": "%AM6$%AM3$%AM0",
          "label": "%AM6$%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\ninstanceinvoke tooltipDirective.<@%unk/%unk: .show()>()\nstaticinvoke <@%unk/%unk: .tick()>(0)\n%0 = instanceinvoke tooltipDirective.<@%unk/%unk: ._isTooltipVisible()>()\n%1 = staticinvoke <@%unk/%unk: .expect()>(%0)\ninstanceinvoke %1.<@%unk/%unk: .toBe()>(true)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@ts_files/139.ts: %dflt.finishCurrentTooltipAnimation(HTMLElement, boolean)>(overlayContainerElement, true)\n%2 = tooltipDirective.<@%unk/%unk: ._overlayRef>\ninstanceinvoke %2.<@%unk/%unk: .detach()>()\nstaticinvoke <@%unk/%unk: .tick()>(0)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%3 = instanceinvoke tooltipDirective.<@%unk/%unk: ._isTooltipVisible()>()\n%4 = staticinvoke <@%unk/%unk: .expect()>(%3)\ninstanceinvoke %4.<@%unk/%unk: .toBe()>(false)\nstaticinvoke <@ts_files/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)>(tooltipDirective, false)\ninstanceinvoke tooltipDirective.<@%unk/%unk: .show()>()\nstaticinvoke <@%unk/%unk: .tick()>(0)\nstaticinvoke <@ts_files/139.ts: %dflt.finishCurrentTooltipAnimation(HTMLElement, boolean)>(overlayContainerElement, true)\n%5 = instanceinvoke tooltipDirective.<@%unk/%unk: ._isTooltipVisible()>()\n%6 = staticinvoke <@%unk/%unk: .expect()>(%5)\ninstanceinvoke %6.<@%unk/%unk: .toBe()>(true)\nstaticinvoke <@%unk/%unk: .flush()>()\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      tooltipDirective.show();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      tooltipDirective._overlayRef!.detach();\n      tick(0);\n      fixture.detectChanges();\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.show();\n      tick(0);\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      flush();\n    }"
        },
        {
          "type": "function",
          "name": "%AM7$%AM3$%AM0",
          "label": "%AM7$%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\nstaticinvoke <@ts_files/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)>(tooltipDirective, false)\ntooltipDelay = 1000\ninstanceinvoke tooltipDirective.<@%unk/%unk: .show()>(tooltipDelay)\n%0 = instanceinvoke tooltipDirective.<@%unk/%unk: ._isTooltipVisible()>()\n%1 = staticinvoke <@%unk/%unk: .expect()>(%0)\ninstanceinvoke %1.<@%unk/%unk: .toBe()>(false)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%2 = overlayContainerElement.<@%unk/%unk: .textContent>\n%3 = staticinvoke <@%unk/%unk: .expect()>(%2)\ninstanceinvoke %3.<@%unk/%unk: .toContain()>('')\nstaticinvoke <@%unk/%unk: .tick()>(tooltipDelay)\n%4 = instanceinvoke tooltipDirective.<@%unk/%unk: ._isTooltipVisible()>()\n%5 = staticinvoke <@%unk/%unk: .expect()>(%4)\ninstanceinvoke %5.<@%unk/%unk: .toBe()>(true)\n%6 = overlayContainerElement.<@%unk/%unk: .textContent>\n%7 = staticinvoke <@%unk/%unk: .expect()>(%6)\ninstanceinvoke %7.<@%unk/%unk: .toContain()>(initialTooltipMessage)\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      assertTooltipInstance(tooltipDirective, false);\n      const tooltipDelay = 1000;\n      tooltipDirective.show(tooltipDelay);\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      fixture.detectChanges();\n      expect(overlayContainerElement.textContent).toContain('');\n      tick(tooltipDelay);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      expect(overlayContainerElement.textContent).toContain(initialTooltipMessage);\n    }"
        },
        {
          "type": "function",
          "name": "%AM8$%AM3$%AM0",
          "label": "%AM8$%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\n%0 = new @ts_files/139.ts: %AC$%dflt$%AM8$%AM3$%AM0$4\ninstanceinvoke %0.<@ts_files/139.ts: %AC$%dflt$%AM8$%AM3$%AM0$4.constructor()>()\n%1 = instanceinvoke TestBed.<@%unk/%unk: .resetTestingModule()>()\ninstanceinvoke %1.<@%unk/%unk: .configureTestingModule()>(%0)\nfixture = instanceinvoke TestBed.<@%unk/%unk: .createComponent()>(BasicTooltipDemo)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%2 = instanceinvoke By.<@%unk/%unk: .css()>('button')\n%3 = fixture.<@%unk/%unk: .debugElement>\n%4 = instanceinvoke %3.<@%unk/%unk: .query()>(%2)\n%5 = %4.<@%unk/%unk: .injector>\ntooltipDirective = instanceinvoke %5.<@%unk/%unk: .get()>(MatTooltip)\ninstanceinvoke tooltipDirective.<@%unk/%unk: .show()>()\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>()\n%6 = instanceinvoke tooltipDirective.<@%unk/%unk: ._isTooltipVisible()>()\n%7 = staticinvoke <@%unk/%unk: .expect()>(%6)\ninstanceinvoke %7.<@%unk/%unk: .toBe()>(false)\nstaticinvoke <@%unk/%unk: .tick()>(1337)\n%8 = instanceinvoke tooltipDirective.<@%unk/%unk: ._isTooltipVisible()>()\n%9 = staticinvoke <@%unk/%unk: .expect()>(%8)\ninstanceinvoke %9.<@%unk/%unk: .toBe()>(true)\ninstanceinvoke tooltipDirective.<@%unk/%unk: .hide()>()\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>()\n%10 = instanceinvoke tooltipDirective.<@%unk/%unk: ._isTooltipVisible()>()\n%11 = staticinvoke <@%unk/%unk: .expect()>(%10)\ninstanceinvoke %11.<@%unk/%unk: .toBe()>(true)\nstaticinvoke <@%unk/%unk: .tick()>(7331)\n%12 = instanceinvoke tooltipDirective.<@%unk/%unk: ._isTooltipVisible()>()\n%13 = staticinvoke <@%unk/%unk: .expect()>(%12)\ninstanceinvoke %13.<@%unk/%unk: .toBe()>(false)\nstaticinvoke <@%unk/%unk: .flush()>()\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      TestBed.resetTestingModule().configureTestingModule({\n        imports: [MatTooltipModule, OverlayModule, BasicTooltipDemo],\n        providers: [\n          {\n            provide: MAT_TOOLTIP_DEFAULT_OPTIONS,\n            useValue: {showDelay: 1337, hideDelay: 7331},\n          },\n        ],\n      });\n      fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      tooltipDirective = fixture.debugElement\n        .query(By.css('button'))!\n        .injector.get<MatTooltip>(MatTooltip);\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick();\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      tick(1337);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      tooltipDirective.hide();\n      fixture.detectChanges();\n      tick();\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      tick(7331);\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      flush();\n    }"
        },
        {
          "type": "function",
          "name": "%AM9$%AM3$%AM0",
          "label": "%AM9$%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\n%0 = new @ts_files/139.ts: %AC$%dflt$%AM9$%AM3$%AM0$7\ninstanceinvoke %0.<@ts_files/139.ts: %AC$%dflt$%AM9$%AM3$%AM0$7.constructor()>()\n%1 = instanceinvoke TestBed.<@%unk/%unk: .resetTestingModule()>()\ninstanceinvoke %1.<@%unk/%unk: .configureTestingModule()>(%0)\nnewFixture = instanceinvoke TestBed.<@%unk/%unk: .createComponent()>(TooltipDemoWithoutPositionBinding)\ninstanceinvoke newFixture.<@%unk/%unk: .detectChanges()>()\n%2 = instanceinvoke By.<@%unk/%unk: .css()>('button')\n%3 = newFixture.<@%unk/%unk: .debugElement>\n%4 = instanceinvoke %3.<@%unk/%unk: .query()>(%2)\n%5 = %4.<@%unk/%unk: .injector>\ntooltipDirective = instanceinvoke %5.<@%unk/%unk: .get()>(MatTooltip)\ninstanceinvoke tooltipDirective.<@%unk/%unk: .show()>()\ninstanceinvoke newFixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>()\n%6 = tooltipDirective.<@%unk/%unk: .position>\n%7 = staticinvoke <@%unk/%unk: .expect()>(%6)\ninstanceinvoke %7.<@%unk/%unk: .toBe()>('right')\n%8 = instanceinvoke tooltipDirective.<@%unk/%unk: ._getOverlayPosition()>()\n%9 = %8.<@%unk/%unk: .main>\n%10 = %9.<@%unk/%unk: .overlayX>\n%11 = staticinvoke <@%unk/%unk: .expect()>(%10)\ninstanceinvoke %11.<@%unk/%unk: .toBe()>('start')\n%12 = instanceinvoke tooltipDirective.<@%unk/%unk: ._getOverlayPosition()>()\n%13 = %12.<@%unk/%unk: .fallback>\n%14 = %13.<@%unk/%unk: .overlayX>\n%15 = staticinvoke <@%unk/%unk: .expect()>(%14)\ninstanceinvoke %15.<@%unk/%unk: .toBe()>('end')\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      TestBed.resetTestingModule().configureTestingModule({\n        imports: [MatTooltipModule, OverlayModule],\n        declarations: [TooltipDemoWithoutPositionBinding],\n        providers: [\n          {\n            provide: MAT_TOOLTIP_DEFAULT_OPTIONS,\n            useValue: {position: 'right'},\n          },\n        ],\n      });\n      const newFixture = TestBed.createComponent(TooltipDemoWithoutPositionBinding);\n      newFixture.detectChanges();\n      tooltipDirective = newFixture.debugElement\n        .query(By.css('button'))!\n        .injector.get<MatTooltip>(MatTooltip);\n      tooltipDirective.show();\n      newFixture.detectChanges();\n      tick();\n      expect(tooltipDirective.position).toBe('right');\n      expect(tooltipDirective._getOverlayPosition().main.overlayX).toBe('start');\n      expect(tooltipDirective._getOverlayPosition().fallback.overlayX).toBe('end');\n    }"
        },
        {
          "type": "function",
          "name": "%AM10$%AM3$%AM0",
          "label": "%AM10$%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\n%0 = new @ts_files/139.ts: %AC$%dflt$%AM10$%AM3$%AM0$10\ninstanceinvoke %0.<@ts_files/139.ts: %AC$%dflt$%AM10$%AM3$%AM0$10.constructor()>()\n%1 = instanceinvoke TestBed.<@%unk/%unk: .resetTestingModule()>()\ninstanceinvoke %1.<@%unk/%unk: .configureTestingModule()>(%0)\nfixture = instanceinvoke TestBed.<@%unk/%unk: .createComponent()>(TooltipDemoWithoutTooltipClassBinding)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%2 = fixture.<@%unk/%unk: .componentInstance>\ntooltipDirective = %2.<@%unk/%unk: .tooltip>\ninstanceinvoke tooltipDirective.<@%unk/%unk: .show()>()\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>()\noverlayRef = tooltipDirective.<@%unk/%unk: ._overlayRef>\n%3 = overlayRef.<@%unk/%unk: .overlayElement>\n%4 = instanceinvoke %3.<@%unk/%unk: .querySelector()>('.mat-mdc-tooltip')\ntooltipElement = <HTMLElement>%4\n%5 = tooltipDirective.<@%unk/%unk: .tooltipClass>\n%6 = staticinvoke <@%unk/%unk: .expect()>(%5)\ninstanceinvoke %6.<@%unk/%unk: .toBe()>('my-default-tooltip-class')\n%7 = tooltipElement.<@%unk/%unk: .classList>\n%8 = staticinvoke <@%unk/%unk: .expect()>(%7)\ninstanceinvoke %8.<@%unk/%unk: .toContain()>('my-default-tooltip-class')\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      TestBed.resetTestingModule().configureTestingModule({\n        declarations: [TooltipDemoWithoutTooltipClassBinding],\n        imports: [MatTooltipModule, OverlayModule],\n        providers: [\n          {\n            provide: MAT_TOOLTIP_DEFAULT_OPTIONS,\n            useValue: {tooltipClass: 'my-default-tooltip-class'},\n          },\n        ],\n      });\n      const fixture = TestBed.createComponent(TooltipDemoWithoutTooltipClassBinding);\n      fixture.detectChanges();\n      tooltipDirective = fixture.componentInstance.tooltip;\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick();\n      const overlayRef = tooltipDirective._overlayRef!;\n      const tooltipElement = overlayRef.overlayElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;\n      expect(tooltipDirective.tooltipClass).toBe('my-default-tooltip-class');\n      expect(tooltipElement.classList).toContain('my-default-tooltip-class');\n    }"
        },
        {
          "type": "function",
          "name": "%AM11$%AM3$%AM0",
          "label": "%AM11$%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\n%0 = new @ts_files/139.ts: %AC$%dflt$%AM11$%AM3$%AM0$13\ninstanceinvoke %0.<@ts_files/139.ts: %AC$%dflt$%AM11$%AM3$%AM0$13.constructor()>()\n%1 = instanceinvoke TestBed.<@%unk/%unk: .resetTestingModule()>()\ninstanceinvoke %1.<@%unk/%unk: .configureTestingModule()>(%0)\nfixture = instanceinvoke TestBed.<@%unk/%unk: .createComponent()>(TooltipDemoWithTooltipClassBinding)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%2 = fixture.<@%unk/%unk: .componentInstance>\ntooltipDirective = %2.<@%unk/%unk: .tooltip>\ninstanceinvoke tooltipDirective.<@%unk/%unk: .show()>()\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>()\noverlayRef = tooltipDirective.<@%unk/%unk: ._overlayRef>\n%3 = overlayRef.<@%unk/%unk: .overlayElement>\n%4 = instanceinvoke %3.<@%unk/%unk: .querySelector()>('.mat-mdc-tooltip')\ntooltipElement = <HTMLElement>%4\n%5 = tooltipDirective.<@%unk/%unk: .tooltipClass>\n%6 = staticinvoke <@%unk/%unk: .expect()>(%5)\n%7 = %6.<@%unk/%unk: .not>\ninstanceinvoke %7.<@%unk/%unk: .toBe()>('my-default-tooltip-class')\n%8 = tooltipElement.<@%unk/%unk: .classList>\n%9 = staticinvoke <@%unk/%unk: .expect()>(%8)\n%10 = %9.<@%unk/%unk: .not>\ninstanceinvoke %10.<@%unk/%unk: .toContain()>('my-default-tooltip-class')\n%11 = tooltipElement.<@%unk/%unk: .classList>\n%12 = staticinvoke <@%unk/%unk: .expect()>(%11)\ninstanceinvoke %12.<@%unk/%unk: .toContain()>('fixed-tooltip-class')\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      TestBed.resetTestingModule().configureTestingModule({\n        declarations: [TooltipDemoWithTooltipClassBinding],\n        imports: [MatTooltipModule, OverlayModule],\n        providers: [\n          {\n            provide: MAT_TOOLTIP_DEFAULT_OPTIONS,\n            useValue: {tooltipClass: 'my-default-tooltip-class'},\n          },\n        ],\n      });\n      const fixture = TestBed.createComponent(TooltipDemoWithTooltipClassBinding);\n      fixture.detectChanges();\n      tooltipDirective = fixture.componentInstance.tooltip;\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick();\n      const overlayRef = tooltipDirective._overlayRef!;\n      const tooltipElement = overlayRef.overlayElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;\n      expect(tooltipDirective.tooltipClass).not.toBe('my-default-tooltip-class');\n      expect(tooltipElement.classList).not.toContain('my-default-tooltip-class');\n      expect(tooltipElement.classList).toContain('fixed-tooltip-class');\n    }"
        },
        {
          "type": "function",
          "name": "%AM12$%AM3$%AM0",
          "label": "%AM12$%AM3$%AM0",
          "start_line": 1,
          "end_line": 250,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\n%0 = platform.<@%unk/%unk: .IOS>\n%1 = platform.<@%unk/%unk: .ANDROID>\n%2 = %0 || %1\nif %2 != false",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "return",
                  "start_line": 66,
                  "end_line": 1276,
                  "successors": []
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%3 = new @ts_files/139.ts: %AC$%dflt$%AM12$%AM3$%AM0$16\ninstanceinvoke %3.<@ts_files/139.ts: %AC$%dflt$%AM12$%AM3$%AM0$16.constructor()>()\n%4 = instanceinvoke TestBed.<@%unk/%unk: .resetTestingModule()>()\ninstanceinvoke %4.<@%unk/%unk: .configureTestingModule()>(%3)\nwideFixture = instanceinvoke TestBed.<@%unk/%unk: .createComponent()>(WideTooltipDemo)\ninstanceinvoke wideFixture.<@%unk/%unk: .detectChanges()>()\n%5 = instanceinvoke By.<@%unk/%unk: .css()>('button')\n%6 = wideFixture.<@%unk/%unk: .debugElement>\n%7 = instanceinvoke %6.<@%unk/%unk: .query()>(%5)\n%8 = %7.<@%unk/%unk: .injector>\ntooltipDirective = instanceinvoke %8.<@%unk/%unk: .get()>(MatTooltip)\n%9 = wideFixture.<@%unk/%unk: .nativeElement>\nbutton = instanceinvoke %9.<@%unk/%unk: .querySelector()>('button')\ntriggerRect = instanceinvoke button.<@%unk/%unk: .getBoundingClientRect()>()\n%10 = triggerRect.<@%unk/%unk: .right>\n%11 = %10 - 100\n%12 = triggerRect.<@%unk/%unk: .top>\n%13 = %12 + 100\nstaticinvoke <@%unk/%unk: .dispatchMouseEvent()>(button, 'mouseenter', %11, %13)\ninstanceinvoke wideFixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>()\n%14 = instanceinvoke tooltipDirective.<@%unk/%unk: ._isTooltipVisible()>()\n%15 = staticinvoke <@%unk/%unk: .expect()>(%14)\ninstanceinvoke %15.<@%unk/%unk: .toBe()>(true)\n%16 = triggerRect.<@%unk/%unk: .right>\n%17 = %16 - 250\n%18 = tooltipDirective.<@%unk/%unk: ._overlayRef>\n%19 = %18.<@%unk/%unk: .overlayElement>\n%20 = %19.<@%unk/%unk: .offsetLeft>\n%21 = staticinvoke <@%unk/%unk: .expect()>(%20)\ninstanceinvoke %21.<@%unk/%unk: .toBeLessThan()>(%17)\n%22 = triggerRect.<@%unk/%unk: .bottom>\n%23 = tooltipDirective.<@%unk/%unk: ._overlayRef>\n%24 = %23.<@%unk/%unk: .overlayElement>\n%25 = %24.<@%unk/%unk: .offsetTop>\n%26 = staticinvoke <@%unk/%unk: .expect()>(%25)\ninstanceinvoke %26.<@%unk/%unk: .toBeGreaterThanOrEqual()>(%22)\nreturn",
                  "start_line": 1,
                  "end_line": 1276,
                  "successors": []
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      // We don't bind mouse events on mobile devices.\n      if (platform.IOS || platform.ANDROID) {\n        return;\n      }\n      TestBed.resetTestingModule().configureTestingModule({\n        imports: [MatTooltipModule, OverlayModule],\n        declarations: [WideTooltipDemo],\n      });\n      const wideFixture = TestBed.createComponent(WideTooltipDemo);\n      wideFixture.detectChanges();\n      tooltipDirective = wideFixture.debugElement\n        .query(By.css('button'))!\n        .injector.get<MatTooltip>(MatTooltip);\n      const button: HTMLButtonElement = wideFixture.nativeElement.querySelector('button');\n      const triggerRect = button.getBoundingClientRect();\n      dispatchMouseEvent(button, 'mouseenter', triggerRect.right - 100, triggerRect.top + 100);\n      wideFixture.detectChanges();\n      tick();\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      expect(tooltipDirective._overlayRef!.overlayElement.offsetLeft).toBeLessThan(\n        triggerRect.right - 250,\n      );\n      expect(tooltipDirective._overlayRef!.overlayElement.offsetTop).toBeGreaterThanOrEqual(\n        triggerRect.bottom,\n      );\n    }"
        },
        {
          "type": "function",
          "name": "%AM14$%AM13$%AM3$%AM0",
          "label": "%AM14$%AM13$%AM3$%AM0",
          "start_line": 1,
          "end_line": 301,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "resolve = parameter0: unknown\nthis = this: @ts_files/139.ts: %dflt\n%0 = staticinvoke <@%unk/%unk: .setTimeout()>(resolve)\nreturn %0",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "resolve => setTimeout(resolve)"
        },
        {
          "type": "function",
          "name": "%AM13$%AM3$%AM0",
          "label": "%AM13$%AM3$%AM0",
          "start_line": 1,
          "end_line": 277,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\n%0 = platform.<@%unk/%unk: .IOS>\n%1 = platform.<@%unk/%unk: .ANDROID>\n%2 = %0 || %1\nif %2 != false",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "return",
                  "start_line": 66,
                  "end_line": 1276,
                  "successors": []
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%3 = new @ts_files/139.ts: %AC$%dflt$%AM13$%AM3$%AM0$17\ninstanceinvoke %3.<@ts_files/139.ts: %AC$%dflt$%AM13$%AM3$%AM0$17.constructor()>()\n%4 = instanceinvoke TestBed.<@%unk/%unk: .resetTestingModule()>()\ninstanceinvoke %4.<@%unk/%unk: .configureTestingModule()>(%3)\nwideFixture = instanceinvoke TestBed.<@%unk/%unk: .createComponent()>(WideTooltipDemo)\ninstanceinvoke wideFixture.<@%unk/%unk: .detectChanges()>()\n%5 = instanceinvoke By.<@%unk/%unk: .css()>('button')\n%6 = wideFixture.<@%unk/%unk: .debugElement>\n%7 = instanceinvoke %6.<@%unk/%unk: .query()>(%5)\n%8 = %7.<@%unk/%unk: .injector>\ntooltipDirective = instanceinvoke %8.<@%unk/%unk: .get()>(MatTooltip)\n%9 = wideFixture.<@%unk/%unk: .nativeElement>\nbutton = instanceinvoke %9.<@%unk/%unk: .querySelector()>('button')\ntriggerRect = instanceinvoke button.<@%unk/%unk: .getBoundingClientRect()>()\n%10 = triggerRect.<@%unk/%unk: .right>\n%11 = %10 - 100\n%12 = triggerRect.<@%unk/%unk: .top>\n%13 = %12 + 100\nstaticinvoke <@%unk/%unk: .dispatchMouseEvent()>(button, 'mouseenter', %11, %13)\ninstanceinvoke wideFixture.<@%unk/%unk: .detectChanges()>()\n%14 = new @%unk/%unk: Promise<void>\ninstanceinvoke %14.<@%unk/%unk: Promise.constructor()>(%AM14$%AM13$%AM3$%AM0)\n%15 = await %14\n%16 = instanceinvoke tooltipDirective.<@%unk/%unk: ._isTooltipVisible()>()\n%17 = staticinvoke <@%unk/%unk: .expect()>(%16)\ninstanceinvoke %17.<@%unk/%unk: .toBe()>(true)\n%18 = tooltipDirective.<@%unk/%unk: ._overlayRef>\n%19 = %18.<@%unk/%unk: .overlayElement>\nactualOffsetLeft = %19.<@%unk/%unk: .offsetLeft>\n%20 = triggerRect.<@%unk/%unk: .right>\n%21 = %20 - 100\nexpectedOffsetLeft = %21 - 20\n%22 = expectedOffsetLeft + 1\n%23 = staticinvoke <@%unk/%unk: .expect()>(actualOffsetLeft)\ninstanceinvoke %23.<@%unk/%unk: .toBeLessThanOrEqual()>(%22)\n%24 = expectedOffsetLeft - 1\n%25 = staticinvoke <@%unk/%unk: .expect()>(actualOffsetLeft)\ninstanceinvoke %25.<@%unk/%unk: .toBeGreaterThanOrEqual()>(%24)\n%26 = triggerRect.<@%unk/%unk: .top>\n%27 = %26 + 100\n%28 = tooltipDirective.<@%unk/%unk: ._overlayRef>\n%29 = %28.<@%unk/%unk: .overlayElement>\n%30 = %29.<@%unk/%unk: .offsetTop>\n%31 = staticinvoke <@%unk/%unk: .expect()>(%30)\ninstanceinvoke %31.<@%unk/%unk: .toBe()>(%27)\nreturn",
                  "start_line": 1,
                  "end_line": 1276,
                  "successors": []
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "async () => {\n      // We don't bind mouse events on mobile devices.\n      if (platform.IOS || platform.ANDROID) {\n        return;\n      }\n      TestBed.resetTestingModule().configureTestingModule({\n        imports: [MatTooltipModule, OverlayModule],\n        declarations: [WideTooltipDemo],\n        providers: [\n          {\n            provide: MAT_TOOLTIP_DEFAULT_OPTIONS,\n            useValue: {positionAtOrigin: true},\n          },\n        ],\n      });\n      const wideFixture = TestBed.createComponent(WideTooltipDemo);\n      wideFixture.detectChanges();\n      tooltipDirective = wideFixture.debugElement\n        .query(By.css('button'))!\n        .injector.get<MatTooltip>(MatTooltip);\n      const button: HTMLButtonElement = wideFixture.nativeElement.querySelector('button');\n      const triggerRect = button.getBoundingClientRect();\n      dispatchMouseEvent(button, 'mouseenter', triggerRect.right - 100, triggerRect.top + 100);\n      wideFixture.detectChanges();\n      await new Promise<void>(resolve => setTimeout(resolve));\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      const actualOffsetLeft = tooltipDirective._overlayRef!.overlayElement.offsetLeft;\n      const expectedOffsetLeft = triggerRect.right - 100 - 20;\n      expect(actualOffsetLeft).toBeLessThanOrEqual(expectedOffsetLeft + 1);\n      expect(actualOffsetLeft).toBeGreaterThanOrEqual(expectedOffsetLeft - 1);\n      expect(tooltipDirective._overlayRef!.overlayElement.offsetTop).toBe(triggerRect.top + 100);\n    }"
        },
        {
          "type": "function",
          "name": "%AM15$%AM3$%AM0",
          "label": "%AM15$%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\n%0 = new @ts_files/139.ts: %AC$%dflt$%AM15$%AM3$%AM0$20\ninstanceinvoke %0.<@ts_files/139.ts: %AC$%dflt$%AM15$%AM3$%AM0$20.constructor()>()\n%1 = instanceinvoke TestBed.<@%unk/%unk: .resetTestingModule()>()\ninstanceinvoke %1.<@%unk/%unk: .configureTestingModule()>(%0)\nnewFixture = instanceinvoke TestBed.<@%unk/%unk: .createComponent()>(TooltipDemoWithoutPositionBinding)\ninstanceinvoke newFixture.<@%unk/%unk: .detectChanges()>()\n%2 = instanceinvoke By.<@%unk/%unk: .css()>('button')\n%3 = newFixture.<@%unk/%unk: .debugElement>\n%4 = instanceinvoke %3.<@%unk/%unk: .query()>(%2)\n%5 = %4.<@%unk/%unk: .injector>\ntooltipDirective = instanceinvoke %5.<@%unk/%unk: .get()>(MatTooltip)\ninstanceinvoke tooltipDirective.<@%unk/%unk: .show()>()\ninstanceinvoke newFixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>()\n%6 = tooltipDirective.<@%unk/%unk: ._overlayRef>\n%7 = %6.<@%unk/%unk: .overlayElement>\n%8 = %7.<@%unk/%unk: .classList>\n%9 = staticinvoke <@%unk/%unk: .expect()>(%8)\ninstanceinvoke %9.<@%unk/%unk: .toContain()>('mat-mdc-tooltip-panel-non-interactive')\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      TestBed.resetTestingModule().configureTestingModule({\n        imports: [MatTooltipModule, OverlayModule, NoopAnimationsModule],\n        declarations: [TooltipDemoWithoutPositionBinding],\n        providers: [\n          {\n            provide: MAT_TOOLTIP_DEFAULT_OPTIONS,\n            useValue: {disableTooltipInteractivity: true},\n          },\n        ],\n      });\n      const newFixture = TestBed.createComponent(TooltipDemoWithoutPositionBinding);\n      newFixture.detectChanges();\n      tooltipDirective = newFixture.debugElement\n        .query(By.css('button'))!\n        .injector.get<MatTooltip>(MatTooltip);\n      tooltipDirective.show();\n      newFixture.detectChanges();\n      tick();\n      expect(tooltipDirective._overlayRef?.overlayElement.classList).toContain(\n        'mat-mdc-tooltip-panel-non-interactive',\n      );\n    }"
        },
        {
          "type": "function",
          "name": "%AM16$%AM3$%AM0",
          "label": "%AM16$%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\ninstanceinvoke tooltipDirective.<@%unk/%unk: .show()>()\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>(0)\noverlayRef = tooltipDirective.<@%unk/%unk: ._overlayRef>\n%0 = !overlayRef\n%1 = !%0\n%2 = staticinvoke <@%unk/%unk: .expect()>(%1)\ninstanceinvoke %2.<@%unk/%unk: .toBeTruthy()>()\n%3 = overlayRef.<@%unk/%unk: .overlayElement>\n%4 = %3.<@%unk/%unk: .classList>\n%5 = staticinvoke <@%unk/%unk: .expect()>(%4)\n%6 = instanceinvoke %5.<@%unk/%unk: .withContext()>('Expected the overlay panel element to have the tooltip panel class set.')\ninstanceinvoke %6.<@%unk/%unk: .toContain()>('mat-mdc-tooltip-panel')\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick(0);\n      const overlayRef = tooltipDirective._overlayRef;\n      expect(!!overlayRef).toBeTruthy();\n      expect(overlayRef!.overlayElement.classList)\n        .withContext('Expected the overlay panel element to have the tooltip panel class set.')\n        .toContain('mat-mdc-tooltip-panel');\n    }"
        },
        {
          "type": "function",
          "name": "%AM17$%AM3$%AM0",
          "label": "%AM17$%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\ntooltipDirective.<@%unk/%unk: .disabled> = true\n%0 = fixture.<@%unk/%unk: .changeDetectorRef>\ninstanceinvoke %0.<@%unk/%unk: .markForCheck()>()\ninstanceinvoke tooltipDirective.<@%unk/%unk: .show()>()\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>(0)\n%1 = instanceinvoke tooltipDirective.<@%unk/%unk: ._isTooltipVisible()>()\n%2 = staticinvoke <@%unk/%unk: .expect()>(%1)\ninstanceinvoke %2.<@%unk/%unk: .toBe()>(false)\ntooltipDirective.<@%unk/%unk: .disabled> = false\n%3 = fixture.<@%unk/%unk: .changeDetectorRef>\ninstanceinvoke %3.<@%unk/%unk: .markForCheck()>()\ninstanceinvoke tooltipDirective.<@%unk/%unk: .show()>()\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>(0)\n%4 = instanceinvoke tooltipDirective.<@%unk/%unk: ._isTooltipVisible()>()\n%5 = staticinvoke <@%unk/%unk: .expect()>(%4)\ninstanceinvoke %5.<@%unk/%unk: .toBe()>(true)\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      // Test that disabling the tooltip will not set the tooltip visible\n      tooltipDirective.disabled = true;\n      fixture.changeDetectorRef.markForCheck();\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      // Test to make sure setting disabled to false will show the tooltip\n      // Sanity check to make sure everything was correct before (detectChanges, tick)\n      tooltipDirective.disabled = false;\n      fixture.changeDetectorRef.markForCheck();\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n    }"
        },
        {
          "type": "function",
          "name": "%AM18$%AM3$%AM0",
          "label": "%AM18$%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\ntooltipDirective.<@%unk/%unk: .hideDelay> = 1000\ninstanceinvoke tooltipDirective.<@%unk/%unk: .show()>()\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>(0)\n%0 = instanceinvoke tooltipDirective.<@%unk/%unk: ._isTooltipVisible()>()\n%1 = staticinvoke <@%unk/%unk: .expect()>(%0)\ninstanceinvoke %1.<@%unk/%unk: .toBe()>(true)\ntooltipDirective.<@%unk/%unk: .disabled> = true\nstaticinvoke <@%unk/%unk: .tick()>(0)\n%2 = instanceinvoke tooltipDirective.<@%unk/%unk: ._isTooltipVisible()>()\n%3 = staticinvoke <@%unk/%unk: .expect()>(%2)\ninstanceinvoke %3.<@%unk/%unk: .toBe()>(false)\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      // Display the tooltip with a timeout before hiding.\n      tooltipDirective.hideDelay = 1000;\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      // Set tooltip to be disabled and verify that the tooltip hides.\n      tooltipDirective.disabled = true;\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n    }"
        },
        {
          "type": "function",
          "name": "%AM19$%AM3$%AM0",
          "label": "%AM19$%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\ninstanceinvoke tooltipDirective.<@%unk/%unk: .show()>()\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>(0)\n%0 = instanceinvoke tooltipDirective.<@%unk/%unk: ._isTooltipVisible()>()\n%1 = staticinvoke <@%unk/%unk: .expect()>(%0)\ninstanceinvoke %1.<@%unk/%unk: .toBe()>(true)\n%2 = fixture.<@%unk/%unk: .componentInstance>\n%2.<@%unk/%unk: .message> = ''\n%3 = fixture.<@%unk/%unk: .changeDetectorRef>\ninstanceinvoke %3.<@%unk/%unk: .markForCheck()>()\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>(0)\n%4 = instanceinvoke tooltipDirective.<@%unk/%unk: ._isTooltipVisible()>()\n%5 = staticinvoke <@%unk/%unk: .expect()>(%4)\ninstanceinvoke %5.<@%unk/%unk: .toBe()>(false)\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      fixture.componentInstance.message = '';\n      fixture.changeDetectorRef.markForCheck();\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n    }"
        },
        {
          "type": "function",
          "name": "%AM21$%AM20$%AM3$%AM0",
          "label": "%AM21$%AM20$%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\n%0 = instanceinvoke tooltipDirective.<@%unk/%unk: ._isTooltipVisible()>()\n%1 = staticinvoke <@%unk/%unk: .expect()>(%0)\ninstanceinvoke %1.<@%unk/%unk: .toBe()>(false)\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n        expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      }"
        },
        {
          "type": "function",
          "name": "%AM20$%AM3$%AM0",
          "label": "%AM20$%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\nstaticinvoke <@ts_files/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)>(tooltipDirective, false)\ntooltipDelay = 1000\ninstanceinvoke tooltipDirective.<@%unk/%unk: .show()>(tooltipDelay)\n%0 = instanceinvoke tooltipDirective.<@%unk/%unk: ._isTooltipVisible()>()\n%1 = staticinvoke <@%unk/%unk: .expect()>(%0)\ninstanceinvoke %1.<@%unk/%unk: .toBe()>(false)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%2 = overlayContainerElement.<@%unk/%unk: .textContent>\n%3 = staticinvoke <@%unk/%unk: .expect()>(%2)\ninstanceinvoke %3.<@%unk/%unk: .toContain()>('')\ninstanceinvoke tooltipDirective.<@%unk/%unk: .hide()>()\n%4 = instanceinvoke fixture.<@%unk/%unk: .whenStable()>()\ninstanceinvoke %4.<@%unk/%unk: .then()>(%AM21$%AM20$%AM3$%AM0)\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      assertTooltipInstance(tooltipDirective, false);\n      const tooltipDelay = 1000;\n      tooltipDirective.show(tooltipDelay);\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      fixture.detectChanges();\n      expect(overlayContainerElement.textContent).toContain('');\n      tooltipDirective.hide();\n      fixture.whenStable().then(() => {\n        expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      });\n    }"
        },
        {
          "type": "function",
          "name": "%AM22$%AM3$%AM0",
          "label": "%AM22$%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\nstaticinvoke <@ts_files/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)>(tooltipDirective, false)\ntooltipDirective.<@%unk/%unk: .message> = undefined\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\ninstanceinvoke tooltipDirective.<@%unk/%unk: .show()>()\nstaticinvoke <@ts_files/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)>(tooltipDirective, false)\ntooltipDirective.<@%unk/%unk: .message> = null\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\ninstanceinvoke tooltipDirective.<@%unk/%unk: .show()>()\nstaticinvoke <@ts_files/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)>(tooltipDirective, false)\ntooltipDirective.<@%unk/%unk: .message> = ''\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\ninstanceinvoke tooltipDirective.<@%unk/%unk: .show()>()\nstaticinvoke <@ts_files/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)>(tooltipDirective, false)\ntooltipDirective.<@%unk/%unk: .message> = '   '\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\ninstanceinvoke tooltipDirective.<@%unk/%unk: .show()>()\nstaticinvoke <@ts_files/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)>(tooltipDirective, false)\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.message = undefined;\n      fixture.detectChanges();\n      tooltipDirective.show();\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.message = null;\n      fixture.detectChanges();\n      tooltipDirective.show();\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.message = '';\n      fixture.detectChanges();\n      tooltipDirective.show();\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.message = '   ';\n      fixture.detectChanges();\n      tooltipDirective.show();\n      assertTooltipInstance(tooltipDirective, false);\n    }"
        },
        {
          "type": "function",
          "name": "%AM23$%AM3$%AM0",
          "label": "%AM23$%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\ninstanceinvoke tooltipDirective.<@%unk/%unk: .show()>()\nstaticinvoke <@%unk/%unk: .tick()>(0)\n%0 = instanceinvoke tooltipDirective.<@%unk/%unk: ._isTooltipVisible()>()\n%1 = staticinvoke <@%unk/%unk: .expect()>(%0)\ninstanceinvoke %1.<@%unk/%unk: .toBe()>(true)\ntooltipDelay = 1000\ninstanceinvoke tooltipDirective.<@%unk/%unk: .hide()>(tooltipDelay)\n%2 = instanceinvoke tooltipDirective.<@%unk/%unk: ._isTooltipVisible()>()\n%3 = staticinvoke <@%unk/%unk: .expect()>(%2)\ninstanceinvoke %3.<@%unk/%unk: .toBe()>(true)\ninstanceinvoke tooltipDirective.<@%unk/%unk: .show()>()\nstaticinvoke <@%unk/%unk: .tick()>(tooltipDelay)\n%4 = instanceinvoke tooltipDirective.<@%unk/%unk: ._isTooltipVisible()>()\n%5 = staticinvoke <@%unk/%unk: .expect()>(%4)\ninstanceinvoke %5.<@%unk/%unk: .toBe()>(true)\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      tooltipDirective.show();\n      tick(0); // Tick for the show delay (default is 0)\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      // After hide called, a timeout delay is created that will to hide the tooltip.\n      const tooltipDelay = 1000;\n      tooltipDirective.hide(tooltipDelay);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      // Before delay time has passed, call show which should cancel intent to hide tooltip.\n      tooltipDirective.show();\n      tick(tooltipDelay);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n    }"
        },
        {
          "type": "function",
          "name": "%AM24$%AM3$%AM0",
          "label": "%AM24$%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\ntooltipDirective.<@%unk/%unk: .position> = 'below'\ninstanceinvoke tooltipDirective.<@%unk/%unk: .show()>()\nstaticinvoke <@%unk/%unk: .tick()>()\nstaticinvoke <@ts_files/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)>(tooltipDirective, true)\n%0 = tooltipDirective.<@%unk/%unk: ._overlayRef>\n%1 = staticinvoke <@%unk/%unk: .spyOn()>(%0, 'updatePosition')\n%2 = %1.<@%unk/%unk: .and>\ninstanceinvoke %2.<@%unk/%unk: .callThrough()>()\ntooltipDirective.<@%unk/%unk: .position> = 'above'\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>()\nstaticinvoke <@ts_files/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)>(tooltipDirective, true)\n%3 = tooltipDirective.<@%unk/%unk: ._overlayRef>\n%4 = %3.<@%unk/%unk: .updatePosition>\n%5 = staticinvoke <@%unk/%unk: .expect()>(%4)\ninstanceinvoke %5.<@%unk/%unk: .toHaveBeenCalled()>()\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      tooltipDirective.position = 'below';\n      tooltipDirective.show();\n      tick();\n      assertTooltipInstance(tooltipDirective, true);\n      spyOn(tooltipDirective._overlayRef!, 'updatePosition').and.callThrough();\n      tooltipDirective.position = 'above';\n      fixture.detectChanges();\n      tick();\n      assertTooltipInstance(tooltipDirective, true);\n      expect(tooltipDirective._overlayRef!.updatePosition).toHaveBeenCalled();\n    }"
        },
        {
          "type": "function",
          "name": "%AM25$%AM3$%AM0",
          "label": "%AM25$%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\ntooltipDirective.<@%unk/%unk: .position> = 'right'\ninstanceinvoke tooltipDirective.<@%unk/%unk: .show()>()\nstaticinvoke <@%unk/%unk: .tick()>()\nstaticinvoke <@ts_files/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)>(tooltipDirective, true)\n%0 = <any>tooltipDirective\n%1 = staticinvoke <@%unk/%unk: .spyOn()>(%0, '_updatePosition')\n%2 = %1.<@%unk/%unk: .and>\nspy = instanceinvoke %2.<@%unk/%unk: .callThrough()>()\n%3 = dir.<@%unk/%unk: .change>\ninstanceinvoke %3.<@%unk/%unk: .next()>('rtl')\nstaticinvoke <@ts_files/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)>(tooltipDirective, true)\n%4 = staticinvoke <@%unk/%unk: .expect()>(spy)\ninstanceinvoke %4.<@%unk/%unk: .toHaveBeenCalled()>()\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      tooltipDirective.position = 'right';\n      tooltipDirective.show();\n      tick();\n      assertTooltipInstance(tooltipDirective, true);\n      const spy = spyOn(tooltipDirective as any, '_updatePosition').and.callThrough();\n      dir.change.next('rtl');\n      assertTooltipInstance(tooltipDirective, true);\n      expect(spy).toHaveBeenCalled();\n    }"
        },
        {
          "type": "function",
          "name": "%AM27$%AM26$%AM3$%AM0",
          "label": "%AM27$%AM26$%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\ntooltipDirective.<@%unk/%unk: .position> = 'right'\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>()\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n        tooltipDirective.position = 'right';\n        fixture.detectChanges();\n        tick();\n      }"
        },
        {
          "type": "function",
          "name": "%AM26$%AM3$%AM0",
          "label": "%AM26$%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\ntooltipDirective.<@%unk/%unk: .position> = 'left'\ninstanceinvoke tooltipDirective.<@%unk/%unk: .show()>(0)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>()\ninstanceinvoke tooltipDirective.<@%unk/%unk: .hide()>(0)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>()\nstaticinvoke <@ts_files/139.ts: %dflt.finishCurrentTooltipAnimation(HTMLElement, boolean)>(overlayContainerElement, false)\n%0 = staticinvoke <@%unk/%unk: .expect()>(%AM27$%AM26$%AM3$%AM0)\n%1 = %0.<@%unk/%unk: .not>\ninstanceinvoke %1.<@%unk/%unk: .toThrow()>()\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      tooltipDirective.position = 'left';\n      tooltipDirective.show(0);\n      fixture.detectChanges();\n      tick();\n      tooltipDirective.hide(0);\n      fixture.detectChanges();\n      tick();\n      finishCurrentTooltipAnimation(overlayContainerElement, false);\n      expect(() => {\n        tooltipDirective.position = 'right';\n        fixture.detectChanges();\n        tick();\n      }).not.toThrow();\n    }"
        },
        {
          "type": "function",
          "name": "%AM28$%AM3$%AM0",
          "label": "%AM28$%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\nstaticinvoke <@ts_files/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)>(tooltipDirective, false)\ninstanceinvoke tooltipDirective.<@%unk/%unk: .show()>()\nstaticinvoke <@%unk/%unk: .tick()>(0)\n%0 = tooltipDirective.<@%unk/%unk: ._tooltipInstance>\n%1 = instanceinvoke %0.<@%unk/%unk: .isVisible()>()\n%2 = staticinvoke <@%unk/%unk: .expect()>(%1)\ninstanceinvoke %2.<@%unk/%unk: .toBe()>(true)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%3 = overlayContainerElement.<@%unk/%unk: .textContent>\n%4 = staticinvoke <@%unk/%unk: .expect()>(%3)\ninstanceinvoke %4.<@%unk/%unk: .toContain()>(initialTooltipMessage)\nnewMessage = 'new tooltip message'\ntooltipDirective.<@%unk/%unk: .message> = newMessage\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%5 = overlayContainerElement.<@%unk/%unk: .textContent>\n%6 = staticinvoke <@%unk/%unk: .expect()>(%5)\ninstanceinvoke %6.<@%unk/%unk: .toContain()>(newMessage)\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.show();\n      tick(0); // Tick for the show delay (default is 0)\n      expect(tooltipDirective._tooltipInstance!.isVisible()).toBe(true);\n      fixture.detectChanges();\n      expect(overlayContainerElement.textContent).toContain(initialTooltipMessage);\n      const newMessage = 'new tooltip message';\n      tooltipDirective.message = newMessage;\n      fixture.detectChanges();\n      expect(overlayContainerElement.textContent).toContain(newMessage);\n    }"
        },
        {
          "type": "function",
          "name": "%AM29$%AM3$%AM0",
          "label": "%AM29$%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\nstaticinvoke <@ts_files/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)>(tooltipDirective, false)\ninstanceinvoke tooltipDirective.<@%unk/%unk: .show()>()\nstaticinvoke <@%unk/%unk: .tick()>(0)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%0 = instanceinvoke overlayContainerElement.<@%unk/%unk: .querySelector()>('.mat-mdc-tooltip')\ntooltipElement = <HTMLElement>%0\n%1 = tooltipElement.<@%unk/%unk: .classList>\n%2 = staticinvoke <@%unk/%unk: .expect()>(%1)\n%3 = %2.<@%unk/%unk: .not>\ninstanceinvoke %3.<@%unk/%unk: .toContain()>('custom-one', 'Expected to not have the class before enabling matTooltipClass')\n%4 = tooltipElement.<@%unk/%unk: .classList>\n%5 = staticinvoke <@%unk/%unk: .expect()>(%4)\n%6 = %5.<@%unk/%unk: .not>\ninstanceinvoke %6.<@%unk/%unk: .toContain()>('custom-two', 'Expected to not have the class before enabling matTooltipClass')\n%7 = fixture.<@%unk/%unk: .componentInstance>\n%7.<@%unk/%unk: .showTooltipClass> = true\n%8 = fixture.<@%unk/%unk: .changeDetectorRef>\ninstanceinvoke %8.<@%unk/%unk: .markForCheck()>()\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%9 = instanceinvoke overlayContainerElement.<@%unk/%unk: .querySelector()>('.mat-mdc-tooltip')\ntooltipElement = <HTMLElement>%9\n%10 = tooltipElement.<@%unk/%unk: .classList>\n%11 = staticinvoke <@%unk/%unk: .expect()>(%10)\n%12 = instanceinvoke %11.<@%unk/%unk: .withContext()>('Expected to have the class after enabling matTooltipClass')\ninstanceinvoke %12.<@%unk/%unk: .toContain()>('custom-one')\n%13 = tooltipElement.<@%unk/%unk: .classList>\n%14 = staticinvoke <@%unk/%unk: .expect()>(%13)\n%15 = instanceinvoke %14.<@%unk/%unk: .withContext()>('Expected to have the class after enabling matTooltipClass')\ninstanceinvoke %15.<@%unk/%unk: .toContain()>('custom-two')\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.show();\n      tick(0); // Tick for the show delay (default is 0)\n      fixture.detectChanges();\n      // Make sure classes aren't prematurely added\n      let tooltipElement = overlayContainerElement.querySelector('.mat-mdc-tooltip') as HTMLElement;\n      expect(tooltipElement.classList).not.toContain(\n        'custom-one',\n        'Expected to not have the class before enabling matTooltipClass',\n      );\n      expect(tooltipElement.classList).not.toContain(\n        'custom-two',\n        'Expected to not have the class before enabling matTooltipClass',\n      );\n      // Enable the classes via ngClass syntax\n      fixture.componentInstance.showTooltipClass = true;\n      fixture.changeDetectorRef.markForCheck();\n      fixture.detectChanges();\n      // Make sure classes are correctly added\n      tooltipElement = overlayContainerElement.querySelector('.mat-mdc-tooltip') as HTMLElement;\n      expect(tooltipElement.classList)\n        .withContext('Expected to have the class after enabling matTooltipClass')\n        .toContain('custom-one');\n      expect(tooltipElement.classList)\n        .withContext('Expected to have the class after enabling matTooltipClass')\n        .toContain('custom-two');\n    }"
        },
        {
          "type": "function",
          "name": "%AM30$%AM3$%AM0",
          "label": "%AM30$%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\ninstanceinvoke tooltipDirective.<@%unk/%unk: .show()>()\nstaticinvoke <@%unk/%unk: .tick()>(0)\n%0 = instanceinvoke tooltipDirective.<@%unk/%unk: ._isTooltipVisible()>()\n%1 = staticinvoke <@%unk/%unk: .expect()>(%0)\ninstanceinvoke %1.<@%unk/%unk: .toBe()>(true)\ninstanceinvoke fixture.<@%unk/%unk: .destroy()>()\n%2 = overlayContainerElement.<@%unk/%unk: .childNodes>\n%3 = %2.<@%unk/%unk: .length>\n%4 = staticinvoke <@%unk/%unk: .expect()>(%3)\ninstanceinvoke %4.<@%unk/%unk: .toBe()>(0)\n%5 = overlayContainerElement.<@%unk/%unk: .textContent>\n%6 = staticinvoke <@%unk/%unk: .expect()>(%5)\ninstanceinvoke %6.<@%unk/%unk: .toBe()>('')\nstaticinvoke <@%unk/%unk: .flush()>()\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      tooltipDirective.show();\n      tick(0); // Tick for the show delay (default is 0)\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      fixture.destroy();\n      expect(overlayContainerElement.childNodes.length).toBe(0);\n      expect(overlayContainerElement.textContent).toBe('');\n      flush();\n    }"
        },
        {
          "type": "function",
          "name": "%AM31$%AM3$%AM0",
          "label": "%AM31$%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\ndynamicTooltipsDemoFixture = instanceinvoke TestBed.<@%unk/%unk: .createComponent()>(DynamicTooltipsDemo)\ndynamicTooltipsComponent = dynamicTooltipsDemoFixture.<@%unk/%unk: .componentInstance>\n%0 = newarray (string)[2]\n%0[0] = 'Tooltip One'\n%0[1] = 'Tooltip Two'\ndynamicTooltipsComponent.<@%unk/%unk: .tooltips> = %0\ninstanceinvoke dynamicTooltipsDemoFixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>()\n%1 = dynamicTooltipsDemoFixture.<@%unk/%unk: .nativeElement>\nbuttons = instanceinvoke %1.<@%unk/%unk: .querySelectorAll()>('button')\n%2 = buttons.<@%unk/%unk: .0>\nfirstButtonAria = instanceinvoke %2.<@%unk/%unk: .getAttribute()>('aria-describedby')\n%3 = '#' + firstButtonAria\n%4 = instanceinvoke document.<@%unk/%unk: .querySelector()>(%3)\n%5 = %4.<@%unk/%unk: .textContent>\n%6 = staticinvoke <@%unk/%unk: .expect()>(%5)\ninstanceinvoke %6.<@%unk/%unk: .toBe()>('Tooltip One')\n%7 = buttons.<@%unk/%unk: .1>\nsecondButtonAria = instanceinvoke %7.<@%unk/%unk: .getAttribute()>('aria-describedby')\n%8 = '#' + secondButtonAria\n%9 = instanceinvoke document.<@%unk/%unk: .querySelector()>(%8)\n%10 = %9.<@%unk/%unk: .textContent>\n%11 = staticinvoke <@%unk/%unk: .expect()>(%10)\ninstanceinvoke %11.<@%unk/%unk: .toBe()>('Tooltip Two')\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      const dynamicTooltipsDemoFixture = TestBed.createComponent(DynamicTooltipsDemo);\n      const dynamicTooltipsComponent = dynamicTooltipsDemoFixture.componentInstance;\n      dynamicTooltipsComponent.tooltips = ['Tooltip One', 'Tooltip Two'];\n      dynamicTooltipsDemoFixture.detectChanges();\n      tick();\n      const buttons = dynamicTooltipsDemoFixture.nativeElement.querySelectorAll('button');\n      const firstButtonAria = buttons[0].getAttribute('aria-describedby');\n      expect(document.querySelector(`#${firstButtonAria}`)!.textContent).toBe('Tooltip One');\n      const secondButtonAria = buttons[1].getAttribute('aria-describedby');\n      expect(document.querySelector(`#${secondButtonAria}`)!.textContent).toBe('Tooltip Two');\n    }"
        },
        {
          "type": "function",
          "name": "%AM32$%AM3$%AM0",
          "label": "%AM32$%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\nariaLabelFixture = instanceinvoke TestBed.<@%unk/%unk: .createComponent()>(DataBoundAriaLabelTooltip)\ninstanceinvoke ariaLabelFixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>()\n%0 = ariaLabelFixture.<@%unk/%unk: .nativeElement>\nbutton = instanceinvoke %0.<@%unk/%unk: .querySelector()>('button')\n%1 = instanceinvoke button.<@%unk/%unk: .getAttribute()>('aria-describedby')\n%2 = staticinvoke <@%unk/%unk: .expect()>(%1)\ninstanceinvoke %2.<@%unk/%unk: .toBeFalsy()>()\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      const ariaLabelFixture = TestBed.createComponent(DataBoundAriaLabelTooltip);\n      ariaLabelFixture.detectChanges();\n      tick();\n      const button = ariaLabelFixture.nativeElement.querySelector('button');\n      expect(button.getAttribute('aria-describedby')).toBeFalsy();\n    }"
        },
        {
          "type": "function",
          "name": "%AM33$%AM3$%AM0",
          "label": "%AM33$%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\n%0 = instanceinvoke buttonElement.<@%unk/%unk: .getAttribute()>('aria-describedby')\n%1 = staticinvoke <@%unk/%unk: .expect()>(%0)\ninstanceinvoke %1.<@%unk/%unk: .toBeTruthy()>()\n%2 = fixture.<@%unk/%unk: .componentInstance>\n%2.<@%unk/%unk: .tooltipDisabled> = true\n%3 = fixture.<@%unk/%unk: .changeDetectorRef>\ninstanceinvoke %3.<@%unk/%unk: .markForCheck()>()\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>()\n%4 = instanceinvoke buttonElement.<@%unk/%unk: .hasAttribute()>('aria-describedby')\n%5 = staticinvoke <@%unk/%unk: .expect()>(%4)\ninstanceinvoke %5.<@%unk/%unk: .toBe()>(false)\n%6 = fixture.<@%unk/%unk: .componentInstance>\n%6.<@%unk/%unk: .tooltipDisabled> = false\n%7 = fixture.<@%unk/%unk: .changeDetectorRef>\ninstanceinvoke %7.<@%unk/%unk: .markForCheck()>()\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>()\n%8 = instanceinvoke buttonElement.<@%unk/%unk: .getAttribute()>('aria-describedby')\n%9 = staticinvoke <@%unk/%unk: .expect()>(%8)\ninstanceinvoke %9.<@%unk/%unk: .toBeTruthy()>()\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      expect(buttonElement.getAttribute('aria-describedby')).toBeTruthy();\n      fixture.componentInstance.tooltipDisabled = true;\n      fixture.changeDetectorRef.markForCheck();\n      fixture.detectChanges();\n      tick();\n      expect(buttonElement.hasAttribute('aria-describedby')).toBe(false);\n      fixture.componentInstance.tooltipDisabled = false;\n      fixture.changeDetectorRef.markForCheck();\n      fixture.detectChanges();\n      tick();\n      expect(buttonElement.getAttribute('aria-describedby')).toBeTruthy();\n    }"
        },
        {
          "type": "function",
          "name": "%AM34$%AM3$%AM0",
          "label": "%AM34$%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\ninstanceinvoke tooltipDirective.<@%unk/%unk: .show()>()\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@ts_files/139.ts: %dflt.finishCurrentTooltipAnimation(HTMLElement, boolean)>(overlayContainerElement, true)\ntooltipDelay = 1000\ninstanceinvoke tooltipDirective.<@%unk/%unk: .hide()>()\nstaticinvoke <@%unk/%unk: .tick()>(tooltipDelay)\n%0 = fixture.<@%unk/%unk: .componentInstance>\n%0.<@%unk/%unk: .showButton> = false\n%1 = fixture.<@%unk/%unk: .changeDetectorRef>\ninstanceinvoke %1.<@%unk/%unk: .markForCheck()>()\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      tooltipDirective.show();\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      const tooltipDelay = 1000;\n      tooltipDirective.hide();\n      tick(tooltipDelay); // Change the tooltip state to hidden and trigger animation start\n      fixture.componentInstance.showButton = false;\n      fixture.changeDetectorRef.markForCheck();\n      fixture.detectChanges();\n    }"
        },
        {
          "type": "function",
          "name": "%AM35$%AM3$%AM0",
          "label": "%AM35$%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\ninstanceinvoke tooltipDirective.<@%unk/%unk: .show()>()\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@ts_files/139.ts: %dflt.finishCurrentTooltipAnimation(HTMLElement, boolean)>(overlayContainerElement, true)\nspy = instanceinvoke jasmine.<@%unk/%unk: .createSpy()>('complete spy')\n%0 = new @ts_files/139.ts: %AC$%dflt$%AM35$%AM3$%AM0$23\ninstanceinvoke %0.<@ts_files/139.ts: %AC$%dflt$%AM35$%AM3$%AM0$23.constructor()>()\n%1 = tooltipDirective.<@%unk/%unk: ._tooltipInstance>\n%2 = instanceinvoke %1.<@%unk/%unk: .afterHidden()>()\nsubscription = instanceinvoke %2.<@%unk/%unk: .subscribe()>(%0)\ninstanceinvoke tooltipDirective.<@%unk/%unk: .hide()>(0)\nstaticinvoke <@%unk/%unk: .tick()>(0)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%3 = staticinvoke <@%unk/%unk: .expect()>(spy)\ninstanceinvoke %3.<@%unk/%unk: .toHaveBeenCalled()>()\ninstanceinvoke subscription.<@%unk/%unk: .unsubscribe()>()\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      tooltipDirective.show();\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      const spy = jasmine.createSpy('complete spy');\n      const subscription = tooltipDirective\n        ._tooltipInstance!.afterHidden()\n        .subscribe({complete: spy});\n      tooltipDirective.hide(0);\n      tick(0);\n      fixture.detectChanges();\n      expect(spy).toHaveBeenCalled();\n      subscription.unsubscribe();\n    }"
        },
        {
          "type": "function",
          "name": "%AM36$%AM3$%AM0",
          "label": "%AM36$%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\ntooltipDirective.<@%unk/%unk: .position> = 'left'\n%0 = instanceinvoke tooltipDirective.<@%unk/%unk: ._getOrigin()>()\nleftOrigin = %0.<@%unk/%unk: .main>\ntooltipDirective.<@%unk/%unk: .position> = 'right'\n%1 = instanceinvoke tooltipDirective.<@%unk/%unk: ._getOrigin()>()\nrightOrigin = %1.<@%unk/%unk: .main>\ntooltipDirective.<@%unk/%unk: .position> = 'before'\n%2 = instanceinvoke tooltipDirective.<@%unk/%unk: ._getOrigin()>()\n%3 = %2.<@%unk/%unk: .main>\n%4 = staticinvoke <@%unk/%unk: .expect()>(%3)\ninstanceinvoke %4.<@%unk/%unk: .toEqual()>(leftOrigin)\ntooltipDirective.<@%unk/%unk: .position> = 'after'\n%5 = instanceinvoke tooltipDirective.<@%unk/%unk: ._getOrigin()>()\n%6 = %5.<@%unk/%unk: .main>\n%7 = staticinvoke <@%unk/%unk: .expect()>(%6)\ninstanceinvoke %7.<@%unk/%unk: .toEqual()>(rightOrigin)\ndir.<@%unk/%unk: .value> = 'rtl'\ntooltipDirective.<@%unk/%unk: .position> = 'before'\n%8 = instanceinvoke tooltipDirective.<@%unk/%unk: ._getOrigin()>()\n%9 = %8.<@%unk/%unk: .main>\n%10 = staticinvoke <@%unk/%unk: .expect()>(%9)\ninstanceinvoke %10.<@%unk/%unk: .toEqual()>(leftOrigin)\ntooltipDirective.<@%unk/%unk: .position> = 'after'\n%11 = instanceinvoke tooltipDirective.<@%unk/%unk: ._getOrigin()>()\n%12 = %11.<@%unk/%unk: .main>\n%13 = staticinvoke <@%unk/%unk: .expect()>(%12)\ninstanceinvoke %13.<@%unk/%unk: .toEqual()>(rightOrigin)\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      tooltipDirective.position = 'left';\n      const leftOrigin = tooltipDirective._getOrigin().main;\n      tooltipDirective.position = 'right';\n      const rightOrigin = tooltipDirective._getOrigin().main;\n      // Test expectations in LTR\n      tooltipDirective.position = 'before';\n      expect(tooltipDirective._getOrigin().main).toEqual(leftOrigin);\n      tooltipDirective.position = 'after';\n      expect(tooltipDirective._getOrigin().main).toEqual(rightOrigin);\n      // Test expectations in RTL\n      dir.value = 'rtl';\n      tooltipDirective.position = 'before';\n      expect(tooltipDirective._getOrigin().main).toEqual(leftOrigin);\n      tooltipDirective.position = 'after';\n      expect(tooltipDirective._getOrigin().main).toEqual(rightOrigin);\n    }"
        },
        {
          "type": "function",
          "name": "%AM37$%AM3$%AM0",
          "label": "%AM37$%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\ntooltipDirective.<@%unk/%unk: .position> = 'left'\n%0 = instanceinvoke tooltipDirective.<@%unk/%unk: ._getOverlayPosition()>()\nleftOverlayPosition = %0.<@%unk/%unk: .main>\ntooltipDirective.<@%unk/%unk: .position> = 'right'\n%1 = instanceinvoke tooltipDirective.<@%unk/%unk: ._getOverlayPosition()>()\nrightOverlayPosition = %1.<@%unk/%unk: .main>\ntooltipDirective.<@%unk/%unk: .position> = 'before'\n%2 = instanceinvoke tooltipDirective.<@%unk/%unk: ._getOverlayPosition()>()\n%3 = %2.<@%unk/%unk: .main>\n%4 = staticinvoke <@%unk/%unk: .expect()>(%3)\ninstanceinvoke %4.<@%unk/%unk: .toEqual()>(leftOverlayPosition)\ntooltipDirective.<@%unk/%unk: .position> = 'after'\n%5 = instanceinvoke tooltipDirective.<@%unk/%unk: ._getOverlayPosition()>()\n%6 = %5.<@%unk/%unk: .main>\n%7 = staticinvoke <@%unk/%unk: .expect()>(%6)\ninstanceinvoke %7.<@%unk/%unk: .toEqual()>(rightOverlayPosition)\ndir.<@%unk/%unk: .value> = 'rtl'\ntooltipDirective.<@%unk/%unk: .position> = 'before'\n%8 = instanceinvoke tooltipDirective.<@%unk/%unk: ._getOverlayPosition()>()\n%9 = %8.<@%unk/%unk: .main>\n%10 = staticinvoke <@%unk/%unk: .expect()>(%9)\ninstanceinvoke %10.<@%unk/%unk: .toEqual()>(leftOverlayPosition)\ntooltipDirective.<@%unk/%unk: .position> = 'after'\n%11 = instanceinvoke tooltipDirective.<@%unk/%unk: ._getOverlayPosition()>()\n%12 = %11.<@%unk/%unk: .main>\n%13 = staticinvoke <@%unk/%unk: .expect()>(%12)\ninstanceinvoke %13.<@%unk/%unk: .toEqual()>(rightOverlayPosition)\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      tooltipDirective.position = 'left';\n      const leftOverlayPosition = tooltipDirective._getOverlayPosition().main;\n      tooltipDirective.position = 'right';\n      const rightOverlayPosition = tooltipDirective._getOverlayPosition().main;\n      // Test expectations in LTR\n      tooltipDirective.position = 'before';\n      expect(tooltipDirective._getOverlayPosition().main).toEqual(leftOverlayPosition);\n      tooltipDirective.position = 'after';\n      expect(tooltipDirective._getOverlayPosition().main).toEqual(rightOverlayPosition);\n      // Test expectations in RTL\n      dir.value = 'rtl';\n      tooltipDirective.position = 'before';\n      expect(tooltipDirective._getOverlayPosition().main).toEqual(leftOverlayPosition);\n      tooltipDirective.position = 'after';\n      expect(tooltipDirective._getOverlayPosition().main).toEqual(rightOverlayPosition);\n    }"
        },
        {
          "type": "function",
          "name": "%AM39$%AM38$%AM3$%AM0",
          "label": "%AM39$%AM38$%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\n%0 = fixture.<@%unk/%unk: .componentInstance>\n%0.<@%unk/%unk: .position> = 'everywhere'\n%1 = fixture.<@%unk/%unk: .changeDetectorRef>\ninstanceinvoke %1.<@%unk/%unk: .markForCheck()>()\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\ninstanceinvoke tooltipDirective.<@%unk/%unk: .show()>()\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n        fixture.componentInstance.position = 'everywhere';\n        fixture.changeDetectorRef.markForCheck();\n        fixture.detectChanges();\n        tooltipDirective.show();\n      }"
        },
        {
          "type": "function",
          "name": "%AM38$%AM3$%AM0",
          "label": "%AM38$%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\n%0 = staticinvoke <@%unk/%unk: .expect()>(%AM39$%AM38$%AM3$%AM0)\ninstanceinvoke %0.<@%unk/%unk: .toThrowError()>('Tooltip position \"everywhere\" is invalid.')\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      expect(() => {\n        fixture.componentInstance.position = 'everywhere';\n        fixture.changeDetectorRef.markForCheck();\n        fixture.detectChanges();\n        tooltipDirective.show();\n      }).toThrowError('Tooltip position \"everywhere\" is invalid.');\n    }"
        },
        {
          "type": "function",
          "name": "%AM40$%AM3$%AM0",
          "label": "%AM40$%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\ndir.<@%unk/%unk: .value> = 'rtl'\ninstanceinvoke tooltipDirective.<@%unk/%unk: .show()>()\nstaticinvoke <@%unk/%unk: .tick()>(0)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\ntooltipWrapper = instanceinvoke overlayContainerElement.<@%unk/%unk: .querySelector()>('.cdk-overlay-connected-position-bounding-box')\n%0 = staticinvoke <@%unk/%unk: .expect()>(tooltipWrapper)\n%1 = instanceinvoke %0.<@%unk/%unk: .withContext()>('Expected tooltip to be shown.')\ninstanceinvoke %1.<@%unk/%unk: .toBeTruthy()>()\n%2 = instanceinvoke tooltipWrapper.<@%unk/%unk: .getAttribute()>('dir')\n%3 = staticinvoke <@%unk/%unk: .expect()>(%2)\n%4 = instanceinvoke %3.<@%unk/%unk: .withContext()>('Expected tooltip to be in RTL mode.')\ninstanceinvoke %4.<@%unk/%unk: .toBe()>('rtl')\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      dir.value = 'rtl';\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      const tooltipWrapper = overlayContainerElement.querySelector(\n        '.cdk-overlay-connected-position-bounding-box',\n      )!;\n      expect(tooltipWrapper).withContext('Expected tooltip to be shown.').toBeTruthy();\n      expect(tooltipWrapper.getAttribute('dir'))\n        .withContext('Expected tooltip to be in RTL mode.')\n        .toBe('rtl');\n    }"
        },
        {
          "type": "function",
          "name": "%AM41$%AM3$%AM0",
          "label": "%AM41$%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\ndir.<@%unk/%unk: .value> = 'rtl'\ninstanceinvoke tooltipDirective.<@%unk/%unk: .show()>()\nstaticinvoke <@%unk/%unk: .tick()>(0)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@ts_files/139.ts: %dflt.finishCurrentTooltipAnimation(HTMLElement, boolean)>(overlayContainerElement, true)\ntooltipWrapper = instanceinvoke overlayContainerElement.<@%unk/%unk: .querySelector()>('.cdk-overlay-connected-position-bounding-box')\n%0 = instanceinvoke tooltipWrapper.<@%unk/%unk: .getAttribute()>('dir')\n%1 = staticinvoke <@%unk/%unk: .expect()>(%0)\n%2 = instanceinvoke %1.<@%unk/%unk: .withContext()>('Expected tooltip to be in RTL.')\ninstanceinvoke %2.<@%unk/%unk: .toBe()>('rtl')\ninstanceinvoke tooltipDirective.<@%unk/%unk: .hide()>(0)\nstaticinvoke <@%unk/%unk: .tick()>(0)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@ts_files/139.ts: %dflt.finishCurrentTooltipAnimation(HTMLElement, boolean)>(overlayContainerElement, false)\ndir.<@%unk/%unk: .value> = 'ltr'\ninstanceinvoke tooltipDirective.<@%unk/%unk: .show()>()\nstaticinvoke <@%unk/%unk: .tick()>(0)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@ts_files/139.ts: %dflt.finishCurrentTooltipAnimation(HTMLElement, boolean)>(overlayContainerElement, true)\ntooltipWrapper = instanceinvoke overlayContainerElement.<@%unk/%unk: .querySelector()>('.cdk-overlay-connected-position-bounding-box')\n%3 = instanceinvoke tooltipWrapper.<@%unk/%unk: .getAttribute()>('dir')\n%4 = staticinvoke <@%unk/%unk: .expect()>(%3)\n%5 = instanceinvoke %4.<@%unk/%unk: .withContext()>('Expected tooltip to be in LTR.')\ninstanceinvoke %5.<@%unk/%unk: .toBe()>('ltr')\nstaticinvoke <@%unk/%unk: .flush()>()\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      dir.value = 'rtl';\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      let tooltipWrapper = overlayContainerElement.querySelector(\n        '.cdk-overlay-connected-position-bounding-box',\n      )!;\n      expect(tooltipWrapper.getAttribute('dir'))\n        .withContext('Expected tooltip to be in RTL.')\n        .toBe('rtl');\n      tooltipDirective.hide(0);\n      tick(0);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, false);\n      dir.value = 'ltr';\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      tooltipWrapper = overlayContainerElement.querySelector(\n        '.cdk-overlay-connected-position-bounding-box',\n      )!;\n      expect(tooltipWrapper.getAttribute('dir'))\n        .withContext('Expected tooltip to be in LTR.')\n        .toBe('ltr');\n      flush();\n    }"
        },
        {
          "type": "function",
          "name": "%AM42$%AM3$%AM0",
          "label": "%AM42$%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\n%0 = fixture.<@%unk/%unk: .componentInstance>\n%0.<@%unk/%unk: .message> = 100\n%1 = fixture.<@%unk/%unk: .changeDetectorRef>\ninstanceinvoke %1.<@%unk/%unk: .markForCheck()>()\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%2 = tooltipDirective.<@%unk/%unk: .message>\n%3 = staticinvoke <@%unk/%unk: .expect()>(%2)\ninstanceinvoke %3.<@%unk/%unk: .toBe()>('100')\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      fixture.componentInstance.message = 100;\n      fixture.changeDetectorRef.markForCheck();\n      fixture.detectChanges();\n      expect(tooltipDirective.message).toBe('100');\n    }"
        },
        {
          "type": "function",
          "name": "%AM43$%AM3$%AM0",
          "label": "%AM43$%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\ninstanceinvoke tooltipDirective.<@%unk/%unk: .show()>()\nstaticinvoke <@%unk/%unk: .tick()>(0)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@ts_files/139.ts: %dflt.finishCurrentTooltipAnimation(HTMLElement, boolean)>(overlayContainerElement, true)\n%0 = instanceinvoke tooltipDirective.<@%unk/%unk: ._isTooltipVisible()>()\n%1 = staticinvoke <@%unk/%unk: .expect()>(%0)\ninstanceinvoke %1.<@%unk/%unk: .toBe()>(true)\n%2 = overlayContainerElement.<@%unk/%unk: .textContent>\n%3 = staticinvoke <@%unk/%unk: .expect()>(%2)\ninstanceinvoke %3.<@%unk/%unk: .toContain()>(initialTooltipMessage)\n%4 = document.<@%unk/%unk: .body>\ninstanceinvoke %4.<@%unk/%unk: .click()>()\nstaticinvoke <@%unk/%unk: .tick()>(0)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@ts_files/139.ts: %dflt.finishCurrentTooltipAnimation(HTMLElement, boolean)>(overlayContainerElement, false)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%5 = instanceinvoke tooltipDirective.<@%unk/%unk: ._isTooltipVisible()>()\n%6 = staticinvoke <@%unk/%unk: .expect()>(%5)\ninstanceinvoke %6.<@%unk/%unk: .toBe()>(false)\n%7 = overlayContainerElement.<@%unk/%unk: .textContent>\n%8 = staticinvoke <@%unk/%unk: .expect()>(%7)\ninstanceinvoke %8.<@%unk/%unk: .toBe()>('')\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      expect(overlayContainerElement.textContent).toContain(initialTooltipMessage);\n      document.body.click();\n      tick(0);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, false);\n      fixture.detectChanges();\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      expect(overlayContainerElement.textContent).toBe('');\n    }"
        },
        {
          "type": "function",
          "name": "%AM44$%AM3$%AM0",
          "label": "%AM44$%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\ninstanceinvoke tooltipDirective.<@%unk/%unk: .show()>()\nstaticinvoke <@%unk/%unk: .tick()>(0)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@ts_files/139.ts: %dflt.finishCurrentTooltipAnimation(HTMLElement, boolean)>(overlayContainerElement, true)\n%0 = instanceinvoke tooltipDirective.<@%unk/%unk: ._isTooltipVisible()>()\n%1 = staticinvoke <@%unk/%unk: .expect()>(%0)\ninstanceinvoke %1.<@%unk/%unk: .toBe()>(true)\n%2 = overlayContainerElement.<@%unk/%unk: .textContent>\n%3 = staticinvoke <@%unk/%unk: .expect()>(%2)\ninstanceinvoke %3.<@%unk/%unk: .toContain()>(initialTooltipMessage)\n%4 = document.<@%unk/%unk: .body>\nstaticinvoke <@%unk/%unk: .dispatchFakeEvent()>(%4, 'auxclick')\nstaticinvoke <@%unk/%unk: .tick()>(0)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@ts_files/139.ts: %dflt.finishCurrentTooltipAnimation(HTMLElement, boolean)>(overlayContainerElement, false)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%5 = instanceinvoke tooltipDirective.<@%unk/%unk: ._isTooltipVisible()>()\n%6 = staticinvoke <@%unk/%unk: .expect()>(%5)\ninstanceinvoke %6.<@%unk/%unk: .toBe()>(false)\n%7 = overlayContainerElement.<@%unk/%unk: .textContent>\n%8 = staticinvoke <@%unk/%unk: .expect()>(%7)\ninstanceinvoke %8.<@%unk/%unk: .toBe()>('')\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      expect(overlayContainerElement.textContent).toContain(initialTooltipMessage);\n      dispatchFakeEvent(document.body, 'auxclick');\n      tick(0);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, false);\n      fixture.detectChanges();\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      expect(overlayContainerElement.textContent).toBe('');\n    }"
        },
        {
          "type": "function",
          "name": "%AM45$%AM3$%AM0",
          "label": "%AM45$%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\ninstanceinvoke tooltipDirective.<@%unk/%unk: .show()>()\nstaticinvoke <@%unk/%unk: .tick()>(0)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%0 = document.<@%unk/%unk: .body>\ninstanceinvoke %0.<@%unk/%unk: .click()>()\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>(500)\nstaticinvoke <@ts_files/139.ts: %dflt.finishCurrentTooltipAnimation(HTMLElement, boolean)>(overlayContainerElement, true)\n%1 = overlayContainerElement.<@%unk/%unk: .textContent>\n%2 = staticinvoke <@%unk/%unk: .expect()>(%1)\ninstanceinvoke %2.<@%unk/%unk: .toContain()>(initialTooltipMessage)\nstaticinvoke <@%unk/%unk: .flush()>()\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      document.body.click();\n      fixture.detectChanges();\n      tick(500);\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      expect(overlayContainerElement.textContent).toContain(initialTooltipMessage);\n      flush();\n    }"
        },
        {
          "type": "function",
          "name": "%AM46$%AM3$%AM0",
          "label": "%AM46$%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\ninstanceinvoke tooltipDirective.<@%unk/%unk: .show()>()\nstaticinvoke <@%unk/%unk: .tick()>(0)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>(500)\n%0 = instanceinvoke tooltipDirective.<@%unk/%unk: ._isTooltipVisible()>()\n%1 = staticinvoke <@%unk/%unk: .expect()>(%0)\ninstanceinvoke %1.<@%unk/%unk: .toBe()>(true)\n%2 = overlayContainerElement.<@%unk/%unk: .textContent>\n%3 = staticinvoke <@%unk/%unk: .expect()>(%2)\ninstanceinvoke %3.<@%unk/%unk: .toContain()>(initialTooltipMessage)\n%4 = document.<@%unk/%unk: .body>\nstaticinvoke <@%unk/%unk: .dispatchKeyboardEvent()>(%4, 'keydown', ESCAPE)\nstaticinvoke <@%unk/%unk: .tick()>(0)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>(500)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@ts_files/139.ts: %dflt.finishCurrentTooltipAnimation(HTMLElement, boolean)>(overlayContainerElement, false)\n%5 = instanceinvoke tooltipDirective.<@%unk/%unk: ._isTooltipVisible()>()\n%6 = staticinvoke <@%unk/%unk: .expect()>(%5)\ninstanceinvoke %6.<@%unk/%unk: .toBe()>(false)\n%7 = overlayContainerElement.<@%unk/%unk: .textContent>\n%8 = staticinvoke <@%unk/%unk: .expect()>(%7)\ninstanceinvoke %8.<@%unk/%unk: .toBe()>('')\nstaticinvoke <@%unk/%unk: .flush()>()\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      tick(500);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      expect(overlayContainerElement.textContent).toContain(initialTooltipMessage);\n      dispatchKeyboardEvent(document.body, 'keydown', ESCAPE);\n      tick(0);\n      fixture.detectChanges();\n      tick(500);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, false);\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      expect(overlayContainerElement.textContent).toBe('');\n      flush();\n    }"
        },
        {
          "type": "function",
          "name": "%AM48$%AM47$%AM3$%AM0",
          "label": "%AM48$%AM47$%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\n%0 = document.<@%unk/%unk: .body>\nstaticinvoke <@%unk/%unk: .dispatchKeyboardEvent()>(%0, 'keydown', ESCAPE)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n        dispatchKeyboardEvent(document.body, 'keydown', ESCAPE);\n        fixture.detectChanges();\n      }"
        },
        {
          "type": "function",
          "name": "%AM47$%AM3$%AM0",
          "label": "%AM47$%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\n%0 = staticinvoke <@%unk/%unk: .expect()>(%AM48$%AM47$%AM3$%AM0)\n%1 = %0.<@%unk/%unk: .not>\ninstanceinvoke %1.<@%unk/%unk: .toThrow()>()\nstaticinvoke <@%unk/%unk: .flush()>()\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      expect(() => {\n        dispatchKeyboardEvent(document.body, 'keydown', ESCAPE);\n        fixture.detectChanges();\n      }).not.toThrow();\n      // Flush due to the additional tick that is necessary for the FocusMonitor.\n      flush();\n    }"
        },
        {
          "type": "function",
          "name": "%AM49$%AM3$%AM0",
          "label": "%AM49$%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\ninstanceinvoke tooltipDirective.<@%unk/%unk: .show()>()\nstaticinvoke <@%unk/%unk: .tick()>(0)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%0 = document.<@%unk/%unk: .body>\nevent = staticinvoke <@%unk/%unk: .dispatchKeyboardEvent()>(%0, 'keydown', ESCAPE)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .flush()>()\n%1 = event.<@%unk/%unk: .defaultPrevented>\n%2 = staticinvoke <@%unk/%unk: .expect()>(%1)\ninstanceinvoke %2.<@%unk/%unk: .toBe()>(true)\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      const event = dispatchKeyboardEvent(document.body, 'keydown', ESCAPE);\n      fixture.detectChanges();\n      flush();\n      expect(event.defaultPrevented).toBe(true);\n    }"
        },
        {
          "type": "function",
          "name": "%AM50$%AM3$%AM0",
          "label": "%AM50$%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\ninstanceinvoke tooltipDirective.<@%unk/%unk: .show()>()\nstaticinvoke <@%unk/%unk: .tick()>(0)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%0 = new @ts_files/139.ts: %AC$%dflt$%AM50$%AM3$%AM0$24\ninstanceinvoke %0.<@ts_files/139.ts: %AC$%dflt$%AM50$%AM3$%AM0$24.constructor()>()\nevent = staticinvoke <@%unk/%unk: .createKeyboardEvent()>('keydown', ESCAPE, undefined, %0)\n%1 = document.<@%unk/%unk: .body>\nstaticinvoke <@%unk/%unk: .dispatchEvent()>(%1, event)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .flush()>()\n%2 = event.<@%unk/%unk: .defaultPrevented>\n%3 = staticinvoke <@%unk/%unk: .expect()>(%2)\ninstanceinvoke %3.<@%unk/%unk: .toBe()>(false)\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      const event = createKeyboardEvent('keydown', ESCAPE, undefined, {alt: true});\n      dispatchEvent(document.body, event);\n      fixture.detectChanges();\n      flush();\n      expect(event.defaultPrevented).toBe(false);\n    }"
        },
        {
          "type": "function",
          "name": "%AM51$%AM3$%AM0",
          "label": "%AM51$%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\nstaticinvoke <@%unk/%unk: .patchElementFocus()>(buttonElement)\nstaticinvoke <@ts_files/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)>(tooltipDirective, false)\ninstanceinvoke focusMonitor.<@%unk/%unk: .focusVia()>(buttonElement, 'program')\nstaticinvoke <@%unk/%unk: .tick()>(0)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>(500)\n%0 = instanceinvoke overlayContainerElement.<@%unk/%unk: .querySelector()>('.mat-mdc-tooltip')\n%1 = staticinvoke <@%unk/%unk: .expect()>(%0)\ninstanceinvoke %1.<@%unk/%unk: .toBeNull()>()\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      patchElementFocus(buttonElement);\n      assertTooltipInstance(tooltipDirective, false);\n      focusMonitor.focusVia(buttonElement, 'program');\n      tick(0);\n      fixture.detectChanges();\n      tick(500);\n      expect(overlayContainerElement.querySelector('.mat-mdc-tooltip')).toBeNull();\n    }"
        },
        {
          "type": "function",
          "name": "%AM52$%AM3$%AM0",
          "label": "%AM52$%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\nstaticinvoke <@%unk/%unk: .patchElementFocus()>(buttonElement)\nstaticinvoke <@ts_files/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)>(tooltipDirective, false)\ninstanceinvoke focusMonitor.<@%unk/%unk: .focusVia()>(buttonElement, 'mouse')\nstaticinvoke <@%unk/%unk: .tick()>(0)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>(500)\n%0 = instanceinvoke overlayContainerElement.<@%unk/%unk: .querySelector()>('.mat-mdc-tooltip')\n%1 = staticinvoke <@%unk/%unk: .expect()>(%0)\ninstanceinvoke %1.<@%unk/%unk: .toBeNull()>()\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      patchElementFocus(buttonElement);\n      assertTooltipInstance(tooltipDirective, false);\n      focusMonitor.focusVia(buttonElement, 'mouse');\n      tick(0);\n      fixture.detectChanges();\n      tick(500);\n      expect(overlayContainerElement.querySelector('.mat-mdc-tooltip')).toBeNull();\n    }"
        },
        {
          "type": "function",
          "name": "%AM53$%AM3$%AM0",
          "label": "%AM53$%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\nstaticinvoke <@%unk/%unk: .patchElementFocus()>(buttonElement)\nstaticinvoke <@ts_files/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)>(tooltipDirective, false)\ninstanceinvoke focusMonitor.<@%unk/%unk: .focusVia()>(buttonElement, 'touch')\nstaticinvoke <@%unk/%unk: .tick()>(0)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>(500)\n%0 = instanceinvoke overlayContainerElement.<@%unk/%unk: .querySelector()>('.mat-mdc-tooltip')\n%1 = staticinvoke <@%unk/%unk: .expect()>(%0)\ninstanceinvoke %1.<@%unk/%unk: .toBeNull()>()\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      patchElementFocus(buttonElement);\n      assertTooltipInstance(tooltipDirective, false);\n      focusMonitor.focusVia(buttonElement, 'touch');\n      tick(0);\n      fixture.detectChanges();\n      tick(500);\n      expect(overlayContainerElement.querySelector('.mat-mdc-tooltip')).toBeNull();\n    }"
        },
        {
          "type": "function",
          "name": "%AM54$%AM3$%AM0",
          "label": "%AM54$%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\ninstanceinvoke tooltipDirective.<@%unk/%unk: .show()>()\nstaticinvoke <@%unk/%unk: .tick()>(0)\n%0 = instanceinvoke tooltipDirective.<@%unk/%unk: ._isTooltipVisible()>()\n%1 = staticinvoke <@%unk/%unk: .expect()>(%0)\ninstanceinvoke %1.<@%unk/%unk: .toBe()>(true)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@ts_files/139.ts: %dflt.finishCurrentTooltipAnimation(HTMLElement, boolean)>(overlayContainerElement, true)\noverlayRef = tooltipDirective.<@%unk/%unk: ._overlayRef>\n%2 = staticinvoke <@%unk/%unk: .spyOn()>(overlayRef, 'detach')\n%3 = %2.<@%unk/%unk: .and>\ninstanceinvoke %3.<@%unk/%unk: .callThrough()>()\ninstanceinvoke tooltipDirective.<@%unk/%unk: .show()>()\nstaticinvoke <@%unk/%unk: .tick()>(0)\n%4 = instanceinvoke tooltipDirective.<@%unk/%unk: ._isTooltipVisible()>()\n%5 = staticinvoke <@%unk/%unk: .expect()>(%4)\ninstanceinvoke %5.<@%unk/%unk: .toBe()>(true)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@ts_files/139.ts: %dflt.finishCurrentTooltipAnimation(HTMLElement, boolean)>(overlayContainerElement, true)\n%6 = overlayRef.<@%unk/%unk: .detach>\n%7 = staticinvoke <@%unk/%unk: .expect()>(%6)\n%8 = %7.<@%unk/%unk: .not>\ninstanceinvoke %8.<@%unk/%unk: .toHaveBeenCalled()>()\nstaticinvoke <@%unk/%unk: .flush()>()\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      tooltipDirective.show();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      const overlayRef = tooltipDirective._overlayRef!;\n      spyOn(overlayRef, 'detach').and.callThrough();\n      tooltipDirective.show();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      expect(overlayRef.detach).not.toHaveBeenCalled();\n      flush();\n    }"
        },
        {
          "type": "function",
          "name": "%setPositionAndShow$%AM55$%AM3$%AM0",
          "label": "%setPositionAndShow$%AM55$%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "position = parameter0: TooltipPosition\nthis = this: @ts_files/139.ts: %dflt\ninstanceinvoke tooltipDirective.<@%unk/%unk: .hide()>(0)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>(0)\ntooltipDirective.<@%unk/%unk: .position> = position\ninstanceinvoke tooltipDirective.<@%unk/%unk: .show()>(0)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>(0)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>(500)\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "function setPositionAndShow(position: TooltipPosition) {\n        tooltipDirective.hide(0);\n        fixture.detectChanges();\n        tick(0);\n        tooltipDirective.position = position;\n        tooltipDirective.show(0);\n        fixture.detectChanges();\n        tick(0);\n        fixture.detectChanges();\n        tick(500);\n      }"
        },
        {
          "type": "function",
          "name": "%AM55$%AM3$%AM0",
          "label": "%AM55$%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\n%0 = buttonElement.<@%unk/%unk: .style>\n%0.<@%unk/%unk: .position> = 'fixed'\n%2 = buttonElement.<@%unk/%unk: .style>\n%2.<@%unk/%unk: .left> = '200px'\n%3 = %2.<@%unk/%unk: .left>\n%1 = buttonElement.<@%unk/%unk: .style>\n%1.<@%unk/%unk: .top> = %3\n%4 = fixture.<@%unk/%unk: .componentInstance>\n%4.<@%unk/%unk: .message> = 'hi'\n%5 = fixture.<@%unk/%unk: .changeDetectorRef>\ninstanceinvoke %5.<@%unk/%unk: .markForCheck()>()\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .setPositionAndShow()>('below')\n%6 = tooltipDirective.<@%unk/%unk: ._overlayRef>\n%7 = %6.<@%unk/%unk: .overlayElement>\nclassList = %7.<@%unk/%unk: .classList>\n%8 = staticinvoke <@%unk/%unk: .expect()>(classList)\ninstanceinvoke %8.<@%unk/%unk: .toContain()>('mat-mdc-tooltip-panel-below')\nstaticinvoke <@%unk/%unk: .setPositionAndShow()>('above')\n%9 = staticinvoke <@%unk/%unk: .expect()>(classList)\n%10 = %9.<@%unk/%unk: .not>\ninstanceinvoke %10.<@%unk/%unk: .toContain()>('mat-mdc-tooltip-panel-below')\n%11 = staticinvoke <@%unk/%unk: .expect()>(classList)\ninstanceinvoke %11.<@%unk/%unk: .toContain()>('mat-mdc-tooltip-panel-above')\nstaticinvoke <@%unk/%unk: .setPositionAndShow()>('left')\n%12 = staticinvoke <@%unk/%unk: .expect()>(classList)\n%13 = %12.<@%unk/%unk: .not>\ninstanceinvoke %13.<@%unk/%unk: .toContain()>('mat-mdc-tooltip-panel-above')\n%14 = staticinvoke <@%unk/%unk: .expect()>(classList)\ninstanceinvoke %14.<@%unk/%unk: .toContain()>('mat-mdc-tooltip-panel-left')\nstaticinvoke <@%unk/%unk: .setPositionAndShow()>('right')\n%15 = staticinvoke <@%unk/%unk: .expect()>(classList)\n%16 = %15.<@%unk/%unk: .not>\ninstanceinvoke %16.<@%unk/%unk: .toContain()>('mat-mdc-tooltip-panel-left')\n%17 = staticinvoke <@%unk/%unk: .expect()>(classList)\ninstanceinvoke %17.<@%unk/%unk: .toContain()>('mat-mdc-tooltip-panel-right')\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      // Move the element so that the primary position is always used.\n      buttonElement.style.position = 'fixed';\n      buttonElement.style.top = buttonElement.style.left = '200px';\n      fixture.componentInstance.message = 'hi';\n      fixture.changeDetectorRef.markForCheck();\n      fixture.detectChanges();\n      setPositionAndShow('below');\n      const classList = tooltipDirective._overlayRef!.overlayElement.classList;\n      expect(classList).toContain('mat-mdc-tooltip-panel-below');\n      setPositionAndShow('above');\n      expect(classList).not.toContain('mat-mdc-tooltip-panel-below');\n      expect(classList).toContain('mat-mdc-tooltip-panel-above');\n      setPositionAndShow('left');\n      expect(classList).not.toContain('mat-mdc-tooltip-panel-above');\n      expect(classList).toContain('mat-mdc-tooltip-panel-left');\n      setPositionAndShow('right');\n      expect(classList).not.toContain('mat-mdc-tooltip-panel-left');\n      expect(classList).toContain('mat-mdc-tooltip-panel-right');\n      function setPositionAndShow(position: TooltipPosition) {\n        tooltipDirective.hide(0);\n        fixture.detectChanges();\n        tick(0);\n        tooltipDirective.position = position;\n        tooltipDirective.show(0);\n        fixture.detectChanges();\n        tick(0);\n        fixture.detectChanges();\n        tick(500);\n      }\n    }"
        },
        {
          "type": "function",
          "name": "%AM56$%AM3$%AM0",
          "label": "%AM56$%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\n%0 = buttonElement.<@%unk/%unk: .style>\n%0.<@%unk/%unk: .position> = 'fixed'\n%2 = buttonElement.<@%unk/%unk: .style>\n%2.<@%unk/%unk: .left> = '200px'\n%3 = %2.<@%unk/%unk: .left>\n%1 = buttonElement.<@%unk/%unk: .style>\n%1.<@%unk/%unk: .top> = %3\n%4 = fixture.<@%unk/%unk: .componentInstance>\n%4.<@%unk/%unk: .message> = 'hi'\n%5 = fixture.<@%unk/%unk: .changeDetectorRef>\ninstanceinvoke %5.<@%unk/%unk: .markForCheck()>()\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\ndir.<@%unk/%unk: .value> = 'ltr'\ntooltipDirective.<@%unk/%unk: .position> = 'after'\n%6 = fixture.<@%unk/%unk: .changeDetectorRef>\ninstanceinvoke %6.<@%unk/%unk: .markForCheck()>()\ninstanceinvoke tooltipDirective.<@%unk/%unk: .show()>(0)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>(0)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>(500)\n%7 = tooltipDirective.<@%unk/%unk: ._overlayRef>\n%8 = %7.<@%unk/%unk: .overlayElement>\nclassList = %8.<@%unk/%unk: .classList>\n%9 = staticinvoke <@%unk/%unk: .expect()>(classList)\n%10 = %9.<@%unk/%unk: .not>\ninstanceinvoke %10.<@%unk/%unk: .toContain()>('mat-mdc-tooltip-panel-after')\n%11 = staticinvoke <@%unk/%unk: .expect()>(classList)\n%12 = %11.<@%unk/%unk: .not>\ninstanceinvoke %12.<@%unk/%unk: .toContain()>('mat-mdc-tooltip-panel-before')\n%13 = staticinvoke <@%unk/%unk: .expect()>(classList)\n%14 = %13.<@%unk/%unk: .not>\ninstanceinvoke %14.<@%unk/%unk: .toContain()>('mat-mdc-tooltip-panel-left')\n%15 = staticinvoke <@%unk/%unk: .expect()>(classList)\ninstanceinvoke %15.<@%unk/%unk: .toContain()>('mat-mdc-tooltip-panel-right')\ninstanceinvoke tooltipDirective.<@%unk/%unk: .hide()>(0)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>(0)\ndir.<@%unk/%unk: .value> = 'rtl'\ninstanceinvoke tooltipDirective.<@%unk/%unk: .show()>(0)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>(0)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>(500)\n%16 = staticinvoke <@%unk/%unk: .expect()>(classList)\n%17 = %16.<@%unk/%unk: .not>\ninstanceinvoke %17.<@%unk/%unk: .toContain()>('mat-mdc-tooltip-panel-after')\n%18 = staticinvoke <@%unk/%unk: .expect()>(classList)\n%19 = %18.<@%unk/%unk: .not>\ninstanceinvoke %19.<@%unk/%unk: .toContain()>('mat-mdc-tooltip-panel-before')\n%20 = staticinvoke <@%unk/%unk: .expect()>(classList)\n%21 = %20.<@%unk/%unk: .not>\ninstanceinvoke %21.<@%unk/%unk: .toContain()>('mat-mdc-tooltip-panel-right')\n%22 = staticinvoke <@%unk/%unk: .expect()>(classList)\ninstanceinvoke %22.<@%unk/%unk: .toContain()>('mat-mdc-tooltip-panel-left')\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      // Move the element so that the primary position is always used.\n      buttonElement.style.position = 'fixed';\n      buttonElement.style.top = buttonElement.style.left = '200px';\n      fixture.componentInstance.message = 'hi';\n      fixture.changeDetectorRef.markForCheck();\n      fixture.detectChanges();\n      dir.value = 'ltr';\n      tooltipDirective.position = 'after';\n      fixture.changeDetectorRef.markForCheck();\n      tooltipDirective.show(0);\n      fixture.detectChanges();\n      tick(0);\n      fixture.detectChanges();\n      tick(500);\n      const classList = tooltipDirective._overlayRef!.overlayElement.classList;\n      expect(classList).not.toContain('mat-mdc-tooltip-panel-after');\n      expect(classList).not.toContain('mat-mdc-tooltip-panel-before');\n      expect(classList).not.toContain('mat-mdc-tooltip-panel-left');\n      expect(classList).toContain('mat-mdc-tooltip-panel-right');\n      tooltipDirective.hide(0);\n      fixture.detectChanges();\n      tick(0);\n      dir.value = 'rtl';\n      tooltipDirective.show(0);\n      fixture.detectChanges();\n      tick(0);\n      fixture.detectChanges();\n      tick(500);\n      expect(classList).not.toContain('mat-mdc-tooltip-panel-after');\n      expect(classList).not.toContain('mat-mdc-tooltip-panel-before');\n      expect(classList).not.toContain('mat-mdc-tooltip-panel-right');\n      expect(classList).toContain('mat-mdc-tooltip-panel-left');\n    }"
        },
        {
          "type": "function",
          "name": "%AM57$%AM3$%AM0",
          "label": "%AM57$%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\nstaticinvoke <@ts_files/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)>(tooltipDirective, false)\ninstanceinvoke tooltipDirective.<@%unk/%unk: .show()>(1000)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\ninstanceinvoke fixture.<@%unk/%unk: .destroy()>()\nstaticinvoke <@%unk/%unk: .flush()>()\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.show(1000);\n      fixture.detectChanges();\n      // Note that we aren't asserting anything, but `fakeAsync` will\n      // throw if we have any timers by the end of the test.\n      fixture.destroy();\n      flush();\n    }"
        },
        {
          "type": "function",
          "name": "%AM58$%AM3$%AM0",
          "label": "%AM58$%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\nstaticinvoke <@ts_files/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)>(tooltipDirective, false)\ninstanceinvoke tooltipDirective.<@%unk/%unk: .show()>()\nstaticinvoke <@%unk/%unk: .tick()>(0)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>(500)\ninstanceinvoke tooltipDirective.<@%unk/%unk: .hide()>(1000)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\ninstanceinvoke fixture.<@%unk/%unk: .destroy()>()\nstaticinvoke <@%unk/%unk: .flush()>()\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      tick(500);\n      tooltipDirective.hide(1000);\n      fixture.detectChanges();\n      // Note that we aren't asserting anything, but `fakeAsync` will\n      // throw if we have any timers by the end of the test.\n      fixture.destroy();\n      flush();\n    }"
        },
        {
          "type": "function",
          "name": "%AM59$%AM3$%AM0",
          "label": "%AM59$%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\n%1 = 'This is a very long message that should cause the' + 'tooltip message body to overflow onto a new line.'\n%0 = fixture.<@%unk/%unk: .componentInstance>\n%0.<@%unk/%unk: .message> = %1\ninstanceinvoke tooltipDirective.<@%unk/%unk: .show()>()\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>()\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%2 = instanceinvoke overlayContainerElement.<@%unk/%unk: .querySelector()>('.mat-mdc-tooltip')\ntooltipElement = <HTMLElement>%2\n%3 = tooltipElement.<@%unk/%unk: .classList>\n%4 = staticinvoke <@%unk/%unk: .expect()>(%3)\ninstanceinvoke %4.<@%unk/%unk: .toContain()>('mdc-tooltip--multiline')\n%5 = tooltipDirective.<@%unk/%unk: ._tooltipInstance>\n%6 = %5.<@%unk/%unk: ._isMultiline>\n%7 = staticinvoke <@%unk/%unk: .expect()>(%6)\ninstanceinvoke %7.<@%unk/%unk: .toBeTrue()>()\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      fixture.componentInstance.message =\n        'This is a very long message that should cause the' +\n        'tooltip message body to overflow onto a new line.';\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick();\n      // Need to detect changes again to wait for the multiline class to be applied.\n      fixture.detectChanges();\n      const tooltipElement = overlayContainerElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;\n      expect(tooltipElement.classList).toContain('mdc-tooltip--multiline');\n      expect(tooltipDirective._tooltipInstance?._isMultiline).toBeTrue();\n    }"
        },
        {
          "type": "function",
          "name": "%AM60$%AM3$%AM0",
          "label": "%AM60$%AM3$%AM0",
          "start_line": 1,
          "end_line": 889,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\n%0 = platform.<@%unk/%unk: .IOS>\n%1 = platform.<@%unk/%unk: .ANDROID>\n%2 = %0 || %1\nif %2 != false",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "return",
                  "start_line": 66,
                  "end_line": 1276,
                  "successors": []
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%3 = fixture.<@%unk/%unk: .componentInstance>\n%4 = %3.<@%unk/%unk: .button>\n%5 = %4.<@%unk/%unk: .nativeElement>\nstaticinvoke <@%unk/%unk: .dispatchMouseEvent()>(%5, 'mouseenter')\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>(0)\n%6 = instanceinvoke tooltipDirective.<@%unk/%unk: ._isTooltipVisible()>()\n%7 = staticinvoke <@%unk/%unk: .expect()>(%6)\ninstanceinvoke %7.<@%unk/%unk: .toBe()>(true)\n%8 = fixture.<@%unk/%unk: .componentInstance>\n%9 = %8.<@%unk/%unk: .button>\n%10 = %9.<@%unk/%unk: .nativeElement>\nstaticinvoke <@%unk/%unk: .dispatchMouseEvent()>(%10, 'mouseleave')\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>(0)\n%11 = instanceinvoke tooltipDirective.<@%unk/%unk: ._isTooltipVisible()>()\n%12 = staticinvoke <@%unk/%unk: .expect()>(%11)\ninstanceinvoke %12.<@%unk/%unk: .toBe()>(false)\nreturn",
                  "start_line": 1,
                  "end_line": 1276,
                  "successors": []
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      // We don't bind mouse events on mobile devices.\n      if (platform.IOS || platform.ANDROID) {\n        return;\n      }\n      dispatchMouseEvent(fixture.componentInstance.button.nativeElement, 'mouseenter');\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      dispatchMouseEvent(fixture.componentInstance.button.nativeElement, 'mouseleave');\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n    }"
        },
        {
          "type": "function",
          "name": "%AM61$%AM3$%AM0",
          "label": "%AM61$%AM3$%AM0",
          "start_line": 1,
          "end_line": 903,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\n%0 = platform.<@%unk/%unk: .IOS>\n%1 = platform.<@%unk/%unk: .ANDROID>\n%2 = %0 || %1\nif %2 != false",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "return",
                  "start_line": 66,
                  "end_line": 1276,
                  "successors": []
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%3 = fixture.<@%unk/%unk: .componentInstance>\n%4 = %3.<@%unk/%unk: .button>\n%5 = %4.<@%unk/%unk: .nativeElement>\nstaticinvoke <@%unk/%unk: .dispatchMouseEvent()>(%5, 'mouseenter')\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>(0)\n%6 = instanceinvoke tooltipDirective.<@%unk/%unk: ._isTooltipVisible()>()\n%7 = staticinvoke <@%unk/%unk: .expect()>(%6)\ninstanceinvoke %7.<@%unk/%unk: .toBe()>(true)\n%8 = instanceinvoke overlayContainerElement.<@%unk/%unk: .querySelector()>('.mat-mdc-tooltip')\ntooltipElement = <HTMLElement>%8\nevent = staticinvoke <@%unk/%unk: .createMouseEvent()>('mouseleave')\n%9 = new @ts_files/139.ts: %AC$%dflt$%AM61$%AM3$%AM0$25\ninstanceinvoke %9.<@ts_files/139.ts: %AC$%dflt$%AM61$%AM3$%AM0$25.constructor()>()\ninstanceinvoke Object.<@%unk/%unk: .defineProperty()>(event, 'relatedTarget', %9)\n%10 = fixture.<@%unk/%unk: .componentInstance>\n%11 = %10.<@%unk/%unk: .button>\n%12 = %11.<@%unk/%unk: .nativeElement>\nstaticinvoke <@%unk/%unk: .dispatchEvent()>(%12, event)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>(0)\n%13 = instanceinvoke tooltipDirective.<@%unk/%unk: ._isTooltipVisible()>()\n%14 = staticinvoke <@%unk/%unk: .expect()>(%13)\ninstanceinvoke %14.<@%unk/%unk: .toBe()>(true)\nreturn",
                  "start_line": 1,
                  "end_line": 1276,
                  "successors": []
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      // We don't bind mouse events on mobile devices.\n      if (platform.IOS || platform.ANDROID) {\n        return;\n      }\n      dispatchMouseEvent(fixture.componentInstance.button.nativeElement, 'mouseenter');\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      const tooltipElement = overlayContainerElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;\n      const event = createMouseEvent('mouseleave');\n      Object.defineProperty(event, 'relatedTarget', {value: tooltipElement});\n      dispatchEvent(fixture.componentInstance.button.nativeElement, event);\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n    }"
        },
        {
          "type": "function",
          "name": "%AM62$%AM3$%AM0",
          "label": "%AM62$%AM3$%AM0",
          "start_line": 1,
          "end_line": 922,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\n%0 = platform.<@%unk/%unk: .IOS>\n%1 = platform.<@%unk/%unk: .ANDROID>\n%2 = %0 || %1\nif %2 != false",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "return",
                  "start_line": 66,
                  "end_line": 1276,
                  "successors": []
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%3 = fixture.<@%unk/%unk: .componentInstance>\n%4 = %3.<@%unk/%unk: .button>\n%5 = %4.<@%unk/%unk: .nativeElement>\nstaticinvoke <@%unk/%unk: .dispatchMouseEvent()>(%5, 'mouseenter')\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>(0)\n%6 = instanceinvoke tooltipDirective.<@%unk/%unk: ._isTooltipVisible()>()\n%7 = staticinvoke <@%unk/%unk: .expect()>(%6)\ninstanceinvoke %7.<@%unk/%unk: .toBe()>(true)\n%8 = instanceinvoke overlayContainerElement.<@%unk/%unk: .querySelector()>('.mat-mdc-tooltip')\ntooltipElement = <HTMLElement>%8\nstaticinvoke <@%unk/%unk: .dispatchMouseEvent()>(tooltipElement, 'mouseleave')\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>(0)\n%9 = instanceinvoke tooltipDirective.<@%unk/%unk: ._isTooltipVisible()>()\n%10 = staticinvoke <@%unk/%unk: .expect()>(%9)\ninstanceinvoke %10.<@%unk/%unk: .toBe()>(false)\nreturn",
                  "start_line": 1,
                  "end_line": 1276,
                  "successors": []
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      // We don't bind mouse events on mobile devices.\n      if (platform.IOS || platform.ANDROID) {\n        return;\n      }\n      dispatchMouseEvent(fixture.componentInstance.button.nativeElement, 'mouseenter');\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      const tooltipElement = overlayContainerElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;\n      dispatchMouseEvent(tooltipElement, 'mouseleave');\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n    }"
        },
        {
          "type": "function",
          "name": "%AM63$%AM3$%AM0",
          "label": "%AM63$%AM3$%AM0",
          "start_line": 1,
          "end_line": 939,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\n%0 = platform.<@%unk/%unk: .IOS>\n%1 = platform.<@%unk/%unk: .ANDROID>\n%2 = %0 || %1\nif %2 != false",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "return",
                  "start_line": 66,
                  "end_line": 1276,
                  "successors": []
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%3 = fixture.<@%unk/%unk: .componentInstance>\n%4 = %3.<@%unk/%unk: .button>\n%5 = %4.<@%unk/%unk: .nativeElement>\nstaticinvoke <@%unk/%unk: .dispatchMouseEvent()>(%5, 'mouseenter')\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>(0)\n%6 = instanceinvoke tooltipDirective.<@%unk/%unk: ._isTooltipVisible()>()\n%7 = staticinvoke <@%unk/%unk: .expect()>(%6)\ninstanceinvoke %7.<@%unk/%unk: .toBe()>(true)\n%8 = instanceinvoke overlayContainerElement.<@%unk/%unk: .querySelector()>('.mat-mdc-tooltip')\ntooltipElement = <HTMLElement>%8\nevent = staticinvoke <@%unk/%unk: .createMouseEvent()>('mouseleave')\n%9 = new @ts_files/139.ts: %AC$%dflt$%AM63$%AM3$%AM0$26\ninstanceinvoke %9.<@ts_files/139.ts: %AC$%dflt$%AM63$%AM3$%AM0$26.constructor()>()\ninstanceinvoke Object.<@%unk/%unk: .defineProperty()>(event, 'relatedTarget', %9)\nstaticinvoke <@%unk/%unk: .dispatchEvent()>(tooltipElement, event)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>(0)\n%10 = instanceinvoke tooltipDirective.<@%unk/%unk: ._isTooltipVisible()>()\n%11 = staticinvoke <@%unk/%unk: .expect()>(%10)\ninstanceinvoke %11.<@%unk/%unk: .toBe()>(true)\nreturn",
                  "start_line": 1,
                  "end_line": 1276,
                  "successors": []
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      // We don't bind mouse events on mobile devices.\n      if (platform.IOS || platform.ANDROID) {\n        return;\n      }\n      dispatchMouseEvent(fixture.componentInstance.button.nativeElement, 'mouseenter');\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      const tooltipElement = overlayContainerElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;\n      const event = createMouseEvent('mouseleave');\n      Object.defineProperty(event, 'relatedTarget', {\n        value: fixture.componentInstance.button.nativeElement,\n      });\n      dispatchEvent(tooltipElement, event);\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n    }"
        },
        {
          "type": "function",
          "name": "%AM3$%AM0",
          "label": "%AM3$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\nfixture = undefined\nbuttonDebugElement = undefined\nbuttonElement = undefined\ntooltipDirective = undefined\n%0 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM4$%AM3$%AM0)\nstaticinvoke <@%unk/%unk: .beforeEach()>(%0)\n%1 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM5$%AM3$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should show and hide the tooltip', %1)\n%2 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM6$%AM3$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should be able to re-open a tooltip if it was closed by detaching the overlay', %2)\n%3 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM7$%AM3$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should show with delay', %3)\n%4 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM8$%AM3$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should be able to override the default show and hide delays', %4)\n%5 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM9$%AM3$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should be able to override the default position', %5)\n%6 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM10$%AM3$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should be able to define a default (global) tooltip class', %6)\n%7 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM11$%AM3$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should be able to provide tooltip class over the custom default one', %7)\n%8 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM12$%AM3$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should position on the bottom-left by default', %8)\nstaticinvoke <@%unk/%unk: .it()>('should be able to override the default positionAtOrigin', %AM13$%AM3$%AM0)\n%9 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM15$%AM3$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should be able to disable tooltip interactivity', %9)\n%10 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM16$%AM3$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should set a css class on the overlay panel element', %10)\n%11 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM17$%AM3$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should not show if disabled', %11)\n%12 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM18$%AM3$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should hide if disabled while visible', %12)\n%13 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM19$%AM3$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should hide if the message is cleared while the tooltip is open', %13)\n%14 = staticinvoke <@%unk/%unk: .waitForAsync()>(%AM20$%AM3$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should not show if hide is called before delay finishes', %14)\nstaticinvoke <@%unk/%unk: .it()>('should not show tooltip if message is not present or empty', %AM22$%AM3$%AM0)\n%15 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM23$%AM3$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should not follow through with hide if show is called after', %15)\n%16 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM24$%AM3$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should be able to update the tooltip position while open', %16)\n%17 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM25$%AM3$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should update the tooltip position when the directionality changes', %17)\n%18 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM26$%AM3$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should not throw when updating the position for a closed tooltip', %18)\n%19 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM28$%AM3$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should be able to modify the tooltip message', %19)\n%20 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM29$%AM3$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should allow extra classes to be set on the tooltip', %20)\n%21 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM30$%AM3$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should be removed after parent destroyed', %21)\n%22 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM31$%AM3$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should have an aria-describedby element with the tooltip message', %22)\n%23 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM32$%AM3$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should not add an ARIA description for elements that have the same text as a data-bound aria-label', %23)\n%24 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM33$%AM3$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should toggle aria-describedby depending on whether the tooltip is disabled', %24)\n%25 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM34$%AM3$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should not try to dispose the tooltip when destroyed and done hiding', %25)\n%26 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM35$%AM3$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should complete the afterHidden stream when tooltip is destroyed', %26)\nstaticinvoke <@%unk/%unk: .it()>('should consistently position before and after overlay origin in ltr and rtl dir', %AM36$%AM3$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should consistently position before and after overlay position in ltr and rtl dir', %AM37$%AM3$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should throw when trying to assign an invalid position', %AM38$%AM3$%AM0)\n%27 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM40$%AM3$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should pass the layout direction to the tooltip', %27)\n%28 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM41$%AM3$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should keep the overlay direction in sync with the trigger direction', %28)\n%29 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM42$%AM3$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should be able to set the tooltip message as a number', %29)\n%30 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM43$%AM3$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should hide when clicking away', %30)\n%31 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM44$%AM3$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should hide when clicking away with an auxilliary button', %31)\n%32 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM45$%AM3$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should not hide immediately if a click fires while animating', %32)\n%33 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM46$%AM3$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should hide when pressing escape', %33)\n%34 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM47$%AM3$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should not throw when pressing ESCAPE', %34)\n%35 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM49$%AM3$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should preventDefault when pressing ESCAPE', %35)\n%36 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM50$%AM3$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should not preventDefault when pressing ESCAPE with a modifier', %36)\n%37 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM51$%AM3$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should not show the tooltip on programmatic focus', %37)\n%38 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM52$%AM3$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should not show the tooltip on mouse focus', %38)\n%39 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM53$%AM3$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should not show the tooltip on touch focus', %39)\n%40 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM54$%AM3$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should not hide the tooltip when calling `show` twice in a row', %40)\n%41 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM55$%AM3$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should set a class on the overlay panel that reflects the position', %41)\n%42 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM56$%AM3$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should account for RTL when setting the tooltip position class', %42)\n%43 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM57$%AM3$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should clear the show timeout on destroy', %43)\n%44 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM58$%AM3$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should clear the hide timeout on destroy', %44)\n%45 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM59$%AM3$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should set the multiline class on tooltips with messages that overflow', %45)\n%46 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM60$%AM3$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should hide on mouseleave on the trigger', %46)\n%47 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM61$%AM3$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should not hide on mouseleave if the pointer goes from the trigger to the tooltip', %47)\n%48 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM62$%AM3$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should hide on mouseleave on the tooltip', %48)\n%49 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM63$%AM3$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should not hide on mouseleave if the pointer goes from the tooltip to the trigger', %49)\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n    let fixture: ComponentFixture<BasicTooltipDemo>;\n    let buttonDebugElement: DebugElement;\n    let buttonElement: HTMLButtonElement;\n    let tooltipDirective: MatTooltip;\n    beforeEach(fakeAsync(() => {\n      fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      tick();\n      buttonDebugElement = fixture.debugElement.query(By.css('button'))!;\n      buttonElement = buttonDebugElement.nativeElement;\n      tooltipDirective = buttonDebugElement.injector.get<MatTooltip>(MatTooltip);\n    }));\n    it('should show and hide the tooltip', fakeAsync(() => {\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.show();\n      tick(0); // Tick for the show delay (default is 0)\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      fixture.detectChanges();\n      // Wait until animation has finished\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      // Make sure tooltip is shown to the user and animation has finished.\n      const tooltipElement = overlayContainerElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;\n      expect(tooltipElement instanceof HTMLElement).toBe(true);\n      expect(tooltipElement.classList).toContain('mat-mdc-tooltip-show');\n      expect(overlayContainerElement.textContent).toContain(initialTooltipMessage);\n      // After hide is called, a timeout delay is created that will to hide the tooltip.\n      const tooltipDelay = 1000;\n      tooltipDirective.hide(tooltipDelay);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      // After the tooltip delay elapses, expect that the tooltip is not visible.\n      tick(tooltipDelay);\n      fixture.detectChanges();\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      // On animation complete, should expect that the tooltip has been detached.\n      finishCurrentTooltipAnimation(overlayContainerElement, false);\n      assertTooltipInstance(tooltipDirective, false);\n      flush();\n    }));\n    it('should be able to re-open a tooltip if it was closed by detaching the overlay', fakeAsync(() => {\n      tooltipDirective.show();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      tooltipDirective._overlayRef!.detach();\n      tick(0);\n      fixture.detectChanges();\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.show();\n      tick(0);\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      flush();\n    }));\n    it('should show with delay', fakeAsync(() => {\n      assertTooltipInstance(tooltipDirective, false);\n      const tooltipDelay = 1000;\n      tooltipDirective.show(tooltipDelay);\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      fixture.detectChanges();\n      expect(overlayContainerElement.textContent).toContain('');\n      tick(tooltipDelay);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      expect(overlayContainerElement.textContent).toContain(initialTooltipMessage);\n    }));\n    it('should be able to override the default show and hide delays', fakeAsync(() => {\n      TestBed.resetTestingModule().configureTestingModule({\n        imports: [MatTooltipModule, OverlayModule, BasicTooltipDemo],\n        providers: [\n          {\n            provide: MAT_TOOLTIP_DEFAULT_OPTIONS,\n            useValue: {showDelay: 1337, hideDelay: 7331},\n          },\n        ],\n      });\n      fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      tooltipDirective = fixture.debugElement\n        .query(By.css('button'))!\n        .injector.get<MatTooltip>(MatTooltip);\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick();\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      tick(1337);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      tooltipDirective.hide();\n      fixture.detectChanges();\n      tick();\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      tick(7331);\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      flush();\n    }));\n    it('should be able to override the default position', fakeAsync(() => {\n      TestBed.resetTestingModule().configureTestingModule({\n        imports: [MatTooltipModule, OverlayModule],\n        declarations: [TooltipDemoWithoutPositionBinding],\n        providers: [\n          {\n            provide: MAT_TOOLTIP_DEFAULT_OPTIONS,\n            useValue: {position: 'right'},\n          },\n        ],\n      });\n      const newFixture = TestBed.createComponent(TooltipDemoWithoutPositionBinding);\n      newFixture.detectChanges();\n      tooltipDirective = newFixture.debugElement\n        .query(By.css('button'))!\n        .injector.get<MatTooltip>(MatTooltip);\n      tooltipDirective.show();\n      newFixture.detectChanges();\n      tick();\n      expect(tooltipDirective.position).toBe('right');\n      expect(tooltipDirective._getOverlayPosition().main.overlayX).toBe('start');\n      expect(tooltipDirective._getOverlayPosition().fallback.overlayX).toBe('end');\n    }));\n    it('should be able to define a default (global) tooltip class', fakeAsync(() => {\n      TestBed.resetTestingModule().configureTestingModule({\n        declarations: [TooltipDemoWithoutTooltipClassBinding],\n        imports: [MatTooltipModule, OverlayModule],\n        providers: [\n          {\n            provide: MAT_TOOLTIP_DEFAULT_OPTIONS,\n            useValue: {tooltipClass: 'my-default-tooltip-class'},\n          },\n        ],\n      });\n      const fixture = TestBed.createComponent(TooltipDemoWithoutTooltipClassBinding);\n      fixture.detectChanges();\n      tooltipDirective = fixture.componentInstance.tooltip;\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick();\n      const overlayRef = tooltipDirective._overlayRef!;\n      const tooltipElement = overlayRef.overlayElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;\n      expect(tooltipDirective.tooltipClass).toBe('my-default-tooltip-class');\n      expect(tooltipElement.classList).toContain('my-default-tooltip-class');\n    }));\n    it('should be able to provide tooltip class over the custom default one', fakeAsync(() => {\n      TestBed.resetTestingModule().configureTestingModule({\n        declarations: [TooltipDemoWithTooltipClassBinding],\n        imports: [MatTooltipModule, OverlayModule],\n        providers: [\n          {\n            provide: MAT_TOOLTIP_DEFAULT_OPTIONS,\n            useValue: {tooltipClass: 'my-default-tooltip-class'},\n          },\n        ],\n      });\n      const fixture = TestBed.createComponent(TooltipDemoWithTooltipClassBinding);\n      fixture.detectChanges();\n      tooltipDirective = fixture.componentInstance.tooltip;\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick();\n      const overlayRef = tooltipDirective._overlayRef!;\n      const tooltipElement = overlayRef.overlayElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;\n      expect(tooltipDirective.tooltipClass).not.toBe('my-default-tooltip-class');\n      expect(tooltipElement.classList).not.toContain('my-default-tooltip-class');\n      expect(tooltipElement.classList).toContain('fixed-tooltip-class');\n    }));\n    it('should position on the bottom-left by default', fakeAsync(() => {\n      // We don't bind mouse events on mobile devices.\n      if (platform.IOS || platform.ANDROID) {\n        return;\n      }\n      TestBed.resetTestingModule().configureTestingModule({\n        imports: [MatTooltipModule, OverlayModule],\n        declarations: [WideTooltipDemo],\n      });\n      const wideFixture = TestBed.createComponent(WideTooltipDemo);\n      wideFixture.detectChanges();\n      tooltipDirective = wideFixture.debugElement\n        .query(By.css('button'))!\n        .injector.get<MatTooltip>(MatTooltip);\n      const button: HTMLButtonElement = wideFixture.nativeElement.querySelector('button');\n      const triggerRect = button.getBoundingClientRect();\n      dispatchMouseEvent(button, 'mouseenter', triggerRect.right - 100, triggerRect.top + 100);\n      wideFixture.detectChanges();\n      tick();\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      expect(tooltipDirective._overlayRef!.overlayElement.offsetLeft).toBeLessThan(\n        triggerRect.right - 250,\n      );\n      expect(tooltipDirective._overlayRef!.overlayElement.offsetTop).toBeGreaterThanOrEqual(\n        triggerRect.bottom,\n      );\n    }));\n    it('should be able to override the default positionAtOrigin', async () => {\n      // We don't bind mouse events on mobile devices.\n      if (platform.IOS || platform.ANDROID) {\n        return;\n      }\n      TestBed.resetTestingModule().configureTestingModule({\n        imports: [MatTooltipModule, OverlayModule],\n        declarations: [WideTooltipDemo],\n        providers: [\n          {\n            provide: MAT_TOOLTIP_DEFAULT_OPTIONS,\n            useValue: {positionAtOrigin: true},\n          },\n        ],\n      });\n      const wideFixture = TestBed.createComponent(WideTooltipDemo);\n      wideFixture.detectChanges();\n      tooltipDirective = wideFixture.debugElement\n        .query(By.css('button'))!\n        .injector.get<MatTooltip>(MatTooltip);\n      const button: HTMLButtonElement = wideFixture.nativeElement.querySelector('button');\n      const triggerRect = button.getBoundingClientRect();\n      dispatchMouseEvent(button, 'mouseenter', triggerRect.right - 100, triggerRect.top + 100);\n      wideFixture.detectChanges();\n      await new Promise<void>(resolve => setTimeout(resolve));\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      const actualOffsetLeft = tooltipDirective._overlayRef!.overlayElement.offsetLeft;\n      const expectedOffsetLeft = triggerRect.right - 100 - 20;\n      expect(actualOffsetLeft).toBeLessThanOrEqual(expectedOffsetLeft + 1);\n      expect(actualOffsetLeft).toBeGreaterThanOrEqual(expectedOffsetLeft - 1);\n      expect(tooltipDirective._overlayRef!.overlayElement.offsetTop).toBe(triggerRect.top + 100);\n    });\n    it('should be able to disable tooltip interactivity', fakeAsync(() => {\n      TestBed.resetTestingModule().configureTestingModule({\n        imports: [MatTooltipModule, OverlayModule, NoopAnimationsModule],\n        declarations: [TooltipDemoWithoutPositionBinding],\n        providers: [\n          {\n            provide: MAT_TOOLTIP_DEFAULT_OPTIONS,\n            useValue: {disableTooltipInteractivity: true},\n          },\n        ],\n      });\n      const newFixture = TestBed.createComponent(TooltipDemoWithoutPositionBinding);\n      newFixture.detectChanges();\n      tooltipDirective = newFixture.debugElement\n        .query(By.css('button'))!\n        .injector.get<MatTooltip>(MatTooltip);\n      tooltipDirective.show();\n      newFixture.detectChanges();\n      tick();\n      expect(tooltipDirective._overlayRef?.overlayElement.classList).toContain(\n        'mat-mdc-tooltip-panel-non-interactive',\n      );\n    }));\n    it('should set a css class on the overlay panel element', fakeAsync(() => {\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick(0);\n      const overlayRef = tooltipDirective._overlayRef;\n      expect(!!overlayRef).toBeTruthy();\n      expect(overlayRef!.overlayElement.classList)\n        .withContext('Expected the overlay panel element to have the tooltip panel class set.')\n        .toContain('mat-mdc-tooltip-panel');\n    }));\n    it('should not show if disabled', fakeAsync(() => {\n      // Test that disabling the tooltip will not set the tooltip visible\n      tooltipDirective.disabled = true;\n      fixture.changeDetectorRef.markForCheck();\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      // Test to make sure setting disabled to false will show the tooltip\n      // Sanity check to make sure everything was correct before (detectChanges, tick)\n      tooltipDirective.disabled = false;\n      fixture.changeDetectorRef.markForCheck();\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n    }));\n    it('should hide if disabled while visible', fakeAsync(() => {\n      // Display the tooltip with a timeout before hiding.\n      tooltipDirective.hideDelay = 1000;\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      // Set tooltip to be disabled and verify that the tooltip hides.\n      tooltipDirective.disabled = true;\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n    }));\n    it('should hide if the message is cleared while the tooltip is open', fakeAsync(() => {\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      fixture.componentInstance.message = '';\n      fixture.changeDetectorRef.markForCheck();\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n    }));\n    it('should not show if hide is called before delay finishes', waitForAsync(() => {\n      assertTooltipInstance(tooltipDirective, false);\n      const tooltipDelay = 1000;\n      tooltipDirective.show(tooltipDelay);\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      fixture.detectChanges();\n      expect(overlayContainerElement.textContent).toContain('');\n      tooltipDirective.hide();\n      fixture.whenStable().then(() => {\n        expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      });\n    }));\n    it('should not show tooltip if message is not present or empty', () => {\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.message = undefined;\n      fixture.detectChanges();\n      tooltipDirective.show();\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.message = null;\n      fixture.detectChanges();\n      tooltipDirective.show();\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.message = '';\n      fixture.detectChanges();\n      tooltipDirective.show();\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.message = '   ';\n      fixture.detectChanges();\n      tooltipDirective.show();\n      assertTooltipInstance(tooltipDirective, false);\n    });\n    it('should not follow through with hide if show is called after', fakeAsync(() => {\n      tooltipDirective.show();\n      tick(0); // Tick for the show delay (default is 0)\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      // After hide called, a timeout delay is created that will to hide the tooltip.\n      const tooltipDelay = 1000;\n      tooltipDirective.hide(tooltipDelay);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      // Before delay time has passed, call show which should cancel intent to hide tooltip.\n      tooltipDirective.show();\n      tick(tooltipDelay);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n    }));\n    it('should be able to update the tooltip position while open', fakeAsync(() => {\n      tooltipDirective.position = 'below';\n      tooltipDirective.show();\n      tick();\n      assertTooltipInstance(tooltipDirective, true);\n      spyOn(tooltipDirective._overlayRef!, 'updatePosition').and.callThrough();\n      tooltipDirective.position = 'above';\n      fixture.detectChanges();\n      tick();\n      assertTooltipInstance(tooltipDirective, true);\n      expect(tooltipDirective._overlayRef!.updatePosition).toHaveBeenCalled();\n    }));\n    it('should update the tooltip position when the directionality changes', fakeAsync(() => {\n      tooltipDirective.position = 'right';\n      tooltipDirective.show();\n      tick();\n      assertTooltipInstance(tooltipDirective, true);\n      const spy = spyOn(tooltipDirective as any, '_updatePosition').and.callThrough();\n      dir.change.next('rtl');\n      assertTooltipInstance(tooltipDirective, true);\n      expect(spy).toHaveBeenCalled();\n    }));\n    it('should not throw when updating the position for a closed tooltip', fakeAsync(() => {\n      tooltipDirective.position = 'left';\n      tooltipDirective.show(0);\n      fixture.detectChanges();\n      tick();\n      tooltipDirective.hide(0);\n      fixture.detectChanges();\n      tick();\n      finishCurrentTooltipAnimation(overlayContainerElement, false);\n      expect(() => {\n        tooltipDirective.position = 'right';\n        fixture.detectChanges();\n        tick();\n      }).not.toThrow();\n    }));\n    it('should be able to modify the tooltip message', fakeAsync(() => {\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.show();\n      tick(0); // Tick for the show delay (default is 0)\n      expect(tooltipDirective._tooltipInstance!.isVisible()).toBe(true);\n      fixture.detectChanges();\n      expect(overlayContainerElement.textContent).toContain(initialTooltipMessage);\n      const newMessage = 'new tooltip message';\n      tooltipDirective.message = newMessage;\n      fixture.detectChanges();\n      expect(overlayContainerElement.textContent).toContain(newMessage);\n    }));\n    it('should allow extra classes to be set on the tooltip', fakeAsync(() => {\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.show();\n      tick(0); // Tick for the show delay (default is 0)\n      fixture.detectChanges();\n      // Make sure classes aren't prematurely added\n      let tooltipElement = overlayContainerElement.querySelector('.mat-mdc-tooltip') as HTMLElement;\n      expect(tooltipElement.classList).not.toContain(\n        'custom-one',\n        'Expected to not have the class before enabling matTooltipClass',\n      );\n      expect(tooltipElement.classList).not.toContain(\n        'custom-two',\n        'Expected to not have the class before enabling matTooltipClass',\n      );\n      // Enable the classes via ngClass syntax\n      fixture.componentInstance.showTooltipClass = true;\n      fixture.changeDetectorRef.markForCheck();\n      fixture.detectChanges();\n      // Make sure classes are correctly added\n      tooltipElement = overlayContainerElement.querySelector('.mat-mdc-tooltip') as HTMLElement;\n      expect(tooltipElement.classList)\n        .withContext('Expected to have the class after enabling matTooltipClass')\n        .toContain('custom-one');\n      expect(tooltipElement.classList)\n        .withContext('Expected to have the class after enabling matTooltipClass')\n        .toContain('custom-two');\n    }));\n    it('should be removed after parent destroyed', fakeAsync(() => {\n      tooltipDirective.show();\n      tick(0); // Tick for the show delay (default is 0)\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      fixture.destroy();\n      expect(overlayContainerElement.childNodes.length).toBe(0);\n      expect(overlayContainerElement.textContent).toBe('');\n      flush();\n    }));\n    it('should have an aria-describedby element with the tooltip message', fakeAsync(() => {\n      const dynamicTooltipsDemoFixture = TestBed.createComponent(DynamicTooltipsDemo);\n      const dynamicTooltipsComponent = dynamicTooltipsDemoFixture.componentInstance;\n      dynamicTooltipsComponent.tooltips = ['Tooltip One', 'Tooltip Two'];\n      dynamicTooltipsDemoFixture.detectChanges();\n      tick();\n      const buttons = dynamicTooltipsDemoFixture.nativeElement.querySelectorAll('button');\n      const firstButtonAria = buttons[0].getAttribute('aria-describedby');\n      expect(document.querySelector(`#${firstButtonAria}`)!.textContent).toBe('Tooltip One');\n      const secondButtonAria = buttons[1].getAttribute('aria-describedby');\n      expect(document.querySelector(`#${secondButtonAria}`)!.textContent).toBe('Tooltip Two');\n    }));\n    it('should not add an ARIA description for elements that have the same text as a data-bound aria-label', fakeAsync(() => {\n      const ariaLabelFixture = TestBed.createComponent(DataBoundAriaLabelTooltip);\n      ariaLabelFixture.detectChanges();\n      tick();\n      const button = ariaLabelFixture.nativeElement.querySelector('button');\n      expect(button.getAttribute('aria-describedby')).toBeFalsy();\n    }));\n    it('should toggle aria-describedby depending on whether the tooltip is disabled', fakeAsync(() => {\n      expect(buttonElement.getAttribute('aria-describedby')).toBeTruthy();\n      fixture.componentInstance.tooltipDisabled = true;\n      fixture.changeDetectorRef.markForCheck();\n      fixture.detectChanges();\n      tick();\n      expect(buttonElement.hasAttribute('aria-describedby')).toBe(false);\n      fixture.componentInstance.tooltipDisabled = false;\n      fixture.changeDetectorRef.markForCheck();\n      fixture.detectChanges();\n      tick();\n      expect(buttonElement.getAttribute('aria-describedby')).toBeTruthy();\n    }));\n    it('should not try to dispose the tooltip when destroyed and done hiding', fakeAsync(() => {\n      tooltipDirective.show();\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      const tooltipDelay = 1000;\n      tooltipDirective.hide();\n      tick(tooltipDelay); // Change the tooltip state to hidden and trigger animation start\n      fixture.componentInstance.showButton = false;\n      fixture.changeDetectorRef.markForCheck();\n      fixture.detectChanges();\n    }));\n    it('should complete the afterHidden stream when tooltip is destroyed', fakeAsync(() => {\n      tooltipDirective.show();\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      const spy = jasmine.createSpy('complete spy');\n      const subscription = tooltipDirective\n        ._tooltipInstance!.afterHidden()\n        .subscribe({complete: spy});\n      tooltipDirective.hide(0);\n      tick(0);\n      fixture.detectChanges();\n      expect(spy).toHaveBeenCalled();\n      subscription.unsubscribe();\n    }));\n    it('should consistently position before and after overlay origin in ltr and rtl dir', () => {\n      tooltipDirective.position = 'left';\n      const leftOrigin = tooltipDirective._getOrigin().main;\n      tooltipDirective.position = 'right';\n      const rightOrigin = tooltipDirective._getOrigin().main;\n      // Test expectations in LTR\n      tooltipDirective.position = 'before';\n      expect(tooltipDirective._getOrigin().main).toEqual(leftOrigin);\n      tooltipDirective.position = 'after';\n      expect(tooltipDirective._getOrigin().main).toEqual(rightOrigin);\n      // Test expectations in RTL\n      dir.value = 'rtl';\n      tooltipDirective.position = 'before';\n      expect(tooltipDirective._getOrigin().main).toEqual(leftOrigin);\n      tooltipDirective.position = 'after';\n      expect(tooltipDirective._getOrigin().main).toEqual(rightOrigin);\n    });\n    it('should consistently position before and after overlay position in ltr and rtl dir', () => {\n      tooltipDirective.position = 'left';\n      const leftOverlayPosition = tooltipDirective._getOverlayPosition().main;\n      tooltipDirective.position = 'right';\n      const rightOverlayPosition = tooltipDirective._getOverlayPosition().main;\n      // Test expectations in LTR\n      tooltipDirective.position = 'before';\n      expect(tooltipDirective._getOverlayPosition().main).toEqual(leftOverlayPosition);\n      tooltipDirective.position = 'after';\n      expect(tooltipDirective._getOverlayPosition().main).toEqual(rightOverlayPosition);\n      // Test expectations in RTL\n      dir.value = 'rtl';\n      tooltipDirective.position = 'before';\n      expect(tooltipDirective._getOverlayPosition().main).toEqual(leftOverlayPosition);\n      tooltipDirective.position = 'after';\n      expect(tooltipDirective._getOverlayPosition().main).toEqual(rightOverlayPosition);\n    });\n    it('should throw when trying to assign an invalid position', () => {\n      expect(() => {\n        fixture.componentInstance.position = 'everywhere';\n        fixture.changeDetectorRef.markForCheck();\n        fixture.detectChanges();\n        tooltipDirective.show();\n      }).toThrowError('Tooltip position \"everywhere\" is invalid.');\n    });\n    it('should pass the layout direction to the tooltip', fakeAsync(() => {\n      dir.value = 'rtl';\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      const tooltipWrapper = overlayContainerElement.querySelector(\n        '.cdk-overlay-connected-position-bounding-box',\n      )!;\n      expect(tooltipWrapper).withContext('Expected tooltip to be shown.').toBeTruthy();\n      expect(tooltipWrapper.getAttribute('dir'))\n        .withContext('Expected tooltip to be in RTL mode.')\n        .toBe('rtl');\n    }));\n    it('should keep the overlay direction in sync with the trigger direction', fakeAsync(() => {\n      dir.value = 'rtl';\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      let tooltipWrapper = overlayContainerElement.querySelector(\n        '.cdk-overlay-connected-position-bounding-box',\n      )!;\n      expect(tooltipWrapper.getAttribute('dir'))\n        .withContext('Expected tooltip to be in RTL.')\n        .toBe('rtl');\n      tooltipDirective.hide(0);\n      tick(0);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, false);\n      dir.value = 'ltr';\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      tooltipWrapper = overlayContainerElement.querySelector(\n        '.cdk-overlay-connected-position-bounding-box',\n      )!;\n      expect(tooltipWrapper.getAttribute('dir'))\n        .withContext('Expected tooltip to be in LTR.')\n        .toBe('ltr');\n      flush();\n    }));\n    it('should be able to set the tooltip message as a number', fakeAsync(() => {\n      fixture.componentInstance.message = 100;\n      fixture.changeDetectorRef.markForCheck();\n      fixture.detectChanges();\n      expect(tooltipDirective.message).toBe('100');\n    }));\n    it('should hide when clicking away', fakeAsync(() => {\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      expect(overlayContainerElement.textContent).toContain(initialTooltipMessage);\n      document.body.click();\n      tick(0);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, false);\n      fixture.detectChanges();\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      expect(overlayContainerElement.textContent).toBe('');\n    }));\n    it('should hide when clicking away with an auxilliary button', fakeAsync(() => {\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      expect(overlayContainerElement.textContent).toContain(initialTooltipMessage);\n      dispatchFakeEvent(document.body, 'auxclick');\n      tick(0);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, false);\n      fixture.detectChanges();\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      expect(overlayContainerElement.textContent).toBe('');\n    }));\n    it('should not hide immediately if a click fires while animating', fakeAsync(() => {\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      document.body.click();\n      fixture.detectChanges();\n      tick(500);\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      expect(overlayContainerElement.textContent).toContain(initialTooltipMessage);\n      flush();\n    }));\n    it('should hide when pressing escape', fakeAsync(() => {\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      tick(500);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      expect(overlayContainerElement.textContent).toContain(initialTooltipMessage);\n      dispatchKeyboardEvent(document.body, 'keydown', ESCAPE);\n      tick(0);\n      fixture.detectChanges();\n      tick(500);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, false);\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      expect(overlayContainerElement.textContent).toBe('');\n      flush();\n    }));\n    it('should not throw when pressing ESCAPE', fakeAsync(() => {\n      expect(() => {\n        dispatchKeyboardEvent(document.body, 'keydown', ESCAPE);\n        fixture.detectChanges();\n      }).not.toThrow();\n      // Flush due to the additional tick that is necessary for the FocusMonitor.\n      flush();\n    }));\n    it('should preventDefault when pressing ESCAPE', fakeAsync(() => {\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      const event = dispatchKeyboardEvent(document.body, 'keydown', ESCAPE);\n      fixture.detectChanges();\n      flush();\n      expect(event.defaultPrevented).toBe(true);\n    }));\n    it('should not preventDefault when pressing ESCAPE with a modifier', fakeAsync(() => {\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      const event = createKeyboardEvent('keydown', ESCAPE, undefined, {alt: true});\n      dispatchEvent(document.body, event);\n      fixture.detectChanges();\n      flush();\n      expect(event.defaultPrevented).toBe(false);\n    }));\n    it('should not show the tooltip on programmatic focus', fakeAsync(() => {\n      patchElementFocus(buttonElement);\n      assertTooltipInstance(tooltipDirective, false);\n      focusMonitor.focusVia(buttonElement, 'program');\n      tick(0);\n      fixture.detectChanges();\n      tick(500);\n      expect(overlayContainerElement.querySelector('.mat-mdc-tooltip')).toBeNull();\n    }));\n    it('should not show the tooltip on mouse focus', fakeAsync(() => {\n      patchElementFocus(buttonElement);\n      assertTooltipInstance(tooltipDirective, false);\n      focusMonitor.focusVia(buttonElement, 'mouse');\n      tick(0);\n      fixture.detectChanges();\n      tick(500);\n      expect(overlayContainerElement.querySelector('.mat-mdc-tooltip')).toBeNull();\n    }));\n    it('should not show the tooltip on touch focus', fakeAsync(() => {\n      patchElementFocus(buttonElement);\n      assertTooltipInstance(tooltipDirective, false);\n      focusMonitor.focusVia(buttonElement, 'touch');\n      tick(0);\n      fixture.detectChanges();\n      tick(500);\n      expect(overlayContainerElement.querySelector('.mat-mdc-tooltip')).toBeNull();\n    }));\n    it('should not hide the tooltip when calling `show` twice in a row', fakeAsync(() => {\n      tooltipDirective.show();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      const overlayRef = tooltipDirective._overlayRef!;\n      spyOn(overlayRef, 'detach').and.callThrough();\n      tooltipDirective.show();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      expect(overlayRef.detach).not.toHaveBeenCalled();\n      flush();\n    }));\n    it('should set a class on the overlay panel that reflects the position', fakeAsync(() => {\n      // Move the element so that the primary position is always used.\n      buttonElement.style.position = 'fixed';\n      buttonElement.style.top = buttonElement.style.left = '200px';\n      fixture.componentInstance.message = 'hi';\n      fixture.changeDetectorRef.markForCheck();\n      fixture.detectChanges();\n      setPositionAndShow('below');\n      const classList = tooltipDirective._overlayRef!.overlayElement.classList;\n      expect(classList).toContain('mat-mdc-tooltip-panel-below');\n      setPositionAndShow('above');\n      expect(classList).not.toContain('mat-mdc-tooltip-panel-below');\n      expect(classList).toContain('mat-mdc-tooltip-panel-above');\n      setPositionAndShow('left');\n      expect(classList).not.toContain('mat-mdc-tooltip-panel-above');\n      expect(classList).toContain('mat-mdc-tooltip-panel-left');\n      setPositionAndShow('right');\n      expect(classList).not.toContain('mat-mdc-tooltip-panel-left');\n      expect(classList).toContain('mat-mdc-tooltip-panel-right');\n      function setPositionAndShow(position: TooltipPosition) {\n        tooltipDirective.hide(0);\n        fixture.detectChanges();\n        tick(0);\n        tooltipDirective.position = position;\n        tooltipDirective.show(0);\n        fixture.detectChanges();\n        tick(0);\n        fixture.detectChanges();\n        tick(500);\n      }\n    }));\n    it('should account for RTL when setting the tooltip position class', fakeAsync(() => {\n      // Move the element so that the primary position is always used.\n      buttonElement.style.position = 'fixed';\n      buttonElement.style.top = buttonElement.style.left = '200px';\n      fixture.componentInstance.message = 'hi';\n      fixture.changeDetectorRef.markForCheck();\n      fixture.detectChanges();\n      dir.value = 'ltr';\n      tooltipDirective.position = 'after';\n      fixture.changeDetectorRef.markForCheck();\n      tooltipDirective.show(0);\n      fixture.detectChanges();\n      tick(0);\n      fixture.detectChanges();\n      tick(500);\n      const classList = tooltipDirective._overlayRef!.overlayElement.classList;\n      expect(classList).not.toContain('mat-mdc-tooltip-panel-after');\n      expect(classList).not.toContain('mat-mdc-tooltip-panel-before');\n      expect(classList).not.toContain('mat-mdc-tooltip-panel-left');\n      expect(classList).toContain('mat-mdc-tooltip-panel-right');\n      tooltipDirective.hide(0);\n      fixture.detectChanges();\n      tick(0);\n      dir.value = 'rtl';\n      tooltipDirective.show(0);\n      fixture.detectChanges();\n      tick(0);\n      fixture.detectChanges();\n      tick(500);\n      expect(classList).not.toContain('mat-mdc-tooltip-panel-after');\n      expect(classList).not.toContain('mat-mdc-tooltip-panel-before');\n      expect(classList).not.toContain('mat-mdc-tooltip-panel-right');\n      expect(classList).toContain('mat-mdc-tooltip-panel-left');\n    }));\n    it('should clear the show timeout on destroy', fakeAsync(() => {\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.show(1000);\n      fixture.detectChanges();\n      // Note that we aren't asserting anything, but `fakeAsync` will\n      // throw if we have any timers by the end of the test.\n      fixture.destroy();\n      flush();\n    }));\n    it('should clear the hide timeout on destroy', fakeAsync(() => {\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      tick(500);\n      tooltipDirective.hide(1000);\n      fixture.detectChanges();\n      // Note that we aren't asserting anything, but `fakeAsync` will\n      // throw if we have any timers by the end of the test.\n      fixture.destroy();\n      flush();\n    }));\n    it('should set the multiline class on tooltips with messages that overflow', fakeAsync(() => {\n      fixture.componentInstance.message =\n        'This is a very long message that should cause the' +\n        'tooltip message body to overflow onto a new line.';\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick();\n      // Need to detect changes again to wait for the multiline class to be applied.\n      fixture.detectChanges();\n      const tooltipElement = overlayContainerElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;\n      expect(tooltipElement.classList).toContain('mdc-tooltip--multiline');\n      expect(tooltipDirective._tooltipInstance?._isMultiline).toBeTrue();\n    }));\n    it('should hide on mouseleave on the trigger', fakeAsync(() => {\n      // We don't bind mouse events on mobile devices.\n      if (platform.IOS || platform.ANDROID) {\n        return;\n      }\n      dispatchMouseEvent(fixture.componentInstance.button.nativeElement, 'mouseenter');\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      dispatchMouseEvent(fixture.componentInstance.button.nativeElement, 'mouseleave');\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n    }));\n    it('should not hide on mouseleave if the pointer goes from the trigger to the tooltip', fakeAsync(() => {\n      // We don't bind mouse events on mobile devices.\n      if (platform.IOS || platform.ANDROID) {\n        return;\n      }\n      dispatchMouseEvent(fixture.componentInstance.button.nativeElement, 'mouseenter');\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      const tooltipElement = overlayContainerElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;\n      const event = createMouseEvent('mouseleave');\n      Object.defineProperty(event, 'relatedTarget', {value: tooltipElement});\n      dispatchEvent(fixture.componentInstance.button.nativeElement, event);\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n    }));\n    it('should hide on mouseleave on the tooltip', fakeAsync(() => {\n      // We don't bind mouse events on mobile devices.\n      if (platform.IOS || platform.ANDROID) {\n        return;\n      }\n      dispatchMouseEvent(fixture.componentInstance.button.nativeElement, 'mouseenter');\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      const tooltipElement = overlayContainerElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;\n      dispatchMouseEvent(tooltipElement, 'mouseleave');\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n    }));\n    it('should not hide on mouseleave if the pointer goes from the tooltip to the trigger', fakeAsync(() => {\n      // We don't bind mouse events on mobile devices.\n      if (platform.IOS || platform.ANDROID) {\n        return;\n      }\n      dispatchMouseEvent(fixture.componentInstance.button.nativeElement, 'mouseenter');\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      const tooltipElement = overlayContainerElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;\n      const event = createMouseEvent('mouseleave');\n      Object.defineProperty(event, 'relatedTarget', {\n        value: fixture.componentInstance.button.nativeElement,\n      });\n      dispatchEvent(tooltipElement, event);\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n    }));\n  }"
        },
        {
          "type": "function",
          "name": "%AM65$%AM64$%AM0",
          "label": "%AM65$%AM64$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\nfixture = instanceinvoke TestBed.<@%unk/%unk: .createComponent()>(BasicTooltipDemo)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%0 = instanceinvoke By.<@%unk/%unk: .css()>('button')\n%1 = fixture.<@%unk/%unk: .debugElement>\n%2 = instanceinvoke %1.<@%unk/%unk: .query()>(%0)\n%3 = %2.<@%unk/%unk: .injector>\ntooltip = instanceinvoke %3.<@%unk/%unk: .get()>(MatTooltip)\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      tooltip = fixture.debugElement.query(By.css('button'))!.injector.get<MatTooltip>(MatTooltip);\n    }"
        },
        {
          "type": "function",
          "name": "%AM66$%AM64$%AM0",
          "label": "%AM66$%AM64$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\ntooltip.<@%unk/%unk: .position> = 'left'\n%0 = instanceinvoke tooltip.<@%unk/%unk: ._getOrigin()>()\n%1 = %0.<@%unk/%unk: .main>\n%2 = %1.<@%unk/%unk: .originX>\n%3 = staticinvoke <@%unk/%unk: .expect()>(%2)\ninstanceinvoke %3.<@%unk/%unk: .toBe()>('start')\n%4 = instanceinvoke tooltip.<@%unk/%unk: ._getOrigin()>()\n%5 = %4.<@%unk/%unk: .fallback>\n%6 = %5.<@%unk/%unk: .originX>\n%7 = staticinvoke <@%unk/%unk: .expect()>(%6)\ninstanceinvoke %7.<@%unk/%unk: .toBe()>('end')\ntooltip.<@%unk/%unk: .position> = 'right'\n%8 = instanceinvoke tooltip.<@%unk/%unk: ._getOrigin()>()\n%9 = %8.<@%unk/%unk: .main>\n%10 = %9.<@%unk/%unk: .originX>\n%11 = staticinvoke <@%unk/%unk: .expect()>(%10)\ninstanceinvoke %11.<@%unk/%unk: .toBe()>('end')\n%12 = instanceinvoke tooltip.<@%unk/%unk: ._getOrigin()>()\n%13 = %12.<@%unk/%unk: .fallback>\n%14 = %13.<@%unk/%unk: .originX>\n%15 = staticinvoke <@%unk/%unk: .expect()>(%14)\ninstanceinvoke %15.<@%unk/%unk: .toBe()>('start')\ntooltip.<@%unk/%unk: .position> = 'above'\n%16 = instanceinvoke tooltip.<@%unk/%unk: ._getOrigin()>()\n%17 = %16.<@%unk/%unk: .main>\n%18 = %17.<@%unk/%unk: .originY>\n%19 = staticinvoke <@%unk/%unk: .expect()>(%18)\ninstanceinvoke %19.<@%unk/%unk: .toBe()>('top')\n%20 = instanceinvoke tooltip.<@%unk/%unk: ._getOrigin()>()\n%21 = %20.<@%unk/%unk: .fallback>\n%22 = %21.<@%unk/%unk: .originY>\n%23 = staticinvoke <@%unk/%unk: .expect()>(%22)\ninstanceinvoke %23.<@%unk/%unk: .toBe()>('bottom')\ntooltip.<@%unk/%unk: .position> = 'below'\n%24 = instanceinvoke tooltip.<@%unk/%unk: ._getOrigin()>()\n%25 = %24.<@%unk/%unk: .main>\n%26 = %25.<@%unk/%unk: .originY>\n%27 = staticinvoke <@%unk/%unk: .expect()>(%26)\ninstanceinvoke %27.<@%unk/%unk: .toBe()>('bottom')\n%28 = instanceinvoke tooltip.<@%unk/%unk: ._getOrigin()>()\n%29 = %28.<@%unk/%unk: .fallback>\n%30 = %29.<@%unk/%unk: .originY>\n%31 = staticinvoke <@%unk/%unk: .expect()>(%30)\ninstanceinvoke %31.<@%unk/%unk: .toBe()>('top')\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      tooltip.position = 'left';\n      expect(tooltip._getOrigin().main.originX).toBe('start');\n      expect(tooltip._getOrigin().fallback.originX).toBe('end');\n      tooltip.position = 'right';\n      expect(tooltip._getOrigin().main.originX).toBe('end');\n      expect(tooltip._getOrigin().fallback.originX).toBe('start');\n      tooltip.position = 'above';\n      expect(tooltip._getOrigin().main.originY).toBe('top');\n      expect(tooltip._getOrigin().fallback.originY).toBe('bottom');\n      tooltip.position = 'below';\n      expect(tooltip._getOrigin().main.originY).toBe('bottom');\n      expect(tooltip._getOrigin().fallback.originY).toBe('top');\n    }"
        },
        {
          "type": "function",
          "name": "%AM67$%AM64$%AM0",
          "label": "%AM67$%AM64$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\ntooltip.<@%unk/%unk: .position> = 'left'\n%0 = instanceinvoke tooltip.<@%unk/%unk: ._getOverlayPosition()>()\n%1 = %0.<@%unk/%unk: .main>\n%2 = %1.<@%unk/%unk: .overlayX>\n%3 = staticinvoke <@%unk/%unk: .expect()>(%2)\ninstanceinvoke %3.<@%unk/%unk: .toBe()>('end')\n%4 = instanceinvoke tooltip.<@%unk/%unk: ._getOverlayPosition()>()\n%5 = %4.<@%unk/%unk: .fallback>\n%6 = %5.<@%unk/%unk: .overlayX>\n%7 = staticinvoke <@%unk/%unk: .expect()>(%6)\ninstanceinvoke %7.<@%unk/%unk: .toBe()>('start')\ntooltip.<@%unk/%unk: .position> = 'right'\n%8 = instanceinvoke tooltip.<@%unk/%unk: ._getOverlayPosition()>()\n%9 = %8.<@%unk/%unk: .main>\n%10 = %9.<@%unk/%unk: .overlayX>\n%11 = staticinvoke <@%unk/%unk: .expect()>(%10)\ninstanceinvoke %11.<@%unk/%unk: .toBe()>('start')\n%12 = instanceinvoke tooltip.<@%unk/%unk: ._getOverlayPosition()>()\n%13 = %12.<@%unk/%unk: .fallback>\n%14 = %13.<@%unk/%unk: .overlayX>\n%15 = staticinvoke <@%unk/%unk: .expect()>(%14)\ninstanceinvoke %15.<@%unk/%unk: .toBe()>('end')\ntooltip.<@%unk/%unk: .position> = 'above'\n%16 = instanceinvoke tooltip.<@%unk/%unk: ._getOverlayPosition()>()\n%17 = %16.<@%unk/%unk: .main>\n%18 = %17.<@%unk/%unk: .overlayY>\n%19 = staticinvoke <@%unk/%unk: .expect()>(%18)\ninstanceinvoke %19.<@%unk/%unk: .toBe()>('bottom')\n%20 = instanceinvoke tooltip.<@%unk/%unk: ._getOverlayPosition()>()\n%21 = %20.<@%unk/%unk: .fallback>\n%22 = %21.<@%unk/%unk: .overlayY>\n%23 = staticinvoke <@%unk/%unk: .expect()>(%22)\ninstanceinvoke %23.<@%unk/%unk: .toBe()>('top')\ntooltip.<@%unk/%unk: .position> = 'below'\n%24 = instanceinvoke tooltip.<@%unk/%unk: ._getOverlayPosition()>()\n%25 = %24.<@%unk/%unk: .main>\n%26 = %25.<@%unk/%unk: .overlayY>\n%27 = staticinvoke <@%unk/%unk: .expect()>(%26)\ninstanceinvoke %27.<@%unk/%unk: .toBe()>('top')\n%28 = instanceinvoke tooltip.<@%unk/%unk: ._getOverlayPosition()>()\n%29 = %28.<@%unk/%unk: .fallback>\n%30 = %29.<@%unk/%unk: .overlayY>\n%31 = staticinvoke <@%unk/%unk: .expect()>(%30)\ninstanceinvoke %31.<@%unk/%unk: .toBe()>('bottom')\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      tooltip.position = 'left';\n      expect(tooltip._getOverlayPosition().main.overlayX).toBe('end');\n      expect(tooltip._getOverlayPosition().fallback.overlayX).toBe('start');\n      tooltip.position = 'right';\n      expect(tooltip._getOverlayPosition().main.overlayX).toBe('start');\n      expect(tooltip._getOverlayPosition().fallback.overlayX).toBe('end');\n      tooltip.position = 'above';\n      expect(tooltip._getOverlayPosition().main.overlayY).toBe('bottom');\n      expect(tooltip._getOverlayPosition().fallback.overlayY).toBe('top');\n      tooltip.position = 'below';\n      expect(tooltip._getOverlayPosition().main.overlayY).toBe('top');\n      expect(tooltip._getOverlayPosition().fallback.overlayY).toBe('bottom');\n    }"
        },
        {
          "type": "function",
          "name": "%AM64$%AM0",
          "label": "%AM64$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\nfixture = undefined\ntooltip = undefined\nstaticinvoke <@%unk/%unk: .beforeEach()>(%AM65$%AM64$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should set a fallback origin position by inverting the main origin position', %AM66$%AM64$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should set a fallback overlay position by inverting the main overlay position', %AM67$%AM64$%AM0)\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n    let fixture: ComponentFixture<BasicTooltipDemo>;\n    let tooltip: MatTooltip;\n    beforeEach(() => {\n      fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      tooltip = fixture.debugElement.query(By.css('button'))!.injector.get<MatTooltip>(MatTooltip);\n    });\n    it('should set a fallback origin position by inverting the main origin position', () => {\n      tooltip.position = 'left';\n      expect(tooltip._getOrigin().main.originX).toBe('start');\n      expect(tooltip._getOrigin().fallback.originX).toBe('end');\n      tooltip.position = 'right';\n      expect(tooltip._getOrigin().main.originX).toBe('end');\n      expect(tooltip._getOrigin().fallback.originX).toBe('start');\n      tooltip.position = 'above';\n      expect(tooltip._getOrigin().main.originY).toBe('top');\n      expect(tooltip._getOrigin().fallback.originY).toBe('bottom');\n      tooltip.position = 'below';\n      expect(tooltip._getOrigin().main.originY).toBe('bottom');\n      expect(tooltip._getOrigin().fallback.originY).toBe('top');\n    });\n    it('should set a fallback overlay position by inverting the main overlay position', () => {\n      tooltip.position = 'left';\n      expect(tooltip._getOverlayPosition().main.overlayX).toBe('end');\n      expect(tooltip._getOverlayPosition().fallback.overlayX).toBe('start');\n      tooltip.position = 'right';\n      expect(tooltip._getOverlayPosition().main.overlayX).toBe('start');\n      expect(tooltip._getOverlayPosition().fallback.overlayX).toBe('end');\n      tooltip.position = 'above';\n      expect(tooltip._getOverlayPosition().main.overlayY).toBe('bottom');\n      expect(tooltip._getOverlayPosition().fallback.overlayY).toBe('top');\n      tooltip.position = 'below';\n      expect(tooltip._getOverlayPosition().main.overlayY).toBe('top');\n      expect(tooltip._getOverlayPosition().fallback.overlayY).toBe('bottom');\n    });\n  }"
        },
        {
          "type": "function",
          "name": "%AM69$%AM68$%AM0",
          "label": "%AM69$%AM68$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\nfixture = instanceinvoke TestBed.<@%unk/%unk: .createComponent()>(ScrollableTooltipDemo)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%0 = instanceinvoke By.<@%unk/%unk: .css()>('button')\n%1 = fixture.<@%unk/%unk: .debugElement>\nbuttonDebugElement = instanceinvoke %1.<@%unk/%unk: .query()>(%0)\n%2 = buttonDebugElement.<@%unk/%unk: .injector>\ntooltipDirective = instanceinvoke %2.<@%unk/%unk: .get()>(MatTooltip)\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      fixture = TestBed.createComponent(ScrollableTooltipDemo);\n      fixture.detectChanges();\n      buttonDebugElement = fixture.debugElement.query(By.css('button'))!;\n      tooltipDirective = buttonDebugElement.injector.get<MatTooltip>(MatTooltip);\n    }"
        },
        {
          "type": "function",
          "name": "%AM70$%AM68$%AM0",
          "label": "%AM70$%AM68$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\nstaticinvoke <@ts_files/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)>(tooltipDirective, false)\ninstanceinvoke tooltipDirective.<@%unk/%unk: .show()>()\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>(0)\n%0 = instanceinvoke tooltipDirective.<@%unk/%unk: ._isTooltipVisible()>()\n%1 = staticinvoke <@%unk/%unk: .expect()>(%0)\n%2 = instanceinvoke %1.<@%unk/%unk: .withContext()>('Expected tooltip to be initially visible')\ninstanceinvoke %2.<@%unk/%unk: .toBe()>(true)\n%3 = fixture.<@%unk/%unk: .componentInstance>\ninstanceinvoke %3.<@%unk/%unk: .scrollDown()>()\n%4 = SCROLL_THROTTLE_MS - 1\nstaticinvoke <@%unk/%unk: .tick()>(%4)\n%5 = instanceinvoke tooltipDirective.<@%unk/%unk: ._isTooltipVisible()>()\n%6 = staticinvoke <@%unk/%unk: .expect()>(%5)\n%7 = instanceinvoke %6.<@%unk/%unk: .withContext()>('Expected tooltip to be visible when scrolling, before throttle limit')\ninstanceinvoke %7.<@%unk/%unk: .toBe()>(true)\nstaticinvoke <@%unk/%unk: .tick()>(100)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%8 = instanceinvoke tooltipDirective.<@%unk/%unk: ._isTooltipVisible()>()\n%9 = staticinvoke <@%unk/%unk: .expect()>(%8)\n%10 = instanceinvoke %9.<@%unk/%unk: .withContext()>('Expected tooltip hidden when scrolled out of view, after throttle limit')\ninstanceinvoke %10.<@%unk/%unk: .toBe()>(false)\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      assertTooltipInstance(tooltipDirective, false);\n      // Show the tooltip and tick for the show delay (default is 0)\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick(0);\n      // Expect that the tooltip is displayed\n      // Expect that the tooltip is displayed\n      expect(tooltipDirective._isTooltipVisible())\n        .withContext('Expected tooltip to be initially visible')\n        .toBe(true);\n      // Scroll the page but tick just before the default throttle should update.\n      fixture.componentInstance.scrollDown();\n      tick(SCROLL_THROTTLE_MS - 1);\n      expect(tooltipDirective._isTooltipVisible())\n        .withContext('Expected tooltip to be visible when scrolling, before throttle limit')\n        .toBe(true);\n      // Finish ticking to the throttle's limit and check that the scroll event notified the\n      // tooltip and it was hidden.\n      tick(100);\n      fixture.detectChanges();\n      expect(tooltipDirective._isTooltipVisible())\n        .withContext('Expected tooltip hidden when scrolled out of view, after throttle limit')\n        .toBe(false);\n    }"
        },
        {
          "type": "function",
          "name": "%AM68$%AM0",
          "label": "%AM68$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\nfixture = undefined\nbuttonDebugElement = undefined\ntooltipDirective = undefined\nstaticinvoke <@%unk/%unk: .beforeEach()>(%AM69$%AM68$%AM0)\n%0 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM70$%AM68$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should hide tooltip if clipped after changing positions', %0)\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n    let fixture: ComponentFixture<ScrollableTooltipDemo>;\n    let buttonDebugElement: DebugElement;\n    let tooltipDirective: MatTooltip;\n    beforeEach(() => {\n      fixture = TestBed.createComponent(ScrollableTooltipDemo);\n      fixture.detectChanges();\n      buttonDebugElement = fixture.debugElement.query(By.css('button'))!;\n      tooltipDirective = buttonDebugElement.injector.get<MatTooltip>(MatTooltip);\n    });\n    it('should hide tooltip if clipped after changing positions', fakeAsync(() => {\n      assertTooltipInstance(tooltipDirective, false);\n      // Show the tooltip and tick for the show delay (default is 0)\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick(0);\n      // Expect that the tooltip is displayed\n      // Expect that the tooltip is displayed\n      expect(tooltipDirective._isTooltipVisible())\n        .withContext('Expected tooltip to be initially visible')\n        .toBe(true);\n      // Scroll the page but tick just before the default throttle should update.\n      fixture.componentInstance.scrollDown();\n      tick(SCROLL_THROTTLE_MS - 1);\n      expect(tooltipDirective._isTooltipVisible())\n        .withContext('Expected tooltip to be visible when scrolling, before throttle limit')\n        .toBe(true);\n      // Finish ticking to the throttle's limit and check that the scroll event notified the\n      // tooltip and it was hidden.\n      tick(100);\n      fixture.detectChanges();\n      expect(tooltipDirective._isTooltipVisible())\n        .withContext('Expected tooltip hidden when scrolled out of view, after throttle limit')\n        .toBe(false);\n    }));\n  }"
        },
        {
          "type": "function",
          "name": "%AM72$%AM71$%AM0",
          "label": "%AM72$%AM71$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\nfixture = instanceinvoke TestBed.<@%unk/%unk: .createComponent()>(OnPushTooltipDemo)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%0 = instanceinvoke By.<@%unk/%unk: .css()>('button')\n%1 = fixture.<@%unk/%unk: .debugElement>\nbuttonDebugElement = instanceinvoke %1.<@%unk/%unk: .query()>(%0)\nbuttonElement = <HTMLButtonElement>buttonDebugElement.<@%unk/%unk: .nativeElement>\n%2 = buttonDebugElement.<@%unk/%unk: .injector>\ntooltipDirective = instanceinvoke %2.<@%unk/%unk: .get()>(MatTooltip)\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      fixture = TestBed.createComponent(OnPushTooltipDemo);\n      fixture.detectChanges();\n      buttonDebugElement = fixture.debugElement.query(By.css('button'))!;\n      buttonElement = <HTMLButtonElement>buttonDebugElement.nativeElement;\n      tooltipDirective = buttonDebugElement.injector.get<MatTooltip>(MatTooltip);\n    }"
        },
        {
          "type": "function",
          "name": "%AM73$%AM71$%AM0",
          "label": "%AM73$%AM71$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\nstaticinvoke <@ts_files/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)>(tooltipDirective, false)\ninstanceinvoke tooltipDirective.<@%unk/%unk: .show()>()\nstaticinvoke <@%unk/%unk: .tick()>(0)\n%0 = instanceinvoke tooltipDirective.<@%unk/%unk: ._isTooltipVisible()>()\n%1 = staticinvoke <@%unk/%unk: .expect()>(%0)\ninstanceinvoke %1.<@%unk/%unk: .toBe()>(true)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@ts_files/139.ts: %dflt.finishCurrentTooltipAnimation(HTMLElement, boolean)>(overlayContainerElement, true)\n%2 = instanceinvoke overlayContainerElement.<@%unk/%unk: .querySelector()>('.mat-mdc-tooltip')\ntooltipElement = <HTMLElement>%2\n%3 = staticinvoke <@%unk/%unk: .expect()>(tooltipElement instanceof HTMLElement)\ninstanceinvoke %3.<@%unk/%unk: .toBe()>(true)\n%4 = tooltipElement.<@%unk/%unk: .classList>\n%5 = staticinvoke <@%unk/%unk: .expect()>(%4)\ninstanceinvoke %5.<@%unk/%unk: .toContain()>('mat-mdc-tooltip-show')\ntooltipDelay = 1000\ninstanceinvoke tooltipDirective.<@%unk/%unk: .hide()>(tooltipDelay)\n%6 = instanceinvoke tooltipDirective.<@%unk/%unk: ._isTooltipVisible()>()\n%7 = staticinvoke <@%unk/%unk: .expect()>(%6)\ninstanceinvoke %7.<@%unk/%unk: .toBe()>(true)\nstaticinvoke <@%unk/%unk: .tick()>(tooltipDelay)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%8 = instanceinvoke tooltipDirective.<@%unk/%unk: ._isTooltipVisible()>()\n%9 = staticinvoke <@%unk/%unk: .expect()>(%8)\ninstanceinvoke %9.<@%unk/%unk: .toBe()>(false)\nstaticinvoke <@ts_files/139.ts: %dflt.finishCurrentTooltipAnimation(HTMLElement, boolean)>(overlayContainerElement, false)\nstaticinvoke <@ts_files/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)>(tooltipDirective, false)\nstaticinvoke <@%unk/%unk: .flush()>()\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.show();\n      tick(0); // Tick for the show delay (default is 0)\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      fixture.detectChanges();\n      // wait until animation has finished\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      // Make sure tooltip is shown to the user and animation has finished\n      const tooltipElement = overlayContainerElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;\n      expect(tooltipElement instanceof HTMLElement).toBe(true);\n      expect(tooltipElement.classList).toContain('mat-mdc-tooltip-show');\n      // After hide called, a timeout delay is created that will to hide the tooltip.\n      const tooltipDelay = 1000;\n      tooltipDirective.hide(tooltipDelay);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      // After the tooltip delay elapses, expect that the tooltip is not visible.\n      tick(tooltipDelay);\n      fixture.detectChanges();\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      // On animation complete, should expect that the tooltip has been detached.\n      finishCurrentTooltipAnimation(overlayContainerElement, false);\n      assertTooltipInstance(tooltipDirective, false);\n      flush();\n    }"
        },
        {
          "type": "function",
          "name": "%AM74$%AM71$%AM0",
          "label": "%AM74$%AM71$%AM0",
          "start_line": 1,
          "end_line": 1073,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\n%0 = platform.<@%unk/%unk: .IOS>\n%1 = platform.<@%unk/%unk: .ANDROID>\n%2 = %0 || %1\nif %2 != false",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "return",
                  "start_line": 66,
                  "end_line": 1276,
                  "successors": []
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "staticinvoke <@%unk/%unk: .dispatchFakeEvent()>(buttonElement, 'mouseenter')\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>(0)\n%3 = instanceinvoke overlayContainerElement.<@%unk/%unk: .querySelector()>('.mat-mdc-tooltip')\ntooltipElement = <HTMLElement>%3\n%4 = tooltipElement.<@%unk/%unk: .textContent>\n%5 = staticinvoke <@%unk/%unk: .expect()>(%4)\ninstanceinvoke %5.<@%unk/%unk: .toContain()>('initial tooltip message')\nreturn",
                  "start_line": 1,
                  "end_line": 1276,
                  "successors": []
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      // We don't bind mouse events on mobile devices.\n      if (platform.IOS || platform.ANDROID) {\n        return;\n      }\n      dispatchFakeEvent(buttonElement, 'mouseenter');\n      fixture.detectChanges();\n      tick(0);\n      const tooltipElement = overlayContainerElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;\n      expect(tooltipElement.textContent).toContain('initial tooltip message');\n    }"
        },
        {
          "type": "function",
          "name": "%AM71$%AM0",
          "label": "%AM71$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\nfixture = undefined\nbuttonDebugElement = undefined\nbuttonElement = undefined\ntooltipDirective = undefined\nstaticinvoke <@%unk/%unk: .beforeEach()>(%AM72$%AM71$%AM0)\n%0 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM73$%AM71$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should show and hide the tooltip', %0)\n%1 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM74$%AM71$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should have rendered the tooltip text on init', %1)\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n    let fixture: ComponentFixture<OnPushTooltipDemo>;\n    let buttonDebugElement: DebugElement;\n    let buttonElement: HTMLButtonElement;\n    let tooltipDirective: MatTooltip;\n    beforeEach(() => {\n      fixture = TestBed.createComponent(OnPushTooltipDemo);\n      fixture.detectChanges();\n      buttonDebugElement = fixture.debugElement.query(By.css('button'))!;\n      buttonElement = <HTMLButtonElement>buttonDebugElement.nativeElement;\n      tooltipDirective = buttonDebugElement.injector.get<MatTooltip>(MatTooltip);\n    });\n    it('should show and hide the tooltip', fakeAsync(() => {\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.show();\n      tick(0); // Tick for the show delay (default is 0)\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      fixture.detectChanges();\n      // wait until animation has finished\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      // Make sure tooltip is shown to the user and animation has finished\n      const tooltipElement = overlayContainerElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;\n      expect(tooltipElement instanceof HTMLElement).toBe(true);\n      expect(tooltipElement.classList).toContain('mat-mdc-tooltip-show');\n      // After hide called, a timeout delay is created that will to hide the tooltip.\n      const tooltipDelay = 1000;\n      tooltipDirective.hide(tooltipDelay);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      // After the tooltip delay elapses, expect that the tooltip is not visible.\n      tick(tooltipDelay);\n      fixture.detectChanges();\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      // On animation complete, should expect that the tooltip has been detached.\n      finishCurrentTooltipAnimation(overlayContainerElement, false);\n      assertTooltipInstance(tooltipDirective, false);\n      flush();\n    }));\n    it('should have rendered the tooltip text on init', fakeAsync(() => {\n      // We don't bind mouse events on mobile devices.\n      if (platform.IOS || platform.ANDROID) {\n        return;\n      }\n      dispatchFakeEvent(buttonElement, 'mouseenter');\n      fixture.detectChanges();\n      tick(0);\n      const tooltipElement = overlayContainerElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;\n      expect(tooltipElement.textContent).toContain('initial tooltip message');\n    }));\n  }"
        },
        {
          "type": "function",
          "name": "%AM76$%AM75$%AM0",
          "label": "%AM76$%AM75$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\nplatform.<@%unk/%unk: .ANDROID> = true\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      platform.ANDROID = true;\n    }"
        },
        {
          "type": "function",
          "name": "%AM77$%AM75$%AM0",
          "label": "%AM77$%AM75$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\nfixture = instanceinvoke TestBed.<@%unk/%unk: .createComponent()>(BasicTooltipDemo)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%0 = fixture.<@%unk/%unk: .nativeElement>\nbutton = instanceinvoke %0.<@%unk/%unk: .querySelector()>('button')\nstaticinvoke <@%unk/%unk: .dispatchFakeEvent()>(button, 'touchstart')\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>(250)\n%1 = fixture.<@%unk/%unk: .componentInstance>\n%2 = %1.<@%unk/%unk: .tooltip>\nstaticinvoke <@ts_files/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)>(%2, false)\nstaticinvoke <@%unk/%unk: .tick()>(500)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@ts_files/139.ts: %dflt.finishCurrentTooltipAnimation(HTMLElement, boolean)>(overlayContainerElement, true)\n%3 = fixture.<@%unk/%unk: .componentInstance>\n%4 = %3.<@%unk/%unk: .tooltip>\nstaticinvoke <@ts_files/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)>(%4, true)\nstaticinvoke <@%unk/%unk: .flush()>()\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      const button: HTMLButtonElement = fixture.nativeElement.querySelector('button');\n      dispatchFakeEvent(button, 'touchstart');\n      fixture.detectChanges();\n      tick(250); // Halfway through the delay.\n      assertTooltipInstance(fixture.componentInstance.tooltip, false);\n      tick(500); // Finish the delay.\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true); // Finish the animation.\n      assertTooltipInstance(fixture.componentInstance.tooltip, true);\n      flush();\n    }"
        },
        {
          "type": "function",
          "name": "%AM78$%AM75$%AM0",
          "label": "%AM78$%AM75$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\nfixture = instanceinvoke TestBed.<@%unk/%unk: .createComponent()>(BasicTooltipDemo)\n%0 = fixture.<@%unk/%unk: .componentInstance>\n%0.<@%unk/%unk: .touchGestures> = 'off'\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%1 = fixture.<@%unk/%unk: .nativeElement>\nbutton = instanceinvoke %1.<@%unk/%unk: .querySelector()>('button')\nstaticinvoke <@%unk/%unk: .dispatchFakeEvent()>(button, 'touchstart')\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>(500)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>(500)\n%2 = fixture.<@%unk/%unk: .componentInstance>\n%3 = %2.<@%unk/%unk: .tooltip>\nstaticinvoke <@ts_files/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)>(%3, false)\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.componentInstance.touchGestures = 'off';\n      fixture.detectChanges();\n      const button: HTMLButtonElement = fixture.nativeElement.querySelector('button');\n      dispatchFakeEvent(button, 'touchstart');\n      fixture.detectChanges();\n      tick(500); // Finish the delay.\n      fixture.detectChanges();\n      tick(500); // Finish the animation.\n      assertTooltipInstance(fixture.componentInstance.tooltip, false);\n    }"
        },
        {
          "type": "function",
          "name": "%AM79$%AM75$%AM0",
          "label": "%AM79$%AM75$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\nfixture = instanceinvoke TestBed.<@%unk/%unk: .createComponent()>(BasicTooltipDemo)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%0 = fixture.<@%unk/%unk: .nativeElement>\nbutton = instanceinvoke %0.<@%unk/%unk: .querySelector()>('button')\nevent = staticinvoke <@%unk/%unk: .dispatchFakeEvent()>(button, 'touchstart')\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%1 = event.<@%unk/%unk: .defaultPrevented>\n%2 = staticinvoke <@%unk/%unk: .expect()>(%1)\ninstanceinvoke %2.<@%unk/%unk: .toBe()>(false)\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      const button: HTMLButtonElement = fixture.nativeElement.querySelector('button');\n      const event = dispatchFakeEvent(button, 'touchstart');\n      fixture.detectChanges();\n      expect(event.defaultPrevented).toBe(false);\n    }"
        },
        {
          "type": "function",
          "name": "%AM80$%AM75$%AM0",
          "label": "%AM80$%AM75$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\nfixture = instanceinvoke TestBed.<@%unk/%unk: .createComponent()>(BasicTooltipDemo)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%0 = fixture.<@%unk/%unk: .nativeElement>\nbutton = instanceinvoke %0.<@%unk/%unk: .querySelector()>('button')\nstaticinvoke <@%unk/%unk: .dispatchFakeEvent()>(button, 'touchstart')\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>(500)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@ts_files/139.ts: %dflt.finishCurrentTooltipAnimation(HTMLElement, boolean)>(overlayContainerElement, true)\n%1 = fixture.<@%unk/%unk: .componentInstance>\n%2 = %1.<@%unk/%unk: .tooltip>\nstaticinvoke <@ts_files/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)>(%2, true)\nstaticinvoke <@%unk/%unk: .dispatchFakeEvent()>(button, 'touchend')\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>(1000)\n%3 = fixture.<@%unk/%unk: .componentInstance>\n%4 = %3.<@%unk/%unk: .tooltip>\nstaticinvoke <@ts_files/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)>(%4, true)\nstaticinvoke <@%unk/%unk: .tick()>(500)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@ts_files/139.ts: %dflt.finishCurrentTooltipAnimation(HTMLElement, boolean)>(overlayContainerElement, false)\n%5 = fixture.<@%unk/%unk: .componentInstance>\n%6 = %5.<@%unk/%unk: .tooltip>\nstaticinvoke <@ts_files/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)>(%6, false)\nstaticinvoke <@%unk/%unk: .flush()>()\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      const button: HTMLButtonElement = fixture.nativeElement.querySelector('button');\n      dispatchFakeEvent(button, 'touchstart');\n      fixture.detectChanges();\n      tick(500); // Finish the open delay.\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true); // Finish the animation.\n      assertTooltipInstance(fixture.componentInstance.tooltip, true);\n      dispatchFakeEvent(button, 'touchend');\n      fixture.detectChanges();\n      tick(1000); // 2/3 through the delay\n      assertTooltipInstance(fixture.componentInstance.tooltip, true);\n      tick(500); // Finish the delay.\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, false); // Finish the exit animation.\n      assertTooltipInstance(fixture.componentInstance.tooltip, false);\n      flush();\n    }"
        },
        {
          "type": "function",
          "name": "%AM81$%AM75$%AM0",
          "label": "%AM81$%AM75$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\nfixture = instanceinvoke TestBed.<@%unk/%unk: .createComponent()>(BasicTooltipDemo)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%0 = fixture.<@%unk/%unk: .nativeElement>\nbutton = instanceinvoke %0.<@%unk/%unk: .querySelector()>('button')\nstaticinvoke <@%unk/%unk: .dispatchFakeEvent()>(button, 'touchstart')\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>(500)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@ts_files/139.ts: %dflt.finishCurrentTooltipAnimation(HTMLElement, boolean)>(overlayContainerElement, true)\n%1 = fixture.<@%unk/%unk: .componentInstance>\n%2 = %1.<@%unk/%unk: .tooltip>\nstaticinvoke <@ts_files/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)>(%2, true)\nstaticinvoke <@%unk/%unk: .dispatchFakeEvent()>(button, 'touchcancel')\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>(1000)\n%3 = fixture.<@%unk/%unk: .componentInstance>\n%4 = %3.<@%unk/%unk: .tooltip>\nstaticinvoke <@ts_files/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)>(%4, true)\nstaticinvoke <@%unk/%unk: .tick()>(500)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@ts_files/139.ts: %dflt.finishCurrentTooltipAnimation(HTMLElement, boolean)>(overlayContainerElement, false)\n%5 = fixture.<@%unk/%unk: .componentInstance>\n%6 = %5.<@%unk/%unk: .tooltip>\nstaticinvoke <@ts_files/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)>(%6, false)\nstaticinvoke <@%unk/%unk: .flush()>()\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      const button: HTMLButtonElement = fixture.nativeElement.querySelector('button');\n      dispatchFakeEvent(button, 'touchstart');\n      fixture.detectChanges();\n      tick(500); // Finish the open delay.\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true); // Finish the animation.\n      assertTooltipInstance(fixture.componentInstance.tooltip, true);\n      dispatchFakeEvent(button, 'touchcancel');\n      fixture.detectChanges();\n      tick(1000); // 2/3 through the delay\n      assertTooltipInstance(fixture.componentInstance.tooltip, true);\n      tick(500); // Finish the delay.\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, false); // Finish the exit animation.\n      assertTooltipInstance(fixture.componentInstance.tooltip, false);\n      flush();\n    }"
        },
        {
          "type": "function",
          "name": "%AM82$%AM75$%AM0",
          "label": "%AM82$%AM75$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\nfixture = instanceinvoke TestBed.<@%unk/%unk: .createComponent()>(BasicTooltipDemo)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%0 = fixture.<@%unk/%unk: .nativeElement>\n%1 = instanceinvoke %0.<@%unk/%unk: .querySelector()>('button')\nstyles = %1.<@%unk/%unk: .style>\n%2 = styles.<@%unk/%unk: .touchAction>\n%3 = <any>styles\n%4 = %3.<@%unk/%unk: .webkitUserDrag>\n%5 = %2 || %4\n%6 = staticinvoke <@%unk/%unk: .expect()>(%5)\ninstanceinvoke %6.<@%unk/%unk: .toBe()>('none')\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      const styles = fixture.nativeElement.querySelector('button').style;\n      expect(styles.touchAction || (styles as any).webkitUserDrag).toBe('none');\n    }"
        },
        {
          "type": "function",
          "name": "%AM83$%AM75$%AM0",
          "label": "%AM83$%AM75$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\nfixture = instanceinvoke TestBed.<@%unk/%unk: .createComponent()>(BasicTooltipDemo)\n%0 = fixture.<@%unk/%unk: .componentInstance>\n%0.<@%unk/%unk: .touchGestures> = 'off'\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%1 = fixture.<@%unk/%unk: .nativeElement>\n%2 = instanceinvoke %1.<@%unk/%unk: .querySelector()>('button')\nstyles = %2.<@%unk/%unk: .style>\n%3 = styles.<@%unk/%unk: .touchAction>\n%4 = <any>styles\n%5 = %4.<@%unk/%unk: .webkitUserDrag>\n%6 = %3 || %5\n%7 = staticinvoke <@%unk/%unk: .expect()>(%6)\ninstanceinvoke %7.<@%unk/%unk: .toBeFalsy()>()\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.componentInstance.touchGestures = 'off';\n      fixture.detectChanges();\n      const styles = fixture.nativeElement.querySelector('button').style;\n      expect(styles.touchAction || (styles as any).webkitUserDrag).toBeFalsy();\n    }"
        },
        {
          "type": "function",
          "name": "%AM84$%AM75$%AM0",
          "label": "%AM84$%AM75$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\nfixture = instanceinvoke TestBed.<@%unk/%unk: .createComponent()>(TooltipOnTextFields)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%0 = fixture.<@%unk/%unk: .componentInstance>\n%1 = %0.<@%unk/%unk: .input>\n%2 = %1.<@%unk/%unk: .nativeElement>\ninputStyle = %2.<@%unk/%unk: .style>\n%3 = fixture.<@%unk/%unk: .componentInstance>\n%4 = %3.<@%unk/%unk: .textarea>\n%5 = %4.<@%unk/%unk: .nativeElement>\ntextareaStyle = %5.<@%unk/%unk: .style>\n%6 = inputStyle.<@%unk/%unk: .userSelect>\n%7 = staticinvoke <@%unk/%unk: .expect()>(%6)\ninstanceinvoke %7.<@%unk/%unk: .toBeFalsy()>()\n%8 = inputStyle.<@%unk/%unk: .webkitUserSelect>\n%9 = staticinvoke <@%unk/%unk: .expect()>(%8)\ninstanceinvoke %9.<@%unk/%unk: .toBeFalsy()>()\n%10 = <any>inputStyle\n%11 = %10.<@%unk/%unk: .msUserSelect>\n%12 = staticinvoke <@%unk/%unk: .expect()>(%11)\ninstanceinvoke %12.<@%unk/%unk: .toBeFalsy()>()\n%13 = <any>inputStyle\n%14 = %13.<@%unk/%unk: .MozUserSelect>\n%15 = staticinvoke <@%unk/%unk: .expect()>(%14)\ninstanceinvoke %15.<@%unk/%unk: .toBeFalsy()>()\n%16 = textareaStyle.<@%unk/%unk: .userSelect>\n%17 = staticinvoke <@%unk/%unk: .expect()>(%16)\ninstanceinvoke %17.<@%unk/%unk: .toBeFalsy()>()\n%18 = textareaStyle.<@%unk/%unk: .webkitUserSelect>\n%19 = staticinvoke <@%unk/%unk: .expect()>(%18)\ninstanceinvoke %19.<@%unk/%unk: .toBeFalsy()>()\n%20 = <any>textareaStyle\n%21 = %20.<@%unk/%unk: .msUserSelect>\n%22 = staticinvoke <@%unk/%unk: .expect()>(%21)\ninstanceinvoke %22.<@%unk/%unk: .toBeFalsy()>()\n%23 = <any>textareaStyle\n%24 = %23.<@%unk/%unk: .MozUserSelect>\n%25 = staticinvoke <@%unk/%unk: .expect()>(%24)\ninstanceinvoke %25.<@%unk/%unk: .toBeFalsy()>()\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      const fixture = TestBed.createComponent(TooltipOnTextFields);\n      fixture.detectChanges();\n      const inputStyle = fixture.componentInstance.input.nativeElement.style;\n      const textareaStyle = fixture.componentInstance.textarea.nativeElement.style;\n      expect(inputStyle.userSelect).toBeFalsy();\n      expect(inputStyle.webkitUserSelect).toBeFalsy();\n      expect((inputStyle as any).msUserSelect).toBeFalsy();\n      expect((inputStyle as any).MozUserSelect).toBeFalsy();\n      expect(textareaStyle.userSelect).toBeFalsy();\n      expect(textareaStyle.webkitUserSelect).toBeFalsy();\n      expect((textareaStyle as any).msUserSelect).toBeFalsy();\n      expect((textareaStyle as any).MozUserSelect).toBeFalsy();\n    }"
        },
        {
          "type": "function",
          "name": "%AM85$%AM75$%AM0",
          "label": "%AM85$%AM75$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\nfixture = instanceinvoke TestBed.<@%unk/%unk: .createComponent()>(TooltipOnTextFields)\n%0 = fixture.<@%unk/%unk: .componentInstance>\n%0.<@%unk/%unk: .touchGestures> = 'on'\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%1 = fixture.<@%unk/%unk: .componentInstance>\n%2 = %1.<@%unk/%unk: .input>\n%3 = %2.<@%unk/%unk: .nativeElement>\ninputStyle = %3.<@%unk/%unk: .style>\n%4 = inputStyle.<@%unk/%unk: .userSelect>\n%5 = inputStyle.<@%unk/%unk: .webkitUserSelect>\n%6 = %4 || %5\n%7 = <any>inputStyle\n%8 = %7.<@%unk/%unk: .msUserSelect>\n%9 = %6 || %8\n%10 = <any>inputStyle\n%11 = %10.<@%unk/%unk: .MozUserSelect>\ninputUserSelect = %9 || %11\n%12 = fixture.<@%unk/%unk: .componentInstance>\n%13 = %12.<@%unk/%unk: .textarea>\n%14 = %13.<@%unk/%unk: .nativeElement>\ntextareaStyle = %14.<@%unk/%unk: .style>\n%15 = textareaStyle.<@%unk/%unk: .userSelect>\n%16 = textareaStyle.<@%unk/%unk: .webkitUserSelect>\n%17 = %15 || %16\n%18 = <any>textareaStyle\n%19 = %18.<@%unk/%unk: .msUserSelect>\n%20 = %17 || %19\n%21 = <any>textareaStyle\n%22 = %21.<@%unk/%unk: .MozUserSelect>\ntextareaUserSelect = %20 || %22\n%23 = staticinvoke <@%unk/%unk: .expect()>(inputUserSelect)\ninstanceinvoke %23.<@%unk/%unk: .toBe()>('none')\n%24 = staticinvoke <@%unk/%unk: .expect()>(textareaUserSelect)\ninstanceinvoke %24.<@%unk/%unk: .toBe()>('none')\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      const fixture = TestBed.createComponent(TooltipOnTextFields);\n      fixture.componentInstance.touchGestures = 'on';\n      fixture.detectChanges();\n      const inputStyle = fixture.componentInstance.input.nativeElement.style;\n      const inputUserSelect =\n        inputStyle.userSelect ||\n        inputStyle.webkitUserSelect ||\n        (inputStyle as any).msUserSelect ||\n        (inputStyle as any).MozUserSelect;\n      const textareaStyle = fixture.componentInstance.textarea.nativeElement.style;\n      const textareaUserSelect =\n        textareaStyle.userSelect ||\n        textareaStyle.webkitUserSelect ||\n        (textareaStyle as any).msUserSelect ||\n        (textareaStyle as any).MozUserSelect;\n      expect(inputUserSelect).toBe('none');\n      expect(textareaUserSelect).toBe('none');\n    }"
        },
        {
          "type": "function",
          "name": "%AM86$%AM75$%AM0",
          "label": "%AM86$%AM75$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\nfixture = instanceinvoke TestBed.<@%unk/%unk: .createComponent()>(TooltipOnDraggableElement)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%0 = fixture.<@%unk/%unk: .componentInstance>\n%1 = %0.<@%unk/%unk: .button>\n%2 = %1.<@%unk/%unk: .nativeElement>\n%3 = %2.<@%unk/%unk: .style>\n%4 = %3.<@%unk/%unk: .webkitUserDrag>\n%5 = staticinvoke <@%unk/%unk: .expect()>(%4)\ninstanceinvoke %5.<@%unk/%unk: .toBeFalsy()>()\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      const fixture = TestBed.createComponent(TooltipOnDraggableElement);\n      fixture.detectChanges();\n      expect(fixture.componentInstance.button.nativeElement.style.webkitUserDrag).toBeFalsy();\n    }"
        },
        {
          "type": "function",
          "name": "%AM87$%AM75$%AM0",
          "label": "%AM87$%AM75$%AM0",
          "start_line": 1,
          "end_line": 1216,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\nfixture = instanceinvoke TestBed.<@%unk/%unk: .createComponent()>(TooltipOnDraggableElement)\n%0 = fixture.<@%unk/%unk: .componentInstance>\n%0.<@%unk/%unk: .touchGestures> = 'on'\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%1 = fixture.<@%unk/%unk: .componentInstance>\n%2 = %1.<@%unk/%unk: .button>\n%3 = %2.<@%unk/%unk: .nativeElement>\nstyles = %3.<@%unk/%unk: .style>\nif undefined != 0",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%4 = styles.<@%unk/%unk: .webkitUserDrag>\n%5 = staticinvoke <@%unk/%unk: .expect()>(%4)\ninstanceinvoke %5.<@%unk/%unk: .toBe()>('none')",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "return",
                      "start_line": 66,
                      "end_line": 1276,
                      "successors": []
                    }
                  ]
                },
                {
                  "type": "blockRef",
                  "label": "(RepeatedBlock)"
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      const fixture = TestBed.createComponent(TooltipOnDraggableElement);\n      fixture.componentInstance.touchGestures = 'on';\n      fixture.detectChanges();\n      const styles = fixture.componentInstance.button.nativeElement.style;\n      if ('webkitUserDrag' in styles) {\n        expect(styles.webkitUserDrag).toBe('none');\n      }\n    }"
        },
        {
          "type": "function",
          "name": "%AM88$%AM75$%AM0",
          "label": "%AM88$%AM75$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\nplatform.<@%unk/%unk: .IOS> = true\nplatform.<@%unk/%unk: .ANDROID> = false\nfixture = instanceinvoke TestBed.<@%unk/%unk: .createComponent()>(BasicTooltipDemo)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%0 = fixture.<@%unk/%unk: .componentInstance>\n%1 = %0.<@%unk/%unk: .button>\n%2 = %1.<@%unk/%unk: .nativeElement>\nstaticinvoke <@%unk/%unk: .dispatchMouseEvent()>(%2, 'mouseenter')\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%3 = fixture.<@%unk/%unk: .componentInstance>\n%4 = %3.<@%unk/%unk: .tooltip>\nstaticinvoke <@ts_files/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)>(%4, false)\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      platform.IOS = true;\n      platform.ANDROID = false;\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      dispatchMouseEvent(fixture.componentInstance.button.nativeElement, 'mouseenter');\n      fixture.detectChanges();\n      assertTooltipInstance(fixture.componentInstance.tooltip, false);\n    }"
        },
        {
          "type": "function",
          "name": "%AM89$%AM75$%AM0",
          "label": "%AM89$%AM75$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\nplatform.<@%unk/%unk: .ANDROID> = true\nplatform.<@%unk/%unk: .IOS> = false\nfixture = instanceinvoke TestBed.<@%unk/%unk: .createComponent()>(BasicTooltipDemo)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%0 = fixture.<@%unk/%unk: .componentInstance>\n%1 = %0.<@%unk/%unk: .button>\n%2 = %1.<@%unk/%unk: .nativeElement>\nstaticinvoke <@%unk/%unk: .dispatchMouseEvent()>(%2, 'mouseenter')\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%3 = fixture.<@%unk/%unk: .componentInstance>\n%4 = %3.<@%unk/%unk: .tooltip>\nstaticinvoke <@ts_files/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)>(%4, false)\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      platform.ANDROID = true;\n      platform.IOS = false;\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      dispatchMouseEvent(fixture.componentInstance.button.nativeElement, 'mouseenter');\n      fixture.detectChanges();\n      assertTooltipInstance(fixture.componentInstance.tooltip, false);\n    }"
        },
        {
          "type": "function",
          "name": "%AM75$%AM0",
          "label": "%AM75$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\nstaticinvoke <@%unk/%unk: .beforeEach()>(%AM76$%AM75$%AM0)\n%0 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM77$%AM75$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should have a delay when showing on touchstart', %0)\n%1 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM78$%AM75$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should be able to disable opening on touch', %1)\nstaticinvoke <@%unk/%unk: .it()>('should not prevent the default action on touchstart', %AM79$%AM75$%AM0)\n%2 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM80$%AM75$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should close on touchend with a delay', %2)\n%3 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM81$%AM75$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should close on touchcancel with a delay', %3)\nstaticinvoke <@%unk/%unk: .it()>('should disable native touch interactions', %AM82$%AM75$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should allow native touch interactions if touch gestures are turned off', %AM83$%AM75$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should allow text selection on inputs when gestures are set to auto', %AM84$%AM75$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should disable text selection on inputs when gestures are set to on', %AM85$%AM75$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should allow native dragging on draggable elements when gestures are set to auto', %AM86$%AM75$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should disable native dragging on draggable elements when gestures are set to on', %AM87$%AM75$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should not open on `mouseenter` on iOS', %AM88$%AM75$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should not open on `mouseenter` on Android', %AM89$%AM75$%AM0)\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n    beforeEach(() => {\n      platform.ANDROID = true;\n    });\n    it('should have a delay when showing on touchstart', fakeAsync(() => {\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      const button: HTMLButtonElement = fixture.nativeElement.querySelector('button');\n      dispatchFakeEvent(button, 'touchstart');\n      fixture.detectChanges();\n      tick(250); // Halfway through the delay.\n      assertTooltipInstance(fixture.componentInstance.tooltip, false);\n      tick(500); // Finish the delay.\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true); // Finish the animation.\n      assertTooltipInstance(fixture.componentInstance.tooltip, true);\n      flush();\n    }));\n    it('should be able to disable opening on touch', fakeAsync(() => {\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.componentInstance.touchGestures = 'off';\n      fixture.detectChanges();\n      const button: HTMLButtonElement = fixture.nativeElement.querySelector('button');\n      dispatchFakeEvent(button, 'touchstart');\n      fixture.detectChanges();\n      tick(500); // Finish the delay.\n      fixture.detectChanges();\n      tick(500); // Finish the animation.\n      assertTooltipInstance(fixture.componentInstance.tooltip, false);\n    }));\n    it('should not prevent the default action on touchstart', () => {\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      const button: HTMLButtonElement = fixture.nativeElement.querySelector('button');\n      const event = dispatchFakeEvent(button, 'touchstart');\n      fixture.detectChanges();\n      expect(event.defaultPrevented).toBe(false);\n    });\n    it('should close on touchend with a delay', fakeAsync(() => {\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      const button: HTMLButtonElement = fixture.nativeElement.querySelector('button');\n      dispatchFakeEvent(button, 'touchstart');\n      fixture.detectChanges();\n      tick(500); // Finish the open delay.\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true); // Finish the animation.\n      assertTooltipInstance(fixture.componentInstance.tooltip, true);\n      dispatchFakeEvent(button, 'touchend');\n      fixture.detectChanges();\n      tick(1000); // 2/3 through the delay\n      assertTooltipInstance(fixture.componentInstance.tooltip, true);\n      tick(500); // Finish the delay.\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, false); // Finish the exit animation.\n      assertTooltipInstance(fixture.componentInstance.tooltip, false);\n      flush();\n    }));\n    it('should close on touchcancel with a delay', fakeAsync(() => {\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      const button: HTMLButtonElement = fixture.nativeElement.querySelector('button');\n      dispatchFakeEvent(button, 'touchstart');\n      fixture.detectChanges();\n      tick(500); // Finish the open delay.\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true); // Finish the animation.\n      assertTooltipInstance(fixture.componentInstance.tooltip, true);\n      dispatchFakeEvent(button, 'touchcancel');\n      fixture.detectChanges();\n      tick(1000); // 2/3 through the delay\n      assertTooltipInstance(fixture.componentInstance.tooltip, true);\n      tick(500); // Finish the delay.\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, false); // Finish the exit animation.\n      assertTooltipInstance(fixture.componentInstance.tooltip, false);\n      flush();\n    }));\n    it('should disable native touch interactions', () => {\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      const styles = fixture.nativeElement.querySelector('button').style;\n      expect(styles.touchAction || (styles as any).webkitUserDrag).toBe('none');\n    });\n    it('should allow native touch interactions if touch gestures are turned off', () => {\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.componentInstance.touchGestures = 'off';\n      fixture.detectChanges();\n      const styles = fixture.nativeElement.querySelector('button').style;\n      expect(styles.touchAction || (styles as any).webkitUserDrag).toBeFalsy();\n    });\n    it('should allow text selection on inputs when gestures are set to auto', () => {\n      const fixture = TestBed.createComponent(TooltipOnTextFields);\n      fixture.detectChanges();\n      const inputStyle = fixture.componentInstance.input.nativeElement.style;\n      const textareaStyle = fixture.componentInstance.textarea.nativeElement.style;\n      expect(inputStyle.userSelect).toBeFalsy();\n      expect(inputStyle.webkitUserSelect).toBeFalsy();\n      expect((inputStyle as any).msUserSelect).toBeFalsy();\n      expect((inputStyle as any).MozUserSelect).toBeFalsy();\n      expect(textareaStyle.userSelect).toBeFalsy();\n      expect(textareaStyle.webkitUserSelect).toBeFalsy();\n      expect((textareaStyle as any).msUserSelect).toBeFalsy();\n      expect((textareaStyle as any).MozUserSelect).toBeFalsy();\n    });\n    it('should disable text selection on inputs when gestures are set to on', () => {\n      const fixture = TestBed.createComponent(TooltipOnTextFields);\n      fixture.componentInstance.touchGestures = 'on';\n      fixture.detectChanges();\n      const inputStyle = fixture.componentInstance.input.nativeElement.style;\n      const inputUserSelect =\n        inputStyle.userSelect ||\n        inputStyle.webkitUserSelect ||\n        (inputStyle as any).msUserSelect ||\n        (inputStyle as any).MozUserSelect;\n      const textareaStyle = fixture.componentInstance.textarea.nativeElement.style;\n      const textareaUserSelect =\n        textareaStyle.userSelect ||\n        textareaStyle.webkitUserSelect ||\n        (textareaStyle as any).msUserSelect ||\n        (textareaStyle as any).MozUserSelect;\n      expect(inputUserSelect).toBe('none');\n      expect(textareaUserSelect).toBe('none');\n    });\n    it('should allow native dragging on draggable elements when gestures are set to auto', () => {\n      const fixture = TestBed.createComponent(TooltipOnDraggableElement);\n      fixture.detectChanges();\n      expect(fixture.componentInstance.button.nativeElement.style.webkitUserDrag).toBeFalsy();\n    });\n    it('should disable native dragging on draggable elements when gestures are set to on', () => {\n      const fixture = TestBed.createComponent(TooltipOnDraggableElement);\n      fixture.componentInstance.touchGestures = 'on';\n      fixture.detectChanges();\n      const styles = fixture.componentInstance.button.nativeElement.style;\n      if ('webkitUserDrag' in styles) {\n        expect(styles.webkitUserDrag).toBe('none');\n      }\n    });\n    it('should not open on `mouseenter` on iOS', () => {\n      platform.IOS = true;\n      platform.ANDROID = false;\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      dispatchMouseEvent(fixture.componentInstance.button.nativeElement, 'mouseenter');\n      fixture.detectChanges();\n      assertTooltipInstance(fixture.componentInstance.tooltip, false);\n    });\n    it('should not open on `mouseenter` on Android', () => {\n      platform.ANDROID = true;\n      platform.IOS = false;\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      dispatchMouseEvent(fixture.componentInstance.button.nativeElement, 'mouseenter');\n      fixture.detectChanges();\n      assertTooltipInstance(fixture.componentInstance.tooltip, false);\n    });\n  }"
        },
        {
          "type": "function",
          "name": "%AM91$%AM90$%AM0",
          "label": "%AM91$%AM90$%AM0",
          "start_line": 1,
          "end_line": 1245,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\n%0 = platform.<@%unk/%unk: .IOS>\n%1 = platform.<@%unk/%unk: .ANDROID>\n%2 = %0 || %1\nif %2 != false",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "return",
                  "start_line": 66,
                  "end_line": 1276,
                  "successors": []
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "fixture = instanceinvoke TestBed.<@%unk/%unk: .createComponent()>(BasicTooltipDemo)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%3 = fixture.<@%unk/%unk: .nativeElement>\nbutton = instanceinvoke %3.<@%unk/%unk: .querySelector()>('button')\nstaticinvoke <@%unk/%unk: .dispatchFakeEvent()>(button, 'mouseenter')\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>(500)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@ts_files/139.ts: %dflt.finishCurrentTooltipAnimation(HTMLElement, boolean)>(overlayContainerElement, true)\n%4 = fixture.<@%unk/%unk: .componentInstance>\n%5 = %4.<@%unk/%unk: .tooltip>\nstaticinvoke <@ts_files/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)>(%5, true)\nwheelEvent = staticinvoke <@%unk/%unk: .createFakeEvent()>('wheel')\n%6 = new @ts_files/139.ts: %AC$%dflt$%AM91$%AM90$%AM0$27\ninstanceinvoke %6.<@ts_files/139.ts: %AC$%dflt$%AM91$%AM90$%AM0$27.constructor()>()\ninstanceinvoke Object.<@%unk/%unk: .defineProperties()>(wheelEvent, %6)\nstaticinvoke <@%unk/%unk: .dispatchEvent()>(button, wheelEvent)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>(1500)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@ts_files/139.ts: %dflt.finishCurrentTooltipAnimation(HTMLElement, boolean)>(overlayContainerElement, false)\n%7 = fixture.<@%unk/%unk: .componentInstance>\n%8 = %7.<@%unk/%unk: .tooltip>\nstaticinvoke <@ts_files/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)>(%8, false)\nstaticinvoke <@%unk/%unk: .flush()>()\nreturn",
                  "start_line": 1,
                  "end_line": 1276,
                  "successors": []
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      // We don't bind wheel events on mobile devices.\n      if (platform.IOS || platform.ANDROID) {\n        return;\n      }\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      const button: HTMLButtonElement = fixture.nativeElement.querySelector('button');\n      dispatchFakeEvent(button, 'mouseenter');\n      fixture.detectChanges();\n      tick(500); // Finish the open delay.\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      assertTooltipInstance(fixture.componentInstance.tooltip, true);\n      // Simulate the pointer at the bottom/right of the page.\n      const wheelEvent = createFakeEvent('wheel');\n      Object.defineProperties(wheelEvent, {\n        clientX: {get: () => window.innerWidth},\n        clientY: {get: () => window.innerHeight},\n      });\n      dispatchEvent(button, wheelEvent);\n      fixture.detectChanges();\n      tick(1500); // Finish the delay.\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, false);\n      assertTooltipInstance(fixture.componentInstance.tooltip, false);\n      flush();\n    }"
        },
        {
          "type": "function",
          "name": "%AM92$%AM90$%AM0",
          "label": "%AM92$%AM90$%AM0",
          "start_line": 1,
          "end_line": 1273,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\n%0 = platform.<@%unk/%unk: .IOS>\n%1 = platform.<@%unk/%unk: .ANDROID>\n%2 = %0 || %1\nif %2 != false",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "return",
                  "start_line": 66,
                  "end_line": 1276,
                  "successors": []
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "fixture = instanceinvoke TestBed.<@%unk/%unk: .createComponent()>(BasicTooltipDemo)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\n%3 = fixture.<@%unk/%unk: .nativeElement>\nbutton = instanceinvoke %3.<@%unk/%unk: .querySelector()>('button')\nstaticinvoke <@%unk/%unk: .dispatchFakeEvent()>(button, 'mouseenter')\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>(500)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@ts_files/139.ts: %dflt.finishCurrentTooltipAnimation(HTMLElement, boolean)>(overlayContainerElement, true)\n%4 = fixture.<@%unk/%unk: .componentInstance>\n%5 = %4.<@%unk/%unk: .tooltip>\nstaticinvoke <@ts_files/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)>(%5, true)\ntriggerRect = instanceinvoke button.<@%unk/%unk: .getBoundingClientRect()>()\nwheelEvent = staticinvoke <@%unk/%unk: .createFakeEvent()>('wheel')\n%6 = new @ts_files/139.ts: %AC$%dflt$%AM92$%AM90$%AM0$30\ninstanceinvoke %6.<@ts_files/139.ts: %AC$%dflt$%AM92$%AM90$%AM0$30.constructor()>()\ninstanceinvoke Object.<@%unk/%unk: .defineProperties()>(wheelEvent, %6)\nstaticinvoke <@%unk/%unk: .dispatchEvent()>(button, wheelEvent)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@%unk/%unk: .tick()>(1500)\ninstanceinvoke fixture.<@%unk/%unk: .detectChanges()>()\nstaticinvoke <@ts_files/139.ts: %dflt.finishCurrentTooltipAnimation(HTMLElement, boolean)>(overlayContainerElement, false)\n%7 = fixture.<@%unk/%unk: .componentInstance>\n%8 = %7.<@%unk/%unk: .tooltip>\nstaticinvoke <@ts_files/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)>(%8, true)\nstaticinvoke <@%unk/%unk: .flush()>()\nreturn",
                  "start_line": 1,
                  "end_line": 1276,
                  "successors": []
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      // We don't bind wheel events on mobile devices.\n      if (platform.IOS || platform.ANDROID) {\n        return;\n      }\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      const button: HTMLButtonElement = fixture.nativeElement.querySelector('button');\n      dispatchFakeEvent(button, 'mouseenter');\n      fixture.detectChanges();\n      tick(500); // Finish the open delay.\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      assertTooltipInstance(fixture.componentInstance.tooltip, true);\n      // Simulate the pointer over the trigger.\n      const triggerRect = button.getBoundingClientRect();\n      const wheelEvent = createFakeEvent('wheel');\n      Object.defineProperties(wheelEvent, {\n        clientX: {get: () => triggerRect.left + 1},\n        clientY: {get: () => triggerRect.top + 1},\n      });\n      dispatchEvent(button, wheelEvent);\n      fixture.detectChanges();\n      tick(1500); // Finish the delay.\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, false);\n      assertTooltipInstance(fixture.componentInstance.tooltip, true);\n      flush();\n    }"
        },
        {
          "type": "function",
          "name": "%AM90$%AM0",
          "label": "%AM90$%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\n%0 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM91$%AM90$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should close when a wheel event causes the cursor to leave the trigger', %0)\n%1 = staticinvoke <@%unk/%unk: .fakeAsync()>(%AM92$%AM90$%AM0)\nstaticinvoke <@%unk/%unk: .it()>('should not close if the cursor is over the trigger after a wheel event', %1)\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n    it('should close when a wheel event causes the cursor to leave the trigger', fakeAsync(() => {\n      // We don't bind wheel events on mobile devices.\n      if (platform.IOS || platform.ANDROID) {\n        return;\n      }\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      const button: HTMLButtonElement = fixture.nativeElement.querySelector('button');\n      dispatchFakeEvent(button, 'mouseenter');\n      fixture.detectChanges();\n      tick(500); // Finish the open delay.\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      assertTooltipInstance(fixture.componentInstance.tooltip, true);\n      // Simulate the pointer at the bottom/right of the page.\n      const wheelEvent = createFakeEvent('wheel');\n      Object.defineProperties(wheelEvent, {\n        clientX: {get: () => window.innerWidth},\n        clientY: {get: () => window.innerHeight},\n      });\n      dispatchEvent(button, wheelEvent);\n      fixture.detectChanges();\n      tick(1500); // Finish the delay.\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, false);\n      assertTooltipInstance(fixture.componentInstance.tooltip, false);\n      flush();\n    }));\n    it('should not close if the cursor is over the trigger after a wheel event', fakeAsync(() => {\n      // We don't bind wheel events on mobile devices.\n      if (platform.IOS || platform.ANDROID) {\n        return;\n      }\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      const button: HTMLButtonElement = fixture.nativeElement.querySelector('button');\n      dispatchFakeEvent(button, 'mouseenter');\n      fixture.detectChanges();\n      tick(500); // Finish the open delay.\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      assertTooltipInstance(fixture.componentInstance.tooltip, true);\n      // Simulate the pointer over the trigger.\n      const triggerRect = button.getBoundingClientRect();\n      const wheelEvent = createFakeEvent('wheel');\n      Object.defineProperties(wheelEvent, {\n        clientX: {get: () => triggerRect.left + 1},\n        clientY: {get: () => triggerRect.top + 1},\n      });\n      dispatchEvent(button, wheelEvent);\n      fixture.detectChanges();\n      tick(1500); // Finish the delay.\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, false);\n      assertTooltipInstance(fixture.componentInstance.tooltip, true);\n      flush();\n    }));\n  }"
        },
        {
          "type": "function",
          "name": "%AM0",
          "label": "%AM0",
          "start_line": 1,
          "end_line": 1276,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\noverlayContainerElement = undefined\ndir = undefined\nplatform = undefined\nfocusMonitor = undefined\n%0 = staticinvoke <@%unk/%unk: .waitForAsync()>(%AM1$%AM0)\nstaticinvoke <@%unk/%unk: .beforeEach()>(%0)\nstaticinvoke <@%unk/%unk: .describe()>('basic usage', %AM3$%AM0)\nstaticinvoke <@%unk/%unk: .describe()>('fallback positions', %AM64$%AM0)\nstaticinvoke <@%unk/%unk: .describe()>('scrollable usage', %AM68$%AM0)\nstaticinvoke <@%unk/%unk: .describe()>('with OnPush', %AM71$%AM0)\nstaticinvoke <@%unk/%unk: .describe()>('touch gestures', %AM75$%AM0)\nstaticinvoke <@%unk/%unk: .describe()>('mouse wheel handling', %AM90$%AM0)\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n  let overlayContainerElement: HTMLElement;\n  let dir: {value: Direction; change: Subject<Direction>};\n  let platform: Platform;\n  let focusMonitor: FocusMonitor;\n  beforeEach(waitForAsync(() => {\n    TestBed.configureTestingModule({\n      imports: [\n        MatTooltipModule,\n        OverlayModule,\n        BasicTooltipDemo,\n        ScrollableTooltipDemo,\n        OnPushTooltipDemo,\n        DynamicTooltipsDemo,\n        TooltipOnTextFields,\n        TooltipOnDraggableElement,\n        DataBoundAriaLabelTooltip,\n      ],\n      providers: [\n        {\n          provide: Directionality,\n          useFactory: () => {\n            return (dir = {value: 'ltr', change: new Subject()});\n          },\n        },\n      ],\n    });\n    inject(\n      [OverlayContainer, FocusMonitor, Platform],\n      (oc: OverlayContainer, fm: FocusMonitor, pl: Platform) => {\n        overlayContainerElement = oc.getContainerElement();\n        focusMonitor = fm;\n        platform = pl;\n      },\n    )();\n  }));\n  describe('basic usage', () => {\n    let fixture: ComponentFixture<BasicTooltipDemo>;\n    let buttonDebugElement: DebugElement;\n    let buttonElement: HTMLButtonElement;\n    let tooltipDirective: MatTooltip;\n    beforeEach(fakeAsync(() => {\n      fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      tick();\n      buttonDebugElement = fixture.debugElement.query(By.css('button'))!;\n      buttonElement = buttonDebugElement.nativeElement;\n      tooltipDirective = buttonDebugElement.injector.get<MatTooltip>(MatTooltip);\n    }));\n    it('should show and hide the tooltip', fakeAsync(() => {\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.show();\n      tick(0); // Tick for the show delay (default is 0)\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      fixture.detectChanges();\n      // Wait until animation has finished\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      // Make sure tooltip is shown to the user and animation has finished.\n      const tooltipElement = overlayContainerElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;\n      expect(tooltipElement instanceof HTMLElement).toBe(true);\n      expect(tooltipElement.classList).toContain('mat-mdc-tooltip-show');\n      expect(overlayContainerElement.textContent).toContain(initialTooltipMessage);\n      // After hide is called, a timeout delay is created that will to hide the tooltip.\n      const tooltipDelay = 1000;\n      tooltipDirective.hide(tooltipDelay);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      // After the tooltip delay elapses, expect that the tooltip is not visible.\n      tick(tooltipDelay);\n      fixture.detectChanges();\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      // On animation complete, should expect that the tooltip has been detached.\n      finishCurrentTooltipAnimation(overlayContainerElement, false);\n      assertTooltipInstance(tooltipDirective, false);\n      flush();\n    }));\n    it('should be able to re-open a tooltip if it was closed by detaching the overlay', fakeAsync(() => {\n      tooltipDirective.show();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      tooltipDirective._overlayRef!.detach();\n      tick(0);\n      fixture.detectChanges();\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.show();\n      tick(0);\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      flush();\n    }));\n    it('should show with delay', fakeAsync(() => {\n      assertTooltipInstance(tooltipDirective, false);\n      const tooltipDelay = 1000;\n      tooltipDirective.show(tooltipDelay);\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      fixture.detectChanges();\n      expect(overlayContainerElement.textContent).toContain('');\n      tick(tooltipDelay);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      expect(overlayContainerElement.textContent).toContain(initialTooltipMessage);\n    }));\n    it('should be able to override the default show and hide delays', fakeAsync(() => {\n      TestBed.resetTestingModule().configureTestingModule({\n        imports: [MatTooltipModule, OverlayModule, BasicTooltipDemo],\n        providers: [\n          {\n            provide: MAT_TOOLTIP_DEFAULT_OPTIONS,\n            useValue: {showDelay: 1337, hideDelay: 7331},\n          },\n        ],\n      });\n      fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      tooltipDirective = fixture.debugElement\n        .query(By.css('button'))!\n        .injector.get<MatTooltip>(MatTooltip);\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick();\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      tick(1337);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      tooltipDirective.hide();\n      fixture.detectChanges();\n      tick();\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      tick(7331);\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      flush();\n    }));\n    it('should be able to override the default position', fakeAsync(() => {\n      TestBed.resetTestingModule().configureTestingModule({\n        imports: [MatTooltipModule, OverlayModule],\n        declarations: [TooltipDemoWithoutPositionBinding],\n        providers: [\n          {\n            provide: MAT_TOOLTIP_DEFAULT_OPTIONS,\n            useValue: {position: 'right'},\n          },\n        ],\n      });\n      const newFixture = TestBed.createComponent(TooltipDemoWithoutPositionBinding);\n      newFixture.detectChanges();\n      tooltipDirective = newFixture.debugElement\n        .query(By.css('button'))!\n        .injector.get<MatTooltip>(MatTooltip);\n      tooltipDirective.show();\n      newFixture.detectChanges();\n      tick();\n      expect(tooltipDirective.position).toBe('right');\n      expect(tooltipDirective._getOverlayPosition().main.overlayX).toBe('start');\n      expect(tooltipDirective._getOverlayPosition().fallback.overlayX).toBe('end');\n    }));\n    it('should be able to define a default (global) tooltip class', fakeAsync(() => {\n      TestBed.resetTestingModule().configureTestingModule({\n        declarations: [TooltipDemoWithoutTooltipClassBinding],\n        imports: [MatTooltipModule, OverlayModule],\n        providers: [\n          {\n            provide: MAT_TOOLTIP_DEFAULT_OPTIONS,\n            useValue: {tooltipClass: 'my-default-tooltip-class'},\n          },\n        ],\n      });\n      const fixture = TestBed.createComponent(TooltipDemoWithoutTooltipClassBinding);\n      fixture.detectChanges();\n      tooltipDirective = fixture.componentInstance.tooltip;\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick();\n      const overlayRef = tooltipDirective._overlayRef!;\n      const tooltipElement = overlayRef.overlayElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;\n      expect(tooltipDirective.tooltipClass).toBe('my-default-tooltip-class');\n      expect(tooltipElement.classList).toContain('my-default-tooltip-class');\n    }));\n    it('should be able to provide tooltip class over the custom default one', fakeAsync(() => {\n      TestBed.resetTestingModule().configureTestingModule({\n        declarations: [TooltipDemoWithTooltipClassBinding],\n        imports: [MatTooltipModule, OverlayModule],\n        providers: [\n          {\n            provide: MAT_TOOLTIP_DEFAULT_OPTIONS,\n            useValue: {tooltipClass: 'my-default-tooltip-class'},\n          },\n        ],\n      });\n      const fixture = TestBed.createComponent(TooltipDemoWithTooltipClassBinding);\n      fixture.detectChanges();\n      tooltipDirective = fixture.componentInstance.tooltip;\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick();\n      const overlayRef = tooltipDirective._overlayRef!;\n      const tooltipElement = overlayRef.overlayElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;\n      expect(tooltipDirective.tooltipClass).not.toBe('my-default-tooltip-class');\n      expect(tooltipElement.classList).not.toContain('my-default-tooltip-class');\n      expect(tooltipElement.classList).toContain('fixed-tooltip-class');\n    }));\n    it('should position on the bottom-left by default', fakeAsync(() => {\n      // We don't bind mouse events on mobile devices.\n      if (platform.IOS || platform.ANDROID) {\n        return;\n      }\n      TestBed.resetTestingModule().configureTestingModule({\n        imports: [MatTooltipModule, OverlayModule],\n        declarations: [WideTooltipDemo],\n      });\n      const wideFixture = TestBed.createComponent(WideTooltipDemo);\n      wideFixture.detectChanges();\n      tooltipDirective = wideFixture.debugElement\n        .query(By.css('button'))!\n        .injector.get<MatTooltip>(MatTooltip);\n      const button: HTMLButtonElement = wideFixture.nativeElement.querySelector('button');\n      const triggerRect = button.getBoundingClientRect();\n      dispatchMouseEvent(button, 'mouseenter', triggerRect.right - 100, triggerRect.top + 100);\n      wideFixture.detectChanges();\n      tick();\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      expect(tooltipDirective._overlayRef!.overlayElement.offsetLeft).toBeLessThan(\n        triggerRect.right - 250,\n      );\n      expect(tooltipDirective._overlayRef!.overlayElement.offsetTop).toBeGreaterThanOrEqual(\n        triggerRect.bottom,\n      );\n    }));\n    it('should be able to override the default positionAtOrigin', async () => {\n      // We don't bind mouse events on mobile devices.\n      if (platform.IOS || platform.ANDROID) {\n        return;\n      }\n      TestBed.resetTestingModule().configureTestingModule({\n        imports: [MatTooltipModule, OverlayModule],\n        declarations: [WideTooltipDemo],\n        providers: [\n          {\n            provide: MAT_TOOLTIP_DEFAULT_OPTIONS,\n            useValue: {positionAtOrigin: true},\n          },\n        ],\n      });\n      const wideFixture = TestBed.createComponent(WideTooltipDemo);\n      wideFixture.detectChanges();\n      tooltipDirective = wideFixture.debugElement\n        .query(By.css('button'))!\n        .injector.get<MatTooltip>(MatTooltip);\n      const button: HTMLButtonElement = wideFixture.nativeElement.querySelector('button');\n      const triggerRect = button.getBoundingClientRect();\n      dispatchMouseEvent(button, 'mouseenter', triggerRect.right - 100, triggerRect.top + 100);\n      wideFixture.detectChanges();\n      await new Promise<void>(resolve => setTimeout(resolve));\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      const actualOffsetLeft = tooltipDirective._overlayRef!.overlayElement.offsetLeft;\n      const expectedOffsetLeft = triggerRect.right - 100 - 20;\n      expect(actualOffsetLeft).toBeLessThanOrEqual(expectedOffsetLeft + 1);\n      expect(actualOffsetLeft).toBeGreaterThanOrEqual(expectedOffsetLeft - 1);\n      expect(tooltipDirective._overlayRef!.overlayElement.offsetTop).toBe(triggerRect.top + 100);\n    });\n    it('should be able to disable tooltip interactivity', fakeAsync(() => {\n      TestBed.resetTestingModule().configureTestingModule({\n        imports: [MatTooltipModule, OverlayModule, NoopAnimationsModule],\n        declarations: [TooltipDemoWithoutPositionBinding],\n        providers: [\n          {\n            provide: MAT_TOOLTIP_DEFAULT_OPTIONS,\n            useValue: {disableTooltipInteractivity: true},\n          },\n        ],\n      });\n      const newFixture = TestBed.createComponent(TooltipDemoWithoutPositionBinding);\n      newFixture.detectChanges();\n      tooltipDirective = newFixture.debugElement\n        .query(By.css('button'))!\n        .injector.get<MatTooltip>(MatTooltip);\n      tooltipDirective.show();\n      newFixture.detectChanges();\n      tick();\n      expect(tooltipDirective._overlayRef?.overlayElement.classList).toContain(\n        'mat-mdc-tooltip-panel-non-interactive',\n      );\n    }));\n    it('should set a css class on the overlay panel element', fakeAsync(() => {\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick(0);\n      const overlayRef = tooltipDirective._overlayRef;\n      expect(!!overlayRef).toBeTruthy();\n      expect(overlayRef!.overlayElement.classList)\n        .withContext('Expected the overlay panel element to have the tooltip panel class set.')\n        .toContain('mat-mdc-tooltip-panel');\n    }));\n    it('should not show if disabled', fakeAsync(() => {\n      // Test that disabling the tooltip will not set the tooltip visible\n      tooltipDirective.disabled = true;\n      fixture.changeDetectorRef.markForCheck();\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      // Test to make sure setting disabled to false will show the tooltip\n      // Sanity check to make sure everything was correct before (detectChanges, tick)\n      tooltipDirective.disabled = false;\n      fixture.changeDetectorRef.markForCheck();\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n    }));\n    it('should hide if disabled while visible', fakeAsync(() => {\n      // Display the tooltip with a timeout before hiding.\n      tooltipDirective.hideDelay = 1000;\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      // Set tooltip to be disabled and verify that the tooltip hides.\n      tooltipDirective.disabled = true;\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n    }));\n    it('should hide if the message is cleared while the tooltip is open', fakeAsync(() => {\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      fixture.componentInstance.message = '';\n      fixture.changeDetectorRef.markForCheck();\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n    }));\n    it('should not show if hide is called before delay finishes', waitForAsync(() => {\n      assertTooltipInstance(tooltipDirective, false);\n      const tooltipDelay = 1000;\n      tooltipDirective.show(tooltipDelay);\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      fixture.detectChanges();\n      expect(overlayContainerElement.textContent).toContain('');\n      tooltipDirective.hide();\n      fixture.whenStable().then(() => {\n        expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      });\n    }));\n    it('should not show tooltip if message is not present or empty', () => {\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.message = undefined;\n      fixture.detectChanges();\n      tooltipDirective.show();\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.message = null;\n      fixture.detectChanges();\n      tooltipDirective.show();\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.message = '';\n      fixture.detectChanges();\n      tooltipDirective.show();\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.message = '   ';\n      fixture.detectChanges();\n      tooltipDirective.show();\n      assertTooltipInstance(tooltipDirective, false);\n    });\n    it('should not follow through with hide if show is called after', fakeAsync(() => {\n      tooltipDirective.show();\n      tick(0); // Tick for the show delay (default is 0)\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      // After hide called, a timeout delay is created that will to hide the tooltip.\n      const tooltipDelay = 1000;\n      tooltipDirective.hide(tooltipDelay);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      // Before delay time has passed, call show which should cancel intent to hide tooltip.\n      tooltipDirective.show();\n      tick(tooltipDelay);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n    }));\n    it('should be able to update the tooltip position while open', fakeAsync(() => {\n      tooltipDirective.position = 'below';\n      tooltipDirective.show();\n      tick();\n      assertTooltipInstance(tooltipDirective, true);\n      spyOn(tooltipDirective._overlayRef!, 'updatePosition').and.callThrough();\n      tooltipDirective.position = 'above';\n      fixture.detectChanges();\n      tick();\n      assertTooltipInstance(tooltipDirective, true);\n      expect(tooltipDirective._overlayRef!.updatePosition).toHaveBeenCalled();\n    }));\n    it('should update the tooltip position when the directionality changes', fakeAsync(() => {\n      tooltipDirective.position = 'right';\n      tooltipDirective.show();\n      tick();\n      assertTooltipInstance(tooltipDirective, true);\n      const spy = spyOn(tooltipDirective as any, '_updatePosition').and.callThrough();\n      dir.change.next('rtl');\n      assertTooltipInstance(tooltipDirective, true);\n      expect(spy).toHaveBeenCalled();\n    }));\n    it('should not throw when updating the position for a closed tooltip', fakeAsync(() => {\n      tooltipDirective.position = 'left';\n      tooltipDirective.show(0);\n      fixture.detectChanges();\n      tick();\n      tooltipDirective.hide(0);\n      fixture.detectChanges();\n      tick();\n      finishCurrentTooltipAnimation(overlayContainerElement, false);\n      expect(() => {\n        tooltipDirective.position = 'right';\n        fixture.detectChanges();\n        tick();\n      }).not.toThrow();\n    }));\n    it('should be able to modify the tooltip message', fakeAsync(() => {\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.show();\n      tick(0); // Tick for the show delay (default is 0)\n      expect(tooltipDirective._tooltipInstance!.isVisible()).toBe(true);\n      fixture.detectChanges();\n      expect(overlayContainerElement.textContent).toContain(initialTooltipMessage);\n      const newMessage = 'new tooltip message';\n      tooltipDirective.message = newMessage;\n      fixture.detectChanges();\n      expect(overlayContainerElement.textContent).toContain(newMessage);\n    }));\n    it('should allow extra classes to be set on the tooltip', fakeAsync(() => {\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.show();\n      tick(0); // Tick for the show delay (default is 0)\n      fixture.detectChanges();\n      // Make sure classes aren't prematurely added\n      let tooltipElement = overlayContainerElement.querySelector('.mat-mdc-tooltip') as HTMLElement;\n      expect(tooltipElement.classList).not.toContain(\n        'custom-one',\n        'Expected to not have the class before enabling matTooltipClass',\n      );\n      expect(tooltipElement.classList).not.toContain(\n        'custom-two',\n        'Expected to not have the class before enabling matTooltipClass',\n      );\n      // Enable the classes via ngClass syntax\n      fixture.componentInstance.showTooltipClass = true;\n      fixture.changeDetectorRef.markForCheck();\n      fixture.detectChanges();\n      // Make sure classes are correctly added\n      tooltipElement = overlayContainerElement.querySelector('.mat-mdc-tooltip') as HTMLElement;\n      expect(tooltipElement.classList)\n        .withContext('Expected to have the class after enabling matTooltipClass')\n        .toContain('custom-one');\n      expect(tooltipElement.classList)\n        .withContext('Expected to have the class after enabling matTooltipClass')\n        .toContain('custom-two');\n    }));\n    it('should be removed after parent destroyed', fakeAsync(() => {\n      tooltipDirective.show();\n      tick(0); // Tick for the show delay (default is 0)\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      fixture.destroy();\n      expect(overlayContainerElement.childNodes.length).toBe(0);\n      expect(overlayContainerElement.textContent).toBe('');\n      flush();\n    }));\n    it('should have an aria-describedby element with the tooltip message', fakeAsync(() => {\n      const dynamicTooltipsDemoFixture = TestBed.createComponent(DynamicTooltipsDemo);\n      const dynamicTooltipsComponent = dynamicTooltipsDemoFixture.componentInstance;\n      dynamicTooltipsComponent.tooltips = ['Tooltip One', 'Tooltip Two'];\n      dynamicTooltipsDemoFixture.detectChanges();\n      tick();\n      const buttons = dynamicTooltipsDemoFixture.nativeElement.querySelectorAll('button');\n      const firstButtonAria = buttons[0].getAttribute('aria-describedby');\n      expect(document.querySelector(`#${firstButtonAria}`)!.textContent).toBe('Tooltip One');\n      const secondButtonAria = buttons[1].getAttribute('aria-describedby');\n      expect(document.querySelector(`#${secondButtonAria}`)!.textContent).toBe('Tooltip Two');\n    }));\n    it('should not add an ARIA description for elements that have the same text as a data-bound aria-label', fakeAsync(() => {\n      const ariaLabelFixture = TestBed.createComponent(DataBoundAriaLabelTooltip);\n      ariaLabelFixture.detectChanges();\n      tick();\n      const button = ariaLabelFixture.nativeElement.querySelector('button');\n      expect(button.getAttribute('aria-describedby')).toBeFalsy();\n    }));\n    it('should toggle aria-describedby depending on whether the tooltip is disabled', fakeAsync(() => {\n      expect(buttonElement.getAttribute('aria-describedby')).toBeTruthy();\n      fixture.componentInstance.tooltipDisabled = true;\n      fixture.changeDetectorRef.markForCheck();\n      fixture.detectChanges();\n      tick();\n      expect(buttonElement.hasAttribute('aria-describedby')).toBe(false);\n      fixture.componentInstance.tooltipDisabled = false;\n      fixture.changeDetectorRef.markForCheck();\n      fixture.detectChanges();\n      tick();\n      expect(buttonElement.getAttribute('aria-describedby')).toBeTruthy();\n    }));\n    it('should not try to dispose the tooltip when destroyed and done hiding', fakeAsync(() => {\n      tooltipDirective.show();\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      const tooltipDelay = 1000;\n      tooltipDirective.hide();\n      tick(tooltipDelay); // Change the tooltip state to hidden and trigger animation start\n      fixture.componentInstance.showButton = false;\n      fixture.changeDetectorRef.markForCheck();\n      fixture.detectChanges();\n    }));\n    it('should complete the afterHidden stream when tooltip is destroyed', fakeAsync(() => {\n      tooltipDirective.show();\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      const spy = jasmine.createSpy('complete spy');\n      const subscription = tooltipDirective\n        ._tooltipInstance!.afterHidden()\n        .subscribe({complete: spy});\n      tooltipDirective.hide(0);\n      tick(0);\n      fixture.detectChanges();\n      expect(spy).toHaveBeenCalled();\n      subscription.unsubscribe();\n    }));\n    it('should consistently position before and after overlay origin in ltr and rtl dir', () => {\n      tooltipDirective.position = 'left';\n      const leftOrigin = tooltipDirective._getOrigin().main;\n      tooltipDirective.position = 'right';\n      const rightOrigin = tooltipDirective._getOrigin().main;\n      // Test expectations in LTR\n      tooltipDirective.position = 'before';\n      expect(tooltipDirective._getOrigin().main).toEqual(leftOrigin);\n      tooltipDirective.position = 'after';\n      expect(tooltipDirective._getOrigin().main).toEqual(rightOrigin);\n      // Test expectations in RTL\n      dir.value = 'rtl';\n      tooltipDirective.position = 'before';\n      expect(tooltipDirective._getOrigin().main).toEqual(leftOrigin);\n      tooltipDirective.position = 'after';\n      expect(tooltipDirective._getOrigin().main).toEqual(rightOrigin);\n    });\n    it('should consistently position before and after overlay position in ltr and rtl dir', () => {\n      tooltipDirective.position = 'left';\n      const leftOverlayPosition = tooltipDirective._getOverlayPosition().main;\n      tooltipDirective.position = 'right';\n      const rightOverlayPosition = tooltipDirective._getOverlayPosition().main;\n      // Test expectations in LTR\n      tooltipDirective.position = 'before';\n      expect(tooltipDirective._getOverlayPosition().main).toEqual(leftOverlayPosition);\n      tooltipDirective.position = 'after';\n      expect(tooltipDirective._getOverlayPosition().main).toEqual(rightOverlayPosition);\n      // Test expectations in RTL\n      dir.value = 'rtl';\n      tooltipDirective.position = 'before';\n      expect(tooltipDirective._getOverlayPosition().main).toEqual(leftOverlayPosition);\n      tooltipDirective.position = 'after';\n      expect(tooltipDirective._getOverlayPosition().main).toEqual(rightOverlayPosition);\n    });\n    it('should throw when trying to assign an invalid position', () => {\n      expect(() => {\n        fixture.componentInstance.position = 'everywhere';\n        fixture.changeDetectorRef.markForCheck();\n        fixture.detectChanges();\n        tooltipDirective.show();\n      }).toThrowError('Tooltip position \"everywhere\" is invalid.');\n    });\n    it('should pass the layout direction to the tooltip', fakeAsync(() => {\n      dir.value = 'rtl';\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      const tooltipWrapper = overlayContainerElement.querySelector(\n        '.cdk-overlay-connected-position-bounding-box',\n      )!;\n      expect(tooltipWrapper).withContext('Expected tooltip to be shown.').toBeTruthy();\n      expect(tooltipWrapper.getAttribute('dir'))\n        .withContext('Expected tooltip to be in RTL mode.')\n        .toBe('rtl');\n    }));\n    it('should keep the overlay direction in sync with the trigger direction', fakeAsync(() => {\n      dir.value = 'rtl';\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      let tooltipWrapper = overlayContainerElement.querySelector(\n        '.cdk-overlay-connected-position-bounding-box',\n      )!;\n      expect(tooltipWrapper.getAttribute('dir'))\n        .withContext('Expected tooltip to be in RTL.')\n        .toBe('rtl');\n      tooltipDirective.hide(0);\n      tick(0);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, false);\n      dir.value = 'ltr';\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      tooltipWrapper = overlayContainerElement.querySelector(\n        '.cdk-overlay-connected-position-bounding-box',\n      )!;\n      expect(tooltipWrapper.getAttribute('dir'))\n        .withContext('Expected tooltip to be in LTR.')\n        .toBe('ltr');\n      flush();\n    }));\n    it('should be able to set the tooltip message as a number', fakeAsync(() => {\n      fixture.componentInstance.message = 100;\n      fixture.changeDetectorRef.markForCheck();\n      fixture.detectChanges();\n      expect(tooltipDirective.message).toBe('100');\n    }));\n    it('should hide when clicking away', fakeAsync(() => {\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      expect(overlayContainerElement.textContent).toContain(initialTooltipMessage);\n      document.body.click();\n      tick(0);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, false);\n      fixture.detectChanges();\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      expect(overlayContainerElement.textContent).toBe('');\n    }));\n    it('should hide when clicking away with an auxilliary button', fakeAsync(() => {\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      expect(overlayContainerElement.textContent).toContain(initialTooltipMessage);\n      dispatchFakeEvent(document.body, 'auxclick');\n      tick(0);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, false);\n      fixture.detectChanges();\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      expect(overlayContainerElement.textContent).toBe('');\n    }));\n    it('should not hide immediately if a click fires while animating', fakeAsync(() => {\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      document.body.click();\n      fixture.detectChanges();\n      tick(500);\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      expect(overlayContainerElement.textContent).toContain(initialTooltipMessage);\n      flush();\n    }));\n    it('should hide when pressing escape', fakeAsync(() => {\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      tick(500);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      expect(overlayContainerElement.textContent).toContain(initialTooltipMessage);\n      dispatchKeyboardEvent(document.body, 'keydown', ESCAPE);\n      tick(0);\n      fixture.detectChanges();\n      tick(500);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, false);\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      expect(overlayContainerElement.textContent).toBe('');\n      flush();\n    }));\n    it('should not throw when pressing ESCAPE', fakeAsync(() => {\n      expect(() => {\n        dispatchKeyboardEvent(document.body, 'keydown', ESCAPE);\n        fixture.detectChanges();\n      }).not.toThrow();\n      // Flush due to the additional tick that is necessary for the FocusMonitor.\n      flush();\n    }));\n    it('should preventDefault when pressing ESCAPE', fakeAsync(() => {\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      const event = dispatchKeyboardEvent(document.body, 'keydown', ESCAPE);\n      fixture.detectChanges();\n      flush();\n      expect(event.defaultPrevented).toBe(true);\n    }));\n    it('should not preventDefault when pressing ESCAPE with a modifier', fakeAsync(() => {\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      const event = createKeyboardEvent('keydown', ESCAPE, undefined, {alt: true});\n      dispatchEvent(document.body, event);\n      fixture.detectChanges();\n      flush();\n      expect(event.defaultPrevented).toBe(false);\n    }));\n    it('should not show the tooltip on programmatic focus', fakeAsync(() => {\n      patchElementFocus(buttonElement);\n      assertTooltipInstance(tooltipDirective, false);\n      focusMonitor.focusVia(buttonElement, 'program');\n      tick(0);\n      fixture.detectChanges();\n      tick(500);\n      expect(overlayContainerElement.querySelector('.mat-mdc-tooltip')).toBeNull();\n    }));\n    it('should not show the tooltip on mouse focus', fakeAsync(() => {\n      patchElementFocus(buttonElement);\n      assertTooltipInstance(tooltipDirective, false);\n      focusMonitor.focusVia(buttonElement, 'mouse');\n      tick(0);\n      fixture.detectChanges();\n      tick(500);\n      expect(overlayContainerElement.querySelector('.mat-mdc-tooltip')).toBeNull();\n    }));\n    it('should not show the tooltip on touch focus', fakeAsync(() => {\n      patchElementFocus(buttonElement);\n      assertTooltipInstance(tooltipDirective, false);\n      focusMonitor.focusVia(buttonElement, 'touch');\n      tick(0);\n      fixture.detectChanges();\n      tick(500);\n      expect(overlayContainerElement.querySelector('.mat-mdc-tooltip')).toBeNull();\n    }));\n    it('should not hide the tooltip when calling `show` twice in a row', fakeAsync(() => {\n      tooltipDirective.show();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      const overlayRef = tooltipDirective._overlayRef!;\n      spyOn(overlayRef, 'detach').and.callThrough();\n      tooltipDirective.show();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      expect(overlayRef.detach).not.toHaveBeenCalled();\n      flush();\n    }));\n    it('should set a class on the overlay panel that reflects the position', fakeAsync(() => {\n      // Move the element so that the primary position is always used.\n      buttonElement.style.position = 'fixed';\n      buttonElement.style.top = buttonElement.style.left = '200px';\n      fixture.componentInstance.message = 'hi';\n      fixture.changeDetectorRef.markForCheck();\n      fixture.detectChanges();\n      setPositionAndShow('below');\n      const classList = tooltipDirective._overlayRef!.overlayElement.classList;\n      expect(classList).toContain('mat-mdc-tooltip-panel-below');\n      setPositionAndShow('above');\n      expect(classList).not.toContain('mat-mdc-tooltip-panel-below');\n      expect(classList).toContain('mat-mdc-tooltip-panel-above');\n      setPositionAndShow('left');\n      expect(classList).not.toContain('mat-mdc-tooltip-panel-above');\n      expect(classList).toContain('mat-mdc-tooltip-panel-left');\n      setPositionAndShow('right');\n      expect(classList).not.toContain('mat-mdc-tooltip-panel-left');\n      expect(classList).toContain('mat-mdc-tooltip-panel-right');\n      function setPositionAndShow(position: TooltipPosition) {\n        tooltipDirective.hide(0);\n        fixture.detectChanges();\n        tick(0);\n        tooltipDirective.position = position;\n        tooltipDirective.show(0);\n        fixture.detectChanges();\n        tick(0);\n        fixture.detectChanges();\n        tick(500);\n      }\n    }));\n    it('should account for RTL when setting the tooltip position class', fakeAsync(() => {\n      // Move the element so that the primary position is always used.\n      buttonElement.style.position = 'fixed';\n      buttonElement.style.top = buttonElement.style.left = '200px';\n      fixture.componentInstance.message = 'hi';\n      fixture.changeDetectorRef.markForCheck();\n      fixture.detectChanges();\n      dir.value = 'ltr';\n      tooltipDirective.position = 'after';\n      fixture.changeDetectorRef.markForCheck();\n      tooltipDirective.show(0);\n      fixture.detectChanges();\n      tick(0);\n      fixture.detectChanges();\n      tick(500);\n      const classList = tooltipDirective._overlayRef!.overlayElement.classList;\n      expect(classList).not.toContain('mat-mdc-tooltip-panel-after');\n      expect(classList).not.toContain('mat-mdc-tooltip-panel-before');\n      expect(classList).not.toContain('mat-mdc-tooltip-panel-left');\n      expect(classList).toContain('mat-mdc-tooltip-panel-right');\n      tooltipDirective.hide(0);\n      fixture.detectChanges();\n      tick(0);\n      dir.value = 'rtl';\n      tooltipDirective.show(0);\n      fixture.detectChanges();\n      tick(0);\n      fixture.detectChanges();\n      tick(500);\n      expect(classList).not.toContain('mat-mdc-tooltip-panel-after');\n      expect(classList).not.toContain('mat-mdc-tooltip-panel-before');\n      expect(classList).not.toContain('mat-mdc-tooltip-panel-right');\n      expect(classList).toContain('mat-mdc-tooltip-panel-left');\n    }));\n    it('should clear the show timeout on destroy', fakeAsync(() => {\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.show(1000);\n      fixture.detectChanges();\n      // Note that we aren't asserting anything, but `fakeAsync` will\n      // throw if we have any timers by the end of the test.\n      fixture.destroy();\n      flush();\n    }));\n    it('should clear the hide timeout on destroy', fakeAsync(() => {\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      tick(500);\n      tooltipDirective.hide(1000);\n      fixture.detectChanges();\n      // Note that we aren't asserting anything, but `fakeAsync` will\n      // throw if we have any timers by the end of the test.\n      fixture.destroy();\n      flush();\n    }));\n    it('should set the multiline class on tooltips with messages that overflow', fakeAsync(() => {\n      fixture.componentInstance.message =\n        'This is a very long message that should cause the' +\n        'tooltip message body to overflow onto a new line.';\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick();\n      // Need to detect changes again to wait for the multiline class to be applied.\n      fixture.detectChanges();\n      const tooltipElement = overlayContainerElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;\n      expect(tooltipElement.classList).toContain('mdc-tooltip--multiline');\n      expect(tooltipDirective._tooltipInstance?._isMultiline).toBeTrue();\n    }));\n    it('should hide on mouseleave on the trigger', fakeAsync(() => {\n      // We don't bind mouse events on mobile devices.\n      if (platform.IOS || platform.ANDROID) {\n        return;\n      }\n      dispatchMouseEvent(fixture.componentInstance.button.nativeElement, 'mouseenter');\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      dispatchMouseEvent(fixture.componentInstance.button.nativeElement, 'mouseleave');\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n    }));\n    it('should not hide on mouseleave if the pointer goes from the trigger to the tooltip', fakeAsync(() => {\n      // We don't bind mouse events on mobile devices.\n      if (platform.IOS || platform.ANDROID) {\n        return;\n      }\n      dispatchMouseEvent(fixture.componentInstance.button.nativeElement, 'mouseenter');\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      const tooltipElement = overlayContainerElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;\n      const event = createMouseEvent('mouseleave');\n      Object.defineProperty(event, 'relatedTarget', {value: tooltipElement});\n      dispatchEvent(fixture.componentInstance.button.nativeElement, event);\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n    }));\n    it('should hide on mouseleave on the tooltip', fakeAsync(() => {\n      // We don't bind mouse events on mobile devices.\n      if (platform.IOS || platform.ANDROID) {\n        return;\n      }\n      dispatchMouseEvent(fixture.componentInstance.button.nativeElement, 'mouseenter');\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      const tooltipElement = overlayContainerElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;\n      dispatchMouseEvent(tooltipElement, 'mouseleave');\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n    }));\n    it('should not hide on mouseleave if the pointer goes from the tooltip to the trigger', fakeAsync(() => {\n      // We don't bind mouse events on mobile devices.\n      if (platform.IOS || platform.ANDROID) {\n        return;\n      }\n      dispatchMouseEvent(fixture.componentInstance.button.nativeElement, 'mouseenter');\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      const tooltipElement = overlayContainerElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;\n      const event = createMouseEvent('mouseleave');\n      Object.defineProperty(event, 'relatedTarget', {\n        value: fixture.componentInstance.button.nativeElement,\n      });\n      dispatchEvent(tooltipElement, event);\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n    }));\n  });\n  describe('fallback positions', () => {\n    let fixture: ComponentFixture<BasicTooltipDemo>;\n    let tooltip: MatTooltip;\n    beforeEach(() => {\n      fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      tooltip = fixture.debugElement.query(By.css('button'))!.injector.get<MatTooltip>(MatTooltip);\n    });\n    it('should set a fallback origin position by inverting the main origin position', () => {\n      tooltip.position = 'left';\n      expect(tooltip._getOrigin().main.originX).toBe('start');\n      expect(tooltip._getOrigin().fallback.originX).toBe('end');\n      tooltip.position = 'right';\n      expect(tooltip._getOrigin().main.originX).toBe('end');\n      expect(tooltip._getOrigin().fallback.originX).toBe('start');\n      tooltip.position = 'above';\n      expect(tooltip._getOrigin().main.originY).toBe('top');\n      expect(tooltip._getOrigin().fallback.originY).toBe('bottom');\n      tooltip.position = 'below';\n      expect(tooltip._getOrigin().main.originY).toBe('bottom');\n      expect(tooltip._getOrigin().fallback.originY).toBe('top');\n    });\n    it('should set a fallback overlay position by inverting the main overlay position', () => {\n      tooltip.position = 'left';\n      expect(tooltip._getOverlayPosition().main.overlayX).toBe('end');\n      expect(tooltip._getOverlayPosition().fallback.overlayX).toBe('start');\n      tooltip.position = 'right';\n      expect(tooltip._getOverlayPosition().main.overlayX).toBe('start');\n      expect(tooltip._getOverlayPosition().fallback.overlayX).toBe('end');\n      tooltip.position = 'above';\n      expect(tooltip._getOverlayPosition().main.overlayY).toBe('bottom');\n      expect(tooltip._getOverlayPosition().fallback.overlayY).toBe('top');\n      tooltip.position = 'below';\n      expect(tooltip._getOverlayPosition().main.overlayY).toBe('top');\n      expect(tooltip._getOverlayPosition().fallback.overlayY).toBe('bottom');\n    });\n  });\n  describe('scrollable usage', () => {\n    let fixture: ComponentFixture<ScrollableTooltipDemo>;\n    let buttonDebugElement: DebugElement;\n    let tooltipDirective: MatTooltip;\n    beforeEach(() => {\n      fixture = TestBed.createComponent(ScrollableTooltipDemo);\n      fixture.detectChanges();\n      buttonDebugElement = fixture.debugElement.query(By.css('button'))!;\n      tooltipDirective = buttonDebugElement.injector.get<MatTooltip>(MatTooltip);\n    });\n    it('should hide tooltip if clipped after changing positions', fakeAsync(() => {\n      assertTooltipInstance(tooltipDirective, false);\n      // Show the tooltip and tick for the show delay (default is 0)\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick(0);\n      // Expect that the tooltip is displayed\n      // Expect that the tooltip is displayed\n      expect(tooltipDirective._isTooltipVisible())\n        .withContext('Expected tooltip to be initially visible')\n        .toBe(true);\n      // Scroll the page but tick just before the default throttle should update.\n      fixture.componentInstance.scrollDown();\n      tick(SCROLL_THROTTLE_MS - 1);\n      expect(tooltipDirective._isTooltipVisible())\n        .withContext('Expected tooltip to be visible when scrolling, before throttle limit')\n        .toBe(true);\n      // Finish ticking to the throttle's limit and check that the scroll event notified the\n      // tooltip and it was hidden.\n      tick(100);\n      fixture.detectChanges();\n      expect(tooltipDirective._isTooltipVisible())\n        .withContext('Expected tooltip hidden when scrolled out of view, after throttle limit')\n        .toBe(false);\n    }));\n  });\n  describe('with OnPush', () => {\n    let fixture: ComponentFixture<OnPushTooltipDemo>;\n    let buttonDebugElement: DebugElement;\n    let buttonElement: HTMLButtonElement;\n    let tooltipDirective: MatTooltip;\n    beforeEach(() => {\n      fixture = TestBed.createComponent(OnPushTooltipDemo);\n      fixture.detectChanges();\n      buttonDebugElement = fixture.debugElement.query(By.css('button'))!;\n      buttonElement = <HTMLButtonElement>buttonDebugElement.nativeElement;\n      tooltipDirective = buttonDebugElement.injector.get<MatTooltip>(MatTooltip);\n    });\n    it('should show and hide the tooltip', fakeAsync(() => {\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.show();\n      tick(0); // Tick for the show delay (default is 0)\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      fixture.detectChanges();\n      // wait until animation has finished\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      // Make sure tooltip is shown to the user and animation has finished\n      const tooltipElement = overlayContainerElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;\n      expect(tooltipElement instanceof HTMLElement).toBe(true);\n      expect(tooltipElement.classList).toContain('mat-mdc-tooltip-show');\n      // After hide called, a timeout delay is created that will to hide the tooltip.\n      const tooltipDelay = 1000;\n      tooltipDirective.hide(tooltipDelay);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      // After the tooltip delay elapses, expect that the tooltip is not visible.\n      tick(tooltipDelay);\n      fixture.detectChanges();\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      // On animation complete, should expect that the tooltip has been detached.\n      finishCurrentTooltipAnimation(overlayContainerElement, false);\n      assertTooltipInstance(tooltipDirective, false);\n      flush();\n    }));\n    it('should have rendered the tooltip text on init', fakeAsync(() => {\n      // We don't bind mouse events on mobile devices.\n      if (platform.IOS || platform.ANDROID) {\n        return;\n      }\n      dispatchFakeEvent(buttonElement, 'mouseenter');\n      fixture.detectChanges();\n      tick(0);\n      const tooltipElement = overlayContainerElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;\n      expect(tooltipElement.textContent).toContain('initial tooltip message');\n    }));\n  });\n  describe('touch gestures', () => {\n    beforeEach(() => {\n      platform.ANDROID = true;\n    });\n    it('should have a delay when showing on touchstart', fakeAsync(() => {\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      const button: HTMLButtonElement = fixture.nativeElement.querySelector('button');\n      dispatchFakeEvent(button, 'touchstart');\n      fixture.detectChanges();\n      tick(250); // Halfway through the delay.\n      assertTooltipInstance(fixture.componentInstance.tooltip, false);\n      tick(500); // Finish the delay.\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true); // Finish the animation.\n      assertTooltipInstance(fixture.componentInstance.tooltip, true);\n      flush();\n    }));\n    it('should be able to disable opening on touch', fakeAsync(() => {\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.componentInstance.touchGestures = 'off';\n      fixture.detectChanges();\n      const button: HTMLButtonElement = fixture.nativeElement.querySelector('button');\n      dispatchFakeEvent(button, 'touchstart');\n      fixture.detectChanges();\n      tick(500); // Finish the delay.\n      fixture.detectChanges();\n      tick(500); // Finish the animation.\n      assertTooltipInstance(fixture.componentInstance.tooltip, false);\n    }));\n    it('should not prevent the default action on touchstart', () => {\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      const button: HTMLButtonElement = fixture.nativeElement.querySelector('button');\n      const event = dispatchFakeEvent(button, 'touchstart');\n      fixture.detectChanges();\n      expect(event.defaultPrevented).toBe(false);\n    });\n    it('should close on touchend with a delay', fakeAsync(() => {\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      const button: HTMLButtonElement = fixture.nativeElement.querySelector('button');\n      dispatchFakeEvent(button, 'touchstart');\n      fixture.detectChanges();\n      tick(500); // Finish the open delay.\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true); // Finish the animation.\n      assertTooltipInstance(fixture.componentInstance.tooltip, true);\n      dispatchFakeEvent(button, 'touchend');\n      fixture.detectChanges();\n      tick(1000); // 2/3 through the delay\n      assertTooltipInstance(fixture.componentInstance.tooltip, true);\n      tick(500); // Finish the delay.\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, false); // Finish the exit animation.\n      assertTooltipInstance(fixture.componentInstance.tooltip, false);\n      flush();\n    }));\n    it('should close on touchcancel with a delay', fakeAsync(() => {\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      const button: HTMLButtonElement = fixture.nativeElement.querySelector('button');\n      dispatchFakeEvent(button, 'touchstart');\n      fixture.detectChanges();\n      tick(500); // Finish the open delay.\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true); // Finish the animation.\n      assertTooltipInstance(fixture.componentInstance.tooltip, true);\n      dispatchFakeEvent(button, 'touchcancel');\n      fixture.detectChanges();\n      tick(1000); // 2/3 through the delay\n      assertTooltipInstance(fixture.componentInstance.tooltip, true);\n      tick(500); // Finish the delay.\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, false); // Finish the exit animation.\n      assertTooltipInstance(fixture.componentInstance.tooltip, false);\n      flush();\n    }));\n    it('should disable native touch interactions', () => {\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      const styles = fixture.nativeElement.querySelector('button').style;\n      expect(styles.touchAction || (styles as any).webkitUserDrag).toBe('none');\n    });\n    it('should allow native touch interactions if touch gestures are turned off', () => {\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.componentInstance.touchGestures = 'off';\n      fixture.detectChanges();\n      const styles = fixture.nativeElement.querySelector('button').style;\n      expect(styles.touchAction || (styles as any).webkitUserDrag).toBeFalsy();\n    });\n    it('should allow text selection on inputs when gestures are set to auto', () => {\n      const fixture = TestBed.createComponent(TooltipOnTextFields);\n      fixture.detectChanges();\n      const inputStyle = fixture.componentInstance.input.nativeElement.style;\n      const textareaStyle = fixture.componentInstance.textarea.nativeElement.style;\n      expect(inputStyle.userSelect).toBeFalsy();\n      expect(inputStyle.webkitUserSelect).toBeFalsy();\n      expect((inputStyle as any).msUserSelect).toBeFalsy();\n      expect((inputStyle as any).MozUserSelect).toBeFalsy();\n      expect(textareaStyle.userSelect).toBeFalsy();\n      expect(textareaStyle.webkitUserSelect).toBeFalsy();\n      expect((textareaStyle as any).msUserSelect).toBeFalsy();\n      expect((textareaStyle as any).MozUserSelect).toBeFalsy();\n    });\n    it('should disable text selection on inputs when gestures are set to on', () => {\n      const fixture = TestBed.createComponent(TooltipOnTextFields);\n      fixture.componentInstance.touchGestures = 'on';\n      fixture.detectChanges();\n      const inputStyle = fixture.componentInstance.input.nativeElement.style;\n      const inputUserSelect =\n        inputStyle.userSelect ||\n        inputStyle.webkitUserSelect ||\n        (inputStyle as any).msUserSelect ||\n        (inputStyle as any).MozUserSelect;\n      const textareaStyle = fixture.componentInstance.textarea.nativeElement.style;\n      const textareaUserSelect =\n        textareaStyle.userSelect ||\n        textareaStyle.webkitUserSelect ||\n        (textareaStyle as any).msUserSelect ||\n        (textareaStyle as any).MozUserSelect;\n      expect(inputUserSelect).toBe('none');\n      expect(textareaUserSelect).toBe('none');\n    });\n    it('should allow native dragging on draggable elements when gestures are set to auto', () => {\n      const fixture = TestBed.createComponent(TooltipOnDraggableElement);\n      fixture.detectChanges();\n      expect(fixture.componentInstance.button.nativeElement.style.webkitUserDrag).toBeFalsy();\n    });\n    it('should disable native dragging on draggable elements when gestures are set to on', () => {\n      const fixture = TestBed.createComponent(TooltipOnDraggableElement);\n      fixture.componentInstance.touchGestures = 'on';\n      fixture.detectChanges();\n      const styles = fixture.componentInstance.button.nativeElement.style;\n      if ('webkitUserDrag' in styles) {\n        expect(styles.webkitUserDrag).toBe('none');\n      }\n    });\n    it('should not open on `mouseenter` on iOS', () => {\n      platform.IOS = true;\n      platform.ANDROID = false;\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      dispatchMouseEvent(fixture.componentInstance.button.nativeElement, 'mouseenter');\n      fixture.detectChanges();\n      assertTooltipInstance(fixture.componentInstance.tooltip, false);\n    });\n    it('should not open on `mouseenter` on Android', () => {\n      platform.ANDROID = true;\n      platform.IOS = false;\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      dispatchMouseEvent(fixture.componentInstance.button.nativeElement, 'mouseenter');\n      fixture.detectChanges();\n      assertTooltipInstance(fixture.componentInstance.tooltip, false);\n    });\n  });\n  describe('mouse wheel handling', () => {\n    it('should close when a wheel event causes the cursor to leave the trigger', fakeAsync(() => {\n      // We don't bind wheel events on mobile devices.\n      if (platform.IOS || platform.ANDROID) {\n        return;\n      }\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      const button: HTMLButtonElement = fixture.nativeElement.querySelector('button');\n      dispatchFakeEvent(button, 'mouseenter');\n      fixture.detectChanges();\n      tick(500); // Finish the open delay.\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      assertTooltipInstance(fixture.componentInstance.tooltip, true);\n      // Simulate the pointer at the bottom/right of the page.\n      const wheelEvent = createFakeEvent('wheel');\n      Object.defineProperties(wheelEvent, {\n        clientX: {get: () => window.innerWidth},\n        clientY: {get: () => window.innerHeight},\n      });\n      dispatchEvent(button, wheelEvent);\n      fixture.detectChanges();\n      tick(1500); // Finish the delay.\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, false);\n      assertTooltipInstance(fixture.componentInstance.tooltip, false);\n      flush();\n    }));\n    it('should not close if the cursor is over the trigger after a wheel event', fakeAsync(() => {\n      // We don't bind wheel events on mobile devices.\n      if (platform.IOS || platform.ANDROID) {\n        return;\n      }\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      const button: HTMLButtonElement = fixture.nativeElement.querySelector('button');\n      dispatchFakeEvent(button, 'mouseenter');\n      fixture.detectChanges();\n      tick(500); // Finish the open delay.\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      assertTooltipInstance(fixture.componentInstance.tooltip, true);\n      // Simulate the pointer over the trigger.\n      const triggerRect = button.getBoundingClientRect();\n      const wheelEvent = createFakeEvent('wheel');\n      Object.defineProperties(wheelEvent, {\n        clientX: {get: () => triggerRect.left + 1},\n        clientY: {get: () => triggerRect.top + 1},\n      });\n      dispatchEvent(button, wheelEvent);\n      fixture.detectChanges();\n      tick(1500); // Finish the delay.\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, false);\n      assertTooltipInstance(fixture.componentInstance.tooltip, true);\n      flush();\n    }));\n  });\n}"
        }
      ],
      "classes": [],
      "blocks": [],
      "simplified_code": ""
    },
    {
      "type": "class",
      "name": "BasicTooltipDemo",
      "label": "BasicTooltipDemo",
      "start_line": 1304,
      "end_line": 1304,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "@Component({\n  selector: 'app',\n  template: `\n    @if (showButton) {\n      <button #button\n        [matTooltip]=\"message\"\n        [matTooltipPosition]=\"position\"\n        [matTooltipClass]=\"{'custom-one': showTooltipClass, 'custom-two': showTooltipClass}\"\n        [matTooltipTouchGestures]=\"touchGestures\"\n        [matTooltipDisabled]=\"tooltipDisabled\">Button</button>\n    }`,\n  standalone: true,\n  imports: [MatTooltipModule, OverlayModule],\n})\nclass BasicTooltipDemo {\n  position = 'below';\n  message: any = initialTooltipMessage;\n  showButton = true;\n  showTooltipClass = false;\n  tooltipDisabled = false;\n  touchGestures: TooltipTouchGestures = 'auto';\n  @ViewChild(MatTooltip) tooltip: MatTooltip;\n  @ViewChild('button') button: ElementRef<HTMLButtonElement>;\n}"
    },
    {
      "type": "class",
      "name": "ScrollableTooltipDemo",
      "label": "ScrollableTooltipDemo",
      "start_line": 1,
      "end_line": 1347,
      "functions": [
        {
          "type": "function",
          "name": "scrollDown",
          "label": "scrollDown",
          "start_line": 1,
          "end_line": 1347,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: ScrollableTooltipDemo\n%0 = this.<@ts_files/139.ts: ScrollableTooltipDemo.scrollingContainer>\n%1 = instanceinvoke %0.<@%unk/%unk: .getElementRef()>()\nscrollingContainerEl = %1.<@%unk/%unk: .nativeElement>\nscrollingContainerEl.<@%unk/%unk: .scrollTop> = 250\nstaticinvoke <@%unk/%unk: .dispatchFakeEvent()>(scrollingContainerEl, 'scroll')\nreturn",
              "start_line": 1,
              "end_line": 1276,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "scrollDown() {\n    const scrollingContainerEl = this.scrollingContainer.getElementRef().nativeElement;\n    scrollingContainerEl.scrollTop = 250;\n    // Emit a scroll event from the scrolling element in our component.\n    // This event should be picked up by the scrollable directive and notify.\n    // The notification should be picked up by the service.\n    dispatchFakeEvent(scrollingContainerEl, 'scroll');\n  }"
        }
      ],
      "classes": [],
      "blocks": [],
      "simplified_code": "@Component({\n  selector: 'app',\n  template: `\n    <div cdkScrollable style=\"padding: 100px; margin: 300px;\n                               height: 200px; width: 200px; overflow: auto;\">\n      @if (showButton) {\n        <button style=\"margin-bottom: 600px\"\n              [matTooltip]=\"message\"\n              [matTooltipPosition]=\"position\">Button</button>\n      }\n    </div>`,\n  standalone: true,\n  imports: [MatTooltipModule, OverlayModule],\n})\nclass ScrollableTooltipDemo {\n  position: string = 'below';\n  message: string = initialTooltipMessage;\n  showButton: boolean = true;\n  @ViewChild(CdkScrollable) scrollingContainer: CdkScrollable;\n  scrollDown() {\n    const scrollingContainerEl = this.scrollingContainer.getElementRef().nativeElement;\n    scrollingContainerEl.scrollTop = 250;\n    // Emit a scroll event from the scrolling element in our component.\n    // This event should be picked up by the scrollable directive and notify.\n    // The notification should be picked up by the service.\n    dispatchFakeEvent(scrollingContainerEl, 'scroll');\n  }\n}"
    },
    {
      "type": "class",
      "name": "OnPushTooltipDemo",
      "label": "OnPushTooltipDemo",
      "start_line": 1356,
      "end_line": 1356,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "@Component({\n  selector: 'app',\n  template: `\n    <button [matTooltip]=\"message\"\n            [matTooltipPosition]=\"position\">\n      Button\n    </button>`,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  standalone: true,\n  imports: [MatTooltipModule, OverlayModule],\n})\nclass OnPushTooltipDemo {\n  position: string = 'below';\n  message: string = initialTooltipMessage;\n}"
    },
    {
      "type": "class",
      "name": "DynamicTooltipsDemo",
      "label": "DynamicTooltipsDemo",
      "start_line": 1371,
      "end_line": 1371,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "@Component({\n  selector: 'app',\n  template: `\n    @for (tooltip of tooltips; track tooltip) {\n      <button [matTooltip]=\"tooltip\">Button {{tooltip}}</button>\n    }\n  `,\n  standalone: true,\n  imports: [MatTooltipModule, OverlayModule],\n})\nclass DynamicTooltipsDemo {\n  tooltips: string[] = [];\n}"
    },
    {
      "type": "class",
      "name": "DataBoundAriaLabelTooltip",
      "label": "DataBoundAriaLabelTooltip",
      "start_line": 1384,
      "end_line": 1384,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "@Component({\n  template: `<button [matTooltip]=\"message\" [attr.aria-label]=\"message\">Click me</button>`,\n  standalone: true,\n  imports: [MatTooltipModule, OverlayModule],\n})\nclass DataBoundAriaLabelTooltip {\n  message = 'Hello there';\n}"
    },
    {
      "type": "class",
      "name": "TooltipOnTextFields",
      "label": "TooltipOnTextFields",
      "start_line": 1392,
      "end_line": 1392,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "@Component({\n  template: `\n    <input\n      #input\n      matTooltip=\"Something\"\n      [matTooltipTouchGestures]=\"touchGestures\">\n    <textarea\n      #textarea\n      matTooltip=\"Another thing\"\n      [matTooltipTouchGestures]=\"touchGestures\"></textarea>\n  `,\n  standalone: true,\n  imports: [MatTooltipModule, OverlayModule],\n})\nclass TooltipOnTextFields {\n  @ViewChild('input') input: ElementRef<HTMLInputElement>;\n  @ViewChild('textarea') textarea: ElementRef<HTMLTextAreaElement>;\n  touchGestures: TooltipTouchGestures = 'auto';\n}"
    },
    {
      "type": "class",
      "name": "TooltipOnDraggableElement",
      "label": "TooltipOnDraggableElement",
      "start_line": 1411,
      "end_line": 1411,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "@Component({\n  template: `\n    <button\n      #button\n      draggable=\"true\"\n      matTooltip=\"Drag me\"\n      [matTooltipTouchGestures]=\"touchGestures\"></button>\n  `,\n  standalone: true,\n  imports: [MatTooltipModule, OverlayModule],\n})\nclass TooltipOnDraggableElement {\n  @ViewChild('button') button: ElementRef;\n  touchGestures: TooltipTouchGestures = 'auto';\n}"
    },
    {
      "type": "class",
      "name": "TooltipDemoWithoutPositionBinding",
      "label": "TooltipDemoWithoutPositionBinding",
      "start_line": 1426,
      "end_line": 1426,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "@Component({\n  selector: 'app',\n  template: `<button #button [matTooltip]=\"message\">Button</button>`,\n  standalone: false,\n})\nclass TooltipDemoWithoutPositionBinding {\n  message: any = initialTooltipMessage;\n  @ViewChild(MatTooltip) tooltip: MatTooltip;\n  @ViewChild('button') button: ElementRef<HTMLButtonElement>;\n}"
    },
    {
      "type": "class",
      "name": "TooltipDemoWithoutTooltipClassBinding",
      "label": "TooltipDemoWithoutTooltipClassBinding",
      "start_line": 1436,
      "end_line": 1436,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "@Component({\n  selector: 'app',\n  template: `<button #button [matTooltip]=\"message\">Button</button>`,\n  standalone: false,\n})\nclass TooltipDemoWithoutTooltipClassBinding {\n  message = initialTooltipMessage;\n  @ViewChild(MatTooltip) tooltip: MatTooltip;\n  @ViewChild('button') button: ElementRef<HTMLButtonElement>;\n}"
    },
    {
      "type": "class",
      "name": "TooltipDemoWithTooltipClassBinding",
      "label": "TooltipDemoWithTooltipClassBinding",
      "start_line": 1446,
      "end_line": 1446,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "@Component({\n  selector: 'app',\n  template: `\n    <button #button matTooltipClass=\"fixed-tooltip-class\" [matTooltip]=\"message\">Button</button>\n  `,\n  standalone: false,\n})\nclass TooltipDemoWithTooltipClassBinding {\n  message: any = initialTooltipMessage;\n  @ViewChild(MatTooltip) tooltip: MatTooltip;\n  @ViewChild('button') button: ElementRef<HTMLButtonElement>;\n}"
    },
    {
      "type": "class",
      "name": "WideTooltipDemo",
      "label": "WideTooltipDemo",
      "start_line": 1458,
      "end_line": 1458,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "@Component({\n  selector: 'app',\n  styles: `button { width: 500px; height: 500px; }`,\n  template: `<button #button [matTooltip]=\"message\">Button</button>`,\n  standalone: false,\n})\nclass WideTooltipDemo {\n  message = 'Test';\n  @ViewChild(MatTooltip) tooltip: MatTooltip;\n  @ViewChild('button') button: ElementRef<HTMLButtonElement>;\n}"
    },
    {
      "type": "class",
      "name": "%AC$0",
      "label": "%AC$0",
      "start_line": 46,
      "end_line": 46,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{value: Direction; change: Subject<Direction>}"
    },
    {
      "type": "class",
      "name": "%AC$%AC$%AC$%dflt$%AM1$%AM0$1$%instInit$2$%AM0$%instInit$3",
      "label": "%AC$%AC$%AC$%dflt$%AM1$%AM0$1$%instInit$2$%AM0$%instInit$3",
      "start_line": 66,
      "end_line": 66,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{value: 'ltr', change: new Subject()}"
    },
    {
      "type": "class",
      "name": "%AC$%AC$%dflt$%AM1$%AM0$1$%instInit$2",
      "label": "%AC$%AC$%dflt$%AM1$%AM0$1$%instInit$2",
      "start_line": 1,
      "end_line": 65,
      "functions": [
        {
          "type": "function",
          "name": "%AM0$%instInit",
          "label": "%AM0$%instInit",
          "start_line": 1,
          "end_line": 65,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %AC$%AC$%dflt$%AM1$%AM0$1$%instInit$2\n%0 = new @ts_files/139.ts: %AC$%AC$%AC$%dflt$%AM1$%AM0$1$%instInit$2$%AM0$%instInit$3\ninstanceinvoke %0.<@ts_files/139.ts: %AC$%AC$%AC$%dflt$%AM1$%AM0$1$%instInit$2$%AM0$%instInit$3.constructor()>()\ndir = %0\nreturn dir",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n            return (dir = {value: 'ltr', change: new Subject()});\n          }"
        }
      ],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n          provide: Directionality,\n          useFactory: () => {\n            return (dir = {value: 'ltr', change: new Subject()});\n          },\n        }"
    },
    {
      "type": "class",
      "name": "%AC$%dflt$%AM1$%AM0$1",
      "label": "%AC$%dflt$%AM1$%AM0$1",
      "start_line": 50,
      "end_line": 50,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n      imports: [\n        MatTooltipModule,\n        OverlayModule,\n        BasicTooltipDemo,\n        ScrollableTooltipDemo,\n        OnPushTooltipDemo,\n        DynamicTooltipsDemo,\n        TooltipOnTextFields,\n        TooltipOnDraggableElement,\n        DataBoundAriaLabelTooltip,\n      ],\n      providers: [\n        {\n          provide: Directionality,\n          useFactory: () => {\n            return (dir = {value: 'ltr', change: new Subject()});\n          },\n        },\n      ],\n    }"
    },
    {
      "type": "class",
      "name": "%AC$%AC$%AC$%dflt$%AM8$%AM3$%AM0$4$%instInit$5$%instInit$6",
      "label": "%AC$%AC$%AC$%dflt$%AM8$%AM3$%AM0$4$%instInit$5$%instInit$6",
      "start_line": 155,
      "end_line": 155,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{showDelay: 1337, hideDelay: 7331}"
    },
    {
      "type": "class",
      "name": "%AC$%AC$%dflt$%AM8$%AM3$%AM0$4$%instInit$5",
      "label": "%AC$%AC$%dflt$%AM8$%AM3$%AM0$4$%instInit$5",
      "start_line": 153,
      "end_line": 153,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n            provide: MAT_TOOLTIP_DEFAULT_OPTIONS,\n            useValue: {showDelay: 1337, hideDelay: 7331},\n          }"
    },
    {
      "type": "class",
      "name": "%AC$%dflt$%AM8$%AM3$%AM0$4",
      "label": "%AC$%dflt$%AM8$%AM3$%AM0$4",
      "start_line": 150,
      "end_line": 150,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n        imports: [MatTooltipModule, OverlayModule, BasicTooltipDemo],\n        providers: [\n          {\n            provide: MAT_TOOLTIP_DEFAULT_OPTIONS,\n            useValue: {showDelay: 1337, hideDelay: 7331},\n          },\n        ],\n      }"
    },
    {
      "type": "class",
      "name": "%AC$%AC$%AC$%dflt$%AM9$%AM3$%AM0$7$%instInit$8$%instInit$9",
      "label": "%AC$%AC$%AC$%dflt$%AM9$%AM3$%AM0$7$%instInit$8$%instInit$9",
      "start_line": 185,
      "end_line": 185,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{position: 'right'}"
    },
    {
      "type": "class",
      "name": "%AC$%AC$%dflt$%AM9$%AM3$%AM0$7$%instInit$8",
      "label": "%AC$%AC$%dflt$%AM9$%AM3$%AM0$7$%instInit$8",
      "start_line": 183,
      "end_line": 183,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n            provide: MAT_TOOLTIP_DEFAULT_OPTIONS,\n            useValue: {position: 'right'},\n          }"
    },
    {
      "type": "class",
      "name": "%AC$%dflt$%AM9$%AM3$%AM0$7",
      "label": "%AC$%dflt$%AM9$%AM3$%AM0$7",
      "start_line": 179,
      "end_line": 179,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n        imports: [MatTooltipModule, OverlayModule],\n        declarations: [TooltipDemoWithoutPositionBinding],\n        providers: [\n          {\n            provide: MAT_TOOLTIP_DEFAULT_OPTIONS,\n            useValue: {position: 'right'},\n          },\n        ],\n      }"
    },
    {
      "type": "class",
      "name": "%AC$%AC$%AC$%dflt$%AM10$%AM3$%AM0$10$%instInit$11$%instInit$12",
      "label": "%AC$%AC$%AC$%dflt$%AM10$%AM3$%AM0$10$%instInit$11$%instInit$12",
      "start_line": 208,
      "end_line": 208,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{tooltipClass: 'my-default-tooltip-class'}"
    },
    {
      "type": "class",
      "name": "%AC$%AC$%dflt$%AM10$%AM3$%AM0$10$%instInit$11",
      "label": "%AC$%AC$%dflt$%AM10$%AM3$%AM0$10$%instInit$11",
      "start_line": 206,
      "end_line": 206,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n            provide: MAT_TOOLTIP_DEFAULT_OPTIONS,\n            useValue: {tooltipClass: 'my-default-tooltip-class'},\n          }"
    },
    {
      "type": "class",
      "name": "%AC$%dflt$%AM10$%AM3$%AM0$10",
      "label": "%AC$%dflt$%AM10$%AM3$%AM0$10",
      "start_line": 202,
      "end_line": 202,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n        declarations: [TooltipDemoWithoutTooltipClassBinding],\n        imports: [MatTooltipModule, OverlayModule],\n        providers: [\n          {\n            provide: MAT_TOOLTIP_DEFAULT_OPTIONS,\n            useValue: {tooltipClass: 'my-default-tooltip-class'},\n          },\n        ],\n      }"
    },
    {
      "type": "class",
      "name": "%AC$%AC$%AC$%dflt$%AM11$%AM3$%AM0$13$%instInit$14$%instInit$15",
      "label": "%AC$%AC$%AC$%dflt$%AM11$%AM3$%AM0$13$%instInit$14$%instInit$15",
      "start_line": 232,
      "end_line": 232,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{tooltipClass: 'my-default-tooltip-class'}"
    },
    {
      "type": "class",
      "name": "%AC$%AC$%dflt$%AM11$%AM3$%AM0$13$%instInit$14",
      "label": "%AC$%AC$%dflt$%AM11$%AM3$%AM0$13$%instInit$14",
      "start_line": 230,
      "end_line": 230,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n            provide: MAT_TOOLTIP_DEFAULT_OPTIONS,\n            useValue: {tooltipClass: 'my-default-tooltip-class'},\n          }"
    },
    {
      "type": "class",
      "name": "%AC$%dflt$%AM11$%AM3$%AM0$13",
      "label": "%AC$%dflt$%AM11$%AM3$%AM0$13",
      "start_line": 226,
      "end_line": 226,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n        declarations: [TooltipDemoWithTooltipClassBinding],\n        imports: [MatTooltipModule, OverlayModule],\n        providers: [\n          {\n            provide: MAT_TOOLTIP_DEFAULT_OPTIONS,\n            useValue: {tooltipClass: 'my-default-tooltip-class'},\n          },\n        ],\n      }"
    },
    {
      "type": "class",
      "name": "%AC$%dflt$%AM12$%AM3$%AM0$16",
      "label": "%AC$%dflt$%AM12$%AM3$%AM0$16",
      "start_line": 255,
      "end_line": 255,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n        imports: [MatTooltipModule, OverlayModule],\n        declarations: [WideTooltipDemo],\n      }"
    },
    {
      "type": "class",
      "name": "%AC$%AC$%AC$%dflt$%AM13$%AM3$%AM0$17$%instInit$18$%instInit$19",
      "label": "%AC$%AC$%AC$%dflt$%AM13$%AM3$%AM0$17$%instInit$18$%instInit$19",
      "start_line": 288,
      "end_line": 288,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{positionAtOrigin: true}"
    },
    {
      "type": "class",
      "name": "%AC$%AC$%dflt$%AM13$%AM3$%AM0$17$%instInit$18",
      "label": "%AC$%AC$%dflt$%AM13$%AM3$%AM0$17$%instInit$18",
      "start_line": 286,
      "end_line": 286,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n            provide: MAT_TOOLTIP_DEFAULT_OPTIONS,\n            useValue: {positionAtOrigin: true},\n          }"
    },
    {
      "type": "class",
      "name": "%AC$%dflt$%AM13$%AM3$%AM0$17",
      "label": "%AC$%dflt$%AM13$%AM3$%AM0$17",
      "start_line": 282,
      "end_line": 282,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n        imports: [MatTooltipModule, OverlayModule],\n        declarations: [WideTooltipDemo],\n        providers: [\n          {\n            provide: MAT_TOOLTIP_DEFAULT_OPTIONS,\n            useValue: {positionAtOrigin: true},\n          },\n        ],\n      }"
    },
    {
      "type": "class",
      "name": "%AC$%AC$%AC$%dflt$%AM15$%AM3$%AM0$20$%instInit$21$%instInit$22",
      "label": "%AC$%AC$%AC$%dflt$%AM15$%AM3$%AM0$20$%instInit$21$%instInit$22",
      "start_line": 316,
      "end_line": 316,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{disableTooltipInteractivity: true}"
    },
    {
      "type": "class",
      "name": "%AC$%AC$%dflt$%AM15$%AM3$%AM0$20$%instInit$21",
      "label": "%AC$%AC$%dflt$%AM15$%AM3$%AM0$20$%instInit$21",
      "start_line": 314,
      "end_line": 314,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n            provide: MAT_TOOLTIP_DEFAULT_OPTIONS,\n            useValue: {disableTooltipInteractivity: true},\n          }"
    },
    {
      "type": "class",
      "name": "%AC$%dflt$%AM15$%AM3$%AM0$20",
      "label": "%AC$%dflt$%AM15$%AM3$%AM0$20",
      "start_line": 310,
      "end_line": 310,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n        imports: [MatTooltipModule, OverlayModule, NoopAnimationsModule],\n        declarations: [TooltipDemoWithoutPositionBinding],\n        providers: [\n          {\n            provide: MAT_TOOLTIP_DEFAULT_OPTIONS,\n            useValue: {disableTooltipInteractivity: true},\n          },\n        ],\n      }"
    },
    {
      "type": "class",
      "name": "%AC$%dflt$%AM35$%AM3$%AM0$23",
      "label": "%AC$%dflt$%AM35$%AM3$%AM0$23",
      "start_line": 562,
      "end_line": 562,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{complete: spy}"
    },
    {
      "type": "class",
      "name": "%AC$%dflt$%AM50$%AM3$%AM0$24",
      "label": "%AC$%dflt$%AM50$%AM3$%AM0$24",
      "start_line": 738,
      "end_line": 738,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{alt: true}"
    },
    {
      "type": "class",
      "name": "%AC$%dflt$%AM61$%AM3$%AM0$25",
      "label": "%AC$%dflt$%AM61$%AM3$%AM0$25",
      "start_line": 916,
      "end_line": 916,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{value: tooltipElement}"
    },
    {
      "type": "class",
      "name": "%AC$%dflt$%AM63$%AM3$%AM0$26",
      "label": "%AC$%dflt$%AM63$%AM3$%AM0$26",
      "start_line": 952,
      "end_line": 952,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n        value: fixture.componentInstance.button.nativeElement,\n      }"
    },
    {
      "type": "class",
      "name": "%AC$%AC$%dflt$%AM91$%AM90$%AM0$27$%instInit$28",
      "label": "%AC$%AC$%dflt$%AM91$%AM90$%AM0$27$%instInit$28",
      "start_line": 1,
      "end_line": 1262,
      "functions": [
        {
          "type": "function",
          "name": "%AM0$%instInit",
          "label": "%AM0$%instInit",
          "start_line": 1,
          "end_line": 1262,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %AC$%AC$%dflt$%AM91$%AM90$%AM0$27$%instInit$28\n%0 = window.<@%unk/%unk: .innerWidth>\nreturn %0",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => window.innerWidth"
        }
      ],
      "classes": [],
      "blocks": [],
      "simplified_code": "{get: () => window.innerWidth}"
    },
    {
      "type": "class",
      "name": "%AC$%AC$%dflt$%AM91$%AM90$%AM0$27$%instInit$29",
      "label": "%AC$%AC$%dflt$%AM91$%AM90$%AM0$27$%instInit$29",
      "start_line": 1,
      "end_line": 1263,
      "functions": [
        {
          "type": "function",
          "name": "%AM0$%instInit",
          "label": "%AM0$%instInit",
          "start_line": 1,
          "end_line": 1263,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %AC$%AC$%dflt$%AM91$%AM90$%AM0$27$%instInit$29\n%0 = window.<@%unk/%unk: .innerHeight>\nreturn %0",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => window.innerHeight"
        }
      ],
      "classes": [],
      "blocks": [],
      "simplified_code": "{get: () => window.innerHeight}"
    },
    {
      "type": "class",
      "name": "%AC$%dflt$%AM91$%AM90$%AM0$27",
      "label": "%AC$%dflt$%AM91$%AM90$%AM0$27",
      "start_line": 1261,
      "end_line": 1261,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n        clientX: {get: () => window.innerWidth},\n        clientY: {get: () => window.innerHeight},\n      }"
    },
    {
      "type": "class",
      "name": "%AC$%AC$%dflt$%AM92$%AM90$%AM0$30$%instInit$31",
      "label": "%AC$%AC$%dflt$%AM92$%AM90$%AM0$30$%instInit$31",
      "start_line": 1,
      "end_line": 1291,
      "functions": [
        {
          "type": "function",
          "name": "%AM0$%instInit",
          "label": "%AM0$%instInit",
          "start_line": 1,
          "end_line": 1291,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %AC$%AC$%dflt$%AM92$%AM90$%AM0$30$%instInit$31\n%0 = triggerRect.<@%unk/%unk: .left>\n%1 = %0 + 1\nreturn %1",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => triggerRect.left + 1"
        }
      ],
      "classes": [],
      "blocks": [],
      "simplified_code": "{get: () => triggerRect.left + 1}"
    },
    {
      "type": "class",
      "name": "%AC$%AC$%dflt$%AM92$%AM90$%AM0$30$%instInit$32",
      "label": "%AC$%AC$%dflt$%AM92$%AM90$%AM0$30$%instInit$32",
      "start_line": 1,
      "end_line": 1292,
      "functions": [
        {
          "type": "function",
          "name": "%AM0$%instInit",
          "label": "%AM0$%instInit",
          "start_line": 1,
          "end_line": 1292,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %AC$%AC$%dflt$%AM92$%AM90$%AM0$30$%instInit$32\n%0 = triggerRect.<@%unk/%unk: .top>\n%1 = %0 + 1\nreturn %1",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => triggerRect.top + 1"
        }
      ],
      "classes": [],
      "blocks": [],
      "simplified_code": "{get: () => triggerRect.top + 1}"
    },
    {
      "type": "class",
      "name": "%AC$%dflt$%AM92$%AM90$%AM0$30",
      "label": "%AC$%dflt$%AM92$%AM90$%AM0$30",
      "start_line": 1290,
      "end_line": 1290,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n        clientX: {get: () => triggerRect.left + 1},\n        clientY: {get: () => triggerRect.top + 1},\n      }"
    },
    {
      "type": "class",
      "name": "%AC$%dflt$finishCurrentTooltipAnimation$33",
      "label": "%AC$%dflt$finishCurrentTooltipAnimation$33",
      "start_line": 1,
      "end_line": 1479,
      "functions": [
        {
          "type": "function",
          "name": "%AM0$%instInit",
          "label": "%AM0$%instInit",
          "start_line": 1,
          "end_line": 1479,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/139.ts: %dflt\nif isVisible != 0\nConditionalOperatorIfTrue0\n%0 = 'show'\nConditionalOperatorIfFalse0\n%0 = 'hide'\nConditionalOperatorEnd0\n%1 = 'mat-mdc-tooltip-' + %0\nreturn %1",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => `mat-mdc-tooltip-${isVisible ? 'show' : 'hide'}`"
        }
      ],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n    get: () => `mat-mdc-tooltip-${isVisible ? 'show' : 'hide'}`,\n  }"
    }
  ],
  "functions": [],
  "blocks": [],
  "simplified_code": "import {FocusMonitor} from '@angular/cdk/a11y';\nimport {Direction, Directionality} from '@angular/cdk/bidi';\nimport {ESCAPE} from '@angular/cdk/keycodes';\nimport {CdkScrollable, OverlayContainer, OverlayModule} from '@angular/cdk/overlay';\nimport {Platform} from '@angular/cdk/platform';\nimport {\n  createFakeEvent,\n  createKeyboardEvent,\n  createMouseEvent,\n  dispatchEvent,\n  dispatchFakeEvent,\n  dispatchKeyboardEvent,\n  dispatchMouseEvent,\n  patchElementFocus,\n} from '@angular/cdk/testing/private';\nimport {\n  ChangeDetectionStrategy,\n  Component,\n  DebugElement,\n  ElementRef,\n  ViewChild,\n} from '@angular/core';\nimport {\n  ComponentFixture,\n  TestBed,\n  fakeAsync,\n  flush,\n  inject,\n  tick,\n  waitForAsync,\n} from '@angular/core/testing';\nimport {By} from '@angular/platform-browser';\nimport {NoopAnimationsModule} from '@angular/platform-browser/animations';\nimport {Subject} from 'rxjs';\nimport {\n  MAT_TOOLTIP_DEFAULT_OPTIONS,\n  MatTooltip,\n  MatTooltipModule,\n  SCROLL_THROTTLE_MS,\n  TooltipPosition,\n  TooltipTouchGestures,\n} from './index';\nconst initialTooltipMessage = 'initial tooltip message';\ndescribe('MatTooltip', () => {\n  let overlayContainerElement: HTMLElement;\n  let dir: {value: Direction; change: Subject<Direction>};\n  let platform: Platform;\n  let focusMonitor: FocusMonitor;\n  beforeEach(waitForAsync(() => {\n    TestBed.configureTestingModule({\n      imports: [\n        MatTooltipModule,\n        OverlayModule,\n        BasicTooltipDemo,\n        ScrollableTooltipDemo,\n        OnPushTooltipDemo,\n        DynamicTooltipsDemo,\n        TooltipOnTextFields,\n        TooltipOnDraggableElement,\n        DataBoundAriaLabelTooltip,\n      ],\n      providers: [\n        {\n          provide: Directionality,\n          useFactory: () => {\n            return (dir = {value: 'ltr', change: new Subject()});\n          },\n        },\n      ],\n    });\n    inject(\n      [OverlayContainer, FocusMonitor, Platform],\n      (oc: OverlayContainer, fm: FocusMonitor, pl: Platform) => {\n        overlayContainerElement = oc.getContainerElement();\n        focusMonitor = fm;\n        platform = pl;\n      },\n    )();\n  }));\n  describe('basic usage', () => {\n    let fixture: ComponentFixture<BasicTooltipDemo>;\n    let buttonDebugElement: DebugElement;\n    let buttonElement: HTMLButtonElement;\n    let tooltipDirective: MatTooltip;\n    beforeEach(fakeAsync(() => {\n      fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      tick();\n      buttonDebugElement = fixture.debugElement.query(By.css('button'))!;\n      buttonElement = buttonDebugElement.nativeElement;\n      tooltipDirective = buttonDebugElement.injector.get<MatTooltip>(MatTooltip);\n    }));\n    it('should show and hide the tooltip', fakeAsync(() => {\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.show();\n      tick(0); // Tick for the show delay (default is 0)\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      fixture.detectChanges();\n      // Wait until animation has finished\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      // Make sure tooltip is shown to the user and animation has finished.\n      const tooltipElement = overlayContainerElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;\n      expect(tooltipElement instanceof HTMLElement).toBe(true);\n      expect(tooltipElement.classList).toContain('mat-mdc-tooltip-show');\n      expect(overlayContainerElement.textContent).toContain(initialTooltipMessage);\n      // After hide is called, a timeout delay is created that will to hide the tooltip.\n      const tooltipDelay = 1000;\n      tooltipDirective.hide(tooltipDelay);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      // After the tooltip delay elapses, expect that the tooltip is not visible.\n      tick(tooltipDelay);\n      fixture.detectChanges();\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      // On animation complete, should expect that the tooltip has been detached.\n      finishCurrentTooltipAnimation(overlayContainerElement, false);\n      assertTooltipInstance(tooltipDirective, false);\n      flush();\n    }));\n    it('should be able to re-open a tooltip if it was closed by detaching the overlay', fakeAsync(() => {\n      tooltipDirective.show();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      tooltipDirective._overlayRef!.detach();\n      tick(0);\n      fixture.detectChanges();\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.show();\n      tick(0);\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      flush();\n    }));\n    it('should show with delay', fakeAsync(() => {\n      assertTooltipInstance(tooltipDirective, false);\n      const tooltipDelay = 1000;\n      tooltipDirective.show(tooltipDelay);\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      fixture.detectChanges();\n      expect(overlayContainerElement.textContent).toContain('');\n      tick(tooltipDelay);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      expect(overlayContainerElement.textContent).toContain(initialTooltipMessage);\n    }));\n    it('should be able to override the default show and hide delays', fakeAsync(() => {\n      TestBed.resetTestingModule().configureTestingModule({\n        imports: [MatTooltipModule, OverlayModule, BasicTooltipDemo],\n        providers: [\n          {\n            provide: MAT_TOOLTIP_DEFAULT_OPTIONS,\n            useValue: {showDelay: 1337, hideDelay: 7331},\n          },\n        ],\n      });\n      fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      tooltipDirective = fixture.debugElement\n        .query(By.css('button'))!\n        .injector.get<MatTooltip>(MatTooltip);\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick();\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      tick(1337);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      tooltipDirective.hide();\n      fixture.detectChanges();\n      tick();\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      tick(7331);\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      flush();\n    }));\n    it('should be able to override the default position', fakeAsync(() => {\n      TestBed.resetTestingModule().configureTestingModule({\n        imports: [MatTooltipModule, OverlayModule],\n        declarations: [TooltipDemoWithoutPositionBinding],\n        providers: [\n          {\n            provide: MAT_TOOLTIP_DEFAULT_OPTIONS,\n            useValue: {position: 'right'},\n          },\n        ],\n      });\n      const newFixture = TestBed.createComponent(TooltipDemoWithoutPositionBinding);\n      newFixture.detectChanges();\n      tooltipDirective = newFixture.debugElement\n        .query(By.css('button'))!\n        .injector.get<MatTooltip>(MatTooltip);\n      tooltipDirective.show();\n      newFixture.detectChanges();\n      tick();\n      expect(tooltipDirective.position).toBe('right');\n      expect(tooltipDirective._getOverlayPosition().main.overlayX).toBe('start');\n      expect(tooltipDirective._getOverlayPosition().fallback.overlayX).toBe('end');\n    }));\n    it('should be able to define a default (global) tooltip class', fakeAsync(() => {\n      TestBed.resetTestingModule().configureTestingModule({\n        declarations: [TooltipDemoWithoutTooltipClassBinding],\n        imports: [MatTooltipModule, OverlayModule],\n        providers: [\n          {\n            provide: MAT_TOOLTIP_DEFAULT_OPTIONS,\n            useValue: {tooltipClass: 'my-default-tooltip-class'},\n          },\n        ],\n      });\n      const fixture = TestBed.createComponent(TooltipDemoWithoutTooltipClassBinding);\n      fixture.detectChanges();\n      tooltipDirective = fixture.componentInstance.tooltip;\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick();\n      const overlayRef = tooltipDirective._overlayRef!;\n      const tooltipElement = overlayRef.overlayElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;\n      expect(tooltipDirective.tooltipClass).toBe('my-default-tooltip-class');\n      expect(tooltipElement.classList).toContain('my-default-tooltip-class');\n    }));\n    it('should be able to provide tooltip class over the custom default one', fakeAsync(() => {\n      TestBed.resetTestingModule().configureTestingModule({\n        declarations: [TooltipDemoWithTooltipClassBinding],\n        imports: [MatTooltipModule, OverlayModule],\n        providers: [\n          {\n            provide: MAT_TOOLTIP_DEFAULT_OPTIONS,\n            useValue: {tooltipClass: 'my-default-tooltip-class'},\n          },\n        ],\n      });\n      const fixture = TestBed.createComponent(TooltipDemoWithTooltipClassBinding);\n      fixture.detectChanges();\n      tooltipDirective = fixture.componentInstance.tooltip;\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick();\n      const overlayRef = tooltipDirective._overlayRef!;\n      const tooltipElement = overlayRef.overlayElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;\n      expect(tooltipDirective.tooltipClass).not.toBe('my-default-tooltip-class');\n      expect(tooltipElement.classList).not.toContain('my-default-tooltip-class');\n      expect(tooltipElement.classList).toContain('fixed-tooltip-class');\n    }));\n    it('should position on the bottom-left by default', fakeAsync(() => {\n      // We don't bind mouse events on mobile devices.\n      if (platform.IOS || platform.ANDROID) {\n        return;\n      }\n      TestBed.resetTestingModule().configureTestingModule({\n        imports: [MatTooltipModule, OverlayModule],\n        declarations: [WideTooltipDemo],\n      });\n      const wideFixture = TestBed.createComponent(WideTooltipDemo);\n      wideFixture.detectChanges();\n      tooltipDirective = wideFixture.debugElement\n        .query(By.css('button'))!\n        .injector.get<MatTooltip>(MatTooltip);\n      const button: HTMLButtonElement = wideFixture.nativeElement.querySelector('button');\n      const triggerRect = button.getBoundingClientRect();\n      dispatchMouseEvent(button, 'mouseenter', triggerRect.right - 100, triggerRect.top + 100);\n      wideFixture.detectChanges();\n      tick();\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      expect(tooltipDirective._overlayRef!.overlayElement.offsetLeft).toBeLessThan(\n        triggerRect.right - 250,\n      );\n      expect(tooltipDirective._overlayRef!.overlayElement.offsetTop).toBeGreaterThanOrEqual(\n        triggerRect.bottom,\n      );\n    }));\n    it('should be able to override the default positionAtOrigin', async () => {\n      // We don't bind mouse events on mobile devices.\n      if (platform.IOS || platform.ANDROID) {\n        return;\n      }\n      TestBed.resetTestingModule().configureTestingModule({\n        imports: [MatTooltipModule, OverlayModule],\n        declarations: [WideTooltipDemo],\n        providers: [\n          {\n            provide: MAT_TOOLTIP_DEFAULT_OPTIONS,\n            useValue: {positionAtOrigin: true},\n          },\n        ],\n      });\n      const wideFixture = TestBed.createComponent(WideTooltipDemo);\n      wideFixture.detectChanges();\n      tooltipDirective = wideFixture.debugElement\n        .query(By.css('button'))!\n        .injector.get<MatTooltip>(MatTooltip);\n      const button: HTMLButtonElement = wideFixture.nativeElement.querySelector('button');\n      const triggerRect = button.getBoundingClientRect();\n      dispatchMouseEvent(button, 'mouseenter', triggerRect.right - 100, triggerRect.top + 100);\n      wideFixture.detectChanges();\n      await new Promise<void>(resolve => setTimeout(resolve));\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      const actualOffsetLeft = tooltipDirective._overlayRef!.overlayElement.offsetLeft;\n      const expectedOffsetLeft = triggerRect.right - 100 - 20;\n      expect(actualOffsetLeft).toBeLessThanOrEqual(expectedOffsetLeft + 1);\n      expect(actualOffsetLeft).toBeGreaterThanOrEqual(expectedOffsetLeft - 1);\n      expect(tooltipDirective._overlayRef!.overlayElement.offsetTop).toBe(triggerRect.top + 100);\n    });\n    it('should be able to disable tooltip interactivity', fakeAsync(() => {\n      TestBed.resetTestingModule().configureTestingModule({\n        imports: [MatTooltipModule, OverlayModule, NoopAnimationsModule],\n        declarations: [TooltipDemoWithoutPositionBinding],\n        providers: [\n          {\n            provide: MAT_TOOLTIP_DEFAULT_OPTIONS,\n            useValue: {disableTooltipInteractivity: true},\n          },\n        ],\n      });\n      const newFixture = TestBed.createComponent(TooltipDemoWithoutPositionBinding);\n      newFixture.detectChanges();\n      tooltipDirective = newFixture.debugElement\n        .query(By.css('button'))!\n        .injector.get<MatTooltip>(MatTooltip);\n      tooltipDirective.show();\n      newFixture.detectChanges();\n      tick();\n      expect(tooltipDirective._overlayRef?.overlayElement.classList).toContain(\n        'mat-mdc-tooltip-panel-non-interactive',\n      );\n    }));\n    it('should set a css class on the overlay panel element', fakeAsync(() => {\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick(0);\n      const overlayRef = tooltipDirective._overlayRef;\n      expect(!!overlayRef).toBeTruthy();\n      expect(overlayRef!.overlayElement.classList)\n        .withContext('Expected the overlay panel element to have the tooltip panel class set.')\n        .toContain('mat-mdc-tooltip-panel');\n    }));\n    it('should not show if disabled', fakeAsync(() => {\n      // Test that disabling the tooltip will not set the tooltip visible\n      tooltipDirective.disabled = true;\n      fixture.changeDetectorRef.markForCheck();\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      // Test to make sure setting disabled to false will show the tooltip\n      // Sanity check to make sure everything was correct before (detectChanges, tick)\n      tooltipDirective.disabled = false;\n      fixture.changeDetectorRef.markForCheck();\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n    }));\n    it('should hide if disabled while visible', fakeAsync(() => {\n      // Display the tooltip with a timeout before hiding.\n      tooltipDirective.hideDelay = 1000;\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      // Set tooltip to be disabled and verify that the tooltip hides.\n      tooltipDirective.disabled = true;\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n    }));\n    it('should hide if the message is cleared while the tooltip is open', fakeAsync(() => {\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      fixture.componentInstance.message = '';\n      fixture.changeDetectorRef.markForCheck();\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n    }));\n    it('should not show if hide is called before delay finishes', waitForAsync(() => {\n      assertTooltipInstance(tooltipDirective, false);\n      const tooltipDelay = 1000;\n      tooltipDirective.show(tooltipDelay);\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      fixture.detectChanges();\n      expect(overlayContainerElement.textContent).toContain('');\n      tooltipDirective.hide();\n      fixture.whenStable().then(() => {\n        expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      });\n    }));\n    it('should not show tooltip if message is not present or empty', () => {\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.message = undefined;\n      fixture.detectChanges();\n      tooltipDirective.show();\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.message = null;\n      fixture.detectChanges();\n      tooltipDirective.show();\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.message = '';\n      fixture.detectChanges();\n      tooltipDirective.show();\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.message = '   ';\n      fixture.detectChanges();\n      tooltipDirective.show();\n      assertTooltipInstance(tooltipDirective, false);\n    });\n    it('should not follow through with hide if show is called after', fakeAsync(() => {\n      tooltipDirective.show();\n      tick(0); // Tick for the show delay (default is 0)\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      // After hide called, a timeout delay is created that will to hide the tooltip.\n      const tooltipDelay = 1000;\n      tooltipDirective.hide(tooltipDelay);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      // Before delay time has passed, call show which should cancel intent to hide tooltip.\n      tooltipDirective.show();\n      tick(tooltipDelay);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n    }));\n    it('should be able to update the tooltip position while open', fakeAsync(() => {\n      tooltipDirective.position = 'below';\n      tooltipDirective.show();\n      tick();\n      assertTooltipInstance(tooltipDirective, true);\n      spyOn(tooltipDirective._overlayRef!, 'updatePosition').and.callThrough();\n      tooltipDirective.position = 'above';\n      fixture.detectChanges();\n      tick();\n      assertTooltipInstance(tooltipDirective, true);\n      expect(tooltipDirective._overlayRef!.updatePosition).toHaveBeenCalled();\n    }));\n    it('should update the tooltip position when the directionality changes', fakeAsync(() => {\n      tooltipDirective.position = 'right';\n      tooltipDirective.show();\n      tick();\n      assertTooltipInstance(tooltipDirective, true);\n      const spy = spyOn(tooltipDirective as any, '_updatePosition').and.callThrough();\n      dir.change.next('rtl');\n      assertTooltipInstance(tooltipDirective, true);\n      expect(spy).toHaveBeenCalled();\n    }));\n    it('should not throw when updating the position for a closed tooltip', fakeAsync(() => {\n      tooltipDirective.position = 'left';\n      tooltipDirective.show(0);\n      fixture.detectChanges();\n      tick();\n      tooltipDirective.hide(0);\n      fixture.detectChanges();\n      tick();\n      finishCurrentTooltipAnimation(overlayContainerElement, false);\n      expect(() => {\n        tooltipDirective.position = 'right';\n        fixture.detectChanges();\n        tick();\n      }).not.toThrow();\n    }));\n    it('should be able to modify the tooltip message', fakeAsync(() => {\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.show();\n      tick(0); // Tick for the show delay (default is 0)\n      expect(tooltipDirective._tooltipInstance!.isVisible()).toBe(true);\n      fixture.detectChanges();\n      expect(overlayContainerElement.textContent).toContain(initialTooltipMessage);\n      const newMessage = 'new tooltip message';\n      tooltipDirective.message = newMessage;\n      fixture.detectChanges();\n      expect(overlayContainerElement.textContent).toContain(newMessage);\n    }));\n    it('should allow extra classes to be set on the tooltip', fakeAsync(() => {\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.show();\n      tick(0); // Tick for the show delay (default is 0)\n      fixture.detectChanges();\n      // Make sure classes aren't prematurely added\n      let tooltipElement = overlayContainerElement.querySelector('.mat-mdc-tooltip') as HTMLElement;\n      expect(tooltipElement.classList).not.toContain(\n        'custom-one',\n        'Expected to not have the class before enabling matTooltipClass',\n      );\n      expect(tooltipElement.classList).not.toContain(\n        'custom-two',\n        'Expected to not have the class before enabling matTooltipClass',\n      );\n      // Enable the classes via ngClass syntax\n      fixture.componentInstance.showTooltipClass = true;\n      fixture.changeDetectorRef.markForCheck();\n      fixture.detectChanges();\n      // Make sure classes are correctly added\n      tooltipElement = overlayContainerElement.querySelector('.mat-mdc-tooltip') as HTMLElement;\n      expect(tooltipElement.classList)\n        .withContext('Expected to have the class after enabling matTooltipClass')\n        .toContain('custom-one');\n      expect(tooltipElement.classList)\n        .withContext('Expected to have the class after enabling matTooltipClass')\n        .toContain('custom-two');\n    }));\n    it('should be removed after parent destroyed', fakeAsync(() => {\n      tooltipDirective.show();\n      tick(0); // Tick for the show delay (default is 0)\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      fixture.destroy();\n      expect(overlayContainerElement.childNodes.length).toBe(0);\n      expect(overlayContainerElement.textContent).toBe('');\n      flush();\n    }));\n    it('should have an aria-describedby element with the tooltip message', fakeAsync(() => {\n      const dynamicTooltipsDemoFixture = TestBed.createComponent(DynamicTooltipsDemo);\n      const dynamicTooltipsComponent = dynamicTooltipsDemoFixture.componentInstance;\n      dynamicTooltipsComponent.tooltips = ['Tooltip One', 'Tooltip Two'];\n      dynamicTooltipsDemoFixture.detectChanges();\n      tick();\n      const buttons = dynamicTooltipsDemoFixture.nativeElement.querySelectorAll('button');\n      const firstButtonAria = buttons[0].getAttribute('aria-describedby');\n      expect(document.querySelector(`#${firstButtonAria}`)!.textContent).toBe('Tooltip One');\n      const secondButtonAria = buttons[1].getAttribute('aria-describedby');\n      expect(document.querySelector(`#${secondButtonAria}`)!.textContent).toBe('Tooltip Two');\n    }));\n    it('should not add an ARIA description for elements that have the same text as a data-bound aria-label', fakeAsync(() => {\n      const ariaLabelFixture = TestBed.createComponent(DataBoundAriaLabelTooltip);\n      ariaLabelFixture.detectChanges();\n      tick();\n      const button = ariaLabelFixture.nativeElement.querySelector('button');\n      expect(button.getAttribute('aria-describedby')).toBeFalsy();\n    }));\n    it('should toggle aria-describedby depending on whether the tooltip is disabled', fakeAsync(() => {\n      expect(buttonElement.getAttribute('aria-describedby')).toBeTruthy();\n      fixture.componentInstance.tooltipDisabled = true;\n      fixture.changeDetectorRef.markForCheck();\n      fixture.detectChanges();\n      tick();\n      expect(buttonElement.hasAttribute('aria-describedby')).toBe(false);\n      fixture.componentInstance.tooltipDisabled = false;\n      fixture.changeDetectorRef.markForCheck();\n      fixture.detectChanges();\n      tick();\n      expect(buttonElement.getAttribute('aria-describedby')).toBeTruthy();\n    }));\n    it('should not try to dispose the tooltip when destroyed and done hiding', fakeAsync(() => {\n      tooltipDirective.show();\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      const tooltipDelay = 1000;\n      tooltipDirective.hide();\n      tick(tooltipDelay); // Change the tooltip state to hidden and trigger animation start\n      fixture.componentInstance.showButton = false;\n      fixture.changeDetectorRef.markForCheck();\n      fixture.detectChanges();\n    }));\n    it('should complete the afterHidden stream when tooltip is destroyed', fakeAsync(() => {\n      tooltipDirective.show();\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      const spy = jasmine.createSpy('complete spy');\n      const subscription = tooltipDirective\n        ._tooltipInstance!.afterHidden()\n        .subscribe({complete: spy});\n      tooltipDirective.hide(0);\n      tick(0);\n      fixture.detectChanges();\n      expect(spy).toHaveBeenCalled();\n      subscription.unsubscribe();\n    }));\n    it('should consistently position before and after overlay origin in ltr and rtl dir', () => {\n      tooltipDirective.position = 'left';\n      const leftOrigin = tooltipDirective._getOrigin().main;\n      tooltipDirective.position = 'right';\n      const rightOrigin = tooltipDirective._getOrigin().main;\n      // Test expectations in LTR\n      tooltipDirective.position = 'before';\n      expect(tooltipDirective._getOrigin().main).toEqual(leftOrigin);\n      tooltipDirective.position = 'after';\n      expect(tooltipDirective._getOrigin().main).toEqual(rightOrigin);\n      // Test expectations in RTL\n      dir.value = 'rtl';\n      tooltipDirective.position = 'before';\n      expect(tooltipDirective._getOrigin().main).toEqual(leftOrigin);\n      tooltipDirective.position = 'after';\n      expect(tooltipDirective._getOrigin().main).toEqual(rightOrigin);\n    });\n    it('should consistently position before and after overlay position in ltr and rtl dir', () => {\n      tooltipDirective.position = 'left';\n      const leftOverlayPosition = tooltipDirective._getOverlayPosition().main;\n      tooltipDirective.position = 'right';\n      const rightOverlayPosition = tooltipDirective._getOverlayPosition().main;\n      // Test expectations in LTR\n      tooltipDirective.position = 'before';\n      expect(tooltipDirective._getOverlayPosition().main).toEqual(leftOverlayPosition);\n      tooltipDirective.position = 'after';\n      expect(tooltipDirective._getOverlayPosition().main).toEqual(rightOverlayPosition);\n      // Test expectations in RTL\n      dir.value = 'rtl';\n      tooltipDirective.position = 'before';\n      expect(tooltipDirective._getOverlayPosition().main).toEqual(leftOverlayPosition);\n      tooltipDirective.position = 'after';\n      expect(tooltipDirective._getOverlayPosition().main).toEqual(rightOverlayPosition);\n    });\n    it('should throw when trying to assign an invalid position', () => {\n      expect(() => {\n        fixture.componentInstance.position = 'everywhere';\n        fixture.changeDetectorRef.markForCheck();\n        fixture.detectChanges();\n        tooltipDirective.show();\n      }).toThrowError('Tooltip position \"everywhere\" is invalid.');\n    });\n    it('should pass the layout direction to the tooltip', fakeAsync(() => {\n      dir.value = 'rtl';\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      const tooltipWrapper = overlayContainerElement.querySelector(\n        '.cdk-overlay-connected-position-bounding-box',\n      )!;\n      expect(tooltipWrapper).withContext('Expected tooltip to be shown.').toBeTruthy();\n      expect(tooltipWrapper.getAttribute('dir'))\n        .withContext('Expected tooltip to be in RTL mode.')\n        .toBe('rtl');\n    }));\n    it('should keep the overlay direction in sync with the trigger direction', fakeAsync(() => {\n      dir.value = 'rtl';\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      let tooltipWrapper = overlayContainerElement.querySelector(\n        '.cdk-overlay-connected-position-bounding-box',\n      )!;\n      expect(tooltipWrapper.getAttribute('dir'))\n        .withContext('Expected tooltip to be in RTL.')\n        .toBe('rtl');\n      tooltipDirective.hide(0);\n      tick(0);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, false);\n      dir.value = 'ltr';\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      tooltipWrapper = overlayContainerElement.querySelector(\n        '.cdk-overlay-connected-position-bounding-box',\n      )!;\n      expect(tooltipWrapper.getAttribute('dir'))\n        .withContext('Expected tooltip to be in LTR.')\n        .toBe('ltr');\n      flush();\n    }));\n    it('should be able to set the tooltip message as a number', fakeAsync(() => {\n      fixture.componentInstance.message = 100;\n      fixture.changeDetectorRef.markForCheck();\n      fixture.detectChanges();\n      expect(tooltipDirective.message).toBe('100');\n    }));\n    it('should hide when clicking away', fakeAsync(() => {\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      expect(overlayContainerElement.textContent).toContain(initialTooltipMessage);\n      document.body.click();\n      tick(0);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, false);\n      fixture.detectChanges();\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      expect(overlayContainerElement.textContent).toBe('');\n    }));\n    it('should hide when clicking away with an auxilliary button', fakeAsync(() => {\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      expect(overlayContainerElement.textContent).toContain(initialTooltipMessage);\n      dispatchFakeEvent(document.body, 'auxclick');\n      tick(0);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, false);\n      fixture.detectChanges();\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      expect(overlayContainerElement.textContent).toBe('');\n    }));\n    it('should not hide immediately if a click fires while animating', fakeAsync(() => {\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      document.body.click();\n      fixture.detectChanges();\n      tick(500);\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      expect(overlayContainerElement.textContent).toContain(initialTooltipMessage);\n      flush();\n    }));\n    it('should hide when pressing escape', fakeAsync(() => {\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      tick(500);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      expect(overlayContainerElement.textContent).toContain(initialTooltipMessage);\n      dispatchKeyboardEvent(document.body, 'keydown', ESCAPE);\n      tick(0);\n      fixture.detectChanges();\n      tick(500);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, false);\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      expect(overlayContainerElement.textContent).toBe('');\n      flush();\n    }));\n    it('should not throw when pressing ESCAPE', fakeAsync(() => {\n      expect(() => {\n        dispatchKeyboardEvent(document.body, 'keydown', ESCAPE);\n        fixture.detectChanges();\n      }).not.toThrow();\n      // Flush due to the additional tick that is necessary for the FocusMonitor.\n      flush();\n    }));\n    it('should preventDefault when pressing ESCAPE', fakeAsync(() => {\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      const event = dispatchKeyboardEvent(document.body, 'keydown', ESCAPE);\n      fixture.detectChanges();\n      flush();\n      expect(event.defaultPrevented).toBe(true);\n    }));\n    it('should not preventDefault when pressing ESCAPE with a modifier', fakeAsync(() => {\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      const event = createKeyboardEvent('keydown', ESCAPE, undefined, {alt: true});\n      dispatchEvent(document.body, event);\n      fixture.detectChanges();\n      flush();\n      expect(event.defaultPrevented).toBe(false);\n    }));\n    it('should not show the tooltip on programmatic focus', fakeAsync(() => {\n      patchElementFocus(buttonElement);\n      assertTooltipInstance(tooltipDirective, false);\n      focusMonitor.focusVia(buttonElement, 'program');\n      tick(0);\n      fixture.detectChanges();\n      tick(500);\n      expect(overlayContainerElement.querySelector('.mat-mdc-tooltip')).toBeNull();\n    }));\n    it('should not show the tooltip on mouse focus', fakeAsync(() => {\n      patchElementFocus(buttonElement);\n      assertTooltipInstance(tooltipDirective, false);\n      focusMonitor.focusVia(buttonElement, 'mouse');\n      tick(0);\n      fixture.detectChanges();\n      tick(500);\n      expect(overlayContainerElement.querySelector('.mat-mdc-tooltip')).toBeNull();\n    }));\n    it('should not show the tooltip on touch focus', fakeAsync(() => {\n      patchElementFocus(buttonElement);\n      assertTooltipInstance(tooltipDirective, false);\n      focusMonitor.focusVia(buttonElement, 'touch');\n      tick(0);\n      fixture.detectChanges();\n      tick(500);\n      expect(overlayContainerElement.querySelector('.mat-mdc-tooltip')).toBeNull();\n    }));\n    it('should not hide the tooltip when calling `show` twice in a row', fakeAsync(() => {\n      tooltipDirective.show();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      const overlayRef = tooltipDirective._overlayRef!;\n      spyOn(overlayRef, 'detach').and.callThrough();\n      tooltipDirective.show();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      expect(overlayRef.detach).not.toHaveBeenCalled();\n      flush();\n    }));\n    it('should set a class on the overlay panel that reflects the position', fakeAsync(() => {\n      // Move the element so that the primary position is always used.\n      buttonElement.style.position = 'fixed';\n      buttonElement.style.top = buttonElement.style.left = '200px';\n      fixture.componentInstance.message = 'hi';\n      fixture.changeDetectorRef.markForCheck();\n      fixture.detectChanges();\n      setPositionAndShow('below');\n      const classList = tooltipDirective._overlayRef!.overlayElement.classList;\n      expect(classList).toContain('mat-mdc-tooltip-panel-below');\n      setPositionAndShow('above');\n      expect(classList).not.toContain('mat-mdc-tooltip-panel-below');\n      expect(classList).toContain('mat-mdc-tooltip-panel-above');\n      setPositionAndShow('left');\n      expect(classList).not.toContain('mat-mdc-tooltip-panel-above');\n      expect(classList).toContain('mat-mdc-tooltip-panel-left');\n      setPositionAndShow('right');\n      expect(classList).not.toContain('mat-mdc-tooltip-panel-left');\n      expect(classList).toContain('mat-mdc-tooltip-panel-right');\n      function setPositionAndShow(position: TooltipPosition) {\n        tooltipDirective.hide(0);\n        fixture.detectChanges();\n        tick(0);\n        tooltipDirective.position = position;\n        tooltipDirective.show(0);\n        fixture.detectChanges();\n        tick(0);\n        fixture.detectChanges();\n        tick(500);\n      }\n    }));\n    it('should account for RTL when setting the tooltip position class', fakeAsync(() => {\n      // Move the element so that the primary position is always used.\n      buttonElement.style.position = 'fixed';\n      buttonElement.style.top = buttonElement.style.left = '200px';\n      fixture.componentInstance.message = 'hi';\n      fixture.changeDetectorRef.markForCheck();\n      fixture.detectChanges();\n      dir.value = 'ltr';\n      tooltipDirective.position = 'after';\n      fixture.changeDetectorRef.markForCheck();\n      tooltipDirective.show(0);\n      fixture.detectChanges();\n      tick(0);\n      fixture.detectChanges();\n      tick(500);\n      const classList = tooltipDirective._overlayRef!.overlayElement.classList;\n      expect(classList).not.toContain('mat-mdc-tooltip-panel-after');\n      expect(classList).not.toContain('mat-mdc-tooltip-panel-before');\n      expect(classList).not.toContain('mat-mdc-tooltip-panel-left');\n      expect(classList).toContain('mat-mdc-tooltip-panel-right');\n      tooltipDirective.hide(0);\n      fixture.detectChanges();\n      tick(0);\n      dir.value = 'rtl';\n      tooltipDirective.show(0);\n      fixture.detectChanges();\n      tick(0);\n      fixture.detectChanges();\n      tick(500);\n      expect(classList).not.toContain('mat-mdc-tooltip-panel-after');\n      expect(classList).not.toContain('mat-mdc-tooltip-panel-before');\n      expect(classList).not.toContain('mat-mdc-tooltip-panel-right');\n      expect(classList).toContain('mat-mdc-tooltip-panel-left');\n    }));\n    it('should clear the show timeout on destroy', fakeAsync(() => {\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.show(1000);\n      fixture.detectChanges();\n      // Note that we aren't asserting anything, but `fakeAsync` will\n      // throw if we have any timers by the end of the test.\n      fixture.destroy();\n      flush();\n    }));\n    it('should clear the hide timeout on destroy', fakeAsync(() => {\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      tick(500);\n      tooltipDirective.hide(1000);\n      fixture.detectChanges();\n      // Note that we aren't asserting anything, but `fakeAsync` will\n      // throw if we have any timers by the end of the test.\n      fixture.destroy();\n      flush();\n    }));\n    it('should set the multiline class on tooltips with messages that overflow', fakeAsync(() => {\n      fixture.componentInstance.message =\n        'This is a very long message that should cause the' +\n        'tooltip message body to overflow onto a new line.';\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick();\n      // Need to detect changes again to wait for the multiline class to be applied.\n      fixture.detectChanges();\n      const tooltipElement = overlayContainerElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;\n      expect(tooltipElement.classList).toContain('mdc-tooltip--multiline');\n      expect(tooltipDirective._tooltipInstance?._isMultiline).toBeTrue();\n    }));\n    it('should hide on mouseleave on the trigger', fakeAsync(() => {\n      // We don't bind mouse events on mobile devices.\n      if (platform.IOS || platform.ANDROID) {\n        return;\n      }\n      dispatchMouseEvent(fixture.componentInstance.button.nativeElement, 'mouseenter');\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      dispatchMouseEvent(fixture.componentInstance.button.nativeElement, 'mouseleave');\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n    }));\n    it('should not hide on mouseleave if the pointer goes from the trigger to the tooltip', fakeAsync(() => {\n      // We don't bind mouse events on mobile devices.\n      if (platform.IOS || platform.ANDROID) {\n        return;\n      }\n      dispatchMouseEvent(fixture.componentInstance.button.nativeElement, 'mouseenter');\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      const tooltipElement = overlayContainerElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;\n      const event = createMouseEvent('mouseleave');\n      Object.defineProperty(event, 'relatedTarget', {value: tooltipElement});\n      dispatchEvent(fixture.componentInstance.button.nativeElement, event);\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n    }));\n    it('should hide on mouseleave on the tooltip', fakeAsync(() => {\n      // We don't bind mouse events on mobile devices.\n      if (platform.IOS || platform.ANDROID) {\n        return;\n      }\n      dispatchMouseEvent(fixture.componentInstance.button.nativeElement, 'mouseenter');\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      const tooltipElement = overlayContainerElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;\n      dispatchMouseEvent(tooltipElement, 'mouseleave');\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n    }));\n    it('should not hide on mouseleave if the pointer goes from the tooltip to the trigger', fakeAsync(() => {\n      // We don't bind mouse events on mobile devices.\n      if (platform.IOS || platform.ANDROID) {\n        return;\n      }\n      dispatchMouseEvent(fixture.componentInstance.button.nativeElement, 'mouseenter');\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      const tooltipElement = overlayContainerElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;\n      const event = createMouseEvent('mouseleave');\n      Object.defineProperty(event, 'relatedTarget', {\n        value: fixture.componentInstance.button.nativeElement,\n      });\n      dispatchEvent(tooltipElement, event);\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n    }));\n  });\n  describe('fallback positions', () => {\n    let fixture: ComponentFixture<BasicTooltipDemo>;\n    let tooltip: MatTooltip;\n    beforeEach(() => {\n      fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      tooltip = fixture.debugElement.query(By.css('button'))!.injector.get<MatTooltip>(MatTooltip);\n    });\n    it('should set a fallback origin position by inverting the main origin position', () => {\n      tooltip.position = 'left';\n      expect(tooltip._getOrigin().main.originX).toBe('start');\n      expect(tooltip._getOrigin().fallback.originX).toBe('end');\n      tooltip.position = 'right';\n      expect(tooltip._getOrigin().main.originX).toBe('end');\n      expect(tooltip._getOrigin().fallback.originX).toBe('start');\n      tooltip.position = 'above';\n      expect(tooltip._getOrigin().main.originY).toBe('top');\n      expect(tooltip._getOrigin().fallback.originY).toBe('bottom');\n      tooltip.position = 'below';\n      expect(tooltip._getOrigin().main.originY).toBe('bottom');\n      expect(tooltip._getOrigin().fallback.originY).toBe('top');\n    });\n    it('should set a fallback overlay position by inverting the main overlay position', () => {\n      tooltip.position = 'left';\n      expect(tooltip._getOverlayPosition().main.overlayX).toBe('end');\n      expect(tooltip._getOverlayPosition().fallback.overlayX).toBe('start');\n      tooltip.position = 'right';\n      expect(tooltip._getOverlayPosition().main.overlayX).toBe('start');\n      expect(tooltip._getOverlayPosition().fallback.overlayX).toBe('end');\n      tooltip.position = 'above';\n      expect(tooltip._getOverlayPosition().main.overlayY).toBe('bottom');\n      expect(tooltip._getOverlayPosition().fallback.overlayY).toBe('top');\n      tooltip.position = 'below';\n      expect(tooltip._getOverlayPosition().main.overlayY).toBe('top');\n      expect(tooltip._getOverlayPosition().fallback.overlayY).toBe('bottom');\n    });\n  });\n  describe('scrollable usage', () => {\n    let fixture: ComponentFixture<ScrollableTooltipDemo>;\n    let buttonDebugElement: DebugElement;\n    let tooltipDirective: MatTooltip;\n    beforeEach(() => {\n      fixture = TestBed.createComponent(ScrollableTooltipDemo);\n      fixture.detectChanges();\n      buttonDebugElement = fixture.debugElement.query(By.css('button'))!;\n      tooltipDirective = buttonDebugElement.injector.get<MatTooltip>(MatTooltip);\n    });\n    it('should hide tooltip if clipped after changing positions', fakeAsync(() => {\n      assertTooltipInstance(tooltipDirective, false);\n      // Show the tooltip and tick for the show delay (default is 0)\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick(0);\n      // Expect that the tooltip is displayed\n      // Expect that the tooltip is displayed\n      expect(tooltipDirective._isTooltipVisible())\n        .withContext('Expected tooltip to be initially visible')\n        .toBe(true);\n      // Scroll the page but tick just before the default throttle should update.\n      fixture.componentInstance.scrollDown();\n      tick(SCROLL_THROTTLE_MS - 1);\n      expect(tooltipDirective._isTooltipVisible())\n        .withContext('Expected tooltip to be visible when scrolling, before throttle limit')\n        .toBe(true);\n      // Finish ticking to the throttle's limit and check that the scroll event notified the\n      // tooltip and it was hidden.\n      tick(100);\n      fixture.detectChanges();\n      expect(tooltipDirective._isTooltipVisible())\n        .withContext('Expected tooltip hidden when scrolled out of view, after throttle limit')\n        .toBe(false);\n    }));\n  });\n  describe('with OnPush', () => {\n    let fixture: ComponentFixture<OnPushTooltipDemo>;\n    let buttonDebugElement: DebugElement;\n    let buttonElement: HTMLButtonElement;\n    let tooltipDirective: MatTooltip;\n    beforeEach(() => {\n      fixture = TestBed.createComponent(OnPushTooltipDemo);\n      fixture.detectChanges();\n      buttonDebugElement = fixture.debugElement.query(By.css('button'))!;\n      buttonElement = <HTMLButtonElement>buttonDebugElement.nativeElement;\n      tooltipDirective = buttonDebugElement.injector.get<MatTooltip>(MatTooltip);\n    });\n    it('should show and hide the tooltip', fakeAsync(() => {\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.show();\n      tick(0); // Tick for the show delay (default is 0)\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      fixture.detectChanges();\n      // wait until animation has finished\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      // Make sure tooltip is shown to the user and animation has finished\n      const tooltipElement = overlayContainerElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;\n      expect(tooltipElement instanceof HTMLElement).toBe(true);\n      expect(tooltipElement.classList).toContain('mat-mdc-tooltip-show');\n      // After hide called, a timeout delay is created that will to hide the tooltip.\n      const tooltipDelay = 1000;\n      tooltipDirective.hide(tooltipDelay);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      // After the tooltip delay elapses, expect that the tooltip is not visible.\n      tick(tooltipDelay);\n      fixture.detectChanges();\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      // On animation complete, should expect that the tooltip has been detached.\n      finishCurrentTooltipAnimation(overlayContainerElement, false);\n      assertTooltipInstance(tooltipDirective, false);\n      flush();\n    }));\n    it('should have rendered the tooltip text on init', fakeAsync(() => {\n      // We don't bind mouse events on mobile devices.\n      if (platform.IOS || platform.ANDROID) {\n        return;\n      }\n      dispatchFakeEvent(buttonElement, 'mouseenter');\n      fixture.detectChanges();\n      tick(0);\n      const tooltipElement = overlayContainerElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;\n      expect(tooltipElement.textContent).toContain('initial tooltip message');\n    }));\n  });\n  describe('touch gestures', () => {\n    beforeEach(() => {\n      platform.ANDROID = true;\n    });\n    it('should have a delay when showing on touchstart', fakeAsync(() => {\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      const button: HTMLButtonElement = fixture.nativeElement.querySelector('button');\n      dispatchFakeEvent(button, 'touchstart');\n      fixture.detectChanges();\n      tick(250); // Halfway through the delay.\n      assertTooltipInstance(fixture.componentInstance.tooltip, false);\n      tick(500); // Finish the delay.\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true); // Finish the animation.\n      assertTooltipInstance(fixture.componentInstance.tooltip, true);\n      flush();\n    }));\n    it('should be able to disable opening on touch', fakeAsync(() => {\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.componentInstance.touchGestures = 'off';\n      fixture.detectChanges();\n      const button: HTMLButtonElement = fixture.nativeElement.querySelector('button');\n      dispatchFakeEvent(button, 'touchstart');\n      fixture.detectChanges();\n      tick(500); // Finish the delay.\n      fixture.detectChanges();\n      tick(500); // Finish the animation.\n      assertTooltipInstance(fixture.componentInstance.tooltip, false);\n    }));\n    it('should not prevent the default action on touchstart', () => {\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      const button: HTMLButtonElement = fixture.nativeElement.querySelector('button');\n      const event = dispatchFakeEvent(button, 'touchstart');\n      fixture.detectChanges();\n      expect(event.defaultPrevented).toBe(false);\n    });\n    it('should close on touchend with a delay', fakeAsync(() => {\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      const button: HTMLButtonElement = fixture.nativeElement.querySelector('button');\n      dispatchFakeEvent(button, 'touchstart');\n      fixture.detectChanges();\n      tick(500); // Finish the open delay.\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true); // Finish the animation.\n      assertTooltipInstance(fixture.componentInstance.tooltip, true);\n      dispatchFakeEvent(button, 'touchend');\n      fixture.detectChanges();\n      tick(1000); // 2/3 through the delay\n      assertTooltipInstance(fixture.componentInstance.tooltip, true);\n      tick(500); // Finish the delay.\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, false); // Finish the exit animation.\n      assertTooltipInstance(fixture.componentInstance.tooltip, false);\n      flush();\n    }));\n    it('should close on touchcancel with a delay', fakeAsync(() => {\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      const button: HTMLButtonElement = fixture.nativeElement.querySelector('button');\n      dispatchFakeEvent(button, 'touchstart');\n      fixture.detectChanges();\n      tick(500); // Finish the open delay.\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true); // Finish the animation.\n      assertTooltipInstance(fixture.componentInstance.tooltip, true);\n      dispatchFakeEvent(button, 'touchcancel');\n      fixture.detectChanges();\n      tick(1000); // 2/3 through the delay\n      assertTooltipInstance(fixture.componentInstance.tooltip, true);\n      tick(500); // Finish the delay.\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, false); // Finish the exit animation.\n      assertTooltipInstance(fixture.componentInstance.tooltip, false);\n      flush();\n    }));\n    it('should disable native touch interactions', () => {\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      const styles = fixture.nativeElement.querySelector('button').style;\n      expect(styles.touchAction || (styles as any).webkitUserDrag).toBe('none');\n    });\n    it('should allow native touch interactions if touch gestures are turned off', () => {\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.componentInstance.touchGestures = 'off';\n      fixture.detectChanges();\n      const styles = fixture.nativeElement.querySelector('button').style;\n      expect(styles.touchAction || (styles as any).webkitUserDrag).toBeFalsy();\n    });\n    it('should allow text selection on inputs when gestures are set to auto', () => {\n      const fixture = TestBed.createComponent(TooltipOnTextFields);\n      fixture.detectChanges();\n      const inputStyle = fixture.componentInstance.input.nativeElement.style;\n      const textareaStyle = fixture.componentInstance.textarea.nativeElement.style;\n      expect(inputStyle.userSelect).toBeFalsy();\n      expect(inputStyle.webkitUserSelect).toBeFalsy();\n      expect((inputStyle as any).msUserSelect).toBeFalsy();\n      expect((inputStyle as any).MozUserSelect).toBeFalsy();\n      expect(textareaStyle.userSelect).toBeFalsy();\n      expect(textareaStyle.webkitUserSelect).toBeFalsy();\n      expect((textareaStyle as any).msUserSelect).toBeFalsy();\n      expect((textareaStyle as any).MozUserSelect).toBeFalsy();\n    });\n    it('should disable text selection on inputs when gestures are set to on', () => {\n      const fixture = TestBed.createComponent(TooltipOnTextFields);\n      fixture.componentInstance.touchGestures = 'on';\n      fixture.detectChanges();\n      const inputStyle = fixture.componentInstance.input.nativeElement.style;\n      const inputUserSelect =\n        inputStyle.userSelect ||\n        inputStyle.webkitUserSelect ||\n        (inputStyle as any).msUserSelect ||\n        (inputStyle as any).MozUserSelect;\n      const textareaStyle = fixture.componentInstance.textarea.nativeElement.style;\n      const textareaUserSelect =\n        textareaStyle.userSelect ||\n        textareaStyle.webkitUserSelect ||\n        (textareaStyle as any).msUserSelect ||\n        (textareaStyle as any).MozUserSelect;\n      expect(inputUserSelect).toBe('none');\n      expect(textareaUserSelect).toBe('none');\n    });\n    it('should allow native dragging on draggable elements when gestures are set to auto', () => {\n      const fixture = TestBed.createComponent(TooltipOnDraggableElement);\n      fixture.detectChanges();\n      expect(fixture.componentInstance.button.nativeElement.style.webkitUserDrag).toBeFalsy();\n    });\n    it('should disable native dragging on draggable elements when gestures are set to on', () => {\n      const fixture = TestBed.createComponent(TooltipOnDraggableElement);\n      fixture.componentInstance.touchGestures = 'on';\n      fixture.detectChanges();\n      const styles = fixture.componentInstance.button.nativeElement.style;\n      if ('webkitUserDrag' in styles) {\n        expect(styles.webkitUserDrag).toBe('none');\n      }\n    });\n    it('should not open on `mouseenter` on iOS', () => {\n      platform.IOS = true;\n      platform.ANDROID = false;\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      dispatchMouseEvent(fixture.componentInstance.button.nativeElement, 'mouseenter');\n      fixture.detectChanges();\n      assertTooltipInstance(fixture.componentInstance.tooltip, false);\n    });\n    it('should not open on `mouseenter` on Android', () => {\n      platform.ANDROID = true;\n      platform.IOS = false;\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      dispatchMouseEvent(fixture.componentInstance.button.nativeElement, 'mouseenter');\n      fixture.detectChanges();\n      assertTooltipInstance(fixture.componentInstance.tooltip, false);\n    });\n  });\n  describe('mouse wheel handling', () => {\n    it('should close when a wheel event causes the cursor to leave the trigger', fakeAsync(() => {\n      // We don't bind wheel events on mobile devices.\n      if (platform.IOS || platform.ANDROID) {\n        return;\n      }\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      const button: HTMLButtonElement = fixture.nativeElement.querySelector('button');\n      dispatchFakeEvent(button, 'mouseenter');\n      fixture.detectChanges();\n      tick(500); // Finish the open delay.\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      assertTooltipInstance(fixture.componentInstance.tooltip, true);\n      // Simulate the pointer at the bottom/right of the page.\n      const wheelEvent = createFakeEvent('wheel');\n      Object.defineProperties(wheelEvent, {\n        clientX: {get: () => window.innerWidth},\n        clientY: {get: () => window.innerHeight},\n      });\n      dispatchEvent(button, wheelEvent);\n      fixture.detectChanges();\n      tick(1500); // Finish the delay.\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, false);\n      assertTooltipInstance(fixture.componentInstance.tooltip, false);\n      flush();\n    }));\n    it('should not close if the cursor is over the trigger after a wheel event', fakeAsync(() => {\n      // We don't bind wheel events on mobile devices.\n      if (platform.IOS || platform.ANDROID) {\n        return;\n      }\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      const button: HTMLButtonElement = fixture.nativeElement.querySelector('button');\n      dispatchFakeEvent(button, 'mouseenter');\n      fixture.detectChanges();\n      tick(500); // Finish the open delay.\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      assertTooltipInstance(fixture.componentInstance.tooltip, true);\n      // Simulate the pointer over the trigger.\n      const triggerRect = button.getBoundingClientRect();\n      const wheelEvent = createFakeEvent('wheel');\n      Object.defineProperties(wheelEvent, {\n        clientX: {get: () => triggerRect.left + 1},\n        clientY: {get: () => triggerRect.top + 1},\n      });\n      dispatchEvent(button, wheelEvent);\n      fixture.detectChanges();\n      tick(1500); // Finish the delay.\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, false);\n      assertTooltipInstance(fixture.componentInstance.tooltip, true);\n      flush();\n    }));\n  });\n});\n@Component({\n  selector: 'app',\n  template: `\n    @if (showButton) {\n      <button #button\n        [matTooltip]=\"message\"\n        [matTooltipPosition]=\"position\"\n        [matTooltipClass]=\"{'custom-one': showTooltipClass, 'custom-two': showTooltipClass}\"\n        [matTooltipTouchGestures]=\"touchGestures\"\n        [matTooltipDisabled]=\"tooltipDisabled\">Button</button>\n    }`,\n  standalone: true,\n  imports: [MatTooltipModule, OverlayModule],\n})\nclass BasicTooltipDemo {\n  position = 'below';\n  message: any = initialTooltipMessage;\n  showButton = true;\n  showTooltipClass = false;\n  tooltipDisabled = false;\n  touchGestures: TooltipTouchGestures = 'auto';\n  @ViewChild(MatTooltip) tooltip: MatTooltip;\n  @ViewChild('button') button: ElementRef<HTMLButtonElement>;\n}\n@Component({\n  selector: 'app',\n  template: `\n    <div cdkScrollable style=\"padding: 100px; margin: 300px;\n                               height: 200px; width: 200px; overflow: auto;\">\n      @if (showButton) {\n        <button style=\"margin-bottom: 600px\"\n              [matTooltip]=\"message\"\n              [matTooltipPosition]=\"position\">Button</button>\n      }\n    </div>`,\n  standalone: true,\n  imports: [MatTooltipModule, OverlayModule],\n})\nclass ScrollableTooltipDemo {\n  position: string = 'below';\n  message: string = initialTooltipMessage;\n  showButton: boolean = true;\n  @ViewChild(CdkScrollable) scrollingContainer: CdkScrollable;\n  scrollDown() {\n    const scrollingContainerEl = this.scrollingContainer.getElementRef().nativeElement;\n    scrollingContainerEl.scrollTop = 250;\n    // Emit a scroll event from the scrolling element in our component.\n    // This event should be picked up by the scrollable directive and notify.\n    // The notification should be picked up by the service.\n    dispatchFakeEvent(scrollingContainerEl, 'scroll');\n  }\n}\n@Component({\n  selector: 'app',\n  template: `\n    <button [matTooltip]=\"message\"\n            [matTooltipPosition]=\"position\">\n      Button\n    </button>`,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  standalone: true,\n  imports: [MatTooltipModule, OverlayModule],\n})\nclass OnPushTooltipDemo {\n  position: string = 'below';\n  message: string = initialTooltipMessage;\n}\n@Component({\n  selector: 'app',\n  template: `\n    @for (tooltip of tooltips; track tooltip) {\n      <button [matTooltip]=\"tooltip\">Button {{tooltip}}</button>\n    }\n  `,\n  standalone: true,\n  imports: [MatTooltipModule, OverlayModule],\n})\nclass DynamicTooltipsDemo {\n  tooltips: string[] = [];\n}\n@Component({\n  template: `<button [matTooltip]=\"message\" [attr.aria-label]=\"message\">Click me</button>`,\n  standalone: true,\n  imports: [MatTooltipModule, OverlayModule],\n})\nclass DataBoundAriaLabelTooltip {\n  message = 'Hello there';\n}\n@Component({\n  template: `\n    <input\n      #input\n      matTooltip=\"Something\"\n      [matTooltipTouchGestures]=\"touchGestures\">\n    <textarea\n      #textarea\n      matTooltip=\"Another thing\"\n      [matTooltipTouchGestures]=\"touchGestures\"></textarea>\n  `,\n  standalone: true,\n  imports: [MatTooltipModule, OverlayModule],\n})\nclass TooltipOnTextFields {\n  @ViewChild('input') input: ElementRef<HTMLInputElement>;\n  @ViewChild('textarea') textarea: ElementRef<HTMLTextAreaElement>;\n  touchGestures: TooltipTouchGestures = 'auto';\n}\n@Component({\n  template: `\n    <button\n      #button\n      draggable=\"true\"\n      matTooltip=\"Drag me\"\n      [matTooltipTouchGestures]=\"touchGestures\"></button>\n  `,\n  standalone: true,\n  imports: [MatTooltipModule, OverlayModule],\n})\nclass TooltipOnDraggableElement {\n  @ViewChild('button') button: ElementRef;\n  touchGestures: TooltipTouchGestures = 'auto';\n}\n@Component({\n  selector: 'app',\n  template: `<button #button [matTooltip]=\"message\">Button</button>`,\n  standalone: false,\n})\nclass TooltipDemoWithoutPositionBinding {\n  message: any = initialTooltipMessage;\n  @ViewChild(MatTooltip) tooltip: MatTooltip;\n  @ViewChild('button') button: ElementRef<HTMLButtonElement>;\n}\n@Component({\n  selector: 'app',\n  template: `<button #button [matTooltip]=\"message\">Button</button>`,\n  standalone: false,\n})\nclass TooltipDemoWithoutTooltipClassBinding {\n  message = initialTooltipMessage;\n  @ViewChild(MatTooltip) tooltip: MatTooltip;\n  @ViewChild('button') button: ElementRef<HTMLButtonElement>;\n}\n@Component({\n  selector: 'app',\n  template: `\n    <button #button matTooltipClass=\"fixed-tooltip-class\" [matTooltip]=\"message\">Button</button>\n  `,\n  standalone: false,\n})\nclass TooltipDemoWithTooltipClassBinding {\n  message: any = initialTooltipMessage;\n  @ViewChild(MatTooltip) tooltip: MatTooltip;\n  @ViewChild('button') button: ElementRef<HTMLButtonElement>;\n}\n@Component({\n  selector: 'app',\n  styles: `button { width: 500px; height: 500px; }`,\n  template: `<button #button [matTooltip]=\"message\">Button</button>`,\n  standalone: false,\n})\nclass WideTooltipDemo {\n  message = 'Test';\n  @ViewChild(MatTooltip) tooltip: MatTooltip;\n  @ViewChild('button') button: ElementRef<HTMLButtonElement>;\n}\nfunction assertTooltipInstance(tooltip: MatTooltip, shouldExist: boolean): void {\n  // Note that we have to cast this to a boolean, because Jasmine will go into an infinite loop\n  // if it tries to stringify the `_tooltipInstance` when an assertion fails. The infinite loop\n  // happens due to the `_tooltipInstance` having a circular structure.\n  expect(!!tooltip._tooltipInstance).toBe(shouldExist);\n}\nfunction finishCurrentTooltipAnimation(overlayContainer: HTMLElement, isVisible: boolean) {\n  const tooltip = overlayContainer.querySelector('.mat-mdc-tooltip')!;\n  const event = createFakeEvent('animationend');\n  Object.defineProperty(event, 'animationName', {\n    get: () => `mat-mdc-tooltip-${isVisible ? 'show' : 'hide'}`,\n  });\n  dispatchEvent(tooltip, event);\n}"
}