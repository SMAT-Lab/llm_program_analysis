{
  "type": "file",
  "name": "208.ts",
  "label": "208.ts",
  "start_line": -1,
  "end_line": 513,
  "classes": [
    {
      "type": "class",
      "name": "%dflt",
      "label": "%dflt",
      "start_line": -1,
      "end_line": 508,
      "functions": [
        {
          "type": "function",
          "name": "%dflt",
          "label": "%dflt",
          "start_line": -1,
          "end_line": 508,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/208.ts: %dflt\nforkScript = staticinvoke <@%unk/%unk: .join()>(__dirname, './fork.js')\nworkerPath = staticinvoke <@%unk/%unk: .join()>(__dirname, './batch/run-batch.js')\n%0 = chalk.<@%unk/%unk: .green>\n%1 = chalk.<@%unk/%unk: .greenBright>\n%2 = chalk.<@%unk/%unk: .red>\n%3 = chalk.<@%unk/%unk: .redBright>\n%4 = chalk.<@%unk/%unk: .cyan>\n%5 = chalk.<@%unk/%unk: .cyanBright>\n%6 = chalk.<@%unk/%unk: .yellow>\n%7 = chalk.<@%unk/%unk: .yellowBright>\n%8 = chalk.<@%unk/%unk: .magenta>\n%9 = chalk.<@%unk/%unk: .magentaBright>\n%10 = newarray (unknown)[10]\n%10[0] = %0\n%10[1] = %1\n%10[2] = %2\n%10[3] = %3\n%10[4] = %4\n%10[5] = %5\n%10[6] = %6\n%10[7] = %7\n%10[8] = %8\n%10[9] = %9\ncolors = %10\nreturn",
              "start_line": 1,
              "end_line": 508,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": ""
        },
        {
          "type": "function",
          "name": "getColor",
          "label": "getColor",
          "start_line": 1,
          "end_line": 487,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "projectName = parameter0: string\nthis = this: @ts_files/208.ts: %dflt\ncode = 0\ni = 0",
              "start_line": 1,
              "end_line": 487,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%0 = projectName.<@%unk/%unk: .length>\nif i < %0",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "code = code + instanceinvoke projectName.<@%unk/%unk: .charCodeAt()>(i)\ni = i + 1",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "blockRef",
                          "label": "(RepeatedBlock)"
                        }
                      ]
                    },
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "%1 = colors.<@%unk/%unk: .length>\ncolorIndex = code % %1\n%2 = colors[colorIndex]\nreturn %2",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": []
                    }
                  ]
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "function getColor(projectName: string) {\n  let code = 0;\n  for (let i = 0; i < projectName.length; ++i) {\n    code += projectName.charCodeAt(i);\n  }\n  const colorIndex = code % colors.length;\n  return colors[colorIndex];\n}"
        },
        {
          "type": "function",
          "name": "logClearLineToPrefixTransformer",
          "label": "logClearLineToPrefixTransformer",
          "start_line": 1,
          "end_line": 493,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "prefix = parameter0: string\nthis = this: @ts_files/208.ts: %dflt\nprevChunk = null\n%0 = new @%unk/%unk: Transform\n%1 = new @ts_files/208.ts: %AC$%dflt$logClearLineToPrefixTransformer$9\ninstanceinvoke %1.<@ts_files/208.ts: %AC$%dflt$logClearLineToPrefixTransformer$9.constructor()>()\ninstanceinvoke %0.<@%unk/%unk: Transform.constructor()>(%1)\nreturn %0",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "function logClearLineToPrefixTransformer(prefix: string) {\n  let prevChunk = null;\n  return new Transform({\n    transform(chunk, _encoding, callback) {\n      if (prevChunk && prevChunk.toString() === '\\x1b[2K') {\n        chunk = chunk.toString().replace(/\\x1b\\[1G/g, (m) => m + prefix);\n      }\n      this.push(chunk);\n      prevChunk = chunk;\n      callback();\n    },\n  });\n}"
        },
        {
          "type": "function",
          "name": "addPrefixTransformer",
          "label": "addPrefixTransformer",
          "start_line": 1,
          "end_line": 506,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "prefix = parameter0: string\nthis = this: @ts_files/208.ts: %dflt\n%0 = process.<@%unk/%unk: .platform>\n%1 = instanceinvoke %0.<@%unk/%unk: .startsWith()>('win')\nif %1 != 0",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "newLineSeparator = '\r\n'",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "%3 = new @%unk/%unk: Transform\n%4 = new @ts_files/208.ts: %AC$%dflt$addPrefixTransformer$10\ninstanceinvoke %4.<@ts_files/208.ts: %AC$%dflt$addPrefixTransformer$10.constructor()>()\ninstanceinvoke %3.<@%unk/%unk: Transform.constructor()>(%4)\nreturn %3",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": []
                    }
                  ]
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "newLineSeparator = '\n'",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "blockRef",
                      "label": "(RepeatedBlock)"
                    }
                  ]
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "function addPrefixTransformer(prefix?: string) {\n  const newLineSeparator = process.platform.startsWith('win') ? '\\r\\n' : '\\n';\n  return new Transform({\n    transform(chunk, _encoding, callback) {\n      const list = chunk.toString().split(/\\r\\n|[\\n\\v\\f\\r\\x85\\u2028\\u2029]/g);\n      list\n        .filter(Boolean)\n        .forEach((m) =>\n          this.push(\n            prefix ? prefix + ' ' + m + newLineSeparator : m + newLineSeparator\n          )\n        );\n      callback();\n    },\n  });\n}"
        }
      ],
      "classes": [],
      "blocks": [],
      "simplified_code": ""
    },
    {
      "type": "class",
      "name": "%AC$0",
      "label": "%AC$0",
      "start_line": 120,
      "end_line": 120,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n      temporaryOutputPath: string;\n      streamOutput: boolean;\n      pipeOutput: boolean;\n      taskGraph: TaskGraph;\n      env: NodeJS.ProcessEnv;\n    }"
    },
    {
      "type": "class",
      "name": "%AC$1",
      "label": "%AC$1",
      "start_line": 127,
      "end_line": 127,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{ code: number; terminalOutput: string }"
    },
    {
      "type": "class",
      "name": "%AC$2",
      "label": "%AC$2",
      "start_line": 150,
      "end_line": 150,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n      temporaryOutputPath: string;\n      streamOutput: boolean;\n      pipeOutput: boolean;\n      taskGraph: TaskGraph;\n      env: NodeJS.ProcessEnv;\n      disablePseudoTerminal: boolean;\n    }"
    },
    {
      "type": "class",
      "name": "%AC$3",
      "label": "%AC$3",
      "start_line": 158,
      "end_line": 158,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{ code: number; terminalOutput: string }"
    },
    {
      "type": "class",
      "name": "%AC$4",
      "label": "%AC$4",
      "start_line": 191,
      "end_line": 191,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n      temporaryOutputPath: string;\n      streamOutput: boolean;\n      taskGraph: TaskGraph;\n      env: NodeJS.ProcessEnv;\n    }"
    },
    {
      "type": "class",
      "name": "%AC$5",
      "label": "%AC$5",
      "start_line": 197,
      "end_line": 197,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{ code: number; terminalOutput: string }"
    },
    {
      "type": "class",
      "name": "%AC$6",
      "label": "%AC$6",
      "start_line": 241,
      "end_line": 241,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n      streamOutput: boolean;\n      temporaryOutputPath: string;\n      taskGraph: TaskGraph;\n      env: NodeJS.ProcessEnv;\n    }"
    },
    {
      "type": "class",
      "name": "%AC$7",
      "label": "%AC$7",
      "start_line": 262,
      "end_line": 262,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n      streamOutput: boolean;\n      temporaryOutputPath: string;\n      taskGraph: TaskGraph;\n      env: NodeJS.ProcessEnv;\n    }"
    },
    {
      "type": "class",
      "name": "%AC$8",
      "label": "%AC$8",
      "start_line": 348,
      "end_line": 348,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n      streamOutput: boolean;\n      temporaryOutputPath: string;\n      taskGraph: TaskGraph;\n      env: NodeJS.ProcessEnv;\n    }"
    },
    {
      "type": "class",
      "name": "ForkedProcessTaskRunner",
      "label": "ForkedProcessTaskRunner",
      "start_line": 1,
      "end_line": 508,
      "functions": [
        {
          "type": "function",
          "name": "constructor",
          "label": "constructor",
          "start_line": 1,
          "end_line": 508,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "instanceinvoke this.<@ts_files/208.ts: ForkedProcessTaskRunner.%instInit()>()\noptions = parameter0: DefaultTasksRunnerOptions\nthis = this: @ts_files/208.ts: ForkedProcessTaskRunner\nreturn",
              "start_line": 1,
              "end_line": 508,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "constructor(private readonly options: DefaultTasksRunnerOptions) {}"
        },
        {
          "type": "function",
          "name": "init",
          "label": "init",
          "start_line": 1,
          "end_line": 33,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/208.ts: ForkedProcessTaskRunner\n%0 = this.<@ts_files/208.ts: ForkedProcessTaskRunner.pseudoTerminal>\nif %0 != 0",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%1 = this.<@ts_files/208.ts: ForkedProcessTaskRunner.pseudoTerminal>\n%2 = instanceinvoke %1.<@%unk/%unk: .init()>()\n%3 = await %2",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "instanceinvoke this.<@ts_files/208.ts: ForkedProcessTaskRunner.setupProcessEventListeners()>()\nreturn",
                      "start_line": 1,
                      "end_line": 508,
                      "successors": []
                    }
                  ]
                },
                {
                  "type": "blockRef",
                  "label": "(RepeatedBlock)"
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "async init() {\n    if (this.pseudoTerminal) {\n      await this.pseudoTerminal.init();\n    }\n    this.setupProcessEventListeners();\n  }"
        },
        {
          "type": "function",
          "name": "forkProcessForBatch",
          "label": "forkProcessForBatch",
          "start_line": 1,
          "end_line": 40,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "ObjectBindingPattern = parameter0: Batch\nfullTaskGraph = parameter1: TaskGraph\nenv = parameter2: NodeJS.ProcessEnv\nthis = this: @ts_files/208.ts: ForkedProcessTaskRunner\n%0 = new @%unk/%unk: Promise<BatchResults>\ninstanceinvoke %0.<@%unk/%unk: Promise.constructor()>(%AM0$forkProcessForBatch)\nreturn %0",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "public forkProcessForBatch(\n    { executorName, taskGraph: batchTaskGraph }: Batch,\n    fullTaskGraph: TaskGraph,\n    env: NodeJS.ProcessEnv\n  ) {\n    return new Promise<BatchResults>((res, rej) => {\n      try {\n        const count = Object.keys(batchTaskGraph.tasks).length;\n        if (count > 1) {\n          output.logSingleLine(\n            `Running ${output.bold(count)} ${output.bold(\n              'tasks'\n            )} with ${output.bold(executorName)}`\n          );\n        } else {\n          const args = getPrintableCommandArgsForTask(\n            Object.values(batchTaskGraph.tasks)[0]\n          );\n          output.logCommand(args.join(' '));\n        }\n        const p = fork(workerPath, {\n          stdio: ['inherit', 'inherit', 'inherit', 'ipc'],\n          env,\n        });\n        this.processes.add(p);\n        p.once('exit', (code, signal) => {\n          this.processes.delete(p);\n          if (code === null) code = signalToCode(signal);\n          if (code !== 0) {\n            const results: BatchResults = {};\n            for (const rootTaskId of batchTaskGraph.roots) {\n              results[rootTaskId] = {\n                success: false,\n                terminalOutput: '',\n              };\n            }\n            rej(\n              new Error(\n                `\"${executorName}\" exited unexpectedly with code: ${code}`\n              )\n            );\n          }\n        });\n        p.on('message', (message: BatchMessage) => {\n          switch (message.type) {\n            case BatchMessageType.CompleteBatchExecution: {\n              res(message.results);\n              break;\n            }\n            case BatchMessageType.RunTasks: {\n              break;\n            }\n            default: {\n              // Re-emit any non-batch messages from the task process\n              if (process.send) {\n                process.send(message);\n              }\n            }\n          }\n        });\n        // Start the tasks\n        p.send({\n          type: BatchMessageType.RunTasks,\n          executorName,\n          batchTaskGraph,\n          fullTaskGraph,\n        });\n      } catch (e) {\n        rej(e);\n      }\n    });\n  }"
        },
        {
          "type": "function",
          "name": "forkProcessLegacy",
          "label": "forkProcessLegacy",
          "start_line": 1,
          "end_line": 112,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "task = parameter0: Task\nObjectBindingPattern = parameter1: @ts_files/208.ts: %AC$0\nthis = this: @ts_files/208.ts: ForkedProcessTaskRunner\nif pipeOutput != 0",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%0 = new @ts_files/208.ts: %AC$ForkedProcessTaskRunner$forkProcessLegacy$15\ninstanceinvoke %0.<@ts_files/208.ts: %AC$ForkedProcessTaskRunner$forkProcessLegacy$15.constructor()>()\n%1 = instanceinvoke this.<@ts_files/208.ts: ForkedProcessTaskRunner.forkProcessPipeOutputCapture(Task, @ts_files/208.ts: %AC$6)>(task, %0)\n%2 = await %1",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "return %2",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": []
                    }
                  ]
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%3 = new @ts_files/208.ts: %AC$ForkedProcessTaskRunner$forkProcessLegacy$16\ninstanceinvoke %3.<@ts_files/208.ts: %AC$ForkedProcessTaskRunner$forkProcessLegacy$16.constructor()>()\n%4 = instanceinvoke this.<@ts_files/208.ts: ForkedProcessTaskRunner.forkProcessDirectOutputCapture(Task, @ts_files/208.ts: %AC$8)>(task, %3)\n%2 = await %4",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "blockRef",
                      "label": "(RepeatedBlock)"
                    }
                  ]
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "public async forkProcessLegacy(\n    task: Task,\n    {\n      temporaryOutputPath,\n      streamOutput,\n      pipeOutput,\n      taskGraph,\n      env,\n    }: {\n      temporaryOutputPath: string;\n      streamOutput: boolean;\n      pipeOutput: boolean;\n      taskGraph: TaskGraph;\n      env: NodeJS.ProcessEnv;\n    }\n  ): Promise<{ code: number; terminalOutput: string }> {\n    return pipeOutput\n      ? await this.forkProcessPipeOutputCapture(task, {\n          temporaryOutputPath,\n          streamOutput,\n          taskGraph,\n          env,\n        })\n      : await this.forkProcessDirectOutputCapture(task, {\n          temporaryOutputPath,\n          streamOutput,\n          taskGraph,\n          env,\n        });\n  }"
        },
        {
          "type": "function",
          "name": "forkProcess",
          "label": "forkProcess",
          "start_line": 1,
          "end_line": 142,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "task = parameter0: Task\nObjectBindingPattern = parameter1: @ts_files/208.ts: %AC$2\nthis = this: @ts_files/208.ts: ForkedProcessTaskRunner\n%0 = process.<@%unk/%unk: .env>\n%1 = %0.<@%unk/%unk: .NX_PREFIX_OUTPUT>\n%2 = %1 === 'true'\nshouldPrefix = streamOutput && %2\n%3 = this.<@ts_files/208.ts: ForkedProcessTaskRunner.pseudoTerminal>\n%4 = !%3\n%5 = %4 || disablePseudoTerminal\n%6 = !streamOutput\n%7 = %5 || %6\n%8 = %7 || shouldPrefix\nif %8 != false",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%9 = new @ts_files/208.ts: %AC$ForkedProcessTaskRunner$forkProcess$17\ninstanceinvoke %9.<@ts_files/208.ts: %AC$ForkedProcessTaskRunner$forkProcess$17.constructor()>()\n%10 = instanceinvoke this.<@ts_files/208.ts: ForkedProcessTaskRunner.forkProcessWithPrefixAndNotTTY(Task, @ts_files/208.ts: %AC$7)>(task, %9)\nreturn %10",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": []
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%11 = new @ts_files/208.ts: %AC$ForkedProcessTaskRunner$forkProcess$18\ninstanceinvoke %11.<@ts_files/208.ts: %AC$ForkedProcessTaskRunner$forkProcess$18.constructor()>()\n%12 = instanceinvoke this.<@ts_files/208.ts: ForkedProcessTaskRunner.forkProcessWithPseudoTerminal(Task, @ts_files/208.ts: %AC$4)>(task, %11)\nreturn %12",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": []
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "public async forkProcess(\n    task: Task,\n    {\n      temporaryOutputPath,\n      streamOutput,\n      taskGraph,\n      env,\n      disablePseudoTerminal,\n    }: {\n      temporaryOutputPath: string;\n      streamOutput: boolean;\n      pipeOutput: boolean;\n      taskGraph: TaskGraph;\n      env: NodeJS.ProcessEnv;\n      disablePseudoTerminal: boolean;\n    }\n  ): Promise<{ code: number; terminalOutput: string }> {\n    const shouldPrefix =\n      streamOutput && process.env.NX_PREFIX_OUTPUT === 'true';\n    // streamOutput would be false if we are running multiple targets\n    // there's no point in running the commands in a pty if we are not streaming the output\n    if (\n      !this.pseudoTerminal ||\n      disablePseudoTerminal ||\n      !streamOutput ||\n      shouldPrefix\n    ) {\n      return this.forkProcessWithPrefixAndNotTTY(task, {\n        temporaryOutputPath,\n        streamOutput,\n        taskGraph,\n        env,\n      });\n    } else {\n      return this.forkProcessWithPseudoTerminal(task, {\n        temporaryOutputPath,\n        streamOutput,\n        taskGraph,\n        env,\n      });\n    }\n  }"
        },
        {
          "type": "function",
          "name": "forkProcessWithPseudoTerminal",
          "label": "forkProcessWithPseudoTerminal",
          "start_line": 1,
          "end_line": 184,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "task = parameter0: Task\nObjectBindingPattern = parameter1: @ts_files/208.ts: %AC$4\nthis = this: @ts_files/208.ts: ForkedProcessTaskRunner\nargs = staticinvoke <@%unk/%unk: .getPrintableCommandArgsForTask()>(task)\nif streamOutput != 0",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%0 = instanceinvoke args.<@%unk/%unk: .join()>(' ')\ninstanceinvoke output.<@%unk/%unk: .logCommand()>(%0)",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "childId = task.<@%unk/%unk: .id>\n%1 = new @ts_files/208.ts: %AC$ForkedProcessTaskRunner$forkProcessWithPseudoTerminal$19\ninstanceinvoke %1.<@ts_files/208.ts: %AC$ForkedProcessTaskRunner$forkProcessWithPseudoTerminal$19.constructor()>()\n%2 = this.<@ts_files/208.ts: ForkedProcessTaskRunner.pseudoTerminal>\n%3 = instanceinvoke %2.<@%unk/%unk: .fork()>(childId, forkScript, %1)\np = await %3\n%4 = new @ts_files/208.ts: %AC$ForkedProcessTaskRunner$forkProcessWithPseudoTerminal$20\ninstanceinvoke %4.<@ts_files/208.ts: %AC$ForkedProcessTaskRunner$forkProcessWithPseudoTerminal$20.constructor()>()\ninstanceinvoke p.<@%unk/%unk: .send()>(%4)\n%5 = this.<@ts_files/208.ts: ForkedProcessTaskRunner.processes>\ninstanceinvoke %5.<@%unk/%unk: .add()>(p)\nterminalOutput = ''\ninstanceinvoke p.<@%unk/%unk: .onOutput()>(%AM3$forkProcessWithPseudoTerminal)\n%6 = new @%unk/%unk: Promise\ninstanceinvoke %6.<@%unk/%unk: Promise.constructor()>(%AM4$forkProcessWithPseudoTerminal)\nreturn %6",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": []
                    }
                  ]
                },
                {
                  "type": "blockRef",
                  "label": "(RepeatedBlock)"
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "private async forkProcessWithPseudoTerminal(\n    task: Task,\n    {\n      temporaryOutputPath,\n      streamOutput,\n      taskGraph,\n      env,\n    }: {\n      temporaryOutputPath: string;\n      streamOutput: boolean;\n      taskGraph: TaskGraph;\n      env: NodeJS.ProcessEnv;\n    }\n  ): Promise<{ code: number; terminalOutput: string }> {\n    const args = getPrintableCommandArgsForTask(task);\n    if (streamOutput) {\n      output.logCommand(args.join(' '));\n    }\n    const childId = task.id;\n    const p = await this.pseudoTerminal.fork(childId, forkScript, {\n      cwd: process.cwd(),\n      execArgv: process.execArgv,\n      jsEnv: env,\n      quiet: !streamOutput,\n    });\n    p.send({\n      targetDescription: task.target,\n      overrides: task.overrides,\n      taskGraph,\n      isVerbose: this.verbose,\n    });\n    this.processes.add(p);\n    let terminalOutput = '';\n    p.onOutput((msg) => {\n      terminalOutput += msg;\n    });\n    return new Promise((res) => {\n      p.onExit((code) => {\n        // If the exit code is greater than 128, it's a special exit code for a signal\n        if (code >= 128) {\n          process.exit(code);\n        }\n        this.writeTerminalOutput(temporaryOutputPath, terminalOutput);\n        res({\n          code,\n          terminalOutput,\n        });\n      });\n    });\n  }"
        },
        {
          "type": "function",
          "name": "forkProcessPipeOutputCapture",
          "label": "forkProcessPipeOutputCapture",
          "start_line": 1,
          "end_line": 234,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "task = parameter0: Task\nObjectBindingPattern = parameter1: @ts_files/208.ts: %AC$6\nthis = this: @ts_files/208.ts: ForkedProcessTaskRunner\n%0 = new @ts_files/208.ts: %AC$ForkedProcessTaskRunner$forkProcessPipeOutputCapture$22\ninstanceinvoke %0.<@ts_files/208.ts: %AC$ForkedProcessTaskRunner$forkProcessPipeOutputCapture$22.constructor()>()\n%1 = instanceinvoke this.<@ts_files/208.ts: ForkedProcessTaskRunner.forkProcessWithPrefixAndNotTTY(Task, @ts_files/208.ts: %AC$7)>(task, %0)\nreturn %1",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "private forkProcessPipeOutputCapture(\n    task: Task,\n    {\n      streamOutput,\n      temporaryOutputPath,\n      taskGraph,\n      env,\n    }: {\n      streamOutput: boolean;\n      temporaryOutputPath: string;\n      taskGraph: TaskGraph;\n      env: NodeJS.ProcessEnv;\n    }\n  ) {\n    return this.forkProcessWithPrefixAndNotTTY(task, {\n      streamOutput,\n      temporaryOutputPath,\n      taskGraph,\n      env,\n    });\n  }"
        },
        {
          "type": "function",
          "name": "forkProcessWithPrefixAndNotTTY",
          "label": "forkProcessWithPrefixAndNotTTY",
          "start_line": 1,
          "end_line": 255,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "task = parameter0: Task\nObjectBindingPattern = parameter1: @ts_files/208.ts: %AC$7\nthis = this: @ts_files/208.ts: ForkedProcessTaskRunner\n%0 = new @%unk/%unk: Promise<@ts_files/208.ts: %AC$23>\ninstanceinvoke %0.<@%unk/%unk: Promise.constructor()>(%AM6$forkProcessWithPrefixAndNotTTY)\nreturn %0",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "private forkProcessWithPrefixAndNotTTY(\n    task: Task,\n    {\n      streamOutput,\n      temporaryOutputPath,\n      taskGraph,\n      env,\n    }: {\n      streamOutput: boolean;\n      temporaryOutputPath: string;\n      taskGraph: TaskGraph;\n      env: NodeJS.ProcessEnv;\n    }\n  ) {\n    return new Promise<{ code: number; terminalOutput: string }>((res, rej) => {\n      try {\n        const args = getPrintableCommandArgsForTask(task);\n        if (streamOutput) {\n          output.logCommand(args.join(' '));\n        }\n        const p = fork(this.cliPath, {\n          stdio: ['inherit', 'pipe', 'pipe', 'ipc'],\n          env,\n        });\n        this.processes.add(p);\n        // Re-emit any messages from the task process\n        p.on('message', (message) => {\n          if (process.send) {\n            process.send(message);\n          }\n        });\n        // Send message to run the executor\n        p.send({\n          targetDescription: task.target,\n          overrides: task.overrides,\n          taskGraph,\n          isVerbose: this.verbose,\n        });\n        if (streamOutput) {\n          if (process.env.NX_PREFIX_OUTPUT === 'true') {\n            const color = getColor(task.target.project);\n            const prefixText = `${task.target.project}:`;\n            p.stdout\n              .pipe(\n                logClearLineToPrefixTransformer(color.bold(prefixText) + ' ')\n              )\n              .pipe(addPrefixTransformer(color.bold(prefixText)))\n              .pipe(process.stdout);\n            p.stderr\n              .pipe(logClearLineToPrefixTransformer(color(prefixText) + ' '))\n              .pipe(addPrefixTransformer(color(prefixText)))\n              .pipe(process.stderr);\n          } else {\n            p.stdout.pipe(addPrefixTransformer()).pipe(process.stdout);\n            p.stderr.pipe(addPrefixTransformer()).pipe(process.stderr);\n          }\n        }\n        let outWithErr = [];\n        p.stdout.on('data', (chunk) => {\n          outWithErr.push(chunk.toString());\n        });\n        p.stderr.on('data', (chunk) => {\n          outWithErr.push(chunk.toString());\n        });\n        p.on('exit', (code, signal) => {\n          this.processes.delete(p);\n          if (code === null) code = signalToCode(signal);\n          // we didn't print any output as we were running the command\n          // print all the collected output|\n          const terminalOutput = outWithErr.join('');\n          if (!streamOutput) {\n            this.options.lifeCycle.printTaskTerminalOutput(\n              task,\n              code === 0 ? 'success' : 'failure',\n              terminalOutput\n            );\n          }\n          this.writeTerminalOutput(temporaryOutputPath, terminalOutput);\n          res({ code, terminalOutput });\n        });\n      } catch (e) {\n        console.error(e);\n        rej(e);\n      }\n    });\n  }"
        },
        {
          "type": "function",
          "name": "forkProcessDirectOutputCapture",
          "label": "forkProcessDirectOutputCapture",
          "start_line": 1,
          "end_line": 341,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "task = parameter0: Task\nObjectBindingPattern = parameter1: @ts_files/208.ts: %AC$8\nthis = this: @ts_files/208.ts: ForkedProcessTaskRunner\n%0 = new @%unk/%unk: Promise<@ts_files/208.ts: %AC$27>\ninstanceinvoke %0.<@%unk/%unk: Promise.constructor()>(%AM11$forkProcessDirectOutputCapture)\nreturn %0",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "private forkProcessDirectOutputCapture(\n    task: Task,\n    {\n      streamOutput,\n      temporaryOutputPath,\n      taskGraph,\n      env,\n    }: {\n      streamOutput: boolean;\n      temporaryOutputPath: string;\n      taskGraph: TaskGraph;\n      env: NodeJS.ProcessEnv;\n    }\n  ) {\n    return new Promise<{ code: number; terminalOutput: string }>((res, rej) => {\n      try {\n        const args = getPrintableCommandArgsForTask(task);\n        if (streamOutput) {\n          output.logCommand(args.join(' '));\n        }\n        const p = fork(this.cliPath, {\n          stdio: ['inherit', 'inherit', 'inherit', 'ipc'],\n          env,\n        });\n        this.processes.add(p);\n        // Re-emit any messages from the task process\n        p.on('message', (message) => {\n          if (process.send) {\n            process.send(message);\n          }\n        });\n        // Send message to run the executor\n        p.send({\n          targetDescription: task.target,\n          overrides: task.overrides,\n          taskGraph,\n          isVerbose: this.verbose,\n        });\n        p.on('exit', (code, signal) => {\n          if (code === null) code = signalToCode(signal);\n          // we didn't print any output as we were running the command\n          // print all the collected output\n          let terminalOutput = '';\n          try {\n            terminalOutput = this.readTerminalOutput(temporaryOutputPath);\n            if (!streamOutput) {\n              this.options.lifeCycle.printTaskTerminalOutput(\n                task,\n                code === 0 ? 'success' : 'failure',\n                terminalOutput\n              );\n            }\n          } catch (e) {\n            console.log(stripIndents`\n              Unable to print terminal output for Task \"${task.id}\".\n              Task failed with Exit Code ${code} and Signal \"${signal}\".\n              Received error message:\n              ${e.message}\n            `);\n          }\n          res({\n            code,\n            terminalOutput,\n          });\n        });\n      } catch (e) {\n        console.error(e);\n        rej(e);\n      }\n    });\n  }"
        },
        {
          "type": "function",
          "name": "readTerminalOutput",
          "label": "readTerminalOutput",
          "start_line": 1,
          "end_line": 412,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "outputPath = parameter0: string\nthis = this: @ts_files/208.ts: ForkedProcessTaskRunner\n%0 = staticinvoke <@%unk/%unk: .readFileSync()>(outputPath)\n%1 = instanceinvoke %0.<@%unk/%unk: .toString()>()\nreturn %1",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "private readTerminalOutput(outputPath: string) {\n    return readFileSync(outputPath).toString();\n  }"
        },
        {
          "type": "function",
          "name": "writeTerminalOutput",
          "label": "writeTerminalOutput",
          "start_line": 1,
          "end_line": 508,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "outputPath = parameter0: string\ncontent = parameter1: string\nthis = this: @ts_files/208.ts: ForkedProcessTaskRunner\nstaticinvoke <@%unk/%unk: .writeFileSync()>(outputPath, content)\nreturn",
              "start_line": 1,
              "end_line": 508,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "private writeTerminalOutput(outputPath: string, content: string) {\n    writeFileSync(outputPath, content);\n  }"
        },
        {
          "type": "function",
          "name": "setupProcessEventListeners",
          "label": "setupProcessEventListeners",
          "start_line": 1,
          "end_line": 418,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/208.ts: ForkedProcessTaskRunner\n%0 = this.<@ts_files/208.ts: ForkedProcessTaskRunner.pseudoTerminal>\nif %0 != 0",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%1 = this.<@ts_files/208.ts: ForkedProcessTaskRunner.pseudoTerminal>\ninstanceinvoke %1.<@%unk/%unk: .onMessageFromChildren()>(%AM14$setupProcessEventListeners)",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "instanceinvoke process.<@%unk/%unk: .on()>('message', %AM15$setupProcessEventListeners)\ninstanceinvoke process.<@%unk/%unk: .on()>('exit', %AM17$setupProcessEventListeners)\ninstanceinvoke process.<@%unk/%unk: .on()>('SIGINT', %AM19$setupProcessEventListeners)\ninstanceinvoke process.<@%unk/%unk: .on()>('SIGTERM', %AM21$setupProcessEventListeners)\ninstanceinvoke process.<@%unk/%unk: .on()>('SIGHUP', %AM23$setupProcessEventListeners)\nreturn",
                      "start_line": 1,
                      "end_line": 508,
                      "successors": []
                    }
                  ]
                },
                {
                  "type": "blockRef",
                  "label": "(RepeatedBlock)"
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "private setupProcessEventListeners() {\n    if (this.pseudoTerminal) {\n      this.pseudoTerminal.onMessageFromChildren((message: Serializable) => {\n        process.send(message);\n      });\n    }\n    // When the nx process gets a message, it will be sent into the task's process\n    process.on('message', (message: Serializable) => {\n      // this.publisher.publish(message.toString());\n      if (this.pseudoTerminal) {\n        this.pseudoTerminal.sendMessageToChildren(message);\n      }\n      this.processes.forEach((p) => {\n        if ('connected' in p && p.connected) {\n          p.send(message);\n        }\n      });\n    });\n    // Terminate any task processes on exit\n    process.on('exit', () => {\n      this.processes.forEach((p) => {\n        if ('connected' in p ? p.connected : p.isAlive) {\n          p.kill();\n        }\n      });\n    });\n    process.on('SIGINT', () => {\n      this.processes.forEach((p) => {\n        if ('connected' in p ? p.connected : p.isAlive) {\n          p.kill('SIGTERM');\n        }\n      });\n      // we exit here because we don't need to write anything to cache.\n      process.exit(signalToCode('SIGINT'));\n    });\n    process.on('SIGTERM', () => {\n      this.processes.forEach((p) => {\n        if ('connected' in p ? p.connected : p.isAlive) {\n          p.kill('SIGTERM');\n        }\n      });\n      // no exit here because we expect child processes to terminate which\n      // will store results to the cache and will terminate this process\n    });\n    process.on('SIGHUP', () => {\n      this.processes.forEach((p) => {\n        if ('connected' in p ? p.connected : p.isAlive) {\n          p.kill('SIGTERM');\n        }\n      });\n      // no exit here because we expect child processes to terminate which\n      // will store results to the cache and will terminate this process\n    });\n  }"
        },
        {
          "type": "function",
          "name": "%AM1$%AM0$forkProcessForBatch",
          "label": "%AM1$%AM0$forkProcessForBatch",
          "start_line": 1,
          "end_line": 65,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "code = parameter0: unknown\nsignal = parameter1: unknown\nthis = this: @ts_files/208.ts: ForkedProcessTaskRunner\n%0 = this.<@ts_files/208.ts: ForkedProcessTaskRunner.processes>\ninstanceinvoke %0.<@%unk/%unk: .delete()>(p)\nif code === null",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "code = staticinvoke <@%unk/%unk: .signalToCode()>(signal)",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "if code !== 0",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "%1 = new @ts_files/208.ts: %AC$ForkedProcessTaskRunner$%AM1$%AM0$forkProcessForBatch$12\ninstanceinvoke %1.<@ts_files/208.ts: %AC$ForkedProcessTaskRunner$%AM1$%AM0$forkProcessForBatch$12.constructor()>()\nresults = %1\n%2 = batchTaskGraph.<@%unk/%unk: .roots>\n%3 = instanceinvoke %2.<@%unk/%unk: .iterator()>()",
                          "start_line": 1,
                          "end_line": 1,
                          "successors": [
                            {
                              "type": "block",
                              "name": "Block?",
                              "label": "%4 = instanceinvoke %3.<@%unk/%unk: .next()>()\n%5 = %4.<@ES2015/BuiltinClass: IteratorResult.done>\nif %5 == true",
                              "start_line": 1,
                              "end_line": 1,
                              "successors": [
                                {
                                  "type": "block",
                                  "name": "Block?",
                                  "label": "%6 = %4.<@ES2015/BuiltinClass: IteratorResult.value>\nrootTaskId = <unknown>%6\n%7 = new @ts_files/208.ts: %AC$ForkedProcessTaskRunner$%AM1$%AM0$forkProcessForBatch$13\ninstanceinvoke %7.<@ts_files/208.ts: %AC$ForkedProcessTaskRunner$%AM1$%AM0$forkProcessForBatch$13.constructor()>()\nresults.<@ts_files/208.ts: %AC$ForkedProcessTaskRunner$%AM1$%AM0$forkProcessForBatch$12.rootTaskId> = %7",
                                  "start_line": 1,
                                  "end_line": 1,
                                  "successors": [
                                    {
                                      "type": "blockRef",
                                      "label": "(RepeatedBlock)"
                                    }
                                  ]
                                },
                                {
                                  "type": "block",
                                  "name": "Block?",
                                  "label": "%8 = new @%unk/%unk: Error\n%9 = '\"' + executorName\n%10 = %9 + '\" exited unexpectedly with code: '\n%11 = %10 + code\ninstanceinvoke %8.<@%unk/%unk: Error.constructor()>(%11)\nstaticinvoke <@%unk/%unk: .rej()>(%8)",
                                  "start_line": 1,
                                  "end_line": 1,
                                  "successors": [
                                    {
                                      "type": "block",
                                      "name": "Block?",
                                      "label": "return",
                                      "start_line": 45,
                                      "end_line": 508,
                                      "successors": []
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        },
                        {
                          "type": "blockRef",
                          "label": "(RepeatedBlock)"
                        }
                      ]
                    }
                  ]
                },
                {
                  "type": "blockRef",
                  "label": "(RepeatedBlock)"
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "(code, signal) => {\n          this.processes.delete(p);\n          if (code === null) code = signalToCode(signal);\n          if (code !== 0) {\n            const results: BatchResults = {};\n            for (const rootTaskId of batchTaskGraph.roots) {\n              results[rootTaskId] = {\n                success: false,\n                terminalOutput: '',\n              };\n            }\n            rej(\n              new Error(\n                `\"${executorName}\" exited unexpectedly with code: ${code}`\n              )\n            );\n          }\n        }"
        },
        {
          "type": "function",
          "name": "%AM2$%AM0$forkProcessForBatch",
          "label": "%AM2$%AM0$forkProcessForBatch",
          "start_line": 1,
          "end_line": 83,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "message = parameter0: BatchMessage\nthis = this: @ts_files/208.ts: ForkedProcessTaskRunner\n%0 = message.<@%unk/%unk: .type>\n%1 = BatchMessageType.<@%unk/%unk: .CompleteBatchExecution>\nif %0 == %1",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%3 = message.<@%unk/%unk: .results>\nstaticinvoke <@%unk/%unk: .res()>(%3)",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "return",
                      "start_line": 45,
                      "end_line": 508,
                      "successors": []
                    }
                  ]
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%2 = BatchMessageType.<@%unk/%unk: .RunTasks>\nif %0 == %2",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "%4 = process.<@%unk/%unk: .send>\nif %4 != 0",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "instanceinvoke process.<@%unk/%unk: .send()>(message)",
                          "start_line": 1,
                          "end_line": 1,
                          "successors": [
                            {
                              "type": "blockRef",
                              "label": "(RepeatedBlock)"
                            }
                          ]
                        },
                        {
                          "type": "blockRef",
                          "label": "(RepeatedBlock)"
                        }
                      ]
                    },
                    {
                      "type": "blockRef",
                      "label": "(RepeatedBlock)"
                    }
                  ]
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "(message: BatchMessage) => {\n          switch (message.type) {\n            case BatchMessageType.CompleteBatchExecution: {\n              res(message.results);\n              break;\n            }\n            case BatchMessageType.RunTasks: {\n              break;\n            }\n            default: {\n              // Re-emit any non-batch messages from the task process\n              if (process.send) {\n                process.send(message);\n              }\n            }\n          }\n        }"
        },
        {
          "type": "function",
          "name": "%AM0$forkProcessForBatch",
          "label": "%AM0$forkProcessForBatch",
          "start_line": 1,
          "end_line": 45,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "res = parameter0: unknown\nrej = parameter1: unknown\nthis = this: @ts_files/208.ts: ForkedProcessTaskRunner",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%0 = batchTaskGraph.<@%unk/%unk: .tasks>\n%1 = instanceinvoke Object.<@%unk/%unk: .keys()>(%0)\ncount = %1.<@%unk/%unk: .length>\nif count > 1",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "%2 = instanceinvoke output.<@%unk/%unk: .bold()>(count)\n%3 = instanceinvoke output.<@%unk/%unk: .bold()>('tasks')\n%4 = instanceinvoke output.<@%unk/%unk: .bold()>(executorName)\n%5 = 'Running ' + %2\n%6 = %5 + ' '\n%7 = %6 + %3\n%8 = %7 + ' with '\n%9 = %8 + %4\ninstanceinvoke output.<@%unk/%unk: .logSingleLine()>(%9)",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "%14 = new @ts_files/208.ts: %AC$ForkedProcessTaskRunner$%AM0$forkProcessForBatch$11\ninstanceinvoke %14.<@ts_files/208.ts: %AC$ForkedProcessTaskRunner$%AM0$forkProcessForBatch$11.constructor()>()\np = staticinvoke <@%unk/%unk: .fork()>(workerPath, %14)\n%15 = this.<@ts_files/208.ts: ForkedProcessTaskRunner.processes>\ninstanceinvoke %15.<@%unk/%unk: .add()>(p)\ninstanceinvoke p.<@%unk/%unk: .once()>('exit', %AM1$%AM0$forkProcessForBatch)\ninstanceinvoke p.<@%unk/%unk: .on()>('message', %AM2$%AM0$forkProcessForBatch)\n%16 = new @ts_files/208.ts: %AC$ForkedProcessTaskRunner$%AM0$forkProcessForBatch$14\ninstanceinvoke %16.<@ts_files/208.ts: %AC$ForkedProcessTaskRunner$%AM0$forkProcessForBatch$14.constructor()>()\ninstanceinvoke p.<@%unk/%unk: .send()>(%16)",
                          "start_line": 1,
                          "end_line": 1,
                          "successors": [
                            {
                              "type": "block",
                              "name": "Block?",
                              "label": "return",
                              "start_line": 45,
                              "end_line": 508,
                              "successors": []
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "%10 = batchTaskGraph.<@%unk/%unk: .tasks>\n%11 = instanceinvoke Object.<@%unk/%unk: .values()>(%10)\n%12 = %11.<@%unk/%unk: .0>\nargs = staticinvoke <@%unk/%unk: .getPrintableCommandArgsForTask()>(%12)\n%13 = instanceinvoke args.<@%unk/%unk: .join()>(' ')\ninstanceinvoke output.<@%unk/%unk: .logCommand()>(%13)",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "blockRef",
                          "label": "(RepeatedBlock)"
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "block",
              "name": "Block?",
              "label": "e = caughtexception: unknown\nstaticinvoke <@%unk/%unk: .rej()>(e)",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "blockRef",
                  "label": "(RepeatedBlock)"
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "(res, rej) => {\n      try {\n        const count = Object.keys(batchTaskGraph.tasks).length;\n        if (count > 1) {\n          output.logSingleLine(\n            `Running ${output.bold(count)} ${output.bold(\n              'tasks'\n            )} with ${output.bold(executorName)}`\n          );\n        } else {\n          const args = getPrintableCommandArgsForTask(\n            Object.values(batchTaskGraph.tasks)[0]\n          );\n          output.logCommand(args.join(' '));\n        }\n        const p = fork(workerPath, {\n          stdio: ['inherit', 'inherit', 'inherit', 'ipc'],\n          env,\n        });\n        this.processes.add(p);\n        p.once('exit', (code, signal) => {\n          this.processes.delete(p);\n          if (code === null) code = signalToCode(signal);\n          if (code !== 0) {\n            const results: BatchResults = {};\n            for (const rootTaskId of batchTaskGraph.roots) {\n              results[rootTaskId] = {\n                success: false,\n                terminalOutput: '',\n              };\n            }\n            rej(\n              new Error(\n                `\"${executorName}\" exited unexpectedly with code: ${code}`\n              )\n            );\n          }\n        });\n        p.on('message', (message: BatchMessage) => {\n          switch (message.type) {\n            case BatchMessageType.CompleteBatchExecution: {\n              res(message.results);\n              break;\n            }\n            case BatchMessageType.RunTasks: {\n              break;\n            }\n            default: {\n              // Re-emit any non-batch messages from the task process\n              if (process.send) {\n                process.send(message);\n              }\n            }\n          }\n        });\n        // Start the tasks\n        p.send({\n          type: BatchMessageType.RunTasks,\n          executorName,\n          batchTaskGraph,\n          fullTaskGraph,\n        });\n      } catch (e) {\n        rej(e);\n      }\n    }"
        },
        {
          "type": "function",
          "name": "%AM3$forkProcessWithPseudoTerminal",
          "label": "%AM3$forkProcessWithPseudoTerminal",
          "start_line": 1,
          "end_line": 508,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "%closures0 = parameter0: [terminalOutput]\nmsg = parameter1: unknown\nterminalOutput = %closures0.terminalOutput\nthis = this: @ts_files/208.ts: ForkedProcessTaskRunner\nterminalOutput = terminalOutput + msg\nreturn",
              "start_line": 1,
              "end_line": 508,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "(msg) => {\n      terminalOutput += msg;\n    }"
        },
        {
          "type": "function",
          "name": "%AM5$%AM4$forkProcessWithPseudoTerminal",
          "label": "%AM5$%AM4$forkProcessWithPseudoTerminal",
          "start_line": 1,
          "end_line": 221,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "code = parameter0: unknown\nthis = this: @ts_files/208.ts: ForkedProcessTaskRunner\nif code >= 128",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "instanceinvoke process.<@%unk/%unk: .exit()>(code)",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "instanceinvoke this.<@ts_files/208.ts: ForkedProcessTaskRunner.writeTerminalOutput(string, string)>(temporaryOutputPath, terminalOutput)\n%0 = new @ts_files/208.ts: %AC$ForkedProcessTaskRunner$%AM5$%AM4$forkProcessWithPseudoTerminal$21\ninstanceinvoke %0.<@ts_files/208.ts: %AC$ForkedProcessTaskRunner$%AM5$%AM4$forkProcessWithPseudoTerminal$21.constructor()>()\nstaticinvoke <@%unk/%unk: .res()>(%0)\nreturn",
                      "start_line": 1,
                      "end_line": 508,
                      "successors": []
                    }
                  ]
                },
                {
                  "type": "blockRef",
                  "label": "(RepeatedBlock)"
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "(code) => {\n        // If the exit code is greater than 128, it's a special exit code for a signal\n        if (code >= 128) {\n          process.exit(code);\n        }\n        this.writeTerminalOutput(temporaryOutputPath, terminalOutput);\n        res({\n          code,\n          terminalOutput,\n        });\n      }"
        },
        {
          "type": "function",
          "name": "%AM4$forkProcessWithPseudoTerminal",
          "label": "%AM4$forkProcessWithPseudoTerminal",
          "start_line": 1,
          "end_line": 508,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "%closures1 = parameter0: [p]\nres = parameter1: unknown\np = %closures1.p\nthis = this: @ts_files/208.ts: ForkedProcessTaskRunner\ninstanceinvoke p.<@%unk/%unk: .onExit()>(%AM5$%AM4$forkProcessWithPseudoTerminal)\nreturn",
              "start_line": 1,
              "end_line": 508,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "(res) => {\n      p.onExit((code) => {\n        // If the exit code is greater than 128, it's a special exit code for a signal\n        if (code >= 128) {\n          process.exit(code);\n        }\n        this.writeTerminalOutput(temporaryOutputPath, terminalOutput);\n        res({\n          code,\n          terminalOutput,\n        });\n      });\n    }"
        },
        {
          "type": "function",
          "name": "%AM7$%AM6$forkProcessWithPrefixAndNotTTY",
          "label": "%AM7$%AM6$forkProcessWithPrefixAndNotTTY",
          "start_line": 1,
          "end_line": 281,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "message = parameter0: unknown\nthis = this: @ts_files/208.ts: ForkedProcessTaskRunner\n%0 = process.<@%unk/%unk: .send>\nif %0 != 0",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "instanceinvoke process.<@%unk/%unk: .send()>(message)",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "return",
                      "start_line": 45,
                      "end_line": 508,
                      "successors": []
                    }
                  ]
                },
                {
                  "type": "blockRef",
                  "label": "(RepeatedBlock)"
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "(message) => {\n          if (process.send) {\n            process.send(message);\n          }\n        }"
        },
        {
          "type": "function",
          "name": "%AM8$%AM6$forkProcessWithPrefixAndNotTTY",
          "label": "%AM8$%AM6$forkProcessWithPrefixAndNotTTY",
          "start_line": 1,
          "end_line": 508,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "chunk = parameter0: unknown\nthis = this: @ts_files/208.ts: ForkedProcessTaskRunner\n%0 = instanceinvoke chunk.<@%unk/%unk: .toString()>()\ninstanceinvoke outWithErr.<@%unk/%unk: .push()>(%0)\nreturn",
              "start_line": 1,
              "end_line": 508,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "(chunk) => {\n          outWithErr.push(chunk.toString());\n        }"
        },
        {
          "type": "function",
          "name": "%AM9$%AM6$forkProcessWithPrefixAndNotTTY",
          "label": "%AM9$%AM6$forkProcessWithPrefixAndNotTTY",
          "start_line": 1,
          "end_line": 508,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "chunk = parameter0: unknown\nthis = this: @ts_files/208.ts: ForkedProcessTaskRunner\n%0 = instanceinvoke chunk.<@%unk/%unk: .toString()>()\ninstanceinvoke outWithErr.<@%unk/%unk: .push()>(%0)\nreturn",
              "start_line": 1,
              "end_line": 508,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "(chunk) => {\n          outWithErr.push(chunk.toString());\n        }"
        },
        {
          "type": "function",
          "name": "%AM10$%AM6$forkProcessWithPrefixAndNotTTY",
          "label": "%AM10$%AM6$forkProcessWithPrefixAndNotTTY",
          "start_line": 1,
          "end_line": 319,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "code = parameter0: unknown\nsignal = parameter1: unknown\nthis = this: @ts_files/208.ts: ForkedProcessTaskRunner\n%0 = this.<@ts_files/208.ts: ForkedProcessTaskRunner.processes>\ninstanceinvoke %0.<@%unk/%unk: .delete()>(p)\nif code === null",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "code = staticinvoke <@%unk/%unk: .signalToCode()>(signal)",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "terminalOutput = instanceinvoke outWithErr.<@%unk/%unk: .join()>('')\n%1 = !streamOutput\nif %1 != 0",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "instanceinvoke this.<@ts_files/208.ts: ForkedProcessTaskRunner.writeTerminalOutput(string, string)>(temporaryOutputPath, terminalOutput)\n%5 = new @ts_files/208.ts: %AC$ForkedProcessTaskRunner$%AM10$%AM6$forkProcessWithPrefixAndNotTTY$26\ninstanceinvoke %5.<@ts_files/208.ts: %AC$ForkedProcessTaskRunner$%AM10$%AM6$forkProcessWithPrefixAndNotTTY$26.constructor()>()\nstaticinvoke <@%unk/%unk: .res()>(%5)\nreturn",
                          "start_line": 1,
                          "end_line": 508,
                          "successors": []
                        },
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "if code === 0",
                          "start_line": 1,
                          "end_line": 1,
                          "successors": [
                            {
                              "type": "block",
                              "name": "Block?",
                              "label": "%2 = 'success'",
                              "start_line": 1,
                              "end_line": 1,
                              "successors": [
                                {
                                  "type": "block",
                                  "name": "Block?",
                                  "label": "%3 = this.<@ts_files/208.ts: ForkedProcessTaskRunner.options>\n%4 = %3.<@%unk/%unk: .lifeCycle>\ninstanceinvoke %4.<@%unk/%unk: .printTaskTerminalOutput()>(task, %2, terminalOutput)",
                                  "start_line": 1,
                                  "end_line": 1,
                                  "successors": [
                                    {
                                      "type": "blockRef",
                                      "label": "(RepeatedBlock)"
                                    }
                                  ]
                                }
                              ]
                            },
                            {
                              "type": "block",
                              "name": "Block?",
                              "label": "%2 = 'failure'",
                              "start_line": 1,
                              "end_line": 1,
                              "successors": [
                                {
                                  "type": "blockRef",
                                  "label": "(RepeatedBlock)"
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "type": "blockRef",
                  "label": "(RepeatedBlock)"
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "(code, signal) => {\n          this.processes.delete(p);\n          if (code === null) code = signalToCode(signal);\n          // we didn't print any output as we were running the command\n          // print all the collected output|\n          const terminalOutput = outWithErr.join('');\n          if (!streamOutput) {\n            this.options.lifeCycle.printTaskTerminalOutput(\n              task,\n              code === 0 ? 'success' : 'failure',\n              terminalOutput\n            );\n          }\n          this.writeTerminalOutput(temporaryOutputPath, terminalOutput);\n          res({ code, terminalOutput });\n        }"
        },
        {
          "type": "function",
          "name": "%AM6$forkProcessWithPrefixAndNotTTY",
          "label": "%AM6$forkProcessWithPrefixAndNotTTY",
          "start_line": 1,
          "end_line": 269,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "%closures0 = parameter0: [task]\nres = parameter1: unknown\nrej = parameter2: unknown\ntask = %closures0.task\nthis = this: @ts_files/208.ts: ForkedProcessTaskRunner",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "args = staticinvoke <@%unk/%unk: .getPrintableCommandArgsForTask()>(task)\nif streamOutput != 0",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "%0 = instanceinvoke args.<@%unk/%unk: .join()>(' ')\ninstanceinvoke output.<@%unk/%unk: .logCommand()>(%0)",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "%1 = this.<@ts_files/208.ts: ForkedProcessTaskRunner.cliPath>\n%2 = new @ts_files/208.ts: %AC$ForkedProcessTaskRunner$%AM6$forkProcessWithPrefixAndNotTTY$24\ninstanceinvoke %2.<@ts_files/208.ts: %AC$ForkedProcessTaskRunner$%AM6$forkProcessWithPrefixAndNotTTY$24.constructor()>()\np = staticinvoke <@%unk/%unk: .fork()>(%1, %2)\n%3 = this.<@ts_files/208.ts: ForkedProcessTaskRunner.processes>\ninstanceinvoke %3.<@%unk/%unk: .add()>(p)\ninstanceinvoke p.<@%unk/%unk: .on()>('message', %AM7$%AM6$forkProcessWithPrefixAndNotTTY)\n%4 = new @ts_files/208.ts: %AC$ForkedProcessTaskRunner$%AM6$forkProcessWithPrefixAndNotTTY$25\ninstanceinvoke %4.<@ts_files/208.ts: %AC$ForkedProcessTaskRunner$%AM6$forkProcessWithPrefixAndNotTTY$25.constructor()>()\ninstanceinvoke p.<@%unk/%unk: .send()>(%4)\nif streamOutput != 0",
                          "start_line": 1,
                          "end_line": 1,
                          "successors": [
                            {
                              "type": "block",
                              "name": "Block?",
                              "label": "%5 = process.<@%unk/%unk: .env>\n%6 = %5.<@%unk/%unk: .NX_PREFIX_OUTPUT>\nif %6 === 'true'",
                              "start_line": 1,
                              "end_line": 1,
                              "successors": [
                                {
                                  "type": "block",
                                  "name": "Block?",
                                  "label": "%7 = task.<@%unk/%unk: .target>\n%8 = %7.<@%unk/%unk: .project>\ncolor = staticinvoke <@ts_files/208.ts: %dflt.getColor(string)>(%8)\n%9 = task.<@%unk/%unk: .target>\n%10 = %9.<@%unk/%unk: .project>\n%11 = %10 + ':'\nprefixText = %11\n%12 = process.<@%unk/%unk: .stdout>\n%13 = instanceinvoke color.<@%unk/%unk: .bold()>(prefixText)\n%14 = staticinvoke <@ts_files/208.ts: %dflt.addPrefixTransformer(string)>(%13)\n%15 = instanceinvoke color.<@%unk/%unk: .bold()>(prefixText)\n%16 = %15 + ' '\n%17 = staticinvoke <@ts_files/208.ts: %dflt.logClearLineToPrefixTransformer(string)>(%16)\n%18 = p.<@%unk/%unk: .stdout>\n%19 = instanceinvoke %18.<@%unk/%unk: .pipe()>(%17)\n%20 = instanceinvoke %19.<@%unk/%unk: .pipe()>(%14)\ninstanceinvoke %20.<@%unk/%unk: .pipe()>(%12)\n%21 = process.<@%unk/%unk: .stderr>\n%22 = staticinvoke <@%unk/%unk: .color()>(prefixText)\n%23 = staticinvoke <@ts_files/208.ts: %dflt.addPrefixTransformer(string)>(%22)\n%24 = staticinvoke <@%unk/%unk: .color()>(prefixText)\n%25 = %24 + ' '\n%26 = staticinvoke <@ts_files/208.ts: %dflt.logClearLineToPrefixTransformer(string)>(%25)\n%27 = p.<@%unk/%unk: .stderr>\n%28 = instanceinvoke %27.<@%unk/%unk: .pipe()>(%26)\n%29 = instanceinvoke %28.<@%unk/%unk: .pipe()>(%23)\ninstanceinvoke %29.<@%unk/%unk: .pipe()>(%21)",
                                  "start_line": 1,
                                  "end_line": 1,
                                  "successors": [
                                    {
                                      "type": "block",
                                      "name": "Block?",
                                      "label": "%38 = newarray (any)[0]\noutWithErr = %38\n%39 = p.<@%unk/%unk: .stdout>\ninstanceinvoke %39.<@%unk/%unk: .on()>('data', %AM8$%AM6$forkProcessWithPrefixAndNotTTY)\n%40 = p.<@%unk/%unk: .stderr>\ninstanceinvoke %40.<@%unk/%unk: .on()>('data', %AM9$%AM6$forkProcessWithPrefixAndNotTTY)\ninstanceinvoke p.<@%unk/%unk: .on()>('exit', %AM10$%AM6$forkProcessWithPrefixAndNotTTY)",
                                      "start_line": 1,
                                      "end_line": 1,
                                      "successors": [
                                        {
                                          "type": "block",
                                          "name": "Block?",
                                          "label": "return",
                                          "start_line": 45,
                                          "end_line": 508,
                                          "successors": []
                                        }
                                      ]
                                    }
                                  ]
                                },
                                {
                                  "type": "block",
                                  "name": "Block?",
                                  "label": "%30 = process.<@%unk/%unk: .stdout>\n%31 = staticinvoke <@ts_files/208.ts: %dflt.addPrefixTransformer(string)>()\n%32 = p.<@%unk/%unk: .stdout>\n%33 = instanceinvoke %32.<@%unk/%unk: .pipe()>(%31)\ninstanceinvoke %33.<@%unk/%unk: .pipe()>(%30)\n%34 = process.<@%unk/%unk: .stderr>\n%35 = staticinvoke <@ts_files/208.ts: %dflt.addPrefixTransformer(string)>()\n%36 = p.<@%unk/%unk: .stderr>\n%37 = instanceinvoke %36.<@%unk/%unk: .pipe()>(%35)\ninstanceinvoke %37.<@%unk/%unk: .pipe()>(%34)",
                                  "start_line": 1,
                                  "end_line": 1,
                                  "successors": [
                                    {
                                      "type": "blockRef",
                                      "label": "(RepeatedBlock)"
                                    }
                                  ]
                                }
                              ]
                            },
                            {
                              "type": "blockRef",
                              "label": "(RepeatedBlock)"
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "type": "blockRef",
                      "label": "(RepeatedBlock)"
                    }
                  ]
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "block",
              "name": "Block?",
              "label": "e = caughtexception: unknown\ninstanceinvoke console.<@%unk/%unk: .error()>(e)\nstaticinvoke <@%unk/%unk: .rej()>(e)",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "blockRef",
                  "label": "(RepeatedBlock)"
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "(res, rej) => {\n      try {\n        const args = getPrintableCommandArgsForTask(task);\n        if (streamOutput) {\n          output.logCommand(args.join(' '));\n        }\n        const p = fork(this.cliPath, {\n          stdio: ['inherit', 'pipe', 'pipe', 'ipc'],\n          env,\n        });\n        this.processes.add(p);\n        // Re-emit any messages from the task process\n        p.on('message', (message) => {\n          if (process.send) {\n            process.send(message);\n          }\n        });\n        // Send message to run the executor\n        p.send({\n          targetDescription: task.target,\n          overrides: task.overrides,\n          taskGraph,\n          isVerbose: this.verbose,\n        });\n        if (streamOutput) {\n          if (process.env.NX_PREFIX_OUTPUT === 'true') {\n            const color = getColor(task.target.project);\n            const prefixText = `${task.target.project}:`;\n            p.stdout\n              .pipe(\n                logClearLineToPrefixTransformer(color.bold(prefixText) + ' ')\n              )\n              .pipe(addPrefixTransformer(color.bold(prefixText)))\n              .pipe(process.stdout);\n            p.stderr\n              .pipe(logClearLineToPrefixTransformer(color(prefixText) + ' '))\n              .pipe(addPrefixTransformer(color(prefixText)))\n              .pipe(process.stderr);\n          } else {\n            p.stdout.pipe(addPrefixTransformer()).pipe(process.stdout);\n            p.stderr.pipe(addPrefixTransformer()).pipe(process.stderr);\n          }\n        }\n        let outWithErr = [];\n        p.stdout.on('data', (chunk) => {\n          outWithErr.push(chunk.toString());\n        });\n        p.stderr.on('data', (chunk) => {\n          outWithErr.push(chunk.toString());\n        });\n        p.on('exit', (code, signal) => {\n          this.processes.delete(p);\n          if (code === null) code = signalToCode(signal);\n          // we didn't print any output as we were running the command\n          // print all the collected output|\n          const terminalOutput = outWithErr.join('');\n          if (!streamOutput) {\n            this.options.lifeCycle.printTaskTerminalOutput(\n              task,\n              code === 0 ? 'success' : 'failure',\n              terminalOutput\n            );\n          }\n          this.writeTerminalOutput(temporaryOutputPath, terminalOutput);\n          res({ code, terminalOutput });\n        });\n      } catch (e) {\n        console.error(e);\n        rej(e);\n      }\n    }"
        },
        {
          "type": "function",
          "name": "%AM12$%AM11$forkProcessDirectOutputCapture",
          "label": "%AM12$%AM11$forkProcessDirectOutputCapture",
          "start_line": 1,
          "end_line": 367,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "message = parameter0: unknown\nthis = this: @ts_files/208.ts: ForkedProcessTaskRunner\n%0 = process.<@%unk/%unk: .send>\nif %0 != 0",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "instanceinvoke process.<@%unk/%unk: .send()>(message)",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "return",
                      "start_line": 45,
                      "end_line": 508,
                      "successors": []
                    }
                  ]
                },
                {
                  "type": "blockRef",
                  "label": "(RepeatedBlock)"
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "(message) => {\n          if (process.send) {\n            process.send(message);\n          }\n        }"
        },
        {
          "type": "function",
          "name": "%AM13$%AM11$forkProcessDirectOutputCapture",
          "label": "%AM13$%AM11$forkProcessDirectOutputCapture",
          "start_line": 1,
          "end_line": 379,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "code = parameter0: unknown\nsignal = parameter1: unknown\nthis = this: @ts_files/208.ts: ForkedProcessTaskRunner\nif code === null",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "code = staticinvoke <@%unk/%unk: .signalToCode()>(signal)",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "terminalOutput = ''",
                      "start_line": 216,
                      "end_line": 383,
                      "successors": [
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "terminalOutput = instanceinvoke this.<@ts_files/208.ts: ForkedProcessTaskRunner.readTerminalOutput(string)>(temporaryOutputPath)\n%0 = !streamOutput\nif %0 != 0",
                          "start_line": 1,
                          "end_line": 1,
                          "successors": [
                            {
                              "type": "block",
                              "name": "Block?",
                              "label": "",
                              "start_line": 1,
                              "end_line": 1,
                              "successors": [
                                {
                                  "type": "block",
                                  "name": "Block?",
                                  "label": "%4 = new @ts_files/208.ts: %AC$ForkedProcessTaskRunner$%AM13$%AM11$forkProcessDirectOutputCapture$30\ninstanceinvoke %4.<@ts_files/208.ts: %AC$ForkedProcessTaskRunner$%AM13$%AM11$forkProcessDirectOutputCapture$30.constructor()>()\nstaticinvoke <@%unk/%unk: .res()>(%4)\nreturn",
                                  "start_line": 1,
                                  "end_line": 508,
                                  "successors": []
                                }
                              ]
                            },
                            {
                              "type": "block",
                              "name": "Block?",
                              "label": "if code === 0",
                              "start_line": 1,
                              "end_line": 1,
                              "successors": [
                                {
                                  "type": "block",
                                  "name": "Block?",
                                  "label": "%1 = 'success'",
                                  "start_line": 1,
                                  "end_line": 1,
                                  "successors": [
                                    {
                                      "type": "block",
                                      "name": "Block?",
                                      "label": "%2 = this.<@ts_files/208.ts: ForkedProcessTaskRunner.options>\n%3 = %2.<@%unk/%unk: .lifeCycle>\ninstanceinvoke %3.<@%unk/%unk: .printTaskTerminalOutput()>(task, %1, terminalOutput)",
                                      "start_line": 1,
                                      "end_line": 1,
                                      "successors": [
                                        {
                                          "type": "blockRef",
                                          "label": "(RepeatedBlock)"
                                        }
                                      ]
                                    }
                                  ]
                                },
                                {
                                  "type": "block",
                                  "name": "Block?",
                                  "label": "%1 = 'failure'",
                                  "start_line": 1,
                                  "end_line": 1,
                                  "successors": [
                                    {
                                      "type": "blockRef",
                                      "label": "(RepeatedBlock)"
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "type": "blockRef",
                  "label": "(RepeatedBlock)"
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "block",
              "name": "Block?",
              "label": "e = caughtexception: unknown\ninstanceinvoke console.<@%unk/%unk: .log()>(stripIndents`\n              Unable to print terminal output for Task \"${task.id}\".\n              Task failed with Exit Code ${code} and Signal \"${signal}\".\n              Received error message:\n              ${e.message}\n            `)",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "blockRef",
                  "label": "(RepeatedBlock)"
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "(code, signal) => {\n          if (code === null) code = signalToCode(signal);\n          // we didn't print any output as we were running the command\n          // print all the collected output\n          let terminalOutput = '';\n          try {\n            terminalOutput = this.readTerminalOutput(temporaryOutputPath);\n            if (!streamOutput) {\n              this.options.lifeCycle.printTaskTerminalOutput(\n                task,\n                code === 0 ? 'success' : 'failure',\n                terminalOutput\n              );\n            }\n          } catch (e) {\n            console.log(stripIndents`\n              Unable to print terminal output for Task \"${task.id}\".\n              Task failed with Exit Code ${code} and Signal \"${signal}\".\n              Received error message:\n              ${e.message}\n            `);\n          }\n          res({\n            code,\n            terminalOutput,\n          });\n        }"
        },
        {
          "type": "function",
          "name": "%AM11$forkProcessDirectOutputCapture",
          "label": "%AM11$forkProcessDirectOutputCapture",
          "start_line": 1,
          "end_line": 355,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "%closures0 = parameter0: [task]\nres = parameter1: unknown\nrej = parameter2: unknown\ntask = %closures0.task\nthis = this: @ts_files/208.ts: ForkedProcessTaskRunner",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "args = staticinvoke <@%unk/%unk: .getPrintableCommandArgsForTask()>(task)\nif streamOutput != 0",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "%0 = instanceinvoke args.<@%unk/%unk: .join()>(' ')\ninstanceinvoke output.<@%unk/%unk: .logCommand()>(%0)",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "%1 = this.<@ts_files/208.ts: ForkedProcessTaskRunner.cliPath>\n%2 = new @ts_files/208.ts: %AC$ForkedProcessTaskRunner$%AM11$forkProcessDirectOutputCapture$28\ninstanceinvoke %2.<@ts_files/208.ts: %AC$ForkedProcessTaskRunner$%AM11$forkProcessDirectOutputCapture$28.constructor()>()\np = staticinvoke <@%unk/%unk: .fork()>(%1, %2)\n%3 = this.<@ts_files/208.ts: ForkedProcessTaskRunner.processes>\ninstanceinvoke %3.<@%unk/%unk: .add()>(p)\ninstanceinvoke p.<@%unk/%unk: .on()>('message', %AM12$%AM11$forkProcessDirectOutputCapture)\n%4 = new @ts_files/208.ts: %AC$ForkedProcessTaskRunner$%AM11$forkProcessDirectOutputCapture$29\ninstanceinvoke %4.<@ts_files/208.ts: %AC$ForkedProcessTaskRunner$%AM11$forkProcessDirectOutputCapture$29.constructor()>()\ninstanceinvoke p.<@%unk/%unk: .send()>(%4)\ninstanceinvoke p.<@%unk/%unk: .on()>('exit', %AM13$%AM11$forkProcessDirectOutputCapture)",
                          "start_line": 1,
                          "end_line": 1,
                          "successors": [
                            {
                              "type": "block",
                              "name": "Block?",
                              "label": "return",
                              "start_line": 45,
                              "end_line": 508,
                              "successors": []
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "type": "blockRef",
                      "label": "(RepeatedBlock)"
                    }
                  ]
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "block",
              "name": "Block?",
              "label": "e = caughtexception: unknown\ninstanceinvoke console.<@%unk/%unk: .error()>(e)\nstaticinvoke <@%unk/%unk: .rej()>(e)",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "blockRef",
                  "label": "(RepeatedBlock)"
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "(res, rej) => {\n      try {\n        const args = getPrintableCommandArgsForTask(task);\n        if (streamOutput) {\n          output.logCommand(args.join(' '));\n        }\n        const p = fork(this.cliPath, {\n          stdio: ['inherit', 'inherit', 'inherit', 'ipc'],\n          env,\n        });\n        this.processes.add(p);\n        // Re-emit any messages from the task process\n        p.on('message', (message) => {\n          if (process.send) {\n            process.send(message);\n          }\n        });\n        // Send message to run the executor\n        p.send({\n          targetDescription: task.target,\n          overrides: task.overrides,\n          taskGraph,\n          isVerbose: this.verbose,\n        });\n        p.on('exit', (code, signal) => {\n          if (code === null) code = signalToCode(signal);\n          // we didn't print any output as we were running the command\n          // print all the collected output\n          let terminalOutput = '';\n          try {\n            terminalOutput = this.readTerminalOutput(temporaryOutputPath);\n            if (!streamOutput) {\n              this.options.lifeCycle.printTaskTerminalOutput(\n                task,\n                code === 0 ? 'success' : 'failure',\n                terminalOutput\n              );\n            }\n          } catch (e) {\n            console.log(stripIndents`\n              Unable to print terminal output for Task \"${task.id}\".\n              Task failed with Exit Code ${code} and Signal \"${signal}\".\n              Received error message:\n              ${e.message}\n            `);\n          }\n          res({\n            code,\n            terminalOutput,\n          });\n        });\n      } catch (e) {\n        console.error(e);\n        rej(e);\n      }\n    }"
        },
        {
          "type": "function",
          "name": "%AM14$setupProcessEventListeners",
          "label": "%AM14$setupProcessEventListeners",
          "start_line": 1,
          "end_line": 508,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "message = parameter0: Serializable\nthis = this: @ts_files/208.ts: ForkedProcessTaskRunner\ninstanceinvoke process.<@%unk/%unk: .send()>(message)\nreturn",
              "start_line": 1,
              "end_line": 508,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "(message: Serializable) => {\n        process.send(message);\n      }"
        },
        {
          "type": "function",
          "name": "%AM16$%AM15$setupProcessEventListeners",
          "label": "%AM16$%AM15$setupProcessEventListeners",
          "start_line": 1,
          "end_line": 430,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "p = parameter0: unknown\nthis = this: @ts_files/208.ts: ForkedProcessTaskRunner\n%0 = p.<@%unk/%unk: .connected>\n%1 = undefined && %0\nif %1 != false",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "instanceinvoke p.<@%unk/%unk: .send()>(message)",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "return",
                      "start_line": 45,
                      "end_line": 508,
                      "successors": []
                    }
                  ]
                },
                {
                  "type": "blockRef",
                  "label": "(RepeatedBlock)"
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "(p) => {\n        if ('connected' in p && p.connected) {\n          p.send(message);\n        }\n      }"
        },
        {
          "type": "function",
          "name": "%AM15$setupProcessEventListeners",
          "label": "%AM15$setupProcessEventListeners",
          "start_line": 1,
          "end_line": 425,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "message = parameter0: Serializable\nthis = this: @ts_files/208.ts: ForkedProcessTaskRunner\n%0 = this.<@ts_files/208.ts: ForkedProcessTaskRunner.pseudoTerminal>\nif %0 != 0",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%1 = this.<@ts_files/208.ts: ForkedProcessTaskRunner.pseudoTerminal>\ninstanceinvoke %1.<@%unk/%unk: .sendMessageToChildren()>(message)",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "%2 = this.<@ts_files/208.ts: ForkedProcessTaskRunner.processes>\ninstanceinvoke %2.<@%unk/%unk: .forEach()>(%AM16$%AM15$setupProcessEventListeners)\nreturn",
                      "start_line": 1,
                      "end_line": 508,
                      "successors": []
                    }
                  ]
                },
                {
                  "type": "blockRef",
                  "label": "(RepeatedBlock)"
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "(message: Serializable) => {\n      // this.publisher.publish(message.toString());\n      if (this.pseudoTerminal) {\n        this.pseudoTerminal.sendMessageToChildren(message);\n      }\n      this.processes.forEach((p) => {\n        if ('connected' in p && p.connected) {\n          p.send(message);\n        }\n      });\n    }"
        },
        {
          "type": "function",
          "name": "%AM18$%AM17$setupProcessEventListeners",
          "label": "%AM18$%AM17$setupProcessEventListeners",
          "start_line": 1,
          "end_line": 438,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "instanceinvoke p.<@%unk/%unk: .kill()>()",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "return",
                  "start_line": 45,
                  "end_line": 508,
                  "successors": []
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "block",
              "name": "Block?",
              "label": "p = parameter0: unknown\nthis = this: @ts_files/208.ts: ForkedProcessTaskRunner\nif undefined != 0",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%0 = p.<@%unk/%unk: .connected>",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "if %0 != 0",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "blockRef",
                          "label": "(RepeatedBlock)"
                        },
                        {
                          "type": "blockRef",
                          "label": "(RepeatedBlock)"
                        }
                      ]
                    }
                  ]
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%0 = p.<@%unk/%unk: .isAlive>",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "blockRef",
                      "label": "(RepeatedBlock)"
                    }
                  ]
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "(p) => {\n        if ('connected' in p ? p.connected : p.isAlive) {\n          p.kill();\n        }\n      }"
        },
        {
          "type": "function",
          "name": "%AM17$setupProcessEventListeners",
          "label": "%AM17$setupProcessEventListeners",
          "start_line": 1,
          "end_line": 508,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/208.ts: ForkedProcessTaskRunner\n%0 = this.<@ts_files/208.ts: ForkedProcessTaskRunner.processes>\ninstanceinvoke %0.<@%unk/%unk: .forEach()>(%AM18$%AM17$setupProcessEventListeners)\nreturn",
              "start_line": 1,
              "end_line": 508,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      this.processes.forEach((p) => {\n        if ('connected' in p ? p.connected : p.isAlive) {\n          p.kill();\n        }\n      });\n    }"
        },
        {
          "type": "function",
          "name": "%AM20$%AM19$setupProcessEventListeners",
          "label": "%AM20$%AM19$setupProcessEventListeners",
          "start_line": 1,
          "end_line": 445,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "instanceinvoke p.<@%unk/%unk: .kill()>('SIGTERM')",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "return",
                  "start_line": 45,
                  "end_line": 508,
                  "successors": []
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "block",
              "name": "Block?",
              "label": "p = parameter0: unknown\nthis = this: @ts_files/208.ts: ForkedProcessTaskRunner\nif undefined != 0",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%0 = p.<@%unk/%unk: .connected>",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "if %0 != 0",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "blockRef",
                          "label": "(RepeatedBlock)"
                        },
                        {
                          "type": "blockRef",
                          "label": "(RepeatedBlock)"
                        }
                      ]
                    }
                  ]
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%0 = p.<@%unk/%unk: .isAlive>",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "blockRef",
                      "label": "(RepeatedBlock)"
                    }
                  ]
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "(p) => {\n        if ('connected' in p ? p.connected : p.isAlive) {\n          p.kill('SIGTERM');\n        }\n      }"
        },
        {
          "type": "function",
          "name": "%AM19$setupProcessEventListeners",
          "label": "%AM19$setupProcessEventListeners",
          "start_line": 1,
          "end_line": 508,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/208.ts: ForkedProcessTaskRunner\n%0 = this.<@ts_files/208.ts: ForkedProcessTaskRunner.processes>\ninstanceinvoke %0.<@%unk/%unk: .forEach()>(%AM20$%AM19$setupProcessEventListeners)\n%1 = staticinvoke <@%unk/%unk: .signalToCode()>('SIGINT')\ninstanceinvoke process.<@%unk/%unk: .exit()>(%1)\nreturn",
              "start_line": 1,
              "end_line": 508,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      this.processes.forEach((p) => {\n        if ('connected' in p ? p.connected : p.isAlive) {\n          p.kill('SIGTERM');\n        }\n      });\n      // we exit here because we don't need to write anything to cache.\n      process.exit(signalToCode('SIGINT'));\n    }"
        },
        {
          "type": "function",
          "name": "%AM22$%AM21$setupProcessEventListeners",
          "label": "%AM22$%AM21$setupProcessEventListeners",
          "start_line": 1,
          "end_line": 454,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "instanceinvoke p.<@%unk/%unk: .kill()>('SIGTERM')",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "return",
                  "start_line": 45,
                  "end_line": 508,
                  "successors": []
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "block",
              "name": "Block?",
              "label": "p = parameter0: unknown\nthis = this: @ts_files/208.ts: ForkedProcessTaskRunner\nif undefined != 0",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%0 = p.<@%unk/%unk: .connected>",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "if %0 != 0",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "blockRef",
                          "label": "(RepeatedBlock)"
                        },
                        {
                          "type": "blockRef",
                          "label": "(RepeatedBlock)"
                        }
                      ]
                    }
                  ]
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%0 = p.<@%unk/%unk: .isAlive>",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "blockRef",
                      "label": "(RepeatedBlock)"
                    }
                  ]
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "(p) => {\n        if ('connected' in p ? p.connected : p.isAlive) {\n          p.kill('SIGTERM');\n        }\n      }"
        },
        {
          "type": "function",
          "name": "%AM21$setupProcessEventListeners",
          "label": "%AM21$setupProcessEventListeners",
          "start_line": 1,
          "end_line": 508,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/208.ts: ForkedProcessTaskRunner\n%0 = this.<@ts_files/208.ts: ForkedProcessTaskRunner.processes>\ninstanceinvoke %0.<@%unk/%unk: .forEach()>(%AM22$%AM21$setupProcessEventListeners)\nreturn",
              "start_line": 1,
              "end_line": 508,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      this.processes.forEach((p) => {\n        if ('connected' in p ? p.connected : p.isAlive) {\n          p.kill('SIGTERM');\n        }\n      });\n      // no exit here because we expect child processes to terminate which\n      // will store results to the cache and will terminate this process\n    }"
        },
        {
          "type": "function",
          "name": "%AM24$%AM23$setupProcessEventListeners",
          "label": "%AM24$%AM23$setupProcessEventListeners",
          "start_line": 1,
          "end_line": 463,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "instanceinvoke p.<@%unk/%unk: .kill()>('SIGTERM')",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "return",
                  "start_line": 45,
                  "end_line": 508,
                  "successors": []
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "block",
              "name": "Block?",
              "label": "p = parameter0: unknown\nthis = this: @ts_files/208.ts: ForkedProcessTaskRunner\nif undefined != 0",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%0 = p.<@%unk/%unk: .connected>",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "if %0 != 0",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "blockRef",
                          "label": "(RepeatedBlock)"
                        },
                        {
                          "type": "blockRef",
                          "label": "(RepeatedBlock)"
                        }
                      ]
                    }
                  ]
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%0 = p.<@%unk/%unk: .isAlive>",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "blockRef",
                      "label": "(RepeatedBlock)"
                    }
                  ]
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "(p) => {\n        if ('connected' in p ? p.connected : p.isAlive) {\n          p.kill('SIGTERM');\n        }\n      }"
        },
        {
          "type": "function",
          "name": "%AM23$setupProcessEventListeners",
          "label": "%AM23$setupProcessEventListeners",
          "start_line": 1,
          "end_line": 508,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/208.ts: ForkedProcessTaskRunner\n%0 = this.<@ts_files/208.ts: ForkedProcessTaskRunner.processes>\ninstanceinvoke %0.<@%unk/%unk: .forEach()>(%AM24$%AM23$setupProcessEventListeners)\nreturn",
              "start_line": 1,
              "end_line": 508,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "() => {\n      this.processes.forEach((p) => {\n        if ('connected' in p ? p.connected : p.isAlive) {\n          p.kill('SIGTERM');\n        }\n      });\n      // no exit here because we expect child processes to terminate which\n      // will store results to the cache and will terminate this process\n    }"
        }
      ],
      "classes": [],
      "blocks": [],
      "simplified_code": "export class ForkedProcessTaskRunner {\n  cliPath = getCliPath();\n  private readonly verbose = process.env.NX_VERBOSE_LOGGING === 'true';\n  private processes = new Set<ChildProcess | PseudoTtyProcess>();\n  private pseudoTerminal: PseudoTerminal | null = PseudoTerminal.isSupported()\n    ? getPseudoTerminal()\n    : null;\n  constructor(private readonly options: DefaultTasksRunnerOptions) {}\n  async init() {\n    if (this.pseudoTerminal) {\n      await this.pseudoTerminal.init();\n    }\n    this.setupProcessEventListeners();\n  }\n  // TODO: vsavkin delegate terminal output printing\n  public forkProcessForBatch(\n    { executorName, taskGraph: batchTaskGraph }: Batch,\n    fullTaskGraph: TaskGraph,\n    env: NodeJS.ProcessEnv\n  ) {\n    return new Promise<BatchResults>((res, rej) => {\n      try {\n        const count = Object.keys(batchTaskGraph.tasks).length;\n        if (count > 1) {\n          output.logSingleLine(\n            `Running ${output.bold(count)} ${output.bold(\n              'tasks'\n            )} with ${output.bold(executorName)}`\n          );\n        } else {\n          const args = getPrintableCommandArgsForTask(\n            Object.values(batchTaskGraph.tasks)[0]\n          );\n          output.logCommand(args.join(' '));\n        }\n        const p = fork(workerPath, {\n          stdio: ['inherit', 'inherit', 'inherit', 'ipc'],\n          env,\n        });\n        this.processes.add(p);\n        p.once('exit', (code, signal) => {\n          this.processes.delete(p);\n          if (code === null) code = signalToCode(signal);\n          if (code !== 0) {\n            const results: BatchResults = {};\n            for (const rootTaskId of batchTaskGraph.roots) {\n              results[rootTaskId] = {\n                success: false,\n                terminalOutput: '',\n              };\n            }\n            rej(\n              new Error(\n                `\"${executorName}\" exited unexpectedly with code: ${code}`\n              )\n            );\n          }\n        });\n        p.on('message', (message: BatchMessage) => {\n          switch (message.type) {\n            case BatchMessageType.CompleteBatchExecution: {\n              res(message.results);\n              break;\n            }\n            case BatchMessageType.RunTasks: {\n              break;\n            }\n            default: {\n              // Re-emit any non-batch messages from the task process\n              if (process.send) {\n                process.send(message);\n              }\n            }\n          }\n        });\n        // Start the tasks\n        p.send({\n          type: BatchMessageType.RunTasks,\n          executorName,\n          batchTaskGraph,\n          fullTaskGraph,\n        });\n      } catch (e) {\n        rej(e);\n      }\n    });\n  }\n  public async forkProcessLegacy(\n    task: Task,\n    {\n      temporaryOutputPath,\n      streamOutput,\n      pipeOutput,\n      taskGraph,\n      env,\n    }: {\n      temporaryOutputPath: string;\n      streamOutput: boolean;\n      pipeOutput: boolean;\n      taskGraph: TaskGraph;\n      env: NodeJS.ProcessEnv;\n    }\n  ): Promise<{ code: number; terminalOutput: string }> {\n    return pipeOutput\n      ? await this.forkProcessPipeOutputCapture(task, {\n          temporaryOutputPath,\n          streamOutput,\n          taskGraph,\n          env,\n        })\n      : await this.forkProcessDirectOutputCapture(task, {\n          temporaryOutputPath,\n          streamOutput,\n          taskGraph,\n          env,\n        });\n  }\n  public async forkProcess(\n    task: Task,\n    {\n      temporaryOutputPath,\n      streamOutput,\n      taskGraph,\n      env,\n      disablePseudoTerminal,\n    }: {\n      temporaryOutputPath: string;\n      streamOutput: boolean;\n      pipeOutput: boolean;\n      taskGraph: TaskGraph;\n      env: NodeJS.ProcessEnv;\n      disablePseudoTerminal: boolean;\n    }\n  ): Promise<{ code: number; terminalOutput: string }> {\n    const shouldPrefix =\n      streamOutput && process.env.NX_PREFIX_OUTPUT === 'true';\n    // streamOutput would be false if we are running multiple targets\n    // there's no point in running the commands in a pty if we are not streaming the output\n    if (\n      !this.pseudoTerminal ||\n      disablePseudoTerminal ||\n      !streamOutput ||\n      shouldPrefix\n    ) {\n      return this.forkProcessWithPrefixAndNotTTY(task, {\n        temporaryOutputPath,\n        streamOutput,\n        taskGraph,\n        env,\n      });\n    } else {\n      return this.forkProcessWithPseudoTerminal(task, {\n        temporaryOutputPath,\n        streamOutput,\n        taskGraph,\n        env,\n      });\n    }\n  }\n  private async forkProcessWithPseudoTerminal(\n    task: Task,\n    {\n      temporaryOutputPath,\n      streamOutput,\n      taskGraph,\n      env,\n    }: {\n      temporaryOutputPath: string;\n      streamOutput: boolean;\n      taskGraph: TaskGraph;\n      env: NodeJS.ProcessEnv;\n    }\n  ): Promise<{ code: number; terminalOutput: string }> {\n    const args = getPrintableCommandArgsForTask(task);\n    if (streamOutput) {\n      output.logCommand(args.join(' '));\n    }\n    const childId = task.id;\n    const p = await this.pseudoTerminal.fork(childId, forkScript, {\n      cwd: process.cwd(),\n      execArgv: process.execArgv,\n      jsEnv: env,\n      quiet: !streamOutput,\n    });\n    p.send({\n      targetDescription: task.target,\n      overrides: task.overrides,\n      taskGraph,\n      isVerbose: this.verbose,\n    });\n    this.processes.add(p);\n    let terminalOutput = '';\n    p.onOutput((msg) => {\n      terminalOutput += msg;\n    });\n    return new Promise((res) => {\n      p.onExit((code) => {\n        // If the exit code is greater than 128, it's a special exit code for a signal\n        if (code >= 128) {\n          process.exit(code);\n        }\n        this.writeTerminalOutput(temporaryOutputPath, terminalOutput);\n        res({\n          code,\n          terminalOutput,\n        });\n      });\n    });\n  }\n  private forkProcessPipeOutputCapture(\n    task: Task,\n    {\n      streamOutput,\n      temporaryOutputPath,\n      taskGraph,\n      env,\n    }: {\n      streamOutput: boolean;\n      temporaryOutputPath: string;\n      taskGraph: TaskGraph;\n      env: NodeJS.ProcessEnv;\n    }\n  ) {\n    return this.forkProcessWithPrefixAndNotTTY(task, {\n      streamOutput,\n      temporaryOutputPath,\n      taskGraph,\n      env,\n    });\n  }\n  private forkProcessWithPrefixAndNotTTY(\n    task: Task,\n    {\n      streamOutput,\n      temporaryOutputPath,\n      taskGraph,\n      env,\n    }: {\n      streamOutput: boolean;\n      temporaryOutputPath: string;\n      taskGraph: TaskGraph;\n      env: NodeJS.ProcessEnv;\n    }\n  ) {\n    return new Promise<{ code: number; terminalOutput: string }>((res, rej) => {\n      try {\n        const args = getPrintableCommandArgsForTask(task);\n        if (streamOutput) {\n          output.logCommand(args.join(' '));\n        }\n        const p = fork(this.cliPath, {\n          stdio: ['inherit', 'pipe', 'pipe', 'ipc'],\n          env,\n        });\n        this.processes.add(p);\n        // Re-emit any messages from the task process\n        p.on('message', (message) => {\n          if (process.send) {\n            process.send(message);\n          }\n        });\n        // Send message to run the executor\n        p.send({\n          targetDescription: task.target,\n          overrides: task.overrides,\n          taskGraph,\n          isVerbose: this.verbose,\n        });\n        if (streamOutput) {\n          if (process.env.NX_PREFIX_OUTPUT === 'true') {\n            const color = getColor(task.target.project);\n            const prefixText = `${task.target.project}:`;\n            p.stdout\n              .pipe(\n                logClearLineToPrefixTransformer(color.bold(prefixText) + ' ')\n              )\n              .pipe(addPrefixTransformer(color.bold(prefixText)))\n              .pipe(process.stdout);\n            p.stderr\n              .pipe(logClearLineToPrefixTransformer(color(prefixText) + ' '))\n              .pipe(addPrefixTransformer(color(prefixText)))\n              .pipe(process.stderr);\n          } else {\n            p.stdout.pipe(addPrefixTransformer()).pipe(process.stdout);\n            p.stderr.pipe(addPrefixTransformer()).pipe(process.stderr);\n          }\n        }\n        let outWithErr = [];\n        p.stdout.on('data', (chunk) => {\n          outWithErr.push(chunk.toString());\n        });\n        p.stderr.on('data', (chunk) => {\n          outWithErr.push(chunk.toString());\n        });\n        p.on('exit', (code, signal) => {\n          this.processes.delete(p);\n          if (code === null) code = signalToCode(signal);\n          // we didn't print any output as we were running the command\n          // print all the collected output|\n          const terminalOutput = outWithErr.join('');\n          if (!streamOutput) {\n            this.options.lifeCycle.printTaskTerminalOutput(\n              task,\n              code === 0 ? 'success' : 'failure',\n              terminalOutput\n            );\n          }\n          this.writeTerminalOutput(temporaryOutputPath, terminalOutput);\n          res({ code, terminalOutput });\n        });\n      } catch (e) {\n        console.error(e);\n        rej(e);\n      }\n    });\n  }\n  private forkProcessDirectOutputCapture(\n    task: Task,\n    {\n      streamOutput,\n      temporaryOutputPath,\n      taskGraph,\n      env,\n    }: {\n      streamOutput: boolean;\n      temporaryOutputPath: string;\n      taskGraph: TaskGraph;\n      env: NodeJS.ProcessEnv;\n    }\n  ) {\n    return new Promise<{ code: number; terminalOutput: string }>((res, rej) => {\n      try {\n        const args = getPrintableCommandArgsForTask(task);\n        if (streamOutput) {\n          output.logCommand(args.join(' '));\n        }\n        const p = fork(this.cliPath, {\n          stdio: ['inherit', 'inherit', 'inherit', 'ipc'],\n          env,\n        });\n        this.processes.add(p);\n        // Re-emit any messages from the task process\n        p.on('message', (message) => {\n          if (process.send) {\n            process.send(message);\n          }\n        });\n        // Send message to run the executor\n        p.send({\n          targetDescription: task.target,\n          overrides: task.overrides,\n          taskGraph,\n          isVerbose: this.verbose,\n        });\n        p.on('exit', (code, signal) => {\n          if (code === null) code = signalToCode(signal);\n          // we didn't print any output as we were running the command\n          // print all the collected output\n          let terminalOutput = '';\n          try {\n            terminalOutput = this.readTerminalOutput(temporaryOutputPath);\n            if (!streamOutput) {\n              this.options.lifeCycle.printTaskTerminalOutput(\n                task,\n                code === 0 ? 'success' : 'failure',\n                terminalOutput\n              );\n            }\n          } catch (e) {\n            console.log(stripIndents`\n              Unable to print terminal output for Task \"${task.id}\".\n              Task failed with Exit Code ${code} and Signal \"${signal}\".\n              Received error message:\n              ${e.message}\n            `);\n          }\n          res({\n            code,\n            terminalOutput,\n          });\n        });\n      } catch (e) {\n        console.error(e);\n        rej(e);\n      }\n    });\n  }\n  private readTerminalOutput(outputPath: string) {\n    return readFileSync(outputPath).toString();\n  }\n  private writeTerminalOutput(outputPath: string, content: string) {\n    writeFileSync(outputPath, content);\n  }\n  private setupProcessEventListeners() {\n    if (this.pseudoTerminal) {\n      this.pseudoTerminal.onMessageFromChildren((message: Serializable) => {\n        process.send(message);\n      });\n    }\n    // When the nx process gets a message, it will be sent into the task's process\n    process.on('message', (message: Serializable) => {\n      // this.publisher.publish(message.toString());\n      if (this.pseudoTerminal) {\n        this.pseudoTerminal.sendMessageToChildren(message);\n      }\n      this.processes.forEach((p) => {\n        if ('connected' in p && p.connected) {\n          p.send(message);\n        }\n      });\n    });\n    // Terminate any task processes on exit\n    process.on('exit', () => {\n      this.processes.forEach((p) => {\n        if ('connected' in p ? p.connected : p.isAlive) {\n          p.kill();\n        }\n      });\n    });\n    process.on('SIGINT', () => {\n      this.processes.forEach((p) => {\n        if ('connected' in p ? p.connected : p.isAlive) {\n          p.kill('SIGTERM');\n        }\n      });\n      // we exit here because we don't need to write anything to cache.\n      process.exit(signalToCode('SIGINT'));\n    });\n    process.on('SIGTERM', () => {\n      this.processes.forEach((p) => {\n        if ('connected' in p ? p.connected : p.isAlive) {\n          p.kill('SIGTERM');\n        }\n      });\n      // no exit here because we expect child processes to terminate which\n      // will store results to the cache and will terminate this process\n    });\n    process.on('SIGHUP', () => {\n      this.processes.forEach((p) => {\n        if ('connected' in p ? p.connected : p.isAlive) {\n          p.kill('SIGTERM');\n        }\n      });\n      // no exit here because we expect child processes to terminate which\n      // will store results to the cache and will terminate this process\n    });\n  }\n}"
    },
    {
      "type": "class",
      "name": "%AC$%dflt$logClearLineToPrefixTransformer$9",
      "label": "%AC$%dflt$logClearLineToPrefixTransformer$9",
      "start_line": 1,
      "end_line": 498,
      "functions": [
        {
          "type": "function",
          "name": "%AM0$transform",
          "label": "%AM0$transform",
          "start_line": 1,
          "end_line": 498,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "m = parameter0: unknown\nthis = this: @ts_files/208.ts: %dflt\n%0 = m + prefix\nreturn %0",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "(m) => m + prefix"
        },
        {
          "type": "function",
          "name": "transform",
          "label": "transform",
          "start_line": 1,
          "end_line": 496,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "chunk = parameter0: unknown\n_encoding = parameter1: unknown\ncallback = parameter2: unknown\nthis = this: @ts_files/208.ts: %dflt\n%0 = instanceinvoke prevChunk.<@%unk/%unk: .toString()>()\n%1 = %0 === '\u001b[2K'\n%2 = prevChunk && %1\nif %2 != false",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%3 = instanceinvoke chunk.<@%unk/%unk: .toString()>()\nchunk = instanceinvoke %3.<@%unk/%unk: .replace()>(/\\x1b\\[1G/g, %AM0$transform)",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "instanceinvoke this.<@%unk/%unk: .push()>(chunk)\nprevChunk = chunk\nstaticinvoke <@%unk/%unk: .callback()>()\nreturn",
                      "start_line": 1,
                      "end_line": 508,
                      "successors": []
                    }
                  ]
                },
                {
                  "type": "blockRef",
                  "label": "(RepeatedBlock)"
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "transform(chunk, _encoding, callback) {\n      if (prevChunk && prevChunk.toString() === '\\x1b[2K') {\n        chunk = chunk.toString().replace(/\\x1b\\[1G/g, (m) => m + prefix);\n      }\n      this.push(chunk);\n      prevChunk = chunk;\n      callback();\n    }"
        }
      ],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n    transform(chunk, _encoding, callback) {\n      if (prevChunk && prevChunk.toString() === '\\x1b[2K') {\n        chunk = chunk.toString().replace(/\\x1b\\[1G/g, (m) => m + prefix);\n      }\n      this.push(chunk);\n      prevChunk = chunk;\n      callback();\n    },\n  }"
    },
    {
      "type": "class",
      "name": "%AC$%dflt$addPrefixTransformer$10",
      "label": "%AC$%dflt$addPrefixTransformer$10",
      "start_line": 1,
      "end_line": 513,
      "functions": [
        {
          "type": "function",
          "name": "%AM0$transform",
          "label": "%AM0$transform",
          "start_line": 1,
          "end_line": 513,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "m = parameter0: unknown\nthis = this: @ts_files/208.ts: %dflt\nif prefix != 0\nConditionalOperatorIfTrue0\n%0 = prefix + ' '\n%1 = %0 + m\n%2 = %1 + newLineSeparator\nConditionalOperatorIfFalse0\n%2 = m + newLineSeparator\nConditionalOperatorEnd0\n%3 = instanceinvoke this.<@%unk/%unk: .push()>(%2)\nreturn %3",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "(m) =>\n          this.push(\n            prefix ? prefix + ' ' + m + newLineSeparator : m + newLineSeparator\n          )"
        },
        {
          "type": "function",
          "name": "transform",
          "label": "transform",
          "start_line": 1,
          "end_line": 509,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "chunk = parameter0: unknown\n_encoding = parameter1: unknown\ncallback = parameter2: unknown\nthis = this: @ts_files/208.ts: %dflt\n%0 = instanceinvoke chunk.<@%unk/%unk: .toString()>()\nlist = instanceinvoke %0.<@%unk/%unk: .split()>(/\\r\\n|[\\n\\v\\f\\r\\x85\\u2028\\u2029]/g)\n%1 = instanceinvoke list.<@%unk/%unk: .filter()>(Boolean)\ninstanceinvoke %1.<@%unk/%unk: .forEach()>(%AM0$transform)\nstaticinvoke <@%unk/%unk: .callback()>()\nreturn",
              "start_line": 1,
              "end_line": 508,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "transform(chunk, _encoding, callback) {\n      const list = chunk.toString().split(/\\r\\n|[\\n\\v\\f\\r\\x85\\u2028\\u2029]/g);\n      list\n        .filter(Boolean)\n        .forEach((m) =>\n          this.push(\n            prefix ? prefix + ' ' + m + newLineSeparator : m + newLineSeparator\n          )\n        );\n      callback();\n    }"
        }
      ],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n    transform(chunk, _encoding, callback) {\n      const list = chunk.toString().split(/\\r\\n|[\\n\\v\\f\\r\\x85\\u2028\\u2029]/g);\n      list\n        .filter(Boolean)\n        .forEach((m) =>\n          this.push(\n            prefix ? prefix + ' ' + m + newLineSeparator : m + newLineSeparator\n          )\n        );\n      callback();\n    },\n  }"
    },
    {
      "type": "class",
      "name": "%AC$ForkedProcessTaskRunner$%AM0$forkProcessForBatch$11",
      "label": "%AC$ForkedProcessTaskRunner$%AM0$forkProcessForBatch$11",
      "start_line": 60,
      "end_line": 60,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n          stdio: ['inherit', 'inherit', 'inherit', 'ipc'],\n          env,\n        }"
    },
    {
      "type": "class",
      "name": "%AC$ForkedProcessTaskRunner$%AM1$%AM0$forkProcessForBatch$12",
      "label": "%AC$ForkedProcessTaskRunner$%AM1$%AM0$forkProcessForBatch$12",
      "start_line": 69,
      "end_line": 69,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{}"
    },
    {
      "type": "class",
      "name": "%AC$ForkedProcessTaskRunner$%AM1$%AM0$forkProcessForBatch$13",
      "label": "%AC$ForkedProcessTaskRunner$%AM1$%AM0$forkProcessForBatch$13",
      "start_line": 71,
      "end_line": 71,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n                success: false,\n                terminalOutput: '',\n              }"
    },
    {
      "type": "class",
      "name": "%AC$ForkedProcessTaskRunner$%AM0$forkProcessForBatch$14",
      "label": "%AC$ForkedProcessTaskRunner$%AM0$forkProcessForBatch$14",
      "start_line": 101,
      "end_line": 101,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n          type: BatchMessageType.RunTasks,\n          executorName,\n          batchTaskGraph,\n          fullTaskGraph,\n        }"
    },
    {
      "type": "class",
      "name": "%AC$ForkedProcessTaskRunner$forkProcessLegacy$15",
      "label": "%AC$ForkedProcessTaskRunner$forkProcessLegacy$15",
      "start_line": 129,
      "end_line": 129,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n          temporaryOutputPath,\n          streamOutput,\n          taskGraph,\n          env,\n        }"
    },
    {
      "type": "class",
      "name": "%AC$ForkedProcessTaskRunner$forkProcessLegacy$16",
      "label": "%AC$ForkedProcessTaskRunner$forkProcessLegacy$16",
      "start_line": 135,
      "end_line": 135,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n          temporaryOutputPath,\n          streamOutput,\n          taskGraph,\n          env,\n        }"
    },
    {
      "type": "class",
      "name": "%AC$ForkedProcessTaskRunner$forkProcess$17",
      "label": "%AC$ForkedProcessTaskRunner$forkProcess$17",
      "start_line": 169,
      "end_line": 169,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n        temporaryOutputPath,\n        streamOutput,\n        taskGraph,\n        env,\n      }"
    },
    {
      "type": "class",
      "name": "%AC$ForkedProcessTaskRunner$forkProcess$18",
      "label": "%AC$ForkedProcessTaskRunner$forkProcess$18",
      "start_line": 176,
      "end_line": 176,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n        temporaryOutputPath,\n        streamOutput,\n        taskGraph,\n        env,\n      }"
    },
    {
      "type": "class",
      "name": "%AC$ForkedProcessTaskRunner$forkProcessWithPseudoTerminal$19",
      "label": "%AC$ForkedProcessTaskRunner$forkProcessWithPseudoTerminal$19",
      "start_line": 203,
      "end_line": 203,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n      cwd: process.cwd(),\n      execArgv: process.execArgv,\n      jsEnv: env,\n      quiet: !streamOutput,\n    }"
    },
    {
      "type": "class",
      "name": "%AC$ForkedProcessTaskRunner$forkProcessWithPseudoTerminal$20",
      "label": "%AC$ForkedProcessTaskRunner$forkProcessWithPseudoTerminal$20",
      "start_line": 209,
      "end_line": 209,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n      targetDescription: task.target,\n      overrides: task.overrides,\n      taskGraph,\n      isVerbose: this.verbose,\n    }"
    },
    {
      "type": "class",
      "name": "%AC$ForkedProcessTaskRunner$%AM5$%AM4$forkProcessWithPseudoTerminal$21",
      "label": "%AC$ForkedProcessTaskRunner$%AM5$%AM4$forkProcessWithPseudoTerminal$21",
      "start_line": 227,
      "end_line": 227,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n          code,\n          terminalOutput,\n        }"
    },
    {
      "type": "class",
      "name": "%AC$ForkedProcessTaskRunner$forkProcessPipeOutputCapture$22",
      "label": "%AC$ForkedProcessTaskRunner$forkProcessPipeOutputCapture$22",
      "start_line": 248,
      "end_line": 248,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n      streamOutput,\n      temporaryOutputPath,\n      taskGraph,\n      env,\n    }"
    },
    {
      "type": "class",
      "name": "%AC$23",
      "label": "%AC$23",
      "start_line": 269,
      "end_line": 269,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{ code: number; terminalOutput: string }"
    },
    {
      "type": "class",
      "name": "%AC$ForkedProcessTaskRunner$%AM6$forkProcessWithPrefixAndNotTTY$24",
      "label": "%AC$ForkedProcessTaskRunner$%AM6$forkProcessWithPrefixAndNotTTY$24",
      "start_line": 275,
      "end_line": 275,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n          stdio: ['inherit', 'pipe', 'pipe', 'ipc'],\n          env,\n        }"
    },
    {
      "type": "class",
      "name": "%AC$ForkedProcessTaskRunner$%AM6$forkProcessWithPrefixAndNotTTY$25",
      "label": "%AC$ForkedProcessTaskRunner$%AM6$forkProcessWithPrefixAndNotTTY$25",
      "start_line": 287,
      "end_line": 287,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n          targetDescription: task.target,\n          overrides: task.overrides,\n          taskGraph,\n          isVerbose: this.verbose,\n        }"
    },
    {
      "type": "class",
      "name": "%AC$ForkedProcessTaskRunner$%AM10$%AM6$forkProcessWithPrefixAndNotTTY$26",
      "label": "%AC$ForkedProcessTaskRunner$%AM10$%AM6$forkProcessWithPrefixAndNotTTY$26",
      "start_line": 333,
      "end_line": 333,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{ code, terminalOutput }"
    },
    {
      "type": "class",
      "name": "%AC$27",
      "label": "%AC$27",
      "start_line": 355,
      "end_line": 355,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{ code: number; terminalOutput: string }"
    },
    {
      "type": "class",
      "name": "%AC$ForkedProcessTaskRunner$%AM11$forkProcessDirectOutputCapture$28",
      "label": "%AC$ForkedProcessTaskRunner$%AM11$forkProcessDirectOutputCapture$28",
      "start_line": 361,
      "end_line": 361,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n          stdio: ['inherit', 'inherit', 'inherit', 'ipc'],\n          env,\n        }"
    },
    {
      "type": "class",
      "name": "%AC$ForkedProcessTaskRunner$%AM11$forkProcessDirectOutputCapture$29",
      "label": "%AC$ForkedProcessTaskRunner$%AM11$forkProcessDirectOutputCapture$29",
      "start_line": 373,
      "end_line": 373,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n          targetDescription: task.target,\n          overrides: task.overrides,\n          taskGraph,\n          isVerbose: this.verbose,\n        }"
    },
    {
      "type": "class",
      "name": "%AC$ForkedProcessTaskRunner$%AM13$%AM11$forkProcessDirectOutputCapture$30",
      "label": "%AC$ForkedProcessTaskRunner$%AM13$%AM11$forkProcessDirectOutputCapture$30",
      "start_line": 401,
      "end_line": 401,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n            code,\n            terminalOutput,\n          }"
    }
  ],
  "functions": [],
  "blocks": [],
  "simplified_code": "import { readFileSync, writeFileSync } from 'fs';\nimport { ChildProcess, fork, Serializable } from 'child_process';\nimport * as chalk from 'chalk';\nimport { DefaultTasksRunnerOptions } from './default-tasks-runner';\nimport { output } from '../utils/output';\nimport { getCliPath, getPrintableCommandArgsForTask } from './utils';\nimport { Batch } from './tasks-schedule';\nimport { join } from 'path';\nimport {\n  BatchMessage,\n  BatchMessageType,\n  BatchResults,\n} from './batch/batch-messages';\nimport { stripIndents } from '../utils/strip-indents';\nimport { Task, TaskGraph } from '../config/task-graph';\nimport { Transform } from 'stream';\nimport {\n  PseudoTtyProcess,\n  getPseudoTerminal,\n  PseudoTerminal,\n} from './pseudo-terminal';\nimport { signalToCode } from '../utils/exit-codes';\nconst forkScript = join(__dirname, './fork.js');\nconst workerPath = join(__dirname, './batch/run-batch.js');\nexport class ForkedProcessTaskRunner {\n  cliPath = getCliPath();\n  private readonly verbose = process.env.NX_VERBOSE_LOGGING === 'true';\n  private processes = new Set<ChildProcess | PseudoTtyProcess>();\n  private pseudoTerminal: PseudoTerminal | null = PseudoTerminal.isSupported()\n    ? getPseudoTerminal()\n    : null;\n  constructor(private readonly options: DefaultTasksRunnerOptions) {}\n  async init() {\n    if (this.pseudoTerminal) {\n      await this.pseudoTerminal.init();\n    }\n    this.setupProcessEventListeners();\n  }\n  // TODO: vsavkin delegate terminal output printing\n  public forkProcessForBatch(\n    { executorName, taskGraph: batchTaskGraph }: Batch,\n    fullTaskGraph: TaskGraph,\n    env: NodeJS.ProcessEnv\n  ) {\n    return new Promise<BatchResults>((res, rej) => {\n      try {\n        const count = Object.keys(batchTaskGraph.tasks).length;\n        if (count > 1) {\n          output.logSingleLine(\n            `Running ${output.bold(count)} ${output.bold(\n              'tasks'\n            )} with ${output.bold(executorName)}`\n          );\n        } else {\n          const args = getPrintableCommandArgsForTask(\n            Object.values(batchTaskGraph.tasks)[0]\n          );\n          output.logCommand(args.join(' '));\n        }\n        const p = fork(workerPath, {\n          stdio: ['inherit', 'inherit', 'inherit', 'ipc'],\n          env,\n        });\n        this.processes.add(p);\n        p.once('exit', (code, signal) => {\n          this.processes.delete(p);\n          if (code === null) code = signalToCode(signal);\n          if (code !== 0) {\n            const results: BatchResults = {};\n            for (const rootTaskId of batchTaskGraph.roots) {\n              results[rootTaskId] = {\n                success: false,\n                terminalOutput: '',\n              };\n            }\n            rej(\n              new Error(\n                `\"${executorName}\" exited unexpectedly with code: ${code}`\n              )\n            );\n          }\n        });\n        p.on('message', (message: BatchMessage) => {\n          switch (message.type) {\n            case BatchMessageType.CompleteBatchExecution: {\n              res(message.results);\n              break;\n            }\n            case BatchMessageType.RunTasks: {\n              break;\n            }\n            default: {\n              // Re-emit any non-batch messages from the task process\n              if (process.send) {\n                process.send(message);\n              }\n            }\n          }\n        });\n        // Start the tasks\n        p.send({\n          type: BatchMessageType.RunTasks,\n          executorName,\n          batchTaskGraph,\n          fullTaskGraph,\n        });\n      } catch (e) {\n        rej(e);\n      }\n    });\n  }\n  public async forkProcessLegacy(\n    task: Task,\n    {\n      temporaryOutputPath,\n      streamOutput,\n      pipeOutput,\n      taskGraph,\n      env,\n    }: {\n      temporaryOutputPath: string;\n      streamOutput: boolean;\n      pipeOutput: boolean;\n      taskGraph: TaskGraph;\n      env: NodeJS.ProcessEnv;\n    }\n  ): Promise<{ code: number; terminalOutput: string }> {\n    return pipeOutput\n      ? await this.forkProcessPipeOutputCapture(task, {\n          temporaryOutputPath,\n          streamOutput,\n          taskGraph,\n          env,\n        })\n      : await this.forkProcessDirectOutputCapture(task, {\n          temporaryOutputPath,\n          streamOutput,\n          taskGraph,\n          env,\n        });\n  }\n  public async forkProcess(\n    task: Task,\n    {\n      temporaryOutputPath,\n      streamOutput,\n      taskGraph,\n      env,\n      disablePseudoTerminal,\n    }: {\n      temporaryOutputPath: string;\n      streamOutput: boolean;\n      pipeOutput: boolean;\n      taskGraph: TaskGraph;\n      env: NodeJS.ProcessEnv;\n      disablePseudoTerminal: boolean;\n    }\n  ): Promise<{ code: number; terminalOutput: string }> {\n    const shouldPrefix =\n      streamOutput && process.env.NX_PREFIX_OUTPUT === 'true';\n    // streamOutput would be false if we are running multiple targets\n    // there's no point in running the commands in a pty if we are not streaming the output\n    if (\n      !this.pseudoTerminal ||\n      disablePseudoTerminal ||\n      !streamOutput ||\n      shouldPrefix\n    ) {\n      return this.forkProcessWithPrefixAndNotTTY(task, {\n        temporaryOutputPath,\n        streamOutput,\n        taskGraph,\n        env,\n      });\n    } else {\n      return this.forkProcessWithPseudoTerminal(task, {\n        temporaryOutputPath,\n        streamOutput,\n        taskGraph,\n        env,\n      });\n    }\n  }\n  private async forkProcessWithPseudoTerminal(\n    task: Task,\n    {\n      temporaryOutputPath,\n      streamOutput,\n      taskGraph,\n      env,\n    }: {\n      temporaryOutputPath: string;\n      streamOutput: boolean;\n      taskGraph: TaskGraph;\n      env: NodeJS.ProcessEnv;\n    }\n  ): Promise<{ code: number; terminalOutput: string }> {\n    const args = getPrintableCommandArgsForTask(task);\n    if (streamOutput) {\n      output.logCommand(args.join(' '));\n    }\n    const childId = task.id;\n    const p = await this.pseudoTerminal.fork(childId, forkScript, {\n      cwd: process.cwd(),\n      execArgv: process.execArgv,\n      jsEnv: env,\n      quiet: !streamOutput,\n    });\n    p.send({\n      targetDescription: task.target,\n      overrides: task.overrides,\n      taskGraph,\n      isVerbose: this.verbose,\n    });\n    this.processes.add(p);\n    let terminalOutput = '';\n    p.onOutput((msg) => {\n      terminalOutput += msg;\n    });\n    return new Promise((res) => {\n      p.onExit((code) => {\n        // If the exit code is greater than 128, it's a special exit code for a signal\n        if (code >= 128) {\n          process.exit(code);\n        }\n        this.writeTerminalOutput(temporaryOutputPath, terminalOutput);\n        res({\n          code,\n          terminalOutput,\n        });\n      });\n    });\n  }\n  private forkProcessPipeOutputCapture(\n    task: Task,\n    {\n      streamOutput,\n      temporaryOutputPath,\n      taskGraph,\n      env,\n    }: {\n      streamOutput: boolean;\n      temporaryOutputPath: string;\n      taskGraph: TaskGraph;\n      env: NodeJS.ProcessEnv;\n    }\n  ) {\n    return this.forkProcessWithPrefixAndNotTTY(task, {\n      streamOutput,\n      temporaryOutputPath,\n      taskGraph,\n      env,\n    });\n  }\n  private forkProcessWithPrefixAndNotTTY(\n    task: Task,\n    {\n      streamOutput,\n      temporaryOutputPath,\n      taskGraph,\n      env,\n    }: {\n      streamOutput: boolean;\n      temporaryOutputPath: string;\n      taskGraph: TaskGraph;\n      env: NodeJS.ProcessEnv;\n    }\n  ) {\n    return new Promise<{ code: number; terminalOutput: string }>((res, rej) => {\n      try {\n        const args = getPrintableCommandArgsForTask(task);\n        if (streamOutput) {\n          output.logCommand(args.join(' '));\n        }\n        const p = fork(this.cliPath, {\n          stdio: ['inherit', 'pipe', 'pipe', 'ipc'],\n          env,\n        });\n        this.processes.add(p);\n        // Re-emit any messages from the task process\n        p.on('message', (message) => {\n          if (process.send) {\n            process.send(message);\n          }\n        });\n        // Send message to run the executor\n        p.send({\n          targetDescription: task.target,\n          overrides: task.overrides,\n          taskGraph,\n          isVerbose: this.verbose,\n        });\n        if (streamOutput) {\n          if (process.env.NX_PREFIX_OUTPUT === 'true') {\n            const color = getColor(task.target.project);\n            const prefixText = `${task.target.project}:`;\n            p.stdout\n              .pipe(\n                logClearLineToPrefixTransformer(color.bold(prefixText) + ' ')\n              )\n              .pipe(addPrefixTransformer(color.bold(prefixText)))\n              .pipe(process.stdout);\n            p.stderr\n              .pipe(logClearLineToPrefixTransformer(color(prefixText) + ' '))\n              .pipe(addPrefixTransformer(color(prefixText)))\n              .pipe(process.stderr);\n          } else {\n            p.stdout.pipe(addPrefixTransformer()).pipe(process.stdout);\n            p.stderr.pipe(addPrefixTransformer()).pipe(process.stderr);\n          }\n        }\n        let outWithErr = [];\n        p.stdout.on('data', (chunk) => {\n          outWithErr.push(chunk.toString());\n        });\n        p.stderr.on('data', (chunk) => {\n          outWithErr.push(chunk.toString());\n        });\n        p.on('exit', (code, signal) => {\n          this.processes.delete(p);\n          if (code === null) code = signalToCode(signal);\n          // we didn't print any output as we were running the command\n          // print all the collected output|\n          const terminalOutput = outWithErr.join('');\n          if (!streamOutput) {\n            this.options.lifeCycle.printTaskTerminalOutput(\n              task,\n              code === 0 ? 'success' : 'failure',\n              terminalOutput\n            );\n          }\n          this.writeTerminalOutput(temporaryOutputPath, terminalOutput);\n          res({ code, terminalOutput });\n        });\n      } catch (e) {\n        console.error(e);\n        rej(e);\n      }\n    });\n  }\n  private forkProcessDirectOutputCapture(\n    task: Task,\n    {\n      streamOutput,\n      temporaryOutputPath,\n      taskGraph,\n      env,\n    }: {\n      streamOutput: boolean;\n      temporaryOutputPath: string;\n      taskGraph: TaskGraph;\n      env: NodeJS.ProcessEnv;\n    }\n  ) {\n    return new Promise<{ code: number; terminalOutput: string }>((res, rej) => {\n      try {\n        const args = getPrintableCommandArgsForTask(task);\n        if (streamOutput) {\n          output.logCommand(args.join(' '));\n        }\n        const p = fork(this.cliPath, {\n          stdio: ['inherit', 'inherit', 'inherit', 'ipc'],\n          env,\n        });\n        this.processes.add(p);\n        // Re-emit any messages from the task process\n        p.on('message', (message) => {\n          if (process.send) {\n            process.send(message);\n          }\n        });\n        // Send message to run the executor\n        p.send({\n          targetDescription: task.target,\n          overrides: task.overrides,\n          taskGraph,\n          isVerbose: this.verbose,\n        });\n        p.on('exit', (code, signal) => {\n          if (code === null) code = signalToCode(signal);\n          // we didn't print any output as we were running the command\n          // print all the collected output\n          let terminalOutput = '';\n          try {\n            terminalOutput = this.readTerminalOutput(temporaryOutputPath);\n            if (!streamOutput) {\n              this.options.lifeCycle.printTaskTerminalOutput(\n                task,\n                code === 0 ? 'success' : 'failure',\n                terminalOutput\n              );\n            }\n          } catch (e) {\n            console.log(stripIndents`\n              Unable to print terminal output for Task \"${task.id}\".\n              Task failed with Exit Code ${code} and Signal \"${signal}\".\n              Received error message:\n              ${e.message}\n            `);\n          }\n          res({\n            code,\n            terminalOutput,\n          });\n        });\n      } catch (e) {\n        console.error(e);\n        rej(e);\n      }\n    });\n  }\n  private readTerminalOutput(outputPath: string) {\n    return readFileSync(outputPath).toString();\n  }\n  private writeTerminalOutput(outputPath: string, content: string) {\n    writeFileSync(outputPath, content);\n  }\n  private setupProcessEventListeners() {\n    if (this.pseudoTerminal) {\n      this.pseudoTerminal.onMessageFromChildren((message: Serializable) => {\n        process.send(message);\n      });\n    }\n    // When the nx process gets a message, it will be sent into the task's process\n    process.on('message', (message: Serializable) => {\n      // this.publisher.publish(message.toString());\n      if (this.pseudoTerminal) {\n        this.pseudoTerminal.sendMessageToChildren(message);\n      }\n      this.processes.forEach((p) => {\n        if ('connected' in p && p.connected) {\n          p.send(message);\n        }\n      });\n    });\n    // Terminate any task processes on exit\n    process.on('exit', () => {\n      this.processes.forEach((p) => {\n        if ('connected' in p ? p.connected : p.isAlive) {\n          p.kill();\n        }\n      });\n    });\n    process.on('SIGINT', () => {\n      this.processes.forEach((p) => {\n        if ('connected' in p ? p.connected : p.isAlive) {\n          p.kill('SIGTERM');\n        }\n      });\n      // we exit here because we don't need to write anything to cache.\n      process.exit(signalToCode('SIGINT'));\n    });\n    process.on('SIGTERM', () => {\n      this.processes.forEach((p) => {\n        if ('connected' in p ? p.connected : p.isAlive) {\n          p.kill('SIGTERM');\n        }\n      });\n      // no exit here because we expect child processes to terminate which\n      // will store results to the cache and will terminate this process\n    });\n    process.on('SIGHUP', () => {\n      this.processes.forEach((p) => {\n        if ('connected' in p ? p.connected : p.isAlive) {\n          p.kill('SIGTERM');\n        }\n      });\n      // no exit here because we expect child processes to terminate which\n      // will store results to the cache and will terminate this process\n    });\n  }\n}\nconst colors = [\n  chalk.green,\n  chalk.greenBright,\n  chalk.red,\n  chalk.redBright,\n  chalk.cyan,\n  chalk.cyanBright,\n  chalk.yellow,\n  chalk.yellowBright,\n  chalk.magenta,\n  chalk.magentaBright,\n];\nfunction getColor(projectName: string) {\n  let code = 0;\n  for (let i = 0; i < projectName.length; ++i) {\n    code += projectName.charCodeAt(i);\n  }\n  const colorIndex = code % colors.length;\n  return colors[colorIndex];\n}\nfunction logClearLineToPrefixTransformer(prefix: string) {\n  let prevChunk = null;\n  return new Transform({\n    transform(chunk, _encoding, callback) {\n      if (prevChunk && prevChunk.toString() === '\\x1b[2K') {\n        chunk = chunk.toString().replace(/\\x1b\\[1G/g, (m) => m + prefix);\n      }\n      this.push(chunk);\n      prevChunk = chunk;\n      callback();\n    },\n  });\n}\nfunction addPrefixTransformer(prefix?: string) {\n  const newLineSeparator = process.platform.startsWith('win') ? '\\r\\n' : '\\n';\n  return new Transform({\n    transform(chunk, _encoding, callback) {\n      const list = chunk.toString().split(/\\r\\n|[\\n\\v\\f\\r\\x85\\u2028\\u2029]/g);\n      list\n        .filter(Boolean)\n        .forEach((m) =>\n          this.push(\n            prefix ? prefix + ' ' + m + newLineSeparator : m + newLineSeparator\n          )\n        );\n      callback();\n    },\n  });\n}"
}