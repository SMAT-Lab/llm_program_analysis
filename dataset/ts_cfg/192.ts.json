{
  "type": "file",
  "name": "192.ts",
  "label": "192.ts",
  "start_line": -1,
  "end_line": 549,
  "classes": [
    {
      "type": "class",
      "name": "%dflt",
      "label": "%dflt",
      "start_line": -1,
      "end_line": 549,
      "functions": [
        {
          "type": "function",
          "name": "%dflt",
          "label": "%dflt",
          "start_line": -1,
          "end_line": 549,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/192.ts: %dflt\nreturn",
              "start_line": 1,
              "end_line": 549,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": ""
        }
      ],
      "classes": [],
      "blocks": [],
      "simplified_code": ""
    },
    {
      "type": "class",
      "name": "WorkspaceRepository",
      "label": "WorkspaceRepository",
      "start_line": 1,
      "end_line": 549,
      "functions": [
        {
          "type": "function",
          "name": "constructor",
          "label": "constructor",
          "start_line": 1,
          "end_line": 549,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "instanceinvoke this.<@ts_files/192.ts: WorkspaceRepository.%instInit()>()\ninternalContext = parameter0: WorkspaceInternalContext\ntarget = parameter1: EntityTarget<Entity extends ObjectLiteral>\nmanager = parameter2: EntityManager\nqueryRunner = parameter3: QueryRunner\nthis = this: @ts_files/192.ts: WorkspaceRepository\nstaticinvoke <@%unk/%unk: .super()>(target, manager, queryRunner)\nthis.<@ts_files/192.ts: WorkspaceRepository.internalContext> = internalContext\nreturn",
              "start_line": 1,
              "end_line": 549,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "constructor(\n    internalContext: WorkspaceInternalContext,\n    target: EntityTarget<Entity>,\n    manager: EntityManager,\n    queryRunner?: QueryRunner,\n  ) {\n    super(target, manager, queryRunner);\n    this.internalContext = internalContext;\n  }"
        },
        {
          "type": "function",
          "name": "find",
          "label": "find",
          "start_line": 1,
          "end_line": 323,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "options = parameter0: FindManyOptions<Entity extends ObjectLiteral>\nentityManager = parameter1: EntityManager\nthis = this: @ts_files/192.ts: WorkspaceRepository\n%0 = this.<@ts_files/192.ts: WorkspaceRepository.manager>\nmanager = entityManager || %0\n%1 = instanceinvoke this.<@ts_files/192.ts: WorkspaceRepository.transformOptions(T extends FindManyOptions<Entity>|FindOneOptions<Entity>|undefined)>(options)\ncomputedOptions = await %1\n%2 = this.<@ts_files/192.ts: WorkspaceRepository.target>\n%3 = instanceinvoke manager.<@%unk/%unk: .find()>(%2, computedOptions)\nresult = await %3\n%4 = instanceinvoke this.<@ts_files/192.ts: WorkspaceRepository.formatResult(T, ObjectMetadataItemWithFieldMaps)>(result)\nformattedResult = await %4\nreturn formattedResult",
              "start_line": 1,
              "end_line": 323,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "override async find(\n    options?: FindManyOptions<Entity>,\n    entityManager?: EntityManager,\n  ): Promise<Entity[]> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions(options);\n    const result = await manager.find(this.target, computedOptions);\n    const formattedResult = await this.formatResult(result);\n    return formattedResult;\n  }"
        },
        {
          "type": "function",
          "name": "findBy",
          "label": "findBy",
          "start_line": 1,
          "end_line": 323,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "where = parameter0: FindOptionsWhere<Entity extends ObjectLiteral>|FindOptionsWhere<Entity>[]\nentityManager = parameter1: EntityManager\nthis = this: @ts_files/192.ts: WorkspaceRepository\n%0 = this.<@ts_files/192.ts: WorkspaceRepository.manager>\nmanager = entityManager || %0\n%1 = new @ts_files/192.ts: %AC$WorkspaceRepository$findBy$0\ninstanceinvoke %1.<@ts_files/192.ts: %AC$WorkspaceRepository$findBy$0.constructor()>()\n%2 = instanceinvoke this.<@ts_files/192.ts: WorkspaceRepository.transformOptions(T extends FindManyOptions<Entity>|FindOneOptions<Entity>|undefined)>(%1)\ncomputedOptions = await %2\n%3 = this.<@ts_files/192.ts: WorkspaceRepository.target>\n%4 = computedOptions.<@%unk/%unk: .where>\n%5 = instanceinvoke manager.<@%unk/%unk: .findBy()>(%3, %4)\nresult = await %5\n%6 = instanceinvoke this.<@ts_files/192.ts: WorkspaceRepository.formatResult(T, ObjectMetadataItemWithFieldMaps)>(result)\nformattedResult = await %6\nreturn formattedResult",
              "start_line": 1,
              "end_line": 323,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "override async findBy(\n    where: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    entityManager?: EntityManager,\n  ): Promise<Entity[]> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions({ where });\n    const result = await manager.findBy(this.target, computedOptions.where);\n    const formattedResult = await this.formatResult(result);\n    return formattedResult;\n  }"
        },
        {
          "type": "function",
          "name": "findAndCount",
          "label": "findAndCount",
          "start_line": 1,
          "end_line": 323,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "options = parameter0: FindManyOptions<Entity extends ObjectLiteral>\nentityManager = parameter1: EntityManager\nthis = this: @ts_files/192.ts: WorkspaceRepository\n%0 = this.<@ts_files/192.ts: WorkspaceRepository.manager>\nmanager = entityManager || %0\n%1 = instanceinvoke this.<@ts_files/192.ts: WorkspaceRepository.transformOptions(T extends FindManyOptions<Entity>|FindOneOptions<Entity>|undefined)>(options)\ncomputedOptions = await %1\n%2 = this.<@ts_files/192.ts: WorkspaceRepository.target>\n%3 = instanceinvoke manager.<@%unk/%unk: .findAndCount()>(%2, computedOptions)\nresult = await %3\n%4 = instanceinvoke this.<@ts_files/192.ts: WorkspaceRepository.formatResult(T, ObjectMetadataItemWithFieldMaps)>(result)\nformattedResult = await %4\nreturn formattedResult",
              "start_line": 1,
              "end_line": 323,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "override async findAndCount(\n    options?: FindManyOptions<Entity>,\n    entityManager?: EntityManager,\n  ): Promise<[Entity[], number]> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions(options);\n    const result = await manager.findAndCount(this.target, computedOptions);\n    const formattedResult = await this.formatResult(result);\n    return formattedResult;\n  }"
        },
        {
          "type": "function",
          "name": "findAndCountBy",
          "label": "findAndCountBy",
          "start_line": 1,
          "end_line": 323,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "where = parameter0: FindOptionsWhere<Entity extends ObjectLiteral>|FindOptionsWhere<Entity>[]\nentityManager = parameter1: EntityManager\nthis = this: @ts_files/192.ts: WorkspaceRepository\n%0 = this.<@ts_files/192.ts: WorkspaceRepository.manager>\nmanager = entityManager || %0\n%1 = new @ts_files/192.ts: %AC$WorkspaceRepository$findAndCountBy$1\ninstanceinvoke %1.<@ts_files/192.ts: %AC$WorkspaceRepository$findAndCountBy$1.constructor()>()\n%2 = instanceinvoke this.<@ts_files/192.ts: WorkspaceRepository.transformOptions(T extends FindManyOptions<Entity>|FindOneOptions<Entity>|undefined)>(%1)\ncomputedOptions = await %2\n%3 = this.<@ts_files/192.ts: WorkspaceRepository.target>\n%4 = computedOptions.<@%unk/%unk: .where>\n%5 = instanceinvoke manager.<@%unk/%unk: .findAndCountBy()>(%3, %4)\nresult = await %5\n%6 = instanceinvoke this.<@ts_files/192.ts: WorkspaceRepository.formatResult(T, ObjectMetadataItemWithFieldMaps)>(result)\nformattedResult = await %6\nreturn formattedResult",
              "start_line": 1,
              "end_line": 323,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "override async findAndCountBy(\n    where: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    entityManager?: EntityManager,\n  ): Promise<[Entity[], number]> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions({ where });\n    const result = await manager.findAndCountBy(\n      this.target,\n      computedOptions.where,\n    );\n    const formattedResult = await this.formatResult(result);\n    return formattedResult;\n  }"
        },
        {
          "type": "function",
          "name": "findOne",
          "label": "findOne",
          "start_line": 1,
          "end_line": 323,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "options = parameter0: FindOneOptions<Entity extends ObjectLiteral>\nentityManager = parameter1: EntityManager\nthis = this: @ts_files/192.ts: WorkspaceRepository\n%0 = this.<@ts_files/192.ts: WorkspaceRepository.manager>\nmanager = entityManager || %0\n%1 = instanceinvoke this.<@ts_files/192.ts: WorkspaceRepository.transformOptions(T extends FindManyOptions<Entity>|FindOneOptions<Entity>|undefined)>(options)\ncomputedOptions = await %1\n%2 = this.<@ts_files/192.ts: WorkspaceRepository.target>\n%3 = instanceinvoke manager.<@%unk/%unk: .findOne()>(%2, computedOptions)\nresult = await %3\n%4 = instanceinvoke this.<@ts_files/192.ts: WorkspaceRepository.formatResult(T, ObjectMetadataItemWithFieldMaps)>(result)\nformattedResult = await %4\nreturn formattedResult",
              "start_line": 1,
              "end_line": 323,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "override async findOne(\n    options: FindOneOptions<Entity>,\n    entityManager?: EntityManager,\n  ): Promise<Entity | null> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions(options);\n    const result = await manager.findOne(this.target, computedOptions);\n    const formattedResult = await this.formatResult(result);\n    return formattedResult;\n  }"
        },
        {
          "type": "function",
          "name": "findOneBy",
          "label": "findOneBy",
          "start_line": 1,
          "end_line": 323,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "where = parameter0: FindOptionsWhere<Entity extends ObjectLiteral>|FindOptionsWhere<Entity>[]\nentityManager = parameter1: EntityManager\nthis = this: @ts_files/192.ts: WorkspaceRepository\n%0 = this.<@ts_files/192.ts: WorkspaceRepository.manager>\nmanager = entityManager || %0\n%1 = new @ts_files/192.ts: %AC$WorkspaceRepository$findOneBy$2\ninstanceinvoke %1.<@ts_files/192.ts: %AC$WorkspaceRepository$findOneBy$2.constructor()>()\n%2 = instanceinvoke this.<@ts_files/192.ts: WorkspaceRepository.transformOptions(T extends FindManyOptions<Entity>|FindOneOptions<Entity>|undefined)>(%1)\ncomputedOptions = await %2\n%3 = this.<@ts_files/192.ts: WorkspaceRepository.target>\n%4 = computedOptions.<@%unk/%unk: .where>\n%5 = instanceinvoke manager.<@%unk/%unk: .findOneBy()>(%3, %4)\nresult = await %5\n%6 = instanceinvoke this.<@ts_files/192.ts: WorkspaceRepository.formatResult(T, ObjectMetadataItemWithFieldMaps)>(result)\nformattedResult = await %6\nreturn formattedResult",
              "start_line": 1,
              "end_line": 323,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "override async findOneBy(\n    where: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    entityManager?: EntityManager,\n  ): Promise<Entity | null> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions({ where });\n    const result = await manager.findOneBy(this.target, computedOptions.where);\n    const formattedResult = await this.formatResult(result);\n    return formattedResult;\n  }"
        },
        {
          "type": "function",
          "name": "findOneOrFail",
          "label": "findOneOrFail",
          "start_line": 1,
          "end_line": 323,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "options = parameter0: FindOneOptions<Entity extends ObjectLiteral>\nentityManager = parameter1: EntityManager\nthis = this: @ts_files/192.ts: WorkspaceRepository\n%0 = this.<@ts_files/192.ts: WorkspaceRepository.manager>\nmanager = entityManager || %0\n%1 = instanceinvoke this.<@ts_files/192.ts: WorkspaceRepository.transformOptions(T extends FindManyOptions<Entity>|FindOneOptions<Entity>|undefined)>(options)\ncomputedOptions = await %1\n%2 = this.<@ts_files/192.ts: WorkspaceRepository.target>\n%3 = instanceinvoke manager.<@%unk/%unk: .findOneOrFail()>(%2, computedOptions)\nresult = await %3\n%4 = instanceinvoke this.<@ts_files/192.ts: WorkspaceRepository.formatResult(T, ObjectMetadataItemWithFieldMaps)>(result)\nformattedResult = await %4\nreturn formattedResult",
              "start_line": 1,
              "end_line": 323,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "override async findOneOrFail(\n    options: FindOneOptions<Entity>,\n    entityManager?: EntityManager,\n  ): Promise<Entity> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions(options);\n    const result = await manager.findOneOrFail(this.target, computedOptions);\n    const formattedResult = await this.formatResult(result);\n    return formattedResult;\n  }"
        },
        {
          "type": "function",
          "name": "findOneByOrFail",
          "label": "findOneByOrFail",
          "start_line": 1,
          "end_line": 323,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "where = parameter0: FindOptionsWhere<Entity extends ObjectLiteral>|FindOptionsWhere<Entity>[]\nentityManager = parameter1: EntityManager\nthis = this: @ts_files/192.ts: WorkspaceRepository\n%0 = this.<@ts_files/192.ts: WorkspaceRepository.manager>\nmanager = entityManager || %0\n%1 = new @ts_files/192.ts: %AC$WorkspaceRepository$findOneByOrFail$3\ninstanceinvoke %1.<@ts_files/192.ts: %AC$WorkspaceRepository$findOneByOrFail$3.constructor()>()\n%2 = instanceinvoke this.<@ts_files/192.ts: WorkspaceRepository.transformOptions(T extends FindManyOptions<Entity>|FindOneOptions<Entity>|undefined)>(%1)\ncomputedOptions = await %2\n%3 = this.<@ts_files/192.ts: WorkspaceRepository.target>\n%4 = computedOptions.<@%unk/%unk: .where>\n%5 = instanceinvoke manager.<@%unk/%unk: .findOneByOrFail()>(%3, %4)\nresult = await %5\n%6 = instanceinvoke this.<@ts_files/192.ts: WorkspaceRepository.formatResult(T, ObjectMetadataItemWithFieldMaps)>(result)\nformattedResult = await %6\nreturn formattedResult",
              "start_line": 1,
              "end_line": 323,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "override async findOneByOrFail(\n    where: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    entityManager?: EntityManager,\n  ): Promise<Entity> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions({ where });\n    const result = await manager.findOneByOrFail(\n      this.target,\n      computedOptions.where,\n    );\n    const formattedResult = await this.formatResult(result);\n    return formattedResult;\n  }"
        },
        {
          "type": "function",
          "name": "save",
          "label": "save",
          "start_line": 1,
          "end_line": 147,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "entityOrEntities = parameter0: T extends DeepPartial<Entity>|T[]\noptions = parameter1: SaveOptions\nentityManager = parameter2: EntityManager\nthis = this: @ts_files/192.ts: WorkspaceRepository\n%0 = this.<@ts_files/192.ts: WorkspaceRepository.manager>\nmanager = entityManager || %0\n%1 = instanceinvoke this.<@ts_files/192.ts: WorkspaceRepository.formatData(T)>(entityOrEntities)\nformattedEntityOrEntities = await %1\nresult = undefined\n%2 = instanceinvoke Array.<@%unk/%unk: .isArray()>(formattedEntityOrEntities)\nif %2 != 0",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%3 = this.<@ts_files/192.ts: WorkspaceRepository.target>\n%4 = instanceinvoke manager.<@%unk/%unk: .save()>(%3, formattedEntityOrEntities, options)\nresult = await %4",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "%7 = instanceinvoke this.<@ts_files/192.ts: WorkspaceRepository.formatResult(T, ObjectMetadataItemWithFieldMaps)>(result)\nformattedResult = await %7\nreturn formattedResult",
                      "start_line": 1,
                      "end_line": 323,
                      "successors": []
                    }
                  ]
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%5 = this.<@ts_files/192.ts: WorkspaceRepository.target>\n%6 = instanceinvoke manager.<@%unk/%unk: .save()>(%5, formattedEntityOrEntities, options)\nresult = await %6",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "blockRef",
                      "label": "(RepeatedBlock)"
                    }
                  ]
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "override async save<T extends DeepPartial<Entity>>(\n    entityOrEntities: T | T[],\n    options?: SaveOptions,\n    entityManager?: EntityManager,\n  ): Promise<T | T[]> {\n    const manager = entityManager || this.manager;\n    const formattedEntityOrEntities = await this.formatData(entityOrEntities);\n    let result: T | T[];\n    // Needed becasuse save method has multiple signature, otherwise we will need to do a type assertion\n    if (Array.isArray(formattedEntityOrEntities)) {\n      result = await manager.save(\n        this.target,\n        formattedEntityOrEntities,\n        options,\n      );\n    } else {\n      result = await manager.save(\n        this.target,\n        formattedEntityOrEntities,\n        options,\n      );\n    }\n    const formattedResult = await this.formatResult(result);\n    return formattedResult;\n  }"
        },
        {
          "type": "function",
          "name": "remove",
          "label": "remove",
          "start_line": 1,
          "end_line": 323,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "entityOrEntities = parameter0: Entity extends ObjectLiteral|Entity[]\noptions = parameter1: RemoveOptions\nentityManager = parameter2: EntityManager\nthis = this: @ts_files/192.ts: WorkspaceRepository\n%0 = this.<@ts_files/192.ts: WorkspaceRepository.manager>\nmanager = entityManager || %0\n%1 = instanceinvoke this.<@ts_files/192.ts: WorkspaceRepository.formatData(T)>(entityOrEntities)\nformattedEntityOrEntities = await %1\n%2 = this.<@ts_files/192.ts: WorkspaceRepository.target>\n%3 = instanceinvoke manager.<@%unk/%unk: .remove()>(%2, formattedEntityOrEntities, options)\nresult = await %3\n%4 = instanceinvoke this.<@ts_files/192.ts: WorkspaceRepository.formatResult(T, ObjectMetadataItemWithFieldMaps)>(result)\nformattedResult = await %4\nreturn formattedResult",
              "start_line": 1,
              "end_line": 323,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "override async remove(\n    entityOrEntities: Entity | Entity[],\n    options?: RemoveOptions,\n    entityManager?: EntityManager,\n  ): Promise<Entity | Entity[]> {\n    const manager = entityManager || this.manager;\n    const formattedEntityOrEntities = await this.formatData(entityOrEntities);\n    const result = await manager.remove(\n      this.target,\n      formattedEntityOrEntities,\n      options,\n    );\n    const formattedResult = await this.formatResult(result);\n    return formattedResult;\n  }"
        },
        {
          "type": "function",
          "name": "delete",
          "label": "delete",
          "start_line": 1,
          "end_line": 197,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "criteria = parameter0: string|string[]|number|number[]|Date|Date[]|ObjectId|ObjectId[]|FindOptionsWhere<Entity extends ObjectLiteral>\nentityManager = parameter1: EntityManager\nthis = this: @ts_files/192.ts: WorkspaceRepository\n%0 = this.<@ts_files/192.ts: WorkspaceRepository.manager>\nmanager = entityManager || %0\n%1 = typeof criteria === 'object'\n%2 = %1 && undefined\nif %2 != false",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%3 = instanceinvoke this.<@ts_files/192.ts: WorkspaceRepository.transformOptions(T extends FindManyOptions<Entity>|FindOneOptions<Entity>|undefined)>(criteria)\ncriteria = await %3",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "%4 = this.<@ts_files/192.ts: WorkspaceRepository.target>\n%5 = instanceinvoke manager.<@%unk/%unk: .delete()>(%4, criteria)\nreturn %5",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": []
                    }
                  ]
                },
                {
                  "type": "blockRef",
                  "label": "(RepeatedBlock)"
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "override async delete(\n    criteria:\n      | string\n      | string[]\n      | number\n      | number[]\n      | Date\n      | Date[]\n      | ObjectId\n      | ObjectId[]\n      | FindOptionsWhere<Entity>,\n    entityManager?: EntityManager,\n  ): Promise<DeleteResult> {\n    const manager = entityManager || this.manager;\n    if (typeof criteria === 'object' && 'where' in criteria) {\n      criteria = await this.transformOptions(criteria);\n    }\n    return manager.delete(this.target, criteria);\n  }"
        },
        {
          "type": "function",
          "name": "softRemove",
          "label": "softRemove",
          "start_line": 1,
          "end_line": 236,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "entityOrEntities = parameter0: T extends DeepPartial<Entity>|T[]\noptions = parameter1: SaveOptions\nentityManager = parameter2: EntityManager\nthis = this: @ts_files/192.ts: WorkspaceRepository\n%0 = this.<@ts_files/192.ts: WorkspaceRepository.manager>\nmanager = entityManager || %0\n%1 = instanceinvoke this.<@ts_files/192.ts: WorkspaceRepository.formatData(T)>(entityOrEntities)\nformattedEntityOrEntities = await %1\nresult = undefined\n%2 = instanceinvoke Array.<@%unk/%unk: .isArray()>(formattedEntityOrEntities)\nif %2 != 0",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%3 = this.<@ts_files/192.ts: WorkspaceRepository.target>\n%4 = instanceinvoke manager.<@%unk/%unk: .softRemove()>(%3, formattedEntityOrEntities, options)\nresult = await %4",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "%7 = instanceinvoke this.<@ts_files/192.ts: WorkspaceRepository.formatResult(T, ObjectMetadataItemWithFieldMaps)>(result)\nformattedResult = await %7\nreturn formattedResult",
                      "start_line": 1,
                      "end_line": 323,
                      "successors": []
                    }
                  ]
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%5 = this.<@ts_files/192.ts: WorkspaceRepository.target>\n%6 = instanceinvoke manager.<@%unk/%unk: .softRemove()>(%5, formattedEntityOrEntities, options)\nresult = await %6",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "blockRef",
                      "label": "(RepeatedBlock)"
                    }
                  ]
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "override async softRemove<T extends DeepPartial<Entity>>(\n    entityOrEntities: T | T[],\n    options?: SaveOptions,\n    entityManager?: EntityManager,\n  ): Promise<T | T[]> {\n    const manager = entityManager || this.manager;\n    const formattedEntityOrEntities = await this.formatData(entityOrEntities);\n    let result: T | T[];\n    // Needed becasuse save method has multiple signature, otherwise we will need to do a type assertion\n    if (Array.isArray(formattedEntityOrEntities)) {\n      result = await manager.softRemove(\n        this.target,\n        formattedEntityOrEntities,\n        options,\n      );\n    } else {\n      result = await manager.softRemove(\n        this.target,\n        formattedEntityOrEntities,\n        options,\n      );\n    }\n    const formattedResult = await this.formatResult(result);\n    return formattedResult;\n  }"
        },
        {
          "type": "function",
          "name": "softDelete",
          "label": "softDelete",
          "start_line": 1,
          "end_line": 261,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "criteria = parameter0: string|string[]|number|number[]|Date|Date[]|ObjectId|ObjectId[]|FindOptionsWhere<Entity extends ObjectLiteral>\nentityManager = parameter1: EntityManager\nthis = this: @ts_files/192.ts: WorkspaceRepository\n%0 = this.<@ts_files/192.ts: WorkspaceRepository.manager>\nmanager = entityManager || %0\n%1 = typeof criteria === 'object'\n%2 = %1 && undefined\nif %2 != false",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%3 = instanceinvoke this.<@ts_files/192.ts: WorkspaceRepository.transformOptions(T extends FindManyOptions<Entity>|FindOneOptions<Entity>|undefined)>(criteria)\ncriteria = await %3",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "%4 = this.<@ts_files/192.ts: WorkspaceRepository.target>\n%5 = instanceinvoke manager.<@%unk/%unk: .softDelete()>(%4, criteria)\nreturn %5",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": []
                    }
                  ]
                },
                {
                  "type": "blockRef",
                  "label": "(RepeatedBlock)"
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "override async softDelete(\n    criteria:\n      | string\n      | string[]\n      | number\n      | number[]\n      | Date\n      | Date[]\n      | ObjectId\n      | ObjectId[]\n      | FindOptionsWhere<Entity>,\n    entityManager?: EntityManager,\n  ): Promise<UpdateResult> {\n    const manager = entityManager || this.manager;\n    if (typeof criteria === 'object' && 'where' in criteria) {\n      criteria = await this.transformOptions(criteria);\n    }\n    return manager.softDelete(this.target, criteria);\n  }"
        },
        {
          "type": "function",
          "name": "recover",
          "label": "recover",
          "start_line": 1,
          "end_line": 300,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "entityOrEntities = parameter0: T extends DeepPartial<Entity>|T[]\noptions = parameter1: SaveOptions\nentityManager = parameter2: EntityManager\nthis = this: @ts_files/192.ts: WorkspaceRepository\n%0 = this.<@ts_files/192.ts: WorkspaceRepository.manager>\nmanager = entityManager || %0\n%1 = instanceinvoke this.<@ts_files/192.ts: WorkspaceRepository.formatData(T)>(entityOrEntities)\nformattedEntityOrEntities = await %1\nresult = undefined\n%2 = instanceinvoke Array.<@%unk/%unk: .isArray()>(formattedEntityOrEntities)\nif %2 != 0",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%3 = this.<@ts_files/192.ts: WorkspaceRepository.target>\n%4 = instanceinvoke manager.<@%unk/%unk: .recover()>(%3, formattedEntityOrEntities, options)\nresult = await %4",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "%7 = instanceinvoke this.<@ts_files/192.ts: WorkspaceRepository.formatResult(T, ObjectMetadataItemWithFieldMaps)>(result)\nformattedResult = await %7\nreturn formattedResult",
                      "start_line": 1,
                      "end_line": 323,
                      "successors": []
                    }
                  ]
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%5 = this.<@ts_files/192.ts: WorkspaceRepository.target>\n%6 = instanceinvoke manager.<@%unk/%unk: .recover()>(%5, formattedEntityOrEntities, options)\nresult = await %6",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "blockRef",
                      "label": "(RepeatedBlock)"
                    }
                  ]
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "override async recover<T extends DeepPartial<Entity>>(\n    entityOrEntities: T | T[],\n    options?: SaveOptions,\n    entityManager?: EntityManager,\n  ): Promise<T | T[]> {\n    const manager = entityManager || this.manager;\n    const formattedEntityOrEntities = await this.formatData(entityOrEntities);\n    let result: T | T[];\n    // Needed becasuse save method has multiple signature, otherwise we will need to do a type assertion\n    if (Array.isArray(formattedEntityOrEntities)) {\n      result = await manager.recover(\n        this.target,\n        formattedEntityOrEntities,\n        options,\n      );\n    } else {\n      result = await manager.recover(\n        this.target,\n        formattedEntityOrEntities,\n        options,\n      );\n    }\n    const formattedResult = await this.formatResult(result);\n    return formattedResult;\n  }"
        },
        {
          "type": "function",
          "name": "restore",
          "label": "restore",
          "start_line": 1,
          "end_line": 325,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "criteria = parameter0: string|string[]|number|number[]|Date|Date[]|ObjectId|ObjectId[]|FindOptionsWhere<Entity extends ObjectLiteral>\nentityManager = parameter1: EntityManager\nthis = this: @ts_files/192.ts: WorkspaceRepository\n%0 = this.<@ts_files/192.ts: WorkspaceRepository.manager>\nmanager = entityManager || %0\n%1 = typeof criteria === 'object'\n%2 = %1 && undefined\nif %2 != false",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%3 = instanceinvoke this.<@ts_files/192.ts: WorkspaceRepository.transformOptions(T extends FindManyOptions<Entity>|FindOneOptions<Entity>|undefined)>(criteria)\ncriteria = await %3",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "%4 = this.<@ts_files/192.ts: WorkspaceRepository.target>\n%5 = instanceinvoke manager.<@%unk/%unk: .restore()>(%4, criteria)\nreturn %5",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": []
                    }
                  ]
                },
                {
                  "type": "blockRef",
                  "label": "(RepeatedBlock)"
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "override async restore(\n    criteria:\n      | string\n      | string[]\n      | number\n      | number[]\n      | Date\n      | Date[]\n      | ObjectId\n      | ObjectId[]\n      | FindOptionsWhere<Entity>,\n    entityManager?: EntityManager,\n  ): Promise<UpdateResult> {\n    const manager = entityManager || this.manager;\n    if (typeof criteria === 'object' && 'where' in criteria) {\n      criteria = await this.transformOptions(criteria);\n    }\n    return manager.restore(this.target, criteria);\n  }"
        },
        {
          "type": "function",
          "name": "insert",
          "label": "insert",
          "start_line": 1,
          "end_line": 344,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "entity = parameter0: QueryDeepPartialEntity<Entity extends ObjectLiteral>|QueryDeepPartialEntity<Entity>[]\nentityManager = parameter1: EntityManager\nthis = this: @ts_files/192.ts: WorkspaceRepository\n%0 = this.<@ts_files/192.ts: WorkspaceRepository.manager>\nmanager = entityManager || %0\n%1 = instanceinvoke this.<@ts_files/192.ts: WorkspaceRepository.formatData(T)>(entity)\nformatedEntity = await %1\n%2 = this.<@ts_files/192.ts: WorkspaceRepository.target>\n%3 = instanceinvoke manager.<@%unk/%unk: .insert()>(%2, formatedEntity)\nresult = await %3\n%4 = result.<@%unk/%unk: .generatedMaps>\n%5 = instanceinvoke this.<@ts_files/192.ts: WorkspaceRepository.formatResult(T, ObjectMetadataItemWithFieldMaps)>(%4)\nformattedResult = await %5\n%6 = new @ts_files/192.ts: %AC$WorkspaceRepository$insert$4\ninstanceinvoke %6.<@ts_files/192.ts: %AC$WorkspaceRepository$insert$4.constructor()>()\nreturn %6",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "override async insert(\n    entity: QueryDeepPartialEntity<Entity> | QueryDeepPartialEntity<Entity>[],\n    entityManager?: EntityManager,\n  ): Promise<InsertResult> {\n    const manager = entityManager || this.manager;\n    const formatedEntity = await this.formatData(entity);\n    const result = await manager.insert(this.target, formatedEntity);\n    const formattedResult = await this.formatResult(result.generatedMaps);\n    return {\n      raw: result.raw,\n      generatedMaps: formattedResult,\n      identifiers: result.identifiers,\n    };\n  }"
        },
        {
          "type": "function",
          "name": "update",
          "label": "update",
          "start_line": 1,
          "end_line": 358,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "criteria = parameter0: string|string[]|number|number[]|Date|Date[]|ObjectId|ObjectId[]|FindOptionsWhere<Entity extends ObjectLiteral>\npartialEntity = parameter1: QueryDeepPartialEntity<Entity extends ObjectLiteral>\nentityManager = parameter2: EntityManager\nthis = this: @ts_files/192.ts: WorkspaceRepository\n%0 = this.<@ts_files/192.ts: WorkspaceRepository.manager>\nmanager = entityManager || %0\n%1 = typeof criteria === 'object'\n%2 = %1 && undefined\nif %2 != false",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%3 = instanceinvoke this.<@ts_files/192.ts: WorkspaceRepository.transformOptions(T extends FindManyOptions<Entity>|FindOneOptions<Entity>|undefined)>(criteria)\ncriteria = await %3",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "%4 = this.<@ts_files/192.ts: WorkspaceRepository.target>\n%5 = instanceinvoke manager.<@%unk/%unk: .update()>(%4, criteria, partialEntity)\nreturn %5",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": []
                    }
                  ]
                },
                {
                  "type": "blockRef",
                  "label": "(RepeatedBlock)"
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "override async update(\n    criteria:\n      | string\n      | string[]\n      | number\n      | number[]\n      | Date\n      | Date[]\n      | ObjectId\n      | ObjectId[]\n      | FindOptionsWhere<Entity>,\n    partialEntity: QueryDeepPartialEntity<Entity>,\n    entityManager?: EntityManager,\n  ): Promise<UpdateResult> {\n    const manager = entityManager || this.manager;\n    if (typeof criteria === 'object' && 'where' in criteria) {\n      criteria = await this.transformOptions(criteria);\n    }\n    return manager.update(this.target, criteria, partialEntity);\n  }"
        },
        {
          "type": "function",
          "name": "upsert",
          "label": "upsert",
          "start_line": 1,
          "end_line": 378,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "entityOrEntities = parameter0: QueryDeepPartialEntity<Entity extends ObjectLiteral>|QueryDeepPartialEntity<Entity>[]\nconflictPathsOrOptions = parameter1: string[]|UpsertOptions<Entity extends ObjectLiteral>\nentityManager = parameter2: EntityManager\nthis = this: @ts_files/192.ts: WorkspaceRepository\n%0 = this.<@ts_files/192.ts: WorkspaceRepository.manager>\nmanager = entityManager || %0\n%1 = instanceinvoke this.<@ts_files/192.ts: WorkspaceRepository.formatData(T)>(entityOrEntities)\nformattedEntityOrEntities = await %1\n%2 = this.<@ts_files/192.ts: WorkspaceRepository.target>\n%3 = instanceinvoke manager.<@%unk/%unk: .upsert()>(%2, formattedEntityOrEntities, conflictPathsOrOptions)\nresult = await %3\n%4 = result.<@%unk/%unk: .generatedMaps>\n%5 = instanceinvoke this.<@ts_files/192.ts: WorkspaceRepository.formatResult(T, ObjectMetadataItemWithFieldMaps)>(%4)\nformattedResult = await %5\n%6 = new @ts_files/192.ts: %AC$WorkspaceRepository$upsert$5\ninstanceinvoke %6.<@ts_files/192.ts: %AC$WorkspaceRepository$upsert$5.constructor()>()\nreturn %6",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "override async upsert(\n    entityOrEntities:\n      | QueryDeepPartialEntity<Entity>\n      | QueryDeepPartialEntity<Entity>[],\n    conflictPathsOrOptions: string[] | UpsertOptions<Entity>,\n    entityManager?: EntityManager,\n  ): Promise<InsertResult> {\n    const manager = entityManager || this.manager;\n    const formattedEntityOrEntities = await this.formatData(entityOrEntities);\n    const result = await manager.upsert(\n      this.target,\n      formattedEntityOrEntities,\n      conflictPathsOrOptions,\n    );\n    const formattedResult = await this.formatResult(result.generatedMaps);\n    return {\n      raw: result.raw,\n      generatedMaps: formattedResult,\n      identifiers: result.identifiers,\n    };\n  }"
        },
        {
          "type": "function",
          "name": "exists",
          "label": "exists",
          "start_line": 1,
          "end_line": 399,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "options = parameter0: FindManyOptions<Entity extends ObjectLiteral>\nentityManager = parameter1: EntityManager\nthis = this: @ts_files/192.ts: WorkspaceRepository\n%0 = this.<@ts_files/192.ts: WorkspaceRepository.manager>\nmanager = entityManager || %0\n%1 = instanceinvoke this.<@ts_files/192.ts: WorkspaceRepository.transformOptions(T extends FindManyOptions<Entity>|FindOneOptions<Entity>|undefined)>(options)\ncomputedOptions = await %1\n%2 = this.<@ts_files/192.ts: WorkspaceRepository.target>\n%3 = instanceinvoke manager.<@%unk/%unk: .exists()>(%2, computedOptions)\nreturn %3",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "override async exists(\n    options?: FindManyOptions<Entity>,\n    entityManager?: EntityManager,\n  ): Promise<boolean> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions(options);\n    return manager.exists(this.target, computedOptions);\n  }"
        },
        {
          "type": "function",
          "name": "existsBy",
          "label": "existsBy",
          "start_line": 1,
          "end_line": 407,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "where = parameter0: FindOptionsWhere<Entity extends ObjectLiteral>|FindOptionsWhere<Entity>[]\nentityManager = parameter1: EntityManager\nthis = this: @ts_files/192.ts: WorkspaceRepository\n%0 = this.<@ts_files/192.ts: WorkspaceRepository.manager>\nmanager = entityManager || %0\n%1 = new @ts_files/192.ts: %AC$WorkspaceRepository$existsBy$6\ninstanceinvoke %1.<@ts_files/192.ts: %AC$WorkspaceRepository$existsBy$6.constructor()>()\n%2 = instanceinvoke this.<@ts_files/192.ts: WorkspaceRepository.transformOptions(T extends FindManyOptions<Entity>|FindOneOptions<Entity>|undefined)>(%1)\ncomputedOptions = await %2\n%3 = this.<@ts_files/192.ts: WorkspaceRepository.target>\n%4 = computedOptions.<@%unk/%unk: .where>\n%5 = instanceinvoke manager.<@%unk/%unk: .existsBy()>(%3, %4)\nreturn %5",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "override async existsBy(\n    where: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    entityManager?: EntityManager,\n  ): Promise<boolean> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions({ where });\n    return manager.existsBy(this.target, computedOptions.where);\n  }"
        },
        {
          "type": "function",
          "name": "count",
          "label": "count",
          "start_line": 1,
          "end_line": 415,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "options = parameter0: FindManyOptions<Entity extends ObjectLiteral>\nentityManager = parameter1: EntityManager\nthis = this: @ts_files/192.ts: WorkspaceRepository\n%0 = this.<@ts_files/192.ts: WorkspaceRepository.manager>\nmanager = entityManager || %0\n%1 = instanceinvoke this.<@ts_files/192.ts: WorkspaceRepository.transformOptions(T extends FindManyOptions<Entity>|FindOneOptions<Entity>|undefined)>(options)\ncomputedOptions = await %1\n%2 = this.<@ts_files/192.ts: WorkspaceRepository.target>\n%3 = instanceinvoke manager.<@%unk/%unk: .count()>(%2, computedOptions)\nreturn %3",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "override async count(\n    options?: FindManyOptions<Entity>,\n    entityManager?: EntityManager,\n  ): Promise<number> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions(options);\n    return manager.count(this.target, computedOptions);\n  }"
        },
        {
          "type": "function",
          "name": "countBy",
          "label": "countBy",
          "start_line": 1,
          "end_line": 423,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "where = parameter0: FindOptionsWhere<Entity extends ObjectLiteral>|FindOptionsWhere<Entity>[]\nentityManager = parameter1: EntityManager\nthis = this: @ts_files/192.ts: WorkspaceRepository\n%0 = this.<@ts_files/192.ts: WorkspaceRepository.manager>\nmanager = entityManager || %0\n%1 = new @ts_files/192.ts: %AC$WorkspaceRepository$countBy$7\ninstanceinvoke %1.<@ts_files/192.ts: %AC$WorkspaceRepository$countBy$7.constructor()>()\n%2 = instanceinvoke this.<@ts_files/192.ts: WorkspaceRepository.transformOptions(T extends FindManyOptions<Entity>|FindOneOptions<Entity>|undefined)>(%1)\ncomputedOptions = await %2\n%3 = this.<@ts_files/192.ts: WorkspaceRepository.target>\n%4 = computedOptions.<@%unk/%unk: .where>\n%5 = instanceinvoke manager.<@%unk/%unk: .countBy()>(%3, %4)\nreturn %5",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "override async countBy(\n    where: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    entityManager?: EntityManager,\n  ): Promise<number> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions({ where });\n    return manager.countBy(this.target, computedOptions.where);\n  }"
        },
        {
          "type": "function",
          "name": "sum",
          "label": "sum",
          "start_line": 1,
          "end_line": 431,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "columnName = parameter0: PickKeysByType<Entity extends ObjectLiteral,number>\nwhere = parameter1: FindOptionsWhere<Entity extends ObjectLiteral>|FindOptionsWhere<Entity>[]\nentityManager = parameter2: EntityManager\nthis = this: @ts_files/192.ts: WorkspaceRepository\n%0 = this.<@ts_files/192.ts: WorkspaceRepository.manager>\nmanager = entityManager || %0\n%1 = new @ts_files/192.ts: %AC$WorkspaceRepository$sum$8\ninstanceinvoke %1.<@ts_files/192.ts: %AC$WorkspaceRepository$sum$8.constructor()>()\n%2 = instanceinvoke this.<@ts_files/192.ts: WorkspaceRepository.transformOptions(T extends FindManyOptions<Entity>|FindOneOptions<Entity>|undefined)>(%1)\ncomputedOptions = await %2\n%3 = this.<@ts_files/192.ts: WorkspaceRepository.target>\n%4 = computedOptions.<@%unk/%unk: .where>\n%5 = instanceinvoke manager.<@%unk/%unk: .sum()>(%3, columnName, %4)\nreturn %5",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "override async sum(\n    columnName: PickKeysByType<Entity, number>,\n    where?: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    entityManager?: EntityManager,\n  ): Promise<number | null> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions({ where });\n    return manager.sum(this.target, columnName, computedOptions.where);\n  }"
        },
        {
          "type": "function",
          "name": "average",
          "label": "average",
          "start_line": 1,
          "end_line": 440,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "columnName = parameter0: PickKeysByType<Entity extends ObjectLiteral,number>\nwhere = parameter1: FindOptionsWhere<Entity extends ObjectLiteral>|FindOptionsWhere<Entity>[]\nentityManager = parameter2: EntityManager\nthis = this: @ts_files/192.ts: WorkspaceRepository\n%0 = this.<@ts_files/192.ts: WorkspaceRepository.manager>\nmanager = entityManager || %0\n%1 = new @ts_files/192.ts: %AC$WorkspaceRepository$average$9\ninstanceinvoke %1.<@ts_files/192.ts: %AC$WorkspaceRepository$average$9.constructor()>()\n%2 = instanceinvoke this.<@ts_files/192.ts: WorkspaceRepository.transformOptions(T extends FindManyOptions<Entity>|FindOneOptions<Entity>|undefined)>(%1)\ncomputedOptions = await %2\n%3 = this.<@ts_files/192.ts: WorkspaceRepository.target>\n%4 = computedOptions.<@%unk/%unk: .where>\n%5 = instanceinvoke manager.<@%unk/%unk: .average()>(%3, columnName, %4)\nreturn %5",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "override async average(\n    columnName: PickKeysByType<Entity, number>,\n    where?: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    entityManager?: EntityManager,\n  ): Promise<number | null> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions({ where });\n    return manager.average(this.target, columnName, computedOptions.where);\n  }"
        },
        {
          "type": "function",
          "name": "minimum",
          "label": "minimum",
          "start_line": 1,
          "end_line": 449,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "columnName = parameter0: PickKeysByType<Entity extends ObjectLiteral,number>\nwhere = parameter1: FindOptionsWhere<Entity extends ObjectLiteral>|FindOptionsWhere<Entity>[]\nentityManager = parameter2: EntityManager\nthis = this: @ts_files/192.ts: WorkspaceRepository\n%0 = this.<@ts_files/192.ts: WorkspaceRepository.manager>\nmanager = entityManager || %0\n%1 = new @ts_files/192.ts: %AC$WorkspaceRepository$minimum$10\ninstanceinvoke %1.<@ts_files/192.ts: %AC$WorkspaceRepository$minimum$10.constructor()>()\n%2 = instanceinvoke this.<@ts_files/192.ts: WorkspaceRepository.transformOptions(T extends FindManyOptions<Entity>|FindOneOptions<Entity>|undefined)>(%1)\ncomputedOptions = await %2\n%3 = this.<@ts_files/192.ts: WorkspaceRepository.target>\n%4 = computedOptions.<@%unk/%unk: .where>\n%5 = instanceinvoke manager.<@%unk/%unk: .minimum()>(%3, columnName, %4)\nreturn %5",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "override async minimum(\n    columnName: PickKeysByType<Entity, number>,\n    where?: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    entityManager?: EntityManager,\n  ): Promise<number | null> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions({ where });\n    return manager.minimum(this.target, columnName, computedOptions.where);\n  }"
        },
        {
          "type": "function",
          "name": "maximum",
          "label": "maximum",
          "start_line": 1,
          "end_line": 458,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "columnName = parameter0: PickKeysByType<Entity extends ObjectLiteral,number>\nwhere = parameter1: FindOptionsWhere<Entity extends ObjectLiteral>|FindOptionsWhere<Entity>[]\nentityManager = parameter2: EntityManager\nthis = this: @ts_files/192.ts: WorkspaceRepository\n%0 = this.<@ts_files/192.ts: WorkspaceRepository.manager>\nmanager = entityManager || %0\n%1 = new @ts_files/192.ts: %AC$WorkspaceRepository$maximum$11\ninstanceinvoke %1.<@ts_files/192.ts: %AC$WorkspaceRepository$maximum$11.constructor()>()\n%2 = instanceinvoke this.<@ts_files/192.ts: WorkspaceRepository.transformOptions(T extends FindManyOptions<Entity>|FindOneOptions<Entity>|undefined)>(%1)\ncomputedOptions = await %2\n%3 = this.<@ts_files/192.ts: WorkspaceRepository.target>\n%4 = computedOptions.<@%unk/%unk: .where>\n%5 = instanceinvoke manager.<@%unk/%unk: .maximum()>(%3, columnName, %4)\nreturn %5",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "override async maximum(\n    columnName: PickKeysByType<Entity, number>,\n    where?: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    entityManager?: EntityManager,\n  ): Promise<number | null> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions({ where });\n    return manager.maximum(this.target, columnName, computedOptions.where);\n  }"
        },
        {
          "type": "function",
          "name": "increment",
          "label": "increment",
          "start_line": 1,
          "end_line": 467,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "conditions = parameter0: FindOptionsWhere<Entity extends ObjectLiteral>\npropertyPath = parameter1: string\nvalue = parameter2: number|string\nentityManager = parameter3: EntityManager\nthis = this: @ts_files/192.ts: WorkspaceRepository\n%0 = this.<@ts_files/192.ts: WorkspaceRepository.manager>\nmanager = entityManager || %0\n%1 = new @ts_files/192.ts: %AC$WorkspaceRepository$increment$12\ninstanceinvoke %1.<@ts_files/192.ts: %AC$WorkspaceRepository$increment$12.constructor()>()\n%2 = instanceinvoke this.<@ts_files/192.ts: WorkspaceRepository.transformOptions(T extends FindManyOptions<Entity>|FindOneOptions<Entity>|undefined)>(%1)\ncomputedConditions = await %2\n%3 = this.<@ts_files/192.ts: WorkspaceRepository.target>\n%4 = computedConditions.<@%unk/%unk: .where>\n%5 = instanceinvoke manager.<@%unk/%unk: .increment()>(%3, %4, propertyPath, value)\nreturn %5",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "override async increment(\n    conditions: FindOptionsWhere<Entity>,\n    propertyPath: string,\n    value: number | string,\n    entityManager?: EntityManager,\n  ): Promise<UpdateResult> {\n    const manager = entityManager || this.manager;\n    const computedConditions = await this.transformOptions({\n      where: conditions,\n    });\n    return manager.increment(\n      this.target,\n      computedConditions.where,\n      propertyPath,\n      value,\n    );\n  }"
        },
        {
          "type": "function",
          "name": "decrement",
          "label": "decrement",
          "start_line": 1,
          "end_line": 484,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "conditions = parameter0: FindOptionsWhere<Entity extends ObjectLiteral>\npropertyPath = parameter1: string\nvalue = parameter2: number|string\nentityManager = parameter3: EntityManager\nthis = this: @ts_files/192.ts: WorkspaceRepository\n%0 = this.<@ts_files/192.ts: WorkspaceRepository.manager>\nmanager = entityManager || %0\n%1 = new @ts_files/192.ts: %AC$WorkspaceRepository$decrement$13\ninstanceinvoke %1.<@ts_files/192.ts: %AC$WorkspaceRepository$decrement$13.constructor()>()\n%2 = instanceinvoke this.<@ts_files/192.ts: WorkspaceRepository.transformOptions(T extends FindManyOptions<Entity>|FindOneOptions<Entity>|undefined)>(%1)\ncomputedConditions = await %2\n%3 = this.<@ts_files/192.ts: WorkspaceRepository.target>\n%4 = computedConditions.<@%unk/%unk: .where>\n%5 = instanceinvoke manager.<@%unk/%unk: .decrement()>(%3, %4, propertyPath, value)\nreturn %5",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "override async decrement(\n    conditions: FindOptionsWhere<Entity>,\n    propertyPath: string,\n    value: number | string,\n    entityManager?: EntityManager,\n  ): Promise<UpdateResult> {\n    const manager = entityManager || this.manager;\n    const computedConditions = await this.transformOptions({\n      where: conditions,\n    });\n    return manager.decrement(\n      this.target,\n      computedConditions.where,\n      propertyPath,\n      value,\n    );\n  }"
        },
        {
          "type": "function",
          "name": "getObjectMetadataFromTarget",
          "label": "getObjectMetadataFromTarget",
          "start_line": 1,
          "end_line": 501,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "%6 = new @%unk/%unk: Error\ninstanceinvoke %6.<@%unk/%unk: Error.constructor()>('Object metadata name is missing')\nthrow %6",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%7 = this.<@ts_files/192.ts: WorkspaceRepository.internalContext>\n%8 = %7.<@%unk/%unk: .objectMetadataMaps>\nobjectMetadata = staticinvoke <@%unk/%unk: .getObjectMetadataMapItemByNameSingular()>(%8, objectMetadataName)\n%9 = !objectMetadata\nif %9 != 0",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "%10 = new @%unk/%unk: Error\n%11 = 'Object metadata for object \"' + objectMetadataName\n%12 = %11 + '\" is missing '\n%13 = this.<@ts_files/192.ts: WorkspaceRepository.internalContext>\n%14 = %13.<@%unk/%unk: .workspaceId>\n%15 = 'in workspace \"' + %14\n%16 = %15 + '\" '\n%17 = %12 + %16\n%18 = this.<@ts_files/192.ts: WorkspaceRepository.internalContext>\n%19 = %18.<@%unk/%unk: .objectMetadataMaps>\n%20 = %19.<@%unk/%unk: .idByNameSingular>\n%21 = instanceinvoke Object.<@%unk/%unk: .keys()>(%20)\n%22 = %21.<@%unk/%unk: .length>\n%23 = 'with object metadata collection length: ' + %22\n%24 = %17 + %23\ninstanceinvoke %10.<@%unk/%unk: Error.constructor()>(%24)\nthrow %10",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "return objectMetadata",
                          "start_line": 527,
                          "end_line": 527,
                          "successors": []
                        }
                      ]
                    },
                    {
                      "type": "blockRef",
                      "label": "(RepeatedBlock)"
                    }
                  ]
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/192.ts: WorkspaceRepository\nif typeof this.<@ts_files/192.ts: WorkspaceRepository.target> === 'string'",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "objectMetadataName = this.<@ts_files/192.ts: WorkspaceRepository.target>",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "%5 = !objectMetadataName\nif %5 != 0",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "blockRef",
                          "label": "(RepeatedBlock)"
                        },
                        {
                          "type": "blockRef",
                          "label": "(RepeatedBlock)"
                        }
                      ]
                    }
                  ]
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%1 = this.<@ts_files/192.ts: WorkspaceRepository.internalContext>\n%2 = %1.<@%unk/%unk: .workspaceId>\n%3 = this.<@ts_files/192.ts: WorkspaceRepository.target>\n%4 = <EntitySchema>%3\nobjectMetadataName = instanceinvoke WorkspaceEntitiesStorage.<@%unk/%unk: .getObjectMetadataName()>(%2, %4)",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "blockRef",
                      "label": "(RepeatedBlock)"
                    }
                  ]
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "private async getObjectMetadataFromTarget() {\n    const objectMetadataName =\n      typeof this.target === 'string'\n        ? this.target\n        : WorkspaceEntitiesStorage.getObjectMetadataName(\n            this.internalContext.workspaceId,\n            this.target as EntitySchema,\n          );\n    if (!objectMetadataName) {\n      throw new Error('Object metadata name is missing');\n    }\n    const objectMetadata = getObjectMetadataMapItemByNameSingular(\n      this.internalContext.objectMetadataMaps,\n      objectMetadataName,\n    );\n    if (!objectMetadata) {\n      throw new Error(\n        `Object metadata for object \"${objectMetadataName}\" is missing ` +\n          `in workspace \"${this.internalContext.workspaceId}\" ` +\n          `with object metadata collection length: ${\n            Object.keys(\n              this.internalContext.objectMetadataMaps.idByNameSingular,\n            ).length\n          }`,\n      );\n    }\n    return objectMetadata;\n  }"
        },
        {
          "type": "function",
          "name": "transformOptions",
          "label": "transformOptions",
          "start_line": 1,
          "end_line": 529,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "options = parameter0: T extends FindManyOptions<Entity>|FindOneOptions<Entity>|undefined\nthis = this: @ts_files/192.ts: WorkspaceRepository\n%0 = !options\nif %0 != 0",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "return options",
                  "start_line": 533,
                  "end_line": 533,
                  "successors": []
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%1 = new @ts_files/192.ts: %AC$WorkspaceRepository$transformOptions$14\ninstanceinvoke %1.<@ts_files/192.ts: %AC$WorkspaceRepository$transformOptions$14.constructor()>()\ntransformedOptions = %1\n%2 = options.<@%unk/%unk: .where>\n%3 = instanceinvoke this.<@ts_files/192.ts: WorkspaceRepository.formatData(T)>(%2)\ntransformedOptions.<@ts_files/192.ts: %AC$WorkspaceRepository$transformOptions$14.where> = await %3\nreturn transformedOptions",
                  "start_line": 1,
                  "end_line": 537,
                  "successors": []
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "private async transformOptions<\n    T extends FindManyOptions<Entity> | FindOneOptions<Entity> | undefined,\n  >(options: T): Promise<T> {\n    if (!options) {\n      return options;\n    }\n    const transformedOptions = { ...options };\n    transformedOptions.where = await this.formatData(options.where);\n    return transformedOptions;\n  }"
        },
        {
          "type": "function",
          "name": "formatData",
          "label": "formatData",
          "start_line": 1,
          "end_line": 539,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "data = parameter0: T\nthis = this: @ts_files/192.ts: WorkspaceRepository\n%0 = instanceinvoke this.<@ts_files/192.ts: WorkspaceRepository.getObjectMetadataFromTarget()>()\nobjectMetadata = await %0\n%1 = staticinvoke <@%unk/%unk: .formatData()>(data, objectMetadata)\n%2 = <T>%1\nreturn %2",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "private async formatData<T>(data: T): Promise<T> {\n    const objectMetadata = await this.getObjectMetadataFromTarget();\n    return formatData(data, objectMetadata) as T;\n  }"
        },
        {
          "type": "function",
          "name": "formatResult",
          "label": "formatResult",
          "start_line": 1,
          "end_line": 543,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "data = parameter0: T\nobjectMetadata = parameter1: ObjectMetadataItemWithFieldMaps\nthis = this: @ts_files/192.ts: WorkspaceRepository\n%0 = instanceinvoke this.<@ts_files/192.ts: WorkspaceRepository.getObjectMetadataFromTarget()>()\nobjectMetadata = objectMetadata ?? await %0\n%1 = this.<@ts_files/192.ts: WorkspaceRepository.internalContext>\nobjectMetadataMaps = %1.<@%unk/%unk: .objectMetadataMaps>\n%2 = staticinvoke <@%unk/%unk: .formatResult()>(data, objectMetadata, objectMetadataMaps)\n%3 = <T>%2\nreturn %3",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "async formatResult<T>(\n    data: T,\n    objectMetadata?: ObjectMetadataItemWithFieldMaps,\n  ): Promise<T> {\n    objectMetadata ??= await this.getObjectMetadataFromTarget();\n    const objectMetadataMaps = this.internalContext.objectMetadataMaps;\n    return formatResult(data, objectMetadata, objectMetadataMaps) as T;\n  }"
        }
      ],
      "classes": [],
      "blocks": [],
      "simplified_code": "export class WorkspaceRepository<\n  Entity extends ObjectLiteral,\n> extends Repository<Entity> {\n  private readonly internalContext: WorkspaceInternalContext;\n  constructor(\n    internalContext: WorkspaceInternalContext,\n    target: EntityTarget<Entity>,\n    manager: EntityManager,\n    queryRunner?: QueryRunner,\n  ) {\n    super(target, manager, queryRunner);\n    this.internalContext = internalContext;\n  }\n  override async find(\n    options?: FindManyOptions<Entity>,\n    entityManager?: EntityManager,\n  ): Promise<Entity[]> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions(options);\n    const result = await manager.find(this.target, computedOptions);\n    const formattedResult = await this.formatResult(result);\n    return formattedResult;\n  }\n  override async findBy(\n    where: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    entityManager?: EntityManager,\n  ): Promise<Entity[]> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions({ where });\n    const result = await manager.findBy(this.target, computedOptions.where);\n    const formattedResult = await this.formatResult(result);\n    return formattedResult;\n  }\n  override async findAndCount(\n    options?: FindManyOptions<Entity>,\n    entityManager?: EntityManager,\n  ): Promise<[Entity[], number]> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions(options);\n    const result = await manager.findAndCount(this.target, computedOptions);\n    const formattedResult = await this.formatResult(result);\n    return formattedResult;\n  }\n  override async findAndCountBy(\n    where: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    entityManager?: EntityManager,\n  ): Promise<[Entity[], number]> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions({ where });\n    const result = await manager.findAndCountBy(\n      this.target,\n      computedOptions.where,\n    );\n    const formattedResult = await this.formatResult(result);\n    return formattedResult;\n  }\n  override async findOne(\n    options: FindOneOptions<Entity>,\n    entityManager?: EntityManager,\n  ): Promise<Entity | null> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions(options);\n    const result = await manager.findOne(this.target, computedOptions);\n    const formattedResult = await this.formatResult(result);\n    return formattedResult;\n  }\n  override async findOneBy(\n    where: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    entityManager?: EntityManager,\n  ): Promise<Entity | null> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions({ where });\n    const result = await manager.findOneBy(this.target, computedOptions.where);\n    const formattedResult = await this.formatResult(result);\n    return formattedResult;\n  }\n  override async findOneOrFail(\n    options: FindOneOptions<Entity>,\n    entityManager?: EntityManager,\n  ): Promise<Entity> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions(options);\n    const result = await manager.findOneOrFail(this.target, computedOptions);\n    const formattedResult = await this.formatResult(result);\n    return formattedResult;\n  }\n  override async findOneByOrFail(\n    where: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    entityManager?: EntityManager,\n  ): Promise<Entity> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions({ where });\n    const result = await manager.findOneByOrFail(\n      this.target,\n      computedOptions.where,\n    );\n    const formattedResult = await this.formatResult(result);\n    return formattedResult;\n  }\n  override save<T extends DeepPartial<Entity>>(\n    entities: T[],\n    options: SaveOptions & { reload: false },\n    entityManager?: EntityManager,\n  ): Promise<T[]>;\n  override save<T extends DeepPartial<Entity>>(\n    entities: T[],\n    options?: SaveOptions,\n    entityManager?: EntityManager,\n  ): Promise<(T & Entity)[]>;\n  override save<T extends DeepPartial<Entity>>(\n    entity: T,\n    options: SaveOptions & { reload: false },\n    entityManager?: EntityManager,\n  ): Promise<T>;\n  override save<T extends DeepPartial<Entity>>(\n    entity: T,\n    options?: SaveOptions,\n    entityManager?: EntityManager,\n  ): Promise<T & Entity>;\n  override async save<T extends DeepPartial<Entity>>(\n    entityOrEntities: T | T[],\n    options?: SaveOptions,\n    entityManager?: EntityManager,\n  ): Promise<T | T[]> {\n    const manager = entityManager || this.manager;\n    const formattedEntityOrEntities = await this.formatData(entityOrEntities);\n    let result: T | T[];\n    // Needed becasuse save method has multiple signature, otherwise we will need to do a type assertion\n    if (Array.isArray(formattedEntityOrEntities)) {\n      result = await manager.save(\n        this.target,\n        formattedEntityOrEntities,\n        options,\n      );\n    } else {\n      result = await manager.save(\n        this.target,\n        formattedEntityOrEntities,\n        options,\n      );\n    }\n    const formattedResult = await this.formatResult(result);\n    return formattedResult;\n  }\n  override remove(\n    entities: Entity[],\n    options?: RemoveOptions,\n    entityManager?: EntityManager,\n  ): Promise<Entity[]>;\n  override remove(\n    entity: Entity,\n    options?: RemoveOptions,\n    entityManager?: EntityManager,\n  ): Promise<Entity>;\n  override async remove(\n    entityOrEntities: Entity | Entity[],\n    options?: RemoveOptions,\n    entityManager?: EntityManager,\n  ): Promise<Entity | Entity[]> {\n    const manager = entityManager || this.manager;\n    const formattedEntityOrEntities = await this.formatData(entityOrEntities);\n    const result = await manager.remove(\n      this.target,\n      formattedEntityOrEntities,\n      options,\n    );\n    const formattedResult = await this.formatResult(result);\n    return formattedResult;\n  }\n  override async delete(\n    criteria:\n      | string\n      | string[]\n      | number\n      | number[]\n      | Date\n      | Date[]\n      | ObjectId\n      | ObjectId[]\n      | FindOptionsWhere<Entity>,\n    entityManager?: EntityManager,\n  ): Promise<DeleteResult> {\n    const manager = entityManager || this.manager;\n    if (typeof criteria === 'object' && 'where' in criteria) {\n      criteria = await this.transformOptions(criteria);\n    }\n    return manager.delete(this.target, criteria);\n  }\n  override softRemove<T extends DeepPartial<Entity>>(\n    entities: T[],\n    options: SaveOptions & { reload: false },\n    entityManager?: EntityManager,\n  ): Promise<T[]>;\n  override softRemove<T extends DeepPartial<Entity>>(\n    entities: T[],\n    options?: SaveOptions,\n    entityManager?: EntityManager,\n  ): Promise<(T & Entity)[]>;\n  override softRemove<T extends DeepPartial<Entity>>(\n    entity: T,\n    options: SaveOptions & { reload: false },\n    entityManager?: EntityManager,\n  ): Promise<T>;\n  override softRemove<T extends DeepPartial<Entity>>(\n    entity: T,\n    options?: SaveOptions,\n    entityManager?: EntityManager,\n  ): Promise<T & Entity>;\n  override async softRemove<T extends DeepPartial<Entity>>(\n    entityOrEntities: T | T[],\n    options?: SaveOptions,\n    entityManager?: EntityManager,\n  ): Promise<T | T[]> {\n    const manager = entityManager || this.manager;\n    const formattedEntityOrEntities = await this.formatData(entityOrEntities);\n    let result: T | T[];\n    // Needed becasuse save method has multiple signature, otherwise we will need to do a type assertion\n    if (Array.isArray(formattedEntityOrEntities)) {\n      result = await manager.softRemove(\n        this.target,\n        formattedEntityOrEntities,\n        options,\n      );\n    } else {\n      result = await manager.softRemove(\n        this.target,\n        formattedEntityOrEntities,\n        options,\n      );\n    }\n    const formattedResult = await this.formatResult(result);\n    return formattedResult;\n  }\n  override async softDelete(\n    criteria:\n      | string\n      | string[]\n      | number\n      | number[]\n      | Date\n      | Date[]\n      | ObjectId\n      | ObjectId[]\n      | FindOptionsWhere<Entity>,\n    entityManager?: EntityManager,\n  ): Promise<UpdateResult> {\n    const manager = entityManager || this.manager;\n    if (typeof criteria === 'object' && 'where' in criteria) {\n      criteria = await this.transformOptions(criteria);\n    }\n    return manager.softDelete(this.target, criteria);\n  }\n  override recover<T extends DeepPartial<Entity>>(\n    entities: T[],\n    options: SaveOptions & { reload: false },\n    entityManager?: EntityManager,\n  ): Promise<T[]>;\n  override recover<T extends DeepPartial<Entity>>(\n    entities: T[],\n    options?: SaveOptions,\n    entityManager?: EntityManager,\n  ): Promise<(T & Entity)[]>;\n  override recover<T extends DeepPartial<Entity>>(\n    entity: T,\n    options: SaveOptions & { reload: false },\n    entityManager?: EntityManager,\n  ): Promise<T>;\n  override recover<T extends DeepPartial<Entity>>(\n    entity: T,\n    options?: SaveOptions,\n    entityManager?: EntityManager,\n  ): Promise<T & Entity>;\n  override async recover<T extends DeepPartial<Entity>>(\n    entityOrEntities: T | T[],\n    options?: SaveOptions,\n    entityManager?: EntityManager,\n  ): Promise<T | T[]> {\n    const manager = entityManager || this.manager;\n    const formattedEntityOrEntities = await this.formatData(entityOrEntities);\n    let result: T | T[];\n    // Needed becasuse save method has multiple signature, otherwise we will need to do a type assertion\n    if (Array.isArray(formattedEntityOrEntities)) {\n      result = await manager.recover(\n        this.target,\n        formattedEntityOrEntities,\n        options,\n      );\n    } else {\n      result = await manager.recover(\n        this.target,\n        formattedEntityOrEntities,\n        options,\n      );\n    }\n    const formattedResult = await this.formatResult(result);\n    return formattedResult;\n  }\n  override async restore(\n    criteria:\n      | string\n      | string[]\n      | number\n      | number[]\n      | Date\n      | Date[]\n      | ObjectId\n      | ObjectId[]\n      | FindOptionsWhere<Entity>,\n    entityManager?: EntityManager,\n  ): Promise<UpdateResult> {\n    const manager = entityManager || this.manager;\n    if (typeof criteria === 'object' && 'where' in criteria) {\n      criteria = await this.transformOptions(criteria);\n    }\n    return manager.restore(this.target, criteria);\n  }\n  override async insert(\n    entity: QueryDeepPartialEntity<Entity> | QueryDeepPartialEntity<Entity>[],\n    entityManager?: EntityManager,\n  ): Promise<InsertResult> {\n    const manager = entityManager || this.manager;\n    const formatedEntity = await this.formatData(entity);\n    const result = await manager.insert(this.target, formatedEntity);\n    const formattedResult = await this.formatResult(result.generatedMaps);\n    return {\n      raw: result.raw,\n      generatedMaps: formattedResult,\n      identifiers: result.identifiers,\n    };\n  }\n  override async update(\n    criteria:\n      | string\n      | string[]\n      | number\n      | number[]\n      | Date\n      | Date[]\n      | ObjectId\n      | ObjectId[]\n      | FindOptionsWhere<Entity>,\n    partialEntity: QueryDeepPartialEntity<Entity>,\n    entityManager?: EntityManager,\n  ): Promise<UpdateResult> {\n    const manager = entityManager || this.manager;\n    if (typeof criteria === 'object' && 'where' in criteria) {\n      criteria = await this.transformOptions(criteria);\n    }\n    return manager.update(this.target, criteria, partialEntity);\n  }\n  override async upsert(\n    entityOrEntities:\n      | QueryDeepPartialEntity<Entity>\n      | QueryDeepPartialEntity<Entity>[],\n    conflictPathsOrOptions: string[] | UpsertOptions<Entity>,\n    entityManager?: EntityManager,\n  ): Promise<InsertResult> {\n    const manager = entityManager || this.manager;\n    const formattedEntityOrEntities = await this.formatData(entityOrEntities);\n    const result = await manager.upsert(\n      this.target,\n      formattedEntityOrEntities,\n      conflictPathsOrOptions,\n    );\n    const formattedResult = await this.formatResult(result.generatedMaps);\n    return {\n      raw: result.raw,\n      generatedMaps: formattedResult,\n      identifiers: result.identifiers,\n    };\n  }\n  override async exists(\n    options?: FindManyOptions<Entity>,\n    entityManager?: EntityManager,\n  ): Promise<boolean> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions(options);\n    return manager.exists(this.target, computedOptions);\n  }\n  override async existsBy(\n    where: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    entityManager?: EntityManager,\n  ): Promise<boolean> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions({ where });\n    return manager.existsBy(this.target, computedOptions.where);\n  }\n  override async count(\n    options?: FindManyOptions<Entity>,\n    entityManager?: EntityManager,\n  ): Promise<number> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions(options);\n    return manager.count(this.target, computedOptions);\n  }\n  override async countBy(\n    where: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    entityManager?: EntityManager,\n  ): Promise<number> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions({ where });\n    return manager.countBy(this.target, computedOptions.where);\n  }\n  override async sum(\n    columnName: PickKeysByType<Entity, number>,\n    where?: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    entityManager?: EntityManager,\n  ): Promise<number | null> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions({ where });\n    return manager.sum(this.target, columnName, computedOptions.where);\n  }\n  override async average(\n    columnName: PickKeysByType<Entity, number>,\n    where?: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    entityManager?: EntityManager,\n  ): Promise<number | null> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions({ where });\n    return manager.average(this.target, columnName, computedOptions.where);\n  }\n  override async minimum(\n    columnName: PickKeysByType<Entity, number>,\n    where?: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    entityManager?: EntityManager,\n  ): Promise<number | null> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions({ where });\n    return manager.minimum(this.target, columnName, computedOptions.where);\n  }\n  override async maximum(\n    columnName: PickKeysByType<Entity, number>,\n    where?: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    entityManager?: EntityManager,\n  ): Promise<number | null> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions({ where });\n    return manager.maximum(this.target, columnName, computedOptions.where);\n  }\n  override async increment(\n    conditions: FindOptionsWhere<Entity>,\n    propertyPath: string,\n    value: number | string,\n    entityManager?: EntityManager,\n  ): Promise<UpdateResult> {\n    const manager = entityManager || this.manager;\n    const computedConditions = await this.transformOptions({\n      where: conditions,\n    });\n    return manager.increment(\n      this.target,\n      computedConditions.where,\n      propertyPath,\n      value,\n    );\n  }\n  override async decrement(\n    conditions: FindOptionsWhere<Entity>,\n    propertyPath: string,\n    value: number | string,\n    entityManager?: EntityManager,\n  ): Promise<UpdateResult> {\n    const manager = entityManager || this.manager;\n    const computedConditions = await this.transformOptions({\n      where: conditions,\n    });\n    return manager.decrement(\n      this.target,\n      computedConditions.where,\n      propertyPath,\n      value,\n    );\n  }\n  private async getObjectMetadataFromTarget() {\n    const objectMetadataName =\n      typeof this.target === 'string'\n        ? this.target\n        : WorkspaceEntitiesStorage.getObjectMetadataName(\n            this.internalContext.workspaceId,\n            this.target as EntitySchema,\n          );\n    if (!objectMetadataName) {\n      throw new Error('Object metadata name is missing');\n    }\n    const objectMetadata = getObjectMetadataMapItemByNameSingular(\n      this.internalContext.objectMetadataMaps,\n      objectMetadataName,\n    );\n    if (!objectMetadata) {\n      throw new Error(\n        `Object metadata for object \"${objectMetadataName}\" is missing ` +\n          `in workspace \"${this.internalContext.workspaceId}\" ` +\n          `with object metadata collection length: ${\n            Object.keys(\n              this.internalContext.objectMetadataMaps.idByNameSingular,\n            ).length\n          }`,\n      );\n    }\n    return objectMetadata;\n  }\n  private async transformOptions<\n    T extends FindManyOptions<Entity> | FindOneOptions<Entity> | undefined,\n  >(options: T): Promise<T> {\n    if (!options) {\n      return options;\n    }\n    const transformedOptions = { ...options };\n    transformedOptions.where = await this.formatData(options.where);\n    return transformedOptions;\n  }\n  private async formatData<T>(data: T): Promise<T> {\n    const objectMetadata = await this.getObjectMetadataFromTarget();\n    return formatData(data, objectMetadata) as T;\n  }\n  async formatResult<T>(\n    data: T,\n    objectMetadata?: ObjectMetadataItemWithFieldMaps,\n  ): Promise<T> {\n    objectMetadata ??= await this.getObjectMetadataFromTarget();\n    const objectMetadataMaps = this.internalContext.objectMetadataMaps;\n    return formatResult(data, objectMetadata, objectMetadataMaps) as T;\n  }\n}"
    },
    {
      "type": "class",
      "name": "%AC$WorkspaceRepository$findBy$0",
      "label": "%AC$WorkspaceRepository$findBy$0",
      "start_line": 56,
      "end_line": 56,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{ where }"
    },
    {
      "type": "class",
      "name": "%AC$WorkspaceRepository$findAndCountBy$1",
      "label": "%AC$WorkspaceRepository$findAndCountBy$1",
      "start_line": 76,
      "end_line": 76,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{ where }"
    },
    {
      "type": "class",
      "name": "%AC$WorkspaceRepository$findOneBy$2",
      "label": "%AC$WorkspaceRepository$findOneBy$2",
      "start_line": 99,
      "end_line": 99,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{ where }"
    },
    {
      "type": "class",
      "name": "%AC$WorkspaceRepository$findOneByOrFail$3",
      "label": "%AC$WorkspaceRepository$findOneByOrFail$3",
      "start_line": 119,
      "end_line": 119,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{ where }"
    },
    {
      "type": "class",
      "name": "%AC$WorkspaceRepository$insert$4",
      "label": "%AC$WorkspaceRepository$insert$4",
      "start_line": 352,
      "end_line": 352,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n      raw: result.raw,\n      generatedMaps: formattedResult,\n      identifiers: result.identifiers,\n    }"
    },
    {
      "type": "class",
      "name": "%AC$WorkspaceRepository$upsert$5",
      "label": "%AC$WorkspaceRepository$upsert$5",
      "start_line": 393,
      "end_line": 393,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n      raw: result.raw,\n      generatedMaps: formattedResult,\n      identifiers: result.identifiers,\n    }"
    },
    {
      "type": "class",
      "name": "%AC$WorkspaceRepository$existsBy$6",
      "label": "%AC$WorkspaceRepository$existsBy$6",
      "start_line": 412,
      "end_line": 412,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{ where }"
    },
    {
      "type": "class",
      "name": "%AC$WorkspaceRepository$countBy$7",
      "label": "%AC$WorkspaceRepository$countBy$7",
      "start_line": 428,
      "end_line": 428,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{ where }"
    },
    {
      "type": "class",
      "name": "%AC$WorkspaceRepository$sum$8",
      "label": "%AC$WorkspaceRepository$sum$8",
      "start_line": 437,
      "end_line": 437,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{ where }"
    },
    {
      "type": "class",
      "name": "%AC$WorkspaceRepository$average$9",
      "label": "%AC$WorkspaceRepository$average$9",
      "start_line": 446,
      "end_line": 446,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{ where }"
    },
    {
      "type": "class",
      "name": "%AC$WorkspaceRepository$minimum$10",
      "label": "%AC$WorkspaceRepository$minimum$10",
      "start_line": 455,
      "end_line": 455,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{ where }"
    },
    {
      "type": "class",
      "name": "%AC$WorkspaceRepository$maximum$11",
      "label": "%AC$WorkspaceRepository$maximum$11",
      "start_line": 464,
      "end_line": 464,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{ where }"
    },
    {
      "type": "class",
      "name": "%AC$WorkspaceRepository$increment$12",
      "label": "%AC$WorkspaceRepository$increment$12",
      "start_line": 474,
      "end_line": 474,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n      where: conditions,\n    }"
    },
    {
      "type": "class",
      "name": "%AC$WorkspaceRepository$decrement$13",
      "label": "%AC$WorkspaceRepository$decrement$13",
      "start_line": 491,
      "end_line": 491,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{\n      where: conditions,\n    }"
    },
    {
      "type": "class",
      "name": "%AC$WorkspaceRepository$transformOptions$14",
      "label": "%AC$WorkspaceRepository$transformOptions$14",
      "start_line": 535,
      "end_line": 535,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{ ...options }"
    }
  ],
  "functions": [],
  "blocks": [],
  "simplified_code": "import {\n  DeepPartial,\n  DeleteResult,\n  EntityManager,\n  EntitySchema,\n  EntityTarget,\n  FindManyOptions,\n  FindOneOptions,\n  FindOptionsWhere,\n  InsertResult,\n  ObjectId,\n  ObjectLiteral,\n  QueryRunner,\n  RemoveOptions,\n  Repository,\n  SaveOptions,\n  UpdateResult,\n} from 'typeorm';\nimport { PickKeysByType } from 'typeorm/common/PickKeysByType';\nimport { QueryDeepPartialEntity } from 'typeorm/query-builder/QueryPartialEntity';\nimport { UpsertOptions } from 'typeorm/repository/UpsertOptions';\nimport { WorkspaceInternalContext } from 'src/engine/twenty-orm/interfaces/workspace-internal-context.interface';\nimport { ObjectMetadataItemWithFieldMaps } from 'src/engine/metadata-modules/types/object-metadata-item-with-field-maps';\nimport { getObjectMetadataMapItemByNameSingular } from 'src/engine/metadata-modules/utils/get-object-metadata-map-item-by-name-singular.util';\nimport { WorkspaceEntitiesStorage } from 'src/engine/twenty-orm/storage/workspace-entities.storage';\nimport { formatData } from 'src/engine/twenty-orm/utils/format-data.util';\nimport { formatResult } from 'src/engine/twenty-orm/utils/format-result.util';\nexport class WorkspaceRepository<\n  Entity extends ObjectLiteral,\n> extends Repository<Entity> {\n  private readonly internalContext: WorkspaceInternalContext;\n  constructor(\n    internalContext: WorkspaceInternalContext,\n    target: EntityTarget<Entity>,\n    manager: EntityManager,\n    queryRunner?: QueryRunner,\n  ) {\n    super(target, manager, queryRunner);\n    this.internalContext = internalContext;\n  }\n  override async find(\n    options?: FindManyOptions<Entity>,\n    entityManager?: EntityManager,\n  ): Promise<Entity[]> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions(options);\n    const result = await manager.find(this.target, computedOptions);\n    const formattedResult = await this.formatResult(result);\n    return formattedResult;\n  }\n  override async findBy(\n    where: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    entityManager?: EntityManager,\n  ): Promise<Entity[]> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions({ where });\n    const result = await manager.findBy(this.target, computedOptions.where);\n    const formattedResult = await this.formatResult(result);\n    return formattedResult;\n  }\n  override async findAndCount(\n    options?: FindManyOptions<Entity>,\n    entityManager?: EntityManager,\n  ): Promise<[Entity[], number]> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions(options);\n    const result = await manager.findAndCount(this.target, computedOptions);\n    const formattedResult = await this.formatResult(result);\n    return formattedResult;\n  }\n  override async findAndCountBy(\n    where: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    entityManager?: EntityManager,\n  ): Promise<[Entity[], number]> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions({ where });\n    const result = await manager.findAndCountBy(\n      this.target,\n      computedOptions.where,\n    );\n    const formattedResult = await this.formatResult(result);\n    return formattedResult;\n  }\n  override async findOne(\n    options: FindOneOptions<Entity>,\n    entityManager?: EntityManager,\n  ): Promise<Entity | null> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions(options);\n    const result = await manager.findOne(this.target, computedOptions);\n    const formattedResult = await this.formatResult(result);\n    return formattedResult;\n  }\n  override async findOneBy(\n    where: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    entityManager?: EntityManager,\n  ): Promise<Entity | null> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions({ where });\n    const result = await manager.findOneBy(this.target, computedOptions.where);\n    const formattedResult = await this.formatResult(result);\n    return formattedResult;\n  }\n  override async findOneOrFail(\n    options: FindOneOptions<Entity>,\n    entityManager?: EntityManager,\n  ): Promise<Entity> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions(options);\n    const result = await manager.findOneOrFail(this.target, computedOptions);\n    const formattedResult = await this.formatResult(result);\n    return formattedResult;\n  }\n  override async findOneByOrFail(\n    where: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    entityManager?: EntityManager,\n  ): Promise<Entity> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions({ where });\n    const result = await manager.findOneByOrFail(\n      this.target,\n      computedOptions.where,\n    );\n    const formattedResult = await this.formatResult(result);\n    return formattedResult;\n  }\n  override save<T extends DeepPartial<Entity>>(\n    entities: T[],\n    options: SaveOptions & { reload: false },\n    entityManager?: EntityManager,\n  ): Promise<T[]>;\n  override save<T extends DeepPartial<Entity>>(\n    entities: T[],\n    options?: SaveOptions,\n    entityManager?: EntityManager,\n  ): Promise<(T & Entity)[]>;\n  override save<T extends DeepPartial<Entity>>(\n    entity: T,\n    options: SaveOptions & { reload: false },\n    entityManager?: EntityManager,\n  ): Promise<T>;\n  override save<T extends DeepPartial<Entity>>(\n    entity: T,\n    options?: SaveOptions,\n    entityManager?: EntityManager,\n  ): Promise<T & Entity>;\n  override async save<T extends DeepPartial<Entity>>(\n    entityOrEntities: T | T[],\n    options?: SaveOptions,\n    entityManager?: EntityManager,\n  ): Promise<T | T[]> {\n    const manager = entityManager || this.manager;\n    const formattedEntityOrEntities = await this.formatData(entityOrEntities);\n    let result: T | T[];\n    // Needed becasuse save method has multiple signature, otherwise we will need to do a type assertion\n    if (Array.isArray(formattedEntityOrEntities)) {\n      result = await manager.save(\n        this.target,\n        formattedEntityOrEntities,\n        options,\n      );\n    } else {\n      result = await manager.save(\n        this.target,\n        formattedEntityOrEntities,\n        options,\n      );\n    }\n    const formattedResult = await this.formatResult(result);\n    return formattedResult;\n  }\n  override remove(\n    entities: Entity[],\n    options?: RemoveOptions,\n    entityManager?: EntityManager,\n  ): Promise<Entity[]>;\n  override remove(\n    entity: Entity,\n    options?: RemoveOptions,\n    entityManager?: EntityManager,\n  ): Promise<Entity>;\n  override async remove(\n    entityOrEntities: Entity | Entity[],\n    options?: RemoveOptions,\n    entityManager?: EntityManager,\n  ): Promise<Entity | Entity[]> {\n    const manager = entityManager || this.manager;\n    const formattedEntityOrEntities = await this.formatData(entityOrEntities);\n    const result = await manager.remove(\n      this.target,\n      formattedEntityOrEntities,\n      options,\n    );\n    const formattedResult = await this.formatResult(result);\n    return formattedResult;\n  }\n  override async delete(\n    criteria:\n      | string\n      | string[]\n      | number\n      | number[]\n      | Date\n      | Date[]\n      | ObjectId\n      | ObjectId[]\n      | FindOptionsWhere<Entity>,\n    entityManager?: EntityManager,\n  ): Promise<DeleteResult> {\n    const manager = entityManager || this.manager;\n    if (typeof criteria === 'object' && 'where' in criteria) {\n      criteria = await this.transformOptions(criteria);\n    }\n    return manager.delete(this.target, criteria);\n  }\n  override softRemove<T extends DeepPartial<Entity>>(\n    entities: T[],\n    options: SaveOptions & { reload: false },\n    entityManager?: EntityManager,\n  ): Promise<T[]>;\n  override softRemove<T extends DeepPartial<Entity>>(\n    entities: T[],\n    options?: SaveOptions,\n    entityManager?: EntityManager,\n  ): Promise<(T & Entity)[]>;\n  override softRemove<T extends DeepPartial<Entity>>(\n    entity: T,\n    options: SaveOptions & { reload: false },\n    entityManager?: EntityManager,\n  ): Promise<T>;\n  override softRemove<T extends DeepPartial<Entity>>(\n    entity: T,\n    options?: SaveOptions,\n    entityManager?: EntityManager,\n  ): Promise<T & Entity>;\n  override async softRemove<T extends DeepPartial<Entity>>(\n    entityOrEntities: T | T[],\n    options?: SaveOptions,\n    entityManager?: EntityManager,\n  ): Promise<T | T[]> {\n    const manager = entityManager || this.manager;\n    const formattedEntityOrEntities = await this.formatData(entityOrEntities);\n    let result: T | T[];\n    // Needed becasuse save method has multiple signature, otherwise we will need to do a type assertion\n    if (Array.isArray(formattedEntityOrEntities)) {\n      result = await manager.softRemove(\n        this.target,\n        formattedEntityOrEntities,\n        options,\n      );\n    } else {\n      result = await manager.softRemove(\n        this.target,\n        formattedEntityOrEntities,\n        options,\n      );\n    }\n    const formattedResult = await this.formatResult(result);\n    return formattedResult;\n  }\n  override async softDelete(\n    criteria:\n      | string\n      | string[]\n      | number\n      | number[]\n      | Date\n      | Date[]\n      | ObjectId\n      | ObjectId[]\n      | FindOptionsWhere<Entity>,\n    entityManager?: EntityManager,\n  ): Promise<UpdateResult> {\n    const manager = entityManager || this.manager;\n    if (typeof criteria === 'object' && 'where' in criteria) {\n      criteria = await this.transformOptions(criteria);\n    }\n    return manager.softDelete(this.target, criteria);\n  }\n  override recover<T extends DeepPartial<Entity>>(\n    entities: T[],\n    options: SaveOptions & { reload: false },\n    entityManager?: EntityManager,\n  ): Promise<T[]>;\n  override recover<T extends DeepPartial<Entity>>(\n    entities: T[],\n    options?: SaveOptions,\n    entityManager?: EntityManager,\n  ): Promise<(T & Entity)[]>;\n  override recover<T extends DeepPartial<Entity>>(\n    entity: T,\n    options: SaveOptions & { reload: false },\n    entityManager?: EntityManager,\n  ): Promise<T>;\n  override recover<T extends DeepPartial<Entity>>(\n    entity: T,\n    options?: SaveOptions,\n    entityManager?: EntityManager,\n  ): Promise<T & Entity>;\n  override async recover<T extends DeepPartial<Entity>>(\n    entityOrEntities: T | T[],\n    options?: SaveOptions,\n    entityManager?: EntityManager,\n  ): Promise<T | T[]> {\n    const manager = entityManager || this.manager;\n    const formattedEntityOrEntities = await this.formatData(entityOrEntities);\n    let result: T | T[];\n    // Needed becasuse save method has multiple signature, otherwise we will need to do a type assertion\n    if (Array.isArray(formattedEntityOrEntities)) {\n      result = await manager.recover(\n        this.target,\n        formattedEntityOrEntities,\n        options,\n      );\n    } else {\n      result = await manager.recover(\n        this.target,\n        formattedEntityOrEntities,\n        options,\n      );\n    }\n    const formattedResult = await this.formatResult(result);\n    return formattedResult;\n  }\n  override async restore(\n    criteria:\n      | string\n      | string[]\n      | number\n      | number[]\n      | Date\n      | Date[]\n      | ObjectId\n      | ObjectId[]\n      | FindOptionsWhere<Entity>,\n    entityManager?: EntityManager,\n  ): Promise<UpdateResult> {\n    const manager = entityManager || this.manager;\n    if (typeof criteria === 'object' && 'where' in criteria) {\n      criteria = await this.transformOptions(criteria);\n    }\n    return manager.restore(this.target, criteria);\n  }\n  override async insert(\n    entity: QueryDeepPartialEntity<Entity> | QueryDeepPartialEntity<Entity>[],\n    entityManager?: EntityManager,\n  ): Promise<InsertResult> {\n    const manager = entityManager || this.manager;\n    const formatedEntity = await this.formatData(entity);\n    const result = await manager.insert(this.target, formatedEntity);\n    const formattedResult = await this.formatResult(result.generatedMaps);\n    return {\n      raw: result.raw,\n      generatedMaps: formattedResult,\n      identifiers: result.identifiers,\n    };\n  }\n  override async update(\n    criteria:\n      | string\n      | string[]\n      | number\n      | number[]\n      | Date\n      | Date[]\n      | ObjectId\n      | ObjectId[]\n      | FindOptionsWhere<Entity>,\n    partialEntity: QueryDeepPartialEntity<Entity>,\n    entityManager?: EntityManager,\n  ): Promise<UpdateResult> {\n    const manager = entityManager || this.manager;\n    if (typeof criteria === 'object' && 'where' in criteria) {\n      criteria = await this.transformOptions(criteria);\n    }\n    return manager.update(this.target, criteria, partialEntity);\n  }\n  override async upsert(\n    entityOrEntities:\n      | QueryDeepPartialEntity<Entity>\n      | QueryDeepPartialEntity<Entity>[],\n    conflictPathsOrOptions: string[] | UpsertOptions<Entity>,\n    entityManager?: EntityManager,\n  ): Promise<InsertResult> {\n    const manager = entityManager || this.manager;\n    const formattedEntityOrEntities = await this.formatData(entityOrEntities);\n    const result = await manager.upsert(\n      this.target,\n      formattedEntityOrEntities,\n      conflictPathsOrOptions,\n    );\n    const formattedResult = await this.formatResult(result.generatedMaps);\n    return {\n      raw: result.raw,\n      generatedMaps: formattedResult,\n      identifiers: result.identifiers,\n    };\n  }\n  override async exists(\n    options?: FindManyOptions<Entity>,\n    entityManager?: EntityManager,\n  ): Promise<boolean> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions(options);\n    return manager.exists(this.target, computedOptions);\n  }\n  override async existsBy(\n    where: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    entityManager?: EntityManager,\n  ): Promise<boolean> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions({ where });\n    return manager.existsBy(this.target, computedOptions.where);\n  }\n  override async count(\n    options?: FindManyOptions<Entity>,\n    entityManager?: EntityManager,\n  ): Promise<number> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions(options);\n    return manager.count(this.target, computedOptions);\n  }\n  override async countBy(\n    where: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    entityManager?: EntityManager,\n  ): Promise<number> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions({ where });\n    return manager.countBy(this.target, computedOptions.where);\n  }\n  override async sum(\n    columnName: PickKeysByType<Entity, number>,\n    where?: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    entityManager?: EntityManager,\n  ): Promise<number | null> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions({ where });\n    return manager.sum(this.target, columnName, computedOptions.where);\n  }\n  override async average(\n    columnName: PickKeysByType<Entity, number>,\n    where?: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    entityManager?: EntityManager,\n  ): Promise<number | null> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions({ where });\n    return manager.average(this.target, columnName, computedOptions.where);\n  }\n  override async minimum(\n    columnName: PickKeysByType<Entity, number>,\n    where?: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    entityManager?: EntityManager,\n  ): Promise<number | null> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions({ where });\n    return manager.minimum(this.target, columnName, computedOptions.where);\n  }\n  override async maximum(\n    columnName: PickKeysByType<Entity, number>,\n    where?: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    entityManager?: EntityManager,\n  ): Promise<number | null> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions({ where });\n    return manager.maximum(this.target, columnName, computedOptions.where);\n  }\n  override async increment(\n    conditions: FindOptionsWhere<Entity>,\n    propertyPath: string,\n    value: number | string,\n    entityManager?: EntityManager,\n  ): Promise<UpdateResult> {\n    const manager = entityManager || this.manager;\n    const computedConditions = await this.transformOptions({\n      where: conditions,\n    });\n    return manager.increment(\n      this.target,\n      computedConditions.where,\n      propertyPath,\n      value,\n    );\n  }\n  override async decrement(\n    conditions: FindOptionsWhere<Entity>,\n    propertyPath: string,\n    value: number | string,\n    entityManager?: EntityManager,\n  ): Promise<UpdateResult> {\n    const manager = entityManager || this.manager;\n    const computedConditions = await this.transformOptions({\n      where: conditions,\n    });\n    return manager.decrement(\n      this.target,\n      computedConditions.where,\n      propertyPath,\n      value,\n    );\n  }\n  private async getObjectMetadataFromTarget() {\n    const objectMetadataName =\n      typeof this.target === 'string'\n        ? this.target\n        : WorkspaceEntitiesStorage.getObjectMetadataName(\n            this.internalContext.workspaceId,\n            this.target as EntitySchema,\n          );\n    if (!objectMetadataName) {\n      throw new Error('Object metadata name is missing');\n    }\n    const objectMetadata = getObjectMetadataMapItemByNameSingular(\n      this.internalContext.objectMetadataMaps,\n      objectMetadataName,\n    );\n    if (!objectMetadata) {\n      throw new Error(\n        `Object metadata for object \"${objectMetadataName}\" is missing ` +\n          `in workspace \"${this.internalContext.workspaceId}\" ` +\n          `with object metadata collection length: ${\n            Object.keys(\n              this.internalContext.objectMetadataMaps.idByNameSingular,\n            ).length\n          }`,\n      );\n    }\n    return objectMetadata;\n  }\n  private async transformOptions<\n    T extends FindManyOptions<Entity> | FindOneOptions<Entity> | undefined,\n  >(options: T): Promise<T> {\n    if (!options) {\n      return options;\n    }\n    const transformedOptions = { ...options };\n    transformedOptions.where = await this.formatData(options.where);\n    return transformedOptions;\n  }\n  private async formatData<T>(data: T): Promise<T> {\n    const objectMetadata = await this.getObjectMetadataFromTarget();\n    return formatData(data, objectMetadata) as T;\n  }\n  async formatResult<T>(\n    data: T,\n    objectMetadata?: ObjectMetadataItemWithFieldMaps,\n  ): Promise<T> {\n    objectMetadata ??= await this.getObjectMetadataFromTarget();\n    const objectMetadataMaps = this.internalContext.objectMetadataMaps;\n    return formatResult(data, objectMetadata, objectMetadataMaps) as T;\n  }\n}"
}