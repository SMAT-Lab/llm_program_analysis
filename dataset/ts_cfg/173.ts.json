{
  "type": "file",
  "name": "173.ts",
  "label": "173.ts",
  "start_line": -1,
  "end_line": 163,
  "classes": [
    {
      "type": "class",
      "name": "%dflt",
      "label": "%dflt",
      "start_line": -1,
      "end_line": 163,
      "functions": [
        {
          "type": "function",
          "name": "%dflt",
          "label": "%dflt",
          "start_line": -1,
          "end_line": 163,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "this = this: @ts_files/173.ts: %dflt\nreturn",
              "start_line": 1,
              "end_line": 163,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": ""
        },
        {
          "type": "function",
          "name": "isStringArray",
          "label": "isStringArray",
          "start_line": 1,
          "end_line": 3,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "value = parameter0: any\nthis = this: @ts_files/173.ts: %dflt\n%0 = instanceinvoke Array.<@%unk/%unk: .isArray()>(value)\n%1 = <any>value\n%2 = instanceinvoke %1.<@%unk/%unk: .every()>(%AM0$isStringArray)\n%3 = %0 && %2\nreturn %3",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "function isStringArray(value: any): value is string[] {\n  return Array.isArray(value) && (value as any[]).every(elem => typeof elem === 'string')\n}"
        },
        {
          "type": "function",
          "name": "isStrArrayOrUndefined",
          "label": "isStrArrayOrUndefined",
          "start_line": 1,
          "end_line": 6,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "arg = parameter0: any\nthis = this: @ts_files/173.ts: %dflt\n%0 = typeof arg === 'undefined'\n%1 = staticinvoke <@ts_files/173.ts: %dflt.isStringArray(any)>(arg)\n%2 = %0 || %1\nreturn %2",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "function isStrArrayOrUndefined(arg: any): arg is string[] | undefined {\n  return ((typeof arg === 'undefined') || isStringArray(arg))\n}"
        },
        {
          "type": "function",
          "name": "%AM0$isStringArray",
          "label": "%AM0$isStringArray",
          "start_line": 1,
          "end_line": 4,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "elem = parameter0: unknown\nthis = this: @ts_files/173.ts: %dflt\n%0 = typeof elem === 'string'\nreturn %0",
              "start_line": 1,
              "end_line": 1,
              "successors": []
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "elem => typeof elem === 'string'"
        }
      ],
      "classes": [],
      "blocks": [],
      "simplified_code": ""
    },
    {
      "type": "class",
      "name": "SemanticTokensBuilder",
      "label": "SemanticTokensBuilder",
      "start_line": 1,
      "end_line": 159,
      "functions": [
        {
          "type": "function",
          "name": "constructor",
          "label": "constructor",
          "start_line": 1,
          "end_line": 18,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "instanceinvoke this.<@ts_files/173.ts: SemanticTokensBuilder.%instInit()>()\nlegend = parameter0: SemanticTokensLegend\nthis = this: @ts_files/173.ts: SemanticTokensBuilder\nthis.<@ts_files/173.ts: SemanticTokensBuilder._prevLine> = 0\nthis.<@ts_files/173.ts: SemanticTokensBuilder._prevChar> = 0\nthis.<@ts_files/173.ts: SemanticTokensBuilder._dataIsSortedAndDeltaEncoded> = true\n%0 = newarray (any)[0]\nthis.<@ts_files/173.ts: SemanticTokensBuilder._data> = %0\nthis.<@ts_files/173.ts: SemanticTokensBuilder._dataLen> = 0\n%1 = new @%unk/%unk: Map<string,number>\ninstanceinvoke %1.<@%unk/%unk: Map.constructor()>()\nthis.<@ts_files/173.ts: SemanticTokensBuilder._tokenTypeStrToInt> = %1\n%2 = new @%unk/%unk: Map<string,number>\ninstanceinvoke %2.<@%unk/%unk: Map.constructor()>()\nthis.<@ts_files/173.ts: SemanticTokensBuilder._tokenModifierStrToInt> = %2\nthis.<@ts_files/173.ts: SemanticTokensBuilder._hasLegend> = false\nif legend != 0",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "this.<@ts_files/173.ts: SemanticTokensBuilder._hasLegend> = true\ni = 0\n%3 = legend.<@%unk/%unk: .tokenTypes>\nlen = %3.<@%unk/%unk: .length>",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "if i < len",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "%4 = legend.<@%unk/%unk: .tokenTypes>\n%5 = %4.<@%unk/%unk: .i>\n%6 = this.<@ts_files/173.ts: SemanticTokensBuilder._tokenTypeStrToInt>\ninstanceinvoke %6.<@%unk/%unk: .set()>(%5, i)\ni = i + 1",
                          "start_line": 1,
                          "end_line": 1,
                          "successors": [
                            {
                              "type": "blockRef",
                              "label": "(RepeatedBlock)"
                            }
                          ]
                        },
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "i = 0\n%7 = legend.<@%unk/%unk: .tokenModifiers>\nlen = %7.<@%unk/%unk: .length>",
                          "start_line": 29,
                          "end_line": 1,
                          "successors": [
                            {
                              "type": "block",
                              "name": "Block?",
                              "label": "if i < len",
                              "start_line": 1,
                              "end_line": 1,
                              "successors": [
                                {
                                  "type": "block",
                                  "name": "Block?",
                                  "label": "%8 = legend.<@%unk/%unk: .tokenModifiers>\n%9 = %8.<@%unk/%unk: .i>\n%10 = this.<@ts_files/173.ts: SemanticTokensBuilder._tokenModifierStrToInt>\ninstanceinvoke %10.<@%unk/%unk: .set()>(%9, i)\ni = i + 1",
                                  "start_line": 1,
                                  "end_line": 1,
                                  "successors": [
                                    {
                                      "type": "blockRef",
                                      "label": "(RepeatedBlock)"
                                    }
                                  ]
                                },
                                {
                                  "type": "block",
                                  "name": "Block?",
                                  "label": "return",
                                  "start_line": 4,
                                  "end_line": 163,
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "type": "blockRef",
                  "label": "(RepeatedBlock)"
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "constructor(legend?: SemanticTokensLegend) {\n    this._prevLine = 0\n    this._prevChar = 0\n    this._dataIsSortedAndDeltaEncoded = true\n    this._data = []\n    this._dataLen = 0\n    this._tokenTypeStrToInt = new Map<string, number>()\n    this._tokenModifierStrToInt = new Map<string, number>()\n    this._hasLegend = false\n    if (legend) {\n      this._hasLegend = true\n      for (let i = 0, len = legend.tokenTypes.length; i < len; i++) {\n        this._tokenTypeStrToInt.set(legend.tokenTypes[i], i)\n      }\n      for (let i = 0, len = legend.tokenModifiers.length; i < len; i++) {\n        this._tokenModifierStrToInt.set(legend.tokenModifiers[i], i)\n      }\n    }\n  }"
        },
        {
          "type": "function",
          "name": "push",
          "label": "push",
          "start_line": 1,
          "end_line": 39,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "arg0 = parameter0: any\narg1 = parameter1: any\narg2 = parameter2: any\narg3 = parameter3: any\narg4 = parameter4: any\nthis = this: @ts_files/173.ts: SemanticTokensBuilder\n%0 = typeof arg0 === 'number'\n%1 = typeof arg1 === 'number'\n%2 = %0 && %1\n%3 = typeof arg2 === 'number'\n%4 = %2 && %3\n%5 = typeof arg3 === 'number'\n%6 = %4 && %5\n%7 = typeof arg4 === 'number'\n%8 = typeof arg4 === 'undefined'\n%9 = %7 || %8\n%10 = %6 && %9\nif %10 != false",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "if typeof arg4 === 'undefined'",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "arg4 = 0",
                      "start_line": 42,
                      "end_line": 42,
                      "successors": [
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "%11 = instanceinvoke this.<@ts_files/173.ts: SemanticTokensBuilder._pushEncoded(number, number, number, number, number)>(arg0, arg1, arg2, arg3, arg4)\nreturn %11",
                          "start_line": 1,
                          "end_line": 1,
                          "successors": []
                        }
                      ]
                    },
                    {
                      "type": "blockRef",
                      "label": "(RepeatedBlock)"
                    }
                  ]
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%12 = instanceinvoke Range.<@%unk/%unk: .is()>(arg0)\n%13 = typeof arg1 === 'string'\n%14 = %12 && %13\n%15 = staticinvoke <@ts_files/173.ts: %dflt.isStrArrayOrUndefined(any)>(arg2)\n%16 = %14 && %15\nif %16 != false",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "%17 = instanceinvoke this.<@ts_files/173.ts: SemanticTokensBuilder._push(Range, string, string[])>(arg0, arg1, arg2)\nreturn %17",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": []
                    },
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "%18 = new @%unk/%unk: Error\ninstanceinvoke %18.<@%unk/%unk: Error.constructor()>('Illegal argument')\nthrow %18\nreturn",
                      "start_line": 1,
                      "end_line": 163,
                      "successors": []
                    }
                  ]
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "public push(arg0: any, arg1: any, arg2: any, arg3?: any, arg4?: any): void {\n    if (typeof arg0 === 'number' && typeof arg1 === 'number' && typeof arg2 === 'number' && typeof arg3 === 'number' && (typeof arg4 === 'number' || typeof arg4 === 'undefined')) {\n      if (typeof arg4 === 'undefined') {\n        arg4 = 0\n      }\n      // 1st overload\n      return this._pushEncoded(arg0, arg1, arg2, arg3, arg4)\n    }\n    if (Range.is(arg0) && typeof arg1 === 'string' && isStrArrayOrUndefined(arg2)) {\n      // 2nd overload\n      return this._push(arg0, arg1, arg2)\n    }\n    throw new Error('Illegal argument')\n  }"
        },
        {
          "type": "function",
          "name": "_push",
          "label": "_push",
          "start_line": 1,
          "end_line": 53,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "range = parameter0: Range\ntokenType = parameter1: string\ntokenModifiers = parameter2: string[]\nthis = this: @ts_files/173.ts: SemanticTokensBuilder\n%0 = this.<@ts_files/173.ts: SemanticTokensBuilder._hasLegend>\n%1 = !%0\nif %1 != false",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%2 = new @%unk/%unk: Error\ninstanceinvoke %2.<@%unk/%unk: Error.constructor()>('Legend must be provided in constructor')\nthrow %2",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "%3 = range.<@%unk/%unk: .start>\n%4 = %3.<@%unk/%unk: .line>\n%5 = range.<@%unk/%unk: .end>\n%6 = %5.<@%unk/%unk: .line>\nif %4 !== %6",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "%7 = new @%unk/%unk: Error\ninstanceinvoke %7.<@%unk/%unk: Error.constructor()>('`range` cannot span multiple lines')\nthrow %7",
                          "start_line": 1,
                          "end_line": 1,
                          "successors": [
                            {
                              "type": "block",
                              "name": "Block?",
                              "label": "%8 = this.<@ts_files/173.ts: SemanticTokensBuilder._tokenTypeStrToInt>\n%9 = instanceinvoke %8.<@%unk/%unk: .has()>(tokenType)\n%10 = !%9\nif %10 != 0",
                              "start_line": 1,
                              "end_line": 1,
                              "successors": [
                                {
                                  "type": "block",
                                  "name": "Block?",
                                  "label": "%11 = new @%unk/%unk: Error\ninstanceinvoke %11.<@%unk/%unk: Error.constructor()>('`tokenType` is not in the provided legend')\nthrow %11",
                                  "start_line": 1,
                                  "end_line": 1,
                                  "successors": [
                                    {
                                      "type": "block",
                                      "name": "Block?",
                                      "label": "%12 = range.<@%unk/%unk: .start>\nline = %12.<@%unk/%unk: .line>\n%13 = range.<@%unk/%unk: .start>\nchar = %13.<@%unk/%unk: .character>\n%14 = range.<@%unk/%unk: .end>\n%15 = %14.<@%unk/%unk: .character>\n%16 = range.<@%unk/%unk: .start>\n%17 = %16.<@%unk/%unk: .character>\nlength = %15 - %17\n%18 = this.<@ts_files/173.ts: SemanticTokensBuilder._tokenTypeStrToInt>\nnTokenType = instanceinvoke %18.<@%unk/%unk: .get()>(tokenType)\nnTokenModifiers = 0\nif tokenModifiers != 0\n%19 = instanceinvoke tokenModifiers.<@%unk/%unk: .iterator()>()",
                                      "start_line": 1,
                                      "end_line": 1,
                                      "successors": [
                                        {
                                          "type": "block",
                                          "name": "Block?",
                                          "label": "%20 = instanceinvoke %19.<@%unk/%unk: .next()>()\n%21 = %20.<@ES2015/BuiltinClass: IteratorResult.done>\nif %21 == true",
                                          "start_line": 1,
                                          "end_line": 1,
                                          "successors": [
                                            {
                                              "type": "block",
                                              "name": "Block?",
                                              "label": "%22 = %20.<@ES2015/BuiltinClass: IteratorResult.value>\ntokenModifier = <string>%22\n%23 = this.<@ts_files/173.ts: SemanticTokensBuilder._tokenModifierStrToInt>\n%24 = instanceinvoke %23.<@%unk/%unk: .has()>(tokenModifier)\n%25 = !%24\nif %25 != 0",
                                              "start_line": 1,
                                              "end_line": 1,
                                              "successors": [
                                                {
                                                  "type": "block",
                                                  "name": "Block?",
                                                  "label": "%26 = new @%unk/%unk: Error\ninstanceinvoke %26.<@%unk/%unk: Error.constructor()>('`tokenModifier` is not in the provided legend')\nthrow %26",
                                                  "start_line": 1,
                                                  "end_line": 1,
                                                  "successors": [
                                                    {
                                                      "type": "block",
                                                      "name": "Block?",
                                                      "label": "%27 = this.<@ts_files/173.ts: SemanticTokensBuilder._tokenModifierStrToInt>\nnTokenModifier = instanceinvoke %27.<@%unk/%unk: .get()>(tokenModifier)\n%28 = 1 << nTokenModifier\nnTokenModifiers = nTokenModifiers | %28 >>> 0",
                                                      "start_line": 1,
                                                      "end_line": 1,
                                                      "successors": [
                                                        {
                                                          "type": "blockRef",
                                                          "label": "(RepeatedBlock)"
                                                        }
                                                      ]
                                                    }
                                                  ]
                                                },
                                                {
                                                  "type": "blockRef",
                                                  "label": "(RepeatedBlock)"
                                                }
                                              ]
                                            },
                                            {
                                              "type": "block",
                                              "name": "Block?",
                                              "label": "instanceinvoke this.<@ts_files/173.ts: SemanticTokensBuilder._pushEncoded(number, number, number, number, number)>(line, char, length, nTokenType, nTokenModifiers)\nreturn",
                                              "start_line": 1,
                                              "end_line": 163,
                                              "successors": []
                                            }
                                          ]
                                        },
                                        {
                                          "type": "blockRef",
                                          "label": "(RepeatedBlock)"
                                        }
                                      ]
                                    }
                                  ]
                                },
                                {
                                  "type": "blockRef",
                                  "label": "(RepeatedBlock)"
                                }
                              ]
                            }
                          ]
                        },
                        {
                          "type": "blockRef",
                          "label": "(RepeatedBlock)"
                        }
                      ]
                    }
                  ]
                },
                {
                  "type": "blockRef",
                  "label": "(RepeatedBlock)"
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "private _push(range: Range, tokenType: string, tokenModifiers?: string[]): void {\n    if (!this._hasLegend) {\n      throw new Error('Legend must be provided in constructor')\n    }\n    if (range.start.line !== range.end.line) {\n      throw new Error('`range` cannot span multiple lines')\n    }\n    if (!this._tokenTypeStrToInt.has(tokenType)) {\n      throw new Error('`tokenType` is not in the provided legend')\n    }\n    const line = range.start.line\n    const char = range.start.character\n    const length = range.end.character - range.start.character\n    const nTokenType = this._tokenTypeStrToInt.get(tokenType)!\n    let nTokenModifiers = 0\n    if (tokenModifiers) {\n      for (const tokenModifier of tokenModifiers) {\n        if (!this._tokenModifierStrToInt.has(tokenModifier)) {\n          throw new Error('`tokenModifier` is not in the provided legend')\n        }\n        const nTokenModifier = this._tokenModifierStrToInt.get(tokenModifier)!\n        nTokenModifiers |= (1 << nTokenModifier) >>> 0\n      }\n    }\n    this._pushEncoded(line, char, length, nTokenType, nTokenModifiers)\n  }"
        },
        {
          "type": "function",
          "name": "_pushEncoded",
          "label": "_pushEncoded",
          "start_line": 1,
          "end_line": 79,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "line = parameter0: number\nchar = parameter1: number\nlength = parameter2: number\ntokenType = parameter3: number\ntokenModifiers = parameter4: number\nthis = this: @ts_files/173.ts: SemanticTokensBuilder\n%0 = this.<@ts_files/173.ts: SemanticTokensBuilder._dataIsSortedAndDeltaEncoded>\n%1 = this.<@ts_files/173.ts: SemanticTokensBuilder._prevLine>\n%2 = line < %1\n%3 = this.<@ts_files/173.ts: SemanticTokensBuilder._prevLine>\n%4 = line === %3\n%5 = this.<@ts_files/173.ts: SemanticTokensBuilder._prevChar>\n%6 = char < %5\n%7 = %4 && %6\n%8 = %2 || %7\n%9 = %0 && %8\nif %9 != false",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "this.<@ts_files/173.ts: SemanticTokensBuilder._dataIsSortedAndDeltaEncoded> = false\n%10 = this.<@ts_files/173.ts: SemanticTokensBuilder._data>\n%11 = %10.<@%unk/%unk: .length>\n%12 = %11 / 5\ntokenCount = %12 | 0\nprevLine = 0\nprevChar = 0\ni = 0",
                  "start_line": 1,
                  "end_line": 139,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "if i < tokenCount",
                      "start_line": 1,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "%13 = this.<@ts_files/173.ts: SemanticTokensBuilder._data>\n%14 = 5 * i\nline = %13[%14]\n%15 = this.<@ts_files/173.ts: SemanticTokensBuilder._data>\n%16 = 5 * i\n%17 = %16 + 1\nchar = %15[%17]\nif line === 0",
                          "start_line": 1,
                          "end_line": 1,
                          "successors": [
                            {
                              "type": "block",
                              "name": "Block?",
                              "label": "line = prevLine\nchar = char + prevChar",
                              "start_line": 92,
                              "end_line": 1,
                              "successors": [
                                {
                                  "type": "block",
                                  "name": "Block?",
                                  "label": "%18 = this.<@ts_files/173.ts: SemanticTokensBuilder._data>\n%19 = 5 * i\n%18['%19'] = line\n%20 = this.<@ts_files/173.ts: SemanticTokensBuilder._data>\n%21 = 5 * i\n%22 = %21 + 1\n%20['%22'] = char\nprevLine = line\nprevChar = char\ni = i + 1",
                                  "start_line": 1,
                                  "end_line": 1,
                                  "successors": [
                                    {
                                      "type": "blockRef",
                                      "label": "(RepeatedBlock)"
                                    }
                                  ]
                                }
                              ]
                            },
                            {
                              "type": "block",
                              "name": "Block?",
                              "label": "line = line + prevLine",
                              "start_line": 1,
                              "end_line": 1,
                              "successors": [
                                {
                                  "type": "blockRef",
                                  "label": "(RepeatedBlock)"
                                }
                              ]
                            }
                          ]
                        },
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "pushLine = line\npushChar = char\n%23 = this.<@ts_files/173.ts: SemanticTokensBuilder._dataIsSortedAndDeltaEncoded>\n%24 = this.<@ts_files/173.ts: SemanticTokensBuilder._dataLen>\n%25 = %24 > 0\n%26 = %23 && %25\nif %26 != false",
                          "start_line": 104,
                          "end_line": 1,
                          "successors": [
                            {
                              "type": "block",
                              "name": "Block?",
                              "label": "pushLine = pushLine - this.<@ts_files/173.ts: SemanticTokensBuilder._prevLine>\nif pushLine === 0",
                              "start_line": 1,
                              "end_line": 1,
                              "successors": [
                                {
                                  "type": "block",
                                  "name": "Block?",
                                  "label": "pushChar = pushChar - this.<@ts_files/173.ts: SemanticTokensBuilder._prevChar>",
                                  "start_line": 1,
                                  "end_line": 1,
                                  "successors": [
                                    {
                                      "type": "block",
                                      "name": "Block?",
                                      "label": "%27 = this.<@ts_files/173.ts: SemanticTokensBuilder._data>\n%28 = this.<@ts_files/173.ts: SemanticTokensBuilder._dataLen>\n%28 = %28 + 1\n%27['%28'] = pushLine\n%29 = this.<@ts_files/173.ts: SemanticTokensBuilder._data>\n%30 = this.<@ts_files/173.ts: SemanticTokensBuilder._dataLen>\n%30 = %30 + 1\n%29['%30'] = pushChar\n%31 = this.<@ts_files/173.ts: SemanticTokensBuilder._data>\n%32 = this.<@ts_files/173.ts: SemanticTokensBuilder._dataLen>\n%32 = %32 + 1\n%31['%32'] = length\n%33 = this.<@ts_files/173.ts: SemanticTokensBuilder._data>\n%34 = this.<@ts_files/173.ts: SemanticTokensBuilder._dataLen>\n%34 = %34 + 1\n%33['%34'] = tokenType\n%35 = this.<@ts_files/173.ts: SemanticTokensBuilder._data>\n%36 = this.<@ts_files/173.ts: SemanticTokensBuilder._dataLen>\n%36 = %36 + 1\n%35['%36'] = tokenModifiers\nthis.<@ts_files/173.ts: SemanticTokensBuilder._prevLine> = line\nthis.<@ts_files/173.ts: SemanticTokensBuilder._prevChar> = char\nreturn",
                                      "start_line": 1,
                                      "end_line": 163,
                                      "successors": []
                                    }
                                  ]
                                },
                                {
                                  "type": "blockRef",
                                  "label": "(RepeatedBlock)"
                                }
                              ]
                            },
                            {
                              "type": "blockRef",
                              "label": "(RepeatedBlock)"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "type": "blockRef",
                  "label": "(RepeatedBlock)"
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "private _pushEncoded(line: number, char: number, length: number, tokenType: number, tokenModifiers: number): void {\n    if (this._dataIsSortedAndDeltaEncoded && (line < this._prevLine || (line === this._prevLine && char < this._prevChar))) {\n      // push calls were ordered and are no longer ordered\n      this._dataIsSortedAndDeltaEncoded = false\n      // Remove delta encoding from data\n      const tokenCount = (this._data.length / 5) | 0\n      let prevLine = 0\n      let prevChar = 0\n      for (let i = 0; i < tokenCount; i++) {\n        let line = this._data[5 * i]\n        let char = this._data[5 * i + 1]\n        if (line === 0) {\n          // on the same line as previous token\n          line = prevLine\n          char += prevChar\n        } else {\n          // on a different line than previous token\n          line += prevLine\n        }\n        this._data[5 * i] = line\n        this._data[5 * i + 1] = char\n        prevLine = line\n        prevChar = char\n      }\n    }\n    let pushLine = line\n    let pushChar = char\n    if (this._dataIsSortedAndDeltaEncoded && this._dataLen > 0) {\n      pushLine -= this._prevLine\n      if (pushLine === 0) {\n        pushChar -= this._prevChar\n      }\n    }\n    this._data[this._dataLen++] = pushLine\n    this._data[this._dataLen++] = pushChar\n    this._data[this._dataLen++] = length\n    this._data[this._dataLen++] = tokenType\n    this._data[this._dataLen++] = tokenModifiers\n    this._prevLine = line\n    this._prevChar = char\n  }"
        },
        {
          "type": "function",
          "name": "build",
          "label": "build",
          "start_line": 1,
          "end_line": 159,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "resultId = parameter0: string\nthis = this: @ts_files/173.ts: SemanticTokensBuilder\n%0 = this.<@ts_files/173.ts: SemanticTokensBuilder._dataIsSortedAndDeltaEncoded>\n%1 = !%0\nif %1 != false",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%2 = new @ts_files/173.ts: %AC$SemanticTokensBuilder$build$0\ninstanceinvoke %2.<@ts_files/173.ts: %AC$SemanticTokensBuilder$build$0.constructor()>()\nreturn %2",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": []
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%3 = new @ts_files/173.ts: %AC$SemanticTokensBuilder$build$1\ninstanceinvoke %3.<@ts_files/173.ts: %AC$SemanticTokensBuilder$build$1.constructor()>()\nreturn %3",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": []
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "public build(resultId?: string): SemanticTokens {\n    if (!this._dataIsSortedAndDeltaEncoded) {\n      return { data: SemanticTokensBuilder._sortAndDeltaEncode(this._data), resultId }\n    }\n    return { data: this._data, resultId }\n  }"
        },
        {
          "type": "function",
          "name": "%AM0$_sortAndDeltaEncode",
          "label": "%AM0$_sortAndDeltaEncode",
          "start_line": 1,
          "end_line": 126,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "%closures0 = parameter0: [data]\na = parameter1: unknown\nb = parameter2: unknown\ndata = %closures0.data\nthis = this: @ts_files/173.ts: SemanticTokensBuilder\n%0 = 5 * a\naLine = data[%0]\n%1 = 5 * b\nbLine = data[%1]\nif aLine === bLine",
              "start_line": 1,
              "end_line": 1,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%2 = 5 * a\n%3 = %2 + 1\naChar = data[%3]\n%4 = 5 * b\n%5 = %4 + 1\nbChar = data[%5]\n%6 = aChar - bChar\nreturn %6",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": []
                },
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "%7 = aLine - bLine\nreturn %7",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": []
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "(a, b) => {\n      const aLine = data[5 * a]\n      const bLine = data[5 * b]\n      if (aLine === bLine) {\n        const aChar = data[5 * a + 1]\n        const bChar = data[5 * b + 1]\n        return aChar - bChar\n      }\n      return aLine - bLine\n    }"
        },
        {
          "type": "function",
          "name": "_sortAndDeltaEncode",
          "label": "_sortAndDeltaEncode",
          "start_line": 1,
          "end_line": 139,
          "blocks": [
            {
              "type": "block",
              "name": "Block?",
              "label": "data = parameter0: number[]\nthis = this: @ts_files/173.ts: SemanticTokensBuilder\n%0 = newarray (any)[0]\npos = %0\n%1 = data.<@%unk/%unk: .length>\n%2 = %1 / 5\ntokenCount = %2 | 0\ni = 0",
              "start_line": 1,
              "end_line": 139,
              "successors": [
                {
                  "type": "block",
                  "name": "Block?",
                  "label": "if i < tokenCount",
                  "start_line": 1,
                  "end_line": 1,
                  "successors": [
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "pos[i] = i\ni = i + 1",
                      "start_line": 124,
                      "end_line": 1,
                      "successors": [
                        {
                          "type": "blockRef",
                          "label": "(RepeatedBlock)"
                        }
                      ]
                    },
                    {
                      "type": "block",
                      "name": "Block?",
                      "label": "instanceinvoke pos.<@%unk/%unk: .sort()>(%AM0$_sortAndDeltaEncode)\n%3 = data.<@%unk/%unk: .length>\n%4 = newarray (number)[%3]\nresult = %4\nprevLine = 0\nprevChar = 0\ni = 0",
                      "start_line": 1,
                      "end_line": 139,
                      "successors": [
                        {
                          "type": "block",
                          "name": "Block?",
                          "label": "if i < tokenCount",
                          "start_line": 1,
                          "end_line": 1,
                          "successors": [
                            {
                              "type": "block",
                              "name": "Block?",
                              "label": "return result",
                              "start_line": 157,
                              "end_line": 157,
                              "successors": []
                            },
                            {
                              "type": "block",
                              "name": "Block?",
                              "label": "%5 = pos[i]\nsrcOffset = 5 * %5\n%6 = srcOffset + 0\nline = data[%6]\n%7 = srcOffset + 1\nchar = data[%7]\n%8 = srcOffset + 2\nlength = data[%8]\n%9 = srcOffset + 3\ntokenType = data[%9]\n%10 = srcOffset + 4\ntokenModifiers = data[%10]\npushLine = line - prevLine\nif pushLine === 0",
                              "start_line": 1,
                              "end_line": 1,
                              "successors": [
                                {
                                  "type": "block",
                                  "name": "Block?",
                                  "label": "pushChar = char - prevChar",
                                  "start_line": 1,
                                  "end_line": 1,
                                  "successors": [
                                    {
                                      "type": "block",
                                      "name": "Block?",
                                      "label": "dstOffset = 5 * i\n%12 = dstOffset + 0\nresult[%12] = pushLine\n%13 = dstOffset + 1\nresult[%13] = pushChar\n%14 = dstOffset + 2\nresult[%14] = length\n%15 = dstOffset + 3\nresult[%15] = tokenType\n%16 = dstOffset + 4\nresult[%16] = tokenModifiers\nprevLine = line\nprevChar = char\ni = i + 1",
                                      "start_line": 148,
                                      "end_line": 1,
                                      "successors": [
                                        {
                                          "type": "blockRef",
                                          "label": "(RepeatedBlock)"
                                        }
                                      ]
                                    }
                                  ]
                                },
                                {
                                  "type": "block",
                                  "name": "Block?",
                                  "label": "pushChar = char",
                                  "start_line": 105,
                                  "end_line": 105,
                                  "successors": [
                                    {
                                      "type": "blockRef",
                                      "label": "(RepeatedBlock)"
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            },
            {
              "type": "blockRef",
              "label": "(RepeatedBlock)"
            }
          ],
          "functions": [],
          "classes": [],
          "simplified_code": "private static _sortAndDeltaEncode(data: number[]): number[] {\n    let pos: number[] = []\n    const tokenCount = (data.length / 5) | 0\n    for (let i = 0; i < tokenCount; i++) {\n      pos[i] = i\n    }\n    pos.sort((a, b) => {\n      const aLine = data[5 * a]\n      const bLine = data[5 * b]\n      if (aLine === bLine) {\n        const aChar = data[5 * a + 1]\n        const bChar = data[5 * b + 1]\n        return aChar - bChar\n      }\n      return aLine - bLine\n    })\n    const result = new Array<number>(data.length)\n    let prevLine = 0\n    let prevChar = 0\n    for (let i = 0; i < tokenCount; i++) {\n      const srcOffset = 5 * pos[i]\n      const line = data[srcOffset + 0]\n      const char = data[srcOffset + 1]\n      const length = data[srcOffset + 2]\n      const tokenType = data[srcOffset + 3]\n      const tokenModifiers = data[srcOffset + 4]\n      const pushLine = line - prevLine\n      const pushChar = (pushLine === 0 ? char - prevChar : char)\n      const dstOffset = 5 * i\n      result[dstOffset + 0] = pushLine\n      result[dstOffset + 1] = pushChar\n      result[dstOffset + 2] = length\n      result[dstOffset + 3] = tokenType\n      result[dstOffset + 4] = tokenModifiers\n      prevLine = line\n      prevChar = char\n    }\n    return result\n  }"
        }
      ],
      "classes": [],
      "blocks": [],
      "simplified_code": "export class SemanticTokensBuilder {\n  private _prevLine: number\n  private _prevChar: number\n  private _dataIsSortedAndDeltaEncoded: boolean\n  private _data: number[]\n  private _dataLen: number\n  private _tokenTypeStrToInt: Map<string, number>\n  private _tokenModifierStrToInt: Map<string, number>\n  private _hasLegend: boolean\n  constructor(legend?: SemanticTokensLegend) {\n    this._prevLine = 0\n    this._prevChar = 0\n    this._dataIsSortedAndDeltaEncoded = true\n    this._data = []\n    this._dataLen = 0\n    this._tokenTypeStrToInt = new Map<string, number>()\n    this._tokenModifierStrToInt = new Map<string, number>()\n    this._hasLegend = false\n    if (legend) {\n      this._hasLegend = true\n      for (let i = 0, len = legend.tokenTypes.length; i < len; i++) {\n        this._tokenTypeStrToInt.set(legend.tokenTypes[i], i)\n      }\n      for (let i = 0, len = legend.tokenModifiers.length; i < len; i++) {\n        this._tokenModifierStrToInt.set(legend.tokenModifiers[i], i)\n      }\n    }\n  }\n  public push(line: number, char: number, length: number, tokenType: number, tokenModifiers?: number): void\n  public push(range: Range, tokenType: string, tokenModifiers?: string[]): void\n  public push(arg0: any, arg1: any, arg2: any, arg3?: any, arg4?: any): void {\n    if (typeof arg0 === 'number' && typeof arg1 === 'number' && typeof arg2 === 'number' && typeof arg3 === 'number' && (typeof arg4 === 'number' || typeof arg4 === 'undefined')) {\n      if (typeof arg4 === 'undefined') {\n        arg4 = 0\n      }\n      // 1st overload\n      return this._pushEncoded(arg0, arg1, arg2, arg3, arg4)\n    }\n    if (Range.is(arg0) && typeof arg1 === 'string' && isStrArrayOrUndefined(arg2)) {\n      // 2nd overload\n      return this._push(arg0, arg1, arg2)\n    }\n    throw new Error('Illegal argument')\n  }\n  private _push(range: Range, tokenType: string, tokenModifiers?: string[]): void {\n    if (!this._hasLegend) {\n      throw new Error('Legend must be provided in constructor')\n    }\n    if (range.start.line !== range.end.line) {\n      throw new Error('`range` cannot span multiple lines')\n    }\n    if (!this._tokenTypeStrToInt.has(tokenType)) {\n      throw new Error('`tokenType` is not in the provided legend')\n    }\n    const line = range.start.line\n    const char = range.start.character\n    const length = range.end.character - range.start.character\n    const nTokenType = this._tokenTypeStrToInt.get(tokenType)!\n    let nTokenModifiers = 0\n    if (tokenModifiers) {\n      for (const tokenModifier of tokenModifiers) {\n        if (!this._tokenModifierStrToInt.has(tokenModifier)) {\n          throw new Error('`tokenModifier` is not in the provided legend')\n        }\n        const nTokenModifier = this._tokenModifierStrToInt.get(tokenModifier)!\n        nTokenModifiers |= (1 << nTokenModifier) >>> 0\n      }\n    }\n    this._pushEncoded(line, char, length, nTokenType, nTokenModifiers)\n  }\n  private _pushEncoded(line: number, char: number, length: number, tokenType: number, tokenModifiers: number): void {\n    if (this._dataIsSortedAndDeltaEncoded && (line < this._prevLine || (line === this._prevLine && char < this._prevChar))) {\n      // push calls were ordered and are no longer ordered\n      this._dataIsSortedAndDeltaEncoded = false\n      // Remove delta encoding from data\n      const tokenCount = (this._data.length / 5) | 0\n      let prevLine = 0\n      let prevChar = 0\n      for (let i = 0; i < tokenCount; i++) {\n        let line = this._data[5 * i]\n        let char = this._data[5 * i + 1]\n        if (line === 0) {\n          // on the same line as previous token\n          line = prevLine\n          char += prevChar\n        } else {\n          // on a different line than previous token\n          line += prevLine\n        }\n        this._data[5 * i] = line\n        this._data[5 * i + 1] = char\n        prevLine = line\n        prevChar = char\n      }\n    }\n    let pushLine = line\n    let pushChar = char\n    if (this._dataIsSortedAndDeltaEncoded && this._dataLen > 0) {\n      pushLine -= this._prevLine\n      if (pushLine === 0) {\n        pushChar -= this._prevChar\n      }\n    }\n    this._data[this._dataLen++] = pushLine\n    this._data[this._dataLen++] = pushChar\n    this._data[this._dataLen++] = length\n    this._data[this._dataLen++] = tokenType\n    this._data[this._dataLen++] = tokenModifiers\n    this._prevLine = line\n    this._prevChar = char\n  }\n  private static _sortAndDeltaEncode(data: number[]): number[] {\n    let pos: number[] = []\n    const tokenCount = (data.length / 5) | 0\n    for (let i = 0; i < tokenCount; i++) {\n      pos[i] = i\n    }\n    pos.sort((a, b) => {\n      const aLine = data[5 * a]\n      const bLine = data[5 * b]\n      if (aLine === bLine) {\n        const aChar = data[5 * a + 1]\n        const bChar = data[5 * b + 1]\n        return aChar - bChar\n      }\n      return aLine - bLine\n    })\n    const result = new Array<number>(data.length)\n    let prevLine = 0\n    let prevChar = 0\n    for (let i = 0; i < tokenCount; i++) {\n      const srcOffset = 5 * pos[i]\n      const line = data[srcOffset + 0]\n      const char = data[srcOffset + 1]\n      const length = data[srcOffset + 2]\n      const tokenType = data[srcOffset + 3]\n      const tokenModifiers = data[srcOffset + 4]\n      const pushLine = line - prevLine\n      const pushChar = (pushLine === 0 ? char - prevChar : char)\n      const dstOffset = 5 * i\n      result[dstOffset + 0] = pushLine\n      result[dstOffset + 1] = pushChar\n      result[dstOffset + 2] = length\n      result[dstOffset + 3] = tokenType\n      result[dstOffset + 4] = tokenModifiers\n      prevLine = line\n      prevChar = char\n    }\n    return result\n  }\n  public build(resultId?: string): SemanticTokens {\n    if (!this._dataIsSortedAndDeltaEncoded) {\n      return { data: SemanticTokensBuilder._sortAndDeltaEncode(this._data), resultId }\n    }\n    return { data: this._data, resultId }\n  }\n}"
    },
    {
      "type": "class",
      "name": "%AC$SemanticTokensBuilder$build$0",
      "label": "%AC$SemanticTokensBuilder$build$0",
      "start_line": 161,
      "end_line": 161,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{ data: SemanticTokensBuilder._sortAndDeltaEncode(this._data), resultId }"
    },
    {
      "type": "class",
      "name": "%AC$SemanticTokensBuilder$build$1",
      "label": "%AC$SemanticTokensBuilder$build$1",
      "start_line": 163,
      "end_line": 163,
      "functions": [],
      "classes": [],
      "blocks": [],
      "simplified_code": "{ data: this._data, resultId }"
    }
  ],
  "functions": [],
  "blocks": [],
  "simplified_code": "'use strict'\nimport { Range, SemanticTokens, SemanticTokensLegend } from \"vscode-languageserver-types\"\nfunction isStringArray(value: any): value is string[] {\n  return Array.isArray(value) && (value as any[]).every(elem => typeof elem === 'string')\n}\nfunction isStrArrayOrUndefined(arg: any): arg is string[] | undefined {\n  return ((typeof arg === 'undefined') || isStringArray(arg))\n}\nexport class SemanticTokensBuilder {\n  private _prevLine: number\n  private _prevChar: number\n  private _dataIsSortedAndDeltaEncoded: boolean\n  private _data: number[]\n  private _dataLen: number\n  private _tokenTypeStrToInt: Map<string, number>\n  private _tokenModifierStrToInt: Map<string, number>\n  private _hasLegend: boolean\n  constructor(legend?: SemanticTokensLegend) {\n    this._prevLine = 0\n    this._prevChar = 0\n    this._dataIsSortedAndDeltaEncoded = true\n    this._data = []\n    this._dataLen = 0\n    this._tokenTypeStrToInt = new Map<string, number>()\n    this._tokenModifierStrToInt = new Map<string, number>()\n    this._hasLegend = false\n    if (legend) {\n      this._hasLegend = true\n      for (let i = 0, len = legend.tokenTypes.length; i < len; i++) {\n        this._tokenTypeStrToInt.set(legend.tokenTypes[i], i)\n      }\n      for (let i = 0, len = legend.tokenModifiers.length; i < len; i++) {\n        this._tokenModifierStrToInt.set(legend.tokenModifiers[i], i)\n      }\n    }\n  }\n  public push(line: number, char: number, length: number, tokenType: number, tokenModifiers?: number): void\n  public push(range: Range, tokenType: string, tokenModifiers?: string[]): void\n  public push(arg0: any, arg1: any, arg2: any, arg3?: any, arg4?: any): void {\n    if (typeof arg0 === 'number' && typeof arg1 === 'number' && typeof arg2 === 'number' && typeof arg3 === 'number' && (typeof arg4 === 'number' || typeof arg4 === 'undefined')) {\n      if (typeof arg4 === 'undefined') {\n        arg4 = 0\n      }\n      // 1st overload\n      return this._pushEncoded(arg0, arg1, arg2, arg3, arg4)\n    }\n    if (Range.is(arg0) && typeof arg1 === 'string' && isStrArrayOrUndefined(arg2)) {\n      // 2nd overload\n      return this._push(arg0, arg1, arg2)\n    }\n    throw new Error('Illegal argument')\n  }\n  private _push(range: Range, tokenType: string, tokenModifiers?: string[]): void {\n    if (!this._hasLegend) {\n      throw new Error('Legend must be provided in constructor')\n    }\n    if (range.start.line !== range.end.line) {\n      throw new Error('`range` cannot span multiple lines')\n    }\n    if (!this._tokenTypeStrToInt.has(tokenType)) {\n      throw new Error('`tokenType` is not in the provided legend')\n    }\n    const line = range.start.line\n    const char = range.start.character\n    const length = range.end.character - range.start.character\n    const nTokenType = this._tokenTypeStrToInt.get(tokenType)!\n    let nTokenModifiers = 0\n    if (tokenModifiers) {\n      for (const tokenModifier of tokenModifiers) {\n        if (!this._tokenModifierStrToInt.has(tokenModifier)) {\n          throw new Error('`tokenModifier` is not in the provided legend')\n        }\n        const nTokenModifier = this._tokenModifierStrToInt.get(tokenModifier)!\n        nTokenModifiers |= (1 << nTokenModifier) >>> 0\n      }\n    }\n    this._pushEncoded(line, char, length, nTokenType, nTokenModifiers)\n  }\n  private _pushEncoded(line: number, char: number, length: number, tokenType: number, tokenModifiers: number): void {\n    if (this._dataIsSortedAndDeltaEncoded && (line < this._prevLine || (line === this._prevLine && char < this._prevChar))) {\n      // push calls were ordered and are no longer ordered\n      this._dataIsSortedAndDeltaEncoded = false\n      // Remove delta encoding from data\n      const tokenCount = (this._data.length / 5) | 0\n      let prevLine = 0\n      let prevChar = 0\n      for (let i = 0; i < tokenCount; i++) {\n        let line = this._data[5 * i]\n        let char = this._data[5 * i + 1]\n        if (line === 0) {\n          // on the same line as previous token\n          line = prevLine\n          char += prevChar\n        } else {\n          // on a different line than previous token\n          line += prevLine\n        }\n        this._data[5 * i] = line\n        this._data[5 * i + 1] = char\n        prevLine = line\n        prevChar = char\n      }\n    }\n    let pushLine = line\n    let pushChar = char\n    if (this._dataIsSortedAndDeltaEncoded && this._dataLen > 0) {\n      pushLine -= this._prevLine\n      if (pushLine === 0) {\n        pushChar -= this._prevChar\n      }\n    }\n    this._data[this._dataLen++] = pushLine\n    this._data[this._dataLen++] = pushChar\n    this._data[this._dataLen++] = length\n    this._data[this._dataLen++] = tokenType\n    this._data[this._dataLen++] = tokenModifiers\n    this._prevLine = line\n    this._prevChar = char\n  }\n  private static _sortAndDeltaEncode(data: number[]): number[] {\n    let pos: number[] = []\n    const tokenCount = (data.length / 5) | 0\n    for (let i = 0; i < tokenCount; i++) {\n      pos[i] = i\n    }\n    pos.sort((a, b) => {\n      const aLine = data[5 * a]\n      const bLine = data[5 * b]\n      if (aLine === bLine) {\n        const aChar = data[5 * a + 1]\n        const bChar = data[5 * b + 1]\n        return aChar - bChar\n      }\n      return aLine - bLine\n    })\n    const result = new Array<number>(data.length)\n    let prevLine = 0\n    let prevChar = 0\n    for (let i = 0; i < tokenCount; i++) {\n      const srcOffset = 5 * pos[i]\n      const line = data[srcOffset + 0]\n      const char = data[srcOffset + 1]\n      const length = data[srcOffset + 2]\n      const tokenType = data[srcOffset + 3]\n      const tokenModifiers = data[srcOffset + 4]\n      const pushLine = line - prevLine\n      const pushChar = (pushLine === 0 ? char - prevChar : char)\n      const dstOffset = 5 * i\n      result[dstOffset + 0] = pushLine\n      result[dstOffset + 1] = pushChar\n      result[dstOffset + 2] = length\n      result[dstOffset + 3] = tokenType\n      result[dstOffset + 4] = tokenModifiers\n      prevLine = line\n      prevChar = char\n    }\n    return result\n  }\n  public build(resultId?: string): SemanticTokens {\n    if (!this._dataIsSortedAndDeltaEncoded) {\n      return { data: SemanticTokensBuilder._sortAndDeltaEncode(this._data), resultId }\n    }\n    return { data: this._data, resultId }\n  }\n}"
}