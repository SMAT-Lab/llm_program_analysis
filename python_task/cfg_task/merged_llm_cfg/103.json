{
  "name": "example_script",
  "type": "CFG",
  "start_line": 1,
  "end_line": 309,
  "functions": [],
  "classes": [
    {
      "name": "IntegrationCredentialsStore",
      "type": "class",
      "start_line": 110,
      "end_line": 309,
      "functions": [
        {
          "name": "__init__",
          "type": "function",
          "start_line": 111,
          "end_line": 114,
          "functions": [],
          "classes": [],
          "simplified_code": "    def __init__(self):\n        from backend.data.redis import get_redis\n\n        self.locks = RedisKeyedMutex(get_redis())",
          "blocks": [
            {
              "id": 1,
              "label": "def __init__(self):\nfrom backend.data.redis import get_redis\nself.locks = RedisKeyedMutex(get_redis())",
              "successors": []
            }
          ]
        },
        {
          "name": "db_manager",
          "type": "function",
          "start_line": 118,
          "end_line": 122,
          "functions": [],
          "classes": [],
          "simplified_code": "    def db_manager(self) -> \"DatabaseManager\":\n        from backend.executor.database import DatabaseManager\n        from backend.util.service import get_service_client\n\n        return get_service_client(DatabaseManager)",
          "blocks": [
            {
              "id": 1,
              "label": "from backend.executor.database import DatabaseManager\nfrom backend.util.service import get_service_client\nreturn get_service_client(DatabaseManager)",
              "successors": []
            }
          ]
        },
        {
          "name": "add_creds",
          "type": "function",
          "start_line": 124,
          "end_line": 133,
          "functions": [],
          "classes": [],
          "simplified_code": "    def add_creds(self, user_id: str, credentials: Credentials) -> None:\n        with self.locked_user_integrations(user_id):\n            if self.get_creds_by_id(user_id, credentials.id):\n                raise ValueError(\n                    f\"Can not re-create existing credentials #{credentials.id} \"\n                    f\"for user #{user_id}\"\n                )\n            self._set_user_integration_creds(\n                user_id, [*self.get_all_creds(user_id), credentials]\n            )",
          "blocks": [
            {
              "id": 1,
              "label": "with self.locked_user_integrations(user_id):\nif self.get_creds_by_id(user_id, credentials.id):\nraise ValueError(f\"Can not re-create existing credentials #{credentials.id} \" f\"for user #{user_id}\")",
              "successors": []
            },
            {
              "id": 4,
              "label": "self._set_user_integration_creds(user_id, [*self.get_all_creds(user_id), credentials])",
              "successors": []
            }
          ]
        },
        {
          "name": "get_all_creds",
          "type": "function",
          "start_line": 135,
          "end_line": 158,
          "functions": [],
          "classes": [],
          "simplified_code": "    def get_all_creds(self, user_id: str) -> list[Credentials]:\n        users_credentials = self._get_user_integrations(user_id).credentials\n        all_credentials = users_credentials\n        if settings.secrets.revid_api_key:\n            all_credentials.append(revid_credentials)\n        if settings.secrets.ideogram_api_key:\n            all_credentials.append(ideogram_credentials)\n        if settings.secrets.groq_api_key:\n            all_credentials.append(groq_credentials)\n        if settings.secrets.replicate_api_key:\n            all_credentials.append(replicate_credentials)\n        if settings.secrets.openai_api_key:\n            all_credentials.append(openai_credentials)\n        if settings.secrets.anthropic_api_key:\n            all_credentials.append(anthropic_credentials)\n        if settings.secrets.did_api_key:\n            all_credentials.append(did_credentials)\n        if settings.secrets.jina_api_key:\n            all_credentials.append(jina_credentials)\n        if settings.secrets.unreal_speech_api_key:\n            all_credentials.append(unreal_credentials)\n        if settings.secrets.open_router_api_key:\n            all_credentials.append(open_router_credentials)\n        return all_credentials",
          "blocks": [
            {
              "id": 1,
              "label": "users_credentials = self._get_user_integrations(user_id).credentials\nall_credentials = users_credentials\nif settings.secrets.revid_api_key:\nall_credentials.append(revid_credentials)",
              "successors": [
                4
              ]
            },
            {
              "id": 4,
              "label": "if settings.secrets.ideogram_api_key:\nall_credentials.append(ideogram_credentials)",
              "successors": [
                6
              ]
            },
            {
              "id": 6,
              "label": "if settings.secrets.groq_api_key:\nall_credentials.append(groq_credentials)",
              "successors": [
                8
              ]
            },
            {
              "id": 8,
              "label": "if settings.secrets.replicate_api_key:\nall_credentials.append(replicate_credentials)",
              "successors": [
                10
              ]
            },
            {
              "id": 10,
              "label": "if settings.secrets.openai_api_key:\nall_credentials.append(openai_credentials)",
              "successors": [
                12
              ]
            },
            {
              "id": 12,
              "label": "if settings.secrets.anthropic_api_key:\nall_credentials.append(anthropic_credentials)",
              "successors": [
                14
              ]
            },
            {
              "id": 14,
              "label": "if settings.secrets.did_api_key:\nall_credentials.append(did_credentials)",
              "successors": [
                16
              ]
            },
            {
              "id": 16,
              "label": "if settings.secrets.jina_api_key:\nall_credentials.append(jina_credentials)",
              "successors": [
                18
              ]
            },
            {
              "id": 18,
              "label": "if settings.secrets.unreal_speech_api_key:\nall_credentials.append(unreal_credentials)",
              "successors": [
                20
              ]
            },
            {
              "id": 20,
              "label": "if settings.secrets.open_router_api_key:\nall_credentials.append(open_router_credentials)",
              "successors": [
                22
              ]
            },
            {
              "id": 22,
              "label": "return all_credentials",
              "successors": []
            }
          ]
        },
        {
          "name": "get_creds_by_id",
          "type": "function",
          "start_line": 160,
          "end_line": 162,
          "functions": [],
          "classes": [],
          "simplified_code": "    def get_creds_by_id(self, user_id: str, credentials_id: str) -> Credentials | None:\n        all_credentials = self.get_all_creds(user_id)\n        return next((c for c in all_credentials if c.id == credentials_id), None)",
          "blocks": [
            {
              "id": 1,
              "label": "all_credentials = self.get_all_creds(user_id)\nreturn next((c for c in all_credentials if c.id == credentials_id), None)",
              "successors": []
            }
          ]
        },
        {
          "name": "get_creds_by_provider",
          "type": "function",
          "start_line": 164,
          "end_line": 166,
          "functions": [],
          "classes": [],
          "simplified_code": "    def get_creds_by_provider(self, user_id: str, provider: str) -> list[Credentials]:\n        credentials = self.get_all_creds(user_id)\n        return [c for c in credentials if c.provider == provider]",
          "blocks": [
            {
              "id": 1,
              "label": "credentials = self.get_all_creds(user_id)\nreturn [c for c in credentials if c.provider == provider]",
              "successors": []
            }
          ]
        },
        {
          "name": "get_authorized_providers",
          "type": "function",
          "start_line": 168,
          "end_line": 170,
          "functions": [],
          "classes": [],
          "simplified_code": "    def get_authorized_providers(self, user_id: str) -> list[str]:\n        credentials = self.get_all_creds(user_id)\n        return list(set(c.provider for c in credentials))",
          "blocks": [
            {
              "id": 1,
              "label": "credentials = self.get_all_creds(user_id)\nreturn list(set(c.provider for c in credentials))",
              "successors": []
            }
          ]
        },
        {
          "name": "update_creds",
          "type": "function",
          "start_line": 172,
          "end_line": 204,
          "functions": [],
          "classes": [],
          "simplified_code": "    def update_creds(self, user_id: str, updated: Credentials) -> None:\n        with self.locked_user_integrations(user_id):\n            current = self.get_creds_by_id(user_id, updated.id)\n            if not current:\n                raise ValueError(\n                    f\"Credentials with ID {updated.id} \"\n                    f\"for user with ID {user_id} not found\"\n                )\n            if type(current) is not type(updated):\n                raise TypeError(\n                    f\"Can not update credentials with ID {updated.id} \"\n                    f\"from type {type(current)} \"\n                    f\"to type {type(updated)}\"\n                )\n\n            # Ensure no scopes are removed when updating credentials\n            if (\n                isinstance(updated, OAuth2Credentials)\n                and isinstance(current, OAuth2Credentials)\n                and not set(updated.scopes).issuperset(current.scopes)\n            ):\n                raise ValueError(\n                    f\"Can not update credentials with ID {updated.id} \"\n                    f\"and scopes {current.scopes} \"\n                    f\"to more restrictive set of scopes {updated.scopes}\"\n                )\n\n            # Update the credentials\n            updated_credentials_list = [\n                updated if c.id == updated.id else c\n                for c in self.get_all_creds(user_id)\n            ]\n            self._set_user_integration_creds(user_id, updated_credentials_list)",
          "blocks": [
            {
              "id": 1,
              "label": "with self.locked_user_integrations(user_id):\ncurrent = self.get_creds_by_id(user_id, updated.id)",
              "successors": [
                3
              ]
            },
            {
              "id": 3,
              "label": "if not current:",
              "successors": [
                4,
                5
              ]
            },
            {
              "id": 4,
              "label": "raise ValueError(...)",
              "successors": []
            },
            {
              "id": 5,
              "label": "if type(current) is not type(updated):\nraise TypeError(...)",
              "successors": []
            },
            {
              "id": 7,
              "label": "if (isinstance(updated, OAuth2Credentials) and isinstance(current, OAuth2Credentials) and not set(updated.scopes).issuperset(current.scopes)):",
              "successors": [
                8,
                9
              ]
            },
            {
              "id": 8,
              "label": "raise ValueError(...)",
              "successors": []
            },
            {
              "id": 9,
              "label": "updated_credentials_list = [updated if c.id == updated.id else c for c in self.get_all_creds(user_id)]",
              "successors": [
                10
              ]
            },
            {
              "id": 10,
              "label": "self._set_user_integration_creds(user_id, updated_credentials_list)",
              "successors": []
            }
          ]
        },
        {
          "name": "delete_creds_by_id",
          "type": "function",
          "start_line": 206,
          "end_line": 211,
          "functions": [],
          "classes": [],
          "simplified_code": "    def delete_creds_by_id(self, user_id: str, credentials_id: str) -> None:\n        with self.locked_user_integrations(user_id):\n            filtered_credentials = [\n                c for c in self.get_all_creds(user_id) if c.id != credentials_id\n            ]\n            self._set_user_integration_creds(user_id, filtered_credentials)",
          "blocks": [
            {
              "id": 1,
              "label": "with self.locked_user_integrations(user_id):\nfiltered_credentials = [c for c in self.get_all_creds(user_id) if c.id != credentials_id]\nself._set_user_integration_creds(user_id, filtered_credentials)",
              "successors": []
            }
          ]
        },
        {
          "name": "store_state_token",
          "type": "function",
          "start_line": 213,
          "end_line": 234,
          "functions": [],
          "classes": [],
          "simplified_code": "    def store_state_token(self, user_id: str, provider: str, scopes: list[str]) -> str:\n        token = secrets.token_urlsafe(32)\n        expires_at = datetime.now(timezone.utc) + timedelta(minutes=10)\n\n        state = OAuthState(\n            token=token,\n            provider=provider,\n            expires_at=int(expires_at.timestamp()),\n            scopes=scopes,\n        )\n\n        with self.locked_user_integrations(user_id):\n            user_integrations = self._get_user_integrations(user_id)\n            oauth_states = user_integrations.oauth_states\n            oauth_states.append(state)\n            user_integrations.oauth_states = oauth_states\n\n            self.db_manager.update_user_integrations(\n                user_id=user_id, data=user_integrations\n            )\n\n        return token",
          "blocks": [
            {
              "id": 1,
              "label": "token = secrets.token_urlsafe(32)\nexpires_at = datetime.now(timezone.utc) + timedelta(minutes=10)\n\nstate = OAuthState(\n    token=token,\n    provider=provider,\n    expires_at=int(expires_at.timestamp()),\n    scopes=scopes,\n)\nwith self.locked_user_integrations(user_id):\nuser_integrations = self._get_user_integrations(user_id)\noauth_states = user_integrations.oauth_states\noauth_states.append(state)\nuser_integrations.oauth_states = oauth_states\n\nself.db_manager.update_user_integrations(\n    user_id=user_id, data=user_integrations\n)",
              "successors": [
                4
              ]
            },
            {
              "id": 4,
              "label": "return token",
              "successors": []
            }
          ]
        },
        {
          "name": "get_any_valid_scopes_from_state_token",
          "type": "function",
          "start_line": 236,
          "end_line": 264,
          "functions": [],
          "classes": [],
          "simplified_code": "    def get_any_valid_scopes_from_state_token(\n        self, user_id: str, token: str, provider: str\n    ) -> list[str]:\n        \"\"\"\n        Get the valid scopes from the OAuth state token. This will return any valid scopes\n        from any OAuth state token for the given provider. If no valid scopes are found,\n        an empty list is returned. DO NOT RELY ON THIS TOKEN TO AUTHENTICATE A USER, AS IT\n        IS TO CHECK IF THE USER HAS GIVEN PERMISSIONS TO THE APPLICATION BEFORE EXCHANGING\n        THE CODE FOR TOKENS.\n        \"\"\"\n        user_integrations = self._get_user_integrations(user_id)\n        oauth_states = user_integrations.oauth_states\n\n        now = datetime.now(timezone.utc)\n        valid_state = next(\n            (\n                state\n                for state in oauth_states\n                if state.token == token\n                and state.provider == provider\n                and state.expires_at > now.timestamp()\n            ),\n            None,\n        )\n\n        if valid_state:\n            return valid_state.scopes\n\n        return []",
          "blocks": [
            {
              "id": 1,
              "label": "user_integrations = self._get_user_integrations(user_id)\noauth_states = user_integrations.oauth_states\nnow = datetime.now(timezone.utc)\nvalid_state = next((\n                state\n                for state in oauth_states\n                if state.token == token\n                and state.provider == provider\n                and state.expires_at > now.timestamp()\n            ),\n            None,\n        )\nif valid_state:\nreturn valid_state.scopes",
              "successors": []
            },
            {
              "id": 7,
              "label": "return []",
              "successors": []
            }
          ]
        },
        {
          "name": "verify_state_token",
          "type": "function",
          "start_line": 266,
          "end_line": 290,
          "functions": [],
          "classes": [],
          "simplified_code": "    def verify_state_token(self, user_id: str, token: str, provider: str) -> bool:\n        with self.locked_user_integrations(user_id):\n            user_integrations = self._get_user_integrations(user_id)\n            oauth_states = user_integrations.oauth_states\n\n            now = datetime.now(timezone.utc)\n            valid_state = next(\n                (\n                    state\n                    for state in oauth_states\n                    if state.token == token\n                    and state.provider == provider\n                    and state.expires_at > now.timestamp()\n                ),\n                None,\n            )\n\n            if valid_state:\n                # Remove the used state\n                oauth_states.remove(valid_state)\n                user_integrations.oauth_states = oauth_states\n                self.db_manager.update_user_integrations(user_id, user_integrations)\n                return True\n\n        return False",
          "blocks": [
            {
              "id": 1,
              "label": "with self.locked_user_integrations(user_id):\nuser_integrations = self._get_user_integrations(user_id)\noauth_states = user_integrations.oauth_states\nnow = datetime.now(timezone.utc)\nvalid_state = next((state for state in oauth_states if state.token == token and state.provider == provider and state.expires_at > now.timestamp()), None)\nif valid_state:\noauth_states.remove(valid_state)\nuser_integrations.oauth_states = oauth_states\nself.db_manager.update_user_integrations(user_id, user_integrations)\nreturn True",
              "successors": []
            },
            {
              "id": 6,
              "label": "return False",
              "successors": []
            }
          ]
        },
        {
          "name": "_set_user_integration_creds",
          "type": "function",
          "start_line": 292,
          "end_line": 299,
          "functions": [],
          "classes": [],
          "simplified_code": "    def _set_user_integration_creds(\n        self, user_id: str, credentials: list[Credentials]\n    ) -> None:\n        integrations = self._get_user_integrations(user_id)\n        # Remove default credentials from the list\n        credentials = [c for c in credentials if c not in DEFAULT_CREDENTIALS]\n        integrations.credentials = credentials\n        self.db_manager.update_user_integrations(user_id, integrations)",
          "blocks": [
            {
              "id": 1,
              "label": "integrations = self._get_user_integrations(user_id)\ncredentials = [c for c in credentials if c not in DEFAULT_CREDENTIALS]\nintegrations.credentials = credentials\nself.db_manager.update_user_integrations(user_id, integrations)",
              "successors": []
            }
          ]
        },
        {
          "name": "_get_user_integrations",
          "type": "function",
          "start_line": 301,
          "end_line": 305,
          "functions": [],
          "classes": [],
          "simplified_code": "    def _get_user_integrations(self, user_id: str) -> UserIntegrations:\n        integrations: UserIntegrations = self.db_manager.get_user_integrations(\n            user_id=user_id\n        )\n        return integrations",
          "blocks": [
            {
              "id": 1,
              "label": "integrations: UserIntegrations = self.db_manager.get_user_integrations(user_id=user_id)\nreturn integrations",
              "successors": []
            }
          ]
        },
        {
          "name": "locked_user_integrations",
          "type": "function",
          "start_line": 307,
          "end_line": 309,
          "functions": [],
          "classes": [],
          "simplified_code": "    def locked_user_integrations(self, user_id: str):\n        key = (f\"user:{user_id}\", \"integrations\")\n        return self.locks.locked(key)",
          "blocks": [
            {
              "id": 1,
              "label": "def locked_user_integrations(self, user_id: str):\nkey = (f\"user:{user_id}\", \"integrations\")\nreturn self.locks.locked(key)",
              "successors": []
            }
          ]
        }
      ],
      "classes": [],
      "simplified_code": "class IntegrationCredentialsStore:\n        self.locks = RedisKeyedMutex(get_redis())\n\n    @property\n    @thread_cached\n        return get_service_client(DatabaseManager)\n\n            )\n\n        return all_credentials\n\n        return next((c for c in all_credentials if c.id == credentials_id), None)\n\n        return [c for c in credentials if c.provider == provider]\n\n        return list(set(c.provider for c in credentials))\n\n            self._set_user_integration_creds(user_id, updated_credentials_list)\n\n            self._set_user_integration_creds(user_id, filtered_credentials)\n\n        return token\n\n        return []\n\n        return False\n\n        self.db_manager.update_user_integrations(user_id, integrations)\n\n        return integrations\n\n        return self.locks.locked(key)",
      "blocks": [
        {
          "id": 1,
          "label": "class IntegrationCredentialsStore:\nself.locks = RedisKeyedMutex(get_redis())",
          "successors": []
        }
      ]
    }
  ],
  "simplified_code": "import secrets\nfrom datetime import datetime, timedelta, timezone\nfrom typing import TYPE_CHECKING\n\nfrom pydantic import SecretStr\n\nif TYPE_CHECKING:\n    from backend.executor.database import DatabaseManager\n\nfrom autogpt_libs.utils.cache import thread_cached\nfrom autogpt_libs.utils.synchronize import RedisKeyedMutex\n\nfrom backend.data.model import (\n    APIKeyCredentials,\n    Credentials,\n    OAuth2Credentials,\n    OAuthState,\n    UserIntegrations,\n)\nfrom backend.util.settings import Settings\n\nsettings = Settings()\n\nrevid_credentials = APIKeyCredentials(\n    id=\"fdb7f412-f519-48d1-9b5f-d2f73d0e01fe\",\n    provider=\"revid\",\n    api_key=SecretStr(settings.secrets.revid_api_key),\n    title=\"Use Credits for Revid\",\n    expires_at=None,\n)\nideogram_credentials = APIKeyCredentials(\n    id=\"760f84fc-b270-42de-91f6-08efe1b512d0\",\n    provider=\"ideogram\",\n    api_key=SecretStr(settings.secrets.ideogram_api_key),\n    title=\"Use Credits for Ideogram\",\n    expires_at=None,\n)\nreplicate_credentials = APIKeyCredentials(\n    id=\"6b9fc200-4726-4973-86c9-cd526f5ce5db\",\n    provider=\"replicate\",\n    api_key=SecretStr(settings.secrets.replicate_api_key),\n    title=\"Use Credits for Replicate\",\n    expires_at=None,\n)\nopenai_credentials = APIKeyCredentials(\n    id=\"53c25cb8-e3ee-465c-a4d1-e75a4c899c2a\",\n    provider=\"openai\",\n    api_key=SecretStr(settings.secrets.openai_api_key),\n    title=\"Use Credits for OpenAI\",\n    expires_at=None,\n)\nanthropic_credentials = APIKeyCredentials(\n    id=\"24e5d942-d9e3-4798-8151-90143ee55629\",\n    provider=\"anthropic\",\n    api_key=SecretStr(settings.secrets.anthropic_api_key),\n    title=\"Use Credits for Anthropic\",\n    expires_at=None,\n)\ngroq_credentials = APIKeyCredentials(\n    id=\"4ec22295-8f97-4dd1-b42b-2c6957a02545\",\n    provider=\"groq\",\n    api_key=SecretStr(settings.secrets.groq_api_key),\n    title=\"Use Credits for Groq\",\n    expires_at=None,\n)\ndid_credentials = APIKeyCredentials(\n    id=\"7f7b0654-c36b-4565-8fa7-9a52575dfae2\",\n    provider=\"d_id\",\n    api_key=SecretStr(settings.secrets.did_api_key),\n    title=\"Use Credits for D-ID\",\n    expires_at=None,\n)\njina_credentials = APIKeyCredentials(\n    id=\"7f26de70-ba0d-494e-ba76-238e65e7b45f\",\n    provider=\"jina\",\n    api_key=SecretStr(settings.secrets.jina_api_key),\n    title=\"Use Credits for Jina\",\n    expires_at=None,\n)\nunreal_credentials = APIKeyCredentials(\n    id=\"66f20754-1b81-48e4-91d0-f4f0dd82145f\",\n    provider=\"unreal\",\n    api_key=SecretStr(settings.secrets.unreal_speech_api_key),\n    title=\"Use Credits for Unreal\",\n    expires_at=None,\n)\nopen_router_credentials = APIKeyCredentials(\n    id=\"b5a0e27d-0c98-4df3-a4b9-10193e1f3c40\",\n    provider=\"open_router\",\n    api_key=SecretStr(settings.secrets.open_router_api_key),\n    title=\"Use Credits for Open Router\",\n    expires_at=None,\n)\n\n\nDEFAULT_CREDENTIALS = [\n    revid_credentials,\n    ideogram_credentials,\n    replicate_credentials,\n    openai_credentials,\n    anthropic_credentials,\n    groq_credentials,\n    did_credentials,\n    jina_credentials,\n    unreal_credentials,\n    open_router_credentials,\n]\n\n\n        return self.locks.locked(key)",
  "blocks": [
    {
      "id": 1,
      "label": "import secrets; from datetime import datetime, timedelta, timezone; from typing import TYPE_CHECKING; from pydantic import SecretStr\nif TYPE_CHECKING: from backend.executor.database import DatabaseManager\nfrom autogpt_libs.utils.cache import thread_cached; from autogpt_libs.utils.synchronize import RedisKeyedMutex; from backend.data.model import ( APIKeyCredentials, Credentials, OAuth2Credentials, OAuthState, UserIntegrations, ); from backend.util.settings import Settings\nsettings = Settings()\nrevid_credentials = APIKeyCredentials( id=\"fdb7f412-f519-48d1-9b5f-d2f73d0e01fe\", provider=\"revid\", api_key=SecretStr(settings.secrets.revid_api_key), title=\"Use Credits for Revid\", expires_at=None )\nideogram_credentials = APIKeyCredentials( id=\"760f84fc-b270-42de-91f6-08efe1b512d0\", provider=\"ideogram\", api_key=SecretStr(settings.secrets.ideogram_api_key), title=\"Use Credits for Ideogram\", expires_at=None )\nreplicate_credentials = APIKeyCredentials( id=\"6b9fc200-4726-4973-86c9-cd526f5ce5db\", provider=\"replicate\", api_key=SecretStr(settings.secrets.replicate_api_key), title=\"Use Credits for Replicate\", expires_at=None )\nopenai_credentials = APIKeyCredentials( id=\"53c25cb8-e3ee-465c-a4d1-e75a4c899c2a\", provider=\"openai\", api_key=SecretStr(settings.secrets.openai_api_key), title=\"Use Credits for OpenAI\", expires_at=None )\nanthropic_credentials = APIKeyCredentials( id=\"24e5d942-d9e3-4798-8151-90143ee55629\", provider=\"anthropic\", api_key=SecretStr(settings.secrets.anthropic_api_key), title=\"Use Credits for Anthropic\", expires_at=None )\ngroq_credentials = APIKeyCredentials( id=\"4ec22295-8f97-4dd1-b42b-2c6957a02545\", provider=\"groq\", api_key=SecretStr(settings.secrets.groq_api_key), title=\"Use Credits for Groq\", expires_at=None )\ndid_credentials = APIKeyCredentials( id=\"7f7b0654-c36b-4565-8fa7-9a52575dfae2\", provider=\"d_id\", api_key=SecretStr(settings.secrets.did_api_key), title=\"Use Credits for D-ID\", expires_at=None )\njina_credentials = APIKeyCredentials( id=\"7f26de70-ba0d-494e-ba76-238e65e7b45f\", provider=\"jina\", api_key=SecretStr(settings.secrets.jina_api_key), title=\"Use Credits for Jina\", expires_at=None )\nunreal_credentials = APIKeyCredentials( id=\"66f20754-1b81-48e4-91d0-f4f0dd82145f\", provider=\"unreal\", api_key=SecretStr(settings.secrets.unreal_speech_api_key), title=\"Use Credits for Unreal\", expires_at=None )\nopen_router_credentials = APIKeyCredentials( id=\"b5a0e27d-0c98-4df3-a4b9-10193e1f3c40\", provider=\"open_router\", api_key=SecretStr(settings.secrets.open_router_api_key), title=\"Use Credits for Open Router\", expires_at=None )\nDEFAULT_CREDENTIALS = [ revid_credentials, ideogram_credentials, replicate_credentials, openai_credentials, anthropic_credentials, groq_credentials, did_credentials, jina_credentials, unreal_credentials, open_router_credentials, ]\nreturn self.locks.locked(key)",
      "successors": []
    }
  ]
}