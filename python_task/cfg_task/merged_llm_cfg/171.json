{
  "name": "example_script",
  "type": "CFG",
  "start_line": 1,
  "end_line": 276,
  "functions": [
    {
      "name": "expose",
      "type": "function",
      "start_line": 51,
      "end_line": 70,
      "functions": [
        {
          "name": "wrapper",
          "type": "function",
          "start_line": 60,
          "end_line": 66,
          "functions": [],
          "classes": [],
          "simplified_code": "    def wrapper(*args, **kwargs):\n        try:\n            return func(*args, **kwargs)\n        except Exception as e:\n            msg = f\"Error in {func.__name__}: {e.__str__()}\"\n            logger.exception(msg)\n            raise",
          "blocks": [
            {
              "id": 1,
              "label": "def wrapper(*args, **kwargs):\ntry:",
              "successors": [
                {
                  "id": 3,
                  "label": "return func(*args, **kwargs)",
                  "successors": []
                },
                {
                  "id": 4,
                  "label": "except Exception as e:\nmsg = f\"Error in {func.__name__}: {e.__str__()}\"",
                  "successors": [
                    {
                      "id": 6,
                      "label": "logger.exception(msg)\nraise",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "classes": [],
      "simplified_code": "def expose(func: C) -> C:\n    \"\"\"\n    Decorator to mark a method or class to be exposed for remote calls.\n\n    ## ⚠️ Gotcha\n    Aside from \"simple\" types, only Pydantic models are passed unscathed *if annotated*.\n    Any other passed or returned class objects are converted to dictionaries by Pyro.\n    \"\"\"\n\n            raise\n\n    register_pydantic_serializers(func)\n\n    return pyro.expose(wrapper)  # type: ignore",
      "blocks": [
        {
          "id": 1,
          "label": "def expose(func: C) -> C:\n\"\"\"\nDecorator to mark a method or class to be exposed for remote calls.\n\n## ⚠️ Gotcha\nAside from \"simple\" types, only Pydantic models are passed unscathed *if annotated*.\nAny other passed or returned class objects are converted to dictionaries by Pyro.\n\"\"\"",
          "successors": [
            {
              "id": 3,
              "label": "raise",
              "successors": []
            },
            {
              "id": 4,
              "label": "register_pydantic_serializers(func)\nreturn pyro.expose(wrapper)  # type: ignore",
              "successors": []
            }
          ]
        }
      ]
    },
    {
      "name": "register_pydantic_serializers",
      "type": "function",
      "start_line": 73,
      "end_line": 89,
      "functions": [],
      "classes": [],
      "simplified_code": "def register_pydantic_serializers(func: Callable):\n    \"\"\"Register custom serializers and deserializers for annotated Pydantic models\"\"\"\n    for name, annotation in func.__annotations__.items():\n        try:\n            pydantic_types = _pydantic_models_from_type_annotation(annotation)\n        except Exception as e:\n            raise TypeError(f\"Error while exposing {func.__name__}: {e.__str__()}\")\n\n        for model in pydantic_types:\n            logger.debug(\n                f\"Registering Pyro (de)serializers for {func.__name__} annotation \"\n                f\"'{name}': {model.__qualname__}\"\n            )\n            pyro.register_class_to_dict(model, _make_custom_serializer(model))\n            pyro.register_dict_to_class(\n                model.__qualname__, _make_custom_deserializer(model)\n            )",
      "blocks": [
        {
          "id": 1,
          "label": "def register_pydantic_serializers(func: Callable):",
          "successors": [
            {
              "id": 2,
              "label": "for name, annotation in func.__annotations__.items():",
              "successors": [
                {
                  "id": 3,
                  "label": "try:",
                  "successors": [
                    {
                      "id": 4,
                      "label": "pydantic_types = _pydantic_models_from_type_annotation(annotation)",
                      "successors": [
                        {
                          "id": 6,
                          "label": "for model in pydantic_types:",
                          "successors": [
                            {
                              "id": 7,
                              "label": "logger.debug( f\"Registering Pyro (de)serializers for {func.__name__} annotation '{name}': {model.__qualname__}\" )\npyro.register_class_to_dict(model, _make_custom_serializer(model))",
                              "successors": [
                                {
                                  "id": 9,
                                  "label": "pyro.register_dict_to_class( model.__qualname__, _make_custom_deserializer(model) )",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "id": 5,
                      "label": "except Exception as e:\nraise TypeError(f\"Error while exposing {func.__name__}: {e.__str__()}\")",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "_make_custom_serializer",
      "type": "function",
      "start_line": 92,
      "end_line": 101,
      "functions": [
        {
          "name": "custom_class_to_dict",
          "type": "function",
          "start_line": 93,
          "end_line": 99,
          "functions": [],
          "classes": [],
          "simplified_code": "    def custom_class_to_dict(obj):\n        data = {\n            \"__class__\": obj.__class__.__qualname__,\n            **obj.model_dump(),\n        }\n        logger.debug(f\"Serializing {obj.__class__.__qualname__} with data: {data}\")\n        return data",
          "blocks": [
            {
              "id": 1,
              "label": "def custom_class_to_dict(obj):\n    data = {\n        \"__class__\": obj.__class__.__qualname__,\n        **obj.model_dump(),\n    }",
              "successors": [
                {
                  "id": 3,
                  "label": "    logger.debug(f\"Serializing {obj.__class__.__qualname__} with data: {data}\")\n    return data",
                  "successors": []
                }
              ]
            }
          ]
        }
      ],
      "classes": [],
      "simplified_code": "def _make_custom_serializer(model: Type[BaseModel]):\n        return data\n\n    return custom_class_to_dict",
      "blocks": [
        {
          "id": 1,
          "label": "def _make_custom_serializer(model: Type[BaseModel]):\n    return data",
          "successors": []
        }
      ]
    },
    {
      "name": "_make_custom_deserializer",
      "type": "function",
      "start_line": 104,
      "end_line": 109,
      "functions": [
        {
          "name": "custom_dict_to_class",
          "type": "function",
          "start_line": 105,
          "end_line": 107,
          "functions": [],
          "classes": [],
          "simplified_code": "    def custom_dict_to_class(qualname, data: dict):\n        logger.debug(f\"Deserializing {model.__qualname__} from data: {data}\")\n        return model(**data)",
          "blocks": [
            {
              "id": 1,
              "label": "def custom_dict_to_class(qualname, data: dict):\nlogger.debug(f\"Deserializing {model.__qualname__} from data: {data}\")",
              "successors": [
                {
                  "id": 3,
                  "label": "return model(**data)",
                  "successors": []
                }
              ]
            }
          ]
        }
      ],
      "classes": [],
      "simplified_code": "def _make_custom_deserializer(model: Type[BaseModel]):\n        return model(**data)\n\n    return custom_dict_to_class",
      "blocks": [
        {
          "id": 1,
          "label": "def _make_custom_deserializer(model: Type[BaseModel]):\n    return model(**data)",
          "successors": []
        }
      ]
    },
    {
      "name": "close_service_client",
      "type": "function",
      "start_line": 203,
      "end_line": 207,
      "functions": [],
      "classes": [],
      "simplified_code": "def close_service_client(client: AppService) -> None:\n    if isinstance(client, PyroClient):\n        client.proxy._pyroRelease()\n    else:\n        raise RuntimeError(f\"Client {client.__class__} is not a Pyro client.\")",
      "blocks": [
        {
          "id": 1,
          "label": "def close_service_client(client: AppService) -> None:\nif isinstance(client, PyroClient):",
          "successors": [
            {
              "id": 3,
              "label": "    client.proxy._pyroRelease()",
              "successors": []
            },
            {
              "id": 4,
              "label": "else:\n    raise RuntimeError(f\"Client {client.__class__} is not a Pyro client.\")",
              "successors": []
            }
          ]
        }
      ]
    },
    {
      "name": "get_service_client",
      "type": "function",
      "start_line": 210,
      "end_line": 228,
      "functions": [],
      "classes": [
        {
          "name": "DynamicClient",
          "type": "class",
          "start_line": 213,
          "end_line": 228,
          "functions": [
            {
              "name": "__init__",
              "type": "function",
              "start_line": 215,
              "end_line": 222,
              "functions": [],
              "classes": [],
              "simplified_code": "        def __init__(self):\n            host = os.environ.get(f\"{service_name.upper()}_HOST\", pyro_host)\n            uri = f\"PYRO:{service_type.service_name}@{host}:{service_type.get_port()}\"\n            logger.debug(f\"Connecting to service [{service_name}]. URI = {uri}\")\n            self.proxy = Pyro5.api.Proxy(uri)\n            # Attempt to bind to ensure the connection is established\n            self.proxy._pyroBind()\n            logger.debug(f\"Successfully connected to service [{service_name}]\")",
              "blocks": [
                {
                  "id": 1,
                  "label": "def __init__(self):\nhost = os.environ.get(f\"{service_name.upper()}_HOST\", pyro_host)\nuri = f\"PYRO:{service_type.service_name}@{host}:{service_type.get_port()}\"\nlogger.debug(f\"Connecting to service [{service_name}]. URI = {uri}\")\nself.proxy = Pyro5.api.Proxy(uri)",
                  "successors": [
                    {
                      "id": 3,
                      "label": "self.proxy._pyroBind()\nlogger.debug(f\"Successfully connected to service [{service_name}]\")",
                      "successors": []
                    }
                  ]
                }
              ]
            },
            {
              "name": "__getattr__",
              "type": "function",
              "start_line": 224,
              "end_line": 226,
              "functions": [],
              "classes": [],
              "simplified_code": "        def __getattr__(self, name: str) -> Callable[..., Any]:\n            res = getattr(self.proxy, name)\n            return res",
              "blocks": [
                {
                  "id": 1,
                  "label": "def __getattr__(self, name: str) -> Callable[..., Any]:\n    res = getattr(self.proxy, name)",
                  "successors": [
                    {
                      "id": 3,
                      "label": "    return res",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ],
          "classes": [],
          "simplified_code": "    class DynamicClient(PyroClient):\n        @conn_retry(\"Pyro\", f\"Connecting to [{service_name}]\")\n            logger.debug(f\"Successfully connected to service [{service_name}]\")\n\n            return res\n\n    return cast(AS, DynamicClient())",
          "blocks": [
            {
              "id": 1,
              "label": "class DynamicClient(PyroClient):\n@conn_retry(\"Pyro\", f\"Connecting to [{service_name}]\")",
              "successors": [
                {
                  "id": 3,
                  "label": "logger.debug(f\"Successfully connected to service [{service_name}]\")\nreturn res",
                  "successors": []
                }
              ]
            }
          ]
        }
      ],
      "simplified_code": "def get_service_client(service_type: Type[AS]) -> AS:\n    service_name = service_type.service_name\n\n    return cast(AS, DynamicClient())",
      "blocks": [
        {
          "id": 1,
          "label": "def get_service_client(service_type: Type[AS]) -> AS:\n service_name = service_type.service_name\nreturn cast(AS, DynamicClient())",
          "successors": []
        }
      ]
    },
    {
      "name": "_pydantic_models_from_type_annotation",
      "type": "function",
      "start_line": 234,
      "end_line": 276,
      "functions": [],
      "classes": [],
      "simplified_code": "def _pydantic_models_from_type_annotation(annotation) -> Iterator[type[BaseModel]]:\n    # Peel Annotated parameters\n    if (origin := get_origin(annotation)) and origin is Annotated:\n        annotation = get_args(annotation)[0]\n\n    origin = get_origin(annotation)\n    args = get_args(annotation)\n\n    if origin in (\n        Union,\n        UnionType,\n        list,\n        List,\n        tuple,\n        Tuple,\n        set,\n        Set,\n        frozenset,\n        FrozenSet,\n    ):\n        for arg in args:\n            yield from _pydantic_models_from_type_annotation(arg)\n    elif origin in (dict, Dict):\n        key_type, value_type = args\n        yield from _pydantic_models_from_type_annotation(key_type)\n        yield from _pydantic_models_from_type_annotation(value_type)\n    elif origin in (Awaitable, Coroutine):\n        # For coroutines and awaitables, check the return type\n        return_type = args[-1]\n        yield from _pydantic_models_from_type_annotation(return_type)\n    else:\n        annotype = annotation if origin is None else origin\n\n        # Exclude generic types and aliases\n        if (\n            annotype is not None\n            and not hasattr(typing, getattr(annotype, \"__name__\", \"\"))\n            and isinstance(annotype, type)\n        ):\n            if issubclass(annotype, BaseModel):\n                yield annotype\n            elif annotype not in builtin_types and not issubclass(annotype, Enum):\n                raise TypeError(f\"Unsupported type encountered: {annotype}\")",
      "blocks": [
        {
          "id": 1,
          "label": "def _pydantic_models_from_type_annotation(annotation) -> Iterator[type[BaseModel]]:\n    if (origin := get_origin(annotation)) and origin is Annotated:",
          "successors": [
            {
              "id": 3,
              "label": "        annotation = get_args(annotation)[0]\n    origin = get_origin(annotation)\n    args = get_args(annotation)",
              "successors": [
                {
                  "id": 5,
                  "label": "    if origin in (Union, UnionType, list, List, tuple, Tuple, set, Set, frozenset, FrozenSet):",
                  "successors": [
                    {
                      "id": 6,
                      "label": "        for arg in args:\n            yield from _pydantic_models_from_type_annotation(arg)",
                      "successors": [
                        {
                          "id": 10,
                          "label": "else:\n    annotype = annotation if origin is None else origin",
                          "successors": [
                            {
                              "id": 12,
                              "label": "    if (annotype is not None\n        and not hasattr(typing, getattr(annotype, \"__name__\", \"\"))\n        and isinstance(annotype, type)):\n        if issubclass(annotype, BaseModel):",
                              "successors": [
                                {
                                  "id": 14,
                                  "label": "            yield annotype",
                                  "successors": []
                                },
                                {
                                  "id": 15,
                                  "label": "elif annotype not in builtin_types and not issubclass(annotype, Enum):\n                raise TypeError(f\"Unsupported type encountered: {annotype}\")",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "id": 7,
                      "label": "elif origin in (dict, Dict):\n        key_type, value_type = args\n        yield from _pydantic_models_from_type_annotation(key_type)\n        yield from _pydantic_models_from_type_annotation(value_type)",
                      "successors": [
                        {
                          "id": 10,
                          "label": "else:\n    annotype = annotation if origin is None else origin",
                          "successors": [
                            {
                              "id": 12,
                              "label": "    if (annotype is not None\n        and not hasattr(typing, getattr(annotype, \"__name__\", \"\"))\n        and isinstance(annotype, type)):\n        if issubclass(annotype, BaseModel):",
                              "successors": [
                                {
                                  "id": 14,
                                  "label": "            yield annotype",
                                  "successors": []
                                },
                                {
                                  "id": 15,
                                  "label": "elif annotype not in builtin_types and not issubclass(annotype, Enum):\n                raise TypeError(f\"Unsupported type encountered: {annotype}\")",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "id": 9,
                      "label": "elif origin in (Awaitable, Coroutine):\n        return_type = args[-1]\n        yield from _pydantic_models_from_type_annotation(return_type)",
                      "successors": [
                        {
                          "id": 10,
                          "label": "else:\n    annotype = annotation if origin is None else origin",
                          "successors": [
                            {
                              "id": 12,
                              "label": "    if (annotype is not None\n        and not hasattr(typing, getattr(annotype, \"__name__\", \"\"))\n        and isinstance(annotype, type)):\n        if issubclass(annotype, BaseModel):",
                              "successors": [
                                {
                                  "id": 14,
                                  "label": "            yield annotype",
                                  "successors": []
                                },
                                {
                                  "id": 15,
                                  "label": "elif annotype not in builtin_types and not issubclass(annotype, Enum):\n                raise TypeError(f\"Unsupported type encountered: {annotype}\")",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    }
  ],
  "classes": [
    {
      "name": "AppService",
      "type": "class",
      "start_line": 112,
      "end_line": 190,
      "functions": [
        {
          "name": "__init__",
          "type": "function",
          "start_line": 118,
          "end_line": 119,
          "functions": [],
          "classes": [],
          "simplified_code": "    def __init__(self):\n        self.uri = None",
          "blocks": [
            {
              "id": 1,
              "label": "def __init__(self):\n    self.uri = None",
              "successors": []
            }
          ]
        },
        {
          "name": "get_port",
          "type": "function",
          "start_line": 123,
          "end_line": 124,
          "functions": [],
          "classes": [],
          "simplified_code": "    def get_port(cls) -> int:\n        pass",
          "blocks": [
            {
              "id": 1,
              "label": "def get_port(cls) -> int:\npass",
              "successors": []
            }
          ]
        },
        {
          "name": "get_host",
          "type": "function",
          "start_line": 127,
          "end_line": 128,
          "functions": [],
          "classes": [],
          "simplified_code": "    def get_host(cls) -> str:\n        return os.environ.get(f\"{cls.service_name.upper()}_HOST\", config.pyro_host)",
          "blocks": [
            {
              "id": 1,
              "label": "def get_host(cls) -> str:\n    return os.environ.get(f\"{cls.service_name.upper()}_HOST\", config.pyro_host)",
              "successors": []
            }
          ]
        },
        {
          "name": "run_service",
          "type": "function",
          "start_line": 130,
          "end_line": 132,
          "functions": [],
          "classes": [],
          "simplified_code": "    def run_service(self) -> None:\n        while True:\n            time.sleep(10)",
          "blocks": [
            {
              "id": 1,
              "label": "def run_service(self) -> None:",
              "successors": [
                {
                  "id": 2,
                  "label": "while True:",
                  "successors": [
                    {
                      "id": 3,
                      "label": "    time.sleep(10)",
                      "successors": [
                        {
                          "id": 2,
                          "label": "while True:",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "__run_async",
          "type": "function",
          "start_line": 134,
          "end_line": 135,
          "functions": [],
          "classes": [],
          "simplified_code": "    def __run_async(self, coro: Coroutine[Any, Any, T]):\n        return asyncio.run_coroutine_threadsafe(coro, self.shared_event_loop)",
          "blocks": [
            {
              "id": 1,
              "label": "def __run_async(self, coro: Coroutine[Any, Any, T]):\nreturn asyncio.run_coroutine_threadsafe(coro, self.shared_event_loop)",
              "successors": []
            }
          ]
        },
        {
          "name": "run_and_wait",
          "type": "function",
          "start_line": 137,
          "end_line": 139,
          "functions": [],
          "classes": [],
          "simplified_code": "    def run_and_wait(self, coro: Coroutine[Any, Any, T]) -> T:\n        future = self.__run_async(coro)\n        return future.result()",
          "blocks": [
            {
              "id": 1,
              "label": "def run_and_wait(self, coro: Coroutine[Any, Any, T]) -> T:\n    future = self.__run_async(coro)",
              "successors": [
                {
                  "id": 3,
                  "label": "    return future.result()",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "run",
          "type": "function",
          "start_line": 141,
          "end_line": 166,
          "functions": [],
          "classes": [],
          "simplified_code": "    def run(self):\n        self.shared_event_loop = asyncio.get_event_loop()\n        if self.use_db:\n            self.shared_event_loop.run_until_complete(db.connect())\n        if self.use_redis:\n            redis.connect()\n        if self.use_supabase:\n            from supabase import create_client\n\n            secrets = Secrets()\n            self.supabase = create_client(\n                secrets.supabase_url, secrets.supabase_service_role_key\n            )\n\n        # Initialize the async loop.\n        async_thread = threading.Thread(target=self.__start_async_loop)\n        async_thread.daemon = True\n        async_thread.start()\n\n        # Initialize pyro service\n        daemon_thread = threading.Thread(target=self.__start_pyro)\n        daemon_thread.daemon = True\n        daemon_thread.start()\n\n        # Run the main service (if it's not implemented, just sleep).\n        self.run_service()",
          "blocks": [
            {
              "id": 1,
              "label": "def run(self):\nself.shared_event_loop = asyncio.get_event_loop()",
              "successors": [
                {
                  "id": 3,
                  "label": "if self.use_db:",
                  "successors": [
                    {
                      "id": 4,
                      "label": "self.shared_event_loop.run_until_complete(db.connect())\nif self.use_redis:",
                      "successors": [
                        {
                          "id": 8,
                          "label": "redis.connect()",
                          "successors": [
                            {
                              "id": 13,
                              "label": "if self.use_supabase:\nfrom supabase import create_client\n\n            secrets = Secrets()\n            self.supabase = create_client(\n                secrets.supabase_url, secrets.supabase_service_role_key\n            )",
                              "successors": [
                                {
                                  "id": 21,
                                  "label": "async_thread = threading.Thread(target=self.__start_async_loop)\n        async_thread.daemon = True\n        async_thread.start()\ndaemon_thread = threading.Thread(target=self.__start_pyro)\n        daemon_thread.daemon = True\n        daemon_thread.start()",
                                  "successors": [
                                    {
                                      "id": 23,
                                      "label": "self.run_service()",
                                      "successors": []
                                    }
                                  ]
                                }
                              ]
                            },
                            {
                              "id": 21,
                              "label": "async_thread = threading.Thread(target=self.__start_async_loop)\n        async_thread.daemon = True\n        async_thread.start()\ndaemon_thread = threading.Thread(target=self.__start_pyro)\n        daemon_thread.daemon = True\n        daemon_thread.start()",
                              "successors": [
                                {
                                  "id": 23,
                                  "label": "self.run_service()",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "id": 13,
                      "label": "if self.use_supabase:\nfrom supabase import create_client\n\n            secrets = Secrets()\n            self.supabase = create_client(\n                secrets.supabase_url, secrets.supabase_service_role_key\n            )",
                      "successors": [
                        {
                          "id": 21,
                          "label": "async_thread = threading.Thread(target=self.__start_async_loop)\n        async_thread.daemon = True\n        async_thread.start()\ndaemon_thread = threading.Thread(target=self.__start_pyro)\n        daemon_thread.daemon = True\n        daemon_thread.start()",
                          "successors": [
                            {
                              "id": 23,
                              "label": "self.run_service()",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "id": 21,
                      "label": "async_thread = threading.Thread(target=self.__start_async_loop)\n        async_thread.daemon = True\n        async_thread.start()\ndaemon_thread = threading.Thread(target=self.__start_pyro)\n        daemon_thread.daemon = True\n        daemon_thread.start()",
                      "successors": [
                        {
                          "id": 23,
                          "label": "self.run_service()",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "cleanup",
          "type": "function",
          "start_line": 168,
          "end_line": 174,
          "functions": [],
          "classes": [],
          "simplified_code": "    def cleanup(self):\n        if self.use_db:\n            logger.info(f\"[{self.__class__.__name__}] ⏳ Disconnecting DB...\")\n            self.run_and_wait(db.disconnect())\n        if self.use_redis:\n            logger.info(f\"[{self.__class__.__name__}] ⏳ Disconnecting Redis...\")\n            redis.disconnect()",
          "blocks": [
            {
              "id": 1,
              "label": "def cleanup(self):\nif self.use_db:",
              "successors": [
                {
                  "id": 3,
                  "label": "    logger.info(f\"[{self.__class__.__name__}] ⏳ Disconnecting DB...\")\n    self.run_and_wait(db.disconnect())\nif self.use_redis:",
                  "successors": [
                    {
                      "id": 6,
                      "label": "    logger.info(f\"[{self.__class__.__name__}] ⏳ Disconnecting Redis...\")\n    redis.disconnect()",
                      "successors": []
                    }
                  ]
                },
                {
                  "id": 4,
                  "label": "if self.use_redis:\n    logger.info(f\"[{self.__class__.__name__}] ⏳ Disconnecting Redis...\")\n    redis.disconnect()",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "__start_pyro",
          "type": "function",
          "start_line": 177,
          "end_line": 187,
          "functions": [],
          "classes": [],
          "simplified_code": "    def __start_pyro(self):\n        maximum_connection_thread_count = max(\n            Pyro5.config.THREADPOOL_SIZE,\n            config.num_node_workers * config.num_graph_workers,\n        )\n\n        Pyro5.config.THREADPOOL_SIZE = maximum_connection_thread_count  # type: ignore\n        daemon = Pyro5.api.Daemon(host=config.pyro_host, port=self.get_port())\n        self.uri = daemon.register(self, objectId=self.service_name)\n        logger.info(f\"[{self.service_name}] Connected to Pyro; URI = {self.uri}\")\n        daemon.requestLoop()",
          "blocks": [
            {
              "id": 1,
              "label": "def __start_pyro(self):\nmaximum_connection_thread_count = max(\n    Pyro5.config.THREADPOOL_SIZE,\n    config.num_node_workers * config.num_graph_workers,\n)",
              "successors": [
                {
                  "id": 3,
                  "label": "Pyro5.config.THREADPOOL_SIZE = maximum_connection_thread_count  # type: ignore\ndaemon = Pyro5.api.Daemon(host=config.pyro_host, port=self.get_port())",
                  "successors": [
                    {
                      "id": 5,
                      "label": "self.uri = daemon.register(self, objectId=self.service_name)\nlogger.info(f\"[{self.service_name}] Connected to Pyro; URI = {self.uri}\")",
                      "successors": [
                        {
                          "id": 7,
                          "label": "daemon.requestLoop()",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "__start_async_loop",
          "type": "function",
          "start_line": 189,
          "end_line": 190,
          "functions": [],
          "classes": [],
          "simplified_code": "    def __start_async_loop(self):\n        self.shared_event_loop.run_forever()",
          "blocks": [
            {
              "id": 1,
              "label": "def __start_async_loop(self):\n    self.shared_event_loop.run_forever()",
              "successors": []
            }
          ]
        }
      ],
      "classes": [],
      "simplified_code": "class AppService(AppProcess, ABC):\n    shared_event_loop: asyncio.AbstractEventLoop\n    use_db: bool = False\n    use_redis: bool = False\n    use_supabase: bool = False\n\n        self.uri = None\n\n    @classmethod\n    @abstractmethod\n        pass\n\n    @classmethod\n        return os.environ.get(f\"{cls.service_name.upper()}_HOST\", config.pyro_host)\n\n            time.sleep(10)\n\n        return asyncio.run_coroutine_threadsafe(coro, self.shared_event_loop)\n\n        return future.result()\n\n        self.run_service()\n\n            redis.disconnect()\n\n    @conn_retry(\"Pyro\", \"Starting Pyro Service\")\n        daemon.requestLoop()\n\n        self.shared_event_loop.run_forever()",
      "blocks": [
        {
          "id": 1,
          "label": "class AppService(AppProcess, ABC):",
          "successors": [
            {
              "id": 2,
              "label": "shared_event_loop: asyncio.AbstractEventLoop\nuse_db: bool = False\nuse_redis: bool = False\nuse_supabase: bool = False\n\nself.uri = None",
              "successors": []
            },
            {
              "id": 3,
              "label": "@classmethod\n@abstractmethod\npass",
              "successors": []
            },
            {
              "id": 4,
              "label": "@classmethod\nreturn os.environ.get(f\"{cls.service_name.upper()}_HOST\", config.pyro_host)",
              "successors": []
            },
            {
              "id": 5,
              "label": "time.sleep(10)",
              "successors": []
            },
            {
              "id": 6,
              "label": "return asyncio.run_coroutine_threadsafe(coro, self.shared_event_loop)",
              "successors": []
            },
            {
              "id": 7,
              "label": "return future.result()",
              "successors": []
            },
            {
              "id": 8,
              "label": "self.run_service()",
              "successors": []
            },
            {
              "id": 9,
              "label": "redis.disconnect()",
              "successors": []
            },
            {
              "id": 10,
              "label": "@conn_retry(\"Pyro\", \"Starting Pyro Service\")\ndaemon.requestLoop()",
              "successors": []
            },
            {
              "id": 11,
              "label": "self.shared_event_loop.run_forever()",
              "successors": []
            }
          ]
        }
      ]
    },
    {
      "name": "PyroClient",
      "type": "class",
      "start_line": 199,
      "end_line": 202,
      "functions": [],
      "classes": [],
      "simplified_code": "class PyroClient:\n    proxy: Pyro5.api.Proxy\n\n",
      "blocks": []
    }
  ],
  "simplified_code": "import asyncio\nimport builtins\nimport logging\nimport os\nimport threading\nimport time\nimport typing\nfrom abc import ABC, abstractmethod\nfrom enum import Enum\nfrom types import NoneType, UnionType\nfrom typing import (\n    Annotated,\n    Any,\n    Awaitable,\n    Callable,\n    Coroutine,\n    Dict,\n    FrozenSet,\n    Iterator,\n    List,\n    Set,\n    Tuple,\n    Type,\n    TypeVar,\n    Union,\n    cast,\n    get_args,\n    get_origin,\n)\n\nimport Pyro5.api\nfrom pydantic import BaseModel\nfrom Pyro5 import api as pyro\nfrom Pyro5 import config as pyro_config\n\nfrom backend.data import db, redis\nfrom backend.util.process import AppProcess\nfrom backend.util.retry import conn_retry\nfrom backend.util.settings import Config, Secrets\n\nlogger = logging.getLogger(__name__)\nT = TypeVar(\"T\")\nC = TypeVar(\"C\", bound=Callable)\n\nconfig = Config()\npyro_host = config.pyro_host\npyro_config.MAX_RETRIES = config.pyro_client_comm_retry  # type: ignore\npyro_config.COMMTIMEOUT = config.pyro_client_comm_timeout  # type: ignore\n\n\n    return pyro.expose(wrapper)  # type: ignore\n\n\n            )\n\n\n    return custom_class_to_dict\n\n\n    return custom_dict_to_class\n\n\n        self.shared_event_loop.run_forever()\n\n\n# --------- UTILITIES --------- #\n\n\nAS = TypeVar(\"AS\", bound=AppService)\n\n\n\n        raise RuntimeError(f\"Client {client.__class__} is not a Pyro client.\")\n\n\n    return cast(AS, DynamicClient())\n\n\nbuiltin_types = [*vars(builtins).values(), NoneType, Enum]\n\n\n                raise TypeError(f\"Unsupported type encountered: {annotype}\")",
  "blocks": [
    {
      "id": 1,
      "label": "import asyncio\nimport builtins\nimport logging\nimport os\nimport threading\nimport time\nimport typing\nfrom abc import ABC, abstractmethod\nfrom enum import Enum\nfrom types import NoneType, UnionType\nfrom typing import (\n    Annotated,\n    Any,\n    Awaitable,\n    Callable,\n    Coroutine,\n    Dict,\n    FrozenSet,\n    Iterator,\n    List,\n    Set,\n    Tuple,\n    Type,\n    TypeVar,\n    Union,\n    cast,\n    get_args,\n    get_origin,\n)\n\nimport Pyro5.api\nfrom pydantic import BaseModel\nfrom Pyro5 import api as pyro\nfrom Pyro5 import config as pyro_config\n\nfrom backend.data import db, redis\nfrom backend.util.process import AppProcess\nfrom backend.util.retry import conn_retry\nfrom backend.util.settings import Config, Secrets\n\nlogger = logging.getLogger(__name__)\nT = TypeVar(\"T\")\nC = TypeVar(\"C\", bound=Callable)",
      "successors": [
        {
          "id": 2,
          "label": "config = Config()\npyro_host = config.pyro_host\npyro_config.MAX_RETRIES = config.pyro_client_comm_retry  # type: ignore\npyro_config.COMMTIMEOUT = config.pyro_client_comm_timeout  # type: ignore",
          "successors": [
            {
              "id": 3,
              "label": "return pyro.expose(wrapper)  # type: ignore",
              "successors": []
            },
            {
              "id": 4,
              "label": "return custom_class_to_dict",
              "successors": []
            },
            {
              "id": 5,
              "label": "return custom_dict_to_class",
              "successors": []
            },
            {
              "id": 6,
              "label": "self.shared_event_loop.run_forever()",
              "successors": []
            }
          ]
        },
        {
          "id": 7,
          "label": "raise RuntimeError(f\"Client {client.__class__} is not a Pyro client.\")\nreturn cast(AS, DynamicClient())",
          "successors": []
        },
        {
          "id": 9,
          "label": "builtin_types = [*vars(builtins).values(), NoneType, Enum]\nraise TypeError(f\"Unsupported type encountered: {annotype}\")",
          "successors": []
        }
      ]
    }
  ]
}