{
  "name": "example_script",
  "type": "CFG",
  "start_line": 1,
  "end_line": 746,
  "functions": [
    {
      "name": "get_node",
      "type": "function",
      "start_line": 430,
      "end_line": 435,
      "functions": [],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 430,
          "line": "async def get_node(node_id: str) -> NodeModel:"
        },
        {
          "lineno": 431,
          "line": "    node = await AgentNode.prisma().find_unique_or_raise("
        },
        {
          "lineno": 432,
          "line": "        where={\"id\": node_id},"
        },
        {
          "lineno": 433,
          "line": "        include=AGENT_NODE_INCLUDE,"
        },
        {
          "lineno": 434,
          "line": "    )"
        },
        {
          "lineno": 435,
          "line": "    return NodeModel.from_db(node)"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "label": "async def get_node(node_id: str) -> NodeModel:\n    node = await AgentNode.prisma().find_unique_or_raise(\n        where={\"id\": node_id},\n        include=AGENT_NODE_INCLUDE,\n    )",
          "successors": [
            {
              "id": 3,
              "label": "    return NodeModel.from_db(node)",
              "successors": []
            }
          ]
        }
      ]
    },
    {
      "name": "set_node_webhook",
      "type": "function",
      "start_line": 438,
      "end_line": 450,
      "functions": [],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 438,
          "line": "async def set_node_webhook(node_id: str, webhook_id: str | None) -> NodeModel:"
        },
        {
          "lineno": 439,
          "line": "    node = await AgentNode.prisma().update("
        },
        {
          "lineno": 440,
          "line": "        where={\"id\": node_id},"
        },
        {
          "lineno": 441,
          "line": "        data=("
        },
        {
          "lineno": 442,
          "line": "            {\"Webhook\": {\"connect\": {\"id\": webhook_id}}}"
        },
        {
          "lineno": 443,
          "line": "            if webhook_id"
        },
        {
          "lineno": 444,
          "line": "            else {\"Webhook\": {\"disconnect\": True}}"
        },
        {
          "lineno": 445,
          "line": "        ),"
        },
        {
          "lineno": 446,
          "line": "        include=AGENT_NODE_INCLUDE,"
        },
        {
          "lineno": 447,
          "line": "    )"
        },
        {
          "lineno": 448,
          "line": "    if not node:"
        },
        {
          "lineno": 449,
          "line": "        raise ValueError(f\"Node #{node_id} not found\")"
        },
        {
          "lineno": 450,
          "line": "    return NodeModel.from_db(node)"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "label": "async def set_node_webhook(node_id: str, webhook_id: str | None) -> NodeModel:\n    node = await AgentNode.prisma().update(\n        where={\"id\": node_id},\n        data=(\n            {\"Webhook\": {\"connect\": {\"id\": webhook_id}}}\n            if webhook_id\n            else {\"Webhook\": {\"disconnect\": True}}\n        ),\n        include=AGENT_NODE_INCLUDE,\n    )",
          "successors": [
            {
              "id": 2,
              "label": "if not node:\n    raise ValueError(f\"Node #{node_id} not found\")\nreturn NodeModel.from_db(node)",
              "successors": []
            },
            {
              "id": 3,
              "label": "return NodeModel.from_db(node)",
              "successors": []
            }
          ]
        }
      ]
    },
    {
      "name": "get_graphs",
      "type": "function",
      "start_line": 453,
      "end_line": 490,
      "functions": [],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 453,
          "line": "async def get_graphs("
        },
        {
          "lineno": 454,
          "line": "    user_id: str,"
        },
        {
          "lineno": 455,
          "line": "    filter_by: Literal[\"active\", \"template\"] | None = \"active\","
        },
        {
          "lineno": 456,
          "line": ") -> list[GraphModel]:"
        },
        {
          "lineno": 457,
          "line": "    \"\"\""
        },
        {
          "lineno": 458,
          "line": "    Retrieves graph metadata objects."
        },
        {
          "lineno": 459,
          "line": "    Default behaviour is to get all currently active graphs."
        },
        {
          "lineno": 460,
          "line": ""
        },
        {
          "lineno": 461,
          "line": "    Args:"
        },
        {
          "lineno": 462,
          "line": "        filter_by: An optional filter to either select templates or active graphs."
        },
        {
          "lineno": 463,
          "line": "        user_id: The ID of the user that owns the graph."
        },
        {
          "lineno": 464,
          "line": ""
        },
        {
          "lineno": 465,
          "line": "    Returns:"
        },
        {
          "lineno": 466,
          "line": "        list[GraphModel]: A list of objects representing the retrieved graphs."
        },
        {
          "lineno": 467,
          "line": "    \"\"\""
        },
        {
          "lineno": 468,
          "line": "    where_clause: AgentGraphWhereInput = {\"userId\": user_id}"
        },
        {
          "lineno": 469,
          "line": ""
        },
        {
          "lineno": 470,
          "line": "    if filter_by == \"active\":"
        },
        {
          "lineno": 471,
          "line": "        where_clause[\"isActive\"] = True"
        },
        {
          "lineno": 472,
          "line": "    elif filter_by == \"template\":"
        },
        {
          "lineno": 473,
          "line": "        where_clause[\"isTemplate\"] = True"
        },
        {
          "lineno": 474,
          "line": ""
        },
        {
          "lineno": 475,
          "line": "    graphs = await AgentGraph.prisma().find_many("
        },
        {
          "lineno": 476,
          "line": "        where=where_clause,"
        },
        {
          "lineno": 477,
          "line": "        distinct=[\"id\"],"
        },
        {
          "lineno": 478,
          "line": "        order={\"version\": \"desc\"},"
        },
        {
          "lineno": 479,
          "line": "        include=AGENT_GRAPH_INCLUDE,"
        },
        {
          "lineno": 480,
          "line": "    )"
        },
        {
          "lineno": 481,
          "line": ""
        },
        {
          "lineno": 482,
          "line": "    graph_models = []"
        },
        {
          "lineno": 483,
          "line": "    for graph in graphs:"
        },
        {
          "lineno": 484,
          "line": "        try:"
        },
        {
          "lineno": 485,
          "line": "            graph_models.append(GraphModel.from_db(graph))"
        },
        {
          "lineno": 486,
          "line": "        except Exception as e:"
        },
        {
          "lineno": 487,
          "line": "            logger.error(f\"Error processing graph {graph.id}: {e}\")"
        },
        {
          "lineno": 488,
          "line": "            continue"
        },
        {
          "lineno": 489,
          "line": ""
        },
        {
          "lineno": 490,
          "line": "    return graph_models"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "label": "async def get_graphs(\n    user_id: str,\n    filter_by: Literal[\"active\", \"template\"] | None = \"active\",\n) -> list[GraphModel]:\n    \"\"\"\n    Retrieves graph metadata objects.\n    Default behaviour is to get all currently active graphs.\n\n    Args:\n        filter_by: An optional filter to either select templates or active graphs.\n        user_id: The ID of the user that owns the graph.\n\n    Returns:\n        list[GraphModel]: A list of objects representing the retrieved graphs.\n    \"\"\"\n    where_clause: AgentGraphWhereInput = {\"userId\": user_id}\n\n",
          "successors": [
            {
              "id": 2,
              "label": "if filter_by == \"active\":\n    where_clause[\"isActive\"] = True\n\ngraphs = await AgentGraph.prisma().find_many(\n    where=where_clause,\n    distinct=[\"id\"],\n    order={\"version\": \"desc\"},\n    include=AGENT_GRAPH_INCLUDE,\n)\n\n",
              "successors": [
                {
                  "id": 4,
                  "label": "graph_models = []\nfor graph in graphs:\n    try:\n        graph_models.append(GraphModel.from_db(graph))\n    except Exception as e:\n        logger.error(f\"Error processing graph {graph.id}: {e}\")\n        continue\n\nreturn graph_models\n",
                  "successors": []
                }
              ]
            },
            {
              "id": 5,
              "label": "elif filter_by == \"template\":\n    where_clause[\"isTemplate\"] = True\n\ngraphs = await AgentGraph.prisma().find_many(\n    where=where_clause,\n    distinct=[\"id\"],\n    order={\"version\": \"desc\"},\n    include=AGENT_GRAPH_INCLUDE,\n)\n\n",
              "successors": [
                {
                  "id": 4,
                  "label": "graph_models = []\nfor graph in graphs:\n    try:\n        graph_models.append(GraphModel.from_db(graph))\n    except Exception as e:\n        logger.error(f\"Error processing graph {graph.id}: {e}\")\n        continue\n\nreturn graph_models\n",
                  "successors": []
                }
              ]
            },
            {
              "id": 6,
              "label": "graphs = await AgentGraph.prisma().find_many(\n    where=where_clause,\n    distinct=[\"id\"],\n    order={\"version\": \"desc\"},\n    include=AGENT_GRAPH_INCLUDE,\n)\n\n\ngraph_models = []\nfor graph in graphs:\n    try:\n        graph_models.append(GraphModel.from_db(graph))\n    except Exception as e:\n        logger.error(f\"Error processing graph {graph.id}: {e}\")\n        continue\n\nreturn graph_models\n",
              "successors": []
            }
          ]
        }
      ]
    },
    {
      "name": "get_executions",
      "type": "function",
      "start_line": 493,
      "end_line": 498,
      "functions": [],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 493,
          "line": "async def get_executions(user_id: str) -> list[GraphExecution]:"
        },
        {
          "lineno": 494,
          "line": "    executions = await AgentGraphExecution.prisma().find_many("
        },
        {
          "lineno": 495,
          "line": "        where={\"userId\": user_id},"
        },
        {
          "lineno": 496,
          "line": "        order={\"createdAt\": \"desc\"},"
        },
        {
          "lineno": 497,
          "line": "    )"
        },
        {
          "lineno": 498,
          "line": "    return [GraphExecution.from_db(execution) for execution in executions]"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "label": "async def get_executions(user_id: str) -> list[GraphExecution]:\nexecutions = await AgentGraphExecution.prisma().find_many(\n        where={\"userId\": user_id},\n        order={\"createdAt\": \"desc\"},\n    )",
          "successors": [
            {
              "id": 3,
              "label": "return [GraphExecution.from_db(execution) for execution in executions]",
              "successors": []
            }
          ]
        }
      ]
    },
    {
      "name": "get_execution",
      "type": "function",
      "start_line": 501,
      "end_line": 505,
      "functions": [],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 501,
          "line": "async def get_execution(user_id: str, execution_id: str) -> GraphExecution | None:"
        },
        {
          "lineno": 502,
          "line": "    execution = await AgentGraphExecution.prisma().find_first("
        },
        {
          "lineno": 503,
          "line": "        where={\"id\": execution_id, \"userId\": user_id}"
        },
        {
          "lineno": 504,
          "line": "    )"
        },
        {
          "lineno": 505,
          "line": "    return GraphExecution.from_db(execution) if execution else None"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "label": "async def get_execution(user_id: str, execution_id: str) -> GraphExecution | None:\nexecution = await AgentGraphExecution.prisma().find_first(\n    where={\"id\": execution_id, \"userId\": user_id}\n)",
          "successors": [
            {
              "id": 3,
              "label": "return GraphExecution.from_db(execution) if execution else None",
              "successors": []
            }
          ]
        }
      ]
    },
    {
      "name": "get_graph",
      "type": "function",
      "start_line": 508,
      "end_line": 539,
      "functions": [],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 508,
          "line": "async def get_graph("
        },
        {
          "lineno": 509,
          "line": "    graph_id: str,"
        },
        {
          "lineno": 510,
          "line": "    version: int | None = None,"
        },
        {
          "lineno": 511,
          "line": "    template: bool = False,"
        },
        {
          "lineno": 512,
          "line": "    user_id: str | None = None,"
        },
        {
          "lineno": 513,
          "line": "    for_export: bool = False,"
        },
        {
          "lineno": 514,
          "line": ") -> GraphModel | None:"
        },
        {
          "lineno": 515,
          "line": "    \"\"\""
        },
        {
          "lineno": 516,
          "line": "    Retrieves a graph from the DB."
        },
        {
          "lineno": 517,
          "line": "    Defaults to the version with `is_active` if `version` is not passed,"
        },
        {
          "lineno": 518,
          "line": "    or the latest version with `is_template` if `template=True`."
        },
        {
          "lineno": 519,
          "line": ""
        },
        {
          "lineno": 520,
          "line": "    Returns `None` if the record is not found."
        },
        {
          "lineno": 521,
          "line": "    \"\"\""
        },
        {
          "lineno": 522,
          "line": "    where_clause: AgentGraphWhereInput = {"
        },
        {
          "lineno": 523,
          "line": "        \"id\": graph_id,"
        },
        {
          "lineno": 524,
          "line": "    }"
        },
        {
          "lineno": 525,
          "line": "    if version is not None:"
        },
        {
          "lineno": 526,
          "line": "        where_clause[\"version\"] = version"
        },
        {
          "lineno": 527,
          "line": "    elif not template:"
        },
        {
          "lineno": 528,
          "line": "        where_clause[\"isActive\"] = True"
        },
        {
          "lineno": 529,
          "line": ""
        },
        {
          "lineno": 530,
          "line": "    # TODO: Fix hack workaround to get adding store agents to work"
        },
        {
          "lineno": 531,
          "line": "    if user_id is not None and not template:"
        },
        {
          "lineno": 532,
          "line": "        where_clause[\"userId\"] = user_id"
        },
        {
          "lineno": 533,
          "line": ""
        },
        {
          "lineno": 534,
          "line": "    graph = await AgentGraph.prisma().find_first("
        },
        {
          "lineno": 535,
          "line": "        where=where_clause,"
        },
        {
          "lineno": 536,
          "line": "        include=AGENT_GRAPH_INCLUDE,"
        },
        {
          "lineno": 537,
          "line": "        order={\"version\": \"desc\"},"
        },
        {
          "lineno": 538,
          "line": "    )"
        },
        {
          "lineno": 539,
          "line": "    return GraphModel.from_db(graph, for_export) if graph else None"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "label": "async def get_graph(\n    graph_id: str,\n    version: int | None = None,\n    template: bool = False,\n    user_id: str | None = None,\n    for_export: bool = False,\n) -> GraphModel | None:\n    \"\"\"\n    Retrieves a graph from the DB.\n    Defaults to the version with `is_active` if `version` is not passed,\n    or the latest version with `is_template` if `template=True`.\n\n    Returns `None` if the record is not found.\n    \"\"\"\n    where_clause: AgentGraphWhereInput = {\n        \"id\": graph_id,\n    }",
          "successors": [
            {
              "id": 2,
              "label": "if version is not None:\n    where_clause[\"version\"] = version\ngraph = await AgentGraph.prisma().find_first(\n    where=where_clause,\n    include=AGENT_GRAPH_INCLUDE,\n    order={\"version\": \"desc\"},\n)",
              "successors": [
                {
                  "id": 6,
                  "label": "return GraphModel.from_db(graph, for_export) if graph else None",
                  "successors": []
                }
              ]
            },
            {
              "id": 3,
              "label": "elif not template:\n    where_clause[\"isActive\"] = True\nif user_id is not None and not template:\n    where_clause[\"userId\"] = user_id",
              "successors": [
                {
                  "id": 5,
                  "label": "graph = await AgentGraph.prisma().find_first(\n    where=where_clause,\n    include=AGENT_GRAPH_INCLUDE,\n    order={\"version\": \"desc\"},\n)\nreturn GraphModel.from_db(graph, for_export) if graph else None",
                  "successors": []
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "set_graph_active_version",
      "type": "function",
      "start_line": 542,
      "end_line": 564,
      "functions": [],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 542,
          "line": "async def set_graph_active_version(graph_id: str, version: int, user_id: str) -> None:"
        },
        {
          "lineno": 543,
          "line": "    # Activate the requested version if it exists and is owned by the user."
        },
        {
          "lineno": 544,
          "line": "    updated_count = await AgentGraph.prisma().update_many("
        },
        {
          "lineno": 545,
          "line": "        data={\"isActive\": True},"
        },
        {
          "lineno": 546,
          "line": "        where={"
        },
        {
          "lineno": 547,
          "line": "            \"id\": graph_id,"
        },
        {
          "lineno": 548,
          "line": "            \"version\": version,"
        },
        {
          "lineno": 549,
          "line": "            \"userId\": user_id,"
        },
        {
          "lineno": 550,
          "line": "        },"
        },
        {
          "lineno": 551,
          "line": "    )"
        },
        {
          "lineno": 552,
          "line": "    if updated_count == 0:"
        },
        {
          "lineno": 553,
          "line": "        raise Exception(f\"Graph #{graph_id} v{version} not found or not owned by user\")"
        },
        {
          "lineno": 554,
          "line": ""
        },
        {
          "lineno": 555,
          "line": "    # Deactivate all other versions."
        },
        {
          "lineno": 556,
          "line": "    await AgentGraph.prisma().update_many("
        },
        {
          "lineno": 557,
          "line": "        data={\"isActive\": False},"
        },
        {
          "lineno": 558,
          "line": "        where={"
        },
        {
          "lineno": 559,
          "line": "            \"id\": graph_id,"
        },
        {
          "lineno": 560,
          "line": "            \"version\": {\"not\": version},"
        },
        {
          "lineno": 561,
          "line": "            \"userId\": user_id,"
        },
        {
          "lineno": 562,
          "line": "            \"isActive\": True,"
        },
        {
          "lineno": 563,
          "line": "        },"
        },
        {
          "lineno": 564,
          "line": "    )"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "label": "async def set_graph_active_version(graph_id: str, version: int, user_id: str) -> None:\n    # Activate the requested version if it exists and is owned by the user.\n    updated_count = await AgentGraph.prisma().update_many(\n        data={\"isActive\": True},\n        where={\n            \"id\": graph_id,\n            \"version\": version,\n            \"userId\": user_id,\n        },\n    )",
          "successors": [
            {
              "id": 2,
              "label": "if updated_count == 0:\n        raise Exception(f\"Graph #{graph_id} v{version} not found or not owned by user\")",
              "successors": []
            },
            {
              "id": 3,
              "label": "# Deactivate all other versions.\n    await AgentGraph.prisma().update_many(\n        data={\"isActive\": False},\n        where={\n            \"id\": graph_id,\n            \"version\": {\"not\": version},\n            \"userId\": user_id,\n            \"isActive\": True,\n        },\n    )",
              "successors": []
            }
          ]
        }
      ]
    },
    {
      "name": "get_graph_all_versions",
      "type": "function",
      "start_line": 567,
      "end_line": 577,
      "functions": [],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 567,
          "line": "async def get_graph_all_versions(graph_id: str, user_id: str) -> list[GraphModel]:"
        },
        {
          "lineno": 568,
          "line": "    graph_versions = await AgentGraph.prisma().find_many("
        },
        {
          "lineno": 569,
          "line": "        where={\"id\": graph_id, \"userId\": user_id},"
        },
        {
          "lineno": 570,
          "line": "        order={\"version\": \"desc\"},"
        },
        {
          "lineno": 571,
          "line": "        include=AGENT_GRAPH_INCLUDE,"
        },
        {
          "lineno": 572,
          "line": "    )"
        },
        {
          "lineno": 573,
          "line": ""
        },
        {
          "lineno": 574,
          "line": "    if not graph_versions:"
        },
        {
          "lineno": 575,
          "line": "        return []"
        },
        {
          "lineno": 576,
          "line": ""
        },
        {
          "lineno": 577,
          "line": "    return [GraphModel.from_db(graph) for graph in graph_versions]"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "label": "async def get_graph_all_versions(graph_id: str, user_id: str) -> list[GraphModel]:\n    graph_versions = await AgentGraph.prisma().find_many(\n        where={\"id\": graph_id, \"userId\": user_id},\n        order={\"version\": \"desc\"},\n        include=AGENT_GRAPH_INCLUDE,\n    )\nif not graph_versions:\n    return []",
          "successors": [
            {
              "id": 3,
              "label": "return [GraphModel.from_db(graph) for graph in graph_versions]",
              "successors": []
            }
          ]
        }
      ]
    },
    {
      "name": "delete_graph",
      "type": "function",
      "start_line": 580,
      "end_line": 586,
      "functions": [],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 580,
          "line": "async def delete_graph(graph_id: str, user_id: str) -> int:"
        },
        {
          "lineno": 581,
          "line": "    entries_count = await AgentGraph.prisma().delete_many("
        },
        {
          "lineno": 582,
          "line": "        where={\"id\": graph_id, \"userId\": user_id}"
        },
        {
          "lineno": 583,
          "line": "    )"
        },
        {
          "lineno": 584,
          "line": "    if entries_count:"
        },
        {
          "lineno": 585,
          "line": "        logger.info(f\"Deleted {entries_count} graph entries for Graph #{graph_id}\")"
        },
        {
          "lineno": 586,
          "line": "    return entries_count"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "label": "async def delete_graph(graph_id: str, user_id: str) -> int:\n    entries_count = await AgentGraph.prisma().delete_many(\n        where={\"id\": graph_id, \"userId\": user_id}\n    )\nif entries_count:\n    logger.info(f\"Deleted {entries_count} graph entries for Graph #{graph_id}\")",
          "successors": [
            {
              "id": 3,
              "label": "return entries_count",
              "successors": []
            }
          ]
        }
      ]
    },
    {
      "name": "create_graph",
      "type": "function",
      "start_line": 589,
      "end_line": 598,
      "functions": [],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 589,
          "line": "async def create_graph(graph: Graph, user_id: str) -> GraphModel:"
        },
        {
          "lineno": 590,
          "line": "    async with transaction() as tx:"
        },
        {
          "lineno": 591,
          "line": "        await __create_graph(tx, graph, user_id)"
        },
        {
          "lineno": 592,
          "line": ""
        },
        {
          "lineno": 593,
          "line": "    if created_graph := await get_graph("
        },
        {
          "lineno": 594,
          "line": "        graph.id, graph.version, graph.is_template, user_id=user_id"
        },
        {
          "lineno": 595,
          "line": "    ):"
        },
        {
          "lineno": 596,
          "line": "        return created_graph"
        },
        {
          "lineno": 597,
          "line": ""
        },
        {
          "lineno": 598,
          "line": "    raise ValueError(f\"Created graph {graph.id} v{graph.version} is not in DB\")"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "label": "async def create_graph(graph: Graph, user_id: str) -> GraphModel:\nasync with transaction() as tx:\n        await __create_graph(tx, graph, user_id)",
          "successors": [
            {
              "id": 3,
              "label": "if created_graph := await get_graph(\n        graph.id, graph.version, graph.is_template, user_id=user_id\n    ):",
              "successors": [
                {
                  "id": 4,
                  "label": "return created_graph",
                  "successors": []
                },
                {
                  "id": 5,
                  "label": "raise ValueError(f\"Created graph {graph.id} v{graph.version} is not in DB\")",
                  "successors": []
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "__create_graph",
      "type": "function",
      "start_line": 601,
      "end_line": 644,
      "functions": [],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 601,
          "line": "async def __create_graph(tx, graph: Graph, user_id: str):"
        },
        {
          "lineno": 602,
          "line": "    await AgentGraph.prisma(tx).create("
        },
        {
          "lineno": 603,
          "line": "        data={"
        },
        {
          "lineno": 604,
          "line": "            \"id\": graph.id,"
        },
        {
          "lineno": 605,
          "line": "            \"version\": graph.version,"
        },
        {
          "lineno": 606,
          "line": "            \"name\": graph.name,"
        },
        {
          "lineno": 607,
          "line": "            \"description\": graph.description,"
        },
        {
          "lineno": 608,
          "line": "            \"isTemplate\": graph.is_template,"
        },
        {
          "lineno": 609,
          "line": "            \"isActive\": graph.is_active,"
        },
        {
          "lineno": 610,
          "line": "            \"userId\": user_id,"
        },
        {
          "lineno": 611,
          "line": "        }"
        },
        {
          "lineno": 612,
          "line": "    )"
        },
        {
          "lineno": 613,
          "line": ""
        },
        {
          "lineno": 614,
          "line": "    await asyncio.gather("
        },
        {
          "lineno": 615,
          "line": "        *["
        },
        {
          "lineno": 616,
          "line": "            AgentNode.prisma(tx).create("
        },
        {
          "lineno": 617,
          "line": "                {"
        },
        {
          "lineno": 618,
          "line": "                    \"id\": node.id,"
        },
        {
          "lineno": 619,
          "line": "                    \"agentBlockId\": node.block_id,"
        },
        {
          "lineno": 620,
          "line": "                    \"agentGraphId\": graph.id,"
        },
        {
          "lineno": 621,
          "line": "                    \"agentGraphVersion\": graph.version,"
        },
        {
          "lineno": 622,
          "line": "                    \"constantInput\": json.dumps(node.input_default),"
        },
        {
          "lineno": 623,
          "line": "                    \"metadata\": json.dumps(node.metadata),"
        },
        {
          "lineno": 624,
          "line": "                }"
        },
        {
          "lineno": 625,
          "line": "            )"
        },
        {
          "lineno": 626,
          "line": "            for node in graph.nodes"
        },
        {
          "lineno": 627,
          "line": "        ]"
        },
        {
          "lineno": 628,
          "line": "    )"
        },
        {
          "lineno": 629,
          "line": ""
        },
        {
          "lineno": 630,
          "line": "    await asyncio.gather("
        },
        {
          "lineno": 631,
          "line": "        *["
        },
        {
          "lineno": 632,
          "line": "            AgentNodeLink.prisma(tx).create("
        },
        {
          "lineno": 633,
          "line": "                {"
        },
        {
          "lineno": 634,
          "line": "                    \"id\": str(uuid.uuid4()),"
        },
        {
          "lineno": 635,
          "line": "                    \"sourceName\": link.source_name,"
        },
        {
          "lineno": 636,
          "line": "                    \"sinkName\": link.sink_name,"
        },
        {
          "lineno": 637,
          "line": "                    \"agentNodeSourceId\": link.source_id,"
        },
        {
          "lineno": 638,
          "line": "                    \"agentNodeSinkId\": link.sink_id,"
        },
        {
          "lineno": 639,
          "line": "                    \"isStatic\": link.is_static,"
        },
        {
          "lineno": 640,
          "line": "                }"
        },
        {
          "lineno": 641,
          "line": "            )"
        },
        {
          "lineno": 642,
          "line": "            for link in graph.links"
        },
        {
          "lineno": 643,
          "line": "        ]"
        },
        {
          "lineno": 644,
          "line": "    )"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "label": "async def __create_graph(tx, graph: Graph, user_id: str):\nawait AgentGraph.prisma(tx).create(\n    data={\n        \"id\": graph.id,\n        \"version\": graph.version,\n        \"name\": graph.name,\n        \"description\": graph.description,\n        \"isTemplate\": graph.is_template,\n        \"isActive\": graph.is_active,\n        \"userId\": user_id,\n    }\n)",
          "successors": [
            {
              "id": 3,
              "label": "await asyncio.gather(\n    *[\n        AgentNode.prisma(tx).create(\n            {\n                \"id\": node.id,\n                \"agentBlockId\": node.block_id,\n                \"agentGraphId\": graph.id,\n                \"agentGraphVersion\": graph.version,\n                \"constantInput\": json.dumps(node.input_default),\n                \"metadata\": json.dumps(node.metadata),\n            }\n        )\n        for node in graph.nodes\n    ]\n)\nawait asyncio.gather(\n    *[\n        AgentNodeLink.prisma(tx).create(\n            {\n                \"id\": str(uuid.uuid4()),\n                \"sourceName\": link.source_name,\n                \"sinkName\": link.sink_name,\n                \"agentNodeSourceId\": link.source_id,\n                \"agentNodeSinkId\": link.sink_id,\n                \"isStatic\": link.is_static,\n            }\n        )\n        for link in graph.links\n    ]\n)",
              "successors": []
            }
          ]
        }
      ]
    },
    {
      "name": "make_graph_model",
      "type": "function",
      "start_line": 650,
      "end_line": 673,
      "functions": [],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 650,
          "line": "def make_graph_model(creatable_graph: Graph, user_id: str) -> GraphModel:"
        },
        {
          "lineno": 651,
          "line": "    \"\"\""
        },
        {
          "lineno": 652,
          "line": "    Convert a Graph to a GraphModel, setting graph_id and graph_version on all nodes."
        },
        {
          "lineno": 653,
          "line": ""
        },
        {
          "lineno": 654,
          "line": "    Args:"
        },
        {
          "lineno": 655,
          "line": "        creatable_graph (Graph): The creatable graph to convert."
        },
        {
          "lineno": 656,
          "line": "        user_id (str): The ID of the user creating the graph."
        },
        {
          "lineno": 657,
          "line": ""
        },
        {
          "lineno": 658,
          "line": "    Returns:"
        },
        {
          "lineno": 659,
          "line": "        GraphModel: The converted Graph object."
        },
        {
          "lineno": 660,
          "line": "    \"\"\""
        },
        {
          "lineno": 661,
          "line": "    # Create a new Graph object, inheriting properties from CreatableGraph"
        },
        {
          "lineno": 662,
          "line": "    return GraphModel("
        },
        {
          "lineno": 663,
          "line": "        **creatable_graph.model_dump(exclude={\"nodes\"}),"
        },
        {
          "lineno": 664,
          "line": "        user_id=user_id,"
        },
        {
          "lineno": 665,
          "line": "        nodes=["
        },
        {
          "lineno": 666,
          "line": "            NodeModel("
        },
        {
          "lineno": 667,
          "line": "                **creatable_node.model_dump(),"
        },
        {
          "lineno": 668,
          "line": "                graph_id=creatable_graph.id,"
        },
        {
          "lineno": 669,
          "line": "                graph_version=creatable_graph.version,"
        },
        {
          "lineno": 670,
          "line": "            )"
        },
        {
          "lineno": 671,
          "line": "            for creatable_node in creatable_graph.nodes"
        },
        {
          "lineno": 672,
          "line": "        ],"
        },
        {
          "lineno": 673,
          "line": "    )"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "label": "def make_graph_model(creatable_graph: Graph, user_id: str) -> GraphModel:\n    \"\"\"\n    Convert a Graph to a GraphModel, setting graph_id and graph_version on all nodes.\n\n    Args:\n        creatable_graph (Graph): The creatable graph to convert.\n        user_id (str): The ID of the user creating the graph.\n\n    Returns:\n        GraphModel: The converted Graph object.\n    \"\"\"\n    # Create a new Graph object, inheriting properties from CreatableGraph\nreturn GraphModel(\n        **creatable_graph.model_dump(exclude={\"nodes\"}),\n        user_id=user_id,\n        nodes=[\n            NodeModel(\n                **creatable_node.model_dump(),\n                graph_id=creatable_graph.id,\n                graph_version=creatable_graph.version,\n            )\n            for creatable_node in creatable_graph.nodes\n        ],\n    )",
          "successors": []
        }
      ]
    },
    {
      "name": "fix_llm_provider_credentials",
      "type": "function",
      "start_line": 676,
      "end_line": 746,
      "functions": [],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 676,
          "line": "async def fix_llm_provider_credentials():"
        },
        {
          "lineno": 677,
          "line": "    \"\"\"Fix node credentials with provider `llm`\"\"\""
        },
        {
          "lineno": 678,
          "line": "    from backend.integrations.credentials_store import IntegrationCredentialsStore"
        },
        {
          "lineno": 679,
          "line": ""
        },
        {
          "lineno": 680,
          "line": "    from .user import get_user_integrations"
        },
        {
          "lineno": 681,
          "line": ""
        },
        {
          "lineno": 682,
          "line": "    store = IntegrationCredentialsStore()"
        },
        {
          "lineno": 683,
          "line": ""
        },
        {
          "lineno": 684,
          "line": "    broken_nodes = await prisma.get_client().query_raw("
        },
        {
          "lineno": 685,
          "line": "        \"\"\""
        },
        {
          "lineno": 686,
          "line": "        SELECT    graph.\"userId\"       user_id,"
        },
        {
          "lineno": 687,
          "line": "                  node.id              node_id,"
        },
        {
          "lineno": 688,
          "line": "                  node.\"constantInput\" node_preset_input"
        },
        {
          "lineno": 689,
          "line": "        FROM      platform.\"AgentNode\"  node"
        },
        {
          "lineno": 690,
          "line": "        LEFT JOIN platform.\"AgentGraph\" graph"
        },
        {
          "lineno": 691,
          "line": "        ON        node.\"agentGraphId\" = graph.id"
        },
        {
          "lineno": 692,
          "line": "        WHERE     node.\"constantInput\"::jsonb->'credentials'->>'provider' = 'llm'"
        },
        {
          "lineno": 693,
          "line": "        ORDER BY  graph.\"userId\";"
        },
        {
          "lineno": 694,
          "line": "        \"\"\""
        },
        {
          "lineno": 695,
          "line": "    )"
        },
        {
          "lineno": 696,
          "line": "    logger.info(f\"Fixing LLM credential inputs on {len(broken_nodes)} nodes\")"
        },
        {
          "lineno": 697,
          "line": ""
        },
        {
          "lineno": 698,
          "line": "    user_id: str = \"\""
        },
        {
          "lineno": 699,
          "line": "    user_integrations = None"
        },
        {
          "lineno": 700,
          "line": "    for node in broken_nodes:"
        },
        {
          "lineno": 701,
          "line": "        if node[\"user_id\"] != user_id:"
        },
        {
          "lineno": 702,
          "line": "            # Save queries by only fetching once per user"
        },
        {
          "lineno": 703,
          "line": "            user_id = node[\"user_id\"]"
        },
        {
          "lineno": 704,
          "line": "            user_integrations = await get_user_integrations(user_id)"
        },
        {
          "lineno": 705,
          "line": "        elif not user_integrations:"
        },
        {
          "lineno": 706,
          "line": "            raise RuntimeError(f\"Impossible state while processing node {node}\")"
        },
        {
          "lineno": 707,
          "line": ""
        },
        {
          "lineno": 708,
          "line": "        node_id: str = node[\"node_id\"]"
        },
        {
          "lineno": 709,
          "line": "        node_preset_input: dict = json.loads(node[\"node_preset_input\"])"
        },
        {
          "lineno": 710,
          "line": "        credentials_meta: dict = node_preset_input[\"credentials\"]"
        },
        {
          "lineno": 711,
          "line": ""
        },
        {
          "lineno": 712,
          "line": "        credentials = next("
        },
        {
          "lineno": 713,
          "line": "            ("
        },
        {
          "lineno": 714,
          "line": "                c"
        },
        {
          "lineno": 715,
          "line": "                for c in user_integrations.credentials"
        },
        {
          "lineno": 716,
          "line": "                if c.id == credentials_meta[\"id\"]"
        },
        {
          "lineno": 717,
          "line": "            ),"
        },
        {
          "lineno": 718,
          "line": "            None,"
        },
        {
          "lineno": 719,
          "line": "        )"
        },
        {
          "lineno": 720,
          "line": "        if not credentials:"
        },
        {
          "lineno": 721,
          "line": "            continue"
        },
        {
          "lineno": 722,
          "line": "        if credentials.type != \"api_key\":"
        },
        {
          "lineno": 723,
          "line": "            logger.warning("
        },
        {
          "lineno": 724,
          "line": "                f\"User {user_id} credentials {credentials.id} with provider 'llm' \""
        },
        {
          "lineno": 725,
          "line": "                f\"has invalid type '{credentials.type}'\""
        },
        {
          "lineno": 726,
          "line": "            )"
        },
        {
          "lineno": 727,
          "line": "            continue"
        },
        {
          "lineno": 728,
          "line": ""
        },
        {
          "lineno": 729,
          "line": "        api_key = credentials.api_key.get_secret_value()"
        },
        {
          "lineno": 730,
          "line": "        if api_key.startswith(\"sk-ant-api03-\"):"
        },
        {
          "lineno": 731,
          "line": "            credentials.provider = credentials_meta[\"provider\"] = \"anthropic\""
        },
        {
          "lineno": 732,
          "line": "        elif api_key.startswith(\"sk-\"):"
        },
        {
          "lineno": 733,
          "line": "            credentials.provider = credentials_meta[\"provider\"] = \"openai\""
        },
        {
          "lineno": 734,
          "line": "        elif api_key.startswith(\"gsk_\"):"
        },
        {
          "lineno": 735,
          "line": "            credentials.provider = credentials_meta[\"provider\"] = \"groq\""
        },
        {
          "lineno": 736,
          "line": "        else:"
        },
        {
          "lineno": 737,
          "line": "            logger.warning("
        },
        {
          "lineno": 738,
          "line": "                f\"Could not identify provider from key prefix {api_key[:13]}*****\""
        },
        {
          "lineno": 739,
          "line": "            )"
        },
        {
          "lineno": 740,
          "line": "            continue"
        },
        {
          "lineno": 741,
          "line": ""
        },
        {
          "lineno": 742,
          "line": "        store.update_creds(user_id, credentials)"
        },
        {
          "lineno": 743,
          "line": "        await AgentNode.prisma().update("
        },
        {
          "lineno": 744,
          "line": "            where={\"id\": node_id},"
        },
        {
          "lineno": 745,
          "line": "            data={\"constantInput\": json.dumps(node_preset_input)},"
        },
        {
          "lineno": 746,
          "line": "        )"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "label": "async def fix_llm_provider_credentials():\n    \"\"\"Fix node credentials with provider `llm`\"\"\"\n    from backend.integrations.credentials_store import IntegrationCredentialsStore\n\n    from .user import get_user_integrations\n\n    store = IntegrationCredentialsStore()\nbroken_nodes = await prisma.get_client().query_raw(\n        \"\"\"\n        SELECT    graph.\"userId\"       user_id,\n                  node.id              node_id,\n                  node.\"constantInput\" node_preset_input\n        FROM      platform.\"AgentNode\"  node\n        LEFT JOIN platform.\"AgentGraph\" graph\n        ON        node.\"agentGraphId\" = graph.id\n        WHERE     node.\"constantInput\"::jsonb->'credentials'->>'provider' = 'llm'\n        ORDER BY  graph.\"userId\";\n        \"\"\"\n    )\n    logger.info(f\"Fixing LLM credential inputs on {len(broken_nodes)} nodes\")",
          "successors": [
            {
              "id": 3,
              "label": "user_id: str = \"\"\n    user_integrations = None",
              "successors": [
                {
                  "id": 4,
                  "label": "for node in broken_nodes:\n        if node[\"user_id\"] != user_id:\n            # Save queries by only fetching once per user\n            user_id = node[\"user_id\"]\n            user_integrations = await get_user_integrations(user_id)\n        elif not user_integrations:\n            raise RuntimeError(f\"Impossible state while processing node {node}\")",
                  "successors": [
                    {
                      "id": 5,
                      "label": "node_id: str = node[\"node_id\"]\n        node_preset_input: dict = json.loads(node[\"node_preset_input\"])\n        credentials_meta: dict = node_preset_input[\"credentials\"]\ncredentials = next(\n            (\n                c\n                for c in user_integrations.credentials\n                if c.id == credentials_meta[\"id\"]\n            ),\n            None,\n        )",
                      "successors": [
                        {
                          "id": 7,
                          "label": "if not credentials:\n            continue\nif credentials.type != \"api_key\":\n            logger.warning(\n                f\"User {user_id} credentials {credentials.id} with provider 'llm' \"\n                f\"has invalid type '{credentials.type}'\"\n            )\n            continue",
                          "successors": [
                            {
                              "id": 9,
                              "label": "api_key = credentials.api_key.get_secret_value()\n        if api_key.startswith(\"sk-ant-api03-\"):\n            credentials.provider = credentials_meta[\"provider\"] = \"anthropic\"\n        elif api_key.startswith(\"sk-\"):\n            credentials.provider = credentials_meta[\"provider\"] = \"openai\"\n        elif api_key.startswith(\"gsk_\"):\n            credentials.provider = credentials_meta[\"provider\"] = \"groq\"\n        else:\n            logger.warning(\n                f\"Could not identify provider from key prefix {api_key[:13]}*****\"\n            )\n            continue\nstore.update_creds(user_id, credentials)\n        await AgentNode.prisma().update(\n            where={\"id\": node_id},\n            data={\"constantInput\": json.dumps(node_preset_input)},\n        )",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    }
  ],
  "classes": [
    {
      "name": "Link",
      "type": "class",
      "start_line": 26,
      "end_line": 45,
      "functions": [
        {
          "name": "from_db",
          "type": "function",
          "start_line": 34,
          "end_line": 42,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 34,
              "line": "    def from_db(link: AgentNodeLink):"
            },
            {
              "lineno": 35,
              "line": "        return Link("
            },
            {
              "lineno": 36,
              "line": "            id=link.id,"
            },
            {
              "lineno": 37,
              "line": "            source_name=link.sourceName,"
            },
            {
              "lineno": 38,
              "line": "            source_id=link.agentNodeSourceId,"
            },
            {
              "lineno": 39,
              "line": "            sink_name=link.sinkName,"
            },
            {
              "lineno": 40,
              "line": "            sink_id=link.agentNodeSinkId,"
            },
            {
              "lineno": 41,
              "line": "            is_static=link.isStatic,"
            },
            {
              "lineno": 42,
              "line": "        )"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "label": "    def from_db(link: AgentNodeLink):\n        return Link(\n            id=link.id,\n            source_name=link.sourceName,\n            source_id=link.agentNodeSourceId,\n            sink_name=link.sinkName,\n            sink_id=link.agentNodeSinkId,\n            is_static=link.isStatic,\n        )",
              "successors": []
            }
          ]
        },
        {
          "name": "__hash__",
          "type": "function",
          "start_line": 44,
          "end_line": 45,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 44,
              "line": "    def __hash__(self):"
            },
            {
              "lineno": 45,
              "line": "        return hash((self.source_id, self.sink_id, self.source_name, self.sink_name))"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "label": "    def __hash__(self):\n        return hash((self.source_id, self.sink_id, self.source_name, self.sink_name))",
              "successors": []
            }
          ]
        }
      ],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 26,
          "line": "class Link(BaseDbModel):"
        },
        {
          "lineno": 27,
          "line": "    source_id: str"
        },
        {
          "lineno": 28,
          "line": "    sink_id: str"
        },
        {
          "lineno": 29,
          "line": "    source_name: str"
        },
        {
          "lineno": 30,
          "line": "    sink_name: str"
        },
        {
          "lineno": 31,
          "line": "    is_static: bool = False"
        },
        {
          "lineno": 32,
          "line": ""
        },
        {
          "lineno": 33,
          "line": "    @staticmethod"
        },
        {
          "lineno": 43,
          "line": ""
        }
      ],
      "blocks": [
        {
          "id": 1,
          "label": "class Link(BaseDbModel):\n    source_id: str\n    sink_id: str\n    source_name: str\n    sink_name: str\n    is_static: bool = False\n@staticmethod",
          "successors": []
        }
      ]
    },
    {
      "name": "Node",
      "type": "class",
      "start_line": 48,
      "end_line": 56,
      "functions": [],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 48,
          "line": "class Node(BaseDbModel):"
        },
        {
          "lineno": 49,
          "line": "    block_id: str"
        },
        {
          "lineno": 50,
          "line": "    input_default: BlockInput = {}  # dict[input_name, default_value]"
        },
        {
          "lineno": 51,
          "line": "    metadata: dict[str, Any] = {}"
        },
        {
          "lineno": 52,
          "line": "    input_links: list[Link] = []"
        },
        {
          "lineno": 53,
          "line": "    output_links: list[Link] = []"
        },
        {
          "lineno": 54,
          "line": ""
        },
        {
          "lineno": 55,
          "line": "    webhook_id: Optional[str] = None"
        },
        {
          "lineno": 56,
          "line": ""
        }
      ],
      "blocks": [
        {
          "id": 1,
          "label": "class Node(BaseDbModel):\n    block_id: str\n    input_default: BlockInput = {}  # dict[input_name, default_value]\n    metadata: dict[str, Any] = {}\n    input_links: list[Link] = []\n    output_links: list[Link] = []\n\n    webhook_id: Optional[str] = None\n",
          "successors": []
        }
      ]
    },
    {
      "name": "NodeModel",
      "type": "class",
      "start_line": 58,
      "end_line": 96,
      "functions": [
        {
          "name": "from_db",
          "type": "function",
          "start_line": 65,
          "end_line": 80,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 65,
              "line": "    def from_db(node: AgentNode):"
            },
            {
              "lineno": 66,
              "line": "        if not node.AgentBlock:"
            },
            {
              "lineno": 67,
              "line": "            raise ValueError(f\"Invalid node {node.id}, invalid AgentBlock.\")"
            },
            {
              "lineno": 68,
              "line": "        obj = NodeModel("
            },
            {
              "lineno": 69,
              "line": "            id=node.id,"
            },
            {
              "lineno": 70,
              "line": "            block_id=node.AgentBlock.id,"
            },
            {
              "lineno": 71,
              "line": "            input_default=json.loads(node.constantInput, target_type=dict[str, Any]),"
            },
            {
              "lineno": 72,
              "line": "            metadata=json.loads(node.metadata, target_type=dict[str, Any]),"
            },
            {
              "lineno": 73,
              "line": "            graph_id=node.agentGraphId,"
            },
            {
              "lineno": 74,
              "line": "            graph_version=node.agentGraphVersion,"
            },
            {
              "lineno": 75,
              "line": "            webhook_id=node.webhookId,"
            },
            {
              "lineno": 76,
              "line": "            webhook=Webhook.from_db(node.Webhook) if node.Webhook else None,"
            },
            {
              "lineno": 77,
              "line": "        )"
            },
            {
              "lineno": 78,
              "line": "        obj.input_links = [Link.from_db(link) for link in node.Input or []]"
            },
            {
              "lineno": 79,
              "line": "        obj.output_links = [Link.from_db(link) for link in node.Output or []]"
            },
            {
              "lineno": 80,
              "line": "        return obj"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "label": "    def from_db(node: AgentNode):\n        if not node.AgentBlock:",
              "successors": [
                {
                  "id": 2,
                  "label": "            raise ValueError(f\"Invalid node {node.id}, invalid AgentBlock.\")",
                  "successors": []
                },
                {
                  "id": 3,
                  "label": "        obj = NodeModel(\n            id=node.id,\n            block_id=node.AgentBlock.id,\n            input_default=json.loads(node.constantInput, target_type=dict[str, Any]),\n            metadata=json.loads(node.metadata, target_type=dict[str, Any]),\n            graph_id=node.agentGraphId,\n            graph_version=node.agentGraphVersion,\n            webhook_id=node.webhookId,\n            webhook=Webhook.from_db(node.Webhook) if node.Webhook else None,\n        )\n        obj.input_links = [Link.from_db(link) for link in node.Input or []]\n        obj.output_links = [Link.from_db(link) for link in node.Output or []]\n        return obj",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "is_triggered_by_event_type",
          "type": "function",
          "start_line": 82,
          "end_line": 96,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 82,
              "line": "    def is_triggered_by_event_type(self, event_type: str) -> bool:"
            },
            {
              "lineno": 83,
              "line": "        if not (block := get_block(self.block_id)):"
            },
            {
              "lineno": 84,
              "line": "            raise ValueError(f\"Block #{self.block_id} not found for node #{self.id}\")"
            },
            {
              "lineno": 85,
              "line": "        if not block.webhook_config:"
            },
            {
              "lineno": 86,
              "line": "            raise TypeError(\"This method can't be used on non-webhook blocks\")"
            },
            {
              "lineno": 87,
              "line": "        if not block.webhook_config.event_filter_input:"
            },
            {
              "lineno": 88,
              "line": "            return True"
            },
            {
              "lineno": 89,
              "line": "        event_filter = self.input_default.get(block.webhook_config.event_filter_input)"
            },
            {
              "lineno": 90,
              "line": "        if not event_filter:"
            },
            {
              "lineno": 91,
              "line": "            raise ValueError(f\"Event filter is not configured on node #{self.id}\")"
            },
            {
              "lineno": 92,
              "line": "        return event_type in ["
            },
            {
              "lineno": 93,
              "line": "            block.webhook_config.event_format.format(event=k)"
            },
            {
              "lineno": 94,
              "line": "            for k in event_filter"
            },
            {
              "lineno": 95,
              "line": "            if event_filter[k] is True"
            },
            {
              "lineno": 96,
              "line": "        ]"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "label": "    def is_triggered_by_event_type(self, event_type: str) -> bool:\n        if not (block := get_block(self.block_id)):",
              "successors": [
                {
                  "id": 3,
                  "label": "            raise ValueError(f\"Block #{self.block_id} not found for node #{self.id}\")",
                  "successors": []
                },
                {
                  "id": 4,
                  "label": "        if not block.webhook_config:",
                  "successors": [
                    {
                      "id": 5,
                      "label": "            raise TypeError(\"This method can't be used on non-webhook blocks\")",
                      "successors": []
                    },
                    {
                      "id": 6,
                      "label": "        if not block.webhook_config.event_filter_input:",
                      "successors": [
                        {
                          "id": 7,
                          "label": "            return True",
                          "successors": []
                        },
                        {
                          "id": 8,
                          "label": "        event_filter = self.input_default.get(block.webhook_config.event_filter_input)\n        if not event_filter:",
                          "successors": [
                            {
                              "id": 10,
                              "label": "            raise ValueError(f\"Event filter is not configured on node #{self.id}\")",
                              "successors": []
                            },
                            {
                              "id": 11,
                              "label": "        return event_type in [\n            block.webhook_config.event_format.format(event=k)\n            for k in event_filter\n            if event_filter[k] is True\n        ]",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 58,
          "line": "class NodeModel(Node):"
        },
        {
          "lineno": 59,
          "line": "    graph_id: str"
        },
        {
          "lineno": 60,
          "line": "    graph_version: int"
        },
        {
          "lineno": 61,
          "line": ""
        },
        {
          "lineno": 62,
          "line": "    webhook: Optional[Webhook] = None"
        },
        {
          "lineno": 63,
          "line": ""
        },
        {
          "lineno": 64,
          "line": "    @staticmethod"
        },
        {
          "lineno": 81,
          "line": ""
        }
      ],
      "blocks": [
        {
          "id": 1,
          "label": "class NodeModel(Node):\n    graph_id: str\n    graph_version: int\nwebhook: Optional[Webhook] = None",
          "successors": [
            {
              "id": 3,
              "label": "@staticmethod",
              "successors": []
            }
          ]
        }
      ]
    },
    {
      "name": "GraphExecution",
      "type": "class",
      "start_line": 103,
      "end_line": 139,
      "functions": [
        {
          "name": "from_db",
          "type": "function",
          "start_line": 114,
          "end_line": 139,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 114,
              "line": "    def from_db(execution: AgentGraphExecution):"
            },
            {
              "lineno": 115,
              "line": "        now = datetime.now(timezone.utc)"
            },
            {
              "lineno": 116,
              "line": "        start_time = execution.startedAt or execution.createdAt"
            },
            {
              "lineno": 117,
              "line": "        end_time = execution.updatedAt or now"
            },
            {
              "lineno": 118,
              "line": "        duration = (end_time - start_time).total_seconds()"
            },
            {
              "lineno": 119,
              "line": "        total_run_time = duration"
            },
            {
              "lineno": 120,
              "line": ""
            },
            {
              "lineno": 121,
              "line": "        try:"
            },
            {
              "lineno": 122,
              "line": "            stats = json.loads(execution.stats or \"{}\", target_type=dict[str, Any])"
            },
            {
              "lineno": 123,
              "line": "        except ValueError:"
            },
            {
              "lineno": 124,
              "line": "            stats = {}"
            },
            {
              "lineno": 125,
              "line": ""
            },
            {
              "lineno": 126,
              "line": "        duration = stats.get(\"walltime\", duration)"
            },
            {
              "lineno": 127,
              "line": "        total_run_time = stats.get(\"nodes_walltime\", total_run_time)"
            },
            {
              "lineno": 128,
              "line": ""
            },
            {
              "lineno": 129,
              "line": "        return GraphExecution("
            },
            {
              "lineno": 130,
              "line": "            id=execution.id,"
            },
            {
              "lineno": 131,
              "line": "            execution_id=execution.id,"
            },
            {
              "lineno": 132,
              "line": "            started_at=start_time,"
            },
            {
              "lineno": 133,
              "line": "            ended_at=end_time,"
            },
            {
              "lineno": 134,
              "line": "            duration=duration,"
            },
            {
              "lineno": 135,
              "line": "            total_run_time=total_run_time,"
            },
            {
              "lineno": 136,
              "line": "            status=ExecutionStatus(execution.executionStatus),"
            },
            {
              "lineno": 137,
              "line": "            graph_id=execution.agentGraphId,"
            },
            {
              "lineno": 138,
              "line": "            graph_version=execution.agentGraphVersion,"
            },
            {
              "lineno": 139,
              "line": "        )"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "label": "    def from_db(execution: AgentGraphExecution):\n        now = datetime.now(timezone.utc)\n        start_time = execution.startedAt or execution.createdAt\n        end_time = execution.updatedAt or now\n        duration = (end_time - start_time).total_seconds()\n        total_run_time = duration\n\n        try:\n            stats = json.loads(execution.stats or \"{}\", target_type=dict[str, Any])\n",
              "successors": [
                {
                  "id": 3,
                  "label": "        except ValueError:\n            stats = {}\n\n        duration = stats.get(\"walltime\", duration)\n        total_run_time = stats.get(\"nodes_walltime\", total_run_time)\n",
                  "successors": [
                    {
                      "id": 5,
                      "label": "        return GraphExecution(\n            id=execution.id,\n            execution_id=execution.id,\n            started_at=start_time,\n            ended_at=end_time,\n            duration=duration,\n            total_run_time=total_run_time,\n            status=ExecutionStatus(execution.executionStatus),\n            graph_id=execution.agentGraphId,\n            graph_version=execution.agentGraphVersion,\n        )\n",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 103,
          "line": "class GraphExecution(BaseDbModel):"
        },
        {
          "lineno": 104,
          "line": "    execution_id: str"
        },
        {
          "lineno": 105,
          "line": "    started_at: datetime"
        },
        {
          "lineno": 106,
          "line": "    ended_at: datetime"
        },
        {
          "lineno": 107,
          "line": "    duration: float"
        },
        {
          "lineno": 108,
          "line": "    total_run_time: float"
        },
        {
          "lineno": 109,
          "line": "    status: ExecutionStatus"
        },
        {
          "lineno": 110,
          "line": "    graph_id: str"
        },
        {
          "lineno": 111,
          "line": "    graph_version: int"
        },
        {
          "lineno": 112,
          "line": ""
        },
        {
          "lineno": 113,
          "line": "    @staticmethod"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "label": "class GraphExecution(BaseDbModel):\n    execution_id: str\n    started_at: datetime\n    ended_at: datetime\n    duration: float\n    total_run_time: float\n    status: ExecutionStatus\n    graph_id: str\n    graph_version: int",
          "successors": []
        }
      ]
    },
    {
      "name": "Graph",
      "type": "class",
      "start_line": 142,
      "end_line": 204,
      "functions": [
        {
          "name": "input_schema",
          "type": "function",
          "start_line": 153,
          "end_line": 163,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 153,
              "line": "    def input_schema(self) -> dict[str, Any]:"
            },
            {
              "lineno": 154,
              "line": "        return self._generate_schema("
            },
            {
              "lineno": 155,
              "line": "            AgentInputBlock.Input,"
            },
            {
              "lineno": 156,
              "line": "            ["
            },
            {
              "lineno": 157,
              "line": "                node.input_default"
            },
            {
              "lineno": 158,
              "line": "                for node in self.nodes"
            },
            {
              "lineno": 159,
              "line": "                if (b := get_block(node.block_id))"
            },
            {
              "lineno": 160,
              "line": "                and b.block_type == BlockType.INPUT"
            },
            {
              "lineno": 161,
              "line": "                and \"name\" in node.input_default"
            },
            {
              "lineno": 162,
              "line": "            ],"
            },
            {
              "lineno": 163,
              "line": "        )"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "label": "    def input_schema(self) -> dict[str, Any]:\n        return self._generate_schema(\n            AgentInputBlock.Input,\n            [\n                node.input_default\n                for node in self.nodes\n                if (b := get_block(node.block_id))\n                and b.block_type == BlockType.INPUT\n                and \"name\" in node.input_default\n            ],\n        )",
              "successors": []
            }
          ]
        },
        {
          "name": "output_schema",
          "type": "function",
          "start_line": 167,
          "end_line": 177,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 167,
              "line": "    def output_schema(self) -> dict[str, Any]:"
            },
            {
              "lineno": 168,
              "line": "        return self._generate_schema("
            },
            {
              "lineno": 169,
              "line": "            AgentOutputBlock.Input,"
            },
            {
              "lineno": 170,
              "line": "            ["
            },
            {
              "lineno": 171,
              "line": "                node.input_default"
            },
            {
              "lineno": 172,
              "line": "                for node in self.nodes"
            },
            {
              "lineno": 173,
              "line": "                if (b := get_block(node.block_id))"
            },
            {
              "lineno": 174,
              "line": "                and b.block_type == BlockType.OUTPUT"
            },
            {
              "lineno": 175,
              "line": "                and \"name\" in node.input_default"
            },
            {
              "lineno": 176,
              "line": "            ],"
            },
            {
              "lineno": 177,
              "line": "        )"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "label": "    def output_schema(self) -> dict[str, Any]:\n        return self._generate_schema(\n            AgentOutputBlock.Input,\n            [\n                node.input_default\n                for node in self.nodes\n                if (b := get_block(node.block_id))\n                and b.block_type == BlockType.OUTPUT\n                and \"name\" in node.input_default\n            ],\n        )",
              "successors": []
            }
          ]
        },
        {
          "name": "_generate_schema",
          "type": "function",
          "start_line": 180,
          "end_line": 204,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 180,
              "line": "    def _generate_schema("
            },
            {
              "lineno": 181,
              "line": "        type_class: Type[AgentInputBlock.Input] | Type[AgentOutputBlock.Input],"
            },
            {
              "lineno": 182,
              "line": "        data: list[dict],"
            },
            {
              "lineno": 183,
              "line": "    ) -> dict[str, Any]:"
            },
            {
              "lineno": 184,
              "line": "        props = []"
            },
            {
              "lineno": 185,
              "line": "        for p in data:"
            },
            {
              "lineno": 186,
              "line": "            try:"
            },
            {
              "lineno": 187,
              "line": "                props.append(type_class(**p))"
            },
            {
              "lineno": 188,
              "line": "            except Exception as e:"
            },
            {
              "lineno": 189,
              "line": "                logger.warning(f\"Invalid {type_class}: {p}, {e}\")"
            },
            {
              "lineno": 190,
              "line": ""
            },
            {
              "lineno": 191,
              "line": "        return {"
            },
            {
              "lineno": 192,
              "line": "            \"type\": \"object\","
            },
            {
              "lineno": 193,
              "line": "            \"properties\": {"
            },
            {
              "lineno": 194,
              "line": "                p.name: {"
            },
            {
              "lineno": 195,
              "line": "                    \"secret\": p.secret,"
            },
            {
              "lineno": 196,
              "line": "                    \"advanced\": p.advanced,"
            },
            {
              "lineno": 197,
              "line": "                    \"title\": p.title or p.name,"
            },
            {
              "lineno": 198,
              "line": "                    **({\"description\": p.description} if p.description else {}),"
            },
            {
              "lineno": 199,
              "line": "                    **({\"default\": p.value} if p.value is not None else {}),"
            },
            {
              "lineno": 200,
              "line": "                }"
            },
            {
              "lineno": 201,
              "line": "                for p in props"
            },
            {
              "lineno": 202,
              "line": "            },"
            },
            {
              "lineno": 203,
              "line": "            \"required\": [p.name for p in props if p.value is None],"
            },
            {
              "lineno": 204,
              "line": "        }"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "label": "    def _generate_schema(\n        type_class: Type[AgentInputBlock.Input] | Type[AgentOutputBlock.Input],\n        data: list[dict],\n    ) -> dict[str, Any]:\n        props = []",
              "successors": [
                {
                  "id": 2,
                  "label": "        for p in data:",
                  "successors": [
                    {
                      "id": 3,
                      "label": "            try:\n                props.append(type_class(**p))\n            except Exception as e:\n                logger.warning(f\"Invalid {type_class}: {p}, {e}\")",
                      "successors": [
                        {
                          "id": 5,
                          "label": "        return {\n            \"type\": \"object\",\n            \"properties\": {\n                p.name: {\n                    \"secret\": p.secret,\n                    \"advanced\": p.advanced,\n                    \"title\": p.title or p.name,\n                    **({\"description\": p.description} if p.description else {}),\n                    **({\"default\": p.value} if p.value is not None else {}),\n                }\n                for p in props\n            },\n            \"required\": [p.name for p in props if p.value is None],\n        }",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 142,
          "line": "class Graph(BaseDbModel):"
        },
        {
          "lineno": 143,
          "line": "    version: int = 1"
        },
        {
          "lineno": 144,
          "line": "    is_active: bool = True"
        },
        {
          "lineno": 145,
          "line": "    is_template: bool = False"
        },
        {
          "lineno": 146,
          "line": "    name: str"
        },
        {
          "lineno": 147,
          "line": "    description: str"
        },
        {
          "lineno": 148,
          "line": "    nodes: list[Node] = []"
        },
        {
          "lineno": 149,
          "line": "    links: list[Link] = []"
        },
        {
          "lineno": 150,
          "line": ""
        },
        {
          "lineno": 151,
          "line": "    @computed_field"
        },
        {
          "lineno": 152,
          "line": "    @property"
        },
        {
          "lineno": 164,
          "line": ""
        },
        {
          "lineno": 165,
          "line": "    @computed_field"
        },
        {
          "lineno": 166,
          "line": "    @property"
        },
        {
          "lineno": 178,
          "line": ""
        },
        {
          "lineno": 179,
          "line": "    @staticmethod"
        }
      ],
      "blocks": []
    },
    {
      "name": "GraphModel",
      "type": "class",
      "start_line": 207,
      "end_line": 745,
      "functions": [
        {
          "name": "starting_nodes",
          "type": "function",
          "start_line": 212,
          "end_line": 223,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 212,
              "line": "    def starting_nodes(self) -> list[Node]:"
            },
            {
              "lineno": 213,
              "line": "        outbound_nodes = {link.sink_id for link in self.links}"
            },
            {
              "lineno": 214,
              "line": "        input_nodes = {"
            },
            {
              "lineno": 215,
              "line": "            v.id"
            },
            {
              "lineno": 216,
              "line": "            for v in self.nodes"
            },
            {
              "lineno": 217,
              "line": "            if (b := get_block(v.block_id)) and b.block_type == BlockType.INPUT"
            },
            {
              "lineno": 218,
              "line": "        }"
            },
            {
              "lineno": 219,
              "line": "        return ["
            },
            {
              "lineno": 220,
              "line": "            node"
            },
            {
              "lineno": 221,
              "line": "            for node in self.nodes"
            },
            {
              "lineno": 222,
              "line": "            if node.id not in outbound_nodes or node.id in input_nodes"
            },
            {
              "lineno": 223,
              "line": "        ]"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "label": "def starting_nodes(self) -> list[Node]:\noutbound_nodes = {link.sink_id for link in self.links}\ninput_nodes = {\n    v.id\n    for v in self.nodes\n    if (b := get_block(v.block_id)) and b.block_type == BlockType.INPUT\n}",
              "successors": [
                {
                  "id": 3,
                  "label": "return [\n    node\n    for node in self.nodes\n    if node.id not in outbound_nodes or node.id in input_nodes\n]",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "reassign_ids",
          "type": "function",
          "start_line": 225,
          "end_line": 252,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 225,
              "line": "    def reassign_ids(self, user_id: str, reassign_graph_id: bool = False):"
            },
            {
              "lineno": 226,
              "line": "        \"\"\""
            },
            {
              "lineno": 227,
              "line": "        Reassigns all IDs in the graph to new UUIDs."
            },
            {
              "lineno": 228,
              "line": "        This method can be used before storing a new graph to the database."
            },
            {
              "lineno": 229,
              "line": "        \"\"\""
            },
            {
              "lineno": 230,
              "line": ""
            },
            {
              "lineno": 231,
              "line": "        # Reassign Graph ID"
            },
            {
              "lineno": 232,
              "line": "        id_map = {node.id: str(uuid.uuid4()) for node in self.nodes}"
            },
            {
              "lineno": 233,
              "line": "        if reassign_graph_id:"
            },
            {
              "lineno": 234,
              "line": "            self.id = str(uuid.uuid4())"
            },
            {
              "lineno": 235,
              "line": ""
            },
            {
              "lineno": 236,
              "line": "        # Reassign Node IDs"
            },
            {
              "lineno": 237,
              "line": "        for node in self.nodes:"
            },
            {
              "lineno": 238,
              "line": "            node.id = id_map[node.id]"
            },
            {
              "lineno": 239,
              "line": ""
            },
            {
              "lineno": 240,
              "line": "        # Reassign Link IDs"
            },
            {
              "lineno": 241,
              "line": "        for link in self.links:"
            },
            {
              "lineno": 242,
              "line": "            link.source_id = id_map[link.source_id]"
            },
            {
              "lineno": 243,
              "line": "            link.sink_id = id_map[link.sink_id]"
            },
            {
              "lineno": 244,
              "line": ""
            },
            {
              "lineno": 245,
              "line": "        # Reassign User IDs for agent blocks"
            },
            {
              "lineno": 246,
              "line": "        for node in self.nodes:"
            },
            {
              "lineno": 247,
              "line": "            if node.block_id != AgentExecutorBlock().id:"
            },
            {
              "lineno": 248,
              "line": "                continue"
            },
            {
              "lineno": 249,
              "line": "            node.input_default[\"user_id\"] = user_id"
            },
            {
              "lineno": 250,
              "line": "            node.input_default.setdefault(\"data\", {})"
            },
            {
              "lineno": 251,
              "line": ""
            },
            {
              "lineno": 252,
              "line": "        self.validate_graph()"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "label": "def reassign_ids(self, user_id: str, reassign_graph_id: bool = False):\n    \"\"\"\n    Reassigns all IDs in the graph to new UUIDs.\n    This method can be used before storing a new graph to the database.\n    \"\"\"\n\n    # Reassign Graph ID\n    id_map = {node.id: str(uuid.uuid4()) for node in self.nodes}\nif reassign_graph_id:\n    self.id = str(uuid.uuid4())",
              "successors": [
                {
                  "id": 3,
                  "label": "# Reassign Node IDs\nfor node in self.nodes:\n    node.id = id_map[node.id]\n# Reassign Link IDs\nfor link in self.links:\n    link.source_id = id_map[link.source_id]\n    link.sink_id = id_map[link.sink_id]",
                  "successors": [
                    {
                      "id": 5,
                      "label": "# Reassign User IDs for agent blocks\nfor node in self.nodes:\n    if node.block_id != AgentExecutorBlock().id:\n        continue\n    node.input_default[\"user_id\"] = user_id\n    node.input_default.setdefault(\"data\", {})\nself.validate_graph()",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "validate_graph",
          "type": "function",
          "start_line": 254,
          "end_line": 368,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 254,
              "line": "    def validate_graph(self, for_run: bool = False):"
            },
            {
              "lineno": 255,
              "line": "        def sanitize(name):"
            },
            {
              "lineno": 256,
              "line": "            return name.split(\"_#_\")[0].split(\"_@_\")[0].split(\"_$_\")[0]"
            },
            {
              "lineno": 257,
              "line": ""
            },
            {
              "lineno": 258,
              "line": "        input_links = defaultdict(list)"
            },
            {
              "lineno": 259,
              "line": "        for link in self.links:"
            },
            {
              "lineno": 260,
              "line": "            input_links[link.sink_id].append(link)"
            },
            {
              "lineno": 261,
              "line": ""
            },
            {
              "lineno": 262,
              "line": "        # Nodes: required fields are filled or connected and dependencies are satisfied"
            },
            {
              "lineno": 263,
              "line": "        for node in self.nodes:"
            },
            {
              "lineno": 264,
              "line": "            block = get_block(node.block_id)"
            },
            {
              "lineno": 265,
              "line": "            if block is None:"
            },
            {
              "lineno": 266,
              "line": "                raise ValueError(f\"Invalid block {node.block_id} for node #{node.id}\")"
            },
            {
              "lineno": 267,
              "line": ""
            },
            {
              "lineno": 268,
              "line": "            provided_inputs = set("
            },
            {
              "lineno": 269,
              "line": "                [sanitize(name) for name in node.input_default]"
            },
            {
              "lineno": 270,
              "line": "                + [sanitize(link.sink_name) for link in input_links.get(node.id, [])]"
            },
            {
              "lineno": 271,
              "line": "            )"
            },
            {
              "lineno": 272,
              "line": "            for name in block.input_schema.get_required_fields():"
            },
            {
              "lineno": 273,
              "line": "                if ("
            },
            {
              "lineno": 274,
              "line": "                    name not in provided_inputs"
            },
            {
              "lineno": 275,
              "line": "                    and not ("
            },
            {
              "lineno": 276,
              "line": "                        name == \"payload\""
            },
            {
              "lineno": 277,
              "line": "                        and block.block_type"
            },
            {
              "lineno": 278,
              "line": "                        in (BlockType.WEBHOOK, BlockType.WEBHOOK_MANUAL)"
            },
            {
              "lineno": 279,
              "line": "                    )"
            },
            {
              "lineno": 280,
              "line": "                    and ("
            },
            {
              "lineno": 281,
              "line": "                        for_run  # Skip input completion validation, unless when executing."
            },
            {
              "lineno": 282,
              "line": "                        or block.block_type == BlockType.INPUT"
            },
            {
              "lineno": 283,
              "line": "                        or block.block_type == BlockType.OUTPUT"
            },
            {
              "lineno": 284,
              "line": "                        or block.block_type == BlockType.AGENT"
            },
            {
              "lineno": 285,
              "line": "                    )"
            },
            {
              "lineno": 286,
              "line": "                ):"
            },
            {
              "lineno": 287,
              "line": "                    raise ValueError("
            },
            {
              "lineno": 288,
              "line": "                        f\"Node {block.name} #{node.id} required input missing: `{name}`\""
            },
            {
              "lineno": 289,
              "line": "                    )"
            },
            {
              "lineno": 290,
              "line": ""
            },
            {
              "lineno": 291,
              "line": "            # Get input schema properties and check dependencies"
            },
            {
              "lineno": 292,
              "line": "            input_schema = block.input_schema.model_fields"
            },
            {
              "lineno": 293,
              "line": "            required_fields = block.input_schema.get_required_fields()"
            },
            {
              "lineno": 294,
              "line": ""
            },
            {
              "lineno": 295,
              "line": "            def has_value(name):"
            },
            {
              "lineno": 296,
              "line": "                return ("
            },
            {
              "lineno": 297,
              "line": "                    node is not None"
            },
            {
              "lineno": 298,
              "line": "                    and name in node.input_default"
            },
            {
              "lineno": 299,
              "line": "                    and node.input_default[name] is not None"
            },
            {
              "lineno": 300,
              "line": "                    and str(node.input_default[name]).strip() != \"\""
            },
            {
              "lineno": 301,
              "line": "                ) or (name in input_schema and input_schema[name].default is not None)"
            },
            {
              "lineno": 302,
              "line": ""
            },
            {
              "lineno": 303,
              "line": "            # Validate dependencies between fields"
            },
            {
              "lineno": 304,
              "line": "            for field_name, field_info in input_schema.items():"
            },
            {
              "lineno": 305,
              "line": "                # Apply input dependency validation only on run & field with depends_on"
            },
            {
              "lineno": 306,
              "line": "                json_schema_extra = field_info.json_schema_extra or {}"
            },
            {
              "lineno": 307,
              "line": "                dependencies = json_schema_extra.get(\"depends_on\", [])"
            },
            {
              "lineno": 308,
              "line": "                if not for_run or not dependencies:"
            },
            {
              "lineno": 309,
              "line": "                    continue"
            },
            {
              "lineno": 310,
              "line": ""
            },
            {
              "lineno": 311,
              "line": "                # Check if dependent field has value in input_default"
            },
            {
              "lineno": 312,
              "line": "                field_has_value = has_value(field_name)"
            },
            {
              "lineno": 313,
              "line": "                field_is_required = field_name in required_fields"
            },
            {
              "lineno": 314,
              "line": ""
            },
            {
              "lineno": 315,
              "line": "                # Check for missing dependencies when dependent field is present"
            },
            {
              "lineno": 316,
              "line": "                missing_deps = [dep for dep in dependencies if not has_value(dep)]"
            },
            {
              "lineno": 317,
              "line": "                if missing_deps and (field_has_value or field_is_required):"
            },
            {
              "lineno": 318,
              "line": "                    raise ValueError("
            },
            {
              "lineno": 319,
              "line": "                        f\"Node {block.name} #{node.id}: Field `{field_name}` requires [{', '.join(missing_deps)}] to be set\""
            },
            {
              "lineno": 320,
              "line": "                    )"
            },
            {
              "lineno": 321,
              "line": ""
            },
            {
              "lineno": 322,
              "line": "        node_map = {v.id: v for v in self.nodes}"
            },
            {
              "lineno": 323,
              "line": ""
            },
            {
              "lineno": 324,
              "line": "        def is_static_output_block(nid: str) -> bool:"
            },
            {
              "lineno": 325,
              "line": "            bid = node_map[nid].block_id"
            },
            {
              "lineno": 326,
              "line": "            b = get_block(bid)"
            },
            {
              "lineno": 327,
              "line": "            return b.static_output if b else False"
            },
            {
              "lineno": 328,
              "line": ""
            },
            {
              "lineno": 329,
              "line": "        # Links: links are connected and the connected pin data type are compatible."
            },
            {
              "lineno": 330,
              "line": "        for link in self.links:"
            },
            {
              "lineno": 331,
              "line": "            source = (link.source_id, link.source_name)"
            },
            {
              "lineno": 332,
              "line": "            sink = (link.sink_id, link.sink_name)"
            },
            {
              "lineno": 333,
              "line": "            suffix = f\"Link {source} <-> {sink}\""
            },
            {
              "lineno": 334,
              "line": ""
            },
            {
              "lineno": 335,
              "line": "            for i, (node_id, name) in enumerate([source, sink]):"
            },
            {
              "lineno": 336,
              "line": "                node = node_map.get(node_id)"
            },
            {
              "lineno": 337,
              "line": "                if not node:"
            },
            {
              "lineno": 338,
              "line": "                    raise ValueError("
            },
            {
              "lineno": 339,
              "line": "                        f\"{suffix}, {node_id} is invalid node id, available nodes: {node_map.keys()}\""
            },
            {
              "lineno": 340,
              "line": "                    )"
            },
            {
              "lineno": 341,
              "line": ""
            },
            {
              "lineno": 342,
              "line": "                block = get_block(node.block_id)"
            },
            {
              "lineno": 343,
              "line": "                if not block:"
            },
            {
              "lineno": 344,
              "line": "                    blocks = {v().id: v().name for v in get_blocks().values()}"
            },
            {
              "lineno": 345,
              "line": "                    raise ValueError("
            },
            {
              "lineno": 346,
              "line": "                        f\"{suffix}, {node.block_id} is invalid block id, available blocks: {blocks}\""
            },
            {
              "lineno": 347,
              "line": "                    )"
            },
            {
              "lineno": 348,
              "line": ""
            },
            {
              "lineno": 349,
              "line": "                sanitized_name = sanitize(name)"
            },
            {
              "lineno": 350,
              "line": "                vals = node.input_default"
            },
            {
              "lineno": 351,
              "line": "                if i == 0:"
            },
            {
              "lineno": 352,
              "line": "                    fields = ("
            },
            {
              "lineno": 353,
              "line": "                        block.output_schema.get_fields()"
            },
            {
              "lineno": 354,
              "line": "                        if block.block_type != BlockType.AGENT"
            },
            {
              "lineno": 355,
              "line": "                        else vals.get(\"output_schema\", {}).get(\"properties\", {}).keys()"
            },
            {
              "lineno": 356,
              "line": "                    )"
            },
            {
              "lineno": 357,
              "line": "                else:"
            },
            {
              "lineno": 358,
              "line": "                    fields = ("
            },
            {
              "lineno": 359,
              "line": "                        block.input_schema.get_fields()"
            },
            {
              "lineno": 360,
              "line": "                        if block.block_type != BlockType.AGENT"
            },
            {
              "lineno": 361,
              "line": "                        else vals.get(\"input_schema\", {}).get(\"properties\", {}).keys()"
            },
            {
              "lineno": 362,
              "line": "                    )"
            },
            {
              "lineno": 363,
              "line": "                if sanitized_name not in fields:"
            },
            {
              "lineno": 364,
              "line": "                    fields_msg = f\"Allowed fields: {fields}\""
            },
            {
              "lineno": 365,
              "line": "                    raise ValueError(f\"{suffix}, `{name}` invalid, {fields_msg}\")"
            },
            {
              "lineno": 366,
              "line": ""
            },
            {
              "lineno": 367,
              "line": "            if is_static_output_block(link.source_id):"
            },
            {
              "lineno": 368,
              "line": "                link.is_static = True  # Each value block output should be static."
            }
          ],
          "blocks": [
            {
              "id": 1,
              "label": "    def validate_graph(self, for_run: bool = False):\n        def sanitize(name):\n            return name.split(\"_#_\")[0].split(\"_@_\")[0].split(\"_$_\")[0]",
              "successors": [
                {
                  "id": 3,
                  "label": "        input_links = defaultdict(list)\n        for link in self.links:\n            input_links[link.sink_id].append(link)",
                  "successors": [
                    {
                      "id": 5,
                      "label": "        for node in self.nodes:\n            block = get_block(node.block_id)",
                      "successors": [
                        {
                          "id": 6,
                          "label": "            if block is None:\n                raise ValueError(f\"Invalid block {node.block_id} for node #{node.id}\")\n            provided_inputs = set(\n                [sanitize(name) for name in node.input_default]\n                + [sanitize(link.sink_name) for link in input_links.get(node.id, [])]\n            )",
                          "successors": [
                            {
                              "id": 8,
                              "label": "            for name in block.input_schema.get_required_fields():\n                if (\n                    name not in provided_inputs\n                    and not (\n                        name == \"payload\"\n                        and block.block_type\n                        in (BlockType.WEBHOOK, BlockType.WEBHOOK_MANUAL)\n                    )\n                    and (\n                        for_run  # Skip input completion validation, unless when executing.\n                        or block.block_type == BlockType.INPUT\n                        or block.block_type == BlockType.OUTPUT\n                        or block.block_type == BlockType.AGENT\n                    )\n                ):",
                              "successors": [
                                {
                                  "id": 9,
                                  "label": "                    raise ValueError(\n                        f\"Node {block.name} #{node.id} required input missing: `{name}`\"\n                    )",
                                  "successors": []
                                }
                              ]
                            },
                            {
                              "id": 10,
                              "label": "            input_schema = block.input_schema.model_fields\n            required_fields = block.input_schema.get_required_fields()\n            def has_value(name):\n                return (\n                    node is not None\n                    and name in node.input_default\n                    and node.input_default[name] is not None\n                    and str(node.input_default[name]).strip() != \"\"\n                ) or (name in input_schema and input_schema[name].default is not None)",
                              "successors": [
                                {
                                  "id": 12,
                                  "label": "            for field_name, field_info in input_schema.items():\n                json_schema_extra = field_info.json_schema_extra or {}\n                dependencies = json_schema_extra.get(\"depends_on\", [])\n                if not for_run or not dependencies:\n                    continue\n\n                field_has_value = has_value(field_name)\n                field_is_required = field_name in required_fields\n\n                missing_deps = [dep for dep in dependencies if not has_value(dep)]\n                if missing_deps and (field_has_value or field_is_required):\n                    raise ValueError(\n                        f\"Node {block.name} #{node.id}: Field `{field_name}` requires [{', '.join(missing_deps)}] to be set\"\n                    )",
                                  "successors": [
                                    {
                                      "id": 13,
                                      "label": "        node_map = {v.id: v for v in self.nodes}\n        def is_static_output_block(nid: str) -> bool:\n            bid = node_map[nid].block_id\n            b = get_block(bid)\n            return b.static_output if b else False",
                                      "successors": [
                                        {
                                          "id": 15,
                                          "label": "        for link in self.links:\n            source = (link.source_id, link.source_name)",
                                          "successors": [
                                            {
                                              "id": 16,
                                              "label": "            sink = (link.sink_id, link.sink_name)\n            suffix = f\"Link {source} <-> {sink}\"",
                                              "successors": [
                                                {
                                                  "id": 17,
                                                  "label": "            for i, (node_id, name) in enumerate([source, sink]):\n                node = node_map.get(node_id)\n                if not node:\n                    raise ValueError(\n                        f\"{suffix}, {node_id} is invalid node id, available nodes: {node_map.keys()}\"\n                    )\n\n                block = get_block(node.block_id)\n                if not block:\n                    blocks = {v().id: v().name for v in get_blocks().values()}\n                    raise ValueError(\n                        f\"{suffix}, {node.block_id} is invalid block id, available blocks: {blocks}\"\n                    )\n\n                sanitized_name = sanitize(name)\n                vals = node.input_default",
                                                  "successors": [
                                                    {
                                                      "id": 18,
                                                      "label": "                if i == 0:\n                    fields = (\n                        block.output_schema.get_fields()\n                        if block.block_type != BlockType.AGENT\n                        else vals.get(\"output_schema\", {}).get(\"properties\", {}).keys()\n                    )\n                else:\n                    fields = (\n                        block.input_schema.get_fields()\n                        if block.block_type != BlockType.AGENT\n                        else vals.get(\"input_schema\", {}).get(\"properties\", {}).keys()\n                    )\n                if sanitized_name not in fields:\n                    fields_msg = f\"Allowed fields: {fields}\"\n                    raise ValueError(f\"{suffix}, `{name}` invalid, {fields_msg}\")\n            if is_static_output_block(link.source_id):\n                link.is_static = True  # Each value block output should be static.",
                                                      "successors": []
                                                    }
                                                  ]
                                                }
                                              ]
                                            }
                                          ]
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "from_db",
          "type": "function",
          "start_line": 371,
          "end_line": 391,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 371,
              "line": "    def from_db(graph: AgentGraph, for_export: bool = False):"
            },
            {
              "lineno": 372,
              "line": "        return GraphModel("
            },
            {
              "lineno": 373,
              "line": "            id=graph.id,"
            },
            {
              "lineno": 374,
              "line": "            user_id=graph.userId,"
            },
            {
              "lineno": 375,
              "line": "            version=graph.version,"
            },
            {
              "lineno": 376,
              "line": "            is_active=graph.isActive,"
            },
            {
              "lineno": 377,
              "line": "            is_template=graph.isTemplate,"
            },
            {
              "lineno": 378,
              "line": "            name=graph.name or \"\","
            },
            {
              "lineno": 379,
              "line": "            description=graph.description or \"\","
            },
            {
              "lineno": 380,
              "line": "            nodes=["
            },
            {
              "lineno": 381,
              "line": "                NodeModel.from_db(GraphModel._process_node(node, for_export))"
            },
            {
              "lineno": 382,
              "line": "                for node in graph.AgentNodes or []"
            },
            {
              "lineno": 383,
              "line": "            ],"
            },
            {
              "lineno": 384,
              "line": "            links=list("
            },
            {
              "lineno": 385,
              "line": "                {"
            },
            {
              "lineno": 386,
              "line": "                    Link.from_db(link)"
            },
            {
              "lineno": 387,
              "line": "                    for node in graph.AgentNodes or []"
            },
            {
              "lineno": 388,
              "line": "                    for link in (node.Input or []) + (node.Output or [])"
            },
            {
              "lineno": 389,
              "line": "                }"
            },
            {
              "lineno": 390,
              "line": "            ),"
            },
            {
              "lineno": 391,
              "line": "        )"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "label": "    def from_db(graph: AgentGraph, for_export: bool = False):\n        return GraphModel(\n            id=graph.id,\n            user_id=graph.userId,\n            version=graph.version,\n            is_active=graph.isActive,\n            is_template=graph.isTemplate,\n            name=graph.name or \"\",\n            description=graph.description or \"\",\n            nodes=[\n                NodeModel.from_db(GraphModel._process_node(node, for_export))\n                for node in graph.AgentNodes or []\n            ],\n            links=list(\n                {\n                    Link.from_db(link)\n                    for node in graph.AgentNodes or []\n                    for link in (node.Input or []) + (node.Output or [])\n                }\n            ),",
              "successors": []
            }
          ]
        },
        {
          "name": "_process_node",
          "type": "function",
          "start_line": 394,
          "end_line": 408,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 394,
              "line": "    def _process_node(node: AgentNode, for_export: bool) -> AgentNode:"
            },
            {
              "lineno": 395,
              "line": "        if for_export:"
            },
            {
              "lineno": 396,
              "line": "            # Remove credentials from node input"
            },
            {
              "lineno": 397,
              "line": "            if node.constantInput:"
            },
            {
              "lineno": 398,
              "line": "                constant_input = json.loads("
            },
            {
              "lineno": 399,
              "line": "                    node.constantInput, target_type=dict[str, Any]"
            },
            {
              "lineno": 400,
              "line": "                )"
            },
            {
              "lineno": 401,
              "line": "                constant_input = GraphModel._hide_node_input_credentials(constant_input)"
            },
            {
              "lineno": 402,
              "line": "                node.constantInput = json.dumps(constant_input)"
            },
            {
              "lineno": 403,
              "line": ""
            },
            {
              "lineno": 404,
              "line": "            # Remove webhook info"
            },
            {
              "lineno": 405,
              "line": "            node.webhookId = None"
            },
            {
              "lineno": 406,
              "line": "            node.Webhook = None"
            },
            {
              "lineno": 407,
              "line": ""
            },
            {
              "lineno": 408,
              "line": "        return node"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "label": "    def _process_node(node: AgentNode, for_export: bool) -> AgentNode:",
              "successors": [
                {
                  "id": 2,
                  "label": "        if for_export:\n            # Remove credentials from node input",
                  "successors": [
                    {
                      "id": 4,
                      "label": "            if node.constantInput:\n                constant_input = json.loads(\n                    node.constantInput, target_type=dict[str, Any]\n                )\n                constant_input = GraphModel._hide_node_input_credentials(constant_input)\n                node.constantInput = json.dumps(constant_input)",
                      "successors": []
                    },
                    {
                      "id": 6,
                      "label": "            # Remove webhook info\n            node.webhookId = None\n            node.Webhook = None",
                      "successors": []
                    }
                  ]
                },
                {
                  "id": 7,
                  "label": "        return node",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "_hide_node_input_credentials",
          "type": "function",
          "start_line": 411,
          "end_line": 424,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 411,
              "line": "    def _hide_node_input_credentials(input_data: dict[str, Any]) -> dict[str, Any]:"
            },
            {
              "lineno": 412,
              "line": "        sensitive_keys = [\"credentials\", \"api_key\", \"password\", \"token\", \"secret\"]"
            },
            {
              "lineno": 413,
              "line": "        result = {}"
            },
            {
              "lineno": 414,
              "line": "        for key, value in input_data.items():"
            },
            {
              "lineno": 415,
              "line": "            if isinstance(value, dict):"
            },
            {
              "lineno": 416,
              "line": "                result[key] = GraphModel._hide_node_input_credentials(value)"
            },
            {
              "lineno": 417,
              "line": "            elif isinstance(value, str) and any("
            },
            {
              "lineno": 418,
              "line": "                sensitive_key in key.lower() for sensitive_key in sensitive_keys"
            },
            {
              "lineno": 419,
              "line": "            ):"
            },
            {
              "lineno": 420,
              "line": "                # Skip this key-value pair in the result"
            },
            {
              "lineno": 421,
              "line": "                continue"
            },
            {
              "lineno": 422,
              "line": "            else:"
            },
            {
              "lineno": 423,
              "line": "                result[key] = value"
            },
            {
              "lineno": 424,
              "line": "        return result"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "label": "    def _hide_node_input_credentials(input_data: dict[str, Any]) -> dict[str, Any]:\n        sensitive_keys = [\"credentials\", \"api_key\", \"password\", \"token\", \"secret\"]\n        result = {}",
              "successors": [
                {
                  "id": 3,
                  "label": "        for key, value in input_data.items():",
                  "successors": [
                    {
                      "id": 4,
                      "label": "            if isinstance(value, dict):\n                result[key] = GraphModel._hide_node_input_credentials(value)\n            if isinstance(value, dict):\n                result[key] = GraphModel._hide_node_input_credentials(value)",
                      "successors": [
                        {
                          "id": 7,
                          "label": "            elif isinstance(value, str) and any(\n                sensitive_key in key.lower() for sensitive_key in sensitive_keys\n            ):\n                # Skip this key-value pair in the result\n                continue\n            else:\n                result[key] = value",
                          "successors": [
                            {
                              "id": 3,
                              "label": "        for key, value in input_data.items():",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "id": 6,
                      "label": "            elif isinstance(value, str) and any(\n                sensitive_key in key.lower() for sensitive_key in sensitive_keys\n            ):\n                # Skip this key-value pair in the result\n                continue\n            else:\n                result[key] = value",
                      "successors": [
                        {
                          "id": 3,
                          "label": "        for key, value in input_data.items():",
                          "successors": []
                        }
                      ]
                    },
                    {
                      "id": 8,
                      "label": "            else:\n                result[key] = value",
                      "successors": [
                        {
                          "id": 3,
                          "label": "        for key, value in input_data.items():",
                          "successors": []
                        }
                      ]
                    }
                  ]
                },
                {
                  "id": 9,
                  "label": "        return result",
                  "successors": []
                }
              ]
            }
          ]
        }
      ],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 207,
          "line": "class GraphModel(Graph):"
        },
        {
          "lineno": 208,
          "line": "    user_id: str"
        },
        {
          "lineno": 209,
          "line": "    nodes: list[NodeModel] = []  # type: ignore"
        },
        {
          "lineno": 210,
          "line": ""
        },
        {
          "lineno": 211,
          "line": "    @property"
        },
        {
          "lineno": 224,
          "line": ""
        },
        {
          "lineno": 253,
          "line": ""
        },
        {
          "lineno": 369,
          "line": ""
        },
        {
          "lineno": 370,
          "line": "    @staticmethod"
        },
        {
          "lineno": 392,
          "line": ""
        },
        {
          "lineno": 393,
          "line": "    @staticmethod"
        },
        {
          "lineno": 409,
          "line": ""
        },
        {
          "lineno": 410,
          "line": "    @staticmethod"
        },
        {
          "lineno": 425,
          "line": ""
        },
        {
          "lineno": 426,
          "line": ""
        },
        {
          "lineno": 427,
          "line": "# --------------------- CRUD functions --------------------- #"
        },
        {
          "lineno": 428,
          "line": ""
        },
        {
          "lineno": 429,
          "line": ""
        },
        {
          "lineno": 430,
          "line": "async def get_node(node_id: str) -> NodeModel:"
        },
        {
          "lineno": 431,
          "line": "    node = await AgentNode.prisma().find_unique_or_raise("
        },
        {
          "lineno": 432,
          "line": "        where={\"id\": node_id},"
        },
        {
          "lineno": 433,
          "line": "        include=AGENT_NODE_INCLUDE,"
        },
        {
          "lineno": 434,
          "line": "    )"
        },
        {
          "lineno": 435,
          "line": "    return NodeModel.from_db(node)"
        },
        {
          "lineno": 436,
          "line": ""
        },
        {
          "lineno": 437,
          "line": ""
        },
        {
          "lineno": 438,
          "line": "async def set_node_webhook(node_id: str, webhook_id: str | None) -> NodeModel:"
        },
        {
          "lineno": 439,
          "line": "    node = await AgentNode.prisma().update("
        },
        {
          "lineno": 440,
          "line": "        where={\"id\": node_id},"
        },
        {
          "lineno": 441,
          "line": "        data=("
        },
        {
          "lineno": 442,
          "line": "            {\"Webhook\": {\"connect\": {\"id\": webhook_id}}}"
        },
        {
          "lineno": 443,
          "line": "            if webhook_id"
        },
        {
          "lineno": 444,
          "line": "            else {\"Webhook\": {\"disconnect\": True}}"
        },
        {
          "lineno": 445,
          "line": "        ),"
        },
        {
          "lineno": 446,
          "line": "        include=AGENT_NODE_INCLUDE,"
        },
        {
          "lineno": 447,
          "line": "    )"
        },
        {
          "lineno": 448,
          "line": "    if not node:"
        },
        {
          "lineno": 449,
          "line": "        raise ValueError(f\"Node #{node_id} not found\")"
        },
        {
          "lineno": 450,
          "line": "    return NodeModel.from_db(node)"
        },
        {
          "lineno": 451,
          "line": ""
        },
        {
          "lineno": 452,
          "line": ""
        },
        {
          "lineno": 453,
          "line": "async def get_graphs("
        },
        {
          "lineno": 454,
          "line": "    user_id: str,"
        },
        {
          "lineno": 455,
          "line": "    filter_by: Literal[\"active\", \"template\"] | None = \"active\","
        },
        {
          "lineno": 456,
          "line": ") -> list[GraphModel]:"
        },
        {
          "lineno": 457,
          "line": "    \"\"\""
        },
        {
          "lineno": 458,
          "line": "    Retrieves graph metadata objects."
        },
        {
          "lineno": 459,
          "line": "    Default behaviour is to get all currently active graphs."
        },
        {
          "lineno": 460,
          "line": ""
        },
        {
          "lineno": 461,
          "line": "    Args:"
        },
        {
          "lineno": 462,
          "line": "        filter_by: An optional filter to either select templates or active graphs."
        },
        {
          "lineno": 463,
          "line": "        user_id: The ID of the user that owns the graph."
        },
        {
          "lineno": 464,
          "line": ""
        },
        {
          "lineno": 465,
          "line": "    Returns:"
        },
        {
          "lineno": 466,
          "line": "        list[GraphModel]: A list of objects representing the retrieved graphs."
        },
        {
          "lineno": 467,
          "line": "    \"\"\""
        },
        {
          "lineno": 468,
          "line": "    where_clause: AgentGraphWhereInput = {\"userId\": user_id}"
        },
        {
          "lineno": 469,
          "line": ""
        },
        {
          "lineno": 470,
          "line": "    if filter_by == \"active\":"
        },
        {
          "lineno": 471,
          "line": "        where_clause[\"isActive\"] = True"
        },
        {
          "lineno": 472,
          "line": "    elif filter_by == \"template\":"
        },
        {
          "lineno": 473,
          "line": "        where_clause[\"isTemplate\"] = True"
        },
        {
          "lineno": 474,
          "line": ""
        },
        {
          "lineno": 475,
          "line": "    graphs = await AgentGraph.prisma().find_many("
        },
        {
          "lineno": 476,
          "line": "        where=where_clause,"
        },
        {
          "lineno": 477,
          "line": "        distinct=[\"id\"],"
        },
        {
          "lineno": 478,
          "line": "        order={\"version\": \"desc\"},"
        },
        {
          "lineno": 479,
          "line": "        include=AGENT_GRAPH_INCLUDE,"
        },
        {
          "lineno": 480,
          "line": "    )"
        },
        {
          "lineno": 481,
          "line": ""
        },
        {
          "lineno": 482,
          "line": "    graph_models = []"
        },
        {
          "lineno": 483,
          "line": "    for graph in graphs:"
        },
        {
          "lineno": 484,
          "line": "        try:"
        },
        {
          "lineno": 485,
          "line": "            graph_models.append(GraphModel.from_db(graph))"
        },
        {
          "lineno": 486,
          "line": "        except Exception as e:"
        },
        {
          "lineno": 487,
          "line": "            logger.error(f\"Error processing graph {graph.id}: {e}\")"
        },
        {
          "lineno": 488,
          "line": "            continue"
        },
        {
          "lineno": 489,
          "line": ""
        },
        {
          "lineno": 490,
          "line": "    return graph_models"
        },
        {
          "lineno": 491,
          "line": ""
        },
        {
          "lineno": 492,
          "line": ""
        },
        {
          "lineno": 493,
          "line": "async def get_executions(user_id: str) -> list[GraphExecution]:"
        },
        {
          "lineno": 494,
          "line": "    executions = await AgentGraphExecution.prisma().find_many("
        },
        {
          "lineno": 495,
          "line": "        where={\"userId\": user_id},"
        },
        {
          "lineno": 496,
          "line": "        order={\"createdAt\": \"desc\"},"
        },
        {
          "lineno": 497,
          "line": "    )"
        },
        {
          "lineno": 498,
          "line": "    return [GraphExecution.from_db(execution) for execution in executions]"
        },
        {
          "lineno": 499,
          "line": ""
        },
        {
          "lineno": 500,
          "line": ""
        },
        {
          "lineno": 501,
          "line": "async def get_execution(user_id: str, execution_id: str) -> GraphExecution | None:"
        },
        {
          "lineno": 502,
          "line": "    execution = await AgentGraphExecution.prisma().find_first("
        },
        {
          "lineno": 503,
          "line": "        where={\"id\": execution_id, \"userId\": user_id}"
        },
        {
          "lineno": 504,
          "line": "    )"
        },
        {
          "lineno": 505,
          "line": "    return GraphExecution.from_db(execution) if execution else None"
        },
        {
          "lineno": 506,
          "line": ""
        },
        {
          "lineno": 507,
          "line": ""
        },
        {
          "lineno": 508,
          "line": "async def get_graph("
        },
        {
          "lineno": 509,
          "line": "    graph_id: str,"
        },
        {
          "lineno": 510,
          "line": "    version: int | None = None,"
        },
        {
          "lineno": 511,
          "line": "    template: bool = False,"
        },
        {
          "lineno": 512,
          "line": "    user_id: str | None = None,"
        },
        {
          "lineno": 513,
          "line": "    for_export: bool = False,"
        },
        {
          "lineno": 514,
          "line": ") -> GraphModel | None:"
        },
        {
          "lineno": 515,
          "line": "    \"\"\""
        },
        {
          "lineno": 516,
          "line": "    Retrieves a graph from the DB."
        },
        {
          "lineno": 517,
          "line": "    Defaults to the version with `is_active` if `version` is not passed,"
        },
        {
          "lineno": 518,
          "line": "    or the latest version with `is_template` if `template=True`."
        },
        {
          "lineno": 519,
          "line": ""
        },
        {
          "lineno": 520,
          "line": "    Returns `None` if the record is not found."
        },
        {
          "lineno": 521,
          "line": "    \"\"\""
        },
        {
          "lineno": 522,
          "line": "    where_clause: AgentGraphWhereInput = {"
        },
        {
          "lineno": 523,
          "line": "        \"id\": graph_id,"
        },
        {
          "lineno": 524,
          "line": "    }"
        },
        {
          "lineno": 525,
          "line": "    if version is not None:"
        },
        {
          "lineno": 526,
          "line": "        where_clause[\"version\"] = version"
        },
        {
          "lineno": 527,
          "line": "    elif not template:"
        },
        {
          "lineno": 528,
          "line": "        where_clause[\"isActive\"] = True"
        },
        {
          "lineno": 529,
          "line": ""
        },
        {
          "lineno": 530,
          "line": "    # TODO: Fix hack workaround to get adding store agents to work"
        },
        {
          "lineno": 531,
          "line": "    if user_id is not None and not template:"
        },
        {
          "lineno": 532,
          "line": "        where_clause[\"userId\"] = user_id"
        },
        {
          "lineno": 533,
          "line": ""
        },
        {
          "lineno": 534,
          "line": "    graph = await AgentGraph.prisma().find_first("
        },
        {
          "lineno": 535,
          "line": "        where=where_clause,"
        },
        {
          "lineno": 536,
          "line": "        include=AGENT_GRAPH_INCLUDE,"
        },
        {
          "lineno": 537,
          "line": "        order={\"version\": \"desc\"},"
        },
        {
          "lineno": 538,
          "line": "    )"
        },
        {
          "lineno": 539,
          "line": "    return GraphModel.from_db(graph, for_export) if graph else None"
        },
        {
          "lineno": 540,
          "line": ""
        },
        {
          "lineno": 541,
          "line": ""
        },
        {
          "lineno": 542,
          "line": "async def set_graph_active_version(graph_id: str, version: int, user_id: str) -> None:"
        },
        {
          "lineno": 543,
          "line": "    # Activate the requested version if it exists and is owned by the user."
        },
        {
          "lineno": 544,
          "line": "    updated_count = await AgentGraph.prisma().update_many("
        },
        {
          "lineno": 545,
          "line": "        data={\"isActive\": True},"
        },
        {
          "lineno": 546,
          "line": "        where={"
        },
        {
          "lineno": 547,
          "line": "            \"id\": graph_id,"
        },
        {
          "lineno": 548,
          "line": "            \"version\": version,"
        },
        {
          "lineno": 549,
          "line": "            \"userId\": user_id,"
        },
        {
          "lineno": 550,
          "line": "        },"
        },
        {
          "lineno": 551,
          "line": "    )"
        },
        {
          "lineno": 552,
          "line": "    if updated_count == 0:"
        },
        {
          "lineno": 553,
          "line": "        raise Exception(f\"Graph #{graph_id} v{version} not found or not owned by user\")"
        },
        {
          "lineno": 554,
          "line": ""
        },
        {
          "lineno": 555,
          "line": "    # Deactivate all other versions."
        },
        {
          "lineno": 556,
          "line": "    await AgentGraph.prisma().update_many("
        },
        {
          "lineno": 557,
          "line": "        data={\"isActive\": False},"
        },
        {
          "lineno": 558,
          "line": "        where={"
        },
        {
          "lineno": 559,
          "line": "            \"id\": graph_id,"
        },
        {
          "lineno": 560,
          "line": "            \"version\": {\"not\": version},"
        },
        {
          "lineno": 561,
          "line": "            \"userId\": user_id,"
        },
        {
          "lineno": 562,
          "line": "            \"isActive\": True,"
        },
        {
          "lineno": 563,
          "line": "        },"
        },
        {
          "lineno": 564,
          "line": "    )"
        },
        {
          "lineno": 565,
          "line": ""
        },
        {
          "lineno": 566,
          "line": ""
        },
        {
          "lineno": 567,
          "line": "async def get_graph_all_versions(graph_id: str, user_id: str) -> list[GraphModel]:"
        },
        {
          "lineno": 568,
          "line": "    graph_versions = await AgentGraph.prisma().find_many("
        },
        {
          "lineno": 569,
          "line": "        where={\"id\": graph_id, \"userId\": user_id},"
        },
        {
          "lineno": 570,
          "line": "        order={\"version\": \"desc\"},"
        },
        {
          "lineno": 571,
          "line": "        include=AGENT_GRAPH_INCLUDE,"
        },
        {
          "lineno": 572,
          "line": "    )"
        },
        {
          "lineno": 573,
          "line": ""
        },
        {
          "lineno": 574,
          "line": "    if not graph_versions:"
        },
        {
          "lineno": 575,
          "line": "        return []"
        },
        {
          "lineno": 576,
          "line": ""
        },
        {
          "lineno": 577,
          "line": "    return [GraphModel.from_db(graph) for graph in graph_versions]"
        },
        {
          "lineno": 578,
          "line": ""
        },
        {
          "lineno": 579,
          "line": ""
        },
        {
          "lineno": 580,
          "line": "async def delete_graph(graph_id: str, user_id: str) -> int:"
        },
        {
          "lineno": 581,
          "line": "    entries_count = await AgentGraph.prisma().delete_many("
        },
        {
          "lineno": 582,
          "line": "        where={\"id\": graph_id, \"userId\": user_id}"
        },
        {
          "lineno": 583,
          "line": "    )"
        },
        {
          "lineno": 584,
          "line": "    if entries_count:"
        },
        {
          "lineno": 585,
          "line": "        logger.info(f\"Deleted {entries_count} graph entries for Graph #{graph_id}\")"
        },
        {
          "lineno": 586,
          "line": "    return entries_count"
        },
        {
          "lineno": 587,
          "line": ""
        },
        {
          "lineno": 588,
          "line": ""
        },
        {
          "lineno": 589,
          "line": "async def create_graph(graph: Graph, user_id: str) -> GraphModel:"
        },
        {
          "lineno": 590,
          "line": "    async with transaction() as tx:"
        },
        {
          "lineno": 591,
          "line": "        await __create_graph(tx, graph, user_id)"
        },
        {
          "lineno": 592,
          "line": ""
        },
        {
          "lineno": 593,
          "line": "    if created_graph := await get_graph("
        },
        {
          "lineno": 594,
          "line": "        graph.id, graph.version, graph.is_template, user_id=user_id"
        },
        {
          "lineno": 595,
          "line": "    ):"
        },
        {
          "lineno": 596,
          "line": "        return created_graph"
        },
        {
          "lineno": 597,
          "line": ""
        },
        {
          "lineno": 598,
          "line": "    raise ValueError(f\"Created graph {graph.id} v{graph.version} is not in DB\")"
        },
        {
          "lineno": 599,
          "line": ""
        },
        {
          "lineno": 600,
          "line": ""
        },
        {
          "lineno": 601,
          "line": "async def __create_graph(tx, graph: Graph, user_id: str):"
        },
        {
          "lineno": 602,
          "line": "    await AgentGraph.prisma(tx).create("
        },
        {
          "lineno": 603,
          "line": "        data={"
        },
        {
          "lineno": 604,
          "line": "            \"id\": graph.id,"
        },
        {
          "lineno": 605,
          "line": "            \"version\": graph.version,"
        },
        {
          "lineno": 606,
          "line": "            \"name\": graph.name,"
        },
        {
          "lineno": 607,
          "line": "            \"description\": graph.description,"
        },
        {
          "lineno": 608,
          "line": "            \"isTemplate\": graph.is_template,"
        },
        {
          "lineno": 609,
          "line": "            \"isActive\": graph.is_active,"
        },
        {
          "lineno": 610,
          "line": "            \"userId\": user_id,"
        },
        {
          "lineno": 611,
          "line": "        }"
        },
        {
          "lineno": 612,
          "line": "    )"
        },
        {
          "lineno": 613,
          "line": ""
        },
        {
          "lineno": 614,
          "line": "    await asyncio.gather("
        },
        {
          "lineno": 615,
          "line": "        *["
        },
        {
          "lineno": 616,
          "line": "            AgentNode.prisma(tx).create("
        },
        {
          "lineno": 617,
          "line": "                {"
        },
        {
          "lineno": 618,
          "line": "                    \"id\": node.id,"
        },
        {
          "lineno": 619,
          "line": "                    \"agentBlockId\": node.block_id,"
        },
        {
          "lineno": 620,
          "line": "                    \"agentGraphId\": graph.id,"
        },
        {
          "lineno": 621,
          "line": "                    \"agentGraphVersion\": graph.version,"
        },
        {
          "lineno": 622,
          "line": "                    \"constantInput\": json.dumps(node.input_default),"
        },
        {
          "lineno": 623,
          "line": "                    \"metadata\": json.dumps(node.metadata),"
        },
        {
          "lineno": 624,
          "line": "                }"
        },
        {
          "lineno": 625,
          "line": "            )"
        },
        {
          "lineno": 626,
          "line": "            for node in graph.nodes"
        },
        {
          "lineno": 627,
          "line": "        ]"
        },
        {
          "lineno": 628,
          "line": "    )"
        },
        {
          "lineno": 629,
          "line": ""
        },
        {
          "lineno": 630,
          "line": "    await asyncio.gather("
        },
        {
          "lineno": 631,
          "line": "        *["
        },
        {
          "lineno": 632,
          "line": "            AgentNodeLink.prisma(tx).create("
        },
        {
          "lineno": 633,
          "line": "                {"
        },
        {
          "lineno": 634,
          "line": "                    \"id\": str(uuid.uuid4()),"
        },
        {
          "lineno": 635,
          "line": "                    \"sourceName\": link.source_name,"
        },
        {
          "lineno": 636,
          "line": "                    \"sinkName\": link.sink_name,"
        },
        {
          "lineno": 637,
          "line": "                    \"agentNodeSourceId\": link.source_id,"
        },
        {
          "lineno": 638,
          "line": "                    \"agentNodeSinkId\": link.sink_id,"
        },
        {
          "lineno": 639,
          "line": "                    \"isStatic\": link.is_static,"
        },
        {
          "lineno": 640,
          "line": "                }"
        },
        {
          "lineno": 641,
          "line": "            )"
        },
        {
          "lineno": 642,
          "line": "            for link in graph.links"
        },
        {
          "lineno": 643,
          "line": "        ]"
        },
        {
          "lineno": 644,
          "line": "    )"
        },
        {
          "lineno": 645,
          "line": ""
        },
        {
          "lineno": 646,
          "line": ""
        },
        {
          "lineno": 647,
          "line": "# ------------------------ UTILITIES ------------------------ #"
        },
        {
          "lineno": 648,
          "line": ""
        },
        {
          "lineno": 649,
          "line": ""
        },
        {
          "lineno": 650,
          "line": "def make_graph_model(creatable_graph: Graph, user_id: str) -> GraphModel:"
        },
        {
          "lineno": 651,
          "line": "    \"\"\""
        },
        {
          "lineno": 652,
          "line": "    Convert a Graph to a GraphModel, setting graph_id and graph_version on all nodes."
        },
        {
          "lineno": 653,
          "line": ""
        },
        {
          "lineno": 654,
          "line": "    Args:"
        },
        {
          "lineno": 655,
          "line": "        creatable_graph (Graph): The creatable graph to convert."
        },
        {
          "lineno": 656,
          "line": "        user_id (str): The ID of the user creating the graph."
        },
        {
          "lineno": 657,
          "line": ""
        },
        {
          "lineno": 658,
          "line": "    Returns:"
        },
        {
          "lineno": 659,
          "line": "        GraphModel: The converted Graph object."
        },
        {
          "lineno": 660,
          "line": "    \"\"\""
        },
        {
          "lineno": 661,
          "line": "    # Create a new Graph object, inheriting properties from CreatableGraph"
        },
        {
          "lineno": 662,
          "line": "    return GraphModel("
        },
        {
          "lineno": 663,
          "line": "        **creatable_graph.model_dump(exclude={\"nodes\"}),"
        },
        {
          "lineno": 664,
          "line": "        user_id=user_id,"
        },
        {
          "lineno": 665,
          "line": "        nodes=["
        },
        {
          "lineno": 666,
          "line": "            NodeModel("
        },
        {
          "lineno": 667,
          "line": "                **creatable_node.model_dump(),"
        },
        {
          "lineno": 668,
          "line": "                graph_id=creatable_graph.id,"
        },
        {
          "lineno": 669,
          "line": "                graph_version=creatable_graph.version,"
        },
        {
          "lineno": 670,
          "line": "            )"
        },
        {
          "lineno": 671,
          "line": "            for creatable_node in creatable_graph.nodes"
        },
        {
          "lineno": 672,
          "line": "        ],"
        },
        {
          "lineno": 673,
          "line": "    )"
        },
        {
          "lineno": 674,
          "line": ""
        },
        {
          "lineno": 675,
          "line": ""
        },
        {
          "lineno": 676,
          "line": "async def fix_llm_provider_credentials():"
        },
        {
          "lineno": 677,
          "line": "    \"\"\"Fix node credentials with provider `llm`\"\"\""
        },
        {
          "lineno": 678,
          "line": "    from backend.integrations.credentials_store import IntegrationCredentialsStore"
        },
        {
          "lineno": 679,
          "line": ""
        },
        {
          "lineno": 680,
          "line": "    from .user import get_user_integrations"
        },
        {
          "lineno": 681,
          "line": ""
        },
        {
          "lineno": 682,
          "line": "    store = IntegrationCredentialsStore()"
        },
        {
          "lineno": 683,
          "line": ""
        },
        {
          "lineno": 684,
          "line": "    broken_nodes = await prisma.get_client().query_raw("
        },
        {
          "lineno": 685,
          "line": "        \"\"\""
        },
        {
          "lineno": 686,
          "line": "        SELECT    graph.\"userId\"       user_id,"
        },
        {
          "lineno": 687,
          "line": "                  node.id              node_id,"
        },
        {
          "lineno": 688,
          "line": "                  node.\"constantInput\" node_preset_input"
        },
        {
          "lineno": 689,
          "line": "        FROM      platform.\"AgentNode\"  node"
        },
        {
          "lineno": 690,
          "line": "        LEFT JOIN platform.\"AgentGraph\" graph"
        },
        {
          "lineno": 691,
          "line": "        ON        node.\"agentGraphId\" = graph.id"
        },
        {
          "lineno": 692,
          "line": "        WHERE     node.\"constantInput\"::jsonb->'credentials'->>'provider' = 'llm'"
        },
        {
          "lineno": 693,
          "line": "        ORDER BY  graph.\"userId\";"
        },
        {
          "lineno": 694,
          "line": "        \"\"\""
        },
        {
          "lineno": 695,
          "line": "    )"
        },
        {
          "lineno": 696,
          "line": "    logger.info(f\"Fixing LLM credential inputs on {len(broken_nodes)} nodes\")"
        },
        {
          "lineno": 697,
          "line": ""
        },
        {
          "lineno": 698,
          "line": "    user_id: str = \"\""
        },
        {
          "lineno": 699,
          "line": "    user_integrations = None"
        },
        {
          "lineno": 700,
          "line": "    for node in broken_nodes:"
        },
        {
          "lineno": 701,
          "line": "        if node[\"user_id\"] != user_id:"
        },
        {
          "lineno": 702,
          "line": "            # Save queries by only fetching once per user"
        },
        {
          "lineno": 703,
          "line": "            user_id = node[\"user_id\"]"
        },
        {
          "lineno": 704,
          "line": "            user_integrations = await get_user_integrations(user_id)"
        },
        {
          "lineno": 705,
          "line": "        elif not user_integrations:"
        },
        {
          "lineno": 706,
          "line": "            raise RuntimeError(f\"Impossible state while processing node {node}\")"
        },
        {
          "lineno": 707,
          "line": ""
        },
        {
          "lineno": 708,
          "line": "        node_id: str = node[\"node_id\"]"
        },
        {
          "lineno": 709,
          "line": "        node_preset_input: dict = json.loads(node[\"node_preset_input\"])"
        },
        {
          "lineno": 710,
          "line": "        credentials_meta: dict = node_preset_input[\"credentials\"]"
        },
        {
          "lineno": 711,
          "line": ""
        },
        {
          "lineno": 712,
          "line": "        credentials = next("
        },
        {
          "lineno": 713,
          "line": "            ("
        },
        {
          "lineno": 714,
          "line": "                c"
        },
        {
          "lineno": 715,
          "line": "                for c in user_integrations.credentials"
        },
        {
          "lineno": 716,
          "line": "                if c.id == credentials_meta[\"id\"]"
        },
        {
          "lineno": 717,
          "line": "            ),"
        },
        {
          "lineno": 718,
          "line": "            None,"
        },
        {
          "lineno": 719,
          "line": "        )"
        },
        {
          "lineno": 720,
          "line": "        if not credentials:"
        },
        {
          "lineno": 721,
          "line": "            continue"
        },
        {
          "lineno": 722,
          "line": "        if credentials.type != \"api_key\":"
        },
        {
          "lineno": 723,
          "line": "            logger.warning("
        },
        {
          "lineno": 724,
          "line": "                f\"User {user_id} credentials {credentials.id} with provider 'llm' \""
        },
        {
          "lineno": 725,
          "line": "                f\"has invalid type '{credentials.type}'\""
        },
        {
          "lineno": 726,
          "line": "            )"
        },
        {
          "lineno": 727,
          "line": "            continue"
        },
        {
          "lineno": 728,
          "line": ""
        },
        {
          "lineno": 729,
          "line": "        api_key = credentials.api_key.get_secret_value()"
        },
        {
          "lineno": 730,
          "line": "        if api_key.startswith(\"sk-ant-api03-\"):"
        },
        {
          "lineno": 731,
          "line": "            credentials.provider = credentials_meta[\"provider\"] = \"anthropic\""
        },
        {
          "lineno": 732,
          "line": "        elif api_key.startswith(\"sk-\"):"
        },
        {
          "lineno": 733,
          "line": "            credentials.provider = credentials_meta[\"provider\"] = \"openai\""
        },
        {
          "lineno": 734,
          "line": "        elif api_key.startswith(\"gsk_\"):"
        },
        {
          "lineno": 735,
          "line": "            credentials.provider = credentials_meta[\"provider\"] = \"groq\""
        },
        {
          "lineno": 736,
          "line": "        else:"
        },
        {
          "lineno": 737,
          "line": "            logger.warning("
        },
        {
          "lineno": 738,
          "line": "                f\"Could not identify provider from key prefix {api_key[:13]}*****\""
        },
        {
          "lineno": 739,
          "line": "            )"
        },
        {
          "lineno": 740,
          "line": "            continue"
        },
        {
          "lineno": 741,
          "line": ""
        },
        {
          "lineno": 742,
          "line": "        store.update_creds(user_id, credentials)"
        },
        {
          "lineno": 743,
          "line": "        await AgentNode.prisma().update("
        },
        {
          "lineno": 744,
          "line": "            where={\"id\": node_id},"
        },
        {
          "lineno": 745,
          "line": "            data={\"constantInput\": json.dumps(node_preset_input)},"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "label": "class GraphModel(Graph):\n    user_id: str\n    nodes: list[NodeModel] = []  # type: ignore",
          "successors": [
            {
              "id": 2,
              "label": "@property",
              "successors": []
            },
            {
              "id": 3,
              "label": "@staticmethod",
              "successors": []
            },
            {
              "id": 4,
              "label": "@staticmethod",
              "successors": []
            },
            {
              "id": 5,
              "label": "@staticmethod",
              "successors": []
            },
            {
              "id": 6,
              "label": "async def get_node(node_id: str) -> NodeModel:\n    node = await AgentNode.prisma().find_unique_or_raise(\n        where={\"id\": node_id},\n        include=AGENT_NODE_INCLUDE,\n    )\n    return NodeModel.from_db(node)\nasync def set_node_webhook(node_id: str, webhook_id: str | None) -> NodeModel:\n    node = await AgentNode.prisma().update(\n        where={\"id\": node_id},\n        data=(\n            {\"Webhook\": {\"connect\": {\"id\": webhook_id}}}\n            if webhook_id\n            else {\"Webhook\": {\"disconnect\": True}}\n        ),\n        include=AGENT_NODE_INCLUDE,\n    )\n    if not node:\n        raise ValueError(f\"Node #{node_id} not found\")\n    return NodeModel.from_db(node)",
              "successors": [
                {
                  "id": 8,
                  "label": "async def get_graphs(\n    user_id: str,\n    filter_by: Literal[\"active\", \"template\"] | None = \"active\",\n) -> list[GraphModel]:\n    \"\"\"\n    Retrieves graph metadata objects.\n    Default behaviour is to get all currently active graphs.\n\n    Args:\n        filter_by: An optional filter to either select templates or active graphs.\n        user_id: The ID of the user that owns the graph.\n\n    Returns:\n        list[GraphModel]: A list of objects representing the retrieved graphs.\n    \"\"\"\n    where_clause: AgentGraphWhereInput = {\"userId\": user_id}\n\n    if filter_by == \"active\":\n        where_clause[\"isActive\"] = True\n    elif filter_by == \"template\":\n        where_clause[\"isTemplate\"] = True\n\n    graphs = await AgentGraph.prisma().find_many(\n        where=where_clause,\n        distinct=[\"id\"],\n        order={\"version\": \"desc\"},\n        include=AGENT_GRAPH_INCLUDE,\n    )\n\n    graph_models = []\n    for graph in graphs:\n        try:\n            graph_models.append(GraphModel.from_db(graph))\n        except Exception as e:\n            logger.error(f\"Error processing graph {graph.id}: {e}\")\n            continue\n\n    return graph_models",
                  "successors": []
                }
              ]
            }
          ]
        }
      ]
    }
  ],
  "simplified_code": [
    {
      "lineno": 1,
      "line": "import asyncio"
    },
    {
      "lineno": 2,
      "line": "import logging"
    },
    {
      "lineno": 3,
      "line": "import uuid"
    },
    {
      "lineno": 4,
      "line": "from collections import defaultdict"
    },
    {
      "lineno": 5,
      "line": "from datetime import datetime, timezone"
    },
    {
      "lineno": 6,
      "line": "from typing import Any, Literal, Optional, Type"
    },
    {
      "lineno": 7,
      "line": ""
    },
    {
      "lineno": 8,
      "line": "import prisma"
    },
    {
      "lineno": 9,
      "line": "from prisma.models import AgentGraph, AgentGraphExecution, AgentNode, AgentNodeLink"
    },
    {
      "lineno": 10,
      "line": "from prisma.types import AgentGraphWhereInput"
    },
    {
      "lineno": 11,
      "line": "from pydantic.fields import computed_field"
    },
    {
      "lineno": 12,
      "line": ""
    },
    {
      "lineno": 13,
      "line": "from backend.blocks.agent import AgentExecutorBlock"
    },
    {
      "lineno": 14,
      "line": "from backend.blocks.basic import AgentInputBlock, AgentOutputBlock"
    },
    {
      "lineno": 15,
      "line": "from backend.util import json"
    },
    {
      "lineno": 16,
      "line": ""
    },
    {
      "lineno": 17,
      "line": "from .block import BlockInput, BlockType, get_block, get_blocks"
    },
    {
      "lineno": 18,
      "line": "from .db import BaseDbModel, transaction"
    },
    {
      "lineno": 19,
      "line": "from .execution import ExecutionStatus"
    },
    {
      "lineno": 20,
      "line": "from .includes import AGENT_GRAPH_INCLUDE, AGENT_NODE_INCLUDE"
    },
    {
      "lineno": 21,
      "line": "from .integrations import Webhook"
    },
    {
      "lineno": 22,
      "line": ""
    },
    {
      "lineno": 23,
      "line": "logger = logging.getLogger(__name__)"
    },
    {
      "lineno": 24,
      "line": ""
    },
    {
      "lineno": 25,
      "line": ""
    },
    {
      "lineno": 46,
      "line": ""
    },
    {
      "lineno": 47,
      "line": ""
    },
    {
      "lineno": 57,
      "line": ""
    },
    {
      "lineno": 97,
      "line": ""
    },
    {
      "lineno": 98,
      "line": ""
    },
    {
      "lineno": 99,
      "line": "# Fix 2-way reference Node <-> Webhook"
    },
    {
      "lineno": 100,
      "line": "Webhook.model_rebuild()"
    },
    {
      "lineno": 101,
      "line": ""
    },
    {
      "lineno": 102,
      "line": ""
    },
    {
      "lineno": 140,
      "line": ""
    },
    {
      "lineno": 141,
      "line": ""
    },
    {
      "lineno": 205,
      "line": ""
    },
    {
      "lineno": 206,
      "line": ""
    }
  ],
  "blocks": [
    {
      "id": 1,
      "label": "import asyncio\nimport logging\nimport uuid\nfrom collections import defaultdict\nfrom datetime import datetime, timezone\nfrom typing import Any, Literal, Optional, Type\n\nimport prisma\nfrom prisma.models import AgentGraph, AgentGraphExecution, AgentNode, AgentNodeLink\nfrom prisma.types import AgentGraphWhereInput\nfrom pydantic.fields import computed_field\n\nfrom backend.blocks.agent import AgentExecutorBlock\nfrom backend.blocks.basic import AgentInputBlock, AgentOutputBlock\nfrom backend.util import json\n\nfrom .block import BlockInput, BlockType, get_block, get_blocks\nfrom .db import BaseDbModel, transaction\nfrom .execution import ExecutionStatus\nfrom .includes import AGENT_GRAPH_INCLUDE, AGENT_NODE_INCLUDE\nfrom .integrations import Webhook\n\nlogger = logging.getLogger(__name__)\n",
      "successors": [
        {
          "id": 3,
          "label": "Webhook.model_rebuild()\n",
          "successors": []
        }
      ]
    }
  ]
}