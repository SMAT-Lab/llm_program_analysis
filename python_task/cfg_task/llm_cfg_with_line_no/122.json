{
  "name": "example_script",
  "type": "CFG",
  "start_line": 1,
  "end_line": 484,
  "functions": [
    {
      "name": "create_graph_execution",
      "type": "function",
      "start_line": 134,
      "end_line": 173,
      "functions": [],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 134,
          "line": "async def create_graph_execution("
        },
        {
          "lineno": 135,
          "line": "    graph_id: str,"
        },
        {
          "lineno": 136,
          "line": "    graph_version: int,"
        },
        {
          "lineno": 137,
          "line": "    nodes_input: list[tuple[str, BlockInput]],"
        },
        {
          "lineno": 138,
          "line": "    user_id: str,"
        },
        {
          "lineno": 139,
          "line": ") -> tuple[str, list[ExecutionResult]]:"
        },
        {
          "lineno": 140,
          "line": "    \"\"\""
        },
        {
          "lineno": 141,
          "line": "    Create a new AgentGraphExecution record."
        },
        {
          "lineno": 142,
          "line": "    Returns:"
        },
        {
          "lineno": 143,
          "line": "        The id of the AgentGraphExecution and the list of ExecutionResult for each node."
        },
        {
          "lineno": 144,
          "line": "    \"\"\""
        },
        {
          "lineno": 145,
          "line": "    result = await AgentGraphExecution.prisma().create("
        },
        {
          "lineno": 146,
          "line": "        data={"
        },
        {
          "lineno": 147,
          "line": "            \"agentGraphId\": graph_id,"
        },
        {
          "lineno": 148,
          "line": "            \"agentGraphVersion\": graph_version,"
        },
        {
          "lineno": 149,
          "line": "            \"executionStatus\": ExecutionStatus.QUEUED,"
        },
        {
          "lineno": 150,
          "line": "            \"AgentNodeExecutions\": {"
        },
        {
          "lineno": 151,
          "line": "                \"create\": [  # type: ignore"
        },
        {
          "lineno": 152,
          "line": "                    {"
        },
        {
          "lineno": 153,
          "line": "                        \"agentNodeId\": node_id,"
        },
        {
          "lineno": 154,
          "line": "                        \"executionStatus\": ExecutionStatus.INCOMPLETE,"
        },
        {
          "lineno": 155,
          "line": "                        \"Input\": {"
        },
        {
          "lineno": 156,
          "line": "                            \"create\": ["
        },
        {
          "lineno": 157,
          "line": "                                {\"name\": name, \"data\": json.dumps(data)}"
        },
        {
          "lineno": 158,
          "line": "                                for name, data in node_input.items()"
        },
        {
          "lineno": 159,
          "line": "                            ]"
        },
        {
          "lineno": 160,
          "line": "                        },"
        },
        {
          "lineno": 161,
          "line": "                    }"
        },
        {
          "lineno": 162,
          "line": "                    for node_id, node_input in nodes_input"
        },
        {
          "lineno": 163,
          "line": "                ]"
        },
        {
          "lineno": 164,
          "line": "            },"
        },
        {
          "lineno": 165,
          "line": "            \"userId\": user_id,"
        },
        {
          "lineno": 166,
          "line": "        },"
        },
        {
          "lineno": 167,
          "line": "        include=GRAPH_EXECUTION_INCLUDE,"
        },
        {
          "lineno": 168,
          "line": "    )"
        },
        {
          "lineno": 169,
          "line": ""
        },
        {
          "lineno": 170,
          "line": "    return result.id, ["
        },
        {
          "lineno": 171,
          "line": "        ExecutionResult.from_db(execution)"
        },
        {
          "lineno": 172,
          "line": "        for execution in result.AgentNodeExecutions or []"
        },
        {
          "lineno": 173,
          "line": "    ]"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "start_line": 134,
          "end_line": 144,
          "label": "async def create_graph_execution(\n    graph_id: str,\n    graph_version: int,\n    nodes_input: list[tuple[str, BlockInput]],\n    user_id: str,\n) -> tuple[str, list[ExecutionResult]]:\n    \"\"\"\n    Create a new AgentGraphExecution record.\n    Returns:\n        The id of the AgentGraphExecution and the list of ExecutionResult for each node.\n    \"\"\"",
          "successors": [
            {
              "id": 2,
              "start_line": 145,
              "end_line": 168,
              "label": "result = await AgentGraphExecution.prisma().create(\n        data={\n            \"agentGraphId\": graph_id,\n            \"agentGraphVersion\": graph_version,\n            \"executionStatus\": ExecutionStatus.QUEUED,\n            \"AgentNodeExecutions\": {\n                \"create\": [  # type: ignore\n                    {\n                        \"agentNodeId\": node_id,\n                        \"executionStatus\": ExecutionStatus.INCOMPLETE,\n                        \"Input\": {\n                            \"create\": [\n                                {\"name\": name, \"data\": json.dumps(data)}\n                                for name, data in node_input.items()\n                            ]\n                        },\n                    }\n                    for node_id, node_input in nodes_input\n                ]\n            },\n            \"userId\": user_id,\n        },\n        include=GRAPH_EXECUTION_INCLUDE,\n    )",
              "successors": [
                {
                  "id": 3,
                  "start_line": 170,
                  "end_line": 173,
                  "label": "return result.id, [\n        ExecutionResult.from_db(execution)\n        for execution in result.AgentNodeExecutions or []\n    ]",
                  "successors": []
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "upsert_execution_input",
      "type": "function",
      "start_line": 176,
      "end_line": 241,
      "functions": [],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 176,
          "line": "async def upsert_execution_input("
        },
        {
          "lineno": 177,
          "line": "    node_id: str,"
        },
        {
          "lineno": 178,
          "line": "    graph_exec_id: str,"
        },
        {
          "lineno": 179,
          "line": "    input_name: str,"
        },
        {
          "lineno": 180,
          "line": "    input_data: Any,"
        },
        {
          "lineno": 181,
          "line": "    node_exec_id: str | None = None,"
        },
        {
          "lineno": 182,
          "line": ") -> tuple[str, BlockInput]:"
        },
        {
          "lineno": 183,
          "line": "    \"\"\""
        },
        {
          "lineno": 184,
          "line": "    Insert AgentNodeExecutionInputOutput record for as one of AgentNodeExecution.Input."
        },
        {
          "lineno": 185,
          "line": "    If there is no AgentNodeExecution that has no `input_name` as input, create new one."
        },
        {
          "lineno": 186,
          "line": ""
        },
        {
          "lineno": 187,
          "line": "    Args:"
        },
        {
          "lineno": 188,
          "line": "        node_id: The id of the AgentNode."
        },
        {
          "lineno": 189,
          "line": "        graph_exec_id: The id of the AgentGraphExecution."
        },
        {
          "lineno": 190,
          "line": "        input_name: The name of the input data."
        },
        {
          "lineno": 191,
          "line": "        input_data: The input data to be inserted."
        },
        {
          "lineno": 192,
          "line": "        node_exec_id: [Optional] The id of the AgentNodeExecution that has no `input_name` as input. If not provided, it will find the eligible incomplete AgentNodeExecution or create a new one."
        },
        {
          "lineno": 193,
          "line": ""
        },
        {
          "lineno": 194,
          "line": "    Returns:"
        },
        {
          "lineno": 195,
          "line": "        * The id of the created or existing AgentNodeExecution."
        },
        {
          "lineno": 196,
          "line": "        * Dict of node input data, key is the input name, value is the input data."
        },
        {
          "lineno": 197,
          "line": "    \"\"\""
        },
        {
          "lineno": 198,
          "line": "    existing_execution = await AgentNodeExecution.prisma().find_first("
        },
        {
          "lineno": 199,
          "line": "        where={  # type: ignore"
        },
        {
          "lineno": 200,
          "line": "            **({\"id\": node_exec_id} if node_exec_id else {}),"
        },
        {
          "lineno": 201,
          "line": "            \"agentNodeId\": node_id,"
        },
        {
          "lineno": 202,
          "line": "            \"agentGraphExecutionId\": graph_exec_id,"
        },
        {
          "lineno": 203,
          "line": "            \"executionStatus\": ExecutionStatus.INCOMPLETE,"
        },
        {
          "lineno": 204,
          "line": "            \"Input\": {\"every\": {\"name\": {\"not\": input_name}}},"
        },
        {
          "lineno": 205,
          "line": "        },"
        },
        {
          "lineno": 206,
          "line": "        order={\"addedTime\": \"asc\"},"
        },
        {
          "lineno": 207,
          "line": "        include={\"Input\": True},"
        },
        {
          "lineno": 208,
          "line": "    )"
        },
        {
          "lineno": 209,
          "line": "    json_input_data = json.dumps(input_data)"
        },
        {
          "lineno": 210,
          "line": ""
        },
        {
          "lineno": 211,
          "line": "    if existing_execution:"
        },
        {
          "lineno": 212,
          "line": "        await AgentNodeExecutionInputOutput.prisma().create("
        },
        {
          "lineno": 213,
          "line": "            data={"
        },
        {
          "lineno": 214,
          "line": "                \"name\": input_name,"
        },
        {
          "lineno": 215,
          "line": "                \"data\": json_input_data,"
        },
        {
          "lineno": 216,
          "line": "                \"referencedByInputExecId\": existing_execution.id,"
        },
        {
          "lineno": 217,
          "line": "            }"
        },
        {
          "lineno": 218,
          "line": "        )"
        },
        {
          "lineno": 219,
          "line": "        return existing_execution.id, {"
        },
        {
          "lineno": 220,
          "line": "            **{"
        },
        {
          "lineno": 221,
          "line": "                input_data.name: json.loads(input_data.data)"
        },
        {
          "lineno": 222,
          "line": "                for input_data in existing_execution.Input or []"
        },
        {
          "lineno": 223,
          "line": "            },"
        },
        {
          "lineno": 224,
          "line": "            input_name: input_data,"
        },
        {
          "lineno": 225,
          "line": "        }"
        },
        {
          "lineno": 226,
          "line": ""
        },
        {
          "lineno": 227,
          "line": "    elif not node_exec_id:"
        },
        {
          "lineno": 228,
          "line": "        result = await AgentNodeExecution.prisma().create("
        },
        {
          "lineno": 229,
          "line": "            data={"
        },
        {
          "lineno": 230,
          "line": "                \"agentNodeId\": node_id,"
        },
        {
          "lineno": 231,
          "line": "                \"agentGraphExecutionId\": graph_exec_id,"
        },
        {
          "lineno": 232,
          "line": "                \"executionStatus\": ExecutionStatus.INCOMPLETE,"
        },
        {
          "lineno": 233,
          "line": "                \"Input\": {\"create\": {\"name\": input_name, \"data\": json_input_data}},"
        },
        {
          "lineno": 234,
          "line": "            }"
        },
        {
          "lineno": 235,
          "line": "        )"
        },
        {
          "lineno": 236,
          "line": "        return result.id, {input_name: input_data}"
        },
        {
          "lineno": 237,
          "line": ""
        },
        {
          "lineno": 238,
          "line": "    else:"
        },
        {
          "lineno": 239,
          "line": "        raise ValueError("
        },
        {
          "lineno": 240,
          "line": "            f\"NodeExecution {node_exec_id} not found or already has input {input_name}.\""
        },
        {
          "lineno": 241,
          "line": "        )"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "start_line": 176,
          "end_line": 198,
          "label": "async def upsert_execution_input(\n    node_id: str,\n    graph_exec_id: str,\n    input_name: str,\n    input_data: Any,\n    node_exec_id: str | None = None,\n) -> tuple[str, BlockInput]:\n    \"\"\"\n    Insert AgentNodeExecutionInputOutput record for as one of AgentNodeExecution.Input.\n    If there is no AgentNodeExecution that has no `input_name` as input, create new one.\n\n    Args:\n        node_id: The id of the AgentNode.\n        graph_exec_id: The id of the AgentGraphExecution.\n        input_name: The name of the input data.\n        input_data: The input data to be inserted.\n        node_exec_id: [Optional] The id of the AgentNodeExecution that has no `input_name` as input. If not provided, it will find the eligible incomplete AgentNodeExecution or create a new one.\n\n    Returns:\n        * The id of the created or existing AgentNodeExecution.\n        * Dict of node input data, key is the input name, value is the input data.\n    \"\"\"\n    existing_execution = await AgentNodeExecution.prisma().find_first(",
          "successors": [
            {
              "id": 2,
              "start_line": 199,
              "end_line": 209,
              "label": " where={  # type: ignore\n            **({\"id\": node_exec_id} if node_exec_id else {}),\n            \"agentNodeId\": node_id,\n            \"agentGraphExecutionId\": graph_exec_id,\n            \"executionStatus\": ExecutionStatus.INCOMPLETE,\n            \"Input\": {\"every\": {\"name\": {\"not\": input_name}}},\n        },\n        order={\"addedTime\": \"asc\"},\n        include={\"Input\": True},\n    )\n    json_input_data = json.dumps(input_data)",
              "successors": [
                {
                  "id": 3,
                  "start_line": 211,
                  "end_line": 211,
                  "label": "if existing_execution:",
                  "successors": [
                    {
                      "id": 4,
                      "start_line": 212,
                      "end_line": 225,
                      "label": "await AgentNodeExecutionInputOutput.prisma().create(\n        data={\n            \"name\": input_name,\n            \"data\": json_input_data,\n            \"referencedByInputExecId\": existing_execution.id,\n        }\n    )\n    return existing_execution.id, {\n        **{\n            input_data.name: json.loads(input_data.data)\n            for input_data in existing_execution.Input or []\n        },\n        input_name: input_data,\n    }",
                      "successors": []
                    }
                  ]
                },
                {
                  "id": 5,
                  "start_line": 227,
                  "end_line": 227,
                  "label": "elif not node_exec_id:",
                  "successors": [
                    {
                      "id": 6,
                      "start_line": 228,
                      "end_line": 236,
                      "label": "result = await AgentNodeExecution.prisma().create(\n        data={\n            \"agentNodeId\": node_id,\n            \"agentGraphExecutionId\": graph_exec_id,\n            \"executionStatus\": ExecutionStatus.INCOMPLETE,\n            \"Input\": {\"create\": {\"name\": input_name, \"data\": json_input_data}},\n        }\n    )\n    return result.id, {input_name: input_data}",
                      "successors": []
                    }
                  ]
                },
                {
                  "id": 7,
                  "start_line": 238,
                  "end_line": 241,
                  "label": "else:\n    raise ValueError(\n        f\"NodeExecution {node_exec_id} not found or already has input {input_name}.\"\n    )",
                  "successors": []
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "upsert_execution_output",
      "type": "function",
      "start_line": 244,
      "end_line": 258,
      "functions": [],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 244,
          "line": "async def upsert_execution_output("
        },
        {
          "lineno": 245,
          "line": "    node_exec_id: str,"
        },
        {
          "lineno": 246,
          "line": "    output_name: str,"
        },
        {
          "lineno": 247,
          "line": "    output_data: Any,"
        },
        {
          "lineno": 248,
          "line": ") -> None:"
        },
        {
          "lineno": 249,
          "line": "    \"\"\""
        },
        {
          "lineno": 250,
          "line": "    Insert AgentNodeExecutionInputOutput record for as one of AgentNodeExecution.Output."
        },
        {
          "lineno": 251,
          "line": "    \"\"\""
        },
        {
          "lineno": 252,
          "line": "    await AgentNodeExecutionInputOutput.prisma().create("
        },
        {
          "lineno": 253,
          "line": "        data={"
        },
        {
          "lineno": 254,
          "line": "            \"name\": output_name,"
        },
        {
          "lineno": 255,
          "line": "            \"data\": json.dumps(output_data),"
        },
        {
          "lineno": 256,
          "line": "            \"referencedByOutputExecId\": node_exec_id,"
        },
        {
          "lineno": 257,
          "line": "        }"
        },
        {
          "lineno": 258,
          "line": "    )"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "start_line": 244,
          "end_line": 258,
          "label": "async def upsert_execution_output(\n    node_exec_id: str,\n    output_name: str,\n    output_data: Any,\n) -> None:\n    \"\"\"\n    Insert AgentNodeExecutionInputOutput record for as one of AgentNodeExecution.Output.\n    \"\"\"\n    await AgentNodeExecutionInputOutput.prisma().create(\n        data={\n            \"name\": output_name,\n            \"data\": json.dumps(output_data),\n            \"referencedByOutputExecId\": node_exec_id,\n        }\n    )",
          "successors": []
        }
      ]
    },
    {
      "name": "update_graph_execution_start_time",
      "type": "function",
      "start_line": 261,
      "end_line": 268,
      "functions": [],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 261,
          "line": "async def update_graph_execution_start_time(graph_exec_id: str):"
        },
        {
          "lineno": 262,
          "line": "    await AgentGraphExecution.prisma().update("
        },
        {
          "lineno": 263,
          "line": "        where={\"id\": graph_exec_id},"
        },
        {
          "lineno": 264,
          "line": "        data={"
        },
        {
          "lineno": 265,
          "line": "            \"executionStatus\": ExecutionStatus.RUNNING,"
        },
        {
          "lineno": 266,
          "line": "            \"startedAt\": datetime.now(tz=timezone.utc),"
        },
        {
          "lineno": 267,
          "line": "        },"
        },
        {
          "lineno": 268,
          "line": "    )"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "start_line": 261,
          "end_line": 268,
          "label": [
            "async def update_graph_execution_start_time(graph_exec_id: str):",
            "    await AgentGraphExecution.prisma().update(",
            "        where={\"id\": graph_exec_id},",
            "        data={",
            "            \"executionStatus\": ExecutionStatus.RUNNING,",
            "            \"startedAt\": datetime.now(tz=timezone.utc),",
            "        },",
            "    )"
          ],
          "successors": []
        }
      ]
    },
    {
      "name": "update_graph_execution_stats",
      "type": "function",
      "start_line": 271,
      "end_line": 286,
      "functions": [],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 271,
          "line": "async def update_graph_execution_stats("
        },
        {
          "lineno": 272,
          "line": "    graph_exec_id: str,"
        },
        {
          "lineno": 273,
          "line": "    stats: dict[str, Any],"
        },
        {
          "lineno": 274,
          "line": ") -> ExecutionResult:"
        },
        {
          "lineno": 275,
          "line": "    status = ExecutionStatus.FAILED if stats.get(\"error\") else ExecutionStatus.COMPLETED"
        },
        {
          "lineno": 276,
          "line": "    res = await AgentGraphExecution.prisma().update("
        },
        {
          "lineno": 277,
          "line": "        where={\"id\": graph_exec_id},"
        },
        {
          "lineno": 278,
          "line": "        data={"
        },
        {
          "lineno": 279,
          "line": "            \"executionStatus\": status,"
        },
        {
          "lineno": 280,
          "line": "            \"stats\": json.dumps(stats),"
        },
        {
          "lineno": 281,
          "line": "        },"
        },
        {
          "lineno": 282,
          "line": "    )"
        },
        {
          "lineno": 283,
          "line": "    if not res:"
        },
        {
          "lineno": 284,
          "line": "        raise ValueError(f\"Execution {graph_exec_id} not found.\")"
        },
        {
          "lineno": 285,
          "line": ""
        },
        {
          "lineno": 286,
          "line": "    return ExecutionResult.from_graph(res)"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "start_line": 271,
          "end_line": 275,
          "label": "async def update_graph_execution_stats(\n    graph_exec_id: str,\n    stats: dict[str, Any],\n) -> ExecutionResult:\n    status = ExecutionStatus.FAILED if stats.get(\"error\") else ExecutionStatus.COMPLETED",
          "successors": [
            {
              "id": 2,
              "start_line": 276,
              "end_line": 282,
              "label": "res = await AgentGraphExecution.prisma().update(\n    where={\"id\": graph_exec_id},\n    data={\n        \"executionStatus\": status,\n        \"stats\": json.dumps(stats),\n    },\n)",
              "successors": [
                {
                  "id": 3,
                  "start_line": 283,
                  "end_line": 284,
                  "label": "if not res:\n    raise ValueError(f\"Execution {graph_exec_id} not found.\")",
                  "successors": [
                    {
                      "id": 4,
                      "start_line": 286,
                      "end_line": 286,
                      "label": "return ExecutionResult.from_graph(res)",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "update_node_execution_stats",
      "type": "function",
      "start_line": 289,
      "end_line": 293,
      "functions": [],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 289,
          "line": "async def update_node_execution_stats(node_exec_id: str, stats: dict[str, Any]):"
        },
        {
          "lineno": 290,
          "line": "    await AgentNodeExecution.prisma().update("
        },
        {
          "lineno": 291,
          "line": "        where={\"id\": node_exec_id},"
        },
        {
          "lineno": 292,
          "line": "        data={\"stats\": json.dumps(stats)},"
        },
        {
          "lineno": 293,
          "line": "    )"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "start_line": 289,
          "end_line": 293,
          "label": "async def update_node_execution_stats(node_exec_id: str, stats: dict[str, Any]):\n    await AgentNodeExecution.prisma().update(\n        where={\"id\": node_exec_id},\n        data={\"stats\": json.dumps(stats)},\n    )",
          "successors": []
        }
      ]
    },
    {
      "name": "update_execution_status",
      "type": "function",
      "start_line": 296,
      "end_line": 324,
      "functions": [],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 296,
          "line": "async def update_execution_status("
        },
        {
          "lineno": 297,
          "line": "    node_exec_id: str,"
        },
        {
          "lineno": 298,
          "line": "    status: ExecutionStatus,"
        },
        {
          "lineno": 299,
          "line": "    execution_data: BlockInput | None = None,"
        },
        {
          "lineno": 300,
          "line": "    stats: dict[str, Any] | None = None,"
        },
        {
          "lineno": 301,
          "line": ") -> ExecutionResult:"
        },
        {
          "lineno": 302,
          "line": "    if status == ExecutionStatus.QUEUED and execution_data is None:"
        },
        {
          "lineno": 303,
          "line": "        raise ValueError(\"Execution data must be provided when queuing an execution.\")"
        },
        {
          "lineno": 304,
          "line": ""
        },
        {
          "lineno": 305,
          "line": "    now = datetime.now(tz=timezone.utc)"
        },
        {
          "lineno": 306,
          "line": "    data = {"
        },
        {
          "lineno": 307,
          "line": "        **({\"executionStatus\": status}),"
        },
        {
          "lineno": 308,
          "line": "        **({\"queuedTime\": now} if status == ExecutionStatus.QUEUED else {}),"
        },
        {
          "lineno": 309,
          "line": "        **({\"startedTime\": now} if status == ExecutionStatus.RUNNING else {}),"
        },
        {
          "lineno": 310,
          "line": "        **({\"endedTime\": now} if status == ExecutionStatus.FAILED else {}),"
        },
        {
          "lineno": 311,
          "line": "        **({\"endedTime\": now} if status == ExecutionStatus.COMPLETED else {}),"
        },
        {
          "lineno": 312,
          "line": "        **({\"executionData\": json.dumps(execution_data)} if execution_data else {}),"
        },
        {
          "lineno": 313,
          "line": "        **({\"stats\": json.dumps(stats)} if stats else {}),"
        },
        {
          "lineno": 314,
          "line": "    }"
        },
        {
          "lineno": 315,
          "line": ""
        },
        {
          "lineno": 316,
          "line": "    res = await AgentNodeExecution.prisma().update("
        },
        {
          "lineno": 317,
          "line": "        where={\"id\": node_exec_id},"
        },
        {
          "lineno": 318,
          "line": "        data=data,  # type: ignore"
        },
        {
          "lineno": 319,
          "line": "        include=EXECUTION_RESULT_INCLUDE,"
        },
        {
          "lineno": 320,
          "line": "    )"
        },
        {
          "lineno": 321,
          "line": "    if not res:"
        },
        {
          "lineno": 322,
          "line": "        raise ValueError(f\"Execution {node_exec_id} not found.\")"
        },
        {
          "lineno": 323,
          "line": ""
        },
        {
          "lineno": 324,
          "line": "    return ExecutionResult.from_db(res)"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "start_line": 296,
          "end_line": 301,
          "label": "async def update_execution_status(\n node_exec_id: str,\n status: ExecutionStatus,\n execution_data: BlockInput | None = None,\n stats: dict[str, Any] | None = None,\n) -> ExecutionResult:",
          "successors": [
            {
              "id": 2,
              "start_line": 302,
              "end_line": 303,
              "label": "if status == ExecutionStatus.QUEUED and execution_data is None:\n raise ValueError(\"Execution data must be provided when queuing an execution.\")",
              "successors": [
                {
                  "id": 3,
                  "start_line": 305,
                  "end_line": 314,
                  "label": "now = datetime.now(tz=timezone.utc)\ndata = {\n **({\"executionStatus\": status}),\n **({\"queuedTime\": now} if status == ExecutionStatus.QUEUED else {}),\n **({\"startedTime\": now} if status == ExecutionStatus.RUNNING else {}),\n **({\"endedTime\": now} if status == ExecutionStatus.FAILED else {}),\n **({\"endedTime\": now} if status == ExecutionStatus.COMPLETED else {}),\n **({\"executionData\": json.dumps(execution_data)} if execution_data else {}),\n **({\"stats\": json.dumps(stats)} if stats else {}),\n}",
                  "successors": [
                    {
                      "id": 4,
                      "start_line": 316,
                      "end_line": 320,
                      "label": "res = await AgentNodeExecution.prisma().update(\n where={\"id\": node_exec_id},\n data=data, # type: ignore\n include=EXECUTION_RESULT_INCLUDE,\n)",
                      "successors": [
                        {
                          "id": 5,
                          "start_line": 321,
                          "end_line": 322,
                          "label": "if not res:\n raise ValueError(f\"Execution {node_exec_id} not found.\")",
                          "successors": [
                            {
                              "id": 6,
                              "start_line": 324,
                              "end_line": 324,
                              "label": "return ExecutionResult.from_db(res)",
                              "successors": []
                            }
                          ]
                        },
                        {
                          "id": 6,
                          "start_line": 324,
                          "end_line": 324,
                          "label": "return ExecutionResult.from_db(res)",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "get_execution_results",
      "type": "function",
      "start_line": 327,
      "end_line": 337,
      "functions": [],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 327,
          "line": "async def get_execution_results(graph_exec_id: str) -> list[ExecutionResult]:"
        },
        {
          "lineno": 328,
          "line": "    executions = await AgentNodeExecution.prisma().find_many("
        },
        {
          "lineno": 329,
          "line": "        where={\"agentGraphExecutionId\": graph_exec_id},"
        },
        {
          "lineno": 330,
          "line": "        include=EXECUTION_RESULT_INCLUDE,"
        },
        {
          "lineno": 331,
          "line": "        order=["
        },
        {
          "lineno": 332,
          "line": "            {\"queuedTime\": \"asc\"},"
        },
        {
          "lineno": 333,
          "line": "            {\"addedTime\": \"asc\"},  # Fallback: Incomplete execs has no queuedTime."
        },
        {
          "lineno": 334,
          "line": "        ],"
        },
        {
          "lineno": 335,
          "line": "    )"
        },
        {
          "lineno": 336,
          "line": "    res = [ExecutionResult.from_db(execution) for execution in executions]"
        },
        {
          "lineno": 337,
          "line": "    return res"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "start_line": 327,
          "end_line": 335,
          "label": "async def get_execution_results(graph_exec_id: str) -> list[ExecutionResult]:\n    executions = await AgentNodeExecution.prisma().find_many(\n        where={\"agentGraphExecutionId\": graph_exec_id},\n        include=EXECUTION_RESULT_INCLUDE,\n        order=[\n            {\"queuedTime\": \"asc\"},\n            {\"addedTime\": \"asc\"},  # Fallback: Incomplete execs has no queuedTime.\n        ],\n    )",
          "successors": [
            {
              "id": 2,
              "start_line": 336,
              "end_line": 336,
              "label": "res = [ExecutionResult.from_db(execution) for execution in executions]",
              "successors": [
                {
                  "id": 3,
                  "start_line": 337,
                  "end_line": 337,
                  "label": "return res",
                  "successors": []
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "parse_execution_output",
      "type": "function",
      "start_line": 345,
      "end_line": 370,
      "functions": [],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 345,
          "line": "def parse_execution_output(output: BlockData, name: str) -> Any | None:"
        },
        {
          "lineno": 346,
          "line": "    # Allow extracting partial output data by name."
        },
        {
          "lineno": 347,
          "line": "    output_name, output_data = output"
        },
        {
          "lineno": 348,
          "line": ""
        },
        {
          "lineno": 349,
          "line": "    if name == output_name:"
        },
        {
          "lineno": 350,
          "line": "        return output_data"
        },
        {
          "lineno": 351,
          "line": ""
        },
        {
          "lineno": 352,
          "line": "    if name.startswith(f\"{output_name}{LIST_SPLIT}\"):"
        },
        {
          "lineno": 353,
          "line": "        index = int(name.split(LIST_SPLIT)[1])"
        },
        {
          "lineno": 354,
          "line": "        if not isinstance(output_data, list) or len(output_data) <= index:"
        },
        {
          "lineno": 355,
          "line": "            return None"
        },
        {
          "lineno": 356,
          "line": "        return output_data[int(name.split(LIST_SPLIT)[1])]"
        },
        {
          "lineno": 357,
          "line": ""
        },
        {
          "lineno": 358,
          "line": "    if name.startswith(f\"{output_name}{DICT_SPLIT}\"):"
        },
        {
          "lineno": 359,
          "line": "        index = name.split(DICT_SPLIT)[1]"
        },
        {
          "lineno": 360,
          "line": "        if not isinstance(output_data, dict) or index not in output_data:"
        },
        {
          "lineno": 361,
          "line": "            return None"
        },
        {
          "lineno": 362,
          "line": "        return output_data[index]"
        },
        {
          "lineno": 363,
          "line": ""
        },
        {
          "lineno": 364,
          "line": "    if name.startswith(f\"{output_name}{OBJC_SPLIT}\"):"
        },
        {
          "lineno": 365,
          "line": "        index = name.split(OBJC_SPLIT)[1]"
        },
        {
          "lineno": 366,
          "line": "        if isinstance(output_data, object) and hasattr(output_data, index):"
        },
        {
          "lineno": 367,
          "line": "            return getattr(output_data, index)"
        },
        {
          "lineno": 368,
          "line": "        return None"
        },
        {
          "lineno": 369,
          "line": ""
        },
        {
          "lineno": 370,
          "line": "    return None"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "start_line": 345,
          "end_line": 347,
          "label": "def parse_execution_output(output: BlockData, name: str) -> Any | None:\n    # Allow extracting partial output data by name.\n    output_name, output_data = output",
          "successors": [
            {
              "id": 2,
              "start_line": 349,
              "end_line": 350,
              "label": "if name == output_name:\n        return output_data",
              "successors": [
                {
                  "id": 3,
                  "start_line": 352,
                  "end_line": 356,
                  "label": "if name.startswith(f\"{output_name}{LIST_SPLIT}\"):\n        index = int(name.split(LIST_SPLIT)[1])\n        if not isinstance(output_data, list) or len(output_data) <= index:\n            return None\n        return output_data[int(name.split(LIST_SPLIT)[1])]",
                  "successors": [
                    {
                      "id": 4,
                      "start_line": 358,
                      "end_line": 362,
                      "label": "if name.startswith(f\"{output_name}{DICT_SPLIT}\"):\n        index = name.split(DICT_SPLIT)[1]\n        if not isinstance(output_data, dict) or index not in output_data:\n            return None\n        return output_data[index]",
                      "successors": [
                        {
                          "id": 5,
                          "start_line": 364,
                          "end_line": 368,
                          "label": "if name.startswith(f\"{output_name}{OBJC_SPLIT}\"):\n        index = name.split(OBJC_SPLIT)[1]\n        if isinstance(output_data, object) and hasattr(output_data, index):\n            return getattr(output_data, index)\n        return None",
                          "successors": [
                            {
                              "id": 6,
                              "start_line": 370,
                              "end_line": 370,
                              "label": "return None",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "merge_execution_input",
      "type": "function",
      "start_line": 373,
      "end_line": 415,
      "functions": [],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 373,
          "line": "def merge_execution_input(data: BlockInput) -> BlockInput:"
        },
        {
          "lineno": 374,
          "line": "    \"\"\""
        },
        {
          "lineno": 375,
          "line": "    Merge all dynamic input pins which described by the following pattern:"
        },
        {
          "lineno": 376,
          "line": "    - <input_name>_$_<index> for list input."
        },
        {
          "lineno": 377,
          "line": "    - <input_name>_#_<index> for dict input."
        },
        {
          "lineno": 378,
          "line": "    - <input_name>_@_<index> for object input."
        },
        {
          "lineno": 379,
          "line": "    This function will construct pins with the same name into a single list/dict/object."
        },
        {
          "lineno": 380,
          "line": "    \"\"\""
        },
        {
          "lineno": 381,
          "line": ""
        },
        {
          "lineno": 382,
          "line": "    # Merge all input with <input_name>_$_<index> into a single list."
        },
        {
          "lineno": 383,
          "line": "    items = list(data.items())"
        },
        {
          "lineno": 384,
          "line": ""
        },
        {
          "lineno": 385,
          "line": "    for key, value in items:"
        },
        {
          "lineno": 386,
          "line": "        if LIST_SPLIT not in key:"
        },
        {
          "lineno": 387,
          "line": "            continue"
        },
        {
          "lineno": 388,
          "line": "        name, index = key.split(LIST_SPLIT)"
        },
        {
          "lineno": 389,
          "line": "        if not index.isdigit():"
        },
        {
          "lineno": 390,
          "line": "            raise ValueError(f\"Invalid key: {key}, #{index} index must be an integer.\")"
        },
        {
          "lineno": 391,
          "line": ""
        },
        {
          "lineno": 392,
          "line": "        data[name] = data.get(name, [])"
        },
        {
          "lineno": 393,
          "line": "        if int(index) >= len(data[name]):"
        },
        {
          "lineno": 394,
          "line": "            # Pad list with empty string on missing indices."
        },
        {
          "lineno": 395,
          "line": "            data[name].extend([\"\"] * (int(index) - len(data[name]) + 1))"
        },
        {
          "lineno": 396,
          "line": "        data[name][int(index)] = value"
        },
        {
          "lineno": 397,
          "line": ""
        },
        {
          "lineno": 398,
          "line": "    # Merge all input with <input_name>_#_<index> into a single dict."
        },
        {
          "lineno": 399,
          "line": "    for key, value in items:"
        },
        {
          "lineno": 400,
          "line": "        if DICT_SPLIT not in key:"
        },
        {
          "lineno": 401,
          "line": "            continue"
        },
        {
          "lineno": 402,
          "line": "        name, index = key.split(DICT_SPLIT)"
        },
        {
          "lineno": 403,
          "line": "        data[name] = data.get(name, {})"
        },
        {
          "lineno": 404,
          "line": "        data[name][index] = value"
        },
        {
          "lineno": 405,
          "line": ""
        },
        {
          "lineno": 406,
          "line": "    # Merge all input with <input_name>_@_<index> into a single object."
        },
        {
          "lineno": 407,
          "line": "    for key, value in items:"
        },
        {
          "lineno": 408,
          "line": "        if OBJC_SPLIT not in key:"
        },
        {
          "lineno": 409,
          "line": "            continue"
        },
        {
          "lineno": 410,
          "line": "        name, index = key.split(OBJC_SPLIT)"
        },
        {
          "lineno": 411,
          "line": "        if name not in data or not isinstance(data[name], object):"
        },
        {
          "lineno": 412,
          "line": "            data[name] = mock.MockObject()"
        },
        {
          "lineno": 413,
          "line": "        setattr(data[name], index, value)"
        },
        {
          "lineno": 414,
          "line": ""
        },
        {
          "lineno": 415,
          "line": "    return data"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "start_line": 373,
          "end_line": 383,
          "label": [
            "def merge_execution_input(data: BlockInput) -> BlockInput:",
            "    \"\"\"",
            "    Merge all dynamic input pins which described by the following pattern:",
            "    - <input_name>_$_<index> for list input.",
            "    - <input_name>_#_<index> for dict input.",
            "    - <input_name>_@_<index> for object input.",
            "    This function will construct pins with the same name into a single list/dict/object.",
            "    \"\"\"",
            "",
            "    # Merge all input with <input_name>_$_<index> into a single list.",
            "    items = list(data.items())"
          ],
          "successors": [
            {
              "id": 2,
              "start_line": 385,
              "end_line": 385,
              "label": [
                "for key, value in items:"
              ],
              "successors": [
                {
                  "id": 3,
                  "start_line": 386,
                  "end_line": 390,
                  "label": [
                    "if LIST_SPLIT not in key:",
                    "    continue",
                    "name, index = key.split(LIST_SPLIT)",
                    "if not index.isdigit():",
                    "    raise ValueError(f\"Invalid key: {key}, #{index} index must be an integer.\")"
                  ],
                  "successors": [
                    {
                      "id": 4,
                      "start_line": 392,
                      "end_line": 396,
                      "label": [
                        "data[name] = data.get(name, [])",
                        "if int(index) >= len(data[name]):",
                        "    # Pad list with empty string on missing indices.",
                        "    data[name].extend([\"\"] * (int(index) - len(data[name]) + 1))",
                        "data[name][int(index)] = value"
                      ],
                      "successors": [
                        {
                          "id": 5,
                          "start_line": 399,
                          "end_line": 399,
                          "label": [
                            "for key, value in items:"
                          ],
                          "successors": [
                            {
                              "id": 6,
                              "start_line": 400,
                              "end_line": 404,
                              "label": [
                                "if DICT_SPLIT not in key:",
                                "    continue",
                                "name, index = key.split(DICT_SPLIT)",
                                "data[name] = data.get(name, {})",
                                "data[name][index] = value"
                              ],
                              "successors": [
                                {
                                  "id": 7,
                                  "start_line": 407,
                                  "end_line": 407,
                                  "label": [
                                    "for key, value in items:"
                                  ],
                                  "successors": [
                                    {
                                      "id": 8,
                                      "start_line": 408,
                                      "end_line": 413,
                                      "label": [
                                        "if OBJC_SPLIT not in key:",
                                        "    continue",
                                        "name, index = key.split(OBJC_SPLIT)",
                                        "if name not in data or not isinstance(data[name], object):",
                                        "    data[name] = mock.MockObject()",
                                        "setattr(data[name], index, value)"
                                      ],
                                      "successors": [
                                        {
                                          "id": 9,
                                          "start_line": 415,
                                          "end_line": 415,
                                          "label": [
                                            "return data"
                                          ],
                                          "successors": []
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "get_latest_execution",
      "type": "function",
      "start_line": 418,
      "end_line": 431,
      "functions": [],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 418,
          "line": "async def get_latest_execution(node_id: str, graph_eid: str) -> ExecutionResult | None:"
        },
        {
          "lineno": 419,
          "line": "    execution = await AgentNodeExecution.prisma().find_first("
        },
        {
          "lineno": 420,
          "line": "        where={"
        },
        {
          "lineno": 421,
          "line": "            \"agentNodeId\": node_id,"
        },
        {
          "lineno": 422,
          "line": "            \"agentGraphExecutionId\": graph_eid,"
        },
        {
          "lineno": 423,
          "line": "            \"executionStatus\": {\"not\": ExecutionStatus.INCOMPLETE},"
        },
        {
          "lineno": 424,
          "line": "            \"executionData\": {\"not\": None},  # type: ignore"
        },
        {
          "lineno": 425,
          "line": "        },"
        },
        {
          "lineno": 426,
          "line": "        order={\"queuedTime\": \"desc\"},"
        },
        {
          "lineno": 427,
          "line": "        include=EXECUTION_RESULT_INCLUDE,"
        },
        {
          "lineno": 428,
          "line": "    )"
        },
        {
          "lineno": 429,
          "line": "    if not execution:"
        },
        {
          "lineno": 430,
          "line": "        return None"
        },
        {
          "lineno": 431,
          "line": "    return ExecutionResult.from_db(execution)"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "start_line": 418,
          "end_line": 428,
          "label": "async def get_latest_execution(node_id: str, graph_eid: str) -> ExecutionResult | None:\n    execution = await AgentNodeExecution.prisma().find_first(\n        where={\n            \"agentNodeId\": node_id,\n            \"agentGraphExecutionId\": graph_eid,\n            \"executionStatus\": {\"not\": ExecutionStatus.INCOMPLETE},\n            \"executionData\": {\"not\": None},  # type: ignore\n        },\n        order={\"queuedTime\": \"desc\"},\n        include=EXECUTION_RESULT_INCLUDE,\n    )",
          "successors": [
            {
              "id": 2,
              "start_line": 429,
              "end_line": 430,
              "label": "if not execution:\n    return None",
              "successors": [
                {
                  "id": 3,
                  "start_line": 431,
                  "end_line": 431,
                  "label": "return ExecutionResult.from_db(execution)",
                  "successors": []
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "get_incomplete_executions",
      "type": "function",
      "start_line": 434,
      "end_line": 445,
      "functions": [],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 434,
          "line": "async def get_incomplete_executions("
        },
        {
          "lineno": 435,
          "line": "    node_id: str, graph_eid: str"
        },
        {
          "lineno": 436,
          "line": ") -> list[ExecutionResult]:"
        },
        {
          "lineno": 437,
          "line": "    executions = await AgentNodeExecution.prisma().find_many("
        },
        {
          "lineno": 438,
          "line": "        where={"
        },
        {
          "lineno": 439,
          "line": "            \"agentNodeId\": node_id,"
        },
        {
          "lineno": 440,
          "line": "            \"agentGraphExecutionId\": graph_eid,"
        },
        {
          "lineno": 441,
          "line": "            \"executionStatus\": ExecutionStatus.INCOMPLETE,"
        },
        {
          "lineno": 442,
          "line": "        },"
        },
        {
          "lineno": 443,
          "line": "        include=EXECUTION_RESULT_INCLUDE,"
        },
        {
          "lineno": 444,
          "line": "    )"
        },
        {
          "lineno": 445,
          "line": "    return [ExecutionResult.from_db(execution) for execution in executions]"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "start_line": 434,
          "end_line": 444,
          "label": "async def get_incomplete_executions(\n    node_id: str, graph_eid: str\n) -> list[ExecutionResult]:\n    executions = await AgentNodeExecution.prisma().find_many(\n        where={\n            \"agentNodeId\": node_id,\n            \"agentGraphExecutionId\": graph_eid,\n            \"executionStatus\": ExecutionStatus.INCOMPLETE,\n        },\n        include=EXECUTION_RESULT_INCLUDE,\n    )",
          "successors": [
            {
              "id": 2,
              "start_line": 445,
              "end_line": 445,
              "label": "return [ExecutionResult.from_db(execution) for execution in executions]",
              "successors": []
            }
          ]
        }
      ]
    }
  ],
  "classes": [
    {
      "name": "GraphExecutionEntry",
      "type": "class",
      "start_line": 21,
      "end_line": 25,
      "functions": [],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 21,
          "line": "class GraphExecutionEntry(BaseModel):"
        },
        {
          "lineno": 22,
          "line": "    user_id: str"
        },
        {
          "lineno": 23,
          "line": "    graph_exec_id: str"
        },
        {
          "lineno": 24,
          "line": "    graph_id: str"
        },
        {
          "lineno": 25,
          "line": "    start_node_execs: list[\"NodeExecutionEntry\"]"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "start_line": 21,
          "end_line": 25,
          "label": "class GraphExecutionEntry(BaseModel):\n    user_id: str\n    graph_exec_id: str\n    graph_id: str\n    start_node_execs: list[\"NodeExecutionEntry\"]",
          "successors": []
        }
      ]
    },
    {
      "name": "NodeExecutionEntry",
      "type": "class",
      "start_line": 28,
      "end_line": 34,
      "functions": [],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 28,
          "line": "class NodeExecutionEntry(BaseModel):"
        },
        {
          "lineno": 29,
          "line": "    user_id: str"
        },
        {
          "lineno": 30,
          "line": "    graph_exec_id: str"
        },
        {
          "lineno": 31,
          "line": "    graph_id: str"
        },
        {
          "lineno": 32,
          "line": "    node_exec_id: str"
        },
        {
          "lineno": 33,
          "line": "    node_id: str"
        },
        {
          "lineno": 34,
          "line": "    data: BlockInput"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "start_line": 28,
          "end_line": 34,
          "label": "class NodeExecutionEntry(BaseModel):\n    user_id: str\n    graph_exec_id: str\n    graph_id: str\n    node_exec_id: str\n    node_id: str\n    data: BlockInput",
          "successors": []
        }
      ]
    },
    {
      "name": "ExecutionQueue",
      "type": "class",
      "start_line": 42,
      "end_line": 59,
      "functions": [
        {
          "name": "__init__",
          "type": "function",
          "start_line": 48,
          "end_line": 49,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 48,
              "line": "    def __init__(self):"
            },
            {
              "lineno": 49,
              "line": "        self.queue = Manager().Queue()"
            }
          ],
          "blocks": []
        },
        {
          "name": "add",
          "type": "function",
          "start_line": 51,
          "end_line": 53,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 51,
              "line": "    def add(self, execution: T) -> T:"
            },
            {
              "lineno": 52,
              "line": "        self.queue.put(execution)"
            },
            {
              "lineno": 53,
              "line": "        return execution"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 51,
              "end_line": 52,
              "label": "    def add(self, execution: T) -> T:\n        self.queue.put(execution)",
              "successors": [
                {
                  "id": 2,
                  "start_line": 53,
                  "end_line": 53,
                  "label": "        return execution",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "get",
          "type": "function",
          "start_line": 55,
          "end_line": 56,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 55,
              "line": "    def get(self) -> T:"
            },
            {
              "lineno": 56,
              "line": "        return self.queue.get()"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 55,
              "end_line": 56,
              "label": " def get(self) -> T:\n return self.queue.get()",
              "successors": []
            }
          ]
        },
        {
          "name": "empty",
          "type": "function",
          "start_line": 58,
          "end_line": 59,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 58,
              "line": "    def empty(self) -> bool:"
            },
            {
              "lineno": 59,
              "line": "        return self.queue.empty()"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 58,
              "end_line": 59,
              "label": "    def empty(self) -> bool:\n        return self.queue.empty()",
              "successors": []
            }
          ]
        }
      ],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 42,
          "line": "class ExecutionQueue(Generic[T]):"
        },
        {
          "lineno": 43,
          "line": "    \"\"\""
        },
        {
          "lineno": 44,
          "line": "    Queue for managing the execution of agents."
        },
        {
          "lineno": 45,
          "line": "    This will be shared between different processes"
        },
        {
          "lineno": 46,
          "line": "    \"\"\""
        },
        {
          "lineno": 47,
          "line": ""
        },
        {
          "lineno": 50,
          "line": ""
        },
        {
          "lineno": 54,
          "line": ""
        },
        {
          "lineno": 57,
          "line": ""
        }
      ],
      "blocks": [
        {
          "id": 1,
          "start_line": 42,
          "end_line": 46,
          "label": "class ExecutionQueue(Generic[T]):\n    \"\"\"\n    Queue for managing the execution of agents.\n    This will be shared between different processes\n    \"\"\"",
          "successors": []
        }
      ]
    },
    {
      "name": "ExecutionResult",
      "type": "class",
      "start_line": 62,
      "end_line": 128,
      "functions": [
        {
          "name": "from_graph",
          "type": "function",
          "start_line": 78,
          "end_line": 95,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 78,
              "line": "    def from_graph(graph: AgentGraphExecution):"
            },
            {
              "lineno": 79,
              "line": "        return ExecutionResult("
            },
            {
              "lineno": 80,
              "line": "            graph_id=graph.agentGraphId,"
            },
            {
              "lineno": 81,
              "line": "            graph_version=graph.agentGraphVersion,"
            },
            {
              "lineno": 82,
              "line": "            graph_exec_id=graph.id,"
            },
            {
              "lineno": 83,
              "line": "            node_exec_id=\"\","
            },
            {
              "lineno": 84,
              "line": "            node_id=\"\","
            },
            {
              "lineno": 85,
              "line": "            block_id=\"\","
            },
            {
              "lineno": 86,
              "line": "            status=graph.executionStatus,"
            },
            {
              "lineno": 87,
              "line": "            # TODO: Populate input_data & output_data from AgentNodeExecutions"
            },
            {
              "lineno": 88,
              "line": "            #       Input & Output comes AgentInputBlock & AgentOutputBlock."
            },
            {
              "lineno": 89,
              "line": "            input_data={},"
            },
            {
              "lineno": 90,
              "line": "            output_data={},"
            },
            {
              "lineno": 91,
              "line": "            add_time=graph.createdAt,"
            },
            {
              "lineno": 92,
              "line": "            queue_time=graph.createdAt,"
            },
            {
              "lineno": 93,
              "line": "            start_time=graph.startedAt,"
            },
            {
              "lineno": 94,
              "line": "            end_time=graph.updatedAt,"
            },
            {
              "lineno": 95,
              "line": "        )"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 78,
              "end_line": 78,
              "label": "    def from_graph(graph: AgentGraphExecution):",
              "successors": [
                {
                  "id": 2,
                  "start_line": 79,
                  "end_line": 95,
                  "label": "        return ExecutionResult(\n            graph_id=graph.agentGraphId,\n            graph_version=graph.agentGraphVersion,\n            graph_exec_id=graph.id,\n            node_exec_id=\"\",\n            node_id=\"\",\n            block_id=\"\",\n            status=graph.executionStatus,\n            # TODO: Populate input_data & output_data from AgentNodeExecutions\n            #       Input & Output comes AgentInputBlock & AgentOutputBlock.\n            input_data={},\n            output_data={},\n            add_time=graph.createdAt,\n            queue_time=graph.createdAt,\n            start_time=graph.startedAt,\n            end_time=graph.updatedAt,\n        )",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "from_db",
          "type": "function",
          "start_line": 98,
          "end_line": 128,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 98,
              "line": "    def from_db(execution: AgentNodeExecution):"
            },
            {
              "lineno": 99,
              "line": "        if execution.executionData:"
            },
            {
              "lineno": 100,
              "line": "            # Execution that has been queued for execution will persist its data."
            },
            {
              "lineno": 101,
              "line": "            input_data = json.loads(execution.executionData, target_type=dict[str, Any])"
            },
            {
              "lineno": 102,
              "line": "        else:"
            },
            {
              "lineno": 103,
              "line": "            # For incomplete execution, executionData will not be yet available."
            },
            {
              "lineno": 104,
              "line": "            input_data: BlockInput = defaultdict()"
            },
            {
              "lineno": 105,
              "line": "            for data in execution.Input or []:"
            },
            {
              "lineno": 106,
              "line": "                input_data[data.name] = json.loads(data.data)"
            },
            {
              "lineno": 107,
              "line": ""
            },
            {
              "lineno": 108,
              "line": "        output_data: CompletedBlockOutput = defaultdict(list)"
            },
            {
              "lineno": 109,
              "line": "        for data in execution.Output or []:"
            },
            {
              "lineno": 110,
              "line": "            output_data[data.name].append(json.loads(data.data))"
            },
            {
              "lineno": 111,
              "line": ""
            },
            {
              "lineno": 112,
              "line": "        graph_execution: AgentGraphExecution | None = execution.AgentGraphExecution"
            },
            {
              "lineno": 113,
              "line": ""
            },
            {
              "lineno": 114,
              "line": "        return ExecutionResult("
            },
            {
              "lineno": 115,
              "line": "            graph_id=graph_execution.agentGraphId if graph_execution else \"\","
            },
            {
              "lineno": 116,
              "line": "            graph_version=graph_execution.agentGraphVersion if graph_execution else 0,"
            },
            {
              "lineno": 117,
              "line": "            graph_exec_id=execution.agentGraphExecutionId,"
            },
            {
              "lineno": 118,
              "line": "            block_id=execution.AgentNode.agentBlockId if execution.AgentNode else \"\","
            },
            {
              "lineno": 119,
              "line": "            node_exec_id=execution.id,"
            },
            {
              "lineno": 120,
              "line": "            node_id=execution.agentNodeId,"
            },
            {
              "lineno": 121,
              "line": "            status=execution.executionStatus,"
            },
            {
              "lineno": 122,
              "line": "            input_data=input_data,"
            },
            {
              "lineno": 123,
              "line": "            output_data=output_data,"
            },
            {
              "lineno": 124,
              "line": "            add_time=execution.addedTime,"
            },
            {
              "lineno": 125,
              "line": "            queue_time=execution.queuedTime,"
            },
            {
              "lineno": 126,
              "line": "            start_time=execution.startedTime,"
            },
            {
              "lineno": 127,
              "line": "            end_time=execution.endedTime,"
            },
            {
              "lineno": 128,
              "line": "        )"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 98,
              "end_line": 98,
              "label": "    def from_db(execution: AgentNodeExecution):",
              "successors": [
                {
                  "id": 2,
                  "start_line": 99,
                  "end_line": 99,
                  "label": "        if execution.executionData:",
                  "successors": [
                    {
                      "id": 3,
                      "start_line": 100,
                      "end_line": 101,
                      "label": "            # Execution that has been queued for execution will persist its data.\n            input_data = json.loads(execution.executionData, target_type=dict[str, Any])",
                      "successors": [
                        {
                          "id": 6,
                          "start_line": 108,
                          "end_line": 110,
                          "label": "        output_data: CompletedBlockOutput = defaultdict(list)\n        for data in execution.Output or []:\n            output_data[data.name].append(json.loads(data.data))",
                          "successors": [
                            {
                              "id": 7,
                              "start_line": 112,
                              "end_line": 112,
                              "label": "        graph_execution: AgentGraphExecution | None = execution.AgentGraphExecution",
                              "successors": [
                                {
                                  "id": 8,
                                  "start_line": 114,
                                  "end_line": 128,
                                  "label": "        return ExecutionResult(\n            graph_id=graph_execution.agentGraphId if graph_execution else \"\",\n            graph_version=graph_execution.agentGraphVersion if graph_execution else 0,\n            graph_exec_id=execution.agentGraphExecutionId,\n            block_id=execution.AgentNode.agentBlockId if execution.AgentNode else \"\",\n            node_exec_id=execution.id,\n            node_id=execution.agentNodeId,\n            status=execution.executionStatus,\n            input_data=input_data,\n            output_data=output_data,\n            add_time=execution.addedTime,\n            queue_time=execution.queuedTime,\n            start_time=execution.startedTime,\n            end_time=execution.endedTime,\n        )",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "id": 4,
                      "start_line": 102,
                      "end_line": 104,
                      "label": "        else:\n            # For incomplete execution, executionData will not be yet available.\n            input_data: BlockInput = defaultdict()",
                      "successors": [
                        {
                          "id": 5,
                          "start_line": 105,
                          "end_line": 106,
                          "label": "            for data in execution.Input or []:\n                input_data[data.name] = json.loads(data.data)",
                          "successors": [
                            {
                              "id": 6,
                              "start_line": 108,
                              "end_line": 110,
                              "label": "        output_data: CompletedBlockOutput = defaultdict(list)\n        for data in execution.Output or []:\n            output_data[data.name].append(json.loads(data.data))",
                              "successors": [
                                {
                                  "id": 7,
                                  "start_line": 112,
                                  "end_line": 112,
                                  "label": "        graph_execution: AgentGraphExecution | None = execution.AgentGraphExecution",
                                  "successors": [
                                    {
                                      "id": 8,
                                      "start_line": 114,
                                      "end_line": 128,
                                      "label": "        return ExecutionResult(\n            graph_id=graph_execution.agentGraphId if graph_execution else \"\",\n            graph_version=graph_execution.agentGraphVersion if graph_execution else 0,\n            graph_exec_id=execution.agentGraphExecutionId,\n            block_id=execution.AgentNode.agentBlockId if execution.AgentNode else \"\",\n            node_exec_id=execution.id,\n            node_id=execution.agentNodeId,\n            status=execution.executionStatus,\n            input_data=input_data,\n            output_data=output_data,\n            add_time=execution.addedTime,\n            queue_time=execution.queuedTime,\n            start_time=execution.startedTime,\n            end_time=execution.endedTime,\n        )",
                                      "successors": []
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 62,
          "line": "class ExecutionResult(BaseModel):"
        },
        {
          "lineno": 63,
          "line": "    graph_id: str"
        },
        {
          "lineno": 64,
          "line": "    graph_version: int"
        },
        {
          "lineno": 65,
          "line": "    graph_exec_id: str"
        },
        {
          "lineno": 66,
          "line": "    node_exec_id: str"
        },
        {
          "lineno": 67,
          "line": "    node_id: str"
        },
        {
          "lineno": 68,
          "line": "    block_id: str"
        },
        {
          "lineno": 69,
          "line": "    status: ExecutionStatus"
        },
        {
          "lineno": 70,
          "line": "    input_data: BlockInput"
        },
        {
          "lineno": 71,
          "line": "    output_data: CompletedBlockOutput"
        },
        {
          "lineno": 72,
          "line": "    add_time: datetime"
        },
        {
          "lineno": 73,
          "line": "    queue_time: datetime | None"
        },
        {
          "lineno": 74,
          "line": "    start_time: datetime | None"
        },
        {
          "lineno": 75,
          "line": "    end_time: datetime | None"
        },
        {
          "lineno": 76,
          "line": ""
        },
        {
          "lineno": 77,
          "line": "    @staticmethod"
        },
        {
          "lineno": 96,
          "line": ""
        },
        {
          "lineno": 97,
          "line": "    @staticmethod"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "start_line": 62,
          "end_line": 76,
          "label": "class ExecutionResult(BaseModel):\n    graph_id: str\n    graph_version: int\n    graph_exec_id: str\n    node_exec_id: str\n    node_id: str\n    block_id: str\n    status: ExecutionStatus\n    input_data: BlockInput\n    output_data: CompletedBlockOutput\n    add_time: datetime\n    queue_time: datetime | None\n    start_time: datetime | None\n    end_time: datetime | None",
          "successors": [
            {
              "id": 2,
              "start_line": 77,
              "end_line": 77,
              "label": "@staticmethod",
              "successors": []
            },
            {
              "id": 3,
              "start_line": 97,
              "end_line": 97,
              "label": "@staticmethod",
              "successors": []
            }
          ]
        }
      ]
    },
    {
      "name": "RedisExecutionEventBus",
      "type": "class",
      "start_line": 453,
      "end_line": 467,
      "functions": [
        {
          "name": "event_bus_name",
          "type": "function",
          "start_line": 457,
          "end_line": 458,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 457,
              "line": "    def event_bus_name(self) -> str:"
            },
            {
              "lineno": 458,
              "line": "        return config.execution_event_bus_name"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 457,
              "end_line": 458,
              "label": "    def event_bus_name(self) -> str:\n        return config.execution_event_bus_name",
              "successors": []
            }
          ]
        },
        {
          "name": "publish",
          "type": "function",
          "start_line": 460,
          "end_line": 461,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 460,
              "line": "    def publish(self, res: ExecutionResult):"
            },
            {
              "lineno": 461,
              "line": "        self.publish_event(res, f\"{res.graph_id}/{res.graph_exec_id}\")"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 460,
              "end_line": 461,
              "label": "    def publish(self, res: ExecutionResult):\n        self.publish_event(res, f\"{res.graph_id}/{res.graph_exec_id}\")",
              "successors": []
            }
          ]
        },
        {
          "name": "listen",
          "type": "function",
          "start_line": 463,
          "end_line": 467,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 463,
              "line": "    def listen("
            },
            {
              "lineno": 464,
              "line": "        self, graph_id: str = \"*\", graph_exec_id: str = \"*\""
            },
            {
              "lineno": 465,
              "line": "    ) -> Generator[ExecutionResult, None, None]:"
            },
            {
              "lineno": 466,
              "line": "        for execution_result in self.listen_events(f\"{graph_id}/{graph_exec_id}\"):"
            },
            {
              "lineno": 467,
              "line": "            yield execution_result"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 463,
              "end_line": 465,
              "label": "    def listen(\n        self, graph_id: str = \"*\", graph_exec_id: str = \"*\"\n    ) -> Generator[ExecutionResult, None, None]:",
              "successors": [
                {
                  "id": 2,
                  "start_line": 466,
                  "end_line": 467,
                  "label": "        for execution_result in self.listen_events(f\"{graph_id}/{graph_exec_id}\"):\n            yield execution_result",
                  "successors": []
                }
              ]
            }
          ]
        }
      ],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 453,
          "line": "class RedisExecutionEventBus(RedisEventBus[ExecutionResult]):"
        },
        {
          "lineno": 454,
          "line": "    Model = ExecutionResult"
        },
        {
          "lineno": 455,
          "line": ""
        },
        {
          "lineno": 456,
          "line": "    @property"
        },
        {
          "lineno": 459,
          "line": ""
        },
        {
          "lineno": 462,
          "line": ""
        }
      ],
      "blocks": [
        {
          "id": 1,
          "start_line": 453,
          "end_line": 454,
          "label": "class RedisExecutionEventBus(RedisEventBus[ExecutionResult]):\n    Model = ExecutionResult",
          "successors": []
        },
        {
          "id": 2,
          "start_line": 456,
          "end_line": 456,
          "label": "    @property",
          "successors": []
        }
      ]
    },
    {
      "name": "AsyncRedisExecutionEventBus",
      "type": "class",
      "start_line": 470,
      "end_line": 484,
      "functions": [
        {
          "name": "event_bus_name",
          "type": "function",
          "start_line": 474,
          "end_line": 475,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 474,
              "line": "    def event_bus_name(self) -> str:"
            },
            {
              "lineno": 475,
              "line": "        return config.execution_event_bus_name"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 474,
              "end_line": 475,
              "label": "    def event_bus_name(self) -> str:\n        return config.execution_event_bus_name",
              "successors": []
            }
          ]
        },
        {
          "name": "publish",
          "type": "function",
          "start_line": 477,
          "end_line": 478,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 477,
              "line": "    async def publish(self, res: ExecutionResult):"
            },
            {
              "lineno": 478,
              "line": "        await self.publish_event(res, f\"{res.graph_id}/{res.graph_exec_id}\")"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 477,
              "end_line": 478,
              "label": "    async def publish(self, res: ExecutionResult):\n        await self.publish_event(res, f\"{res.graph_id}/{res.graph_exec_id}\")",
              "successors": []
            }
          ]
        },
        {
          "name": "listen",
          "type": "function",
          "start_line": 480,
          "end_line": 484,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 480,
              "line": "    async def listen("
            },
            {
              "lineno": 481,
              "line": "        self, graph_id: str = \"*\", graph_exec_id: str = \"*\""
            },
            {
              "lineno": 482,
              "line": "    ) -> AsyncGenerator[ExecutionResult, None]:"
            },
            {
              "lineno": 483,
              "line": "        async for execution_result in self.listen_events(f\"{graph_id}/{graph_exec_id}\"):"
            },
            {
              "lineno": 484,
              "line": "            yield execution_result"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 480,
              "end_line": 482,
              "label": "    async def listen(\n        self, graph_id: str = \"*\", graph_exec_id: str = \"*\"\n    ) -> AsyncGenerator[ExecutionResult, None]:",
              "successors": [
                {
                  "id": 2,
                  "start_line": 483,
                  "end_line": 483,
                  "label": "        async for execution_result in self.listen_events(f\"{graph_id}/{graph_exec_id}\"):",
                  "successors": [
                    {
                      "id": 3,
                      "start_line": 484,
                      "end_line": 484,
                      "label": "            yield execution_result",
                      "successors": [
                        {
                          "id": 2,
                          "start_line": 483,
                          "end_line": 483,
                          "label": "        async for execution_result in self.listen_events(f\"{graph_id}/{graph_exec_id}\"):",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 470,
          "line": "class AsyncRedisExecutionEventBus(AsyncRedisEventBus[ExecutionResult]):"
        },
        {
          "lineno": 471,
          "line": "    Model = ExecutionResult"
        },
        {
          "lineno": 472,
          "line": ""
        },
        {
          "lineno": 473,
          "line": "    @property"
        },
        {
          "lineno": 476,
          "line": ""
        },
        {
          "lineno": 479,
          "line": ""
        }
      ],
      "blocks": [
        {
          "id": 1,
          "start_line": 470,
          "end_line": 471,
          "label": "class AsyncRedisExecutionEventBus(AsyncRedisEventBus[ExecutionResult]):\n    Model = ExecutionResult",
          "successors": []
        },
        {
          "id": 2,
          "start_line": 472,
          "end_line": 472,
          "label": "",
          "successors": []
        },
        {
          "id": 3,
          "start_line": 473,
          "end_line": 473,
          "label": "    @property",
          "successors": []
        },
        {
          "id": 4,
          "start_line": 476,
          "end_line": 476,
          "label": "",
          "successors": []
        },
        {
          "id": 5,
          "start_line": 479,
          "end_line": 479,
          "label": "",
          "successors": []
        }
      ]
    }
  ],
  "simplified_code": [
    {
      "lineno": 1,
      "line": "from collections import defaultdict"
    },
    {
      "lineno": 2,
      "line": "from datetime import datetime, timezone"
    },
    {
      "lineno": 3,
      "line": "from multiprocessing import Manager"
    },
    {
      "lineno": 4,
      "line": "from typing import Any, AsyncGenerator, Generator, Generic, TypeVar"
    },
    {
      "lineno": 5,
      "line": ""
    },
    {
      "lineno": 6,
      "line": "from prisma.enums import AgentExecutionStatus"
    },
    {
      "lineno": 7,
      "line": "from prisma.models import ("
    },
    {
      "lineno": 8,
      "line": "    AgentGraphExecution,"
    },
    {
      "lineno": 9,
      "line": "    AgentNodeExecution,"
    },
    {
      "lineno": 10,
      "line": "    AgentNodeExecutionInputOutput,"
    },
    {
      "lineno": 11,
      "line": ")"
    },
    {
      "lineno": 12,
      "line": "from pydantic import BaseModel"
    },
    {
      "lineno": 13,
      "line": ""
    },
    {
      "lineno": 14,
      "line": "from backend.data.block import BlockData, BlockInput, CompletedBlockOutput"
    },
    {
      "lineno": 15,
      "line": "from backend.data.includes import EXECUTION_RESULT_INCLUDE, GRAPH_EXECUTION_INCLUDE"
    },
    {
      "lineno": 16,
      "line": "from backend.data.queue import AsyncRedisEventBus, RedisEventBus"
    },
    {
      "lineno": 17,
      "line": "from backend.util import json, mock"
    },
    {
      "lineno": 18,
      "line": "from backend.util.settings import Config"
    },
    {
      "lineno": 19,
      "line": ""
    },
    {
      "lineno": 20,
      "line": ""
    },
    {
      "lineno": 26,
      "line": ""
    },
    {
      "lineno": 27,
      "line": ""
    },
    {
      "lineno": 35,
      "line": ""
    },
    {
      "lineno": 36,
      "line": ""
    },
    {
      "lineno": 37,
      "line": "ExecutionStatus = AgentExecutionStatus"
    },
    {
      "lineno": 38,
      "line": ""
    },
    {
      "lineno": 39,
      "line": "T = TypeVar(\"T\")"
    },
    {
      "lineno": 40,
      "line": ""
    },
    {
      "lineno": 41,
      "line": ""
    },
    {
      "lineno": 60,
      "line": ""
    },
    {
      "lineno": 61,
      "line": ""
    },
    {
      "lineno": 129,
      "line": ""
    },
    {
      "lineno": 130,
      "line": ""
    },
    {
      "lineno": 131,
      "line": "# --------------------- Model functions --------------------- #"
    },
    {
      "lineno": 132,
      "line": ""
    },
    {
      "lineno": 133,
      "line": ""
    },
    {
      "lineno": 174,
      "line": ""
    },
    {
      "lineno": 175,
      "line": ""
    },
    {
      "lineno": 242,
      "line": ""
    },
    {
      "lineno": 243,
      "line": ""
    },
    {
      "lineno": 259,
      "line": ""
    },
    {
      "lineno": 260,
      "line": ""
    },
    {
      "lineno": 269,
      "line": ""
    },
    {
      "lineno": 270,
      "line": ""
    },
    {
      "lineno": 287,
      "line": ""
    },
    {
      "lineno": 288,
      "line": ""
    },
    {
      "lineno": 294,
      "line": ""
    },
    {
      "lineno": 295,
      "line": ""
    },
    {
      "lineno": 325,
      "line": ""
    },
    {
      "lineno": 326,
      "line": ""
    },
    {
      "lineno": 338,
      "line": ""
    },
    {
      "lineno": 339,
      "line": ""
    },
    {
      "lineno": 340,
      "line": "LIST_SPLIT = \"_$_\""
    },
    {
      "lineno": 341,
      "line": "DICT_SPLIT = \"_#_\""
    },
    {
      "lineno": 342,
      "line": "OBJC_SPLIT = \"_@_\""
    },
    {
      "lineno": 343,
      "line": ""
    },
    {
      "lineno": 344,
      "line": ""
    },
    {
      "lineno": 371,
      "line": ""
    },
    {
      "lineno": 372,
      "line": ""
    },
    {
      "lineno": 416,
      "line": ""
    },
    {
      "lineno": 417,
      "line": ""
    },
    {
      "lineno": 432,
      "line": ""
    },
    {
      "lineno": 433,
      "line": ""
    },
    {
      "lineno": 446,
      "line": ""
    },
    {
      "lineno": 447,
      "line": ""
    },
    {
      "lineno": 448,
      "line": "# --------------------- Event Bus --------------------- #"
    },
    {
      "lineno": 449,
      "line": ""
    },
    {
      "lineno": 450,
      "line": "config = Config()"
    },
    {
      "lineno": 451,
      "line": ""
    },
    {
      "lineno": 452,
      "line": ""
    },
    {
      "lineno": 468,
      "line": ""
    },
    {
      "lineno": 469,
      "line": ""
    }
  ],
  "blocks": [
    {
      "id": 1,
      "start_line": 1,
      "end_line": 18,
      "label": "from collections import defaultdict\nfrom datetime import datetime, timezone\nfrom multiprocessing import Manager\nfrom typing import Any, AsyncGenerator, Generator, Generic, TypeVar\n\nfrom prisma.enums import AgentExecutionStatus\nfrom prisma.models import (\n    AgentGraphExecution,\n    AgentNodeExecution,\n    AgentNodeExecutionInputOutput,\n)\nfrom pydantic import BaseModel\n\nfrom backend.data.block import BlockData, BlockInput, CompletedBlockOutput\nfrom backend.data.includes import EXECUTION_RESULT_INCLUDE, GRAPH_EXECUTION_INCLUDE\nfrom backend.data.queue import AsyncRedisEventBus, RedisEventBus\nfrom backend.util import json, mock\nfrom backend.util.settings import Config\n\n",
      "successors": [
        {
          "id": 2,
          "start_line": 37,
          "end_line": 37,
          "label": "ExecutionStatus = AgentExecutionStatus\n",
          "successors": [
            {
              "id": 3,
              "start_line": 39,
              "end_line": 39,
              "label": "T = TypeVar(\"T\")\n\n",
              "successors": [
                {
                  "id": 4,
                  "start_line": 340,
                  "end_line": 342,
                  "label": "LIST_SPLIT = \"_$_\"\nDICT_SPLIT = \"_#_\"\nOBJC_SPLIT = \"_@_\"\n\n",
                  "successors": [
                    {
                      "id": 5,
                      "start_line": 450,
                      "end_line": 450,
                      "label": "config = Config()\n\n",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    }
  ]
}