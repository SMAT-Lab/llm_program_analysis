{
  "name": "example_script",
  "type": "CFG",
  "start_line": 1,
  "end_line": 960,
  "functions": [
    {
      "name": "execute_node",
      "type": "function",
      "start_line": 102,
      "end_line": 245,
      "functions": [
        {
          "name": "update_execution",
          "type": "function",
          "start_line": 127,
          "end_line": 130,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 127,
              "line": "    def update_execution(status: ExecutionStatus) -> ExecutionResult:"
            },
            {
              "lineno": 128,
              "line": "        exec_update = db_client.update_execution_status(node_exec_id, status)"
            },
            {
              "lineno": 129,
              "line": "        db_client.send_execution_update(exec_update)"
            },
            {
              "lineno": 130,
              "line": "        return exec_update"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 127,
              "end_line": 130,
              "label": "    def update_execution(status: ExecutionStatus) -> ExecutionResult:\n        exec_update = db_client.update_execution_status(node_exec_id, status)\n        db_client.send_execution_update(exec_update)\n        return exec_update",
              "successors": []
            }
          ]
        }
      ],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 102,
          "line": "def execute_node("
        },
        {
          "lineno": 103,
          "line": "    db_client: \"DatabaseManager\","
        },
        {
          "lineno": 104,
          "line": "    creds_manager: IntegrationCredentialsManager,"
        },
        {
          "lineno": 105,
          "line": "    data: NodeExecutionEntry,"
        },
        {
          "lineno": 106,
          "line": "    execution_stats: dict[str, Any] | None = None,"
        },
        {
          "lineno": 107,
          "line": ") -> ExecutionStream:"
        },
        {
          "lineno": 108,
          "line": "    \"\"\""
        },
        {
          "lineno": 109,
          "line": "    Execute a node in the graph. This will trigger a block execution on a node,"
        },
        {
          "lineno": 110,
          "line": "    persist the execution result, and return the subsequent node to be executed."
        },
        {
          "lineno": 111,
          "line": ""
        },
        {
          "lineno": 112,
          "line": "    Args:"
        },
        {
          "lineno": 113,
          "line": "        db_client: The client to send execution updates to the server."
        },
        {
          "lineno": 114,
          "line": "        creds_manager: The manager to acquire and release credentials."
        },
        {
          "lineno": 115,
          "line": "        data: The execution data for executing the current node."
        },
        {
          "lineno": 116,
          "line": "        execution_stats: The execution statistics to be updated."
        },
        {
          "lineno": 117,
          "line": ""
        },
        {
          "lineno": 118,
          "line": "    Returns:"
        },
        {
          "lineno": 119,
          "line": "        The subsequent node to be enqueued, or None if there is no subsequent node."
        },
        {
          "lineno": 120,
          "line": "    \"\"\""
        },
        {
          "lineno": 121,
          "line": "    user_id = data.user_id"
        },
        {
          "lineno": 122,
          "line": "    graph_exec_id = data.graph_exec_id"
        },
        {
          "lineno": 123,
          "line": "    graph_id = data.graph_id"
        },
        {
          "lineno": 124,
          "line": "    node_exec_id = data.node_exec_id"
        },
        {
          "lineno": 125,
          "line": "    node_id = data.node_id"
        },
        {
          "lineno": 126,
          "line": ""
        },
        {
          "lineno": 131,
          "line": ""
        },
        {
          "lineno": 132,
          "line": "    node = db_client.get_node(node_id)"
        },
        {
          "lineno": 133,
          "line": ""
        },
        {
          "lineno": 134,
          "line": "    node_block = get_block(node.block_id)"
        },
        {
          "lineno": 135,
          "line": "    if not node_block:"
        },
        {
          "lineno": 136,
          "line": "        logger.error(f\"Block {node.block_id} not found.\")"
        },
        {
          "lineno": 137,
          "line": "        return"
        },
        {
          "lineno": 138,
          "line": ""
        },
        {
          "lineno": 139,
          "line": "    log_metadata = LogMetadata("
        },
        {
          "lineno": 140,
          "line": "        user_id=user_id,"
        },
        {
          "lineno": 141,
          "line": "        graph_eid=graph_exec_id,"
        },
        {
          "lineno": 142,
          "line": "        graph_id=graph_id,"
        },
        {
          "lineno": 143,
          "line": "        node_eid=node_exec_id,"
        },
        {
          "lineno": 144,
          "line": "        node_id=node_id,"
        },
        {
          "lineno": 145,
          "line": "        block_name=node_block.name,"
        },
        {
          "lineno": 146,
          "line": "    )"
        },
        {
          "lineno": 147,
          "line": ""
        },
        {
          "lineno": 148,
          "line": "    # Sanity check: validate the execution input."
        },
        {
          "lineno": 149,
          "line": "    input_data, error = validate_exec(node, data.data, resolve_input=False)"
        },
        {
          "lineno": 150,
          "line": "    if input_data is None:"
        },
        {
          "lineno": 151,
          "line": "        log_metadata.error(f\"Skip execution, input validation error: {error}\")"
        },
        {
          "lineno": 152,
          "line": "        db_client.upsert_execution_output(node_exec_id, \"error\", error)"
        },
        {
          "lineno": 153,
          "line": "        update_execution(ExecutionStatus.FAILED)"
        },
        {
          "lineno": 154,
          "line": "        return"
        },
        {
          "lineno": 155,
          "line": ""
        },
        {
          "lineno": 156,
          "line": "    # Re-shape the input data for agent block."
        },
        {
          "lineno": 157,
          "line": "    # AgentExecutorBlock specially separate the node input_data & its input_default."
        },
        {
          "lineno": 158,
          "line": "    if isinstance(node_block, AgentExecutorBlock):"
        },
        {
          "lineno": 159,
          "line": "        input_data = {**node.input_default, \"data\": input_data}"
        },
        {
          "lineno": 160,
          "line": ""
        },
        {
          "lineno": 161,
          "line": "    # Execute the node"
        },
        {
          "lineno": 162,
          "line": "    input_data_str = json.dumps(input_data)"
        },
        {
          "lineno": 163,
          "line": "    input_size = len(input_data_str)"
        },
        {
          "lineno": 164,
          "line": "    log_metadata.info(\"Executed node with input\", input=input_data_str)"
        },
        {
          "lineno": 165,
          "line": "    update_execution(ExecutionStatus.RUNNING)"
        },
        {
          "lineno": 166,
          "line": ""
        },
        {
          "lineno": 167,
          "line": "    extra_exec_kwargs = {}"
        },
        {
          "lineno": 168,
          "line": "    # Last-minute fetch credentials + acquire a system-wide read-write lock to prevent"
        },
        {
          "lineno": 169,
          "line": "    # changes during execution. ⚠️ This means a set of credentials can only be used by"
        },
        {
          "lineno": 170,
          "line": "    # one (running) block at a time; simultaneous execution of blocks using same"
        },
        {
          "lineno": 171,
          "line": "    # credentials is not supported."
        },
        {
          "lineno": 172,
          "line": "    creds_lock = None"
        },
        {
          "lineno": 173,
          "line": "    if CREDENTIALS_FIELD_NAME in input_data:"
        },
        {
          "lineno": 174,
          "line": "        credentials_meta = CredentialsMetaInput(**input_data[CREDENTIALS_FIELD_NAME])"
        },
        {
          "lineno": 175,
          "line": "        credentials, creds_lock = creds_manager.acquire(user_id, credentials_meta.id)"
        },
        {
          "lineno": 176,
          "line": "        extra_exec_kwargs[\"credentials\"] = credentials"
        },
        {
          "lineno": 177,
          "line": ""
        },
        {
          "lineno": 178,
          "line": "    output_size = 0"
        },
        {
          "lineno": 179,
          "line": "    end_status = ExecutionStatus.COMPLETED"
        },
        {
          "lineno": 180,
          "line": "    credit = db_client.get_or_refill_credit(user_id)"
        },
        {
          "lineno": 181,
          "line": "    if credit < 0:"
        },
        {
          "lineno": 182,
          "line": "        raise ValueError(f\"Insufficient credit: {credit}\")"
        },
        {
          "lineno": 183,
          "line": ""
        },
        {
          "lineno": 184,
          "line": "    try:"
        },
        {
          "lineno": 185,
          "line": "        for output_name, output_data in node_block.execute("
        },
        {
          "lineno": 186,
          "line": "            input_data, **extra_exec_kwargs"
        },
        {
          "lineno": 187,
          "line": "        ):"
        },
        {
          "lineno": 188,
          "line": "            output_size += len(json.dumps(output_data))"
        },
        {
          "lineno": 189,
          "line": "            log_metadata.info(\"Node produced output\", **{output_name: output_data})"
        },
        {
          "lineno": 190,
          "line": "            db_client.upsert_execution_output(node_exec_id, output_name, output_data)"
        },
        {
          "lineno": 191,
          "line": ""
        },
        {
          "lineno": 192,
          "line": "            for execution in _enqueue_next_nodes("
        },
        {
          "lineno": 193,
          "line": "                db_client=db_client,"
        },
        {
          "lineno": 194,
          "line": "                node=node,"
        },
        {
          "lineno": 195,
          "line": "                output=(output_name, output_data),"
        },
        {
          "lineno": 196,
          "line": "                user_id=user_id,"
        },
        {
          "lineno": 197,
          "line": "                graph_exec_id=graph_exec_id,"
        },
        {
          "lineno": 198,
          "line": "                graph_id=graph_id,"
        },
        {
          "lineno": 199,
          "line": "                log_metadata=log_metadata,"
        },
        {
          "lineno": 200,
          "line": "            ):"
        },
        {
          "lineno": 201,
          "line": "                yield execution"
        },
        {
          "lineno": 202,
          "line": ""
        },
        {
          "lineno": 203,
          "line": "    except Exception as e:"
        },
        {
          "lineno": 204,
          "line": "        end_status = ExecutionStatus.FAILED"
        },
        {
          "lineno": 205,
          "line": "        error_msg = str(e)"
        },
        {
          "lineno": 206,
          "line": "        log_metadata.exception(f\"Node execution failed with error {error_msg}\")"
        },
        {
          "lineno": 207,
          "line": "        db_client.upsert_execution_output(node_exec_id, \"error\", error_msg)"
        },
        {
          "lineno": 208,
          "line": ""
        },
        {
          "lineno": 209,
          "line": "        for execution in _enqueue_next_nodes("
        },
        {
          "lineno": 210,
          "line": "            db_client=db_client,"
        },
        {
          "lineno": 211,
          "line": "            node=node,"
        },
        {
          "lineno": 212,
          "line": "            output=(\"error\", error_msg),"
        },
        {
          "lineno": 213,
          "line": "            user_id=user_id,"
        },
        {
          "lineno": 214,
          "line": "            graph_exec_id=graph_exec_id,"
        },
        {
          "lineno": 215,
          "line": "            graph_id=graph_id,"
        },
        {
          "lineno": 216,
          "line": "            log_metadata=log_metadata,"
        },
        {
          "lineno": 217,
          "line": "        ):"
        },
        {
          "lineno": 218,
          "line": "            yield execution"
        },
        {
          "lineno": 219,
          "line": ""
        },
        {
          "lineno": 220,
          "line": "        raise e"
        },
        {
          "lineno": 221,
          "line": "    finally:"
        },
        {
          "lineno": 222,
          "line": "        # Ensure credentials are released even if execution fails"
        },
        {
          "lineno": 223,
          "line": "        if creds_lock:"
        },
        {
          "lineno": 224,
          "line": "            try:"
        },
        {
          "lineno": 225,
          "line": "                creds_lock.release()"
        },
        {
          "lineno": 226,
          "line": "            except Exception as e:"
        },
        {
          "lineno": 227,
          "line": "                log_metadata.error(f\"Failed to release credentials lock: {e}\")"
        },
        {
          "lineno": 228,
          "line": ""
        },
        {
          "lineno": 229,
          "line": "        # Update execution status and spend credits"
        },
        {
          "lineno": 230,
          "line": "        res = update_execution(end_status)"
        },
        {
          "lineno": 231,
          "line": "        if end_status == ExecutionStatus.COMPLETED:"
        },
        {
          "lineno": 232,
          "line": "            s = input_size + output_size"
        },
        {
          "lineno": 233,
          "line": "            t = ("
        },
        {
          "lineno": 234,
          "line": "                (res.end_time - res.start_time).total_seconds()"
        },
        {
          "lineno": 235,
          "line": "                if res.end_time and res.start_time"
        },
        {
          "lineno": 236,
          "line": "                else 0"
        },
        {
          "lineno": 237,
          "line": "            )"
        },
        {
          "lineno": 238,
          "line": "            db_client.spend_credits(user_id, credit, node_block.id, input_data, s, t)"
        },
        {
          "lineno": 239,
          "line": ""
        },
        {
          "lineno": 240,
          "line": "        # Update execution stats"
        },
        {
          "lineno": 241,
          "line": "        if execution_stats is not None:"
        },
        {
          "lineno": 242,
          "line": "            execution_stats.update(node_block.execution_stats)"
        },
        {
          "lineno": 243,
          "line": "            execution_stats[\"input_size\"] = input_size"
        },
        {
          "lineno": 244,
          "line": "            execution_stats[\"output_size\"] = output_size"
        },
        {
          "lineno": 245,
          "line": ""
        }
      ],
      "blocks": [
        {
          "id": 1,
          "start_line": 102,
          "end_line": 107,
          "label": "def execute_node(\n    db_client: \"DatabaseManager\",\n    creds_manager: IntegrationCredentialsManager,\n    data: NodeExecutionEntry,\n    execution_stats: dict[str, Any] | None = None,\n) -> ExecutionStream:",
          "successors": [
            {
              "id": 2,
              "start_line": 121,
              "end_line": 125,
              "label": "user_id = data.user_id\n    graph_exec_id = data.graph_exec_id\n    graph_id = data.graph_id\n    node_exec_id = data.node_exec_id\n    node_id = data.node_id",
              "successors": [
                {
                  "id": 3,
                  "start_line": 132,
                  "end_line": 135,
                  "label": "node = db_client.get_node(node_id)\n\n    node_block = get_block(node.block_id)\n    if not node_block:",
                  "successors": [
                    {
                      "id": 4,
                      "start_line": 136,
                      "end_line": 137,
                      "label": "logger.error(f\"Block {node.block_id} not found.\")\n        return",
                      "successors": []
                    },
                    {
                      "id": 5,
                      "start_line": 139,
                      "end_line": 149,
                      "label": "log_metadata = LogMetadata(\n        user_id=user_id,\n        graph_eid=graph_exec_id,\n        graph_id=graph_id,\n        node_eid=node_exec_id,\n        node_id=node_id,\n        block_name=node_block.name,\n    )\n\n    # Sanity check: validate the execution input.\n    input_data, error = validate_exec(node, data.data, resolve_input=False)",
                      "successors": [
                        {
                          "id": 6,
                          "start_line": 150,
                          "end_line": 154,
                          "label": "if input_data is None:\n        log_metadata.error(f\"Skip execution, input validation error: {error}\")\n        db_client.upsert_execution_output(node_exec_id, \"error\", error)\n        update_execution(ExecutionStatus.FAILED)\n        return",
                          "successors": []
                        },
                        {
                          "id": 7,
                          "start_line": 156,
                          "end_line": 158,
                          "label": "# Re-shape the input data for agent block.\n    # AgentExecutorBlock specially separate the node input_data & its input_default.\n    if isinstance(node_block, AgentExecutorBlock):",
                          "successors": [
                            {
                              "id": 8,
                              "start_line": 159,
                              "end_line": 159,
                              "label": "input_data = {**node.input_default, \"data\": input_data}",
                              "successors": []
                            },
                            {
                              "id": 9,
                              "start_line": 161,
                              "end_line": 176,
                              "label": "# Execute the node\n    input_data_str = json.dumps(input_data)\n    input_size = len(input_data_str)\n    log_metadata.info(\"Executed node with input\", input=input_data_str)\n    update_execution(ExecutionStatus.RUNNING)\n\n    extra_exec_kwargs = {}\n    # Last-minute fetch credentials + acquire a system-wide read-write lock to prevent\n    # changes during execution. \n    # This means a set of credentials can only be used by\n    # one (running) block at a time; simultaneous execution of blocks using same\n    # credentials is not supported.\n    creds_lock = None\n    if CREDENTIALS_FIELD_NAME in input_data:\n        credentials_meta = CredentialsMetaInput(**input_data[CREDENTIALS_FIELD_NAME])\n        credentials, creds_lock = creds_manager.acquire(user_id, credentials_meta.id)\n        extra_exec_kwargs[\"credentials\"] = credentials",
                              "successors": [
                                {
                                  "id": 10,
                                  "start_line": 178,
                                  "end_line": 196,
                                  "label": "output_size = 0\n    end_status = ExecutionStatus.COMPLETED\n    credit = db_client.get_or_refill_credit(user_id)\n    if credit < 0:\n        raise ValueError(f\"Insufficient credit: {credit}\")\n\n    try:\n        for output_name, output_data in node_block.execute(\n            input_data, **extra_exec_kwargs\n        ):\n            output_size += len(json.dumps(output_data))\n            log_metadata.info(\"Node produced output\", **{output_name: output_data})\n            db_client.upsert_execution_output(node_exec_id, output_name, output_data)\n\n            for execution in _enqueue_next_nodes(\n                db_client=db_client,\n                node=node,\n                output=(output_name, output_data),",
                                  "successors": [
                                    {
                                      "id": 11,
                                      "start_line": 201,
                                      "end_line": 203,
                                      "label": "yield execution\n\n    except Exception as e:",
                                      "successors": [
                                        {
                                          "id": 12,
                                          "start_line": 204,
                                          "end_line": 220,
                                          "label": "end_status = ExecutionStatus.FAILED\n        error_msg = str(e)\n        log_metadata.exception(f\"Node execution failed with error {error_msg}\")\n        db_client.upsert_execution_output(node_exec_id, \"error\", error_msg)\n\n        for execution in _enqueue_next_nodes(\n            db_client=db_client,\n            node=node,\n            output=(\"error\", error_msg),\n            user_id=user_id,\n            graph_exec_id=graph_exec_id,\n            graph_id=graph_id,\n            log_metadata=log_metadata,\n        ):\n            yield execution\n\n        raise e",
                                          "successors": []
                                        },
                                        {
                                          "id": 13,
                                          "start_line": 221,
                                          "end_line": 244,
                                          "label": "finally:\n        # Ensure credentials are released even if execution fails\n        if creds_lock:\n            try:\n                creds_lock.release()\n            except Exception as e:\n                log_metadata.error(f\"Failed to release credentials lock: {e}\")\n\n        # Update execution status and spend credits\n        res = update_execution(end_status)\n        if end_status == ExecutionStatus.COMPLETED:\n            s = input_size + output_size\n            t = (\n                (res.end_time - res.start_time).total_seconds()\n                if res.end_time and res.start_time\n                else 0\n            )\n            db_client.spend_credits(user_id, credit, node_block.id, input_data, s, t)\n\n        # Update execution stats\n        if execution_stats is not None:\n            execution_stats.update(node_block.execution_stats)\n            execution_stats[\"input_size\"] = input_size\n            execution_stats[\"output_size\"] = output_size",
                                          "successors": []
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "_enqueue_next_nodes",
      "type": "function",
      "start_line": 247,
      "end_line": 360,
      "functions": [
        {
          "name": "add_enqueued_execution",
          "type": "function",
          "start_line": 256,
          "end_line": 270,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 256,
              "line": "    def add_enqueued_execution("
            },
            {
              "lineno": 257,
              "line": "        node_exec_id: str, node_id: str, data: BlockInput"
            },
            {
              "lineno": 258,
              "line": "    ) -> NodeExecutionEntry:"
            },
            {
              "lineno": 259,
              "line": "        exec_update = db_client.update_execution_status("
            },
            {
              "lineno": 260,
              "line": "            node_exec_id, ExecutionStatus.QUEUED, data"
            },
            {
              "lineno": 261,
              "line": "        )"
            },
            {
              "lineno": 262,
              "line": "        db_client.send_execution_update(exec_update)"
            },
            {
              "lineno": 263,
              "line": "        return NodeExecutionEntry("
            },
            {
              "lineno": 264,
              "line": "            user_id=user_id,"
            },
            {
              "lineno": 265,
              "line": "            graph_exec_id=graph_exec_id,"
            },
            {
              "lineno": 266,
              "line": "            graph_id=graph_id,"
            },
            {
              "lineno": 267,
              "line": "            node_exec_id=node_exec_id,"
            },
            {
              "lineno": 268,
              "line": "            node_id=node_id,"
            },
            {
              "lineno": 269,
              "line": "            data=data,"
            },
            {
              "lineno": 270,
              "line": "        )"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 256,
              "end_line": 258,
              "label": "    def add_enqueued_execution(\n        node_exec_id: str, node_id: str, data: BlockInput\n    ) -> NodeExecutionEntry:",
              "successors": [
                {
                  "id": 2,
                  "start_line": 259,
                  "end_line": 262,
                  "label": "        exec_update = db_client.update_execution_status(\n            node_exec_id, ExecutionStatus.QUEUED, data\n        )\n        db_client.send_execution_update(exec_update)",
                  "successors": [
                    {
                      "id": 3,
                      "start_line": 263,
                      "end_line": 270,
                      "label": "        return NodeExecutionEntry(\n            user_id=user_id,\n            graph_exec_id=graph_exec_id,\n            graph_id=graph_id,\n            node_exec_id=node_exec_id,\n            node_id=node_id,\n            data=data,\n        )",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "register_next_executions",
          "type": "function",
          "start_line": 272,
          "end_line": 354,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 272,
              "line": "    def register_next_executions(node_link: Link) -> list[NodeExecutionEntry]:"
            },
            {
              "lineno": 273,
              "line": "        enqueued_executions = []"
            },
            {
              "lineno": 274,
              "line": "        next_output_name = node_link.source_name"
            },
            {
              "lineno": 275,
              "line": "        next_input_name = node_link.sink_name"
            },
            {
              "lineno": 276,
              "line": "        next_node_id = node_link.sink_id"
            },
            {
              "lineno": 277,
              "line": ""
            },
            {
              "lineno": 278,
              "line": "        next_data = parse_execution_output(output, next_output_name)"
            },
            {
              "lineno": 279,
              "line": "        if next_data is None:"
            },
            {
              "lineno": 280,
              "line": "            return enqueued_executions"
            },
            {
              "lineno": 281,
              "line": ""
            },
            {
              "lineno": 282,
              "line": "        next_node = db_client.get_node(next_node_id)"
            },
            {
              "lineno": 283,
              "line": ""
            },
            {
              "lineno": 284,
              "line": "        # Multiple node can register the same next node, we need this to be atomic"
            },
            {
              "lineno": 285,
              "line": "        # To avoid same execution to be enqueued multiple times,"
            },
            {
              "lineno": 286,
              "line": "        # Or the same input to be consumed multiple times."
            },
            {
              "lineno": 287,
              "line": "        with synchronized(f\"upsert_input-{next_node_id}-{graph_exec_id}\"):"
            },
            {
              "lineno": 288,
              "line": "            # Add output data to the earliest incomplete execution, or create a new one."
            },
            {
              "lineno": 289,
              "line": "            next_node_exec_id, next_node_input = db_client.upsert_execution_input("
            },
            {
              "lineno": 290,
              "line": "                node_id=next_node_id,"
            },
            {
              "lineno": 291,
              "line": "                graph_exec_id=graph_exec_id,"
            },
            {
              "lineno": 292,
              "line": "                input_name=next_input_name,"
            },
            {
              "lineno": 293,
              "line": "                input_data=next_data,"
            },
            {
              "lineno": 294,
              "line": "            )"
            },
            {
              "lineno": 295,
              "line": ""
            },
            {
              "lineno": 296,
              "line": "            # Complete missing static input pins data using the last execution input."
            },
            {
              "lineno": 297,
              "line": "            static_link_names = {"
            },
            {
              "lineno": 298,
              "line": "                link.sink_name"
            },
            {
              "lineno": 299,
              "line": "                for link in next_node.input_links"
            },
            {
              "lineno": 300,
              "line": "                if link.is_static and link.sink_name not in next_node_input"
            },
            {
              "lineno": 301,
              "line": "            }"
            },
            {
              "lineno": 302,
              "line": "            if static_link_names and ("
            },
            {
              "lineno": 303,
              "line": "                latest_execution := db_client.get_latest_execution("
            },
            {
              "lineno": 304,
              "line": "                    next_node_id, graph_exec_id"
            },
            {
              "lineno": 305,
              "line": "                )"
            },
            {
              "lineno": 306,
              "line": "            ):"
            },
            {
              "lineno": 307,
              "line": "                for name in static_link_names:"
            },
            {
              "lineno": 308,
              "line": "                    next_node_input[name] = latest_execution.input_data.get(name)"
            },
            {
              "lineno": 309,
              "line": ""
            },
            {
              "lineno": 310,
              "line": "            # Validate the input data for the next node."
            },
            {
              "lineno": 311,
              "line": "            next_node_input, validation_msg = validate_exec(next_node, next_node_input)"
            },
            {
              "lineno": 312,
              "line": "            suffix = f\"{next_output_name}>{next_input_name}~{next_node_exec_id}:{validation_msg}\""
            },
            {
              "lineno": 313,
              "line": ""
            },
            {
              "lineno": 314,
              "line": "            # Incomplete input data, skip queueing the execution."
            },
            {
              "lineno": 315,
              "line": "            if not next_node_input:"
            },
            {
              "lineno": 316,
              "line": "                log_metadata.warning(f\"Skipped queueing {suffix}\")"
            },
            {
              "lineno": 317,
              "line": "                return enqueued_executions"
            },
            {
              "lineno": 318,
              "line": ""
            },
            {
              "lineno": 319,
              "line": "            # Input is complete, enqueue the execution."
            },
            {
              "lineno": 320,
              "line": "            log_metadata.info(f\"Enqueued {suffix}\")"
            },
            {
              "lineno": 321,
              "line": "            enqueued_executions.append("
            },
            {
              "lineno": 322,
              "line": "                add_enqueued_execution(next_node_exec_id, next_node_id, next_node_input)"
            },
            {
              "lineno": 323,
              "line": "            )"
            },
            {
              "lineno": 324,
              "line": ""
            },
            {
              "lineno": 325,
              "line": "            # Next execution stops here if the link is not static."
            },
            {
              "lineno": 326,
              "line": "            if not node_link.is_static:"
            },
            {
              "lineno": 327,
              "line": "                return enqueued_executions"
            },
            {
              "lineno": 328,
              "line": ""
            },
            {
              "lineno": 329,
              "line": "            # If link is static, there could be some incomplete executions waiting for it."
            },
            {
              "lineno": 330,
              "line": "            # Load and complete the input missing input data, and try to re-enqueue them."
            },
            {
              "lineno": 331,
              "line": "            for iexec in db_client.get_incomplete_executions("
            },
            {
              "lineno": 332,
              "line": "                next_node_id, graph_exec_id"
            },
            {
              "lineno": 333,
              "line": "            ):"
            },
            {
              "lineno": 334,
              "line": "                idata = iexec.input_data"
            },
            {
              "lineno": 335,
              "line": "                ineid = iexec.node_exec_id"
            },
            {
              "lineno": 336,
              "line": ""
            },
            {
              "lineno": 337,
              "line": "                static_link_names = {"
            },
            {
              "lineno": 338,
              "line": "                    link.sink_name"
            },
            {
              "lineno": 339,
              "line": "                    for link in next_node.input_links"
            },
            {
              "lineno": 340,
              "line": "                    if link.is_static and link.sink_name not in idata"
            },
            {
              "lineno": 341,
              "line": "                }"
            },
            {
              "lineno": 342,
              "line": "                for input_name in static_link_names:"
            },
            {
              "lineno": 343,
              "line": "                    idata[input_name] = next_node_input[input_name]"
            },
            {
              "lineno": 344,
              "line": ""
            },
            {
              "lineno": 345,
              "line": "                idata, msg = validate_exec(next_node, idata)"
            },
            {
              "lineno": 346,
              "line": "                suffix = f\"{next_output_name}>{next_input_name}~{ineid}:{msg}\""
            },
            {
              "lineno": 347,
              "line": "                if not idata:"
            },
            {
              "lineno": 348,
              "line": "                    log_metadata.info(f\"Enqueueing static-link skipped: {suffix}\")"
            },
            {
              "lineno": 349,
              "line": "                    continue"
            },
            {
              "lineno": 350,
              "line": "                log_metadata.info(f\"Enqueueing static-link execution {suffix}\")"
            },
            {
              "lineno": 351,
              "line": "                enqueued_executions.append("
            },
            {
              "lineno": 352,
              "line": "                    add_enqueued_execution(iexec.node_exec_id, next_node_id, idata)"
            },
            {
              "lineno": 353,
              "line": "                )"
            },
            {
              "lineno": 354,
              "line": "            return enqueued_executions"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 272,
              "end_line": 279,
              "label": "    def register_next_executions(node_link: Link) -> list[NodeExecutionEntry]:\n        enqueued_executions = []\n        next_output_name = node_link.source_name\n        next_input_name = node_link.sink_name\n        next_node_id = node_link.sink_id\n\n        next_data = parse_execution_output(output, next_output_name)\n        if next_data is None:",
              "successors": [
                {
                  "id": 2,
                  "start_line": 280,
                  "end_line": 280,
                  "label": "            return enqueued_executions",
                  "successors": []
                },
                {
                  "id": 3,
                  "start_line": 282,
                  "end_line": 287,
                  "label": "        next_node = db_client.get_node(next_node_id)\n\n        # Multiple node can register the same next node, we need this to be atomic\n        # To avoid same execution to be enqueued multiple times,\n        # Or the same input to be consumed multiple times.\n        with synchronized(f\"upsert_input-{next_node_id}-{graph_exec_id}\"):",
                  "successors": [
                    {
                      "id": 4,
                      "start_line": 288,
                      "end_line": 294,
                      "label": "            # Add output data to the earliest incomplete execution, or create a new one.\n            next_node_exec_id, next_node_input = db_client.upsert_execution_input(\n                node_id=next_node_id,\n                graph_exec_id=graph_exec_id,\n                input_name=next_input_name,\n                input_data=next_data,\n            )",
                      "successors": [
                        {
                          "id": 5,
                          "start_line": 296,
                          "end_line": 301,
                          "label": "            # Complete missing static input pins data using the last execution input.\n            static_link_names = {\n                link.sink_name\n                for link in next_node.input_links\n                if link.is_static and link.sink_name not in next_node_input\n            }",
                          "successors": [
                            {
                              "id": 6,
                              "start_line": 302,
                              "end_line": 306,
                              "label": "            if static_link_names and (\n                latest_execution := db_client.get_latest_execution(\n                    next_node_id, graph_exec_id\n                )\n            ):",
                              "successors": [
                                {
                                  "id": 7,
                                  "start_line": 307,
                                  "end_line": 308,
                                  "label": "                for name in static_link_names:\n                    next_node_input[name] = latest_execution.input_data.get(name)",
                                  "successors": []
                                }
                              ]
                            },
                            {
                              "id": 8,
                              "start_line": 310,
                              "end_line": 315,
                              "label": "            # Validate the input data for the next node.\n            next_node_input, validation_msg = validate_exec(next_node, next_node_input)\n            suffix = f\"{next_output_name}>{next_input_name}~{next_node_exec_id}:{validation_msg}\"\n\n            # Incomplete input data, skip queueing the execution.\n            if not next_node_input:",
                              "successors": [
                                {
                                  "id": 9,
                                  "start_line": 316,
                                  "end_line": 317,
                                  "label": "                log_metadata.warning(f\"Skipped queueing {suffix}\")\n                return enqueued_executions",
                                  "successors": []
                                },
                                {
                                  "id": 10,
                                  "start_line": 319,
                                  "end_line": 327,
                                  "label": "            # Input is complete, enqueue the execution.\n            log_metadata.info(f\"Enqueued {suffix}\")\n            enqueued_executions.append(\n                add_enqueued_execution(next_node_exec_id, next_node_id, next_node_input)\n            )\n\n            # Next execution stops here if the link is not static.\n            if not node_link.is_static:\n                return enqueued_executions",
                                  "successors": []
                                },
                                {
                                  "id": 11,
                                  "start_line": 329,
                                  "end_line": 331,
                                  "label": "            # If link is static, there could be some incomplete executions waiting for it.\n            # Load and complete the input missing input data, and try to re-enqueue them.\n            for iexec in db_client.get_incomplete_executions(",
                                  "successors": [
                                    {
                                      "id": 12,
                                      "start_line": 332,
                                      "end_line": 353,
                                      "label": "                next_node_id, graph_exec_id\n            ):\n                idata = iexec.input_data\n                ineid = iexec.node_exec_id\n\n                static_link_names = {\n                    link.sink_name\n                    for link in next_node.input_links\n                    if link.is_static and link.sink_name not in idata\n                }\n                for input_name in static_link_names:\n                    idata[input_name] = next_node_input[input_name]\n\n                idata, msg = validate_exec(next_node, idata)\n                suffix = f\"{next_output_name}>{next_input_name}~{ineid}:{msg}\"\n                if not idata:\n                    log_metadata.info(f\"Enqueueing static-link skipped: {suffix}\")\n                    continue\n                log_metadata.info(f\"Enqueueing static-link execution {suffix}\")\n                enqueued_executions.append(\n                    add_enqueued_execution(iexec.node_exec_id, next_node_id, idata)\n                )\n            return enqueued_executions",
                                      "successors": []
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 247,
          "line": "def _enqueue_next_nodes("
        },
        {
          "lineno": 248,
          "line": "    db_client: \"DatabaseManager\","
        },
        {
          "lineno": 249,
          "line": "    node: Node,"
        },
        {
          "lineno": 250,
          "line": "    output: BlockData,"
        },
        {
          "lineno": 251,
          "line": "    user_id: str,"
        },
        {
          "lineno": 252,
          "line": "    graph_exec_id: str,"
        },
        {
          "lineno": 253,
          "line": "    graph_id: str,"
        },
        {
          "lineno": 254,
          "line": "    log_metadata: LogMetadata,"
        },
        {
          "lineno": 255,
          "line": ") -> list[NodeExecutionEntry]:"
        },
        {
          "lineno": 271,
          "line": ""
        },
        {
          "lineno": 355,
          "line": ""
        },
        {
          "lineno": 356,
          "line": "    return ["
        },
        {
          "lineno": 357,
          "line": "        execution"
        },
        {
          "lineno": 358,
          "line": "        for link in node.output_links"
        },
        {
          "lineno": 359,
          "line": "        for execution in register_next_executions(link)"
        },
        {
          "lineno": 360,
          "line": "    ]"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "start_line": 247,
          "end_line": 255,
          "label": "def _enqueue_next_nodes(\n    db_client: \"DatabaseManager\",\n    node: Node,\n    output: BlockData,\n    user_id: str,\n    graph_exec_id: str,\n    graph_id: str,\n    log_metadata: LogMetadata\n) -> list[NodeExecutionEntry]:",
          "successors": [
            {
              "id": 2,
              "start_line": 356,
              "end_line": 360,
              "label": "return [\n    execution\n    for link in node.output_links\n    for execution in register_next_executions(link)\n]",
              "successors": []
            }
          ]
        }
      ]
    },
    {
      "name": "validate_exec",
      "type": "function",
      "start_line": 363,
      "end_line": 430,
      "functions": [],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 363,
          "line": "def validate_exec("
        },
        {
          "lineno": 364,
          "line": "    node: Node,"
        },
        {
          "lineno": 365,
          "line": "    data: BlockInput,"
        },
        {
          "lineno": 366,
          "line": "    resolve_input: bool = True,"
        },
        {
          "lineno": 367,
          "line": ") -> tuple[BlockInput | None, str]:"
        },
        {
          "lineno": 368,
          "line": "    \"\"\""
        },
        {
          "lineno": 369,
          "line": "    Validate the input data for a node execution."
        },
        {
          "lineno": 370,
          "line": ""
        },
        {
          "lineno": 371,
          "line": "    Args:"
        },
        {
          "lineno": 372,
          "line": "        node: The node to execute."
        },
        {
          "lineno": 373,
          "line": "        data: The input data for the node execution."
        },
        {
          "lineno": 374,
          "line": "        resolve_input: Whether to resolve dynamic pins into dict/list/object."
        },
        {
          "lineno": 375,
          "line": ""
        },
        {
          "lineno": 376,
          "line": "    Returns:"
        },
        {
          "lineno": 377,
          "line": "        A tuple of the validated data and the block name."
        },
        {
          "lineno": 378,
          "line": "        If the data is invalid, the first element will be None, and the second element"
        },
        {
          "lineno": 379,
          "line": "        will be an error message."
        },
        {
          "lineno": 380,
          "line": "        If the data is valid, the first element will be the resolved input data, and"
        },
        {
          "lineno": 381,
          "line": "        the second element will be the block name."
        },
        {
          "lineno": 382,
          "line": "    \"\"\""
        },
        {
          "lineno": 383,
          "line": "    node_block: Block | None = get_block(node.block_id)"
        },
        {
          "lineno": 384,
          "line": "    if not node_block:"
        },
        {
          "lineno": 385,
          "line": "        return None, f\"Block for {node.block_id} not found.\""
        },
        {
          "lineno": 386,
          "line": ""
        },
        {
          "lineno": 387,
          "line": "    if isinstance(node_block, AgentExecutorBlock):"
        },
        {
          "lineno": 388,
          "line": "        # Validate the execution metadata for the agent executor block."
        },
        {
          "lineno": 389,
          "line": "        try:"
        },
        {
          "lineno": 390,
          "line": "            exec_data = AgentExecutorBlock.Input(**node.input_default)"
        },
        {
          "lineno": 391,
          "line": "        except Exception as e:"
        },
        {
          "lineno": 392,
          "line": "            return None, f\"Input data doesn't match {node_block.name}: {str(e)}\""
        },
        {
          "lineno": 393,
          "line": ""
        },
        {
          "lineno": 394,
          "line": "        # Validation input"
        },
        {
          "lineno": 395,
          "line": "        input_schema = exec_data.input_schema"
        },
        {
          "lineno": 396,
          "line": "        required_fields = set(input_schema[\"required\"])"
        },
        {
          "lineno": 397,
          "line": "        input_default = exec_data.data"
        },
        {
          "lineno": 398,
          "line": "    else:"
        },
        {
          "lineno": 399,
          "line": "        # Convert non-matching data types to the expected input schema."
        },
        {
          "lineno": 400,
          "line": "        for name, data_type in node_block.input_schema.__annotations__.items():"
        },
        {
          "lineno": 401,
          "line": "            if (value := data.get(name)) and (type(value) is not data_type):"
        },
        {
          "lineno": 402,
          "line": "                data[name] = convert(value, data_type)"
        },
        {
          "lineno": 403,
          "line": ""
        },
        {
          "lineno": 404,
          "line": "        # Validation input"
        },
        {
          "lineno": 405,
          "line": "        input_schema = node_block.input_schema.jsonschema()"
        },
        {
          "lineno": 406,
          "line": "        required_fields = node_block.input_schema.get_required_fields()"
        },
        {
          "lineno": 407,
          "line": "        input_default = node.input_default"
        },
        {
          "lineno": 408,
          "line": ""
        },
        {
          "lineno": 409,
          "line": "    # Input data (without default values) should contain all required fields."
        },
        {
          "lineno": 410,
          "line": "    error_prefix = f\"Input data missing or mismatch for `{node_block.name}`:\""
        },
        {
          "lineno": 411,
          "line": "    input_fields_from_nodes = {link.sink_name for link in node.input_links}"
        },
        {
          "lineno": 412,
          "line": "    if not input_fields_from_nodes.issubset(data):"
        },
        {
          "lineno": 413,
          "line": "        return None, f\"{error_prefix} {input_fields_from_nodes - set(data)}\""
        },
        {
          "lineno": 414,
          "line": ""
        },
        {
          "lineno": 415,
          "line": "    # Merge input data with default values and resolve dynamic dict/list/object pins."
        },
        {
          "lineno": 416,
          "line": "    data = {**input_default, **data}"
        },
        {
          "lineno": 417,
          "line": "    if resolve_input:"
        },
        {
          "lineno": 418,
          "line": "        data = merge_execution_input(data)"
        },
        {
          "lineno": 419,
          "line": ""
        },
        {
          "lineno": 420,
          "line": "    # Input data post-merge should contain all required fields from the schema."
        },
        {
          "lineno": 421,
          "line": "    if not required_fields.issubset(data):"
        },
        {
          "lineno": 422,
          "line": "        return None, f\"{error_prefix} {required_fields - set(data)}\""
        },
        {
          "lineno": 423,
          "line": ""
        },
        {
          "lineno": 424,
          "line": "    # Last validation: Validate the input values against the schema."
        },
        {
          "lineno": 425,
          "line": "    if error := json.validate_with_jsonschema(schema=input_schema, data=data):"
        },
        {
          "lineno": 426,
          "line": "        error_message = f\"{error_prefix} {error}\""
        },
        {
          "lineno": 427,
          "line": "        logger.error(error_message)"
        },
        {
          "lineno": 428,
          "line": "        return None, error_message"
        },
        {
          "lineno": 429,
          "line": ""
        },
        {
          "lineno": 430,
          "line": "    return data, node_block.name"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "start_line": 363,
          "end_line": 383,
          "label": "def validate_exec(\n    node: Node,\n    data: BlockInput,\n    resolve_input: bool = True,\n) -> tuple[BlockInput | None, str]:\n    \"\"\"\n    Validate the input data for a node execution.\n\n    Args:\n        node: The node to execute.\n        data: The input data for the node execution.\n        resolve_input: Whether to resolve dynamic pins into dict/list/object.\n\n    Returns:\n        A tuple of the validated data and the block name.\n        If the data is invalid, the first element will be None, and the second element\n        will be an error message.\n        If the data is valid, the first element will be the resolved input data, and\n        the second element will be the block name.\n    \"\"\"\n    node_block: Block | None = get_block(node.block_id)\n",
          "successors": [
            {
              "id": 2,
              "start_line": 384,
              "end_line": 385,
              "label": "if not node_block:\n    return None, f\"Block for {node.block_id} not found.\"\n",
              "successors": [
                {
                  "id": 3,
                  "start_line": 387,
                  "end_line": 398,
                  "label": "if isinstance(node_block, AgentExecutorBlock):\n    # Validate the execution metadata for the agent executor block.\n    try:\n        exec_data = AgentExecutorBlock.Input(**node.input_default)\n    except Exception as e:\n        return None, f\"Input data doesn't match {node_block.name}: {str(e)}\"\n\n    # Validation input\n    input_schema = exec_data.input_schema\n    required_fields = set(input_schema[\"required\"])\n    input_default = exec_data.data\nelse:\n    # Convert non-matching data types to the expected input schema.\n    for name, data_type in node_block.input_schema.__annotations__.items():\n        if (value := data.get(name)) and (type(value) is not data_type):\n            data[name] = convert(value, data_type)\n\n    # Validation input\n    input_schema = node_block.input_schema.jsonschema()\n    required_fields = node_block.input_schema.get_required_fields()\n    input_default = node.input_default\n",
                  "successors": [
                    {
                      "id": 4,
                      "start_line": 409,
                      "end_line": 413,
                      "label": "# Input data (without default values) should contain all required fields.\nerror_prefix = f\"Input data missing or mismatch for `{node_block.name}`:\"\ninput_fields_from_nodes = {link.sink_name for link in node.input_links}\nif not input_fields_from_nodes.issubset(data):\n    return None, f\"{error_prefix} {input_fields_from_nodes - set(data)}\"\n",
                      "successors": [
                        {
                          "id": 5,
                          "start_line": 415,
                          "end_line": 418,
                          "label": "# Merge input data with default values and resolve dynamic dict/list/object pins.\ndata = {**input_default, **data}\nif resolve_input:\n    data = merge_execution_input(data)\n",
                          "successors": [
                            {
                              "id": 6,
                              "start_line": 420,
                              "end_line": 422,
                              "label": "# Input data post-merge should contain all required fields from the schema.\nif not required_fields.issubset(data):\n    return None, f\"{error_prefix} {required_fields - set(data)}\"\n",
                              "successors": [
                                {
                                  "id": 7,
                                  "start_line": 424,
                                  "end_line": 428,
                                  "label": "# Last validation: Validate the input values against the schema.\nif error := json.validate_with_jsonschema(schema=input_schema, data=data):\n    error_message = f\"{error_prefix} {error}\"\n    logger.error(error_message)\n    return None, error_message\n",
                                  "successors": [
                                    {
                                      "id": 8,
                                      "start_line": 430,
                                      "end_line": 430,
                                      "label": "return data, node_block.name\n",
                                      "successors": []
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "get_db_client",
      "type": "function",
      "start_line": 936,
      "end_line": 940,
      "functions": [],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 936,
          "line": "@thread_cached"
        },
        {
          "lineno": 937,
          "line": "def get_db_client() -> \"DatabaseManager\":"
        },
        {
          "lineno": 938,
          "line": "    from backend.executor import DatabaseManager"
        },
        {
          "lineno": 939,
          "line": ""
        },
        {
          "lineno": 940,
          "line": "    return get_service_client(DatabaseManager)"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "start_line": 936,
          "end_line": 936,
          "label": "@thread_cached",
          "successors": [
            {
              "id": 2,
              "start_line": 937,
              "end_line": 938,
              "label": "def get_db_client() -> \"DatabaseManager\":\n    from backend.executor import DatabaseManager",
              "successors": [
                {
                  "id": 3,
                  "start_line": 940,
                  "end_line": 940,
                  "label": "return get_service_client(DatabaseManager)",
                  "successors": []
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "synchronized",
      "type": "function",
      "start_line": 943,
      "end_line": 951,
      "functions": [],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 943,
          "line": "@contextmanager"
        },
        {
          "lineno": 944,
          "line": "def synchronized(key: str, timeout: int = 60):"
        },
        {
          "lineno": 945,
          "line": "    lock: RedisLock = redis.get_redis().lock(f\"lock:{key}\", timeout=timeout)"
        },
        {
          "lineno": 946,
          "line": "    try:"
        },
        {
          "lineno": 947,
          "line": "        lock.acquire()"
        },
        {
          "lineno": 948,
          "line": "        yield"
        },
        {
          "lineno": 949,
          "line": "    finally:"
        },
        {
          "lineno": 950,
          "line": "        if lock.locked():"
        },
        {
          "lineno": 951,
          "line": "            lock.release()"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "start_line": 943,
          "end_line": 943,
          "label": "@contextmanager",
          "successors": [
            {
              "id": 2,
              "start_line": 944,
              "end_line": 945,
              "label": "def synchronized(key: str, timeout: int = 60):\n    lock: RedisLock = redis.get_redis().lock(f\"lock:{key}\", timeout=timeout)",
              "successors": [
                {
                  "id": 3,
                  "start_line": 946,
                  "end_line": 947,
                  "label": "try:\n    lock.acquire()",
                  "successors": [
                    {
                      "id": 4,
                      "start_line": 948,
                      "end_line": 948,
                      "label": "yield",
                      "successors": [
                        {
                          "id": 5,
                          "start_line": 949,
                          "end_line": 951,
                          "label": "finally:\n    if lock.locked():\n        lock.release()",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "llprint",
      "type": "function",
      "start_line": 954,
      "end_line": 960,
      "functions": [],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 954,
          "line": "def llprint(message: str):"
        },
        {
          "lineno": 955,
          "line": "    \"\"\""
        },
        {
          "lineno": 956,
          "line": "    Low-level print/log helper function for use in signal handlers."
        },
        {
          "lineno": 957,
          "line": "    Regular log/print statements are not allowed in signal handlers."
        },
        {
          "lineno": 958,
          "line": "    \"\"\""
        },
        {
          "lineno": 959,
          "line": "    if logger.getEffectiveLevel() == logging.DEBUG:"
        },
        {
          "lineno": 960,
          "line": "        os.write(sys.stdout.fileno(), (message + \"\\n\").encode())"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "start_line": 954,
          "end_line": 959,
          "label": "def llprint(message: str):\n    \"\"\"\n    Low-level print/log helper function for use in signal handlers.\n    Regular log/print statements are not allowed in signal handlers.\n    \"\"\"\n    if logger.getEffectiveLevel() == logging.DEBUG:",
          "successors": [
            {
              "id": 2,
              "start_line": 960,
              "end_line": 960,
              "label": "        os.write(sys.stdout.fileno(), (message + \"\\n\").encode())",
              "successors": []
            }
          ]
        }
      ]
    }
  ],
  "classes": [
    {
      "name": "LogMetadata",
      "type": "class",
      "start_line": 53,
      "end_line": 95,
      "functions": [
        {
          "name": "__init__",
          "type": "function",
          "start_line": 54,
          "end_line": 72,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 54,
              "line": "    def __init__("
            },
            {
              "lineno": 55,
              "line": "        self,"
            },
            {
              "lineno": 56,
              "line": "        user_id: str,"
            },
            {
              "lineno": 57,
              "line": "        graph_eid: str,"
            },
            {
              "lineno": 58,
              "line": "        graph_id: str,"
            },
            {
              "lineno": 59,
              "line": "        node_eid: str,"
            },
            {
              "lineno": 60,
              "line": "        node_id: str,"
            },
            {
              "lineno": 61,
              "line": "        block_name: str,"
            },
            {
              "lineno": 62,
              "line": "    ):"
            },
            {
              "lineno": 63,
              "line": "        self.metadata = {"
            },
            {
              "lineno": 64,
              "line": "            \"component\": \"ExecutionManager\","
            },
            {
              "lineno": 65,
              "line": "            \"user_id\": user_id,"
            },
            {
              "lineno": 66,
              "line": "            \"graph_eid\": graph_eid,"
            },
            {
              "lineno": 67,
              "line": "            \"graph_id\": graph_id,"
            },
            {
              "lineno": 68,
              "line": "            \"node_eid\": node_eid,"
            },
            {
              "lineno": 69,
              "line": "            \"node_id\": node_id,"
            },
            {
              "lineno": 70,
              "line": "            \"block_name\": block_name,"
            },
            {
              "lineno": 71,
              "line": "        }"
            },
            {
              "lineno": 72,
              "line": "        self.prefix = f\"[ExecutionManager|uid:{user_id}|gid:{graph_id}|nid:{node_id}]|geid:{graph_eid}|nid:{node_eid}|{block_name}]\""
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 54,
              "end_line": 62,
              "label": "    def __init__(\n        self,\n        user_id: str,\n        graph_eid: str,\n        graph_id: str,\n        node_eid: str,\n        node_id: str,\n        block_name: str,\n    ):",
              "successors": [
                {
                  "id": 2,
                  "start_line": 63,
                  "end_line": 71,
                  "label": "        self.metadata = {\n            \"component\": \"ExecutionManager\",\n            \"user_id\": user_id,\n            \"graph_eid\": graph_eid,\n            \"graph_id\": graph_id,\n            \"node_eid\": node_eid,\n            \"node_id\": node_id,\n            \"block_name\": block_name,\n        }",
                  "successors": [
                    {
                      "id": 3,
                      "start_line": 72,
                      "end_line": 72,
                      "label": "        self.prefix = f\"[ExecutionManager|uid:{user_id}|gid:{graph_id}|nid:{node_id}]|geid:{graph_eid}|nid:{node_eid}|{block_name}]\"",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "info",
          "type": "function",
          "start_line": 74,
          "end_line": 76,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 74,
              "line": "    def info(self, msg: str, **extra):"
            },
            {
              "lineno": 75,
              "line": "        msg = self._wrap(msg, **extra)"
            },
            {
              "lineno": 76,
              "line": "        logger.info(msg, extra={\"json_fields\": {**self.metadata, **extra}})"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 74,
              "end_line": 76,
              "label": "    def info(self, msg: str, **extra):\n        msg = self._wrap(msg, **extra)\n        logger.info(msg, extra={\"json_fields\": {**self.metadata, **extra}})",
              "successors": []
            }
          ]
        },
        {
          "name": "warning",
          "type": "function",
          "start_line": 78,
          "end_line": 80,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 78,
              "line": "    def warning(self, msg: str, **extra):"
            },
            {
              "lineno": 79,
              "line": "        msg = self._wrap(msg, **extra)"
            },
            {
              "lineno": 80,
              "line": "        logger.warning(msg, extra={\"json_fields\": {**self.metadata, **extra}})"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 78,
              "end_line": 80,
              "label": "    def warning(self, msg: str, **extra):\n        msg = self._wrap(msg, **extra)\n        logger.warning(msg, extra={\"json_fields\": {**self.metadata, **extra}})",
              "successors": []
            }
          ]
        },
        {
          "name": "error",
          "type": "function",
          "start_line": 82,
          "end_line": 84,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 82,
              "line": "    def error(self, msg: str, **extra):"
            },
            {
              "lineno": 83,
              "line": "        msg = self._wrap(msg, **extra)"
            },
            {
              "lineno": 84,
              "line": "        logger.error(msg, extra={\"json_fields\": {**self.metadata, **extra}})"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 82,
              "end_line": 84,
              "label": "    def error(self, msg: str, **extra):\n        msg = self._wrap(msg, **extra)\n        logger.error(msg, extra={\"json_fields\": {**self.metadata, **extra}})",
              "successors": []
            }
          ]
        },
        {
          "name": "debug",
          "type": "function",
          "start_line": 86,
          "end_line": 88,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 86,
              "line": "    def debug(self, msg: str, **extra):"
            },
            {
              "lineno": 87,
              "line": "        msg = self._wrap(msg, **extra)"
            },
            {
              "lineno": 88,
              "line": "        logger.debug(msg, extra={\"json_fields\": {**self.metadata, **extra}})"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 86,
              "end_line": 88,
              "label": "    def debug(self, msg: str, **extra):\n        msg = self._wrap(msg, **extra)\n        logger.debug(msg, extra={\"json_fields\": {**self.metadata, **extra}})",
              "successors": []
            }
          ]
        },
        {
          "name": "exception",
          "type": "function",
          "start_line": 90,
          "end_line": 92,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 90,
              "line": "    def exception(self, msg: str, **extra):"
            },
            {
              "lineno": 91,
              "line": "        msg = self._wrap(msg, **extra)"
            },
            {
              "lineno": 92,
              "line": "        logger.exception(msg, extra={\"json_fields\": {**self.metadata, **extra}})"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 90,
              "end_line": 92,
              "label": "    def exception(self, msg: str, **extra):\n        msg = self._wrap(msg, **extra)\n        logger.exception(msg, extra={\"json_fields\": {**self.metadata, **extra}})",
              "successors": []
            }
          ]
        },
        {
          "name": "_wrap",
          "type": "function",
          "start_line": 94,
          "end_line": 95,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 94,
              "line": "    def _wrap(self, msg: str, **extra):"
            },
            {
              "lineno": 95,
              "line": "        return f\"{self.prefix} {msg} {extra}\""
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 94,
              "end_line": 95,
              "label": "    def _wrap(self, msg: str, **extra):\n        return f\"{self.prefix} {msg} {extra}\"",
              "successors": []
            }
          ]
        }
      ],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 53,
          "line": "class LogMetadata:"
        },
        {
          "lineno": 73,
          "line": ""
        },
        {
          "lineno": 77,
          "line": ""
        },
        {
          "lineno": 81,
          "line": ""
        },
        {
          "lineno": 85,
          "line": ""
        },
        {
          "lineno": 89,
          "line": ""
        },
        {
          "lineno": 93,
          "line": ""
        }
      ],
      "blocks": [
        {
          "id": 1,
          "start_line": 53,
          "end_line": 53,
          "label": "class LogMetadata:",
          "successors": []
        }
      ]
    },
    {
      "name": "Executor",
      "type": "class",
      "start_line": 433,
      "end_line": 713,
      "functions": [
        {
          "name": "on_node_executor_start",
          "type": "function",
          "start_line": 459,
          "end_line": 472,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 459,
              "line": "    def on_node_executor_start(cls):"
            },
            {
              "lineno": 460,
              "line": "        configure_logging()"
            },
            {
              "lineno": 461,
              "line": "        set_service_name(\"NodeExecutor\")"
            },
            {
              "lineno": 462,
              "line": "        redis.connect()"
            },
            {
              "lineno": 463,
              "line": "        cls.pid = os.getpid()"
            },
            {
              "lineno": 464,
              "line": "        cls.db_client = get_db_client()"
            },
            {
              "lineno": 465,
              "line": "        cls.creds_manager = IntegrationCredentialsManager()"
            },
            {
              "lineno": 466,
              "line": ""
            },
            {
              "lineno": 467,
              "line": "        # Set up shutdown handlers"
            },
            {
              "lineno": 468,
              "line": "        cls.shutdown_lock = threading.Lock()"
            },
            {
              "lineno": 469,
              "line": "        atexit.register(cls.on_node_executor_stop)  # handle regular shutdown"
            },
            {
              "lineno": 470,
              "line": "        signal.signal(  # handle termination"
            },
            {
              "lineno": 471,
              "line": "            signal.SIGTERM, lambda _, __: cls.on_node_executor_sigterm()"
            },
            {
              "lineno": 472,
              "line": "        )"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 459,
              "end_line": 465,
              "label": "    def on_node_executor_start(cls):\n        configure_logging()\n        set_service_name(\"NodeExecutor\")\n        redis.connect()\n        cls.pid = os.getpid()\n        cls.db_client = get_db_client()\n        cls.creds_manager = IntegrationCredentialsManager()",
              "successors": [
                {
                  "id": 2,
                  "start_line": 467,
                  "end_line": 472,
                  "label": "        # Set up shutdown handlers\n        cls.shutdown_lock = threading.Lock()\n        atexit.register(cls.on_node_executor_stop)  # handle regular shutdown\n        signal.signal(  # handle termination\n            signal.SIGTERM, lambda _, __: cls.on_node_executor_sigterm()\n        )",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "on_node_executor_stop",
          "type": "function",
          "start_line": 475,
          "end_line": 485,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 475,
              "line": "    def on_node_executor_stop(cls):"
            },
            {
              "lineno": 476,
              "line": "        if not cls.shutdown_lock.acquire(blocking=False):"
            },
            {
              "lineno": 477,
              "line": "            return  # already shutting down"
            },
            {
              "lineno": 478,
              "line": ""
            },
            {
              "lineno": 479,
              "line": "        logger.info(f\"[on_node_executor_stop {cls.pid}] ⏳ Releasing locks...\")"
            },
            {
              "lineno": 480,
              "line": "        cls.creds_manager.release_all_locks()"
            },
            {
              "lineno": 481,
              "line": "        logger.info(f\"[on_node_executor_stop {cls.pid}] ⏳ Disconnecting Redis...\")"
            },
            {
              "lineno": 482,
              "line": "        redis.disconnect()"
            },
            {
              "lineno": 483,
              "line": "        logger.info(f\"[on_node_executor_stop {cls.pid}] ⏳ Disconnecting DB manager...\")"
            },
            {
              "lineno": 484,
              "line": "        close_service_client(cls.db_client)"
            },
            {
              "lineno": 485,
              "line": "        logger.info(f\"[on_node_executor_stop {cls.pid}] ✅ Finished cleanup\")"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 475,
              "end_line": 475,
              "label": "    def on_node_executor_stop(cls):",
              "successors": [
                {
                  "id": 2,
                  "start_line": 476,
                  "end_line": 477,
                  "label": "        if not cls.shutdown_lock.acquire(blocking=False):\n            return  # already shutting down",
                  "successors": [
                    {
                      "id": 3,
                      "start_line": 479,
                      "end_line": 485,
                      "label": "        logger.info(f\"[on_node_executor_stop {cls.pid}] \\\\u23f3 Releasing locks...\")\n        cls.creds_manager.release_all_locks()\n        logger.info(f\"[on_node_executor_stop {cls.pid}] \\\\u23f3 Disconnecting Redis...\")\n        redis.disconnect()\n        logger.info(f\"[on_node_executor_stop {cls.pid}] \\\\u23f3 Disconnecting DB manager...\")\n        close_service_client(cls.db_client)\n        logger.info(f\"[on_node_executor_stop {cls.pid}] \\\\u2705 Finished cleanup\")",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "on_node_executor_sigterm",
          "type": "function",
          "start_line": 488,
          "end_line": 498,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 488,
              "line": "    def on_node_executor_sigterm(cls):"
            },
            {
              "lineno": 489,
              "line": "        llprint(f\"[on_node_executor_sigterm {cls.pid}] ⚠️ SIGTERM received\")"
            },
            {
              "lineno": 490,
              "line": "        if not cls.shutdown_lock.acquire(blocking=False):"
            },
            {
              "lineno": 491,
              "line": "            return  # already shutting down"
            },
            {
              "lineno": 492,
              "line": ""
            },
            {
              "lineno": 493,
              "line": "        llprint(f\"[on_node_executor_stop {cls.pid}] ⏳ Releasing locks...\")"
            },
            {
              "lineno": 494,
              "line": "        cls.creds_manager.release_all_locks()"
            },
            {
              "lineno": 495,
              "line": "        llprint(f\"[on_node_executor_stop {cls.pid}] ⏳ Disconnecting Redis...\")"
            },
            {
              "lineno": 496,
              "line": "        redis.disconnect()"
            },
            {
              "lineno": 497,
              "line": "        llprint(f\"[on_node_executor_stop {cls.pid}] ✅ Finished cleanup\")"
            },
            {
              "lineno": 498,
              "line": "        sys.exit(0)"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 488,
              "end_line": 490,
              "label": "    def on_node_executor_sigterm(cls):\n        llprint(f\"[on_node_executor_sigterm {cls.pid}] \\\\u26a0\\\\ufe0f SIGTERM received\")\n        if not cls.shutdown_lock.acquire(blocking=False):",
              "successors": [
                {
                  "id": 2,
                  "start_line": 491,
                  "end_line": 491,
                  "label": "            return  # already shutting down",
                  "successors": []
                },
                {
                  "id": 3,
                  "start_line": 493,
                  "end_line": 498,
                  "label": "        llprint(f\"[on_node_executor_stop {cls.pid}] \\\\u23f3 Releasing locks...\")\n        cls.creds_manager.release_all_locks()\n        llprint(f\"[on_node_executor_stop {cls.pid}] \\\\u23f3 Disconnecting Redis...\")\n        redis.disconnect()\n        llprint(f\"[on_node_executor_stop {cls.pid}] \\\\u2705 Finished cleanup\")\n        sys.exit(0)",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "on_node_execution",
          "type": "function",
          "start_line": 502,
          "end_line": 526,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 502,
              "line": "    def on_node_execution("
            },
            {
              "lineno": 503,
              "line": "        cls,"
            },
            {
              "lineno": 504,
              "line": "        q: ExecutionQueue[NodeExecutionEntry],"
            },
            {
              "lineno": 505,
              "line": "        node_exec: NodeExecutionEntry,"
            },
            {
              "lineno": 506,
              "line": "    ) -> dict[str, Any]:"
            },
            {
              "lineno": 507,
              "line": "        log_metadata = LogMetadata("
            },
            {
              "lineno": 508,
              "line": "            user_id=node_exec.user_id,"
            },
            {
              "lineno": 509,
              "line": "            graph_eid=node_exec.graph_exec_id,"
            },
            {
              "lineno": 510,
              "line": "            graph_id=node_exec.graph_id,"
            },
            {
              "lineno": 511,
              "line": "            node_eid=node_exec.node_exec_id,"
            },
            {
              "lineno": 512,
              "line": "            node_id=node_exec.node_id,"
            },
            {
              "lineno": 513,
              "line": "            block_name=\"-\","
            },
            {
              "lineno": 514,
              "line": "        )"
            },
            {
              "lineno": 515,
              "line": ""
            },
            {
              "lineno": 516,
              "line": "        execution_stats = {}"
            },
            {
              "lineno": 517,
              "line": "        timing_info, _ = cls._on_node_execution("
            },
            {
              "lineno": 518,
              "line": "            q, node_exec, log_metadata, execution_stats"
            },
            {
              "lineno": 519,
              "line": "        )"
            },
            {
              "lineno": 520,
              "line": "        execution_stats[\"walltime\"] = timing_info.wall_time"
            },
            {
              "lineno": 521,
              "line": "        execution_stats[\"cputime\"] = timing_info.cpu_time"
            },
            {
              "lineno": 522,
              "line": ""
            },
            {
              "lineno": 523,
              "line": "        cls.db_client.update_node_execution_stats("
            },
            {
              "lineno": 524,
              "line": "            node_exec.node_exec_id, execution_stats"
            },
            {
              "lineno": 525,
              "line": "        )"
            },
            {
              "lineno": 526,
              "line": "        return execution_stats"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 502,
              "end_line": 506,
              "label": "    def on_node_execution(\n        cls,\n        q: ExecutionQueue[NodeExecutionEntry],\n        node_exec: NodeExecutionEntry,\n    ) -> dict[str, Any]:",
              "successors": [
                {
                  "id": 2,
                  "start_line": 507,
                  "end_line": 514,
                  "label": "        log_metadata = LogMetadata(\n            user_id=node_exec.user_id,\n            graph_eid=node_exec.graph_exec_id,\n            graph_id=node_exec.graph_id,\n            node_eid=node_exec.node_exec_id,\n            node_id=node_exec.node_id,\n            block_name=\"-\",\n        )",
                  "successors": [
                    {
                      "id": 3,
                      "start_line": 516,
                      "end_line": 519,
                      "label": "        execution_stats = {}\n        timing_info, _ = cls._on_node_execution(\n            q, node_exec, log_metadata, execution_stats\n        )",
                      "successors": [
                        {
                          "id": 4,
                          "start_line": 520,
                          "end_line": 521,
                          "label": "        execution_stats[\"walltime\"] = timing_info.wall_time\n        execution_stats[\"cputime\"] = timing_info.cpu_time",
                          "successors": [
                            {
                              "id": 5,
                              "start_line": 523,
                              "end_line": 525,
                              "label": "        cls.db_client.update_node_execution_stats(\n            node_exec.node_exec_id, execution_stats\n        )",
                              "successors": [
                                {
                                  "id": 6,
                                  "start_line": 526,
                                  "end_line": 526,
                                  "label": "        return execution_stats",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "_on_node_execution",
          "type": "function",
          "start_line": 530,
          "end_line": 548,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 530,
              "line": "    def _on_node_execution("
            },
            {
              "lineno": 531,
              "line": "        cls,"
            },
            {
              "lineno": 532,
              "line": "        q: ExecutionQueue[NodeExecutionEntry],"
            },
            {
              "lineno": 533,
              "line": "        node_exec: NodeExecutionEntry,"
            },
            {
              "lineno": 534,
              "line": "        log_metadata: LogMetadata,"
            },
            {
              "lineno": 535,
              "line": "        stats: dict[str, Any] | None = None,"
            },
            {
              "lineno": 536,
              "line": "    ):"
            },
            {
              "lineno": 537,
              "line": "        try:"
            },
            {
              "lineno": 538,
              "line": "            log_metadata.info(f\"Start node execution {node_exec.node_exec_id}\")"
            },
            {
              "lineno": 539,
              "line": "            for execution in execute_node("
            },
            {
              "lineno": 540,
              "line": "                cls.db_client, cls.creds_manager, node_exec, stats"
            },
            {
              "lineno": 541,
              "line": "            ):"
            },
            {
              "lineno": 542,
              "line": "                q.add(execution)"
            },
            {
              "lineno": 543,
              "line": "            log_metadata.info(f\"Finished node execution {node_exec.node_exec_id}\")"
            },
            {
              "lineno": 544,
              "line": "        except Exception as e:"
            },
            {
              "lineno": 545,
              "line": "            log_metadata.exception("
            },
            {
              "lineno": 546,
              "line": "                f\"Failed node execution {node_exec.node_exec_id}: {e}\""
            },
            {
              "lineno": 547,
              "line": "            )"
            },
            {
              "lineno": 548,
              "line": ""
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 530,
              "end_line": 536,
              "label": "    def _on_node_execution(\n        cls,\n        q: ExecutionQueue[NodeExecutionEntry],\n        node_exec: NodeExecutionEntry,\n        log_metadata: LogMetadata,\n        stats: dict[str, Any] | None = None,\n    ):",
              "successors": [
                {
                  "id": 2,
                  "start_line": 537,
                  "end_line": 537,
                  "label": "        try:",
                  "successors": [
                    {
                      "id": 3,
                      "start_line": 538,
                      "end_line": 543,
                      "label": "            log_metadata.info(f\"Start node execution {node_exec.node_exec_id}\")\n            for execution in execute_node(\n                cls.db_client, cls.creds_manager, node_exec, stats\n            ):\n                q.add(execution)\n            log_metadata.info(f\"Finished node execution {node_exec.node_exec_id}\")",
                      "successors": []
                    },
                    {
                      "id": 4,
                      "start_line": 544,
                      "end_line": 547,
                      "label": "        except Exception as e:\n            log_metadata.exception(\n                f\"Failed node execution {node_exec.node_exec_id}: {e}\"\n            )",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "on_graph_executor_start",
          "type": "function",
          "start_line": 550,
          "end_line": 563,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 550,
              "line": "    def on_graph_executor_start(cls):"
            },
            {
              "lineno": 551,
              "line": "        configure_logging()"
            },
            {
              "lineno": 552,
              "line": "        set_service_name(\"GraphExecutor\")"
            },
            {
              "lineno": 553,
              "line": ""
            },
            {
              "lineno": 554,
              "line": "        cls.db_client = get_db_client()"
            },
            {
              "lineno": 555,
              "line": "        cls.pool_size = settings.config.num_node_workers"
            },
            {
              "lineno": 556,
              "line": "        cls.pid = os.getpid()"
            },
            {
              "lineno": 557,
              "line": "        cls._init_node_executor_pool()"
            },
            {
              "lineno": 558,
              "line": "        logger.info("
            },
            {
              "lineno": 559,
              "line": "            f\"Graph executor {cls.pid} started with {cls.pool_size} node workers\""
            },
            {
              "lineno": 560,
              "line": "        )"
            },
            {
              "lineno": 561,
              "line": ""
            },
            {
              "lineno": 562,
              "line": "        # Set up shutdown handler"
            },
            {
              "lineno": 563,
              "line": "        atexit.register(cls.on_graph_executor_stop)"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 550,
              "end_line": 563,
              "label": "    def on_graph_executor_start(cls):\n        configure_logging()\n        set_service_name(\"GraphExecutor\")\n\n        cls.db_client = get_db_client()\n        cls.pool_size = settings.config.num_node_workers\n        cls.pid = os.getpid()\n        cls._init_node_executor_pool()\n        logger.info(\n            f\"Graph executor {cls.pid} started with {cls.pool_size} node workers\"\n        )\n\n        # Set up shutdown handler\n        atexit.register(cls.on_graph_executor_stop)",
              "successors": []
            }
          ]
        },
        {
          "name": "on_graph_executor_stop",
          "type": "function",
          "start_line": 566,
          "end_line": 572,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 566,
              "line": "    def on_graph_executor_stop(cls):"
            },
            {
              "lineno": 567,
              "line": "        prefix = f\"[on_graph_executor_stop {cls.pid}]\""
            },
            {
              "lineno": 568,
              "line": "        logger.info(f\"{prefix} ⏳ Terminating node executor pool...\")"
            },
            {
              "lineno": 569,
              "line": "        cls.executor.terminate()"
            },
            {
              "lineno": 570,
              "line": "        logger.info(f\"{prefix} ⏳ Disconnecting DB manager...\")"
            },
            {
              "lineno": 571,
              "line": "        close_service_client(cls.db_client)"
            },
            {
              "lineno": 572,
              "line": "        logger.info(f\"{prefix} ✅ Finished cleanup\")"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 566,
              "end_line": 566,
              "label": "    def on_graph_executor_stop(cls):",
              "successors": [
                {
                  "id": 2,
                  "start_line": 567,
                  "end_line": 572,
                  "label": "        prefix = f\"[on_graph_executor_stop {cls.pid}]\"\n        logger.info(f\"{prefix} \\\\u23f3 Terminating node executor pool...\")\n        cls.executor.terminate()\n        logger.info(f\"{prefix} \\\\u23f3 Disconnecting DB manager...\")\n        close_service_client(cls.db_client)\n        logger.info(f\"{prefix} \\\\u2705 Finished cleanup\")",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "_init_node_executor_pool",
          "type": "function",
          "start_line": 575,
          "end_line": 579,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 575,
              "line": "    def _init_node_executor_pool(cls):"
            },
            {
              "lineno": 576,
              "line": "        cls.executor = Pool("
            },
            {
              "lineno": 577,
              "line": "            processes=cls.pool_size,"
            },
            {
              "lineno": 578,
              "line": "            initializer=cls.on_node_executor_start,"
            },
            {
              "lineno": 579,
              "line": "        )"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 575,
              "end_line": 579,
              "label": "    def _init_node_executor_pool(cls):\n        cls.executor = Pool(\n            processes=cls.pool_size,\n            initializer=cls.on_node_executor_start,\n        )",
              "successors": []
            }
          ]
        },
        {
          "name": "on_graph_execution",
          "type": "function",
          "start_line": 583,
          "end_line": 604,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 583,
              "line": "    def on_graph_execution("
            },
            {
              "lineno": 584,
              "line": "        cls, graph_exec: GraphExecutionEntry, cancel: threading.Event"
            },
            {
              "lineno": 585,
              "line": "    ):"
            },
            {
              "lineno": 586,
              "line": "        log_metadata = LogMetadata("
            },
            {
              "lineno": 587,
              "line": "            user_id=graph_exec.user_id,"
            },
            {
              "lineno": 588,
              "line": "            graph_eid=graph_exec.graph_exec_id,"
            },
            {
              "lineno": 589,
              "line": "            graph_id=graph_exec.graph_id,"
            },
            {
              "lineno": 590,
              "line": "            node_id=\"*\","
            },
            {
              "lineno": 591,
              "line": "            node_eid=\"*\","
            },
            {
              "lineno": 592,
              "line": "            block_name=\"-\","
            },
            {
              "lineno": 593,
              "line": "        )"
            },
            {
              "lineno": 594,
              "line": "        timing_info, (exec_stats, error) = cls._on_graph_execution("
            },
            {
              "lineno": 595,
              "line": "            graph_exec, cancel, log_metadata"
            },
            {
              "lineno": 596,
              "line": "        )"
            },
            {
              "lineno": 597,
              "line": "        exec_stats[\"walltime\"] = timing_info.wall_time"
            },
            {
              "lineno": 598,
              "line": "        exec_stats[\"cputime\"] = timing_info.cpu_time"
            },
            {
              "lineno": 599,
              "line": "        exec_stats[\"error\"] = str(error) if error else None"
            },
            {
              "lineno": 600,
              "line": "        result = cls.db_client.update_graph_execution_stats("
            },
            {
              "lineno": 601,
              "line": "            graph_exec_id=graph_exec.graph_exec_id,"
            },
            {
              "lineno": 602,
              "line": "            stats=exec_stats,"
            },
            {
              "lineno": 603,
              "line": "        )"
            },
            {
              "lineno": 604,
              "line": "        cls.db_client.send_execution_update(result)"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 583,
              "end_line": 603,
              "label": "    def on_graph_execution(\n        cls, graph_exec: GraphExecutionEntry, cancel: threading.Event\n    ):\n        log_metadata = LogMetadata(\n            user_id=graph_exec.user_id,\n            graph_eid=graph_exec.graph_exec_id,\n            graph_id=graph_exec.graph_id,\n            node_id=\"*\",\n            node_eid=\"*\",\n            block_name=\"-\",\n        )\n        timing_info, (exec_stats, error) = cls._on_graph_execution(\n            graph_exec, cancel, log_metadata\n        )\n        exec_stats[\"walltime\"] = timing_info.wall_time\n        exec_stats[\"cputime\"] = timing_info.cpu_time\n        exec_stats[\"error\"] = str(error) if error else None\n        result = cls.db_client.update_graph_execution_stats(\n            graph_exec_id=graph_exec.graph_exec_id,\n            stats=exec_stats,\n        )",
              "successors": [
                {
                  "id": 2,
                  "start_line": 604,
                  "end_line": 604,
                  "label": "        cls.db_client.send_execution_update(result)",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "_on_graph_execution",
          "type": "function",
          "start_line": 608,
          "end_line": 713,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 608,
              "line": "    def _on_graph_execution("
            },
            {
              "lineno": 609,
              "line": "        cls,"
            },
            {
              "lineno": 610,
              "line": "        graph_exec: GraphExecutionEntry,"
            },
            {
              "lineno": 611,
              "line": "        cancel: threading.Event,"
            },
            {
              "lineno": 612,
              "line": "        log_metadata: LogMetadata,"
            },
            {
              "lineno": 613,
              "line": "    ) -> tuple[dict[str, Any], Exception | None]:"
            },
            {
              "lineno": 614,
              "line": "        \"\"\""
            },
            {
              "lineno": 615,
              "line": "        Returns:"
            },
            {
              "lineno": 616,
              "line": "            The execution statistics of the graph execution."
            },
            {
              "lineno": 617,
              "line": "            The error that occurred during the execution."
            },
            {
              "lineno": 618,
              "line": "        \"\"\""
            },
            {
              "lineno": 619,
              "line": "        log_metadata.info(f\"Start graph execution {graph_exec.graph_exec_id}\")"
            },
            {
              "lineno": 620,
              "line": "        exec_stats = {"
            },
            {
              "lineno": 621,
              "line": "            \"nodes_walltime\": 0,"
            },
            {
              "lineno": 622,
              "line": "            \"nodes_cputime\": 0,"
            },
            {
              "lineno": 623,
              "line": "            \"node_count\": 0,"
            },
            {
              "lineno": 624,
              "line": "        }"
            },
            {
              "lineno": 625,
              "line": "        error = None"
            },
            {
              "lineno": 626,
              "line": "        finished = False"
            },
            {
              "lineno": 627,
              "line": ""
            },
            {
              "lineno": 628,
              "line": "        def cancel_handler():"
            },
            {
              "lineno": 629,
              "line": "            while not cancel.is_set():"
            },
            {
              "lineno": 630,
              "line": "                cancel.wait(1)"
            },
            {
              "lineno": 631,
              "line": "            if finished:"
            },
            {
              "lineno": 632,
              "line": "                return"
            },
            {
              "lineno": 633,
              "line": "            cls.executor.terminate()"
            },
            {
              "lineno": 634,
              "line": "            log_metadata.info(f\"Terminated graph execution {graph_exec.graph_exec_id}\")"
            },
            {
              "lineno": 635,
              "line": "            cls._init_node_executor_pool()"
            },
            {
              "lineno": 636,
              "line": ""
            },
            {
              "lineno": 637,
              "line": "        cancel_thread = threading.Thread(target=cancel_handler)"
            },
            {
              "lineno": 638,
              "line": "        cancel_thread.start()"
            },
            {
              "lineno": 639,
              "line": ""
            },
            {
              "lineno": 640,
              "line": "        try:"
            },
            {
              "lineno": 641,
              "line": "            queue = ExecutionQueue[NodeExecutionEntry]()"
            },
            {
              "lineno": 642,
              "line": "            for node_exec in graph_exec.start_node_execs:"
            },
            {
              "lineno": 643,
              "line": "                queue.add(node_exec)"
            },
            {
              "lineno": 644,
              "line": ""
            },
            {
              "lineno": 645,
              "line": "            running_executions: dict[str, AsyncResult] = {}"
            },
            {
              "lineno": 646,
              "line": ""
            },
            {
              "lineno": 647,
              "line": "            def make_exec_callback(exec_data: NodeExecutionEntry):"
            },
            {
              "lineno": 648,
              "line": "                node_id = exec_data.node_id"
            },
            {
              "lineno": 649,
              "line": ""
            },
            {
              "lineno": 650,
              "line": "                def callback(result: object):"
            },
            {
              "lineno": 651,
              "line": "                    running_executions.pop(node_id)"
            },
            {
              "lineno": 652,
              "line": "                    nonlocal exec_stats"
            },
            {
              "lineno": 653,
              "line": "                    if isinstance(result, dict):"
            },
            {
              "lineno": 654,
              "line": "                        exec_stats[\"node_count\"] += 1"
            },
            {
              "lineno": 655,
              "line": "                        exec_stats[\"nodes_cputime\"] += result.get(\"cputime\", 0)"
            },
            {
              "lineno": 656,
              "line": "                        exec_stats[\"nodes_walltime\"] += result.get(\"walltime\", 0)"
            },
            {
              "lineno": 657,
              "line": ""
            },
            {
              "lineno": 658,
              "line": "                return callback"
            },
            {
              "lineno": 659,
              "line": ""
            },
            {
              "lineno": 660,
              "line": "            while not queue.empty():"
            },
            {
              "lineno": 661,
              "line": "                if cancel.is_set():"
            },
            {
              "lineno": 662,
              "line": "                    error = RuntimeError(\"Execution is cancelled\")"
            },
            {
              "lineno": 663,
              "line": "                    return exec_stats, error"
            },
            {
              "lineno": 664,
              "line": ""
            },
            {
              "lineno": 665,
              "line": "                exec_data = queue.get()"
            },
            {
              "lineno": 666,
              "line": ""
            },
            {
              "lineno": 667,
              "line": "                # Avoid parallel execution of the same node."
            },
            {
              "lineno": 668,
              "line": "                execution = running_executions.get(exec_data.node_id)"
            },
            {
              "lineno": 669,
              "line": "                if execution and not execution.ready():"
            },
            {
              "lineno": 670,
              "line": "                    # TODO (performance improvement):"
            },
            {
              "lineno": 671,
              "line": "                    #   Wait for the completion of the same node execution is blocking."
            },
            {
              "lineno": 672,
              "line": "                    #   To improve this we need a separate queue for each node."
            },
            {
              "lineno": 673,
              "line": "                    #   Re-enqueueing the data back to the queue will disrupt the order."
            },
            {
              "lineno": 674,
              "line": "                    execution.wait()"
            },
            {
              "lineno": 675,
              "line": ""
            },
            {
              "lineno": 676,
              "line": "                log_metadata.debug("
            },
            {
              "lineno": 677,
              "line": "                    f\"Dispatching node execution {exec_data.node_exec_id} \""
            },
            {
              "lineno": 678,
              "line": "                    f\"for node {exec_data.node_id}\","
            },
            {
              "lineno": 679,
              "line": "                )"
            },
            {
              "lineno": 680,
              "line": "                running_executions[exec_data.node_id] = cls.executor.apply_async("
            },
            {
              "lineno": 681,
              "line": "                    cls.on_node_execution,"
            },
            {
              "lineno": 682,
              "line": "                    (queue, exec_data),"
            },
            {
              "lineno": 683,
              "line": "                    callback=make_exec_callback(exec_data),"
            },
            {
              "lineno": 684,
              "line": "                )"
            },
            {
              "lineno": 685,
              "line": ""
            },
            {
              "lineno": 686,
              "line": "                # Avoid terminating graph execution when some nodes are still running."
            },
            {
              "lineno": 687,
              "line": "                while queue.empty() and running_executions:"
            },
            {
              "lineno": 688,
              "line": "                    log_metadata.debug("
            },
            {
              "lineno": 689,
              "line": "                        f\"Queue empty; running nodes: {list(running_executions.keys())}\""
            },
            {
              "lineno": 690,
              "line": "                    )"
            },
            {
              "lineno": 691,
              "line": "                    for node_id, execution in list(running_executions.items()):"
            },
            {
              "lineno": 692,
              "line": "                        if cancel.is_set():"
            },
            {
              "lineno": 693,
              "line": "                            error = RuntimeError(\"Execution is cancelled\")"
            },
            {
              "lineno": 694,
              "line": "                            return exec_stats, error"
            },
            {
              "lineno": 695,
              "line": ""
            },
            {
              "lineno": 696,
              "line": "                        if not queue.empty():"
            },
            {
              "lineno": 697,
              "line": "                            break  # yield to parent loop to execute new queue items"
            },
            {
              "lineno": 698,
              "line": ""
            },
            {
              "lineno": 699,
              "line": "                        log_metadata.debug(f\"Waiting on execution of node {node_id}\")"
            },
            {
              "lineno": 700,
              "line": "                        execution.wait(3)"
            },
            {
              "lineno": 701,
              "line": ""
            },
            {
              "lineno": 702,
              "line": "            log_metadata.info(f\"Finished graph execution {graph_exec.graph_exec_id}\")"
            },
            {
              "lineno": 703,
              "line": "        except Exception as e:"
            },
            {
              "lineno": 704,
              "line": "            log_metadata.exception("
            },
            {
              "lineno": 705,
              "line": "                f\"Failed graph execution {graph_exec.graph_exec_id}: {e}\""
            },
            {
              "lineno": 706,
              "line": "            )"
            },
            {
              "lineno": 707,
              "line": "            error = e"
            },
            {
              "lineno": 708,
              "line": "        finally:"
            },
            {
              "lineno": 709,
              "line": "            if not cancel.is_set():"
            },
            {
              "lineno": 710,
              "line": "                finished = True"
            },
            {
              "lineno": 711,
              "line": "                cancel.set()"
            },
            {
              "lineno": 712,
              "line": "            cancel_thread.join()"
            },
            {
              "lineno": 713,
              "line": "            return exec_stats, error"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 608,
              "end_line": 628,
              "label": "def _on_graph_execution(\n        cls,\n        graph_exec: GraphExecutionEntry,\n        cancel: threading.Event,\n        log_metadata: LogMetadata,\n    ) -> tuple[dict[str, Any], Exception | None]:\n        \"\"\"\n        Returns:\n            The execution statistics of the graph execution.\n            The error that occurred during the execution.\n        \"\"\"\n        log_metadata.info(f\"Start graph execution {graph_exec.graph_exec_id}\")\n        exec_stats = {\n            \"nodes_walltime\": 0,\n            \"nodes_cputime\": 0,\n            \"node_count\": 0,\n        }\n        error = None\n        finished = False",
              "successors": [
                {
                  "id": 2,
                  "start_line": 628,
                  "end_line": 636,
                  "label": "def cancel_handler():\n            while not cancel.is_set():\n                cancel.wait(1)\n            if finished:\n                return\n            cls.executor.terminate()\n            log_metadata.info(f\"Terminated graph execution {graph_exec.graph_exec_id}\")\n            cls._init_node_executor_pool()",
                  "successors": []
                },
                {
                  "id": 3,
                  "start_line": 637,
                  "end_line": 638,
                  "label": "cancel_thread = threading.Thread(target=cancel_handler)\n        cancel_thread.start()",
                  "successors": []
                },
                {
                  "id": 4,
                  "start_line": 640,
                  "end_line": 703,
                  "label": "try:\n            queue = ExecutionQueue[NodeExecutionEntry]()\n            for node_exec in graph_exec.start_node_execs:\n                queue.add(node_exec)\n\n            running_executions: dict[str, AsyncResult] = {}\n\n            def make_exec_callback(exec_data: NodeExecutionEntry):\n                node_id = exec_data.node_id\n\n                def callback(result: object):\n                    running_executions.pop(node_id)\n                    nonlocal exec_stats\n                    if isinstance(result, dict):\n                        exec_stats[\"node_count\"] += 1\n                        exec_stats[\"nodes_cputime\"] += result.get(\"cputime\", 0)\n                        exec_stats[\"nodes_walltime\"] += result.get(\"walltime\", 0)\n\n                return callback\n\n            while not queue.empty():\n                if cancel.is_set():\n                    error = RuntimeError(\"Execution is cancelled\")\n                    return exec_stats, error\n\n                exec_data = queue.get()\n\n                # Avoid parallel execution of the same node.\n                execution = running_executions.get(exec_data.node_id)\n                if execution and not execution.ready():\n                    # TODO (performance improvement):\n                    #   Wait for the completion of the same node execution is blocking.\n                    #   To improve this we need a separate queue for each node.\n                    #   Re-enqueueing the data back to the queue will disrupt the order.\n                    execution.wait()\n\n                log_metadata.debug(\n                    f\"Dispatching node execution {exec_data.node_exec_id} \"\n                    f\"for node {exec_data.node_id}\",\n                )\n                running_executions[exec_data.node_id] = cls.executor.apply_async(\n                    cls.on_node_execution,\n                    (queue, exec_data),\n                    callback=make_exec_callback(exec_data),\n                )\n\n                # Avoid terminating graph execution when some nodes are still running.\n                while queue.empty() and running_executions:\n                    log_metadata.debug(\n                        f\"Queue empty; running nodes: {list(running_executions.keys())}\"\n                    )\n                    for node_id, execution in list(running_executions.items()):\n                        if cancel.is_set():\n                            error = RuntimeError(\"Execution is cancelled\")\n                            return exec_stats, error\n\n                        if not queue.empty():\n                            break  # yield to parent loop to execute new queue items\n\n                        log_metadata.debug(f\"Waiting on execution of node {node_id}\")\n                        execution.wait(3)\n\n            log_metadata.info(f\"Finished graph execution {graph_exec.graph_exec_id}\")",
                  "successors": []
                },
                {
                  "id": 5,
                  "start_line": 703,
                  "end_line": 707,
                  "label": "except Exception as e:\n            log_metadata.exception(\n                f\"Failed graph execution {graph_exec.graph_exec_id}: {e}\"\n            )\n            error = e",
                  "successors": []
                },
                {
                  "id": 6,
                  "start_line": 708,
                  "end_line": 713,
                  "label": "finally:\n            if not cancel.is_set():\n                finished = True\n                cancel.set()\n            cancel_thread.join()\n            return exec_stats, error",
                  "successors": []
                }
              ]
            }
          ]
        }
      ],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 433,
          "line": "class Executor:"
        },
        {
          "lineno": 434,
          "line": "    \"\"\""
        },
        {
          "lineno": 435,
          "line": "    This class contains event handlers for the process pool executor events."
        },
        {
          "lineno": 436,
          "line": ""
        },
        {
          "lineno": 437,
          "line": "    The main events are:"
        },
        {
          "lineno": 438,
          "line": "        on_node_executor_start: Initialize the process that executes the node."
        },
        {
          "lineno": 439,
          "line": "        on_node_execution: Execution logic for a node."
        },
        {
          "lineno": 440,
          "line": ""
        },
        {
          "lineno": 441,
          "line": "        on_graph_executor_start: Initialize the process that executes the graph."
        },
        {
          "lineno": 442,
          "line": "        on_graph_execution: Execution logic for a graph."
        },
        {
          "lineno": 443,
          "line": ""
        },
        {
          "lineno": 444,
          "line": "    The execution flow:"
        },
        {
          "lineno": 445,
          "line": "        1. Graph execution request is added to the queue."
        },
        {
          "lineno": 446,
          "line": "        2. Graph executor loop picks the request from the queue."
        },
        {
          "lineno": 447,
          "line": "        3. Graph executor loop submits the graph execution request to the executor pool."
        },
        {
          "lineno": 448,
          "line": "      [on_graph_execution]"
        },
        {
          "lineno": 449,
          "line": "        4. Graph executor initialize the node execution queue."
        },
        {
          "lineno": 450,
          "line": "        5. Graph executor adds the starting nodes to the node execution queue."
        },
        {
          "lineno": 451,
          "line": "        6. Graph executor waits for all nodes to be executed."
        },
        {
          "lineno": 452,
          "line": "      [on_node_execution]"
        },
        {
          "lineno": 453,
          "line": "        7. Node executor picks the node execution request from the queue."
        },
        {
          "lineno": 454,
          "line": "        8. Node executor executes the node."
        },
        {
          "lineno": 455,
          "line": "        9. Node executor enqueues the next executed nodes to the node execution queue."
        },
        {
          "lineno": 456,
          "line": "    \"\"\""
        },
        {
          "lineno": 457,
          "line": ""
        },
        {
          "lineno": 458,
          "line": "    @classmethod"
        },
        {
          "lineno": 473,
          "line": ""
        },
        {
          "lineno": 474,
          "line": "    @classmethod"
        },
        {
          "lineno": 486,
          "line": ""
        },
        {
          "lineno": 487,
          "line": "    @classmethod"
        },
        {
          "lineno": 499,
          "line": ""
        },
        {
          "lineno": 500,
          "line": "    @classmethod"
        },
        {
          "lineno": 501,
          "line": "    @error_logged"
        },
        {
          "lineno": 527,
          "line": ""
        },
        {
          "lineno": 528,
          "line": "    @classmethod"
        },
        {
          "lineno": 529,
          "line": "    @time_measured"
        },
        {
          "lineno": 549,
          "line": "    @classmethod"
        },
        {
          "lineno": 564,
          "line": ""
        },
        {
          "lineno": 565,
          "line": "    @classmethod"
        },
        {
          "lineno": 573,
          "line": ""
        },
        {
          "lineno": 574,
          "line": "    @classmethod"
        },
        {
          "lineno": 580,
          "line": ""
        },
        {
          "lineno": 581,
          "line": "    @classmethod"
        },
        {
          "lineno": 582,
          "line": "    @error_logged"
        },
        {
          "lineno": 605,
          "line": ""
        },
        {
          "lineno": 606,
          "line": "    @classmethod"
        },
        {
          "lineno": 607,
          "line": "    @time_measured"
        }
      ],
      "blocks": []
    },
    {
      "name": "ExecutionManager",
      "type": "class",
      "start_line": 716,
      "end_line": 930,
      "functions": [
        {
          "name": "__init__",
          "type": "function",
          "start_line": 717,
          "end_line": 723,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 717,
              "line": "    def __init__(self):"
            },
            {
              "lineno": 718,
              "line": "        super().__init__()"
            },
            {
              "lineno": 719,
              "line": "        self.use_redis = True"
            },
            {
              "lineno": 720,
              "line": "        self.use_supabase = True"
            },
            {
              "lineno": 721,
              "line": "        self.pool_size = settings.config.num_graph_workers"
            },
            {
              "lineno": 722,
              "line": "        self.queue = ExecutionQueue[GraphExecutionEntry]()"
            },
            {
              "lineno": 723,
              "line": "        self.active_graph_runs: dict[str, tuple[Future, threading.Event]] = {}"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 717,
              "end_line": 723,
              "label": "    def __init__(self):\n        super().__init__()\n        self.use_redis = True\n        self.use_supabase = True\n        self.pool_size = settings.config.num_graph_workers\n        self.queue = ExecutionQueue[GraphExecutionEntry]()\n        self.active_graph_runs: dict[str, tuple[Future, threading.Event]] = {}",
              "successors": []
            }
          ]
        },
        {
          "name": "get_port",
          "type": "function",
          "start_line": 726,
          "end_line": 727,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 726,
              "line": "    def get_port(cls) -> int:"
            },
            {
              "lineno": 727,
              "line": "        return settings.config.execution_manager_port"
            }
          ],
          "blocks": []
        },
        {
          "name": "run_service",
          "type": "function",
          "start_line": 729,
          "end_line": 753,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 729,
              "line": "    def run_service(self):"
            },
            {
              "lineno": 730,
              "line": "        from backend.integrations.credentials_store import IntegrationCredentialsStore"
            },
            {
              "lineno": 731,
              "line": ""
            },
            {
              "lineno": 732,
              "line": "        self.credentials_store = IntegrationCredentialsStore()"
            },
            {
              "lineno": 733,
              "line": "        self.executor = ProcessPoolExecutor("
            },
            {
              "lineno": 734,
              "line": "            max_workers=self.pool_size,"
            },
            {
              "lineno": 735,
              "line": "            initializer=Executor.on_graph_executor_start,"
            },
            {
              "lineno": 736,
              "line": "        )"
            },
            {
              "lineno": 737,
              "line": "        sync_manager = multiprocessing.Manager()"
            },
            {
              "lineno": 738,
              "line": "        logger.info("
            },
            {
              "lineno": 739,
              "line": "            f\"[{self.service_name}] Started with max-{self.pool_size} graph workers\""
            },
            {
              "lineno": 740,
              "line": "        )"
            },
            {
              "lineno": 741,
              "line": "        while True:"
            },
            {
              "lineno": 742,
              "line": "            graph_exec_data = self.queue.get()"
            },
            {
              "lineno": 743,
              "line": "            graph_exec_id = graph_exec_data.graph_exec_id"
            },
            {
              "lineno": 744,
              "line": "            logger.debug("
            },
            {
              "lineno": 745,
              "line": "                f\"[ExecutionManager] Dispatching graph execution {graph_exec_id}\""
            },
            {
              "lineno": 746,
              "line": "            )"
            },
            {
              "lineno": 747,
              "line": "            cancel_event = sync_manager.Event()"
            },
            {
              "lineno": 748,
              "line": "            future = self.executor.submit("
            },
            {
              "lineno": 749,
              "line": "                Executor.on_graph_execution, graph_exec_data, cancel_event"
            },
            {
              "lineno": 750,
              "line": "            )"
            },
            {
              "lineno": 751,
              "line": "            self.active_graph_runs[graph_exec_id] = (future, cancel_event)"
            },
            {
              "lineno": 752,
              "line": "            future.add_done_callback("
            },
            {
              "lineno": 753,
              "line": "                lambda _: self.active_graph_runs.pop(graph_exec_id, None)"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 729,
              "end_line": 740,
              "label": "def run_service(self):\n        from backend.integrations.credentials_store import IntegrationCredentialsStore\n\n        self.credentials_store = IntegrationCredentialsStore()\n        self.executor = ProcessPoolExecutor(\n            max_workers=self.pool_size,\n            initializer=Executor.on_graph_executor_start,\n        )\n        sync_manager = multiprocessing.Manager()\n        logger.info(\n            f\"[{self.service_name}] Started with max-{self.pool_size} graph workers\"\n        )",
              "successors": [
                {
                  "id": 2,
                  "start_line": 741,
                  "end_line": 753,
                  "label": "while True:\n            graph_exec_data = self.queue.get()\n            graph_exec_id = graph_exec_data.graph_exec_id\n            logger.debug(\n                f\"[ExecutionManager] Dispatching graph execution {graph_exec_id}\"\n            )\n            cancel_event = sync_manager.Event()\n            future = self.executor.submit(\n                Executor.on_graph_execution, graph_exec_data, cancel_event\n            )\n            self.active_graph_runs[graph_exec_id] = (future, cancel_event)\n            future.add_done_callback(\n                lambda _: self.active_graph_runs.pop(graph_exec_id, None)",
                  "successors": [
                    {
                      "id": 3,
                      "start_line": 741,
                      "end_line": 741,
                      "label": "while True:",
                      "successors": [
                        {
                          "id": 4,
                          "start_line": 742,
                          "end_line": 753,
                          "label": "graph_exec_data = self.queue.get()\n            graph_exec_id = graph_exec_data.graph_exec_id\n            logger.debug(\n                f\"[ExecutionManager] Dispatching graph execution {graph_exec_id}\"\n            )\n            cancel_event = sync_manager.Event()\n            future = self.executor.submit(\n                Executor.on_graph_execution, graph_exec_data, cancel_event\n            )\n            self.active_graph_runs[graph_exec_id] = (future, cancel_event)\n            future.add_done_callback(\n                lambda _: self.active_graph_runs.pop(graph_exec_id, None)",
                          "successors": [
                            {
                              "id": 3,
                              "start_line": 741,
                              "end_line": 741,
                              "label": "while True:",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "cleanup",
          "type": "function",
          "start_line": 756,
          "end_line": 760,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 756,
              "line": "    def cleanup(self):"
            },
            {
              "lineno": 757,
              "line": "        logger.info(f\"[{__class__.__name__}] ⏳ Shutting down graph executor pool...\")"
            },
            {
              "lineno": 758,
              "line": "        self.executor.shutdown(cancel_futures=True)"
            },
            {
              "lineno": 759,
              "line": ""
            },
            {
              "lineno": 760,
              "line": "        super().cleanup()"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 756,
              "end_line": 760,
              "label": "    def cleanup(self):\n        logger.info(f\"[{__class__.__name__}] \\\\u23f3 Shutting down graph executor pool...\")\n        self.executor.shutdown(cancel_futures=True)\n        \n        super().cleanup()",
              "successors": []
            }
          ]
        },
        {
          "name": "db_client",
          "type": "function",
          "start_line": 763,
          "end_line": 764,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 763,
              "line": "    def db_client(self) -> \"DatabaseManager\":"
            },
            {
              "lineno": 764,
              "line": "        return get_db_client()"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 763,
              "end_line": 764,
              "label": "    def db_client(self) -> \"DatabaseManager\":\n        return get_db_client()",
              "successors": []
            }
          ]
        },
        {
          "name": "add_execution",
          "type": "function",
          "start_line": 767,
          "end_line": 848,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 767,
              "line": "    def add_execution("
            },
            {
              "lineno": 768,
              "line": "        self,"
            },
            {
              "lineno": 769,
              "line": "        graph_id: str,"
            },
            {
              "lineno": 770,
              "line": "        data: BlockInput,"
            },
            {
              "lineno": 771,
              "line": "        user_id: str,"
            },
            {
              "lineno": 772,
              "line": "        graph_version: int | None = None,"
            },
            {
              "lineno": 773,
              "line": "    ) -> GraphExecutionEntry:"
            },
            {
              "lineno": 774,
              "line": "        graph: GraphModel | None = self.db_client.get_graph("
            },
            {
              "lineno": 775,
              "line": "            graph_id=graph_id, user_id=user_id, version=graph_version"
            },
            {
              "lineno": 776,
              "line": "        )"
            },
            {
              "lineno": 777,
              "line": "        if not graph:"
            },
            {
              "lineno": 778,
              "line": "            raise ValueError(f\"Graph #{graph_id} not found.\")"
            },
            {
              "lineno": 779,
              "line": ""
            },
            {
              "lineno": 780,
              "line": "        graph.validate_graph(for_run=True)"
            },
            {
              "lineno": 781,
              "line": "        self._validate_node_input_credentials(graph, user_id)"
            },
            {
              "lineno": 782,
              "line": ""
            },
            {
              "lineno": 783,
              "line": "        nodes_input = []"
            },
            {
              "lineno": 784,
              "line": "        for node in graph.starting_nodes:"
            },
            {
              "lineno": 785,
              "line": "            input_data = {}"
            },
            {
              "lineno": 786,
              "line": "            block = get_block(node.block_id)"
            },
            {
              "lineno": 787,
              "line": ""
            },
            {
              "lineno": 788,
              "line": "            # Invalid block & Note block should never be executed."
            },
            {
              "lineno": 789,
              "line": "            if not block or block.block_type == BlockType.NOTE:"
            },
            {
              "lineno": 790,
              "line": "                continue"
            },
            {
              "lineno": 791,
              "line": ""
            },
            {
              "lineno": 792,
              "line": "            # Extract request input data, and assign it to the input pin."
            },
            {
              "lineno": 793,
              "line": "            if block.block_type == BlockType.INPUT:"
            },
            {
              "lineno": 794,
              "line": "                name = node.input_default.get(\"name\")"
            },
            {
              "lineno": 795,
              "line": "                if name and name in data:"
            },
            {
              "lineno": 796,
              "line": "                    input_data = {\"value\": data[name]}"
            },
            {
              "lineno": 797,
              "line": ""
            },
            {
              "lineno": 798,
              "line": "            # Extract webhook payload, and assign it to the input pin"
            },
            {
              "lineno": 799,
              "line": "            webhook_payload_key = f\"webhook_{node.webhook_id}_payload\""
            },
            {
              "lineno": 800,
              "line": "            if ("
            },
            {
              "lineno": 801,
              "line": "                block.block_type in (BlockType.WEBHOOK, BlockType.WEBHOOK_MANUAL)"
            },
            {
              "lineno": 802,
              "line": "                and node.webhook_id"
            },
            {
              "lineno": 803,
              "line": "            ):"
            },
            {
              "lineno": 804,
              "line": "                if webhook_payload_key not in data:"
            },
            {
              "lineno": 805,
              "line": "                    raise ValueError("
            },
            {
              "lineno": 806,
              "line": "                        f\"Node {block.name} #{node.id} webhook payload is missing\""
            },
            {
              "lineno": 807,
              "line": "                    )"
            },
            {
              "lineno": 808,
              "line": "                input_data = {\"payload\": data[webhook_payload_key]}"
            },
            {
              "lineno": 809,
              "line": ""
            },
            {
              "lineno": 810,
              "line": "            input_data, error = validate_exec(node, input_data)"
            },
            {
              "lineno": 811,
              "line": "            if input_data is None:"
            },
            {
              "lineno": 812,
              "line": "                raise ValueError(error)"
            },
            {
              "lineno": 813,
              "line": "            else:"
            },
            {
              "lineno": 814,
              "line": "                nodes_input.append((node.id, input_data))"
            },
            {
              "lineno": 815,
              "line": ""
            },
            {
              "lineno": 816,
              "line": "        graph_exec_id, node_execs = self.db_client.create_graph_execution("
            },
            {
              "lineno": 817,
              "line": "            graph_id=graph_id,"
            },
            {
              "lineno": 818,
              "line": "            graph_version=graph.version,"
            },
            {
              "lineno": 819,
              "line": "            nodes_input=nodes_input,"
            },
            {
              "lineno": 820,
              "line": "            user_id=user_id,"
            },
            {
              "lineno": 821,
              "line": "        )"
            },
            {
              "lineno": 822,
              "line": ""
            },
            {
              "lineno": 823,
              "line": "        starting_node_execs = []"
            },
            {
              "lineno": 824,
              "line": "        for node_exec in node_execs:"
            },
            {
              "lineno": 825,
              "line": "            starting_node_execs.append("
            },
            {
              "lineno": 826,
              "line": "                NodeExecutionEntry("
            },
            {
              "lineno": 827,
              "line": "                    user_id=user_id,"
            },
            {
              "lineno": 828,
              "line": "                    graph_exec_id=node_exec.graph_exec_id,"
            },
            {
              "lineno": 829,
              "line": "                    graph_id=node_exec.graph_id,"
            },
            {
              "lineno": 830,
              "line": "                    node_exec_id=node_exec.node_exec_id,"
            },
            {
              "lineno": 831,
              "line": "                    node_id=node_exec.node_id,"
            },
            {
              "lineno": 832,
              "line": "                    data=node_exec.input_data,"
            },
            {
              "lineno": 833,
              "line": "                )"
            },
            {
              "lineno": 834,
              "line": "            )"
            },
            {
              "lineno": 835,
              "line": "            exec_update = self.db_client.update_execution_status("
            },
            {
              "lineno": 836,
              "line": "                node_exec.node_exec_id, ExecutionStatus.QUEUED, node_exec.input_data"
            },
            {
              "lineno": 837,
              "line": "            )"
            },
            {
              "lineno": 838,
              "line": "            self.db_client.send_execution_update(exec_update)"
            },
            {
              "lineno": 839,
              "line": ""
            },
            {
              "lineno": 840,
              "line": "        graph_exec = GraphExecutionEntry("
            },
            {
              "lineno": 841,
              "line": "            user_id=user_id,"
            },
            {
              "lineno": 842,
              "line": "            graph_id=graph_id,"
            },
            {
              "lineno": 843,
              "line": "            graph_exec_id=graph_exec_id,"
            },
            {
              "lineno": 844,
              "line": "            start_node_execs=starting_node_execs,"
            },
            {
              "lineno": 845,
              "line": "        )"
            },
            {
              "lineno": 846,
              "line": "        self.queue.add(graph_exec)"
            },
            {
              "lineno": 847,
              "line": ""
            },
            {
              "lineno": 848,
              "line": "        return graph_exec"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 767,
              "end_line": 776,
              "label": "    def add_execution(\n        self,\n        graph_id: str,\n        data: BlockInput,\n        user_id: str,\n        graph_version: int | None = None,\n    ) -> GraphExecutionEntry:\n        graph: GraphModel | None = self.db_client.get_graph(\n            graph_id=graph_id, user_id=user_id, version=graph_version\n        )",
              "successors": [
                {
                  "id": 2,
                  "start_line": 777,
                  "end_line": 778,
                  "label": "        if not graph:\n            raise ValueError(f\"Graph #{graph_id} not found.\")",
                  "successors": [
                    {
                      "id": 3,
                      "start_line": 780,
                      "end_line": 781,
                      "label": "        graph.validate_graph(for_run=True)\n        self._validate_node_input_credentials(graph, user_id)",
                      "successors": [
                        {
                          "id": 4,
                          "start_line": 783,
                          "end_line": 784,
                          "label": "        nodes_input = []\n        for node in graph.starting_nodes:",
                          "successors": [
                            {
                              "id": 5,
                              "start_line": 785,
                              "end_line": 786,
                              "label": "            input_data = {}\n            block = get_block(node.block_id)",
                              "successors": [
                                {
                                  "id": 6,
                                  "start_line": 789,
                                  "end_line": 790,
                                  "label": "            if not block or block.block_type == BlockType.NOTE:\n                continue",
                                  "successors": [
                                    {
                                      "id": 7,
                                      "start_line": 792,
                                      "end_line": 796,
                                      "label": "            if block.block_type == BlockType.INPUT:\n                name = node.input_default.get(\"name\")\n                if name and name in data:\n                    input_data = {\"value\": data[name]}",
                                      "successors": [
                                        {
                                          "id": 8,
                                          "start_line": 799,
                                          "end_line": 808,
                                          "label": "            webhook_payload_key = f\"webhook_{node.webhook_id}_payload\"\n            if (\n                block.block_type in (BlockType.WEBHOOK, BlockType.WEBHOOK_MANUAL)\n                and node.webhook_id\n            ):\n                if webhook_payload_key not in data:\n                    raise ValueError(\n                        f\"Node {block.name} #{node.id} webhook payload is missing\"\n                    )\n                input_data = {\"payload\": data[webhook_payload_key]}",
                                          "successors": [
                                            {
                                              "id": 9,
                                              "start_line": 810,
                                              "end_line": 814,
                                              "label": "            input_data, error = validate_exec(node, input_data)\n            if input_data is None:\n                raise ValueError(error)\n            else:\n                nodes_input.append((node.id, input_data))",
                                              "successors": [
                                                {
                                                  "id": 10,
                                                  "start_line": 816,
                                                  "end_line": 821,
                                                  "label": "        graph_exec_id, node_execs = self.db_client.create_graph_execution(\n            graph_id=graph_id,\n            graph_version=graph.version,\n            nodes_input=nodes_input,\n            user_id=user_id,\n        )",
                                                  "successors": [
                                                    {
                                                      "id": 11,
                                                      "start_line": 823,
                                                      "end_line": 838,
                                                      "label": "        starting_node_execs = []\n        for node_exec in node_execs:\n            starting_node_execs.append(\n                NodeExecutionEntry(\n                    user_id=user_id,\n                    graph_exec_id=node_exec.graph_exec_id,\n                    graph_id=node_exec.graph_id,\n                    node_exec_id=node_exec.node_exec_id,\n                    node_id=node_exec.node_id,\n                    data=node_exec.input_data,\n                )\n            )\n            exec_update = self.db_client.update_execution_status(\n                node_exec.node_exec_id, ExecutionStatus.QUEUED, node_exec.input_data\n            )\n            self.db_client.send_execution_update(exec_update)",
                                                      "successors": [
                                                        {
                                                          "id": 12,
                                                          "start_line": 840,
                                                          "end_line": 846,
                                                          "label": "        graph_exec = GraphExecutionEntry(\n            user_id=user_id,\n            graph_id=graph_id,\n            graph_exec_id=graph_exec_id,\n            start_node_execs=starting_node_execs,\n        )\n        self.queue.add(graph_exec)",
                                                          "successors": [
                                                            {
                                                              "id": 13,
                                                              "start_line": 848,
                                                              "end_line": 848,
                                                              "label": "        return graph_exec",
                                                              "successors": []
                                                            }
                                                          ]
                                                        }
                                                      ]
                                                    }
                                                  ]
                                                }
                                              ]
                                            }
                                          ]
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "cancel_execution",
          "type": "function",
          "start_line": 851,
          "end_line": 885,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 851,
              "line": "    def cancel_execution(self, graph_exec_id: str) -> None:"
            },
            {
              "lineno": 852,
              "line": "        \"\"\""
            },
            {
              "lineno": 853,
              "line": "        Mechanism:"
            },
            {
              "lineno": 854,
              "line": "        1. Set the cancel event"
            },
            {
              "lineno": 855,
              "line": "        2. Graph executor's cancel handler thread detects the event, terminates workers,"
            },
            {
              "lineno": 856,
              "line": "           reinitializes worker pool, and returns."
            },
            {
              "lineno": 857,
              "line": "        3. Update execution statuses in DB and set `error` outputs to `\"TERMINATED\"`."
            },
            {
              "lineno": 858,
              "line": "        \"\"\""
            },
            {
              "lineno": 859,
              "line": "        if graph_exec_id not in self.active_graph_runs:"
            },
            {
              "lineno": 860,
              "line": "            raise Exception("
            },
            {
              "lineno": 861,
              "line": "                f\"Graph execution #{graph_exec_id} not active/running: \""
            },
            {
              "lineno": 862,
              "line": "                \"possibly already completed/cancelled.\""
            },
            {
              "lineno": 863,
              "line": "            )"
            },
            {
              "lineno": 864,
              "line": ""
            },
            {
              "lineno": 865,
              "line": "        future, cancel_event = self.active_graph_runs[graph_exec_id]"
            },
            {
              "lineno": 866,
              "line": "        if cancel_event.is_set():"
            },
            {
              "lineno": 867,
              "line": "            return"
            },
            {
              "lineno": 868,
              "line": ""
            },
            {
              "lineno": 869,
              "line": "        cancel_event.set()"
            },
            {
              "lineno": 870,
              "line": "        future.result()"
            },
            {
              "lineno": 871,
              "line": ""
            },
            {
              "lineno": 872,
              "line": "        # Update the status of the unfinished node executions"
            },
            {
              "lineno": 873,
              "line": "        node_execs = self.db_client.get_execution_results(graph_exec_id)"
            },
            {
              "lineno": 874,
              "line": "        for node_exec in node_execs:"
            },
            {
              "lineno": 875,
              "line": "            if node_exec.status not in ("
            },
            {
              "lineno": 876,
              "line": "                ExecutionStatus.COMPLETED,"
            },
            {
              "lineno": 877,
              "line": "                ExecutionStatus.FAILED,"
            },
            {
              "lineno": 878,
              "line": "            ):"
            },
            {
              "lineno": 879,
              "line": "                self.db_client.upsert_execution_output("
            },
            {
              "lineno": 880,
              "line": "                    node_exec.node_exec_id, \"error\", \"TERMINATED\""
            },
            {
              "lineno": 881,
              "line": "                )"
            },
            {
              "lineno": 882,
              "line": "                exec_update = self.db_client.update_execution_status("
            },
            {
              "lineno": 883,
              "line": "                    node_exec.node_exec_id, ExecutionStatus.FAILED"
            },
            {
              "lineno": 884,
              "line": "                )"
            },
            {
              "lineno": 885,
              "line": "                self.db_client.send_execution_update(exec_update)"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 851,
              "end_line": 858,
              "label": "    def cancel_execution(self, graph_exec_id: str) -> None:\n        \"\"\"\n        Mechanism:\n        1. Set the cancel event\n        2. Graph executor's cancel handler thread detects the event, terminates workers,\n           reinitializes worker pool, and returns.\n        3. Update execution statuses in DB and set `error` outputs to `\"TERMINATED\"`.\n        \"\"\"",
              "successors": [
                {
                  "id": 2,
                  "start_line": 859,
                  "end_line": 863,
                  "label": "        if graph_exec_id not in self.active_graph_runs:\n            raise Exception(\n                f\"Graph execution #{graph_exec_id} not active/running: \"\n                \"possibly already completed/cancelled.\"\n            )",
                  "successors": [
                    {
                      "id": 3,
                      "start_line": 865,
                      "end_line": 867,
                      "label": "        future, cancel_event = self.active_graph_runs[graph_exec_id]\n        if cancel_event.is_set():\n            return",
                      "successors": [
                        {
                          "id": 4,
                          "start_line": 869,
                          "end_line": 870,
                          "label": "        cancel_event.set()\n        future.result()",
                          "successors": [
                            {
                              "id": 5,
                              "start_line": 872,
                              "end_line": 885,
                              "label": "        # Update the status of the unfinished node executions\n        node_execs = self.db_client.get_execution_results(graph_exec_id)\n        for node_exec in node_execs:\n            if node_exec.status not in (\n                ExecutionStatus.COMPLETED,\n                ExecutionStatus.FAILED,\n            ):\n                self.db_client.upsert_execution_output(\n                    node_exec.node_exec_id, \"error\", \"TERMINATED\"\n                )\n                exec_update = self.db_client.update_execution_status(\n                    node_exec.node_exec_id, ExecutionStatus.FAILED\n                )\n                self.db_client.send_execution_update(exec_update)",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "_validate_node_input_credentials",
          "type": "function",
          "start_line": 887,
          "end_line": 930,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 887,
              "line": "    def _validate_node_input_credentials(self, graph: GraphModel, user_id: str):"
            },
            {
              "lineno": 888,
              "line": "        \"\"\"Checks all credentials for all nodes of the graph\"\"\""
            },
            {
              "lineno": 889,
              "line": ""
            },
            {
              "lineno": 890,
              "line": "        for node in graph.nodes:"
            },
            {
              "lineno": 891,
              "line": "            block = get_block(node.block_id)"
            },
            {
              "lineno": 892,
              "line": "            if not block:"
            },
            {
              "lineno": 893,
              "line": "                raise ValueError(f\"Unknown block {node.block_id} for node #{node.id}\")"
            },
            {
              "lineno": 894,
              "line": ""
            },
            {
              "lineno": 895,
              "line": "            # Find any fields of type CredentialsMetaInput"
            },
            {
              "lineno": 896,
              "line": "            model_fields = cast(type[BaseModel], block.input_schema).model_fields"
            },
            {
              "lineno": 897,
              "line": "            if CREDENTIALS_FIELD_NAME not in model_fields:"
            },
            {
              "lineno": 898,
              "line": "                continue"
            },
            {
              "lineno": 899,
              "line": ""
            },
            {
              "lineno": 900,
              "line": "            field = model_fields[CREDENTIALS_FIELD_NAME]"
            },
            {
              "lineno": 901,
              "line": ""
            },
            {
              "lineno": 902,
              "line": "            # The BlockSchema class enforces that a `credentials` field is always a"
            },
            {
              "lineno": 903,
              "line": "            # `CredentialsMetaInput`, so we can safely assume this here."
            },
            {
              "lineno": 904,
              "line": "            credentials_meta_type = cast(CredentialsMetaInput, field.annotation)"
            },
            {
              "lineno": 905,
              "line": "            credentials_meta = credentials_meta_type.model_validate("
            },
            {
              "lineno": 906,
              "line": "                node.input_default[CREDENTIALS_FIELD_NAME]"
            },
            {
              "lineno": 907,
              "line": "            )"
            },
            {
              "lineno": 908,
              "line": "            # Fetch the corresponding Credentials and perform sanity checks"
            },
            {
              "lineno": 909,
              "line": "            credentials = self.credentials_store.get_creds_by_id("
            },
            {
              "lineno": 910,
              "line": "                user_id, credentials_meta.id"
            },
            {
              "lineno": 911,
              "line": "            )"
            },
            {
              "lineno": 912,
              "line": "            if not credentials:"
            },
            {
              "lineno": 913,
              "line": "                raise ValueError("
            },
            {
              "lineno": 914,
              "line": "                    f\"Unknown credentials #{credentials_meta.id} \""
            },
            {
              "lineno": 915,
              "line": "                    f\"for node #{node.id}\""
            },
            {
              "lineno": 916,
              "line": "                )"
            },
            {
              "lineno": 917,
              "line": "            if ("
            },
            {
              "lineno": 918,
              "line": "                credentials.provider != credentials_meta.provider"
            },
            {
              "lineno": 919,
              "line": "                or credentials.type != credentials_meta.type"
            },
            {
              "lineno": 920,
              "line": "            ):"
            },
            {
              "lineno": 921,
              "line": "                logger.warning("
            },
            {
              "lineno": 922,
              "line": "                    f\"Invalid credentials #{credentials.id} for node #{node.id}: \""
            },
            {
              "lineno": 923,
              "line": "                    \"type/provider mismatch: \""
            },
            {
              "lineno": 924,
              "line": "                    f\"{credentials_meta.type}<>{credentials.type};\""
            },
            {
              "lineno": 925,
              "line": "                    f\"{credentials_meta.provider}<>{credentials.provider}\""
            },
            {
              "lineno": 926,
              "line": "                )"
            },
            {
              "lineno": 927,
              "line": "                raise ValueError("
            },
            {
              "lineno": 928,
              "line": "                    f\"Invalid credentials #{credentials.id} for node #{node.id}: \""
            },
            {
              "lineno": 929,
              "line": "                    \"type/provider mismatch\""
            },
            {
              "lineno": 930,
              "line": "                )"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 887,
              "end_line": 889,
              "label": [
                "    def _validate_node_input_credentials(self, graph: GraphModel, user_id: str):",
                "        \"\"\"Checks all credentials for all nodes of the graph\"\"\"",
                ""
              ],
              "successors": [
                {
                  "id": 2,
                  "start_line": 890,
                  "end_line": 890,
                  "label": [
                    "        for node in graph.nodes:"
                  ],
                  "successors": [
                    {
                      "id": 3,
                      "start_line": 891,
                      "end_line": 893,
                      "label": [
                        "            block = get_block(node.block_id)",
                        "            if not block:",
                        "                raise ValueError(f\"Unknown block {node.block_id} for node #{node.id}\")"
                      ],
                      "successors": [
                        {
                          "id": 4,
                          "start_line": 895,
                          "end_line": 898,
                          "label": [
                            "            # Find any fields of type CredentialsMetaInput",
                            "            model_fields = cast(type[BaseModel], block.input_schema).model_fields",
                            "            if CREDENTIALS_FIELD_NAME not in model_fields:",
                            "                continue"
                          ],
                          "successors": [
                            {
                              "id": 5,
                              "start_line": 900,
                              "end_line": 916,
                              "label": [
                                "            field = model_fields[CREDENTIALS_FIELD_NAME]",
                                "",
                                "            # The BlockSchema class enforces that a `credentials` field is always a",
                                "            # `CredentialsMetaInput`, so we can safely assume this here.",
                                "            credentials_meta_type = cast(CredentialsMetaInput, field.annotation)",
                                "            credentials_meta = credentials_meta_type.model_validate(",
                                "                node.input_default[CREDENTIALS_FIELD_NAME]",
                                "            )",
                                "            # Fetch the corresponding Credentials and perform sanity checks",
                                "            credentials = self.credentials_store.get_creds_by_id(",
                                "                user_id, credentials_meta.id",
                                "            )",
                                "            if not credentials:",
                                "                raise ValueError(",
                                "                    f\"Unknown credentials #{credentials_meta.id} \"",
                                "                    f\"for node #{node.id}\"",
                                "                )"
                              ],
                              "successors": [
                                {
                                  "id": 6,
                                  "start_line": 917,
                                  "end_line": 930,
                                  "label": [
                                    "            if (",
                                    "                credentials.provider != credentials_meta.provider",
                                    "                or credentials.type != credentials_meta.type",
                                    "            ):",
                                    "                logger.warning(",
                                    "                    f\"Invalid credentials #{credentials.id} for node #{node.id}: \"",
                                    "                    \"type/provider mismatch: \"",
                                    "                    f\"{credentials_meta.type}<>{credentials.type};\"",
                                    "                    f\"{credentials_meta.provider}<>{credentials.provider}\"",
                                    "                )",
                                    "                raise ValueError(",
                                    "                    f\"Invalid credentials #{credentials.id} for node #{node.id}: \"",
                                    "                    \"type/provider mismatch\"",
                                    "                )"
                                  ],
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 716,
          "line": "class ExecutionManager(AppService):"
        },
        {
          "lineno": 724,
          "line": ""
        },
        {
          "lineno": 725,
          "line": "    @classmethod"
        },
        {
          "lineno": 728,
          "line": ""
        },
        {
          "lineno": 754,
          "line": "            )"
        },
        {
          "lineno": 755,
          "line": ""
        },
        {
          "lineno": 761,
          "line": ""
        },
        {
          "lineno": 762,
          "line": "    @property"
        },
        {
          "lineno": 765,
          "line": ""
        },
        {
          "lineno": 766,
          "line": "    @expose"
        },
        {
          "lineno": 849,
          "line": ""
        },
        {
          "lineno": 850,
          "line": "    @expose"
        },
        {
          "lineno": 886,
          "line": ""
        }
      ],
      "blocks": [
        {
          "id": 1,
          "start_line": 716,
          "end_line": 716,
          "label": "class ExecutionManager(AppService):",
          "successors": []
        },
        {
          "id": 2,
          "start_line": 724,
          "end_line": 724,
          "label": "",
          "successors": []
        },
        {
          "id": 3,
          "start_line": 725,
          "end_line": 725,
          "label": "    @classmethod",
          "successors": []
        },
        {
          "id": 4,
          "start_line": 728,
          "end_line": 728,
          "label": "",
          "successors": []
        },
        {
          "id": 5,
          "start_line": 754,
          "end_line": 754,
          "label": "            )",
          "successors": []
        },
        {
          "id": 6,
          "start_line": 755,
          "end_line": 755,
          "label": "",
          "successors": []
        },
        {
          "id": 7,
          "start_line": 761,
          "end_line": 761,
          "label": "",
          "successors": []
        },
        {
          "id": 8,
          "start_line": 762,
          "end_line": 762,
          "label": "    @property",
          "successors": []
        },
        {
          "id": 9,
          "start_line": 765,
          "end_line": 765,
          "label": "",
          "successors": []
        },
        {
          "id": 10,
          "start_line": 766,
          "end_line": 766,
          "label": "    @expose",
          "successors": []
        },
        {
          "id": 11,
          "start_line": 849,
          "end_line": 849,
          "label": "",
          "successors": []
        },
        {
          "id": 12,
          "start_line": 850,
          "end_line": 850,
          "label": "    @expose",
          "successors": []
        },
        {
          "id": 13,
          "start_line": 886,
          "end_line": 886,
          "label": "",
          "successors": []
        }
      ]
    }
  ],
  "simplified_code": [
    {
      "lineno": 1,
      "line": "import atexit"
    },
    {
      "lineno": 2,
      "line": "import logging"
    },
    {
      "lineno": 3,
      "line": "import multiprocessing"
    },
    {
      "lineno": 4,
      "line": "import os"
    },
    {
      "lineno": 5,
      "line": "import signal"
    },
    {
      "lineno": 6,
      "line": "import sys"
    },
    {
      "lineno": 7,
      "line": "import threading"
    },
    {
      "lineno": 8,
      "line": "from concurrent.futures import Future, ProcessPoolExecutor"
    },
    {
      "lineno": 9,
      "line": "from contextlib import contextmanager"
    },
    {
      "lineno": 10,
      "line": "from multiprocessing.pool import AsyncResult, Pool"
    },
    {
      "lineno": 11,
      "line": "from typing import TYPE_CHECKING, Any, Generator, TypeVar, cast"
    },
    {
      "lineno": 12,
      "line": ""
    },
    {
      "lineno": 13,
      "line": "from pydantic import BaseModel"
    },
    {
      "lineno": 14,
      "line": "from redis.lock import Lock as RedisLock"
    },
    {
      "lineno": 15,
      "line": ""
    },
    {
      "lineno": 16,
      "line": "if TYPE_CHECKING:"
    },
    {
      "lineno": 17,
      "line": "    from backend.executor import DatabaseManager"
    },
    {
      "lineno": 18,
      "line": ""
    },
    {
      "lineno": 19,
      "line": "from autogpt_libs.utils.cache import thread_cached"
    },
    {
      "lineno": 20,
      "line": ""
    },
    {
      "lineno": 21,
      "line": "from backend.blocks.agent import AgentExecutorBlock"
    },
    {
      "lineno": 22,
      "line": "from backend.data import redis"
    },
    {
      "lineno": 23,
      "line": "from backend.data.block import Block, BlockData, BlockInput, BlockType, get_block"
    },
    {
      "lineno": 24,
      "line": "from backend.data.execution import ("
    },
    {
      "lineno": 25,
      "line": "    ExecutionQueue,"
    },
    {
      "lineno": 26,
      "line": "    ExecutionResult,"
    },
    {
      "lineno": 27,
      "line": "    ExecutionStatus,"
    },
    {
      "lineno": 28,
      "line": "    GraphExecutionEntry,"
    },
    {
      "lineno": 29,
      "line": "    NodeExecutionEntry,"
    },
    {
      "lineno": 30,
      "line": "    merge_execution_input,"
    },
    {
      "lineno": 31,
      "line": "    parse_execution_output,"
    },
    {
      "lineno": 32,
      "line": ")"
    },
    {
      "lineno": 33,
      "line": "from backend.data.graph import GraphModel, Link, Node"
    },
    {
      "lineno": 34,
      "line": "from backend.data.model import CREDENTIALS_FIELD_NAME, CredentialsMetaInput"
    },
    {
      "lineno": 35,
      "line": "from backend.integrations.creds_manager import IntegrationCredentialsManager"
    },
    {
      "lineno": 36,
      "line": "from backend.util import json"
    },
    {
      "lineno": 37,
      "line": "from backend.util.decorator import error_logged, time_measured"
    },
    {
      "lineno": 38,
      "line": "from backend.util.logging import configure_logging"
    },
    {
      "lineno": 39,
      "line": "from backend.util.process import set_service_name"
    },
    {
      "lineno": 40,
      "line": "from backend.util.service import ("
    },
    {
      "lineno": 41,
      "line": "    AppService,"
    },
    {
      "lineno": 42,
      "line": "    close_service_client,"
    },
    {
      "lineno": 43,
      "line": "    expose,"
    },
    {
      "lineno": 44,
      "line": "    get_service_client,"
    },
    {
      "lineno": 45,
      "line": ")"
    },
    {
      "lineno": 46,
      "line": "from backend.util.settings import Settings"
    },
    {
      "lineno": 47,
      "line": "from backend.util.type import convert"
    },
    {
      "lineno": 48,
      "line": ""
    },
    {
      "lineno": 49,
      "line": "logger = logging.getLogger(__name__)"
    },
    {
      "lineno": 50,
      "line": "settings = Settings()"
    },
    {
      "lineno": 51,
      "line": ""
    },
    {
      "lineno": 52,
      "line": ""
    },
    {
      "lineno": 96,
      "line": ""
    },
    {
      "lineno": 97,
      "line": ""
    },
    {
      "lineno": 98,
      "line": "T = TypeVar(\"T\")"
    },
    {
      "lineno": 99,
      "line": "ExecutionStream = Generator[NodeExecutionEntry, None, None]"
    },
    {
      "lineno": 100,
      "line": ""
    },
    {
      "lineno": 101,
      "line": ""
    },
    {
      "lineno": 246,
      "line": ""
    },
    {
      "lineno": 361,
      "line": ""
    },
    {
      "lineno": 362,
      "line": ""
    },
    {
      "lineno": 431,
      "line": ""
    },
    {
      "lineno": 432,
      "line": ""
    },
    {
      "lineno": 714,
      "line": ""
    },
    {
      "lineno": 715,
      "line": ""
    },
    {
      "lineno": 931,
      "line": ""
    },
    {
      "lineno": 932,
      "line": ""
    },
    {
      "lineno": 933,
      "line": "# ------- UTILITIES ------- #"
    },
    {
      "lineno": 934,
      "line": ""
    },
    {
      "lineno": 935,
      "line": ""
    },
    {
      "lineno": 941,
      "line": ""
    },
    {
      "lineno": 942,
      "line": ""
    },
    {
      "lineno": 952,
      "line": ""
    },
    {
      "lineno": 953,
      "line": ""
    }
  ],
  "blocks": [
    {
      "id": 1,
      "start_line": 1,
      "end_line": 15,
      "label": "import atexit\nimport logging\nimport multiprocessing\nimport os\nimport signal\nimport sys\nimport threading\nfrom concurrent.futures import Future, ProcessPoolExecutor\nfrom contextlib import contextmanager\nfrom multiprocessing.pool import AsyncResult, Pool\nfrom typing import TYPE_CHECKING, Any, Generator, TypeVar, cast",
      "successors": [
        {
          "id": 2,
          "start_line": 16,
          "end_line": 17,
          "label": "if TYPE_CHECKING:\n    from backend.executor import DatabaseManager",
          "successors": [
            {
              "id": 3,
              "start_line": 19,
              "end_line": 47,
              "label": "from autogpt_libs.utils.cache import thread_cached\nfrom backend.blocks.agent import AgentExecutorBlock\nfrom backend.data import redis\nfrom backend.data.block import Block, BlockData, BlockInput, BlockType, get_block\nfrom backend.data.execution import (\n    ExecutionQueue,\n    ExecutionResult,\n    ExecutionStatus,\n    GraphExecutionEntry,\n    NodeExecutionEntry,\n    merge_execution_input,\n    parse_execution_output,\n)\nfrom backend.data.graph import GraphModel, Link, Node\nfrom backend.data.model import CREDENTIALS_FIELD_NAME, CredentialsMetaInput\nfrom backend.integrations.creds_manager import IntegrationCredentialsManager\nfrom backend.util import json\nfrom backend.util.decorator import error_logged, time_measured\nfrom backend.util.logging import configure_logging\nfrom backend.util.process import set_service_name\nfrom backend.util.service import (\n    AppService,\n    close_service_client,\n    expose,\n    get_service_client,\n)\nfrom backend.util.settings import Settings\nfrom backend.util.type import convert",
              "successors": [
                {
                  "id": 4,
                  "start_line": 49,
                  "end_line": 50,
                  "label": "logger = logging.getLogger(__name__)\nsettings = Settings()",
                  "successors": [
                    {
                      "id": 5,
                      "start_line": 98,
                      "end_line": 99,
                      "label": "T = TypeVar(\"T\")\nExecutionStream = Generator[NodeExecutionEntry, None, None]",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    }
  ]
}