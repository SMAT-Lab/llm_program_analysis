{
  "name": "example_script",
  "type": "CFG",
  "blocks": [
    {
      "id": 1,
      "start_line": 1,
      "end_line": 47,
      "label": "import asyncio\nimport builtins\nimport logging\nimport os\nimport threading\nimport time\nimport typing\nfrom abc import ABC, abstractmethod\nfrom enum import Enum\nfrom types import NoneType, UnionType\nfrom typing import (\n    Annotated,\n    Any,\n    Awaitable,\n    Callable,\n    Coroutine,\n    Dict,\n    FrozenSet,\n    Iterator,\n    List,\n    Set,\n    Tuple,\n    Type,\n    TypeVar,\n    Union,\n    cast,\n    get_args,\n    get_origin,\n)\nimport Pyro5.api\nfrom pydantic import BaseModel\nfrom Pyro5 import api as pyro\nfrom Pyro5 import config as pyro_config\nfrom backend.data import db, redis\nfrom backend.util.process import AppProcess\nfrom backend.util.retry import conn_retry\nfrom backend.util.settings import Config, Secrets\nlogger = logging.getLogger(__name__)\nT = TypeVar(\"T\")\nC = TypeVar(\"C\", bound=Callable)\nconfig = Config()\npyro_host = config.pyro_host\npyro_config.MAX_RETRIES = config.pyro_client_comm_retry  # type: ignore\npyro_config.COMMTIMEOUT = config.pyro_client_comm_timeout  # type: ignore\n# --------- UTILITIES --------- #\nAS = TypeVar(\"AS\", bound=AppService)\nbuiltin_types = [*vars(builtins).values(), NoneType, Enum]",
      "successors": []
    }
  ],
  "functions": [
    {
      "name": "expose",
      "type": "CFG",
      "blocks": [],
      "functions": [],
      "classes": []
    },
    {
      "name": "register_pydantic_serializers",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 3,
          "end_line": 3,
          "label": "for name, annotation in func.__annotations__.items():",
          "successors": [
            {
              "id": 2,
              "start_line": 4,
              "end_line": 4,
              "label": "try:",
              "successors": [
                {
                  "id": 3,
                  "start_line": 5,
                  "end_line": 5,
                  "label": "pydantic_types = _pydantic_models_from_type_annotation(annotation)",
                  "successors": []
                },
                {
                  "id": 4,
                  "start_line": 6,
                  "end_line": 7,
                  "label": "except Exception as e:\n            raise TypeError(f\"Error while exposing {func.__name__}: {e.__str__()}\")",
                  "successors": []
                }
              ]
            },
            {
              "id": 5,
              "start_line": 8,
              "end_line": 8,
              "label": "for model in pydantic_types:",
              "successors": [
                {
                  "id": 6,
                  "start_line": 9,
                  "end_line": 16,
                  "label": "logger.debug(\n                f\"Registering Pyro (de)serializers for {func.__name__} annotation \"\n                f\"'{name}': {model.__qualname__}\"\n            )\n            pyro.register_class_to_dict(model, _make_custom_serializer(model))\n            pyro.register_dict_to_class(\n                model.__qualname__, _make_custom_deserializer(model)\n            )",
                  "successors": []
                }
              ]
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "_make_custom_serializer",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 1,
          "label": "def _make_custom_serializer(model: Type[BaseModel]):",
          "successors": [
            {
              "id": 2,
              "start_line": 2,
              "end_line": 9,
              "label": "def custom_class_to_dict(obj):\n        data = {\n            \"__class__\": obj.__class__.__qualname__,\n            **obj.model_dump(),\n        }\n        logger.debug(f\"Serializing {obj.__class__.__qualname__} with data: {data}\")\n        return data\n    return custom_class_to_dict",
              "successors": []
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "_make_custom_deserializer",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 1,
          "label": "def _make_custom_deserializer(model: Type[BaseModel]):",
          "successors": [
            {
              "id": 2,
              "start_line": 2,
              "end_line": 5,
              "label": "def custom_dict_to_class(qualname, data: dict):\n        logger.debug(f\"Deserializing {model.__qualname__} from data: {data}\")\n        return model(**data)\n    return custom_dict_to_class",
              "successors": []
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "close_service_client",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 2,
          "label": "def close_service_client(client: AppService) -> None:\n    if isinstance(client, PyroClient):",
          "successors": [
            {
              "id": 2,
              "start_line": 3,
              "end_line": 3,
              "label": "client.proxy._pyroRelease()",
              "successors": []
            },
            {
              "id": 3,
              "start_line": 5,
              "end_line": 5,
              "label": "raise RuntimeError(f\"Client {client.__class__} is not a Pyro client.\")",
              "successors": []
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "get_service_client",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 2,
          "label": "def get_service_client(service_type: Type[AS]) -> AS:\n    service_name = service_type.service_name",
          "successors": []
        }
      ],
      "functions": [],
      "classes": [
        {
          "name": "DynamicClient",
          "type": "CFG",
          "blocks": [],
          "functions": [
            {
              "name": "__init__",
              "type": "CFG",
              "blocks": [
                {
                  "id": 1,
                  "start_line": 1,
                  "end_line": 8,
                  "label": "def __init__(self):\n            host = os.environ.get(f\"{service_name.upper()}_HOST\", pyro_host)\n            uri = f\"PYRO:{service_type.service_name}@{host}:{service_type.get_port()}\"\n            logger.debug(f\"Connecting to service [{service_name}]. URI = {uri}\")\n            self.proxy = Pyro5.api.Proxy(uri)\n            # Attempt to bind to ensure the connection is established\n            self.proxy._pyroBind()\n            logger.debug(f\"Successfully connected to service [{service_name}]\")",
                  "successors": []
                }
              ],
              "functions": [],
              "classes": []
            },
            {
              "name": "__getattr__",
              "type": "CFG",
              "blocks": [
                {
                  "id": 1,
                  "start_line": 1,
                  "end_line": 3,
                  "label": "def __getattr__(self, name: str) -> Callable[..., Any]:\n            res = getattr(self.proxy, name)\n            return res",
                  "successors": []
                }
              ],
              "functions": [],
              "classes": []
            }
          ],
          "classes": []
        }
      ]
    },
    {
      "name": "_pydantic_models_from_type_annotation",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 3,
          "label": "def _pydantic_models_from_type_annotation(annotation) -> Iterator[type[BaseModel]]:\n    # Peel Annotated parameters\n    if (origin := get_origin(annotation)) and origin is Annotated:",
          "successors": [
            {
              "id": 2,
              "start_line": 4,
              "end_line": 4,
              "label": "annotation = get_args(annotation)[0]",
              "successors": []
            }
          ]
        },
        {
          "id": 3,
          "start_line": 5,
          "end_line": 6,
          "label": "origin = get_origin(annotation)\n    args = get_args(annotation)",
          "successors": [
            {
              "id": 4,
              "start_line": 7,
              "end_line": 18,
              "label": "if origin in (\n        Union,\n        UnionType,\n        list,\n        List,\n        tuple,\n        Tuple,\n        set,\n        Set,\n        frozenset,\n        FrozenSet,\n    ):",
              "successors": [
                {
                  "id": 5,
                  "start_line": 19,
                  "end_line": 20,
                  "label": "for arg in args:\n            yield from _pydantic_models_from_type_annotation(arg)",
                  "successors": []
                }
              ]
            },
            {
              "id": 6,
              "start_line": 21,
              "end_line": 24,
              "label": "elif origin in (dict, Dict):\n        key_type, value_type = args\n        yield from _pydantic_models_from_type_annotation(key_type)\n        yield from _pydantic_models_from_type_annotation(value_type)",
              "successors": []
            },
            {
              "id": 7,
              "start_line": 25,
              "end_line": 28,
              "label": "elif origin in (Awaitable, Coroutine):\n        # For coroutines and awaitables, check the return type\n        return_type = args[-1]\n        yield from _pydantic_models_from_type_annotation(return_type)",
              "successors": []
            },
            {
              "id": 8,
              "start_line": 29,
              "end_line": 36,
              "label": "else:\n        annotype = annotation if origin is None else origin\n        # Exclude generic types and aliases\n        if (\n            annotype is not None\n            and not hasattr(typing, getattr(annotype, \"__name__\", \"\"))\n            and isinstance(annotype, type)\n        ):",
              "successors": [
                {
                  "id": 9,
                  "start_line": 37,
                  "end_line": 38,
                  "label": "if issubclass(annotype, BaseModel):\n                yield annotype",
                  "successors": []
                },
                {
                  "id": 10,
                  "start_line": 39,
                  "end_line": 40,
                  "label": "elif annotype not in builtin_types and not issubclass(annotype, Enum):\n                raise TypeError(f\"Unsupported type encountered: {annotype}\")",
                  "successors": []
                }
              ]
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    }
  ],
  "classes": [
    {
      "name": "AppService",
      "type": "CFG",
      "blocks": [],
      "functions": [
        {
          "name": "__init__",
          "type": "CFG",
          "blocks": [
            {
              "id": 1,
              "start_line": 1,
              "end_line": 2,
              "label": "def __init__(self):\n        self.uri = None",
              "successors": []
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "get_port",
          "type": "CFG",
          "blocks": [
            {
              "id": 1,
              "start_line": 1,
              "end_line": 2,
              "label": "def get_port(cls) -> int:\n        pass",
              "successors": []
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "get_host",
          "type": "CFG",
          "blocks": [
            {
              "id": 1,
              "start_line": 1,
              "end_line": 2,
              "label": "def get_host(cls) -> str:\n        return os.environ.get(f\"{cls.service_name.upper()}_HOST\", config.pyro_host)",
              "successors": []
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "run_service",
          "type": "CFG",
          "blocks": [
            {
              "id": 1,
              "start_line": 2,
              "end_line": 2,
              "label": "while True:",
              "successors": [
                {
                  "id": 2,
                  "start_line": 3,
                  "end_line": 3,
                  "label": "time.sleep(10)",
                  "successors": []
                }
              ]
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "__run_async",
          "type": "CFG",
          "blocks": [
            {
              "id": 1,
              "start_line": 1,
              "end_line": 2,
              "label": "def __run_async(self, coro: Coroutine[Any, Any, T]):\n        return asyncio.run_coroutine_threadsafe(coro, self.shared_event_loop)",
              "successors": []
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "run_and_wait",
          "type": "CFG",
          "blocks": [
            {
              "id": 1,
              "start_line": 1,
              "end_line": 3,
              "label": "def run_and_wait(self, coro: Coroutine[Any, Any, T]) -> T:\n        future = self.__run_async(coro)\n        return future.result()",
              "successors": []
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "run",
          "type": "CFG",
          "blocks": [
            {
              "id": 1,
              "start_line": 1,
              "end_line": 3,
              "label": "def run(self):\n        self.shared_event_loop = asyncio.get_event_loop()\n        if self.use_db:",
              "successors": [
                {
                  "id": 2,
                  "start_line": 4,
                  "end_line": 4,
                  "label": "self.shared_event_loop.run_until_complete(db.connect())",
                  "successors": []
                },
                {
                  "id": 3,
                  "start_line": 5,
                  "end_line": 5,
                  "label": "if self.use_redis:",
                  "successors": [
                    {
                      "id": 4,
                      "start_line": 6,
                      "end_line": 6,
                      "label": "redis.connect()",
                      "successors": []
                    }
                  ]
                },
                {
                  "id": 5,
                  "start_line": 7,
                  "end_line": 7,
                  "label": "if self.use_supabase:",
                  "successors": [
                    {
                      "id": 6,
                      "start_line": 8,
                      "end_line": 12,
                      "label": "from supabase import create_client\n            secrets = Secrets()\n            self.supabase = create_client(\n                secrets.supabase_url, secrets.supabase_service_role_key\n            )",
                      "successors": []
                    }
                  ]
                }
              ]
            },
            {
              "id": 7,
              "start_line": 13,
              "end_line": 16,
              "label": "# Initialize the async loop.\n        async_thread = threading.Thread(target=self.__start_async_loop)\n        async_thread.daemon = True\n        async_thread.start()",
              "successors": []
            },
            {
              "id": 8,
              "start_line": 17,
              "end_line": 20,
              "label": "# Initialize pyro service\n        daemon_thread = threading.Thread(target=self.__start_pyro)\n        daemon_thread.daemon = True\n        daemon_thread.start()",
              "successors": []
            },
            {
              "id": 9,
              "start_line": 21,
              "end_line": 22,
              "label": "# Run the main service (if it's not implemented, just sleep).\n        self.run_service()",
              "successors": []
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "cleanup",
          "type": "CFG",
          "blocks": [
            {
              "id": 1,
              "start_line": 2,
              "end_line": 2,
              "label": "if self.use_db:",
              "successors": [
                {
                  "id": 2,
                  "start_line": 3,
                  "end_line": 4,
                  "label": "logger.info(f\"[{self.__class__.__name__}] \u23f3 Disconnecting DB...\")\n            self.run_and_wait(db.disconnect())",
                  "successors": []
                }
              ]
            },
            {
              "id": 3,
              "start_line": 5,
              "end_line": 5,
              "label": "if self.use_redis:",
              "successors": [
                {
                  "id": 4,
                  "start_line": 6,
                  "end_line": 7,
                  "label": "logger.info(f\"[{self.__class__.__name__}] \u23f3 Disconnecting Redis...\")\n            redis.disconnect()",
                  "successors": []
                }
              ]
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "__start_pyro",
          "type": "CFG",
          "blocks": [
            {
              "id": 1,
              "start_line": 1,
              "end_line": 10,
              "label": "def __start_pyro(self):\n        maximum_connection_thread_count = max(\n            Pyro5.config.THREADPOOL_SIZE,\n            config.num_node_workers * config.num_graph_workers,\n        )\n        Pyro5.config.THREADPOOL_SIZE = maximum_connection_thread_count  # type: ignore\n        daemon = Pyro5.api.Daemon(host=config.pyro_host, port=self.get_port())\n        self.uri = daemon.register(self, objectId=self.service_name)\n        logger.info(f\"[{self.service_name}] Connected to Pyro; URI = {self.uri}\")\n        daemon.requestLoop()",
              "successors": []
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "__start_async_loop",
          "type": "CFG",
          "blocks": [
            {
              "id": 1,
              "start_line": 1,
              "end_line": 2,
              "label": "def __start_async_loop(self):\n        self.shared_event_loop.run_forever()",
              "successors": []
            }
          ],
          "functions": [],
          "classes": []
        }
      ],
      "classes": []
    },
    {
      "name": "PyroClient",
      "type": "CFG",
      "blocks": [],
      "functions": [],
      "classes": []
    }
  ]
}