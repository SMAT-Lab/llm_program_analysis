{
  "name": "example_script",
  "type": "CFG",
  "blocks": [
    {
      "id": 1,
      "start_line": 1,
      "end_line": 11,
      "label": "import logging\nimport pytest\nfrom prisma.models import User\nfrom backend.blocks.basic import FindInDictionaryBlock, StoreValueBlock\nfrom backend.blocks.maths import CalculatorBlock, Operation\nfrom backend.data import execution, graph\nfrom backend.server.model import CreateGraph\nfrom backend.server.rest_api import AgentServer\nfrom backend.usecases.sample import create_test_graph, create_test_user\nfrom backend.util.test import SpinTestServer, wait_execution\nlogger = logging.getLogger(__name__)",
      "successors": []
    }
  ],
  "functions": [
    {
      "name": "create_graph",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 3,
          "label": "async def create_graph(s: SpinTestServer, g: graph.Graph, u: User) -> graph.Graph:\n    logger.info(f\"Creating graph for user {u.id}\")\n    return await s.agent_server.test_create_graph(CreateGraph(graph=g), u.id)",
          "successors": []
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "execute_graph",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 8,
          "end_line": 9,
          "label": "logger.info(f\"Executing graph {test_graph.id} for user {test_user.id}\")\n    logger.info(f\"Input data: {input_data}\")",
          "successors": [
            {
              "id": 2,
              "start_line": 11,
              "end_line": 13,
              "label": "response = await agent_server.test_execute_graph(\n        test_graph.id, input_data, test_user.id\n    )",
              "successors": [
                {
                  "id": 3,
                  "start_line": 14,
                  "end_line": 15,
                  "label": "graph_exec_id = response[\"id\"]\n    logger.info(f\"Created execution with ID: {graph_exec_id}\")",
                  "successors": [
                    {
                      "id": 4,
                      "start_line": 17,
                      "end_line": 18,
                      "label": "logger.info(\"Waiting for execution to complete...\")\n    result = await wait_execution(test_user.id, test_graph.id, graph_exec_id)",
                      "successors": [
                        {
                          "id": 5,
                          "start_line": 19,
                          "end_line": 21,
                          "label": "logger.info(f\"Execution completed with {len(result)} results\")\n    assert result and len(result) == num_execs\n    return graph_exec_id",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "assert_sample_graph_executions",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 13,
          "label": "async def assert_sample_graph_executions(\n    agent_server: AgentServer,\n    test_graph: graph.Graph,\n    test_user: User,\n    graph_exec_id: str,\n):\n    logger.info(f\"Checking execution results for graph {test_graph.id}\")\n    executions = await agent_server.test_get_graph_run_node_execution_results(\n        test_graph.id,\n        graph_exec_id,\n        test_user.id,\n    )\n    output_list = [{\"result\": [\"Hello\"]}, {\"result\": [\"World\"]}]",
          "successors": [
            {
              "id": 2,
              "start_line": 14,
              "end_line": 23,
              "label": "input_list = [\n        {\n            \"name\": \"input_1\",\n            \"value\": \"Hello\",\n        },\n        {\n            \"name\": \"input_2\",\n            \"value\": \"World\",\n        },\n    ]",
              "successors": [
                {
                  "id": 3,
                  "start_line": 24,
                  "end_line": 35,
                  "label": "# Executing StoreValueBlock\n    exec = executions[0]\n    logger.info(f\"Checking first StoreValueBlock execution: {exec}\")\n    assert exec.status == execution.ExecutionStatus.COMPLETED\n    assert exec.graph_exec_id == graph_exec_id\n    assert (\n        exec.output_data in output_list\n    ), f\"Output data: {exec.output_data} and {output_list}\"\n    assert (\n        exec.input_data in input_list\n    ), f\"Input data: {exec.input_data} and {input_list}\"\n    assert exec.node_id in [test_graph.nodes[0].id, test_graph.nodes[1].id]",
                  "successors": [
                    {
                      "id": 4,
                      "start_line": 36,
                      "end_line": 47,
                      "label": "# Executing StoreValueBlock\n    exec = executions[1]\n    logger.info(f\"Checking second StoreValueBlock execution: {exec}\")\n    assert exec.status == execution.ExecutionStatus.COMPLETED\n    assert exec.graph_exec_id == graph_exec_id\n    assert (\n        exec.output_data in output_list\n    ), f\"Output data: {exec.output_data} and {output_list}\"\n    assert (\n        exec.input_data in input_list\n    ), f\"Input data: {exec.input_data} and {input_list}\"\n    assert exec.node_id in [test_graph.nodes[0].id, test_graph.nodes[1].id]",
                      "successors": [
                        {
                          "id": 5,
                          "start_line": 48,
                          "end_line": 61,
                          "label": "# Executing FillTextTemplateBlock\n    exec = executions[2]\n    logger.info(f\"Checking FillTextTemplateBlock execution: {exec}\")\n    assert exec.status == execution.ExecutionStatus.COMPLETED\n    assert exec.graph_exec_id == graph_exec_id\n    assert exec.output_data == {\"output\": [\"Hello, World!!!\"]}\n    assert exec.input_data == {\n        \"format\": \"{a}, {b}{c}\",\n        \"values\": {\"a\": \"Hello\", \"b\": \"World\", \"c\": \"!!!\"},\n        \"values_#_a\": \"Hello\",\n        \"values_#_b\": \"World\",\n        \"values_#_c\": \"!!!\",\n    }\n    assert exec.node_id == test_graph.nodes[2].id",
                          "successors": [
                            {
                              "id": 6,
                              "start_line": 62,
                              "end_line": 69,
                              "label": "# Executing PrintToConsoleBlock\n    exec = executions[3]\n    logger.info(f\"Checking PrintToConsoleBlock execution: {exec}\")\n    assert exec.status == execution.ExecutionStatus.COMPLETED\n    assert exec.graph_exec_id == graph_exec_id\n    assert exec.output_data == {\"status\": [\"printed\"]}\n    assert exec.input_data == {\"text\": \"Hello, World!!!\"}\n    assert exec.node_id == test_graph.nodes[3].id",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "test_agent_execution",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 16,
          "label": "async def test_agent_execution(server: SpinTestServer):\n    logger.info(\"Starting test_agent_execution\")\n    test_user = await create_test_user()\n    test_graph = await create_graph(server, create_test_graph(), test_user)\n    data = {\"input_1\": \"Hello\", \"input_2\": \"World\"}\n    graph_exec_id = await execute_graph(\n        server.agent_server,\n        test_graph,\n        test_user,\n        data,\n        4,\n    )\n    await assert_sample_graph_executions(\n        server.agent_server, test_graph, test_user, graph_exec_id\n    )\n    logger.info(\"Completed test_agent_execution\")",
          "successors": []
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "test_input_pin_always_waited",
      "type": "CFG",
      "blocks": [],
      "functions": [],
      "classes": []
    },
    {
      "name": "test_static_input_link_on_graph",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 13,
          "label": "async def test_static_input_link_on_graph(server: SpinTestServer):\n    \"\"\"\n    This test is asserting the behaviour of static input link, e.g: reusable input link.\n    Test scenario:\n    *StoreValueBlock1*===a=========\\\\\n    *StoreValueBlock2*===a=====\\\\  ||\n    *StoreValueBlock3*===a===*MathBlock*====b / static====*StoreValueBlock5*\n    *StoreValueBlock4*=========================================//\n    In this test, there will be three input waiting in the MathBlock input pin `a`.\n    And later, another output is produced on input pin `b`, which is a static link,\n    this input will complete the input of those three incomplete executions.\n    \"\"\"\n    logger.info(\"Starting test_static_input_link_on_graph\")",
          "successors": [
            {
              "id": 2,
              "start_line": 14,
              "end_line": 24,
              "label": "nodes = [\n        graph.Node(block_id=StoreValueBlock().id, input_default={\"input\": 4}),  # a\n        graph.Node(block_id=StoreValueBlock().id, input_default={\"input\": 4}),  # a\n        graph.Node(block_id=StoreValueBlock().id, input_default={\"input\": 4}),  # a\n        graph.Node(block_id=StoreValueBlock().id, input_default={\"input\": 5}),  # b\n        graph.Node(block_id=StoreValueBlock().id),\n        graph.Node(\n            block_id=CalculatorBlock().id,\n            input_default={\"operation\": Operation.ADD.value},\n        ),\n    ]",
              "successors": []
            },
            {
              "id": 3,
              "start_line": 25,
              "end_line": 57,
              "label": "links = [\n        graph.Link(\n            source_id=nodes[0].id,\n            sink_id=nodes[5].id,\n            source_name=\"output\",\n            sink_name=\"a\",\n        ),\n        graph.Link(\n            source_id=nodes[1].id,\n            sink_id=nodes[5].id,\n            source_name=\"output\",\n            sink_name=\"a\",\n        ),\n        graph.Link(\n            source_id=nodes[2].id,\n            sink_id=nodes[5].id,\n            source_name=\"output\",\n            sink_name=\"a\",\n        ),\n        graph.Link(\n            source_id=nodes[3].id,\n            sink_id=nodes[4].id,\n            source_name=\"output\",\n            sink_name=\"input\",\n        ),\n        graph.Link(\n            source_id=nodes[4].id,\n            sink_id=nodes[5].id,\n            source_name=\"output\",\n            sink_name=\"b\",\n            is_static=True,  # This is the static link to test.\n        ),\n    ]",
              "successors": []
            },
            {
              "id": 4,
              "start_line": 58,
              "end_line": 68,
              "label": "test_graph = graph.Graph(\n        name=\"TestGraph\",\n        description=\"Test graph\",\n        nodes=nodes,\n        links=links,\n    )\n    test_user = await create_test_user()\n    test_graph = await create_graph(server, test_graph, test_user)\n    graph_exec_id = await execute_graph(\n        server.agent_server, test_graph, test_user, {}, 8\n    )",
              "successors": []
            },
            {
              "id": 5,
              "start_line": 69,
              "end_line": 79,
              "label": "logger.info(\"Checking execution results\")\n    executions = await server.agent_server.test_get_graph_run_node_execution_results(\n        test_graph.id, graph_exec_id, test_user.id\n    )\n    assert len(executions) == 8\n    # The last 3 executions will be a+b=4+5=9\n    logger.info(\"Completed test_static_input_link_on_graph\")",
              "successors": [
                {
                  "id": 6,
                  "start_line": 75,
                  "end_line": 78,
                  "label": "for i, exec_data in enumerate(executions[-3:]):\n        logger.info(f\"Checking execution {i+1} of last 3: {exec_data}\")\n        assert exec_data.status == execution.ExecutionStatus.COMPLETED\n        assert exec_data.output_data == {\"result\": [9]}",
                  "successors": []
                }
              ]
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    }
  ],
  "classes": []
}