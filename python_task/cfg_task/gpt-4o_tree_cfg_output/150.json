{
  "name": "example_script",
  "type": "CFG",
  "blocks": [
    {
      "id": 1,
      "start_line": 53,
      "end_line": 54,
      "label": "from __future__ import annotations\nif __name__ == \"__main__\":",
      "successors": [
        {
          "id": 2,
          "start_line": 55,
          "end_line": 57,
          "label": "import doctest\n    doctest.testmod()\n    n_queens_solution(4)",
          "successors": []
        }
      ]
    }
  ],
  "functions": [
    {
      "name": "depth_first_search",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 19,
          "label": "def depth_first_search(\n    possible_board: list[int],\n    diagonal_right_collisions: list[int],\n    diagonal_left_collisions: list[int],\n    boards: list[list[str]],\n    n: int,\n) -> None:\n    \"\"\"\n    >>> boards = []\n    >>> depth_first_search([], [], [], boards, 4)\n    >>> for board in boards:\n    ...     print(board)\n    ['. Q . . ', '. . . Q ', 'Q . . . ', '. . Q . ']\n    ['. . Q . ', 'Q . . . ', '. . . Q ', '. Q . . ']\n    \"\"\"\n    # Get next row in the current board (possible_board) to fill it with a queen\n    row = len(possible_board)\n    # If row is equal to the size of the board it means there are a queen in each row in\n    # the current board (possible_board)",
          "successors": [
            {
              "id": 2,
              "start_line": 20,
              "end_line": 24,
              "label": "if row == n:\n        # We convert the variable possible_board that looks like this: [1, 3, 0, 2] to\n        # this: ['. Q . . ', '. . . Q ', 'Q . . . ', '. . Q . ']\n        boards.append([\". \" * i + \"Q \" + \". \" * (n - 1 - i) for i in possible_board])\n        return",
              "successors": []
            },
            {
              "id": 3,
              "start_line": 25,
              "end_line": 53,
              "label": "# We iterate each column in the row to find all possible results in each row\n    for col in range(n):\n        # We apply that we learned previously. First we check that in the current board\n        # (possible_board) there are not other same value because if there is it means\n        # that there are a collision in vertical. Then we apply the two formulas we\n        # learned before:\n        #\n        # 45\u00ba: y - x = b or 45: row - col = b\n        # 135\u00ba: y + x = b or row + col = b.\n        #\n        # And we verify if the results of this two formulas not exist in their variables\n        # respectively.  (diagonal_right_collisions, diagonal_left_collisions)\n        #\n        # If any or these are True it means there is a collision so we continue to the\n        # next value in the for loop.",
              "successors": [
                {
                  "id": 4,
                  "start_line": 40,
                  "end_line": 45,
                  "label": "if (\n            col in possible_board\n            or row - col in diagonal_right_collisions\n            or row + col in diagonal_left_collisions\n        ):\n            continue",
                  "successors": []
                },
                {
                  "id": 5,
                  "start_line": 46,
                  "end_line": 53,
                  "label": "# If it is False we call dfs function again and we update the inputs\n        depth_first_search(\n            [*possible_board, col],\n            [*diagonal_right_collisions, row - col],\n            [*diagonal_left_collisions, row + col],\n            boards,\n            n,\n        )",
                  "successors": []
                }
              ]
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "n_queens_solution",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 5,
          "end_line": 5,
          "label": "for board in boards:",
          "successors": [
            {
              "id": 2,
              "start_line": 6,
              "end_line": 8,
              "label": "for column in board:\n            print(column)\n        print(\"\")",
              "successors": []
            }
          ]
        },
        {
          "id": 3,
          "start_line": 9,
          "end_line": 9,
          "label": "print(len(boards), \"solutions were found.\")",
          "successors": []
        }
      ],
      "functions": [],
      "classes": []
    }
  ],
  "classes": []
}