{
  "name": "example_script",
  "type": "CFG",
  "blocks": [
    {
      "id": 1,
      "start_line": 1,
      "end_line": 7,
      "label": "\"\"\"\nThe nqueens problem is of placing N queens on a N * N\nchess board such that no queen can attack any other queens placed\non that chess board.\nThis means that one queen cannot have any other queen on its horizontal, vertical and\ndiagonal lines.\n\"\"\"",
      "successors": []
    },
    {
      "id": 2,
      "start_line": 8,
      "end_line": 14,
      "label": "from __future__ import annotations\nsolution = []\n# Number of queens (e.g., n=8 for an 8x8 board)\nn = 8\nboard = [[0 for i in range(n)] for j in range(n)]\nsolve(board, 0)\nprint(\"The total number of solutions are:\", len(solution))",
      "successors": []
    }
  ],
  "functions": [
    {
      "name": "is_safe",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 25,
          "label": "def is_safe(board: list[list[int]], row: int, column: int) -> bool:\n    \"\"\"\n    This function returns a boolean value True if it is safe to place a queen there\n    considering the current state of the board.\n    Parameters:\n    board (2D matrix): The chessboard\n    row, column: Coordinates of the cell on the board\n    Returns:\n    Boolean Value\n    >>> is_safe([[0, 0, 0], [0, 0, 0], [0, 0, 0]], 1, 1)\n    True\n    >>> is_safe([[1, 0, 0], [0, 0, 0], [0, 0, 0]], 1, 1)\n    False\n    \"\"\"\n    n = len(board)  # Size of the board\n    # Check if there is any queen in the same row, column,\n    # left upper diagonal, and right upper diagonal\n    return (\n        all(board[i][j] != 1 for i, j in zip(range(row, -1, -1), range(column, n)))\n        and all(\n            board[i][j] != 1 for i, j in zip(range(row, -1, -1), range(column, -1, -1))\n        )\n        and all(board[i][j] != 1 for i, j in zip(range(row, n), range(column, n)))\n        and all(board[i][j] != 1 for i, j in zip(range(row, n), range(column, -1, -1)))\n    )",
          "successors": []
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "solve",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 7,
          "label": "def solve(board: list[list[int]], row: int) -> bool:\n    \"\"\"\n    This function creates a state space tree and calls the safe function until it\n    receives a False Boolean and terminates that branch and backtracks to the next\n    possible solution branch.\n    \"\"\"\n    if row >= len(board):",
          "successors": [
            {
              "id": 2,
              "start_line": 8,
              "end_line": 15,
              "label": "\"\"\"\n        If the row number exceeds N, we have a board with a successful combination\n        and that combination is appended to the solution list and the board is printed.\n        \"\"\"\n        solution.append(board)\n        printboard(board)\n        print()\n        return True",
              "successors": []
            },
            {
              "id": 3,
              "start_line": 16,
              "end_line": 27,
              "label": "for i in range(len(board)):\n        \"\"\"\n        For every row, it iterates through each column to check if it is feasible to\n        place a queen there.\n        If all the combinations for that particular branch are successful, the board is\n        reinitialized for the next possible combination.\n        \"\"\"\n    return False",
              "successors": [
                {
                  "id": 4,
                  "start_line": 23,
                  "end_line": 26,
                  "label": "if is_safe(board, row, i):\n            board[row][i] = 1\n            solve(board, row + 1)\n            board[row][i] = 0",
                  "successors": []
                }
              ]
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "printboard",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 5,
          "end_line": 5,
          "label": "for i in range(len(board)):",
          "successors": [
            {
              "id": 2,
              "start_line": 6,
              "end_line": 6,
              "label": "for j in range(len(board)):",
              "successors": [
                {
                  "id": 3,
                  "start_line": 7,
                  "end_line": 7,
                  "label": "if board[i][j] == 1:",
                  "successors": [
                    {
                      "id": 4,
                      "start_line": 8,
                      "end_line": 8,
                      "label": "print(\"Q\", end=\" \")  # Queen is present",
                      "successors": []
                    },
                    {
                      "id": 5,
                      "start_line": 9,
                      "end_line": 10,
                      "label": "else:\n                print(\".\", end=\" \")  # Empty cell",
                      "successors": []
                    }
                  ]
                }
              ]
            },
            {
              "id": 6,
              "start_line": 11,
              "end_line": 11,
              "label": "print()",
              "successors": []
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    }
  ],
  "classes": []
}