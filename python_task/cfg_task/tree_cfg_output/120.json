{
  "name": "example_script",
  "type": "CFG",
  "blocks": [
    {
      "id": 1,
      "start_line": 1,
      "end_line": 35,
      "label": "import inspect\nfrom abc import ABC, abstractmethod\nfrom enum import Enum\nfrom typing import (\n    Any,\n    ClassVar,\n    Generator,\n    Generic,\n    Optional,\n    Type,\n    TypeVar,\n    cast,\n    get_origin,\n)\nimport jsonref\nimport jsonschema\nfrom prisma.models import AgentBlock\nfrom pydantic import BaseModel\nfrom backend.util import json\nfrom backend.util.settings import Config\nfrom .model import (\n    CREDENTIALS_FIELD_NAME,\n    ContributorDetails,\n    Credentials,\n    CredentialsMetaInput,\n)\napp_config = Config()\nBlockData = tuple[str, Any]  # Input & Output data should be a tuple of (name, data).\nBlockInput = dict[str, Any]  # Input: 1 input pin consumes 1 data.\nBlockOutput = Generator[BlockData, None, None]  # Output: 1 output pin produces n data.\nCompletedBlockOutput = dict[str, list[Any]]  # Completed stream, collected as a dict.\nBlockSchemaInputType = TypeVar(\"BlockSchemaInputType\", bound=BlockSchema)\nBlockSchemaOutputType = TypeVar(\"BlockSchemaOutputType\", bound=BlockSchema)\n# --8<-- [start:BlockWebhookConfig]\n# ======================= Block Helper Functions ======================= #",
      "successors": []
    }
  ],
  "functions": [
    {
      "name": "dict",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 1,
          "label": "def dict(self) -> dict[str, str]:",
          "successors": [
            {
              "id": 2,
              "start_line": 2,
              "end_line": 2,
              "label": "return {\"category\": self.name, \"description\": self.value}",
              "successors": []
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "jsonschema",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 1,
          "label": "def jsonschema(cls) -> dict[str, Any]:",
          "successors": [
            {
              "id": 2,
              "start_line": 2,
              "end_line": 2,
              "label": "if cls.cached_jsonschema:",
              "successors": [
                {
                  "id": 3,
                  "start_line": 3,
                  "end_line": 3,
                  "label": "return cls.cached_jsonschema",
                  "successors": []
                },
                {
                  "id": 4,
                  "start_line": 4,
                  "end_line": 4,
                  "label": "model = jsonref.replace_refs(cls.model_json_schema(), merge_props=True)",
                  "successors": [
                    {
                      "id": 5,
                      "start_line": 5,
                      "end_line": 5,
                      "label": "cls.cached_jsonschema = cast(dict[str, Any], ref_to_dict(model))",
                      "successors": [
                        {
                          "id": 6,
                          "start_line": 6,
                          "end_line": 6,
                          "label": "# Set default properties values",
                          "successors": [
                            {
                              "id": 7,
                              "start_line": 7,
                              "end_line": 7,
                              "label": "for field in cls.cached_jsonschema.get(\"properties\", {}).values():",
                              "successors": [
                                {
                                  "id": 8,
                                  "start_line": 8,
                                  "end_line": 8,
                                  "label": "if isinstance(field, dict) and \"advanced\" not in field:",
                                  "successors": [
                                    {
                                      "id": 9,
                                      "start_line": 9,
                                      "end_line": 9,
                                      "label": "field[\"advanced\"] = True",
                                      "successors": []
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "ref_to_dict",
          "type": "CFG",
          "blocks": [
            {
              "id": 1,
              "start_line": 1,
              "end_line": 1,
              "label": "def ref_to_dict(obj):",
              "successors": [
                {
                  "id": 2,
                  "start_line": 2,
                  "end_line": 2,
                  "label": "if isinstance(obj, dict):",
                  "successors": [
                    {
                      "id": 3,
                      "start_line": 3,
                      "end_line": 6,
                      "label": "# OpenAPI <3.1 does not support sibling fields that has a $ref key\n                # So sometimes, the schema has an \"allOf\"/\"anyOf\"/\"oneOf\" with 1 item.\n                keys = {\"allOf\", \"anyOf\", \"oneOf\"}\n                one_key = next((k for k in keys if k in obj and len(obj[k]) == 1), None)",
                      "successors": [
                        {
                          "id": 4,
                          "start_line": 7,
                          "end_line": 7,
                          "label": "if one_key:",
                          "successors": [
                            {
                              "id": 5,
                              "start_line": 8,
                              "end_line": 8,
                              "label": "obj.update(obj[one_key][0])",
                              "successors": [
                                {
                                  "id": 6,
                                  "start_line": 9,
                                  "end_line": 13,
                                  "label": "return {\n                    key: ref_to_dict(value)\n                    for key, value in obj.items()\n                    if not key.startswith(\"$\") and key != one_key\n                }",
                                  "successors": []
                                }
                              ]
                            },
                            {
                              "id": 7,
                              "start_line": 9,
                              "end_line": 13,
                              "label": "return {\n                    key: ref_to_dict(value)\n                    for key, value in obj.items()\n                    if not key.startswith(\"$\") and key != one_key\n                }",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "id": 8,
                      "start_line": 14,
                      "end_line": 14,
                      "label": "elif isinstance(obj, list):",
                      "successors": [
                        {
                          "id": 9,
                          "start_line": 15,
                          "end_line": 15,
                          "label": "return [ref_to_dict(item) for item in obj]",
                          "successors": []
                        }
                      ]
                    },
                    {
                      "id": 10,
                      "start_line": 16,
                      "end_line": 16,
                      "label": "return obj",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ],
          "functions": [],
          "classes": []
        }
      ],
      "classes": []
    },
    {
      "name": "validate_data",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 1,
          "label": "def validate_data(cls, data: BlockInput) -> str | None:",
          "successors": [
            {
              "id": 2,
              "start_line": 2,
              "end_line": 2,
              "label": "return json.validate_with_jsonschema(schema=cls.jsonschema(), data=data)",
              "successors": []
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "validate_field",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 6,
          "label": "def validate_field(cls, field_name: str, data: BlockInput) -> str | None:\n        \"\"\"\n        Validate the data against a specific property (one of the input/output name).\n        Returns the validation error message if the data does not match the schema.\n        \"\"\"\n        model_schema = cls.jsonschema().get(\"properties\", {})",
          "successors": [
            {
              "id": 2,
              "start_line": 7,
              "end_line": 7,
              "label": "if not model_schema:",
              "successors": [
                {
                  "id": 3,
                  "start_line": 8,
                  "end_line": 8,
                  "label": "return f\"Invalid model schema {cls}\"",
                  "successors": []
                },
                {
                  "id": 4,
                  "start_line": 9,
                  "end_line": 9,
                  "label": "property_schema = model_schema.get(field_name)",
                  "successors": [
                    {
                      "id": 5,
                      "start_line": 10,
                      "end_line": 10,
                      "label": "if not property_schema:",
                      "successors": [
                        {
                          "id": 6,
                          "start_line": 11,
                          "end_line": 11,
                          "label": "return f\"Invalid property name {field_name}\"",
                          "successors": []
                        },
                        {
                          "id": 7,
                          "start_line": 12,
                          "end_line": 12,
                          "label": "try:",
                          "successors": [
                            {
                              "id": 8,
                              "start_line": 13,
                              "end_line": 14,
                              "label": "jsonschema.validate(json.to_dict(data), property_schema)\n            return None",
                              "successors": []
                            },
                            {
                              "id": 9,
                              "start_line": 15,
                              "end_line": 16,
                              "label": "except jsonschema.ValidationError as e:\n            return str(e)",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "get_fields",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 1,
          "label": "def get_fields(cls) -> set[str]:",
          "successors": [
            {
              "id": 2,
              "start_line": 2,
              "end_line": 2,
              "label": "return set(cls.model_fields.keys())",
              "successors": []
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "get_required_fields",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 1,
          "label": "def get_required_fields(cls) -> set[str]:",
          "successors": [
            {
              "id": 2,
              "start_line": 2,
              "end_line": 6,
              "label": "return {\n            field\n            for field, field_info in cls.model_fields.items()\n            if field_info.is_required()\n        }",
              "successors": []
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "__pydantic_init_subclass__",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 6,
          "label": "def __pydantic_init_subclass__(cls, **kwargs):\n        \"\"\"Validates the schema definition. Rules:\n        - Only one `CredentialsMetaInput` field may be present.\n          - This field MUST be called `credentials`.\n        - A field that is called `credentials` MUST be a `CredentialsMetaInput`.\n        \"\"\"",
          "successors": [
            {
              "id": 2,
              "start_line": 7,
              "end_line": 9,
              "label": "super().__pydantic_init_subclass__(**kwargs)\n        # Reset cached JSON schema to prevent inheriting it from parent class\n        cls.cached_jsonschema = {}",
              "successors": [
                {
                  "id": 3,
                  "start_line": 10,
                  "end_line": 20,
                  "label": "credentials_fields = [\n            field_name\n            for field_name, info in cls.model_fields.items()\n            if (\n                inspect.isclass(info.annotation)\n                and issubclass(\n                    get_origin(info.annotation) or info.annotation,\n                    CredentialsMetaInput,\n                )\n            )\n        ]",
                  "successors": [
                    {
                      "id": 4,
                      "start_line": 21,
                      "end_line": 24,
                      "label": "if len(credentials_fields) > 1:\n            raise ValueError(\n                f\"{cls.__qualname__} can only have one CredentialsMetaInput field\"\n            )",
                      "successors": [
                        {
                          "id": 5,
                          "start_line": 25,
                          "end_line": 32,
                          "label": "elif (\n            len(credentials_fields) == 1\n            and credentials_fields[0] != CREDENTIALS_FIELD_NAME\n        ):\n            raise ValueError(\n                f\"CredentialsMetaInput field on {cls.__qualname__} \"\n                \"must be named 'credentials'\"\n            )",
                          "successors": [
                            {
                              "id": 6,
                              "start_line": 33,
                              "end_line": 40,
                              "label": "elif (\n            len(credentials_fields) == 0\n            and CREDENTIALS_FIELD_NAME in cls.model_fields.keys()\n        ):\n            raise TypeError(\n                f\"Field 'credentials' on {cls.__qualname__} \"\n                f\"must be of type {CredentialsMetaInput.__name__}\"\n            )",
                              "successors": [
                                {
                                  "id": 7,
                                  "start_line": 41,
                                  "end_line": 45,
                                  "label": "if credentials_field := cls.model_fields.get(CREDENTIALS_FIELD_NAME):\n            credentials_input_type = cast(\n                CredentialsMetaInput, credentials_field.annotation\n            )\n            credentials_input_type.validate_credentials_field_schema(cls)",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "create",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 1,
          "label": "def create(cls: Type[\"Block\"]) -> \"Block\":",
          "successors": [
            {
              "id": 2,
              "start_line": 2,
              "end_line": 2,
              "label": "return cls()",
              "successors": []
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "run",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 11,
          "label": "def run(self, input_data: BlockSchemaInputType, **kwargs) -> BlockOutput:\n        \"\"\"\n        Run the block with the given input data.\n        Args:\n            input_data: The input data with the structure of input_schema.\n        Returns:\n            A Generator that yields (output_name, output_data).\n            output_name: One of the output name defined in Block's output_schema.\n            output_data: The data for the output_name, matching the defined schema.\n        \"\"\"\n        pass",
          "successors": []
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "run_once",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 1,
          "label": "def run_once(self, input_data: BlockSchemaInputType, output: str, **kwargs) -> Any:",
          "successors": [
            {
              "id": 2,
              "start_line": 2,
              "end_line": 2,
              "label": "for name, data in self.run(input_data, **kwargs):",
              "successors": [
                {
                  "id": 3,
                  "start_line": 3,
                  "end_line": 3,
                  "label": "if name == output:",
                  "successors": [
                    {
                      "id": 4,
                      "start_line": 4,
                      "end_line": 4,
                      "label": "return data",
                      "successors": []
                    }
                  ]
                },
                {
                  "id": 5,
                  "start_line": 5,
                  "end_line": 5,
                  "label": "raise ValueError(f\"{self.name} did not produce any output for {output}\")",
                  "successors": []
                }
              ]
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "merge_stats",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 1,
          "label": "def merge_stats(self, stats: dict[str, Any]) -> dict[str, Any]:",
          "successors": [
            {
              "id": 2,
              "start_line": 2,
              "end_line": 2,
              "label": "for key, value in stats.items():",
              "successors": [
                {
                  "id": 3,
                  "start_line": 3,
                  "end_line": 3,
                  "label": "if isinstance(value, dict):",
                  "successors": [
                    {
                      "id": 4,
                      "start_line": 4,
                      "end_line": 4,
                      "label": "self.execution_stats.setdefault(key, {}).update(value)",
                      "successors": []
                    },
                    {
                      "id": 5,
                      "start_line": 5,
                      "end_line": 5,
                      "label": "elif isinstance(value, (int, float)):",
                      "successors": [
                        {
                          "id": 6,
                          "start_line": 6,
                          "end_line": 7,
                          "label": "self.execution_stats.setdefault(key, 0)\n                self.execution_stats[key] += value",
                          "successors": []
                        },
                        {
                          "id": 7,
                          "start_line": 8,
                          "end_line": 8,
                          "label": "elif isinstance(value, list):",
                          "successors": [
                            {
                              "id": 8,
                              "start_line": 9,
                              "end_line": 10,
                              "label": "self.execution_stats.setdefault(key, [])\n                self.execution_stats[key].extend(value)",
                              "successors": []
                            },
                            {
                              "id": 9,
                              "start_line": 11,
                              "end_line": 12,
                              "label": "else:\n                self.execution_stats[key] = value",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "id": 10,
          "start_line": 13,
          "end_line": 13,
          "label": "return self.execution_stats",
          "successors": []
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "name",
      "type": "CFG",
      "blocks": [],
      "functions": [],
      "classes": []
    },
    {
      "name": "to_dict",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 1,
          "label": "def to_dict(self):",
          "successors": [
            {
              "id": 2,
              "start_line": 2,
              "end_line": 14,
              "label": "return {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"inputSchema\": self.input_schema.jsonschema(),\n            \"outputSchema\": self.output_schema.jsonschema(),\n            \"description\": self.description,\n            \"categories\": [category.dict() for category in self.categories],\n            \"contributors\": [\n                contributor.model_dump() for contributor in self.contributors\n            ],\n            \"staticOutput\": self.static_output,\n            \"uiType\": self.block_type.value,\n        }",
              "successors": []
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "execute",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 1,
          "label": "def execute(self, input_data: BlockInput, **kwargs) -> BlockOutput:",
          "successors": [
            {
              "id": 2,
              "start_line": 2,
              "end_line": 2,
              "label": "if error := self.input_schema.validate_data(input_data):",
              "successors": [
                {
                  "id": 3,
                  "start_line": 3,
                  "end_line": 5,
                  "label": "raise ValueError(\n                f\"Unable to execute block with invalid input data: {error}\"\n            )",
                  "successors": []
                },
                {
                  "id": 4,
                  "start_line": 6,
                  "end_line": 8,
                  "label": "for output_name, output_data in self.run(\n            self.input_schema(**input_data), **kwargs\n        ):",
                  "successors": [
                    {
                      "id": 5,
                      "start_line": 9,
                      "end_line": 9,
                      "label": "if output_name == \"error\":",
                      "successors": [
                        {
                          "id": 6,
                          "start_line": 10,
                          "end_line": 10,
                          "label": "raise RuntimeError(output_data)",
                          "successors": []
                        },
                        {
                          "id": 7,
                          "start_line": 11,
                          "end_line": 13,
                          "label": "if self.block_type == BlockType.STANDARD and (\n                error := self.output_schema.validate_field(output_name, output_data)\n            ):",
                          "successors": [
                            {
                              "id": 8,
                              "start_line": 14,
                              "end_line": 14,
                              "label": "raise ValueError(f\"Block produced an invalid output data: {error}\")",
                              "successors": []
                            },
                            {
                              "id": 9,
                              "start_line": 15,
                              "end_line": 15,
                              "label": "yield output_name, output_data",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "get_blocks",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 1,
          "label": "def get_blocks() -> dict[str, Type[Block]]:",
          "successors": [
            {
              "id": 2,
              "start_line": 2,
              "end_line": 2,
              "label": "from backend.blocks import AVAILABLE_BLOCKS  # noqa: E402",
              "successors": [
                {
                  "id": 3,
                  "start_line": 3,
                  "end_line": 3,
                  "label": "return AVAILABLE_BLOCKS",
                  "successors": []
                }
              ]
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "initialize_blocks",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 1,
          "label": "async def initialize_blocks() -> None:",
          "successors": [
            {
              "id": 2,
              "start_line": 2,
              "end_line": 2,
              "label": "for cls in get_blocks().values():",
              "successors": [
                {
                  "id": 3,
                  "start_line": 3,
                  "end_line": 3,
                  "label": "block = cls()",
                  "successors": [
                    {
                      "id": 4,
                      "start_line": 4,
                      "end_line": 6,
                      "label": "existing_block = await AgentBlock.prisma().find_first(\n            where={\"OR\": [{\"id\": block.id}, {\"name\": block.name}]}\n        )",
                      "successors": [
                        {
                          "id": 5,
                          "start_line": 7,
                          "end_line": 7,
                          "label": "if not existing_block:",
                          "successors": [
                            {
                              "id": 6,
                              "start_line": 8,
                              "end_line": 15,
                              "label": "await AgentBlock.prisma().create(\n                data={\n                    \"id\": block.id,\n                    \"name\": block.name,\n                    \"inputSchema\": json.dumps(block.input_schema.jsonschema()),\n                    \"outputSchema\": json.dumps(block.output_schema.jsonschema()),\n                }\n            )",
                              "successors": [
                                {
                                  "id": 7,
                                  "start_line": 16,
                                  "end_line": 16,
                                  "label": "continue",
                                  "successors": []
                                }
                              ]
                            },
                            {
                              "id": 8,
                              "start_line": 17,
                              "end_line": 18,
                              "label": "input_schema = json.dumps(block.input_schema.jsonschema())\n        output_schema = json.dumps(block.output_schema.jsonschema())",
                              "successors": [
                                {
                                  "id": 9,
                                  "start_line": 19,
                                  "end_line": 24,
                                  "label": "if (\n            block.id != existing_block.id\n            or block.name != existing_block.name\n            or input_schema != existing_block.inputSchema\n            or output_schema != existing_block.outputSchema\n        ):",
                                  "successors": [
                                    {
                                      "id": 10,
                                      "start_line": 25,
                                      "end_line": 33,
                                      "label": "await AgentBlock.prisma().update(\n                where={\"id\": existing_block.id},\n                data={\n                    \"id\": block.id,\n                    \"name\": block.name,\n                    \"inputSchema\": input_schema,\n                    \"outputSchema\": output_schema,\n                },\n            )",
                                      "successors": []
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "get_block",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 1,
          "label": "def get_block(block_id: str) -> Block | None:",
          "successors": [
            {
              "id": 2,
              "start_line": 2,
              "end_line": 2,
              "label": "cls = get_blocks().get(block_id)",
              "successors": [
                {
                  "id": 3,
                  "start_line": 3,
                  "end_line": 3,
                  "label": "return cls() if cls else None",
                  "successors": []
                }
              ]
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    }
  ],
  "classes": [
    {
      "name": "BlockType",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 8,
          "label": "class BlockType(Enum):\n    STANDARD = \"Standard\"\n    INPUT = \"Input\"\n    OUTPUT = \"Output\"\n    NOTE = \"Note\"\n    WEBHOOK = \"Webhook\"\n    WEBHOOK_MANUAL = \"Webhook (manual)\"\n    AGENT = \"Agent\"",
          "successors": []
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "BlockCategory",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 15,
          "label": "class BlockCategory(Enum):\n    AI = \"Block that leverages AI to perform a task.\"\n    SOCIAL = \"Block that interacts with social media platforms.\"\n    TEXT = \"Block that processes text data.\"\n    SEARCH = \"Block that searches or extracts information from the internet.\"\n    BASIC = \"Block that performs basic operations.\"\n    INPUT = \"Block that interacts with input of the graph.\"\n    OUTPUT = \"Block that interacts with output of the graph.\"\n    LOGIC = \"Programming logic to control the flow of your agent\"\n    COMMUNICATION = \"Block that interacts with communication platforms.\"\n    DEVELOPER_TOOLS = \"Developer tools such as GitHub blocks.\"\n    DATA = \"Block that interacts with structured data.\"\n    HARDWARE = \"Block that interacts with hardware.\"\n    AGENT = \"Block that interacts with other agents.\"\n    CRM = \"Block that interacts with CRM services.\"",
          "successors": []
        }
      ],
      "functions": [
        {
          "name": "dict",
          "type": "CFG",
          "blocks": [
            {
              "id": 1,
              "start_line": 1,
              "end_line": 1,
              "label": "def dict(self) -> dict[str, str]:",
              "successors": [
                {
                  "id": 2,
                  "start_line": 2,
                  "end_line": 2,
                  "label": "return {\"category\": self.name, \"description\": self.value}",
                  "successors": []
                }
              ]
            }
          ],
          "functions": [],
          "classes": []
        }
      ],
      "classes": []
    },
    {
      "name": "BlockSchema",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 1,
          "label": "class BlockSchema(BaseModel):",
          "successors": [
            {
              "id": 2,
              "start_line": 2,
              "end_line": 2,
              "label": "cached_jsonschema: ClassVar[dict[str, Any]]",
              "successors": [
                {
                  "id": 3,
                  "start_line": 3,
                  "end_line": 3,
                  "label": "@classmethod",
                  "successors": [
                    {
                      "id": 4,
                      "start_line": 4,
                      "end_line": 4,
                      "label": "@classmethod",
                      "successors": [
                        {
                          "id": 5,
                          "start_line": 5,
                          "end_line": 5,
                          "label": "@classmethod",
                          "successors": [
                            {
                              "id": 6,
                              "start_line": 6,
                              "end_line": 6,
                              "label": "@classmethod",
                              "successors": [
                                {
                                  "id": 7,
                                  "start_line": 7,
                                  "end_line": 7,
                                  "label": "@classmethod",
                                  "successors": [
                                    {
                                      "id": 8,
                                      "start_line": 8,
                                      "end_line": 8,
                                      "label": "@classmethod",
                                      "successors": []
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "jsonschema",
          "type": "CFG",
          "blocks": [
            {
              "id": 1,
              "start_line": 1,
              "end_line": 1,
              "label": "def jsonschema(cls) -> dict[str, Any]:",
              "successors": [
                {
                  "id": 2,
                  "start_line": 2,
                  "end_line": 2,
                  "label": "if cls.cached_jsonschema:",
                  "successors": [
                    {
                      "id": 3,
                      "start_line": 3,
                      "end_line": 3,
                      "label": "return cls.cached_jsonschema",
                      "successors": []
                    },
                    {
                      "id": 4,
                      "start_line": 4,
                      "end_line": 10,
                      "label": "model = jsonref.replace_refs(cls.model_json_schema(), merge_props=True)\n        cls.cached_jsonschema = cast(dict[str, Any], ref_to_dict(model))\n        # Set default properties values\n        return cls.cached_jsonschema",
                      "successors": [
                        {
                          "id": 5,
                          "start_line": 7,
                          "end_line": 9,
                          "label": "for field in cls.cached_jsonschema.get(\"properties\", {}).values():\n            if isinstance(field, dict) and \"advanced\" not in field:\n                field[\"advanced\"] = True",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "functions": [
            {
              "name": "ref_to_dict",
              "type": "CFG",
              "blocks": [
                {
                  "id": 1,
                  "start_line": 1,
                  "end_line": 1,
                  "label": "def ref_to_dict(obj):",
                  "successors": [
                    {
                      "id": 2,
                      "start_line": 2,
                      "end_line": 2,
                      "label": "if isinstance(obj, dict):",
                      "successors": [
                        {
                          "id": 3,
                          "start_line": 3,
                          "end_line": 6,
                          "label": "# OpenAPI <3.1 does not support sibling fields that has a $ref key\n                # So sometimes, the schema has an \"allOf\"/\"anyOf\"/\"oneOf\" with 1 item.\n                keys = {\"allOf\", \"anyOf\", \"oneOf\"}\n                one_key = next((k for k in keys if k in obj and len(obj[k]) == 1), None)",
                          "successors": [
                            {
                              "id": 4,
                              "start_line": 7,
                              "end_line": 7,
                              "label": "if one_key:",
                              "successors": [
                                {
                                  "id": 5,
                                  "start_line": 8,
                                  "end_line": 8,
                                  "label": "obj.update(obj[one_key][0])",
                                  "successors": [
                                    {
                                      "id": 6,
                                      "start_line": 9,
                                      "end_line": 13,
                                      "label": "return {\n                    key: ref_to_dict(value)\n                    for key, value in obj.items()\n                    if not key.startswith(\"$\") and key != one_key\n                }",
                                      "successors": []
                                    }
                                  ]
                                },
                                {
                                  "id": 7,
                                  "start_line": 9,
                                  "end_line": 13,
                                  "label": "return {\n                    key: ref_to_dict(value)\n                    for key, value in obj.items()\n                    if not key.startswith(\"$\") and key != one_key\n                }",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        },
                        {
                          "id": 8,
                          "start_line": 14,
                          "end_line": 14,
                          "label": "elif isinstance(obj, list):",
                          "successors": [
                            {
                              "id": 9,
                              "start_line": 15,
                              "end_line": 15,
                              "label": "return [ref_to_dict(item) for item in obj]",
                              "successors": []
                            }
                          ]
                        },
                        {
                          "id": 10,
                          "start_line": 16,
                          "end_line": 16,
                          "label": "return obj",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ],
              "functions": [],
              "classes": []
            }
          ],
          "classes": []
        },
        {
          "name": "validate_data",
          "type": "CFG",
          "blocks": [
            {
              "id": 1,
              "start_line": 1,
              "end_line": 1,
              "label": "def validate_data(cls, data: BlockInput) -> str | None:",
              "successors": [
                {
                  "id": 2,
                  "start_line": 2,
                  "end_line": 2,
                  "label": "return json.validate_with_jsonschema(schema=cls.jsonschema(), data=data)",
                  "successors": []
                }
              ]
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "validate_field",
          "type": "CFG",
          "blocks": [
            {
              "id": 1,
              "start_line": 1,
              "end_line": 6,
              "label": "def validate_field(cls, field_name: str, data: BlockInput) -> str | None:\n        \"\"\"\n        Validate the data against a specific property (one of the input/output name).\n        Returns the validation error message if the data does not match the schema.\n        \"\"\"\n        model_schema = cls.jsonschema().get(\"properties\", {})",
              "successors": [
                {
                  "id": 2,
                  "start_line": 7,
                  "end_line": 7,
                  "label": "if not model_schema:",
                  "successors": [
                    {
                      "id": 3,
                      "start_line": 8,
                      "end_line": 8,
                      "label": "return f\"Invalid model schema {cls}\"",
                      "successors": []
                    },
                    {
                      "id": 4,
                      "start_line": 9,
                      "end_line": 9,
                      "label": "property_schema = model_schema.get(field_name)",
                      "successors": [
                        {
                          "id": 5,
                          "start_line": 10,
                          "end_line": 10,
                          "label": "if not property_schema:",
                          "successors": [
                            {
                              "id": 6,
                              "start_line": 11,
                              "end_line": 11,
                              "label": "return f\"Invalid property name {field_name}\"",
                              "successors": []
                            },
                            {
                              "id": 7,
                              "start_line": 12,
                              "end_line": 12,
                              "label": "try:",
                              "successors": [
                                {
                                  "id": 8,
                                  "start_line": 13,
                                  "end_line": 14,
                                  "label": "jsonschema.validate(json.to_dict(data), property_schema)\n            return None",
                                  "successors": []
                                },
                                {
                                  "id": 9,
                                  "start_line": 15,
                                  "end_line": 16,
                                  "label": "except jsonschema.ValidationError as e:\n            return str(e)",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "get_fields",
          "type": "CFG",
          "blocks": [
            {
              "id": 1,
              "start_line": 1,
              "end_line": 1,
              "label": "def get_fields(cls) -> set[str]:",
              "successors": [
                {
                  "id": 2,
                  "start_line": 2,
                  "end_line": 2,
                  "label": "return set(cls.model_fields.keys())",
                  "successors": []
                }
              ]
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "get_required_fields",
          "type": "CFG",
          "blocks": [
            {
              "id": 1,
              "start_line": 1,
              "end_line": 1,
              "label": "def get_required_fields(cls) -> set[str]:",
              "successors": [
                {
                  "id": 2,
                  "start_line": 2,
                  "end_line": 6,
                  "label": "return {\n            field\n            for field, field_info in cls.model_fields.items()\n            if field_info.is_required()\n        }",
                  "successors": []
                }
              ]
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "__pydantic_init_subclass__",
          "type": "CFG",
          "blocks": [
            {
              "id": 1,
              "start_line": 1,
              "end_line": 6,
              "label": "def __pydantic_init_subclass__(cls, **kwargs):\n        \"\"\"Validates the schema definition. Rules:\n        - Only one `CredentialsMetaInput` field may be present.\n          - This field MUST be called `credentials`.\n        - A field that is called `credentials` MUST be a `CredentialsMetaInput`.\n        \"\"\"",
              "successors": [
                {
                  "id": 2,
                  "start_line": 7,
                  "end_line": 9,
                  "label": "super().__pydantic_init_subclass__(**kwargs)\n        # Reset cached JSON schema to prevent inheriting it from parent class\n        cls.cached_jsonschema = {}",
                  "successors": [
                    {
                      "id": 3,
                      "start_line": 10,
                      "end_line": 20,
                      "label": "credentials_fields = [\n            field_name\n            for field_name, info in cls.model_fields.items()\n            if (\n                inspect.isclass(info.annotation)\n                and issubclass(\n                    get_origin(info.annotation) or info.annotation,\n                    CredentialsMetaInput,\n                )\n            )\n        ]",
                      "successors": [
                        {
                          "id": 4,
                          "start_line": 21,
                          "end_line": 24,
                          "label": "if len(credentials_fields) > 1:\n            raise ValueError(\n                f\"{cls.__qualname__} can only have one CredentialsMetaInput field\"\n            )",
                          "successors": [
                            {
                              "id": 5,
                              "start_line": 25,
                              "end_line": 32,
                              "label": "elif (\n            len(credentials_fields) == 1\n            and credentials_fields[0] != CREDENTIALS_FIELD_NAME\n        ):\n            raise ValueError(\n                f\"CredentialsMetaInput field on {cls.__qualname__} \"\n                \"must be named 'credentials'\"\n            )",
                              "successors": [
                                {
                                  "id": 6,
                                  "start_line": 33,
                                  "end_line": 40,
                                  "label": "elif (\n            len(credentials_fields) == 0\n            and CREDENTIALS_FIELD_NAME in cls.model_fields.keys()\n        ):\n            raise TypeError(\n                f\"Field 'credentials' on {cls.__qualname__} \"\n                f\"must be of type {CredentialsMetaInput.__name__}\"\n            )",
                                  "successors": [
                                    {
                                      "id": 7,
                                      "start_line": 41,
                                      "end_line": 45,
                                      "label": "if credentials_field := cls.model_fields.get(CREDENTIALS_FIELD_NAME):\n            credentials_input_type = cast(\n                CredentialsMetaInput, credentials_field.annotation\n            )\n            credentials_input_type.validate_credentials_field_schema(cls)",
                                      "successors": []
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "functions": [],
          "classes": []
        }
      ],
      "classes": []
    },
    {
      "name": "EmptySchema",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 2,
          "label": "class EmptySchema(BlockSchema):\n    pass",
          "successors": []
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "BlockManualWebhookConfig",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 23,
          "label": "class BlockManualWebhookConfig(BaseModel):\n    \"\"\"\n    Configuration model for webhook-triggered blocks on which\n    the user has to manually set up the webhook at the provider.\n    \"\"\"\n    provider: str\n    \"\"\"The service provider that the webhook connects to\"\"\"\n    webhook_type: str\n    \"\"\"\n    Identifier for the webhook type. E.g. GitHub has repo and organization level hooks.\n    Only for use in the corresponding `WebhooksManager`.\n    \"\"\"\n    event_filter_input: str = \"\"\n    \"\"\"\n    Name of the block's event filter input.\n    Leave empty if the corresponding webhook doesn't have distinct event/payload types.\n    \"\"\"\n    event_format: str = \"{event}\"\n    \"\"\"\n    Template string for the event(s) that a block instance subscribes to.\n    Applied individually to each event selected in the event filter input.\n    Example: `\"pull_request.{event}\"` -> `\"pull_request.opened\"`\n    \"\"\"",
          "successors": []
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "BlockWebhookConfig",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 13,
          "label": "class BlockWebhookConfig(BlockManualWebhookConfig):\n    \"\"\"\n    Configuration model for webhook-triggered blocks for which\n    the webhook can be automatically set up through the provider's API.\n    \"\"\"\n    resource_format: str\n    \"\"\"\n    Template string for the resource that a block instance subscribes to.\n    Fields will be filled from the block's inputs (except `payload`).\n    Example: `f\"{repo}/pull_requests\"` (note: not how it's actually implemented)\n    Only for use in the corresponding `WebhooksManager`.\n    \"\"\"\n    # --8<-- [end:BlockWebhookConfig]",
          "successors": []
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "Block",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 1,
          "label": "class Block(ABC, Generic[BlockSchemaInputType, BlockSchemaOutputType]):",
          "successors": [
            {
              "id": 2,
              "start_line": 2,
              "end_line": 2,
              "label": "@classmethod",
              "successors": [
                {
                  "id": 3,
                  "start_line": 3,
                  "end_line": 3,
                  "label": "@abstractmethod",
                  "successors": [
                    {
                      "id": 4,
                      "start_line": 4,
                      "end_line": 4,
                      "label": "@property",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "type": "CFG",
          "blocks": [
            {
              "id": 1,
              "start_line": 1,
              "end_line": 17,
              "label": "def __init__(\n        self,\n        id: str = \"\",\n        description: str = \"\",\n        contributors: list[ContributorDetails] = [],\n        categories: set[BlockCategory] | None = None,\n        input_schema: Type[BlockSchemaInputType] = EmptySchema,\n        output_schema: Type[BlockSchemaOutputType] = EmptySchema,\n        test_input: BlockInput | list[BlockInput] | None = None,\n        test_output: BlockData | list[BlockData] | None = None,\n        test_mock: dict[str, Any] | None = None,\n        test_credentials: Optional[Credentials] = None,\n        disabled: bool = False,\n        static_output: bool = False,\n        block_type: BlockType = BlockType.STANDARD,\n        webhook_config: Optional[BlockWebhookConfig | BlockManualWebhookConfig] = None,\n    ):",
              "successors": [
                {
                  "id": 2,
                  "start_line": 18,
                  "end_line": 33,
                  "label": "\"\"\"\n        Initialize the block with the given schema.\n        Args:\n            id: The unique identifier for the block, this value will be persisted in the\n                DB. So it should be a unique and constant across the application run.\n                Use the UUID format for the ID.\n            description: The description of the block, explaining what the block does.\n            contributors: The list of contributors who contributed to the block.\n            input_schema: The schema, defined as a Pydantic model, for the input data.\n            output_schema: The schema, defined as a Pydantic model, for the output data.\n            test_input: The list or single sample input data for the block, for testing.\n            test_output: The list or single expected output if the test_input is run.\n            test_mock: function names on the block implementation to mock on test run.\n            disabled: If the block is disabled, it will not be available for execution.\n            static_output: Whether the output links of the block are static by default.\n        \"\"\"",
                  "successors": [
                    {
                      "id": 3,
                      "start_line": 34,
                      "end_line": 48,
                      "label": "self.id = id\n        self.input_schema = input_schema\n        self.output_schema = output_schema\n        self.test_input = test_input\n        self.test_output = test_output\n        self.test_mock = test_mock\n        self.test_credentials = test_credentials\n        self.description = description\n        self.categories = categories or set()\n        self.contributors = contributors or set()\n        self.disabled = disabled\n        self.static_output = static_output\n        self.block_type = block_type\n        self.webhook_config = webhook_config\n        self.execution_stats = {}",
                      "successors": [
                        {
                          "id": 4,
                          "start_line": 49,
                          "end_line": 49,
                          "label": "if self.webhook_config:",
                          "successors": [
                            {
                              "id": 5,
                              "start_line": 50,
                              "end_line": 50,
                              "label": "if isinstance(self.webhook_config, BlockWebhookConfig):",
                              "successors": [
                                {
                                  "id": 6,
                                  "start_line": 51,
                                  "end_line": 55,
                                  "label": "# Enforce presence of credentials field on auto-setup webhook blocks\n                if CREDENTIALS_FIELD_NAME not in self.input_schema.model_fields:\n                    raise TypeError(\n                        \"credentials field is required on auto-setup webhook blocks\"\n                    )",
                                  "successors": [
                                    {
                                      "id": 7,
                                      "start_line": 56,
                                      "end_line": 56,
                                      "label": "self.block_type = BlockType.WEBHOOK",
                                      "successors": []
                                    }
                                  ]
                                },
                                {
                                  "id": 8,
                                  "start_line": 57,
                                  "end_line": 57,
                                  "label": "else:",
                                  "successors": [
                                    {
                                      "id": 9,
                                      "start_line": 58,
                                      "end_line": 58,
                                      "label": "self.block_type = BlockType.WEBHOOK_MANUAL",
                                      "successors": []
                                    }
                                  ]
                                }
                              ]
                            },
                            {
                              "id": 10,
                              "start_line": 59,
                              "end_line": 59,
                              "label": "# Enforce shape of webhook event filter, if present",
                              "successors": [
                                {
                                  "id": 11,
                                  "start_line": 60,
                                  "end_line": 60,
                                  "label": "if self.webhook_config.event_filter_input:",
                                  "successors": [
                                    {
                                      "id": 12,
                                      "start_line": 61,
                                      "end_line": 75,
                                      "label": "event_filter_field = self.input_schema.model_fields[\n                    self.webhook_config.event_filter_input\n                ]\n                if not (\n                    isinstance(event_filter_field.annotation, type)\n                    and issubclass(event_filter_field.annotation, BaseModel)\n                    and all(\n                        field.annotation is bool\n                        for field in event_filter_field.annotation.model_fields.values()\n                    )\n                ):\n                    raise NotImplementedError(\n                        f\"{self.name} has an invalid webhook event selector: \"\n                        \"field must be a BaseModel and all its fields must be boolean\"\n                    )",
                                      "successors": []
                                    }
                                  ]
                                }
                              ]
                            },
                            {
                              "id": 13,
                              "start_line": 76,
                              "end_line": 76,
                              "label": "# Enforce presence of 'payload' input",
                              "successors": [
                                {
                                  "id": 14,
                                  "start_line": 77,
                                  "end_line": 80,
                                  "label": "if \"payload\" not in self.input_schema.model_fields:\n                raise TypeError(\n                    f\"{self.name} is webhook-triggered but has no 'payload' input\"\n                )",
                                  "successors": []
                                }
                              ]
                            },
                            {
                              "id": 15,
                              "start_line": 81,
                              "end_line": 81,
                              "label": "# Disable webhook-triggered block if webhook functionality not available",
                              "successors": [
                                {
                                  "id": 16,
                                  "start_line": 82,
                                  "end_line": 83,
                                  "label": "if not app_config.platform_base_url:\n                self.disabled = True",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "create",
          "type": "CFG",
          "blocks": [
            {
              "id": 1,
              "start_line": 1,
              "end_line": 1,
              "label": "def create(cls: Type[\"Block\"]) -> \"Block\":",
              "successors": [
                {
                  "id": 2,
                  "start_line": 2,
                  "end_line": 2,
                  "label": "return cls()",
                  "successors": []
                }
              ]
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "run",
          "type": "CFG",
          "blocks": [
            {
              "id": 1,
              "start_line": 1,
              "end_line": 11,
              "label": "def run(self, input_data: BlockSchemaInputType, **kwargs) -> BlockOutput:\n        \"\"\"\n        Run the block with the given input data.\n        Args:\n            input_data: The input data with the structure of input_schema.\n        Returns:\n            A Generator that yields (output_name, output_data).\n            output_name: One of the output name defined in Block's output_schema.\n            output_data: The data for the output_name, matching the defined schema.\n        \"\"\"\n        pass",
              "successors": []
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "run_once",
          "type": "CFG",
          "blocks": [
            {
              "id": 1,
              "start_line": 1,
              "end_line": 1,
              "label": "def run_once(self, input_data: BlockSchemaInputType, output: str, **kwargs) -> Any:",
              "successors": [
                {
                  "id": 2,
                  "start_line": 2,
                  "end_line": 2,
                  "label": "for name, data in self.run(input_data, **kwargs):",
                  "successors": [
                    {
                      "id": 3,
                      "start_line": 3,
                      "end_line": 3,
                      "label": "if name == output:",
                      "successors": [
                        {
                          "id": 4,
                          "start_line": 4,
                          "end_line": 4,
                          "label": "return data",
                          "successors": []
                        }
                      ]
                    },
                    {
                      "id": 5,
                      "start_line": 5,
                      "end_line": 5,
                      "label": "raise ValueError(f\"{self.name} did not produce any output for {output}\")",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "merge_stats",
          "type": "CFG",
          "blocks": [
            {
              "id": 1,
              "start_line": 1,
              "end_line": 1,
              "label": "def merge_stats(self, stats: dict[str, Any]) -> dict[str, Any]:",
              "successors": [
                {
                  "id": 2,
                  "start_line": 2,
                  "end_line": 2,
                  "label": "for key, value in stats.items():",
                  "successors": [
                    {
                      "id": 3,
                      "start_line": 3,
                      "end_line": 3,
                      "label": "if isinstance(value, dict):",
                      "successors": [
                        {
                          "id": 4,
                          "start_line": 4,
                          "end_line": 4,
                          "label": "self.execution_stats.setdefault(key, {}).update(value)",
                          "successors": []
                        },
                        {
                          "id": 5,
                          "start_line": 5,
                          "end_line": 5,
                          "label": "elif isinstance(value, (int, float)):",
                          "successors": [
                            {
                              "id": 6,
                              "start_line": 6,
                              "end_line": 7,
                              "label": "self.execution_stats.setdefault(key, 0)\n                self.execution_stats[key] += value",
                              "successors": []
                            }
                          ]
                        },
                        {
                          "id": 7,
                          "start_line": 8,
                          "end_line": 8,
                          "label": "elif isinstance(value, list):",
                          "successors": [
                            {
                              "id": 8,
                              "start_line": 9,
                              "end_line": 10,
                              "label": "self.execution_stats.setdefault(key, [])\n                self.execution_stats[key].extend(value)",
                              "successors": []
                            }
                          ]
                        },
                        {
                          "id": 9,
                          "start_line": 11,
                          "end_line": 11,
                          "label": "else:",
                          "successors": [
                            {
                              "id": 10,
                              "start_line": 12,
                              "end_line": 12,
                              "label": "self.execution_stats[key] = value",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "id": 11,
              "start_line": 13,
              "end_line": 13,
              "label": "return self.execution_stats",
              "successors": []
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "name",
          "type": "CFG",
          "blocks": [],
          "functions": [],
          "classes": []
        },
        {
          "name": "to_dict",
          "type": "CFG",
          "blocks": [
            {
              "id": 1,
              "start_line": 1,
              "end_line": 1,
              "label": "def to_dict(self):",
              "successors": [
                {
                  "id": 2,
                  "start_line": 2,
                  "end_line": 14,
                  "label": "return {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"inputSchema\": self.input_schema.jsonschema(),\n            \"outputSchema\": self.output_schema.jsonschema(),\n            \"description\": self.description,\n            \"categories\": [category.dict() for category in self.categories],\n            \"contributors\": [\n                contributor.model_dump() for contributor in self.contributors\n            ],\n            \"staticOutput\": self.static_output,\n            \"uiType\": self.block_type.value,\n        }",
                  "successors": []
                }
              ]
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "execute",
          "type": "CFG",
          "blocks": [
            {
              "id": 1,
              "start_line": 1,
              "end_line": 1,
              "label": "def execute(self, input_data: BlockInput, **kwargs) -> BlockOutput:",
              "successors": [
                {
                  "id": 2,
                  "start_line": 2,
                  "end_line": 2,
                  "label": "if error := self.input_schema.validate_data(input_data):",
                  "successors": [
                    {
                      "id": 3,
                      "start_line": 3,
                      "end_line": 5,
                      "label": "raise ValueError(\n                f\"Unable to execute block with invalid input data: {error}\"\n            )",
                      "successors": []
                    },
                    {
                      "id": 4,
                      "start_line": 6,
                      "end_line": 8,
                      "label": "for output_name, output_data in self.run(\n            self.input_schema(**input_data), **kwargs\n        ):",
                      "successors": [
                        {
                          "id": 5,
                          "start_line": 9,
                          "end_line": 9,
                          "label": "if output_name == \"error\":",
                          "successors": [
                            {
                              "id": 6,
                              "start_line": 10,
                              "end_line": 10,
                              "label": "raise RuntimeError(output_data)",
                              "successors": []
                            },
                            {
                              "id": 7,
                              "start_line": 11,
                              "end_line": 13,
                              "label": "if self.block_type == BlockType.STANDARD and (\n                error := self.output_schema.validate_field(output_name, output_data)\n            ):",
                              "successors": [
                                {
                                  "id": 8,
                                  "start_line": 14,
                                  "end_line": 14,
                                  "label": "raise ValueError(f\"Block produced an invalid output data: {error}\")",
                                  "successors": []
                                },
                                {
                                  "id": 9,
                                  "start_line": 15,
                                  "end_line": 15,
                                  "label": "yield output_name, output_data",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "functions": [],
          "classes": []
        }
      ],
      "classes": []
    }
  ]
}