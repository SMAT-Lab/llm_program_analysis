{
  "name": "example_script",
  "type": "CFG",
  "blocks": [
    {
      "id": 1,
      "start_line": 1,
      "end_line": 1,
      "label": "from __future__ import annotations",
      "successors": [
        {
          "id": 2,
          "start_line": 2,
          "end_line": 2,
          "label": "if __name__ == \"__main__\":",
          "successors": [
            {
              "id": 3,
              "start_line": 3,
              "end_line": 4,
              "label": "import doctest\n    doctest.testmod(optionflags=doctest.NORMALIZE_WHITESPACE)",
              "successors": []
            }
          ]
        }
      ]
    }
  ],
  "functions": [
    {
      "name": "solve_maze",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 7,
          "label": "def solve_maze(\n    maze: list[list[int]],\n    source_row: int,\n    source_column: int,\n    destination_row: int,\n    destination_column: int,\n) -> list[list[int]]:",
          "successors": [
            {
              "id": 2,
              "start_line": 8,
              "end_line": 110,
              "label": "\"\"\"\n    This method solves the \"rat in maze\" problem.\n    Parameters :\n        - maze: A two dimensional matrix of zeros and ones.\n        - source_row: The row index of the starting point.\n        - source_column: The column index of the starting point.\n        - destination_row: The row index of the destination point.\n        - destination_column: The column index of the destination point.\n    Returns:\n        - solution: A 2D matrix representing the solution path if it exists.\n    Raises:\n        - ValueError: If no solution exists or if the source or\n            destination coordinates are invalid.\n    Description:\n        This method navigates through a maze represented as an n by n matrix,\n        starting from a specified source cell and\n        aiming to reach a destination cell.\n        The maze consists of walls (1s) and open paths (0s).\n        By providing custom row and column values, the source and destination\n        cells can be adjusted.\n    >>> maze = [[0, 1, 0, 1, 1],\n    ...         [0, 0, 0, 0, 0],\n    ...         [1, 0, 1, 0, 1],\n    ...         [0, 0, 1, 0, 0],\n    ...         [1, 0, 0, 1, 0]]\n    >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE\n    [[0, 1, 1, 1, 1],\n    [0, 0, 0, 0, 1],\n    [1, 1, 1, 0, 1],\n    [1, 1, 1, 0, 0],\n    [1, 1, 1, 1, 0]]\n    Note:\n        In the output maze, the zeros (0s) represent one of the possible\n        paths from the source to the destination.\n    >>> maze = [[0, 1, 0, 1, 1],\n    ...         [0, 0, 0, 0, 0],\n    ...         [0, 0, 0, 0, 1],\n    ...         [0, 0, 0, 0, 0],\n    ...         [0, 0, 0, 0, 0]]\n    >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE\n    [[0, 1, 1, 1, 1],\n    [0, 1, 1, 1, 1],\n    [0, 1, 1, 1, 1],\n    [0, 1, 1, 1, 1],\n    [0, 0, 0, 0, 0]]\n    >>> maze = [[0, 0, 0],\n    ...         [0, 1, 0],\n    ...         [1, 0, 0]]\n    >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE\n    [[0, 0, 0],\n    [1, 1, 0],\n    [1, 1, 0]]\n    >>> maze = [[1, 0, 0],\n    ...         [0, 1, 0],\n    ...         [1, 0, 0]]\n    >>> solve_maze(maze,0,1,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE\n    [[1, 0, 0],\n    [1, 1, 0],\n    [1, 1, 0]]\n    >>> maze = [[1, 1, 0, 0, 1, 0, 0, 1],\n    ...         [1, 0, 1, 0, 0, 1, 1, 1],\n    ...         [0, 1, 0, 1, 0, 0, 1, 0],\n    ...         [1, 1, 1, 0, 0, 1, 0, 1],\n    ...         [0, 1, 0, 0, 1, 0, 1, 1],\n    ...         [0, 0, 0, 1, 1, 1, 0, 1],\n    ...         [0, 1, 0, 1, 0, 1, 1, 1],\n    ...         [1, 1, 0, 0, 0, 0, 0, 1]]\n    >>> solve_maze(maze,0,2,len(maze)-1,2)  # doctest: +NORMALIZE_WHITESPACE\n    [[1, 1, 0, 0, 1, 1, 1, 1],\n    [1, 1, 1, 0, 0, 1, 1, 1],\n    [1, 1, 1, 1, 0, 1, 1, 1],\n    [1, 1, 1, 0, 0, 1, 1, 1],\n    [1, 1, 0, 0, 1, 1, 1, 1],\n    [1, 1, 0, 1, 1, 1, 1, 1],\n    [1, 1, 0, 1, 1, 1, 1, 1],\n    [1, 1, 0, 1, 1, 1, 1, 1]]\n    >>> maze = [[1, 0, 0],\n    ...         [0, 1, 1],\n    ...         [1, 0, 1]]\n    >>> solve_maze(maze,0,1,len(maze)-1,len(maze)-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: No solution exists!\n    >>> maze = [[0, 0],\n    ...         [1, 1]]\n    >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: No solution exists!\n    >>> maze = [[0, 1],\n    ...         [1, 0]]\n    >>> solve_maze(maze,2,0,len(maze)-1,len(maze)-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid source or destination coordinates\n    >>> maze = [[1, 0, 0],\n    ...         [0, 1, 0],\n    ...         [1, 0, 0]]\n    >>> solve_maze(maze,0,1,len(maze),len(maze)-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid source or destination coordinates\n    \"\"\"",
              "successors": [
                {
                  "id": 3,
                  "start_line": 111,
                  "end_line": 111,
                  "label": "size = len(maze)",
                  "successors": [
                    {
                      "id": 4,
                      "start_line": 112,
                      "end_line": 115,
                      "label": "# Check if source and destination coordinates are Invalid.\n    if not (0 <= source_row <= size - 1 and 0 <= source_column <= size - 1) or (\n        not (0 <= destination_row <= size - 1 and 0 <= destination_column <= size - 1)\n    ):",
                      "successors": [
                        {
                          "id": 5,
                          "start_line": 116,
                          "end_line": 116,
                          "label": "raise ValueError(\"Invalid source or destination coordinates\")",
                          "successors": []
                        },
                        {
                          "id": 6,
                          "start_line": 117,
                          "end_line": 118,
                          "label": "# We need to create solution object to save path.\n    solutions = [[1 for _ in range(size)] for _ in range(size)]",
                          "successors": [
                            {
                              "id": 7,
                              "start_line": 119,
                              "end_line": 121,
                              "label": "solved = run_maze(\n        maze, source_row, source_column, destination_row, destination_column, solutions\n    )",
                              "successors": [
                                {
                                  "id": 8,
                                  "start_line": 122,
                                  "end_line": 122,
                                  "label": "if solved:",
                                  "successors": [
                                    {
                                      "id": 9,
                                      "start_line": 123,
                                      "end_line": 123,
                                      "label": "return solutions",
                                      "successors": []
                                    },
                                    {
                                      "id": 10,
                                      "start_line": 124,
                                      "end_line": 125,
                                      "label": "else:\n        raise ValueError(\"No solution exists!\")",
                                      "successors": []
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "run_maze",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 19,
          "label": "def run_maze(\n    maze: list[list[int]],\n    i: int,\n    j: int,\n    destination_row: int,\n    destination_column: int,\n    solutions: list[list[int]],\n) -> bool:\n    \"\"\"\n    This method is recursive starting from (i, j) and going in one of four directions:\n    up, down, left, right.\n    If a path is found to destination it returns True otherwise it returns False.\n    Parameters\n        maze: A two dimensional matrix of zeros and ones.\n        i, j : coordinates of matrix\n        solutions: A two dimensional matrix of solutions.\n    Returns:\n        Boolean if path is found True, Otherwise False.\n    \"\"\"",
          "successors": [
            {
              "id": 2,
              "start_line": 20,
              "end_line": 20,
              "label": "size = len(maze)",
              "successors": [
                {
                  "id": 3,
                  "start_line": 21,
                  "end_line": 22,
                  "label": "# Final check point.\n    if i == destination_row and j == destination_column and maze[i][j] == 0:",
                  "successors": [
                    {
                      "id": 4,
                      "start_line": 23,
                      "end_line": 24,
                      "label": "solutions[i][j] = 0\n        return True",
                      "successors": []
                    },
                    {
                      "id": 5,
                      "start_line": 25,
                      "end_line": 26,
                      "label": "lower_flag = (not i < 0) and (not j < 0)  # Check lower bounds\n    upper_flag = (i < size) and (j < size)  # Check upper bounds",
                      "successors": [
                        {
                          "id": 6,
                          "start_line": 27,
                          "end_line": 27,
                          "label": "if lower_flag and upper_flag:",
                          "successors": [
                            {
                              "id": 7,
                              "start_line": 28,
                              "end_line": 29,
                              "label": "# check for already visited and block points.\n        block_flag = (solutions[i][j]) and (not maze[i][j])",
                              "successors": [
                                {
                                  "id": 8,
                                  "start_line": 30,
                                  "end_line": 30,
                                  "label": "if block_flag:",
                                  "successors": [
                                    {
                                      "id": 9,
                                      "start_line": 31,
                                      "end_line": 32,
                                      "label": "# check visited\n            solutions[i][j] = 0",
                                      "successors": [
                                        {
                                          "id": 10,
                                          "start_line": 33,
                                          "end_line": 45,
                                          "label": "# check for directions\n            if (\n                run_maze(maze, i + 1, j, destination_row, destination_column, solutions)\n                or run_maze(\n                    maze, i, j + 1, destination_row, destination_column, solutions\n                )\n                or run_maze(\n                    maze, i - 1, j, destination_row, destination_column, solutions\n                )\n                or run_maze(\n                    maze, i, j - 1, destination_row, destination_column, solutions\n                )\n            ):",
                                          "successors": [
                                            {
                                              "id": 11,
                                              "start_line": 46,
                                              "end_line": 46,
                                              "label": "return True",
                                              "successors": []
                                            },
                                            {
                                              "id": 12,
                                              "start_line": 47,
                                              "end_line": 48,
                                              "label": "solutions[i][j] = 1\n            return False",
                                              "successors": []
                                            }
                                          ]
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    }
  ],
  "classes": []
}