{
  "name": "example_script",
  "type": "CFG",
  "blocks": [
    {
      "id": 1,
      "start_line": 1,
      "end_line": 226,
      "label": "import asyncio\nimport logging\nfrom collections import defaultdict\nfrom typing import TYPE_CHECKING, Annotated, Any, Sequence\nimport pydantic\nfrom autogpt_libs.auth.middleware import auth_middleware\nfrom autogpt_libs.feature_flag.client import feature_flag\nfrom autogpt_libs.utils.cache import thread_cached\nfrom fastapi import APIRouter, Depends, HTTPException\nfrom typing_extensions import Optional, TypedDict\nimport backend.data.block\nimport backend.server.integrations.router\nimport backend.server.routers.analytics\nfrom backend.data import execution as execution_db\nfrom backend.data import graph as graph_db\nfrom backend.data.api_key import (\n    APIKeyError,\n    APIKeyNotFoundError,\n    APIKeyPermissionError,\n    APIKeyWithoutHash,\n    generate_api_key,\n    get_api_key_by_id,\n    list_user_api_keys,\n    revoke_api_key,\n    suspend_api_key,\n    update_api_key_permissions,\n)\nfrom backend.data.block import BlockInput, CompletedBlockOutput\nfrom backend.data.credit import get_block_costs, get_user_credit_model\nfrom backend.data.user import get_or_create_user\nfrom backend.executor import ExecutionManager, ExecutionScheduler, scheduler\nfrom backend.integrations.creds_manager import IntegrationCredentialsManager\nfrom backend.integrations.webhooks.graph_lifecycle_hooks import (\n    on_graph_activate,\n    on_graph_deactivate,\n)\nfrom backend.server.model import (\n    CreateAPIKeyRequest,\n    CreateAPIKeyResponse,\n    CreateGraph,\n    SetGraphActiveVersion,\n    UpdatePermissionsRequest,\n)\nfrom backend.server.utils import get_user_id\nfrom backend.util.service import get_service_client\nfrom backend.util.settings import Settings\nif TYPE_CHECKING:\n    from backend.data.model import Credentials\n@thread_cached\n@thread_cached\nsettings = Settings()\nlogger = logging.getLogger(__name__)\nintegration_creds_manager = IntegrationCredentialsManager()\n_user_credit_model = get_user_credit_model()\n# Define the API routes\nv1_router = APIRouter()\nv1_router.include_router(\n    backend.server.integrations.router.router,\n    prefix=\"/integrations\",\n    tags=[\"integrations\"],\n)\nv1_router.include_router(\n    backend.server.routers.analytics.router,\n    prefix=\"/analytics\",\n    tags=[\"analytics\"],\n    dependencies=[Depends(auth_middleware)],\n)\n########################################################\n##################### Auth #############################\n########################################################\n@v1_router.post(\"/auth/user\", tags=[\"auth\"], dependencies=[Depends(auth_middleware)])\n########################################################\n##################### Blocks ###########################\n########################################################\n@v1_router.get(path=\"/blocks\", tags=[\"blocks\"], dependencies=[Depends(auth_middleware)])\n@v1_router.post(\n    path=\"/blocks/{block_id}/execute\",\n    tags=[\"blocks\"],\n    dependencies=[Depends(auth_middleware)],\n)\n########################################################\n##################### Credits ##########################\n########################################################\n@v1_router.get(path=\"/credits\", dependencies=[Depends(auth_middleware)])\n########################################################\n##################### Graphs ###########################\n########################################################\n@v1_router.get(path=\"/graphs\", tags=[\"graphs\"], dependencies=[Depends(auth_middleware)])\n@v1_router.get(\n    path=\"/graphs/{graph_id}\", tags=[\"graphs\"], dependencies=[Depends(auth_middleware)]\n)\n@v1_router.get(\n    path=\"/graphs/{graph_id}/versions/{version}\",\n    tags=[\"graphs\"],\n    dependencies=[Depends(auth_middleware)],\n)\n@v1_router.get(\n    path=\"/graphs/{graph_id}/versions\",\n    tags=[\"graphs\"],\n    dependencies=[Depends(auth_middleware)],\n)\n@v1_router.get(\n    path=\"/templates/{graph_id}/versions\",\n    tags=[\"templates\", \"graphs\"],\n    dependencies=[Depends(auth_middleware)],\n)\n@v1_router.post(\n    path=\"/graphs\", tags=[\"graphs\"], dependencies=[Depends(auth_middleware)]\n)\n@v1_router.delete(\n    path=\"/graphs/{graph_id}\", tags=[\"graphs\"], dependencies=[Depends(auth_middleware)]\n)\n@v1_router.put(\n    path=\"/graphs/{graph_id}\", tags=[\"graphs\"], dependencies=[Depends(auth_middleware)]\n)\n@v1_router.put(\n    path=\"/templates/{graph_id}\",\n    tags=[\"templates\", \"graphs\"],\n    dependencies=[Depends(auth_middleware)],\n)\n@v1_router.put(\n    path=\"/graphs/{graph_id}/versions/active\",\n    tags=[\"graphs\"],\n    dependencies=[Depends(auth_middleware)],\n)\n@v1_router.post(\n    path=\"/graphs/{graph_id}/execute\",\n    tags=[\"graphs\"],\n    dependencies=[Depends(auth_middleware)],\n)\n@v1_router.post(\n    path=\"/graphs/{graph_id}/executions/{graph_exec_id}/stop\",\n    tags=[\"graphs\"],\n    dependencies=[Depends(auth_middleware)],\n)\n@v1_router.get(\n    path=\"/executions\",\n    tags=[\"graphs\"],\n    dependencies=[Depends(auth_middleware)],\n)\n@v1_router.get(\n    path=\"/graphs/{graph_id}/executions/{graph_exec_id}\",\n    tags=[\"graphs\"],\n    dependencies=[Depends(auth_middleware)],\n)\n########################################################\n##################### Templates ########################\n########################################################\n@v1_router.get(\n    path=\"/templates\",\n    tags=[\"graphs\", \"templates\"],\n    dependencies=[Depends(auth_middleware)],\n)\n@v1_router.get(\n    path=\"/templates/{graph_id}\",\n    tags=[\"templates\", \"graphs\"],\n    dependencies=[Depends(auth_middleware)],\n)\n@v1_router.post(\n    path=\"/templates\",\n    tags=[\"templates\", \"graphs\"],\n    dependencies=[Depends(auth_middleware)],\n)\n########################################################\n##################### Schedules ########################\n########################################################\n@v1_router.post(\n    path=\"/schedules\",\n    tags=[\"schedules\"],\n    dependencies=[Depends(auth_middleware)],\n)\n@v1_router.delete(\n    path=\"/schedules/{schedule_id}\",\n    tags=[\"schedules\"],\n    dependencies=[Depends(auth_middleware)],\n)\n@v1_router.get(\n    path=\"/schedules\",\n    tags=[\"schedules\"],\n    dependencies=[Depends(auth_middleware)],\n)\n########################################################\n#####################  API KEY ##############################\n########################################################\n@v1_router.post(\n    \"/api-keys\",\n    response_model=list[CreateAPIKeyResponse] | dict[str, str],\n    tags=[\"api-keys\"],\n    dependencies=[Depends(auth_middleware)],\n)\n@feature_flag(\"api-keys-enabled\")\n@v1_router.get(\n    \"/api-keys\",\n    response_model=list[APIKeyWithoutHash] | dict[str, str],\n    tags=[\"api-keys\"],\n    dependencies=[Depends(auth_middleware)],\n)\n@feature_flag(\"api-keys-enabled\")\n@v1_router.get(\n    \"/api-keys/{key_id}\",\n    response_model=list[APIKeyWithoutHash] | dict[str, str],\n    tags=[\"api-keys\"],\n    dependencies=[Depends(auth_middleware)],\n)\n@feature_flag(\"api-keys-enabled\")\n@v1_router.delete(\n    \"/api-keys/{key_id}\",\n    response_model=list[APIKeyWithoutHash] | dict[str, str],\n    tags=[\"api-keys\"],\n    dependencies=[Depends(auth_middleware)],\n)\n@feature_flag(\"api-keys-enabled\")\n@v1_router.post(\n    \"/api-keys/{key_id}/suspend\",\n    response_model=list[APIKeyWithoutHash] | dict[str, str],\n    tags=[\"api-keys\"],\n    dependencies=[Depends(auth_middleware)],\n)\n@feature_flag(\"api-keys-enabled\")\n@v1_router.put(\n    \"/api-keys/{key_id}/permissions\",\n    response_model=list[APIKeyWithoutHash] | dict[str, str],\n    tags=[\"api-keys\"],\n    dependencies=[Depends(auth_middleware)],\n)\n@feature_flag(\"api-keys-enabled\")",
      "successors": []
    }
  ],
  "functions": [
    {
      "name": "execution_manager_client",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 1,
          "label": "def execution_manager_client() -> ExecutionManager:",
          "successors": [
            {
              "id": 2,
              "start_line": 2,
              "end_line": 2,
              "label": "return get_service_client(ExecutionManager)",
              "successors": []
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "execution_scheduler_client",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 1,
          "label": "def execution_scheduler_client() -> ExecutionScheduler:",
          "successors": [
            {
              "id": 2,
              "start_line": 2,
              "end_line": 2,
              "label": "return get_service_client(ExecutionScheduler)",
              "successors": []
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "get_or_create_user_route",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 1,
          "label": "async def get_or_create_user_route(user_data: dict = Depends(auth_middleware)):",
          "successors": [
            {
              "id": 2,
              "start_line": 2,
              "end_line": 2,
              "label": "user = await get_or_create_user(user_data)",
              "successors": [
                {
                  "id": 3,
                  "start_line": 3,
                  "end_line": 3,
                  "label": "return user.model_dump()",
                  "successors": []
                }
              ]
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "get_graph_blocks",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 1,
          "label": "def get_graph_blocks() -> Sequence[dict[Any, Any]]:",
          "successors": [
            {
              "id": 2,
              "start_line": 2,
              "end_line": 2,
              "label": "blocks = [block() for block in backend.data.block.get_blocks().values()]",
              "successors": [
                {
                  "id": 3,
                  "start_line": 3,
                  "end_line": 3,
                  "label": "costs = get_block_costs()",
                  "successors": [
                    {
                      "id": 4,
                      "start_line": 4,
                      "end_line": 4,
                      "label": "return [{**b.to_dict(), \"costs\": costs.get(b.id, [])} for b in blocks]",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "execute_graph_block",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 2,
          "label": "def execute_graph_block(block_id: str, data: BlockInput) -> CompletedBlockOutput:\n    obj = backend.data.block.get_block(block_id)",
          "successors": [
            {
              "id": 2,
              "start_line": 3,
              "end_line": 3,
              "label": "if not obj:",
              "successors": [
                {
                  "id": 3,
                  "start_line": 4,
                  "end_line": 4,
                  "label": "raise HTTPException(status_code=404, detail=f\"Block #{block_id} not found.\")",
                  "successors": []
                }
              ]
            },
            {
              "id": 4,
              "start_line": 5,
              "end_line": 5,
              "label": "output = defaultdict(list)",
              "successors": [
                {
                  "id": 5,
                  "start_line": 6,
                  "end_line": 7,
                  "label": "for name, data in obj.execute(data):\n        output[name].append(data)",
                  "successors": [
                    {
                      "id": 6,
                      "start_line": 8,
                      "end_line": 8,
                      "label": "return output",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "get_user_credits",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 3,
          "label": "async def get_user_credits(\n    user_id: Annotated[str, Depends(get_user_id)],\n) -> dict[str, int]:",
          "successors": [
            {
              "id": 2,
              "start_line": 4,
              "end_line": 5,
              "label": "# Credits can go negative, so ensure it's at least 0 for user to see.\n    return {\"credits\": max(await _user_credit_model.get_or_refill_credit(user_id), 0)}",
              "successors": []
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "get_graphs",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 3,
          "label": "async def get_graphs(\n    user_id: Annotated[str, Depends(get_user_id)]\n) -> Sequence[graph_db.GraphModel]:",
          "successors": [
            {
              "id": 2,
              "start_line": 4,
              "end_line": 4,
              "label": "return await graph_db.get_graphs(filter_by=\"active\", user_id=user_id)",
              "successors": []
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "get_graph",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 9,
          "label": "async def get_graph(\n    graph_id: str,\n    user_id: Annotated[str, Depends(get_user_id)],\n    version: int | None = None,\n    hide_credentials: bool = False,\n) -> graph_db.GraphModel:\n    graph = await graph_db.get_graph(\n        graph_id, version, user_id=user_id, for_export=hide_credentials\n    )",
          "successors": [
            {
              "id": 2,
              "start_line": 10,
              "end_line": 11,
              "label": "if not graph:\n        raise HTTPException(status_code=404, detail=f\"Graph #{graph_id} not found.\")",
              "successors": [
                {
                  "id": 3,
                  "start_line": 12,
                  "end_line": 12,
                  "label": "return graph",
                  "successors": []
                }
              ]
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "get_graph_all_versions",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 3,
          "label": "async def get_graph_all_versions(\n    graph_id: str, user_id: Annotated[str, Depends(get_user_id)]\n) -> Sequence[graph_db.GraphModel]:",
          "successors": [
            {
              "id": 2,
              "start_line": 4,
              "end_line": 4,
              "label": "graphs = await graph_db.get_graph_all_versions(graph_id, user_id=user_id)",
              "successors": [
                {
                  "id": 3,
                  "start_line": 5,
                  "end_line": 5,
                  "label": "if not graphs:",
                  "successors": [
                    {
                      "id": 4,
                      "start_line": 6,
                      "end_line": 6,
                      "label": "raise HTTPException(status_code=404, detail=f\"Graph #{graph_id} not found.\")",
                      "successors": []
                    }
                  ]
                },
                {
                  "id": 5,
                  "start_line": 7,
                  "end_line": 7,
                  "label": "return graphs",
                  "successors": []
                }
              ]
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "create_new_graph",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 3,
          "label": "async def create_new_graph(\n    create_graph: CreateGraph, user_id: Annotated[str, Depends(get_user_id)]\n) -> graph_db.GraphModel:",
          "successors": [
            {
              "id": 2,
              "start_line": 4,
              "end_line": 4,
              "label": "return await do_create_graph(create_graph, is_template=False, user_id=user_id)",
              "successors": []
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "do_create_graph",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 7,
          "label": "async def do_create_graph(\n    create_graph: CreateGraph,\n    is_template: bool,\n    # user_id doesn't have to be annotated like on other endpoints,\n    # because create_graph isn't used directly as an endpoint\n    user_id: str,\n) -> graph_db.GraphModel:",
          "successors": [
            {
              "id": 2,
              "start_line": 8,
              "end_line": 8,
              "label": "if create_graph.graph:",
              "successors": [
                {
                  "id": 3,
                  "start_line": 9,
                  "end_line": 9,
                  "label": "graph = graph_db.make_graph_model(create_graph.graph, user_id)",
                  "successors": [
                    {
                      "id": 7,
                      "start_line": 27,
                      "end_line": 35,
                      "label": "graph.is_template = is_template\n    graph.is_active = not is_template\n    graph.reassign_ids(user_id=user_id, reassign_graph_id=True)\n    graph = await graph_db.create_graph(graph, user_id=user_id)\n    graph = await on_graph_activate(\n        graph,\n        get_credentials=lambda id: integration_creds_manager.get(user_id, id),\n    )\n    return graph",
                      "successors": []
                    }
                  ]
                },
                {
                  "id": 4,
                  "start_line": 10,
                  "end_line": 10,
                  "label": "elif create_graph.template_id:",
                  "successors": [
                    {
                      "id": 5,
                      "start_line": 11,
                      "end_line": 17,
                      "label": "# Create a new graph from a template\n        graph = await graph_db.get_graph(\n            create_graph.template_id,\n            create_graph.template_version,\n            template=True,\n            user_id=user_id,\n        )",
                      "successors": [
                        {
                          "id": 6,
                          "start_line": 18,
                          "end_line": 21,
                          "label": "if not graph:\n            raise HTTPException(\n                400, detail=f\"Template #{create_graph.template_id} not found\"\n            )",
                          "successors": [
                            {
                              "id": 7,
                              "start_line": 27,
                              "end_line": 35,
                              "label": "graph.is_template = is_template\n    graph.is_active = not is_template\n    graph.reassign_ids(user_id=user_id, reassign_graph_id=True)\n    graph = await graph_db.create_graph(graph, user_id=user_id)\n    graph = await on_graph_activate(\n        graph,\n        get_credentials=lambda id: integration_creds_manager.get(user_id, id),\n    )\n    return graph",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "id": 8,
                  "start_line": 23,
                  "end_line": 26,
                  "label": "else:\n        raise HTTPException(\n            status_code=400, detail=\"Either graph or template_id must be provided.\"\n        )",
                  "successors": []
                }
              ]
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "delete_graph",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 3,
          "label": "async def delete_graph(\n    graph_id: str, user_id: Annotated[str, Depends(get_user_id)]\n) -> DeleteGraphResponse:",
          "successors": [
            {
              "id": 2,
              "start_line": 4,
              "end_line": 4,
              "label": "if active_version := await graph_db.get_graph(graph_id, user_id=user_id):",
              "successors": [
                {
                  "id": 3,
                  "start_line": 5,
                  "end_line": 6,
                  "label": "def get_credentials(credentials_id: str) -> \"Credentials | None\":\n            return integration_creds_manager.get(user_id, credentials_id)",
                  "successors": [
                    {
                      "id": 4,
                      "start_line": 7,
                      "end_line": 7,
                      "label": "await on_graph_deactivate(active_version, get_credentials)",
                      "successors": []
                    }
                  ]
                },
                {
                  "id": 5,
                  "start_line": 8,
                  "end_line": 8,
                  "label": "return {\"version_counts\": await graph_db.delete_graph(graph_id, user_id=user_id)}",
                  "successors": []
                }
              ]
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "update_graph",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 5,
          "label": "async def update_graph(\n    graph_id: str,\n    graph: graph_db.Graph,\n    user_id: Annotated[str, Depends(get_user_id)],\n) -> graph_db.GraphModel:",
          "successors": [
            {
              "id": 2,
              "start_line": 6,
              "end_line": 7,
              "label": "# Sanity check\n    if graph.id and graph.id != graph_id:",
              "successors": [
                {
                  "id": 3,
                  "start_line": 8,
                  "end_line": 8,
                  "label": "raise HTTPException(400, detail=\"Graph ID does not match ID in URI\")",
                  "successors": []
                }
              ]
            },
            {
              "id": 4,
              "start_line": 9,
              "end_line": 10,
              "label": "# Determine new version\n    existing_versions = await graph_db.get_graph_all_versions(graph_id, user_id=user_id)",
              "successors": [
                {
                  "id": 5,
                  "start_line": 11,
                  "end_line": 11,
                  "label": "if not existing_versions:",
                  "successors": [
                    {
                      "id": 6,
                      "start_line": 12,
                      "end_line": 12,
                      "label": "raise HTTPException(404, detail=f\"Graph #{graph_id} not found\")",
                      "successors": []
                    }
                  ]
                },
                {
                  "id": 7,
                  "start_line": 13,
                  "end_line": 14,
                  "label": "latest_version_number = max(g.version for g in existing_versions)\n    graph.version = latest_version_number + 1",
                  "successors": [
                    {
                      "id": 8,
                      "start_line": 15,
                      "end_line": 17,
                      "label": "latest_version_graph = next(\n        v for v in existing_versions if v.version == latest_version_number\n    )",
                      "successors": [
                        {
                          "id": 9,
                          "start_line": 18,
                          "end_line": 18,
                          "label": "current_active_version = next((v for v in existing_versions if v.is_active), None)",
                          "successors": [
                            {
                              "id": 10,
                              "start_line": 19,
                              "end_line": 19,
                              "label": "if latest_version_graph.is_template != graph.is_template:",
                              "successors": [
                                {
                                  "id": 11,
                                  "start_line": 20,
                                  "end_line": 22,
                                  "label": "raise HTTPException(\n            400, detail=\"Changing is_template on an existing graph is forbidden\"\n        )",
                                  "successors": []
                                }
                              ]
                            },
                            {
                              "id": 12,
                              "start_line": 23,
                              "end_line": 23,
                              "label": "graph.is_active = not graph.is_template",
                              "successors": [
                                {
                                  "id": 13,
                                  "start_line": 24,
                                  "end_line": 25,
                                  "label": "graph = graph_db.make_graph_model(graph, user_id)\n    graph.reassign_ids(user_id=user_id)",
                                  "successors": [
                                    {
                                      "id": 14,
                                      "start_line": 26,
                                      "end_line": 26,
                                      "label": "new_graph_version = await graph_db.create_graph(graph, user_id=user_id)",
                                      "successors": [
                                        {
                                          "id": 15,
                                          "start_line": 27,
                                          "end_line": 27,
                                          "label": "if new_graph_version.is_active:",
                                          "successors": [
                                            {
                                              "id": 16,
                                              "start_line": 28,
                                              "end_line": 29,
                                              "label": "def get_credentials(credentials_id: str) -> \"Credentials | None\":\n            return integration_creds_manager.get(user_id, credentials_id)",
                                              "successors": [
                                                {
                                                  "id": 17,
                                                  "start_line": 30,
                                                  "end_line": 34,
                                                  "label": "# Handle activation of the new graph first to ensure continuity\n        new_graph_version = await on_graph_activate(\n            new_graph_version,\n            get_credentials=get_credentials,\n        )",
                                                  "successors": [
                                                    {
                                                      "id": 18,
                                                      "start_line": 35,
                                                      "end_line": 38,
                                                      "label": "# Ensure new version is the only active version\n        await graph_db.set_graph_active_version(\n            graph_id=graph_id, version=new_graph_version.version, user_id=user_id\n        )",
                                                      "successors": [
                                                        {
                                                          "id": 19,
                                                          "start_line": 39,
                                                          "end_line": 39,
                                                          "label": "if current_active_version:",
                                                          "successors": [
                                                            {
                                                              "id": 20,
                                                              "start_line": 40,
                                                              "end_line": 44,
                                                              "label": "# Handle deactivation of the previously active version\n            await on_graph_deactivate(\n                current_active_version,\n                get_credentials=get_credentials,\n            )",
                                                              "successors": []
                                                            }
                                                          ]
                                                        }
                                                      ]
                                                    }
                                                  ]
                                                }
                                              ]
                                            }
                                          ]
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "set_graph_active_version",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 5,
          "label": "async def set_graph_active_version(\n    graph_id: str,\n    request_body: SetGraphActiveVersion,\n    user_id: Annotated[str, Depends(get_user_id)],\n):",
          "successors": [
            {
              "id": 2,
              "start_line": 6,
              "end_line": 9,
              "label": "new_active_version = request_body.active_graph_version\n    new_active_graph = await graph_db.get_graph(\n        graph_id, new_active_version, user_id=user_id\n    )",
              "successors": [
                {
                  "id": 3,
                  "start_line": 10,
                  "end_line": 11,
                  "label": "if not new_active_graph:\n        raise HTTPException(404, f\"Graph #{graph_id} v{new_active_version} not found\")",
                  "successors": []
                },
                {
                  "id": 4,
                  "start_line": 12,
                  "end_line": 12,
                  "label": "current_active_graph = await graph_db.get_graph(graph_id, user_id=user_id)",
                  "successors": [
                    {
                      "id": 5,
                      "start_line": 13,
                      "end_line": 14,
                      "label": "def get_credentials(credentials_id: str) -> \"Credentials | None\":\n        return integration_creds_manager.get(user_id, credentials_id)",
                      "successors": [
                        {
                          "id": 6,
                          "start_line": 15,
                          "end_line": 19,
                          "label": "# Handle activation of the new graph first to ensure continuity\n    await on_graph_activate(\n        new_active_graph,\n        get_credentials=get_credentials,\n    )",
                          "successors": [
                            {
                              "id": 7,
                              "start_line": 20,
                              "end_line": 25,
                              "label": "# Ensure new version is the only active version\n    await graph_db.set_graph_active_version(\n        graph_id=graph_id,\n        version=new_active_version,\n        user_id=user_id,\n    )",
                              "successors": [
                                {
                                  "id": 8,
                                  "start_line": 26,
                                  "end_line": 31,
                                  "label": "if current_active_graph and current_active_graph.version != new_active_version:\n        # Handle deactivation of the previously active version\n        await on_graph_deactivate(\n            current_active_graph,\n            get_credentials=get_credentials,\n        )",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "execute_graph",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 5,
          "label": "def execute_graph(\n    graph_id: str,\n    node_input: dict[Any, Any],\n    user_id: Annotated[str, Depends(get_user_id)],\n) -> dict[str, Any]:  # FIXME: add proper return type",
          "successors": [
            {
              "id": 2,
              "start_line": 6,
              "end_line": 6,
              "label": "try:",
              "successors": [
                {
                  "id": 3,
                  "start_line": 7,
                  "end_line": 9,
                  "label": "graph_exec = execution_manager_client().add_execution(\n            graph_id, node_input, user_id=user_id\n        )",
                  "successors": [
                    {
                      "id": 4,
                      "start_line": 10,
                      "end_line": 10,
                      "label": "return {\"id\": graph_exec.graph_exec_id}",
                      "successors": []
                    }
                  ]
                },
                {
                  "id": 5,
                  "start_line": 11,
                  "end_line": 11,
                  "label": "except Exception as e:",
                  "successors": [
                    {
                      "id": 6,
                      "start_line": 12,
                      "end_line": 12,
                      "label": "msg = e.__str__().encode().decode(\"unicode_escape\")",
                      "successors": [
                        {
                          "id": 7,
                          "start_line": 13,
                          "end_line": 13,
                          "label": "raise HTTPException(status_code=400, detail=msg)",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "stop_graph_run",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 3,
          "label": "async def stop_graph_run(\n    graph_exec_id: str, user_id: Annotated[str, Depends(get_user_id)]\n) -> Sequence[execution_db.ExecutionResult]:",
          "successors": [
            {
              "id": 2,
              "start_line": 4,
              "end_line": 4,
              "label": "if not await graph_db.get_execution(user_id=user_id, execution_id=graph_exec_id):",
              "successors": [
                {
                  "id": 3,
                  "start_line": 5,
                  "end_line": 5,
                  "label": "raise HTTPException(404, detail=f\"Agent execution #{graph_exec_id} not found\")",
                  "successors": []
                },
                {
                  "id": 4,
                  "start_line": 6,
                  "end_line": 8,
                  "label": "await asyncio.to_thread(\n        lambda: execution_manager_client().cancel_execution(graph_exec_id)\n    )",
                  "successors": [
                    {
                      "id": 5,
                      "start_line": 10,
                      "end_line": 10,
                      "label": "return await execution_db.get_execution_results(graph_exec_id)",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "get_executions",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 3,
          "label": "async def get_executions(\n    user_id: Annotated[str, Depends(get_user_id)],\n) -> list[graph_db.GraphExecution]:",
          "successors": [
            {
              "id": 2,
              "start_line": 4,
              "end_line": 4,
              "label": "return await graph_db.get_executions(user_id=user_id)",
              "successors": []
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "get_graph_run_node_execution_results",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 5,
          "label": "async def get_graph_run_node_execution_results(\n    graph_id: str,\n    graph_exec_id: str,\n    user_id: Annotated[str, Depends(get_user_id)],\n) -> Sequence[execution_db.ExecutionResult]:",
          "successors": [
            {
              "id": 2,
              "start_line": 6,
              "end_line": 6,
              "label": "graph = await graph_db.get_graph(graph_id, user_id=user_id)",
              "successors": [
                {
                  "id": 3,
                  "start_line": 7,
                  "end_line": 7,
                  "label": "if not graph:",
                  "successors": [
                    {
                      "id": 4,
                      "start_line": 8,
                      "end_line": 8,
                      "label": "raise HTTPException(status_code=404, detail=f\"Graph #{graph_id} not found.\")",
                      "successors": []
                    },
                    {
                      "id": 5,
                      "start_line": 9,
                      "end_line": 9,
                      "label": "return await execution_db.get_execution_results(graph_exec_id)",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "get_templates",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 3,
          "label": "async def get_templates(\n    user_id: Annotated[str, Depends(get_user_id)]\n) -> Sequence[graph_db.GraphModel]:",
          "successors": [
            {
              "id": 2,
              "start_line": 4,
              "end_line": 4,
              "label": "return await graph_db.get_graphs(filter_by=\"template\", user_id=user_id)",
              "successors": []
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "get_template",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 3,
          "label": "async def get_template(\n    graph_id: str, version: int | None = None\n) -> graph_db.GraphModel:",
          "successors": [
            {
              "id": 2,
              "start_line": 4,
              "end_line": 4,
              "label": "graph = await graph_db.get_graph(graph_id, version, template=True)",
              "successors": [
                {
                  "id": 3,
                  "start_line": 5,
                  "end_line": 5,
                  "label": "if not graph:",
                  "successors": [
                    {
                      "id": 4,
                      "start_line": 6,
                      "end_line": 6,
                      "label": "raise HTTPException(status_code=404, detail=f\"Template #{graph_id} not found.\")",
                      "successors": []
                    }
                  ]
                },
                {
                  "id": 5,
                  "start_line": 7,
                  "end_line": 7,
                  "label": "return graph",
                  "successors": []
                }
              ]
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "create_new_template",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 3,
          "label": "async def create_new_template(\n    create_graph: CreateGraph, user_id: Annotated[str, Depends(get_user_id)]\n) -> graph_db.GraphModel:",
          "successors": [
            {
              "id": 2,
              "start_line": 4,
              "end_line": 4,
              "label": "return await do_create_graph(create_graph, is_template=True, user_id=user_id)",
              "successors": []
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "create_schedule",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 4,
          "label": "async def create_schedule(\n    user_id: Annotated[str, Depends(get_user_id)],\n    schedule: ScheduleCreationRequest,\n) -> scheduler.JobInfo:",
          "successors": [
            {
              "id": 2,
              "start_line": 5,
              "end_line": 5,
              "label": "graph = await graph_db.get_graph(schedule.graph_id, user_id=user_id)",
              "successors": [
                {
                  "id": 3,
                  "start_line": 6,
                  "end_line": 6,
                  "label": "if not graph:",
                  "successors": [
                    {
                      "id": 4,
                      "start_line": 7,
                      "end_line": 9,
                      "label": "raise HTTPException(\n            status_code=404, detail=f\"Graph #{schedule.graph_id} not found.\"\n        )",
                      "successors": []
                    },
                    {
                      "id": 5,
                      "start_line": 10,
                      "end_line": 18,
                      "label": "return await asyncio.to_thread(\n        lambda: execution_scheduler_client().add_execution_schedule(\n            graph_id=schedule.graph_id,\n            graph_version=graph.version,\n            cron=schedule.cron,\n            input_data=schedule.input_data,\n            user_id=user_id,\n        )\n    )",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "delete_schedule",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 4,
          "label": "def delete_schedule(\n    schedule_id: str,\n    user_id: Annotated[str, Depends(get_user_id)],\n) -> dict[Any, Any]:",
          "successors": [
            {
              "id": 2,
              "start_line": 5,
              "end_line": 5,
              "label": "execution_scheduler_client().delete_schedule(schedule_id, user_id=user_id)",
              "successors": [
                {
                  "id": 3,
                  "start_line": 6,
                  "end_line": 6,
                  "label": "return {\"id\": schedule_id}",
                  "successors": []
                }
              ]
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "get_execution_schedules",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 4,
          "label": "def get_execution_schedules(\n    user_id: Annotated[str, Depends(get_user_id)],\n    graph_id: str | None = None,\n) -> list[scheduler.JobInfo]:",
          "successors": [
            {
              "id": 2,
              "start_line": 5,
              "end_line": 8,
              "label": "return execution_scheduler_client().get_execution_schedules(\n        user_id=user_id,\n        graph_id=graph_id,\n    )",
              "successors": []
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "create_api_key",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 4,
          "label": "async def create_api_key(\n    request: CreateAPIKeyRequest, user_id: Annotated[str, Depends(get_user_id)]\n) -> CreateAPIKeyResponse:\n    \"\"\"Create a new API key\"\"\"",
          "successors": [
            {
              "id": 2,
              "start_line": 5,
              "end_line": 5,
              "label": "try:",
              "successors": [
                {
                  "id": 3,
                  "start_line": 6,
                  "end_line": 11,
                  "label": "api_key, plain_text = await generate_api_key(\n            name=request.name,\n            user_id=user_id,\n            permissions=request.permissions,\n            description=request.description,\n        )",
                  "successors": [
                    {
                      "id": 4,
                      "start_line": 12,
                      "end_line": 12,
                      "label": "return CreateAPIKeyResponse(api_key=api_key, plain_text_key=plain_text)",
                      "successors": []
                    }
                  ]
                },
                {
                  "id": 5,
                  "start_line": 13,
                  "end_line": 13,
                  "label": "except APIKeyError as e:",
                  "successors": [
                    {
                      "id": 6,
                      "start_line": 14,
                      "end_line": 14,
                      "label": "logger.error(f\"Failed to create API key: {str(e)}\")",
                      "successors": [
                        {
                          "id": 7,
                          "start_line": 15,
                          "end_line": 15,
                          "label": "raise HTTPException(status_code=400, detail=str(e))",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "get_api_keys",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 4,
          "label": "async def get_api_keys(\n    user_id: Annotated[str, Depends(get_user_id)]\n) -> list[APIKeyWithoutHash]:\n    \"\"\"List all API keys for the user\"\"\"",
          "successors": [
            {
              "id": 2,
              "start_line": 5,
              "end_line": 5,
              "label": "try:",
              "successors": [
                {
                  "id": 3,
                  "start_line": 6,
                  "end_line": 6,
                  "label": "return await list_user_api_keys(user_id)",
                  "successors": []
                },
                {
                  "id": 4,
                  "start_line": 7,
                  "end_line": 7,
                  "label": "except APIKeyError as e:",
                  "successors": [
                    {
                      "id": 5,
                      "start_line": 8,
                      "end_line": 8,
                      "label": "logger.error(f\"Failed to list API keys: {str(e)}\")",
                      "successors": [
                        {
                          "id": 6,
                          "start_line": 9,
                          "end_line": 9,
                          "label": "raise HTTPException(status_code=400, detail=str(e))",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "get_api_key",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 4,
          "label": "async def get_api_key(\n    key_id: str, user_id: Annotated[str, Depends(get_user_id)]\n) -> APIKeyWithoutHash:\n    \"\"\"Get a specific API key\"\"\"",
          "successors": [
            {
              "id": 2,
              "start_line": 5,
              "end_line": 5,
              "label": "try:",
              "successors": [
                {
                  "id": 3,
                  "start_line": 6,
                  "end_line": 6,
                  "label": "api_key = await get_api_key_by_id(key_id, user_id)",
                  "successors": [
                    {
                      "id": 4,
                      "start_line": 7,
                      "end_line": 7,
                      "label": "if not api_key:",
                      "successors": [
                        {
                          "id": 5,
                          "start_line": 8,
                          "end_line": 8,
                          "label": "raise HTTPException(status_code=404, detail=\"API key not found\")",
                          "successors": []
                        },
                        {
                          "id": 6,
                          "start_line": 9,
                          "end_line": 9,
                          "label": "return api_key",
                          "successors": []
                        }
                      ]
                    }
                  ]
                },
                {
                  "id": 7,
                  "start_line": 10,
                  "end_line": 10,
                  "label": "except APIKeyError as e:",
                  "successors": [
                    {
                      "id": 8,
                      "start_line": 11,
                      "end_line": 11,
                      "label": "logger.error(f\"Failed to get API key: {str(e)}\")",
                      "successors": [
                        {
                          "id": 9,
                          "start_line": 12,
                          "end_line": 12,
                          "label": "raise HTTPException(status_code=400, detail=str(e))",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "delete_api_key",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 4,
          "label": "async def delete_api_key(\n    key_id: str, user_id: Annotated[str, Depends(get_user_id)]\n) -> Optional[APIKeyWithoutHash]:\n    \"\"\"Revoke an API key\"\"\"",
          "successors": [
            {
              "id": 2,
              "start_line": 5,
              "end_line": 5,
              "label": "try:",
              "successors": [
                {
                  "id": 3,
                  "start_line": 6,
                  "end_line": 6,
                  "label": "return await revoke_api_key(key_id, user_id)",
                  "successors": []
                },
                {
                  "id": 4,
                  "start_line": 7,
                  "end_line": 8,
                  "label": "except APIKeyNotFoundError:\n        raise HTTPException(status_code=404, detail=\"API key not found\")",
                  "successors": []
                },
                {
                  "id": 5,
                  "start_line": 9,
                  "end_line": 10,
                  "label": "except APIKeyPermissionError:\n        raise HTTPException(status_code=403, detail=\"Permission denied\")",
                  "successors": []
                },
                {
                  "id": 6,
                  "start_line": 11,
                  "end_line": 13,
                  "label": "except APIKeyError as e:\n        logger.error(f\"Failed to revoke API key: {str(e)}\")\n        raise HTTPException(status_code=400, detail=str(e))",
                  "successors": []
                }
              ]
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "suspend_key",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 4,
          "label": "async def suspend_key(\n    key_id: str, user_id: Annotated[str, Depends(get_user_id)]\n) -> Optional[APIKeyWithoutHash]:\n    \"\"\"Suspend an API key\"\"\"",
          "successors": [
            {
              "id": 2,
              "start_line": 5,
              "end_line": 5,
              "label": "try:",
              "successors": [
                {
                  "id": 3,
                  "start_line": 6,
                  "end_line": 6,
                  "label": "return await suspend_api_key(key_id, user_id)",
                  "successors": []
                },
                {
                  "id": 4,
                  "start_line": 7,
                  "end_line": 8,
                  "label": "except APIKeyNotFoundError:\n        raise HTTPException(status_code=404, detail=\"API key not found\")",
                  "successors": []
                },
                {
                  "id": 5,
                  "start_line": 9,
                  "end_line": 10,
                  "label": "except APIKeyPermissionError:\n        raise HTTPException(status_code=403, detail=\"Permission denied\")",
                  "successors": []
                },
                {
                  "id": 6,
                  "start_line": 11,
                  "end_line": 13,
                  "label": "except APIKeyError as e:\n        logger.error(f\"Failed to suspend API key: {str(e)}\")\n        raise HTTPException(status_code=400, detail=str(e))",
                  "successors": []
                }
              ]
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "update_permissions",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 6,
          "label": "async def update_permissions(\n    key_id: str,\n    request: UpdatePermissionsRequest,\n    user_id: Annotated[str, Depends(get_user_id)],\n) -> Optional[APIKeyWithoutHash]:\n    \"\"\"Update API key permissions\"\"\"",
          "successors": [
            {
              "id": 2,
              "start_line": 7,
              "end_line": 7,
              "label": "try:",
              "successors": [
                {
                  "id": 3,
                  "start_line": 8,
                  "end_line": 8,
                  "label": "return await update_api_key_permissions(key_id, user_id, request.permissions)",
                  "successors": []
                },
                {
                  "id": 4,
                  "start_line": 9,
                  "end_line": 10,
                  "label": "except APIKeyNotFoundError:\n        raise HTTPException(status_code=404, detail=\"API key not found\")",
                  "successors": []
                },
                {
                  "id": 5,
                  "start_line": 11,
                  "end_line": 12,
                  "label": "except APIKeyPermissionError:\n        raise HTTPException(status_code=403, detail=\"Permission denied\")",
                  "successors": []
                },
                {
                  "id": 6,
                  "start_line": 13,
                  "end_line": 15,
                  "label": "except APIKeyError as e:\n        logger.error(f\"Failed to update API key permissions: {str(e)}\")\n        raise HTTPException(status_code=400, detail=str(e))",
                  "successors": []
                }
              ]
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    }
  ],
  "classes": [
    {
      "name": "DeleteGraphResponse",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 2,
          "label": "class DeleteGraphResponse(TypedDict):\n    version_counts: int",
          "successors": []
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "ScheduleCreationRequest",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 4,
          "label": "class ScheduleCreationRequest(pydantic.BaseModel):\n    cron: str\n    input_data: dict[Any, Any]\n    graph_id: str",
          "successors": []
        }
      ],
      "functions": [],
      "classes": []
    }
  ]
}