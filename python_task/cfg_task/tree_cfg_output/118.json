{
  "name": "example_script",
  "type": "CFG",
  "blocks": [
    {
      "id": 1,
      "start_line": 1,
      "end_line": 8,
      "label": "\"\"\"\nauthor: Aayush Soni\nGiven n pairs of parentheses, write a function to generate all\ncombinations of well-formed parentheses.\nInput: n = 2\nOutput: [\"(())\",\"()()\"]\nLeetcode link: https://leetcode.com/problems/generate-parentheses/description/\n\"\"\"",
      "successors": [
        {
          "id": 2,
          "start_line": 9,
          "end_line": 11,
          "label": "if __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
          "successors": []
        }
      ]
    }
  ],
  "functions": [
    {
      "name": "backtrack",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 19,
          "label": "def backtrack(\n    partial: str, open_count: int, close_count: int, n: int, result: list[str]\n) -> None:\n    \"\"\"\n    Generate valid combinations of balanced parentheses using recursion.\n    :param partial: A string representing the current combination.\n    :param open_count: An integer representing the count of open parentheses.\n    :param close_count: An integer representing the count of close parentheses.\n    :param n: An integer representing the total number of pairs.\n    :param result: A list to store valid combinations.\n    :return: None\n    This function uses recursion to explore all possible combinations,\n    ensuring that at each step, the parentheses remain balanced.\n    Example:\n    >>> result = []\n    >>> backtrack(\"\", 0, 0, 2, result)\n    >>> result\n    ['(())', '()()']\n    \"\"\"",
          "successors": [
            {
              "id": 2,
              "start_line": 20,
              "end_line": 23,
              "label": "if len(partial) == 2 * n:\n        # When the combination is complete, add it to the result.\n        result.append(partial)\n        return",
              "successors": [
                {
                  "id": 3,
                  "start_line": 24,
                  "end_line": 26,
                  "label": "if open_count < n:\n        # If we can add an open parenthesis, do so, and recurse.\n        backtrack(partial + \"(\", open_count + 1, close_count, n, result)",
                  "successors": [
                    {
                      "id": 4,
                      "start_line": 27,
                      "end_line": 30,
                      "label": "if close_count < open_count:\n        # If we can add a close parenthesis (it won't make the combination invalid),\n        # do so, and recurse.\n        backtrack(partial + \")\", open_count, close_count + 1, n, result)",
                      "successors": []
                    }
                  ]
                },
                {
                  "id": 4,
                  "start_line": 27,
                  "end_line": 30,
                  "label": "if close_count < open_count:\n        # If we can add a close parenthesis (it won't make the combination invalid),\n        # do so, and recurse.\n        backtrack(partial + \")\", open_count, close_count + 1, n, result)",
                  "successors": []
                }
              ]
            },
            {
              "id": 3,
              "start_line": 24,
              "end_line": 26,
              "label": "if open_count < n:\n        # If we can add an open parenthesis, do so, and recurse.\n        backtrack(partial + \"(\", open_count + 1, close_count, n, result)",
              "successors": [
                {
                  "id": 4,
                  "start_line": 27,
                  "end_line": 30,
                  "label": "if close_count < open_count:\n        # If we can add a close parenthesis (it won't make the combination invalid),\n        # do so, and recurse.\n        backtrack(partial + \")\", open_count, close_count + 1, n, result)",
                  "successors": []
                }
              ]
            },
            {
              "id": 4,
              "start_line": 27,
              "end_line": 30,
              "label": "if close_count < open_count:\n        # If we can add a close parenthesis (it won't make the combination invalid),\n        # do so, and recurse.\n        backtrack(partial + \")\", open_count, close_count + 1, n, result)",
              "successors": []
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "generate_parenthesis",
      "type": "CFG",
      "blocks": [
        {
          "id": 1,
          "start_line": 1,
          "end_line": 15,
          "label": "def generate_parenthesis(n: int) -> list[str]:\n    \"\"\"\n    Generate valid combinations of balanced parentheses for a given n.\n    :param n: An integer representing the number of pairs of parentheses.\n    :return: A list of strings with valid combinations.\n    This function uses a recursive approach to generate the combinations.\n    Time Complexity: O(2^(2n)) - In the worst case, we have 2^(2n) combinations.\n    Space Complexity: O(n) - where 'n' is the number of pairs.\n    Example 1:\n    >>> generate_parenthesis(3)\n    ['((()))', '(()())', '(())()', '()(())', '()()()']\n    Example 2:\n    >>> generate_parenthesis(1)\n    ['()']\n    \"\"\"",
          "successors": [
            {
              "id": 2,
              "start_line": 16,
              "end_line": 16,
              "label": "result: list[str] = []",
              "successors": [
                {
                  "id": 3,
                  "start_line": 17,
                  "end_line": 17,
                  "label": "backtrack(\"\", 0, 0, n, result)",
                  "successors": [
                    {
                      "id": 4,
                      "start_line": 18,
                      "end_line": 18,
                      "label": "return result",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    }
  ],
  "classes": []
}