[
  {
    "decl_name": "GlobalBlock",
    "start_line": 0,
    "end_line": 61,
    "children": [
      {
        "decl_name": "match_word_pattern",
        "start_line": 0,
        "end_line": 54,
        "children": [
          {
            "decl_name": "match_word_pattern.backtrack",
            "start_line": 18,
            "end_line": 50,
            "children": [],
            "code": "    def backtrack(pattern_index: int, str_index: int) -> bool:\n        \"\"\"\n        >>> backtrack(0, 0)\n        True\n\n        >>> backtrack(0, 1)\n        True\n\n        >>> backtrack(0, 4)\n        False\n        \"\"\"\n        if pattern_index == len(pattern) and str_index == len(input_string):\n            return True\n        if pattern_index == len(pattern) or str_index == len(input_string):\n            return False\n        char = pattern[pattern_index]\n        if char in pattern_map:\n            mapped_str = pattern_map[char]\n            if input_string.startswith(mapped_str, str_index):\n                return backtrack(pattern_index + 1, str_index + len(mapped_str))\n            else:\n                return False\n        for end in range(str_index + 1, len(input_string) + 1):\n            substr = input_string[str_index:end]\n            if substr in str_map:\n                continue\n            pattern_map[char] = substr\n            str_map[substr] = char\n            if backtrack(pattern_index + 1, end):\n                return True\n            del pattern_map[char]\n            del str_map[substr]\n        return False\n",
            "cfg": {
              "nodes": [
                {
                  "id": "match_word_pattern.backtrack_1",
                  "code": "def backtrack(pattern_index: int, str_index: int) -> bool:\n        \"\"\"\n        >>> backtrack(0, 0)\n        True\n\n        >>> backtrack(0, 1)\n        True\n\n        >>> backtrack(0, 4)\n        False\n        \"\"\"\n"
                },
                {
                  "id": "match_word_pattern.backtrack_2",
                  "code": "        if pattern_index == len(pattern) and str_index == len(input_string):\n            return True\n"
                },
                {
                  "id": "match_word_pattern.backtrack_3",
                  "code": "        if pattern_index == len(pattern) or str_index == len(input_string):\n            return False\n"
                },
                {
                  "id": "match_word_pattern.backtrack_4",
                  "code": "        char = pattern[pattern_index]\n        if char in pattern_map:\n"
                },
                {
                  "id": "match_word_pattern.backtrack_5",
                  "code": "            mapped_str = pattern_map[char]\n            if input_string.startswith(mapped_str, str_index):\n                return backtrack(pattern_index + 1, str_index + len(mapped_str))\n"
                },
                {
                  "id": "match_word_pattern.backtrack_6",
                  "code": "            else:\n                return False\n"
                },
                {
                  "id": "match_word_pattern.backtrack_7",
                  "code": "        for end in range(str_index + 1, len(input_string) + 1):\n            substr = input_string[str_index:end]\n            if substr in str_map:\n"
                },
                {
                  "id": "match_word_pattern.backtrack_8",
                  "code": "                continue\n"
                },
                {
                  "id": "match_word_pattern.backtrack_9",
                  "code": "            pattern_map[char] = substr\n            str_map[substr] = char\n"
                },
                {
                  "id": "match_word_pattern.backtrack_10",
                  "code": "            if backtrack(pattern_index + 1, end):\n                return True\n"
                },
                {
                  "id": "match_word_pattern.backtrack_11",
                  "code": "            del pattern_map[char]\n            del str_map[substr]\n"
                },
                {
                  "id": "match_word_pattern.backtrack_12",
                  "code": "        return False\n"
                }
              ],
              "edges": [
                {
                  "from": "match_word_pattern.backtrack_1",
                  "to": "match_word_pattern.backtrack_2"
                },
                {
                  "from": "match_word_pattern.backtrack_2",
                  "to": "match_word_pattern.backtrack_3"
                },
                {
                  "from": "match_word_pattern.backtrack_2",
                  "to": "match_word_pattern.backtrack_4"
                },
                {
                  "from": "match_word_pattern.backtrack_4",
                  "to": "match_word_pattern.backtrack_5"
                },
                {
                  "from": "match_word_pattern.backtrack_4",
                  "to": "match_word_pattern.backtrack_7"
                },
                {
                  "from": "match_word_pattern.backtrack_5",
                  "to": "match_word_pattern.backtrack_6"
                },
                {
                  "from": "match_word_pattern.backtrack_7",
                  "to": "match_word_pattern.backtrack_8"
                },
                {
                  "from": "match_word_pattern.backtrack_7",
                  "to": "match_word_pattern.backtrack_9"
                },
                {
                  "from": "match_word_pattern.backtrack_8",
                  "to": "match_word_pattern.backtrack_7"
                },
                {
                  "from": "match_word_pattern.backtrack_9",
                  "to": "match_word_pattern.backtrack_10"
                },
                {
                  "from": "match_word_pattern.backtrack_10",
                  "to": "match_word_pattern.backtrack_11"
                },
                {
                  "from": "match_word_pattern.backtrack_10",
                  "to": "match_word_pattern.backtrack_12"
                },
                {
                  "from": "match_word_pattern.backtrack_11",
                  "to": "match_word_pattern.backtrack_7"
                }
              ]
            }
          }
        ],
        "code": "def match_word_pattern(pattern: str, input_string: str) -> bool:\n    \"\"\"\n    Determine if a given pattern matches a string using backtracking.\n\n    pattern: The pattern to match.\n    input_string: The string to match against the pattern.\n    return: True if the pattern matches the string, False otherwise.\n\n    >>> match_word_pattern(\"aba\", \"GraphTreesGraph\")\n    True\n\n    >>> match_word_pattern(\"xyx\", \"PythonRubyPython\")\n    True\n\n    >>> match_word_pattern(\"GG\", \"PythonJavaPython\")\n    False\n    \"\"\"\n\n\n    pattern_map: dict[str, str] = {}\n    str_map: dict[str, str] = {}\n    return backtrack(0, 0)\n",
        "cfg": {
          "nodes": [
            {
              "id": "match_word_pattern_1",
              "code": "def match_word_pattern(pattern: str, input_string: str) -> bool:\n    \"\"\"\n    Determine if a given pattern matches a string using backtracking.\n\n    pattern: The pattern to match.\n    input_string: The string to match against the pattern.\n    return: True if the pattern matches the string, False otherwise.\n\n    >>> match_word_pattern(\"aba\", \"GraphTreesGraph\")\n    True\n\n    >>> match_word_pattern(\"xyx\", \"PythonRubyPython\")\n    True\n\n    >>> match_word_pattern(\"GG\", \"PythonJavaPython\")\n    False\n    \"\"\"\n"
            },
            {
              "id": "match_word_pattern_2",
              "code": "    pattern_map: dict[str, str] = {}\n    str_map: dict[str, str] = {}\n"
            },
            {
              "id": "match_word_pattern_3",
              "code": "    return backtrack(0, 0)\n"
            }
          ],
          "edges": [
            {
              "from": "match_word_pattern_1",
              "to": "match_word_pattern_2"
            },
            {
              "from": "match_word_pattern_2",
              "to": "match_word_pattern_3"
            }
          ]
        }
      },
      {
        "decl_name": "__main__",
        "start_line": 57,
        "end_line": 60,
        "children": [],
        "code": "if __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n",
        "cfg": {
          "nodes": [
            {
              "id": "__main___1",
              "code": "if __name__ == \"__main__\":\n"
            },
            {
              "id": "__main___2",
              "code": "    import doctest\n\n    doctest.testmod()\n"
            }
          ],
          "edges": [
            {
              "from": "__main___1",
              "to": "__main___2"
            }
          ]
        }
      }
    ],
    "code": "\n\n\n"
  }
]