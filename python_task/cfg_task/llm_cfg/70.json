[
  {
    "decl_name": "GlobalBlock",
    "start_line": 0,
    "end_line": 40,
    "children": [],
    "code": "import logging\nfrom typing import TYPE_CHECKING, Annotated, Literal\n\nfrom fastapi import APIRouter, Body, Depends, HTTPException, Path, Query, Request\nfrom pydantic import BaseModel, Field, SecretStr\n\nfrom backend.data.graph import set_node_webhook\nfrom backend.data.integrations import (\n    WebhookEvent,\n    get_all_webhooks_by_creds,\n    get_webhook,\n    publish_webhook_event,\n    wait_for_webhook_event,\n)\nfrom backend.data.model import (\n    APIKeyCredentials,\n    Credentials,\n    CredentialsType,\n    OAuth2Credentials,\n)\nfrom backend.executor.manager import ExecutionManager\nfrom backend.integrations.creds_manager import IntegrationCredentialsManager\nfrom backend.integrations.oauth import HANDLERS_BY_NAME\nfrom backend.integrations.providers import ProviderName\nfrom backend.integrations.webhooks import WEBHOOK_MANAGERS_BY_NAME\nfrom backend.util.exceptions import NeedConfirmation\nfrom backend.util.service import get_service_client\nfrom backend.util.settings import Settings\n\nif TYPE_CHECKING:\n    from backend.integrations.oauth import BaseOAuthHandler\n\nfrom ..utils import get_user_id\n\nlogger = logging.getLogger(__name__)\nsettings = Settings()\nrouter = APIRouter()\n\ncreds_manager = IntegrationCredentialsManager()\n\n\n",
    "cfg": {
      "nodes": [
        {
          "id": "GlobalBlock_1",
          "code": "import logging\nfrom typing import TYPE_CHECKING, Annotated, Literal\n"
        },
        {
          "id": "GlobalBlock_2",
          "code": "from fastapi import APIRouter, Body, Depends, HTTPException, Path, Query, Request\nfrom pydantic import BaseModel, Field, SecretStr\n"
        },
        {
          "id": "GlobalBlock_3",
          "code": "from backend.data.graph import set_node_webhook\nfrom backend.data.integrations import (\n    WebhookEvent,\n    get_all_webhooks_by_creds,\n    get_webhook,\n    publish_webhook_event,\n    wait_for_webhook_event,\n)\n"
        },
        {
          "id": "GlobalBlock_4",
          "code": "from backend.data.model import (\n    APIKeyCredentials,\n    Credentials,\n    CredentialsType,\n    OAuth2Credentials,\n)\n"
        },
        {
          "id": "GlobalBlock_5",
          "code": "from backend.executor.manager import ExecutionManager\nfrom backend.integrations.creds_manager import IntegrationCredentialsManager\nfrom backend.integrations.oauth import HANDLERS_BY_NAME\nfrom backend.integrations.providers import ProviderName\nfrom backend.integrations.webhooks import WEBHOOK_MANAGERS_BY_NAME\nfrom backend.util.exceptions import NeedConfirmation\nfrom backend.util.service import get_service_client\nfrom backend.util.settings import Settings\n"
        },
        {
          "id": "GlobalBlock_6",
          "code": "if TYPE_CHECKING:\n    from backend.integrations.oauth import BaseOAuthHandler\n"
        },
        {
          "id": "GlobalBlock_7",
          "code": "from ..utils import get_user_id\n"
        },
        {
          "id": "GlobalBlock_8",
          "code": "logger = logging.getLogger(__name__)\nsettings = Settings()\nrouter = APIRouter()\n"
        },
        {
          "id": "GlobalBlock_9",
          "code": "creds_manager = IntegrationCredentialsManager()\n"
        }
      ],
      "edges": [
        {
          "from": "GlobalBlock_1",
          "to": "GlobalBlock_2"
        },
        {
          "from": "GlobalBlock_2",
          "to": "GlobalBlock_3"
        },
        {
          "from": "GlobalBlock_3",
          "to": "GlobalBlock_4"
        },
        {
          "from": "GlobalBlock_4",
          "to": "GlobalBlock_5"
        },
        {
          "from": "GlobalBlock_5",
          "to": "GlobalBlock_6"
        },
        {
          "from": "GlobalBlock_6",
          "to": "GlobalBlock_7"
        },
        {
          "from": "GlobalBlock_7",
          "to": "GlobalBlock_8"
        },
        {
          "from": "GlobalBlock_8",
          "to": "GlobalBlock_9"
        }
      ]
    }
  },
  {
    "decl_name": "LoginResponse",
    "start_line": 41,
    "end_line": 43,
    "children": [],
    "code": "class LoginResponse(BaseModel):\n    login_url: str\n    state_token: str\n",
    "cfg": {
      "nodes": [
        {
          "id": "LoginResponse_1",
          "code": "class LoginResponse(BaseModel):\n    login_url: str\n    state_token: str\n"
        }
      ],
      "edges": []
    }
  },
  {
    "decl_name": "login",
    "start_line": 46,
    "end_line": 68,
    "children": [],
    "code": "@router.get(\"/{provider}/login\")\ndef login(\n    provider: Annotated[\n        ProviderName, Path(title=\"The provider to initiate an OAuth flow for\")\n    ],\n    user_id: Annotated[str, Depends(get_user_id)],\n    request: Request,\n    scopes: Annotated[\n        str, Query(title=\"Comma-separated list of authorization scopes\")\n    ] = \"\",\n) -> LoginResponse:\n    handler = _get_provider_oauth_handler(request, provider)\n\n    requested_scopes = scopes.split(\",\") if scopes else []\n\n    # Generate and store a secure random state token along with the scopes\n    state_token = creds_manager.store.store_state_token(\n        user_id, provider, requested_scopes\n    )\n\n    login_url = handler.get_login_url(requested_scopes, state_token)\n\n    return LoginResponse(login_url=login_url, state_token=state_token)\n",
    "cfg": {
      "nodes": [
        {
          "id": "login_1",
          "code": "@router.get(\"/{provider}/login\")\ndef login(\n    provider: Annotated[\n        ProviderName, Path(title=\"The provider to initiate an OAuth flow for\")\n    ],\n    user_id: Annotated[str, Depends(get_user_id)],\n    request: Request,\n    scopes: Annotated[\n        str, Query(title=\"Comma-separated list of authorization scopes\")\n    ] = \"\",\n) -> LoginResponse:\n"
        },
        {
          "id": "login_2",
          "code": "    handler = _get_provider_oauth_handler(request, provider)\n"
        },
        {
          "id": "login_3",
          "code": "    requested_scopes = scopes.split(\",\") if scopes else []\n"
        },
        {
          "id": "login_4",
          "code": "    # Generate and store a secure random state token along with the scopes\n    state_token = creds_manager.store.store_state_token(\n        user_id, provider, requested_scopes\n    )\n"
        },
        {
          "id": "login_5",
          "code": "    login_url = handler.get_login_url(requested_scopes, state_token)\n"
        },
        {
          "id": "login_6",
          "code": "    return LoginResponse(login_url=login_url, state_token=state_token)\n"
        }
      ],
      "edges": [
        {
          "from": "login_1",
          "to": "login_2"
        },
        {
          "from": "login_2",
          "to": "login_3"
        },
        {
          "from": "login_3",
          "to": "login_4"
        },
        {
          "from": "login_4",
          "to": "login_5"
        },
        {
          "from": "login_5",
          "to": "login_6"
        }
      ]
    }
  },
  {
    "decl_name": "CredentialsMetaResponse",
    "start_line": 71,
    "end_line": 77,
    "children": [],
    "code": "class CredentialsMetaResponse(BaseModel):\n    id: str\n    provider: str\n    type: CredentialsType\n    title: str | None\n    scopes: list[str] | None\n    username: str | None\n",
    "cfg": {
      "nodes": [
        {
          "id": "CredentialsMetaResponse_1",
          "code": "class CredentialsMetaResponse(BaseModel):\n    id: str\n    provider: str\n    type: CredentialsType\n    title: str | None\n    scopes: list[str] | None\n    username: str | None\n"
        }
      ],
      "edges": []
    }
  },
  {
    "decl_name": "callback",
    "start_line": 80,
    "end_line": 137,
    "children": [],
    "code": "@router.post(\"/{provider}/callback\")\ndef callback(\n    provider: Annotated[\n        ProviderName, Path(title=\"The target provider for this OAuth exchange\")\n    ],\n    code: Annotated[str, Body(title=\"Authorization code acquired by user login\")],\n    state_token: Annotated[str, Body(title=\"Anti-CSRF nonce\")],\n    user_id: Annotated[str, Depends(get_user_id)],\n    request: Request,\n) -> CredentialsMetaResponse:\n    logger.debug(f\"Received OAuth callback for provider: {provider}\")\n    handler = _get_provider_oauth_handler(request, provider)\n\n    # Verify the state token\n    if not creds_manager.store.verify_state_token(user_id, state_token, provider):\n        logger.warning(f\"Invalid or expired state token for user {user_id}\")\n        raise HTTPException(status_code=400, detail=\"Invalid or expired state token\")\n\n    try:\n        scopes = creds_manager.store.get_any_valid_scopes_from_state_token(\n            user_id, state_token, provider\n        )\n        logger.debug(f\"Retrieved scopes from state token: {scopes}\")\n\n        scopes = handler.handle_default_scopes(scopes)\n\n        credentials = handler.exchange_code_for_tokens(code, scopes)\n        logger.debug(f\"Received credentials with final scopes: {credentials.scopes}\")\n\n        # Check if the granted scopes are sufficient for the requested scopes\n        if not set(scopes).issubset(set(credentials.scopes)):\n            # For now, we'll just log the warning and continue\n            logger.warning(\n                f\"Granted scopes {credentials.scopes} for provider {provider.value} \"\n                f\"do not include all requested scopes {scopes}\"\n            )\n\n    except Exception as e:\n        logger.error(f\"Code->Token exchange failed for provider {provider.value}: {e}\")\n        raise HTTPException(\n            status_code=400, detail=f\"Failed to exchange code for tokens: {str(e)}\"\n        )\n\n    # TODO: Allow specifying `title` to set on `credentials`\n    creds_manager.create(user_id, credentials)\n\n    logger.debug(\n        f\"Successfully processed OAuth callback for user {user_id} \"\n        f\"and provider {provider.value}\"\n    )\n    return CredentialsMetaResponse(\n        id=credentials.id,\n        provider=credentials.provider,\n        type=credentials.type,\n        title=credentials.title,\n        scopes=credentials.scopes,\n        username=credentials.username,\n    )\n",
    "cfg": {
      "nodes": [
        {
          "id": "callback_1",
          "code": "@router.post(\"/{provider}/callback\")\ndef callback(\n    provider: Annotated[\n        ProviderName, Path(title=\"The target provider for this OAuth exchange\")\n    ],\n    code: Annotated[str, Body(title=\"Authorization code acquired by user login\")],\n    state_token: Annotated[str, Body(title=\"Anti-CSRF nonce\")],\n    user_id: Annotated[str, Depends(get_user_id)],\n    request: Request,\n) -> CredentialsMetaResponse:\n"
        },
        {
          "id": "callback_2",
          "code": "    logger.debug(f\"Received OAuth callback for provider: {provider}\")\n    handler = _get_provider_oauth_handler(request, provider)\n"
        },
        {
          "id": "callback_3",
          "code": "    # Verify the state token\n    if not creds_manager.store.verify_state_token(user_id, state_token, provider):\n        logger.warning(f\"Invalid or expired state token for user {user_id}\")\n        raise HTTPException(status_code=400, detail=\"Invalid or expired state token\")\n"
        },
        {
          "id": "callback_4",
          "code": "    try:\n        scopes = creds_manager.store.get_any_valid_scopes_from_state_token(\n            user_id, state_token, provider\n        )\n        logger.debug(f\"Retrieved scopes from state token: {scopes}\")\n"
        },
        {
          "id": "callback_5",
          "code": "        scopes = handler.handle_default_scopes(scopes)\n"
        },
        {
          "id": "callback_6",
          "code": "        credentials = handler.exchange_code_for_tokens(code, scopes)\n        logger.debug(f\"Received credentials with final scopes: {credentials.scopes}\")\n"
        },
        {
          "id": "callback_7",
          "code": "        # Check if the granted scopes are sufficient for the requested scopes\n        if not set(scopes).issubset(set(credentials.scopes)):\n            # For now, we'll just log the warning and continue\n            logger.warning(\n                f\"Granted scopes {credentials.scopes} for provider {provider.value} \"\n                f\"do not include all requested scopes {scopes}\"\n            )\n"
        },
        {
          "id": "callback_8",
          "code": "    except Exception as e:\n        logger.error(f\"Code->Token exchange failed for provider {provider.value}: {e}\")\n        raise HTTPException(\n            status_code=400, detail=f\"Failed to exchange code for tokens: {str(e)}\"\n        )\n"
        },
        {
          "id": "callback_9",
          "code": "    # TODO: Allow specifying `title` to set on `credentials`\n    creds_manager.create(user_id, credentials)\n"
        },
        {
          "id": "callback_10",
          "code": "    logger.debug(\n        f\"Successfully processed OAuth callback for user {user_id} \"\n        f\"and provider {provider.value}\"\n    )\n"
        },
        {
          "id": "callback_11",
          "code": "    return CredentialsMetaResponse(\n        id=credentials.id,\n        provider=credentials.provider,\n        type=credentials.type,\n        title=credentials.title,\n        scopes=credentials.scopes,\n        username=credentials.username,\n    )\n"
        }
      ],
      "edges": [
        {
          "from": "callback_1",
          "to": "callback_2"
        },
        {
          "from": "callback_2",
          "to": "callback_3"
        },
        {
          "from": "callback_3",
          "to": "callback_4"
        },
        {
          "from": "callback_3",
          "to": "callback_8"
        },
        {
          "from": "callback_4",
          "to": "callback_5"
        },
        {
          "from": "callback_5",
          "to": "callback_6"
        },
        {
          "from": "callback_6",
          "to": "callback_7"
        },
        {
          "from": "callback_7",
          "to": "callback_9"
        },
        {
          "from": "callback_9",
          "to": "callback_10"
        },
        {
          "from": "callback_10",
          "to": "callback_11"
        }
      ]
    }
  },
  {
    "decl_name": "list_credentials",
    "start_line": 140,
    "end_line": 155,
    "children": [],
    "code": "@router.get(\"/credentials\")\ndef list_credentials(\n    user_id: Annotated[str, Depends(get_user_id)],\n) -> list[CredentialsMetaResponse]:\n    credentials = creds_manager.store.get_all_creds(user_id)\n    return [\n        CredentialsMetaResponse(\n            id=cred.id,\n            provider=cred.provider,\n            type=cred.type,\n            title=cred.title,\n            scopes=cred.scopes if isinstance(cred, OAuth2Credentials) else None,\n            username=cred.username if isinstance(cred, OAuth2Credentials) else None,\n        )\n        for cred in credentials\n    ]\n",
    "cfg": {
      "nodes": [
        {
          "id": "list_credentials_1",
          "code": "@router.get(\"/credentials\")\ndef list_credentials(\n    user_id: Annotated[str, Depends(get_user_id)],\n) -> list[CredentialsMetaResponse]:\n"
        },
        {
          "id": "list_credentials_2",
          "code": "    credentials = creds_manager.store.get_all_creds(user_id)\n"
        },
        {
          "id": "list_credentials_3",
          "code": "    return [\n        CredentialsMetaResponse(\n            id=cred.id,\n            provider=cred.provider,\n            type=cred.type,\n            title=cred.title,\n            scopes=cred.scopes if isinstance(cred, OAuth2Credentials) else None,\n            username=cred.username if isinstance(cred, OAuth2Credentials) else None,\n        )\n        for cred in credentials\n    ]\n"
        }
      ],
      "edges": [
        {
          "from": "list_credentials_1",
          "to": "list_credentials_2"
        },
        {
          "from": "list_credentials_2",
          "to": "list_credentials_3"
        }
      ]
    }
  },
  {
    "decl_name": "list_credentials_by_provider",
    "start_line": 159,
    "end_line": 176,
    "children": [],
    "code": "def list_credentials_by_provider(\n    provider: Annotated[\n        ProviderName, Path(title=\"The provider to list credentials for\")\n    ],\n    user_id: Annotated[str, Depends(get_user_id)],\n) -> list[CredentialsMetaResponse]:\n    credentials = creds_manager.store.get_creds_by_provider(user_id, provider)\n    return [\n        CredentialsMetaResponse(\n            id=cred.id,\n            provider=cred.provider,\n            type=cred.type,\n            title=cred.title,\n            scopes=cred.scopes if isinstance(cred, OAuth2Credentials) else None,\n            username=cred.username if isinstance(cred, OAuth2Credentials) else None,\n        )\n        for cred in credentials\n    ]\n",
    "cfg": {
      "nodes": [
        {
          "id": "list_credentials_by_provider_1",
          "code": "def list_credentials_by_provider(\n    provider: Annotated[\n        ProviderName, Path(title=\"The provider to list credentials for\")\n    ],\n    user_id: Annotated[str, Depends(get_user_id)],\n) -> list[CredentialsMetaResponse]:\n"
        },
        {
          "id": "list_credentials_by_provider_2",
          "code": "    credentials = creds_manager.store.get_creds_by_provider(user_id, provider)\n"
        },
        {
          "id": "list_credentials_by_provider_3",
          "code": "    return [\n        CredentialsMetaResponse(\n            id=cred.id,\n            provider=cred.provider,\n            type=cred.type,\n            title=cred.title,\n            scopes=cred.scopes if isinstance(cred, OAuth2Credentials) else None,\n            username=cred.username if isinstance(cred, OAuth2Credentials) else None,\n        )\n        for cred in credentials\n    ]\n"
        }
      ],
      "edges": [
        {
          "from": "list_credentials_by_provider_1",
          "to": "list_credentials_by_provider_2"
        },
        {
          "from": "list_credentials_by_provider_2",
          "to": "list_credentials_by_provider_3"
        }
      ]
    }
  },
  {
    "decl_name": "get_credential",
    "start_line": 180,
    "end_line": 194,
    "children": [],
    "code": "def get_credential(\n    provider: Annotated[\n        ProviderName, Path(title=\"The provider to retrieve credentials for\")\n    ],\n    cred_id: Annotated[str, Path(title=\"The ID of the credentials to retrieve\")],\n    user_id: Annotated[str, Depends(get_user_id)],\n) -> Credentials:\n    credential = creds_manager.get(user_id, cred_id)\n    if not credential:\n        raise HTTPException(status_code=404, detail=\"Credentials not found\")\n    if credential.provider != provider:\n        raise HTTPException(\n            status_code=404, detail=\"Credentials do not match the specified provider\"\n        )\n    return credential\n",
    "cfg": {
      "nodes": [
        {
          "id": "get_credential_1",
          "code": "def get_credential(\n    provider: Annotated[\n        ProviderName, Path(title=\"The provider to retrieve credentials for\")\n    ],\n    cred_id: Annotated[str, Path(title=\"The ID of the credentials to retrieve\")],\n    user_id: Annotated[str, Depends(get_user_id)],\n) -> Credentials:\n"
        },
        {
          "id": "get_credential_2",
          "code": "    credential = creds_manager.get(user_id, cred_id)\n"
        },
        {
          "id": "get_credential_3",
          "code": "    if not credential:\n        raise HTTPException(status_code=404, detail=\"Credentials not found\")\n"
        },
        {
          "id": "get_credential_4",
          "code": "    if credential.provider != provider:\n        raise HTTPException(\n            status_code=404, detail=\"Credentials do not match the specified provider\"\n        )\n"
        },
        {
          "id": "get_credential_5",
          "code": "    return credential\n"
        }
      ],
      "edges": [
        {
          "from": "get_credential_1",
          "to": "get_credential_2"
        },
        {
          "from": "get_credential_2",
          "to": "get_credential_3"
        },
        {
          "from": "get_credential_3",
          "to": "get_credential_4"
        },
        {
          "from": "get_credential_3",
          "to": "get_credential_5"
        },
        {
          "from": "get_credential_4",
          "to": "get_credential_5"
        }
      ]
    }
  },
  {
    "decl_name": "create_api_key_credentials",
    "start_line": 198,
    "end_line": 222,
    "children": [],
    "code": "def create_api_key_credentials(\n    user_id: Annotated[str, Depends(get_user_id)],\n    provider: Annotated[\n        ProviderName, Path(title=\"The provider to create credentials for\")\n    ],\n    api_key: Annotated[str, Body(title=\"The API key to store\")],\n    title: Annotated[str, Body(title=\"Optional title for the credentials\")],\n    expires_at: Annotated[\n        int | None, Body(title=\"Unix timestamp when the key expires\")\n    ] = None,\n) -> APIKeyCredentials:\n    new_credentials = APIKeyCredentials(\n        provider=provider,\n        api_key=SecretStr(api_key),\n        title=title,\n        expires_at=expires_at,\n    )\n\n    try:\n        creds_manager.create(user_id, new_credentials)\n    except Exception as e:\n        raise HTTPException(\n            status_code=500, detail=f\"Failed to store credentials: {str(e)}\"\n        )\n    return new_credentials\n",
    "cfg": {
      "nodes": [
        {
          "id": "create_api_key_credentials_1",
          "code": "def create_api_key_credentials(\n    user_id: Annotated[str, Depends(get_user_id)],\n    provider: Annotated[\n        ProviderName, Path(title=\"The provider to create credentials for\")\n    ],\n    api_key: Annotated[str, Body(title=\"The API key to store\")],\n    title: Annotated[str, Body(title=\"Optional title for the credentials\")],\n    expires_at: Annotated[\n        int | None, Body(title=\"Unix timestamp when the key expires\")\n    ] = None,\n) -> APIKeyCredentials:\n"
        },
        {
          "id": "create_api_key_credentials_2",
          "code": "    new_credentials = APIKeyCredentials(\n        provider=provider,\n        api_key=SecretStr(api_key),\n        title=title,\n        expires_at=expires_at,\n    )\n"
        },
        {
          "id": "create_api_key_credentials_3",
          "code": "    try:\n        creds_manager.create(user_id, new_credentials)\n"
        },
        {
          "id": "create_api_key_credentials_4",
          "code": "    except Exception as e:\n        raise HTTPException(\n            status_code=500, detail=f\"Failed to store credentials: {str(e)}\"\n        )\n"
        },
        {
          "id": "create_api_key_credentials_5",
          "code": "    return new_credentials\n"
        }
      ],
      "edges": [
        {
          "from": "create_api_key_credentials_1",
          "to": "create_api_key_credentials_2"
        },
        {
          "from": "create_api_key_credentials_2",
          "to": "create_api_key_credentials_3"
        },
        {
          "from": "create_api_key_credentials_3",
          "to": "create_api_key_credentials_4"
        },
        {
          "from": "create_api_key_credentials_3",
          "to": "create_api_key_credentials_5"
        }
      ]
    }
  },
  {
    "decl_name": "CredentialsDeletionResponse",
    "start_line": 225,
    "end_line": 231,
    "children": [],
    "code": "class CredentialsDeletionResponse(BaseModel):\n    deleted: Literal[True] = True\n    revoked: bool | None = Field(\n        description=\"Indicates whether the credentials were also revoked by their \"\n        \"provider. `None`/`null` if not applicable, e.g. when deleting \"\n        \"non-revocable credentials such as API keys.\"\n    )\n",
    "cfg": {
      "nodes": [
        {
          "id": "CredentialsDeletionResponse_1",
          "code": "class CredentialsDeletionResponse(BaseModel):\n    deleted: Literal[True] = True\n    revoked: bool | None = Field(\n        description=\"Indicates whether the credentials were also revoked by their \"\n        \"provider. `None`/`null` if not applicable, e.g. when deleting \"\n        \"non-revocable credentials such as API keys.\"\n    )\n"
        }
      ],
      "edges": []
    }
  },
  {
    "decl_name": "CredentialsDeletionNeedsConfirmationResponse",
    "start_line": 234,
    "end_line": 237,
    "children": [],
    "code": "class CredentialsDeletionNeedsConfirmationResponse(BaseModel):\n    deleted: Literal[False] = False\n    need_confirmation: Literal[True] = True\n    message: str\n",
    "cfg": {
      "nodes": [
        {
          "id": "CredentialsDeletionNeedsConfirmationResponse_1",
          "code": "class CredentialsDeletionNeedsConfirmationResponse(BaseModel):\n    deleted: Literal[False] = False\n    need_confirmation: Literal[True] = True\n    message: str\n"
        }
      ],
      "edges": []
    }
  },
  {
    "decl_name": "delete_credentials",
    "start_line": 241,
    "end_line": 272,
    "children": [],
    "code": "async def delete_credentials(\n    request: Request,\n    provider: Annotated[\n        ProviderName, Path(title=\"The provider to delete credentials for\")\n    ],\n    cred_id: Annotated[str, Path(title=\"The ID of the credentials to delete\")],\n    user_id: Annotated[str, Depends(get_user_id)],\n    force: Annotated[\n        bool, Query(title=\"Whether to proceed if any linked webhooks are still in use\")\n    ] = False,\n) -> CredentialsDeletionResponse | CredentialsDeletionNeedsConfirmationResponse:\n    creds = creds_manager.store.get_creds_by_id(user_id, cred_id)\n    if not creds:\n        raise HTTPException(status_code=404, detail=\"Credentials not found\")\n    if creds.provider != provider:\n        raise HTTPException(\n            status_code=404, detail=\"Credentials do not match the specified provider\"\n        )\n\n    try:\n        await remove_all_webhooks_for_credentials(creds, force)\n    except NeedConfirmation as e:\n        return CredentialsDeletionNeedsConfirmationResponse(message=str(e))\n\n    creds_manager.delete(user_id, cred_id)\n\n    tokens_revoked = None\n    if isinstance(creds, OAuth2Credentials):\n        handler = _get_provider_oauth_handler(request, provider)\n        tokens_revoked = handler.revoke_tokens(creds)\n\n    return CredentialsDeletionResponse(revoked=tokens_revoked)\n",
    "cfg": {
      "nodes": [
        {
          "id": "delete_credentials_1",
          "code": "async def delete_credentials(\n    request: Request,\n    provider: Annotated[\n        ProviderName, Path(title=\"The provider to delete credentials for\")\n    ],\n    cred_id: Annotated[str, Path(title=\"The ID of the credentials to delete\")],\n    user_id: Annotated[str, Depends(get_user_id)],\n    force: Annotated[\n        bool, Query(title=\"Whether to proceed if any linked webhooks are still in use\")\n    ] = False,\n) -> CredentialsDeletionResponse | CredentialsDeletionNeedsConfirmationResponse:\n"
        },
        {
          "id": "delete_credentials_2",
          "code": "    creds = creds_manager.store.get_creds_by_id(user_id, cred_id)\n"
        },
        {
          "id": "delete_credentials_3",
          "code": "    if not creds:\n        raise HTTPException(status_code=404, detail=\"Credentials not found\")\n"
        },
        {
          "id": "delete_credentials_4",
          "code": "    if creds.provider != provider:\n        raise HTTPException(\n            status_code=404, detail=\"Credentials do not match the specified provider\"\n        )\n"
        },
        {
          "id": "delete_credentials_5",
          "code": "    try:\n        await remove_all_webhooks_for_credentials(creds, force)\n"
        },
        {
          "id": "delete_credentials_6",
          "code": "    except NeedConfirmation as e:\n        return CredentialsDeletionNeedsConfirmationResponse(message=str(e))\n"
        },
        {
          "id": "delete_credentials_7",
          "code": "    creds_manager.delete(user_id, cred_id)\n"
        },
        {
          "id": "delete_credentials_8",
          "code": "    tokens_revoked = None\n"
        },
        {
          "id": "delete_credentials_9",
          "code": "    if isinstance(creds, OAuth2Credentials):\n        handler = _get_provider_oauth_handler(request, provider)\n        tokens_revoked = handler.revoke_tokens(creds)\n"
        },
        {
          "id": "delete_credentials_10",
          "code": "    return CredentialsDeletionResponse(revoked=tokens_revoked)\n"
        }
      ],
      "edges": [
        {
          "from": "delete_credentials_1",
          "to": "delete_credentials_2"
        },
        {
          "from": "delete_credentials_2",
          "to": "delete_credentials_3"
        },
        {
          "from": "delete_credentials_3",
          "to": "delete_credentials_4"
        },
        {
          "from": "delete_credentials_4",
          "to": "delete_credentials_5"
        },
        {
          "from": "delete_credentials_5",
          "to": "delete_credentials_6"
        },
        {
          "from": "delete_credentials_5",
          "to": "delete_credentials_7"
        },
        {
          "from": "delete_credentials_7",
          "to": "delete_credentials_8"
        },
        {
          "from": "delete_credentials_8",
          "to": "delete_credentials_9"
        },
        {
          "from": "delete_credentials_9",
          "to": "delete_credentials_10"
        }
      ]
    }
  },
  {
    "decl_name": "webhook_ingress_generic",
    "start_line": 282,
    "end_line": 322,
    "children": [],
    "code": "async def webhook_ingress_generic(\n    request: Request,\n    provider: Annotated[\n        ProviderName, Path(title=\"Provider where the webhook was registered\")\n    ],\n    webhook_id: Annotated[str, Path(title=\"Our ID for the webhook\")],\n):\n    logger.debug(f\"Received {provider.value} webhook ingress for ID {webhook_id}\")\n    webhook_manager = WEBHOOK_MANAGERS_BY_NAME[provider]()\n    webhook = await get_webhook(webhook_id)\n    logger.debug(f\"Webhook #{webhook_id}: {webhook}\")\n    payload, event_type = await webhook_manager.validate_payload(webhook, request)\n    logger.debug(\n        f\"Validated {provider.value} {webhook.webhook_type} {event_type} event \"\n        f\"with payload {payload}\"\n    )\n\n    webhook_event = WebhookEvent(\n        provider=provider,\n        webhook_id=webhook_id,\n        event_type=event_type,\n        payload=payload,\n    )\n    await publish_webhook_event(webhook_event)\n    logger.debug(f\"Webhook event published: {webhook_event}\")\n\n    if not webhook.attached_nodes:\n        return\n\n    executor = get_service_client(ExecutionManager)\n    for node in webhook.attached_nodes:\n        logger.debug(f\"Webhook-attached node: {node}\")\n        if not node.is_triggered_by_event_type(event_type):\n            logger.debug(f\"Node #{node.id} doesn't trigger on event {event_type}\")\n            continue\n        logger.debug(f\"Executing graph #{node.graph_id} node #{node.id}\")\n        executor.add_execution(\n            node.graph_id,\n            data={f\"webhook_{webhook_id}_payload\": payload},\n            user_id=webhook.user_id,\n        )\n",
    "cfg": {
      "nodes": [
        {
          "id": "webhook_ingress_generic_1",
          "code": "async def webhook_ingress_generic(\n    request: Request,\n    provider: Annotated[\n        ProviderName, Path(title=\"Provider where the webhook was registered\")\n    ],\n    webhook_id: Annotated[str, Path(title=\"Our ID for the webhook\")],\n):\n"
        },
        {
          "id": "webhook_ingress_generic_2",
          "code": "    logger.debug(f\"Received {provider.value} webhook ingress for ID {webhook_id}\")\n"
        },
        {
          "id": "webhook_ingress_generic_3",
          "code": "    webhook_manager = WEBHOOK_MANAGERS_BY_NAME[provider]()\n"
        },
        {
          "id": "webhook_ingress_generic_4",
          "code": "    webhook = await get_webhook(webhook_id)\n"
        },
        {
          "id": "webhook_ingress_generic_5",
          "code": "    logger.debug(f\"Webhook #{webhook_id}: {webhook}\")\n"
        },
        {
          "id": "webhook_ingress_generic_6",
          "code": "    payload, event_type = await webhook_manager.validate_payload(webhook, request)\n"
        },
        {
          "id": "webhook_ingress_generic_7",
          "code": "    logger.debug(\n        f\"Validated {provider.value} {webhook.webhook_type} {event_type} event \"\n        f\"with payload {payload}\"\n    )\n"
        },
        {
          "id": "webhook_ingress_generic_8",
          "code": "    webhook_event = WebhookEvent(\n        provider=provider,\n        webhook_id=webhook_id,\n        event_type=event_type,\n        payload=payload,\n    )\n"
        },
        {
          "id": "webhook_ingress_generic_9",
          "code": "    await publish_webhook_event(webhook_event)\n"
        },
        {
          "id": "webhook_ingress_generic_10",
          "code": "    logger.debug(f\"Webhook event published: {webhook_event}\")\n"
        },
        {
          "id": "webhook_ingress_generic_11",
          "code": "    if not webhook.attached_nodes:\n        return\n"
        },
        {
          "id": "webhook_ingress_generic_12",
          "code": "    executor = get_service_client(ExecutionManager)\n"
        },
        {
          "id": "webhook_ingress_generic_13",
          "code": "    for node in webhook.attached_nodes:\n        logger.debug(f\"Webhook-attached node: {node}\")\n"
        },
        {
          "id": "webhook_ingress_generic_14",
          "code": "        if not node.is_triggered_by_event_type(event_type):\n            logger.debug(f\"Node #{node.id} doesn't trigger on event {event_type}\")\n            continue\n"
        },
        {
          "id": "webhook_ingress_generic_15",
          "code": "        logger.debug(f\"Executing graph #{node.graph_id} node #{node.id}\")\n"
        },
        {
          "id": "webhook_ingress_generic_16",
          "code": "        executor.add_execution(\n            node.graph_id,\n            data={f\"webhook_{webhook_id}_payload\": payload},\n            user_id=webhook.user_id,\n        )\n"
        }
      ],
      "edges": [
        {
          "from": "webhook_ingress_generic_1",
          "to": "webhook_ingress_generic_2"
        },
        {
          "from": "webhook_ingress_generic_2",
          "to": "webhook_ingress_generic_3"
        },
        {
          "from": "webhook_ingress_generic_3",
          "to": "webhook_ingress_generic_4"
        },
        {
          "from": "webhook_ingress_generic_4",
          "to": "webhook_ingress_generic_5"
        },
        {
          "from": "webhook_ingress_generic_5",
          "to": "webhook_ingress_generic_6"
        },
        {
          "from": "webhook_ingress_generic_6",
          "to": "webhook_ingress_generic_7"
        },
        {
          "from": "webhook_ingress_generic_7",
          "to": "webhook_ingress_generic_8"
        },
        {
          "from": "webhook_ingress_generic_8",
          "to": "webhook_ingress_generic_9"
        },
        {
          "from": "webhook_ingress_generic_9",
          "to": "webhook_ingress_generic_10"
        },
        {
          "from": "webhook_ingress_generic_10",
          "to": "webhook_ingress_generic_11"
        },
        {
          "from": "webhook_ingress_generic_11",
          "to": "webhook_ingress_generic_12"
        },
        {
          "from": "webhook_ingress_generic_12",
          "to": "webhook_ingress_generic_13"
        },
        {
          "from": "webhook_ingress_generic_13",
          "to": "webhook_ingress_generic_14"
        },
        {
          "from": "webhook_ingress_generic_14",
          "to": "webhook_ingress_generic_15"
        },
        {
          "from": "webhook_ingress_generic_14",
          "to": "webhook_ingress_generic_13"
        },
        {
          "from": "webhook_ingress_generic_15",
          "to": "webhook_ingress_generic_16"
        },
        {
          "from": "webhook_ingress_generic_16",
          "to": "webhook_ingress_generic_13"
        }
      ]
    }
  },
  {
    "decl_name": "webhook_ping",
    "start_line": 326,
    "end_line": 346,
    "children": [],
    "code": "async def webhook_ping(\n    webhook_id: Annotated[str, Path(title=\"Our ID for the webhook\")],\n    user_id: Annotated[str, Depends(get_user_id)],  # require auth\n):\n    webhook = await get_webhook(webhook_id)\n    webhook_manager = WEBHOOK_MANAGERS_BY_NAME[webhook.provider]()\n\n    credentials = (\n        creds_manager.get(user_id, webhook.credentials_id)\n        if webhook.credentials_id\n        else None\n    )\n    try:\n        await webhook_manager.trigger_ping(webhook, credentials)\n    except NotImplementedError:\n        return False\n\n    if not await wait_for_webhook_event(webhook_id, event_type=\"ping\", timeout=10):\n        raise HTTPException(status_code=504, detail=\"Webhook ping timed out\")\n\n    return True\n",
    "cfg": {
      "nodes": [
        {
          "id": "webhook_ping_1",
          "code": "async def webhook_ping(\n    webhook_id: Annotated[str, Path(title=\"Our ID for the webhook\")],\n    user_id: Annotated[str, Depends(get_user_id)],  # require auth\n):\n"
        },
        {
          "id": "webhook_ping_2",
          "code": "    webhook = await get_webhook(webhook_id)\n    webhook_manager = WEBHOOK_MANAGERS_BY_NAME[webhook.provider]()\n"
        },
        {
          "id": "webhook_ping_3",
          "code": "    credentials = (\n        creds_manager.get(user_id, webhook.credentials_id)\n        if webhook.credentials_id\n        else None\n    )\n"
        },
        {
          "id": "webhook_ping_4",
          "code": "    try:\n        await webhook_manager.trigger_ping(webhook, credentials)\n"
        },
        {
          "id": "webhook_ping_5",
          "code": "    except NotImplementedError:\n        return False\n"
        },
        {
          "id": "webhook_ping_6",
          "code": "    if not await wait_for_webhook_event(webhook_id, event_type=\"ping\", timeout=10):\n        raise HTTPException(status_code=504, detail=\"Webhook ping timed out\")\n"
        },
        {
          "id": "webhook_ping_7",
          "code": "    return True\n"
        }
      ],
      "edges": [
        {
          "from": "webhook_ping_1",
          "to": "webhook_ping_2"
        },
        {
          "from": "webhook_ping_2",
          "to": "webhook_ping_3"
        },
        {
          "from": "webhook_ping_3",
          "to": "webhook_ping_4"
        },
        {
          "from": "webhook_ping_4",
          "to": "webhook_ping_5"
        },
        {
          "from": "webhook_ping_4",
          "to": "webhook_ping_6"
        },
        {
          "from": "webhook_ping_6",
          "to": "webhook_ping_7"
        }
      ]
    }
  },
  {
    "decl_name": "remove_all_webhooks_for_credentials",
    "start_line": 352,
    "end_line": 389,
    "children": [],
    "code": "async def remove_all_webhooks_for_credentials(\n    credentials: Credentials, force: bool = False\n) -> None:\n    \"\"\"\n    Remove and deregister all webhooks that were registered using the given credentials.\n\n    Params:\n        credentials: The credentials for which to remove the associated webhooks.\n        force: Whether to proceed if any of the webhooks are still in use.\n\n    Raises:\n        NeedConfirmation: If any of the webhooks are still in use and `force` is `False`\n    \"\"\"\n    webhooks = await get_all_webhooks_by_creds(credentials.id)\n    if credentials.provider not in WEBHOOK_MANAGERS_BY_NAME:\n        if webhooks:\n            logger.error(\n                f\"Credentials #{credentials.id} for provider {credentials.provider} \"\n                f\"are attached to {len(webhooks)} webhooks, \"\n                f\"but there is no available WebhooksHandler for {credentials.provider}\"\n            )\n        return\n    if any(w.attached_nodes for w in webhooks) and not force:\n        raise NeedConfirmation(\n            \"Some webhooks linked to these credentials are still in use by an agent\"\n        )\n    for webhook in webhooks:\n        # Unlink all nodes\n        for node in webhook.attached_nodes or []:\n            await set_node_webhook(node.id, None)\n\n        # Prune the webhook\n        webhook_manager = WEBHOOK_MANAGERS_BY_NAME[credentials.provider]()\n        success = await webhook_manager.prune_webhook_if_dangling(\n            webhook.id, credentials\n        )\n        if not success:\n            logger.warning(f\"Webhook #{webhook.id} failed to prune\")\n",
    "cfg": {
      "nodes": [
        {
          "id": "remove_all_webhooks_for_credentials_1",
          "code": "async def remove_all_webhooks_for_credentials(\n    credentials: Credentials, force: bool = False\n) -> None:\n"
        },
        {
          "id": "remove_all_webhooks_for_credentials_2",
          "code": "    \"\"\"\n    Remove and deregister all webhooks that were registered using the given credentials.\n\n    Params:\n        credentials: The credentials for which to remove the associated webhooks.\n        force: Whether to proceed if any of the webhooks are still in use.\n\n    Raises:\n        NeedConfirmation: If any of the webhooks are still in use and `force` is `False`\n    \"\"\"\n"
        },
        {
          "id": "remove_all_webhooks_for_credentials_3",
          "code": "    webhooks = await get_all_webhooks_by_creds(credentials.id)\n"
        },
        {
          "id": "remove_all_webhooks_for_credentials_4",
          "code": "    if credentials.provider not in WEBHOOK_MANAGERS_BY_NAME:\n        if webhooks:\n            logger.error(\n                f\"Credentials #{credentials.id} for provider {credentials.provider} \"\n                f\"are attached to {len(webhooks)} webhooks, \"\n                f\"but there is no available WebhooksHandler for {credentials.provider}\"\n            )\n        return\n"
        },
        {
          "id": "remove_all_webhooks_for_credentials_5",
          "code": "    if any(w.attached_nodes for w in webhooks) and not force:\n        raise NeedConfirmation(\n            \"Some webhooks linked to these credentials are still in use by an agent\"\n        )\n"
        },
        {
          "id": "remove_all_webhooks_for_credentials_6",
          "code": "    for webhook in webhooks:\n        # Unlink all nodes\n        for node in webhook.attached_nodes or []:\n            await set_node_webhook(node.id, None)\n"
        },
        {
          "id": "remove_all_webhooks_for_credentials_7",
          "code": "        # Prune the webhook\n        webhook_manager = WEBHOOK_MANAGERS_BY_NAME[credentials.provider]()\n        success = await webhook_manager.prune_webhook_if_dangling(\n            webhook.id, credentials\n        )\n        if not success:\n            logger.warning(f\"Webhook #{webhook.id} failed to prune\")\n"
        }
      ],
      "edges": [
        {
          "from": "remove_all_webhooks_for_credentials_1",
          "to": "remove_all_webhooks_for_credentials_2"
        },
        {
          "from": "remove_all_webhooks_for_credentials_2",
          "to": "remove_all_webhooks_for_credentials_3"
        },
        {
          "from": "remove_all_webhooks_for_credentials_3",
          "to": "remove_all_webhooks_for_credentials_4"
        },
        {
          "from": "remove_all_webhooks_for_credentials_4",
          "to": "remove_all_webhooks_for_credentials_5"
        },
        {
          "from": "remove_all_webhooks_for_credentials_5",
          "to": "remove_all_webhooks_for_credentials_6"
        },
        {
          "from": "remove_all_webhooks_for_credentials_6",
          "to": "remove_all_webhooks_for_credentials_7"
        }
      ]
    }
  },
  {
    "decl_name": "_get_provider_oauth_handler",
    "start_line": 392,
    "end_line": 421,
    "children": [],
    "code": "def _get_provider_oauth_handler(\n    req: Request, provider_name: ProviderName\n) -> \"BaseOAuthHandler\":\n    if provider_name not in HANDLERS_BY_NAME:\n        raise HTTPException(\n            status_code=404,\n            detail=f\"Provider '{provider_name.value}' does not support OAuth\",\n        )\n\n    client_id = getattr(settings.secrets, f\"{provider_name.value}_client_id\")\n    client_secret = getattr(settings.secrets, f\"{provider_name.value}_client_secret\")\n    if not (client_id and client_secret):\n        raise HTTPException(\n            status_code=501,\n            detail=(\n                f\"Integration with provider '{provider_name.value}' is not configured\"\n            ),\n        )\n\n    handler_class = HANDLERS_BY_NAME[provider_name]\n    frontend_base_url = (\n        settings.config.frontend_base_url\n        or settings.config.platform_base_url\n        or str(req.base_url)\n    )\n    return handler_class(\n        client_id=client_id,\n        client_secret=client_secret,\n        redirect_uri=f\"{frontend_base_url}/auth/integrations/oauth_callback\",\n    )\n",
    "cfg": {
      "nodes": [
        {
          "id": "_get_provider_oauth_handler_1",
          "code": "def _get_provider_oauth_handler(\n    req: Request, provider_name: ProviderName\n) -> \"BaseOAuthHandler\":\n"
        },
        {
          "id": "_get_provider_oauth_handler_2",
          "code": "    if provider_name not in HANDLERS_BY_NAME:\n        raise HTTPException(\n            status_code=404,\n            detail=f\"Provider '{provider_name.value}' does not support OAuth\",\n        )\n"
        },
        {
          "id": "_get_provider_oauth_handler_3",
          "code": "    client_id = getattr(settings.secrets, f\"{provider_name.value}_client_id\")\n    client_secret = getattr(settings.secrets, f\"{provider_name.value}_client_secret\")\n"
        },
        {
          "id": "_get_provider_oauth_handler_4",
          "code": "    if not (client_id and client_secret):\n        raise HTTPException(\n            status_code=501,\n            detail=(\n                f\"Integration with provider '{provider_name.value}' is not configured\"\n            ),\n        )\n"
        },
        {
          "id": "_get_provider_oauth_handler_5",
          "code": "    handler_class = HANDLERS_BY_NAME[provider_name]\n    frontend_base_url = (\n        settings.config.frontend_base_url\n        or settings.config.platform_base_url\n        or str(req.base_url)\n    )\n"
        },
        {
          "id": "_get_provider_oauth_handler_6",
          "code": "    return handler_class(\n        client_id=client_id,\n        client_secret=client_secret,\n        redirect_uri=f\"{frontend_base_url}/auth/integrations/oauth_callback\",\n    )\n"
        }
      ],
      "edges": [
        {
          "from": "_get_provider_oauth_handler_1",
          "to": "_get_provider_oauth_handler_2"
        },
        {
          "from": "_get_provider_oauth_handler_2",
          "to": "_get_provider_oauth_handler_3"
        },
        {
          "from": "_get_provider_oauth_handler_3",
          "to": "_get_provider_oauth_handler_4"
        },
        {
          "from": "_get_provider_oauth_handler_4",
          "to": "_get_provider_oauth_handler_5"
        },
        {
          "from": "_get_provider_oauth_handler_5",
          "to": "_get_provider_oauth_handler_6"
        }
      ]
    }
  }
]