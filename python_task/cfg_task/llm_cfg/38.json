[
  {
    "decl_name": "GlobalBlock",
    "start_line": 0,
    "end_line": 24,
    "children": [],
    "code": "import asyncio\nimport logging\nimport uuid\nfrom collections import defaultdict\nfrom datetime import datetime, timezone\nfrom typing import Any, Literal, Optional, Type\n\nimport prisma\nfrom prisma.models import AgentGraph, AgentGraphExecution, AgentNode, AgentNodeLink\nfrom prisma.types import AgentGraphWhereInput\nfrom pydantic.fields import computed_field\n\nfrom backend.blocks.agent import AgentExecutorBlock\nfrom backend.blocks.basic import AgentInputBlock, AgentOutputBlock\nfrom backend.util import json\n\nfrom .block import BlockInput, BlockType, get_block, get_blocks\nfrom .db import BaseDbModel, transaction\nfrom .execution import ExecutionStatus\nfrom .includes import AGENT_GRAPH_INCLUDE, AGENT_NODE_INCLUDE\nfrom .integrations import Webhook\n\nlogger = logging.getLogger(__name__)\n\n\n",
    "cfg": {
      "nodes": [
        {
          "id": "GlobalBlock_1",
          "code": "import asyncio\nimport logging\nimport uuid\nfrom collections import defaultdict\nfrom datetime import datetime, timezone\nfrom typing import Any, Literal, Optional, Type\n\nimport prisma\nfrom prisma.models import AgentGraph, AgentGraphExecution, AgentNode, AgentNodeLink\nfrom prisma.types import AgentGraphWhereInput\nfrom pydantic.fields import computed_field\n\nfrom backend.blocks.agent import AgentExecutorBlock\nfrom backend.blocks.basic import AgentInputBlock, AgentOutputBlock\nfrom backend.util import json\n\nfrom .block import BlockInput, BlockType, get_block, get_blocks\nfrom .db import BaseDbModel, transaction\nfrom .execution import ExecutionStatus\nfrom .includes import AGENT_GRAPH_INCLUDE, AGENT_NODE_INCLUDE\nfrom .integrations import Webhook\n\nlogger = logging.getLogger(__name__)\n"
        }
      ],
      "edges": []
    }
  },
  {
    "decl_name": "Link",
    "start_line": 25,
    "end_line": 44,
    "children": [
      {
        "decl_name": "Link.from_db",
        "start_line": 33,
        "end_line": 41,
        "children": [],
        "code": "    def from_db(link: AgentNodeLink):\n        return Link(\n            id=link.id,\n            source_name=link.sourceName,\n            source_id=link.agentNodeSourceId,\n            sink_name=link.sinkName,\n            sink_id=link.agentNodeSinkId,\n            is_static=link.isStatic,\n        )\n",
        "cfg": {
          "nodes": [
            {
              "id": "Link.from_db_1",
              "code": "def from_db(link: AgentNodeLink):\n        return Link(\n            id=link.id,\n            source_name=link.sourceName,\n            source_id=link.agentNodeSourceId,\n            sink_name=link.sinkName,\n            sink_id=link.agentNodeSinkId,\n            is_static=link.isStatic,\n        )\n"
            }
          ],
          "edges": []
        }
      },
      {
        "decl_name": "Link.__hash__",
        "start_line": 43,
        "end_line": 44,
        "children": [],
        "code": "    def __hash__(self):\n        return hash((self.source_id, self.sink_id, self.source_name, self.sink_name))\n",
        "cfg": {
          "nodes": [
            {
              "id": "Link.__hash___1",
              "code": "def __hash__(self):\n        return hash((self.source_id, self.sink_id, self.source_name, self.sink_name))\n"
            }
          ],
          "edges": []
        }
      }
    ],
    "code": "class Link(BaseDbModel):\n    source_id: str\n    sink_id: str\n    source_name: str\n    sink_name: str\n    is_static: bool = False\n\n    @staticmethod\n\n",
    "cfg": {
      "nodes": [
        {
          "id": "Link_1",
          "code": "class Link(BaseDbModel):\n    source_id: str\n    sink_id: str\n    source_name: str\n    sink_name: str\n    is_static: bool = False\n"
        },
        {
          "id": "Link_2",
          "code": "    @staticmethod\n"
        }
      ],
      "edges": []
    }
  },
  {
    "decl_name": "Node",
    "start_line": 47,
    "end_line": 54,
    "children": [],
    "code": "class Node(BaseDbModel):\n    block_id: str\n    input_default: BlockInput = {}  # dict[input_name, default_value]\n    metadata: dict[str, Any] = {}\n    input_links: list[Link] = []\n    output_links: list[Link] = []\n\n    webhook_id: Optional[str] = None\n",
    "cfg": {
      "nodes": [
        {
          "id": "Node_1",
          "code": "class Node(BaseDbModel):\n    block_id: str\n    input_default: BlockInput = {}  # dict[input_name, default_value]\n    metadata: dict[str, Any] = {}\n    input_links: list[Link] = []\n    output_links: list[Link] = []\n\n    webhook_id: Optional[str] = None\n"
        }
      ],
      "edges": []
    }
  },
  {
    "decl_name": "NodeModel",
    "start_line": 57,
    "end_line": 95,
    "children": [
      {
        "decl_name": "NodeModel.from_db",
        "start_line": 64,
        "end_line": 79,
        "children": [],
        "code": "    def from_db(node: AgentNode):\n        if not node.AgentBlock:\n            raise ValueError(f\"Invalid node {node.id}, invalid AgentBlock.\")\n        obj = NodeModel(\n            id=node.id,\n            block_id=node.AgentBlock.id,\n            input_default=json.loads(node.constantInput, target_type=dict[str, Any]),\n            metadata=json.loads(node.metadata, target_type=dict[str, Any]),\n            graph_id=node.agentGraphId,\n            graph_version=node.agentGraphVersion,\n            webhook_id=node.webhookId,\n            webhook=Webhook.from_db(node.Webhook) if node.Webhook else None,\n        )\n        obj.input_links = [Link.from_db(link) for link in node.Input or []]\n        obj.output_links = [Link.from_db(link) for link in node.Output or []]\n        return obj\n",
        "cfg": {
          "nodes": [
            {
              "id": "NodeModel.from_db_1",
              "code": "def from_db(node: AgentNode):\n"
            },
            {
              "id": "NodeModel.from_db_2",
              "code": "        if not node.AgentBlock:\n            raise ValueError(f\"Invalid node {node.id}, invalid AgentBlock.\")\n"
            },
            {
              "id": "NodeModel.from_db_3",
              "code": "        obj = NodeModel(\n            id=node.id,\n            block_id=node.AgentBlock.id,\n            input_default=json.loads(node.constantInput, target_type=dict[str, Any]),\n            metadata=json.loads(node.metadata, target_type=dict[str, Any]),\n            graph_id=node.agentGraphId,\n            graph_version=node.agentGraphVersion,\n            webhook_id=node.webhookId,\n            webhook=Webhook.from_db(node.Webhook) if node.Webhook else None,\n        )\n"
            },
            {
              "id": "NodeModel.from_db_4",
              "code": "        obj.input_links = [Link.from_db(link) for link in node.Input or []]\n        obj.output_links = [Link.from_db(link) for link in node.Output or []]\n"
            },
            {
              "id": "NodeModel.from_db_5",
              "code": "        return obj\n"
            }
          ],
          "edges": [
            {
              "from": "NodeModel.from_db_1",
              "to": "NodeModel.from_db_2"
            },
            {
              "from": "NodeModel.from_db_2",
              "to": "NodeModel.from_db_3"
            },
            {
              "from": "NodeModel.from_db_3",
              "to": "NodeModel.from_db_4"
            },
            {
              "from": "NodeModel.from_db_4",
              "to": "NodeModel.from_db_5"
            }
          ]
        }
      },
      {
        "decl_name": "NodeModel.is_triggered_by_event_type",
        "start_line": 81,
        "end_line": 95,
        "children": [],
        "code": "    def is_triggered_by_event_type(self, event_type: str) -> bool:\n        if not (block := get_block(self.block_id)):\n            raise ValueError(f\"Block #{self.block_id} not found for node #{self.id}\")\n        if not block.webhook_config:\n            raise TypeError(\"This method can't be used on non-webhook blocks\")\n        if not block.webhook_config.event_filter_input:\n            return True\n        event_filter = self.input_default.get(block.webhook_config.event_filter_input)\n        if not event_filter:\n            raise ValueError(f\"Event filter is not configured on node #{self.id}\")\n        return event_type in [\n            block.webhook_config.event_format.format(event=k)\n            for k in event_filter\n            if event_filter[k] is True\n        ]\n",
        "cfg": {
          "nodes": [
            {
              "id": "NodeModel.is_triggered_by_event_type_1",
              "code": "def is_triggered_by_event_type(self, event_type: str) -> bool:\n"
            },
            {
              "id": "NodeModel.is_triggered_by_event_type_2",
              "code": "        if not (block := get_block(self.block_id)):\n            raise ValueError(f\"Block #{self.block_id} not found for node #{self.id}\")\n"
            },
            {
              "id": "NodeModel.is_triggered_by_event_type_3",
              "code": "        if not block.webhook_config:\n            raise TypeError(\"This method can't be used on non-webhook blocks\")\n"
            },
            {
              "id": "NodeModel.is_triggered_by_event_type_4",
              "code": "        if not block.webhook_config.event_filter_input:\n            return True\n"
            },
            {
              "id": "NodeModel.is_triggered_by_event_type_5",
              "code": "        event_filter = self.input_default.get(block.webhook_config.event_filter_input)\n        if not event_filter:\n            raise ValueError(f\"Event filter is not configured on node #{self.id}\")\n"
            },
            {
              "id": "NodeModel.is_triggered_by_event_type_6",
              "code": "        return event_type in [\n            block.webhook_config.event_format.format(event=k)\n            for k in event_filter\n            if event_filter[k] is True\n        ]\n"
            }
          ],
          "edges": [
            {
              "from": "NodeModel.is_triggered_by_event_type_1",
              "to": "NodeModel.is_triggered_by_event_type_2"
            },
            {
              "from": "NodeModel.is_triggered_by_event_type_2",
              "to": "NodeModel.is_triggered_by_event_type_3"
            },
            {
              "from": "NodeModel.is_triggered_by_event_type_3",
              "to": "NodeModel.is_triggered_by_event_type_4"
            },
            {
              "from": "NodeModel.is_triggered_by_event_type_4",
              "to": "NodeModel.is_triggered_by_event_type_5"
            },
            {
              "from": "NodeModel.is_triggered_by_event_type_4",
              "to": "NodeModel.is_triggered_by_event_type_6"
            },
            {
              "from": "NodeModel.is_triggered_by_event_type_5",
              "to": "NodeModel.is_triggered_by_event_type_6"
            }
          ]
        }
      }
    ],
    "code": "class NodeModel(Node):\n    graph_id: str\n    graph_version: int\n\n    webhook: Optional[Webhook] = None\n\n    @staticmethod\n\n",
    "cfg": {
      "nodes": [
        {
          "id": "NodeModel_1",
          "code": "class NodeModel(Node):\n    graph_id: str\n    graph_version: int\n"
        },
        {
          "id": "NodeModel_2",
          "code": "    webhook: Optional[Webhook] = None\n"
        },
        {
          "id": "NodeModel_3",
          "code": "    @staticmethod\n"
        }
      ],
      "edges": [
        {
          "from": "NodeModel_1",
          "to": "NodeModel_2"
        },
        {
          "from": "NodeModel_2",
          "to": "NodeModel_3"
        }
      ]
    }
  },
  {
    "decl_name": "GraphExecution",
    "start_line": 102,
    "end_line": 138,
    "children": [
      {
        "decl_name": "GraphExecution.from_db",
        "start_line": 113,
        "end_line": 138,
        "children": [],
        "code": "    def from_db(execution: AgentGraphExecution):\n        now = datetime.now(timezone.utc)\n        start_time = execution.startedAt or execution.createdAt\n        end_time = execution.updatedAt or now\n        duration = (end_time - start_time).total_seconds()\n        total_run_time = duration\n\n        try:\n            stats = json.loads(execution.stats or \"{}\", target_type=dict[str, Any])\n        except ValueError:\n            stats = {}\n\n        duration = stats.get(\"walltime\", duration)\n        total_run_time = stats.get(\"nodes_walltime\", total_run_time)\n\n        return GraphExecution(\n            id=execution.id,\n            execution_id=execution.id,\n            started_at=start_time,\n            ended_at=end_time,\n            duration=duration,\n            total_run_time=total_run_time,\n            status=ExecutionStatus(execution.executionStatus),\n            graph_id=execution.agentGraphId,\n            graph_version=execution.agentGraphVersion,\n        )\n",
        "cfg": {
          "nodes": [
            {
              "id": "GraphExecution.from_db_1",
              "code": "def from_db(execution: AgentGraphExecution):\n        now = datetime.now(timezone.utc)\n        start_time = execution.startedAt or execution.createdAt\n        end_time = execution.updatedAt or now\n        duration = (end_time - start_time).total_seconds()\n        total_run_time = duration\n\n"
            },
            {
              "id": "GraphExecution.from_db_2",
              "code": "        try:\n            stats = json.loads(execution.stats or \"{}\", target_type=dict[str, Any])\n        except ValueError:\n            stats = {}\n"
            },
            {
              "id": "GraphExecution.from_db_3",
              "code": "        duration = stats.get(\"walltime\", duration)\n        total_run_time = stats.get(\"nodes_walltime\", total_run_time)\n\n"
            },
            {
              "id": "GraphExecution.from_db_4",
              "code": "        return GraphExecution(\n            id=execution.id,\n            execution_id=execution.id,\n            started_at=start_time,\n            ended_at=end_time,\n            duration=duration,\n            total_run_time=total_run_time,\n            status=ExecutionStatus(execution.executionStatus),\n            graph_id=execution.agentGraphId,\n            graph_version=execution.agentGraphVersion,\n        )\n"
            }
          ],
          "edges": [
            {
              "from": "GraphExecution.from_db_1",
              "to": "GraphExecution.from_db_2"
            },
            {
              "from": "GraphExecution.from_db_2",
              "to": "GraphExecution.from_db_3"
            },
            {
              "from": "GraphExecution.from_db_3",
              "to": "GraphExecution.from_db_4"
            }
          ]
        }
      }
    ],
    "code": "class GraphExecution(BaseDbModel):\n    execution_id: str\n    started_at: datetime\n    ended_at: datetime\n    duration: float\n    total_run_time: float\n    status: ExecutionStatus\n    graph_id: str\n    graph_version: int\n\n    @staticmethod\n",
    "cfg": {
      "nodes": [
        {
          "id": "GraphExecution_1",
          "code": "class GraphExecution(BaseDbModel):\n    execution_id: str\n    started_at: datetime\n    ended_at: datetime\n    duration: float\n    total_run_time: float\n    status: ExecutionStatus\n    graph_id: str\n    graph_version: int\n\n"
        },
        {
          "id": "GraphExecution_2",
          "code": "    @staticmethod\n"
        }
      ],
      "edges": []
    }
  },
  {
    "decl_name": "Graph",
    "start_line": 141,
    "end_line": 203,
    "children": [
      {
        "decl_name": "Graph.input_schema",
        "start_line": 150,
        "end_line": 162,
        "children": [],
        "code": "    @computed_field\n    @property\n    def input_schema(self) -> dict[str, Any]:\n        return self._generate_schema(\n            AgentInputBlock.Input,\n            [\n                node.input_default\n                for node in self.nodes\n                if (b := get_block(node.block_id))\n                and b.block_type == BlockType.INPUT\n                and \"name\" in node.input_default\n            ],\n        )\n",
        "cfg": {
          "nodes": [
            {
              "id": "Graph.input_schema_1",
              "code": "@computed_field\n    @property\n    def input_schema(self) -> dict[str, Any]:\n"
            },
            {
              "id": "Graph.input_schema_2",
              "code": "        return self._generate_schema(\n            AgentInputBlock.Input,\n            [\n                node.input_default\n                for node in self.nodes\n                if (b := get_block(node.block_id))\n                and b.block_type == BlockType.INPUT\n                and \"name\" in node.input_default\n            ],\n        )\n"
            }
          ],
          "edges": [
            {
              "from": "Graph.input_schema_1",
              "to": "Graph.input_schema_2"
            }
          ]
        }
      },
      {
        "decl_name": "Graph.output_schema",
        "start_line": 164,
        "end_line": 176,
        "children": [],
        "code": "    @computed_field\n    @property\n    def output_schema(self) -> dict[str, Any]:\n        return self._generate_schema(\n            AgentOutputBlock.Input,\n            [\n                node.input_default\n                for node in self.nodes\n                if (b := get_block(node.block_id))\n                and b.block_type == BlockType.OUTPUT\n                and \"name\" in node.input_default\n            ],\n        )\n",
        "cfg": {
          "nodes": [
            {
              "id": "Graph.output_schema_1",
              "code": "@computed_field\n    @property\n    def output_schema(self) -> dict[str, Any]:\n"
            },
            {
              "id": "Graph.output_schema_2",
              "code": "        return self._generate_schema(\n            AgentOutputBlock.Input,\n            [\n                node.input_default\n                for node in self.nodes\n                if (b := get_block(node.block_id))\n                and b.block_type == BlockType.OUTPUT\n                and \"name\" in node.input_default\n            ],\n        )\n"
            }
          ],
          "edges": [
            {
              "from": "Graph.output_schema_1",
              "to": "Graph.output_schema_2"
            }
          ]
        }
      },
      {
        "decl_name": "Graph._generate_schema",
        "start_line": 179,
        "end_line": 203,
        "children": [],
        "code": "    def _generate_schema(\n        type_class: Type[AgentInputBlock.Input] | Type[AgentOutputBlock.Input],\n        data: list[dict],\n    ) -> dict[str, Any]:\n        props = []\n        for p in data:\n            try:\n                props.append(type_class(**p))\n            except Exception as e:\n                logger.warning(f\"Invalid {type_class}: {p}, {e}\")\n\n        return {\n            \"type\": \"object\",\n            \"properties\": {\n                p.name: {\n                    \"secret\": p.secret,\n                    \"advanced\": p.advanced,\n                    \"title\": p.title or p.name,\n                    **({\"description\": p.description} if p.description else {}),\n                    **({\"default\": p.value} if p.value is not None else {}),\n                }\n                for p in props\n            },\n            \"required\": [p.name for p in props if p.value is None],\n        }\n",
        "cfg": {
          "nodes": [
            {
              "id": "Graph._generate_schema_1",
              "code": "def _generate_schema(\n        type_class: Type[AgentInputBlock.Input] | Type[AgentOutputBlock.Input],\n        data: list[dict],\n    ) -> dict[str, Any]:\n"
            },
            {
              "id": "Graph._generate_schema_2",
              "code": "        props = []\n"
            },
            {
              "id": "Graph._generate_schema_3",
              "code": "        for p in data:\n"
            },
            {
              "id": "Graph._generate_schema_4",
              "code": "            try:\n                props.append(type_class(**p))\n"
            },
            {
              "id": "Graph._generate_schema_5",
              "code": "            except Exception as e:\n                logger.warning(f\"Invalid {type_class}: {p}, {e}\")\n"
            },
            {
              "id": "Graph._generate_schema_6",
              "code": "        return {\n            \"type\": \"object\",\n            \"properties\": {\n                p.name: {\n                    \"secret\": p.secret,\n                    \"advanced\": p.advanced,\n                    \"title\": p.title or p.name,\n                    **({\"description\": p.description} if p.description else {}),\n                    **({\"default\": p.value} if p.value is not None else {}),\n                }\n                for p in props\n            },\n            \"required\": [p.name for p in props if p.value is None],\n        }\n"
            }
          ],
          "edges": [
            {
              "from": "Graph._generate_schema_1",
              "to": "Graph._generate_schema_2"
            },
            {
              "from": "Graph._generate_schema_2",
              "to": "Graph._generate_schema_3"
            },
            {
              "from": "Graph._generate_schema_3",
              "to": "Graph._generate_schema_4"
            },
            {
              "from": "Graph._generate_schema_3",
              "to": "Graph._generate_schema_6"
            },
            {
              "from": "Graph._generate_schema_4",
              "to": "Graph._generate_schema_5"
            },
            {
              "from": "Graph._generate_schema_4",
              "to": "Graph._generate_schema_3"
            },
            {
              "from": "Graph._generate_schema_5",
              "to": "Graph._generate_schema_3"
            }
          ]
        }
      }
    ],
    "code": "class Graph(BaseDbModel):\n    version: int = 1\n    is_active: bool = True\n    is_template: bool = False\n    name: str\n    description: str\n    nodes: list[Node] = []\n    links: list[Link] = []\n\n\n\n    @staticmethod\n",
    "cfg": {
      "nodes": [
        {
          "id": "Graph_1",
          "code": "class Graph(BaseDbModel):\n    version: int = 1\n    is_active: bool = True\n    is_template: bool = False\n    name: str\n    description: str\n    nodes: list[Node] = []\n    links: list[Link] = []\n"
        },
        {
          "id": "Graph_2",
          "code": "    @staticmethod\n"
        }
      ],
      "edges": []
    }
  },
  {
    "decl_name": "GraphModel",
    "start_line": 206,
    "end_line": 373,
    "children": [
      {
        "decl_name": "GraphModel.starting_nodes",
        "start_line": 210,
        "end_line": 222,
        "children": [],
        "code": "    @property\n    def starting_nodes(self) -> list[Node]:\n        outbound_nodes = {link.sink_id for link in self.links}\n        input_nodes = {\n            v.id\n            for v in self.nodes\n            if (b := get_block(v.block_id)) and b.block_type == BlockType.INPUT\n        }\n        return [\n            node\n            for node in self.nodes\n            if node.id not in outbound_nodes or node.id in input_nodes\n        ]\n",
        "cfg": {
          "nodes": [
            {
              "id": "GraphModel.starting_nodes_1",
              "code": "@property\n    def starting_nodes(self) -> list[Node]:\n"
            },
            {
              "id": "GraphModel.starting_nodes_2",
              "code": "        outbound_nodes = {link.sink_id for link in self.links}\n        input_nodes = {\n            v.id\n            for v in self.nodes\n            if (b := get_block(v.block_id)) and b.block_type == BlockType.INPUT\n        }\n"
            },
            {
              "id": "GraphModel.starting_nodes_3",
              "code": "        return [\n            node\n            for node in self.nodes\n            if node.id not in outbound_nodes or node.id in input_nodes\n        ]\n"
            }
          ],
          "edges": [
            {
              "from": "GraphModel.starting_nodes_1",
              "to": "GraphModel.starting_nodes_2"
            },
            {
              "from": "GraphModel.starting_nodes_2",
              "to": "GraphModel.starting_nodes_3"
            }
          ]
        }
      },
      {
        "decl_name": "GraphModel.reassign_ids",
        "start_line": 224,
        "end_line": 252,
        "children": [],
        "code": "    def reassign_ids(self, user_id: str, reassign_graph_id: bool = False):\n        \"\"\"\n        Reassigns all IDs in the graph to new UUIDs.\n        This method can be used before storing a new graph to the database.\n        \"\"\"\n\n        # Reassign Graph ID\n        id_map = {node.id: str(uuid.uuid4()) for node in self.nodes}\n        if reassign_graph_id:\n            self.id = str(uuid.uuid4())\n\n        # Reassign Node IDs\n        for node in self.nodes:\n            node.id = id_map[node.id]\n\n        # Reassign Link IDs\n        for link in self.links:\n            link.source_id = id_map[link.source_id]\n            link.sink_id = id_map[link.sink_id]\n\n        # Reassign User IDs for agent blocks\n        for node in self.nodes:\n            if node.block_id != AgentExecutorBlock().id:\n                continue\n            node.input_default[\"user_id\"] = user_id\n            node.input_default.setdefault(\"data\", {})\n\n        self.validate_graph()\n\n",
        "cfg": {
          "nodes": [
            {
              "id": "GraphModel.reassign_ids_1",
              "code": "def reassign_ids(self, user_id: str, reassign_graph_id: bool = False):\n        \"\"\"\n        Reassigns all IDs in the graph to new UUIDs.\n        This method can be used before storing a new graph to the database.\n        \"\"\"\n"
            },
            {
              "id": "GraphModel.reassign_ids_2",
              "code": "        # Reassign Graph ID\n        id_map = {node.id: str(uuid.uuid4()) for node in self.nodes}\n"
            },
            {
              "id": "GraphModel.reassign_ids_3",
              "code": "        if reassign_graph_id:\n            self.id = str(uuid.uuid4())\n"
            },
            {
              "id": "GraphModel.reassign_ids_4",
              "code": "        # Reassign Node IDs\n        for node in self.nodes:\n            node.id = id_map[node.id]\n"
            },
            {
              "id": "GraphModel.reassign_ids_5",
              "code": "        # Reassign Link IDs\n        for link in self.links:\n            link.source_id = id_map[link.source_id]\n            link.sink_id = id_map[link.sink_id]\n"
            },
            {
              "id": "GraphModel.reassign_ids_6",
              "code": "        # Reassign User IDs for agent blocks\n        for node in self.nodes:\n            if node.block_id != AgentExecutorBlock().id:\n                continue\n            node.input_default[\"user_id\"] = user_id\n"
            },
            {
              "id": "GraphModel.reassign_ids_7",
              "code": "            node.input_default.setdefault(\"data\", {})\n"
            },
            {
              "id": "GraphModel.reassign_ids_8",
              "code": "        self.validate_graph()\n"
            }
          ],
          "edges": [
            {
              "from": "GraphModel.reassign_ids_1",
              "to": "GraphModel.reassign_ids_2"
            },
            {
              "from": "GraphModel.reassign_ids_2",
              "to": "GraphModel.reassign_ids_3"
            },
            {
              "from": "GraphModel.reassign_ids_2",
              "to": "GraphModel.reassign_ids_4"
            },
            {
              "from": "GraphModel.reassign_ids_3",
              "to": "GraphModel.reassign_ids_4"
            },
            {
              "from": "GraphModel.reassign_ids_4",
              "to": "GraphModel.reassign_ids_5"
            },
            {
              "from": "GraphModel.reassign_ids_5",
              "to": "GraphModel.reassign_ids_6"
            },
            {
              "from": "GraphModel.reassign_ids_6",
              "to": "GraphModel.reassign_ids_7"
            },
            {
              "from": "GraphModel.reassign_ids_7",
              "to": "GraphModel.reassign_ids_8"
            }
          ]
        }
      },
      {
        "decl_name": "GraphModel.validate_graph",
        "start_line": 253,
        "end_line": 370,
        "children": [],
        "code": "    def validate_graph(self, for_run: bool = False):\n        def sanitize(name):\n            return name.split(\"_#_\")[0].split(\"_@_\")[0].split(\"_$_\")[0]\n\n        input_links = defaultdict(list)\n        for link in self.links:\n            input_links[link.sink_id].append(link)\n\n        # Nodes: required fields are filled or connected and dependencies are satisfied\n        for node in self.nodes:\n            block = get_block(node.block_id)\n            if block is None:\n                raise ValueError(f\"Invalid block {node.block_id} for node #{node.id}\")\n\n            provided_inputs = set(\n                [sanitize(name) for name in node.input_default]\n                + [sanitize(link.sink_name) for link in input_links.get(node.id, [])]\n            )\n            for name in block.input_schema.get_required_fields():\n                if (\n                    name not in provided_inputs\n                    and not (\n                        name == \"payload\"\n                        and block.block_type\n                        in (BlockType.WEBHOOK, BlockType.WEBHOOK_MANUAL)\n                    )\n                    and (\n                        for_run  # Skip input completion validation, unless when executing.\n                        or block.block_type == BlockType.INPUT\n                        or block.block_type == BlockType.OUTPUT\n                        or block.block_type == BlockType.AGENT\n                    )\n                ):\n                    raise ValueError(\n                        f\"Node {block.name} #{node.id} required input missing: `{name}`\"\n                    )\n\n            # Get input schema properties and check dependencies\n            input_schema = block.input_schema.model_fields\n            required_fields = block.input_schema.get_required_fields()\n\n            def has_value(name):\n                return (\n                    node is not None\n                    and name in node.input_default\n                    and node.input_default[name] is not None\n                    and str(node.input_default[name]).strip() != \"\"\n                ) or (name in input_schema and input_schema[name].default is not None)\n\n            # Validate dependencies between fields\n            for field_name, field_info in input_schema.items():\n                # Apply input dependency validation only on run & field with depends_on\n                json_schema_extra = field_info.json_schema_extra or {}\n                dependencies = json_schema_extra.get(\"depends_on\", [])\n                if not for_run or not dependencies:\n                    continue\n\n                # Check if dependent field has value in input_default\n                field_has_value = has_value(field_name)\n                field_is_required = field_name in required_fields\n\n                # Check for missing dependencies when dependent field is present\n                missing_deps = [dep for dep in dependencies if not has_value(dep)]\n                if missing_deps and (field_has_value or field_is_required):\n                    raise ValueError(\n                        f\"Node {block.name} #{node.id}: Field `{field_name}` requires [{', '.join(missing_deps)}] to be set\"\n                    )\n\n        node_map = {v.id: v for v in self.nodes}\n\n        def is_static_output_block(nid: str) -> bool:\n            bid = node_map[nid].block_id\n            b = get_block(bid)\n            return b.static_output if b else False\n\n        # Links: links are connected and the connected pin data type are compatible.\n        for link in self.links:\n            source = (link.source_id, link.source_name)\n            sink = (link.sink_id, link.sink_name)\n            suffix = f\"Link {source} <-> {sink}\"\n\n            for i, (node_id, name) in enumerate([source, sink]):\n                node = node_map.get(node_id)\n                if not node:\n                    raise ValueError(\n                        f\"{suffix}, {node_id} is invalid node id, available nodes: {node_map.keys()}\"\n                    )\n\n                block = get_block(node.block_id)\n                if not block:\n                    blocks = {v().id: v().name for v in get_blocks().values()}\n                    raise ValueError(\n                        f\"{suffix}, {node.block_id} is invalid block id, available blocks: {blocks}\"\n                    )\n\n                sanitized_name = sanitize(name)\n                vals = node.input_default\n                if i == 0:\n                    fields = (\n                        block.output_schema.get_fields()\n                        if block.block_type != BlockType.AGENT\n                        else vals.get(\"output_schema\", {}).get(\"properties\", {}).keys()\n                    )\n                else:\n                    fields = (\n                        block.input_schema.get_fields()\n                        if block.block_type != BlockType.AGENT\n                        else vals.get(\"input_schema\", {}).get(\"properties\", {}).keys()\n                    )\n                if sanitized_name not in fields:\n                    fields_msg = f\"Allowed fields: {fields}\"\n                    raise ValueError(f\"{suffix}, `{name}` invalid, {fields_msg}\")\n\n            if is_static_output_block(link.source_id):\n                link.is_static = True  # Each value block output should be static.\n\n    @staticmethod\n    def from_db(graph: AgentGraph, for_export: bool = False):\n",
        "cfg": {
          "nodes": [
            {
              "id": "GraphModel.validate_graph_1",
              "code": "def validate_graph(self, for_run: bool = False):\n"
            },
            {
              "id": "GraphModel.validate_graph_2",
              "code": "        def sanitize(name):\n            return name.split(\"_#_\")[0].split(\"_@_\")[0].split(\"_$_\")[0]\n"
            },
            {
              "id": "GraphModel.validate_graph_3",
              "code": "        input_links = defaultdict(list)\n"
            },
            {
              "id": "GraphModel.validate_graph_4",
              "code": "        for link in self.links:\n            input_links[link.sink_id].append(link)\n"
            },
            {
              "id": "GraphModel.validate_graph_5",
              "code": "        # Nodes: required fields are filled or connected and dependencies are satisfied\n"
            },
            {
              "id": "GraphModel.validate_graph_6",
              "code": "        for node in self.nodes:\n            block = get_block(node.block_id)\n            if block is None:\n                raise ValueError(f\"Invalid block {node.block_id} for node #{node.id}\")\n"
            },
            {
              "id": "GraphModel.validate_graph_7",
              "code": "            provided_inputs = set(\n                [sanitize(name) for name in node.input_default]\n                + [sanitize(link.sink_name) for link in input_links.get(node.id, [])]\n            )\n"
            },
            {
              "id": "GraphModel.validate_graph_8",
              "code": "            for name in block.input_schema.get_required_fields():\n                if (\n                    name not in provided_inputs\n                    and not (\n                        name == \"payload\"\n                        and block.block_type\n                        in (BlockType.WEBHOOK, BlockType.WEBHOOK_MANUAL)\n                    )\n                    and (\n                        for_run  # Skip input completion validation, unless when executing.\n                        or block.block_type == BlockType.INPUT\n                        or block.block_type == BlockType.OUTPUT\n                        or block.block_type == BlockType.AGENT\n                    )\n                ):\n                    raise ValueError(\n                        f\"Node {block.name} #{node.id} required input missing: `{name}`\"\n                    )\n"
            },
            {
              "id": "GraphModel.validate_graph_9",
              "code": "            # Get input schema properties and check dependencies\n            input_schema = block.input_schema.model_fields\n            required_fields = block.input_schema.get_required_fields()\n"
            },
            {
              "id": "GraphModel.validate_graph_10",
              "code": "            def has_value(name):\n                return (\n                    node is not None\n                    and name in node.input_default\n                    and node.input_default[name] is not None\n                    and str(node.input_default[name]).strip() != \"\"\n                ) or (name in input_schema and input_schema[name].default is not None)\n"
            },
            {
              "id": "GraphModel.validate_graph_11",
              "code": "            # Validate dependencies between fields\n"
            },
            {
              "id": "GraphModel.validate_graph_12",
              "code": "            for field_name, field_info in input_schema.items():\n                # Apply input dependency validation only on run & field with depends_on\n                json_schema_extra = field_info.json_schema_extra or {}\n                dependencies = json_schema_extra.get(\"depends_on\", [])\n                if not for_run or not dependencies:\n                    continue\n\n                # Check if dependent field has value in input_default\n                field_has_value = has_value(field_name)\n                field_is_required = field_name in required_fields\n\n                # Check for missing dependencies when dependent field is present\n                missing_deps = [dep for dep in dependencies if not has_value(dep)]\n                if missing_deps and (field_has_value or field_is_required):\n                    raise ValueError(\n                        f\"Node {block.name} #{node.id}: Field `{field_name}` requires [{', '.join(missing_deps)}] to be set\"\n                    )\n"
            },
            {
              "id": "GraphModel.validate_graph_13",
              "code": "        node_map = {v.id: v for v in self.nodes}\n"
            },
            {
              "id": "GraphModel.validate_graph_14",
              "code": "        def is_static_output_block(nid: str) -> bool:\n            bid = node_map[nid].block_id\n            b = get_block(bid)\n            return b.static_output if b else False\n"
            },
            {
              "id": "GraphModel.validate_graph_15",
              "code": "        # Links: links are connected and the connected pin data type are compatible.\n"
            },
            {
              "id": "GraphModel.validate_graph_16",
              "code": "        for link in self.links:\n            source = (link.source_id, link.source_name)\n            sink = (link.sink_id, link.sink_name)\n            suffix = f\"Link {source} <-> {sink}\"\n\n            for i, (node_id, name) in enumerate([source, sink]):\n                node = node_map.get(node_id)\n                if not node:\n                    raise ValueError(\n                        f\"{suffix}, {node_id} is invalid node id, available nodes: {node_map.keys()}\"\n                    )\n\n                block = get_block(node.block_id)\n                if not block:\n                    blocks = {v().id: v().name for v in get_blocks().values()}\n                    raise ValueError(\n                        f\"{suffix}, {node.block_id} is invalid block id, available blocks: {blocks}\"\n                    )\n"
            },
            {
              "id": "GraphModel.validate_graph_17",
              "code": "                sanitized_name = sanitize(name)\n                vals = node.input_default\n                if i == 0:\n                    fields = (\n                        block.output_schema.get_fields()\n                        if block.block_type != BlockType.AGENT\n                        else vals.get(\"output_schema\", {}).get(\"properties\", {}).keys()\n                    )\n                else:\n                    fields = (\n                        block.input_schema.get_fields()\n                        if block.block_type != BlockType.AGENT\n                        else vals.get(\"input_schema\", {}).get(\"properties\", {}).keys()\n                    )\n                if sanitized_name not in fields:\n                    fields_msg = f\"Allowed fields: {fields}\"\n                    raise ValueError(f\"{suffix}, `{name}` invalid, {fields_msg}\")\n"
            },
            {
              "id": "GraphModel.validate_graph_18",
              "code": "            if is_static_output_block(link.source_id):\n                link.is_static = True  # Each value block output should be static.\n"
            },
            {
              "id": "GraphModel.validate_graph_19",
              "code": "    @staticmethod\n    def from_db(graph: AgentGraph, for_export: bool = False):\n"
            }
          ],
          "edges": [
            {
              "from": "GraphModel.validate_graph_1",
              "to": "GraphModel.validate_graph_2"
            },
            {
              "from": "GraphModel.validate_graph_1",
              "to": "GraphModel.validate_graph_3"
            },
            {
              "from": "GraphModel.validate_graph_3",
              "to": "GraphModel.validate_graph_4"
            },
            {
              "from": "GraphModel.validate_graph_4",
              "to": "GraphModel.validate_graph_5"
            },
            {
              "from": "GraphModel.validate_graph_5",
              "to": "GraphModel.validate_graph_6"
            },
            {
              "from": "GraphModel.validate_graph_6",
              "to": "GraphModel.validate_graph_7"
            },
            {
              "from": "GraphModel.validate_graph_7",
              "to": "GraphModel.validate_graph_8"
            },
            {
              "from": "GraphModel.validate_graph_8",
              "to": "GraphModel.validate_graph_9"
            },
            {
              "from": "GraphModel.validate_graph_9",
              "to": "GraphModel.validate_graph_10"
            },
            {
              "from": "GraphModel.validate_graph_10",
              "to": "GraphModel.validate_graph_11"
            },
            {
              "from": "GraphModel.validate_graph_11",
              "to": "GraphModel.validate_graph_12"
            },
            {
              "from": "GraphModel.validate_graph_12",
              "to": "GraphModel.validate_graph_13"
            },
            {
              "from": "GraphModel.validate_graph_13",
              "to": "GraphModel.validate_graph_14"
            },
            {
              "from": "GraphModel.validate_graph_14",
              "to": "GraphModel.validate_graph_15"
            },
            {
              "from": "GraphModel.validate_graph_15",
              "to": "GraphModel.validate_graph_16"
            },
            {
              "from": "GraphModel.validate_graph_16",
              "to": "GraphModel.validate_graph_17"
            },
            {
              "from": "GraphModel.validate_graph_17",
              "to": "GraphModel.validate_graph_18"
            }
          ]
        }
      },
      {
        "decl_name": "GraphModel.from_db",
        "start_line": 370,
        "end_line": 391,
        "children": [],
        "code": "    def from_db(graph: AgentGraph, for_export: bool = False):\n        return GraphModel(\n            id=graph.id,\n            user_id=graph.userId,\n            version=graph.version,\n            is_active=graph.isActive,\n            is_template=graph.isTemplate,\n            name=graph.name or \"\",\n            description=graph.description or \"\",\n            nodes=[\n                NodeModel.from_db(GraphModel._process_node(node, for_export))\n                for node in graph.AgentNodes or []\n            ],\n            links=list(\n                {\n                    Link.from_db(link)\n                    for node in graph.AgentNodes or []\n                    for link in (node.Input or []) + (node.Output or [])\n                }\n            ),\n        )\n\n",
        "cfg": {
          "nodes": [
            {
              "id": "GraphModel.from_db_1",
              "code": "def from_db(graph: AgentGraph, for_export: bool = False):\n"
            },
            {
              "id": "GraphModel.from_db_2",
              "code": "        return GraphModel(\n            id=graph.id,\n            user_id=graph.userId,\n            version=graph.version,\n            is_active=graph.isActive,\n            is_template=graph.isTemplate,\n            name=graph.name or \"\",\n            description=graph.description or \"\",\n            nodes=[\n                NodeModel.from_db(GraphModel._process_node(node, for_export))\n                for node in graph.AgentNodes or []\n            ],\n            links=list(\n                {\n                    Link.from_db(link)\n                    for node in graph.AgentNodes or []\n                    for link in (node.Input or []) + (node.Output or [])\n                }\n            ),\n        )\n"
            }
          ],
          "edges": [
            {
              "from": "GraphModel.from_db_1",
              "to": "GraphModel.from_db_2"
            }
          ]
        }
      }
    ],
    "code": "class GraphModel(Graph):\n    user_id: str\n    nodes: list[NodeModel] = []  # type: ignore\n\n\n",
    "cfg": {
      "nodes": [
        {
          "id": "GraphModel_1",
          "code": "class GraphModel(Graph):\n    user_id: str\n    nodes: list[NodeModel] = []  # type: ignore\n"
        }
      ],
      "edges": []
    }
  },
  {
    "decl_name": "get_node",
    "start_line": 429,
    "end_line": 434,
    "children": [],
    "code": "async def get_node(node_id: str) -> NodeModel:\n    node = await AgentNode.prisma().find_unique_or_raise(\n        where={\"id\": node_id},\n        include=AGENT_NODE_INCLUDE,\n    )\n    return NodeModel.from_db(node)\n",
    "cfg": {
      "nodes": [
        {
          "id": "get_node_1",
          "code": "async def get_node(node_id: str) -> NodeModel:\n"
        },
        {
          "id": "get_node_2",
          "code": "    node = await AgentNode.prisma().find_unique_or_raise(\n        where={\"id\": node_id},\n        include=AGENT_NODE_INCLUDE,\n    )\n"
        },
        {
          "id": "get_node_3",
          "code": "    return NodeModel.from_db(node)\n"
        }
      ],
      "edges": [
        {
          "from": "get_node_1",
          "to": "get_node_2"
        },
        {
          "from": "get_node_2",
          "to": "get_node_3"
        }
      ]
    }
  },
  {
    "decl_name": "set_node_webhook",
    "start_line": 437,
    "end_line": 449,
    "children": [],
    "code": "async def set_node_webhook(node_id: str, webhook_id: str | None) -> NodeModel:\n    node = await AgentNode.prisma().update(\n        where={\"id\": node_id},\n        data=(\n            {\"Webhook\": {\"connect\": {\"id\": webhook_id}}}\n            if webhook_id\n            else {\"Webhook\": {\"disconnect\": True}}\n        ),\n        include=AGENT_NODE_INCLUDE,\n    )\n    if not node:\n        raise ValueError(f\"Node #{node_id} not found\")\n    return NodeModel.from_db(node)\n",
    "cfg": {
      "nodes": [
        {
          "id": "set_node_webhook_1",
          "code": "async def set_node_webhook(node_id: str, webhook_id: str | None) -> NodeModel:\n    node = await AgentNode.prisma().update(\n        where={\"id\": node_id},\n        data=(\n            {\"Webhook\": {\"connect\": {\"id\": webhook_id}}}\n            if webhook_id\n            else {\"Webhook\": {\"disconnect\": True}}\n        ),\n        include=AGENT_NODE_INCLUDE,\n    )\n"
        },
        {
          "id": "set_node_webhook_2",
          "code": "    if not node:\n        raise ValueError(f\"Node #{node_id} not found\")\n"
        },
        {
          "id": "set_node_webhook_3",
          "code": "    return NodeModel.from_db(node)\n"
        }
      ],
      "edges": [
        {
          "from": "set_node_webhook_1",
          "to": "set_node_webhook_2"
        },
        {
          "from": "set_node_webhook_2",
          "to": "set_node_webhook_3"
        }
      ]
    }
  },
  {
    "decl_name": "get_graphs",
    "start_line": 452,
    "end_line": 489,
    "children": [],
    "code": "async def get_graphs(\n    user_id: str,\n    filter_by: Literal[\"active\", \"template\"] | None = \"active\",\n) -> list[GraphModel]:\n    \"\"\"\n    Retrieves graph metadata objects.\n    Default behaviour is to get all currently active graphs.\n\n    Args:\n        filter_by: An optional filter to either select templates or active graphs.\n        user_id: The ID of the user that owns the graph.\n\n    Returns:\n        list[GraphModel]: A list of objects representing the retrieved graphs.\n    \"\"\"\n    where_clause: AgentGraphWhereInput = {\"userId\": user_id}\n\n    if filter_by == \"active\":\n        where_clause[\"isActive\"] = True\n    elif filter_by == \"template\":\n        where_clause[\"isTemplate\"] = True\n\n    graphs = await AgentGraph.prisma().find_many(\n        where=where_clause,\n        distinct=[\"id\"],\n        order={\"version\": \"desc\"},\n        include=AGENT_GRAPH_INCLUDE,\n    )\n\n    graph_models = []\n    for graph in graphs:\n        try:\n            graph_models.append(GraphModel.from_db(graph))\n        except Exception as e:\n            logger.error(f\"Error processing graph {graph.id}: {e}\")\n            continue\n\n    return graph_models\n",
    "cfg": {
      "nodes": [
        {
          "id": "get_graphs_1",
          "code": "async def get_graphs(\n    user_id: str,\n    filter_by: Literal[\"active\", \"template\"] | None = \"active\",\n) -> list[GraphModel]:\n    \"\"\"\n    Retrieves graph metadata objects.\n    Default behaviour is to get all currently active graphs.\n\n    Args:\n        filter_by: An optional filter to either select templates or active graphs.\n        user_id: The ID of the user that owns the graph.\n\n    Returns:\n        list[GraphModel]: A list of objects representing the retrieved graphs.\n    \"\"\"\n"
        },
        {
          "id": "get_graphs_2",
          "code": "    where_clause: AgentGraphWhereInput = {\"userId\": user_id}\n"
        },
        {
          "id": "get_graphs_3",
          "code": "    if filter_by == \"active\":\n        where_clause[\"isActive\"] = True\n"
        },
        {
          "id": "get_graphs_4",
          "code": "    elif filter_by == \"template\":\n        where_clause[\"isTemplate\"] = True\n"
        },
        {
          "id": "get_graphs_5",
          "code": "    graphs = await AgentGraph.prisma().find_many(\n        where=where_clause,\n        distinct=[\"id\"],\n        order={\"version\": \"desc\"},\n        include=AGENT_GRAPH_INCLUDE,\n    )\n"
        },
        {
          "id": "get_graphs_6",
          "code": "    graph_models = []\n"
        },
        {
          "id": "get_graphs_7",
          "code": "    for graph in graphs:\n        try:\n"
        },
        {
          "id": "get_graphs_8",
          "code": "            graph_models.append(GraphModel.from_db(graph))\n"
        },
        {
          "id": "get_graphs_9",
          "code": "        except Exception as e:\n            logger.error(f\"Error processing graph {graph.id}: {e}\")\n            continue\n"
        },
        {
          "id": "get_graphs_10",
          "code": "    return graph_models\n"
        }
      ],
      "edges": [
        {
          "from": "get_graphs_1",
          "to": "get_graphs_2"
        },
        {
          "from": "get_graphs_2",
          "to": "get_graphs_3"
        },
        {
          "from": "get_graphs_3",
          "to": "get_graphs_4"
        },
        {
          "from": "get_graphs_3",
          "to": "get_graphs_5"
        },
        {
          "from": "get_graphs_4",
          "to": "get_graphs_5"
        },
        {
          "from": "get_graphs_5",
          "to": "get_graphs_6"
        },
        {
          "from": "get_graphs_6",
          "to": "get_graphs_7"
        },
        {
          "from": "get_graphs_7",
          "to": "get_graphs_8"
        },
        {
          "from": "get_graphs_7",
          "to": "get_graphs_9"
        },
        {
          "from": "get_graphs_8",
          "to": "get_graphs_7"
        },
        {
          "from": "get_graphs_9",
          "to": "get_graphs_7"
        }
      ]
    }
  },
  {
    "decl_name": "get_executions",
    "start_line": 492,
    "end_line": 497,
    "children": [],
    "code": "async def get_executions(user_id: str) -> list[GraphExecution]:\n    executions = await AgentGraphExecution.prisma().find_many(\n        where={\"userId\": user_id},\n        order={\"createdAt\": \"desc\"},\n    )\n    return [GraphExecution.from_db(execution) for execution in executions]\n",
    "cfg": {
      "nodes": [
        {
          "id": "get_executions_1",
          "code": "async def get_executions(user_id: str) -> list[GraphExecution]:\n"
        },
        {
          "id": "get_executions_2",
          "code": "    executions = await AgentGraphExecution.prisma().find_many(\n        where={\"userId\": user_id},\n        order={\"createdAt\": \"desc\"},\n    )\n"
        },
        {
          "id": "get_executions_3",
          "code": "    return [GraphExecution.from_db(execution) for execution in executions]\n"
        }
      ],
      "edges": [
        {
          "from": "get_executions_1",
          "to": "get_executions_2"
        },
        {
          "from": "get_executions_2",
          "to": "get_executions_3"
        }
      ]
    }
  },
  {
    "decl_name": "get_execution",
    "start_line": 500,
    "end_line": 504,
    "children": [],
    "code": "async def get_execution(user_id: str, execution_id: str) -> GraphExecution | None:\n    execution = await AgentGraphExecution.prisma().find_first(\n        where={\"id\": execution_id, \"userId\": user_id}\n    )\n    return GraphExecution.from_db(execution) if execution else None\n",
    "cfg": {
      "nodes": [
        {
          "id": "get_execution_1",
          "code": "async def get_execution(user_id: str, execution_id: str) -> GraphExecution | None:\n"
        },
        {
          "id": "get_execution_2",
          "code": "    execution = await AgentGraphExecution.prisma().find_first(\n        where={\"id\": execution_id, \"userId\": user_id}\n    )\n"
        },
        {
          "id": "get_execution_3",
          "code": "    return GraphExecution.from_db(execution) if execution else None\n"
        }
      ],
      "edges": [
        {
          "from": "get_execution_1",
          "to": "get_execution_2"
        },
        {
          "from": "get_execution_2",
          "to": "get_execution_3"
        }
      ]
    }
  },
  {
    "decl_name": "get_graph",
    "start_line": 507,
    "end_line": 538,
    "children": [],
    "code": "async def get_graph(\n    graph_id: str,\n    version: int | None = None,\n    template: bool = False,\n    user_id: str | None = None,\n    for_export: bool = False,\n) -> GraphModel | None:\n    \"\"\"\n    Retrieves a graph from the DB.\n    Defaults to the version with `is_active` if `version` is not passed,\n    or the latest version with `is_template` if `template=True`.\n\n    Returns `None` if the record is not found.\n    \"\"\"\n    where_clause: AgentGraphWhereInput = {\n        \"id\": graph_id,\n    }\n    if version is not None:\n        where_clause[\"version\"] = version\n    elif not template:\n        where_clause[\"isActive\"] = True\n\n    # TODO: Fix hack workaround to get adding store agents to work\n    if user_id is not None and not template:\n        where_clause[\"userId\"] = user_id\n\n    graph = await AgentGraph.prisma().find_first(\n        where=where_clause,\n        include=AGENT_GRAPH_INCLUDE,\n        order={\"version\": \"desc\"},\n    )\n    return GraphModel.from_db(graph, for_export) if graph else None\n",
    "cfg": {
      "nodes": [
        {
          "id": "get_graph_1",
          "code": "async def get_graph(\n    graph_id: str,\n    version: int | None = None,\n    template: bool = False,\n    user_id: str | None = None,\n    for_export: bool = False,\n) -> GraphModel | None:\n"
        },
        {
          "id": "get_graph_2",
          "code": "    \"\"\"\n    Retrieves a graph from the DB.\n    Defaults to the version with `is_active` if `version` is not passed,\n    or the latest version with `is_template` if `template=True`.\n\n    Returns `None` if the record is not found.\n    \"\"\"\n"
        },
        {
          "id": "get_graph_3",
          "code": "    where_clause: AgentGraphWhereInput = {\n        \"id\": graph_id,\n    }\n"
        },
        {
          "id": "get_graph_4",
          "code": "    if version is not None:\n        where_clause[\"version\"] = version\n"
        },
        {
          "id": "get_graph_5",
          "code": "    elif not template:\n        where_clause[\"isActive\"] = True\n"
        },
        {
          "id": "get_graph_6",
          "code": "    # TODO: Fix hack workaround to get adding store agents to work\n"
        },
        {
          "id": "get_graph_7",
          "code": "    if user_id is not None and not template:\n        where_clause[\"userId\"] = user_id\n"
        },
        {
          "id": "get_graph_8",
          "code": "    graph = await AgentGraph.prisma().find_first(\n        where=where_clause,\n        include=AGENT_GRAPH_INCLUDE,\n        order={\"version\": \"desc\"},\n    )\n"
        },
        {
          "id": "get_graph_9",
          "code": "    return GraphModel.from_db(graph, for_export) if graph else None\n"
        }
      ],
      "edges": [
        {
          "from": "get_graph_1",
          "to": "get_graph_2"
        },
        {
          "from": "get_graph_2",
          "to": "get_graph_3"
        },
        {
          "from": "get_graph_3",
          "to": "get_graph_4"
        },
        {
          "from": "get_graph_3",
          "to": "get_graph_5"
        },
        {
          "from": "get_graph_4",
          "to": "get_graph_6"
        },
        {
          "from": "get_graph_5",
          "to": "get_graph_6"
        },
        {
          "from": "get_graph_6",
          "to": "get_graph_7"
        },
        {
          "from": "get_graph_7",
          "to": "get_graph_8"
        },
        {
          "from": "get_graph_8",
          "to": "get_graph_9"
        }
      ]
    }
  },
  {
    "decl_name": "set_graph_active_version",
    "start_line": 541,
    "end_line": 563,
    "children": [],
    "code": "async def set_graph_active_version(graph_id: str, version: int, user_id: str) -> None:\n    # Activate the requested version if it exists and is owned by the user.\n    updated_count = await AgentGraph.prisma().update_many(\n        data={\"isActive\": True},\n        where={\n            \"id\": graph_id,\n            \"version\": version,\n            \"userId\": user_id,\n        },\n    )\n    if updated_count == 0:\n        raise Exception(f\"Graph #{graph_id} v{version} not found or not owned by user\")\n\n    # Deactivate all other versions.\n    await AgentGraph.prisma().update_many(\n        data={\"isActive\": False},\n        where={\n            \"id\": graph_id,\n            \"version\": {\"not\": version},\n            \"userId\": user_id,\n            \"isActive\": True,\n        },\n    )\n",
    "cfg": {
      "nodes": [
        {
          "id": "set_graph_active_version_1",
          "code": "async def set_graph_active_version(graph_id: str, version: int, user_id: str) -> None:\n    # Activate the requested version if it exists and is owned by the user.\n    updated_count = await AgentGraph.prisma().update_many(\n        data={\"isActive\": True},\n        where={\n            \"id\": graph_id,\n            \"version\": version,\n            \"userId\": user_id,\n        },\n    )\n"
        },
        {
          "id": "set_graph_active_version_2",
          "code": "    if updated_count == 0:\n        raise Exception(f\"Graph #{graph_id} v{version} not found or not owned by user\")\n"
        },
        {
          "id": "set_graph_active_version_3",
          "code": "    # Deactivate all other versions.\n    await AgentGraph.prisma().update_many(\n        data={\"isActive\": False},\n        where={\n            \"id\": graph_id,\n            \"version\": {\"not\": version},\n            \"userId\": user_id,\n            \"isActive\": True,\n        },\n    )\n"
        }
      ],
      "edges": [
        {
          "from": "set_graph_active_version_1",
          "to": "set_graph_active_version_2"
        },
        {
          "from": "set_graph_active_version_2",
          "to": "set_graph_active_version_3"
        }
      ]
    }
  },
  {
    "decl_name": "get_graph_all_versions",
    "start_line": 566,
    "end_line": 576,
    "children": [],
    "code": "async def get_graph_all_versions(graph_id: str, user_id: str) -> list[GraphModel]:\n    graph_versions = await AgentGraph.prisma().find_many(\n        where={\"id\": graph_id, \"userId\": user_id},\n        order={\"version\": \"desc\"},\n        include=AGENT_GRAPH_INCLUDE,\n    )\n\n    if not graph_versions:\n        return []\n\n    return [GraphModel.from_db(graph) for graph in graph_versions]\n",
    "cfg": {
      "nodes": [
        {
          "id": "get_graph_all_versions_1",
          "code": "async def get_graph_all_versions(graph_id: str, user_id: str) -> list[GraphModel]:\n    graph_versions = await AgentGraph.prisma().find_many(\n        where={\"id\": graph_id, \"userId\": user_id},\n        order={\"version\": \"desc\"},\n        include=AGENT_GRAPH_INCLUDE,\n    )\n"
        },
        {
          "id": "get_graph_all_versions_2",
          "code": "    if not graph_versions:\n        return []\n"
        },
        {
          "id": "get_graph_all_versions_3",
          "code": "    return [GraphModel.from_db(graph) for graph in graph_versions]\n"
        }
      ],
      "edges": [
        {
          "from": "get_graph_all_versions_1",
          "to": "get_graph_all_versions_2"
        },
        {
          "from": "get_graph_all_versions_2",
          "to": "get_graph_all_versions_3"
        }
      ]
    }
  },
  {
    "decl_name": "delete_graph",
    "start_line": 579,
    "end_line": 585,
    "children": [],
    "code": "async def delete_graph(graph_id: str, user_id: str) -> int:\n    entries_count = await AgentGraph.prisma().delete_many(\n        where={\"id\": graph_id, \"userId\": user_id}\n    )\n    if entries_count:\n        logger.info(f\"Deleted {entries_count} graph entries for Graph #{graph_id}\")\n    return entries_count\n",
    "cfg": {
      "nodes": [
        {
          "id": "delete_graph_1",
          "code": "async def delete_graph(graph_id: str, user_id: str) -> int:\n    entries_count = await AgentGraph.prisma().delete_many(\n        where={\"id\": graph_id, \"userId\": user_id}\n    )\n"
        },
        {
          "id": "delete_graph_2",
          "code": "    if entries_count:\n        logger.info(f\"Deleted {entries_count} graph entries for Graph #{graph_id}\")\n"
        },
        {
          "id": "delete_graph_3",
          "code": "    return entries_count\n"
        }
      ],
      "edges": [
        {
          "from": "delete_graph_1",
          "to": "delete_graph_2"
        },
        {
          "from": "delete_graph_2",
          "to": "delete_graph_3"
        }
      ]
    }
  },
  {
    "decl_name": "create_graph",
    "start_line": 588,
    "end_line": 597,
    "children": [],
    "code": "async def create_graph(graph: Graph, user_id: str) -> GraphModel:\n    async with transaction() as tx:\n        await __create_graph(tx, graph, user_id)\n\n    if created_graph := await get_graph(\n        graph.id, graph.version, graph.is_template, user_id=user_id\n    ):\n        return created_graph\n\n    raise ValueError(f\"Created graph {graph.id} v{graph.version} is not in DB\")\n",
    "cfg": {
      "nodes": [
        {
          "id": "create_graph_1",
          "code": "async def create_graph(graph: Graph, user_id: str) -> GraphModel:\n    async with transaction() as tx:\n        await __create_graph(tx, graph, user_id)\n"
        },
        {
          "id": "create_graph_2",
          "code": "    if created_graph := await get_graph(\n        graph.id, graph.version, graph.is_template, user_id=user_id\n    ):\n        return created_graph\n"
        },
        {
          "id": "create_graph_3",
          "code": "    raise ValueError(f\"Created graph {graph.id} v{graph.version} is not in DB\")\n"
        }
      ],
      "edges": [
        {
          "from": "create_graph_1",
          "to": "create_graph_2"
        },
        {
          "from": "create_graph_2",
          "to": "create_graph_3"
        }
      ]
    }
  },
  {
    "decl_name": "__create_graph",
    "start_line": 600,
    "end_line": 644,
    "children": [],
    "code": "async def __create_graph(tx, graph: Graph, user_id: str):\n    await AgentGraph.prisma(tx).create(\n        data={\n            \"id\": graph.id,\n            \"version\": graph.version,\n            \"name\": graph.name,\n            \"description\": graph.description,\n            \"isTemplate\": graph.is_template,\n            \"isActive\": graph.is_active,\n            \"userId\": user_id,\n        }\n    )\n\n    await asyncio.gather(\n        *[\n            AgentNode.prisma(tx).create(\n                {\n                    \"id\": node.id,\n                    \"agentBlockId\": node.block_id,\n                    \"agentGraphId\": graph.id,\n                    \"agentGraphVersion\": graph.version,\n                    \"constantInput\": json.dumps(node.input_default),\n                    \"metadata\": json.dumps(node.metadata),\n                }\n            )\n            for node in graph.nodes\n        ]\n    )\n\n    await asyncio.gather(\n        *[\n            AgentNodeLink.prisma(tx).create(\n                {\n                    \"id\": str(uuid.uuid4()),\n                    \"sourceName\": link.source_name,\n                    \"sinkName\": link.sink_name,\n                    \"agentNodeSourceId\": link.source_id,\n                    \"agentNodeSinkId\": link.sink_id,\n                    \"isStatic\": link.is_static,\n                }\n            )\n            for link in graph.links\n        ]\n    )\n\n",
    "cfg": {
      "nodes": [
        {
          "id": "__create_graph_1",
          "code": "async def __create_graph(tx, graph: Graph, user_id: str):\n    await AgentGraph.prisma(tx).create(\n        data={\n            \"id\": graph.id,\n            \"version\": graph.version,\n            \"name\": graph.name,\n            \"description\": graph.description,\n            \"isTemplate\": graph.is_template,\n            \"isActive\": graph.is_active,\n            \"userId\": user_id,\n        }\n    )\n"
        },
        {
          "id": "__create_graph_2",
          "code": "    await asyncio.gather(\n        *[\n            AgentNode.prisma(tx).create(\n                {\n                    \"id\": node.id,\n                    \"agentBlockId\": node.block_id,\n                    \"agentGraphId\": graph.id,\n                    \"agentGraphVersion\": graph.version,\n                    \"constantInput\": json.dumps(node.input_default),\n                    \"metadata\": json.dumps(node.metadata),\n                }\n            )\n            for node in graph.nodes\n        ]\n    )\n"
        },
        {
          "id": "__create_graph_3",
          "code": "    await asyncio.gather(\n        *[\n            AgentNodeLink.prisma(tx).create(\n                {\n                    \"id\": str(uuid.uuid4()),\n                    \"sourceName\": link.source_name,\n                    \"sinkName\": link.sink_name,\n                    \"agentNodeSourceId\": link.source_id,\n                    \"agentNodeSinkId\": link.sink_id,\n                    \"isStatic\": link.is_static,\n                }\n            )\n            for link in graph.links\n        ]\n    )\n"
        }
      ],
      "edges": [
        {
          "from": "__create_graph_1",
          "to": "__create_graph_2"
        },
        {
          "from": "__create_graph_2",
          "to": "__create_graph_3"
        }
      ]
    }
  },
  {
    "decl_name": "make_graph_model",
    "start_line": 649,
    "end_line": 672,
    "children": [],
    "code": "def make_graph_model(creatable_graph: Graph, user_id: str) -> GraphModel:\n    \"\"\"\n    Convert a Graph to a GraphModel, setting graph_id and graph_version on all nodes.\n\n    Args:\n        creatable_graph (Graph): The creatable graph to convert.\n        user_id (str): The ID of the user creating the graph.\n\n    Returns:\n        GraphModel: The converted Graph object.\n    \"\"\"\n    # Create a new Graph object, inheriting properties from CreatableGraph\n    return GraphModel(\n        **creatable_graph.model_dump(exclude={\"nodes\"}),\n        user_id=user_id,\n        nodes=[\n            NodeModel(\n                **creatable_node.model_dump(),\n                graph_id=creatable_graph.id,\n                graph_version=creatable_graph.version,\n            )\n            for creatable_node in creatable_graph.nodes\n        ],\n    )\n",
    "cfg": {
      "nodes": [
        {
          "id": "make_graph_model_1",
          "code": "def make_graph_model(creatable_graph: Graph, user_id: str) -> GraphModel:\n    \"\"\"\n    Convert a Graph to a GraphModel, setting graph_id and graph_version on all nodes.\n\n    Args:\n        creatable_graph (Graph): The creatable graph to convert.\n        user_id (str): The ID of the user creating the graph.\n\n    Returns:\n        GraphModel: The converted Graph object.\n    \"\"\"\n"
        },
        {
          "id": "make_graph_model_2",
          "code": "    # Create a new Graph object, inheriting properties from CreatableGraph\n    return GraphModel(\n        **creatable_graph.model_dump(exclude={\"nodes\"}),\n        user_id=user_id,\n        nodes=[\n            NodeModel(\n                **creatable_node.model_dump(),\n                graph_id=creatable_graph.id,\n                graph_version=creatable_graph.version,\n            )\n            for creatable_node in creatable_graph.nodes\n        ],\n    )\n"
        }
      ],
      "edges": [
        {
          "from": "make_graph_model_1",
          "to": "make_graph_model_2"
        }
      ]
    }
  },
  {
    "decl_name": "fix_llm_provider_credentials",
    "start_line": 675,
    "end_line": 746,
    "children": [],
    "code": "async def fix_llm_provider_credentials():\n    \"\"\"Fix node credentials with provider `llm`\"\"\"\n    from backend.integrations.credentials_store import IntegrationCredentialsStore\n\n    from .user import get_user_integrations\n\n    store = IntegrationCredentialsStore()\n\n    broken_nodes = await prisma.get_client().query_raw(\n        \"\"\"\n        SELECT    graph.\"userId\"       user_id,\n                  node.id              node_id,\n                  node.\"constantInput\" node_preset_input\n        FROM      platform.\"AgentNode\"  node\n        LEFT JOIN platform.\"AgentGraph\" graph\n        ON        node.\"agentGraphId\" = graph.id\n        WHERE     node.\"constantInput\"::jsonb->'credentials'->>'provider' = 'llm'\n        ORDER BY  graph.\"userId\";\n        \"\"\"\n    )\n    logger.info(f\"Fixing LLM credential inputs on {len(broken_nodes)} nodes\")\n\n    user_id: str = \"\"\n    user_integrations = None\n    for node in broken_nodes:\n        if node[\"user_id\"] != user_id:\n            # Save queries by only fetching once per user\n            user_id = node[\"user_id\"]\n            user_integrations = await get_user_integrations(user_id)\n        elif not user_integrations:\n            raise RuntimeError(f\"Impossible state while processing node {node}\")\n\n        node_id: str = node[\"node_id\"]\n        node_preset_input: dict = json.loads(node[\"node_preset_input\"])\n        credentials_meta: dict = node_preset_input[\"credentials\"]\n\n        credentials = next(\n            (\n                c\n                for c in user_integrations.credentials\n                if c.id == credentials_meta[\"id\"]\n            ),\n            None,\n        )\n        if not credentials:\n            continue\n        if credentials.type != \"api_key\":\n            logger.warning(\n                f\"User {user_id} credentials {credentials.id} with provider 'llm' \"\n                f\"has invalid type '{credentials.type}'\"\n            )\n            continue\n\n        api_key = credentials.api_key.get_secret_value()\n        if api_key.startswith(\"sk-ant-api03-\"):\n            credentials.provider = credentials_meta[\"provider\"] = \"anthropic\"\n        elif api_key.startswith(\"sk-\"):\n            credentials.provider = credentials_meta[\"provider\"] = \"openai\"\n        elif api_key.startswith(\"gsk_\"):\n            credentials.provider = credentials_meta[\"provider\"] = \"groq\"\n        else:\n            logger.warning(\n                f\"Could not identify provider from key prefix {api_key[:13]}*****\"\n            )\n            continue\n\n        store.update_creds(user_id, credentials)\n        await AgentNode.prisma().update(\n            where={\"id\": node_id},\n            data={\"constantInput\": json.dumps(node_preset_input)},\n        )\n\n",
    "cfg": {
      "nodes": [
        {
          "id": "fix_llm_provider_credentials_1",
          "code": "async def fix_llm_provider_credentials():\n    \"\"\"Fix node credentials with provider `llm`\"\"\"\n    from backend.integrations.credentials_store import IntegrationCredentialsStore\n"
        },
        {
          "id": "fix_llm_provider_credentials_2",
          "code": "    from .user import get_user_integrations\n\n    store = IntegrationCredentialsStore()\n"
        },
        {
          "id": "fix_llm_provider_credentials_3",
          "code": "    broken_nodes = await prisma.get_client().query_raw(\n        \"\"\"\n        SELECT    graph.\"userId\"       user_id,\n                  node.id              node_id,\n                  node.\"constantInput\" node_preset_input\n        FROM      platform.\"AgentNode\"  node\n        LEFT JOIN platform.\"AgentGraph\" graph\n        ON        node.\"agentGraphId\" = graph.id\n        WHERE     node.\"constantInput\"::jsonb->'credentials'->>'provider' = 'llm'\n        ORDER BY  graph.\"userId\";\n        \"\"\"\n    )\n"
        },
        {
          "id": "fix_llm_provider_credentials_4",
          "code": "    logger.info(f\"Fixing LLM credential inputs on {len(broken_nodes)} nodes\")\n"
        },
        {
          "id": "fix_llm_provider_credentials_5",
          "code": "    user_id: str = \"\"\n    user_integrations = None\n"
        },
        {
          "id": "fix_llm_provider_credentials_6",
          "code": "    for node in broken_nodes:\n        if node[\"user_id\"] != user_id:\n"
        },
        {
          "id": "fix_llm_provider_credentials_7",
          "code": "            user_id = node[\"user_id\"]\n            user_integrations = await get_user_integrations(user_id)\n"
        },
        {
          "id": "fix_llm_provider_credentials_8",
          "code": "        elif not user_integrations:\n            raise RuntimeError(f\"Impossible state while processing node {node}\")\n"
        },
        {
          "id": "fix_llm_provider_credentials_9",
          "code": "        node_id: str = node[\"node_id\"]\n        node_preset_input: dict = json.loads(node[\"node_preset_input\"])\n        credentials_meta: dict = node_preset_input[\"credentials\"]\n"
        },
        {
          "id": "fix_llm_provider_credentials_10",
          "code": "        credentials = next(\n            (\n                c\n                for c in user_integrations.credentials\n                if c.id == credentials_meta[\"id\"]\n            ),\n            None,\n        )\n"
        },
        {
          "id": "fix_llm_provider_credentials_11",
          "code": "        if not credentials:\n            continue\n"
        },
        {
          "id": "fix_llm_provider_credentials_12",
          "code": "        if credentials.type != \"api_key\":\n            logger.warning(\n                f\"User {user_id} credentials {credentials.id} with provider 'llm' \"\n                f\"has invalid type '{credentials.type}'\"\n            )\n            continue\n"
        },
        {
          "id": "fix_llm_provider_credentials_13",
          "code": "        api_key = credentials.api_key.get_secret_value()\n        if api_key.startswith(\"sk-ant-api03-\"):\n"
        },
        {
          "id": "fix_llm_provider_credentials_14",
          "code": "            credentials.provider = credentials_meta[\"provider\"] = \"anthropic\"\n"
        },
        {
          "id": "fix_llm_provider_credentials_15",
          "code": "        elif api_key.startswith(\"sk-\"):\n            credentials.provider = credentials_meta[\"provider\"] = \"openai\"\n"
        },
        {
          "id": "fix_llm_provider_credentials_16",
          "code": "        elif api_key.startswith(\"gsk_\"):\n            credentials.provider = credentials_meta[\"provider\"] = \"groq\"\n"
        },
        {
          "id": "fix_llm_provider_credentials_17",
          "code": "        else:\n            logger.warning(\n                f\"Could not identify provider from key prefix {api_key[:13]}*****\"\n            )\n            continue\n"
        },
        {
          "id": "fix_llm_provider_credentials_18",
          "code": "        store.update_creds(user_id, credentials)\n"
        },
        {
          "id": "fix_llm_provider_credentials_19",
          "code": "        await AgentNode.prisma().update(\n            where={\"id\": node_id},\n            data={\"constantInput\": json.dumps(node_preset_input)},\n        )\n"
        }
      ],
      "edges": [
        {
          "from": "fix_llm_provider_credentials_1",
          "to": "fix_llm_provider_credentials_2"
        },
        {
          "from": "fix_llm_provider_credentials_2",
          "to": "fix_llm_provider_credentials_3"
        },
        {
          "from": "fix_llm_provider_credentials_3",
          "to": "fix_llm_provider_credentials_4"
        },
        {
          "from": "fix_llm_provider_credentials_4",
          "to": "fix_llm_provider_credentials_5"
        },
        {
          "from": "fix_llm_provider_credentials_5",
          "to": "fix_llm_provider_credentials_6"
        },
        {
          "from": "fix_llm_provider_credentials_6",
          "to": "fix_llm_provider_credentials_7"
        },
        {
          "from": "fix_llm_provider_credentials_6",
          "to": "fix_llm_provider_credentials_8"
        },
        {
          "from": "fix_llm_provider_credentials_7",
          "to": "fix_llm_provider_credentials_9"
        },
        {
          "from": "fix_llm_provider_credentials_9",
          "to": "fix_llm_provider_credentials_10"
        },
        {
          "from": "fix_llm_provider_credentials_10",
          "to": "fix_llm_provider_credentials_11"
        },
        {
          "from": "fix_llm_provider_credentials_11",
          "to": "fix_llm_provider_credentials_12"
        },
        {
          "from": "fix_llm_provider_credentials_12",
          "to": "fix_llm_provider_credentials_13"
        },
        {
          "from": "fix_llm_provider_credentials_13",
          "to": "fix_llm_provider_credentials_14"
        },
        {
          "from": "fix_llm_provider_credentials_13",
          "to": "fix_llm_provider_credentials_15"
        },
        {
          "from": "fix_llm_provider_credentials_13",
          "to": "fix_llm_provider_credentials_16"
        },
        {
          "from": "fix_llm_provider_credentials_13",
          "to": "fix_llm_provider_credentials_17"
        },
        {
          "from": "fix_llm_provider_credentials_14",
          "to": "fix_llm_provider_credentials_18"
        },
        {
          "from": "fix_llm_provider_credentials_15",
          "to": "fix_llm_provider_credentials_18"
        },
        {
          "from": "fix_llm_provider_credentials_16",
          "to": "fix_llm_provider_credentials_18"
        },
        {
          "from": "fix_llm_provider_credentials_18",
          "to": "fix_llm_provider_credentials_19"
        },
        {
          "from": "fix_llm_provider_credentials_19",
          "to": "fix_llm_provider_credentials_6"
        }
      ]
    }
  }
]