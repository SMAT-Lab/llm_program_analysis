{"file_name": "0.json", "name": "0.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom prisma.models import User\nfrom backend.blocks.basic import AgentInputBlock, PrintToConsoleBlock\nfrom backend.blocks.text import FillTextTemplateBlock\nfrom backend.data import graph\nfrom backend.data.graph import create_graph\nfrom backend.data.user import get_or_create_user\nfrom backend.util.test import SpinTestServer, wait_execution\nif __name__ == '__main__':", "successors": [{"id": 20, "label": "#20\nimport asyncio\nasyncio.run(sample_agent())", "successors": []}]}], "functions": [{"name": "create_test_user", "type": "CFG", "blocks": [{"id": 3, "label": "#3\ntest_user_data = {'sub': 'ef3b97d7-1161-4eb4-92b2-10c24fb154c1', 'email':\n    'testuser#example.com', 'name': 'Test User'}\nuser = await get_or_create_user(test_user_data)", "successors": [{"id": 4, "label": "#4\nreturn user", "successors": []}]}], "functions": [], "classes": []}, {"name": "create_test_graph", "type": "CFG", "blocks": [{"id": 8, "label": "#8\n\"\"\"\n    InputBlock\n                                ---- FillTextTemplateBlock ---- PrintToConsoleBlock\n               /\n    InputBlock\n    \"\"\"\nnodes = [graph.Node(block_id=AgentInputBlock().id, input_default={'name':\n    'input_1'}), graph.Node(block_id=AgentInputBlock().id, input_default={\n    'name': 'input_2'}), graph.Node(block_id=FillTextTemplateBlock().id,\n    input_default={'format': '{a}, {b}{c}', 'values_#_c': '!!!'}), graph.\n    Node(block_id=PrintToConsoleBlock().id)]\nlinks = [graph.Link(source_id=nodes[0].id, sink_id=nodes[2].id, source_name\n    ='result', sink_name='values_#_a'), graph.Link(source_id=nodes[1].id,\n    sink_id=nodes[2].id, source_name='result', sink_name='values_#_b'),\n    graph.Link(source_id=nodes[2].id, sink_id=nodes[3].id, source_name=\n    'output', sink_name='text')]\nreturn graph.Graph(name='TestGraph', description='Test graph', nodes=nodes,\n    links=links)", "successors": []}], "functions": [], "classes": []}, {"name": "sample_agent", "type": "CFG", "blocks": [{"id": 12, "label": "#12\nasync with SpinTestServer() as server:\n    test_user = await create_test_user()\n    test_graph = await create_graph(create_test_graph(), test_user.id)\n    input_data = {'input_1': 'Hello', 'input_2': 'World'}\n    response = await server.agent_server.test_execute_graph(test_graph.id,\n        input_data, test_user.id)\n    print(response)\n    result = await wait_execution(test_user.id, test_graph.id, response[\n        'id'], 10)\n    print(result)", "successors": [{"id": 13, "label": "#13\ntest_user = await create_test_user()", "successors": [{"id": 15, "label": "#15\ntest_graph = await create_graph(create_test_graph(), test_user.id)", "successors": [{"id": 16, "label": "#16\ninput_data = {'input_1': 'Hello', 'input_2': 'World'}\nresponse = await server.agent_server.test_execute_graph(test_graph.id,\n    input_data, test_user.id)", "successors": [{"id": 17, "label": "#17\nprint(response)\nresult = await wait_execution(test_user.id, test_graph.id, response['id'], 10)", "successors": [{"id": 18, "label": "#18\nprint(result)", "successors": []}]}]}]}]}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "1.json", "name": "1.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom enum import Enum\nfrom typing import Any, Dict, Literal, Optional\nfrom pydantic import SecretStr\nfrom requests.exceptions import RequestException\nfrom backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema\nfrom backend.data.model import APIKeyCredentials, CredentialsField, CredentialsMetaInput, SchemaField\nfrom backend.integrations.providers import ProviderName\nfrom backend.util.request import requests\nTEST_CREDENTIALS = APIKeyCredentials(id=\n    '01234567-89ab-cdef-0123-456789abcdef', provider='ideogram', api_key=\n    SecretStr('mock-ideogram-api-key'), title='Mock Ideogram API key',\n    expires_at=None)\nTEST_CREDENTIALS_INPUT = {'provider': TEST_CREDENTIALS.provider, 'id':\n    TEST_CREDENTIALS.id, 'type': TEST_CREDENTIALS.type, 'title':\n    TEST_CREDENTIALS.type}", "successors": []}], "functions": [], "classes": [{"name": "IdeogramModelName", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nV2 = 'V_2'\nV1 = 'V_1'\nV1_TURBO = 'V_1_TURBO'\nV2_TURBO = 'V_2_TURBO'", "successors": []}], "functions": [], "classes": []}, {"name": "MagicPromptOption", "type": "CFG", "blocks": [{"id": 6, "label": "#6\nAUTO = 'AUTO'\nON = 'ON'\nOFF = 'OFF'", "successors": []}], "functions": [], "classes": []}, {"name": "StyleType", "type": "CFG", "blocks": [{"id": 9, "label": "#9\nAUTO = 'AUTO'\nGENERAL = 'GENERAL'\nREALISTIC = 'REALISTIC'\nDESIGN = 'DESIGN'\nRENDER_3D = 'RENDER_3D'\nANIME = 'ANIME'", "successors": []}], "functions": [], "classes": []}, {"name": "ColorPalettePreset", "type": "CFG", "blocks": [{"id": 12, "label": "#12\nNONE = 'NONE'\nEMBER = 'EMBER'\nFRESH = 'FRESH'\nJUNGLE = 'JUNGLE'\nMAGIC = 'MAGIC'\nMELON = 'MELON'\nMOSAIC = 'MOSAIC'\nPASTEL = 'PASTEL'\nULTRAMARINE = 'ULTRAMARINE'", "successors": []}], "functions": [], "classes": []}, {"name": "AspectRatio", "type": "CFG", "blocks": [{"id": 15, "label": "#15\nASPECT_10_16 = 'ASPECT_10_16'\nASPECT_16_10 = 'ASPECT_16_10'\nASPECT_9_16 = 'ASPECT_9_16'\nASPECT_16_9 = 'ASPECT_16_9'\nASPECT_3_2 = 'ASPECT_3_2'\nASPECT_2_3 = 'ASPECT_2_3'\nASPECT_4_3 = 'ASPECT_4_3'\nASPECT_3_4 = 'ASPECT_3_4'\nASPECT_1_1 = 'ASPECT_1_1'\nASPECT_1_3 = 'ASPECT_1_3'\nASPECT_3_1 = 'ASPECT_3_1'", "successors": []}], "functions": [], "classes": []}, {"name": "UpscaleOption", "type": "CFG", "blocks": [{"id": 18, "label": "#18\nAI_UPSCALE = 'AI Upscale'\nNO_UPSCALE = 'No Upscale'", "successors": []}], "functions": [], "classes": []}, {"name": "IdeogramModelBlock", "type": "CFG", "blocks": [{"id": 21, "label": "#21", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 29, "label": "#29\nsuper().__init__(id='6ab085e2-20b3-4055-bc3e-08036e01eca6', description=\n    'This block runs Ideogram models with both simple and advanced settings.',\n    categories={BlockCategory.AI}, input_schema=IdeogramModelBlock.Input,\n    output_schema=IdeogramModelBlock.Output, test_input={\n    'ideogram_model_name': IdeogramModelName.V2, 'prompt':\n    'A futuristic cityscape at sunset', 'aspect_ratio': AspectRatio.\n    ASPECT_1_1, 'upscale': UpscaleOption.NO_UPSCALE, 'magic_prompt_option':\n    MagicPromptOption.AUTO, 'seed': None, 'style_type': StyleType.AUTO,\n    'negative_prompt': None, 'color_palette_name': ColorPalettePreset.NONE,\n    'credentials': TEST_CREDENTIALS_INPUT}, test_output=[('result',\n    'https://ideogram.ai/api/images/test-generated-image-url.png')],\n    test_mock={'run_model': lambda api_key, model_name, prompt, seed,\n    aspect_ratio, magic_prompt_option, style_type, negative_prompt,\n    color_palette_name:\n    'https://ideogram.ai/api/images/test-generated-image-url.png',\n    'upscale_image': lambda api_key, image_url:\n    'https://ideogram.ai/api/images/test-upscaled-image-url.png'},\n    test_credentials=TEST_CREDENTIALS)", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 32, "label": "#32\nseed = input_data.seed\nresult = self.run_model(api_key=credentials.api_key, model_name=input_data.\n    ideogram_model_name.value, prompt=input_data.prompt, seed=seed,\n    aspect_ratio=input_data.aspect_ratio.value, magic_prompt_option=\n    input_data.magic_prompt_option.value, style_type=input_data.style_type.\n    value, negative_prompt=input_data.negative_prompt, color_palette_name=\n    input_data.color_palette_name.value)\nif input_data.upscale == UpscaleOption.AI_UPSCALE:", "successors": [{"id": 33, "label": "#33\nresult = self.upscale_image(api_key=credentials.api_key, image_url=result)", "successors": [{"id": 34, "label": "#34\nyield 'result', result", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "run_model", "type": "CFG", "blocks": [{"id": 38, "label": "#38\nurl = 'https://api.ideogram.ai/generate'\nheaders = {'Api-Key': api_key.get_secret_value(), 'Content-Type':\n    'application/json'}\ndata: Dict[str, Any] = {'image_request': {'prompt': prompt, 'model':\n    model_name, 'aspect_ratio': aspect_ratio, 'magic_prompt_option':\n    magic_prompt_option, 'style_type': style_type}}\nif seed is not None:", "successors": [{"id": 39, "label": "#39\ndata['image_request']['seed'] = seed", "successors": [{"id": 40, "label": "#40\nif negative_prompt:", "successors": [{"id": 41, "label": "#41\ndata['image_request']['negative_prompt'] = negative_prompt", "successors": [{"id": 42, "label": "#42\nif color_palette_name != 'NONE':", "successors": [{"id": 43, "label": "#43\ndata['image_request']['color_palette'] = {'name': color_palette_name}", "successors": [{"id": 44, "label": "#44\ntry:", "successors": [{"id": 45, "label": "#45\nresponse = requests.post(url, json=data, headers=headers)\nreturn response.json()['data'][0]['url']", "successors": []}, {"id": 46, "label": "#46\nraise Exception(f'Failed to fetch image: {str(e)}')", "successors": []}]}]}]}]}]}]}]}], "functions": [], "classes": []}, {"name": "upscale_image", "type": "CFG", "blocks": [{"id": 52, "label": "#52\nurl = 'https://api.ideogram.ai/upscale'\nheaders = {'Api-Key': api_key.get_secret_value()}\ntry:", "successors": [{"id": 53, "label": "#53\nimage_response = requests.get(image_url)\nfiles = {'image_file': ('image.png', image_response.content, 'image/png')}\nresponse = requests.post(url, headers=headers, data={'image_request': '{}'},\n    files=files)\nreturn response.json()['data'][0]['url']", "successors": []}, {"id": 54, "label": "#54\nraise Exception(f'Failed to upscale image: {str(e)}')", "successors": []}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 23, "label": "#23\ncredentials: CredentialsMetaInput[Literal[ProviderName.IDEOGRAM], Literal[\n    'api_key']] = CredentialsField(description=\n    'The Ideogram integration can be used with any API key with sufficient permissions for the blocks it is used on.'\n    )\nprompt: str = SchemaField(description='Text prompt for image generation',\n    placeholder=\"e.g., 'A futuristic cityscape at sunset'\", title='Prompt')\nideogram_model_name: IdeogramModelName = SchemaField(description=\n    'The name of the Image Generation Model, e.g., V_2', default=\n    IdeogramModelName.V2, title='Image Generation Model', advanced=False)\naspect_ratio: AspectRatio = SchemaField(description=\n    'Aspect ratio for the generated image', default=AspectRatio.ASPECT_1_1,\n    title='Aspect Ratio', advanced=False)\nupscale: UpscaleOption = SchemaField(description=\n    'Upscale the generated image', default=UpscaleOption.NO_UPSCALE, title=\n    'Upscale Image', advanced=False)\nmagic_prompt_option: MagicPromptOption = SchemaField(description=\n    'Whether to use MagicPrompt for enhancing the request', default=\n    MagicPromptOption.AUTO, title='Magic Prompt Option', advanced=True)\nseed: Optional[int] = SchemaField(description=\n    'Random seed. Set for reproducible generation', default=None, title=\n    'Seed', advanced=True)\nstyle_type: StyleType = SchemaField(description=\n    'Style type to apply, applicable for V_2 and above', default=StyleType.\n    AUTO, title='Style Type', advanced=True)\nnegative_prompt: Optional[str] = SchemaField(description=\n    'Description of what to exclude from the image', default=None, title=\n    'Negative Prompt', advanced=True)\ncolor_palette_name: ColorPalettePreset = SchemaField(description=\n    \"Color palette preset name, choose 'None' to skip\", default=\n    ColorPalettePreset.NONE, title='Color Palette Preset', advanced=True)", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 26, "label": "#26\nresult: str = SchemaField(description='Generated image URL')\nerror: str = SchemaField(description='Error message if the model run failed')", "successors": []}], "functions": [], "classes": []}]}]}
{"file_name": "2.json", "name": "2.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom backend.blocks.jina._auth import JinaCredentials, JinaCredentialsField, JinaCredentialsInput\nfrom backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema\nfrom backend.data.model import SchemaField\nfrom backend.util.request import requests", "successors": []}], "functions": [], "classes": [{"name": "JinaEmbeddingBlock", "type": "CFG", "blocks": [{"id": 3, "label": "#3", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 11, "label": "#11\nsuper().__init__(id='7c56b3ab-62e7-43a2-a2dc-4ec4245660b6', description=\n    'Generates embeddings using Jina AI', categories={BlockCategory.AI},\n    input_schema=JinaEmbeddingBlock.Input, output_schema=JinaEmbeddingBlock\n    .Output)", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 14, "label": "#14\nurl = 'https://api.jina.ai/v1/embeddings'\nheaders = {'Content-Type': 'application/json', 'Authorization':\n    f'Bearer {credentials.api_key.get_secret_value()}'}\ndata = {'input': input_data.texts, 'model': input_data.model}\nresponse = requests.post(url, headers=headers, json=data)\nembeddings = [e['embedding'] for e in response.json()['data']]\nyield 'embeddings', embeddings", "successors": []}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 5, "label": "#5\ntexts: list = SchemaField(description='List of texts to embed')\ncredentials: JinaCredentialsInput = JinaCredentialsField()\nmodel: str = SchemaField(description='Jina embedding model to use', default\n    ='jina-embeddings-v2-base-en')", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 8, "label": "#8\nembeddings: list = SchemaField(description='List of embeddings')", "successors": []}], "functions": [], "classes": []}]}]}
{"file_name": "3.json", "name": "3.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom typing import Type\nfrom backend.blocks.ai_music_generator import AIMusicGeneratorBlock\nfrom backend.blocks.ai_shortform_video_block import AIShortformVideoCreatorBlock\nfrom backend.blocks.ideogram import IdeogramModelBlock\nfrom backend.blocks.jina.embeddings import JinaEmbeddingBlock\nfrom backend.blocks.jina.search import ExtractWebsiteContentBlock, SearchTheWebBlock\nfrom backend.blocks.llm import MODEL_METADATA, AIConversationBlock, AIListGeneratorBlock, AIStructuredResponseGeneratorBlock, AITextGeneratorBlock, AITextSummarizerBlock, LlmModel\nfrom backend.blocks.replicate_flux_advanced import ReplicateFluxAdvancedModelBlock\nfrom backend.blocks.talking_head import CreateTalkingAvatarVideoBlock\nfrom backend.blocks.text_to_speech_block import UnrealTextToSpeechBlock\nfrom backend.data.block import Block\nfrom backend.data.cost import BlockCost, BlockCostType\nfrom backend.integrations.credentials_store import anthropic_credentials, did_credentials, groq_credentials, ideogram_credentials, jina_credentials, open_router_credentials, openai_credentials, replicate_credentials, revid_credentials, unreal_credentials\nMODEL_COST: dict[LlmModel, int] = {LlmModel.O1_PREVIEW: 16, LlmModel.\n    O1_MINI: 4, LlmModel.GPT4O_MINI: 1, LlmModel.GPT4O: 3, LlmModel.\n    GPT4_TURBO: 10, LlmModel.GPT3_5_TURBO: 1, LlmModel.CLAUDE_3_5_SONNET: 4,\n    LlmModel.CLAUDE_3_HAIKU: 1, LlmModel.LLAMA3_8B: 1, LlmModel.LLAMA3_70B:\n    1, LlmModel.MIXTRAL_8X7B: 1, LlmModel.GEMMA_7B: 1, LlmModel.GEMMA2_9B: \n    1, LlmModel.LLAMA3_1_405B: 1, LlmModel.LLAMA3_1_70B: 1, LlmModel.\n    LLAMA3_1_8B: 1, LlmModel.OLLAMA_LLAMA3_8B: 1, LlmModel.\n    OLLAMA_LLAMA3_405B: 1, LlmModel.OLLAMA_DOLPHIN: 1, LlmModel.\n    GEMINI_FLASH_1_5_8B: 1, LlmModel.GROK_BETA: 5, LlmModel.MISTRAL_NEMO: 1,\n    LlmModel.COHERE_COMMAND_R_08_2024: 1, LlmModel.\n    COHERE_COMMAND_R_PLUS_08_2024: 3, LlmModel.EVA_QWEN_2_5_32B: 1,\n    LlmModel.DEEPSEEK_CHAT: 2, LlmModel.\n    PERPLEXITY_LLAMA_3_1_SONAR_LARGE_128K_ONLINE: 1, LlmModel.\n    QWEN_QWQ_32B_PREVIEW: 2, LlmModel.NOUSRESEARCH_HERMES_3_LLAMA_3_1_405B:\n    1, LlmModel.NOUSRESEARCH_HERMES_3_LLAMA_3_1_70B: 1, LlmModel.\n    AMAZON_NOVA_LITE_V1: 1, LlmModel.AMAZON_NOVA_MICRO_V1: 1, LlmModel.\n    AMAZON_NOVA_PRO_V1: 1, LlmModel.MICROSOFT_WIZARDLM_2_8X22B: 1, LlmModel\n    .GRYPHE_MYTHOMAX_L2_13B: 1}", "successors": [{"id": 2, "label": "#2\nfor model in LlmModel:", "successors": [{"id": 3, "label": "#3\nif model not in MODEL_COST:", "successors": [{"id": 5, "label": "#5\nraise ValueError(f'Missing MODEL_COST for model: {model}')", "successors": []}]}, {"id": 4, "label": "#4\nLLM_COST = [BlockCost(cost_type=BlockCostType.RUN, cost_filter={'model':\n    model, 'credentials': {'id': anthropic_credentials.id, 'provider':\n    anthropic_credentials.provider, 'type': anthropic_credentials.type}},\n    cost_amount=cost) for model, cost in MODEL_COST.items() if \n    MODEL_METADATA[model].provider == 'anthropic'] + [BlockCost(cost_type=\n    BlockCostType.RUN, cost_filter={'model': model, 'credentials': {'id':\n    openai_credentials.id, 'provider': openai_credentials.provider, 'type':\n    openai_credentials.type}}, cost_amount=cost) for model, cost in\n    MODEL_COST.items() if MODEL_METADATA[model].provider == 'openai'] + [\n    BlockCost(cost_type=BlockCostType.RUN, cost_filter={'model': model,\n    'credentials': {'id': groq_credentials.id}}, cost_amount=cost) for \n    model, cost in MODEL_COST.items() if MODEL_METADATA[model].provider ==\n    'groq'] + [BlockCost(cost_type=BlockCostType.RUN, cost_filter={'model':\n    model, 'credentials': {'id': open_router_credentials.id, 'provider':\n    open_router_credentials.provider, 'type': open_router_credentials.type}\n    }, cost_amount=cost) for model, cost in MODEL_COST.items() if \n    MODEL_METADATA[model].provider == 'open_router']\nBLOCK_COSTS: dict[Type[Block], list[BlockCost]] = {AIConversationBlock:\n    LLM_COST, AITextGeneratorBlock: LLM_COST,\n    AIStructuredResponseGeneratorBlock: LLM_COST, AITextSummarizerBlock:\n    LLM_COST, AIListGeneratorBlock: LLM_COST, CreateTalkingAvatarVideoBlock:\n    [BlockCost(cost_amount=15, cost_filter={'credentials': {'id':\n    did_credentials.id, 'provider': did_credentials.provider, 'type':\n    did_credentials.type}})], SearchTheWebBlock: [BlockCost(cost_amount=1,\n    cost_filter={'credentials': {'id': jina_credentials.id, 'provider':\n    jina_credentials.provider, 'type': jina_credentials.type}})],\n    ExtractWebsiteContentBlock: [BlockCost(cost_amount=1, cost_filter={\n    'raw_content': False, 'credentials': {'id': jina_credentials.id,\n    'provider': jina_credentials.provider, 'type': jina_credentials.type}})\n    ], IdeogramModelBlock: [BlockCost(cost_amount=16, cost_filter={\n    'credentials': {'id': ideogram_credentials.id, 'provider':\n    ideogram_credentials.provider, 'type': ideogram_credentials.type}})],\n    AIShortformVideoCreatorBlock: [BlockCost(cost_amount=50, cost_filter={\n    'credentials': {'id': revid_credentials.id, 'provider':\n    revid_credentials.provider, 'type': revid_credentials.type}})],\n    ReplicateFluxAdvancedModelBlock: [BlockCost(cost_amount=10, cost_filter\n    ={'credentials': {'id': replicate_credentials.id, 'provider':\n    replicate_credentials.provider, 'type': replicate_credentials.type}})],\n    AIMusicGeneratorBlock: [BlockCost(cost_amount=11, cost_filter={\n    'credentials': {'id': replicate_credentials.id, 'provider':\n    replicate_credentials.provider, 'type': replicate_credentials.type}})],\n    JinaEmbeddingBlock: [BlockCost(cost_amount=12, cost_filter={\n    'credentials': {'id': jina_credentials.id, 'provider': jina_credentials\n    .provider, 'type': jina_credentials.type}})], UnrealTextToSpeechBlock:\n    [BlockCost(cost_amount=5, cost_filter={'credentials': {'id':\n    unreal_credentials.id, 'provider': unreal_credentials.provider, 'type':\n    unreal_credentials.type}})]}", "successors": []}]}]}], "functions": [], "classes": []}
{"file_name": "4.json", "name": "4.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport atexit\nimport logging\nimport multiprocessing\nimport os\nimport signal\nimport sys\nimport threading\nfrom concurrent.futures import Future, ProcessPoolExecutor\nfrom contextlib import contextmanager\nfrom multiprocessing.pool import AsyncResult, Pool\nfrom typing import TYPE_CHECKING, Any, Generator, TypeVar, cast\nfrom pydantic import BaseModel\nfrom redis.lock import Lock as RedisLock\nif TYPE_CHECKING:", "successors": [{"id": 2, "label": "#2\nfrom backend.executor import DatabaseManager", "successors": [{"id": 3, "label": "#3\nfrom autogpt_libs.utils.cache import thread_cached\nfrom backend.blocks.agent import AgentExecutorBlock\nfrom backend.data import redis\nfrom backend.data.block import Block, BlockData, BlockInput, BlockType, get_block\nfrom backend.data.execution import ExecutionQueue, ExecutionResult, ExecutionStatus, GraphExecutionEntry, NodeExecutionEntry, merge_execution_input, parse_execution_output\nfrom backend.data.graph import GraphModel, Link, Node\nfrom backend.data.model import CREDENTIALS_FIELD_NAME, CredentialsMetaInput\nfrom backend.integrations.creds_manager import IntegrationCredentialsManager\nfrom backend.util import json\nfrom backend.util.decorator import error_logged, time_measured\nfrom backend.util.logging import configure_logging\nfrom backend.util.process import set_service_name\nfrom backend.util.service import AppService, close_service_client, expose, get_service_client\nfrom backend.util.settings import Settings\nfrom backend.util.type import convert\nlogger = logging.getLogger(__name__)\nsettings = Settings()\nT = TypeVar('T')\nExecutionStream = Generator[NodeExecutionEntry, None, None]", "successors": []}]}]}], "functions": [{"name": "execute_node", "type": "CFG", "blocks": [{"id": 30, "label": "#30\n\"\"\"\n    Execute a node in the graph. This will trigger a block execution on a node,\n    persist the execution result, and return the subsequent node to be executed.\n\n    Args:\n        db_client: The client to send execution updates to the server.\n        creds_manager: The manager to acquire and release credentials.\n        data: The execution data for executing the current node.\n        execution_stats: The execution statistics to be updated.\n\n    Returns:\n        The subsequent node to be enqueued, or None if there is no subsequent node.\n    \"\"\"\nuser_id = data.user_id\ngraph_exec_id = data.graph_exec_id\ngraph_id = data.graph_id\nnode_exec_id = data.node_exec_id\nnode_id = data.node_id\nnode = db_client.get_node(node_id)\nnode_block = get_block(node.block_id)\nif not node_block:", "successors": [{"id": 35, "label": "#35\nlogger.error(f'Block {node.block_id} not found.')\nreturn", "successors": []}, {"id": 36, "label": "#36\nlog_metadata = LogMetadata(user_id=user_id, graph_eid=graph_exec_id,\n    graph_id=graph_id, node_eid=node_exec_id, node_id=node_id, block_name=\n    node_block.name)\ninput_data, error = validate_exec(node, data.data, resolve_input=False)\nif input_data is None:", "successors": [{"id": 38, "label": "#38\nlog_metadata.error(f'Skip execution, input validation error: {error}')\ndb_client.upsert_execution_output(node_exec_id, 'error', error)\nupdate_execution(ExecutionStatus.FAILED)\nreturn", "successors": []}, {"id": 39, "label": "#39\nif isinstance(node_block, AgentExecutorBlock):", "successors": [{"id": 41, "label": "#41\ninput_data = {**node.input_default, 'data': input_data}", "successors": [{"id": 42, "label": "#42\ninput_data_str = json.dumps(input_data)\ninput_size = len(input_data_str)\nlog_metadata.info('Executed node with input', input=input_data_str)\nupdate_execution(ExecutionStatus.RUNNING)\nextra_exec_kwargs = {}\ncreds_lock = None\nif CREDENTIALS_FIELD_NAME in input_data:", "successors": [{"id": 43, "label": "#43\ncredentials_meta = CredentialsMetaInput(**input_data[CREDENTIALS_FIELD_NAME])\ncredentials, creds_lock = creds_manager.acquire(user_id, credentials_meta.id)\nextra_exec_kwargs['credentials'] = credentials", "successors": [{"id": 44, "label": "#44\noutput_size = 0\nend_status = ExecutionStatus.COMPLETED\ncredit = db_client.get_or_refill_credit(user_id)\nif credit < 0:", "successors": [{"id": 45, "label": "#45\nraise ValueError(f'Insufficient credit: {credit}')", "successors": []}, {"id": 46, "label": "#46\ntry:", "successors": [{"id": 48, "label": "#48\nfor output_name, output_data in node_block.execute(input_data, **", "successors": [{"id": 51, "label": "#51\noutput_size += len(json.dumps(output_data))\nlog_metadata.info('Node produced output', **{output_name: output_data})\ndb_client.upsert_execution_output(node_exec_id, output_name, output_data)", "successors": [{"id": 53, "label": "#53\nfor execution in _enqueue_next_nodes(db_client=db_client, node=node, output", "successors": [{"id": 54, "label": "#54\nyield execution", "successors": []}]}]}]}, {"id": 49, "label": "#49\nend_status = ExecutionStatus.FAILED\nerror_msg = str(e)\nlog_metadata.exception(f'Node execution failed with error {error_msg}')\ndb_client.upsert_execution_output(node_exec_id, 'error', error_msg)", "successors": [{"id": 57, "label": "#57\nfor execution in _enqueue_next_nodes(db_client=db_client, node=node, output", "successors": [{"id": 58, "label": "#58\nyield execution", "successors": []}, {"id": 59, "label": "#59\nraise e", "successors": []}]}]}]}]}]}]}]}]}]}]}], "functions": [{"name": "update_execution", "type": "CFG", "blocks": [{"id": 32, "label": "#32\nexec_update = db_client.update_execution_status(node_exec_id, status)\ndb_client.send_execution_update(exec_update)\nreturn exec_update", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "_enqueue_next_nodes", "type": "CFG", "blocks": [{"id": 64, "label": "#64\nreturn [execution for link in node.output_links for execution in\n    register_next_executions(link)]", "successors": []}], "functions": [{"name": "add_enqueued_execution", "type": "CFG", "blocks": [{"id": 66, "label": "#66\nexec_update = db_client.update_execution_status(node_exec_id,\n    ExecutionStatus.QUEUED, data)\ndb_client.send_execution_update(exec_update)\nreturn NodeExecutionEntry(user_id=user_id, graph_exec_id=graph_exec_id,\n    graph_id=graph_id, node_exec_id=node_exec_id, node_id=node_id, data=data)", "successors": []}], "functions": [], "classes": []}, {"name": "register_next_executions", "type": "CFG", "blocks": [{"id": 70, "label": "#70\nenqueued_executions = []\nnext_output_name = node_link.source_name\nnext_input_name = node_link.sink_name\nnext_node_id = node_link.sink_id\nnext_data = parse_execution_output(output, next_output_name)\nif next_data is None:", "successors": [{"id": 71, "label": "#71\nreturn enqueued_executions", "successors": []}, {"id": 72, "label": "#72\nnext_node = db_client.get_node(next_node_id)\nwith synchronized(f'upsert_input-{next_node_id}-{graph_exec_id}'):", "successors": [{"id": 74, "label": "#74\nnext_node_exec_id, next_node_input = db_client.upsert_execution_input(node_id\n    =next_node_id, graph_exec_id=graph_exec_id, input_name=next_input_name,\n    input_data=next_data)\nstatic_link_names = {link.sink_name for link in next_node.input_links if \n    link.is_static and link.sink_name not in next_node_input}\nif static_link_names and (latest_execution := db_client.", "successors": [{"id": 76, "label": "#76\nfor name in static_link_names:", "successors": [{"id": 78, "label": "#78\nnext_node_input[name] = latest_execution.input_data.get(name)", "successors": []}, {"id": 77, "label": "#77\nnext_node_input, validation_msg = validate_exec(next_node, next_node_input)\nsuffix = (\n    f'{next_output_name}>{next_input_name}~{next_node_exec_id}:{validation_msg}'\n    )\nif not next_node_input:", "successors": [{"id": 80, "label": "#80\nlog_metadata.warning(f'Skipped queueing {suffix}')\nreturn enqueued_executions", "successors": []}, {"id": 81, "label": "#81\nlog_metadata.info(f'Enqueued {suffix}')\nenqueued_executions.append(add_enqueued_execution(next_node_exec_id,\n    next_node_id, next_node_input))\nif not node_link.is_static:", "successors": [{"id": 83, "label": "#83\nreturn enqueued_executions", "successors": []}, {"id": 84, "label": "#84\nfor iexec in db_client.get_incomplete_executions(next_node_id, graph_exec_id):", "successors": [{"id": 86, "label": "#86\nidata = iexec.input_data\nineid = iexec.node_exec_id\nstatic_link_names = {link.sink_name for link in next_node.input_links if \n    link.is_static and link.sink_name not in idata}", "successors": [{"id": 88, "label": "#88\nfor input_name in static_link_names:", "successors": [{"id": 89, "label": "#89\nidata[input_name] = next_node_input[input_name]", "successors": []}, {"id": 90, "label": "#90\nidata, msg = validate_exec(next_node, idata)\nsuffix = f'{next_output_name}>{next_input_name}~{ineid}:{msg}'\nif not idata:", "successors": [{"id": 91, "label": "#91\nlog_metadata.info(f'Enqueueing static-link skipped: {suffix}')", "successors": []}, {"id": 92, "label": "#92\nlog_metadata.info(f'Enqueueing static-link execution {suffix}')\nenqueued_executions.append(add_enqueued_execution(iexec.node_exec_id,\n    next_node_id, idata))", "successors": []}]}]}]}, {"id": 87, "label": "#87\nreturn enqueued_executions", "successors": []}]}]}]}]}]}]}]}], "functions": [], "classes": []}], "classes": []}, {"name": "validate_exec", "type": "CFG", "blocks": [{"id": 98, "label": "#98\n\"\"\"\n    Validate the input data for a node execution.\n\n    Args:\n        node: The node to execute.\n        data: The input data for the node execution.\n        resolve_input: Whether to resolve dynamic pins into dict/list/object.\n\n    Returns:\n        A tuple of the validated data and the block name.\n        If the data is invalid, the first element will be None, and the second element\n        will be an error message.\n        If the data is valid, the first element will be the resolved input data, and\n        the second element will be the block name.\n    \"\"\"\nnode_block: Block | None = get_block(node.block_id)\nif not node_block:", "successors": [{"id": 99, "label": "#99\nreturn None, f'Block for {node.block_id} not found.'", "successors": []}, {"id": 100, "label": "#100\nif isinstance(node_block, AgentExecutorBlock):", "successors": [{"id": 102, "label": "#102\ntry:", "successors": [{"id": 109, "label": "#109\nexec_data = AgentExecutorBlock.Input(**node.input_default)", "successors": [{"id": 111, "label": "#111\ninput_schema = exec_data.input_schema\nrequired_fields = set(input_schema['required'])\ninput_default = exec_data.data", "successors": [{"id": 103, "label": "#103\nerror_prefix = f'Input data missing or mismatch for `{node_block.name}`:'\ninput_fields_from_nodes = {link.sink_name for link in node.input_links}\nif not input_fields_from_nodes.issubset(data):", "successors": [{"id": 113, "label": "#113\nreturn None, f'{error_prefix} {input_fields_from_nodes - set(data)}'", "successors": []}, {"id": 114, "label": "#114\ndata = {**input_default, **data}\nif resolve_input:", "successors": [{"id": 116, "label": "#116\ndata = merge_execution_input(data)", "successors": [{"id": 117, "label": "#117\nif not required_fields.issubset(data):", "successors": [{"id": 118, "label": "#118\nreturn None, f'{error_prefix} {required_fields - set(data)}'", "successors": []}, {"id": 119, "label": "#119\nif (error := json.validate_with_jsonschema(schema=input_schema, data=data)):", "successors": [{"id": 121, "label": "#121\nerror_message = f'{error_prefix} {error}'\nlogger.error(error_message)\nreturn None, error_message", "successors": []}, {"id": 122, "label": "#122\nreturn data, node_block.name", "successors": []}]}]}]}]}]}]}]}, {"id": 110, "label": "#110\nreturn None, f\"Input data doesn't match {node_block.name}: {str(e)}\"", "successors": []}]}, {"id": 104, "label": "#104\nfor name, data_type in node_block.input_schema.__annotations__.items():", "successors": [{"id": 105, "label": "#105\nif (value := data.get(name)) and type(value) is not data_type:", "successors": [{"id": 107, "label": "#107\ndata[name] = convert(value, data_type)", "successors": []}]}, {"id": 106, "label": "#106\ninput_schema = node_block.input_schema.jsonschema()\nrequired_fields = node_block.input_schema.get_required_fields()\ninput_default = node.input_default", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "get_db_client", "type": "CFG", "blocks": [{"id": 297, "label": "#297\nfrom backend.executor import DatabaseManager\nreturn get_service_client(DatabaseManager)", "successors": []}], "functions": [], "classes": []}, {"name": "synchronized", "type": "CFG", "blocks": [{"id": 301, "label": "#301\nlock: RedisLock = redis.get_redis().lock(f'lock:{key}', timeout=timeout)\ntry:", "successors": [{"id": 302, "label": "#302\nlock.acquire()\nyield", "successors": []}]}], "functions": [], "classes": []}, {"name": "llprint", "type": "CFG", "blocks": [{"id": 307, "label": "#307\n\"\"\"\n    Low-level print/log helper function for use in signal handlers.\n    Regular log/print statements are not allowed in signal handlers.\n    \"\"\"\nif logger.getEffectiveLevel() == logging.DEBUG:", "successors": [{"id": 308, "label": "#308\nos.write(sys.stdout.fileno(), (message + '\\n').encode())", "successors": []}]}], "functions": [], "classes": []}], "classes": [{"name": "LogMetadata", "type": "CFG", "blocks": [{"id": 5, "label": "#5", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 7, "label": "#7\nself.metadata = {'component': 'ExecutionManager', 'user_id': user_id,\n    'graph_eid': graph_eid, 'graph_id': graph_id, 'node_eid': node_eid,\n    'node_id': node_id, 'block_name': block_name}\nself.prefix = (\n    f'[ExecutionManager|uid:{user_id}|gid:{graph_id}|nid:{node_id}]|geid:{graph_eid}|nid:{node_eid}|{block_name}]'\n    )", "successors": []}], "functions": [], "classes": []}, {"name": "info", "type": "CFG", "blocks": [{"id": 10, "label": "#10\nmsg = self._wrap(msg, **extra)\nlogger.info(msg, extra={'json_fields': {**self.metadata, **extra}})", "successors": []}], "functions": [], "classes": []}, {"name": "warning", "type": "CFG", "blocks": [{"id": 13, "label": "#13\nmsg = self._wrap(msg, **extra)\nlogger.warning(msg, extra={'json_fields': {**self.metadata, **extra}})", "successors": []}], "functions": [], "classes": []}, {"name": "error", "type": "CFG", "blocks": [{"id": 16, "label": "#16\nmsg = self._wrap(msg, **extra)\nlogger.error(msg, extra={'json_fields': {**self.metadata, **extra}})", "successors": []}], "functions": [], "classes": []}, {"name": "debug", "type": "CFG", "blocks": [{"id": 19, "label": "#19\nmsg = self._wrap(msg, **extra)\nlogger.debug(msg, extra={'json_fields': {**self.metadata, **extra}})", "successors": []}], "functions": [], "classes": []}, {"name": "exception", "type": "CFG", "blocks": [{"id": 22, "label": "#22\nmsg = self._wrap(msg, **extra)\nlogger.exception(msg, extra={'json_fields': {**self.metadata, **extra}})", "successors": []}], "functions": [], "classes": []}, {"name": "_wrap", "type": "CFG", "blocks": [{"id": 25, "label": "#25\nreturn f'{self.prefix} {msg} {extra}'", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "Executor", "type": "CFG", "blocks": [{"id": 127, "label": "#127\n\"\"\"\n    This class contains event handlers for the process pool executor events.\n\n    The main events are:\n        on_node_executor_start: Initialize the process that executes the node.\n        on_node_execution: Execution logic for a node.\n\n        on_graph_executor_start: Initialize the process that executes the graph.\n        on_graph_execution: Execution logic for a graph.\n\n    The execution flow:\n        1. Graph execution request is added to the queue.\n        2. Graph executor loop picks the request from the queue.\n        3. Graph executor loop submits the graph execution request to the executor pool.\n      [on_graph_execution]\n        4. Graph executor initialize the node execution queue.\n        5. Graph executor adds the starting nodes to the node execution queue.\n        6. Graph executor waits for all nodes to be executed.\n      [on_node_execution]\n        7. Node executor picks the node execution request from the queue.\n        8. Node executor executes the node.\n        9. Node executor enqueues the next executed nodes to the node execution queue.\n    \"\"\"", "successors": []}], "functions": [{"name": "on_node_executor_start", "type": "CFG", "blocks": [{"id": 129, "label": "#129\nconfigure_logging()\nset_service_name('NodeExecutor')\nredis.connect()\ncls.pid = os.getpid()\ncls.db_client = get_db_client()\ncls.creds_manager = IntegrationCredentialsManager()\ncls.shutdown_lock = threading.Lock()\natexit.register(cls.on_node_executor_stop)\nsignal.signal(signal.SIGTERM, lambda _, __: cls.on_node_executor_sigterm())", "successors": []}], "functions": [], "classes": []}, {"name": "on_node_executor_stop", "type": "CFG", "blocks": [{"id": 132, "label": "#132\nif not cls.shutdown_lock.acquire(blocking=False):", "successors": [{"id": 133, "label": "#133\nreturn", "successors": []}, {"id": 134, "label": "#134\ncls.creds_manager.release_all_locks()\nredis.disconnect()\nclose_service_client(cls.db_client)\nlogger.info(f'[on_node_executor_stop {cls.pid}] \u2705 Finished cleanup')", "successors": []}]}], "functions": [], "classes": []}, {"name": "on_node_executor_sigterm", "type": "CFG", "blocks": [{"id": 138, "label": "#138\nllprint(f'[on_node_executor_sigterm {cls.pid}] \u26a0\ufe0f SIGTERM received')\nif not cls.shutdown_lock.acquire(blocking=False):", "successors": [{"id": 139, "label": "#139\nreturn", "successors": []}, {"id": 140, "label": "#140\ncls.creds_manager.release_all_locks()\nredis.disconnect()\nllprint(f'[on_node_executor_stop {cls.pid}] \u2705 Finished cleanup')\nsys.exit(0)", "successors": []}]}], "functions": [], "classes": []}, {"name": "on_node_execution", "type": "CFG", "blocks": [{"id": 144, "label": "#144\nlog_metadata = LogMetadata(user_id=node_exec.user_id, graph_eid=node_exec.\n    graph_exec_id, graph_id=node_exec.graph_id, node_eid=node_exec.\n    node_exec_id, node_id=node_exec.node_id, block_name='-')\nexecution_stats = {}\ntiming_info, _ = cls._on_node_execution(q, node_exec, log_metadata,\n    execution_stats)\nexecution_stats['walltime'] = timing_info.wall_time\nexecution_stats['cputime'] = timing_info.cpu_time\ncls.db_client.update_node_execution_stats(node_exec.node_exec_id,\n    execution_stats)\nreturn execution_stats", "successors": []}], "functions": [], "classes": []}, {"name": "_on_node_execution", "type": "CFG", "blocks": [{"id": 148, "label": "#148\ntry:", "successors": [{"id": 149, "label": "#149\nlog_metadata.info(f'Start node execution {node_exec.node_exec_id}')", "successors": [{"id": 152, "label": "#152\nfor execution in execute_node(cls.db_client, cls.creds_manager, node_exec,", "successors": [{"id": 153, "label": "#153\nq.add(execution)", "successors": []}, {"id": 154, "label": "#154\nlog_metadata.info(f'Finished node execution {node_exec.node_exec_id}')", "successors": []}]}]}, {"id": 150, "label": "#150\nlog_metadata.exception(f'Failed node execution {node_exec.node_exec_id}: {e}')", "successors": []}]}], "functions": [], "classes": []}, {"name": "on_graph_executor_start", "type": "CFG", "blocks": [{"id": 157, "label": "#157\nconfigure_logging()\nset_service_name('GraphExecutor')\ncls.db_client = get_db_client()\ncls.pool_size = settings.config.num_node_workers\ncls.pid = os.getpid()\ncls._init_node_executor_pool()\nlogger.info(\n    f'Graph executor {cls.pid} started with {cls.pool_size} node workers')\natexit.register(cls.on_graph_executor_stop)", "successors": []}], "functions": [], "classes": []}, {"name": "on_graph_executor_stop", "type": "CFG", "blocks": [{"id": 160, "label": "#160\nprefix = f'[on_graph_executor_stop {cls.pid}]'\ncls.executor.terminate()\nclose_service_client(cls.db_client)\nlogger.info(f'{prefix} \u2705 Finished cleanup')", "successors": []}], "functions": [], "classes": []}, {"name": "_init_node_executor_pool", "type": "CFG", "blocks": [{"id": 163, "label": "#163\ncls.executor = Pool(processes=cls.pool_size, initializer=cls.\n    on_node_executor_start)", "successors": []}], "functions": [], "classes": []}, {"name": "on_graph_execution", "type": "CFG", "blocks": [{"id": 166, "label": "#166\nlog_metadata = LogMetadata(user_id=graph_exec.user_id, graph_eid=graph_exec\n    .graph_exec_id, graph_id=graph_exec.graph_id, node_id='*', node_eid='*',\n    block_name='-')\ntiming_info, (exec_stats, error) = cls._on_graph_execution(graph_exec,\n    cancel, log_metadata)\nexec_stats['walltime'] = timing_info.wall_time\nexec_stats['cputime'] = timing_info.cpu_time\nexec_stats['error'] = str(error) if error else None\nresult = cls.db_client.update_graph_execution_stats(graph_exec_id=\n    graph_exec.graph_exec_id, stats=exec_stats)\ncls.db_client.send_execution_update(result)", "successors": []}], "functions": [], "classes": []}, {"name": "_on_graph_execution", "type": "CFG", "blocks": [{"id": 169, "label": "#169\n\"\"\"\n        Returns:\n            The execution statistics of the graph execution.\n            The error that occurred during the execution.\n        \"\"\"\nlog_metadata.info(f'Start graph execution {graph_exec.graph_exec_id}')\nexec_stats = {'nodes_walltime': 0, 'nodes_cputime': 0, 'node_count': 0}\nerror = None\nfinished = False\ncancel_thread = threading.Thread(target=cancel_handler)\ncancel_thread.start()\ntry:", "successors": [{"id": 178, "label": "#178\nqueue = ExecutionQueue[NodeExecutionEntry]()", "successors": [{"id": 181, "label": "#181\nfor node_exec in graph_exec.start_node_execs:", "successors": [{"id": 182, "label": "#182\nqueue.add(node_exec)", "successors": []}, {"id": 183, "label": "#183\nrunning_executions: dict[str, AsyncResult] = {}", "successors": [{"id": 193, "label": "#193\nwhile not queue.empty():", "successors": [{"id": 194, "label": "#194\nif cancel.is_set():", "successors": [{"id": 196, "label": "#196\nerror = RuntimeError('Execution is cancelled')\nreturn exec_stats, error", "successors": []}, {"id": 197, "label": "#197\nexec_data = queue.get()\nexecution = running_executions.get(exec_data.node_id)\nif execution and not execution.ready():", "successors": [{"id": 199, "label": "#199\nexecution.wait()", "successors": [{"id": 200, "label": "#200\nlog_metadata.debug(\n    f'Dispatching node execution {exec_data.node_exec_id} for node {exec_data.node_id}'\n    )\nrunning_executions[exec_data.node_id] = cls.executor.apply_async(cls.\n    on_node_execution, (queue, exec_data), callback=make_exec_callback(\n    exec_data))", "successors": [{"id": 201, "label": "#201\nwhile queue.empty() and running_executions:", "successors": [{"id": 202, "label": "#202\nlog_metadata.debug(\n    f'Queue empty; running nodes: {list(running_executions.keys())}')", "successors": [{"id": 204, "label": "#204\nfor node_id, execution in list(running_executions.items()):", "successors": [{"id": 205, "label": "#205\nif cancel.is_set():", "successors": [{"id": 207, "label": "#207\nerror = RuntimeError('Execution is cancelled')\nreturn exec_stats, error", "successors": []}, {"id": 208, "label": "#208\nif not queue.empty():", "successors": [{"id": 211, "label": "#211\nlog_metadata.debug(f'Waiting on execution of node {node_id}')\nexecution.wait(3)", "successors": []}]}]}]}]}]}]}]}]}]}, {"id": 195, "label": "#195\nlog_metadata.info(f'Finished graph execution {graph_exec.graph_exec_id}')", "successors": []}]}]}]}]}, {"id": 179, "label": "#179\nlog_metadata.exception(\n    f'Failed graph execution {graph_exec.graph_exec_id}: {e}')\nerror = e", "successors": []}]}], "functions": [{"name": "cancel_handler", "type": "CFG", "blocks": [{"id": 171, "label": "#171\nwhile not cancel.is_set():", "successors": [{"id": 172, "label": "#172\ncancel.wait(1)", "successors": []}, {"id": 173, "label": "#173\nif finished:", "successors": [{"id": 174, "label": "#174\nreturn", "successors": []}, {"id": 175, "label": "#175\ncls.executor.terminate()\nlog_metadata.info(f'Terminated graph execution {graph_exec.graph_exec_id}')\ncls._init_node_executor_pool()", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "make_exec_callback", "type": "CFG", "blocks": [{"id": 185, "label": "#185\nnode_id = exec_data.node_id\nreturn callback", "successors": []}], "functions": [{"name": "callback", "type": "CFG", "blocks": [{"id": 187, "label": "#187\nrunning_executions.pop(node_id)\nnonlocal exec_stats\nif isinstance(result, dict):", "successors": [{"id": 188, "label": "#188\nexec_stats['node_count'] += 1\nexec_stats['nodes_cputime'] += result.get('cputime', 0)\nexec_stats['nodes_walltime'] += result.get('walltime', 0)", "successors": []}]}], "functions": [], "classes": []}], "classes": []}], "classes": []}], "classes": []}, {"name": "ExecutionManager", "type": "CFG", "blocks": [{"id": 215, "label": "#215", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 217, "label": "#217\nsuper().__init__()\nself.use_redis = True\nself.use_supabase = True\nself.pool_size = settings.config.num_graph_workers\nself.queue = ExecutionQueue[GraphExecutionEntry]()\nself.active_graph_runs: dict[str, tuple[Future, threading.Event]] = {}", "successors": []}], "functions": [], "classes": []}, {"name": "get_port", "type": "CFG", "blocks": [{"id": 220, "label": "#220\nreturn settings.config.execution_manager_port", "successors": []}], "functions": [], "classes": []}, {"name": "run_service", "type": "CFG", "blocks": [{"id": 224, "label": "#224\nfrom backend.integrations.credentials_store import IntegrationCredentialsStore\nself.credentials_store = IntegrationCredentialsStore()\nself.executor = ProcessPoolExecutor(max_workers=self.pool_size, initializer\n    =Executor.on_graph_executor_start)\nsync_manager = multiprocessing.Manager()\nlogger.info(\n    f'[{self.service_name}] Started with max-{self.pool_size} graph workers')", "successors": [{"id": 225, "label": "#225\nwhile True:", "successors": [{"id": 226, "label": "#226\ngraph_exec_data = self.queue.get()\ngraph_exec_id = graph_exec_data.graph_exec_id\nlogger.debug(f'[ExecutionManager] Dispatching graph execution {graph_exec_id}')\ncancel_event = sync_manager.Event()\nfuture = self.executor.submit(Executor.on_graph_execution, graph_exec_data,\n    cancel_event)\nself.active_graph_runs[graph_exec_id] = future, cancel_event\nfuture.add_done_callback(lambda _: self.active_graph_runs.pop(graph_exec_id,\n    None))", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "cleanup", "type": "CFG", "blocks": [{"id": 230, "label": "#230\nself.executor.shutdown(cancel_futures=True)\nsuper().cleanup()", "successors": []}], "functions": [], "classes": []}, {"name": "db_client", "type": "CFG", "blocks": [{"id": 233, "label": "#233\nreturn get_db_client()", "successors": []}], "functions": [], "classes": []}, {"name": "add_execution", "type": "CFG", "blocks": [{"id": 237, "label": "#237\ngraph: GraphModel | None = self.db_client.get_graph(graph_id=graph_id,\n    user_id=user_id, version=graph_version)\nif not graph:", "successors": [{"id": 238, "label": "#238\nraise ValueError(f'Graph #{graph_id} not found.')", "successors": []}, {"id": 239, "label": "#239\ngraph.validate_graph(for_run=True)\nself._validate_node_input_credentials(graph, user_id)\nnodes_input = []", "successors": [{"id": 241, "label": "#241\nfor node in graph.starting_nodes:", "successors": [{"id": 242, "label": "#242\ninput_data = {}\nblock = get_block(node.block_id)\nif not block or block.block_type == BlockType.NOTE:", "successors": [{"id": 245, "label": "#245\nif block.block_type == BlockType.INPUT:", "successors": [{"id": 246, "label": "#246\nname = node.input_default.get('name')\nif name and name in data:", "successors": [{"id": 248, "label": "#248\ninput_data = {'value': data[name]}", "successors": [{"id": 247, "label": "#247\nwebhook_payload_key = f'webhook_{node.webhook_id}_payload'\nif block.block_type in (BlockType.WEBHOOK, BlockType.WEBHOOK_MANUAL", "successors": [{"id": 250, "label": "#250\nif webhook_payload_key not in data:", "successors": [{"id": 252, "label": "#252\nraise ValueError(f'Node {block.name} #{node.id} webhook payload is missing')", "successors": []}, {"id": 253, "label": "#253\ninput_data = {'payload': data[webhook_payload_key]}", "successors": [{"id": 251, "label": "#251\ninput_data, error = validate_exec(node, input_data)\nif input_data is None:", "successors": [{"id": 255, "label": "#255\nraise ValueError(error)", "successors": []}, {"id": 257, "label": "#257\nnodes_input.append((node.id, input_data))", "successors": []}]}]}]}]}]}]}]}]}, {"id": 243, "label": "#243\ngraph_exec_id, node_execs = self.db_client.create_graph_execution(graph_id=\n    graph_id, graph_version=graph.version, nodes_input=nodes_input, user_id\n    =user_id)\nstarting_node_execs = []", "successors": [{"id": 259, "label": "#259\nfor node_exec in node_execs:", "successors": [{"id": 260, "label": "#260\nstarting_node_execs.append(NodeExecutionEntry(user_id=user_id,\n    graph_exec_id=node_exec.graph_exec_id, graph_id=node_exec.graph_id,\n    node_exec_id=node_exec.node_exec_id, node_id=node_exec.node_id, data=\n    node_exec.input_data))\nexec_update = self.db_client.update_execution_status(node_exec.node_exec_id,\n    ExecutionStatus.QUEUED, node_exec.input_data)\nself.db_client.send_execution_update(exec_update)", "successors": []}, {"id": 261, "label": "#261\ngraph_exec = GraphExecutionEntry(user_id=user_id, graph_id=graph_id,\n    graph_exec_id=graph_exec_id, start_node_execs=starting_node_execs)\nself.queue.add(graph_exec)\nreturn graph_exec", "successors": []}]}]}]}]}]}], "functions": [], "classes": []}, {"name": "cancel_execution", "type": "CFG", "blocks": [{"id": 265, "label": "#265\n\"\"\"\n        Mechanism:\n        1. Set the cancel event\n        2. Graph executor's cancel handler thread detects the event, terminates workers,\n           reinitializes worker pool, and returns.\n        3. Update execution statuses in DB and set `error` outputs to `\"TERMINATED\"`.\n        \"\"\"\nif graph_exec_id not in self.active_graph_runs:", "successors": [{"id": 266, "label": "#266\nraise Exception(\n    f'Graph execution #{graph_exec_id} not active/running: possibly already completed/cancelled.'\n    )", "successors": []}, {"id": 267, "label": "#267\nfuture, cancel_event = self.active_graph_runs[graph_exec_id]\nif cancel_event.is_set():", "successors": [{"id": 269, "label": "#269\nreturn", "successors": []}, {"id": 270, "label": "#270\ncancel_event.set()\nfuture.result()\nnode_execs = self.db_client.get_execution_results(graph_exec_id)", "successors": [{"id": 272, "label": "#272\nfor node_exec in node_execs:", "successors": [{"id": 273, "label": "#273\nif node_exec.status not in (ExecutionStatus.COMPLETED, ExecutionStatus.FAILED):", "successors": [{"id": 275, "label": "#275\nself.db_client.upsert_execution_output(node_exec.node_exec_id, 'error',\n    'TERMINATED')\nexec_update = self.db_client.update_execution_status(node_exec.node_exec_id,\n    ExecutionStatus.FAILED)\nself.db_client.send_execution_update(exec_update)", "successors": []}]}]}]}]}]}], "functions": [], "classes": []}, {"name": "_validate_node_input_credentials", "type": "CFG", "blocks": [{"id": 279, "label": "#279\n\"\"\"Checks all credentials for all nodes of the graph\"\"\"", "successors": [{"id": 280, "label": "#280\nfor node in graph.nodes:", "successors": [{"id": 281, "label": "#281\nblock = get_block(node.block_id)\nif not block:", "successors": [{"id": 283, "label": "#283\nraise ValueError(f'Unknown block {node.block_id} for node #{node.id}')", "successors": []}, {"id": 284, "label": "#284\nmodel_fields = cast(type[BaseModel], block.input_schema).model_fields\nif CREDENTIALS_FIELD_NAME not in model_fields:", "successors": [{"id": 287, "label": "#287\nfield = model_fields[CREDENTIALS_FIELD_NAME]\ncredentials_meta_type = cast(CredentialsMetaInput, field.annotation)\ncredentials_meta = credentials_meta_type.model_validate(node.input_default[\n    CREDENTIALS_FIELD_NAME])\ncredentials = self.credentials_store.get_creds_by_id(user_id,\n    credentials_meta.id)\nif not credentials:", "successors": [{"id": 288, "label": "#288\nraise ValueError(\n    f'Unknown credentials #{credentials_meta.id} for node #{node.id}')", "successors": []}, {"id": 289, "label": "#289\nif credentials.provider != credentials_meta.provider or credentials.type != credentials_meta.type:", "successors": [{"id": 291, "label": "#291\nlogger.warning(\n    f'Invalid credentials #{credentials.id} for node #{node.id}: type/provider mismatch: {credentials_meta.type}<>{credentials.type};{credentials_meta.provider}<>{credentials.provider}'\n    )\nraise ValueError(\n    f'Invalid credentials #{credentials.id} for node #{node.id}: type/provider mismatch'\n    )", "successors": []}]}]}]}]}]}]}], "functions": [], "classes": []}], "classes": []}]}
{"file_name": "5.json", "name": "5.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\n\"\"\"\nThe sum-of-subsetsproblem states that a set of non-negative integers, and a\nvalue M, determine all possible subsets of the given set whose summation sum\nequal to given M.\n\nSummation of the chosen numbers must be equal to given number M and one number\ncan be used only once.\n\"\"\"\nfrom __future__ import annotations\n\"\"\"\nremove the comment to take an input from the user\n\nprint(\"Enter the elements\")\nnums = list(map(int, input().split()))\nprint(\"Enter max_sum sum\")\nmax_sum = int(input())\n\n\"\"\"\nnums = [3, 34, 4, 12, 5, 2]\nmax_sum = 9\nresult = generate_sum_of_subsets_soln(nums, max_sum)\nprint(*result)", "successors": []}], "functions": [{"name": "generate_sum_of_subsets_soln", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nresult: list[list[int]] = []\npath: list[int] = []\nnum_index = 0\nremaining_nums_sum = sum(nums)\ncreate_state_space_tree(nums, max_sum, num_index, path, result,\n    remaining_nums_sum)\nreturn result", "successors": []}], "functions": [], "classes": []}, {"name": "create_state_space_tree", "type": "CFG", "blocks": [{"id": 7, "label": "#7\n\"\"\"\n    Creates a state space tree to iterate through each branch using DFS.\n    It terminates the branching of a node when any of the two conditions\n    given below satisfy.\n    This algorithm follows depth-fist-search and backtracks when the node is not\n    branchable.\n\n    \"\"\"\nif sum(path) > max_sum or remaining_nums_sum + sum(path) < max_sum:", "successors": [{"id": 8, "label": "#8\nreturn", "successors": []}, {"id": 9, "label": "#9\nif sum(path) == max_sum:", "successors": [{"id": 11, "label": "#11\nresult.append(path)\nreturn", "successors": []}, {"id": 12, "label": "#12\nfor index in range(num_index, len(nums)):", "successors": [{"id": 14, "label": "#14\ncreate_state_space_tree(nums, max_sum, index + 1, [*path, nums[index]],\n    result, remaining_nums_sum - nums[index])", "successors": []}]}]}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "6.json", "name": "6.json", "type": "CFG", "blocks": [{"id": 1, "label": "#1\n{'name': 'example_script', 'type': 'CFG', 'start_line': 1, 'end_line': 59,\n    'functions': [], 'classes': [{'name': 'FactCheckerBlock', 'type':\n    'class', 'start_line': 14, 'end_line': 59, 'functions': [{'name':\n    '__init__', 'type': 'function', 'start_line': 29, 'end_line': 36,\n    'functions': [], 'classes': [], 'simplified_code':\n    \"\"\"    def __init__(self):\n        super().__init__(\n            id=\"d38b6c5e-9968-4271-8423-6cfe60d6e7e6\",\n            description=\"This block checks the factuality of a given statement using Jina AI's Grounding API.\",\n            categories={BlockCategory.SEARCH},\n            input_schema=FactCheckerBlock.Input,\n            output_schema=FactCheckerBlock.Output,\n        )\"\"\"\n    , 'blocks': [{'id': 1, 'label': 'def __init__(self):', 'successors': [2\n    ]}, {'id': 2, 'label':\n    \"\"\"super().__init__(\n    id=\"d38b6c5e-9968-4271-8423-6cfe60d6e7e6\",\n    description=\"This block checks the factuality of a given statement using Jina AI's Grounding API.\",\n    categories={BlockCategory.SEARCH},\n    input_schema=FactCheckerBlock.Input,\n    output_schema=FactCheckerBlock.Output,\n)\"\"\"\n    , 'successors': []}]}, {'name': 'run', 'type': 'function', 'start_line':\n    38, 'end_line': 59, 'functions': [], 'classes': [], 'simplified_code':\n    \"\"\"    def run(\n        self, input_data: Input, *, credentials: JinaCredentials, **kwargs\n    ) -> BlockOutput:\n        encoded_statement = quote(input_data.statement)\n        url = f\"https://g.jina.ai/{encoded_statement}\"\n\n        headers = {\n            \"Accept\": \"application/json\",\n            \"Authorization\": f\"Bearer {credentials.api_key.get_secret_value()}\",\n        }\n\n        response = requests.get(url, headers=headers)\n        response.raise_for_status()\n        data = response.json()\n\n        if \"data\" in data:\n            data = data[\"data\"]\n            yield \"factuality\", data[\"factuality\"]\n            yield \"result\", data[\"result\"]\n            yield \"reason\", data[\"reason\"]\n        else:\n            raise RuntimeError(f\"Expected 'data' key not found in response: {data}\")\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"encoded_statement = quote(input_data.statement)\nurl = f\"https://g.jina.ai/{encoded_statement}\\\"\"\"\"\n    , 'successors': [2]}, {'id': 2, 'label':\n    \"\"\"headers = {\n    \"Accept\": \"application/json\",\n    \"Authorization\": f\"Bearer {credentials.api_key.get_secret_value()}\",\n}\"\"\"\n    , 'successors': [3]}, {'id': 3, 'label':\n    \"\"\"response = requests.get(url, headers=headers)\nresponse.raise_for_status()\ndata = response.json()\"\"\"\n    , 'successors': [4]}, {'id': 4, 'label': 'if \"data\" in data:',\n    'successors': [5, 6]}, {'id': 5, 'label':\n    \"\"\"data = data[\"data\"]\nyield \"factuality\", data[\"factuality\"]\nyield \"result\", data[\"result\"]\nyield \"reason\", data[\"reason\"]\"\"\"\n    , 'successors': []}, {'id': 6, 'label':\n    'raise RuntimeError(f\"Expected \\'data\\' key not found in response: {data}\")'\n    , 'successors': []}]}], 'classes': [{'name': 'Input', 'type': 'class',\n    'start_line': 15, 'end_line': 19, 'functions': [], 'classes': [],\n    'simplified_code':\n    \"\"\"    class Input(BlockSchema):\n        statement: str = SchemaField(\n            description=\"The statement to check for factuality\"\n        )\n        credentials: JinaCredentialsInput = JinaCredentialsField()\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"class Input(BlockSchema):\n    statement: str = SchemaField(\n        description=\"The statement to check for factuality\"\n    )\n    credentials: JinaCredentialsInput = JinaCredentialsField()\"\"\"\n    , 'successors': []}]}, {'name': 'Output', 'type': 'class', 'start_line':\n    21, 'end_line': 27, 'functions': [], 'classes': [], 'simplified_code':\n    \"\"\"    class Output(BlockSchema):\n        factuality: float = SchemaField(\n            description=\"The factuality score of the statement\"\n        )\n        result: bool = SchemaField(description=\"The result of the factuality check\")\n        reason: str = SchemaField(description=\"The reason for the factuality result\")\n        error: str = SchemaField(description=\"Error message if the check fails\")\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"class Output(BlockSchema):\n    factuality: float = SchemaField(\n        description=\"The factuality score of the statement\"\n    )\n    result: bool = SchemaField(description=\"The result of the factuality check\")\n    reason: str = SchemaField(description=\"The reason for the factuality result\")\n    error: str = SchemaField(description=\"Error message if the check fails\")\"\"\"\n    , 'successors': []}]}], 'simplified_code':\n    \"\"\"class FactCheckerBlock(Block):\n        credentials: JinaCredentialsInput = JinaCredentialsField()\n\n        error: str = SchemaField(description=\"Error message if the check fails\")\n\n        )\n\n            raise RuntimeError(f\"Expected 'data' key not found in response: {data}\")\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"class FactCheckerBlock(Block):\n    credentials: JinaCredentialsInput = JinaCredentialsField()\n    error: str = SchemaField(description=\"Error message if the check fails\")\"\"\"\n    , 'successors': [2]}, {'id': 2, 'label':\n    \"\"\"if not data.get('data'):\n    raise RuntimeError(f\"Expected 'data' key not found in response: {data}\")\"\"\"\n    , 'successors': []}]}], 'simplified_code':\n    \"\"\"from urllib.parse import quote\n\nimport requests\n\nfrom backend.blocks.jina._auth import (\n    JinaCredentials,\n    JinaCredentialsField,\n    JinaCredentialsInput,\n)\nfrom backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema\nfrom backend.data.model import SchemaField\n\n\n            raise RuntimeError(f\"Expected 'data' key not found in response: {data}\")\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"from urllib.parse import quote\n\nimport requests\n\nfrom backend.blocks.jina._auth import (\n    JinaCredentials,\n    JinaCredentialsField,\n    JinaCredentialsInput,\n)\nfrom backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema\nfrom backend.data.model import SchemaField\"\"\"\n    , 'successors': [2]}, {'id': 2, 'label':\n    'raise RuntimeError(f\"Expected \\'data\\' key not found in response: {data}\")'\n    , 'successors': []}]}", "successors": []}], "functions": [], "classes": []}
{"file_name": "7.json", "name": "7.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime, timezone\nfrom prisma import Json\nfrom prisma.enums import CreditTransactionType\nfrom prisma.errors import UniqueViolationError\nfrom prisma.models import CreditTransaction\nfrom backend.data.block import Block, BlockInput, get_block\nfrom backend.data.block_cost_config import BLOCK_COSTS\nfrom backend.data.cost import BlockCost, BlockCostType\nfrom backend.util.settings import Config\nconfig = Config()", "successors": []}], "functions": [{"name": "get_user_credit_model", "type": "CFG", "blocks": [{"id": 96, "label": "#96\nif config.enable_credit.lower() == 'true':", "successors": [{"id": 97, "label": "#97\nreturn UserCredit(config.num_user_credits_refill)", "successors": []}, {"id": 99, "label": "#99\nreturn DisabledUserCredit(0)", "successors": []}]}], "functions": [], "classes": []}, {"name": "get_block_costs", "type": "CFG", "blocks": [{"id": 104, "label": "#104\nreturn {block().id: costs for block, costs in BLOCK_COSTS.items()}", "successors": []}], "functions": [], "classes": []}], "classes": [{"name": "UserCreditBase", "type": "CFG", "blocks": [{"id": 3, "label": "#3", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 5, "label": "#5\nself.num_user_credits_refill = num_user_credits_refill", "successors": []}], "functions": [], "classes": []}, {"name": "get_or_refill_credit", "type": "CFG", "blocks": [{"id": 8, "label": "#8\n\"\"\"\n        Get the current credit for the user and refill if no transaction has been made in the current cycle.\n\n        Returns:\n            int: The current credit for the user.\n        \"\"\"\npass", "successors": []}], "functions": [], "classes": []}, {"name": "spend_credits", "type": "CFG", "blocks": [{"id": 11, "label": "#11\n\"\"\"\n        Spend the credits for the user based on the block usage.\n\n        Args:\n            user_id (str): The user ID.\n            user_credit (int): The current credit for the user.\n            block_id (str): The block ID.\n            input_data (BlockInput): The input data for the block.\n            data_size (float): The size of the data being processed.\n            run_time (float): The time taken to run the block.\n\n        Returns:\n            int: amount of credit spent\n        \"\"\"\npass", "successors": []}], "functions": [], "classes": []}, {"name": "top_up_credits", "type": "CFG", "blocks": [{"id": 14, "label": "#14\n\"\"\"\n        Top up the credits for the user.\n\n        Args:\n            user_id (str): The user ID.\n            amount (int): The amount to top up.\n        \"\"\"\npass", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "UserCredit", "type": "CFG", "blocks": [{"id": 18, "label": "#18", "successors": []}], "functions": [{"name": "get_or_refill_credit", "type": "CFG", "blocks": [{"id": 20, "label": "#20\ncur_time = self.time_now()\ncur_month = cur_time.replace(day=1, hour=0, minute=0, second=0, microsecond=0)\nnxt_month = cur_month.replace(month=cur_month.month + 1\n    ) if cur_month.month < 12 else cur_month.replace(year=cur_month.year + \n    1, month=1)\nuser_credit = await CreditTransaction.prisma().group_by(by=['userId'], sum=\n    {'amount': True}, where={'userId': user_id, 'createdAt': {'gte':\n    cur_month, 'lt': nxt_month}, 'isActive': True})", "successors": [{"id": 21, "label": "#21\nif user_credit:", "successors": [{"id": 22, "label": "#22\ncredit_sum = user_credit[0].get('_sum') or {}\nreturn credit_sum.get('amount', 0)", "successors": []}, {"id": 23, "label": "#23\nkey = f'MONTHLY-CREDIT-TOP-UP-{cur_month}'\ntry:", "successors": [{"id": 25, "label": "#25\nawait CreditTransaction.prisma().create(data={'amount': self.\n    num_user_credits_refill, 'type': CreditTransactionType.TOP_UP, 'userId':\n    user_id, 'transactionKey': key, 'createdAt': self.time_now()})", "successors": [{"id": 27, "label": "#27\nreturn self.num_user_credits_refill", "successors": []}]}, {"id": 26, "label": "#26\npass", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "time_now", "type": "CFG", "blocks": [{"id": 32, "label": "#32\nreturn datetime.now(timezone.utc)", "successors": []}], "functions": [], "classes": []}, {"name": "_block_usage_cost", "type": "CFG", "blocks": [{"id": 36, "label": "#36\nblock_costs = BLOCK_COSTS.get(type(block))\nif not block_costs:", "successors": [{"id": 37, "label": "#37\nreturn 0, {}", "successors": []}, {"id": 38, "label": "#38\nfor block_cost in block_costs:", "successors": [{"id": 40, "label": "#40\nif not self._is_cost_filter_match(block_cost.cost_filter, input_data):", "successors": [{"id": 43, "label": "#43\nif block_cost.cost_type == BlockCostType.RUN:", "successors": [{"id": 44, "label": "#44\nreturn block_cost.cost_amount, block_cost.cost_filter", "successors": []}, {"id": 45, "label": "#45\nif block_cost.cost_type == BlockCostType.SECOND:", "successors": [{"id": 47, "label": "#47\nreturn int(run_time * block_cost.cost_amount), block_cost.cost_filter", "successors": []}, {"id": 48, "label": "#48\nif block_cost.cost_type == BlockCostType.BYTE:", "successors": [{"id": 50, "label": "#50\nreturn int(data_size * block_cost.cost_amount), block_cost.cost_filter", "successors": []}]}]}]}]}, {"id": 41, "label": "#41\nreturn 0, {}", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "_is_cost_filter_match", "type": "CFG", "blocks": [{"id": 56, "label": "#56\n\"\"\"\n        Filter rules:\n          - If costFilter is an object, then check if costFilter is the subset of inputValues\n          - Otherwise, check if costFilter is equal to inputValues.\n          - Undefined, null, and empty string are considered as equal.\n        \"\"\"\nif not isinstance(cost_filter, dict) or not isinstance(input_data, dict):", "successors": [{"id": 57, "label": "#57\nreturn cost_filter == input_data", "successors": []}, {"id": 58, "label": "#58\nreturn all(not input_data.get(k) and not v or input_data.get(k) and self.\n    _is_cost_filter_match(v, input_data[k]) for k, v in cost_filter.items())", "successors": []}]}], "functions": [], "classes": []}, {"name": "spend_credits", "type": "CFG", "blocks": [{"id": 63, "label": "#63\nblock = get_block(block_id)\nif not block:", "successors": [{"id": 64, "label": "#64\nraise ValueError(f'Block not found: {block_id}')", "successors": []}, {"id": 65, "label": "#65\ncost, matching_filter = self._block_usage_cost(block=block, input_data=\n    input_data, data_size=data_size, run_time=run_time)\nif cost <= 0:", "successors": [{"id": 67, "label": "#67\nreturn 0", "successors": []}, {"id": 68, "label": "#68\nif validate_balance and user_credit < cost:", "successors": [{"id": 70, "label": "#70\nraise ValueError(f'Insufficient credit: {user_credit} < {cost}')", "successors": []}, {"id": 71, "label": "#71\nawait CreditTransaction.prisma().create(data={'userId': user_id, 'amount': \n    -cost, 'type': CreditTransactionType.USAGE, 'blockId': block.id,\n    'metadata': Json({'block': block.name, 'input': matching_filter}),\n    'createdAt': self.time_now()})", "successors": [{"id": 73, "label": "#73\nreturn cost", "successors": []}]}]}]}]}], "functions": [], "classes": []}, {"name": "top_up_credits", "type": "CFG", "blocks": [{"id": 77, "label": "#77\nawait CreditTransaction.prisma().create(data={'userId': user_id, 'amount':\n    amount, 'type': CreditTransactionType.TOP_UP, 'createdAt': self.time_now()}\n    )", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "DisabledUserCredit", "type": "CFG", "blocks": [{"id": 82, "label": "#82", "successors": []}], "functions": [{"name": "get_or_refill_credit", "type": "CFG", "blocks": [{"id": 84, "label": "#84\nreturn 0", "successors": []}], "functions": [], "classes": []}, {"name": "spend_credits", "type": "CFG", "blocks": [{"id": 88, "label": "#88\nreturn 0", "successors": []}], "functions": [], "classes": []}, {"name": "top_up_credits", "type": "CFG", "blocks": [{"id": 92, "label": "#92\npass", "successors": []}], "functions": [], "classes": []}], "classes": []}]}
{"file_name": "8.json", "name": "8.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport logging\nfrom autogpt_libs.utils.cache import thread_cached\nfrom backend.data.block import Block, BlockCategory, BlockInput, BlockOutput, BlockSchema, BlockType, get_block\nfrom backend.data.execution import ExecutionStatus\nfrom backend.data.model import SchemaField\nlogger = logging.getLogger(__name__)", "successors": []}], "functions": [{"name": "get_executor_manager_client", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nfrom backend.executor import ExecutionManager\nfrom backend.util.service import get_service_client\nreturn get_service_client(ExecutionManager)", "successors": []}], "functions": [], "classes": []}, {"name": "get_event_bus", "type": "CFG", "blocks": [{"id": 7, "label": "#7\nfrom backend.data.execution import RedisExecutionEventBus\nreturn RedisExecutionEventBus()", "successors": []}], "functions": [], "classes": []}], "classes": [{"name": "AgentExecutorBlock", "type": "CFG", "blocks": [{"id": 11, "label": "#11", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 19, "label": "#19\nsuper().__init__(id='e189baac-8c20-45a1-94a7-55177ea42565', description=\n    'Executes an existing agent inside your agent', input_schema=\n    AgentExecutorBlock.Input, output_schema=AgentExecutorBlock.Output,\n    block_type=BlockType.AGENT, categories={BlockCategory.AGENT})", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 22, "label": "#22\nexecutor_manager = get_executor_manager_client()\nevent_bus = get_event_bus()\ngraph_exec = executor_manager.add_execution(graph_id=input_data.graph_id,\n    graph_version=input_data.graph_version, user_id=input_data.user_id,\n    data=input_data.data)\nlog_id = (\n    f'Graph #{input_data.graph_id}-V{input_data.graph_version}, exec-id: {graph_exec.graph_exec_id}'\n    )\nlogger.info(f'Starting execution of {log_id}')", "successors": [{"id": 23, "label": "#23\nfor event in event_bus.listen(graph_id=graph_exec.graph_id, graph_exec_id=", "successors": [{"id": 24, "label": "#24\nlogger.info(\n    f'Execution {log_id} produced input {event.input_data} output {event.output_data}'\n    )\nif not event.node_id:", "successors": [{"id": 26, "label": "#26\nif event.status in [ExecutionStatus.COMPLETED, ExecutionStatus.FAILED]:", "successors": [{"id": 28, "label": "#28\nlogger.info(f'Execution {log_id} ended with status {event.status}')", "successors": []}]}, {"id": 27, "label": "#27\nif not event.block_id:", "successors": [{"id": 31, "label": "#31\nlogger.warning(f'{log_id} received event without block_id {event}')", "successors": []}, {"id": 32, "label": "#32\nblock = get_block(event.block_id)\nif not block or block.block_type != BlockType.OUTPUT:", "successors": [{"id": 34, "label": "#34\noutput_name = event.input_data.get('name')\nif not output_name:", "successors": [{"id": 35, "label": "#35\nlogger.warning(f'{log_id} produced an output with no name {event}')", "successors": []}, {"id": 36, "label": "#36\nfor output_data in event.output_data.get('output', []):", "successors": [{"id": 37, "label": "#37\nlogger.info(f'Execution {log_id} produced {output_name}: {output_data}')\nyield output_name, output_data", "successors": []}]}]}]}]}]}]}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 13, "label": "#13\nuser_id: str = SchemaField(description='User ID')\ngraph_id: str = SchemaField(description='Graph ID')\ngraph_version: int = SchemaField(description='Graph Version')\ndata: BlockInput = SchemaField(description='Input data for the graph')\ninput_schema: dict = SchemaField(description='Input schema for the graph')\noutput_schema: dict = SchemaField(description='Output schema for the graph')", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 16, "label": "#16\npass", "successors": []}], "functions": [], "classes": []}]}]}
{"file_name": "9.json", "name": "9.json", "type": "CFG", "blocks": [{"id": 1, "label": "#1\n{'name': 'example_script', 'type': 'CFG', 'start_line': 1, 'end_line': 20,\n    'functions': [{'name': 'thread_cached', 'type': 'function',\n    'start_line': 8, 'end_line': 20, 'functions': [{'name': 'wrapper',\n    'type': 'function', 'start_line': 11, 'end_line': 18, 'functions': [],\n    'classes': [], 'simplified_code':\n    \"\"\"    def wrapper(*args: P.args, **kwargs: P.kwargs) -> R:\n        cache = getattr(thread_local, \"cache\", None)\n        if cache is None:\n            cache = thread_local.cache = {}\n        key = (args, tuple(sorted(kwargs.items())))\n        if key not in cache:\n            cache[key] = func(*args, **kwargs)\n        return cache[key]\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"def wrapper(*args: P.args, **kwargs: P.kwargs) -> R:\n    cache = getattr(thread_local, \"cache\", None)\"\"\"\n    , 'successors': [2, 3]}, {'id': 2, 'label':\n    \"\"\"if cache is None:\n    cache = thread_local.cache = {}\"\"\",\n    'successors': [3]}, {'id': 3, 'label':\n    'key = (args, tuple(sorted(kwargs.items())))', 'successors': [4, 5]}, {\n    'id': 4, 'label':\n    \"\"\"if key not in cache:\n    cache[key] = func(*args, **kwargs)\"\"\",\n    'successors': [5]}, {'id': 5, 'label': 'return cache[key]',\n    'successors': []}]}], 'classes': [], 'simplified_code':\n    \"\"\"def thread_cached(func: Callable[P, R]) -> Callable[P, R]:\n    thread_local = threading.local()\n\n        return cache[key]\n\n    return wrapper\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    'def thread_cached(func: Callable[P, R]) -> Callable[P, R]:',\n    'successors': [2]}, {'id': 2, 'label':\n    'thread_local = threading.local()', 'successors': [3]}, {'id': 3,\n    'label': 'def wrapper(*args: P.args, **kwargs: P.kwargs) -> R:',\n    'successors': [4, 9]}, {'id': 4, 'label':\n    'key = (args, frozenset(kwargs.items()))', 'successors': [5]}, {'id': 5,\n    'label': \"if not hasattr(thread_local, 'cache'):\", 'successors': [6, 7]\n    }, {'id': 6, 'label': 'thread_local.cache = {}', 'successors': [7]}, {\n    'id': 7, 'label': 'cache = thread_local.cache', 'successors': [8]}, {\n    'id': 8, 'label': 'if key not in cache:', 'successors': [9, 10]}, {'id':\n    9, 'label': 'cache[key] = func(*args, **kwargs)', 'successors': [10]},\n    {'id': 10, 'label': 'return cache[key]', 'successors': []}]}],\n    'classes': [], 'simplified_code':\n    \"\"\"import threading\nfrom typing import Callable, ParamSpec, TypeVar\n\nP = ParamSpec(\"P\")\nR = TypeVar(\"R\")\n\n\n    return wrapper\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"import threading\nfrom typing import Callable, ParamSpec, TypeVar\n\nP = ParamSpec(\"P\")\nR = TypeVar(\"R\")\"\"\"\n    , 'successors': [2]}, {'id': 2, 'label':\n    \"\"\"def async_call(func: Callable[P, R]) -> Callable[P, None]:\n    def wrapper(*args: P.args, **kwargs: P.kwargs) -> None:\n        threading.Thread(target=func, args=args, kwargs=kwargs).start()\"\"\"\n    , 'successors': [3]}, {'id': 3, 'label': 'return wrapper', 'successors':\n    []}]}", "successors": []}], "functions": [], "classes": []}
{"file_name": "10.json", "name": "10.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport json\nimport os\nimport requests\nimport sys\nimport time\nfrom typing import Dict, List, Tuple\nCHECK_INTERVAL = 30\nif __name__ == '__main__':", "successors": [{"id": 49, "label": "#49\nmain()", "successors": []}]}], "functions": [{"name": "get_environment_variables", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"Retrieve and return necessary environment variables.\"\"\"\ntry:", "successors": [{"id": 4, "label": "#4\nwith open(os.environ['GITHUB_EVENT_PATH']) as f:", "successors": [{"id": 7, "label": "#7\nevent = json.load(f)", "successors": [{"id": 8, "label": "#8\nif 'pull_request' in event:", "successors": [{"id": 9, "label": "#9\nsha = event['pull_request']['head']['sha']", "successors": [{"id": 10, "label": "#10\nreturn os.environ['GITHUB_API_URL'], os.environ['GITHUB_REPOSITORY'\n    ], sha, os.environ['GITHUB_TOKEN'], os.environ['GITHUB_RUN_ID']", "successors": []}]}, {"id": 11, "label": "#11\nsha = os.environ['GITHUB_SHA']", "successors": []}]}]}]}, {"id": 5, "label": "#5\nprint(f'Error: Missing required environment variable or event data: {e}')\nsys.exit(1)", "successors": []}]}], "functions": [], "classes": []}, {"name": "make_api_request", "type": "CFG", "blocks": [{"id": 15, "label": "#15\n\"\"\"Make an API request and return the JSON response.\"\"\"\ntry:", "successors": [{"id": 16, "label": "#16\nprint('Making API request to:', url)\nresponse = requests.get(url, headers=headers, timeout=10)\nresponse.raise_for_status()\nreturn response.json()", "successors": []}, {"id": 17, "label": "#17\nprint(f'Error: API request failed. {e}')\nsys.exit(1)", "successors": []}]}], "functions": [], "classes": []}, {"name": "process_check_runs", "type": "CFG", "blocks": [{"id": 22, "label": "#22\n\"\"\"Process check runs and return their status.\"\"\"\nruns_in_progress = False\nall_others_passed = True", "successors": [{"id": 23, "label": "#23\nfor run in check_runs:", "successors": [{"id": 24, "label": "#24\nif str(run['name']) != 'Check PR Status':", "successors": [{"id": 26, "label": "#26\nstatus = run['status']\nconclusion = run['conclusion']\nif status == 'completed':", "successors": [{"id": 29, "label": "#29\nif conclusion not in ['success', 'skipped', 'neutral']:", "successors": [{"id": 32, "label": "#32\nall_others_passed = False\nprint(f\"Check run {run['name']} (ID: {run['id']}) has conclusion: {conclusion}\"\n    )", "successors": []}]}, {"id": 31, "label": "#31\nruns_in_progress = True\nprint(f\"Check run {run['name']} (ID: {run['id']}) is still {status}.\")\nall_others_passed = False", "successors": []}]}, {"id": 28, "label": "#28\nprint(\n    f\"Skipping check run {run['name']} (ID: {run['id']}) as it is the current run.\"\n    )", "successors": []}]}, {"id": 25, "label": "#25\nreturn runs_in_progress, all_others_passed", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "main", "type": "CFG", "blocks": [{"id": 37, "label": "#37\napi_url, repo, sha, github_token, current_run_id = get_environment_variables()\nendpoint = f'{api_url}/repos/{repo}/commits/{sha}/check-runs'\nheaders = {'Accept': 'application/vnd.github.v3+json'}\nif github_token:", "successors": [{"id": 38, "label": "#38\nheaders['Authorization'] = f'token {github_token}'", "successors": [{"id": 39, "label": "#39\nprint(f'Current run ID: {current_run_id}')", "successors": [{"id": 40, "label": "#40\nwhile True:", "successors": [{"id": 41, "label": "#41\ndata = make_api_request(endpoint, headers)\ncheck_runs = data['check_runs']\nprint(check_runs)\nruns_in_progress, all_others_passed = process_check_runs(check_runs)\nif not runs_in_progress:", "successors": [{"id": 44, "label": "#44\nprint(\n    )\ntime.sleep(CHECK_INTERVAL)", "successors": []}, {"id": 42, "label": "#42\nif all_others_passed:", "successors": [{"id": 45, "label": "#45\nprint('All other completed check runs have passed. This check passes.')\nsys.exit(0)", "successors": []}, {"id": 47, "label": "#47\nprint('Some check runs have failed or have not completed. This check fails.')\nsys.exit(1)", "successors": []}]}]}]}]}]}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "11.json", "name": "11.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport functools\nimport logging\nimport os\nimport time\nfrom typing import Callable, ParamSpec, Tuple, TypeVar\nfrom pydantic import BaseModel\nP = ParamSpec('P')\nT = TypeVar('T')\nlogger = logging.getLogger(__name__)", "successors": []}], "functions": [{"name": "_start_measurement", "type": "CFG", "blocks": [{"id": 6, "label": "#6\nreturn time.time(), os.times()[0] + os.times()[1]", "successors": []}], "functions": [], "classes": []}, {"name": "_end_measurement", "type": "CFG", "blocks": [{"id": 10, "label": "#10\nend_wall_time = time.time()\nend_cpu_time = os.times()[0] + os.times()[1]\nreturn end_wall_time - start_wall_time, end_cpu_time - start_cpu_time", "successors": []}], "functions": [], "classes": []}, {"name": "time_measured", "type": "CFG", "blocks": [{"id": 14, "label": "#14\n\"\"\"\n    Decorator to measure the time taken by a function to execute.\n    \"\"\"\nreturn wrapper", "successors": []}], "functions": [{"name": "wrapper", "type": "CFG", "blocks": [{"id": 16, "label": "#16\nstart_wall_time, start_cpu_time = _start_measurement()\ntry:", "successors": [{"id": 17, "label": "#17\nresult = func(*args, **kwargs)", "successors": [{"id": 18, "label": "#18\nreturn timing_info, result", "successors": []}]}]}], "functions": [], "classes": []}], "classes": []}, {"name": "error_logged", "type": "CFG", "blocks": [{"id": 24, "label": "#24\n\"\"\"\n    Decorator to suppress and log any exceptions raised by a function.\n    \"\"\"\nreturn wrapper", "successors": []}], "functions": [{"name": "wrapper", "type": "CFG", "blocks": [{"id": 26, "label": "#26\ntry:", "successors": [{"id": 27, "label": "#27\nreturn func(*args, **kwargs)", "successors": []}, {"id": 28, "label": "#28\nlogger.exception(\n    f'Error when calling function {func.__name__} with arguments {args} {kwargs}: {e}'\n    )", "successors": []}]}], "functions": [], "classes": []}], "classes": []}], "classes": [{"name": "TimingInfo", "type": "CFG", "blocks": [{"id": 3, "label": "#3\ncpu_time: float\nwall_time: float", "successors": []}], "functions": [], "classes": []}]}
{"file_name": "12.json", "name": "12.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport base64\nfrom typing_extensions import TypedDict\nfrom backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema\nfrom backend.data.model import SchemaField\nfrom ._api import get_api\nfrom ._auth import TEST_CREDENTIALS, TEST_CREDENTIALS_INPUT, GithubCredentials, GithubCredentialsField, GithubCredentialsInput", "successors": []}], "functions": [], "classes": [{"name": "GithubListTagsBlock", "type": "CFG", "blocks": [{"id": 3, "label": "#3", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 14, "label": "#14\nsuper().__init__(id='358924e7-9a11-4d1a-a0f2-13c67fe59e2e', description=\n    'This block lists all tags for a specified GitHub repository.',\n    categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=\n    GithubListTagsBlock.Input, output_schema=GithubListTagsBlock.Output,\n    test_input={'repo_url': 'https://github.com/owner/repo', 'credentials':\n    TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output\n    =[('tag', {'name': 'v1.0.0', 'url':\n    'https://github.com/owner/repo/tree/v1.0.0'})], test_mock={'list_tags':\n    lambda *args, **kwargs: [{'name': 'v1.0.0', 'url':\n    'https://github.com/owner/repo/tree/v1.0.0'}]})", "successors": []}], "functions": [], "classes": []}, {"name": "list_tags", "type": "CFG", "blocks": [{"id": 17, "label": "#17\napi = get_api(credentials)\ntags_url = repo_url + '/tags'\nresponse = api.get(tags_url)\ndata = response.json()\nrepo_path = repo_url.replace('https://github.com/', '')\ntags: list[GithubListTagsBlock.Output.TagItem] = [{'name': tag['name'],\n    'url': f\"https://github.com/{repo_path}/tree/{tag['name']}\"} for tag in\n    data]\nreturn tags", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 21, "label": "#21\ntags = self.list_tags(credentials, input_data.repo_url)\nyield from (('tag', tag) for tag in tags)", "successors": []}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 5, "label": "#5\ncredentials: GithubCredentialsInput = GithubCredentialsField('repo')\nrepo_url: str = SchemaField(description='URL of the GitHub repository',\n    placeholder='https://github.com/owner/repo')", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 8, "label": "#8\ntag: TagItem = SchemaField(title='Tag', description=\n    'Tags with their name and file tree browser URL')\nerror: str = SchemaField(description='Error message if listing tags failed')", "successors": []}], "functions": [], "classes": [{"name": "TagItem", "type": "CFG", "blocks": [{"id": 10, "label": "#10\nname: str\nurl: str", "successors": []}], "functions": [], "classes": []}]}]}, {"name": "GithubListBranchesBlock", "type": "CFG", "blocks": [{"id": 25, "label": "#25", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 36, "label": "#36\nsuper().__init__(id='74243e49-2bec-4916-8bf4-db43d44aead5', description=\n    'This block lists all branches for a specified GitHub repository.',\n    categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=\n    GithubListBranchesBlock.Input, output_schema=GithubListBranchesBlock.\n    Output, test_input={'repo_url': 'https://github.com/owner/repo',\n    'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=\n    TEST_CREDENTIALS, test_output=[('branch', {'name': 'main', 'url':\n    'https://github.com/owner/repo/tree/main'})], test_mock={\n    'list_branches': lambda *args, **kwargs: [{'name': 'main', 'url':\n    'https://github.com/owner/repo/tree/main'}]})", "successors": []}], "functions": [], "classes": []}, {"name": "list_branches", "type": "CFG", "blocks": [{"id": 39, "label": "#39\napi = get_api(credentials)\nbranches_url = repo_url + '/branches'\nresponse = api.get(branches_url)\ndata = response.json()\nrepo_path = repo_url.replace('https://github.com/', '')\nbranches: list[GithubListBranchesBlock.Output.BranchItem] = [{'name':\n    branch['name'], 'url':\n    f\"https://github.com/{repo_path}/tree/{branch['name']}\"} for branch in data\n    ]\nreturn branches", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 43, "label": "#43\nbranches = self.list_branches(credentials, input_data.repo_url)\nyield from (('branch', branch) for branch in branches)", "successors": []}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 27, "label": "#27\ncredentials: GithubCredentialsInput = GithubCredentialsField('repo')\nrepo_url: str = SchemaField(description='URL of the GitHub repository',\n    placeholder='https://github.com/owner/repo')", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 30, "label": "#30\nbranch: BranchItem = SchemaField(title='Branch', description=\n    'Branches with their name and file tree browser URL')\nerror: str = SchemaField(description='Error message if listing branches failed'\n    )", "successors": []}], "functions": [], "classes": [{"name": "BranchItem", "type": "CFG", "blocks": [{"id": 32, "label": "#32\nname: str\nurl: str", "successors": []}], "functions": [], "classes": []}]}]}, {"name": "GithubListDiscussionsBlock", "type": "CFG", "blocks": [{"id": 47, "label": "#47", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 58, "label": "#58\nsuper().__init__(id='3ef1a419-3d76-4e07-b761-de9dad4d51d7', description=\n    'This block lists recent discussions for a specified GitHub repository.',\n    categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=\n    GithubListDiscussionsBlock.Input, output_schema=\n    GithubListDiscussionsBlock.Output, test_input={'repo_url':\n    'https://github.com/owner/repo', 'num_discussions': 3, 'credentials':\n    TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output\n    =[('discussion', {'title': 'Discussion 1', 'url':\n    'https://github.com/owner/repo/discussions/1'})], test_mock={\n    'list_discussions': lambda *args, **kwargs: [{'title': 'Discussion 1',\n    'url': 'https://github.com/owner/repo/discussions/1'}]})", "successors": []}], "functions": [], "classes": []}, {"name": "list_discussions", "type": "CFG", "blocks": [{"id": 61, "label": "#61\napi = get_api(credentials)\nrepo_path = repo_url.replace('https://github.com/', '')\nowner, repo = repo_path.split('/')\nquery = \"\"\"\n        query($owner: String!, $repo: String!, $num: Int!) {\n            repository(owner: $owner, name: $repo) {\n                discussions(first: $num) {\n                    nodes {\n                        title\n                        url\n                    }\n                }\n            }\n        }\n        \"\"\"\nvariables = {'owner': owner, 'repo': repo, 'num': num_discussions}\nresponse = api.post('https://api.github.com/graphql', json={'query': query,\n    'variables': variables})\ndata = response.json()\ndiscussions: list[GithubListDiscussionsBlock.Output.DiscussionItem] = [{\n    'title': discussion['title'], 'url': discussion['url']} for discussion in\n    data['data']['repository']['discussions']['nodes']]\nreturn discussions", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 65, "label": "#65\ndiscussions = self.list_discussions(credentials, input_data.repo_url,\n    input_data.num_discussions)\nyield from (('discussion', discussion) for discussion in discussions)", "successors": []}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 49, "label": "#49\ncredentials: GithubCredentialsInput = GithubCredentialsField('repo')\nrepo_url: str = SchemaField(description='URL of the GitHub repository',\n    placeholder='https://github.com/owner/repo')\nnum_discussions: int = SchemaField(description=\n    'Number of discussions to fetch', default=5)", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 52, "label": "#52\ndiscussion: DiscussionItem = SchemaField(title='Discussion', description=\n    'Discussions with their title and URL')\nerror: str = SchemaField(description=\n    'Error message if listing discussions failed')", "successors": []}], "functions": [], "classes": [{"name": "DiscussionItem", "type": "CFG", "blocks": [{"id": 54, "label": "#54\ntitle: str\nurl: str", "successors": []}], "functions": [], "classes": []}]}]}, {"name": "GithubListReleasesBlock", "type": "CFG", "blocks": [{"id": 69, "label": "#69", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 80, "label": "#80\nsuper().__init__(id='3460367a-6ba7-4645-8ce6-47b05d040b92', description=\n    'This block lists all releases for a specified GitHub repository.',\n    categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=\n    GithubListReleasesBlock.Input, output_schema=GithubListReleasesBlock.\n    Output, test_input={'repo_url': 'https://github.com/owner/repo',\n    'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=\n    TEST_CREDENTIALS, test_output=[('release', {'name': 'v1.0.0', 'url':\n    'https://github.com/owner/repo/releases/tag/v1.0.0'})], test_mock={\n    'list_releases': lambda *args, **kwargs: [{'name': 'v1.0.0', 'url':\n    'https://github.com/owner/repo/releases/tag/v1.0.0'}]})", "successors": []}], "functions": [], "classes": []}, {"name": "list_releases", "type": "CFG", "blocks": [{"id": 83, "label": "#83\napi = get_api(credentials)\nreleases_url = repo_url + '/releases'\nresponse = api.get(releases_url)\ndata = response.json()\nreleases: list[GithubListReleasesBlock.Output.ReleaseItem] = [{'name':\n    release['name'], 'url': release['html_url']} for release in data]\nreturn releases", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 87, "label": "#87\nreleases = self.list_releases(credentials, input_data.repo_url)\nyield from (('release', release) for release in releases)", "successors": []}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 71, "label": "#71\ncredentials: GithubCredentialsInput = GithubCredentialsField('repo')\nrepo_url: str = SchemaField(description='URL of the GitHub repository',\n    placeholder='https://github.com/owner/repo')", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 74, "label": "#74\nrelease: ReleaseItem = SchemaField(title='Release', description=\n    'Releases with their name and file tree browser URL')\nerror: str = SchemaField(description='Error message if listing releases failed'\n    )", "successors": []}], "functions": [], "classes": [{"name": "ReleaseItem", "type": "CFG", "blocks": [{"id": 76, "label": "#76\nname: str\nurl: str", "successors": []}], "functions": [], "classes": []}]}]}, {"name": "GithubReadFileBlock", "type": "CFG", "blocks": [{"id": 91, "label": "#91", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 99, "label": "#99\nsuper().__init__(id='87ce6c27-5752-4bbc-8e26-6da40a3dcfd3', description=\n    'This block reads the content of a specified file from a GitHub repository.'\n    , categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=\n    GithubReadFileBlock.Input, output_schema=GithubReadFileBlock.Output,\n    test_input={'repo_url': 'https://github.com/owner/repo', 'file_path':\n    'path/to/file', 'branch': 'master', 'credentials':\n    TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output\n    =[('raw_content', 'RmlsZSBjb250ZW50'), ('text_content', 'File content'),\n    ('size', 13)], test_mock={'read_file': lambda *args, **kwargs: (\n    'RmlsZSBjb250ZW50', 13)})", "successors": []}], "functions": [], "classes": []}, {"name": "read_file", "type": "CFG", "blocks": [{"id": 102, "label": "#102\napi = get_api(credentials)\ncontent_url = repo_url + f'/contents/{file_path}?ref={branch}'\nresponse = api.get(content_url)\ncontent = response.json()\nif isinstance(content, list):", "successors": [{"id": 103, "label": "#103\nif not (file := next((f for f in content if f['type'] == 'file'), None)):", "successors": [{"id": 105, "label": "#105\nraise TypeError('Not a file')", "successors": []}, {"id": 106, "label": "#106\ncontent = file", "successors": [{"id": 104, "label": "#104\nif content['type'] != 'file':", "successors": [{"id": 108, "label": "#108\nraise TypeError('Not a file')", "successors": []}, {"id": 109, "label": "#109\nreturn content['content'], content['size']", "successors": []}]}]}]}]}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 114, "label": "#114\nraw_content, size = self.read_file(credentials, input_data.repo_url,\n    input_data.file_path.lstrip('/'), input_data.branch)\nyield 'raw_content', raw_content", "successors": [{"id": 115, "label": "#115\nyield 'text_content', base64.b64decode(raw_content).decode('utf-8')", "successors": [{"id": 116, "label": "#116\nyield 'size', size", "successors": []}]}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 93, "label": "#93\ncredentials: GithubCredentialsInput = GithubCredentialsField('repo')\nrepo_url: str = SchemaField(description='URL of the GitHub repository',\n    placeholder='https://github.com/owner/repo')\nfile_path: str = SchemaField(description=\n    'Path to the file in the repository', placeholder='path/to/file')\nbranch: str = SchemaField(description='Branch to read from', placeholder=\n    'branch_name', default='master')", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 96, "label": "#96\ntext_content: str = SchemaField(description=\n    'Content of the file (decoded as UTF-8 text)')\nraw_content: str = SchemaField(description=\n    'Raw base64-encoded content of the file')\nsize: int = SchemaField(description='The size of the file (in bytes)')\nerror: str = SchemaField(description='Error message if the file reading failed'\n    )", "successors": []}], "functions": [], "classes": []}]}, {"name": "GithubReadFolderBlock", "type": "CFG", "blocks": [{"id": 121, "label": "#121", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 135, "label": "#135\nsuper().__init__(id='1355f863-2db3-4d75-9fba-f91e8a8ca400', description=\n    'This block reads the content of a specified folder from a GitHub repository.'\n    , categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=\n    GithubReadFolderBlock.Input, output_schema=GithubReadFolderBlock.Output,\n    test_input={'repo_url': 'https://github.com/owner/repo', 'folder_path':\n    'path/to/folder', 'branch': 'master', 'credentials':\n    TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output\n    =[('file', {'name': 'file1.txt', 'path': 'path/to/folder/file1.txt',\n    'size': 1337}), ('dir', {'name': 'dir2', 'path': 'path/to/folder/dir2'}\n    )], test_mock={'read_folder': lambda *args, **kwargs: ([{'name':\n    'file1.txt', 'path': 'path/to/folder/file1.txt', 'size': 1337}], [{\n    'name': 'dir2', 'path': 'path/to/folder/dir2'}])})", "successors": []}], "functions": [], "classes": []}, {"name": "read_folder", "type": "CFG", "blocks": [{"id": 138, "label": "#138\napi = get_api(credentials)\ncontents_url = repo_url + f'/contents/{folder_path}?ref={branch}'\nresponse = api.get(contents_url)\ncontent = response.json()\nif not isinstance(content, list):", "successors": [{"id": 139, "label": "#139\nraise TypeError('Not a folder')", "successors": []}, {"id": 140, "label": "#140\nfiles = [GithubReadFolderBlock.Output.FileEntry(name=entry['name'], path=\n    entry['path'], size=entry['size']) for entry in content if entry['type'\n    ] == 'file']\ndirs = [GithubReadFolderBlock.Output.DirEntry(name=entry['name'], path=\n    entry['path']) for entry in content if entry['type'] == 'dir']\nreturn files, dirs", "successors": []}]}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 145, "label": "#145\nfiles, dirs = self.read_folder(credentials, input_data.repo_url, input_data\n    .folder_path.lstrip('/'), input_data.branch)\nyield from (('file', file) for file in files)\nyield from (('dir', dir) for dir in dirs)", "successors": []}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 123, "label": "#123\ncredentials: GithubCredentialsInput = GithubCredentialsField('repo')\nrepo_url: str = SchemaField(description='URL of the GitHub repository',\n    placeholder='https://github.com/owner/repo')\nfolder_path: str = SchemaField(description=\n    'Path to the folder in the repository', placeholder='path/to/folder')\nbranch: str = SchemaField(description=\n    'Branch name to read from (defaults to master)', placeholder=\n    'branch_name', default='master')", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 126, "label": "#126\nfile: FileEntry = SchemaField(description='Files in the folder')\ndir: DirEntry = SchemaField(description='Directories in the folder')\nerror: str = SchemaField(description=\n    'Error message if reading the folder failed')", "successors": []}], "functions": [], "classes": [{"name": "DirEntry", "type": "CFG", "blocks": [{"id": 128, "label": "#128\nname: str\npath: str", "successors": []}], "functions": [], "classes": []}, {"name": "FileEntry", "type": "CFG", "blocks": [{"id": 131, "label": "#131\nname: str\npath: str\nsize: int", "successors": []}], "functions": [], "classes": []}]}]}, {"name": "GithubMakeBranchBlock", "type": "CFG", "blocks": [{"id": 149, "label": "#149", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 157, "label": "#157\nsuper().__init__(id='944cc076-95e7-4d1b-b6b6-b15d8ee5448d', description=\n    'This block creates a new branch from a specified source branch.',\n    categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=\n    GithubMakeBranchBlock.Input, output_schema=GithubMakeBranchBlock.Output,\n    test_input={'repo_url': 'https://github.com/owner/repo', 'new_branch':\n    'new_branch_name', 'source_branch': 'source_branch_name', 'credentials':\n    TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output\n    =[('status', 'Branch created successfully')], test_mock={\n    'create_branch': lambda *args, **kwargs: 'Branch created successfully'})", "successors": []}], "functions": [], "classes": []}, {"name": "create_branch", "type": "CFG", "blocks": [{"id": 160, "label": "#160\napi = get_api(credentials)\nref_url = repo_url + f'/git/refs/heads/{source_branch}'\nresponse = api.get(ref_url)\nsha = response.json()['object']['sha']\ncreate_ref_url = repo_url + '/git/refs'\ndata = {'ref': f'refs/heads/{new_branch}', 'sha': sha}\nresponse = api.post(create_ref_url, json=data)\nreturn 'Branch created successfully'", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 164, "label": "#164\nstatus = self.create_branch(credentials, input_data.repo_url, input_data.\n    new_branch, input_data.source_branch)\nyield 'status', status", "successors": []}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 151, "label": "#151\ncredentials: GithubCredentialsInput = GithubCredentialsField('repo')\nrepo_url: str = SchemaField(description='URL of the GitHub repository',\n    placeholder='https://github.com/owner/repo')\nnew_branch: str = SchemaField(description='Name of the new branch',\n    placeholder='new_branch_name')\nsource_branch: str = SchemaField(description='Name of the source branch',\n    placeholder='source_branch_name')", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 154, "label": "#154\nstatus: str = SchemaField(description='Status of the branch creation operation'\n    )\nerror: str = SchemaField(description=\n    'Error message if the branch creation failed')", "successors": []}], "functions": [], "classes": []}]}, {"name": "GithubDeleteBranchBlock", "type": "CFG", "blocks": [{"id": 169, "label": "#169", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 177, "label": "#177\nsuper().__init__(id='0d4130f7-e0ab-4d55-adc3-0a40225e80f4', description=\n    'This block deletes a specified branch.', categories={BlockCategory.\n    DEVELOPER_TOOLS}, input_schema=GithubDeleteBranchBlock.Input,\n    output_schema=GithubDeleteBranchBlock.Output, test_input={'repo_url':\n    'https://github.com/owner/repo', 'branch': 'branch_name', 'credentials':\n    TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output\n    =[('status', 'Branch deleted successfully')], test_mock={\n    'delete_branch': lambda *args, **kwargs: 'Branch deleted successfully'})", "successors": []}], "functions": [], "classes": []}, {"name": "delete_branch", "type": "CFG", "blocks": [{"id": 180, "label": "#180\napi = get_api(credentials)\nref_url = repo_url + f'/git/refs/heads/{branch}'\napi.delete(ref_url)\nreturn 'Branch deleted successfully'", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 184, "label": "#184\nstatus = self.delete_branch(credentials, input_data.repo_url, input_data.branch\n    )\nyield 'status', status", "successors": []}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 171, "label": "#171\ncredentials: GithubCredentialsInput = GithubCredentialsField('repo')\nrepo_url: str = SchemaField(description='URL of the GitHub repository',\n    placeholder='https://github.com/owner/repo')\nbranch: str = SchemaField(description='Name of the branch to delete',\n    placeholder='branch_name')", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 174, "label": "#174\nstatus: str = SchemaField(description='Status of the branch deletion operation'\n    )\nerror: str = SchemaField(description=\n    'Error message if the branch deletion failed')", "successors": []}], "functions": [], "classes": []}]}]}
{"file_name": "13.json", "name": "13.json", "type": "CFG", "blocks": [{"id": 1, "label": "#1\n{'name': 'example_script', 'type': 'CFG', 'start_line': 1, 'end_line': 102,\n    'functions': [], 'classes': [{'name': 'UnrealTextToSpeechBlock', 'type':\n    'class', 'start_line': 30, 'end_line': 102, 'functions': [{'name':\n    '__init__', 'type': 'function', 'start_line': 52, 'end_line': 71,\n    'functions': [], 'classes': [], 'simplified_code':\n    \"\"\"    def __init__(self):\n        super().__init__(\n            id=\"4ff1ff6d-cc40-4caa-ae69-011daa20c378\",\n            description=\"Converts text to speech using the Unreal Speech API\",\n            categories={BlockCategory.AI, BlockCategory.TEXT},\n            input_schema=UnrealTextToSpeechBlock.Input,\n            output_schema=UnrealTextToSpeechBlock.Output,\n            test_input={\n                \"text\": \"This is a test of the text to speech API.\",\n                \"voice_id\": \"Scarlett\",\n                \"credentials\": TEST_CREDENTIALS_INPUT,\n            },\n            test_output=[(\"mp3_url\", \"https://example.com/test.mp3\")],\n            test_mock={\n                \"call_unreal_speech_api\": lambda *args, **kwargs: {\n                    \"OutputUri\": \"https://example.com/test.mp3\"\n                }\n            },\n            test_credentials=TEST_CREDENTIALS,\n        )\"\"\"\n    , 'blocks': [{'id': 1, 'label': 'def __init__(self):', 'successors': [2\n    ]}, {'id': 2, 'label':\n    \"\"\"super().__init__(\n    id=\"4ff1ff6d-cc40-4caa-ae69-011daa20c378\",\n    description=\"Converts text to speech using the Unreal Speech API\",\n    categories={BlockCategory.AI, BlockCategory.TEXT},\n    input_schema=UnrealTextToSpeechBlock.Input,\n    output_schema=UnrealTextToSpeechBlock.Output,\n    test_input={\n        \"text\": \"This is a test of the text to speech API.\",\n        \"voice_id\": \"Scarlett\",\n        \"credentials\": TEST_CREDENTIALS_INPUT,\n    },\n    test_output=[(\"mp3_url\", \"https://example.com/test.mp3\")],\n    test_mock={\n        \"call_unreal_speech_api\": lambda *args, **kwargs: {\n            \"OutputUri\": \"https://example.com/test.mp3\"\n        }\n    },\n    test_credentials=TEST_CREDENTIALS,\n)\"\"\"\n    , 'successors': []}]}, {'name': 'call_unreal_speech_api', 'type':\n    'function', 'start_line': 73, 'end_line': 92, 'functions': [],\n    'classes': [], 'simplified_code':\n    \"\"\"    @staticmethod\n    def call_unreal_speech_api(\n        api_key: SecretStr, text: str, voice_id: str\n    ) -> dict[str, Any]:\n        url = \"https://api.v7.unrealspeech.com/speech\"\n        headers = {\n            \"Authorization\": f\"Bearer {api_key.get_secret_value()}\",\n            \"Content-Type\": \"application/json\",\n        }\n        data = {\n            \"Text\": text,\n            \"VoiceId\": voice_id,\n            \"Bitrate\": \"192k\",\n            \"Speed\": \"0\",\n            \"Pitch\": \"1\",\n            \"TimestampType\": \"sentence\",\n        }\n\n        response = requests.post(url, headers=headers, json=data)\n        return response.json()\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"@staticmethod\ndef call_unreal_speech_api(\n    api_key: SecretStr, text: str, voice_id: str\n) -> dict[str, Any]:\"\"\"\n    , 'successors': [2]}, {'id': 2, 'label':\n    \"\"\"url = \"https://api.v7.unrealspeech.com/speech\"\nheaders = {\n    \"Authorization\": f\"Bearer {api_key.get_secret_value()}\",\n    \"Content-Type\": \"application/json\",\n}\ndata = {\n    \"Text\": text,\n    \"VoiceId\": voice_id,\n    \"Bitrate\": \"192k\",\n    \"Speed\": \"0\",\n    \"Pitch\": \"1\",\n    \"TimestampType\": \"sentence\",\n}\"\"\"\n    , 'successors': [3]}, {'id': 3, 'label':\n    \"\"\"response = requests.post(url, headers=headers, json=data)\nreturn response.json()\"\"\"\n    , 'successors': []}]}, {'name': 'run', 'type': 'function', 'start_line':\n    94, 'end_line': 102, 'functions': [], 'classes': [], 'simplified_code':\n    \"\"\"    def run(\n        self, input_data: Input, *, credentials: APIKeyCredentials, **kwargs\n    ) -> BlockOutput:\n        api_response = self.call_unreal_speech_api(\n            credentials.api_key,\n            input_data.text,\n            input_data.voice_id,\n        )\n        yield \"mp3_url\", api_response[\"OutputUri\"]\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"api_response = self.call_unreal_speech_api(\n    credentials.api_key,\n    input_data.text,\n    input_data.voice_id,\n)\"\"\"\n    , 'successors': [2]}, {'id': 2, 'label':\n    'yield \"mp3_url\", api_response[\"OutputUri\"]', 'successors': []}]}],\n    'classes': [{'name': 'Input', 'type': 'class', 'start_line': 31,\n    'end_line': 46, 'functions': [], 'classes': [], 'simplified_code':\n    \"\"\"    class Input(BlockSchema):\n        text: str = SchemaField(\n            description=\"The text to be converted to speech\",\n            placeholder=\"Enter the text you want to convert to speech\",\n        )\n        voice_id: str = SchemaField(\n            description=\"The voice ID to use for text-to-speech conversion\",\n            placeholder=\"Scarlett\",\n            default=\"Scarlett\",\n        )\n        credentials: CredentialsMetaInput[\n            Literal[ProviderName.UNREAL_SPEECH], Literal[\"api_key\"]\n        ] = CredentialsField(\n            description=\"The Unreal Speech integration can be used with \"\n            \"any API key with sufficient permissions for the blocks it is used on.\",\n        )\"\"\"\n    , 'blocks': [{'id': 1, 'label': 'class Input(BlockSchema):',\n    'successors': [2, 5, 6]}, {'id': 2, 'label':\n    'text: str = SchemaField(description=\"The text to be converted to speech\", placeholder=\"Enter the text you want to convert to speech\")'\n    , 'successors': [3]}, {'id': 3, 'label':\n    'voice_id: str = SchemaField(description=\"The voice ID to use for text-to-speech conversion\", placeholder=\"Scarlett\", default=\"Scarlett\")'\n    , 'successors': [4]}, {'id': 4, 'label':\n    'credentials: CredentialsMetaInput[Literal[ProviderName.UNREAL_SPEECH], Literal[\"api_key\"]] = CredentialsField(description=\"The Unreal Speech integration can be used with any API key with sufficient permissions for the blocks it is used on.\")'\n    , 'successors': []}, {'id': 5, 'label':\n    'text: str = SchemaField(description=\"The text to be converted to speech\", placeholder=\"Enter the text you want to convert to speech\")'\n    , 'successors': [3]}, {'id': 6, 'label':\n    'voice_id: str = SchemaField(description=\"The voice ID to use for text-to-speech conversion\", placeholder=\"Scarlett\", default=\"Scarlett\")'\n    , 'successors': [4]}]}, {'name': 'Output', 'type': 'class',\n    'start_line': 48, 'end_line': 50, 'functions': [], 'classes': [],\n    'simplified_code':\n    \"\"\"    class Output(BlockSchema):\n        mp3_url: str = SchemaField(description=\"The URL of the generated MP3 file\")\n        error: str = SchemaField(description=\"Error message if the API call failed\")\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"class Output(BlockSchema):\n    mp3_url: str = SchemaField(description=\"The URL of the generated MP3 file\")\n    error: str = SchemaField(description=\"Error message if the API call failed\")\"\"\"\n    , 'successors': []}]}], 'simplified_code':\n    \"\"\"class UnrealTextToSpeechBlock(Block):\n        )\n\n        error: str = SchemaField(description=\"Error message if the API call failed\")\n\n        )\n\n        return response.json()\n\n        yield \"mp3_url\", api_response[\"OutputUri\"]\"\"\"\n    , 'blocks': [{'id': 1, 'label': 'class UnrealTextToSpeechBlock(Block):',\n    'successors': [2]}, {'id': 2, 'label':\n    'error: str = SchemaField(description=\"Error message if the API call failed\")'\n    , 'successors': [3]}, {'id': 3, 'label': 'return response.json()',\n    'successors': [4]}, {'id': 4, 'label':\n    'yield \"mp3_url\", api_response[\"OutputUri\"]', 'successors': []}]}],\n    'simplified_code':\n    \"\"\"from typing import Any, Literal\n\nfrom pydantic import SecretStr\n\nfrom backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema\nfrom backend.data.model import (\n    APIKeyCredentials,\n    CredentialsField,\n    CredentialsMetaInput,\n    SchemaField,\n)\nfrom backend.integrations.providers import ProviderName\nfrom backend.util.request import requests\n\nTEST_CREDENTIALS = APIKeyCredentials(\n    id=\"01234567-89ab-cdef-0123-456789abcdef\",\n    provider=\"unreal_speech\",\n    api_key=SecretStr(\"mock-unreal-speech-api-key\"),\n    title=\"Mock Unreal Speech API key\",\n    expires_at=None,\n)\nTEST_CREDENTIALS_INPUT = {\n    \"provider\": TEST_CREDENTIALS.provider,\n    \"id\": TEST_CREDENTIALS.id,\n    \"type\": TEST_CREDENTIALS.type,\n    \"title\": TEST_CREDENTIALS.type,\n}\n\n\n        yield \"mp3_url\", api_response[\"OutputUri\"]\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"from typing import Any, Literal\n\nfrom pydantic import SecretStr\n\nfrom backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema\nfrom backend.data.model import (\n    APIKeyCredentials,\n    CredentialsField,\n    CredentialsMetaInput,\n    SchemaField,\n)\nfrom backend.integrations.providers import ProviderName\nfrom backend.util.request import requests\"\"\"\n    , 'successors': [2]}, {'id': 2, 'label':\n    \"\"\"TEST_CREDENTIALS = APIKeyCredentials(\n    id=\"01234567-89ab-cdef-0123-456789abcdef\",\n    provider=\"unreal_speech\",\n    api_key=SecretStr(\"mock-unreal-speech-api-key\"),\n    title=\"Mock Unreal Speech API key\",\n    expires_at=None,\n)\"\"\"\n    , 'successors': [3]}, {'id': 3, 'label':\n    \"\"\"TEST_CREDENTIALS_INPUT = {\n    \"provider\": TEST_CREDENTIALS.provider,\n    \"id\": TEST_CREDENTIALS.id,\n    \"type\": TEST_CREDENTIALS.type,\n    \"title\": TEST_CREDENTIALS.type,\n}\"\"\"\n    , 'successors': [4]}, {'id': 4, 'label':\n    'yield \"mp3_url\", api_response[\"OutputUri\"]', 'successors': []}]}", "successors": []}], "functions": [], "classes": []}
{"file_name": "14.json", "name": "14.json", "type": "CFG", "blocks": [{"id": 1, "label": "#1\n{'name': 'example_script', 'type': 'CFG', 'start_line': 1, 'end_line': 22,\n    'functions': [], 'classes': [{'name': 'TextFormatter', 'type': 'class',\n    'start_line': 7, 'end_line': 22, 'functions': [{'name': '__init__',\n    'type': 'function', 'start_line': 8, 'end_line': 15, 'functions': [],\n    'classes': [], 'simplified_code':\n    \"\"\"    def __init__(self):\n        # Create a sandboxed environment\n        self.env = SandboxedEnvironment(loader=BaseLoader(), autoescape=True)\n\n        # Clear any registered filters, tests, and globals to minimize attack surface\n        self.env.filters.clear()\n        self.env.tests.clear()\n        self.env.globals.clear()\"\"\"\n    , 'blocks': [{'id': 1, 'label': 'def __init__(self):', 'successors': [2\n    ]}, {'id': 2, 'label':\n    'self.env = SandboxedEnvironment(loader=BaseLoader(), autoescape=True)',\n    'successors': [3]}, {'id': 3, 'label': 'self.env.filters.clear()',\n    'successors': [4]}, {'id': 4, 'label': 'self.env.tests.clear()',\n    'successors': [5]}, {'id': 5, 'label': 'self.env.globals.clear()',\n    'successors': []}]}, {'name': 'format_string', 'type': 'function',\n    'start_line': 17, 'end_line': 22, 'functions': [], 'classes': [],\n    'simplified_code':\n    \"\"\"    def format_string(self, template_str: str, values=None, **kwargs) -> str:\n        template_str = re.sub(r\"(?<!{){[ a-zA-Z0-9_]+}\", r\"{\\\\g<0>}\", template_str)\n        template = self.env.from_string(template_str)\n        return template.render(values or {}, **kwargs)\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    'template_str = re.sub(r\"(?<!{){[ a-zA-Z0-9_]+}\", r\"{\\\\g<0>}\", template_str)'\n    , 'successors': [2]}, {'id': 2, 'label':\n    'template = self.env.from_string(template_str)', 'successors': [3]}, {\n    'id': 3, 'label': 'return template.render(values or {}, **kwargs)',\n    'successors': []}]}], 'simplified_code':\n    \"\"\"class TextFormatter:\n        self.env.globals.clear()\n\n        return template.render(values or {}, **kwargs)\"\"\"\n    , 'blocks': [{'id': 1, 'label': 'class TextFormatter:', 'successors': [\n    2]}, {'id': 2, 'label': 'self.env.globals.clear()', 'successors': [3]},\n    {'id': 3, 'label': 'return template.render(values or {}, **kwargs)',\n    'successors': []}]}], 'simplified_code':\n    \"\"\"import re\n\nfrom jinja2 import BaseLoader\nfrom jinja2.sandbox import SandboxedEnvironment\n\n\n        return template.render(values or {}, **kwargs)\"\"\"\n    , 'blocks': [{'id': 1, 'label': 'import re', 'successors': [2]}, {'id':\n    2, 'label': 'from jinja2 import BaseLoader', 'successors': [3]}, {'id':\n    3, 'label': 'from jinja2.sandbox import SandboxedEnvironment',\n    'successors': [4]}, {'id': 4, 'label':\n    'return template.render(values or {}, **kwargs)', 'successors': []}]}", "successors": []}], "functions": [], "classes": []}
{"file_name": "15.json", "name": "15.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom __future__ import annotations", "successors": []}], "functions": [], "classes": [{"name": "IIRFilter", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"\n    N-Order IIR filter\n    Assumes working with float samples normalized on [-1, 1]\n\n    ---\n\n    Implementation details:\n    Based on the 2nd-order function from\n    https://en.wikipedia.org/wiki/Digital_biquad_filter,\n    this generalized N-order function was made.\n\n    Using the following transfer function\n\n    we can rewrite this to\n        .. math:: y[n]={\\\\frac{1}{a_{0}}}\n    \"\"\"", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 5, "label": "#5\nself.order = order\nself.a_coeffs = [1.0] + [0.0] * order\nself.b_coeffs = [1.0] + [0.0] * order\nself.input_history = [0.0] * self.order\nself.output_history = [0.0] * self.order", "successors": []}], "functions": [], "classes": []}, {"name": "set_coefficients", "type": "CFG", "blocks": [{"id": 8, "label": "#8\n\"\"\"\n        Set the coefficients for the IIR filter.\n        These should both be of size `order` + 1.\n        :math:`a_0` may be left out, and it will use 1.0 as default value.\n\n        This method works well with scipy's filter design functions\n\n        >>> # Make a 2nd-order 1000Hz butterworth lowpass filter\n        >>> import scipy.signal\n        >>> b_coeffs, a_coeffs = scipy.signal.butter(2, 1000,\n        >>> filt = IIRFilter(2)\n        >>> filt.set_coefficients(a_coeffs, b_coeffs)\n        \"\"\"\nif len(a_coeffs) < self.order:", "successors": [{"id": 9, "label": "#9\na_coeffs = [1.0, *a_coeffs]", "successors": [{"id": 10, "label": "#10\nif len(a_coeffs) != self.order + 1:", "successors": [{"id": 11, "label": "#11\nmsg = (\n    f'Expected a_coeffs to have {self.order + 1} elements for {self.order}-order filter, got {len(a_coeffs)}'\n    )\nraise ValueError(msg)", "successors": []}, {"id": 12, "label": "#12\nif len(b_coeffs) != self.order + 1:", "successors": [{"id": 14, "label": "#14\nmsg = (\n    f'Expected b_coeffs to have {self.order + 1} elements for {self.order}-order filter, got {len(a_coeffs)}'\n    )\nraise ValueError(msg)", "successors": []}, {"id": 15, "label": "#15\nself.a_coeffs = a_coeffs\nself.b_coeffs = b_coeffs", "successors": []}]}]}]}]}], "functions": [], "classes": []}, {"name": "process", "type": "CFG", "blocks": [{"id": 19, "label": "#19\n\"\"\"\n        Calculate :math:`y[n]`\n\n        >>> filt = IIRFilter(2)\n        >>> filt.process(0)\n        0.0\n        \"\"\"\nresult = 0.0", "successors": [{"id": 20, "label": "#20\nfor i in range(1, self.order + 1):", "successors": [{"id": 21, "label": "#21\nresult += self.b_coeffs[i] * self.input_history[i - 1] - self.a_coeffs[i\n    ] * self.output_history[i - 1]", "successors": []}, {"id": 22, "label": "#22\nresult = (result + self.b_coeffs[0] * sample) / self.a_coeffs[0]\nself.input_history[1:] = self.input_history[:-1]\nself.output_history[1:] = self.output_history[:-1]\nself.input_history[0] = sample\nself.output_history[0] = result\nreturn result", "successors": []}]}]}], "functions": [], "classes": []}], "classes": []}]}
{"file_name": "16.json", "name": "16.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom backend.blocks.hubspot._auth import HubSpotCredentials, HubSpotCredentialsField, HubSpotCredentialsInput\nfrom backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema\nfrom backend.data.model import SchemaField\nfrom backend.util.request import requests", "successors": []}], "functions": [], "classes": [{"name": "HubSpotContactBlock", "type": "CFG", "blocks": [{"id": 3, "label": "#3", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 11, "label": "#11\nsuper().__init__(id='5267326e-c4c1-4016-9f54-4e72ad02f813', description=\n    'Manages HubSpot contacts - create, update, and retrieve contact information'\n    , categories={BlockCategory.CRM}, input_schema=HubSpotContactBlock.\n    Input, output_schema=HubSpotContactBlock.Output)", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 14, "label": "#14\nbase_url = 'https://api.hubapi.com/crm/v3/objects/contacts'\nheaders = {'Authorization':\n    f'Bearer {credentials.api_key.get_secret_value()}', 'Content-Type':\n    'application/json'}\nif input_data.operation == 'create':", "successors": [{"id": 15, "label": "#15\nresponse = requests.post(base_url, headers=headers, json={'properties':\n    input_data.contact_data})\nresult = response.json()\nyield 'contact', result", "successors": [{"id": 32, "label": "#32\nyield 'status', 'created'", "successors": []}]}, {"id": 17, "label": "#17\nif input_data.operation == 'get':", "successors": [{"id": 18, "label": "#18\nsearch_url = f'{base_url}/search'\nsearch_data = {'filterGroups': [{'filters': [{'propertyName': 'email',\n    'operator': 'EQ', 'value': input_data.email}]}]}\nresponse = requests.post(search_url, headers=headers, json=search_data)\nresult = response.json()\nyield 'contact', result.get('results', [{}])[0]", "successors": [{"id": 30, "label": "#30\nyield 'status', 'retrieved'", "successors": []}]}, {"id": 20, "label": "#20\nif input_data.operation == 'update':", "successors": [{"id": 21, "label": "#21\nsearch_response = requests.post(f'{base_url}/search', headers=headers, json\n    ={'filterGroups': [{'filters': [{'propertyName': 'email', 'operator':\n    'EQ', 'value': input_data.email}]}]})\ncontact_id = search_response.json().get('results', [{}])[0].get('id')\nif contact_id:", "successors": [{"id": 23, "label": "#23\nresponse = requests.patch(f'{base_url}/{contact_id}', headers=headers, json\n    ={'properties': input_data.contact_data})\nresult = response.json()\nyield 'contact', result", "successors": [{"id": 28, "label": "#28\nyield 'status', 'updated'", "successors": []}]}, {"id": 25, "label": "#25\nyield 'contact', {}", "successors": [{"id": 26, "label": "#26\nyield 'status', 'contact_not_found'", "successors": []}]}]}]}]}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 5, "label": "#5\ncredentials: HubSpotCredentialsInput = HubSpotCredentialsField()\noperation: str = SchemaField(description=\n    'Operation to perform (create, update, get)', default='get')\ncontact_data: dict = SchemaField(description=\n    'Contact data for create/update operations', default={})\nemail: str = SchemaField(description=\n    'Email address for get/update operations', default='')", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 8, "label": "#8\ncontact: dict = SchemaField(description='Contact information')\nstatus: str = SchemaField(description='Operation status')", "successors": []}], "functions": [], "classes": []}]}]}
{"file_name": "17.json", "name": "17.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\n\"\"\"\nAuthor  : Alexander Pantyukhin\nDate    : November 24, 2022\n\nTask:\nGiven an m x n grid of characters board and a string word,\nreturn true if word exists in the grid.\n\nThe word can be constructed from letters of sequentially adjacent cells,\nwhere adjacent cells are horizontally or vertically neighboring.\nThe same letter cell may not be used more than once.\n\nExample:\n\nMatrix:\n---------\n|A|B|C|E|\n|S|F|C|S|\n|A|D|E|E|\n---------\n\nWord:\n\"ABCCED\"\n\nResult:\nTrue\n\nImplementation notes: Use backtracking approach.\nAt each point, check all neighbors to try to find the next letter of the word.\n\nleetcode: https://leetcode.com/problems/word-search/\n\n\"\"\"\nif __name__ == '__main__':", "successors": [{"id": 54, "label": "#54\nimport doctest\ndoctest.testmod()", "successors": []}]}], "functions": [{"name": "get_point_key", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"\n    Returns the hash key of matrix indexes.\n\n    >>> get_point_key(10, 20, 1, 0)\n    200\n    \"\"\"\nreturn len_board * len_board_column * row + column", "successors": []}], "functions": [], "classes": []}, {"name": "exits_word", "type": "CFG", "blocks": [{"id": 7, "label": "#7\n\"\"\"\n    Return True if it's possible to search the word suffix\n    starting from the word_index.\n\n    >>> exits_word([[\"A\"]], \"B\", 0, 0, 0, set())\n    False\n    \"\"\"\nif board[row][column] != word[word_index]:", "successors": [{"id": 8, "label": "#8\nreturn False", "successors": []}, {"id": 9, "label": "#9\nif word_index == len(word) - 1:", "successors": [{"id": 11, "label": "#11\nreturn True", "successors": []}, {"id": 12, "label": "#12\ntraverts_directions = [(0, 1), (0, -1), (-1, 0), (1, 0)]\nlen_board = len(board)\nlen_board_column = len(board[0])", "successors": [{"id": 14, "label": "#14\nfor direction in traverts_directions:", "successors": [{"id": 15, "label": "#15\nnext_i = row + direction[0]\nnext_j = column + direction[1]\nif not (0 <= next_i < len_board and 0 <= next_j < len_board_column):", "successors": [{"id": 18, "label": "#18\nkey = get_point_key(len_board, len_board_column, next_i, next_j)\nif key in visited_points_set:", "successors": [{"id": 20, "label": "#20\nvisited_points_set.add(key)\nif exits_word(board, word, next_i, next_j, word_index + 1, visited_points_set):", "successors": [{"id": 21, "label": "#21\nreturn True", "successors": []}, {"id": 22, "label": "#22\nvisited_points_set.remove(key)", "successors": []}]}]}]}, {"id": 16, "label": "#16\nreturn False", "successors": []}]}]}]}]}], "functions": [], "classes": []}, {"name": "word_exists", "type": "CFG", "blocks": [{"id": 27, "label": "#27\n\"\"\"\n    >>> word_exists([[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], \"ABCCED\")\n    True\n    >>> word_exists([[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], \"SEE\")\n    True\n    >>> word_exists([[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], \"ABCB\")\n    False\n    >>> word_exists([[\"A\"]], \"A\")\n    True\n    >>> word_exists([[\"B\", \"A\", \"A\"], [\"A\", \"A\", \"A\"], [\"A\", \"B\", \"A\"]], \"ABB\")\n    False\n    >>> word_exists([[\"A\"]], 123)\n    Traceback (most recent call last):\n    ValueError: The word parameter should be a string of length greater than 0.\n    >>> word_exists([[\"A\"]], \"\")\n    Traceback (most recent call last):\n    ValueError: The word parameter should be a string of length greater than 0.\n    >>> word_exists([[]], \"AB\")\n    Traceback (most recent call last):\n    ValueError: The board should be a non empty matrix of single chars strings.\n    >>> word_exists([], \"AB\")\n    Traceback (most recent call last):\n    ValueError: The board should be a non empty matrix of single chars strings.\n    >>> word_exists([[\"A\"], [21]], \"AB\")\n    Traceback (most recent call last):\n    ValueError: The board should be a non empty matrix of single chars strings.\n    \"\"\"\nboard_error_message = (\n    'The board should be a non empty matrix of single chars strings.')\nlen_board = len(board)\nif not isinstance(board, list) or len(board) == 0:", "successors": [{"id": 28, "label": "#28\nraise ValueError(board_error_message)", "successors": []}, {"id": 29, "label": "#29\nfor row in board:", "successors": [{"id": 31, "label": "#31\nif not isinstance(row, list) or len(row) == 0:", "successors": [{"id": 33, "label": "#33\nraise ValueError(board_error_message)", "successors": []}, {"id": 34, "label": "#34\nfor item in row:", "successors": [{"id": 36, "label": "#36\nif not isinstance(item, str) or len(item) != 1:", "successors": [{"id": 38, "label": "#38\nraise ValueError(board_error_message)", "successors": []}]}]}]}, {"id": 32, "label": "#32\nif not isinstance(word, str) or len(word) == 0:", "successors": [{"id": 41, "label": "#41\nraise ValueError(\n    'The word parameter should be a string of length greater than 0.')", "successors": []}, {"id": 42, "label": "#42\nlen_board_column = len(board[0])", "successors": [{"id": 44, "label": "#44\nfor i in range(len_board):", "successors": [{"id": 45, "label": "#45\nfor j in range(len_board_column):", "successors": [{"id": 47, "label": "#47\nif exits_word(board, word, i, j, 0, {get_point_key(len_board,", "successors": [{"id": 49, "label": "#49\nreturn True", "successors": []}]}]}, {"id": 46, "label": "#46\nreturn False", "successors": []}]}]}]}]}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "18.json", "name": "18.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\n\"\"\"\nGraph Coloring also called \"m coloring problem\"\nconsists of coloring a given graph with at most m colors\nsuch that no adjacent vertices are assigned the same color\n\nWikipedia: https://en.wikipedia.org/wiki/Graph_coloring\n\"\"\"", "successors": []}], "functions": [{"name": "valid_coloring", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"\n    For each neighbour check if the coloring constraint is satisfied\n    If any of the neighbours fail the constraint return False\n    If all neighbours validate the constraint return True\n\n    >>> neighbours = [0,1,0,1,0]\n    >>> colored_vertices = [0, 2, 1, 2, 0]\n\n    >>> color = 1\n    >>> valid_coloring(neighbours, colored_vertices, color)\n    True\n\n    >>> color = 2\n    >>> valid_coloring(neighbours, colored_vertices, color)\n    False\n    \"\"\"\nreturn not any(neighbour == 1 and colored_vertices[i] == color for i,\n    neighbour in enumerate(neighbours))", "successors": []}], "functions": [], "classes": []}, {"name": "util_color", "type": "CFG", "blocks": [{"id": 7, "label": "#7\n\"\"\"\n    Pseudo-Code\n\n    Base Case:\n    1. Check if coloring is complete\n        1.1 If complete return True (meaning that we successfully colored the graph)\n\n    Recursive Step:\n    2. Iterates over each color:\n        Check if the current coloring is valid:\n            2.1. Color given vertex\n            2.2. Do recursive call, check if this coloring leads to a solution\n            2.4. if current coloring leads to a solution return\n            2.5. Uncolor given vertex\n\n    >>> graph = [[0, 1, 0, 0, 0],\n    >>> max_colors = 3\n    >>> colored_vertices = [0, 1, 0, 0, 0]\n    >>> index = 3\n\n    >>> util_color(graph, max_colors, colored_vertices, index)\n    True\n\n    >>> max_colors = 2\n    >>> util_color(graph, max_colors, colored_vertices, index)\n    False\n    \"\"\"\nif index == len(graph):", "successors": [{"id": 8, "label": "#8\nreturn True", "successors": []}, {"id": 9, "label": "#9\nfor i in range(max_colors):", "successors": [{"id": 11, "label": "#11\nif valid_coloring(graph[index], colored_vertices, i):", "successors": [{"id": 13, "label": "#13\ncolored_vertices[index] = i\nif util_color(graph, max_colors, colored_vertices, index + 1):", "successors": [{"id": 15, "label": "#15\nreturn True", "successors": []}, {"id": 16, "label": "#16\ncolored_vertices[index] = -1", "successors": []}]}]}, {"id": 12, "label": "#12\nreturn False", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "color", "type": "CFG", "blocks": [{"id": 21, "label": "#21\n\"\"\"\n    Wrapper function to call subroutine called util_color\n    which will either return True or False.\n    If True is returned colored_vertices list is filled with correct colorings\n\n    >>> graph = [[0, 1, 0, 0, 0],\n\n    >>> max_colors = 3\n    >>> color(graph, max_colors)\n    [0, 1, 0, 2, 0]\n\n    >>> max_colors = 2\n    >>> color(graph, max_colors)\n    []\n    \"\"\"\ncolored_vertices = [-1] * len(graph)\nif util_color(graph, max_colors, colored_vertices, 0):", "successors": [{"id": 22, "label": "#22\nreturn colored_vertices", "successors": []}, {"id": 23, "label": "#23\nreturn []", "successors": []}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "19.json", "name": "19.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport asyncio\nimport json\nimport logging\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom typing import Any, AsyncGenerator, Generator, Generic, Optional, TypeVar\nfrom pydantic import BaseModel\nfrom redis.asyncio.client import PubSub as AsyncPubSub\nfrom redis.client import PubSub\nfrom backend.data import redis\nlogger = logging.getLogger(__name__)\nM = TypeVar('M', bound=BaseModel)", "successors": []}], "functions": [], "classes": [{"name": "DateTimeEncoder", "type": "CFG", "blocks": [{"id": 3, "label": "#3", "successors": []}], "functions": [{"name": "default", "type": "CFG", "blocks": [{"id": 5, "label": "#5\nif isinstance(o, datetime):", "successors": [{"id": 6, "label": "#6\nreturn o.isoformat()", "successors": []}, {"id": 7, "label": "#7\nreturn super().default(o)", "successors": []}]}], "functions": [], "classes": []}], "classes": []}, {"name": "BaseRedisEventBus", "type": "CFG", "blocks": [{"id": 13, "label": "#13\nModel: type[M]", "successors": []}], "functions": [{"name": "event_bus_name", "type": "CFG", "blocks": [{"id": 15, "label": "#15\npass", "successors": []}], "functions": [], "classes": []}, {"name": "_serialize_message", "type": "CFG", "blocks": [{"id": 18, "label": "#18\nmessage = json.dumps(item.model_dump(), cls=DateTimeEncoder)\nchannel_name = f'{self.event_bus_name}/{channel_key}'\nlogger.info(f'[{channel_name}] Publishing an event to Redis {message}')\nreturn message, channel_name", "successors": []}], "functions": [], "classes": []}, {"name": "_deserialize_message", "type": "CFG", "blocks": [{"id": 22, "label": "#22\nmessage_type = 'pmessage' if '*' in channel_key else 'message'\nif msg['type'] != message_type:", "successors": [{"id": 23, "label": "#23\nreturn None", "successors": []}, {"id": 24, "label": "#24\ntry:", "successors": [{"id": 26, "label": "#26\ndata = json.loads(msg['data'])\nlogger.info(f'Consuming an event from Redis {data}')\nreturn self.Model(**data)", "successors": []}, {"id": 27, "label": "#27\nlogger.error(f'Failed to parse event result from Redis {msg} {e}')", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "_get_pubsub_channel", "type": "CFG", "blocks": [{"id": 32, "label": "#32\nfull_channel_name = f'{self.event_bus_name}/{channel_key}'\npubsub = connection.pubsub()\nreturn pubsub, full_channel_name", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "RedisEventBus", "type": "CFG", "blocks": [{"id": 37, "label": "#37\nModel: type[M]", "successors": []}], "functions": [{"name": "connection", "type": "CFG", "blocks": [{"id": 39, "label": "#39\nreturn redis.get_redis()", "successors": []}], "functions": [], "classes": []}, {"name": "publish_event", "type": "CFG", "blocks": [{"id": 43, "label": "#43\nmessage, full_channel_name = self._serialize_message(event, channel_key)\nself.connection.publish(full_channel_name, message)", "successors": []}], "functions": [], "classes": []}, {"name": "listen_events", "type": "CFG", "blocks": [{"id": 46, "label": "#46\npubsub, full_channel_name = self._get_pubsub_channel(self.connection,\n    channel_key)\nassert isinstance(pubsub, PubSub)", "successors": [{"id": 48, "label": "#48\nif '*' in channel_key:", "successors": [{"id": 49, "label": "#49\npubsub.psubscribe(full_channel_name)", "successors": [{"id": 50, "label": "#50\nfor message in pubsub.listen():", "successors": [{"id": 52, "label": "#52\nif (event := self._deserialize_message(message, channel_key)):", "successors": [{"id": 54, "label": "#54\nyield event", "successors": []}]}]}]}, {"id": 51, "label": "#51\npubsub.subscribe(full_channel_name)", "successors": []}]}]}], "functions": [], "classes": []}], "classes": []}, {"name": "AsyncRedisEventBus", "type": "CFG", "blocks": [{"id": 60, "label": "#60\nModel: type[M]", "successors": []}], "functions": [{"name": "connection", "type": "CFG", "blocks": [{"id": 62, "label": "#62\nreturn await redis.get_redis_async()", "successors": []}], "functions": [], "classes": []}, {"name": "publish_event", "type": "CFG", "blocks": [{"id": 66, "label": "#66\nmessage, full_channel_name = self._serialize_message(event, channel_key)\nconnection = await self.connection", "successors": [{"id": 67, "label": "#67\nawait connection.publish(full_channel_name, message)", "successors": []}]}], "functions": [], "classes": []}, {"name": "listen_events", "type": "CFG", "blocks": [{"id": 71, "label": "#71\npubsub, full_channel_name = self._get_pubsub_channel(await self.connection,\n    channel_key)\nassert isinstance(pubsub, AsyncPubSub)", "successors": [{"id": 73, "label": "#73\nif '*' in channel_key:", "successors": [{"id": 74, "label": "#74\nawait pubsub.psubscribe(full_channel_name)", "successors": [{"id": 75, "label": "#75\nasync for message in pubsub.listen():\n    if (event := self._deserialize_message(message, channel_key)):\n        yield event", "successors": [{"id": 79, "label": "#79\nif (event := self._deserialize_message(message, channel_key)):", "successors": [{"id": 81, "label": "#81\nyield event", "successors": []}]}]}]}, {"id": 76, "label": "#76\nawait pubsub.subscribe(full_channel_name)", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "wait_for_event", "type": "CFG", "blocks": [{"id": 86, "label": "#86\ntry:", "successors": [{"id": 87, "label": "#87\nreturn await asyncio.wait_for(anext(aiter(self.listen_events(channel_key))),\n    timeout)", "successors": []}, {"id": 88, "label": "#88\nreturn None", "successors": []}]}], "functions": [], "classes": []}], "classes": []}]}
{"file_name": "20.json", "name": "20.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\n\"\"\"\nCalculates the sum of two non-negative integers using bitwise operators\nWikipedia explanation: https://en.wikipedia.org/wiki/Binary_number\n\"\"\"\nif __name__ == '__main__':", "successors": [{"id": 15, "label": "#15\nimport doctest\ndoctest.testmod()", "successors": []}]}], "functions": [{"name": "bitwise_addition_recursive", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"\n    >>> bitwise_addition_recursive(4, 5)\n    9\n    >>> bitwise_addition_recursive(8, 9)\n    17\n    >>> bitwise_addition_recursive(0, 4)\n    4\n    >>> bitwise_addition_recursive(4.5, 9)\n    Traceback (most recent call last):\n    TypeError: Both arguments MUST be integers!\n    >>> bitwise_addition_recursive('4', 9)\n    Traceback (most recent call last):\n    TypeError: Both arguments MUST be integers!\n    >>> bitwise_addition_recursive('4.5', 9)\n    Traceback (most recent call last):\n    TypeError: Both arguments MUST be integers!\n    >>> bitwise_addition_recursive(-1, 9)\n    Traceback (most recent call last):\n    ValueError: Both arguments MUST be non-negative!\n    >>> bitwise_addition_recursive(1, -9)\n    Traceback (most recent call last):\n    ValueError: Both arguments MUST be non-negative!\n    \"\"\"\nif not isinstance(number, int) or not isinstance(other_number, int):", "successors": [{"id": 4, "label": "#4\nraise TypeError('Both arguments MUST be integers!')", "successors": []}, {"id": 5, "label": "#5\nif number < 0 or other_number < 0:", "successors": [{"id": 7, "label": "#7\nraise ValueError('Both arguments MUST be non-negative!')", "successors": []}, {"id": 8, "label": "#8\nbitwise_sum = number ^ other_number\ncarry = number & other_number\nif carry == 0:", "successors": [{"id": 10, "label": "#10\nreturn bitwise_sum", "successors": []}, {"id": 11, "label": "#11\nreturn bitwise_addition_recursive(bitwise_sum, carry << 1)", "successors": []}]}]}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "21.json", "name": "21.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport asyncio\nimport logging\nfrom collections import defaultdict\nfrom typing import TYPE_CHECKING, Annotated, Any, Sequence\nimport pydantic\nfrom autogpt_libs.auth.middleware import auth_middleware\nfrom autogpt_libs.feature_flag.client import feature_flag\nfrom autogpt_libs.utils.cache import thread_cached\nfrom fastapi import APIRouter, Depends, HTTPException\nfrom typing_extensions import Optional, TypedDict\nimport backend.data.block\nimport backend.server.integrations.router\nimport backend.server.routers.analytics\nfrom backend.data import execution as execution_db\nfrom backend.data import graph as graph_db\nfrom backend.data.api_key import APIKeyError, APIKeyNotFoundError, APIKeyPermissionError, APIKeyWithoutHash, generate_api_key, get_api_key_by_id, list_user_api_keys, revoke_api_key, suspend_api_key, update_api_key_permissions\nfrom backend.data.block import BlockInput, CompletedBlockOutput\nfrom backend.data.credit import get_block_costs, get_user_credit_model\nfrom backend.data.user import get_or_create_user\nfrom backend.executor import ExecutionManager, ExecutionScheduler, scheduler\nfrom backend.integrations.creds_manager import IntegrationCredentialsManager\nfrom backend.integrations.webhooks.graph_lifecycle_hooks import on_graph_activate, on_graph_deactivate\nfrom backend.server.model import CreateAPIKeyRequest, CreateAPIKeyResponse, CreateGraph, SetGraphActiveVersion, UpdatePermissionsRequest\nfrom backend.server.utils import get_user_id\nfrom backend.util.service import get_service_client\nfrom backend.util.settings import Settings\nif TYPE_CHECKING:", "successors": [{"id": 2, "label": "#2\nfrom backend.data.model import Credentials", "successors": [{"id": 3, "label": "#3\nsettings = Settings()\nlogger = logging.getLogger(__name__)\nintegration_creds_manager = IntegrationCredentialsManager()\n_user_credit_model = get_user_credit_model()\nv1_router = APIRouter()\nv1_router.include_router(backend.server.integrations.router.router, prefix=\n    '/integrations', tags=['integrations'])\nv1_router.include_router(backend.server.routers.analytics.router, prefix=\n    '/analytics', tags=['analytics'], dependencies=[Depends(auth_middleware)])", "successors": []}]}]}], "functions": [{"name": "execution_manager_client", "type": "CFG", "blocks": [{"id": 5, "label": "#5\nreturn get_service_client(ExecutionManager)", "successors": []}], "functions": [], "classes": []}, {"name": "execution_scheduler_client", "type": "CFG", "blocks": [{"id": 9, "label": "#9\nreturn get_service_client(ExecutionScheduler)", "successors": []}], "functions": [], "classes": []}, {"name": "get_or_create_user_route", "type": "CFG", "blocks": [{"id": 13, "label": "#13\nuser = await get_or_create_user(user_data)", "successors": [{"id": 14, "label": "#14\nreturn user.model_dump()", "successors": []}]}], "functions": [], "classes": []}, {"name": "get_graph_blocks", "type": "CFG", "blocks": [{"id": 18, "label": "#18\nblocks = [block() for block in backend.data.block.get_blocks().values()]\ncosts = get_block_costs()\nreturn [{**b.to_dict(), 'costs': costs.get(b.id, [])} for b in blocks]", "successors": []}], "functions": [], "classes": []}, {"name": "execute_graph_block", "type": "CFG", "blocks": [{"id": 22, "label": "#22\nobj = backend.data.block.get_block(block_id)\nif not obj:", "successors": [{"id": 23, "label": "#23\nraise HTTPException(status_code=404, detail=f'Block #{block_id} not found.')", "successors": []}, {"id": 24, "label": "#24\noutput = defaultdict(list)", "successors": [{"id": 26, "label": "#26\nfor name, data in obj.execute(data):", "successors": [{"id": 27, "label": "#27\noutput[name].append(data)", "successors": []}, {"id": 28, "label": "#28\nreturn output", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "get_user_credits", "type": "CFG", "blocks": [{"id": 32, "label": "#32\nreturn {'credits': max(await _user_credit_model.get_or_refill_credit(\n    user_id), 0)}", "successors": []}], "functions": [], "classes": []}, {"name": "get_graphs", "type": "CFG", "blocks": [{"id": 39, "label": "#39\nreturn await graph_db.get_graphs(filter_by='active', user_id=user_id)", "successors": []}], "functions": [], "classes": []}, {"name": "get_graph", "type": "CFG", "blocks": [{"id": 43, "label": "#43\ngraph = await graph_db.get_graph(graph_id, version, user_id=user_id,\n    for_export=hide_credentials)", "successors": [{"id": 44, "label": "#44\nif not graph:", "successors": [{"id": 45, "label": "#45\nraise HTTPException(status_code=404, detail=f'Graph #{graph_id} not found.')", "successors": []}, {"id": 46, "label": "#46\nreturn graph", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "get_graph_all_versions", "type": "CFG", "blocks": [{"id": 51, "label": "#51\ngraphs = await graph_db.get_graph_all_versions(graph_id, user_id=user_id)", "successors": [{"id": 52, "label": "#52\nif not graphs:", "successors": [{"id": 53, "label": "#53\nraise HTTPException(status_code=404, detail=f'Graph #{graph_id} not found.')", "successors": []}, {"id": 54, "label": "#54\nreturn graphs", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "create_new_graph", "type": "CFG", "blocks": [{"id": 59, "label": "#59\nreturn await do_create_graph(create_graph, is_template=False, user_id=user_id)", "successors": []}], "functions": [], "classes": []}, {"name": "do_create_graph", "type": "CFG", "blocks": [{"id": 63, "label": "#63\nif create_graph.graph:", "successors": [{"id": 64, "label": "#64\ngraph = graph_db.make_graph_model(create_graph.graph, user_id)", "successors": [{"id": 65, "label": "#65\ngraph.is_template = is_template\ngraph.is_active = not is_template\ngraph.reassign_ids(user_id=user_id, reassign_graph_id=True)\ngraph = await graph_db.create_graph(graph, user_id=user_id)", "successors": [{"id": 75, "label": "#75\ngraph = await on_graph_activate(graph, get_credentials=lambda id:\n    integration_creds_manager.get(user_id, id))", "successors": [{"id": 76, "label": "#76\nreturn graph", "successors": []}]}]}]}, {"id": 66, "label": "#66\nif create_graph.template_id:", "successors": [{"id": 67, "label": "#67\ngraph = await graph_db.get_graph(create_graph.template_id, create_graph.\n    template_version, template=True, user_id=user_id)", "successors": [{"id": 71, "label": "#71\nif not graph:", "successors": [{"id": 72, "label": "#72\nraise HTTPException(400, detail=\n    f'Template #{create_graph.template_id} not found')", "successors": []}, {"id": 73, "label": "#73\ngraph.version = 1", "successors": []}]}]}, {"id": 69, "label": "#69\nraise HTTPException(status_code=400, detail=\n    'Either graph or template_id must be provided.')", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "delete_graph", "type": "CFG", "blocks": [{"id": 80, "label": "#80\nif (active_version := await graph_db.get_graph(graph_id, user_id=user_id)):", "successors": [{"id": 81, "label": "#81\nawait on_graph_deactivate(active_version, get_credentials)", "successors": [{"id": 82, "label": "#82\nreturn {'version_counts': await graph_db.delete_graph(graph_id, user_id=\n    user_id)}", "successors": []}]}]}], "functions": [{"name": "get_credentials", "type": "CFG", "blocks": [{"id": 84, "label": "#84\nreturn integration_creds_manager.get(user_id, credentials_id)", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "update_graph", "type": "CFG", "blocks": [{"id": 91, "label": "#91\nif graph.id and graph.id != graph_id:", "successors": [{"id": 92, "label": "#92\nraise HTTPException(400, detail='Graph ID does not match ID in URI')", "successors": []}, {"id": 93, "label": "#93\nexisting_versions = await graph_db.get_graph_all_versions(graph_id, user_id\n    =user_id)", "successors": [{"id": 95, "label": "#95\nif not existing_versions:", "successors": [{"id": 96, "label": "#96\nraise HTTPException(404, detail=f'Graph #{graph_id} not found')", "successors": []}, {"id": 97, "label": "#97\nlatest_version_number = max(g.version for g in existing_versions)\ngraph.version = latest_version_number + 1\nlatest_version_graph = next(v for v in existing_versions if v.version ==\n    latest_version_number)\ncurrent_active_version = next((v for v in existing_versions if v.is_active),\n    None)\nif latest_version_graph.is_template != graph.is_template:", "successors": [{"id": 99, "label": "#99\nraise HTTPException(400, detail=\n    'Changing is_template on an existing graph is forbidden')", "successors": []}, {"id": 100, "label": "#100\ngraph.is_active = not graph.is_template\ngraph = graph_db.make_graph_model(graph, user_id)\ngraph.reassign_ids(user_id=user_id)\nnew_graph_version = await graph_db.create_graph(graph, user_id=user_id)", "successors": [{"id": 102, "label": "#102\nif new_graph_version.is_active:", "successors": [{"id": 103, "label": "#103\nnew_graph_version = await on_graph_activate(new_graph_version,\n    get_credentials=get_credentials)", "successors": [{"id": 109, "label": "#109\nawait graph_db.set_graph_active_version(graph_id=graph_id, version=\n    new_graph_version.version, user_id=user_id)", "successors": [{"id": 110, "label": "#110\nif current_active_version:", "successors": [{"id": 111, "label": "#111\nawait on_graph_deactivate(current_active_version, get_credentials=\n    get_credentials)", "successors": [{"id": 104, "label": "#104\nreturn new_graph_version", "successors": []}]}]}]}]}]}]}]}]}]}]}], "functions": [{"name": "get_credentials", "type": "CFG", "blocks": [{"id": 106, "label": "#106\nreturn integration_creds_manager.get(user_id, credentials_id)", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "set_graph_active_version", "type": "CFG", "blocks": [{"id": 117, "label": "#117\nnew_active_version = request_body.active_graph_version\nnew_active_graph = await graph_db.get_graph(graph_id, new_active_version,\n    user_id=user_id)", "successors": [{"id": 118, "label": "#118\nif not new_active_graph:", "successors": [{"id": 119, "label": "#119\nraise HTTPException(404, f'Graph #{graph_id} v{new_active_version} not found')", "successors": []}, {"id": 120, "label": "#120\ncurrent_active_graph = await graph_db.get_graph(graph_id, user_id=user_id)", "successors": [{"id": 122, "label": "#122\nawait on_graph_activate(new_active_graph, get_credentials=get_credentials)", "successors": [{"id": 127, "label": "#127\nawait graph_db.set_graph_active_version(graph_id=graph_id, version=\n    new_active_version, user_id=user_id)", "successors": [{"id": 128, "label": "#128\nif current_active_graph and current_active_graph.version != new_active_version:", "successors": [{"id": 129, "label": "#129\nawait on_graph_deactivate(current_active_graph, get_credentials=get_credentials\n    )", "successors": []}]}]}]}]}]}]}], "functions": [{"name": "get_credentials", "type": "CFG", "blocks": [{"id": 124, "label": "#124\nreturn integration_creds_manager.get(user_id, credentials_id)", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "execute_graph", "type": "CFG", "blocks": [{"id": 134, "label": "#134\ntry:", "successors": [{"id": 135, "label": "#135\ngraph_exec = execution_manager_client().add_execution(graph_id, node_input,\n    user_id=user_id)\nreturn {'id': graph_exec.graph_exec_id}", "successors": []}, {"id": 136, "label": "#136\nmsg = e.__str__().encode().decode('unicode_escape')\nraise HTTPException(status_code=400, detail=msg)", "successors": []}]}], "functions": [], "classes": []}, {"name": "stop_graph_run", "type": "CFG", "blocks": [{"id": 142, "label": "#142\nif not await graph_db.get_execution(user_id=user_id, execution_id=graph_exec_id", "successors": [{"id": 143, "label": "#143\nraise HTTPException(404, detail=f'Agent execution #{graph_exec_id} not found')", "successors": []}, {"id": 144, "label": "#144\nawait asyncio.to_thread(lambda : execution_manager_client().\n    cancel_execution(graph_exec_id))", "successors": [{"id": 146, "label": "#146\nreturn await execution_db.get_execution_results(graph_exec_id)", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "get_executions", "type": "CFG", "blocks": [{"id": 150, "label": "#150\nreturn await graph_db.get_executions(user_id=user_id)", "successors": []}], "functions": [], "classes": []}, {"name": "get_graph_run_node_execution_results", "type": "CFG", "blocks": [{"id": 154, "label": "#154\ngraph = await graph_db.get_graph(graph_id, user_id=user_id)", "successors": [{"id": 155, "label": "#155\nif not graph:", "successors": [{"id": 156, "label": "#156\nraise HTTPException(status_code=404, detail=f'Graph #{graph_id} not found.')", "successors": []}, {"id": 157, "label": "#157\nreturn await execution_db.get_execution_results(graph_exec_id)", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "get_templates", "type": "CFG", "blocks": [{"id": 162, "label": "#162\nreturn await graph_db.get_graphs(filter_by='template', user_id=user_id)", "successors": []}], "functions": [], "classes": []}, {"name": "get_template", "type": "CFG", "blocks": [{"id": 166, "label": "#166\ngraph = await graph_db.get_graph(graph_id, version, template=True)", "successors": [{"id": 167, "label": "#167\nif not graph:", "successors": [{"id": 168, "label": "#168\nraise HTTPException(status_code=404, detail=f'Template #{graph_id} not found.')", "successors": []}, {"id": 169, "label": "#169\nreturn graph", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "create_new_template", "type": "CFG", "blocks": [{"id": 174, "label": "#174\nreturn await do_create_graph(create_graph, is_template=True, user_id=user_id)", "successors": []}], "functions": [], "classes": []}, {"name": "create_schedule", "type": "CFG", "blocks": [{"id": 181, "label": "#181\ngraph = await graph_db.get_graph(schedule.graph_id, user_id=user_id)", "successors": [{"id": 182, "label": "#182\nif not graph:", "successors": [{"id": 183, "label": "#183\nraise HTTPException(status_code=404, detail=\n    f'Graph #{schedule.graph_id} not found.')", "successors": []}, {"id": 184, "label": "#184\nreturn await asyncio.to_thread(lambda : execution_scheduler_client().\n    add_execution_schedule(graph_id=schedule.graph_id, graph_version=graph.\n    version, cron=schedule.cron, input_data=schedule.input_data, user_id=\n    user_id))", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "delete_schedule", "type": "CFG", "blocks": [{"id": 189, "label": "#189\nexecution_scheduler_client().delete_schedule(schedule_id, user_id=user_id)\nreturn {'id': schedule_id}", "successors": []}], "functions": [], "classes": []}, {"name": "get_execution_schedules", "type": "CFG", "blocks": [{"id": 193, "label": "#193\nreturn execution_scheduler_client().get_execution_schedules(user_id=user_id,\n    graph_id=graph_id)", "successors": []}], "functions": [], "classes": []}, {"name": "create_api_key", "type": "CFG", "blocks": [{"id": 197, "label": "#197\n\"\"\"Create a new API key\"\"\"\ntry:", "successors": [{"id": 198, "label": "#198\napi_key, plain_text = await generate_api_key(name=request.name, user_id=\n    user_id, permissions=request.permissions, description=request.description)", "successors": [{"id": 201, "label": "#201\nreturn CreateAPIKeyResponse(api_key=api_key, plain_text_key=plain_text)", "successors": []}]}, {"id": 199, "label": "#199\nlogger.error(f'Failed to create API key: {str(e)}')\nraise HTTPException(status_code=400, detail=str(e))", "successors": []}]}], "functions": [], "classes": []}, {"name": "get_api_keys", "type": "CFG", "blocks": [{"id": 206, "label": "#206\n\"\"\"List all API keys for the user\"\"\"\ntry:", "successors": [{"id": 207, "label": "#207\nreturn await list_user_api_keys(user_id)", "successors": []}, {"id": 208, "label": "#208\nlogger.error(f'Failed to list API keys: {str(e)}')\nraise HTTPException(status_code=400, detail=str(e))", "successors": []}]}], "functions": [], "classes": []}, {"name": "get_api_key", "type": "CFG", "blocks": [{"id": 214, "label": "#214\n\"\"\"Get a specific API key\"\"\"\ntry:", "successors": [{"id": 215, "label": "#215\napi_key = await get_api_key_by_id(key_id, user_id)", "successors": [{"id": 218, "label": "#218\nif not api_key:", "successors": [{"id": 219, "label": "#219\nraise HTTPException(status_code=404, detail='API key not found')", "successors": []}, {"id": 220, "label": "#220\nreturn api_key", "successors": []}]}]}, {"id": 216, "label": "#216\nlogger.error(f'Failed to get API key: {str(e)}')\nraise HTTPException(status_code=400, detail=str(e))", "successors": []}]}], "functions": [], "classes": []}, {"name": "delete_api_key", "type": "CFG", "blocks": [{"id": 226, "label": "#226\n\"\"\"Revoke an API key\"\"\"\ntry:", "successors": [{"id": 227, "label": "#227\nreturn await revoke_api_key(key_id, user_id)", "successors": []}, {"id": 228, "label": "#228\nraise HTTPException(status_code=404, detail='API key not found')", "successors": []}, {"id": 229, "label": "#229\nraise HTTPException(status_code=403, detail='Permission denied')", "successors": []}, {"id": 230, "label": "#230\nlogger.error(f'Failed to revoke API key: {str(e)}')\nraise HTTPException(status_code=400, detail=str(e))", "successors": []}]}], "functions": [], "classes": []}, {"name": "suspend_key", "type": "CFG", "blocks": [{"id": 238, "label": "#238\n\"\"\"Suspend an API key\"\"\"\ntry:", "successors": [{"id": 239, "label": "#239\nreturn await suspend_api_key(key_id, user_id)", "successors": []}, {"id": 240, "label": "#240\nraise HTTPException(status_code=404, detail='API key not found')", "successors": []}, {"id": 241, "label": "#241\nraise HTTPException(status_code=403, detail='Permission denied')", "successors": []}, {"id": 242, "label": "#242\nlogger.error(f'Failed to suspend API key: {str(e)}')\nraise HTTPException(status_code=400, detail=str(e))", "successors": []}]}], "functions": [], "classes": []}, {"name": "update_permissions", "type": "CFG", "blocks": [{"id": 250, "label": "#250\n\"\"\"Update API key permissions\"\"\"\ntry:", "successors": [{"id": 251, "label": "#251\nreturn await update_api_key_permissions(key_id, user_id, request.permissions)", "successors": []}, {"id": 252, "label": "#252\nraise HTTPException(status_code=404, detail='API key not found')", "successors": []}, {"id": 253, "label": "#253\nraise HTTPException(status_code=403, detail='Permission denied')", "successors": []}, {"id": 254, "label": "#254\nlogger.error(f'Failed to update API key permissions: {str(e)}')\nraise HTTPException(status_code=400, detail=str(e))", "successors": []}]}], "functions": [], "classes": []}], "classes": [{"name": "DeleteGraphResponse", "type": "CFG", "blocks": [{"id": 36, "label": "#36\nversion_counts: int", "successors": []}], "functions": [], "classes": []}, {"name": "ScheduleCreationRequest", "type": "CFG", "blocks": [{"id": 178, "label": "#178\ncron: str\ninput_data: dict[Any, Any]\ngraph_id: str", "successors": []}], "functions": [], "classes": []}]}
{"file_name": "22.json", "name": "22.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom urllib.parse import urlparse\nfrom typing_extensions import TypedDict\nfrom backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema\nfrom backend.data.model import SchemaField\nfrom ._api import get_api\nfrom ._auth import TEST_CREDENTIALS, TEST_CREDENTIALS_INPUT, GithubCredentials, GithubCredentialsField, GithubCredentialsInput", "successors": []}], "functions": [{"name": "is_github_url", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nreturn urlparse(url).netloc == 'github.com'", "successors": []}], "functions": [], "classes": []}], "classes": [{"name": "GithubCommentBlock", "type": "CFG", "blocks": [{"id": 7, "label": "#7", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 15, "label": "#15\nsuper().__init__(id='a8db4d8d-db1c-4a25-a1b0-416a8c33602b', description=\n    'This block posts a comment on a specified GitHub issue or pull request.',\n    categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=\n    GithubCommentBlock.Input, output_schema=GithubCommentBlock.Output,\n    test_input=[{'issue_url': 'https://github.com/owner/repo/issues/1',\n    'comment': 'This is a test comment.', 'credentials':\n    TEST_CREDENTIALS_INPUT}, {'issue_url':\n    'https://github.com/owner/repo/pull/1', 'comment':\n    'This is a test comment.', 'credentials': TEST_CREDENTIALS_INPUT}],\n    test_credentials=TEST_CREDENTIALS, test_output=[('id', 1337), ('url',\n    'https://github.com/owner/repo/issues/1#issuecomment-1337'), ('id', \n    1337), ('url',\n    'https://github.com/owner/repo/issues/1#issuecomment-1337')], test_mock\n    ={'post_comment': lambda *args, **kwargs: (1337,\n    'https://github.com/owner/repo/issues/1#issuecomment-1337')})", "successors": []}], "functions": [], "classes": []}, {"name": "post_comment", "type": "CFG", "blocks": [{"id": 18, "label": "#18\napi = get_api(credentials)\ndata = {'body': body_text}\nif 'pull' in issue_url:", "successors": [{"id": 19, "label": "#19\nissue_url = issue_url.replace('pull', 'issues')", "successors": [{"id": 20, "label": "#20\ncomments_url = issue_url + '/comments'\nresponse = api.post(comments_url, json=data)\ncomment = response.json()\nreturn comment['id'], comment['html_url']", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 24, "label": "#24\nid, url = self.post_comment(credentials, input_data.issue_url, input_data.\n    comment)\nyield 'id', id", "successors": [{"id": 25, "label": "#25\nyield 'url', url", "successors": []}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 9, "label": "#9\ncredentials: GithubCredentialsInput = GithubCredentialsField('repo')\nissue_url: str = SchemaField(description=\n    'URL of the GitHub issue or pull request', placeholder=\n    'https://github.com/owner/repo/issues/1')\ncomment: str = SchemaField(description=\n    'Comment to post on the issue or pull request', placeholder=\n    'Enter your comment')", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 12, "label": "#12\nid: int = SchemaField(description='ID of the created comment')\nurl: str = SchemaField(description='URL to the comment on GitHub')\nerror: str = SchemaField(description=\n    'Error message if the comment posting failed')", "successors": []}], "functions": [], "classes": []}]}, {"name": "GithubMakeIssueBlock", "type": "CFG", "blocks": [{"id": 30, "label": "#30", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 38, "label": "#38\nsuper().__init__(id='691dad47-f494-44c3-a1e8-05b7990f2dab', description=\n    'This block creates a new issue on a specified GitHub repository.',\n    categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=\n    GithubMakeIssueBlock.Input, output_schema=GithubMakeIssueBlock.Output,\n    test_input={'repo_url': 'https://github.com/owner/repo', 'title':\n    'Test Issue', 'body': 'This is a test issue.', 'credentials':\n    TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output\n    =[('number', 1), ('url', 'https://github.com/owner/repo/issues/1')],\n    test_mock={'create_issue': lambda *args, **kwargs: (1,\n    'https://github.com/owner/repo/issues/1')})", "successors": []}], "functions": [], "classes": []}, {"name": "create_issue", "type": "CFG", "blocks": [{"id": 41, "label": "#41\napi = get_api(credentials)\ndata = {'title': title, 'body': body}\nissues_url = repo_url + '/issues'\nresponse = api.post(issues_url, json=data)\nissue = response.json()\nreturn issue['number'], issue['html_url']", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 45, "label": "#45\nnumber, url = self.create_issue(credentials, input_data.repo_url,\n    input_data.title, input_data.body)\nyield 'number', number", "successors": [{"id": 46, "label": "#46\nyield 'url', url", "successors": []}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 32, "label": "#32\ncredentials: GithubCredentialsInput = GithubCredentialsField('repo')\nrepo_url: str = SchemaField(description='URL of the GitHub repository',\n    placeholder='https://github.com/owner/repo')\ntitle: str = SchemaField(description='Title of the issue', placeholder=\n    'Enter the issue title')\nbody: str = SchemaField(description='Body of the issue', placeholder=\n    'Enter the issue body')", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 35, "label": "#35\nnumber: int = SchemaField(description='Number of the created issue')\nurl: str = SchemaField(description='URL of the created issue')\nerror: str = SchemaField(description=\n    'Error message if the issue creation failed')", "successors": []}], "functions": [], "classes": []}]}, {"name": "GithubReadIssueBlock", "type": "CFG", "blocks": [{"id": 51, "label": "#51", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 59, "label": "#59\nsuper().__init__(id='6443c75d-032a-4772-9c08-230c707c8acc', description=\n    'This block reads the body, title, and user of a specified GitHub issue.',\n    categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=\n    GithubReadIssueBlock.Input, output_schema=GithubReadIssueBlock.Output,\n    test_input={'issue_url': 'https://github.com/owner/repo/issues/1',\n    'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=\n    TEST_CREDENTIALS, test_output=[('title', 'Title of the issue'), ('body',\n    'This is the body of the issue.'), ('user', 'username')], test_mock={\n    'read_issue': lambda *args, **kwargs: ('Title of the issue',\n    'This is the body of the issue.', 'username')})", "successors": []}], "functions": [], "classes": []}, {"name": "read_issue", "type": "CFG", "blocks": [{"id": 62, "label": "#62\napi = get_api(credentials)\nresponse = api.get(issue_url)\ndata = response.json()\ntitle = data.get('title', 'No title found')\nbody = data.get('body', 'No body content found')\nuser = data.get('user', {}).get('login', 'No user found')\nreturn title, body, user", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 66, "label": "#66\ntitle, body, user = self.read_issue(credentials, input_data.issue_url)\nif title:", "successors": [{"id": 67, "label": "#67\nyield 'title', title", "successors": [{"id": 68, "label": "#68\nif body:", "successors": [{"id": 70, "label": "#70\nyield 'body', body", "successors": [{"id": 71, "label": "#71\nif user:", "successors": [{"id": 73, "label": "#73\nyield 'user', user", "successors": []}]}]}]}]}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 53, "label": "#53\ncredentials: GithubCredentialsInput = GithubCredentialsField('repo')\nissue_url: str = SchemaField(description='URL of the GitHub issue',\n    placeholder='https://github.com/owner/repo/issues/1')", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 56, "label": "#56\ntitle: str = SchemaField(description='Title of the issue')\nbody: str = SchemaField(description='Body of the issue')\nuser: str = SchemaField(description='User who created the issue')\nerror: str = SchemaField(description=\n    'Error message if reading the issue failed')", "successors": []}], "functions": [], "classes": []}]}, {"name": "GithubListIssuesBlock", "type": "CFG", "blocks": [{"id": 79, "label": "#79", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 90, "label": "#90\nsuper().__init__(id='c215bfd7-0e57-4573-8f8c-f7d4963dcd74', description=\n    'This block lists all issues for a specified GitHub repository.',\n    categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=\n    GithubListIssuesBlock.Input, output_schema=GithubListIssuesBlock.Output,\n    test_input={'repo_url': 'https://github.com/owner/repo', 'credentials':\n    TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output\n    =[('issue', {'title': 'Issue 1', 'url':\n    'https://github.com/owner/repo/issues/1'})], test_mock={'list_issues': \n    lambda *args, **kwargs: [{'title': 'Issue 1', 'url':\n    'https://github.com/owner/repo/issues/1'}]})", "successors": []}], "functions": [], "classes": []}, {"name": "list_issues", "type": "CFG", "blocks": [{"id": 93, "label": "#93\napi = get_api(credentials)\nissues_url = repo_url + '/issues'\nresponse = api.get(issues_url)\ndata = response.json()\nissues: list[GithubListIssuesBlock.Output.IssueItem] = [{'title': issue[\n    'title'], 'url': issue['html_url']} for issue in data]\nreturn issues", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 97, "label": "#97\nissues = self.list_issues(credentials, input_data.repo_url)\nyield from (('issue', issue) for issue in issues)", "successors": []}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 81, "label": "#81\ncredentials: GithubCredentialsInput = GithubCredentialsField('repo')\nrepo_url: str = SchemaField(description='URL of the GitHub repository',\n    placeholder='https://github.com/owner/repo')", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 84, "label": "#84\nissue: IssueItem = SchemaField(title='Issue', description=\n    'Issues with their title and URL')\nerror: str = SchemaField(description='Error message if listing issues failed')", "successors": []}], "functions": [], "classes": [{"name": "IssueItem", "type": "CFG", "blocks": [{"id": 86, "label": "#86\ntitle: str\nurl: str", "successors": []}], "functions": [], "classes": []}]}]}, {"name": "GithubAddLabelBlock", "type": "CFG", "blocks": [{"id": 101, "label": "#101", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 109, "label": "#109\nsuper().__init__(id='98bd6b77-9506-43d5-b669-6b9733c4b1f1', description=\n    'This block adds a label to a specified GitHub issue or pull request.',\n    categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=\n    GithubAddLabelBlock.Input, output_schema=GithubAddLabelBlock.Output,\n    test_input={'issue_url': 'https://github.com/owner/repo/issues/1',\n    'label': 'bug', 'credentials': TEST_CREDENTIALS_INPUT},\n    test_credentials=TEST_CREDENTIALS, test_output=[('status',\n    'Label added successfully')], test_mock={'add_label': lambda *args, **\n    kwargs: 'Label added successfully'})", "successors": []}], "functions": [], "classes": []}, {"name": "add_label", "type": "CFG", "blocks": [{"id": 112, "label": "#112\napi = get_api(credentials)\ndata = {'labels': [label]}\nlabels_url = issue_url + '/labels'\napi.post(labels_url, json=data)\nreturn 'Label added successfully'", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 116, "label": "#116\nstatus = self.add_label(credentials, input_data.issue_url, input_data.label)\nyield 'status', status", "successors": []}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 103, "label": "#103\ncredentials: GithubCredentialsInput = GithubCredentialsField('repo')\nissue_url: str = SchemaField(description=\n    'URL of the GitHub issue or pull request', placeholder=\n    'https://github.com/owner/repo/issues/1')\nlabel: str = SchemaField(description=\n    'Label to add to the issue or pull request', placeholder='Enter the label')", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 106, "label": "#106\nstatus: str = SchemaField(description='Status of the label addition operation')\nerror: str = SchemaField(description=\n    'Error message if the label addition failed')", "successors": []}], "functions": [], "classes": []}]}, {"name": "GithubRemoveLabelBlock", "type": "CFG", "blocks": [{"id": 121, "label": "#121", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 129, "label": "#129\nsuper().__init__(id='78f050c5-3e3a-48c0-9e5b-ef1ceca5589c', description=\n    'This block removes a label from a specified GitHub issue or pull request.'\n    , categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=\n    GithubRemoveLabelBlock.Input, output_schema=GithubRemoveLabelBlock.\n    Output, test_input={'issue_url':\n    'https://github.com/owner/repo/issues/1', 'label': 'bug', 'credentials':\n    TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output\n    =[('status', 'Label removed successfully')], test_mock={'remove_label':\n    lambda *args, **kwargs: 'Label removed successfully'})", "successors": []}], "functions": [], "classes": []}, {"name": "remove_label", "type": "CFG", "blocks": [{"id": 132, "label": "#132\napi = get_api(credentials)\nlabel_url = issue_url + f'/labels/{label}'\napi.delete(label_url)\nreturn 'Label removed successfully'", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 136, "label": "#136\nstatus = self.remove_label(credentials, input_data.issue_url, input_data.label)\nyield 'status', status", "successors": []}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 123, "label": "#123\ncredentials: GithubCredentialsInput = GithubCredentialsField('repo')\nissue_url: str = SchemaField(description=\n    'URL of the GitHub issue or pull request', placeholder=\n    'https://github.com/owner/repo/issues/1')\nlabel: str = SchemaField(description=\n    'Label to remove from the issue or pull request', placeholder=\n    'Enter the label')", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 126, "label": "#126\nstatus: str = SchemaField(description='Status of the label removal operation')\nerror: str = SchemaField(description=\n    'Error message if the label removal failed')", "successors": []}], "functions": [], "classes": []}]}, {"name": "GithubAssignIssueBlock", "type": "CFG", "blocks": [{"id": 141, "label": "#141", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 149, "label": "#149\nsuper().__init__(id='90507c72-b0ff-413a-886a-23bbbd66f542', description=\n    'This block assigns a user to a specified GitHub issue.', categories={\n    BlockCategory.DEVELOPER_TOOLS}, input_schema=GithubAssignIssueBlock.\n    Input, output_schema=GithubAssignIssueBlock.Output, test_input={\n    'issue_url': 'https://github.com/owner/repo/issues/1', 'assignee':\n    'username1', 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=\n    TEST_CREDENTIALS, test_output=[('status', 'Issue assigned successfully'\n    )], test_mock={'assign_issue': lambda *args, **kwargs:\n    'Issue assigned successfully'})", "successors": []}], "functions": [], "classes": []}, {"name": "assign_issue", "type": "CFG", "blocks": [{"id": 152, "label": "#152\napi = get_api(credentials)\nassignees_url = issue_url + '/assignees'\ndata = {'assignees': [assignee]}\napi.post(assignees_url, json=data)\nreturn 'Issue assigned successfully'", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 156, "label": "#156\nstatus = self.assign_issue(credentials, input_data.issue_url, input_data.\n    assignee)\nyield 'status', status", "successors": []}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 143, "label": "#143\ncredentials: GithubCredentialsInput = GithubCredentialsField('repo')\nissue_url: str = SchemaField(description='URL of the GitHub issue',\n    placeholder='https://github.com/owner/repo/issues/1')\nassignee: str = SchemaField(description='Username to assign to the issue',\n    placeholder='Enter the username')", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 146, "label": "#146\nstatus: str = SchemaField(description=\n    'Status of the issue assignment operation')\nerror: str = SchemaField(description=\n    'Error message if the issue assignment failed')", "successors": []}], "functions": [], "classes": []}]}, {"name": "GithubUnassignIssueBlock", "type": "CFG", "blocks": [{"id": 161, "label": "#161", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 169, "label": "#169\nsuper().__init__(id='d154002a-38f4-46c2-962d-2488f2b05ece', description=\n    'This block unassigns a user from a specified GitHub issue.',\n    categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=\n    GithubUnassignIssueBlock.Input, output_schema=GithubUnassignIssueBlock.\n    Output, test_input={'issue_url':\n    'https://github.com/owner/repo/issues/1', 'assignee': 'username1',\n    'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=\n    TEST_CREDENTIALS, test_output=[('status',\n    'Issue unassigned successfully')], test_mock={'unassign_issue': lambda\n    *args, **kwargs: 'Issue unassigned successfully'})", "successors": []}], "functions": [], "classes": []}, {"name": "unassign_issue", "type": "CFG", "blocks": [{"id": 172, "label": "#172\napi = get_api(credentials)\nassignees_url = issue_url + '/assignees'\ndata = {'assignees': [assignee]}\napi.delete(assignees_url, json=data)\nreturn 'Issue unassigned successfully'", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 176, "label": "#176\nstatus = self.unassign_issue(credentials, input_data.issue_url, input_data.\n    assignee)\nyield 'status', status", "successors": []}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 163, "label": "#163\ncredentials: GithubCredentialsInput = GithubCredentialsField('repo')\nissue_url: str = SchemaField(description='URL of the GitHub issue',\n    placeholder='https://github.com/owner/repo/issues/1')\nassignee: str = SchemaField(description=\n    'Username to unassign from the issue', placeholder='Enter the username')", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 166, "label": "#166\nstatus: str = SchemaField(description=\n    'Status of the issue unassignment operation')\nerror: str = SchemaField(description=\n    'Error message if the issue unassignment failed')", "successors": []}], "functions": [], "classes": []}]}]}
{"file_name": "23.json", "name": "23.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport pytest\nfrom backend.util.request import validate_url", "successors": []}], "functions": [{"name": "test_validate_url", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nwith pytest.raises(ValueError):", "successors": [{"id": 4, "label": "#4\nvalidate_url('localhost', [])", "successors": [{"id": 5, "label": "#5\nwith pytest.raises(ValueError):", "successors": [{"id": 6, "label": "#6\nvalidate_url('192.168.1.1', [])", "successors": [{"id": 7, "label": "#7\nwith pytest.raises(ValueError):", "successors": [{"id": 8, "label": "#8\nvalidate_url('127.0.0.1', [])", "successors": [{"id": 9, "label": "#9\nwith pytest.raises(ValueError):", "successors": [{"id": 10, "label": "#10\nvalidate_url('0.0.0.0', [])", "successors": [{"id": 11, "label": "#11\nassert validate_url('google.com/a?b=c', []) == 'http://google.com/a?b=c'", "successors": [{"id": 13, "label": "#13\nassert validate_url('github.com?key=!@!@', []) == 'http://github.com?key=!@!@'", "successors": [{"id": 15, "label": "#15\nwith pytest.raises(ValueError):", "successors": [{"id": 16, "label": "#16\nvalidate_url('ftp://example.com', [])", "successors": [{"id": 17, "label": "#17\nwith pytest.raises(ValueError):", "successors": [{"id": 18, "label": "#18\nvalidate_url('file://example.com', [])", "successors": [{"id": 19, "label": "#19\nassert validate_url('http://xn--exmple-cua.com', []\n    ) == 'http://xn--exmple-cua.com'", "successors": [{"id": 21, "label": "#21\nwith pytest.raises(ValueError):", "successors": [{"id": 22, "label": "#22\nvalidate_url('http://exa\u25ccmple.com', [])", "successors": [{"id": 23, "label": "#23\nwith pytest.raises(ValueError):", "successors": [{"id": 24, "label": "#24\nvalidate_url('::1', [])", "successors": [{"id": 25, "label": "#25\nwith pytest.raises(ValueError):", "successors": [{"id": 26, "label": "#26\nvalidate_url('http://[::1]', [])", "successors": [{"id": 27, "label": "#27\nwith pytest.raises(ValueError):", "successors": [{"id": 28, "label": "#28\nvalidate_url('http://example_underscore.com', [])", "successors": [{"id": 29, "label": "#29\nwith pytest.raises(ValueError):", "successors": [{"id": 30, "label": "#30\nvalidate_url('http://exa mple.com', [])", "successors": [{"id": 31, "label": "#31\nwith pytest.raises(ValueError):", "successors": [{"id": 32, "label": "#32\nvalidate_url('http://', [])", "successors": [{"id": 33, "label": "#33\nwith pytest.raises(ValueError):", "successors": [{"id": 34, "label": "#34\nvalidate_url('://missing-scheme', [])", "successors": [{"id": 35, "label": "#35\ntrusted = ['internal-api.company.com', '10.0.0.5']\nassert validate_url('internal-api.company.com', trusted\n    ) == 'http://internal-api.company.com'", "successors": [{"id": 37, "label": "#37\nassert validate_url('10.0.0.5', ['10.0.0.5']) == 'http://10.0.0.5'", "successors": [{"id": 39, "label": "#39\nassert validate_url('example.com/path%20with%20spaces', []\n    ) == 'http://example.com/path%20with%20spaces'", "successors": [{"id": 41, "label": "#41\nassert validate_url('http://example.com\\\\backslash', []\n    ) == 'http://example.com/backslash'", "successors": [{"id": 43, "label": "#43\nassert validate_url('example.com', []) == 'http://example.com'", "successors": [{"id": 45, "label": "#45\nassert validate_url('https://secure.com', []) == 'https://secure.com'", "successors": [{"id": 47, "label": "#47\nassert validate_url('example.com?param=\u00e4\u00f6\u00fc', []\n    ) == 'http://example.com?param=\u00e4\u00f6\u00fc'", "successors": []}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "24.json", "name": "24.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom backend.data.block import BlockOutput, BlockSchema\nfrom backend.data.model import APIKeyCredentials, SchemaField\nfrom ._api import TEST_CREDENTIALS, TEST_CREDENTIALS_INPUT, Slant3DCredentialsField, Slant3DCredentialsInput\nfrom .base import Slant3DBlockBase", "successors": []}], "functions": [], "classes": [{"name": "Slant3DSlicerBlock", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"Block for slicing 3D model files\"\"\"", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 11, "label": "#11\nsuper().__init__(id='f8a12c8d-3e4b-4d5f-b6a7-8c9d0e1f2g3h', description=\n    'Slice a 3D model file and get pricing information', input_schema=self.\n    Input, output_schema=self.Output, test_input={'credentials':\n    TEST_CREDENTIALS_INPUT, 'file_url': 'https://example.com/model.stl'},\n    test_credentials=TEST_CREDENTIALS, test_output=[('message',\n    'Slicing successful'), ('price', 8.23)], test_mock={'_make_request': lambda\n    *args, **kwargs: {'message': 'Slicing successful', 'data': {'price': \n    8.23}}})", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 14, "label": "#14\ntry:", "successors": [{"id": 15, "label": "#15\nresult = self._make_request('POST', 'slicer', credentials.api_key.\n    get_secret_value(), json={'fileURL': input_data.file_url})\nyield 'message', result['message']", "successors": [{"id": 18, "label": "#18\nyield 'price', result['data']['price']", "successors": []}]}, {"id": 16, "label": "#16\nyield 'error', str(e)", "successors": [{"id": 20, "label": "#20\nraise", "successors": []}]}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 5, "label": "#5\ncredentials: Slant3DCredentialsInput = Slant3DCredentialsField()\nfile_url: str = SchemaField(description=\n    'URL of the 3D model file to slice (STL)')", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 8, "label": "#8\nmessage: str = SchemaField(description='Response message')\nprice: float = SchemaField(description='Calculated price for printing')\nerror: str = SchemaField(description='Error message if slicing failed')", "successors": []}], "functions": [], "classes": []}]}]}
{"file_name": "25.json", "name": "25.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport logging\nimport time\nfrom enum import Enum\nfrom typing import Literal\nimport replicate\nfrom pydantic import SecretStr\nfrom backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema\nfrom backend.data.model import APIKeyCredentials, CredentialsField, CredentialsMetaInput, SchemaField\nfrom backend.integrations.providers import ProviderName\nlogger = logging.getLogger(__name__)\nTEST_CREDENTIALS = APIKeyCredentials(id=\n    '01234567-89ab-cdef-0123-456789abcdef', provider='replicate', api_key=\n    SecretStr('mock-replicate-api-key'), title='Mock Replicate API key',\n    expires_at=None)\nTEST_CREDENTIALS_INPUT = {'provider': TEST_CREDENTIALS.provider, 'id':\n    TEST_CREDENTIALS.id, 'type': TEST_CREDENTIALS.type, 'title':\n    TEST_CREDENTIALS.type}", "successors": []}], "functions": [], "classes": [{"name": "MusicGenModelVersion", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nSTEREO_LARGE = 'stereo-large'\nMELODY_LARGE = 'melody-large'\nLARGE = 'large'", "successors": []}], "functions": [], "classes": []}, {"name": "AudioFormat", "type": "CFG", "blocks": [{"id": 6, "label": "#6\nWAV = 'wav'\nMP3 = 'mp3'", "successors": []}], "functions": [], "classes": []}, {"name": "NormalizationStrategy", "type": "CFG", "blocks": [{"id": 9, "label": "#9\nLOUDNESS = 'loudness'\nCLIP = 'clip'\nPEAK = 'peak'\nRMS = 'rms'", "successors": []}], "functions": [], "classes": []}, {"name": "AIMusicGeneratorBlock", "type": "CFG", "blocks": [{"id": 12, "label": "#12", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 20, "label": "#20\nsuper().__init__(id='44f6c8ad-d75c-4ae1-8209-aad1c0326928', description=\n    \"This block generates music using Meta's MusicGen model on Replicate.\",\n    categories={BlockCategory.AI}, input_schema=AIMusicGeneratorBlock.Input,\n    output_schema=AIMusicGeneratorBlock.Output, test_input={'credentials':\n    TEST_CREDENTIALS_INPUT, 'prompt':\n    'An upbeat electronic dance track with heavy bass',\n    'music_gen_model_version': MusicGenModelVersion.STEREO_LARGE,\n    'duration': 8, 'temperature': 1.0, 'top_k': 250, 'top_p': 0.0,\n    'classifier_free_guidance': 3, 'output_format': AudioFormat.WAV,\n    'normalization_strategy': NormalizationStrategy.LOUDNESS}, test_output=\n    [('result', 'https://replicate.com/output/generated-audio-url.wav')],\n    test_mock={'run_model': lambda api_key, music_gen_model_version, prompt,\n    duration, temperature, top_k, top_p, classifier_free_guidance,\n    output_format, normalization_strategy:\n    'https://replicate.com/output/generated-audio-url.wav'},\n    test_credentials=TEST_CREDENTIALS)", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 23, "label": "#23\nmax_retries = 3\nretry_delay = 5\nlast_error = None", "successors": [{"id": 24, "label": "#24\nfor attempt in range(max_retries):", "successors": [{"id": 25, "label": "#25\ntry:", "successors": [{"id": 27, "label": "#27\nlogger.debug(f'[AIMusicGeneratorBlock] - Running model (attempt {attempt + 1})'\n    )\nresult = self.run_model(api_key=credentials.api_key,\n    music_gen_model_version=input_data.music_gen_model_version, prompt=\n    input_data.prompt, duration=input_data.duration, temperature=input_data\n    .temperature, top_k=input_data.top_k, top_p=input_data.top_p,\n    classifier_free_guidance=input_data.classifier_free_guidance,\n    output_format=input_data.output_format, normalization_strategy=\n    input_data.normalization_strategy)\nif result and result != 'No output received':", "successors": [{"id": 30, "label": "#30\nyield 'result', result", "successors": [{"id": 34, "label": "#34\nreturn", "successors": []}]}, {"id": 32, "label": "#32\nlast_error = 'Model returned empty or invalid response'\nraise ValueError(last_error)", "successors": []}]}, {"id": 28, "label": "#28\nlast_error = f'Unexpected error: {str(e)}'\nlogger.error(f'[AIMusicGeneratorBlock] - Error: {last_error}')\nif attempt < max_retries - 1:", "successors": [{"id": 36, "label": "#36\ntime.sleep(retry_delay)", "successors": []}]}]}, {"id": 26, "label": "#26\nyield 'error', f'Failed after {max_retries} attempts. Last error: {last_error}'", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "run_model", "type": "CFG", "blocks": [{"id": 41, "label": "#41\nclient = replicate.Client(api_token=api_key.get_secret_value())\noutput = client.run(\n    'meta/musicgen:671ac645ce5e552cc63a54a2bbff63fcf798043055d2dac5fc9e36a837eedcfb'\n    , input={'prompt': prompt, 'music_gen_model_version':\n    music_gen_model_version, 'duration': duration, 'temperature':\n    temperature, 'top_k': top_k, 'top_p': top_p, 'classifier_free_guidance':\n    classifier_free_guidance, 'output_format': output_format,\n    'normalization_strategy': normalization_strategy})\nif isinstance(output, list) and len(output) > 0:", "successors": [{"id": 42, "label": "#42\nresult_url = output[0]", "successors": [{"id": 43, "label": "#43\nreturn result_url", "successors": []}]}, {"id": 44, "label": "#44\nif isinstance(output, str):", "successors": [{"id": 45, "label": "#45\nresult_url = output", "successors": []}, {"id": 47, "label": "#47\nresult_url = 'No output received'", "successors": []}]}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 14, "label": "#14\ncredentials: CredentialsMetaInput[Literal[ProviderName.REPLICATE], Literal[\n    'api_key']] = CredentialsField(description=\n    'The Replicate integration can be used with any API key with sufficient permissions for the blocks it is used on.'\n    )\nprompt: str = SchemaField(description=\n    'A description of the music you want to generate', placeholder=\n    \"e.g., 'An upbeat electronic dance track with heavy bass'\", title='Prompt')\nmusic_gen_model_version: MusicGenModelVersion = SchemaField(description=\n    'Model to use for generation', default=MusicGenModelVersion.\n    STEREO_LARGE, title='Model Version')\nduration: int = SchemaField(description=\n    'Duration of the generated audio in seconds', default=8, title='Duration')\ntemperature: float = SchemaField(description=\n    \"Controls the 'conservativeness' of the sampling process. Higher temperature means more diversity\"\n    , default=1.0, title='Temperature')\ntop_k: int = SchemaField(description=\n    'Reduces sampling to the k most likely tokens', default=250, title='Top K')\ntop_p: float = SchemaField(description=\n    'Reduces sampling to tokens with cumulative probability of p. When set to 0 (default), top_k sampling is used'\n    , default=0.0, title='Top P')\nclassifier_free_guidance: int = SchemaField(description=\n    'Increases the influence of inputs on the output. Higher values produce lower-variance outputs that adhere more closely to inputs'\n    , default=3, title='Classifier Free Guidance')\noutput_format: AudioFormat = SchemaField(description=\n    'Output format for generated audio', default=AudioFormat.WAV, title=\n    'Output Format')\nnormalization_strategy: NormalizationStrategy = SchemaField(description=\n    'Strategy for normalizing audio', default=NormalizationStrategy.\n    LOUDNESS, title='Normalization Strategy')", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 17, "label": "#17\nresult: str = SchemaField(description='URL of the generated audio file')\nerror: str = SchemaField(description='Error message if the model run failed')", "successors": []}], "functions": [], "classes": []}]}]}
{"file_name": "26.json", "name": "26.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom enum import Enum\nfrom typing import Literal\nimport replicate\nfrom pydantic import SecretStr\nfrom replicate.helpers import FileOutput\nfrom backend.data.block import Block, BlockCategory, BlockSchema\nfrom backend.data.model import APIKeyCredentials, CredentialsField, CredentialsMetaInput, SchemaField\nfrom backend.integrations.providers import ProviderName\nSIZE_TO_SD_RATIO = {ImageSize.SQUARE: '1:1', ImageSize.LANDSCAPE: '4:3',\n    ImageSize.PORTRAIT: '3:4', ImageSize.WIDE: '16:9', ImageSize.TALL: '9:16'}\nSIZE_TO_FLUX_RATIO = {ImageSize.SQUARE: '1:1', ImageSize.LANDSCAPE: '4:3',\n    ImageSize.PORTRAIT: '3:4', ImageSize.WIDE: '16:9', ImageSize.TALL: '9:16'}\nSIZE_TO_FLUX_DIMENSIONS = {ImageSize.SQUARE: (1024, 1024), ImageSize.\n    LANDSCAPE: (1365, 1024), ImageSize.PORTRAIT: (1024, 1365), ImageSize.\n    WIDE: (1440, 810), ImageSize.TALL: (810, 1440)}\nSIZE_TO_RECRAFT_DIMENSIONS = {ImageSize.SQUARE: '1024x1024', ImageSize.\n    LANDSCAPE: '1365x1024', ImageSize.PORTRAIT: '1024x1365', ImageSize.WIDE:\n    '1536x1024', ImageSize.TALL: '1024x1536'}\nTEST_CREDENTIALS = APIKeyCredentials(id=\n    '01234567-89ab-cdef-0123-456789abcdef', provider='replicate', api_key=\n    SecretStr('mock-replicate-api-key'), title='Mock Replicate API key',\n    expires_at=None)\nTEST_CREDENTIALS_INPUT = {'provider': TEST_CREDENTIALS.provider, 'id':\n    TEST_CREDENTIALS.id, 'type': TEST_CREDENTIALS.type, 'title':\n    TEST_CREDENTIALS.title}", "successors": []}], "functions": [], "classes": [{"name": "ImageSize", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"\n    Semantic sizes that map reliably across all models\n    \"\"\"\nSQUARE = 'square'\nLANDSCAPE = 'landscape'\nPORTRAIT = 'portrait'\nWIDE = 'wide'\nTALL = 'tall'", "successors": []}], "functions": [], "classes": []}, {"name": "ImageStyle", "type": "CFG", "blocks": [{"id": 6, "label": "#6\n\"\"\"\n    Complete set of supported styles\n    \"\"\"\nANY = 'any'\nREALISTIC = 'realistic_image'\nREALISTIC_BW = 'realistic_image/b_and_w'\nREALISTIC_HDR = 'realistic_image/hdr'\nREALISTIC_NATURAL = 'realistic_image/natural_light'\nREALISTIC_STUDIO = 'realistic_image/studio_portrait'\nREALISTIC_ENTERPRISE = 'realistic_image/enterprise'\nREALISTIC_HARD_FLASH = 'realistic_image/hard_flash'\nREALISTIC_MOTION_BLUR = 'realistic_image/motion_blur'\nDIGITAL_ART = 'digital_illustration'\nPIXEL_ART = 'digital_illustration/pixel_art'\nHAND_DRAWN = 'digital_illustration/hand_drawn'\nGRAIN = 'digital_illustration/grain'\nSKETCH = 'digital_illustration/infantile_sketch'\nPOSTER = 'digital_illustration/2d_art_poster'\nPOSTER_2 = 'digital_illustration/2d_art_poster_2'\nHANDMADE_3D = 'digital_illustration/handmade_3d'\nHAND_DRAWN_OUTLINE = 'digital_illustration/hand_drawn_outline'\nENGRAVING_COLOR = 'digital_illustration/engraving_color'", "successors": []}], "functions": [], "classes": []}, {"name": "ImageGenModel", "type": "CFG", "blocks": [{"id": 9, "label": "#9\n\"\"\"\n    Available model providers\n    \"\"\"\nFLUX = 'Flux 1.1 Pro'\nFLUX_ULTRA = 'Flux 1.1 Pro Ultra'\nRECRAFT = 'Recraft v3'\nSD3_5 = 'Stable Diffusion 3.5 Medium'", "successors": []}], "functions": [], "classes": []}, {"name": "AIImageGeneratorBlock", "type": "CFG", "blocks": [{"id": 12, "label": "#12", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 20, "label": "#20\nsuper().__init__(id='ed1ae7a0-b770-4089-b520-1f0005fad19a', description=\n    'Generate images using various AI models through a unified interface',\n    categories={BlockCategory.AI}, input_schema=AIImageGeneratorBlock.Input,\n    output_schema=AIImageGeneratorBlock.Output, test_input={'credentials':\n    TEST_CREDENTIALS_INPUT, 'prompt':\n    \"An octopus using a laptop in a snowy forest with 'AutoGPT' clearly visible on the screen\"\n    , 'model': ImageGenModel.RECRAFT, 'size': ImageSize.SQUARE, 'style':\n    ImageStyle.REALISTIC}, test_credentials=TEST_CREDENTIALS, test_output=[\n    ('image_url', 'https://replicate.delivery/generated-image.webp')],\n    test_mock={'_run_client': lambda *args, **kwargs:\n    'https://replicate.delivery/generated-image.webp'})", "successors": []}], "functions": [], "classes": []}, {"name": "_run_client", "type": "CFG", "blocks": [{"id": 23, "label": "#23\ntry:", "successors": [{"id": 24, "label": "#24\nclient = replicate.Client(api_token=credentials.api_key.get_secret_value())\noutput = client.run(model_name, input=input_params, wait=False)\nif isinstance(output, list) and len(output) > 0:", "successors": [{"id": 28, "label": "#28\nif isinstance(output[0], FileOutput):", "successors": [{"id": 37, "label": "#37\nresult_url = output[0].url", "successors": [{"id": 29, "label": "#29\nreturn result_url", "successors": []}]}, {"id": 39, "label": "#39\nresult_url = output[0]", "successors": []}]}, {"id": 30, "label": "#30\nif isinstance(output, FileOutput):", "successors": [{"id": 31, "label": "#31\nresult_url = output.url", "successors": []}, {"id": 33, "label": "#33\nif isinstance(output, str):", "successors": [{"id": 34, "label": "#34\nresult_url = output", "successors": []}, {"id": 36, "label": "#36\nresult_url = None", "successors": []}]}]}]}, {"id": 25, "label": "#25\nraise TypeError(f'Error during model execution: {e}')", "successors": []}, {"id": 26, "label": "#26\nraise RuntimeError(f'Unexpected error during model execution: {e}')", "successors": []}]}], "functions": [], "classes": []}, {"name": "generate_image", "type": "CFG", "blocks": [{"id": 45, "label": "#45\ntry:", "successors": [{"id": 46, "label": "#46\nmodified_prompt = input_data.prompt\nif input_data.model not in [ImageGenModel.RECRAFT]:", "successors": [{"id": 49, "label": "#49\nstyle_prefix = self._style_to_prompt_prefix(input_data.style)\nmodified_prompt = f'{style_prefix} {modified_prompt}'.strip()", "successors": [{"id": 50, "label": "#50\nif input_data.model == ImageGenModel.SD3_5:", "successors": [{"id": 51, "label": "#51\ninput_params = {'prompt': modified_prompt, 'aspect_ratio': SIZE_TO_SD_RATIO\n    [input_data.size], 'output_format': 'webp', 'output_quality': 90,\n    'steps': 40, 'cfg_scale': 7.0}\noutput = self._run_client(credentials,\n    'stability-ai/stable-diffusion-3.5-medium', input_params)\nreturn output", "successors": []}, {"id": 53, "label": "#53\nif input_data.model == ImageGenModel.FLUX:", "successors": [{"id": 54, "label": "#54\nwidth, height = SIZE_TO_FLUX_DIMENSIONS[input_data.size]\ninput_params = {'prompt': modified_prompt, 'width': width, 'height': height,\n    'aspect_ratio': SIZE_TO_FLUX_RATIO[input_data.size], 'output_format':\n    'jpg', 'output_quality': 90}\noutput = self._run_client(credentials, 'black-forest-labs/flux-1.1-pro',\n    input_params)\nreturn output", "successors": []}, {"id": 56, "label": "#56\nif input_data.model == ImageGenModel.FLUX_ULTRA:", "successors": [{"id": 57, "label": "#57\nwidth, height = SIZE_TO_FLUX_DIMENSIONS[input_data.size]\ninput_params = {'prompt': modified_prompt, 'width': width, 'height': height,\n    'aspect_ratio': SIZE_TO_FLUX_RATIO[input_data.size], 'output_format':\n    'jpg', 'output_quality': 90}\noutput = self._run_client(credentials,\n    'black-forest-labs/flux-1.1-pro-ultra', input_params)\nreturn output", "successors": []}, {"id": 59, "label": "#59\nif input_data.model == ImageGenModel.RECRAFT:", "successors": [{"id": 60, "label": "#60\ninput_params = {'prompt': input_data.prompt, 'size':\n    SIZE_TO_RECRAFT_DIMENSIONS[input_data.size], 'style': input_data.style.\n    value}\noutput = self._run_client(credentials, 'recraft-ai/recraft-v3', input_params)\nreturn output", "successors": []}]}]}]}]}]}]}, {"id": 47, "label": "#47\nraise RuntimeError(f'Failed to generate image: {str(e)}')", "successors": []}]}], "functions": [], "classes": []}, {"name": "_style_to_prompt_prefix", "type": "CFG", "blocks": [{"id": 69, "label": "#69\n\"\"\"\n        Convert a style enum to a prompt prefix for models without native style support.\n        \"\"\"\nif style == ImageStyle.ANY:", "successors": [{"id": 70, "label": "#70\nreturn ''", "successors": []}, {"id": 71, "label": "#71\nstyle_map = {ImageStyle.REALISTIC: 'photorealistic', ImageStyle.\n    REALISTIC_BW: 'black and white photograph', ImageStyle.REALISTIC_HDR:\n    'HDR photograph', ImageStyle.REALISTIC_NATURAL:\n    'natural light photograph', ImageStyle.REALISTIC_STUDIO:\n    'studio portrait photograph', ImageStyle.REALISTIC_ENTERPRISE:\n    'enterprise photograph', ImageStyle.REALISTIC_HARD_FLASH:\n    'hard flash photograph', ImageStyle.REALISTIC_MOTION_BLUR:\n    'motion blur photograph', ImageStyle.DIGITAL_ART: 'digital art',\n    ImageStyle.PIXEL_ART: 'pixel art', ImageStyle.HAND_DRAWN:\n    'hand drawn illustration', ImageStyle.GRAIN:\n    'grainy digital illustration', ImageStyle.SKETCH:\n    'sketchy illustration', ImageStyle.POSTER: '2D art poster', ImageStyle.\n    POSTER_2: 'alternate 2D art poster', ImageStyle.HANDMADE_3D:\n    'handmade 3D illustration', ImageStyle.HAND_DRAWN_OUTLINE:\n    'hand drawn outline illustration', ImageStyle.ENGRAVING_COLOR:\n    'color engraving illustration'}\nstyle_text = style_map.get(style, '')\nreturn f'{style_text} of' if style_text else ''", "successors": []}]}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 76, "label": "#76\ntry:", "successors": [{"id": 77, "label": "#77\nurl = self.generate_image(input_data, credentials)\nif url:", "successors": [{"id": 80, "label": "#80\nyield 'image_url', url", "successors": []}, {"id": 82, "label": "#82\nyield 'error', 'Image generation returned an empty result.'", "successors": []}]}, {"id": 78, "label": "#78\nyield 'error', str(e)", "successors": []}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 14, "label": "#14\ncredentials: CredentialsMetaInput[Literal[ProviderName.REPLICATE], Literal[\n    'api_key']] = CredentialsField(description=\n    'Enter your Replicate API key to access the image generation API. You can obtain an API key from https://replicate.com/account/api-tokens.'\n    )\nprompt: str = SchemaField(description='Text prompt for image generation',\n    placeholder=\"e.g., 'A red panda using a laptop in a snowy forest'\",\n    title='Prompt')\nmodel: ImageGenModel = SchemaField(description=\n    'The AI model to use for image generation', default=ImageGenModel.SD3_5,\n    title='Model')\nsize: ImageSize = SchemaField(description=\n    \"\"\"Format of the generated image:\n- Square: Perfect for profile pictures, icons\n- Landscape: Traditional photo format\n- Portrait: Vertical photos, portraits\n- Wide: Cinematic format, desktop wallpapers\n- Tall: Mobile wallpapers, social media stories\"\"\"\n    , default=ImageSize.SQUARE, title='Image Format')\nstyle: ImageStyle = SchemaField(description=\n    'Visual style for the generated image', default=ImageStyle.ANY, title=\n    'Image Style')", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 17, "label": "#17\nimage_url: str = SchemaField(description='URL of the generated image')\nerror: str = SchemaField(description='Error message if generation failed')", "successors": []}], "functions": [], "classes": []}]}]}
{"file_name": "27.json", "name": "27.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom typing import cast\nfrom unittest.mock import AsyncMock\nimport pytest\nfrom fastapi import WebSocket, WebSocketDisconnect\nfrom backend.server.conn_manager import ConnectionManager\nfrom backend.server.ws_api import Methods, WsMessage, handle_subscribe, handle_unsubscribe, websocket_router", "successors": []}], "functions": [{"name": "mock_websocket", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nreturn AsyncMock(spec=WebSocket)", "successors": []}], "functions": [], "classes": []}, {"name": "mock_manager", "type": "CFG", "blocks": [{"id": 7, "label": "#7\nreturn AsyncMock(spec=ConnectionManager)", "successors": []}], "functions": [], "classes": []}, {"name": "test_websocket_router_subscribe", "type": "CFG", "blocks": [{"id": 11, "label": "#11\nmock_websocket.receive_text.side_effect = [WsMessage(method=Methods.\n    SUBSCRIBE, data={'graph_id': 'test_graph'}).model_dump_json(),\n    WebSocketDisconnect()]\nawait websocket_router(cast(WebSocket, mock_websocket), cast(\n    ConnectionManager, mock_manager))", "successors": [{"id": 12, "label": "#12\nmock_manager.connect.assert_called_once_with(mock_websocket)\nmock_manager.subscribe.assert_called_once_with('test_graph', mock_websocket)\nmock_websocket.send_text.assert_called_once()\nassert '\"method\":\"subscribe\"' in mock_websocket.send_text.call_args[0][0]", "successors": [{"id": 14, "label": "#14\nassert '\"success\":true' in mock_websocket.send_text.call_args[0][0]", "successors": [{"id": 16, "label": "#16\nmock_manager.disconnect.assert_called_once_with(mock_websocket)", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "test_websocket_router_unsubscribe", "type": "CFG", "blocks": [{"id": 19, "label": "#19\nmock_websocket.receive_text.side_effect = [WsMessage(method=Methods.\n    UNSUBSCRIBE, data={'graph_id': 'test_graph'}).model_dump_json(),\n    WebSocketDisconnect()]\nawait websocket_router(cast(WebSocket, mock_websocket), cast(\n    ConnectionManager, mock_manager))", "successors": [{"id": 20, "label": "#20\nmock_manager.connect.assert_called_once_with(mock_websocket)\nmock_manager.unsubscribe.assert_called_once_with('test_graph', mock_websocket)\nmock_websocket.send_text.assert_called_once()\nassert '\"method\":\"unsubscribe\"' in mock_websocket.send_text.call_args[0][0]", "successors": [{"id": 22, "label": "#22\nassert '\"success\":true' in mock_websocket.send_text.call_args[0][0]", "successors": [{"id": 24, "label": "#24\nmock_manager.disconnect.assert_called_once_with(mock_websocket)", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "test_websocket_router_invalid_method", "type": "CFG", "blocks": [{"id": 27, "label": "#27\nmock_websocket.receive_text.side_effect = [WsMessage(method=Methods.\n    EXECUTION_EVENT).model_dump_json(), WebSocketDisconnect()]\nawait websocket_router(cast(WebSocket, mock_websocket), cast(\n    ConnectionManager, mock_manager))", "successors": [{"id": 28, "label": "#28\nmock_manager.connect.assert_called_once_with(mock_websocket)\nmock_websocket.send_text.assert_called_once()\nassert '\"method\":\"error\"' in mock_websocket.send_text.call_args[0][0]", "successors": [{"id": 30, "label": "#30\nassert '\"success\":false' in mock_websocket.send_text.call_args[0][0]", "successors": [{"id": 32, "label": "#32\nmock_manager.disconnect.assert_called_once_with(mock_websocket)", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "test_handle_subscribe_success", "type": "CFG", "blocks": [{"id": 35, "label": "#35\nmessage = WsMessage(method=Methods.SUBSCRIBE, data={'graph_id': 'test_graph'})\nawait handle_subscribe(cast(WebSocket, mock_websocket), cast(\n    ConnectionManager, mock_manager), message)", "successors": [{"id": 36, "label": "#36\nmock_manager.subscribe.assert_called_once_with('test_graph', mock_websocket)\nmock_websocket.send_text.assert_called_once()\nassert '\"method\":\"subscribe\"' in mock_websocket.send_text.call_args[0][0]", "successors": [{"id": 38, "label": "#38\nassert '\"success\":true' in mock_websocket.send_text.call_args[0][0]", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "test_handle_subscribe_missing_data", "type": "CFG", "blocks": [{"id": 43, "label": "#43\nmessage = WsMessage(method=Methods.SUBSCRIBE)\nawait handle_subscribe(cast(WebSocket, mock_websocket), cast(\n    ConnectionManager, mock_manager), message)", "successors": [{"id": 44, "label": "#44\nmock_manager.subscribe.assert_not_called()\nmock_websocket.send_text.assert_called_once()\nassert '\"method\":\"error\"' in mock_websocket.send_text.call_args[0][0]", "successors": [{"id": 46, "label": "#46\nassert '\"success\":false' in mock_websocket.send_text.call_args[0][0]", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "test_handle_unsubscribe_success", "type": "CFG", "blocks": [{"id": 51, "label": "#51\nmessage = WsMessage(method=Methods.UNSUBSCRIBE, data={'graph_id': 'test_graph'}\n    )\nawait handle_unsubscribe(cast(WebSocket, mock_websocket), cast(\n    ConnectionManager, mock_manager), message)", "successors": [{"id": 52, "label": "#52\nmock_manager.unsubscribe.assert_called_once_with('test_graph', mock_websocket)\nmock_websocket.send_text.assert_called_once()\nassert '\"method\":\"unsubscribe\"' in mock_websocket.send_text.call_args[0][0]", "successors": [{"id": 54, "label": "#54\nassert '\"success\":true' in mock_websocket.send_text.call_args[0][0]", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "test_handle_unsubscribe_missing_data", "type": "CFG", "blocks": [{"id": 59, "label": "#59\nmessage = WsMessage(method=Methods.UNSUBSCRIBE)\nawait handle_unsubscribe(cast(WebSocket, mock_websocket), cast(\n    ConnectionManager, mock_manager), message)", "successors": [{"id": 60, "label": "#60\nmock_manager.unsubscribe.assert_not_called()\nmock_websocket.send_text.assert_called_once()\nassert '\"method\":\"error\"' in mock_websocket.send_text.call_args[0][0]", "successors": [{"id": 62, "label": "#62\nassert '\"success\":false' in mock_websocket.send_text.call_args[0][0]", "successors": []}]}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "28.json", "name": "28.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom enum import Enum\nfrom typing import Any, Optional\nfrom pydantic import BaseModel\nfrom backend.data.block import BlockInput", "successors": []}], "functions": [], "classes": [{"name": "BlockCostType", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nRUN = 'run'\nBYTE = 'byte'\nSECOND = 'second'\nDOLLAR = 'dollar'", "successors": []}], "functions": [], "classes": []}, {"name": "BlockCost", "type": "CFG", "blocks": [{"id": 6, "label": "#6\ncost_amount: int\ncost_filter: BlockInput\ncost_type: BlockCostType", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 8, "label": "#8\nsuper().__init__(cost_amount=cost_amount, cost_filter=cost_filter or {},\n    cost_type=cost_type, **data)", "successors": []}], "functions": [], "classes": []}], "classes": []}]}
{"file_name": "29.json", "name": "29.json", "type": "CFG", "blocks": [{"id": 1, "label": "#1\n{'name': 'example_script', 'type': 'CFG', 'start_line': 1, 'end_line': 13,\n    'functions': [{'name': 'main', 'type': 'function', 'start_line': 5,\n    'end_line': 9, 'functions': [], 'classes': [], 'simplified_code':\n    \"\"\"def main():\n    \"\"\\\"\n    Run all the processes required for the AutoGPT-server WebSocket API.\n    \"\"\\\"\n    run_processes(WebsocketServer())\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"def main():\n    \"\"\\\"\n    Run all the processes required for the AutoGPT-server WebSocket API.\n    \"\"\\\"\n    run_processes(WebsocketServer())\"\"\"\n    , 'successors': []}]}], 'classes': [], 'simplified_code':\n    \"\"\"from backend.app import run_processes\nfrom backend.server.ws_api import WebsocketServer\n\n\n    run_processes(WebsocketServer())\n\n\nif __name__ == \"__main__\":\n    main()\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"from backend.app import run_processes\nfrom backend.server.ws_api import WebsocketServer\n\n\n    run_processes(WebsocketServer())\"\"\"\n    , 'successors': [2]}, {'id': 2, 'label':\n    \"\"\"if __name__ == \"__main__\":\n    main()\"\"\", 'successors': []}]}", "successors": []}], "functions": [], "classes": []}
{"file_name": "30.json", "name": "30.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport re\nimport sys\nimport random\nfrom typing import List, Tuple\nimport requests\nfrom requests.models import Response\nif __name__ == '__main__':", "successors": [{"id": 97, "label": "#97\nnum_args = len(sys.argv)\nonly_duplicate_links_checker = False\nif num_args < 2:", "successors": [{"id": 99, "label": "#99\nprint('No .md file passed')\nsys.exit(1)", "successors": [{"id": 100, "label": "#100\nfilename = sys.argv[1]\nmain(filename, only_duplicate_links_checker)", "successors": []}]}, {"id": 101, "label": "#101\nif num_args == 3:", "successors": [{"id": 102, "label": "#102\nthird_arg = sys.argv[2].lower()\nif third_arg == '-odlc' or third_arg == '--only_duplicate_links_checker':", "successors": [{"id": 104, "label": "#104\nonly_duplicate_links_checker = True", "successors": []}, {"id": 106, "label": "#106\nprint(\n    f'Third invalid argument. Usage: python {__file__} [-odlc | --only_duplicate_links_checker]'\n    )\nsys.exit(1)", "successors": []}]}]}]}]}], "functions": [{"name": "find_links_in_text", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"Find links in a text and return a list of URLs.\"\"\"\nlink_pattern = re.compile(\n    '((?:https?://|www\\\\d{0,3}[.]|[a-z0-9.\\\\-]+[.][a-z]{2,4}/)(?:[^\\\\s()<>]+|\\\\(([^\\\\s()<>]+|(\\\\([^\\\\s()<>]+\\\\)))*\\\\))+(?:\\\\(([^\\\\s()<>]+|(\\\\([^\\\\s()<>]+\\\\)))*\\\\)|[^\\\\s`!()\\\\[\\\\]{};:\\\\\\'\\\\\".,<>?\u00ab\u00bb\u201c\u201d\u2018\u2019]))'\n    )\nraw_links = re.findall(link_pattern, text)\nlinks = [str(raw_link[0]) for raw_link in raw_links]\nreturn links", "successors": []}], "functions": [], "classes": []}, {"name": "find_links_in_file", "type": "CFG", "blocks": [{"id": 7, "label": "#7\n\"\"\"Find links in a file and return a list of URLs from text file.\"\"\"\nwith open(filename, mode='r', encoding='utf-8') as file:", "successors": [{"id": 8, "label": "#8\nreadme = file.read()\nindex_section = readme.find('## Index')\nif index_section == -1:", "successors": [{"id": 10, "label": "#10\nindex_section = 0", "successors": [{"id": 11, "label": "#11\ncontent = readme[index_section:]", "successors": [{"id": 9, "label": "#9\nlinks = find_links_in_text(content)\nreturn links", "successors": []}]}]}]}]}], "functions": [], "classes": []}, {"name": "check_duplicate_links", "type": "CFG", "blocks": [{"id": 15, "label": "#15\n\"\"\"Check for duplicated links.\n\n    Returns a tuple with True or False and duplicate list.\n    \"\"\"\nseen = {}\nduplicates = []\nhas_duplicate = False", "successors": [{"id": 16, "label": "#16\nfor link in links:", "successors": [{"id": 17, "label": "#17\nlink = link.rstrip('/')\nif link not in seen:", "successors": [{"id": 19, "label": "#19\nseen[link] = 1", "successors": []}, {"id": 21, "label": "#21\nif seen[link] == 1:", "successors": [{"id": 22, "label": "#22\nduplicates.append(link)", "successors": []}]}]}, {"id": 18, "label": "#18\nif duplicates:", "successors": [{"id": 24, "label": "#24\nhas_duplicate = True", "successors": [{"id": 25, "label": "#25\nreturn has_duplicate, duplicates", "successors": []}]}]}]}]}], "functions": [], "classes": []}, {"name": "fake_user_agent", "type": "CFG", "blocks": [{"id": 29, "label": "#29\n\"\"\"Faking user agent as some hosting services block not-whitelisted UA.\"\"\"\nuser_agents = [\n    'Mozilla/5.0 (Windows NT 6.2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/28.0.1467.0 Safari/537.36'\n    ,\n    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/605.1.15 (KHTML, like Gecko)'\n    ,\n    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 Safari/537.36'\n    ,\n    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36'\n    ]\nreturn random.choice(user_agents)", "successors": []}], "functions": [], "classes": []}, {"name": "get_host_from_link", "type": "CFG", "blocks": [{"id": 33, "label": "#33\nhost = link.split('://', 1)[1] if '://' in link else link\nif '/' in host:", "successors": [{"id": 34, "label": "#34\nhost = host.split('/', 1)[0]", "successors": [{"id": 35, "label": "#35\nreturn host", "successors": []}]}, {"id": 36, "label": "#36\nif '?' in host:", "successors": [{"id": 37, "label": "#37\nhost = host.split('?', 1)[0]", "successors": []}, {"id": 39, "label": "#39\nif '#' in host:", "successors": [{"id": 40, "label": "#40\nhost = host.split('#', 1)[0]", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "has_cloudflare_protection", "type": "CFG", "blocks": [{"id": 45, "label": "#45\n\"\"\"Checks if there is any cloudflare protection in the response.\n\n    Cloudflare implements multiple network protections on a given link,\n    this script tries to detect if any of them exist in the response from request.\n\n    Common protections have the following HTTP code as a response:\n        - 403: When host header is missing or incorrect (and more)\n        - 503: When DDOS protection exists\n\n    See more about it at:\n        - https://support.cloudflare.com/hc/en-us/articles/115003014512-4xx-Client-Error\n        - https://support.cloudflare.com/hc/en-us/articles/115003011431-Troubleshooting-Cloudflare-5XX-errors\n        - https://www.cloudflare.com/ddos/\n        - https://superuser.com/a/888526\n\n    Discussions in issues and pull requests:\n        - https://github.com/public-apis/public-apis/pull/2409\n        - https://github.com/public-apis/public-apis/issues/2960 \n    \"\"\"\ncode = resp.status_code\nserver = resp.headers.get('Server') or resp.headers.get('server')\ncloudflare_flags = ['403 Forbidden', 'cloudflare', 'Cloudflare',\n    'Checking your browser before accessing', 'This process is automatic.',\n    'Your browser will redirect to your requested content shortly.',\n    'Please allow up to 5 seconds', 'DDoS protection by', 'Ray ID:',\n    'Cloudflare Ray ID:', '_cf_chl', '_cf_chl_opt', '__cf_chl_rt_tk',\n    'cf-spinner-please-wait', 'cf-spinner-redirecting']\nif code in [403, 503] and server == 'cloudflare':", "successors": [{"id": 46, "label": "#46\nhtml = resp.text\nflags_found = [(flag in html) for flag in cloudflare_flags]\nany_flag_found = any(flags_found)\nif any_flag_found:", "successors": [{"id": 48, "label": "#48\nreturn True", "successors": []}, {"id": 47, "label": "#47\nreturn False", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "check_if_link_is_working", "type": "CFG", "blocks": [{"id": 54, "label": "#54\n\"\"\"Checks if a link is working.\n\n    If an error is identified when the request for the link occurs,\n    the return will be a tuple with the first value True and the second\n    value a string containing the error message.\n\n    If no errors are identified, the return will be a tuple with the\n    first value False and the second an empty string.\n    \"\"\"\nhas_error = False\nerror_message = ''\ntry:", "successors": [{"id": 55, "label": "#55\nresp = requests.get(link, timeout=25, headers={'User-Agent':\n    fake_user_agent(), 'host': get_host_from_link(link)})\ncode = resp.status_code\nif code >= 400 and not has_cloudflare_protection(resp):", "successors": [{"id": 62, "label": "#62\nhas_error = True\nerror_message = f'ERR:CLT: {code} : {link}'", "successors": [{"id": 61, "label": "#61\nreturn has_error, error_message", "successors": []}]}]}, {"id": 56, "label": "#56\nhas_error = True\nerror_message = f'ERR:SSL: {error} : {link}'", "successors": []}, {"id": 57, "label": "#57\nhas_error = True\nerror_message = f'ERR:CNT: {error} : {link}'", "successors": []}, {"id": 58, "label": "#58\nhas_error = True\nerror_message = f'ERR:TMO: {link}'", "successors": []}, {"id": 59, "label": "#59\nhas_error = True\nerror_message = f'ERR:TMR: {error} : {link}'", "successors": []}, {"id": 60, "label": "#60\nhas_error = True\nerror_message = f'ERR:UKN: {error} : {link}'", "successors": []}]}], "functions": [], "classes": []}, {"name": "check_if_list_of_links_are_working", "type": "CFG", "blocks": [{"id": 67, "label": "#67\nerror_messages = []", "successors": [{"id": 68, "label": "#68\nfor link in list_of_links:", "successors": [{"id": 69, "label": "#69\nhas_error, error_message = check_if_link_is_working(link)\nif has_error:", "successors": [{"id": 71, "label": "#71\nerror_messages.append(error_message)", "successors": []}]}, {"id": 70, "label": "#70\nreturn error_messages", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "start_duplicate_links_checker", "type": "CFG", "blocks": [{"id": 76, "label": "#76\nhas_duplicate_link, duplicates_links = check_duplicate_links(links)\nif has_duplicate_link:", "successors": [{"id": 77, "label": "#77\nprint(f'Found duplicate links:')", "successors": [{"id": 80, "label": "#80\nfor duplicate_link in duplicates_links:", "successors": [{"id": 81, "label": "#81\nprint(duplicate_link)", "successors": []}, {"id": 82, "label": "#82\nsys.exit(1)", "successors": []}]}]}, {"id": 79, "label": "#79\nprint('No duplicate links.')", "successors": []}]}], "functions": [], "classes": []}, {"name": "start_links_working_checker", "type": "CFG", "blocks": [{"id": 85, "label": "#85\nerrors = check_if_list_of_links_are_working(links)\nif errors:", "successors": [{"id": 86, "label": "#86\nnum_errors = len(errors)\nprint(f'Apparently {num_errors} links are not working properly. See in:')", "successors": [{"id": 88, "label": "#88\nfor error_message in errors:", "successors": [{"id": 89, "label": "#89\nprint(error_message)", "successors": []}, {"id": 90, "label": "#90\nsys.exit(1)", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "main", "type": "CFG", "blocks": [{"id": 93, "label": "#93\nlinks = find_links_in_file(filename)\nstart_duplicate_links_checker(links)\nif not only_duplicate_links_checker:", "successors": [{"id": 94, "label": "#94\nstart_links_working_checker(links)", "successors": []}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "31.json", "name": "31.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nif __name__ == '__main__':", "successors": [{"id": 9, "label": "#9\nimport doctest\ndoctest.testmod()", "successors": []}]}], "functions": [{"name": "excess_3_code", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"\n    Find excess-3 code of integer base 10.\n    Add 3 to all digits in a decimal number then convert to a binary-coded decimal.\n    https://en.wikipedia.org/wiki/Excess-3\n\n    >>> excess_3_code(0)\n    '0b0011'\n    >>> excess_3_code(3)\n    '0b0110'\n    >>> excess_3_code(2)\n    '0b0101'\n    >>> excess_3_code(20)\n    '0b01010011'\n    >>> excess_3_code(120)\n    '0b010001010011'\n    \"\"\"\nnum = ''", "successors": [{"id": 4, "label": "#4\nfor digit in str(max(0, number)):", "successors": [{"id": 5, "label": "#5\nnum += str(bin(int(digit) + 3))[2:].zfill(4)", "successors": []}, {"id": 6, "label": "#6\nreturn '0b' + num", "successors": []}]}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "32.json", "name": "32.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport datetime\nimport autogpt_libs.auth.depends\nimport autogpt_libs.auth.middleware\nimport fastapi\nimport fastapi.testclient\nimport prisma.enums\nimport pytest_mock\nimport backend.server.v2.store.model\nimport backend.server.v2.store.routes\napp = fastapi.FastAPI()\napp.include_router(backend.server.v2.store.routes.router)\nclient = fastapi.testclient.TestClient(app)\napp.dependency_overrides[autogpt_libs.auth.middleware.auth_middleware\n    ] = override_auth_middleware\napp.dependency_overrides[autogpt_libs.auth.depends.get_user_id\n    ] = override_get_user_id", "successors": []}], "functions": [{"name": "override_auth_middleware", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"Override auth middleware for testing\"\"\"\nreturn {'sub': 'test-user-id'}", "successors": []}], "functions": [], "classes": []}, {"name": "override_get_user_id", "type": "CFG", "blocks": [{"id": 7, "label": "#7\n\"\"\"Override get_user_id for testing\"\"\"\nreturn 'test-user-id'", "successors": []}], "functions": [], "classes": []}, {"name": "test_get_agents_defaults", "type": "CFG", "blocks": [{"id": 11, "label": "#11\nmocked_value = backend.server.v2.store.model.StoreAgentsResponse(agents=[],\n    pagination=backend.server.v2.store.model.Pagination(current_page=0,\n    total_items=0, total_pages=0, page_size=10))\nmock_db_call = mocker.patch('backend.server.v2.store.db.get_store_agents')\nmock_db_call.return_value = mocked_value\nresponse = client.get('/agents')\nassert response.status_code == 200", "successors": [{"id": 13, "label": "#13\ndata = backend.server.v2.store.model.StoreAgentsResponse.model_validate(\n    response.json())\nassert data.pagination.total_pages == 0", "successors": [{"id": 15, "label": "#15\nassert data.agents == []", "successors": [{"id": 17, "label": "#17\nmock_db_call.assert_called_once_with(featured=False, creator=None,\n    sorted_by=None, search_query=None, category=None, page=1, page_size=20)", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "test_get_agents_featured", "type": "CFG", "blocks": [{"id": 20, "label": "#20\nmocked_value = backend.server.v2.store.model.StoreAgentsResponse(agents=[\n    backend.server.v2.store.model.StoreAgent(slug='featured-agent',\n    agent_name='Featured Agent', agent_image='featured.jpg', creator=\n    'creator1', creator_avatar='avatar1.jpg', sub_heading=\n    'Featured agent subheading', description='Featured agent description',\n    runs=100, rating=4.5)], pagination=backend.server.v2.store.model.\n    Pagination(current_page=1, total_items=1, total_pages=1, page_size=20))\nmock_db_call = mocker.patch('backend.server.v2.store.db.get_store_agents')\nmock_db_call.return_value = mocked_value\nresponse = client.get('/agents?featured=true')\nassert response.status_code == 200", "successors": [{"id": 22, "label": "#22\ndata = backend.server.v2.store.model.StoreAgentsResponse.model_validate(\n    response.json())\nassert len(data.agents) == 1", "successors": [{"id": 24, "label": "#24\nassert data.agents[0].slug == 'featured-agent'", "successors": [{"id": 26, "label": "#26\nmock_db_call.assert_called_once_with(featured=True, creator=None, sorted_by\n    =None, search_query=None, category=None, page=1, page_size=20)", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "test_get_agents_by_creator", "type": "CFG", "blocks": [{"id": 29, "label": "#29\nmocked_value = backend.server.v2.store.model.StoreAgentsResponse(agents=[\n    backend.server.v2.store.model.StoreAgent(slug='creator-agent',\n    agent_name='Creator Agent', agent_image='agent.jpg', creator=\n    'specific-creator', creator_avatar='avatar.jpg', sub_heading=\n    'Creator agent subheading', description='Creator agent description',\n    runs=50, rating=4.0)], pagination=backend.server.v2.store.model.\n    Pagination(current_page=1, total_items=1, total_pages=1, page_size=20))\nmock_db_call = mocker.patch('backend.server.v2.store.db.get_store_agents')\nmock_db_call.return_value = mocked_value\nresponse = client.get('/agents?creator=specific-creator')\nassert response.status_code == 200", "successors": [{"id": 31, "label": "#31\ndata = backend.server.v2.store.model.StoreAgentsResponse.model_validate(\n    response.json())\nassert len(data.agents) == 1", "successors": [{"id": 33, "label": "#33\nassert data.agents[0].creator == 'specific-creator'", "successors": [{"id": 35, "label": "#35\nmock_db_call.assert_called_once_with(featured=False, creator=\n    'specific-creator', sorted_by=None, search_query=None, category=None,\n    page=1, page_size=20)", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "test_get_agents_sorted", "type": "CFG", "blocks": [{"id": 38, "label": "#38\nmocked_value = backend.server.v2.store.model.StoreAgentsResponse(agents=[\n    backend.server.v2.store.model.StoreAgent(slug='top-agent', agent_name=\n    'Top Agent', agent_image='top.jpg', creator='creator1', creator_avatar=\n    'avatar1.jpg', sub_heading='Top agent subheading', description=\n    'Top agent description', runs=1000, rating=5.0)], pagination=backend.\n    server.v2.store.model.Pagination(current_page=1, total_items=1,\n    total_pages=1, page_size=20))\nmock_db_call = mocker.patch('backend.server.v2.store.db.get_store_agents')\nmock_db_call.return_value = mocked_value\nresponse = client.get('/agents?sorted_by=runs')\nassert response.status_code == 200", "successors": [{"id": 40, "label": "#40\ndata = backend.server.v2.store.model.StoreAgentsResponse.model_validate(\n    response.json())\nassert len(data.agents) == 1", "successors": [{"id": 42, "label": "#42\nassert data.agents[0].runs == 1000", "successors": [{"id": 44, "label": "#44\nmock_db_call.assert_called_once_with(featured=False, creator=None,\n    sorted_by='runs', search_query=None, category=None, page=1, page_size=20)", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "test_get_agents_search", "type": "CFG", "blocks": [{"id": 47, "label": "#47\nmocked_value = backend.server.v2.store.model.StoreAgentsResponse(agents=[\n    backend.server.v2.store.model.StoreAgent(slug='search-agent',\n    agent_name='Search Agent', agent_image='search.jpg', creator='creator1',\n    creator_avatar='avatar1.jpg', sub_heading='Search agent subheading',\n    description='Specific search term description', runs=75, rating=4.2)],\n    pagination=backend.server.v2.store.model.Pagination(current_page=1,\n    total_items=1, total_pages=1, page_size=20))\nmock_db_call = mocker.patch('backend.server.v2.store.db.get_store_agents')\nmock_db_call.return_value = mocked_value\nresponse = client.get('/agents?search_query=specific')\nassert response.status_code == 200", "successors": [{"id": 49, "label": "#49\ndata = backend.server.v2.store.model.StoreAgentsResponse.model_validate(\n    response.json())\nassert len(data.agents) == 1", "successors": [{"id": 51, "label": "#51\nassert 'specific' in data.agents[0].description.lower()", "successors": [{"id": 53, "label": "#53\nmock_db_call.assert_called_once_with(featured=False, creator=None,\n    sorted_by=None, search_query='specific', category=None, page=1,\n    page_size=20)", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "test_get_agents_category", "type": "CFG", "blocks": [{"id": 56, "label": "#56\nmocked_value = backend.server.v2.store.model.StoreAgentsResponse(agents=[\n    backend.server.v2.store.model.StoreAgent(slug='category-agent',\n    agent_name='Category Agent', agent_image='category.jpg', creator=\n    'creator1', creator_avatar='avatar1.jpg', sub_heading=\n    'Category agent subheading', description='Category agent description',\n    runs=60, rating=4.1)], pagination=backend.server.v2.store.model.\n    Pagination(current_page=1, total_items=1, total_pages=1, page_size=20))\nmock_db_call = mocker.patch('backend.server.v2.store.db.get_store_agents')\nmock_db_call.return_value = mocked_value\nresponse = client.get('/agents?category=test-category')\nassert response.status_code == 200", "successors": [{"id": 58, "label": "#58\ndata = backend.server.v2.store.model.StoreAgentsResponse.model_validate(\n    response.json())\nassert len(data.agents) == 1", "successors": [{"id": 60, "label": "#60\nmock_db_call.assert_called_once_with(featured=False, creator=None,\n    sorted_by=None, search_query=None, category='test-category', page=1,\n    page_size=20)", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "test_get_agents_pagination", "type": "CFG", "blocks": [{"id": 63, "label": "#63\nmocked_value = backend.server.v2.store.model.StoreAgentsResponse(agents=[\n    backend.server.v2.store.model.StoreAgent(slug=f'agent-{i}', agent_name=\n    f'Agent {i}', agent_image=f'agent{i}.jpg', creator='creator1',\n    creator_avatar='avatar1.jpg', sub_heading=f'Agent {i} subheading',\n    description=f'Agent {i} description', runs=i * 10, rating=4.0) for i in\n    range(5)], pagination=backend.server.v2.store.model.Pagination(\n    current_page=2, total_items=15, total_pages=3, page_size=5))\nmock_db_call = mocker.patch('backend.server.v2.store.db.get_store_agents')\nmock_db_call.return_value = mocked_value\nresponse = client.get('/agents?page=2&page_size=5')\nassert response.status_code == 200", "successors": [{"id": 65, "label": "#65\ndata = backend.server.v2.store.model.StoreAgentsResponse.model_validate(\n    response.json())\nassert len(data.agents) == 5", "successors": [{"id": 67, "label": "#67\nassert data.pagination.current_page == 2", "successors": [{"id": 69, "label": "#69\nassert data.pagination.page_size == 5", "successors": [{"id": 71, "label": "#71\nmock_db_call.assert_called_once_with(featured=False, creator=None,\n    sorted_by=None, search_query=None, category=None, page=2, page_size=5)", "successors": []}]}]}]}]}], "functions": [], "classes": []}, {"name": "test_get_agents_malformed_request", "type": "CFG", "blocks": [{"id": 74, "label": "#74\nresponse = client.get('/agents?page=-1')\nassert response.status_code == 422", "successors": [{"id": 76, "label": "#76\nresponse = client.get('/agents?page_size=0')\nassert response.status_code == 422", "successors": [{"id": 78, "label": "#78\nresponse = client.get('/agents?page=abc&page_size=def')\nassert response.status_code == 422", "successors": [{"id": 80, "label": "#80\nmock_db_call = mocker.patch('backend.server.v2.store.db.get_store_agents')\nmock_db_call.assert_not_called()", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "test_get_agent_details", "type": "CFG", "blocks": [{"id": 83, "label": "#83\nmocked_value = backend.server.v2.store.model.StoreAgentDetails(\n    store_listing_version_id='test-version-id', slug='test-agent',\n    agent_name='Test Agent', agent_video='video.mp4', agent_image=[\n    'image1.jpg', 'image2.jpg'], creator='creator1', creator_avatar=\n    'avatar1.jpg', sub_heading='Test agent subheading', description=\n    'Test agent description', categories=['category1', 'category2'], runs=\n    100, rating=4.5, versions=['1.0.0', '1.1.0'], last_updated=datetime.\n    datetime.now())\nmock_db_call = mocker.patch(\n    'backend.server.v2.store.db.get_store_agent_details')\nmock_db_call.return_value = mocked_value\nresponse = client.get('/agents/creator1/test-agent')\nassert response.status_code == 200", "successors": [{"id": 85, "label": "#85\ndata = backend.server.v2.store.model.StoreAgentDetails.model_validate(response\n    .json())\nassert data.agent_name == 'Test Agent'", "successors": [{"id": 87, "label": "#87\nassert data.creator == 'creator1'", "successors": [{"id": 89, "label": "#89\nmock_db_call.assert_called_once_with(username='creator1', agent_name=\n    'test-agent')", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "test_get_creators_defaults", "type": "CFG", "blocks": [{"id": 92, "label": "#92\nmocked_value = backend.server.v2.store.model.CreatorsResponse(creators=[],\n    pagination=backend.server.v2.store.model.Pagination(current_page=0,\n    total_items=0, total_pages=0, page_size=10))\nmock_db_call = mocker.patch('backend.server.v2.store.db.get_store_creators')\nmock_db_call.return_value = mocked_value\nresponse = client.get('/creators')\nassert response.status_code == 200", "successors": [{"id": 94, "label": "#94\ndata = backend.server.v2.store.model.CreatorsResponse.model_validate(response\n    .json())\nassert data.pagination.total_pages == 0", "successors": [{"id": 96, "label": "#96\nassert data.creators == []", "successors": [{"id": 98, "label": "#98\nmock_db_call.assert_called_once_with(featured=False, search_query=None,\n    sorted_by=None, page=1, page_size=20)", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "test_get_creators_pagination", "type": "CFG", "blocks": [{"id": 101, "label": "#101\nmocked_value = backend.server.v2.store.model.CreatorsResponse(creators=[\n    backend.server.v2.store.model.Creator(name=f'Creator {i}', username=\n    f'creator{i}', description=f'Creator {i} description', avatar_url=\n    f'avatar{i}.jpg', num_agents=1, agent_rating=4.5, agent_runs=100,\n    is_featured=False) for i in range(5)], pagination=backend.server.v2.\n    store.model.Pagination(current_page=2, total_items=15, total_pages=3,\n    page_size=5))\nmock_db_call = mocker.patch('backend.server.v2.store.db.get_store_creators')\nmock_db_call.return_value = mocked_value\nresponse = client.get('/creators?page=2&page_size=5')\nassert response.status_code == 200", "successors": [{"id": 103, "label": "#103\ndata = backend.server.v2.store.model.CreatorsResponse.model_validate(response\n    .json())\nassert len(data.creators) == 5", "successors": [{"id": 105, "label": "#105\nassert data.pagination.current_page == 2", "successors": [{"id": 107, "label": "#107\nassert data.pagination.page_size == 5", "successors": [{"id": 109, "label": "#109\nmock_db_call.assert_called_once_with(featured=False, search_query=None,\n    sorted_by=None, page=2, page_size=5)", "successors": []}]}]}]}]}], "functions": [], "classes": []}, {"name": "test_get_creators_malformed_request", "type": "CFG", "blocks": [{"id": 112, "label": "#112\nresponse = client.get('/creators?page=-1')\nassert response.status_code == 422", "successors": [{"id": 114, "label": "#114\nresponse = client.get('/creators?page_size=0')\nassert response.status_code == 422", "successors": [{"id": 116, "label": "#116\nresponse = client.get('/creators?page=abc&page_size=def')\nassert response.status_code == 422", "successors": [{"id": 118, "label": "#118\nmock_db_call = mocker.patch('backend.server.v2.store.db.get_store_creators')\nmock_db_call.assert_not_called()", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "test_get_creator_details", "type": "CFG", "blocks": [{"id": 121, "label": "#121\nmocked_value = backend.server.v2.store.model.CreatorDetails(name=\n    'Test User', username='creator1', description=\n    'Test creator description', links=['link1.com', 'link2.com'],\n    avatar_url='avatar.jpg', agent_rating=4.8, agent_runs=1000,\n    top_categories=['category1', 'category2'])\nmock_db_call = mocker.patch(\n    'backend.server.v2.store.db.get_store_creator_details')\nmock_db_call.return_value = mocked_value\nresponse = client.get('/creator/creator1')\nassert response.status_code == 200", "successors": [{"id": 123, "label": "#123\ndata = backend.server.v2.store.model.CreatorDetails.model_validate(response\n    .json())\nassert data.username == 'creator1'", "successors": [{"id": 125, "label": "#125\nassert data.name == 'Test User'", "successors": [{"id": 127, "label": "#127\nmock_db_call.assert_called_once_with(username='creator1')", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "test_get_submissions_success", "type": "CFG", "blocks": [{"id": 130, "label": "#130\nmocked_value = backend.server.v2.store.model.StoreSubmissionsResponse(\n    submissions=[backend.server.v2.store.model.StoreSubmission(name=\n    'Test Agent', description='Test agent description', image_urls=[\n    'test.jpg'], date_submitted=datetime.datetime.now(), status=prisma.\n    enums.SubmissionStatus.APPROVED, runs=50, rating=4.2, agent_id=\n    'test-agent-id', agent_version=1, sub_heading='Test agent subheading',\n    slug='test-agent')], pagination=backend.server.v2.store.model.\n    Pagination(current_page=1, total_items=1, total_pages=1, page_size=20))\nmock_db_call = mocker.patch('backend.server.v2.store.db.get_store_submissions')\nmock_db_call.return_value = mocked_value\nresponse = client.get('/submissions')\nassert response.status_code == 200", "successors": [{"id": 132, "label": "#132\ndata = backend.server.v2.store.model.StoreSubmissionsResponse.model_validate(\n    response.json())\nassert len(data.submissions) == 1", "successors": [{"id": 134, "label": "#134\nassert data.submissions[0].name == 'Test Agent'", "successors": [{"id": 136, "label": "#136\nassert data.pagination.current_page == 1", "successors": [{"id": 138, "label": "#138\nmock_db_call.assert_called_once_with(user_id='test-user-id', page=1,\n    page_size=20)", "successors": []}]}]}]}]}], "functions": [], "classes": []}, {"name": "test_get_submissions_pagination", "type": "CFG", "blocks": [{"id": 141, "label": "#141\nmocked_value = backend.server.v2.store.model.StoreSubmissionsResponse(\n    submissions=[], pagination=backend.server.v2.store.model.Pagination(\n    current_page=2, total_items=10, total_pages=2, page_size=5))\nmock_db_call = mocker.patch('backend.server.v2.store.db.get_store_submissions')\nmock_db_call.return_value = mocked_value\nresponse = client.get('/submissions?page=2&page_size=5')\nassert response.status_code == 200", "successors": [{"id": 143, "label": "#143\ndata = backend.server.v2.store.model.StoreSubmissionsResponse.model_validate(\n    response.json())\nassert data.pagination.current_page == 2", "successors": [{"id": 145, "label": "#145\nassert data.pagination.page_size == 5", "successors": [{"id": 147, "label": "#147\nmock_db_call.assert_called_once_with(user_id='test-user-id', page=2,\n    page_size=5)", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "test_get_submissions_malformed_request", "type": "CFG", "blocks": [{"id": 150, "label": "#150\nresponse = client.get('/submissions?page=-1')\nassert response.status_code == 422", "successors": [{"id": 152, "label": "#152\nresponse = client.get('/submissions?page_size=0')\nassert response.status_code == 422", "successors": [{"id": 154, "label": "#154\nresponse = client.get('/submissions?page=abc&page_size=def')\nassert response.status_code == 422", "successors": [{"id": 156, "label": "#156\nmock_db_call = mocker.patch('backend.server.v2.store.db.get_store_submissions')\nmock_db_call.assert_not_called()", "successors": []}]}]}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "33.json", "name": "33.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport codecs\nfrom backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema\nfrom backend.data.model import SchemaField", "successors": []}], "functions": [], "classes": [{"name": "TextDecoderBlock", "type": "CFG", "blocks": [{"id": 3, "label": "#3", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 11, "label": "#11\nsuper().__init__(id='2570e8fe-8447-43ed-84c7-70d657923231', description=\n    'Decodes a string containing escape sequences into actual text',\n    categories={BlockCategory.TEXT}, input_schema=TextDecoderBlock.Input,\n    output_schema=TextDecoderBlock.Output, test_input={'text':\n    \"\"\"Hello\nWorld!\nThis is a \"quoted\" string.\"\"\"}, test_output=[(\n    'decoded_text', \"\"\"Hello\nWorld!\nThis is a \"quoted\" string.\"\"\")])", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 14, "label": "#14\ndecoded_text = codecs.decode(input_data.text, 'unicode_escape')\nyield 'decoded_text', decoded_text", "successors": []}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 5, "label": "#5\ntext: str = SchemaField(description=\n    'A string containing escaped characters to be decoded', placeholder=\n    'Your entire text block with \\\\n and \\\\\" escaped characters')", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 8, "label": "#8\ndecoded_text: str = SchemaField(description=\n    'The decoded text with escape sequences processed')", "successors": []}], "functions": [], "classes": []}]}]}
{"file_name": "34.json", "name": "34.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom functools import wraps\nfrom typing import Any, Callable, Concatenate, Coroutine, ParamSpec, TypeVar, cast\nfrom backend.data.credit import get_user_credit_model\nfrom backend.data.execution import ExecutionResult, RedisExecutionEventBus, create_graph_execution, get_execution_results, get_incomplete_executions, get_latest_execution, update_execution_status, update_graph_execution_stats, update_node_execution_stats, upsert_execution_input, upsert_execution_output\nfrom backend.data.graph import get_graph, get_node\nfrom backend.data.user import get_user_integrations, get_user_metadata, update_user_integrations, update_user_metadata\nfrom backend.util.service import AppService, expose, register_pydantic_serializers\nfrom backend.util.settings import Config\nP = ParamSpec('P')\nR = TypeVar('R')\nconfig = Config()", "successors": []}], "functions": [], "classes": [{"name": "DatabaseManager", "type": "CFG", "blocks": [{"id": 3, "label": "#3\ncreate_graph_execution = exposed_run_and_wait(create_graph_execution)\nget_execution_results = exposed_run_and_wait(get_execution_results)\nget_incomplete_executions = exposed_run_and_wait(get_incomplete_executions)\nget_latest_execution = exposed_run_and_wait(get_latest_execution)\nupdate_execution_status = exposed_run_and_wait(update_execution_status)\nupdate_graph_execution_stats = exposed_run_and_wait(\n    update_graph_execution_stats)\nupdate_node_execution_stats = exposed_run_and_wait(update_node_execution_stats)\nupsert_execution_input = exposed_run_and_wait(upsert_execution_input)\nupsert_execution_output = exposed_run_and_wait(upsert_execution_output)\nget_node = exposed_run_and_wait(get_node)\nget_graph = exposed_run_and_wait(get_graph)\nuser_credit_model = get_user_credit_model()\nget_or_refill_credit = cast(Callable[[Any, str], int], exposed_run_and_wait\n    (user_credit_model.get_or_refill_credit))\nspend_credits = cast(Callable[[Any, str, int, str, dict[str, str], float,\n    float], int], exposed_run_and_wait(user_credit_model.spend_credits))\nget_user_metadata = exposed_run_and_wait(get_user_metadata)\nupdate_user_metadata = exposed_run_and_wait(update_user_metadata)\nget_user_integrations = exposed_run_and_wait(get_user_integrations)\nupdate_user_integrations = exposed_run_and_wait(update_user_integrations)", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 5, "label": "#5\nsuper().__init__()\nself.use_db = True\nself.use_redis = True\nself.event_queue = RedisExecutionEventBus()", "successors": []}], "functions": [], "classes": []}, {"name": "get_port", "type": "CFG", "blocks": [{"id": 8, "label": "#8\nreturn config.database_api_port", "successors": []}], "functions": [], "classes": []}, {"name": "send_execution_update", "type": "CFG", "blocks": [{"id": 12, "label": "#12\nself.event_queue.publish(execution_result)", "successors": []}], "functions": [], "classes": []}, {"name": "exposed_run_and_wait", "type": "CFG", "blocks": [{"id": 15, "label": "#15\nregister_pydantic_serializers(f)\nreturn wrapper", "successors": []}], "functions": [{"name": "wrapper", "type": "CFG", "blocks": [{"id": 17, "label": "#17\ncoroutine = f(*args, **kwargs)\nres = self.run_and_wait(coroutine)\nreturn res", "successors": []}], "functions": [], "classes": []}], "classes": []}], "classes": []}]}
{"file_name": "35.json", "name": "35.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom backend.util.type import convert", "successors": []}], "functions": [{"name": "test_type_conversion", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nassert convert(5.5, int) == 5", "successors": [{"id": 5, "label": "#5\nassert convert('5.5', int) == 5", "successors": [{"id": 7, "label": "#7\nassert convert([1, 2, 3], int) == 3", "successors": [{"id": 9, "label": "#9\nassert convert('5.5', float) == 5.5", "successors": [{"id": 11, "label": "#11\nassert convert(5, float) == 5.0", "successors": [{"id": 13, "label": "#13\nassert convert('True', bool) is True", "successors": [{"id": 15, "label": "#15\nassert convert('False', bool) is False", "successors": [{"id": 17, "label": "#17\nassert convert(5, str) == '5'", "successors": [{"id": 19, "label": "#19\nassert convert({'a': 1, 'b': 2}, str) == '{\"a\": 1, \"b\": 2}'", "successors": [{"id": 21, "label": "#21\nassert convert([1, 2, 3], str) == '[1, 2, 3]'", "successors": [{"id": 23, "label": "#23\nassert convert('5', list) == ['5']", "successors": [{"id": 25, "label": "#25\nassert convert((1, 2, 3), list) == [1, 2, 3]", "successors": [{"id": 27, "label": "#27\nassert convert({1, 2, 3}, list) == [1, 2, 3]", "successors": [{"id": 29, "label": "#29\nassert convert('5', dict) == {'value': 5}", "successors": [{"id": 31, "label": "#31\nassert convert('{\"a\": 1, \"b\": 2}', dict) == {'a': 1, 'b': 2}", "successors": [{"id": 33, "label": "#33\nassert convert([1, 2, 3], dict) == {(0): 1, (1): 2, (2): 3}", "successors": [{"id": 35, "label": "#35\nassert convert((1, 2, 3), dict) == {(0): 1, (1): 2, (2): 3}", "successors": [{"id": 37, "label": "#37\nfrom typing import List\nassert convert('5', List[int]) == [5]", "successors": [{"id": 39, "label": "#39\nassert convert('[5,4,2]', List[int]) == [5, 4, 2]", "successors": [{"id": 41, "label": "#41\nassert convert([5, 4, 2], List[str]) == ['5', '4', '2']", "successors": []}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "36.json", "name": "36.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom math import log2\nif __name__ == '__main__':", "successors": [{"id": 13, "label": "#13\nimport doctest\ndoctest.testmod()", "successors": []}]}], "functions": [{"name": "binary_count_trailing_zeros", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"\n    Take in 1 integer, return a number that is\n    the number of trailing zeros in binary representation of that number.\n\n    >>> binary_count_trailing_zeros(25)\n    0\n    >>> binary_count_trailing_zeros(36)\n    2\n    >>> binary_count_trailing_zeros(16)\n    4\n    >>> binary_count_trailing_zeros(58)\n    1\n    >>> binary_count_trailing_zeros(4294967296)\n    32\n    >>> binary_count_trailing_zeros(0)\n    0\n    >>> binary_count_trailing_zeros(-10)\n    Traceback (most recent call last):\n    ValueError: Input value must be a positive integer\n    >>> binary_count_trailing_zeros(0.8)\n    Traceback (most recent call last):\n    TypeError: Input value must be a 'int' type\n    >>> binary_count_trailing_zeros(\"0\")\n    Traceback (most recent call last):\n    TypeError: '<' not supported between instances of 'str' and 'int'\n    \"\"\"\nif a < 0:", "successors": [{"id": 4, "label": "#4\nraise ValueError('Input value must be a positive integer')", "successors": []}, {"id": 6, "label": "#6\nif isinstance(a, float):", "successors": [{"id": 7, "label": "#7\nraise TypeError(\"Input value must be a 'int' type\")", "successors": []}, {"id": 5, "label": "#5\nreturn 0 if a == 0 else int(log2(a & -a))", "successors": []}]}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "37.json", "name": "37.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom datetime import datetime, timedelta\nfrom backend.blocks.hubspot._auth import HubSpotCredentials, HubSpotCredentialsField, HubSpotCredentialsInput\nfrom backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema\nfrom backend.data.model import SchemaField\nfrom backend.util.request import requests", "successors": []}], "functions": [], "classes": [{"name": "HubSpotEngagementBlock", "type": "CFG", "blocks": [{"id": 3, "label": "#3", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 11, "label": "#11\nsuper().__init__(id='c6524385-7d87-49d6-a470-248bd29ca765', description=\n    'Manages HubSpot engagements - sends emails and tracks engagement metrics',\n    categories={BlockCategory.CRM, BlockCategory.COMMUNICATION},\n    input_schema=HubSpotEngagementBlock.Input, output_schema=\n    HubSpotEngagementBlock.Output)", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 14, "label": "#14\nbase_url = 'https://api.hubapi.com'\nheaders = {'Authorization':\n    f'Bearer {credentials.api_key.get_secret_value()}', 'Content-Type':\n    'application/json'}\nif input_data.operation == 'send_email':", "successors": [{"id": 15, "label": "#15\nemail_url = f'{base_url}/crm/v3/objects/emails'\nemail_data = {'properties': {'hs_timestamp': datetime.now().isoformat(),\n    'hubspot_owner_id': '1', 'hs_email_direction': 'OUTBOUND',\n    'hs_email_status': 'SEND', 'hs_email_subject': input_data.email_data.\n    get('subject'), 'hs_email_text': input_data.email_data.get('content'),\n    'hs_email_to_email': input_data.email_data.get('recipient')}}\nresponse = requests.post(email_url, headers=headers, json=email_data)\nresult = response.json()\nyield 'result', result", "successors": [{"id": 35, "label": "#35\nyield 'status', 'email_sent'", "successors": []}]}, {"id": 17, "label": "#17\nif input_data.operation == 'track_engagement':", "successors": [{"id": 18, "label": "#18\nfrom_date = datetime.now() - timedelta(days=input_data.timeframe_days)\nengagement_url = (\n    f'{base_url}/crm/v3/objects/contacts/{input_data.contact_id}/engagement')\nparams = {'limit': 100, 'after': from_date.isoformat()}\nresponse = requests.get(engagement_url, headers=headers, params=params)\nengagements = response.json()\nmetrics = {'email_opens': 0, 'email_clicks': 0, 'email_replies': 0,\n    'last_engagement': None, 'engagement_score': 0}", "successors": [{"id": 20, "label": "#20\nfor engagement in engagements.get('results', []):", "successors": [{"id": 21, "label": "#21\neng_type = engagement.get('properties', {}).get('hs_engagement_type')\nif eng_type == 'EMAIL':", "successors": [{"id": 23, "label": "#23\nmetrics['email_opens'] += 1", "successors": [{"id": 24, "label": "#24\neng_time = engagement.get('properties', {}).get('hs_timestamp')\nif eng_time and (not metrics['last_engagement'] or eng_time > metrics[", "successors": [{"id": 31, "label": "#31\nmetrics['last_engagement'] = eng_time", "successors": []}]}]}, {"id": 25, "label": "#25\nif eng_type == 'EMAIL_CLICK':", "successors": [{"id": 26, "label": "#26\nmetrics['email_clicks'] += 1", "successors": []}, {"id": 28, "label": "#28\nif eng_type == 'EMAIL_REPLY':", "successors": [{"id": 29, "label": "#29\nmetrics['email_replies'] += 1", "successors": []}]}]}]}, {"id": 22, "label": "#22\nmetrics['engagement_score'] = metrics['email_opens'] + metrics['email_clicks'\n    ] * 2 + metrics['email_replies'] * 3\nyield 'result', metrics", "successors": [{"id": 33, "label": "#33\nyield 'status', 'engagement_tracked'", "successors": []}]}]}]}]}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 5, "label": "#5\ncredentials: HubSpotCredentialsInput = HubSpotCredentialsField()\noperation: str = SchemaField(description=\n    'Operation to perform (send_email, track_engagement)', default='send_email'\n    )\nemail_data: dict = SchemaField(description=\n    'Email data including recipient, subject, content', default={})\ncontact_id: str = SchemaField(description=\n    'Contact ID for engagement tracking', default='')\ntimeframe_days: int = SchemaField(description=\n    'Number of days to look back for engagement', default=30, optional=True)", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 8, "label": "#8\nresult: dict = SchemaField(description='Operation result')\nstatus: str = SchemaField(description='Operation status')", "successors": []}], "functions": [], "classes": []}]}]}
{"file_name": "38.json", "name": "38.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport asyncio\nimport logging\nimport uuid\nfrom collections import defaultdict\nfrom datetime import datetime, timezone\nfrom typing import Any, Literal, Optional, Type\nimport prisma\nfrom prisma.models import AgentGraph, AgentGraphExecution, AgentNode, AgentNodeLink\nfrom prisma.types import AgentGraphWhereInput\nfrom pydantic.fields import computed_field\nfrom backend.blocks.agent import AgentExecutorBlock\nfrom backend.blocks.basic import AgentInputBlock, AgentOutputBlock\nfrom backend.util import json\nfrom .block import BlockInput, BlockType, get_block, get_blocks\nfrom .db import BaseDbModel, transaction\nfrom .execution import ExecutionStatus\nfrom .includes import AGENT_GRAPH_INCLUDE, AGENT_NODE_INCLUDE\nfrom .integrations import Webhook\nlogger = logging.getLogger(__name__)\nWebhook.model_rebuild()", "successors": []}], "functions": [{"name": "get_node", "type": "CFG", "blocks": [{"id": 176, "label": "#176\nnode = await AgentNode.prisma().find_unique_or_raise(where={'id': node_id},\n    include=AGENT_NODE_INCLUDE)", "successors": [{"id": 177, "label": "#177\nreturn NodeModel.from_db(node)", "successors": []}]}], "functions": [], "classes": []}, {"name": "set_node_webhook", "type": "CFG", "blocks": [{"id": 181, "label": "#181\nnode = await AgentNode.prisma().update(where={'id': node_id}, data={\n    'Webhook': {'connect': {'id': webhook_id}}} if webhook_id else {\n    'Webhook': {'disconnect': True}}, include=AGENT_NODE_INCLUDE)", "successors": [{"id": 182, "label": "#182\nif not node:", "successors": [{"id": 183, "label": "#183\nraise ValueError(f'Node #{node_id} not found')", "successors": []}, {"id": 184, "label": "#184\nreturn NodeModel.from_db(node)", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "get_graphs", "type": "CFG", "blocks": [{"id": 189, "label": "#189\n\"\"\"\n    Retrieves graph metadata objects.\n    Default behaviour is to get all currently active graphs.\n\n    Args:\n        filter_by: An optional filter to either select templates or active graphs.\n        user_id: The ID of the user that owns the graph.\n\n    Returns:\n        list[GraphModel]: A list of objects representing the retrieved graphs.\n    \"\"\"\nwhere_clause: AgentGraphWhereInput = {'userId': user_id}\nif filter_by == 'active':", "successors": [{"id": 190, "label": "#190\nwhere_clause['isActive'] = True", "successors": [{"id": 191, "label": "#191\ngraphs = await AgentGraph.prisma().find_many(where=where_clause, distinct=[\n    'id'], order={'version': 'desc'}, include=AGENT_GRAPH_INCLUDE)", "successors": [{"id": 195, "label": "#195\ngraph_models = []", "successors": [{"id": 196, "label": "#196\nfor graph in graphs:", "successors": [{"id": 197, "label": "#197\ntry:", "successors": [{"id": 199, "label": "#199\ngraph_models.append(GraphModel.from_db(graph))", "successors": []}, {"id": 200, "label": "#200\nlogger.error(f'Error processing graph {graph.id}: {e}')", "successors": []}]}, {"id": 198, "label": "#198\nreturn graph_models", "successors": []}]}]}]}]}, {"id": 192, "label": "#192\nif filter_by == 'template':", "successors": [{"id": 193, "label": "#193\nwhere_clause['isTemplate'] = True", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "get_executions", "type": "CFG", "blocks": [{"id": 205, "label": "#205\nexecutions = await AgentGraphExecution.prisma().find_many(where={'userId':\n    user_id}, order={'createdAt': 'desc'})", "successors": [{"id": 206, "label": "#206\nreturn [GraphExecution.from_db(execution) for execution in executions]", "successors": []}]}], "functions": [], "classes": []}, {"name": "get_execution", "type": "CFG", "blocks": [{"id": 210, "label": "#210\nexecution = await AgentGraphExecution.prisma().find_first(where={'id':\n    execution_id, 'userId': user_id})", "successors": [{"id": 211, "label": "#211\nreturn GraphExecution.from_db(execution) if execution else None", "successors": []}]}], "functions": [], "classes": []}, {"name": "get_graph", "type": "CFG", "blocks": [{"id": 215, "label": "#215\n\"\"\"\n    Retrieves a graph from the DB.\n    Defaults to the version with `is_active` if `version` is not passed,\n    or the latest version with `is_template` if `template=True`.\n\n    Returns `None` if the record is not found.\n    \"\"\"\nwhere_clause: AgentGraphWhereInput = {'id': graph_id}\nif version is not None:", "successors": [{"id": 216, "label": "#216\nwhere_clause['version'] = version", "successors": [{"id": 217, "label": "#217\nif user_id is not None and not template:", "successors": [{"id": 221, "label": "#221\nwhere_clause['userId'] = user_id", "successors": [{"id": 222, "label": "#222\ngraph = await AgentGraph.prisma().find_first(where=where_clause, include=\n    AGENT_GRAPH_INCLUDE, order={'version': 'desc'})", "successors": [{"id": 223, "label": "#223\nreturn GraphModel.from_db(graph, for_export) if graph else None", "successors": []}]}]}]}]}, {"id": 218, "label": "#218\nif not template:", "successors": [{"id": 219, "label": "#219\nwhere_clause['isActive'] = True", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "set_graph_active_version", "type": "CFG", "blocks": [{"id": 227, "label": "#227\nupdated_count = await AgentGraph.prisma().update_many(data={'isActive': \n    True}, where={'id': graph_id, 'version': version, 'userId': user_id})", "successors": [{"id": 228, "label": "#228\nif updated_count == 0:", "successors": [{"id": 229, "label": "#229\nraise Exception(f'Graph #{graph_id} v{version} not found or not owned by user')", "successors": []}, {"id": 230, "label": "#230\nawait AgentGraph.prisma().update_many(data={'isActive': False}, where={'id':\n    graph_id, 'version': {'not': version}, 'userId': user_id, 'isActive': True}\n    )", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "get_graph_all_versions", "type": "CFG", "blocks": [{"id": 235, "label": "#235\ngraph_versions = await AgentGraph.prisma().find_many(where={'id': graph_id,\n    'userId': user_id}, order={'version': 'desc'}, include=AGENT_GRAPH_INCLUDE)", "successors": [{"id": 236, "label": "#236\nif not graph_versions:", "successors": [{"id": 237, "label": "#237\nreturn []", "successors": []}, {"id": 238, "label": "#238\nreturn [GraphModel.from_db(graph) for graph in graph_versions]", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "delete_graph", "type": "CFG", "blocks": [{"id": 243, "label": "#243\nentries_count = await AgentGraph.prisma().delete_many(where={'id': graph_id,\n    'userId': user_id})", "successors": [{"id": 244, "label": "#244\nif entries_count:", "successors": [{"id": 245, "label": "#245\nlogger.info(f'Deleted {entries_count} graph entries for Graph #{graph_id}')", "successors": [{"id": 246, "label": "#246\nreturn entries_count", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "create_graph", "type": "CFG", "blocks": [{"id": 250, "label": "#250\nasync with transaction() as tx:\n    await __create_graph(tx, graph, user_id)", "successors": [{"id": 251, "label": "#251\nawait __create_graph(tx, graph, user_id)", "successors": [{"id": 252, "label": "#252\nif (created_graph := await get_graph(graph.id, graph.version, graph.", "successors": [{"id": 254, "label": "#254\nreturn created_graph", "successors": []}, {"id": 255, "label": "#255\nraise ValueError(f'Created graph {graph.id} v{graph.version} is not in DB')", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "__create_graph", "type": "CFG", "blocks": [{"id": 260, "label": "#260\nawait AgentGraph.prisma(tx).create(data={'id': graph.id, 'version': graph.\n    version, 'name': graph.name, 'description': graph.description,\n    'isTemplate': graph.is_template, 'isActive': graph.is_active, 'userId':\n    user_id})", "successors": [{"id": 261, "label": "#261\nawait asyncio.gather(*[AgentNode.prisma(tx).create({'id': node.id,\n    'agentBlockId': node.block_id, 'agentGraphId': graph.id,\n    'agentGraphVersion': graph.version, 'constantInput': json.dumps(node.\n    input_default), 'metadata': json.dumps(node.metadata)}) for node in\n    graph.nodes])", "successors": [{"id": 262, "label": "#262\nawait asyncio.gather(*[AgentNodeLink.prisma(tx).create({'id': str(uuid.\n    uuid4()), 'sourceName': link.source_name, 'sinkName': link.sink_name,\n    'agentNodeSourceId': link.source_id, 'agentNodeSinkId': link.sink_id,\n    'isStatic': link.is_static}) for link in graph.links])", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "make_graph_model", "type": "CFG", "blocks": [{"id": 266, "label": "#266\n\"\"\"\n    Convert a Graph to a GraphModel, setting graph_id and graph_version on all nodes.\n\n    Args:\n        creatable_graph (Graph): The creatable graph to convert.\n        user_id (str): The ID of the user creating the graph.\n\n    Returns:\n        GraphModel: The converted Graph object.\n    \"\"\"\nreturn GraphModel(**creatable_graph.model_dump(exclude={'nodes'}), user_id=\n    user_id, nodes=[NodeModel(**creatable_node.model_dump(), graph_id=\n    creatable_graph.id, graph_version=creatable_graph.version) for\n    creatable_node in creatable_graph.nodes])", "successors": []}], "functions": [], "classes": []}, {"name": "fix_llm_provider_credentials", "type": "CFG", "blocks": [{"id": 270, "label": "#270\n\"\"\"Fix node credentials with provider `llm`\"\"\"\nfrom backend.integrations.credentials_store import IntegrationCredentialsStore\nfrom .user import get_user_integrations\nstore = IntegrationCredentialsStore()\nbroken_nodes = await prisma.get_client().query_raw(\n    \"\"\"\n        SELECT    graph.\"userId\"       user_id,\n                  node.id              node_id,\n                  node.\"constantInput\" node_preset_input\n        FROM      platform.\"AgentNode\"  node\n        LEFT JOIN platform.\"AgentGraph\" graph\n        ON        node.\"agentGraphId\" = graph.id\n        WHERE     node.\"constantInput\"::jsonb->'credentials'->>'provider' = 'llm'\n        ORDER BY  graph.\"userId\";\n        \"\"\"\n    )", "successors": [{"id": 271, "label": "#271\nlogger.info(f'Fixing LLM credential inputs on {len(broken_nodes)} nodes')\nuser_id: str = ''\nuser_integrations = None", "successors": [{"id": 272, "label": "#272\nfor node in broken_nodes:", "successors": [{"id": 273, "label": "#273\nif node['user_id'] != user_id:", "successors": [{"id": 275, "label": "#275\nuser_id = node['user_id']\nuser_integrations = await get_user_integrations(user_id)", "successors": [{"id": 276, "label": "#276\nnode_id: str = node['node_id']\nnode_preset_input: dict = json.loads(node['node_preset_input'])\ncredentials_meta: dict = node_preset_input['credentials']\ncredentials = next((c for c in user_integrations.credentials if c.id ==\n    credentials_meta['id']), None)\nif not credentials:", "successors": [{"id": 283, "label": "#283\nif credentials.type != 'api_key':", "successors": [{"id": 284, "label": "#284\nlogger.warning(\n    f\"User {user_id} credentials {credentials.id} with provider 'llm' has invalid type '{credentials.type}'\"\n    )", "successors": []}, {"id": 285, "label": "#285\napi_key = credentials.api_key.get_secret_value()\nif api_key.startswith('sk-ant-api03-'):", "successors": [{"id": 286, "label": "#286\ncredentials.provider = credentials_meta['provider'] = 'anthropic'", "successors": [{"id": 287, "label": "#287\nstore.update_creds(user_id, credentials)\nawait AgentNode.prisma().update(where={'id': node_id}, data={\n    'constantInput': json.dumps(node_preset_input)})", "successors": []}]}, {"id": 288, "label": "#288\nif api_key.startswith('sk-'):", "successors": [{"id": 289, "label": "#289\ncredentials.provider = credentials_meta['provider'] = 'openai'", "successors": []}, {"id": 291, "label": "#291\nif api_key.startswith('gsk_'):", "successors": [{"id": 292, "label": "#292\ncredentials.provider = credentials_meta['provider'] = 'groq'", "successors": []}, {"id": 294, "label": "#294\nlogger.warning(\n    f'Could not identify provider from key prefix {api_key[:13]}*****')", "successors": []}]}]}]}]}]}]}, {"id": 277, "label": "#277\nif not user_integrations:", "successors": [{"id": 278, "label": "#278\nraise RuntimeError(f'Impossible state while processing node {node}')", "successors": []}]}]}]}]}]}], "functions": [], "classes": []}], "classes": [{"name": "Link", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nsource_id: str\nsink_id: str\nsource_name: str\nsink_name: str\nis_static: bool = False", "successors": []}], "functions": [{"name": "from_db", "type": "CFG", "blocks": [{"id": 5, "label": "#5\nreturn Link(id=link.id, source_name=link.sourceName, source_id=link.\n    agentNodeSourceId, sink_name=link.sinkName, sink_id=link.\n    agentNodeSinkId, is_static=link.isStatic)", "successors": []}], "functions": [], "classes": []}, {"name": "__hash__", "type": "CFG", "blocks": [{"id": 9, "label": "#9\nreturn hash((self.source_id, self.sink_id, self.source_name, self.sink_name))", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "Node", "type": "CFG", "blocks": [{"id": 14, "label": "#14\nblock_id: str\ninput_default: BlockInput = {}\nmetadata: dict[str, Any] = {}\ninput_links: list[Link] = []\noutput_links: list[Link] = []\nwebhook_id: Optional[str] = None", "successors": []}], "functions": [], "classes": []}, {"name": "NodeModel", "type": "CFG", "blocks": [{"id": 17, "label": "#17\ngraph_id: str\ngraph_version: int\nwebhook: Optional[Webhook] = None", "successors": []}], "functions": [{"name": "from_db", "type": "CFG", "blocks": [{"id": 19, "label": "#19\nif not node.AgentBlock:", "successors": [{"id": 20, "label": "#20\nraise ValueError(f'Invalid node {node.id}, invalid AgentBlock.')", "successors": []}, {"id": 21, "label": "#21\nobj = NodeModel(id=node.id, block_id=node.AgentBlock.id, input_default=json\n    .loads(node.constantInput, target_type=dict[str, Any]), metadata=json.\n    loads(node.metadata, target_type=dict[str, Any]), graph_id=node.\n    agentGraphId, graph_version=node.agentGraphVersion, webhook_id=node.\n    webhookId, webhook=Webhook.from_db(node.Webhook) if node.Webhook else None)\nobj.input_links = [Link.from_db(link) for link in node.Input or []]\nobj.output_links = [Link.from_db(link) for link in node.Output or []]\nreturn obj", "successors": []}]}], "functions": [], "classes": []}, {"name": "is_triggered_by_event_type", "type": "CFG", "blocks": [{"id": 26, "label": "#26\nif not (block := get_block(self.block_id)):", "successors": [{"id": 27, "label": "#27\nraise ValueError(f'Block #{self.block_id} not found for node #{self.id}')", "successors": []}, {"id": 28, "label": "#28\nif not block.webhook_config:", "successors": [{"id": 30, "label": "#30\nraise TypeError(\"This method can't be used on non-webhook blocks\")", "successors": []}, {"id": 31, "label": "#31\nif not block.webhook_config.event_filter_input:", "successors": [{"id": 33, "label": "#33\nreturn True", "successors": []}, {"id": 34, "label": "#34\nevent_filter = self.input_default.get(block.webhook_config.event_filter_input)\nif not event_filter:", "successors": [{"id": 36, "label": "#36\nraise ValueError(f'Event filter is not configured on node #{self.id}')", "successors": []}, {"id": 37, "label": "#37\nreturn event_type in [block.webhook_config.event_format.format(event=k) for\n    k in event_filter if event_filter[k] is True]", "successors": []}]}]}]}]}], "functions": [], "classes": []}], "classes": []}, {"name": "GraphExecution", "type": "CFG", "blocks": [{"id": 43, "label": "#43\nexecution_id: str\nstarted_at: datetime\nended_at: datetime\nduration: float\ntotal_run_time: float\nstatus: ExecutionStatus\ngraph_id: str\ngraph_version: int", "successors": []}], "functions": [{"name": "from_db", "type": "CFG", "blocks": [{"id": 45, "label": "#45\nnow = datetime.now(timezone.utc)\nstart_time = execution.startedAt or execution.createdAt\nend_time = execution.updatedAt or now\nduration = (end_time - start_time).total_seconds()\ntotal_run_time = duration\ntry:", "successors": [{"id": 46, "label": "#46\nstats = json.loads(execution.stats or '{}', target_type=dict[str, Any])", "successors": [{"id": 48, "label": "#48\nduration = stats.get('walltime', duration)\ntotal_run_time = stats.get('nodes_walltime', total_run_time)\nreturn GraphExecution(id=execution.id, execution_id=execution.id,\n    started_at=start_time, ended_at=end_time, duration=duration,\n    total_run_time=total_run_time, status=ExecutionStatus(execution.\n    executionStatus), graph_id=execution.agentGraphId, graph_version=\n    execution.agentGraphVersion)", "successors": []}]}, {"id": 47, "label": "#47\nstats = {}", "successors": []}]}], "functions": [], "classes": []}], "classes": []}, {"name": "Graph", "type": "CFG", "blocks": [{"id": 53, "label": "#53\nversion: int = 1\nis_active: bool = True\nis_template: bool = False\nname: str\ndescription: str\nnodes: list[Node] = []\nlinks: list[Link] = []", "successors": []}], "functions": [{"name": "input_schema", "type": "CFG", "blocks": [{"id": 55, "label": "#55\nreturn self._generate_schema(AgentInputBlock.Input, [node.input_default for\n    node in self.nodes if (b := get_block(node.block_id)) and b.block_type ==\n    BlockType.INPUT and 'name' in node.input_default])", "successors": []}], "functions": [], "classes": []}, {"name": "output_schema", "type": "CFG", "blocks": [{"id": 59, "label": "#59\nreturn self._generate_schema(AgentOutputBlock.Input, [node.input_default for\n    node in self.nodes if (b := get_block(node.block_id)) and b.block_type ==\n    BlockType.OUTPUT and 'name' in node.input_default])", "successors": []}], "functions": [], "classes": []}, {"name": "_generate_schema", "type": "CFG", "blocks": [{"id": 63, "label": "#63\nprops = []", "successors": [{"id": 64, "label": "#64\nfor p in data:", "successors": [{"id": 65, "label": "#65\ntry:", "successors": [{"id": 67, "label": "#67\nprops.append(type_class(**p))", "successors": []}, {"id": 68, "label": "#68\nlogger.warning(f'Invalid {type_class}: {p}, {e}')", "successors": []}]}, {"id": 66, "label": "#66\nreturn {'type': 'object', 'properties': {p.name: {'secret': p.secret,\n    'advanced': p.advanced, 'title': p.title or p.name, **{'description': p\n    .description} if p.description else {}, **{'default': p.value} if p.\n    value is not None else {}} for p in props}, 'required': [p.name for p in\n    props if p.value is None]}", "successors": []}]}]}], "functions": [], "classes": []}], "classes": []}, {"name": "GraphModel", "type": "CFG", "blocks": [{"id": 74, "label": "#74\nuser_id: str\nnodes: list[NodeModel] = []", "successors": []}], "functions": [{"name": "starting_nodes", "type": "CFG", "blocks": [{"id": 76, "label": "#76\noutbound_nodes = {link.sink_id for link in self.links}\ninput_nodes = {v.id for v in self.nodes if (b := get_block(v.block_id)) and\n    b.block_type == BlockType.INPUT}\nreturn [node for node in self.nodes if node.id not in outbound_nodes or \n    node.id in input_nodes]", "successors": []}], "functions": [], "classes": []}, {"name": "reassign_ids", "type": "CFG", "blocks": [{"id": 80, "label": "#80\n\"\"\"\n        Reassigns all IDs in the graph to new UUIDs.\n        This method can be used before storing a new graph to the database.\n        \"\"\"\nid_map = {node.id: str(uuid.uuid4()) for node in self.nodes}\nif reassign_graph_id:", "successors": [{"id": 81, "label": "#81\nself.id = str(uuid.uuid4())", "successors": [{"id": 82, "label": "#82\nfor node in self.nodes:", "successors": [{"id": 83, "label": "#83\nnode.id = id_map[node.id]", "successors": []}, {"id": 84, "label": "#84\nfor link in self.links:", "successors": [{"id": 85, "label": "#85\nlink.source_id = id_map[link.source_id]\nlink.sink_id = id_map[link.sink_id]", "successors": []}, {"id": 86, "label": "#86\nfor node in self.nodes:", "successors": [{"id": 87, "label": "#87\nif node.block_id != AgentExecutorBlock().id:", "successors": [{"id": 90, "label": "#90\nnode.input_default['user_id'] = user_id\nnode.input_default.setdefault('data', {})", "successors": []}]}, {"id": 88, "label": "#88\nself.validate_graph()", "successors": []}]}]}]}]}]}], "functions": [], "classes": []}, {"name": "validate_graph", "type": "CFG", "blocks": [{"id": 93, "label": "#93\ninput_links = defaultdict(list)", "successors": [{"id": 98, "label": "#98\nfor link in self.links:", "successors": [{"id": 99, "label": "#99\ninput_links[link.sink_id].append(link)", "successors": []}, {"id": 100, "label": "#100\nfor node in self.nodes:", "successors": [{"id": 101, "label": "#101\nblock = get_block(node.block_id)\nif block is None:", "successors": [{"id": 103, "label": "#103\nraise ValueError(f'Invalid block {node.block_id} for node #{node.id}')", "successors": []}, {"id": 104, "label": "#104\nprovided_inputs = set([sanitize(name) for name in node.input_default] + [\n    sanitize(link.sink_name) for link in input_links.get(node.id, [])])", "successors": [{"id": 106, "label": "#106\nfor name in block.input_schema.get_required_fields():", "successors": [{"id": 107, "label": "#107\nif name not in provided_inputs and not (name == 'payload' and block.", "successors": [{"id": 109, "label": "#109\nraise ValueError(\n    f'Node {block.name} #{node.id} required input missing: `{name}`')", "successors": []}]}, {"id": 108, "label": "#108\ninput_schema = block.input_schema.model_fields\nrequired_fields = block.input_schema.get_required_fields()", "successors": [{"id": 116, "label": "#116\nfor field_name, field_info in input_schema.items():", "successors": [{"id": 117, "label": "#117\njson_schema_extra = field_info.json_schema_extra or {}\ndependencies = json_schema_extra.get('depends_on', [])\nif not for_run or not dependencies:", "successors": [{"id": 120, "label": "#120\nfield_has_value = has_value(field_name)\nfield_is_required = field_name in required_fields\nmissing_deps = [dep for dep in dependencies if not has_value(dep)]\nif missing_deps and (field_has_value or field_is_required):", "successors": [{"id": 121, "label": "#121\nraise ValueError(\n    f\"Node {block.name} #{node.id}: Field `{field_name}` requires [{', '.join(missing_deps)}] to be set\"\n    )", "successors": []}]}]}]}]}]}]}]}, {"id": 102, "label": "#102\nnode_map = {v.id: v for v in self.nodes}", "successors": [{"id": 128, "label": "#128\nfor link in self.links:", "successors": [{"id": 129, "label": "#129\nsource = link.source_id, link.source_name\nsink = link.sink_id, link.sink_name\nsuffix = f'Link {source} <-> {sink}'", "successors": [{"id": 131, "label": "#131\nfor i, (node_id, name) in enumerate([source, sink]):", "successors": [{"id": 132, "label": "#132\nnode = node_map.get(node_id)\nif not node:", "successors": [{"id": 134, "label": "#134\nraise ValueError(\n    f'{suffix}, {node_id} is invalid node id, available nodes: {node_map.keys()}'\n    )", "successors": []}, {"id": 135, "label": "#135\nblock = get_block(node.block_id)\nif not block:", "successors": [{"id": 137, "label": "#137\nblocks = {v().id: v().name for v in get_blocks().values()}\nraise ValueError(\n    f'{suffix}, {node.block_id} is invalid block id, available blocks: {blocks}'\n    )", "successors": []}, {"id": 138, "label": "#138\nsanitized_name = sanitize(name)\nvals = node.input_default\nif i == 0:", "successors": [{"id": 140, "label": "#140\nfields = block.output_schema.get_fields(\n    ) if block.block_type != BlockType.AGENT else vals.get('output_schema', {}\n    ).get('properties', {}).keys()", "successors": [{"id": 141, "label": "#141\nif sanitized_name not in fields:", "successors": [{"id": 143, "label": "#143\nfields_msg = f'Allowed fields: {fields}'\nraise ValueError(f'{suffix}, `{name}` invalid, {fields_msg}')", "successors": []}]}]}, {"id": 142, "label": "#142\nfields = block.input_schema.get_fields(\n    ) if block.block_type != BlockType.AGENT else vals.get('input_schema', {}\n    ).get('properties', {}).keys()", "successors": []}]}]}]}, {"id": 133, "label": "#133\nif is_static_output_block(link.source_id):", "successors": [{"id": 146, "label": "#146\nlink.is_static = True", "successors": []}]}]}]}]}]}]}]}]}], "functions": [{"name": "sanitize", "type": "CFG", "blocks": [{"id": 95, "label": "#95\nreturn name.split('_#_')[0].split('_@_')[0].split('_$_')[0]", "successors": []}], "functions": [], "classes": []}, {"name": "has_value", "type": "CFG", "blocks": [{"id": 113, "label": "#113\nreturn node is not None and name in node.input_default and node.input_default[\n    name] is not None and str(node.input_default[name]).strip(\n    ) != '' or name in input_schema and input_schema[name].default is not None", "successors": []}], "functions": [], "classes": []}, {"name": "is_static_output_block", "type": "CFG", "blocks": [{"id": 125, "label": "#125\nbid = node_map[nid].block_id\nb = get_block(bid)\nreturn b.static_output if b else False", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "from_db", "type": "CFG", "blocks": [{"id": 150, "label": "#150\nreturn GraphModel(id=graph.id, user_id=graph.userId, version=graph.version,\n    is_active=graph.isActive, is_template=graph.isTemplate, name=graph.name or\n    '', description=graph.description or '', nodes=[NodeModel.from_db(\n    GraphModel._process_node(node, for_export)) for node in graph.\n    AgentNodes or []], links=list({Link.from_db(link) for node in graph.\n    AgentNodes or [] for link in (node.Input or []) + (node.Output or [])}))", "successors": []}], "functions": [], "classes": []}, {"name": "_process_node", "type": "CFG", "blocks": [{"id": 154, "label": "#154\nif for_export:", "successors": [{"id": 155, "label": "#155\nif node.constantInput:", "successors": [{"id": 157, "label": "#157\nconstant_input = json.loads(node.constantInput, target_type=dict[str, Any])\nconstant_input = GraphModel._hide_node_input_credentials(constant_input)\nnode.constantInput = json.dumps(constant_input)", "successors": [{"id": 158, "label": "#158\nnode.webhookId = None\nnode.Webhook = None", "successors": [{"id": 156, "label": "#156\nreturn node", "successors": []}]}]}]}]}], "functions": [], "classes": []}, {"name": "_hide_node_input_credentials", "type": "CFG", "blocks": [{"id": 162, "label": "#162\nsensitive_keys = ['credentials', 'api_key', 'password', 'token', 'secret']\nresult = {}", "successors": [{"id": 163, "label": "#163\nfor key, value in input_data.items():", "successors": [{"id": 164, "label": "#164\nif isinstance(value, dict):", "successors": [{"id": 166, "label": "#166\nresult[key] = GraphModel._hide_node_input_credentials(value)", "successors": []}, {"id": 168, "label": "#168\nif isinstance(value, str) and any(sensitive_key in key.lower() for", "successors": [{"id": 171, "label": "#171\nresult[key] = value", "successors": []}]}]}, {"id": 165, "label": "#165\nreturn result", "successors": []}]}]}], "functions": [], "classes": []}], "classes": []}]}
{"file_name": "39.json", "name": "39.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport asyncio\nfrom typing import Literal\nimport aiohttp\nimport discord\nfrom pydantic import SecretStr\nfrom backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema\nfrom backend.data.model import APIKeyCredentials, CredentialsField, CredentialsMetaInput, SchemaField\nfrom backend.integrations.providers import ProviderName\nDiscordCredentials = CredentialsMetaInput[Literal[ProviderName.DISCORD],\n    Literal['api_key']]\nTEST_CREDENTIALS = APIKeyCredentials(id=\n    '01234567-89ab-cdef-0123-456789abcdef', provider='discord', api_key=\n    SecretStr('test_api_key'), title='Mock Discord API key', expires_at=None)\nTEST_CREDENTIALS_INPUT = {'provider': TEST_CREDENTIALS.provider, 'id':\n    TEST_CREDENTIALS.id, 'type': TEST_CREDENTIALS.type, 'title':\n    TEST_CREDENTIALS.type}", "successors": []}], "functions": [{"name": "DiscordCredentialsField", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nreturn CredentialsField(description='Discord bot token')", "successors": []}], "functions": [], "classes": []}], "classes": [{"name": "ReadDiscordMessagesBlock", "type": "CFG", "blocks": [{"id": 7, "label": "#7", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 15, "label": "#15\nsuper().__init__(id='df06086a-d5ac-4abb-9996-2ad0acb2eff7', input_schema=\n    ReadDiscordMessagesBlock.Input, output_schema=ReadDiscordMessagesBlock.\n    Output, description=\n    'Reads messages from a Discord channel using a bot token.', categories=\n    {BlockCategory.SOCIAL}, test_input={'continuous_read': False,\n    'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=\n    TEST_CREDENTIALS, test_output=[('message_content',\n    \"\"\"Hello!\n\nFile from user: example.txt\nContent: This is the content of the file.\"\"\"\n    ), ('channel_name', 'general'), ('username', 'test_user')], test_mock={\n    'run_bot': lambda token: asyncio.Future()})", "successors": []}], "functions": [], "classes": []}, {"name": "run_bot", "type": "CFG", "blocks": [{"id": 18, "label": "#18\nintents = discord.Intents.default()\nintents.message_content = True\nclient = discord.Client(intents=intents)\nself.output_data = None\nself.channel_name = None\nself.username = None\nawait client.start(token.get_secret_value())", "successors": []}], "functions": [{"name": "on_ready", "type": "CFG", "blocks": [{"id": 20, "label": "#20\nprint(f'Logged in as {client.user}')", "successors": []}], "functions": [], "classes": []}, {"name": "on_message", "type": "CFG", "blocks": [{"id": 23, "label": "#23\nif message.author == client.user:", "successors": [{"id": 24, "label": "#24\nreturn", "successors": []}, {"id": 25, "label": "#25\nself.output_data = message.content\nself.channel_name = message.channel.name\nself.username = message.author.name\nif message.attachments:", "successors": [{"id": 27, "label": "#27\nattachment = message.attachments[0]\nif attachment.filename.endswith(('.txt', '.py')):", "successors": [{"id": 29, "label": "#29\nasync with aiohttp.ClientSession() as session:\n    async with session.get(attachment.url) as response:\n        file_content = await response.text()\n        self.output_data += (\n            f'\\n\\nFile from user: {attachment.filename}\\nContent: {file_content}'\n            )", "successors": [{"id": 31, "label": "#31\nasync with session.get(attachment.url) as response:\n    file_content = await response.text()\n    self.output_data += (\n        f'\\n\\nFile from user: {attachment.filename}\\nContent: {file_content}')", "successors": [{"id": 33, "label": "#33\nfile_content = await response.text()", "successors": [{"id": 35, "label": "#35\nself.output_data += f\"\"\"\n\nFile from user: {attachment.filename}\nContent: {file_content}\"\"\"", "successors": [{"id": 28, "label": "#28\nawait client.close()", "successors": []}]}]}]}]}]}]}]}], "functions": [], "classes": []}], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 41, "label": "#41\nwhile True:", "successors": [{"id": 42, "label": "#42\nfor output_name, output_value in self.__run(input_data, credentials):", "successors": [{"id": 44, "label": "#44\nyield output_name, output_value", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "__run", "type": "CFG", "blocks": [{"id": 49, "label": "#49\ntry:", "successors": [{"id": 50, "label": "#50\nloop = asyncio.get_event_loop()\nfuture = self.run_bot(credentials.api_key)\nif isinstance(future, asyncio.Future):", "successors": [{"id": 54, "label": "#54\nfuture.set_result({'output_data':\n    \"\"\"Hello!\n\nFile from user: example.txt\nContent: This is the content of the file.\"\"\"\n    , 'channel_name': 'general', 'username': 'test_user'})", "successors": [{"id": 55, "label": "#55\nresult = loop.run_until_complete(future)\nif isinstance(result, dict):", "successors": [{"id": 56, "label": "#56\nself.output_data = result.get('output_data')\nself.channel_name = result.get('channel_name')\nself.username = result.get('username')", "successors": [{"id": 57, "label": "#57\nif self.output_data is None or self.channel_name is None or self.username is None:", "successors": [{"id": 58, "label": "#58\nraise ValueError('No message, channel name, or username received.')", "successors": []}, {"id": 59, "label": "#59\nyield 'message_content', self.output_data", "successors": [{"id": 61, "label": "#61\nyield 'channel_name', self.channel_name", "successors": [{"id": 62, "label": "#62\nyield 'username', self.username", "successors": []}]}]}]}]}]}]}]}, {"id": 51, "label": "#51\nraise ValueError(f'Login error occurred: {login_err}')", "successors": []}, {"id": 52, "label": "#52\nraise ValueError(f'An error occurred: {e}')", "successors": []}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 9, "label": "#9\ncredentials: DiscordCredentials = DiscordCredentialsField()", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 12, "label": "#12\nmessage_content: str = SchemaField(description=\n    'The content of the message received')\nchannel_name: str = SchemaField(description=\n    'The name of the channel the message was received from')\nusername: str = SchemaField(description=\n    'The username of the user who sent the message')", "successors": []}], "functions": [], "classes": []}]}, {"name": "SendDiscordMessageBlock", "type": "CFG", "blocks": [{"id": 69, "label": "#69", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 77, "label": "#77\nsuper().__init__(id='d0822ab5-9f8a-44a3-8971-531dd0178b6b', input_schema=\n    SendDiscordMessageBlock.Input, output_schema=SendDiscordMessageBlock.\n    Output, description=\n    'Sends a message to a Discord channel using a bot token.', categories={\n    BlockCategory.SOCIAL}, test_input={'channel_name': 'general',\n    'message_content': 'Hello, Discord!', 'credentials':\n    TEST_CREDENTIALS_INPUT}, test_output=[('status', 'Message sent')],\n    test_mock={'send_message': lambda token, channel_name, message_content:\n    asyncio.Future()}, test_credentials=TEST_CREDENTIALS)", "successors": []}], "functions": [], "classes": []}, {"name": "send_message", "type": "CFG", "blocks": [{"id": 80, "label": "#80\nintents = discord.Intents.default()\nintents.guilds = True\nclient = discord.Client(intents=intents)\nawait client.start(token)", "successors": []}], "functions": [{"name": "on_ready", "type": "CFG", "blocks": [{"id": 82, "label": "#82\nprint(f'Logged in as {client.user}')", "successors": [{"id": 83, "label": "#83\nfor guild in client.guilds:", "successors": [{"id": 84, "label": "#84\nfor channel in guild.text_channels:", "successors": [{"id": 86, "label": "#86\nif channel.name == channel_name:", "successors": [{"id": 88, "label": "#88\nfor chunk in self.chunk_message(message_content):", "successors": [{"id": 90, "label": "#90\nawait channel.send(chunk)", "successors": []}, {"id": 91, "label": "#91\nself.output_data = 'Message sent'\nawait client.close()", "successors": [{"id": 93, "label": "#93\nreturn", "successors": []}]}]}]}]}, {"id": 85, "label": "#85\nself.output_data = 'Channel not found'\nawait client.close()", "successors": []}]}]}], "functions": [], "classes": []}], "classes": []}, {"name": "chunk_message", "type": "CFG", "blocks": [{"id": 100, "label": "#100\n\"\"\"Splits a message into chunks not exceeding the Discord limit.\"\"\"\nreturn [message[i:i + limit] for i in range(0, len(message), limit)]", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 104, "label": "#104\ntry:", "successors": [{"id": 105, "label": "#105\nloop = asyncio.get_event_loop()\nfuture = self.send_message(credentials.api_key.get_secret_value(),\n    input_data.channel_name, input_data.message_content)\nif isinstance(future, asyncio.Future):", "successors": [{"id": 109, "label": "#109\nfuture.set_result('Message sent')", "successors": [{"id": 110, "label": "#110\nresult = loop.run_until_complete(future)\nif isinstance(result, str):", "successors": [{"id": 111, "label": "#111\nself.output_data = result", "successors": [{"id": 112, "label": "#112\nif self.output_data is None:", "successors": [{"id": 113, "label": "#113\nraise ValueError('No status message received.')", "successors": []}, {"id": 114, "label": "#114\nyield 'status', self.output_data", "successors": []}]}]}]}]}]}, {"id": 106, "label": "#106\nraise ValueError(f'Login error occurred: {login_err}')", "successors": []}, {"id": 107, "label": "#107\nraise ValueError(f'An error occurred: {e}')", "successors": []}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 71, "label": "#71\ncredentials: DiscordCredentials = DiscordCredentialsField()\nmessage_content: str = SchemaField(description=\n    'The content of the message received')\nchannel_name: str = SchemaField(description=\n    'The name of the channel the message was received from')", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 74, "label": "#74\nstatus: str = SchemaField(description=\n    \"The status of the operation (e.g., 'Message sent', 'Error')\")", "successors": []}], "functions": [], "classes": []}]}]}
{"file_name": "40.json", "name": "40.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\n\"\"\"\nWord Break Problem is a well-known problem in computer science.\nGiven a string and a dictionary of words, the task is to determine if\nthe string can be segmented into a sequence of one or more dictionary words.\n\nWikipedia: https://en.wikipedia.org/wiki/Word_break_problem\n\"\"\"", "successors": []}], "functions": [{"name": "backtrack", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"\n    Helper function that uses backtracking to determine if a valid\n    word segmentation is possible starting from index 'start'.\n\n    Parameters:\n    input_string (str): The input string to be segmented.\n    word_dict (set[str]): A set of valid dictionary words.\n    start (int): The starting index of the substring to be checked.\n\n    Returns:\n    bool: True if a valid segmentation is possible, otherwise False.\n\n    Example:\n    >>> backtrack(\"leetcode\", {\"leet\", \"code\"}, 0)\n    True\n\n    >>> backtrack(\"applepenapple\", {\"apple\", \"pen\"}, 0)\n    True\n\n    >>> backtrack(\"catsandog\", {\"cats\", \"dog\", \"sand\", \"and\", \"cat\"}, 0)\n    False\n    \"\"\"\nif start == len(input_string):", "successors": [{"id": 4, "label": "#4\nreturn True", "successors": []}, {"id": 5, "label": "#5\nfor end in range(start + 1, len(input_string) + 1):", "successors": [{"id": 7, "label": "#7\nif input_string[start:end] in word_dict and backtrack(input_string,", "successors": [{"id": 9, "label": "#9\nreturn True", "successors": []}]}, {"id": 8, "label": "#8\nreturn False", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "word_break", "type": "CFG", "blocks": [{"id": 15, "label": "#15\n\"\"\"\n    Determines if the input string can be segmented into a sequence of\n    valid dictionary words using backtracking.\n\n    Parameters:\n    input_string (str): The input string to segment.\n    word_dict (set[str]): The set of valid words.\n\n    Returns:\n    bool: True if the string can be segmented into valid words, otherwise False.\n\n    Example:\n    >>> word_break(\"leetcode\", {\"leet\", \"code\"})\n    True\n\n    >>> word_break(\"applepenapple\", {\"apple\", \"pen\"})\n    True\n\n    >>> word_break(\"catsandog\", {\"cats\", \"dog\", \"sand\", \"and\", \"cat\"})\n    False\n    \"\"\"\nreturn backtrack(input_string, word_dict, 0)", "successors": []}], "functions": [], "classes": []}], "classes": []}
{"file_name": "41.json", "name": "41.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\n\"\"\"\n    The approach taken is explained below. I decided to do it simply.\n    Initially I was considering parsing the data into some sort of\n    structure and then generating an appropriate README. I am still\n    considering doing it - but for now this should work. The only issue\n    I see is that it only sorts the entries at the lowest level, and that\n    the order of the top-level contents do not match the order of the actual\n    entries.\n\n    This could be extended by having nested blocks, sorting them recursively\n    and flattening the end structure into a list of lines. Revision 2 maybe ^.^.\n\"\"\"\nif __name__ == '__main__':", "successors": [{"id": 36, "label": "#36\nmain()", "successors": []}]}], "functions": [{"name": "sort_blocks", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nwith open('README.md', 'r') as read_me_file:", "successors": [{"id": 4, "label": "#4\nread_me = read_me_file.read()", "successors": [{"id": 5, "label": "#5\ntable_of_contents = ''.join(read_me.split('- - -')[0])\nblocks = ''.join(read_me.split('- - -')[1]).split('\\n# ')", "successors": [{"id": 6, "label": "#6\nfor i in range(len(blocks)):", "successors": [{"id": 7, "label": "#7\nif i == 0:", "successors": [{"id": 9, "label": "#9\nblocks[i] = blocks[i] + '\\n'", "successors": []}, {"id": 11, "label": "#11\nblocks[i] = '# ' + blocks[i] + '\\n'", "successors": []}]}, {"id": 8, "label": "#8\ninner_blocks = sorted(blocks[0].split('##'))", "successors": [{"id": 12, "label": "#12\nfor i in range(1, len(inner_blocks)):", "successors": [{"id": 13, "label": "#13\nif inner_blocks[i][0] != '#':", "successors": [{"id": 15, "label": "#15\ninner_blocks[i] = '##' + inner_blocks[i]", "successors": []}]}, {"id": 14, "label": "#14\ninner_blocks = ''.join(inner_blocks)\nblocks[0] = inner_blocks\nfinal_README = table_of_contents + '- - -' + ''.join(blocks)\nwith open('README.md', 'w+') as sorted_file:", "successors": [{"id": 17, "label": "#17\nsorted_file.write(final_README)", "successors": []}]}]}]}]}]}]}]}], "functions": [], "classes": []}, {"name": "main", "type": "CFG", "blocks": [{"id": 21, "label": "#21\nwith open('README.md', 'r') as read_me_file:", "successors": [{"id": 22, "label": "#22\nread_me = read_me_file.readlines()", "successors": [{"id": 23, "label": "#23\nblocks = []\nlast_indent = None", "successors": [{"id": 24, "label": "#24\nfor line in read_me:", "successors": [{"id": 25, "label": "#25\ns_line = line.lstrip()\nindent = len(line) - len(s_line)\nif any([s_line.startswith(s) for s in ['* [', '- [']]):", "successors": [{"id": 27, "label": "#27\nif indent == last_indent:", "successors": [{"id": 30, "label": "#30\nblocks[-1].append(line)", "successors": [{"id": 31, "label": "#31\nlast_indent = indent", "successors": []}]}, {"id": 32, "label": "#32\nblocks.append([line])", "successors": []}]}, {"id": 29, "label": "#29\nblocks.append([line])\nlast_indent = None", "successors": []}]}, {"id": 26, "label": "#26\nwith open('README.md', 'w+') as sorted_file:", "successors": [{"id": 33, "label": "#33\nblocks = [''.join(sorted(block, key=str.lower)) for block in blocks]\nsorted_file.write(''.join(blocks))", "successors": [{"id": 34, "label": "#34\nsort_blocks()", "successors": []}]}]}]}]}]}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "42.json", "name": "42.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport logging\nfrom backend.data import integrations\nfrom backend.data.model import APIKeyCredentials, Credentials, OAuth2Credentials\nfrom ._base import WT, BaseWebhooksManager\nlogger = logging.getLogger(__name__)", "successors": []}], "functions": [], "classes": [{"name": "ManualWebhookManagerBase", "type": "CFG", "blocks": [{"id": 3, "label": "#3", "successors": []}], "functions": [{"name": "_register_webhook", "type": "CFG", "blocks": [{"id": 5, "label": "#5\nprint(ingress_url)\nreturn '', {}", "successors": []}], "functions": [], "classes": []}, {"name": "_deregister_webhook", "type": "CFG", "blocks": [{"id": 9, "label": "#9\npass", "successors": []}], "functions": [], "classes": []}], "classes": []}]}
{"file_name": "43.json", "name": "43.json", "type": "CFG", "blocks": [{"id": 1, "label": "#1\n{'name': 'example_script', 'type': 'CFG', 'start_line': 1, 'end_line': 11,\n    'functions': [{'name': 'get_user_id', 'type': 'function', 'start_line':\n    10, 'end_line': 11, 'functions': [], 'classes': [], 'simplified_code':\n    \"\"\"def get_user_id(user: User = Depends(requires_user)) -> str:\n    return user.user_id\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"def get_user_id(user: User = Depends(requires_user)) -> str:\n    return user.user_id\"\"\"\n    , 'successors': []}]}], 'classes': [], 'simplified_code':\n    \"\"\"from autogpt_libs.auth.depends import requires_user\nfrom autogpt_libs.auth.models import User\nfrom fastapi import Depends\n\nfrom backend.util.settings import Settings\n\nsettings = Settings()\n\n\n    return user.user_id\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"from autogpt_libs.auth.depends import requires_user\nfrom autogpt_libs.auth.models import User\nfrom fastapi import Depends\n\nfrom backend.util.settings import Settings\n\nsettings = Settings()\"\"\"\n    , 'successors': [2]}, {'id': 2, 'label': 'return user.user_id',\n    'successors': []}]}", "successors": []}], "functions": [], "classes": []}
{"file_name": "44.json", "name": "44.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom enum import Enum\nfrom typing import List, Literal\nfrom pydantic import SecretStr\nfrom backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema\nfrom backend.data.model import APIKeyCredentials, BlockSecret, CredentialsField, CredentialsMetaInput, SchemaField, SecretField\nfrom backend.integrations.providers import ProviderName\nfrom backend.util.request import requests\nTEST_CREDENTIALS = APIKeyCredentials(id=\n    '01234567-89ab-cdef-0123-456789abcdef', provider='medium', api_key=\n    SecretStr('mock-medium-api-key'), title='Mock Medium API key',\n    expires_at=None)\nTEST_CREDENTIALS_INPUT = {'provider': TEST_CREDENTIALS.provider, 'id':\n    TEST_CREDENTIALS.id, 'type': TEST_CREDENTIALS.type, 'title':\n    TEST_CREDENTIALS.type}", "successors": []}], "functions": [], "classes": [{"name": "PublishToMediumStatus", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nPUBLIC = 'public'\nDRAFT = 'draft'\nUNLISTED = 'unlisted'", "successors": []}], "functions": [], "classes": []}, {"name": "PublishToMediumBlock", "type": "CFG", "blocks": [{"id": 6, "label": "#6", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 14, "label": "#14\nsuper().__init__(id='3f7b2dcb-4a78-4e3f-b0f1-88132e1b89df', input_schema=\n    PublishToMediumBlock.Input, output_schema=PublishToMediumBlock.Output,\n    description='Publishes a post to Medium.', categories={BlockCategory.\n    SOCIAL}, test_input={'author_id': '1234567890abcdef', 'title':\n    'Test Post', 'content':\n    '<h1>Test Content</h1><p>This is a test post.</p>', 'content_format':\n    'html', 'tags': ['test', 'automation'], 'license':\n    'all-rights-reserved', 'notify_followers': False, 'publish_status':\n    PublishToMediumStatus.DRAFT.value, 'credentials':\n    TEST_CREDENTIALS_INPUT}, test_output=[('post_id', 'e6f36a'), (\n    'post_url', 'https://medium.com/@username/test-post-e6f36a'), (\n    'published_at', 1626282600)], test_mock={'create_post': lambda *args,\n    **kwargs: {'data': {'id': 'e6f36a', 'url':\n    'https://medium.com/@username/test-post-e6f36a', 'authorId':\n    '1234567890abcdef', 'publishedAt': 1626282600}}}, test_credentials=\n    TEST_CREDENTIALS)", "successors": []}], "functions": [], "classes": []}, {"name": "create_post", "type": "CFG", "blocks": [{"id": 17, "label": "#17\nheaders = {'Authorization': f'Bearer {api_key.get_secret_value()}',\n    'Content-Type': 'application/json', 'Accept': 'application/json'}\ndata = {'title': title, 'content': content, 'contentFormat': content_format,\n    'tags': tags, 'canonicalUrl': canonical_url, 'publishStatus':\n    publish_status, 'license': license, 'notifyFollowers': notify_followers}\nresponse = requests.post(f'https://api.medium.com/v1/users/{author_id}/posts',\n    headers=headers, json=data)\nreturn response.json()", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 21, "label": "#21\nresponse = self.create_post(credentials.api_key, input_data.author_id.\n    get_secret_value(), input_data.title, input_data.content, input_data.\n    content_format, input_data.tags, input_data.canonical_url, input_data.\n    publish_status, input_data.license, input_data.notify_followers)\nif 'data' in response:", "successors": [{"id": 22, "label": "#22\nyield 'post_id', response['data']['id']", "successors": [{"id": 26, "label": "#26\nyield 'post_url', response['data']['url']", "successors": [{"id": 27, "label": "#27\nyield 'published_at', response['data']['publishedAt']", "successors": []}]}]}, {"id": 24, "label": "#24\nerror_message = response.get('errors', [{}])[0].get('message',\n    'Unknown error occurred')\nraise RuntimeError(f'Failed to create Medium post: {error_message}')", "successors": []}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 8, "label": "#8\nauthor_id: BlockSecret = SecretField(key='medium_author_id', description=\n    \"\"\"The Medium AuthorID of the user. You can get this by calling the /me endpoint of the Medium API.\n\ncurl -H \"Authorization: Bearer YOUR_ACCESS_TOKEN\" https://api.medium.com/v1/me\" the response will contain the authorId field.\"\"\"\n    , placeholder=\"Enter the author's Medium AuthorID\")\ntitle: str = SchemaField(description='The title of your Medium post',\n    placeholder='Enter your post title')\ncontent: str = SchemaField(description=\n    'The main content of your Medium post', placeholder=\n    'Enter your post content')\ncontent_format: str = SchemaField(description=\n    \"The format of the content: 'html' or 'markdown'\", placeholder='html')\ntags: List[str] = SchemaField(description=\n    'List of tags for your Medium post (up to 5)', placeholder=\n    \"['technology', 'AI', 'blogging']\")\ncanonical_url: str | None = SchemaField(default=None, description=\n    'The original home of this content, if it was originally published elsewhere'\n    , placeholder='https://yourblog.com/original-post')\npublish_status: PublishToMediumStatus = SchemaField(description=\n    'The publish status', placeholder=PublishToMediumStatus.DRAFT)\nlicense: str = SchemaField(default='all-rights-reserved', description=\n    \"The license of the post: 'all-rights-reserved', 'cc-40-by', 'cc-40-by-sa', 'cc-40-by-nd', 'cc-40-by-nc', 'cc-40-by-nc-nd', 'cc-40-by-nc-sa', 'cc-40-zero', 'public-domain'\"\n    , placeholder='all-rights-reserved')\nnotify_followers: bool = SchemaField(default=False, description=\n    'Whether to notify followers that the user has published', placeholder=\n    'False')\ncredentials: CredentialsMetaInput[Literal[ProviderName.MEDIUM], Literal[\n    'api_key']] = CredentialsField(description=\n    'The Medium integration can be used with any API key with sufficient permissions for the blocks it is used on.'\n    )", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 11, "label": "#11\npost_id: str = SchemaField(description='The ID of the created Medium post')\npost_url: str = SchemaField(description='The URL of the created Medium post')\npublished_at: int = SchemaField(description=\n    'The timestamp when the post was published')\nerror: str = SchemaField(description=\n    'Error message if the post creation failed')", "successors": []}], "functions": [], "classes": []}]}]}
{"file_name": "45.json", "name": "45.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport logging\nimport uuid\nfrom datetime import datetime, timezone\nfrom typing import List, Optional\nfrom autogpt_libs.api_key.key_manager import APIKeyManager\nfrom prisma.enums import APIKeyPermission, APIKeyStatus\nfrom prisma.errors import PrismaError\nfrom prisma.models import APIKey as PrismaAPIKey\nfrom prisma.types import APIKeyCreateInput, APIKeyUpdateInput, APIKeyWhereInput, APIKeyWhereUniqueInput\nfrom pydantic import BaseModel\nfrom backend.data.db import BaseDbModel\nlogger = logging.getLogger(__name__)", "successors": []}], "functions": [{"name": "generate_api_key", "type": "CFG", "blocks": [{"id": 37, "label": "#37\n\"\"\"\n    Generate a new API key and store it in the database.\n    Returns the API key object (without hash) and the plain text key.\n    \"\"\"\ntry:", "successors": [{"id": 38, "label": "#38\napi_manager = APIKeyManager()\nkey = api_manager.generate_api_key()\napi_key = await PrismaAPIKey.prisma().create(data=APIKeyCreateInput(id=str(\n    uuid.uuid4()), name=name, prefix=key.prefix, postfix=key.postfix, key=\n    key.hash, permissions=[p for p in permissions], description=description,\n    userId=user_id))", "successors": [{"id": 42, "label": "#42\napi_key_without_hash = APIKeyWithoutHash.from_db(api_key)\nreturn api_key_without_hash, key.raw", "successors": []}]}, {"id": 39, "label": "#39\nlogger.error(f'Database error while generating API key: {str(e)}')\nraise APIKeyError(f'Failed to generate API key: {str(e)}')", "successors": []}, {"id": 40, "label": "#40\nlogger.error(f'Unexpected error while generating API key: {str(e)}')\nraise APIKeyError(f'Failed to generate API key: {str(e)}')", "successors": []}]}], "functions": [], "classes": []}, {"name": "validate_api_key", "type": "CFG", "blocks": [{"id": 48, "label": "#48\n\"\"\"\n    Validate an API key and return the API key object if valid.\n    \"\"\"\ntry:", "successors": [{"id": 49, "label": "#49\nif not plain_text_key.startswith(APIKeyManager.PREFIX):", "successors": [{"id": 52, "label": "#52\nlogger.warning('Invalid API key format')\nreturn None", "successors": []}, {"id": 53, "label": "#53\nprefix = plain_text_key[:APIKeyManager.PREFIX_LENGTH]\napi_manager = APIKeyManager()\napi_key = await PrismaAPIKey.prisma().find_first(where=APIKeyWhereInput(\n    prefix=prefix, status=APIKeyStatus.ACTIVE))", "successors": [{"id": 55, "label": "#55\nif not api_key:", "successors": [{"id": 56, "label": "#56\nlogger.warning(f'No active API key found with prefix {prefix}')\nreturn None", "successors": []}, {"id": 57, "label": "#57\nis_valid = api_manager.verify_api_key(plain_text_key, api_key.key)\nif not is_valid:", "successors": [{"id": 59, "label": "#59\nlogger.warning('API key verification failed')\nreturn None", "successors": []}, {"id": 60, "label": "#60\nreturn APIKey.from_db(api_key)", "successors": []}]}]}]}]}, {"id": 50, "label": "#50\nlogger.error(f'Error validating API key: {str(e)}')\nraise APIKeyValidationError(f'Failed to validate API key: {str(e)}')", "successors": []}]}], "functions": [], "classes": []}, {"name": "revoke_api_key", "type": "CFG", "blocks": [{"id": 66, "label": "#66\ntry:", "successors": [{"id": 67, "label": "#67\napi_key = await PrismaAPIKey.prisma().find_unique(where={'id': key_id})", "successors": [{"id": 72, "label": "#72\nif not api_key:", "successors": [{"id": 73, "label": "#73\nraise APIKeyNotFoundError(f'API key with id {key_id} not found')", "successors": []}, {"id": 74, "label": "#74\nif api_key.userId != user_id:", "successors": [{"id": 76, "label": "#76\nraise APIKeyPermissionError(\n    'You do not have permission to revoke this API key.')", "successors": []}, {"id": 77, "label": "#77\nwhere_clause: APIKeyWhereUniqueInput = {'id': key_id}\nupdated_api_key = await PrismaAPIKey.prisma().update(where=where_clause,\n    data=APIKeyUpdateInput(status=APIKeyStatus.REVOKED, revokedAt=datetime.\n    now(timezone.utc)))", "successors": [{"id": 79, "label": "#79\nif updated_api_key:", "successors": [{"id": 80, "label": "#80\nreturn APIKeyWithoutHash.from_db(updated_api_key)", "successors": []}, {"id": 81, "label": "#81\nreturn None", "successors": []}]}]}]}]}]}, {"id": 68, "label": "#68\nraise e", "successors": []}, {"id": 69, "label": "#69\nlogger.error(f'Database error while revoking API key: {str(e)}')\nraise APIKeyError(f'Failed to revoke API key: {str(e)}')", "successors": []}, {"id": 70, "label": "#70\nlogger.error(f'Unexpected error while revoking API key: {str(e)}')\nraise APIKeyError(f'Failed to revoke API key: {str(e)}')", "successors": []}]}], "functions": [], "classes": []}, {"name": "list_user_api_keys", "type": "CFG", "blocks": [{"id": 89, "label": "#89\ntry:", "successors": [{"id": 90, "label": "#90\nwhere_clause: APIKeyWhereInput = {'userId': user_id}\napi_keys = await PrismaAPIKey.prisma().find_many(where=where_clause, order=\n    {'createdAt': 'desc'})", "successors": [{"id": 94, "label": "#94\nreturn [APIKeyWithoutHash.from_db(key) for key in api_keys]", "successors": []}]}, {"id": 91, "label": "#91\nlogger.error(f'Database error while listing API keys: {str(e)}')\nraise APIKeyError(f'Failed to list API keys: {str(e)}')", "successors": []}, {"id": 92, "label": "#92\nlogger.error(f'Unexpected error while listing API keys: {str(e)}')\nraise APIKeyError(f'Failed to list API keys: {str(e)}')", "successors": []}]}], "functions": [], "classes": []}, {"name": "suspend_api_key", "type": "CFG", "blocks": [{"id": 100, "label": "#100\ntry:", "successors": [{"id": 101, "label": "#101\napi_key = await PrismaAPIKey.prisma().find_unique(where={'id': key_id})", "successors": [{"id": 106, "label": "#106\nif not api_key:", "successors": [{"id": 107, "label": "#107\nraise APIKeyNotFoundError(f'API key with id {key_id} not found')", "successors": []}, {"id": 108, "label": "#108\nif api_key.userId != user_id:", "successors": [{"id": 110, "label": "#110\nraise APIKeyPermissionError(\n    'You do not have permission to suspend this API key.')", "successors": []}, {"id": 111, "label": "#111\nwhere_clause: APIKeyWhereUniqueInput = {'id': key_id}\nupdated_api_key = await PrismaAPIKey.prisma().update(where=where_clause,\n    data=APIKeyUpdateInput(status=APIKeyStatus.SUSPENDED))", "successors": [{"id": 113, "label": "#113\nif updated_api_key:", "successors": [{"id": 114, "label": "#114\nreturn APIKeyWithoutHash.from_db(updated_api_key)", "successors": []}, {"id": 115, "label": "#115\nreturn None", "successors": []}]}]}]}]}]}, {"id": 102, "label": "#102\nraise e", "successors": []}, {"id": 103, "label": "#103\nlogger.error(f'Database error while suspending API key: {str(e)}')\nraise APIKeyError(f'Failed to suspend API key: {str(e)}')", "successors": []}, {"id": 104, "label": "#104\nlogger.error(f'Unexpected error while suspending API key: {str(e)}')\nraise APIKeyError(f'Failed to suspend API key: {str(e)}')", "successors": []}]}], "functions": [], "classes": []}, {"name": "has_permission", "type": "CFG", "blocks": [{"id": 123, "label": "#123\ntry:", "successors": [{"id": 124, "label": "#124\nreturn required_permission in api_key.permissions", "successors": []}, {"id": 125, "label": "#125\nlogger.error(f'Error checking API key permissions: {str(e)}')\nreturn False", "successors": []}]}], "functions": [], "classes": []}, {"name": "get_api_key_by_id", "type": "CFG", "blocks": [{"id": 131, "label": "#131\ntry:", "successors": [{"id": 132, "label": "#132\napi_key = await PrismaAPIKey.prisma().find_first(where=APIKeyWhereInput(id=\n    key_id, userId=user_id))", "successors": [{"id": 136, "label": "#136\nif not api_key:", "successors": [{"id": 137, "label": "#137\nreturn None", "successors": []}, {"id": 138, "label": "#138\nreturn APIKeyWithoutHash.from_db(api_key)", "successors": []}]}]}, {"id": 133, "label": "#133\nlogger.error(f'Database error while getting API key: {str(e)}')\nraise APIKeyError(f'Failed to get API key: {str(e)}')", "successors": []}, {"id": 134, "label": "#134\nlogger.error(f'Unexpected error while getting API key: {str(e)}')\nraise APIKeyError(f'Failed to get API key: {str(e)}')", "successors": []}]}], "functions": [], "classes": []}, {"name": "update_api_key_permissions", "type": "CFG", "blocks": [{"id": 145, "label": "#145\n\"\"\"\n    Update the permissions of an API key.\n    \"\"\"\ntry:", "successors": [{"id": 146, "label": "#146\napi_key = await PrismaAPIKey.prisma().find_unique(where={'id': key_id})", "successors": [{"id": 151, "label": "#151\nif api_key is None:", "successors": [{"id": 152, "label": "#152\nraise APIKeyNotFoundError('No such API key found.')", "successors": []}, {"id": 153, "label": "#153\nif api_key.userId != user_id:", "successors": [{"id": 155, "label": "#155\nraise APIKeyPermissionError(\n    'You do not have permission to update this API key.')", "successors": []}, {"id": 156, "label": "#156\nwhere_clause: APIKeyWhereUniqueInput = {'id': key_id}\nupdated_api_key = await PrismaAPIKey.prisma().update(where=where_clause,\n    data=APIKeyUpdateInput(permissions=permissions))", "successors": [{"id": 158, "label": "#158\nif updated_api_key:", "successors": [{"id": 159, "label": "#159\nreturn APIKeyWithoutHash.from_db(updated_api_key)", "successors": []}, {"id": 160, "label": "#160\nreturn None", "successors": []}]}]}]}]}]}, {"id": 147, "label": "#147\nraise e", "successors": []}, {"id": 148, "label": "#148\nlogger.error(f'Database error while updating API key permissions: {str(e)}')\nraise APIKeyError(f'Failed to update API key permissions: {str(e)}')", "successors": []}, {"id": 149, "label": "#149\nlogger.error(f'Unexpected error while updating API key permissions: {str(e)}')\nraise APIKeyError(f'Failed to update API key permissions: {str(e)}')", "successors": []}]}], "functions": [], "classes": []}], "classes": [{"name": "APIKeyError", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"Base exception for API key operations\"\"\"\npass", "successors": []}], "functions": [], "classes": []}, {"name": "APIKeyNotFoundError", "type": "CFG", "blocks": [{"id": 6, "label": "#6\n\"\"\"Raised when an API key is not found\"\"\"\npass", "successors": []}], "functions": [], "classes": []}, {"name": "APIKeyPermissionError", "type": "CFG", "blocks": [{"id": 9, "label": "#9\n\"\"\"Raised when there are permission issues with API key operations\"\"\"\npass", "successors": []}], "functions": [], "classes": []}, {"name": "APIKeyValidationError", "type": "CFG", "blocks": [{"id": 12, "label": "#12\n\"\"\"Raised when API key validation fails\"\"\"\npass", "successors": []}], "functions": [], "classes": []}, {"name": "APIKey", "type": "CFG", "blocks": [{"id": 15, "label": "#15\nname: str\nprefix: str\nkey: str\nstatus: APIKeyStatus = APIKeyStatus.ACTIVE\npermissions: List[APIKeyPermission]\npostfix: str\ncreated_at: datetime\nlast_used_at: Optional[datetime] = None\nrevoked_at: Optional[datetime] = None\ndescription: Optional[str] = None\nuser_id: str", "successors": []}], "functions": [{"name": "from_db", "type": "CFG", "blocks": [{"id": 17, "label": "#17\ntry:", "successors": [{"id": 18, "label": "#18\nreturn APIKey(id=api_key.id, name=api_key.name, prefix=api_key.prefix,\n    postfix=api_key.postfix, key=api_key.key, status=APIKeyStatus(api_key.\n    status), permissions=[APIKeyPermission(p) for p in api_key.permissions],\n    created_at=api_key.createdAt, last_used_at=api_key.lastUsedAt,\n    revoked_at=api_key.revokedAt, description=api_key.description, user_id=\n    api_key.userId)", "successors": []}, {"id": 19, "label": "#19\nlogger.error(f'Error creating APIKey from db: {str(e)}')\nraise APIKeyError(f'Failed to create API key object: {str(e)}')", "successors": []}]}], "functions": [], "classes": []}], "classes": []}, {"name": "APIKeyWithoutHash", "type": "CFG", "blocks": [{"id": 26, "label": "#26\nid: str\nname: str\nprefix: str\npostfix: str\nstatus: APIKeyStatus\npermissions: List[APIKeyPermission]\ncreated_at: datetime\nlast_used_at: Optional[datetime]\nrevoked_at: Optional[datetime]\ndescription: Optional[str]\nuser_id: str", "successors": []}], "functions": [{"name": "from_db", "type": "CFG", "blocks": [{"id": 28, "label": "#28\ntry:", "successors": [{"id": 29, "label": "#29\nreturn APIKeyWithoutHash(id=api_key.id, name=api_key.name, prefix=api_key.\n    prefix, postfix=api_key.postfix, status=APIKeyStatus(api_key.status),\n    permissions=[APIKeyPermission(p) for p in api_key.permissions],\n    created_at=api_key.createdAt, last_used_at=api_key.lastUsedAt,\n    revoked_at=api_key.revokedAt, description=api_key.description, user_id=\n    api_key.userId)", "successors": []}, {"id": 30, "label": "#30\nlogger.error(f'Error creating APIKeyWithoutHash from db: {str(e)}')\nraise APIKeyError(f'Failed to create API key object: {str(e)}')", "successors": []}]}], "functions": [], "classes": []}], "classes": []}]}
{"file_name": "46.json", "name": "46.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom datetime import datetime\nfrom typing import Any, List\nfrom backend.blocks.exa._auth import ExaCredentials, ExaCredentialsField, ExaCredentialsInput\nfrom backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema\nfrom backend.data.model import SchemaField\nfrom backend.util.request import requests\nfrom .helpers import ContentSettings", "successors": []}], "functions": [], "classes": [{"name": "ExaFindSimilarBlock", "type": "CFG", "blocks": [{"id": 3, "label": "#3", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 11, "label": "#11\nsuper().__init__(id='5e7315d1-af61-4a0c-9350-7c868fa7438a', description=\n    \"Finds similar links using Exa's findSimilar API\", categories={\n    BlockCategory.SEARCH}, input_schema=ExaFindSimilarBlock.Input,\n    output_schema=ExaFindSimilarBlock.Output)", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 14, "label": "#14\nurl = 'https://api.exa.ai/findSimilar'\nheaders = {'Content-Type': 'application/json', 'x-api-key': credentials.\n    api_key.get_secret_value()}\npayload = {'url': input_data.url, 'numResults': input_data.\n    number_of_results, 'contents': input_data.contents.dict()}\noptional_field_mapping = {'include_domains': 'includeDomains',\n    'exclude_domains': 'excludeDomains', 'include_text': 'includeText',\n    'exclude_text': 'excludeText'}", "successors": [{"id": 15, "label": "#15\nfor input_field, api_field in optional_field_mapping.items():", "successors": [{"id": 16, "label": "#16\nvalue = getattr(input_data, input_field)\nif value:", "successors": [{"id": 18, "label": "#18\npayload[api_field] = value", "successors": []}]}, {"id": 17, "label": "#17\ndate_field_mapping = {'start_crawl_date': 'startCrawlDate',\n    'end_crawl_date': 'endCrawlDate', 'start_published_date':\n    'startPublishedDate', 'end_published_date': 'endPublishedDate'}", "successors": [{"id": 20, "label": "#20\nfor input_field, api_field in date_field_mapping.items():", "successors": [{"id": 21, "label": "#21\nvalue = getattr(input_data, input_field, None)\nif value:", "successors": [{"id": 23, "label": "#23\npayload[api_field] = value.strftime('%Y-%m-%dT%H:%M:%S.000Z')", "successors": []}]}, {"id": 22, "label": "#22\ntry:", "successors": [{"id": 25, "label": "#25\nresponse = requests.post(url, headers=headers, json=payload)\nresponse.raise_for_status()\ndata = response.json()\nyield 'results', data.get('results', [])", "successors": []}, {"id": 26, "label": "#26\nyield 'error', str(e)", "successors": [{"id": 29, "label": "#29\nyield 'results', []", "successors": []}]}]}]}]}]}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 5, "label": "#5\ncredentials: ExaCredentialsInput = ExaCredentialsField()\nurl: str = SchemaField(description=\n    'The url for which you would like to find similar links')\nnumber_of_results: int = SchemaField(description=\n    'Number of results to return', default=10, advanced=True)\ninclude_domains: List[str] = SchemaField(description=\n    'Domains to include in search', default=[], advanced=True)\nexclude_domains: List[str] = SchemaField(description=\n    'Domains to exclude from search', default=[], advanced=True)\nstart_crawl_date: datetime = SchemaField(description=\n    'Start date for crawled content')\nend_crawl_date: datetime = SchemaField(description=\n    'End date for crawled content')\nstart_published_date: datetime = SchemaField(description=\n    'Start date for published content')\nend_published_date: datetime = SchemaField(description=\n    'End date for published content')\ninclude_text: List[str] = SchemaField(description=\n    'Text patterns to include (max 1 string, up to 5 words)', default=[],\n    advanced=True)\nexclude_text: List[str] = SchemaField(description=\n    'Text patterns to exclude (max 1 string, up to 5 words)', default=[],\n    advanced=True)\ncontents: ContentSettings = SchemaField(description=\n    'Content retrieval settings', default=ContentSettings(), advanced=True)", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 8, "label": "#8\nresults: List[Any] = SchemaField(description=\n    'List of similar documents with title, URL, published date, author, and score'\n    , default=[])", "successors": []}], "functions": [], "classes": []}]}]}
{"file_name": "47.json", "name": "47.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport asyncio\nimport logging\nimport os\nimport threading\nfrom functools import wraps\nfrom uuid import uuid4\nfrom tenacity import retry, stop_after_attempt, wait_exponential\nfrom backend.util.process import get_service_name\nlogger = logging.getLogger(__name__)", "successors": []}], "functions": [{"name": "_log_prefix", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"\n    Returns a prefix string for logging purposes.\n    This needs to be called on the fly to get the current process ID & service name,\n    not the parent process ID & service name.\n    \"\"\"\nreturn f'[PID-{os.getpid()}|THREAD-{threading.get_native_id()}|{get_service_name()}|{resource_name}-{conn_id}]'", "successors": []}], "functions": [], "classes": []}, {"name": "conn_retry", "type": "CFG", "blocks": [{"id": 7, "label": "#7\nconn_id = str(uuid4())\nreturn decorator", "successors": []}], "functions": [{"name": "on_retry", "type": "CFG", "blocks": [{"id": 9, "label": "#9\nprefix = _log_prefix(resource_name, conn_id)\nexception = retry_state.outcome.exception()", "successors": []}], "functions": [], "classes": []}, {"name": "decorator", "type": "CFG", "blocks": [{"id": 12, "label": "#12\nis_coroutine = asyncio.iscoroutinefunction(func)\nretry_decorator = retry(stop=stop_after_attempt(max_retry + 1), wait=\n    wait_exponential(multiplier=multiplier, min=min_wait, max=max_wait),\n    before_sleep=on_retry, reraise=True)\nwrapped_func = retry_decorator(func)\nreturn async_wrapper if is_coroutine else sync_wrapper", "successors": []}], "functions": [{"name": "sync_wrapper", "type": "CFG", "blocks": [{"id": 14, "label": "#14\nprefix = _log_prefix(resource_name, conn_id)\ntry:", "successors": [{"id": 15, "label": "#15\nresult = wrapped_func(*args, **kwargs)\nlogger.info(f'{prefix} {action_name} completed successfully.')\nreturn result", "successors": []}, {"id": 16, "label": "#16\nlogger.error(f'{prefix} {action_name} failed after retries: {e}')\nraise", "successors": []}]}], "functions": [], "classes": []}, {"name": "async_wrapper", "type": "CFG", "blocks": [{"id": 22, "label": "#22\nprefix = _log_prefix(resource_name, conn_id)\ntry:", "successors": [{"id": 23, "label": "#23\nresult = await wrapped_func(*args, **kwargs)", "successors": [{"id": 26, "label": "#26\nlogger.info(f'{prefix} {action_name} completed successfully.')\nreturn result", "successors": []}]}, {"id": 24, "label": "#24\nlogger.error(f'{prefix} {action_name} failed after retries: {e}')\nraise", "successors": []}]}], "functions": [], "classes": []}], "classes": []}], "classes": []}], "classes": []}
{"file_name": "48.json", "name": "48.json", "type": "CFG", "blocks": [{"id": 1, "label": "#1\n{'name': 'example_script', 'type': 'CFG', 'start_line': 1, 'end_line': 61,\n    'functions': [{'name': 'match_word_pattern', 'type': 'function',\n    'start_line': 1, 'end_line': 55, 'functions': [{'name': 'backtrack',\n    'type': 'function', 'start_line': 19, 'end_line': 51, 'functions': [],\n    'classes': [], 'simplified_code':\n    \"\"\"    def backtrack(pattern_index: int, str_index: int) -> bool:\n        \"\"\\\"\n        >>> backtrack(0, 0)\n        True\n\n        >>> backtrack(0, 1)\n        True\n\n        >>> backtrack(0, 4)\n        False\n        \"\"\\\"\n        if pattern_index == len(pattern) and str_index == len(input_string):\n            return True\n        if pattern_index == len(pattern) or str_index == len(input_string):\n            return False\n        char = pattern[pattern_index]\n        if char in pattern_map:\n            mapped_str = pattern_map[char]\n            if input_string.startswith(mapped_str, str_index):\n                return backtrack(pattern_index + 1, str_index + len(mapped_str))\n            else:\n                return False\n        for end in range(str_index + 1, len(input_string) + 1):\n            substr = input_string[str_index:end]\n            if substr in str_map:\n                continue\n            pattern_map[char] = substr\n            str_map[substr] = char\n            if backtrack(pattern_index + 1, end):\n                return True\n            del pattern_map[char]\n            del str_map[substr]\n        return False\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    'if pattern_index == len(pattern) and str_index == len(input_string):',\n    'successors': [2, 3]}, {'id': 2, 'label': 'return True', 'successors':\n    []}, {'id': 3, 'label':\n    'if pattern_index == len(pattern) or str_index == len(input_string):',\n    'successors': [4, 5]}, {'id': 4, 'label': 'return False', 'successors':\n    []}, {'id': 5, 'label': 'char = pattern[pattern_index]', 'successors':\n    [6]}, {'id': 6, 'label': 'if char in pattern_map:', 'successors': [7, \n    12]}, {'id': 7, 'label': 'mapped_str = pattern_map[char]', 'successors':\n    [8]}, {'id': 8, 'label':\n    'if input_string.startswith(mapped_str, str_index):', 'successors': [9,\n    10]}, {'id': 9, 'label':\n    'return backtrack(pattern_index + 1, str_index + len(mapped_str))',\n    'successors': []}, {'id': 10, 'label': 'else:', 'successors': [11]}, {\n    'id': 11, 'label': 'return False', 'successors': []}, {'id': 12,\n    'label': 'for end in range(str_index + 1, len(input_string) + 1):',\n    'successors': [13, 21]}, {'id': 13, 'label':\n    'substr = input_string[str_index:end]', 'successors': [14]}, {'id': 14,\n    'label': 'if substr in str_map:', 'successors': [15, 16]}, {'id': 15,\n    'label': 'continue', 'successors': [21]}, {'id': 16, 'label':\n    \"\"\"pattern_map[char] = substr\nstr_map[substr] = char\"\"\", 'successors':\n    [17]}, {'id': 17, 'label': 'if backtrack(pattern_index + 1, end):',\n    'successors': [18, 19]}, {'id': 18, 'label': 'return True',\n    'successors': []}, {'id': 19, 'label':\n    \"\"\"del pattern_map[char]\ndel str_map[substr]\"\"\", 'successors': [21]}, {\n    'id': 21, 'label': 'pass', 'successors': [12]}, {'id': 22, 'label':\n    'return False', 'successors': []}]}], 'classes': [], 'simplified_code':\n    \"\"\"def match_word_pattern(pattern: str, input_string: str) -> bool:\n    \"\"\\\"\n    Determine if a given pattern matches a string using backtracking.\n\n    pattern: The pattern to match.\n    input_string: The string to match against the pattern.\n    return: True if the pattern matches the string, False otherwise.\n\n    >>> match_word_pattern(\"aba\", \"GraphTreesGraph\")\n    True\n\n    >>> match_word_pattern(\"xyx\", \"PythonRubyPython\")\n    True\n\n    >>> match_word_pattern(\"GG\", \"PythonJavaPython\")\n    False\n    \"\"\\\"\n\n        return False\n\n    pattern_map: dict[str, str] = {}\n    str_map: dict[str, str] = {}\n    return backtrack(0, 0)\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    'def match_word_pattern(pattern: str, input_string: str) -> bool:',\n    'successors': [2]}, {'id': 2, 'label':\n    \"\"\"\"\"\\\"\n    Determine if a given pattern matches a string using backtracking.\n\n    pattern: The pattern to match.\n    input_string: The string to match against the pattern.\n    return: True if the pattern matches the string, False otherwise.\n\n    >>> match_word_pattern(\"aba\", \"GraphTreesGraph\")\n    True\n\n    >>> match_word_pattern(\"xyx\", \"PythonRubyPython\")\n    True\n\n    >>> match_word_pattern(\"GG\", \"PythonJavaPython\")\n    False\n    \"\"\\\"\"\"\"\n    , 'successors': [3]}, {'id': 3, 'label':\n    \"\"\"pattern_map: dict[str, str] = {}\n    str_map: dict[str, str] = {}\"\"\",\n    'successors': [4]}, {'id': 4, 'label': 'return backtrack(0, 0)',\n    'successors': []}]}], 'classes': [], 'simplified_code':\n    \"\"\"    return backtrack(0, 0)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\"\"\"\n    , 'blocks': [{'id': 1, 'label': 'return backtrack(0, 0)', 'successors':\n    []}, {'id': 2, 'label': 'if __name__ == \"__main__\":', 'successors': [3]\n    }, {'id': 3, 'label': \"\"\"import doctest\n\ndoctest.testmod()\"\"\",\n    'successors': []}]}", "successors": []}], "functions": [], "classes": []}
{"file_name": "49.json", "name": "49.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema\nfrom backend.data.model import ContributorDetails, SchemaField", "successors": []}], "functions": [], "classes": [{"name": "ReadCsvBlock", "type": "CFG", "blocks": [{"id": 3, "label": "#3", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 11, "label": "#11\nsuper().__init__(id='acf7625e-d2cb-4941-bfeb-2819fc6fc015', input_schema=\n    ReadCsvBlock.Input, output_schema=ReadCsvBlock.Output, description=\n    'Reads a CSV file and outputs the data as a list of dictionaries and individual rows via rows.'\n    , contributors=[ContributorDetails(name='Nicholas Tindle')], categories\n    ={BlockCategory.TEXT, BlockCategory.DATA}, test_input={'contents':\n    \"\"\"a, b, c\n1,2,3\n4,5,6\"\"\"}, test_output=[('row', {'a': '1', 'b': '2',\n    'c': '3'}), ('row', {'a': '4', 'b': '5', 'c': '6'}), ('all_data', [{'a':\n    '1', 'b': '2', 'c': '3'}, {'a': '4', 'b': '5', 'c': '6'}])])", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 14, "label": "#14\nimport csv\nfrom io import StringIO\ncsv_file = StringIO(input_data.contents)\nreader = csv.reader(csv_file, delimiter=input_data.delimiter, quotechar=\n    input_data.quotechar, escapechar=input_data.escapechar)\nheader = None\nif input_data.has_header:", "successors": [{"id": 15, "label": "#15\nheader = next(reader)\nif input_data.strip:", "successors": [{"id": 17, "label": "#17\nheader = [h.strip() for h in header]", "successors": [{"id": 16, "label": "#16\nfor _ in range(input_data.skip_rows):", "successors": [{"id": 19, "label": "#19\nnext(reader)", "successors": []}, {"id": 20, "label": "#20\nall_data = []", "successors": [{"id": 33, "label": "#33\nfor row in reader:", "successors": [{"id": 34, "label": "#34\nprocessed_row = process_row(row)\nall_data.append(processed_row)\nyield 'row', processed_row", "successors": []}, {"id": 35, "label": "#35\nyield 'all_data', all_data", "successors": []}]}]}]}]}]}]}], "functions": [{"name": "process_row", "type": "CFG", "blocks": [{"id": 22, "label": "#22\ndata = {}", "successors": [{"id": 23, "label": "#23\nfor i, value in enumerate(row):", "successors": [{"id": 24, "label": "#24\nif i not in input_data.skip_columns:", "successors": [{"id": 26, "label": "#26\nif input_data.has_header and header:", "successors": [{"id": 28, "label": "#28\ndata[header[i]] = value.strip() if input_data.strip else value", "successors": []}, {"id": 30, "label": "#30\ndata[str(i)] = value.strip() if input_data.strip else value", "successors": []}]}]}, {"id": 25, "label": "#25\nreturn data", "successors": []}]}]}], "functions": [], "classes": []}], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 5, "label": "#5\ncontents: str = SchemaField(description=\n    'The contents of the CSV file to read', placeholder=\n    \"\"\"a, b, c\n1,2,3\n4,5,6\"\"\")\ndelimiter: str = SchemaField(description=\n    'The delimiter used in the CSV file', default=',')\nquotechar: str = SchemaField(description=\n    'The character used to quote fields', default='\"')\nescapechar: str = SchemaField(description=\n    'The character used to escape the delimiter', default='\\\\')\nhas_header: bool = SchemaField(description=\n    'Whether the CSV file has a header row', default=True)\nskip_rows: int = SchemaField(description=\n    'The number of rows to skip from the start of the file', default=0)\nstrip: bool = SchemaField(description=\n    'Whether to strip whitespace from the values', default=True)\nskip_columns: list[str] = SchemaField(description=\n    'The columns to skip from the start of the row', default=[])", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 8, "label": "#8\nrow: dict[str, str] = SchemaField(description=\n    'The data produced from each row in the CSV file')\nall_data: list[dict[str, str]] = SchemaField(description=\n    'All the data in the CSV file as a list of rows')", "successors": []}], "functions": [], "classes": []}]}]}
{"file_name": "50.json", "name": "50.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom enum import Enum\nfrom typing import Literal\nfrom pydantic import BaseModel, SecretStr\nfrom backend.data.model import APIKeyCredentials, CredentialsField, CredentialsMetaInput\nfrom backend.integrations.providers import ProviderName\nSlant3DCredentialsInput = CredentialsMetaInput[Literal[ProviderName.SLANT3D\n    ], Literal['api_key']]\nTEST_CREDENTIALS = APIKeyCredentials(id=\n    '01234567-89ab-cdef-0123-456789abcdef', provider='slant3d', api_key=\n    SecretStr('mock-slant3d-api-key'), title='Mock Slant3D API key',\n    expires_at=None)\nTEST_CREDENTIALS_INPUT = {'provider': TEST_CREDENTIALS.provider, 'id':\n    TEST_CREDENTIALS.id, 'type': TEST_CREDENTIALS.type, 'title':\n    TEST_CREDENTIALS.title}", "successors": []}], "functions": [{"name": "Slant3DCredentialsField", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nreturn CredentialsField(description='Slant3D API key for authentication')", "successors": []}], "functions": [], "classes": []}], "classes": [{"name": "CustomerDetails", "type": "CFG", "blocks": [{"id": 7, "label": "#7\nname: str\nemail: str\nphone: str\naddress: str\ncity: str\nstate: str\nzip: str\ncountry_iso: str = 'US'\nis_residential: bool = True", "successors": []}], "functions": [], "classes": []}, {"name": "Color", "type": "CFG", "blocks": [{"id": 10, "label": "#10\nWHITE = 'white'\nBLACK = 'black'", "successors": []}], "functions": [], "classes": []}, {"name": "Profile", "type": "CFG", "blocks": [{"id": 13, "label": "#13\nPLA = 'PLA'\nPETG = 'PETG'", "successors": []}], "functions": [], "classes": []}, {"name": "OrderItem", "type": "CFG", "blocks": [{"id": 16, "label": "#16\nfile_url: str\nquantity: str\ncolor: Color = Color.WHITE\nprofile: Profile = Profile.PLA", "successors": []}], "functions": [], "classes": []}, {"name": "Filament", "type": "CFG", "blocks": [{"id": 19, "label": "#19\nfilament: str\nhexColor: str\ncolorTag: str\nprofile: str", "successors": []}], "functions": [], "classes": []}]}
{"file_name": "51.json", "name": "51.json", "type": "CFG", "blocks": [{"id": 1, "label": "#1\n{'name': 'example_script', 'type': 'CFG', 'start_line': 1, 'end_line': 66,\n    'functions': [{'name': 'backtrack', 'type': 'function', 'start_line': \n    16, 'end_line': 38, 'functions': [], 'classes': [], 'simplified_code':\n    \"\"\"def backtrack(\n    candidates: list, path: list, answer: list, target: int, previous_index: int\n) -> None:\n    \"\"\\\"\n    A recursive function that searches for possible combinations. Backtracks in case\n    of a bigger current combination value than the target value.\n\n    Parameters\n    ----------\n    previous_index: Last index from the previous search\n    target: The value we need to obtain by summing our integers in the path list.\n    answer: A list of possible combinations\n    path: Current combination\n    candidates: A list of integers we can use.\n    \"\"\\\"\n    if target == 0:\n        answer.append(path.copy())\n    else:\n        for index in range(previous_index, len(candidates)):\n            if target >= candidates[index]:\n                path.append(candidates[index])\n                backtrack(candidates, path, answer, target - candidates[index], index)\n                path.pop(len(path) - 1)\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"def backtrack(\n    candidates: list, path: list, answer: list, target: int, previous_index: int\n) -> None:\"\"\"\n    , 'successors': [2]}, {'id': 2, 'label': 'if target == 0:',\n    'successors': [3, 4]}, {'id': 3, 'label': 'answer.append(path.copy())',\n    'successors': []}, {'id': 4, 'label': 'else:', 'successors': [5]}, {\n    'id': 5, 'label':\n    'for index in range(previous_index, len(candidates)):', 'successors': [\n    6, 7]}, {'id': 6, 'label': 'if target >= candidates[index]:',\n    'successors': [7, 9]}, {'id': 7, 'label':\n    'path.append(candidates[index])', 'successors': [8]}, {'id': 8, 'label':\n    'backtrack(candidates, path, answer, target - candidates[index], index)',\n    'successors': [9]}, {'id': 9, 'label': 'path.pop(len(path) - 1)',\n    'successors': [5]}]}, {'name': 'combination_sum', 'type': 'function',\n    'start_line': 41, 'end_line': 55, 'functions': [], 'classes': [],\n    'simplified_code':\n    \"\"\"def combination_sum(candidates: list, target: int) -> list:\n    \"\"\\\"\n    >>> combination_sum([2, 3, 5], 8)\n    [[2, 2, 2, 2], [2, 3, 3], [3, 5]]\n    >>> combination_sum([2, 3, 6, 7], 7)\n    [[2, 2, 3], [7]]\n    >>> combination_sum([-8, 2.3, 0], 1)\n    Traceback (most recent call last):\n    RecursionError: maximum recursion depth exceeded\n    \"\"\\\"\n    path = []  # type: list[int]\n    answer = []  # type: list[int]\n    backtrack(candidates, path, answer, target, 0)\n    return answer\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"def combination_sum(candidates: list, target: int) -> list:\n    \"\"\\\"\n    >>> combination_sum([2, 3, 5], 8)\n    [[2, 2, 2, 2], [2, 3, 3], [3, 5]]\n    >>> combination_sum([2, 3, 6, 7], 7)\n    [[2, 2, 3], [7]]\n    >>> combination_sum([-8, 2.3, 0], 1)\n    Traceback (most recent call last):\n    RecursionError: maximum recursion depth exceeded\n    \"\"\\\"\"\"\"\n    , 'successors': [2]}, {'id': 2, 'label': 'path = []  # type: list[int]',\n    'successors': [3]}, {'id': 3, 'label': 'answer = []  # type: list[int]',\n    'successors': [4]}, {'id': 4, 'label':\n    'backtrack(candidates, path, answer, target, 0)', 'successors': [5]}, {\n    'id': 5, 'label': 'return answer', 'successors': []}]}, {'name': 'main',\n    'type': 'function', 'start_line': 58, 'end_line': 59, 'functions': [],\n    'classes': [], 'simplified_code':\n    \"\"\"def main() -> None:\n    print(combination_sum([-8, 2.3, 0], 1))\"\"\",\n    'blocks': [{'id': 1, 'label':\n    \"\"\"def main() -> None:\n    print(combination_sum([-8, 2.3, 0], 1))\"\"\",\n    'successors': []}]}], 'classes': [], 'simplified_code':\n    \"\"\"\"\"\\\"\nIn the Combination Sum problem, we are given a list consisting of distinct integers.\nWe need to find all the combinations whose sum equals to target given.\nWe can use an element more than one.\n\nTime complexity(Average Case): O(n!)\n\nConstraints:\n1 <= candidates.length <= 30\n2 <= candidates[i] <= 40\nAll elements of candidates are distinct.\n1 <= target <= 40\n\"\"\\\"\n\n\n                path.pop(len(path) - 1)\n\n\n    return answer\n\n\n    print(combination_sum([-8, 2.3, 0], 1))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    main()\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"def combination_sum(candidates, target):\n    def backtrack(start, target, path):\n        if target == 0:\n            answer.append(list(path))\n            return\n        for i in range(start, len(candidates)):\n            if candidates[i] > target:\n                continue\n            path.append(candidates[i])\n            backtrack(i, target - candidates[i], path)\n            path.pop(len(path) - 1)\n    answer = []\n    backtrack(0, target, [])\n    return answer\"\"\"\n    , 'successors': [2]}, {'id': 2, 'label':\n    \"\"\"def main():\n    print(combination_sum([-8, 2.3, 0], 1))\"\"\",\n    'successors': [3]}, {'id': 3, 'label':\n    \"\"\"if __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n    main()\"\"\"\n    , 'successors': []}]}", "successors": []}], "functions": [], "classes": []}
{"file_name": "52.json", "name": "52.json", "type": "CFG", "blocks": [{"id": 1, "label": "#1\n{'name': 'example_script', 'type': 'CFG', 'start_line': 1, 'end_line': 34,\n    'functions': [], 'classes': [{'name': 'APIKeyContainer', 'type':\n    'class', 'start_line': 6, 'end_line': 12, 'functions': [],\n    'simplified_code':\n    \"\"\"class APIKeyContainer(NamedTuple):\n    \"\"\\\"Container for API key parts.\"\"\\\"\n\n    raw: str\n    prefix: str\n    postfix: str\n    hash: str\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"class APIKeyContainer(NamedTuple):\n    \"\"\\\"Container for API key parts.\"\"\\\"\n\n    raw: str\n    prefix: str\n    postfix: str\n    hash: str\"\"\"\n    , 'successors': []}]}, {'name': 'APIKeyManager', 'type': 'class',\n    'start_line': 15, 'end_line': 34, 'functions': [{'name':\n    'generate_api_key', 'type': 'function', 'start_line': 20, 'end_line': \n    28, 'functions': [], 'classes': [], 'simplified_code':\n    \"\"\"    def generate_api_key(self) -> APIKeyContainer:\n        \"\"\\\"Generate a new API key with all its parts.\"\"\\\"\n        raw_key = f\"{self.PREFIX}{secrets.token_urlsafe(32)}\"\n        return APIKeyContainer(\n            raw=raw_key,\n            prefix=raw_key[: self.PREFIX_LENGTH],\n            postfix=raw_key[-self.POSTFIX_LENGTH :],\n            hash=hashlib.sha256(raw_key.encode()).hexdigest(),\n        )\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"def generate_api_key(self) -> APIKeyContainer:\n    \"\"\\\"Generate a new API key with all its parts.\"\"\\\"\n    raw_key = f\"{self.PREFIX}{secrets.token_urlsafe(32)}\\\"\"\"\"\n    , 'successors': [2]}, {'id': 2, 'label':\n    \"\"\"return APIKeyContainer(\n    raw=raw_key,\n    prefix=raw_key[: self.PREFIX_LENGTH],\n    postfix=raw_key[-self.POSTFIX_LENGTH :],\n    hash=hashlib.sha256(raw_key.encode()).hexdigest(),\n)\"\"\"\n    , 'successors': []}]}, {'name': 'verify_api_key', 'type': 'function',\n    'start_line': 30, 'end_line': 34, 'functions': [], 'classes': [],\n    'simplified_code':\n    \"\"\"    def verify_api_key(self, provided_key: str, stored_hash: str) -> bool:\n        \"\"\\\"Verify if a provided API key matches the stored hash.\"\"\\\"\n        if not provided_key.startswith(self.PREFIX):\n            return False\n        return hashlib.sha256(provided_key.encode()).hexdigest() == stored_hash\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    'if not provided_key.startswith(self.PREFIX):', 'successors': [2, 3]},\n    {'id': 2, 'label': 'return False', 'successors': []}, {'id': 3, 'label':\n    'return hashlib.sha256(provided_key.encode()).hexdigest() == stored_hash',\n    'successors': []}]}], 'simplified_code':\n    \"\"\"class APIKeyManager:\n    PREFIX: str = \"agpt_\"\n    PREFIX_LENGTH: int = 8\n    POSTFIX_LENGTH: int = 8\n\n        )\n\n        return hashlib.sha256(provided_key.encode()).hexdigest() == stored_hash\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"class APIKeyManager:\n    PREFIX: str = \"agpt_\"\n    PREFIX_LENGTH: int = 8\n    POSTFIX_LENGTH: int = 8\n\n    def validate_key(self, provided_key: str, stored_hash: str) -> bool:\"\"\"\n    , 'successors': [2]}, {'id': 2, 'label':\n    'if not provided_key.startswith(self.PREFIX):', 'successors': [4, 3]},\n    {'id': 3, 'label': 'return False', 'successors': []}, {'id': 4, 'label':\n    'return hashlib.sha256(provided_key.encode()).hexdigest() == stored_hash',\n    'successors': []}]}], 'simplified_code':\n    \"\"\"import hashlib\nimport secrets\nfrom typing import NamedTuple\n\n\n    hash: str\n\n\n        return hashlib.sha256(provided_key.encode()).hexdigest() == stored_hash\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"import hashlib\nimport secrets\nfrom typing import NamedTuple\n\n\n    hash: str\n\n\n        return hashlib.sha256(provided_key.encode()).hexdigest() == stored_hash\"\"\"\n    , 'successors': []}]}", "successors": []}], "functions": [], "classes": []}
{"file_name": "53.json", "name": "53.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport logging\nimport pytest\nfrom prisma.models import User\nfrom backend.blocks.basic import FindInDictionaryBlock, StoreValueBlock\nfrom backend.blocks.maths import CalculatorBlock, Operation\nfrom backend.data import execution, graph\nfrom backend.server.model import CreateGraph\nfrom backend.server.rest_api import AgentServer\nfrom backend.usecases.sample import create_test_graph, create_test_user\nfrom backend.util.test import SpinTestServer, wait_execution\nlogger = logging.getLogger(__name__)", "successors": []}], "functions": [{"name": "create_graph", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nlogger.info(f'Creating graph for user {u.id}')\nreturn await s.agent_server.test_create_graph(CreateGraph(graph=g), u.id)", "successors": []}], "functions": [], "classes": []}, {"name": "execute_graph", "type": "CFG", "blocks": [{"id": 7, "label": "#7\nlogger.info(f'Executing graph {test_graph.id} for user {test_user.id}')\nlogger.info(f'Input data: {input_data}')\nresponse = await agent_server.test_execute_graph(test_graph.id, input_data,\n    test_user.id)", "successors": [{"id": 8, "label": "#8\ngraph_exec_id = response['id']\nlogger.info(f'Created execution with ID: {graph_exec_id}')\nresult = await wait_execution(test_user.id, test_graph.id, graph_exec_id)", "successors": [{"id": 9, "label": "#9\nlogger.info(f'Execution completed with {len(result)} results')\nassert result and len(result) == num_execs", "successors": [{"id": 11, "label": "#11\nreturn graph_exec_id", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "assert_sample_graph_executions", "type": "CFG", "blocks": [{"id": 15, "label": "#15\nlogger.info(f'Checking execution results for graph {test_graph.id}')\nexecutions = await agent_server.test_get_graph_run_node_execution_results(\n    test_graph.id, graph_exec_id, test_user.id)", "successors": [{"id": 16, "label": "#16\noutput_list = [{'result': ['Hello']}, {'result': ['World']}]\ninput_list = [{'name': 'input_1', 'value': 'Hello'}, {'name': 'input_2',\n    'value': 'World'}]\nexec = executions[0]\nlogger.info(f'Checking first StoreValueBlock execution: {exec}')\nassert exec.status == execution.ExecutionStatus.COMPLETED", "successors": [{"id": 18, "label": "#18\nassert exec.graph_exec_id == graph_exec_id", "successors": [{"id": 20, "label": "#20\nassert exec.output_data in output_list, f'Output data: {exec.output_data} and {output_list}'", "successors": [{"id": 22, "label": "#22\nassert exec.input_data in input_list, f'Input data: {exec.input_data} and {input_list}'", "successors": [{"id": 24, "label": "#24\nassert exec.node_id in [test_graph.nodes[0].id, test_graph.nodes[1].id]", "successors": [{"id": 26, "label": "#26\nexec = executions[1]\nlogger.info(f'Checking second StoreValueBlock execution: {exec}')\nassert exec.status == execution.ExecutionStatus.COMPLETED", "successors": [{"id": 28, "label": "#28\nassert exec.graph_exec_id == graph_exec_id", "successors": [{"id": 30, "label": "#30\nassert exec.output_data in output_list, f'Output data: {exec.output_data} and {output_list}'", "successors": [{"id": 32, "label": "#32\nassert exec.input_data in input_list, f'Input data: {exec.input_data} and {input_list}'", "successors": [{"id": 34, "label": "#34\nassert exec.node_id in [test_graph.nodes[0].id, test_graph.nodes[1].id]", "successors": [{"id": 36, "label": "#36\nexec = executions[2]\nlogger.info(f'Checking FillTextTemplateBlock execution: {exec}')\nassert exec.status == execution.ExecutionStatus.COMPLETED", "successors": [{"id": 38, "label": "#38\nassert exec.graph_exec_id == graph_exec_id", "successors": [{"id": 40, "label": "#40\nassert exec.output_data == {'output': ['Hello, World!!!']}", "successors": [{"id": 42, "label": "#42\nassert exec.input_data == {'format': '{a}, {b}{c}', 'values': {'a': 'Hello',\n    'b': 'World', 'c': '!!!'}, 'values_#_a': 'Hello', 'values_#_b': 'World',\n    'values_#_c': '!!!'}", "successors": [{"id": 44, "label": "#44\nassert exec.node_id == test_graph.nodes[2].id", "successors": [{"id": 46, "label": "#46\nexec = executions[3]\nlogger.info(f'Checking PrintToConsoleBlock execution: {exec}')\nassert exec.status == execution.ExecutionStatus.COMPLETED", "successors": [{"id": 48, "label": "#48\nassert exec.graph_exec_id == graph_exec_id", "successors": [{"id": 50, "label": "#50\nassert exec.output_data == {'status': ['printed']}", "successors": [{"id": 52, "label": "#52\nassert exec.input_data == {'text': 'Hello, World!!!'}", "successors": [{"id": 54, "label": "#54\nassert exec.node_id == test_graph.nodes[3].id", "successors": []}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}], "functions": [], "classes": []}, {"name": "test_agent_execution", "type": "CFG", "blocks": [{"id": 59, "label": "#59\nlogger.info('Starting test_agent_execution')\ntest_user = await create_test_user()", "successors": [{"id": 60, "label": "#60\ntest_graph = await create_graph(server, create_test_graph(), test_user)", "successors": [{"id": 61, "label": "#61\ndata = {'input_1': 'Hello', 'input_2': 'World'}\ngraph_exec_id = await execute_graph(server.agent_server, test_graph,\n    test_user, data, 4)", "successors": [{"id": 62, "label": "#62\nawait assert_sample_graph_executions(server.agent_server, test_graph,\n    test_user, graph_exec_id)", "successors": [{"id": 63, "label": "#63\nlogger.info('Completed test_agent_execution')", "successors": []}]}]}]}]}], "functions": [], "classes": []}, {"name": "test_input_pin_always_waited", "type": "CFG", "blocks": [{"id": 66, "label": "#66\n\"\"\"\n    This test is asserting that the input pin should always be waited for the execution,\n    even when default value on that pin is defined, the value has to be ignored.\n\n    Test scenario:\n    StoreValueBlock1\n                \\\\ input\n                     >------- FindInDictionaryBlock | input_default: key: \"\", input: {}\n                // key\n    StoreValueBlock2\n    \"\"\"\nlogger.info('Starting test_input_pin_always_waited')\nnodes = [graph.Node(block_id=StoreValueBlock().id, input_default={'input':\n    {'key1': 'value1', 'key2': 'value2'}}), graph.Node(block_id=\n    StoreValueBlock().id, input_default={'input': 'key2'}), graph.Node(\n    block_id=FindInDictionaryBlock().id, input_default={'key': '', 'input':\n    {}})]\nlinks = [graph.Link(source_id=nodes[0].id, sink_id=nodes[2].id, source_name\n    ='output', sink_name='input'), graph.Link(source_id=nodes[1].id,\n    sink_id=nodes[2].id, source_name='output', sink_name='key')]\ntest_graph = graph.Graph(name='TestGraph', description='Test graph', nodes=\n    nodes, links=links)\ntest_user = await create_test_user()", "successors": [{"id": 67, "label": "#67\ntest_graph = await create_graph(server, test_graph, test_user)", "successors": [{"id": 68, "label": "#68\ngraph_exec_id = await execute_graph(server.agent_server, test_graph,\n    test_user, {}, 3)", "successors": [{"id": 69, "label": "#69\nlogger.info('Checking execution results')\nexecutions = (await server.agent_server.\n    test_get_graph_run_node_execution_results(test_graph.id, graph_exec_id,\n    test_user.id))", "successors": [{"id": 70, "label": "#70\nassert len(executions) == 3", "successors": [{"id": 72, "label": "#72\nassert executions[2].status == execution.ExecutionStatus.COMPLETED", "successors": [{"id": 74, "label": "#74\nassert executions[2].output_data == {'output': ['value2']}", "successors": [{"id": 76, "label": "#76\nlogger.info('Completed test_input_pin_always_waited')", "successors": []}]}]}]}]}]}]}]}], "functions": [], "classes": []}, {"name": "test_static_input_link_on_graph", "type": "CFG", "blocks": [{"id": 79, "label": "#79\n\"\"\"\n    This test is asserting the behaviour of static input link, e.g: reusable input link.\n\n    Test scenario:\n    *StoreValueBlock1*===a=========\\\\\n    *StoreValueBlock2*===a=====\\\\  ||\n    *StoreValueBlock3*===a===*MathBlock*====b / static====*StoreValueBlock5*\n    *StoreValueBlock4*=========================================//\n\n    In this test, there will be three input waiting in the MathBlock input pin `a`.\n    And later, another output is produced on input pin `b`, which is a static link,\n    this input will complete the input of those three incomplete executions.\n    \"\"\"\nlogger.info('Starting test_static_input_link_on_graph')\nnodes = [graph.Node(block_id=StoreValueBlock().id, input_default={'input': \n    4}), graph.Node(block_id=StoreValueBlock().id, input_default={'input': \n    4}), graph.Node(block_id=StoreValueBlock().id, input_default={'input': \n    4}), graph.Node(block_id=StoreValueBlock().id, input_default={'input': \n    5}), graph.Node(block_id=StoreValueBlock().id), graph.Node(block_id=\n    CalculatorBlock().id, input_default={'operation': Operation.ADD.value})]\nlinks = [graph.Link(source_id=nodes[0].id, sink_id=nodes[5].id, source_name\n    ='output', sink_name='a'), graph.Link(source_id=nodes[1].id, sink_id=\n    nodes[5].id, source_name='output', sink_name='a'), graph.Link(source_id\n    =nodes[2].id, sink_id=nodes[5].id, source_name='output', sink_name='a'),\n    graph.Link(source_id=nodes[3].id, sink_id=nodes[4].id, source_name=\n    'output', sink_name='input'), graph.Link(source_id=nodes[4].id, sink_id\n    =nodes[5].id, source_name='output', sink_name='b', is_static=True)]\ntest_graph = graph.Graph(name='TestGraph', description='Test graph', nodes=\n    nodes, links=links)\ntest_user = await create_test_user()", "successors": [{"id": 80, "label": "#80\ntest_graph = await create_graph(server, test_graph, test_user)", "successors": [{"id": 81, "label": "#81\ngraph_exec_id = await execute_graph(server.agent_server, test_graph,\n    test_user, {}, 8)", "successors": [{"id": 82, "label": "#82\nlogger.info('Checking execution results')\nexecutions = (await server.agent_server.\n    test_get_graph_run_node_execution_results(test_graph.id, graph_exec_id,\n    test_user.id))", "successors": [{"id": 83, "label": "#83\nassert len(executions) == 8", "successors": [{"id": 85, "label": "#85\nfor i, exec_data in enumerate(executions[-3:]):", "successors": [{"id": 86, "label": "#86\nlogger.info(f'Checking execution {i + 1} of last 3: {exec_data}')\nassert exec_data.status == execution.ExecutionStatus.COMPLETED", "successors": [{"id": 89, "label": "#89\nassert exec_data.output_data == {'result': [9]}", "successors": []}]}, {"id": 87, "label": "#87\nlogger.info('Completed test_static_input_link_on_graph')", "successors": []}]}]}]}]}]}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "54.json", "name": "54.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport re\nimport sys\nfrom string import punctuation\nfrom typing import List, Tuple, Dict\npunctuation = punctuation.replace('()', '')\nanchor = '###'\nauth_keys = ['apiKey', 'OAuth', 'X-Mashape-Key', 'User-Agent', 'No']\nhttps_keys = ['Yes', 'No']\ncors_keys = ['Yes', 'No', 'Unknown']\nindex_title = 0\nindex_desc = 1\nindex_auth = 2\nindex_https = 3\nindex_cors = 4\nnum_segments = 5\nmin_entries_per_category = 3\nmax_description_length = 100\nanchor_re = re.compile(anchor + '\\\\s(.+)')\ncategory_title_in_index_re = re.compile('\\\\*\\\\s\\\\[(.*)\\\\]')\nlink_re = re.compile('\\\\[(.+)\\\\]\\\\((http.*)\\\\)')\nAPIList = List[str]\nCategories = Dict[str, APIList]\nCategoriesLineNumber = Dict[str, int]\nif __name__ == '__main__':", "successors": [{"id": 106, "label": "#106\nnum_args = len(sys.argv)\nif num_args < 2:", "successors": [{"id": 108, "label": "#108\nprint('No .md file passed (file should contain Markdown table syntax)')\nsys.exit(1)", "successors": [{"id": 109, "label": "#109\nfilename = sys.argv[1]\nmain(filename)", "successors": []}]}]}]}], "functions": [{"name": "error_message", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nline = line_number + 1\nreturn f'(L{line:03d}) {message}'", "successors": []}], "functions": [], "classes": []}, {"name": "get_categories_content", "type": "CFG", "blocks": [{"id": 7, "label": "#7\ncategories = {}\ncategory_line_num = {}", "successors": [{"id": 8, "label": "#8\nfor line_num, line_content in enumerate(contents):", "successors": [{"id": 9, "label": "#9\nif line_content.startswith(anchor):", "successors": [{"id": 11, "label": "#11\ncategory = line_content.split(anchor)[1].strip()\ncategories[category] = []\ncategory_line_num[category] = line_num", "successors": []}, {"id": 12, "label": "#12\nif not line_content.startswith('|') or line_content.startswith('|---'):", "successors": [{"id": 14, "label": "#14\nraw_title = [raw_content.strip() for raw_content in line_content.split('|')\n    [1:-1]][0]\ntitle_match = link_re.match(raw_title)\nif title_match:", "successors": [{"id": 15, "label": "#15\ntitle = title_match.group(1).upper()\ncategories[category].append(title)", "successors": []}]}]}]}, {"id": 10, "label": "#10\nreturn categories, category_line_num", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "check_alphabetical_order", "type": "CFG", "blocks": [{"id": 20, "label": "#20\nerr_msgs = []\ncategories, category_line_num = get_categories_content(contents=lines)", "successors": [{"id": 21, "label": "#21\nfor category, api_list in categories.items():", "successors": [{"id": 22, "label": "#22\nif sorted(api_list) != api_list:", "successors": [{"id": 24, "label": "#24\nerr_msg = error_message(category_line_num[category],\n    f'{category} category is not alphabetical order')\nerr_msgs.append(err_msg)", "successors": []}]}, {"id": 23, "label": "#23\nreturn err_msgs", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "check_title", "type": "CFG", "blocks": [{"id": 29, "label": "#29\nerr_msgs = []\ntitle_match = link_re.match(raw_title)\nif not title_match:", "successors": [{"id": 30, "label": "#30\nerr_msg = error_message(line_num, 'Title syntax should be \"[TITLE](LINK)\"')\nerr_msgs.append(err_msg)", "successors": [{"id": 31, "label": "#31\nreturn err_msgs", "successors": []}]}, {"id": 32, "label": "#32\ntitle = title_match.group(1)\nif title.upper().endswith(' API'):", "successors": [{"id": 33, "label": "#33\nerr_msg = error_message(line_num,\nerr_msgs.append(err_msg)", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "check_description", "type": "CFG", "blocks": [{"id": 38, "label": "#38\nerr_msgs = []\nfirst_char = description[0]\nif first_char.upper() != first_char:", "successors": [{"id": 39, "label": "#39\nerr_msg = error_message(line_num,\n    'first character of description is not capitalized')\nerr_msgs.append(err_msg)", "successors": [{"id": 40, "label": "#40\nlast_char = description[-1]\nif last_char in punctuation:", "successors": [{"id": 41, "label": "#41\nerr_msg = error_message(line_num,\n    f'description should not end with {last_char}')\nerr_msgs.append(err_msg)", "successors": [{"id": 42, "label": "#42\ndesc_length = len(description)\nif desc_length > max_description_length:", "successors": [{"id": 43, "label": "#43\nerr_msg = error_message(line_num,\n    f'description should not exceed {max_description_length} characters (currently {desc_length})'\n    )\nerr_msgs.append(err_msg)", "successors": [{"id": 44, "label": "#44\nreturn err_msgs", "successors": []}]}]}]}]}]}]}], "functions": [], "classes": []}, {"name": "check_auth", "type": "CFG", "blocks": [{"id": 48, "label": "#48\nerr_msgs = []\nbacktick = '`'\nif auth != 'No' and (not auth.startswith(backtick) or not auth.endswith(", "successors": [{"id": 49, "label": "#49\nerr_msg = error_message(line_num, 'auth value is not enclosed with `backticks`'\n    )\nerr_msgs.append(err_msg)", "successors": [{"id": 50, "label": "#50\nif auth.replace(backtick, '') not in auth_keys:", "successors": [{"id": 51, "label": "#51\nerr_msg = error_message(line_num, f'{auth} is not a valid Auth option')\nerr_msgs.append(err_msg)", "successors": [{"id": 52, "label": "#52\nreturn err_msgs", "successors": []}]}]}]}]}], "functions": [], "classes": []}, {"name": "check_https", "type": "CFG", "blocks": [{"id": 56, "label": "#56\nerr_msgs = []\nif https not in https_keys:", "successors": [{"id": 57, "label": "#57\nerr_msg = error_message(line_num, f'{https} is not a valid HTTPS option')\nerr_msgs.append(err_msg)", "successors": [{"id": 58, "label": "#58\nreturn err_msgs", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "check_cors", "type": "CFG", "blocks": [{"id": 62, "label": "#62\nerr_msgs = []\nif cors not in cors_keys:", "successors": [{"id": 63, "label": "#63\nerr_msg = error_message(line_num, f'{cors} is not a valid CORS option')\nerr_msgs.append(err_msg)", "successors": [{"id": 64, "label": "#64\nreturn err_msgs", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "check_entry", "type": "CFG", "blocks": [{"id": 68, "label": "#68\nraw_title = segments[index_title]\ndescription = segments[index_desc]\nauth = segments[index_auth]\nhttps = segments[index_https]\ncors = segments[index_cors]\ntitle_err_msgs = check_title(line_num, raw_title)\ndesc_err_msgs = check_description(line_num, description)\nauth_err_msgs = check_auth(line_num, auth)\nhttps_err_msgs = check_https(line_num, https)\ncors_err_msgs = check_cors(line_num, cors)\nerr_msgs = [*title_err_msgs, *desc_err_msgs, *auth_err_msgs, *\n    https_err_msgs, *cors_err_msgs]\nreturn err_msgs", "successors": []}], "functions": [], "classes": []}, {"name": "check_file_format", "type": "CFG", "blocks": [{"id": 72, "label": "#72\nerr_msgs = []\ncategory_title_in_index = []\nalphabetical_err_msgs = check_alphabetical_order(lines)\nerr_msgs.extend(alphabetical_err_msgs)\nnum_in_category = min_entries_per_category + 1\ncategory = ''\ncategory_line = 0", "successors": [{"id": 73, "label": "#73\nfor line_num, line_content in enumerate(lines):", "successors": [{"id": 74, "label": "#74\ncategory_title_match = category_title_in_index_re.match(line_content)\nif category_title_match:", "successors": [{"id": 76, "label": "#76\ncategory_title_in_index.append(category_title_match.group(1))", "successors": [{"id": 77, "label": "#77\nif line_content.startswith(anchor):", "successors": [{"id": 78, "label": "#78\ncategory_match = anchor_re.match(line_content)\nif category_match:", "successors": [{"id": 80, "label": "#80\nif category_match.group(1) not in category_title_in_index:", "successors": [{"id": 83, "label": "#83\nerr_msg = error_message(line_num,\n    f'category header ({category_match.group(1)}) not added to Index section')\nerr_msgs.append(err_msg)", "successors": [{"id": 81, "label": "#81\nif num_in_category < min_entries_per_category:", "successors": [{"id": 85, "label": "#85\nerr_msg = error_message(category_line,\n    f'{category} category does not have the minimum {min_entries_per_category} entries (only has {num_in_category})'\n    )\nerr_msgs.append(err_msg)", "successors": [{"id": 86, "label": "#86\ncategory = line_content.split(' ')[1]\ncategory_line = line_num\nnum_in_category = 0", "successors": []}]}]}]}]}, {"id": 82, "label": "#82\nerr_msg = error_message(line_num, 'category header is not formatted correctly')\nerr_msgs.append(err_msg)", "successors": []}]}, {"id": 79, "label": "#79\nif not line_content.startswith('|') or line_content.startswith('|---'):", "successors": [{"id": 88, "label": "#88\nnum_in_category += 1\nsegments = line_content.split('|')[1:-1]\nif len(segments) < num_segments:", "successors": [{"id": 89, "label": "#89\nerr_msg = error_message(line_num,\n    f'entry does not have all the required columns (have {len(segments)}, need {num_segments})'\n    )\nerr_msgs.append(err_msg)", "successors": []}, {"id": 90, "label": "#90\nfor segment in segments:", "successors": [{"id": 91, "label": "#91\nif len(segment) - len(segment.lstrip()) != 1 or len(segment) - len(segment.", "successors": [{"id": 93, "label": "#93\nerr_msg = error_message(line_num,\n    'each segment must start and end with exactly 1 space')\nerr_msgs.append(err_msg)", "successors": []}]}, {"id": 92, "label": "#92\nsegments = [segment.strip() for segment in segments]\nentry_err_msgs = check_entry(line_num, segments)\nerr_msgs.extend(entry_err_msgs)", "successors": []}]}]}]}]}]}]}, {"id": 75, "label": "#75\nreturn err_msgs", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "main", "type": "CFG", "blocks": [{"id": 98, "label": "#98\nwith open(filename, mode='r', encoding='utf-8') as file:", "successors": [{"id": 99, "label": "#99\nlines = list(line.rstrip() for line in file)", "successors": [{"id": 100, "label": "#100\nfile_format_err_msgs = check_file_format(lines)\nif file_format_err_msgs:", "successors": [{"id": 101, "label": "#101\nfor err_msg in file_format_err_msgs:", "successors": [{"id": 103, "label": "#103\nprint(err_msg)", "successors": []}, {"id": 104, "label": "#104\nsys.exit(1)", "successors": []}]}]}]}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "55.json", "name": "55.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport time\nfrom datetime import datetime, timedelta, timezone\nfrom typing import Any\nimport feedparser\nimport pydantic\nfrom backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema\nfrom backend.data.model import SchemaField", "successors": []}], "functions": [], "classes": [{"name": "RSSEntry", "type": "CFG", "blocks": [{"id": 3, "label": "#3\ntitle: str\nlink: str\ndescription: str\npub_date: datetime\nauthor: str\ncategories: list[str]", "successors": []}], "functions": [], "classes": []}, {"name": "ReadRSSFeedBlock", "type": "CFG", "blocks": [{"id": 6, "label": "#6", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 14, "label": "#14\nsuper().__init__(id='5ebe6768-8e5d-41e3-9134-1c7bd89a8d52', input_schema=\n    ReadRSSFeedBlock.Input, output_schema=ReadRSSFeedBlock.Output,\n    description='Reads RSS feed entries from a given URL.', categories={\n    BlockCategory.INPUT}, test_input={'rss_url': 'https://example.com/rss',\n    'time_period': 10000000, 'polling_rate': 1, 'run_continuously': False},\n    test_output=[('entry', RSSEntry(title='Example RSS Item', link=\n    'https://example.com/article', description=\n    'This is an example RSS item description.', pub_date=datetime(2023, 6, \n    23, 12, 30, 0, tzinfo=timezone.utc), author='John Doe', categories=[\n    'Technology', 'News']))], test_mock={'parse_feed': lambda *args, **\n    kwargs: {'entries': [{'title': 'Example RSS Item', 'link':\n    'https://example.com/article', 'summary':\n    'This is an example RSS item description.', 'published_parsed': (2023, \n    6, 23, 12, 30, 0, 4, 174, 0), 'author': 'John Doe', 'tags': [{'term':\n    'Technology'}, {'term': 'News'}]}]}})", "successors": []}], "functions": [], "classes": []}, {"name": "parse_feed", "type": "CFG", "blocks": [{"id": 17, "label": "#17\nreturn feedparser.parse(url)", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 21, "label": "#21\nkeep_going = True\nstart_time = datetime.now(timezone.utc) - timedelta(minutes=input_data.\n    time_period)", "successors": [{"id": 22, "label": "#22\nwhile keep_going:", "successors": [{"id": 23, "label": "#23\nkeep_going = input_data.run_continuously\nfeed = self.parse_feed(input_data.rss_url)", "successors": [{"id": 25, "label": "#25\nfor entry in feed['entries']:", "successors": [{"id": 26, "label": "#26\npub_date = datetime(*entry['published_parsed'][:6], tzinfo=timezone.utc)\nif pub_date > start_time:", "successors": [{"id": 28, "label": "#28\nyield 'entry', RSSEntry(title=entry['title'], link=entry['link'],\n    description=entry.get('summary', ''), pub_date=pub_date, author=entry.\n    get('author', ''), categories=[tag['term'] for tag in entry.get('tags',\n    [])])", "successors": []}]}, {"id": 27, "label": "#27\ntime.sleep(input_data.polling_rate)", "successors": []}]}]}]}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 8, "label": "#8\nrss_url: str = SchemaField(description='The URL of the RSS feed to read',\n    placeholder='https://example.com/rss')\ntime_period: int = SchemaField(description=\n    'The time period to check in minutes relative to the run block runtime, e.g. 60 would check for new entries in the last hour.'\n    , placeholder='1440', default=1440)\npolling_rate: int = SchemaField(description=\n    'The number of seconds to wait between polling attempts.', placeholder=\n    '300')\nrun_continuously: bool = SchemaField(description=\n    'Whether to run the block continuously or just once.', default=True)", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 11, "label": "#11\nentry: RSSEntry = SchemaField(description='The RSS item')", "successors": []}], "functions": [], "classes": []}]}]}
{"file_name": "56.json", "name": "56.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\n\"\"\"\n\nThe nqueens problem is of placing N queens on a N * N\nchess board such that no queen can attack any other queens placed\non that chess board.\nThis means that one queen cannot have any other queen on its horizontal, vertical and\ndiagonal lines.\n\n\"\"\"\nfrom __future__ import annotations\nsolution = []\nn = 8\nboard = [[(0) for i in range(n)] for j in range(n)]\nsolve(board, 0)\nprint('The total number of solutions are:', len(solution))", "successors": []}], "functions": [{"name": "is_safe", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"\n    This function returns a boolean value True if it is safe to place a queen there\n    considering the current state of the board.\n\n    Parameters:\n    board (2D matrix): The chessboard\n    row, column: Coordinates of the cell on the board\n\n    Returns:\n    Boolean Value\n\n    >>> is_safe([[0, 0, 0], [0, 0, 0], [0, 0, 0]], 1, 1)\n    True\n    >>> is_safe([[1, 0, 0], [0, 0, 0], [0, 0, 0]], 1, 1)\n    False\n    \"\"\"\nn = len(board)\nreturn all(board[i][j] != 1 for i, j in zip(range(row, -1, -1), range(\n    column, n))) and all(board[i][j] != 1 for i, j in zip(range(row, -1, -1\n    ), range(column, -1, -1))) and all(board[i][j] != 1 for i, j in zip(\n    range(row, n), range(column, n))) and all(board[i][j] != 1 for i, j in\n    zip(range(row, n), range(column, -1, -1)))", "successors": []}], "functions": [], "classes": []}, {"name": "solve", "type": "CFG", "blocks": [{"id": 7, "label": "#7\n\"\"\"\n    This function creates a state space tree and calls the safe function until it\n    receives a False Boolean and terminates that branch and backtracks to the next\n    possible solution branch.\n    \"\"\"\nif row >= len(board):", "successors": [{"id": 8, "label": "#8\n\"\"\"\n        If the row number exceeds N, we have a board with a successful combination\n        and that combination is appended to the solution list and the board is printed.\n        \"\"\"\nsolution.append(board)\nprintboard(board)\nprint()\nreturn True", "successors": []}, {"id": 9, "label": "#9\nfor i in range(len(board)):", "successors": [{"id": 11, "label": "#11\n\"\"\"\n        For every row, it iterates through each column to check if it is feasible to\n        place a queen there.\n        If all the combinations for that particular branch are successful, the board is\n        reinitialized for the next possible combination.\n        \"\"\"\nif is_safe(board, row, i):", "successors": [{"id": 13, "label": "#13\nboard[row][i] = 1\nsolve(board, row + 1)\nboard[row][i] = 0", "successors": []}]}, {"id": 12, "label": "#12\nreturn False", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "printboard", "type": "CFG", "blocks": [{"id": 18, "label": "#18\n\"\"\"\n    Prints the boards that have a successful combination.\n    \"\"\"", "successors": [{"id": 19, "label": "#19\nfor i in range(len(board)):", "successors": [{"id": 20, "label": "#20\nfor j in range(len(board)):", "successors": [{"id": 22, "label": "#22\nif board[i][j] == 1:", "successors": [{"id": 24, "label": "#24\nprint('Q', end=' ')", "successors": []}, {"id": 26, "label": "#26\nprint('.', end=' ')", "successors": []}]}, {"id": 23, "label": "#23\nprint()", "successors": []}]}]}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "57.json", "name": "57.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport logging\nfrom contextlib import contextmanager\nfrom datetime import datetime\nfrom typing import TYPE_CHECKING\nfrom autogpt_libs.utils.synchronize import RedisKeyedMutex\nfrom redis.lock import Lock as RedisLock\nfrom backend.data import redis\nfrom backend.data.model import Credentials\nfrom backend.integrations.credentials_store import IntegrationCredentialsStore\nfrom backend.integrations.oauth import HANDLERS_BY_NAME\nfrom backend.util.exceptions import MissingConfigError\nfrom backend.util.settings import Settings\nif TYPE_CHECKING:", "successors": [{"id": 2, "label": "#2\nfrom backend.integrations.oauth import BaseOAuthHandler", "successors": [{"id": 3, "label": "#3\nlogger = logging.getLogger(__name__)\nsettings = Settings()", "successors": []}]}]}], "functions": [{"name": "_get_provider_oauth_handler", "type": "CFG", "blocks": [{"id": 69, "label": "#69\nif provider_name not in HANDLERS_BY_NAME:", "successors": [{"id": 70, "label": "#70\nraise KeyError(f\"Unknown provider '{provider_name}'\")", "successors": []}, {"id": 71, "label": "#71\nclient_id = getattr(settings.secrets, f'{provider_name}_client_id')\nclient_secret = getattr(settings.secrets, f'{provider_name}_client_secret')\nif not (client_id and client_secret):", "successors": [{"id": 73, "label": "#73\nraise MissingConfigError(\n    f\"Integration with provider '{provider_name}' is not configured\")", "successors": []}, {"id": 74, "label": "#74\nhandler_class = HANDLERS_BY_NAME[provider_name]\nfrontend_base_url = (settings.config.frontend_base_url or settings.config.\n    platform_base_url)\nreturn handler_class(client_id=client_id, client_secret=client_secret,\n    redirect_uri=f'{frontend_base_url}/auth/integrations/oauth_callback')", "successors": []}]}]}], "functions": [], "classes": []}], "classes": [{"name": "IntegrationCredentialsManager", "type": "CFG", "blocks": [{"id": 5, "label": "#5\n\"\"\"\n    Handles the lifecycle of integration credentials.\n    - Automatically refreshes requested credentials if needed.\n    - Uses locking mechanisms to ensure system-wide consistency and\n      prevent invalidation of in-use tokens.\n\n    ### \u26a0\ufe0f Gotcha\n    With `acquire(..)`, credentials can only be in use in one place at a time (e.g. one\n    block execution).\n\n    ### Locking mechanism\n    - Because *getting* credentials can result in a refresh (= *invalidation* +\n      *replacement*) of the stored credentials, *getting* is an operation that\n      potentially requires read/write access.\n    - Checking whether a token has to be refreshed is subject to an additional `refresh`\n      scoped lock to prevent unnecessary sequential refreshes when multiple executions\n      try to access the same credentials simultaneously.\n    - We MUST lock credentials while in use to prevent them from being invalidated while\n      they are in use, e.g. because they are being refreshed by a different part\n      of the system.\n    - The `!time_sensitive` lock in `acquire(..)` is part of a two-tier locking\n      mechanism in which *updating* gets priority over *getting* credentials.\n      This is to prevent a long queue of waiting *get* requests from blocking essential\n      credential refreshes or user-initiated updates.\n\n    It is possible to implement a reader/writer locking system where either multiple\n    readers or a single writer can have simultaneous access, but this would add a lot of\n    complexity to the mechanism. I don't expect the current (\"simple\") mechanism to\n    cause so much latency that it's worth implementing.\n    \"\"\"", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 7, "label": "#7\nredis_conn = redis.get_redis()\nself._locks = RedisKeyedMutex(redis_conn)\nself.store = IntegrationCredentialsStore()", "successors": []}], "functions": [], "classes": []}, {"name": "create", "type": "CFG", "blocks": [{"id": 10, "label": "#10\nreturn self.store.add_creds(user_id, credentials)", "successors": []}], "functions": [], "classes": []}, {"name": "exists", "type": "CFG", "blocks": [{"id": 14, "label": "#14\nreturn self.store.get_creds_by_id(user_id, credentials_id) is not None", "successors": []}], "functions": [], "classes": []}, {"name": "get", "type": "CFG", "blocks": [{"id": 18, "label": "#18\ncredentials = self.store.get_creds_by_id(user_id, credentials_id)\nif not credentials:", "successors": [{"id": 19, "label": "#19\nreturn None", "successors": []}, {"id": 20, "label": "#20\nif credentials.type == 'oauth2' and credentials.access_token_expires_at:", "successors": [{"id": 22, "label": "#22\nlogger.debug(\n    f'Credentials #{credentials.id} expire at {datetime.fromtimestamp(credentials.access_token_expires_at)}; current time is {datetime.now()}'\n    )\nwith self._locked(user_id, credentials_id, 'refresh'):", "successors": [{"id": 25, "label": "#25\noauth_handler = _get_provider_oauth_handler(credentials.provider)\nif oauth_handler.needs_refresh(credentials):", "successors": [{"id": 27, "label": "#27\nlogger.debug(\n    f\"Refreshing '{credentials.provider}' credentials #{credentials.id}\")\n_lock = None\nif lock:", "successors": [{"id": 29, "label": "#29\n_lock = self._acquire_lock(user_id, credentials_id)", "successors": [{"id": 30, "label": "#30\nfresh_credentials = oauth_handler.refresh_tokens(credentials)\nself.store.update_creds(user_id, fresh_credentials)\nif _lock and _lock.locked():", "successors": [{"id": 31, "label": "#31\n_lock.release()", "successors": [{"id": 32, "label": "#32\ncredentials = fresh_credentials", "successors": [{"id": 23, "label": "#23\nreturn credentials", "successors": []}]}]}]}]}]}]}]}, {"id": 24, "label": "#24\nlogger.debug(f'Credentials #{credentials.id} never expire')", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "acquire", "type": "CFG", "blocks": [{"id": 36, "label": "#36\n\"\"\"\n        \u26a0\ufe0f WARNING: this locks credentials system-wide and blocks both acquiring\n        and updating them elsewhere until the lock is released.\n        See the class docstring for more info.\n        \"\"\"\nwith self._locked(user_id, credentials_id, '!time_sensitive'):", "successors": [{"id": 37, "label": "#37\nlock = self._acquire_lock(user_id, credentials_id)", "successors": [{"id": 38, "label": "#38\ncredentials = self.get(user_id, credentials_id, lock=False)\nif not credentials:", "successors": [{"id": 39, "label": "#39\nraise ValueError(f'Credentials #{credentials_id} for user #{user_id} not found'\n    )", "successors": []}, {"id": 40, "label": "#40\nreturn credentials, lock", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "update", "type": "CFG", "blocks": [{"id": 45, "label": "#45\nwith self._locked(user_id, updated.id):", "successors": [{"id": 46, "label": "#46\nself.store.update_creds(user_id, updated)", "successors": []}]}], "functions": [], "classes": []}, {"name": "delete", "type": "CFG", "blocks": [{"id": 50, "label": "#50\nwith self._locked(user_id, credentials_id):", "successors": [{"id": 51, "label": "#51\nself.store.delete_creds_by_id(user_id, credentials_id)", "successors": []}]}], "functions": [], "classes": []}, {"name": "_acquire_lock", "type": "CFG", "blocks": [{"id": 55, "label": "#55\nkey = f'user:{user_id}', f'credentials:{credentials_id}', *args\nreturn self._locks.acquire(key)", "successors": []}], "functions": [], "classes": []}, {"name": "_locked", "type": "CFG", "blocks": [{"id": 59, "label": "#59\nlock = self._acquire_lock(user_id, credentials_id, *args)\ntry:", "successors": [{"id": 60, "label": "#60\nyield", "successors": []}]}], "functions": [], "classes": []}, {"name": "release_all_locks", "type": "CFG", "blocks": [{"id": 65, "label": "#65\n\"\"\"Call this on process termination to ensure all locks are released\"\"\"\nself._locks.release_all_locks()\nself.store.locks.release_all_locks()", "successors": []}], "functions": [], "classes": []}], "classes": []}]}
{"file_name": "58.json", "name": "58.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom enum import Enum\nfrom typing import Any\nfrom backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema\nfrom backend.data.model import SchemaField", "successors": []}], "functions": [], "classes": [{"name": "ComparisonOperator", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nEQUAL = '=='\nNOT_EQUAL = '!='\nGREATER_THAN = '>'\nLESS_THAN = '<'\nGREATER_THAN_OR_EQUAL = '>='\nLESS_THAN_OR_EQUAL = '<='", "successors": []}], "functions": [], "classes": []}, {"name": "ConditionBlock", "type": "CFG", "blocks": [{"id": 6, "label": "#6", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 14, "label": "#14\nsuper().__init__(id='715696a0-e1da-45c8-b209-c2fa9c3b0be6', input_schema=\n    ConditionBlock.Input, output_schema=ConditionBlock.Output, description=\n    'Handles conditional logic based on comparison operators', categories={\n    BlockCategory.LOGIC}, test_input={'value1': 10, 'operator':\n    ComparisonOperator.GREATER_THAN.value, 'value2': 5, 'yes_value':\n    'Greater', 'no_value': 'Not greater'}, test_output=[('result', True), (\n    'yes_output', 'Greater')])", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 17, "label": "#17\noperator = input_data.operator\nvalue1 = input_data.value1\nif isinstance(value1, str):", "successors": [{"id": 18, "label": "#18\ntry:", "successors": [{"id": 20, "label": "#20\nvalue1 = float(value1.strip())", "successors": [{"id": 19, "label": "#19\nvalue2 = input_data.value2\nif isinstance(value2, str):", "successors": [{"id": 23, "label": "#23\ntry:", "successors": [{"id": 25, "label": "#25\nvalue2 = float(value2.strip())", "successors": [{"id": 24, "label": "#24\nyes_value = (input_data.yes_value if input_data.yes_value is not None else\n    value1)\nno_value = input_data.no_value if input_data.no_value is not None else value2\ncomparison_funcs = {ComparisonOperator.EQUAL: lambda a, b: a == b,\n    ComparisonOperator.NOT_EQUAL: lambda a, b: a != b, ComparisonOperator.\n    GREATER_THAN: lambda a, b: a > b, ComparisonOperator.LESS_THAN: lambda\n    a, b: a < b, ComparisonOperator.GREATER_THAN_OR_EQUAL: lambda a, b: a >=\n    b, ComparisonOperator.LESS_THAN_OR_EQUAL: lambda a, b: a <= b}\nresult = comparison_funcs[operator](value1, value2)\nyield 'result', result", "successors": [{"id": 28, "label": "#28\nif result:", "successors": [{"id": 29, "label": "#29\nyield 'yes_output', yes_value", "successors": []}, {"id": 31, "label": "#31\nyield 'no_output', no_value", "successors": []}]}]}]}, {"id": 26, "label": "#26\nvalue2 = value2.strip()", "successors": []}]}]}]}, {"id": 21, "label": "#21\nvalue1 = value1.strip()", "successors": []}]}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 8, "label": "#8\nvalue1: Any = SchemaField(description=\n    'Enter the first value for comparison', placeholder=\n    \"For example: 10 or 'hello' or True\")\noperator: ComparisonOperator = SchemaField(description=\n    'Choose the comparison operator', placeholder='Select an operator')\nvalue2: Any = SchemaField(description=\n    'Enter the second value for comparison', placeholder=\n    \"For example: 20 or 'world' or False\")\nyes_value: Any = SchemaField(description=\n    '(Optional) Value to output if the condition is true. If not provided, value1 will be used.'\n    , placeholder='Leave empty to use value1, or enter a specific value',\n    default=None)\nno_value: Any = SchemaField(description=\n    '(Optional) Value to output if the condition is false. If not provided, value1 will be used.'\n    , placeholder='Leave empty to use value1, or enter a specific value',\n    default=None)", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 11, "label": "#11\nresult: bool = SchemaField(description=\n    'The result of the condition evaluation (True or False)')\nyes_output: Any = SchemaField(description=\n    'The output value if the condition is true')\nno_output: Any = SchemaField(description=\n    'The output value if the condition is false')", "successors": []}], "functions": [], "classes": []}]}]}
{"file_name": "59.json", "name": "59.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport logging\nimport time\nfrom typing import Sequence\nfrom backend.data import db\nfrom backend.data.block import Block, initialize_blocks\nfrom backend.data.execution import ExecutionResult, ExecutionStatus\nfrom backend.data.model import CREDENTIALS_FIELD_NAME\nfrom backend.data.user import create_default_user\nfrom backend.executor import DatabaseManager, ExecutionManager, ExecutionScheduler\nfrom backend.server.rest_api import AgentServer\nfrom backend.server.utils import get_user_id\nlog = logging.getLogger(__name__)", "successors": []}], "functions": [{"name": "wait_execution", "type": "CFG", "blocks": [{"id": 27, "label": "#27", "successors": [{"id": 36, "label": "#36\nfor i in range(timeout):", "successors": [{"id": 37, "label": "#37\nif await is_execution_completed():", "successors": [{"id": 39, "label": "#39\nreturn await AgentServer().test_get_graph_run_node_execution_results(graph_id,\n    graph_exec_id, user_id)", "successors": []}, {"id": 40, "label": "#40\ntime.sleep(1)", "successors": []}]}, {"id": 38, "label": "#38\nassert False, 'Execution did not complete in time.'", "successors": []}]}]}], "functions": [{"name": "is_execution_completed", "type": "CFG", "blocks": [{"id": 29, "label": "#29\nstatus = await AgentServer().test_get_graph_run_status(graph_exec_id, user_id)", "successors": [{"id": 30, "label": "#30\nlog.info(f'Execution status: {status}')\nif status == ExecutionStatus.FAILED:", "successors": [{"id": 31, "label": "#31\nlog.info('Execution failed')\nraise Exception('Execution failed')", "successors": []}, {"id": 32, "label": "#32\nreturn status == ExecutionStatus.COMPLETED", "successors": []}]}]}], "functions": [], "classes": []}], "classes": []}, {"name": "execute_block_test", "type": "CFG", "blocks": [{"id": 46, "label": "#46\nprefix = f'[Test-{block.name}]'\nif not block.test_input or not block.test_output:", "successors": [{"id": 47, "label": "#47\nlog.info(f'{prefix} No test data provided')\nreturn", "successors": []}, {"id": 48, "label": "#48\nif not isinstance(block.test_input, list):", "successors": [{"id": 50, "label": "#50\nblock.test_input = [block.test_input]", "successors": [{"id": 51, "label": "#51\nif not isinstance(block.test_output, list):", "successors": [{"id": 52, "label": "#52\nblock.test_output = [block.test_output]", "successors": [{"id": 53, "label": "#53\noutput_index = 0\nprefix = ' ' * 4 + prefix", "successors": [{"id": 54, "label": "#54\nfor mock_name, mock_obj in (block.test_mock or {}).items():", "successors": [{"id": 55, "label": "#55\nif hasattr(block, mock_name):", "successors": [{"id": 57, "label": "#57\nsetattr(block, mock_name, mock_obj)", "successors": []}, {"id": 59, "label": "#59\nlog.info(f'{prefix} mock {mock_name} not found in block')", "successors": []}]}, {"id": 56, "label": "#56\nextra_exec_kwargs = {}\nif CREDENTIALS_FIELD_NAME in block.input_schema.model_fields:", "successors": [{"id": 60, "label": "#60\nif not block.test_credentials:", "successors": [{"id": 62, "label": "#62\nraise ValueError(f'{prefix} requires credentials but has no test_credentials')", "successors": []}, {"id": 63, "label": "#63\nextra_exec_kwargs[CREDENTIALS_FIELD_NAME] = block.test_credentials", "successors": [{"id": 61, "label": "#61\nfor input_data in block.test_input:", "successors": [{"id": 65, "label": "#65\nlog.info(f'{prefix} in: {input_data}')", "successors": [{"id": 67, "label": "#67\nfor output_name, output_data in block.execute(input_data, **extra_exec_kwargs):", "successors": [{"id": 68, "label": "#68\nif output_index >= len(block.test_output):", "successors": [{"id": 70, "label": "#70\nraise ValueError(f'{prefix} produced output more than expected')", "successors": []}, {"id": 71, "label": "#71\nex_output_name, ex_output_data = block.test_output[output_index]\ncompare(output_data, ex_output_data)\ncompare(output_name, ex_output_name)\noutput_index += 1", "successors": []}]}]}]}, {"id": 66, "label": "#66\nif output_index < len(block.test_output):", "successors": [{"id": 88, "label": "#88\nraise ValueError(\n    f'{prefix} produced output less than expected. output_index={output_index}, len(block.test_output)={len(block.test_output)}'\n    )", "successors": []}]}]}]}]}]}]}]}]}]}]}]}]}], "functions": [{"name": "compare", "type": "CFG", "blocks": [{"id": 74, "label": "#74\nif data == expected_data:", "successors": [{"id": 75, "label": "#75\nis_matching = True", "successors": [{"id": 76, "label": "#76\nmark = '\u2705' if is_matching else '\u274c'\nlog.info(f'{prefix} {mark} comparing `{data}` vs `{expected_data}`')\nif not is_matching:", "successors": [{"id": 84, "label": "#84\nraise ValueError(f'{prefix}: wrong output {data} vs {expected_data}')", "successors": []}]}]}, {"id": 77, "label": "#77\nif isinstance(expected_data, type):", "successors": [{"id": 78, "label": "#78\nis_matching = isinstance(data, expected_data)", "successors": []}, {"id": 80, "label": "#80\nif callable(expected_data):", "successors": [{"id": 81, "label": "#81\nis_matching = expected_data(data)", "successors": []}, {"id": 83, "label": "#83\nis_matching = False", "successors": []}]}]}]}], "functions": [], "classes": []}], "classes": []}], "classes": [{"name": "SpinTestServer", "type": "CFG", "blocks": [{"id": 3, "label": "#3", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 5, "label": "#5\nself.db_api = DatabaseManager()\nself.exec_manager = ExecutionManager()\nself.agent_server = AgentServer()\nself.scheduler = ExecutionScheduler()", "successors": []}], "functions": [], "classes": []}, {"name": "test_get_user_id", "type": "CFG", "blocks": [{"id": 8, "label": "#8\nreturn '3e53486c-cf57-477e-ba2a-cb02dc828e1a'", "successors": []}], "functions": [], "classes": []}, {"name": "__aenter__", "type": "CFG", "blocks": [{"id": 12, "label": "#12\nself.setup_dependency_overrides()\nself.db_api.__enter__()\nself.agent_server.__enter__()\nself.exec_manager.__enter__()\nself.scheduler.__enter__()\nawait db.connect()", "successors": [{"id": 13, "label": "#13\nawait initialize_blocks()", "successors": [{"id": 14, "label": "#14\nawait create_default_user()", "successors": [{"id": 15, "label": "#15\nreturn self", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "__aexit__", "type": "CFG", "blocks": [{"id": 19, "label": "#19\nawait db.disconnect()", "successors": [{"id": 20, "label": "#20\nself.scheduler.__exit__(exc_type, exc_val, exc_tb)\nself.exec_manager.__exit__(exc_type, exc_val, exc_tb)\nself.agent_server.__exit__(exc_type, exc_val, exc_tb)\nself.db_api.__exit__(exc_type, exc_val, exc_tb)", "successors": []}]}], "functions": [], "classes": []}, {"name": "setup_dependency_overrides", "type": "CFG", "blocks": [{"id": 23, "label": "#23\nself.agent_server.set_test_dependency_overrides({get_user_id: self.\n    test_get_user_id})", "successors": []}], "functions": [], "classes": []}], "classes": []}]}
{"file_name": "60.json", "name": "60.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport json\nimport os\nfrom enum import Enum\nfrom typing import Any, Dict, Generic, List, Set, Tuple, Type, TypeVar\nfrom pydantic import BaseModel, Field, PrivateAttr, ValidationInfo, field_validator\nfrom pydantic_settings import BaseSettings, JsonConfigSettingsSource, PydanticBaseSettingsSource, SettingsConfigDict\nfrom backend.util.data import get_data_path\nT = TypeVar('T', bound=BaseSettings)", "successors": []}], "functions": [], "classes": [{"name": "AppEnvironment", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nLOCAL = 'local'\nDEVELOPMENT = 'dev'\nPRODUCTION = 'prod'", "successors": []}], "functions": [], "classes": []}, {"name": "BehaveAs", "type": "CFG", "blocks": [{"id": 6, "label": "#6\nLOCAL = 'local'\nCLOUD = 'cloud'", "successors": []}], "functions": [], "classes": []}, {"name": "UpdateTrackingModel", "type": "CFG", "blocks": [{"id": 9, "label": "#9\n_updated_fields: Set[str] = PrivateAttr(default_factory=set)", "successors": []}], "functions": [{"name": "__setattr__", "type": "CFG", "blocks": [{"id": 11, "label": "#11\nif name in self.model_fields:", "successors": [{"id": 12, "label": "#12\nself._updated_fields.add(name)", "successors": [{"id": 13, "label": "#13\nsuper().__setattr__(name, value)", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "mark_updated", "type": "CFG", "blocks": [{"id": 16, "label": "#16\nif field_name in self.model_fields:", "successors": [{"id": 17, "label": "#17\nself._updated_fields.add(field_name)", "successors": []}]}], "functions": [], "classes": []}, {"name": "clear_updates", "type": "CFG", "blocks": [{"id": 21, "label": "#21\nself._updated_fields.clear()", "successors": []}], "functions": [], "classes": []}, {"name": "get_updates", "type": "CFG", "blocks": [{"id": 24, "label": "#24\nreturn {field: getattr(self, field) for field in self._updated_fields}", "successors": []}], "functions": [], "classes": []}, {"name": "updated_fields", "type": "CFG", "blocks": [{"id": 28, "label": "#28\nreturn self._updated_fields", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "Config", "type": "CFG", "blocks": [{"id": 33, "label": "#33\n\"\"\"Config for the server.\"\"\"\nnum_graph_workers: int = Field(default=10, ge=1, le=1000, description=\n    'Maximum number of workers to use for graph execution.')\nnum_node_workers: int = Field(default=5, ge=1, le=1000, description=\n    'Maximum number of workers to use for node execution within a single graph.'\n    )\npyro_host: str = Field(default='localhost', description=\n    'The default hostname of the Pyro server.')\npyro_client_comm_timeout: float = Field(default=15, description=\n    'The default timeout in seconds, for Pyro client connections.')\npyro_client_comm_retry: int = Field(default=3, description=\n    'The default number of retries for Pyro client connections.')\nenable_auth: bool = Field(default=True, description=\n    'If authentication is enabled or not')\nenable_credit: str = Field(default='false', description=\n    'If user credit system is enabled or not')\nnum_user_credits_refill: int = Field(default=1500, description=\n    'Number of credits to refill for each user')\nmodel_config = SettingsConfigDict(env_file='.env', extra='allow')\nwebsocket_server_host: str = Field(default='0.0.0.0', description=\n    'The host for the websocket server to run on')\nwebsocket_server_port: int = Field(default=8001, description=\n    'The port for the websocket server to run on')\nexecution_manager_port: int = Field(default=8002, description=\n    'The port for execution manager daemon to run on')\nexecution_scheduler_port: int = Field(default=8003, description=\n    'The port for execution scheduler daemon to run on')\nagent_server_port: int = Field(default=8004, description=\n    'The port for agent server daemon to run on')\ndatabase_api_port: int = Field(default=8005, description=\n    'The port for database server API to run on')\nagent_api_host: str = Field(default='0.0.0.0', description=\n    'The host for agent server API to run on')\nagent_api_port: int = Field(default=8006, description=\n    'The port for agent server API to run on')\nplatform_base_url: str = Field(default='', description=\n    \"Must be set so the application knows where it's hosted at. This is necessary to make sure webhooks find their way.\"\n    )\nfrontend_base_url: str = Field(default='', description=\n    'Can be used to explicitly set the base URL for the frontend. This value is then used to generate redirect URLs for OAuth flows.'\n    )\nmedia_gcs_bucket_name: str = Field(default='', description=\n    'The name of the Google Cloud Storage bucket for media files')\napp_env: AppEnvironment = Field(default=AppEnvironment.LOCAL, description=\n    'The name of the app environment: local or dev or prod')\nbehave_as: BehaveAs = Field(default=BehaveAs.LOCAL, description=\n    'What environment to behave as: local or cloud')\nexecution_event_bus_name: str = Field(default='execution_event',\n    description='Name of the event bus')\ntrust_endpoints_for_requests: List[str] = Field(default_factory=list,\n    description=\n    'A whitelist of trusted internal endpoints for the backend to make requests to.'\n    )\nbackend_cors_allow_origins: List[str] = Field(default_factory=list)", "successors": []}], "functions": [{"name": "validate_platform_base_url", "type": "CFG", "blocks": [{"id": 35, "label": "#35\nif not v:", "successors": [{"id": 36, "label": "#36\nreturn v", "successors": []}, {"id": 37, "label": "#37\nif not v.startswith(('http://', 'https://')):", "successors": [{"id": 39, "label": "#39\nraise ValueError(\n    f'{info.field_name} must be a full URL including a http:// or https:// schema'\n    )", "successors": []}, {"id": 40, "label": "#40\nif v.endswith('/'):", "successors": [{"id": 42, "label": "#42\nreturn v.rstrip('/')", "successors": []}, {"id": 43, "label": "#43\nreturn v", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "validate_cors_allow_origins", "type": "CFG", "blocks": [{"id": 48, "label": "#48\nout = []\nport = None\nhas_localhost = False\nhas_127_0_0_1 = False", "successors": [{"id": 49, "label": "#49\nfor url in v:", "successors": [{"id": 50, "label": "#50\nurl = url.strip()\nif url.startswith(('http://', 'https://')):", "successors": [{"id": 52, "label": "#52\nif 'localhost' in url:", "successors": [{"id": 56, "label": "#56\nport = url.split(':')[2]\nhas_localhost = True", "successors": [{"id": 57, "label": "#57\nif '127.0.0.1' in url:", "successors": [{"id": 58, "label": "#58\nport = url.split(':')[2]\nhas_127_0_0_1 = True", "successors": [{"id": 59, "label": "#59\nout.append(url)", "successors": []}]}]}]}]}, {"id": 54, "label": "#54\nraise ValueError(f'Invalid URL: {url}')", "successors": []}]}, {"id": 51, "label": "#51\nif has_127_0_0_1 and not has_localhost:", "successors": [{"id": 60, "label": "#60\nout.append(f'http://localhost:{port}')", "successors": [{"id": 61, "label": "#61\nif has_localhost and not has_127_0_0_1:", "successors": [{"id": 62, "label": "#62\nout.append(f'http://127.0.0.1:{port}')", "successors": [{"id": 63, "label": "#63\nreturn out", "successors": []}]}]}]}]}]}]}], "functions": [], "classes": []}, {"name": "settings_customise_sources", "type": "CFG", "blocks": [{"id": 67, "label": "#67\nreturn env_settings, file_secret_settings, dotenv_settings, JsonConfigSettingsSource(\n    settings_cls), init_settings", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "Secrets", "type": "CFG", "blocks": [{"id": 72, "label": "#72\n\"\"\"Secrets for the server.\"\"\"\nsupabase_url: str = Field(default='', description='Supabase URL')\nsupabase_service_role_key: str = Field(default='', description=\n    'Supabase service role key')\nencryption_key: str = Field(default='', description='Encryption key')\ngithub_client_id: str = Field(default='', description='GitHub OAuth client ID')\ngithub_client_secret: str = Field(default='', description=\n    'GitHub OAuth client secret')\ngoogle_client_id: str = Field(default='', description='Google OAuth client ID')\ngoogle_client_secret: str = Field(default='', description=\n    'Google OAuth client secret')\nnotion_client_id: str = Field(default='', description='Notion OAuth client ID')\nnotion_client_secret: str = Field(default='', description=\n    'Notion OAuth client secret')\nopenai_api_key: str = Field(default='', description='OpenAI API key')\nanthropic_api_key: str = Field(default='', description='Anthropic API key')\ngroq_api_key: str = Field(default='', description='Groq API key')\nopen_router_api_key: str = Field(default='', description='Open Router API Key')\nreddit_client_id: str = Field(default='', description='Reddit client ID')\nreddit_client_secret: str = Field(default='', description=\n    'Reddit client secret')\nreddit_username: str = Field(default='', description='Reddit username')\nreddit_password: str = Field(default='', description='Reddit password')\nopenweathermap_api_key: str = Field(default='', description=\n    'OpenWeatherMap API key')\nmedium_api_key: str = Field(default='', description='Medium API key')\nmedium_author_id: str = Field(default='', description='Medium author ID')\ndid_api_key: str = Field(default='', description='D-ID API Key')\nrevid_api_key: str = Field(default='', description='revid.ai API key')\ndiscord_bot_token: str = Field(default='', description='Discord bot token')\nsmtp_server: str = Field(default='', description='SMTP server IP')\nsmtp_port: str = Field(default='', description='SMTP server port')\nsmtp_username: str = Field(default='', description='SMTP username')\nsmtp_password: str = Field(default='', description='SMTP password')\nsentry_dsn: str = Field(default='', description='Sentry DSN')\ngoogle_maps_api_key: str = Field(default='', description='Google Maps API Key')\nreplicate_api_key: str = Field(default='', description='Replicate API Key')\nunreal_speech_api_key: str = Field(default='', description=\n    'Unreal Speech API Key')\nideogram_api_key: str = Field(default='', description='Ideogram API Key')\njina_api_key: str = Field(default='', description='Jina API Key')\nunreal_speech_api_key: str = Field(default='', description=\n    'Unreal Speech API Key')\nfal_key: str = Field(default='', description='FAL API key')\nmodel_config = SettingsConfigDict(env_file='.env', env_file_encoding=\n    'utf-8', extra='allow')", "successors": []}], "functions": [], "classes": []}, {"name": "Settings", "type": "CFG", "blocks": [{"id": 75, "label": "#75\nconfig: Config = Config()\nsecrets: Secrets = Secrets()", "successors": []}], "functions": [{"name": "save", "type": "CFG", "blocks": [{"id": 77, "label": "#77\nif self.config.updated_fields:", "successors": [{"id": 78, "label": "#78\nconfig_to_save = self.config.get_updates()\nconfig_path = os.path.join(get_data_path(), 'config.json')\nif os.path.exists(config_path):", "successors": [{"id": 80, "label": "#80\nwith open(config_path, 'r+') as f:", "successors": [{"id": 85, "label": "#85\nexisting_config: Dict[str, Any] = json.load(f)\nexisting_config.update(config_to_save)\nf.seek(0)\njson.dump(existing_config, f, indent=2)\nf.truncate()", "successors": [{"id": 81, "label": "#81\nself.config.clear_updates()", "successors": []}]}]}, {"id": 82, "label": "#82\nwith open(config_path, 'w') as f:", "successors": [{"id": 83, "label": "#83\njson.dump(config_to_save, f, indent=2)", "successors": []}]}]}]}], "functions": [], "classes": []}], "classes": []}]}
{"file_name": "61.json", "name": "61.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport json\nfrom typing import Any, Type, TypeVar, overload\nimport jsonschema\nfrom fastapi.encoders import jsonable_encoder\nfrom .type import type_match\nT = TypeVar('T')", "successors": []}], "functions": [{"name": "to_dict", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nreturn jsonable_encoder(data)", "successors": []}], "functions": [], "classes": []}, {"name": "dumps", "type": "CFG", "blocks": [{"id": 7, "label": "#7\nreturn json.dumps(jsonable_encoder(data))", "successors": []}], "functions": [], "classes": []}, {"name": "loads", "type": "CFG", "blocks": [{"id": 17, "label": "#17\nparsed = json.loads(data, *args, **kwargs)\nif target_type:", "successors": [{"id": 18, "label": "#18\nreturn type_match(parsed, target_type)", "successors": []}, {"id": 19, "label": "#19\nreturn parsed", "successors": []}]}], "functions": [], "classes": []}, {"name": "validate_with_jsonschema", "type": "CFG", "blocks": [{"id": 24, "label": "#24\n\"\"\"\n    Validate the data against the schema.\n    Returns the validation error message if the data does not match the schema.\n    \"\"\"\ntry:", "successors": [{"id": 25, "label": "#25\njsonschema.validate(data, schema)\nreturn None", "successors": []}, {"id": 26, "label": "#26\nreturn str(e)", "successors": []}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "62.json", "name": "62.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom urllib.parse import parse_qs, urlparse\nfrom youtube_transcript_api import YouTubeTranscriptApi\nfrom youtube_transcript_api.formatters import TextFormatter\nfrom backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema\nfrom backend.data.model import SchemaField", "successors": []}], "functions": [], "classes": [{"name": "TranscribeYoutubeVideoBlock", "type": "CFG", "blocks": [{"id": 3, "label": "#3", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 11, "label": "#11\nsuper().__init__(id='f3a8f7e1-4b1d-4e5f-9f2a-7c3d5a2e6b4c', input_schema=\n    TranscribeYoutubeVideoBlock.Input, output_schema=\n    TranscribeYoutubeVideoBlock.Output, description=\n    'Transcribes a YouTube video.', categories={BlockCategory.SOCIAL},\n    test_input={'youtube_url':\n    'https://www.youtube.com/watch?v=dQw4w9WgXcQ'}, test_output=[(\n    'video_id', 'dQw4w9WgXcQ'), ('transcript',\n    \"\"\"Never gonna give you up\nNever gonna let you down\"\"\")], test_mock={\n    'get_transcript': lambda video_id: [{'text': 'Never gonna give you up'},\n    {'text': 'Never gonna let you down'}]})", "successors": []}], "functions": [], "classes": []}, {"name": "extract_video_id", "type": "CFG", "blocks": [{"id": 14, "label": "#14\nparsed_url = urlparse(url)\nif parsed_url.netloc == 'youtu.be':", "successors": [{"id": 15, "label": "#15\nreturn parsed_url.path[1:]", "successors": []}, {"id": 16, "label": "#16\nif parsed_url.netloc in ('www.youtube.com', 'youtube.com'):", "successors": [{"id": 18, "label": "#18\nif parsed_url.path == '/watch':", "successors": [{"id": 20, "label": "#20\np = parse_qs(parsed_url.query)\nreturn p['v'][0]", "successors": []}, {"id": 21, "label": "#21\nif parsed_url.path[:7] == '/embed/':", "successors": [{"id": 23, "label": "#23\nreturn parsed_url.path.split('/')[2]", "successors": []}, {"id": 24, "label": "#24\nif parsed_url.path[:3] == '/v/':", "successors": [{"id": 26, "label": "#26\nreturn parsed_url.path.split('/')[2]", "successors": []}, {"id": 19, "label": "#19\nraise ValueError(f'Invalid YouTube URL: {url}')", "successors": []}]}]}]}]}]}], "functions": [], "classes": []}, {"name": "get_transcript", "type": "CFG", "blocks": [{"id": 32, "label": "#32\ntry:", "successors": [{"id": 33, "label": "#33\ntranscript_list = YouTubeTranscriptApi.list_transcripts(video_id)\nif not transcript_list:", "successors": [{"id": 36, "label": "#36\nraise ValueError(f'No transcripts found for the video: {video_id}')", "successors": []}, {"id": 37, "label": "#37\nfor transcript in transcript_list:", "successors": [{"id": 39, "label": "#39\nfirst_transcript = transcript_list.find_transcript([transcript.language_code])\nreturn YouTubeTranscriptApi.get_transcript(video_id, languages=[\n    first_transcript.language_code])", "successors": []}]}]}, {"id": 34, "label": "#34\nraise ValueError(f'No transcripts found for the video: {video_id}')", "successors": []}]}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 45, "label": "#45\nvideo_id = self.extract_video_id(input_data.youtube_url)\nyield 'video_id', video_id", "successors": [{"id": 46, "label": "#46\ntranscript = self.get_transcript(video_id)\nformatter = TextFormatter()\ntranscript_text = formatter.format_transcript(transcript)\nyield 'transcript', transcript_text", "successors": []}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 5, "label": "#5\nyoutube_url: str = SchemaField(title='YouTube URL', description=\n    'The URL of the YouTube video to transcribe', placeholder=\n    'https://www.youtube.com/watch?v=dQw4w9WgXcQ')", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 8, "label": "#8\nvideo_id: str = SchemaField(description='The extracted YouTube video ID')\ntranscript: str = SchemaField(description='The transcribed text of the video')\nerror: str = SchemaField(description=\n    'Any error message if the transcription fails')", "successors": []}], "functions": [], "classes": []}]}]}
{"file_name": "63.json", "name": "63.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom pathlib import Path\nfrom prisma.models import User\nfrom backend.blocks.basic import StoreValueBlock\nfrom backend.blocks.block import BlockInstallationBlock\nfrom backend.blocks.http import SendWebRequestBlock\nfrom backend.blocks.llm import AITextGeneratorBlock\nfrom backend.blocks.text import ExtractTextInformationBlock, FillTextTemplateBlock\nfrom backend.data.graph import Graph, Link, Node, create_graph\nfrom backend.data.user import get_or_create_user\nfrom backend.util.test import SpinTestServer, wait_execution\nsample_block_modules = {'llm':\n    'Block that calls the AI model to generate text.', 'basic':\n    'Block that does basic operations.', 'text':\n    'Blocks that do text operations.', 'reddit':\n    'Blocks that interacts with Reddit.'}\nsample_block_codes = {}", "successors": [{"id": 2, "label": "#2\nfor module, description in sample_block_modules.items():", "successors": [{"id": 3, "label": "#3\ncurrent_dir = Path(__file__).parent\nfile_path = current_dir.parent / 'blocks' / f'{module}.py'\nwith open(file_path, 'r') as f:", "successors": [{"id": 5, "label": "#5\ncode = '\\n'.join(['```python', f.read(), '```'])\nsample_block_codes[module] = f\"\"\"[Example: {description}]\n{code}\"\"\"", "successors": []}]}, {"id": 4, "label": "#4\nif __name__ == '__main__':", "successors": [{"id": 25, "label": "#25\nimport asyncio\nasyncio.run(block_autogen_agent())", "successors": []}]}]}]}], "functions": [{"name": "create_test_user", "type": "CFG", "blocks": [{"id": 8, "label": "#8\ntest_user_data = {'sub': 'ef3b97d7-1161-4eb4-92b2-10c24fb154c1', 'email':\n    'testuser@example.com', 'name': 'Test User'}\nuser = await get_or_create_user(test_user_data)", "successors": [{"id": 9, "label": "#9\nreturn user", "successors": []}]}], "functions": [], "classes": []}, {"name": "create_test_graph", "type": "CFG", "blocks": [{"id": 13, "label": "#13\n\"\"\"\n            StoreValueBlock (input)\n                 ||\n                 v\n        FillTextTemplateBlock (input query)\n                 ||\n                 v\n         SendWebRequestBlock (browse)\n                 ||\n                 v\n     ------> StoreValueBlock===============\n    |           |  |                    ||\n    |            --                     ||\n    |                                   ||\n    |                                   ||\n    |                                    v\n    |        AITextGeneratorBlock  <===== FillTextTemplateBlock (query)\n    |            ||                      ^\n    |            v                      ||\n    |       ExtractTextInformationBlock             ||\n    |            ||                     ||\n    |            v                      ||\n    ------ BlockInstallationBlock  ======\n    \"\"\"\ninput_data = Node(block_id=StoreValueBlock().id)\ninput_query_constant = Node(block_id=StoreValueBlock().id, input_default={\n    'data': None})\ninput_text_formatter = Node(block_id=FillTextTemplateBlock().id,\n    input_default={'format':\n    'Show me how to make a python code for this query: `{query}`'})\nsearch_http_request = Node(block_id=SendWebRequestBlock().id, input_default\n    ={'url': 'https://osit-v2.bentlybro.com/search'})\nsearch_result_constant = Node(block_id=StoreValueBlock().id, input_default=\n    {'data': None})\nprompt_text_formatter = Node(block_id=FillTextTemplateBlock().id,\n    input_default={'format':\n    \"\"\"\nWrite me a full Block implementation for this query: `{query}`\n\nHere is the information I get to write a Python code for that:\n{search_result}\n\nHere is your previous attempt:\n{previous_attempt}\n\"\"\"\n    , 'values_#_previous_attempt': 'No previous attempt found.'})\ncode_gen_llm_call = Node(block_id=AITextGeneratorBlock().id, input_default=\n    {'sys_prompt':\n    f\"\"\"\nYou are a software engineer and you are asked to write the full class implementation.\nThe class that you are implementing is extending a class called `Block`.\nThis class will be used as a node in a graph of other blocks to build a complex system.\nThis class has a method called `run` that takes an input and returns an output.\nIt also has an `id` attribute that is a UUID, input_schema, and output_schema.\nFor UUID, you have to hardcode it, like `d2e2ecd2-9ae6-422d-8dfe-ceca500ce6a6`,\ndon't use any automatic UUID generation, because it needs to be consistent.\nTo validate the correctness of your implementation, you can also define a test.\nThere is `test_input` and `test_output` you can use to validate your implementation.\nThere is also `test_mock` to mock a helper function on your block class for testing.\n\nFeel free to start your answer by explaining your plan what's required how to test, etc.\nBut make sure to produce the fully working implementation at the end,\nand it should be enclosed within this block format:\n```python\n<Your implementation here>\n```\n\nHere are a couple of sample of the Block class implementation:\n\n{'--------------'.join([sample_block_codes[v] for v in sample_block_modules])}\n\"\"\"\n    })\ncode_text_parser = Node(block_id=ExtractTextInformationBlock().id,\n    input_default={'pattern': \"\"\"```python\n(.+?)\n```\"\"\", 'group': 1})\nblock_installation = Node(block_id=BlockInstallationBlock().id)\nnodes = [input_data, input_query_constant, input_text_formatter,\n    search_http_request, search_result_constant, prompt_text_formatter,\n    code_gen_llm_call, code_text_parser, block_installation]\nlinks = [Link(source_id=input_data.id, sink_id=input_query_constant.id,\n    source_name='output', sink_name='input'), Link(source_id=input_data.id,\n    sink_id=input_text_formatter.id, source_name='output', sink_name=\n    'values_#_query'), Link(source_id=input_query_constant.id, sink_id=\n    input_query_constant.id, source_name='output', sink_name='data'), Link(\n    source_id=input_text_formatter.id, sink_id=search_http_request.id,\n    source_name='output', sink_name='body_#_query'), Link(source_id=\n    search_http_request.id, sink_id=search_result_constant.id, source_name=\n    'response_#_reply', sink_name='input'), Link(source_id=\n    search_result_constant.id, sink_id=search_result_constant.id,\n    source_name='output', sink_name='data'), Link(source_id=\n    search_result_constant.id, sink_id=prompt_text_formatter.id,\n    source_name='output', sink_name='values_#_search_result'), Link(\n    source_id=input_query_constant.id, sink_id=prompt_text_formatter.id,\n    source_name='output', sink_name='values_#_query'), Link(source_id=\n    prompt_text_formatter.id, sink_id=code_gen_llm_call.id, source_name=\n    'output', sink_name='prompt'), Link(source_id=code_gen_llm_call.id,\n    sink_id=code_text_parser.id, source_name='response', sink_name='text'),\n    Link(source_id=code_text_parser.id, sink_id=block_installation.id,\n    source_name='positive', sink_name='code'), Link(source_id=\n    block_installation.id, sink_id=prompt_text_formatter.id, source_name=\n    'error', sink_name='values_#_previous_attempt'), Link(source_id=\n    block_installation.id, sink_id=search_result_constant.id, source_name=\n    'error', sink_name='input'), Link(source_id=block_installation.id,\n    sink_id=input_query_constant.id, source_name='error', sink_name='input')]\nreturn Graph(name='BlockAutoGen', description='Block auto generation agent',\n    nodes=nodes, links=links)", "successors": []}], "functions": [], "classes": []}, {"name": "block_autogen_agent", "type": "CFG", "blocks": [{"id": 17, "label": "#17\nasync with SpinTestServer() as server:\n    test_user = await create_test_user()\n    test_graph = await create_graph(create_test_graph(), user_id=test_user.id)\n    input_data = {'input': 'Write me a block that writes a string into a file.'\n        }\n    response = await server.agent_server.test_execute_graph(test_graph.id,\n        input_data, test_user.id)\n    print(response)\n    result = await wait_execution(graph_id=test_graph.id, graph_exec_id=\n        response['id'], timeout=1200, user_id=test_user.id)\n    print(result)", "successors": [{"id": 18, "label": "#18\ntest_user = await create_test_user()", "successors": [{"id": 20, "label": "#20\ntest_graph = await create_graph(create_test_graph(), user_id=test_user.id)", "successors": [{"id": 21, "label": "#21\ninput_data = {'input': 'Write me a block that writes a string into a file.'}\nresponse = await server.agent_server.test_execute_graph(test_graph.id,\n    input_data, test_user.id)", "successors": [{"id": 22, "label": "#22\nprint(response)\nresult = await wait_execution(graph_id=test_graph.id, graph_exec_id=\n    response['id'], timeout=1200, user_id=test_user.id)", "successors": [{"id": 23, "label": "#23\nprint(result)", "successors": []}]}]}]}]}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "64.json", "name": "64.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\n\"\"\"\nIn this problem, we want to determine all possible subsequences\nof the given sequence. We use backtracking to solve this problem.\n\nTime complexity: O(2^n),\nwhere n denotes the length of the given sequence.\n\"\"\"\nfrom __future__ import annotations\nfrom typing import Any\nif __name__ == '__main__':", "successors": [{"id": 11, "label": "#11\nseq: list[Any] = [1, 2, 3]\ngenerate_all_subsequences(seq)\nseq.clear()\nseq.extend(['A', 'B', 'C'])\ngenerate_all_subsequences(seq)", "successors": []}]}], "functions": [{"name": "generate_all_subsequences", "type": "CFG", "blocks": [{"id": 3, "label": "#3\ncreate_state_space_tree(sequence, [], 0)", "successors": []}], "functions": [], "classes": []}, {"name": "create_state_space_tree", "type": "CFG", "blocks": [{"id": 6, "label": "#6\n\"\"\"\n    Creates a state space tree to iterate through each branch using DFS.\n    We know that each state has exactly two children.\n    It terminates when it reaches the end of the given sequence.\n\n    :param sequence: The input sequence for which subsequences are generated.\n    :param current_subsequence: The current subsequence being built.\n    :param index: The current index in the sequence.\n\n    Example:\n    >>> sequence = [3, 2, 1]\n    >>> current_subsequence = []\n    >>> create_state_space_tree(sequence, current_subsequence, 0)\n    []\n    [1]\n    [2]\n    [2, 1]\n    [3]\n    [3, 1]\n    [3, 2]\n    [3, 2, 1]\n\n    >>> sequence = [\"A\", \"B\"]\n    >>> current_subsequence = []\n    >>> create_state_space_tree(sequence, current_subsequence, 0)\n    []\n    ['B']\n    ['A']\n    ['A', 'B']\n\n    >>> sequence = []\n    >>> current_subsequence = []\n    >>> create_state_space_tree(sequence, current_subsequence, 0)\n    []\n\n    >>> sequence = [1, 2, 3, 4]\n    >>> current_subsequence = []\n    >>> create_state_space_tree(sequence, current_subsequence, 0)\n    []\n    [4]\n    [3]\n    [3, 4]\n    [2]\n    [2, 4]\n    [2, 3]\n    [2, 3, 4]\n    [1]\n    [1, 4]\n    [1, 3]\n    [1, 3, 4]\n    [1, 2]\n    [1, 2, 4]\n    [1, 2, 3]\n    [1, 2, 3, 4]\n    \"\"\"\nif index == len(sequence):", "successors": [{"id": 7, "label": "#7\nprint(current_subsequence)\nreturn", "successors": []}, {"id": 8, "label": "#8\ncreate_state_space_tree(sequence, current_subsequence, index + 1)\ncurrent_subsequence.append(sequence[index])\ncreate_state_space_tree(sequence, current_subsequence, index + 1)\ncurrent_subsequence.pop()", "successors": []}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "65.json", "name": "65.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\n\"\"\"\nProblem source: https://www.hackerrank.com/challenges/the-power-sum/problem\nFind the number of ways that a given integer X, can be expressed as the sum\nof the Nth powers of unique, natural numbers. For example, if X=13 and N=2.\nWe have to find all combinations of unique squares adding up to 13.\nThe only solution is 2^2+3^2. Constraints: 1<=X<=1000, 2<=N<=10.\n\"\"\"\nif __name__ == '__main__':", "successors": [{"id": 20, "label": "#20\nimport doctest\ndoctest.testmod()", "successors": []}]}], "functions": [{"name": "backtrack", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"\n    >>> backtrack(13, 2, 1, 0, 0)\n    (0, 1)\n    >>> backtrack(10, 2, 1, 0, 0)\n    (0, 1)\n    >>> backtrack(10, 3, 1, 0, 0)\n    (0, 0)\n    >>> backtrack(20, 2, 1, 0, 0)\n    (0, 1)\n    >>> backtrack(15, 10, 1, 0, 0)\n    (0, 0)\n    >>> backtrack(16, 2, 1, 0, 0)\n    (0, 1)\n    >>> backtrack(20, 1, 1, 0, 0)\n    (0, 64)\n    \"\"\"\nif current_sum == needed_sum:", "successors": [{"id": 4, "label": "#4\nsolutions_count += 1\nreturn current_sum, solutions_count", "successors": []}, {"id": 5, "label": "#5\ni_to_n = current_number ** power\nif current_sum + i_to_n <= needed_sum:", "successors": [{"id": 7, "label": "#7\ncurrent_sum += i_to_n\ncurrent_sum, solutions_count = backtrack(needed_sum, power, current_number +\n    1, current_sum, solutions_count)\ncurrent_sum -= i_to_n", "successors": [{"id": 8, "label": "#8\nif i_to_n < needed_sum:", "successors": [{"id": 9, "label": "#9\ncurrent_sum, solutions_count = backtrack(needed_sum, power, current_number +\n    1, current_sum, solutions_count)", "successors": [{"id": 10, "label": "#10\nreturn current_sum, solutions_count", "successors": []}]}]}]}]}]}], "functions": [], "classes": []}, {"name": "solve", "type": "CFG", "blocks": [{"id": 14, "label": "#14\n\"\"\"\n    >>> solve(13, 2)\n    1\n    >>> solve(10, 2)\n    1\n    >>> solve(10, 3)\n    0\n    >>> solve(20, 2)\n    1\n    >>> solve(15, 10)\n    0\n    >>> solve(16, 2)\n    1\n    >>> solve(20, 1)\n    Traceback (most recent call last):\n    ValueError: Invalid input\n    needed_sum must be between 1 and 1000, power between 2 and 10.\n    >>> solve(-10, 5)\n    Traceback (most recent call last):\n    ValueError: Invalid input\n    needed_sum must be between 1 and 1000, power between 2 and 10.\n    \"\"\"\nif not (1 <= needed_sum <= 1000 and 2 <= power <= 10):", "successors": [{"id": 15, "label": "#15\nraise ValueError(\n    \"\"\"Invalid input\nneeded_sum must be between 1 and 1000, power between 2 and 10.\"\"\"\n    )", "successors": []}, {"id": 16, "label": "#16\nreturn backtrack(needed_sum, power, 1, 0, 0)[1]", "successors": []}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "66.json", "name": "66.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport logging\nimport os\nimport signal\nimport sys\nfrom abc import ABC, abstractmethod\nfrom multiprocessing import Process, set_start_method\nfrom typing import Optional\nfrom backend.util.logging import configure_logging\nfrom backend.util.metrics import sentry_init\nlogger = logging.getLogger(__name__)\n_SERVICE_NAME = 'MainProcess'", "successors": []}], "functions": [{"name": "get_service_name", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nreturn _SERVICE_NAME", "successors": []}], "functions": [], "classes": []}, {"name": "set_service_name", "type": "CFG", "blocks": [{"id": 7, "label": "#7\nglobal _SERVICE_NAME\n_SERVICE_NAME = name", "successors": []}], "functions": [], "classes": []}], "classes": [{"name": "AppProcess", "type": "CFG", "blocks": [{"id": 10, "label": "#10\n\"\"\"\n    A class to represent an object that can be executed in a background process.\n    \"\"\"\nprocess: Optional[Process] = None\nset_start_method('spawn', force=True)\nconfigure_logging()\nsentry_init()", "successors": []}], "functions": [{"name": "run", "type": "CFG", "blocks": [{"id": 12, "label": "#12\n\"\"\"\n        The method that will be executed in the process.\n        \"\"\"\npass", "successors": []}], "functions": [], "classes": []}, {"name": "service_name", "type": "CFG", "blocks": [{"id": 15, "label": "#15\nreturn cls.__name__", "successors": []}], "functions": [], "classes": []}, {"name": "cleanup", "type": "CFG", "blocks": [{"id": 19, "label": "#19\n\"\"\"\n        Implement this method on a subclass to do post-execution cleanup,\n        e.g. disconnecting from a database or terminating child processes.\n        \"\"\"\npass", "successors": []}], "functions": [], "classes": []}, {"name": "health_check", "type": "CFG", "blocks": [{"id": 22, "label": "#22\n\"\"\"\n        A method to check the health of the process.\n        \"\"\"\npass", "successors": []}], "functions": [], "classes": []}, {"name": "execute_run_command", "type": "CFG", "blocks": [{"id": 25, "label": "#25\nsignal.signal(signal.SIGTERM, self._self_terminate)\ntry:", "successors": [{"id": 26, "label": "#26\nif silent:", "successors": [{"id": 29, "label": "#29\nsys.stdout = open(os.devnull, 'w')\nsys.stderr = open(os.devnull, 'w')", "successors": [{"id": 30, "label": "#30\nset_service_name(self.service_name)\nself.run()", "successors": []}]}]}, {"id": 27, "label": "#27", "successors": []}]}], "functions": [], "classes": []}, {"name": "_self_terminate", "type": "CFG", "blocks": [{"id": 33, "label": "#33\nself.cleanup()\nsys.exit(0)", "successors": []}], "functions": [], "classes": []}, {"name": "__enter__", "type": "CFG", "blocks": [{"id": 36, "label": "#36\nself.start(background=True)\nreturn self", "successors": []}], "functions": [], "classes": []}, {"name": "__exit__", "type": "CFG", "blocks": [{"id": 40, "label": "#40\nself.stop()", "successors": []}], "functions": [], "classes": []}, {"name": "start", "type": "CFG", "blocks": [{"id": 43, "label": "#43\n\"\"\"\n        Start the background process.\n        Args:\n            background: Whether to run the process in the background.\n            silent: Whether to disable stdout and stderr.\n            proc_args: Additional arguments to pass to the process.\n        Returns:\n            the process id or 0 if the process is not running in the background.\n        \"\"\"\nif not background:", "successors": [{"id": 44, "label": "#44\nself.execute_run_command(silent)\nreturn 0", "successors": []}, {"id": 45, "label": "#45\nself.process = Process(name=self.__class__.__name__, target=self.\n    execute_run_command, args=(silent,), **proc_args)\nself.process.start()\nself.health_check()\nreturn self.process.pid or 0", "successors": []}]}], "functions": [], "classes": []}, {"name": "stop", "type": "CFG", "blocks": [{"id": 50, "label": "#50\n\"\"\"\n        Stop the background process.\n        \"\"\"\nif not self.process:", "successors": [{"id": 51, "label": "#51\nreturn", "successors": []}, {"id": 52, "label": "#52\nself.process.terminate()\nself.process.join()\nself.process = None", "successors": []}]}], "functions": [], "classes": []}], "classes": []}]}
{"file_name": "67.json", "name": "67.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport logging\nfrom typing import TYPE_CHECKING, Callable, Optional, cast\nfrom backend.data.block import BlockWebhookConfig, get_block\nfrom backend.data.graph import set_node_webhook\nfrom backend.data.model import CREDENTIALS_FIELD_NAME\nfrom backend.integrations.webhooks import WEBHOOK_MANAGERS_BY_NAME\nif TYPE_CHECKING:", "successors": [{"id": 2, "label": "#2\nfrom backend.data.graph import GraphModel, NodeModel\nfrom backend.data.model import Credentials\nfrom ._base import BaseWebhooksManager", "successors": [{"id": 3, "label": "#3\nlogger = logging.getLogger(__name__)", "successors": []}]}]}], "functions": [{"name": "on_graph_activate", "type": "CFG", "blocks": [{"id": 5, "label": "#5\n\"\"\"\n    Hook to be called when a graph is activated/created.\n\n    \u26a0\ufe0f Assuming node entities are not re-used between graph versions, \u26a0\ufe0f\n    this hook calls `on_node_activate` on all nodes in this graph.\n\n    Params:\n        get_credentials: `credentials_id` -> Credentials\n    \"\"\"\nupdated_nodes = []", "successors": [{"id": 6, "label": "#6\nfor new_node in graph.nodes:", "successors": [{"id": 7, "label": "#7\nnode_credentials = None\nif (creds_meta := new_node.input_default.get(CREDENTIALS_FIELD_NAME)):", "successors": [{"id": 9, "label": "#9\nnode_credentials = get_credentials(creds_meta['id'])\nif not node_credentials:", "successors": [{"id": 11, "label": "#11\nraise ValueError(\n    f'Node #{new_node.id} updated with non-existent credentials #{node_credentials}'\n    )", "successors": []}, {"id": 10, "label": "#10\nupdated_node = await on_node_activate(graph.user_id, new_node, credentials=\n    node_credentials)", "successors": [{"id": 14, "label": "#14\nupdated_nodes.append(updated_node)", "successors": []}]}]}]}, {"id": 8, "label": "#8\ngraph.nodes = updated_nodes\nreturn graph", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "on_graph_deactivate", "type": "CFG", "blocks": [{"id": 18, "label": "#18\n\"\"\"\n    Hook to be called when a graph is deactivated/deleted.\n\n    \u26a0\ufe0f Assuming node entities are not re-used between graph versions, \u26a0\ufe0f\n    this hook calls `on_node_deactivate` on all nodes in `graph`.\n\n    Params:\n        get_credentials: `credentials_id` -> Credentials\n    \"\"\"\nupdated_nodes = []", "successors": [{"id": 19, "label": "#19\nfor node in graph.nodes:", "successors": [{"id": 20, "label": "#20\nnode_credentials = None\nif (creds_meta := node.input_default.get(CREDENTIALS_FIELD_NAME)):", "successors": [{"id": 22, "label": "#22\nnode_credentials = get_credentials(creds_meta['id'])\nif not node_credentials:", "successors": [{"id": 24, "label": "#24\nlogger.error(\n    f\"Node #{node.id} referenced non-existent credentials #{creds_meta['id']}\")", "successors": [{"id": 23, "label": "#23\nupdated_node = await on_node_deactivate(node, credentials=node_credentials)", "successors": [{"id": 26, "label": "#26\nupdated_nodes.append(updated_node)", "successors": []}]}]}]}]}, {"id": 21, "label": "#21\ngraph.nodes = updated_nodes\nreturn graph", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "on_node_activate", "type": "CFG", "blocks": [{"id": 30, "label": "#30\n\"\"\"Hook to be called when the node is activated/created\"\"\"\nblock = get_block(node.block_id)\nif not block:", "successors": [{"id": 31, "label": "#31\nraise ValueError(\n    f'Node #{node.id} is instance of unknown block #{node.block_id}')", "successors": []}, {"id": 32, "label": "#32\nif not block.webhook_config:", "successors": [{"id": 34, "label": "#34\nreturn node", "successors": []}, {"id": 35, "label": "#35\nprovider = block.webhook_config.provider\nif provider not in WEBHOOK_MANAGERS_BY_NAME:", "successors": [{"id": 37, "label": "#37\nraise ValueError(\n    f'Block #{block.id} has webhook_config for provider {provider} which does not support webhooks'\n    )", "successors": []}, {"id": 38, "label": "#38\nlogger.debug(\n    f'Activating webhook node #{node.id} with config {block.webhook_config}')\nwebhooks_manager = WEBHOOK_MANAGERS_BY_NAME[provider]()\nif (auto_setup_webhook := isinstance(block.webhook_config, BlockWebhookConfig)", "successors": [{"id": 40, "label": "#40\ntry:", "successors": [{"id": 43, "label": "#43\nresource = block.webhook_config.resource_format.format(**node.input_default)", "successors": [{"id": 45, "label": "#45\nlogger.debug(\n    f'Constructed resource string {resource} from input {node.input_default}')", "successors": [{"id": 41, "label": "#41\nneeds_credentials = CREDENTIALS_FIELD_NAME in block.input_schema.model_fields\ncredentials_meta = node.input_default.get(CREDENTIALS_FIELD_NAME\n    ) if needs_credentials else None\nevent_filter_input_name = block.webhook_config.event_filter_input\nhas_everything_for_webhook = resource is not None and (credentials_meta or \n    not needs_credentials) and (not event_filter_input_name or \n    event_filter_input_name in node.input_default and any(is_on for is_on in\n    node.input_default[event_filter_input_name].values()))\nif has_everything_for_webhook and resource is not None:", "successors": [{"id": 46, "label": "#46\nlogger.debug(f'Node #{node} has everything for a webhook!')\nif credentials_meta and not credentials:", "successors": [{"id": 49, "label": "#49\nraise ValueError(\n    f\"Cannot set up webhook for node #{node.id}: credentials #{credentials_meta['id']} not available\"\n    )", "successors": []}, {"id": 50, "label": "#50\nif event_filter_input_name:", "successors": [{"id": 52, "label": "#52\nevent_filter = cast(dict, node.input_default[event_filter_input_name])\nevents = [block.webhook_config.event_format.format(event=event) for event,\n    enabled in event_filter.items() if enabled is True]\nlogger.debug(f\"Webhook events to subscribe to: {', '.join(events)}\")", "successors": [{"id": 53, "label": "#53\nif auto_setup_webhook:", "successors": [{"id": 55, "label": "#55\nassert credentials is not None", "successors": [{"id": 60, "label": "#60\nnew_webhook = await webhooks_manager.get_suitable_auto_webhook(user_id,\n    credentials, block.webhook_config.webhook_type, resource, events)", "successors": [{"id": 56, "label": "#56\nlogger.debug(f'Acquired webhook: {new_webhook}')\nreturn await set_node_webhook(node.id, new_webhook.id)", "successors": []}]}]}, {"id": 57, "label": "#57\nnew_webhook = await webhooks_manager.get_manual_webhook(user_id, node.\n    graph_id, block.webhook_config.webhook_type, events)", "successors": []}]}]}, {"id": 54, "label": "#54\nevents = []", "successors": []}]}]}, {"id": 48, "label": "#48\nlogger.debug(f'Node #{node.id} does not have everything for a webhook')", "successors": [{"id": 47, "label": "#47\nreturn node", "successors": []}]}]}]}]}, {"id": 44, "label": "#44\nresource = None", "successors": []}]}, {"id": 42, "label": "#42\nresource = ''", "successors": []}]}]}]}]}], "functions": [], "classes": []}, {"name": "on_node_deactivate", "type": "CFG", "blocks": [{"id": 66, "label": "#66\n\"\"\"Hook to be called when node is deactivated/deleted\"\"\"\nlogger.debug(f'Deactivating node #{node.id}')\nblock = get_block(node.block_id)\nif not block:", "successors": [{"id": 67, "label": "#67\nraise ValueError(\n    f'Node #{node.id} is instance of unknown block #{node.block_id}')", "successors": []}, {"id": 68, "label": "#68\nif not block.webhook_config:", "successors": [{"id": 70, "label": "#70\nreturn node", "successors": []}, {"id": 71, "label": "#71\nprovider = block.webhook_config.provider\nif provider not in WEBHOOK_MANAGERS_BY_NAME:", "successors": [{"id": 73, "label": "#73\nraise ValueError(\n    f'Block #{block.id} has webhook_config for provider {provider} which does not support webhooks'\n    )", "successors": []}, {"id": 74, "label": "#74\nwebhooks_manager = WEBHOOK_MANAGERS_BY_NAME[provider]()\nif node.webhook_id:", "successors": [{"id": 76, "label": "#76\nlogger.debug(f'Node #{node.id} has webhook_id {node.webhook_id}')\nif not node.webhook:", "successors": [{"id": 78, "label": "#78\nlogger.error(f'Node #{node.id} has webhook_id but no webhook object')\nraise ValueError('node.webhook not included')", "successors": []}, {"id": 79, "label": "#79\nlogger.debug(f'Detaching webhook from node #{node.id}')\nupdated_node = await set_node_webhook(node.id, None)", "successors": [{"id": 81, "label": "#81\nwebhook = node.webhook\nlogger.debug(\n    f\"Pruning{' and deregistering' if credentials else ''} webhook #{webhook.id}\"\n    )\nawait webhooks_manager.prune_webhook_if_dangling(webhook.id, credentials)", "successors": [{"id": 82, "label": "#82\nif CREDENTIALS_FIELD_NAME in block.input_schema.model_fields and not credentials:", "successors": [{"id": 83, "label": "#83\nlogger.warning(\n    f'Cannot deregister webhook #{webhook.id}: credentials #{webhook.credentials_id} not available ({webhook.provider.value} webhook ID: {webhook.provider_webhook_id})'\n    )", "successors": [{"id": 84, "label": "#84\nreturn updated_node", "successors": []}]}]}]}]}]}, {"id": 77, "label": "#77\nlogger.debug(f'Node #{node.id} has no webhook_id, returning')\nreturn node", "successors": []}]}]}]}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "68.json", "name": "68.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport asyncio\nimport contextlib\nimport logging\nfrom functools import wraps\nfrom typing import Any, Awaitable, Callable, Dict, Optional, TypeVar, Union, cast\nimport ldclient\nfrom fastapi import HTTPException\nfrom ldclient import Context, LDClient\nfrom ldclient.config import Config\nfrom typing_extensions import ParamSpec\nfrom .config import SETTINGS\nlogger = logging.getLogger(__name__)\nlogging.basicConfig(level=logging.DEBUG)\nP = ParamSpec('P')\nT = TypeVar('T')", "successors": []}], "functions": [{"name": "get_client", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"Get the LaunchDarkly client singleton.\"\"\"\nreturn ldclient.get()", "successors": []}], "functions": [], "classes": []}, {"name": "initialize_launchdarkly", "type": "CFG", "blocks": [{"id": 7, "label": "#7\nsdk_key = SETTINGS.launch_darkly_sdk_key\nlogger.debug(\n    f\"Initializing LaunchDarkly with SDK key: {'present' if sdk_key else 'missing'}\"\n    )\nif not sdk_key:", "successors": [{"id": 8, "label": "#8\nlogger.warning('LaunchDarkly SDK key not configured')\nreturn", "successors": []}, {"id": 9, "label": "#9\nconfig = Config(sdk_key)\nldclient.set_config(config)\nif ldclient.get().is_initialized():", "successors": [{"id": 11, "label": "#11\nlogger.info('LaunchDarkly client initialized successfully')", "successors": []}, {"id": 13, "label": "#13\nlogger.error('LaunchDarkly client failed to initialize')", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "shutdown_launchdarkly", "type": "CFG", "blocks": [{"id": 16, "label": "#16\n\"\"\"Shutdown the LaunchDarkly client.\"\"\"\nif ldclient.get().is_initialized():", "successors": [{"id": 17, "label": "#17\nldclient.get().close()\nlogger.info('LaunchDarkly client closed successfully')", "successors": []}]}], "functions": [], "classes": []}, {"name": "create_context", "type": "CFG", "blocks": [{"id": 21, "label": "#21\n\"\"\"Create LaunchDarkly context with optional additional attributes.\"\"\"\nbuilder = Context.builder(str(user_id)).kind('user')\nif additional_attributes:", "successors": [{"id": 22, "label": "#22\nfor key, value in additional_attributes.items():", "successors": [{"id": 24, "label": "#24\nbuilder.set(key, value)", "successors": []}, {"id": 23, "label": "#23\nreturn builder.build()", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "feature_flag", "type": "CFG", "blocks": [{"id": 29, "label": "#29\n\"\"\"\n    Decorator for feature flag protected endpoints.\n    \"\"\"\nreturn decorator", "successors": []}], "functions": [{"name": "decorator", "type": "CFG", "blocks": [{"id": 31, "label": "#31\nreturn cast(Callable[P, Union[T, Awaitable[T]]], async_wrapper if asyncio.\n    iscoroutinefunction(func) else sync_wrapper)", "successors": []}], "functions": [{"name": "async_wrapper", "type": "CFG", "blocks": [{"id": 33, "label": "#33\ntry:", "successors": [{"id": 34, "label": "#34\nuser_id = kwargs.get('user_id')\nif not user_id:", "successors": [{"id": 37, "label": "#37\nraise ValueError('user_id is required')", "successors": []}, {"id": 38, "label": "#38\nif not get_client().is_initialized():", "successors": [{"id": 40, "label": "#40\nlogger.warning(f'LaunchDarkly not initialized, using default={default}')\nis_enabled = default", "successors": [{"id": 41, "label": "#41\nif not is_enabled:", "successors": [{"id": 43, "label": "#43\nraise HTTPException(status_code=404, detail='Feature not available')", "successors": []}, {"id": 44, "label": "#44\nresult = func(*args, **kwargs)\nif asyncio.iscoroutine(result):", "successors": [{"id": 46, "label": "#46\nreturn await result", "successors": []}, {"id": 47, "label": "#47\nreturn cast(T, result)", "successors": []}]}]}]}, {"id": 42, "label": "#42\ncontext = create_context(str(user_id))\nis_enabled = get_client().variation(flag_key, context, default)", "successors": []}]}]}, {"id": 35, "label": "#35\nlogger.error(f'Error evaluating feature flag {flag_key}: {e}')\nraise", "successors": []}]}], "functions": [], "classes": []}, {"name": "sync_wrapper", "type": "CFG", "blocks": [{"id": 53, "label": "#53\ntry:", "successors": [{"id": 54, "label": "#54\nuser_id = kwargs.get('user_id')\nif not user_id:", "successors": [{"id": 57, "label": "#57\nraise ValueError('user_id is required')", "successors": []}, {"id": 58, "label": "#58\nif not get_client().is_initialized():", "successors": [{"id": 60, "label": "#60\nlogger.warning(f'LaunchDarkly not initialized, using default={default}')\nis_enabled = default", "successors": [{"id": 61, "label": "#61\nif not is_enabled:", "successors": [{"id": 63, "label": "#63\nraise HTTPException(status_code=404, detail='Feature not available')", "successors": []}, {"id": 64, "label": "#64\nreturn cast(T, func(*args, **kwargs))", "successors": []}]}]}, {"id": 62, "label": "#62\ncontext = create_context(str(user_id))\nis_enabled = get_client().variation(flag_key, context, default)", "successors": []}]}]}, {"id": 55, "label": "#55\nlogger.error(f'Error evaluating feature flag {flag_key}: {e}')\nraise", "successors": []}]}], "functions": [], "classes": []}], "classes": []}], "classes": []}, {"name": "percentage_rollout", "type": "CFG", "blocks": [{"id": 74, "label": "#74\n\"\"\"Decorator for percentage-based rollouts.\"\"\"\nreturn feature_flag(flag_key, default)", "successors": []}], "functions": [], "classes": []}, {"name": "beta_feature", "type": "CFG", "blocks": [{"id": 78, "label": "#78\n\"\"\"Decorator for beta features.\"\"\"\nactual_key = f'beta-{flag_key}' if flag_key else 'beta'\nreturn feature_flag(actual_key, False)", "successors": []}], "functions": [], "classes": []}, {"name": "mock_flag_variation", "type": "CFG", "blocks": [{"id": 82, "label": "#82\n\"\"\"Context manager for testing feature flags.\"\"\"\noriginal_variation = get_client().variation\nget_client().variation = (lambda key, context, default: return_value if key ==\n    flag_key else original_variation(key, context, default))\ntry:", "successors": [{"id": 83, "label": "#83\nyield", "successors": []}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "69.json", "name": "69.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport logging\nimport time\nfrom enum import Enum\nfrom typing import Literal\nfrom pydantic import SecretStr\nfrom backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema\nfrom backend.data.model import APIKeyCredentials, CredentialsField, CredentialsMetaInput, SchemaField\nfrom backend.integrations.providers import ProviderName\nfrom backend.util.request import requests\nTEST_CREDENTIALS = APIKeyCredentials(id=\n    '01234567-89ab-cdef-0123-456789abcdef', provider='revid', api_key=\n    SecretStr('mock-revid-api-key'), title='Mock Revid API key', expires_at\n    =None)\nTEST_CREDENTIALS_INPUT = {'provider': TEST_CREDENTIALS.provider, 'id':\n    TEST_CREDENTIALS.id, 'type': TEST_CREDENTIALS.type, 'title':\n    TEST_CREDENTIALS.type}\nlogger = logging.getLogger(__name__)", "successors": []}], "functions": [], "classes": [{"name": "AudioTrack", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nOBSERVER = 'Observer',\nFUTURISTIC_BEAT = 'Futuristic Beat',\nSCIENCE_DOCUMENTARY = 'Science Documentary',\nHOTLINE = 'Hotline',\nBLADERUNNER_2049 = 'Bladerunner 2049',\nA_FUTURE = 'A Future',\nELYSIAN_EMBERS = 'Elysian Embers',\nINSPIRING_CINEMATIC = 'Inspiring Cinematic',\nBLADERUNNER_REMIX = 'Bladerunner Remix',\nIZZAMUZZIC = 'Izzamuzzic',\nNAS = 'Nas',\nPARIS_ELSE = 'Paris - Else',\nSNOWFALL = 'Snowfall',\nBURLESQUE = 'Burlesque',\nCORNY_CANDY = 'Corny Candy',\nHIGHWAY_NOCTURNE = 'Highway Nocturne',\nI_DONT_THINK_SO = \"I Don't Think So\",\nLOSING_YOUR_MARBLES = 'Losing Your Marbles',\nREFRESHER = 'Refresher',\nTOURIST = 'Tourist',\nTWIN_TYCHES = 'Twin Tyches',", "successors": []}], "functions": [{"name": "audio_url", "type": "CFG", "blocks": [{"id": 5, "label": "#5\naudio_urls = {AudioTrack.OBSERVER:\n    'https://cdn.tfrv.xyz/audio/observer.mp3', AudioTrack.FUTURISTIC_BEAT:\n    'https://cdn.tfrv.xyz/audio/_futuristic-beat.mp3', AudioTrack.\n    SCIENCE_DOCUMENTARY:\n    'https://cdn.tfrv.xyz/audio/_science-documentary.mp3', AudioTrack.\n    HOTLINE: 'https://cdn.tfrv.xyz/audio/_hotline.mp3', AudioTrack.\n    BLADERUNNER_2049: 'https://cdn.tfrv.xyz/audio/_bladerunner-2049.mp3',\n    AudioTrack.A_FUTURE: 'https://cdn.tfrv.xyz/audio/a-future.mp3',\n    AudioTrack.ELYSIAN_EMBERS:\n    'https://cdn.tfrv.xyz/audio/elysian-embers.mp3', AudioTrack.\n    INSPIRING_CINEMATIC:\n    'https://cdn.tfrv.xyz/audio/inspiring-cinematic-ambient.mp3',\n    AudioTrack.BLADERUNNER_REMIX:\n    'https://cdn.tfrv.xyz/audio/bladerunner-remix.mp3', AudioTrack.\n    IZZAMUZZIC: 'https://cdn.tfrv.xyz/audio/_izzamuzzic.mp3', AudioTrack.\n    NAS: 'https://cdn.tfrv.xyz/audio/_nas.mp3', AudioTrack.PARIS_ELSE:\n    'https://cdn.tfrv.xyz/audio/_paris-else.mp3', AudioTrack.SNOWFALL:\n    'https://cdn.tfrv.xyz/audio/_snowfall.mp3', AudioTrack.BURLESQUE:\n    'https://cdn.tfrv.xyz/audio/burlesque.mp3', AudioTrack.CORNY_CANDY:\n    'https://cdn.tfrv.xyz/audio/corny-candy.mp3', AudioTrack.\n    HIGHWAY_NOCTURNE: 'https://cdn.tfrv.xyz/audio/highway-nocturne.mp3',\n    AudioTrack.I_DONT_THINK_SO:\n    'https://cdn.tfrv.xyz/audio/i-dont-think-so.mp3', AudioTrack.\n    LOSING_YOUR_MARBLES:\n    'https://cdn.tfrv.xyz/audio/losing-your-marbles.mp3', AudioTrack.\n    REFRESHER: 'https://cdn.tfrv.xyz/audio/refresher.mp3', AudioTrack.\n    TOURIST: 'https://cdn.tfrv.xyz/audio/tourist.mp3', AudioTrack.\n    TWIN_TYCHES: 'https://cdn.tfrv.xyz/audio/twin-tynches.mp3'}\nreturn audio_urls[self]", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "GenerationPreset", "type": "CFG", "blocks": [{"id": 10, "label": "#10\nLEONARDO = 'Default',\nANIME = 'Anime',\nREALISM = 'Realist',\nILLUSTRATION = 'Illustration',\nSKETCH_COLOR = 'Sketch Color',\nSKETCH_BW = 'Sketch B&W',\nPIXAR = 'Pixar',\nINK = 'Japanese Ink',\nRENDER_3D = '3D Render',\nLEGO = 'Lego',\nSCIFI = 'Sci-Fi',\nRECRO_CARTOON = 'Retro Cartoon',\nPIXEL_ART = 'Pixel Art',\nCREATIVE = 'Creative',\nPHOTOGRAPHY = 'Photography',\nRAYTRACED = 'Raytraced',\nENVIRONMENT = 'Environment',\nFANTASY = 'Fantasy',\nANIME_SR = 'Anime Realism',\nMOVIE = 'Movie',\nSTYLIZED_ILLUSTRATION = 'Stylized Illustration',\nMANGA = 'Manga',", "successors": []}], "functions": [], "classes": []}, {"name": "Voice", "type": "CFG", "blocks": [{"id": 13, "label": "#13\nLILY = 'Lily'\nDANIEL = 'Daniel'\nBRIAN = 'Brian'\nJESSICA = 'Jessica'\nCHARLOTTE = 'Charlotte'\nCALLUM = 'Callum'", "successors": []}], "functions": [{"name": "voice_id", "type": "CFG", "blocks": [{"id": 15, "label": "#15\nvoice_id_map = {Voice.LILY: 'pFZP5JQG7iQjIQuC4Bku', Voice.DANIEL:\n    'onwK4e9ZLuTAKqWW03F9', Voice.BRIAN: 'nPczCjzI2devNBz1zQrb', Voice.\n    JESSICA: 'cgSgspJ2msm6clMCkdW9', Voice.CHARLOTTE:\n    'XB0fDUnXU5powFXDhCwa', Voice.CALLUM: 'N2lVS1w4EtoT3dr4eOWO'}\nreturn voice_id_map[self]", "successors": []}], "functions": [], "classes": []}, {"name": "__str__", "type": "CFG", "blocks": [{"id": 19, "label": "#19\nreturn self.value", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "VisualMediaType", "type": "CFG", "blocks": [{"id": 24, "label": "#24\nSTOCK_VIDEOS = 'stockVideo',\nMOVING_AI_IMAGES = 'movingImage',\nAI_VIDEO = 'aiVideo',", "successors": []}], "functions": [], "classes": []}, {"name": "AIShortformVideoCreatorBlock", "type": "CFG", "blocks": [{"id": 27, "label": "#27", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 35, "label": "#35\nsuper().__init__(id='361697fb-0c4f-4feb-aed3-8320c88c771b', description=\n    'Creates a shortform video using revid.ai', categories={BlockCategory.\n    SOCIAL, BlockCategory.AI}, input_schema=AIShortformVideoCreatorBlock.\n    Input, output_schema=AIShortformVideoCreatorBlock.Output, test_input={\n    'credentials': TEST_CREDENTIALS_INPUT, 'script':\n    '[close-up of a cat] Meow!', 'ratio': '9 / 16', 'resolution': '720p',\n    'frame_rate': 60, 'generation_preset': GenerationPreset.LEONARDO,\n    'background_music': AudioTrack.HIGHWAY_NOCTURNE, 'voice': Voice.LILY,\n    'video_style': VisualMediaType.STOCK_VIDEOS}, test_output=('video_url',\n    'https://example.com/video.mp4'), test_mock={'create_webhook': lambda :\n    ('test_uuid', 'https://webhook.site/test_uuid'), 'create_video': lambda\n    api_key, payload: {'pid': 'test_pid'}, 'wait_for_video': lambda api_key,\n    pid, webhook_token, max_wait_time=1000: 'https://example.com/video.mp4'\n    }, test_credentials=TEST_CREDENTIALS)", "successors": []}], "functions": [], "classes": []}, {"name": "create_webhook", "type": "CFG", "blocks": [{"id": 38, "label": "#38\nurl = 'https://webhook.site/token'\nheaders = {'Accept': 'application/json', 'Content-Type': 'application/json'}\nresponse = requests.post(url, headers=headers)\nwebhook_data = response.json()\nreturn webhook_data['uuid'], f\"https://webhook.site/{webhook_data['uuid']}\"", "successors": []}], "functions": [], "classes": []}, {"name": "create_video", "type": "CFG", "blocks": [{"id": 42, "label": "#42\nurl = 'https://www.revid.ai/api/public/v2/render'\nheaders = {'key': api_key.get_secret_value()}\nresponse = requests.post(url, json=payload, headers=headers)\nlogger.debug(\n    f'API Response Status Code: {response.status_code}, Content: {response.text}'\n    )\nreturn response.json()", "successors": []}], "functions": [], "classes": []}, {"name": "check_video_status", "type": "CFG", "blocks": [{"id": 46, "label": "#46\nurl = f'https://www.revid.ai/api/public/v2/status?pid={pid}'\nheaders = {'key': api_key.get_secret_value()}\nresponse = requests.get(url, headers=headers)\nreturn response.json()", "successors": []}], "functions": [], "classes": []}, {"name": "wait_for_video", "type": "CFG", "blocks": [{"id": 50, "label": "#50\nstart_time = time.time()", "successors": [{"id": 51, "label": "#51\nwhile time.time() - start_time < max_wait_time:", "successors": [{"id": 52, "label": "#52\nstatus = self.check_video_status(api_key, pid)\nlogger.debug(f'Video status: {status}')\nif status.get('status') == 'ready' and 'videoUrl' in status:", "successors": [{"id": 54, "label": "#54\nreturn status['videoUrl']", "successors": []}, {"id": 56, "label": "#56\nif status.get('status') == 'error':", "successors": [{"id": 57, "label": "#57\nerror_message = status.get('error', 'Unknown error occurred')\nlogger.error(f'Video creation failed: {error_message}')\nraise ValueError(f'Video creation failed: {error_message}')", "successors": []}, {"id": 59, "label": "#59\nif status.get('status') in ['FAILED', 'CANCELED']:", "successors": [{"id": 60, "label": "#60\nlogger.error(f\"Video creation failed: {status.get('message')}\")\nraise ValueError(f\"Video creation failed: {status.get('message')}\")", "successors": []}, {"id": 55, "label": "#55\ntime.sleep(10)", "successors": []}]}]}]}, {"id": 53, "label": "#53\nlogger.error('Video creation timed out')\nraise TimeoutError('Video creation timed out')", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 68, "label": "#68\nwebhook_token, webhook_url = self.create_webhook()\nlogger.debug(f'Webhook URL: {webhook_url}')\naudio_url = input_data.background_music.audio_url\npayload = {'frameRate': input_data.frame_rate, 'resolution': input_data.\n    resolution, 'frameDurationMultiplier': 18, 'webhook': webhook_url,\n    'creationParams': {'mediaType': input_data.video_style,\n    'captionPresetName': 'Wrap 1', 'selectedVoice': input_data.voice.\n    voice_id, 'hasEnhancedGeneration': True, 'generationPreset': input_data\n    .generation_preset.name, 'selectedAudio': input_data.background_music,\n    'origin': '/create', 'inputText': input_data.script, 'flowType':\n    'text-to-video', 'slug': 'create-tiktok-video', 'hasToGenerateVoice': \n    True, 'hasToTranscript': False, 'hasToSearchMedia': True, 'hasAvatar': \n    False, 'hasWebsiteRecorder': False, 'hasTextSmallAtBottom': False,\n    'ratio': input_data.ratio, 'sourceType': 'contentScraping',\n    'selectedStoryStyle': {'value': 'custom', 'label': 'Custom'},\n    'hasToGenerateVideos': input_data.video_style != VisualMediaType.\n    STOCK_VIDEOS, 'audioUrl': audio_url}}\nresponse = self.create_video(credentials.api_key, payload)\npid = response.get('pid')\nif not pid:", "successors": [{"id": 69, "label": "#69\nlogger.error(\n    f'Failed to create video: No project ID returned. API Response: {response}'\n    )\nraise RuntimeError('Failed to create video: No project ID returned')", "successors": []}, {"id": 71, "label": "#71\n    )\nvideo_url = self.wait_for_video(credentials.api_key, pid, webhook_token)\nlogger.debug(f'Video ready: {video_url}')\nyield 'video_url', video_url", "successors": []}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 29, "label": "#29\ncredentials: CredentialsMetaInput[Literal[ProviderName.REVID], Literal[\n    'api_key']] = CredentialsField(description=\n    'The revid.ai integration can be used with any API key with sufficient permissions for the blocks it is used on.'\n    )\nscript: str = SchemaField(description=\n    \"\"\"1. Use short and punctuated sentences\n\n2. Use linebreaks to create a new clip\n\n3. Text outside of brackets is spoken by the AI, and [text between brackets] will be used to guide the visual generation. For example, [close-up of a cat] will show a close-up of a cat.\"\"\"\n    , placeholder='[close-up of a cat] Meow!')\nratio: str = SchemaField(description='Aspect ratio of the video', default=\n    '9 / 16')\nresolution: str = SchemaField(description='Resolution of the video',\n    default='720p')\nframe_rate: int = SchemaField(description='Frame rate of the video', default=60\n    )\ngeneration_preset: GenerationPreset = SchemaField(description=\n    'Generation preset for visual style - only effects AI generated visuals',\n    default=GenerationPreset.LEONARDO, placeholder=GenerationPreset.LEONARDO)\nbackground_music: AudioTrack = SchemaField(description=\n    'Background music track', default=AudioTrack.HIGHWAY_NOCTURNE,\n    placeholder=AudioTrack.HIGHWAY_NOCTURNE)\nvoice: Voice = SchemaField(description='AI voice to use for narration',\n    default=Voice.LILY, placeholder=Voice.LILY)\nvideo_style: VisualMediaType = SchemaField(description=\n    'Type of visual media to use for the video', default=VisualMediaType.\n    STOCK_VIDEOS, placeholder=VisualMediaType.STOCK_VIDEOS)", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 32, "label": "#32\nvideo_url: str = SchemaField(description='The URL of the created video')\nerror: str = SchemaField(description='Error message if the request failed')", "successors": []}], "functions": [], "classes": []}]}]}
{"file_name": "70.json", "name": "70.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport logging\nfrom typing import TYPE_CHECKING, Annotated, Literal\nfrom fastapi import APIRouter, Body, Depends, HTTPException, Path, Query, Request\nfrom pydantic import BaseModel, Field, SecretStr\nfrom backend.data.graph import set_node_webhook\nfrom backend.data.integrations import WebhookEvent, get_all_webhooks_by_creds, get_webhook, publish_webhook_event, wait_for_webhook_event\nfrom backend.data.model import APIKeyCredentials, Credentials, CredentialsType, OAuth2Credentials\nfrom backend.executor.manager import ExecutionManager\nfrom backend.integrations.creds_manager import IntegrationCredentialsManager\nfrom backend.integrations.oauth import HANDLERS_BY_NAME\nfrom backend.integrations.providers import ProviderName\nfrom backend.integrations.webhooks import WEBHOOK_MANAGERS_BY_NAME\nfrom backend.util.exceptions import NeedConfirmation\nfrom backend.util.service import get_service_client\nfrom backend.util.settings import Settings\nif TYPE_CHECKING:", "successors": [{"id": 2, "label": "#2\nfrom backend.integrations.oauth import BaseOAuthHandler", "successors": [{"id": 3, "label": "#3\nfrom ..utils import get_user_id\nlogger = logging.getLogger(__name__)\nsettings = Settings()\nrouter = APIRouter()\ncreds_manager = IntegrationCredentialsManager()", "successors": []}]}]}], "functions": [{"name": "login", "type": "CFG", "blocks": [{"id": 8, "label": "#8\nhandler = _get_provider_oauth_handler(request, provider)\nrequested_scopes = scopes.split(',') if scopes else []\nstate_token = creds_manager.store.store_state_token(user_id, provider,\n    requested_scopes)\nlogin_url = handler.get_login_url(requested_scopes, state_token)\nreturn LoginResponse(login_url=login_url, state_token=state_token)", "successors": []}], "functions": [], "classes": []}, {"name": "callback", "type": "CFG", "blocks": [{"id": 15, "label": "#15\nlogger.debug(f'Received OAuth callback for provider: {provider}')\nhandler = _get_provider_oauth_handler(request, provider)\nif not creds_manager.store.verify_state_token(user_id, state_token, provider):", "successors": [{"id": 16, "label": "#16\nlogger.warning(f'Invalid or expired state token for user {user_id}')\nraise HTTPException(status_code=400, detail='Invalid or expired state token')", "successors": []}, {"id": 17, "label": "#17\ntry:", "successors": [{"id": 19, "label": "#19\nscopes = creds_manager.store.get_any_valid_scopes_from_state_token(user_id,\n    state_token, provider)\nlogger.debug(f'Retrieved scopes from state token: {scopes}')\nscopes = handler.handle_default_scopes(scopes)\ncredentials = handler.exchange_code_for_tokens(code, scopes)\nlogger.debug(f'Received credentials with final scopes: {credentials.scopes}')\nif not set(scopes).issubset(set(credentials.scopes)):", "successors": [{"id": 22, "label": "#22\nlogger.warning(\n    f'Granted scopes {credentials.scopes} for provider {provider.value} do not include all requested scopes {scopes}'\n    )", "successors": [{"id": 21, "label": "#21\ncreds_manager.create(user_id, credentials)\nlogger.debug(\n    f'Successfully processed OAuth callback for user {user_id} and provider {provider.value}'\n    )\nreturn CredentialsMetaResponse(id=credentials.id, provider=credentials.\n    provider, type=credentials.type, title=credentials.title, scopes=\n    credentials.scopes, username=credentials.username)", "successors": []}]}]}, {"id": 20, "label": "#20\nlogger.error(f'Code->Token exchange failed for provider {provider.value}: {e}')\nraise HTTPException(status_code=400, detail=\n    f'Failed to exchange code for tokens: {str(e)}')", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "list_credentials", "type": "CFG", "blocks": [{"id": 28, "label": "#28\ncredentials = creds_manager.store.get_all_creds(user_id)\nreturn [CredentialsMetaResponse(id=cred.id, provider=cred.provider, type=\n    cred.type, title=cred.title, scopes=cred.scopes if isinstance(cred,\n    OAuth2Credentials) else None, username=cred.username if isinstance(cred,\n    OAuth2Credentials) else None) for cred in credentials]", "successors": []}], "functions": [], "classes": []}, {"name": "list_credentials_by_provider", "type": "CFG", "blocks": [{"id": 32, "label": "#32\ncredentials = creds_manager.store.get_creds_by_provider(user_id, provider)\nreturn [CredentialsMetaResponse(id=cred.id, provider=cred.provider, type=\n    cred.type, title=cred.title, scopes=cred.scopes if isinstance(cred,\n    OAuth2Credentials) else None, username=cred.username if isinstance(cred,\n    OAuth2Credentials) else None) for cred in credentials]", "successors": []}], "functions": [], "classes": []}, {"name": "get_credential", "type": "CFG", "blocks": [{"id": 36, "label": "#36\ncredential = creds_manager.get(user_id, cred_id)\nif not credential:", "successors": [{"id": 37, "label": "#37\nraise HTTPException(status_code=404, detail='Credentials not found')", "successors": []}, {"id": 38, "label": "#38\nif credential.provider != provider:", "successors": [{"id": 40, "label": "#40\nraise HTTPException(status_code=404, detail=\n    'Credentials do not match the specified provider')", "successors": []}, {"id": 41, "label": "#41\nreturn credential", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "create_api_key_credentials", "type": "CFG", "blocks": [{"id": 46, "label": "#46\nnew_credentials = APIKeyCredentials(provider=provider, api_key=SecretStr(\n    api_key), title=title, expires_at=expires_at)\ntry:", "successors": [{"id": 47, "label": "#47\ncreds_manager.create(user_id, new_credentials)", "successors": [{"id": 49, "label": "#49\nreturn new_credentials", "successors": []}]}, {"id": 48, "label": "#48\nraise HTTPException(status_code=500, detail=\n    f'Failed to store credentials: {str(e)}')", "successors": []}]}], "functions": [], "classes": []}, {"name": "delete_credentials", "type": "CFG", "blocks": [{"id": 60, "label": "#60\ncreds = creds_manager.store.get_creds_by_id(user_id, cred_id)\nif not creds:", "successors": [{"id": 61, "label": "#61\nraise HTTPException(status_code=404, detail='Credentials not found')", "successors": []}, {"id": 62, "label": "#62\nif creds.provider != provider:", "successors": [{"id": 64, "label": "#64\nraise HTTPException(status_code=404, detail=\n    'Credentials do not match the specified provider')", "successors": []}, {"id": 65, "label": "#65\ntry:", "successors": [{"id": 67, "label": "#67\nawait remove_all_webhooks_for_credentials(creds, force)", "successors": [{"id": 69, "label": "#69\ncreds_manager.delete(user_id, cred_id)\ntokens_revoked = None\nif isinstance(creds, OAuth2Credentials):", "successors": [{"id": 72, "label": "#72\nhandler = _get_provider_oauth_handler(request, provider)\ntokens_revoked = handler.revoke_tokens(creds)", "successors": [{"id": 73, "label": "#73\nreturn CredentialsDeletionResponse(revoked=tokens_revoked)", "successors": []}]}]}]}, {"id": 68, "label": "#68\nreturn CredentialsDeletionNeedsConfirmationResponse(message=str(e))", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "webhook_ingress_generic", "type": "CFG", "blocks": [{"id": 77, "label": "#77\nlogger.debug(f'Received {provider.value} webhook ingress for ID {webhook_id}')\nwebhook_manager = WEBHOOK_MANAGERS_BY_NAME[provider]()\nwebhook = await get_webhook(webhook_id)", "successors": [{"id": 78, "label": "#78\nlogger.debug(f'Webhook #{webhook_id}: {webhook}')\npayload, event_type = await webhook_manager.validate_payload(webhook, request)", "successors": [{"id": 79, "label": "#79\nlogger.debug(\n    f'Validated {provider.value} {webhook.webhook_type} {event_type} event with payload {payload}'\n    )\nwebhook_event = WebhookEvent(provider=provider, webhook_id=webhook_id,\n    event_type=event_type, payload=payload)\nawait publish_webhook_event(webhook_event)", "successors": [{"id": 80, "label": "#80\nlogger.debug(f'Webhook event published: {webhook_event}')\nif not webhook.attached_nodes:", "successors": [{"id": 81, "label": "#81\nreturn", "successors": []}, {"id": 82, "label": "#82\nexecutor = get_service_client(ExecutionManager)", "successors": [{"id": 84, "label": "#84\nfor node in webhook.attached_nodes:", "successors": [{"id": 85, "label": "#85\nlogger.debug(f'Webhook-attached node: {node}')\nif not node.is_triggered_by_event_type(event_type):", "successors": [{"id": 87, "label": "#87\nlogger.debug(f\"Node #{node.id} doesn't trigger on event {event_type}\")", "successors": []}, {"id": 88, "label": "#88\nlogger.debug(f'Executing graph #{node.graph_id} node #{node.id}')\nexecutor.add_execution(node.graph_id, data={f'webhook_{webhook_id}_payload':\n    payload}, user_id=webhook.user_id)", "successors": []}]}]}]}]}]}]}]}], "functions": [], "classes": []}, {"name": "webhook_ping", "type": "CFG", "blocks": [{"id": 91, "label": "#91\nwebhook = await get_webhook(webhook_id)", "successors": [{"id": 92, "label": "#92\nwebhook_manager = WEBHOOK_MANAGERS_BY_NAME[webhook.provider]()\ncredentials = creds_manager.get(user_id, webhook.credentials_id\n    ) if webhook.credentials_id else None\ntry:", "successors": [{"id": 93, "label": "#93\nawait webhook_manager.trigger_ping(webhook, credentials)", "successors": [{"id": 95, "label": "#95\nif not await wait_for_webhook_event(webhook_id, event_type='ping', timeout=10):", "successors": [{"id": 98, "label": "#98\nraise HTTPException(status_code=504, detail='Webhook ping timed out')", "successors": []}, {"id": 99, "label": "#99\nreturn True", "successors": []}]}]}, {"id": 94, "label": "#94\nreturn False", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "remove_all_webhooks_for_credentials", "type": "CFG", "blocks": [{"id": 104, "label": "#104\n\"\"\"\n    Remove and deregister all webhooks that were registered using the given credentials.\n\n    Params:\n        credentials: The credentials for which to remove the associated webhooks.\n        force: Whether to proceed if any of the webhooks are still in use.\n\n    Raises:\n        NeedConfirmation: If any of the webhooks are still in use and `force` is `False`\n    \"\"\"\nwebhooks = await get_all_webhooks_by_creds(credentials.id)", "successors": [{"id": 105, "label": "#105\nif credentials.provider not in WEBHOOK_MANAGERS_BY_NAME:", "successors": [{"id": 106, "label": "#106\nif webhooks:", "successors": [{"id": 108, "label": "#108\nlogger.error(\n    f'Credentials #{credentials.id} for provider {credentials.provider} are attached to {len(webhooks)} webhooks, but there is no available WebhooksHandler for {credentials.provider}'\n    )", "successors": [{"id": 109, "label": "#109\nreturn", "successors": []}]}]}, {"id": 107, "label": "#107\nif any(w.attached_nodes for w in webhooks) and not force:", "successors": [{"id": 111, "label": "#111\nraise NeedConfirmation(\n    'Some webhooks linked to these credentials are still in use by an agent')", "successors": []}, {"id": 112, "label": "#112\nfor webhook in webhooks:", "successors": [{"id": 114, "label": "#114\nfor node in (webhook.attached_nodes or []):", "successors": [{"id": 116, "label": "#116\nawait set_node_webhook(node.id, None)", "successors": []}, {"id": 117, "label": "#117\nwebhook_manager = WEBHOOK_MANAGERS_BY_NAME[credentials.provider]()\nsuccess = await webhook_manager.prune_webhook_if_dangling(webhook.id,\n    credentials)", "successors": [{"id": 119, "label": "#119\nif not success:", "successors": [{"id": 120, "label": "#120\nlogger.warning(f'Webhook #{webhook.id} failed to prune')", "successors": []}]}]}]}]}]}]}]}], "functions": [], "classes": []}, {"name": "_get_provider_oauth_handler", "type": "CFG", "blocks": [{"id": 124, "label": "#124\nif provider_name not in HANDLERS_BY_NAME:", "successors": [{"id": 125, "label": "#125\nraise HTTPException(status_code=404, detail=\n    f\"Provider '{provider_name.value}' does not support OAuth\")", "successors": []}, {"id": 126, "label": "#126\nclient_id = getattr(settings.secrets, f'{provider_name.value}_client_id')\nclient_secret = getattr(settings.secrets,\n    f'{provider_name.value}_client_secret')\nif not (client_id and client_secret):", "successors": [{"id": 128, "label": "#128\nraise HTTPException(status_code=501, detail=\n    f\"Integration with provider '{provider_name.value}' is not configured\")", "successors": []}, {"id": 129, "label": "#129\nhandler_class = HANDLERS_BY_NAME[provider_name]\nfrontend_base_url = (settings.config.frontend_base_url or settings.config.\n    platform_base_url or str(req.base_url))\nreturn handler_class(client_id=client_id, client_secret=client_secret,\n    redirect_uri=f'{frontend_base_url}/auth/integrations/oauth_callback')", "successors": []}]}]}], "functions": [], "classes": []}], "classes": [{"name": "LoginResponse", "type": "CFG", "blocks": [{"id": 5, "label": "#5\nlogin_url: str\nstate_token: str", "successors": []}], "functions": [], "classes": []}, {"name": "CredentialsMetaResponse", "type": "CFG", "blocks": [{"id": 12, "label": "#12\nid: str\nprovider: str\ntype: CredentialsType\ntitle: str | None\nscopes: list[str] | None\nusername: str | None", "successors": []}], "functions": [], "classes": []}, {"name": "CredentialsDeletionResponse", "type": "CFG", "blocks": [{"id": 54, "label": "#54\ndeleted: Literal[True] = True\nrevoked: bool | None = Field(description=\n    'Indicates whether the credentials were also revoked by their provider. `None`/`null` if not applicable, e.g. when deleting non-revocable credentials such as API keys.'\n    )", "successors": []}], "functions": [], "classes": []}, {"name": "CredentialsDeletionNeedsConfirmationResponse", "type": "CFG", "blocks": [{"id": 57, "label": "#57\ndeleted: Literal[False] = False\nneed_confirmation: Literal[True] = True\nmessage: str", "successors": []}], "functions": [], "classes": []}]}
{"file_name": "71.json", "name": "71.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\n\"\"\"\nGiven a partially filled 9x9 2D array, the objective is to fill a 9x9\nsquare grid with digits numbered 1 to 9, so that every row, column, and\nand each of the nine 3x3 sub-grids contains all of the digits.\n\nThis can be solved using Backtracking and is similar to n-queens.\nWe check to see if a cell is safe or not and recursively call the\nfunction on the next column to see if it returns True. if yes, we\nhave solved the puzzle. else, we backtrack and place another number\nin that cell and repeat this process.\n\"\"\"\nfrom __future__ import annotations\nMatrix = list[list[int]]\ninitial_grid: Matrix = [[3, 0, 6, 5, 0, 8, 4, 0, 0], [5, 2, 0, 0, 0, 0, 0, \n    0, 0], [0, 8, 7, 0, 0, 0, 0, 3, 1], [0, 0, 3, 0, 1, 0, 0, 8, 0], [9, 0,\n    0, 8, 6, 3, 0, 0, 5], [0, 5, 0, 0, 9, 0, 6, 0, 0], [1, 3, 0, 0, 0, 0, 2,\n    5, 0], [0, 0, 0, 0, 0, 0, 0, 7, 4], [0, 0, 5, 2, 0, 6, 3, 0, 0]]\nno_solution: Matrix = [[5, 0, 6, 5, 0, 8, 4, 0, 3], [5, 2, 0, 0, 0, 0, 0, 0,\n    2], [1, 8, 7, 0, 0, 0, 0, 3, 1], [0, 0, 3, 0, 1, 0, 0, 8, 0], [9, 0, 0,\n    8, 6, 3, 0, 0, 5], [0, 5, 0, 0, 9, 0, 6, 0, 0], [1, 3, 0, 0, 0, 0, 2, 5,\n    0], [0, 0, 0, 0, 0, 0, 0, 7, 4], [0, 0, 5, 2, 0, 6, 3, 0, 0]]\nif __name__ == '__main__':", "successors": [{"id": 54, "label": "#54\nfor example_grid in (initial_grid, no_solution):", "successors": [{"id": 56, "label": "#56\nprint('\\nExample grid:\\n' + '=' * 20)\nprint_solution(example_grid)\nprint(\"\"\"\nExample grid solution:\"\"\")\nsolution = sudoku(example_grid)\nif solution is not None:", "successors": [{"id": 58, "label": "#58\nprint_solution(solution)", "successors": []}, {"id": 60, "label": "#60\nprint('Cannot find a solution.')", "successors": []}]}]}]}], "functions": [{"name": "is_safe", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"\n    This function checks the grid to see if each row,\n    column, and the 3x3 subgrids contain the digit 'n'.\n    It returns False if it is not 'safe' (a duplicate digit\n    is found) else returns True if it is 'safe'\n    \"\"\"", "successors": [{"id": 4, "label": "#4\nfor i in range(9):", "successors": [{"id": 5, "label": "#5\nif n in {grid[row][i], grid[i][column]}:", "successors": [{"id": 7, "label": "#7\nreturn False", "successors": []}]}, {"id": 6, "label": "#6\nfor i in range(3):", "successors": [{"id": 10, "label": "#10\nfor j in range(3):", "successors": [{"id": 12, "label": "#12\nif grid[row - row % 3 + i][column - column % 3 + j] == n:", "successors": [{"id": 14, "label": "#14\nreturn False", "successors": []}]}]}, {"id": 11, "label": "#11\nreturn True", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "find_empty_location", "type": "CFG", "blocks": [{"id": 20, "label": "#20\n\"\"\"\n    This function finds an empty location so that we can assign a number\n    for that particular row and column.\n    \"\"\"", "successors": [{"id": 21, "label": "#21\nfor i in range(9):", "successors": [{"id": 22, "label": "#22\nfor j in range(9):", "successors": [{"id": 24, "label": "#24\nif grid[i][j] == 0:", "successors": [{"id": 26, "label": "#26\nreturn i, j", "successors": []}]}]}, {"id": 23, "label": "#23\nreturn None", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "sudoku", "type": "CFG", "blocks": [{"id": 32, "label": "#32\n\"\"\"\n    Takes a partially filled-in grid and attempts to assign values to\n    all unassigned locations in such a way to meet the requirements\n    for Sudoku solution (non-duplication across rows, columns, and boxes)\n\n    >>> sudoku(initial_grid)  # doctest: +NORMALIZE_WHITESPACE\n    [[3, 1, 6, 5, 7, 8, 4, 9, 2],\n     [5, 2, 9, 1, 3, 4, 7, 6, 8],\n     [4, 8, 7, 6, 2, 9, 5, 3, 1],\n     [2, 6, 3, 4, 1, 5, 9, 8, 7],\n     [9, 7, 4, 8, 6, 3, 1, 2, 5],\n     [8, 5, 1, 7, 9, 2, 6, 4, 3],\n     [1, 3, 8, 9, 4, 7, 2, 5, 6],\n     [6, 9, 2, 3, 5, 1, 8, 7, 4],\n     [7, 4, 5, 2, 8, 6, 3, 1, 9]]\n     >>> sudoku(no_solution) is None\n     True\n    \"\"\"\nif (location := find_empty_location(grid)):", "successors": [{"id": 33, "label": "#33\nrow, column = location", "successors": [{"id": 34, "label": "#34\nfor digit in range(1, 10):", "successors": [{"id": 37, "label": "#37\nif is_safe(grid, row, column, digit):", "successors": [{"id": 39, "label": "#39\ngrid[row][column] = digit\nif sudoku(grid) is not None:", "successors": [{"id": 41, "label": "#41\nreturn grid", "successors": []}, {"id": 42, "label": "#42\ngrid[row][column] = 0", "successors": []}]}]}, {"id": 38, "label": "#38\nreturn None", "successors": []}]}]}, {"id": 35, "label": "#35\nreturn grid", "successors": []}]}], "functions": [], "classes": []}, {"name": "print_solution", "type": "CFG", "blocks": [{"id": 47, "label": "#47\n\"\"\"\n    A function to print the solution in the form\n    of a 9x9 grid\n    \"\"\"", "successors": [{"id": 48, "label": "#48\nfor row in grid:", "successors": [{"id": 49, "label": "#49\nfor cell in row:", "successors": [{"id": 51, "label": "#51\nprint(cell, end=' ')", "successors": []}, {"id": 52, "label": "#52\nprint()", "successors": []}]}]}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "72.json", "name": "72.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport json\nfrom enum import Enum\nfrom typing import Any\nfrom backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema\nfrom backend.data.model import SchemaField\nfrom backend.util.request import requests", "successors": []}], "functions": [], "classes": [{"name": "HttpMethod", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nGET = 'GET'\nPOST = 'POST'\nPUT = 'PUT'\nDELETE = 'DELETE'\nPATCH = 'PATCH'\nOPTIONS = 'OPTIONS'\nHEAD = 'HEAD'", "successors": []}], "functions": [], "classes": []}, {"name": "SendWebRequestBlock", "type": "CFG", "blocks": [{"id": 6, "label": "#6", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 14, "label": "#14\nsuper().__init__(id='6595ae1f-b924-42cb-9a41-551a0611c4b4', description=\n    'This block makes an HTTP request to the given URL.', categories={\n    BlockCategory.OUTPUT}, input_schema=SendWebRequestBlock.Input,\n    output_schema=SendWebRequestBlock.Output)", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 17, "label": "#17\nif isinstance(input_data.body, str):", "successors": [{"id": 18, "label": "#18\ninput_data.body = json.loads(input_data.body)", "successors": [{"id": 19, "label": "#19\nresponse = requests.request(input_data.method.value, input_data.url,\n    headers=input_data.headers, json=input_data.body if input_data.\n    json_format else None, data=input_data.body if not input_data.\n    json_format else None)\nresult = response.json() if input_data.json_format else response.text\nif response.status_code // 100 == 2:", "successors": [{"id": 20, "label": "#20\nyield 'response', result", "successors": []}, {"id": 22, "label": "#22\nif response.status_code // 100 == 4:", "successors": [{"id": 23, "label": "#23\nyield 'client_error', result", "successors": []}, {"id": 25, "label": "#25\nif response.status_code // 100 == 5:", "successors": [{"id": 26, "label": "#26\nyield 'server_error', result", "successors": []}, {"id": 28, "label": "#28\nraise ValueError(f'Unexpected status code: {response.status_code}')", "successors": []}]}]}]}]}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 8, "label": "#8\nurl: str = SchemaField(description='The URL to send the request to',\n    placeholder='https://api.example.com')\nmethod: HttpMethod = SchemaField(description=\n    'The HTTP method to use for the request', default=HttpMethod.POST)\nheaders: dict[str, str] = SchemaField(description=\n    'The headers to include in the request', default={})\njson_format: bool = SchemaField(title='JSON format', description=\n    'Whether to send and receive body as JSON', default=True)\nbody: Any = SchemaField(description='The body of the request', default=None)", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 11, "label": "#11\nresponse: object = SchemaField(description='The response from the server')\nclient_error: object = SchemaField(description='The error on 4xx status codes')\nserver_error: object = SchemaField(description='The error on 5xx status codes')", "successors": []}], "functions": [], "classes": []}]}]}
{"file_name": "73.json", "name": "73.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport io\nimport logging\nfrom enum import Enum\nimport replicate\nimport replicate.exceptions\nimport requests\nfrom replicate.helpers import FileOutput\nfrom backend.data.graph import Graph\nfrom backend.util.settings import Settings\nlogger = logging.getLogger(__name__)", "successors": []}], "functions": [{"name": "generate_agent_image", "type": "CFG", "blocks": [{"id": 9, "label": "#9\n\"\"\"\n    Generate an image for an agent using Flux model via Replicate API.\n\n    Args:\n        agent (Graph): The agent to generate an image for\n\n    Returns:\n        io.BytesIO: The generated image as bytes\n    \"\"\"\ntry:", "successors": [{"id": 10, "label": "#10\nsettings = Settings()\nif not settings.secrets.replicate_api_key:", "successors": [{"id": 13, "label": "#13\nraise ValueError('Missing Replicate API key in settings')", "successors": []}, {"id": 14, "label": "#14\nprompt = f\"\"\"Create a visually engaging app store thumbnail for the AI agent that highlights what it does in a clear and captivating way:\n- **Name**: {agent.name}\n- **Description**: {agent.description}\nFocus on showcasing its core functionality with an appealing design.\"\"\"\nclient = replicate.Client(api_token=settings.secrets.replicate_api_key)\ninput_data = {'prompt': prompt, 'width': 1024, 'height': 768,\n    'aspect_ratio': '4:3', 'output_format': 'jpg', 'output_quality': 90,\n    'num_inference_steps': 30, 'guidance': 3.5, 'negative_prompt':\n    'blurry, low quality, distorted, deformed', 'disable_safety_checker': True}\ntry:", "successors": [{"id": 16, "label": "#16\noutput = client.run('black-forest-labs/flux-1.1-pro', input=input_data)\nif isinstance(output, list) and output:", "successors": [{"id": 19, "label": "#19\nif isinstance(output[0], FileOutput):", "successors": [{"id": 29, "label": "#29\nimage_bytes = output[0].read()", "successors": [{"id": 20, "label": "#20\nreturn io.BytesIO(image_bytes)", "successors": []}]}, {"id": 31, "label": "#31\nresult_url = output[0]\nresponse = requests.get(result_url)\nresponse.raise_for_status()\nimage_bytes = response.content", "successors": []}]}, {"id": 21, "label": "#21\nif isinstance(output, FileOutput):", "successors": [{"id": 22, "label": "#22\nimage_bytes = output.read()", "successors": []}, {"id": 24, "label": "#24\nif isinstance(output, str):", "successors": [{"id": 25, "label": "#25\nresponse = requests.get(output)\nresponse.raise_for_status()\nimage_bytes = response.content", "successors": []}, {"id": 27, "label": "#27\nraise RuntimeError('Unexpected output format from the model.')", "successors": []}]}]}]}, {"id": 17, "label": "#17\nif e.status == 401:", "successors": [{"id": 33, "label": "#33\nraise RuntimeError('Invalid Replicate API token') from e", "successors": []}, {"id": 34, "label": "#34\nraise RuntimeError(f'Replicate API error: {str(e)}') from e", "successors": []}]}]}]}, {"id": 11, "label": "#11\nlogger.exception('Failed to generate agent image')\nraise RuntimeError(f'Image generation failed: {str(e)}')", "successors": []}]}], "functions": [], "classes": []}], "classes": [{"name": "ImageSize", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nLANDSCAPE = '1024x768'", "successors": []}], "functions": [], "classes": []}, {"name": "ImageStyle", "type": "CFG", "blocks": [{"id": 6, "label": "#6\nDIGITAL_ART = 'digital art'", "successors": []}], "functions": [], "classes": []}]}
{"file_name": "74.json", "name": "74.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport logging\nfrom google.auth.external_account_authorized_user import Credentials as ExternalAccountCredentials\nfrom google.auth.transport.requests import AuthorizedSession, Request\nfrom google.oauth2.credentials import Credentials\nfrom google_auth_oauthlib.flow import Flow\nfrom pydantic import SecretStr\nfrom backend.data.model import OAuth2Credentials\nfrom backend.integrations.providers import ProviderName\nfrom .base import BaseOAuthHandler\nlogger = logging.getLogger(__name__)", "successors": []}], "functions": [], "classes": [{"name": "GoogleOAuthHandler", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"\n    Based on the documentation at https://developers.google.com/identity/protocols/oauth2/web-server\n    \"\"\"\nPROVIDER_NAME = ProviderName.GOOGLE\nEMAIL_ENDPOINT = 'https://www.googleapis.com/oauth2/v2/userinfo'\nDEFAULT_SCOPES = ['https://www.googleapis.com/auth/userinfo.email',\n    'https://www.googleapis.com/auth/userinfo.profile', 'openid']", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 5, "label": "#5\nself.client_id = client_id\nself.client_secret = client_secret\nself.redirect_uri = redirect_uri\nself.token_uri = 'https://oauth2.googleapis.com/token'\nself.revoke_uri = 'https://oauth2.googleapis.com/revoke'", "successors": []}], "functions": [], "classes": []}, {"name": "get_login_url", "type": "CFG", "blocks": [{"id": 8, "label": "#8\nall_scopes = list(set(scopes + self.DEFAULT_SCOPES))\nlogger.debug(f'Setting up OAuth flow with scopes: {all_scopes}')\nflow = self._setup_oauth_flow(all_scopes)\nflow.redirect_uri = self.redirect_uri\nauthorization_url, _ = flow.authorization_url(access_type='offline',\n    include_granted_scopes='true', state=state, prompt='consent')\nreturn authorization_url", "successors": []}], "functions": [], "classes": []}, {"name": "exchange_code_for_tokens", "type": "CFG", "blocks": [{"id": 12, "label": "#12\nlogger.debug(f'Exchanging code for tokens with scopes: {scopes}')\nflow = self._setup_oauth_flow(scopes)\nflow.redirect_uri = self.redirect_uri\nlogger.debug('Fetching token from Google')\nflow.oauth2session.scope = None\ntoken = flow.fetch_token(code=code)\nlogger.debug('Token fetched successfully')\ngranted_scopes: list[str] = token.get('scope', [])\nlogger.debug(f'Scopes granted by Google: {granted_scopes}')\ngoogle_creds = flow.credentials\nlogger.debug(f'Received credentials: {google_creds}')\nlogger.debug('Requesting user email')\nusername = self._request_email(google_creds)\nlogger.debug(f'User email retrieved: {username}')\nassert google_creds.token", "successors": [{"id": 14, "label": "#14\nassert google_creds.refresh_token", "successors": [{"id": 16, "label": "#16\nassert google_creds.expiry", "successors": [{"id": 18, "label": "#18\nassert granted_scopes", "successors": [{"id": 20, "label": "#20\ncredentials = OAuth2Credentials(provider=self.PROVIDER_NAME, title=None,\n    username=username, access_token=SecretStr(google_creds.token),\n    refresh_token=SecretStr(google_creds.refresh_token),\n    access_token_expires_at=int(google_creds.expiry.timestamp()) if\n    google_creds.expiry else None, refresh_token_expires_at=None, scopes=\n    granted_scopes)\nlogger.debug(\n    f'OAuth2Credentials object created successfully with scopes: {credentials.scopes}'\n    )\nreturn credentials", "successors": []}]}]}]}]}], "functions": [], "classes": []}, {"name": "revoke_tokens", "type": "CFG", "blocks": [{"id": 24, "label": "#24\nsession = AuthorizedSession(credentials)\nsession.post(self.revoke_uri, params={'token': credentials.access_token.\n    get_secret_value()}, headers={'content-type':\n    'application/x-www-form-urlencoded'})\nreturn True", "successors": []}], "functions": [], "classes": []}, {"name": "_request_email", "type": "CFG", "blocks": [{"id": 28, "label": "#28\nsession = AuthorizedSession(creds)\nresponse = session.get(self.EMAIL_ENDPOINT)\nif not response.ok:", "successors": [{"id": 29, "label": "#29\nlogger.error(f'Failed to get user email. Status code: {response.status_code}')\nreturn None", "successors": []}, {"id": 30, "label": "#30\nreturn response.json()['email']", "successors": []}]}], "functions": [], "classes": []}, {"name": "_refresh_tokens", "type": "CFG", "blocks": [{"id": 35, "label": "#35\nassert credentials.refresh_token", "successors": [{"id": 37, "label": "#37\ngoogle_creds = Credentials(token=credentials.access_token.get_secret_value(\n    ), refresh_token=credentials.refresh_token.get_secret_value(),\n    token_uri=self.token_uri, client_id=self.client_id, client_secret=self.\n    client_secret, scopes=credentials.scopes)\nassert google_creds.refresh_token", "successors": [{"id": 39, "label": "#39\nassert google_creds.scopes", "successors": [{"id": 41, "label": "#41\ngoogle_creds.refresh(Request())\nassert google_creds.expiry", "successors": [{"id": 43, "label": "#43\nreturn OAuth2Credentials(provider=self.PROVIDER_NAME, id=credentials.id,\n    title=credentials.title, username=credentials.username, access_token=\n    SecretStr(google_creds.token), refresh_token=SecretStr(google_creds.\n    refresh_token), access_token_expires_at=int(google_creds.expiry.\n    timestamp()), refresh_token_expires_at=None, scopes=google_creds.scopes)", "successors": []}]}]}]}]}], "functions": [], "classes": []}, {"name": "_setup_oauth_flow", "type": "CFG", "blocks": [{"id": 47, "label": "#47\nreturn Flow.from_client_config({'web': {'client_id': self.client_id,\n    'client_secret': self.client_secret, 'auth_uri':\n    'https://accounts.google.com/o/oauth2/auth', 'token_uri': self.\n    token_uri}}, scopes=scopes)", "successors": []}], "functions": [], "classes": []}], "classes": []}]}
{"file_name": "75.json", "name": "75.json", "type": "CFG", "blocks": [{"id": 1, "label": "#1\n{'name': 'example_script', 'type': 'CFG', 'start_line': 1, 'end_line': 36,\n    'functions': [{'name': 'test_remove_color_codes', 'type': 'function',\n    'start_line': 35, 'end_line': 36, 'functions': [], 'classes': [],\n    'simplified_code':\n    \"\"\"def test_remove_color_codes(raw_text, clean_text):\n    assert remove_color_codes(raw_text) == clean_text\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    'def test_remove_color_codes(raw_text, clean_text):', 'successors': [2]\n    }, {'id': 2, 'label':\n    'assert remove_color_codes(raw_text) == clean_text', 'successors': []}]\n    }], 'classes': [], 'simplified_code':\n    \"\"\"import pytest\n\nfrom .utils import remove_color_codes\n\n\n@pytest.mark.parametrize(\n    \"raw_text, clean_text\",\n    [\n        (\n            \"COMMAND = \\\\x1b[36mbrowse_website\\\\x1b[0m  \"\n            \"ARGUMENTS = \\\\x1b[36m{'url': 'https://www.google.com',\"\n            \" 'question': 'What is the capital of France?'}\\\\x1b[0m\",\n            \"COMMAND = browse_website  \"\n            \"ARGUMENTS = {'url': 'https://www.google.com',\"\n            \" 'question': 'What is the capital of France?'}\",\n        ),\n        (\n            \"{'Schaue dir meine Projekte auf github () an, als auch meine Webseiten': \"\n            \"'https://github.com/Significant-Gravitas/AutoGPT,\"\n            \" https://discord.gg/autogpt und https://twitter.com/Auto_GPT'}\",\n            \"{'Schaue dir meine Projekte auf github () an, als auch meine Webseiten': \"\n            \"'https://github.com/Significant-Gravitas/AutoGPT,\"\n            \" https://discord.gg/autogpt und https://twitter.com/Auto_GPT'}\",\n        ),\n        (\"\", \"\"),\n        (\"hello\", \"hello\"),\n        (\"hello\\\\x1b[31m world\", \"hello world\"),\n        (\"\\\\x1b[36mHello,\\\\x1b[32m World!\", \"Hello, World!\"),\n        (\n            \"\\\\x1b[1m\\\\x1b[31mError:\\\\x1b[0m\\\\x1b[31m file not found\",\n            \"Error: file not found\",\n        ),\n    ],\n)\n    assert remove_color_codes(raw_text) == clean_text\"\"\"\n    , 'blocks': [{'id': 1, 'label': 'import pytest', 'successors': [2]}, {\n    'id': 2, 'label': 'from .utils import remove_color_codes', 'successors':\n    [3]}, {'id': 3, 'label':\n    \"\"\"@pytest.mark.parametrize(\n    \"raw_text, clean_text\",\n    [\n        (\n            \"COMMAND = \\\\x1b[36mbrowse_website\\\\x1b[0m  \"\n            \"ARGUMENTS = \\\\x1b[36m{'url': 'https://www.google.com',\"\n            \" 'question': 'What is the capital of France?'}\\\\x1b[0m\",\n            \"COMMAND = browse_website  \"\n            \"ARGUMENTS = {'url': 'https://www.google.com',\"\n            \" 'question': 'What is the capital of France?'}\",\n        ),\n        (\n            \"{'Schaue dir meine Projekte auf github () an, als auch meine Webseiten': \"\n            \"'https://github.com/Significant-Gravitas/AutoGPT,\"\n            \" https://discord.gg/autogpt und https://twitter.com/Auto_GPT'}\",\n            \"{'Schaue dir meine Projekte auf github () an, als auch meine Webseiten': \"\n            \"'https://github.com/Significant-Gravitas/AutoGPT,\"\n            \" https://discord.gg/autogpt und https://twitter.com/Auto_GPT'}\",\n        ),\n        (\"\", \"\"),\n        (\"hello\", \"hello\"),\n        (\"hello\\\\x1b[31m world\", \"hello world\"),\n        (\"\\\\x1b[36mHello,\\\\x1b[32m World!\", \"Hello, World!\"),\n        (\n            \"\\\\x1b[1m\\\\x1b[31mError:\\\\x1b[0m\\\\x1b[31m file not found\",\n            \"Error: file not found\",\n        ),\n    ],\n)\"\"\"\n    , 'successors': [4]}, {'id': 4, 'label':\n    'assert remove_color_codes(raw_text) == clean_text', 'successors': []}]}", "successors": []}], "functions": [], "classes": []}
{"file_name": "76.json", "name": "76.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom enum import Enum", "successors": []}], "functions": [], "classes": [{"name": "ProviderName", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nANTHROPIC = 'anthropic'\nCOMPASS = 'compass'\nDISCORD = 'discord'\nD_ID = 'd_id'\nE2B = 'e2b'\nEXA = 'exa'\nFAL = 'fal'\nGITHUB = 'github'\nGOOGLE = 'google'\nGOOGLE_MAPS = 'google_maps'\nGROQ = 'groq'\nHUBSPOT = 'hubspot'\nIDEOGRAM = 'ideogram'\nJINA = 'jina'\nMEDIUM = 'medium'\nNOTION = 'notion'\nOLLAMA = 'ollama'\nOPENAI = 'openai'\nOPENWEATHERMAP = 'openweathermap'\nOPEN_ROUTER = 'open_router'\nPINECONE = 'pinecone'\nREPLICATE = 'replicate'\nREVID = 'revid'\nSLANT3D = 'slant3d'\nUNREAL_SPEECH = 'unreal_speech'", "successors": []}], "functions": [], "classes": []}]}
{"file_name": "77.json", "name": "77.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom math import cos, sin, sqrt, tau\nfrom audio_filters.iir_filter import IIRFilter\n\"\"\"\nCreate 2nd-order IIR filters with Butterworth design.\n\nCode based on https://webaudio.github.io/Audio-EQ-Cookbook/audio-eq-cookbook.html\nAlternatively you can use scipy.signal.butter, which should yield the same results.\n\"\"\"", "successors": []}], "functions": [{"name": "make_lowpass", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"\n    Creates a low-pass filter\n\n    >>> filter = make_lowpass(1000, 48000)\n    >>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE\n    [1.0922959556412573, -1.9828897227476208, 0.9077040443587427, 0.004277569313094809,\n     0.008555138626189618, 0.004277569313094809]\n    \"\"\"\nw0 = tau * frequency / samplerate\n_sin = sin(w0)\n_cos = cos(w0)\nalpha = _sin / (2 * q_factor)\nb0 = (1 - _cos) / 2\nb1 = 1 - _cos\na0 = 1 + alpha\na1 = -2 * _cos\na2 = 1 - alpha\nfilt = IIRFilter(2)\nfilt.set_coefficients([a0, a1, a2], [b0, b1, b0])\nreturn filt", "successors": []}], "functions": [], "classes": []}, {"name": "make_highpass", "type": "CFG", "blocks": [{"id": 7, "label": "#7\n\"\"\"\n    Creates a high-pass filter\n\n    >>> filter = make_highpass(1000, 48000)\n    >>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE\n    [1.0922959556412573, -1.9828897227476208, 0.9077040443587427, 0.9957224306869052,\n     -1.9914448613738105, 0.9957224306869052]\n    \"\"\"\nw0 = tau * frequency / samplerate\n_sin = sin(w0)\n_cos = cos(w0)\nalpha = _sin / (2 * q_factor)\nb0 = (1 + _cos) / 2\nb1 = -1 - _cos\na0 = 1 + alpha\na1 = -2 * _cos\na2 = 1 - alpha\nfilt = IIRFilter(2)\nfilt.set_coefficients([a0, a1, a2], [b0, b1, b0])\nreturn filt", "successors": []}], "functions": [], "classes": []}, {"name": "make_bandpass", "type": "CFG", "blocks": [{"id": 11, "label": "#11\n\"\"\"\n    Creates a band-pass filter\n\n    >>> filter = make_bandpass(1000, 48000)\n    >>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE\n    [1.0922959556412573, -1.9828897227476208, 0.9077040443587427, 0.06526309611002579,\n     0, -0.06526309611002579]\n    \"\"\"\nw0 = tau * frequency / samplerate\n_sin = sin(w0)\n_cos = cos(w0)\nalpha = _sin / (2 * q_factor)\nb0 = _sin / 2\nb1 = 0\nb2 = -b0\na0 = 1 + alpha\na1 = -2 * _cos\na2 = 1 - alpha\nfilt = IIRFilter(2)\nfilt.set_coefficients([a0, a1, a2], [b0, b1, b2])\nreturn filt", "successors": []}], "functions": [], "classes": []}, {"name": "make_allpass", "type": "CFG", "blocks": [{"id": 15, "label": "#15\n\"\"\"\n    Creates an all-pass filter\n\n    >>> filter = make_allpass(1000, 48000)\n    >>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE\n    [1.0922959556412573, -1.9828897227476208, 0.9077040443587427, 0.9077040443587427,\n     -1.9828897227476208, 1.0922959556412573]\n    \"\"\"\nw0 = tau * frequency / samplerate\n_sin = sin(w0)\n_cos = cos(w0)\nalpha = _sin / (2 * q_factor)\nb0 = 1 - alpha\nb1 = -2 * _cos\nb2 = 1 + alpha\nfilt = IIRFilter(2)\nfilt.set_coefficients([b2, b1, b0], [b0, b1, b2])\nreturn filt", "successors": []}], "functions": [], "classes": []}, {"name": "make_peak", "type": "CFG", "blocks": [{"id": 19, "label": "#19\n\"\"\"\n    Creates a peak filter\n\n    >>> filter = make_peak(1000, 48000, 6)\n    >>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE\n    [1.0653405327119334, -1.9828897227476208, 0.9346594672880666, 1.1303715025601122,\n     -1.9828897227476208, 0.8696284974398878]\n    \"\"\"\nw0 = tau * frequency / samplerate\n_sin = sin(w0)\n_cos = cos(w0)\nalpha = _sin / (2 * q_factor)\nbig_a = 10 ** (gain_db / 40)\nb0 = 1 + alpha * big_a\nb1 = -2 * _cos\nb2 = 1 - alpha * big_a\na0 = 1 + alpha / big_a\na1 = -2 * _cos\na2 = 1 - alpha / big_a\nfilt = IIRFilter(2)\nfilt.set_coefficients([a0, a1, a2], [b0, b1, b2])\nreturn filt", "successors": []}], "functions": [], "classes": []}, {"name": "make_lowshelf", "type": "CFG", "blocks": [{"id": 23, "label": "#23\n\"\"\"\n    Creates a low-shelf filter\n\n    >>> filter = make_lowshelf(1000, 48000, 6)\n    >>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE\n    [3.0409336710888786, -5.608870992220748, 2.602157875636628, 3.139954022810743,\n     -5.591841778072785, 2.5201667380627257]\n    \"\"\"\nw0 = tau * frequency / samplerate\n_sin = sin(w0)\n_cos = cos(w0)\nalpha = _sin / (2 * q_factor)\nbig_a = 10 ** (gain_db / 40)\npmc = big_a + 1 - (big_a - 1) * _cos\nppmc = big_a + 1 + (big_a - 1) * _cos\nmpc = big_a - 1 - (big_a + 1) * _cos\npmpc = big_a - 1 + (big_a + 1) * _cos\naa2 = 2 * sqrt(big_a) * alpha\nb0 = big_a * (pmc + aa2)\nb1 = 2 * big_a * mpc\nb2 = big_a * (pmc - aa2)\na0 = ppmc + aa2\na1 = -2 * pmpc\na2 = ppmc - aa2\nfilt = IIRFilter(2)\nfilt.set_coefficients([a0, a1, a2], [b0, b1, b2])\nreturn filt", "successors": []}], "functions": [], "classes": []}, {"name": "make_highshelf", "type": "CFG", "blocks": [{"id": 27, "label": "#27\n\"\"\"\n    Creates a high-shelf filter\n\n    >>> filter = make_highshelf(1000, 48000, 6)\n    >>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE\n    [2.2229172136088806, -3.9587208137297303, 1.7841414181566304, 4.295432981120543,\n     -7.922740859457287, 3.6756456963725253]\n    \"\"\"\nw0 = tau * frequency / samplerate\n_sin = sin(w0)\n_cos = cos(w0)\nalpha = _sin / (2 * q_factor)\nbig_a = 10 ** (gain_db / 40)\npmc = big_a + 1 - (big_a - 1) * _cos\nppmc = big_a + 1 + (big_a - 1) * _cos\nmpc = big_a - 1 - (big_a + 1) * _cos\npmpc = big_a - 1 + (big_a + 1) * _cos\naa2 = 2 * sqrt(big_a) * alpha\nb0 = big_a * (ppmc + aa2)\nb1 = -2 * big_a * pmpc\nb2 = big_a * (ppmc - aa2)\na0 = pmc + aa2\na1 = 2 * mpc\na2 = pmc - aa2\nfilt = IIRFilter(2)\nfilt.set_coefficients([a0, a1, a2], [b0, b1, b2])\nreturn filt", "successors": []}], "functions": [], "classes": []}], "classes": []}
{"file_name": "78.json", "name": "78.json", "type": "CFG", "blocks": [{"id": 1, "label": "#1\n{'name': 'example_script', 'type': 'CFG', 'start_line': 1, 'end_line': 27,\n    'functions': [{'name': 'get_frontend_path', 'type': 'function',\n    'start_line': 6, 'end_line': 15, 'functions': [], 'classes': [],\n    'simplified_code':\n    \"\"\"def get_frontend_path() -> pathlib.Path:\n    if getattr(sys, \"frozen\", False):\n        # The application is frozen\n        datadir = pathlib.Path(os.path.dirname(sys.executable)) / \"example_files\"\n    else:\n        # The application is not frozen\n        # Change this bit to match where you store your data files:\n        filedir = os.path.dirname(__file__)\n        datadir = pathlib.Path(filedir).parent.parent.parent / \"example_files\"\n    return pathlib.Path(datadir)\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    'def get_frontend_path() -> pathlib.Path:', 'successors': [2]}, {'id': \n    2, 'label': 'if getattr(sys, \"frozen\", False):', 'successors': [3, 4]},\n    {'id': 3, 'label':\n    'datadir = pathlib.Path(os.path.dirname(sys.executable)) / \"example_files\"'\n    , 'successors': [5]}, {'id': 4, 'label':\n    \"\"\"filedir = os.path.dirname(__file__)\ndatadir = pathlib.Path(filedir).parent.parent.parent / \"example_files\\\"\"\"\"\n    , 'successors': [5]}, {'id': 5, 'label': 'return pathlib.Path(datadir)',\n    'successors': []}]}, {'name': 'get_data_path', 'type': 'function',\n    'start_line': 18, 'end_line': 27, 'functions': [], 'classes': [],\n    'simplified_code':\n    \"\"\"def get_data_path() -> pathlib.Path:\n    if getattr(sys, \"frozen\", False):\n        # The application is frozen\n        datadir = os.path.dirname(sys.executable)\n    else:\n        # The application is not frozen\n        # Change this bit to match where you store your data files:\n        filedir = os.path.dirname(__file__)\n        datadir = pathlib.Path(filedir).parent.parent\n    return pathlib.Path(datadir)\"\"\"\n    , 'blocks': [{'id': 1, 'label': 'def get_data_path() -> pathlib.Path:',\n    'successors': [2]}, {'id': 2, 'label':\n    'if getattr(sys, \"frozen\", False):', 'successors': [3, 4]}, {'id': 3,\n    'label':\n    \"\"\"# The application is frozen\n        datadir = os.path.dirname(sys.executable)\"\"\"\n    , 'successors': [5]}, {'id': 4, 'label':\n    \"\"\"# The application is not frozen\n        # Change this bit to match where you store your data files:\n        filedir = os.path.dirname(__file__)\n        datadir = pathlib.Path(filedir).parent.parent\"\"\"\n    , 'successors': [5]}, {'id': 5, 'label': 'return pathlib.Path(datadir)',\n    'successors': []}]}], 'classes': [], 'simplified_code':\n    \"\"\"import os\nimport pathlib\nimport sys\n\n\n    return pathlib.Path(datadir)\n\n\n    return pathlib.Path(datadir)\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"import os\nimport pathlib\nimport sys\n\n\n    return pathlib.Path(datadir)\n\n\n    return pathlib.Path(datadir)\"\"\"\n    , 'successors': []}]}", "successors": []}], "functions": [], "classes": []}
{"file_name": "79.json", "name": "79.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nif __name__ == '__main__':", "successors": [{"id": 9, "label": "#9\nimport doctest\ndoctest.testmod()", "successors": []}]}], "functions": [{"name": "binary_and", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"\n    Take in 2 integers, convert them to binary,\n    return a binary number that is the\n    result of a binary and operation on the integers provided.\n\n    >>> binary_and(25, 32)\n    '0b000000'\n    >>> binary_and(37, 50)\n    '0b100000'\n    >>> binary_and(21, 30)\n    '0b10100'\n    >>> binary_and(58, 73)\n    '0b0001000'\n    >>> binary_and(0, 255)\n    '0b00000000'\n    >>> binary_and(256, 256)\n    '0b100000000'\n    >>> binary_and(0, -1)\n    Traceback (most recent call last):\n    ValueError: the value of both inputs must be positive\n    >>> binary_and(0, 1.1)\n    Traceback (most recent call last):\n    ValueError: Unknown format code 'b' for object of type 'float'\n    >>> binary_and(\"0\", \"1\")\n    Traceback (most recent call last):\n    TypeError: '<' not supported between instances of 'str' and 'int'\n    \"\"\"\nif a < 0 or b < 0:", "successors": [{"id": 4, "label": "#4\nraise ValueError('the value of both inputs must be positive')", "successors": []}, {"id": 5, "label": "#5\na_binary = format(a, 'b')\nb_binary = format(b, 'b')\nmax_len = max(len(a_binary), len(b_binary))\nreturn '0b' + ''.join(str(int(char_a == '1' and char_b == '1')) for char_a,\n    char_b in zip(a_binary.zfill(max_len), b_binary.zfill(max_len)))", "successors": []}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "80.json", "name": "80.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport logging", "successors": []}], "functions": [], "classes": [{"name": "BelowLevelFilter", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"Filter for logging levels below a certain threshold.\"\"\"", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 5, "label": "#5\nsuper().__init__()\nself.below_level = below_level", "successors": []}], "functions": [], "classes": []}, {"name": "filter", "type": "CFG", "blocks": [{"id": 8, "label": "#8\nreturn record.levelno < self.below_level", "successors": []}], "functions": [], "classes": []}], "classes": []}]}
{"file_name": "81.json", "name": "81.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport pytest\nfrom backend.util.service import AppService, expose, get_service_client\nTEST_SERVICE_PORT = 8765", "successors": []}], "functions": [{"name": "test_service_creation", "type": "CFG", "blocks": [{"id": 29, "label": "#29\nwith ServiceTest():", "successors": [{"id": 30, "label": "#30\nclient = get_service_client(ServiceTest)\nassert client.add(5, 3) == 8", "successors": [{"id": 33, "label": "#33\nassert client.subtract(10, 4) == 6", "successors": [{"id": 35, "label": "#35\nassert client.fun_with_async(5, 3) == 8", "successors": []}]}]}]}], "functions": [], "classes": []}], "classes": [{"name": "ServiceTest", "type": "CFG", "blocks": [{"id": 3, "label": "#3", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 5, "label": "#5\nsuper().__init__()", "successors": []}], "functions": [], "classes": []}, {"name": "get_port", "type": "CFG", "blocks": [{"id": 8, "label": "#8\nreturn TEST_SERVICE_PORT", "successors": []}], "functions": [], "classes": []}, {"name": "add", "type": "CFG", "blocks": [{"id": 12, "label": "#12\nreturn a + b", "successors": []}], "functions": [], "classes": []}, {"name": "subtract", "type": "CFG", "blocks": [{"id": 16, "label": "#16\nreturn a - b", "successors": []}], "functions": [], "classes": []}, {"name": "fun_with_async", "type": "CFG", "blocks": [{"id": 20, "label": "#20\nreturn self.run_and_wait(add_async(a, b))", "successors": []}], "functions": [{"name": "add_async", "type": "CFG", "blocks": [{"id": 22, "label": "#22\nreturn a + b", "successors": []}], "functions": [], "classes": []}], "classes": []}], "classes": []}]}
{"file_name": "82.json", "name": "82.json", "type": "CFG", "blocks": [{"id": 1, "label": "#1\n{'name': 'example_script', 'type': 'CFG', 'start_line': 1, 'end_line': 94,\n    'functions': [{'name': 'gray_code', 'type': 'function', 'start_line': 1,\n    'end_line': 47, 'functions': [], 'classes': [], 'simplified_code':\n    \"\"\"def gray_code(bit_count: int) -> list:\n    \"\"\\\"\n    Takes in an integer n and returns a n-bit\n    gray code sequence\n    An n-bit gray code sequence is a sequence of 2^n\n    integers where:\n\n    a) Every integer is between [0,2^n -1] inclusive\n    b) The sequence begins with 0\n    c) An integer appears at most one times in the sequence\n    d)The binary representation of every pair of integers differ\n       by exactly one bit\n    e) The binary representation of first and last bit also\n       differ by exactly one bit\n\n    >>> gray_code(2)\n    [0, 1, 3, 2]\n\n    >>> gray_code(1)\n    [0, 1]\n\n    >>> gray_code(3)\n    [0, 1, 3, 2, 6, 7, 5, 4]\n\n    >>> gray_code(-1)\n    Traceback (most recent call last):\n    ValueError: The given input must be positive\n\n    >>> gray_code(10.6)\n    Traceback (most recent call last):\n    TypeError: unsupported operand type(s) for <<: 'int' and 'float'\n    \"\"\\\"\n\n    # bit count represents no. of bits in the gray code\n    if bit_count < 0:\n        raise ValueError(\"The given input must be positive\")\n\n    # get the generated string sequence\n    sequence = gray_code_sequence_string(bit_count)\n    #\n    # convert them to integers\n    for i in range(len(sequence)):\n        sequence[i] = int(sequence[i], 2)\n\n    return sequence\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"def gray_code(bit_count: int) -> list:\n    \"\"\\\"\n    Takes in an integer n and returns a n-bit\n    gray code sequence\n    An n-bit gray code sequence is a sequence of 2^n\n    integers where:\n\n    a) Every integer is between [0,2^n -1] inclusive\n    b) The sequence begins with 0\n    c) An integer appears at most one times in the sequence\n    d)The binary representation of every pair of integers differ\n       by exactly one bit\n    e) The binary representation of first and last bit also\n       differ by exactly one bit\n\n    >>> gray_code(2)\n    [0, 1, 3, 2]\n\n    >>> gray_code(1)\n    [0, 1]\n\n    >>> gray_code(3)\n    [0, 1, 3, 2, 6, 7, 5, 4]\n\n    >>> gray_code(-1)\n    Traceback (most recent call last):\n    ValueError: The given input must be positive\n\n    >>> gray_code(10.6)\n    Traceback (most recent call last):\n    TypeError: unsupported operand type(s) for <<: 'int' and 'float'\n    \"\"\\\"\n\n    # bit count represents no. of bits in the gray code\"\"\"\n    , 'successors': [2]}, {'id': 2, 'label':\n    \"\"\"if bit_count < 0:\n        raise ValueError(\"The given input must be positive\")\"\"\"\n    , 'successors': [3, 4]}, {'id': 3, 'label':\n    'raise ValueError(\"The given input must be positive\")', 'successors': [\n    ]}, {'id': 4, 'label':\n    'sequence = gray_code_sequence_string(bit_count)', 'successors': [5]},\n    {'id': 5, 'label':\n    \"\"\"for i in range(len(sequence)):\n        sequence[i] = int(sequence[i], 2)\"\"\"\n    , 'successors': [6]}, {'id': 6, 'label': 'return sequence',\n    'successors': []}]}, {'name': 'gray_code_sequence_string', 'type':\n    'function', 'start_line': 50, 'end_line': 88, 'functions': [],\n    'classes': [], 'simplified_code':\n    \"\"\"def gray_code_sequence_string(bit_count: int) -> list:\n    \"\"\\\"\n    Will output the n-bit grey sequence as a\n    string of bits\n\n    >>> gray_code_sequence_string(2)\n    ['00', '01', '11', '10']\n\n    >>> gray_code_sequence_string(1)\n    ['0', '1']\n    \"\"\\\"\n\n    # The approach is a recursive one\n    # Base case achieved when either n = 0 or n=1\n    if bit_count == 0:\n        return [\"0\"]\n\n    if bit_count == 1:\n        return [\"0\", \"1\"]\n\n    seq_len = 1 << bit_count  # defines the length of the sequence\n    # 1<< n is equivalent to 2^n\n\n    # recursive answer will generate answer for n-1 bits\n    smaller_sequence = gray_code_sequence_string(bit_count - 1)\n\n    sequence = []\n\n    # append 0 to first half of the smaller sequence generated\n    for i in range(seq_len // 2):\n        generated_no = \"0\" + smaller_sequence[i]\n        sequence.append(generated_no)\n\n    for i in reversed(range(seq_len // 2)):\n        generated_no = \"1\" + smaller_sequence[i]\n        sequence.append(generated_no)\n\n    return sequence\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    'def gray_code_sequence_string(bit_count: int) -> list:', 'successors':\n    [2]}, {'id': 2, 'label': 'if bit_count == 0:', 'successors': [3, 4]}, {\n    'id': 3, 'label': 'return [\"0\"]', 'successors': []}, {'id': 4, 'label':\n    'if bit_count == 1:', 'successors': [5, 6]}, {'id': 5, 'label':\n    'return [\"0\", \"1\"]', 'successors': []}, {'id': 6, 'label':\n    'seq_len = 1 << bit_count', 'successors': [7]}, {'id': 7, 'label':\n    'smaller_sequence = gray_code_sequence_string(bit_count - 1)',\n    'successors': [8]}, {'id': 8, 'label': 'sequence = []', 'successors': [\n    9]}, {'id': 9, 'label': 'for i in range(seq_len // 2):', 'successors':\n    [10, 12]}, {'id': 10, 'label':\n    'generated_no = \"0\" + smaller_sequence[i]', 'successors': [11]}, {'id':\n    11, 'label': 'sequence.append(generated_no)', 'successors': [9]}, {'id':\n    12, 'label': 'for i in reversed(range(seq_len // 2)):', 'successors': [\n    13, 15]}, {'id': 13, 'label':\n    'generated_no = \"1\" + smaller_sequence[i]', 'successors': [14]}, {'id':\n    14, 'label': 'sequence.append(generated_no)', 'successors': [12]}, {\n    'id': 15, 'label': 'return sequence', 'successors': []}]}], 'classes':\n    [], 'simplified_code':\n    \"\"\"    return sequence\n\n\n    return sequence\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\"\"\"\n    , 'blocks': [{'id': 1, 'label': 'return sequence', 'successors': []}, {\n    'id': 2, 'label': 'return sequence', 'successors': []}, {'id': 3,\n    'label': 'if __name__ == \"__main__\":', 'successors': [4]}, {'id': 4,\n    'label': 'import doctest', 'successors': [5]}, {'id': 5, 'label':\n    'doctest.testmod()', 'successors': []}]}", "successors": []}], "functions": [], "classes": []}
{"file_name": "83.json", "name": "83.json", "type": "CFG", "blocks": [{"id": 1, "label": "#1\n{'name': 'example_script', 'type': 'CFG', 'start_line': 1, 'end_line': 22,\n    'functions': [], 'classes': [{'name': 'User', 'type': 'class',\n    'start_line': 9, 'end_line': 22, 'functions': [{'name': 'from_payload',\n    'type': 'function', 'start_line': 16, 'end_line': 22, 'functions': [],\n    'classes': [], 'simplified_code':\n    \"\"\"    def from_payload(cls, payload):\n        return cls(\n            user_id=payload[\"sub\"],\n            email=payload.get(\"email\", \"\"),\n            phone_number=payload.get(\"phone\", \"\"),\n            role=payload[\"role\"],\n        )\"\"\"\n    , 'blocks': [{'id': 1, 'label': 'def from_payload(cls, payload):',\n    'successors': [2]}, {'id': 2, 'label':\n    \"\"\"return cls(\n    user_id=payload[\"sub\"],\n    email=payload.get(\"email\", \"\"),\n    phone_number=payload.get(\"phone\", \"\"),\n    role=payload[\"role\"],\n)\"\"\"\n    , 'successors': []}]}], 'simplified_code':\n    \"\"\"class User:\n    user_id: str\n    email: str\n    phone_number: str\n    role: str\n\n    @classmethod\n        )\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"class User:\n    user_id: str\n    email: str\n    phone_number: str\n    role: str\"\"\"\n    , 'successors': [2]}, {'id': 2, 'label': '@classmethod', 'successors':\n    []}]}], 'simplified_code':\n    \"\"\"from dataclasses import dataclass\n\nDEFAULT_USER_ID = \"3e53486c-cf57-477e-ba2a-cb02dc828e1a\"\nDEFAULT_EMAIL = \"default@example.com\"\n\n\n# Using dataclass here to avoid adding dependency on pydantic\n@dataclass(frozen=True)\n        )\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"from dataclasses import dataclass\n\nDEFAULT_USER_ID = \"3e53486c-cf57-477e-ba2a-cb02dc828e1a\"\nDEFAULT_EMAIL = \"default@example.com\"\n\n\n# Using dataclass here to avoid adding dependency on pydantic\n@dataclass(frozen=True)\n\"\"\"\n    , 'successors': []}]}", "successors": []}], "functions": [], "classes": []}
{"file_name": "84.json", "name": "84.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom datetime import datetime, timezone\nfrom unittest.mock import AsyncMock\nimport pytest\nfrom fastapi import WebSocket\nfrom backend.data.execution import ExecutionResult, ExecutionStatus\nfrom backend.server.conn_manager import ConnectionManager\nfrom backend.server.model import Methods, WsMessage", "successors": []}], "functions": [{"name": "connection_manager", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nreturn ConnectionManager()", "successors": []}], "functions": [], "classes": []}, {"name": "mock_websocket", "type": "CFG", "blocks": [{"id": 7, "label": "#7\nwebsocket: AsyncMock = AsyncMock(spec=WebSocket)\nwebsocket.send_text = AsyncMock()\nreturn websocket", "successors": []}], "functions": [], "classes": []}, {"name": "test_connect", "type": "CFG", "blocks": [{"id": 11, "label": "#11\nawait connection_manager.connect(mock_websocket)", "successors": [{"id": 12, "label": "#12\nassert mock_websocket in connection_manager.active_connections", "successors": [{"id": 14, "label": "#14\nmock_websocket.accept.assert_called_once()", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "test_disconnect", "type": "CFG", "blocks": [{"id": 17, "label": "#17\nconnection_manager.active_connections.add(mock_websocket)\nconnection_manager.subscriptions['test_graph'] = {mock_websocket}\nconnection_manager.disconnect(mock_websocket)\nassert mock_websocket not in connection_manager.active_connections", "successors": [{"id": 19, "label": "#19\nassert mock_websocket not in connection_manager.subscriptions['test_graph']", "successors": []}]}], "functions": [], "classes": []}, {"name": "test_subscribe", "type": "CFG", "blocks": [{"id": 24, "label": "#24\nawait connection_manager.subscribe('test_graph', mock_websocket)", "successors": [{"id": 25, "label": "#25\nassert mock_websocket in connection_manager.subscriptions['test_graph']", "successors": []}]}], "functions": [], "classes": []}, {"name": "test_unsubscribe", "type": "CFG", "blocks": [{"id": 30, "label": "#30\nconnection_manager.subscriptions['test_graph'] = {mock_websocket}\nawait connection_manager.unsubscribe('test_graph', mock_websocket)", "successors": [{"id": 31, "label": "#31\nassert 'test_graph' not in connection_manager.subscriptions", "successors": []}]}], "functions": [], "classes": []}, {"name": "test_send_execution_result", "type": "CFG", "blocks": [{"id": 36, "label": "#36\nconnection_manager.subscriptions['test_graph'] = {mock_websocket}\nresult: ExecutionResult = ExecutionResult(graph_id='test_graph',\n    graph_version=1, graph_exec_id='test_exec_id', node_exec_id=\n    'test_node_exec_id', node_id='test_node_id', block_id='test_block_id',\n    status=ExecutionStatus.COMPLETED, input_data={'input1': 'value1'},\n    output_data={'output1': ['result1']}, add_time=datetime.now(tz=timezone\n    .utc), queue_time=None, start_time=datetime.now(tz=timezone.utc),\n    end_time=datetime.now(tz=timezone.utc))\nawait connection_manager.send_execution_result(result)", "successors": [{"id": 37, "label": "#37\nmock_websocket.send_text.assert_called_once_with(WsMessage(method=Methods.\n    EXECUTION_EVENT, channel='test_graph', data=result.model_dump()).\n    model_dump_json())", "successors": []}]}], "functions": [], "classes": []}, {"name": "test_send_execution_result_no_subscribers", "type": "CFG", "blocks": [{"id": 40, "label": "#40\nresult: ExecutionResult = ExecutionResult(graph_id='test_graph',\n    graph_version=1, graph_exec_id='test_exec_id', node_exec_id=\n    'test_node_exec_id', node_id='test_node_id', block_id='test_block_id',\n    status=ExecutionStatus.COMPLETED, input_data={'input1': 'value1'},\n    output_data={'output1': ['result1']}, add_time=datetime.now(),\n    queue_time=None, start_time=datetime.now(), end_time=datetime.now())\nawait connection_manager.send_execution_result(result)", "successors": [{"id": 41, "label": "#41\nmock_websocket.send_text.assert_not_called()", "successors": []}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "85.json", "name": "85.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom google.oauth2.credentials import Credentials\nfrom googleapiclient.discovery import build\nfrom backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema\nfrom backend.data.model import SchemaField\nfrom ._auth import GOOGLE_OAUTH_IS_CONFIGURED, TEST_CREDENTIALS, TEST_CREDENTIALS_INPUT, GoogleCredentials, GoogleCredentialsField, GoogleCredentialsInput", "successors": []}], "functions": [], "classes": [{"name": "GoogleSheetsReadBlock", "type": "CFG", "blocks": [{"id": 3, "label": "#3", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 11, "label": "#11\nsuper().__init__(id='5724e902-3635-47e9-a108-aaa0263a4988', description=\n    'This block reads data from a Google Sheets spreadsheet.', categories={\n    BlockCategory.DATA}, input_schema=GoogleSheetsReadBlock.Input,\n    output_schema=GoogleSheetsReadBlock.Output, disabled=not\n    GOOGLE_OAUTH_IS_CONFIGURED, test_input={'spreadsheet_id':\n    '1BxiMVs0XRA5nFMdKvBdBZjgmUUqptlbs74OgvE2upms', 'range': 'Sheet1!A1:B2',\n    'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=\n    TEST_CREDENTIALS, test_output=[('result', [['Name', 'Score'], ['Alice',\n    '85']])], test_mock={'_read_sheet': lambda *args, **kwargs: [['Name',\n    'Score'], ['Alice', '85']]})", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 14, "label": "#14\nservice = self._build_service(credentials, **kwargs)\ndata = self._read_sheet(service, input_data.spreadsheet_id, input_data.range)\nyield 'result', data", "successors": []}], "functions": [], "classes": []}, {"name": "_build_service", "type": "CFG", "blocks": [{"id": 18, "label": "#18\ncreds = Credentials(token=credentials.access_token.get_secret_value() if\n    credentials.access_token else None, refresh_token=credentials.\n    refresh_token.get_secret_value() if credentials.refresh_token else None,\n    token_uri='https://oauth2.googleapis.com/token', client_id=kwargs.get(\n    'client_id'), client_secret=kwargs.get('client_secret'), scopes=\n    credentials.scopes)\nreturn build('sheets', 'v4', credentials=creds)", "successors": []}], "functions": [], "classes": []}, {"name": "_read_sheet", "type": "CFG", "blocks": [{"id": 22, "label": "#22\nsheet = service.spreadsheets()\nresult = sheet.values().get(spreadsheetId=spreadsheet_id, range=range).execute(\n    )\nreturn result.get('values', [])", "successors": []}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 5, "label": "#5\ncredentials: GoogleCredentialsInput = GoogleCredentialsField([\n    'https://www.googleapis.com/auth/spreadsheets.readonly'])\nspreadsheet_id: str = SchemaField(description=\n    'The ID of the spreadsheet to read from')\nrange: str = SchemaField(description='The A1 notation of the range to read')", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 8, "label": "#8\nresult: list[list[str]] = SchemaField(description=\n    'The data read from the spreadsheet')\nerror: str = SchemaField(description='Error message if any')", "successors": []}], "functions": [], "classes": []}]}, {"name": "GoogleSheetsWriteBlock", "type": "CFG", "blocks": [{"id": 27, "label": "#27", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 35, "label": "#35\nsuper().__init__(id='d9291e87-301d-47a8-91fe-907fb55460e5', description=\n    'This block writes data to a Google Sheets spreadsheet.', categories={\n    BlockCategory.DATA}, input_schema=GoogleSheetsWriteBlock.Input,\n    output_schema=GoogleSheetsWriteBlock.Output, disabled=not\n    GOOGLE_OAUTH_IS_CONFIGURED, test_input={'spreadsheet_id':\n    '1BxiMVs0XRA5nFMdKvBdBZjgmUUqptlbs74OgvE2upms', 'range': 'Sheet1!A1:B2',\n    'values': [['Name', 'Score'], ['Bob', '90']], 'credentials':\n    TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output\n    =[('result', {'updatedCells': 4, 'updatedColumns': 2, 'updatedRows': 2}\n    )], test_mock={'_write_sheet': lambda *args, **kwargs: {'updatedCells':\n    4, 'updatedColumns': 2, 'updatedRows': 2}})", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 38, "label": "#38\nservice = GoogleSheetsReadBlock._build_service(credentials, **kwargs)\nresult = self._write_sheet(service, input_data.spreadsheet_id, input_data.\n    range, input_data.values)\nyield 'result', result", "successors": []}], "functions": [], "classes": []}, {"name": "_write_sheet", "type": "CFG", "blocks": [{"id": 42, "label": "#42\nbody = {'values': values}\nresult = service.spreadsheets().values().update(spreadsheetId=\n    spreadsheet_id, range=range, valueInputOption='USER_ENTERED', body=body\n    ).execute()\nreturn result", "successors": []}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 29, "label": "#29\ncredentials: GoogleCredentialsInput = GoogleCredentialsField([\n    'https://www.googleapis.com/auth/spreadsheets'])\nspreadsheet_id: str = SchemaField(description=\n    'The ID of the spreadsheet to write to')\nrange: str = SchemaField(description='The A1 notation of the range to write')\nvalues: list[list[str]] = SchemaField(description=\n    'The data to write to the spreadsheet')", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 32, "label": "#32\nresult: dict = SchemaField(description='The result of the write operation')\nerror: str = SchemaField(description='Error message if any')", "successors": []}], "functions": [], "classes": []}]}]}
{"file_name": "86.json", "name": "86.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom datetime import datetime\nimport pytest\nfrom prisma.models import CreditTransaction\nfrom backend.blocks.llm import AITextGeneratorBlock\nfrom backend.data.credit import UserCredit\nfrom backend.data.user import DEFAULT_USER_ID\nfrom backend.integrations.credentials_store import openai_credentials\nfrom backend.util.test import SpinTestServer\nREFILL_VALUE = 1000\nuser_credit = UserCredit(REFILL_VALUE)", "successors": []}], "functions": [{"name": "test_block_credit_usage", "type": "CFG", "blocks": [{"id": 3, "label": "#3\ncurrent_credit = await user_credit.get_or_refill_credit(DEFAULT_USER_ID)", "successors": [{"id": 4, "label": "#4\nspending_amount_1 = await user_credit.spend_credits(DEFAULT_USER_ID,\n    current_credit, AITextGeneratorBlock().id, {'model': 'gpt-4-turbo',\n    'credentials': {'id': openai_credentials.id, 'provider':\n    openai_credentials.provider, 'type': openai_credentials.type}}, 0.0, \n    0.0, validate_balance=False)", "successors": [{"id": 5, "label": "#5\nassert spending_amount_1 > 0", "successors": [{"id": 7, "label": "#7\nspending_amount_2 = await user_credit.spend_credits(DEFAULT_USER_ID,\n    current_credit, AITextGeneratorBlock().id, {'model': 'gpt-4-turbo',\n    'api_key': 'owned_api_key'}, 0.0, 0.0, validate_balance=False)", "successors": [{"id": 8, "label": "#8\nassert spending_amount_2 == 0", "successors": [{"id": 10, "label": "#10\nnew_credit = await user_credit.get_or_refill_credit(DEFAULT_USER_ID)", "successors": [{"id": 11, "label": "#11\nassert new_credit == current_credit - spending_amount_1 - spending_amount_2", "successors": []}]}]}]}]}]}]}], "functions": [], "classes": []}, {"name": "test_block_credit_top_up", "type": "CFG", "blocks": [{"id": 16, "label": "#16\ncurrent_credit = await user_credit.get_or_refill_credit(DEFAULT_USER_ID)", "successors": [{"id": 17, "label": "#17\nawait user_credit.top_up_credits(DEFAULT_USER_ID, 100)", "successors": [{"id": 18, "label": "#18\nnew_credit = await user_credit.get_or_refill_credit(DEFAULT_USER_ID)", "successors": [{"id": 19, "label": "#19\nassert new_credit == current_credit + 100", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "test_block_credit_reset", "type": "CFG", "blocks": [{"id": 24, "label": "#24\nmonth1 = datetime(2022, 1, 15)\nmonth2 = datetime(2022, 2, 15)\nuser_credit.time_now = lambda : month2\nmonth2credit = await user_credit.get_or_refill_credit(DEFAULT_USER_ID)", "successors": [{"id": 25, "label": "#25\nuser_credit.time_now = lambda : month1\nmonth1credit = await user_credit.get_or_refill_credit(DEFAULT_USER_ID)", "successors": [{"id": 26, "label": "#26\nawait user_credit.top_up_credits(DEFAULT_USER_ID, 100)", "successors": [{"id": 27, "label": "#27\nassert await user_credit.get_or_refill_credit(DEFAULT_USER_ID\n    ) == month1credit + 100", "successors": [{"id": 30, "label": "#30\nuser_credit.time_now = lambda : month2\nassert await user_credit.get_or_refill_credit(DEFAULT_USER_ID) == month2credit", "successors": []}]}]}]}]}], "functions": [], "classes": []}, {"name": "test_credit_refill", "type": "CFG", "blocks": [{"id": 36, "label": "#36\nawait CreditTransaction.prisma().update_many(where={'userId':\n    DEFAULT_USER_ID, 'createdAt': {'gte': datetime(2022, 2, 1), 'lt':\n    datetime(2022, 3, 1)}}, data={'isActive': False})", "successors": [{"id": 37, "label": "#37\nuser_credit.time_now = lambda : datetime(2022, 2, 15)\nbalance = await user_credit.get_or_refill_credit(DEFAULT_USER_ID)", "successors": [{"id": 38, "label": "#38\nassert balance == REFILL_VALUE", "successors": []}]}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "87.json", "name": "87.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom prisma.models import User\nfrom backend.blocks.llm import AIStructuredResponseGeneratorBlock\nfrom backend.blocks.reddit import GetRedditPostsBlock, PostRedditCommentBlock\nfrom backend.blocks.text import FillTextTemplateBlock, MatchTextPatternBlock\nfrom backend.data.graph import Graph, Link, Node, create_graph\nfrom backend.data.user import get_or_create_user\nfrom backend.util.test import SpinTestServer, wait_execution\nif __name__ == '__main__':", "successors": [{"id": 20, "label": "#20\nimport asyncio\nasyncio.run(reddit_marketing_agent())", "successors": []}]}], "functions": [{"name": "create_test_graph", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"\n                    subreddit\n                       ||\n                        v\n        GetRedditPostsBlock (post_id, post_title, post_body)\n                  //     ||     \\\\\n              post_id  post_title  post_body\n                 ||       ||        ||\n                 v        v         v\n              FillTextTemplateBlock (format)\n                      ||\n                      v\n            AIStructuredResponseBlock / TextRelevancy\n                 ||       ||       ||\n            post_id  is_relevant  marketing_text\n               ||       ||        ||\n               v        v         v\n                 MatchTextPatternBlock\n                 ||       ||\n              positive  negative\n                ||\n                v\n        PostRedditCommentBlock\n    \"\"\"\nreddit_get_post_input = {'post_limit': 3}\ntext_formatter_input = {'format':\n    \"\"\"\nBased on the following post, write your marketing comment:\n* Post ID: {id}\n* Post Subreddit: {subreddit}\n* Post Title: {title}\n* Post Body: {body}\"\"\"\n    .strip()}\nllm_call_input = {'sys_prompt':\n    \"\"\"\nYou are an expert at marketing.\nYou have been tasked with picking Reddit posts that are relevant to your product.\nThe product you are marketing is: Auto-GPT an autonomous AI agent utilizing GPT model.\nYou reply the post that you find it relevant to be replied with marketing text.\nMake sure to only comment on a relevant post.\n\"\"\"\n    , 'expected_format': {'post_id': 'str, the reddit post id',\n    'is_relevant': 'bool, whether the post is relevant for marketing',\n    'marketing_text': 'str, marketing text, this is empty on irrelevant posts'}\n    }\ntext_matcher_input = {'match': 'true', 'case_sensitive': False}\nreddit_comment_input = {}\nreddit_get_post_node = Node(block_id=GetRedditPostsBlock().id,\n    input_default=reddit_get_post_input)\ntext_formatter_node = Node(block_id=FillTextTemplateBlock().id,\n    input_default=text_formatter_input)\nllm_call_node = Node(block_id=AIStructuredResponseGeneratorBlock().id,\n    input_default=llm_call_input)\ntext_matcher_node = Node(block_id=MatchTextPatternBlock().id, input_default\n    =text_matcher_input)\nreddit_comment_node = Node(block_id=PostRedditCommentBlock().id,\n    input_default=reddit_comment_input)\nnodes = [reddit_get_post_node, text_formatter_node, llm_call_node,\n    text_matcher_node, reddit_comment_node]\nlinks = [Link(source_id=reddit_get_post_node.id, sink_id=\n    text_formatter_node.id, source_name='post', sink_name='values'), Link(\n    source_id=text_formatter_node.id, sink_id=llm_call_node.id, source_name\n    ='output', sink_name='prompt'), Link(source_id=llm_call_node.id,\n    sink_id=text_matcher_node.id, source_name='response', sink_name='data'),\n    Link(source_id=llm_call_node.id, sink_id=text_matcher_node.id,\n    source_name='response_#_is_relevant', sink_name='text'), Link(source_id\n    =text_matcher_node.id, sink_id=reddit_comment_node.id, source_name=\n    'positive_#_post_id', sink_name='data_#_post_id'), Link(source_id=\n    text_matcher_node.id, sink_id=reddit_comment_node.id, source_name=\n    'positive_#_marketing_text', sink_name='data_#_comment')]\ntest_graph = Graph(name='RedditMarketingAgent', description=\n    'Reddit marketing agent', nodes=nodes, links=links)\nreturn test_graph", "successors": []}], "functions": [], "classes": []}, {"name": "create_test_user", "type": "CFG", "blocks": [{"id": 7, "label": "#7\ntest_user_data = {'sub': 'ef3b97d7-1161-4eb4-92b2-10c24fb154c1', 'email':\n    'testuser@example.com', 'name': 'Test User'}\nuser = await get_or_create_user(test_user_data)", "successors": [{"id": 8, "label": "#8\nreturn user", "successors": []}]}], "functions": [], "classes": []}, {"name": "reddit_marketing_agent", "type": "CFG", "blocks": [{"id": 12, "label": "#12\nasync with SpinTestServer() as server:\n    test_user = await create_test_user()\n    test_graph = await create_graph(create_test_graph(), user_id=test_user.id)\n    input_data = {'subreddit': 'AutoGPT'}\n    response = await server.agent_server.test_execute_graph(test_graph.id,\n        input_data, test_user.id)\n    print(response)\n    result = await wait_execution(test_user.id, test_graph.id, response[\n        'id'], 120)\n    print(result)", "successors": [{"id": 13, "label": "#13\ntest_user = await create_test_user()", "successors": [{"id": 15, "label": "#15\ntest_graph = await create_graph(create_test_graph(), user_id=test_user.id)", "successors": [{"id": 16, "label": "#16\ninput_data = {'subreddit': 'AutoGPT'}\nresponse = await server.agent_server.test_execute_graph(test_graph.id,\n    input_data, test_user.id)", "successors": [{"id": 17, "label": "#17\nprint(response)\nresult = await wait_execution(test_user.id, test_graph.id, response['id'], 120)", "successors": [{"id": 18, "label": "#18\nprint(result)", "successors": []}]}]}]}]}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "88.json", "name": "88.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nif __name__ == '__main__':", "successors": [{"id": 13, "label": "#13\nimport doctest\ndoctest.testmod()", "successors": []}]}], "functions": [{"name": "binary_count_setbits", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"\n    Take in 1 integer, return a number that is\n    the number of 1's in binary representation of that number.\n\n    >>> binary_count_setbits(25)\n    3\n    >>> binary_count_setbits(36)\n    2\n    >>> binary_count_setbits(16)\n    1\n    >>> binary_count_setbits(58)\n    4\n    >>> binary_count_setbits(4294967295)\n    32\n    >>> binary_count_setbits(0)\n    0\n    >>> binary_count_setbits(-10)\n    Traceback (most recent call last):\n    ValueError: Input value must be a positive integer\n    >>> binary_count_setbits(0.8)\n    Traceback (most recent call last):\n    TypeError: Input value must be a 'int' type\n    >>> binary_count_setbits(\"0\")\n    Traceback (most recent call last):\n    TypeError: '<' not supported between instances of 'str' and 'int'\n    \"\"\"\nif a < 0:", "successors": [{"id": 4, "label": "#4\nraise ValueError('Input value must be a positive integer')", "successors": []}, {"id": 6, "label": "#6\nif isinstance(a, float):", "successors": [{"id": 7, "label": "#7\nraise TypeError(\"Input value must be a 'int' type\")", "successors": []}, {"id": 5, "label": "#5\nreturn bin(a).count('1')", "successors": []}]}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "89.json", "name": "89.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nif __name__ == '__main__':", "successors": [{"id": 9, "label": "#9\nimport doctest\ndoctest.testmod()", "successors": []}]}], "functions": [{"name": "twos_complement", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"\n    Take in a negative integer 'number'.\n    Return the two's complement representation of 'number'.\n\n    >>> twos_complement(0)\n    '0b0'\n    >>> twos_complement(-1)\n    '0b11'\n    >>> twos_complement(-5)\n    '0b1011'\n    >>> twos_complement(-17)\n    '0b101111'\n    >>> twos_complement(-207)\n    '0b100110001'\n    >>> twos_complement(1)\n    Traceback (most recent call last):\n    ValueError: input must be a negative integer\n    \"\"\"\nif number > 0:", "successors": [{"id": 4, "label": "#4\nraise ValueError('input must be a negative integer')", "successors": []}, {"id": 5, "label": "#5\nbinary_number_length = len(bin(number)[3:])\ntwos_complement_number = bin(abs(number) - (1 << binary_number_length))[3:]\ntwos_complement_number = '1' + '0' * (binary_number_length - len(\n    twos_complement_number)) + twos_complement_number if number < 0 else '0'\nreturn '0b' + twos_complement_number", "successors": []}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "90.json", "name": "90.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport time\nfrom datetime import datetime, timedelta\nfrom typing import Any, Union\nfrom backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema\nfrom backend.data.model import SchemaField", "successors": []}], "functions": [], "classes": [{"name": "GetCurrentTimeBlock", "type": "CFG", "blocks": [{"id": 3, "label": "#3", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 11, "label": "#11\nsuper().__init__(id='a892b8d9-3e4e-4e9c-9c1e-75f8efcf1bfa', description=\n    'This block outputs the current time.', categories={BlockCategory.TEXT},\n    input_schema=GetCurrentTimeBlock.Input, output_schema=\n    GetCurrentTimeBlock.Output, test_input=[{'trigger': 'Hello'}, {\n    'trigger': 'Hello', 'format': '%H:%M'}], test_output=[('time', lambda _:\n    time.strftime('%H:%M:%S')), ('time', lambda _: time.strftime('%H:%M'))])", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 14, "label": "#14\ncurrent_time = time.strftime(input_data.format)\nyield 'time', current_time", "successors": []}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 5, "label": "#5\ntrigger: str = SchemaField(description=\n    'Trigger any data to output the current time')\nformat: str = SchemaField(description='Format of the time to output',\n    default='%H:%M:%S')", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 8, "label": "#8\ntime: str = SchemaField(description=\n    'Current time in the specified format (default: %H:%M:%S)')", "successors": []}], "functions": [], "classes": []}]}, {"name": "GetCurrentDateBlock", "type": "CFG", "blocks": [{"id": 19, "label": "#19", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 27, "label": "#27\nsuper().__init__(id='b29c1b50-5d0e-4d9f-8f9d-1b0e6fcbf0b1', description=\n    'This block outputs the current date with an optional offset.',\n    categories={BlockCategory.TEXT}, input_schema=GetCurrentDateBlock.Input,\n    output_schema=GetCurrentDateBlock.Output, test_input=[{'trigger':\n    'Hello', 'offset': '7'}, {'trigger': 'Hello', 'offset': '7', 'format':\n    '%m/%d/%Y'}], test_output=[('date', lambda t: abs(datetime.now() -\n    datetime.strptime(t, '%Y-%m-%d')) < timedelta(days=8)), ('date', lambda\n    t: abs(datetime.now() - datetime.strptime(t, '%m/%d/%Y')) < timedelta(\n    days=8))])", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 30, "label": "#30\ntry:", "successors": [{"id": 31, "label": "#31\noffset = int(input_data.offset)", "successors": [{"id": 33, "label": "#33\ncurrent_date = datetime.now() - timedelta(days=offset)\nyield 'date', current_date.strftime(input_data.format)", "successors": []}]}, {"id": 32, "label": "#32\noffset = 0", "successors": []}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 21, "label": "#21\ntrigger: str = SchemaField(description=\n    'Trigger any data to output the current date')\noffset: Union[int, str] = SchemaField(title='Days Offset', description=\n    'Offset in days from the current date', default=0)\nformat: str = SchemaField(description='Format of the date to output',\n    default='%Y-%m-%d')", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 24, "label": "#24\ndate: str = SchemaField(description=\n    'Current date in the specified format (default: YYYY-MM-DD)')", "successors": []}], "functions": [], "classes": []}]}, {"name": "GetCurrentDateAndTimeBlock", "type": "CFG", "blocks": [{"id": 38, "label": "#38", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 46, "label": "#46\nsuper().__init__(id='716a67b3-6760-42e7-86dc-18645c6e00fc', description=\n    'This block outputs the current date and time.', categories={\n    BlockCategory.TEXT}, input_schema=GetCurrentDateAndTimeBlock.Input,\n    output_schema=GetCurrentDateAndTimeBlock.Output, test_input=[{'trigger':\n    'Hello'}], test_output=[('date_time', lambda t: abs(datetime.now() -\n    datetime.strptime(t, '%Y-%m-%d %H:%M:%S')) < timedelta(seconds=10))])", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 49, "label": "#49\ncurrent_date_time = time.strftime(input_data.format)\nyield 'date_time', current_date_time", "successors": []}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 40, "label": "#40\ntrigger: str = SchemaField(description=\n    'Trigger any data to output the current date and time')\nformat: str = SchemaField(description=\n    'Format of the date and time to output', default='%Y-%m-%d %H:%M:%S')", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 43, "label": "#43\ndate_time: str = SchemaField(description=\n    'Current date and time in the specified format (default: YYYY-MM-DD HH:MM:SS)'\n    )", "successors": []}], "functions": [], "classes": []}]}, {"name": "CountdownTimerBlock", "type": "CFG", "blocks": [{"id": 54, "label": "#54", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 62, "label": "#62\nsuper().__init__(id='d67a9c52-5e4e-11e2-bcfd-0800200c9a71', description=\n    'This block triggers after a specified duration.', categories={\n    BlockCategory.TEXT}, input_schema=CountdownTimerBlock.Input,\n    output_schema=CountdownTimerBlock.Output, test_input=[{'seconds': 1}, {\n    'input_message': 'Custom message'}], test_output=[('output_message',\n    'timer finished'), ('output_message', 'Custom message')])", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 65, "label": "#65\nseconds = int(input_data.seconds)\nminutes = int(input_data.minutes)\nhours = int(input_data.hours)\ndays = int(input_data.days)\ntotal_seconds = seconds + minutes * 60 + hours * 3600 + days * 86400\ntime.sleep(total_seconds)\nyield 'output_message', input_data.input_message", "successors": []}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 56, "label": "#56\ninput_message: Any = SchemaField(advanced=False, description=\n    'Message to output after the timer finishes', default='timer finished')\nseconds: Union[int, str] = SchemaField(advanced=False, description=\n    'Duration in seconds', default=0)\nminutes: Union[int, str] = SchemaField(advanced=False, description=\n    'Duration in minutes', default=0)\nhours: Union[int, str] = SchemaField(advanced=False, description=\n    'Duration in hours', default=0)\ndays: Union[int, str] = SchemaField(advanced=False, description=\n    'Duration in days', default=0)", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 59, "label": "#59\noutput_message: Any = SchemaField(description=\n    'Message after the timer finishes')", "successors": []}], "functions": [], "classes": []}]}]}
{"file_name": "91.json", "name": "91.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport os\nimport subprocess\ndirectory = os.path.dirname(os.path.realpath(__file__))\nBACKEND_DIR = '.'\nLIBS_DIR = '../autogpt_libs'\nTARGET_DIRS = [BACKEND_DIR, LIBS_DIR]", "successors": []}], "functions": [{"name": "run", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nprint(f\">>>>> Running poetry run {' '.join(command)}\")\nsubprocess.run(['poetry', 'run'] + list(command), cwd=directory, check=True)", "successors": []}], "functions": [], "classes": []}, {"name": "lint", "type": "CFG", "blocks": [{"id": 6, "label": "#6\ntry:", "successors": [{"id": 7, "label": "#7\nrun('ruff', 'check', *TARGET_DIRS, '--exit-zero')\nrun('ruff', 'format', '--diff', '--check', LIBS_DIR)\nrun('isort', '--diff', '--check', '--profile', 'black', BACKEND_DIR)\nrun('black', '--diff', '--check', BACKEND_DIR)\nrun('pyright', *TARGET_DIRS)", "successors": []}, {"id": 8, "label": "#8\nprint('Lint failed, try running `poetry run format` to fix the issues: ', e)\nraise e", "successors": []}]}], "functions": [], "classes": []}, {"name": "format", "type": "CFG", "blocks": [{"id": 13, "label": "#13\nrun('ruff', 'check', '--fix', *TARGET_DIRS)\nrun('ruff', 'format', LIBS_DIR)\nrun('isort', '--profile', 'black', BACKEND_DIR)\nrun('black', BACKEND_DIR)\nrun('pyright', *TARGET_DIRS)", "successors": []}], "functions": [], "classes": []}], "classes": []}
{"file_name": "92.json", "name": "92.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nif __name__ == '__main__':", "successors": [{"id": 9, "label": "#9\nimport doctest\ndoctest.testmod()", "successors": []}]}], "functions": [{"name": "binary_xor", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"\n    Take in 2 integers, convert them to binary,\n    return a binary number that is the\n    result of a binary xor operation on the integers provided.\n\n    >>> binary_xor(25, 32)\n    '0b111001'\n    >>> binary_xor(37, 50)\n    '0b010111'\n    >>> binary_xor(21, 30)\n    '0b01011'\n    >>> binary_xor(58, 73)\n    '0b1110011'\n    >>> binary_xor(0, 255)\n    '0b11111111'\n    >>> binary_xor(256, 256)\n    '0b000000000'\n    >>> binary_xor(0, -1)\n    Traceback (most recent call last):\n    ValueError: the value of both inputs must be positive\n    >>> binary_xor(0, 1.1)\n    Traceback (most recent call last):\n    TypeError: 'float' object cannot be interpreted as an integer\n    >>> binary_xor(\"0\", \"1\")\n    Traceback (most recent call last):\n    TypeError: '<' not supported between instances of 'str' and 'int'\n    \"\"\"\nif a < 0 or b < 0:", "successors": [{"id": 4, "label": "#4\nraise ValueError('the value of both inputs must be positive')", "successors": []}, {"id": 5, "label": "#5\na_binary = str(bin(a))[2:]\nb_binary = str(bin(b))[2:]\nmax_len = max(len(a_binary), len(b_binary))\nreturn '0b' + ''.join(str(int(char_a != char_b)) for char_a, char_b in zip(\n    a_binary.zfill(max_len), b_binary.zfill(max_len)))", "successors": []}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "93.json", "name": "93.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nif __name__ == '__main__':", "successors": [{"id": 57, "label": "#57\nPUZZLE = [([''] * 3) for _ in range(3)]\nWORDS = ['cat', 'dog', 'car']\nif solve_crossword(PUZZLE, WORDS):", "successors": [{"id": 59, "label": "#59\nprint('Solution found:')", "successors": [{"id": 62, "label": "#62\nfor row in PUZZLE:", "successors": [{"id": 63, "label": "#63\nprint(' '.join(row))", "successors": []}]}]}, {"id": 61, "label": "#61\nprint('No solution found:')", "successors": []}]}]}], "functions": [{"name": "is_valid", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"\n    Check if a word can be placed at the given position.\n\n    >>> puzzle = [\n    >>> is_valid(puzzle, 'word', 0, 0, True)\n    True\n    >>> puzzle = [\n    >>> is_valid(puzzle, 'word', 0, 0, False)\n    True\n    \"\"\"", "successors": [{"id": 4, "label": "#4\nfor i in range(len(word)):", "successors": [{"id": 5, "label": "#5\nif vertical:", "successors": [{"id": 7, "label": "#7\nif row + i >= len(puzzle) or puzzle[row + i][col] != '':", "successors": [{"id": 13, "label": "#13\nreturn False", "successors": []}]}, {"id": 9, "label": "#9\nif col + i >= len(puzzle[0]) or puzzle[row][col + i] != '':", "successors": [{"id": 10, "label": "#10\nreturn False", "successors": []}]}]}, {"id": 6, "label": "#6\nreturn True", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "place_word", "type": "CFG", "blocks": [{"id": 19, "label": "#19\n\"\"\"\n    Place a word at the given position.\n\n    >>> puzzle = [\n    >>> place_word(puzzle, 'word', 0, 0, True)\n    >>> puzzle\n    [['w', '', '', ''], ['o', '', '', ''], ['r', '', '', ''], ['d', '', '', '']]\n    \"\"\"", "successors": [{"id": 20, "label": "#20\nfor i, char in enumerate(word):", "successors": [{"id": 21, "label": "#21\nif vertical:", "successors": [{"id": 23, "label": "#23\npuzzle[row + i][col] = char", "successors": []}, {"id": 25, "label": "#25\npuzzle[row][col + i] = char", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "remove_word", "type": "CFG", "blocks": [{"id": 28, "label": "#28\n\"\"\"\n    Remove a word from the given position.\n\n    >>> puzzle = [\n    >>> remove_word(puzzle, 'word', 0, 0, True)\n    >>> puzzle\n    [['', '', '', ''], ['', '', '', ''], ['', '', '', ''], ['', '', '', '']]\n    \"\"\"", "successors": [{"id": 29, "label": "#29\nfor i in range(len(word)):", "successors": [{"id": 30, "label": "#30\nif vertical:", "successors": [{"id": 32, "label": "#32\npuzzle[row + i][col] = ''", "successors": []}, {"id": 34, "label": "#34\npuzzle[row][col + i] = ''", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "solve_crossword", "type": "CFG", "blocks": [{"id": 37, "label": "#37\n\"\"\"\n    Solve the crossword puzzle using backtracking.\n\n    >>> puzzle = [\n\n    >>> words = ['word', 'four', 'more', 'last']\n    >>> solve_crossword(puzzle, words)\n    True\n    >>> puzzle = [\n    >>> words = ['word', 'four', 'more', 'paragraphs']\n    >>> solve_crossword(puzzle, words)\n    False\n    \"\"\"", "successors": [{"id": 38, "label": "#38\nfor row in range(len(puzzle)):", "successors": [{"id": 39, "label": "#39\nfor col in range(len(puzzle[0])):", "successors": [{"id": 41, "label": "#41\nif puzzle[row][col] == '':", "successors": [{"id": 43, "label": "#43\nfor word in words:", "successors": [{"id": 45, "label": "#45\nfor vertical in [True, False]:", "successors": [{"id": 47, "label": "#47\nif is_valid(puzzle, word, row, col, vertical):", "successors": [{"id": 49, "label": "#49\nplace_word(puzzle, word, row, col, vertical)\nwords.remove(word)\nif solve_crossword(puzzle, words):", "successors": [{"id": 51, "label": "#51\nreturn True", "successors": []}, {"id": 52, "label": "#52\nwords.append(word)\nremove_word(puzzle, word, row, col, vertical)", "successors": []}]}]}]}, {"id": 46, "label": "#46\nreturn False", "successors": []}]}]}]}, {"id": 40, "label": "#40\nreturn True", "successors": []}]}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "94.json", "name": "94.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\n\"\"\"\nMinimax helps to achieve maximum score in a game by checking all possible moves\ndepth is current depth in game tree.\n\nnodeIndex is index of current node in scores[].\nif move is of maximizer return true else false\nleaves of game tree is stored in scores[]\nheight is maximum height of Game tree\n\"\"\"\nfrom __future__ import annotations\nimport math\nif __name__ == '__main__':", "successors": [{"id": 21, "label": "#21\nimport doctest\ndoctest.testmod()\nmain()", "successors": []}]}], "functions": [{"name": "minimax", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"\n    This function implements the minimax algorithm, which helps achieve the optimal\n    score for a player in a two-player game by checking all possible moves.\n    If the player is the maximizer, then the score is maximized.\n    If the player is the minimizer, then the score is minimized.\n\n    Parameters:\n    - depth: Current depth in the game tree.\n    - node_index: Index of the current node in the scores list.\n    - is_max: A boolean indicating whether the current move\n              is for the maximizer (True) or minimizer (False).\n    - scores: A list containing the scores of the leaves of the game tree.\n    - height: The maximum height of the game tree.\n\n    Returns:\n    - An integer representing the optimal score for the current player.\n\n    >>> import math\n    >>> scores = [90, 23, 6, 33, 21, 65, 123, 34423]\n    >>> height = math.log(len(scores), 2)\n    >>> minimax(0, 0, True, scores, height)\n    65\n    >>> minimax(-1, 0, True, scores, height)\n    Traceback (most recent call last):\n    ValueError: Depth cannot be less than 0\n    >>> minimax(0, 0, True, [], 2)\n    Traceback (most recent call last):\n    ValueError: Scores cannot be empty\n    >>> scores = [3, 5, 2, 9, 12, 5, 23, 23]\n    >>> height = math.log(len(scores), 2)\n    >>> minimax(0, 0, True, scores, height)\n    12\n    \"\"\"\nif depth < 0:", "successors": [{"id": 4, "label": "#4\nraise ValueError('Depth cannot be less than 0')", "successors": []}, {"id": 5, "label": "#5\nif len(scores) == 0:", "successors": [{"id": 7, "label": "#7\nraise ValueError('Scores cannot be empty')", "successors": []}, {"id": 8, "label": "#8\nif depth == height:", "successors": [{"id": 10, "label": "#10\nreturn scores[node_index]", "successors": []}, {"id": 11, "label": "#11\nif is_max:", "successors": [{"id": 13, "label": "#13\nreturn max(minimax(depth + 1, node_index * 2, False, scores, height),\n    minimax(depth + 1, node_index * 2 + 1, False, scores, height))", "successors": []}, {"id": 14, "label": "#14\nreturn min(minimax(depth + 1, node_index * 2, True, scores, height),\n    minimax(depth + 1, node_index * 2 + 1, True, scores, height))", "successors": []}]}]}]}]}], "functions": [], "classes": []}, {"name": "main", "type": "CFG", "blocks": [{"id": 19, "label": "#19\nscores = [90, 23, 6, 33, 21, 65, 123, 34423]\nheight = math.log(len(scores), 2)\nprint('Optimal value : ', end='')\nprint(minimax(0, 0, True, scores, height))", "successors": []}], "functions": [], "classes": []}], "classes": []}
{"file_name": "95.json", "name": "95.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom typing import Any\nfrom uuid import UUID\nimport pytest\nfrom backend.blocks.basic import AgentInputBlock, AgentOutputBlock, StoreValueBlock\nfrom backend.data.block import BlockSchema\nfrom backend.data.graph import Graph, Link, Node\nfrom backend.data.model import SchemaField\nfrom backend.data.user import DEFAULT_USER_ID\nfrom backend.server.model import CreateGraph\nfrom backend.util.test import SpinTestServer", "successors": []}], "functions": [{"name": "test_graph_creation", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"\n    Test the creation of a graph with nodes and links.\n\n    This test ensures that:\n    1. A graph can be successfully created with valid connections.\n    2. The created graph has the correct structure and properties.\n\n    Args:\n        server (SpinTestServer): The test server instance.\n    \"\"\"\nvalue_block = StoreValueBlock().id\ninput_block = AgentInputBlock().id\ngraph = Graph(id='test_graph', name='TestGraph', description='Test graph',\n    nodes=[Node(id='node_1', block_id=value_block), Node(id='node_2',\n    block_id=input_block, input_default={'name': 'input'}), Node(id=\n    'node_3', block_id=value_block)], links=[Link(source_id='node_1',\n    sink_id='node_2', source_name='output', sink_name='name')])\ncreate_graph = CreateGraph(graph=graph)\ncreated_graph = await server.agent_server.test_create_graph(create_graph,\n    DEFAULT_USER_ID)", "successors": [{"id": 4, "label": "#4\nassert UUID(created_graph.id)", "successors": [{"id": 6, "label": "#6\nassert created_graph.name == 'TestGraph'", "successors": [{"id": 8, "label": "#8\nassert len(created_graph.nodes) == 3", "successors": [{"id": 10, "label": "#10\nassert UUID(created_graph.nodes[0].id)", "successors": [{"id": 12, "label": "#12\nassert UUID(created_graph.nodes[1].id)", "successors": [{"id": 14, "label": "#14\nassert UUID(created_graph.nodes[2].id)", "successors": [{"id": 16, "label": "#16\nnodes = created_graph.nodes\nlinks = created_graph.links\nassert len(links) == 1", "successors": [{"id": 18, "label": "#18\nassert links[0].source_id != links[0].sink_id", "successors": [{"id": 20, "label": "#20\nassert links[0].source_id in {nodes[0].id, nodes[1].id, nodes[2].id}", "successors": [{"id": 22, "label": "#22\nassert links[0].sink_id in {nodes[0].id, nodes[1].id, nodes[2].id}", "successors": []}]}]}]}]}]}]}]}]}]}]}], "functions": [], "classes": []}, {"name": "test_get_input_schema", "type": "CFG", "blocks": [{"id": 27, "label": "#27\n\"\"\"\n    Test the get_input_schema method of a created graph.\n\n    This test ensures that:\n    1. A graph can be created with a single node.\n    2. The input schema of the created graph is correctly generated.\n    3. The input schema contains the expected input name and node id.\n\n    Args:\n        server (SpinTestServer): The test server instance.\n    \"\"\"\nvalue_block = StoreValueBlock().id\ninput_block = AgentInputBlock().id\noutput_block = AgentOutputBlock().id\ngraph = Graph(name='TestInputSchema', description='Test input schema',\n    nodes=[Node(id='node_0_a', block_id=input_block, input_default={'name':\n    'in_key_a', 'title': 'Key A', 'value': 'A'}, metadata={'id': 'node_0_a'\n    }), Node(id='node_0_b', block_id=input_block, input_default={'name':\n    'in_key_b', 'advanced': True}, metadata={'id': 'node_0_b'}), Node(id=\n    'node_1', block_id=value_block, metadata={'id': 'node_1'}), Node(id=\n    'node_2', block_id=output_block, input_default={'name': 'out_key',\n    'description': 'This is an output key'}, metadata={'id': 'node_2'})],\n    links=[Link(source_id='node_0_a', sink_id='node_1', source_name=\n    'result', sink_name='input'), Link(source_id='node_0_b', sink_id=\n    'node_1', source_name='result', sink_name='input'), Link(source_id=\n    'node_1', sink_id='node_2', source_name='output', sink_name='value')])\ncreate_graph = CreateGraph(graph=graph)\ncreated_graph = await server.agent_server.test_create_graph(create_graph,\n    DEFAULT_USER_ID)", "successors": [{"id": 28, "label": "#28\ninput_schema = created_graph.input_schema\ninput_schema['title'] = 'ExpectedInputSchema'\nassert input_schema == ExpectedInputSchema.jsonschema()", "successors": [{"id": 36, "label": "#36\noutput_schema = created_graph.output_schema\noutput_schema['title'] = 'ExpectedOutputSchema'\nassert output_schema == ExpectedOutputSchema.jsonschema()", "successors": []}]}]}], "functions": [], "classes": [{"name": "ExpectedInputSchema", "type": "CFG", "blocks": [{"id": 30, "label": "#30\nin_key_a: Any = SchemaField(title='Key A', default='A', advanced=False)\nin_key_b: Any = SchemaField(title='in_key_b', advanced=True)", "successors": []}], "functions": [], "classes": []}, {"name": "ExpectedOutputSchema", "type": "CFG", "blocks": [{"id": 33, "label": "#33\nout_key: Any = SchemaField(description='This is an output key', title=\n    'out_key', advanced=False)", "successors": []}], "functions": [], "classes": []}]}], "classes": []}
{"file_name": "96.json", "name": "96.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom typing import Optional\nfrom pydantic import BaseModel\nfrom backend.data.model import SchemaField", "successors": []}], "functions": [], "classes": [{"name": "TextSettings", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nmax_characters: int = SchemaField(default=1000, description=\n    'Maximum number of characters to return', placeholder='1000')\ninclude_html_tags: bool = SchemaField(default=False, description=\n    'Whether to include HTML tags in the text', placeholder='False')", "successors": []}], "functions": [], "classes": []}, {"name": "HighlightSettings", "type": "CFG", "blocks": [{"id": 6, "label": "#6\nnum_sentences: int = SchemaField(default=3, description=\n    'Number of sentences per highlight', placeholder='3')\nhighlights_per_url: int = SchemaField(default=3, description=\n    'Number of highlights per URL', placeholder='3')", "successors": []}], "functions": [], "classes": []}, {"name": "SummarySettings", "type": "CFG", "blocks": [{"id": 9, "label": "#9\nquery: Optional[str] = SchemaField(default='', description=\n    'Query string for summarization', placeholder='Enter query')", "successors": []}], "functions": [], "classes": []}, {"name": "ContentSettings", "type": "CFG", "blocks": [{"id": 12, "label": "#12\ntext: TextSettings = SchemaField(default=TextSettings(), description=\n    'Text content settings')\nhighlights: HighlightSettings = SchemaField(default=HighlightSettings(),\n    description='Highlight settings')\nsummary: SummarySettings = SchemaField(default=SummarySettings(),\n    description='Summary settings')", "successors": []}], "functions": [], "classes": []}]}
{"file_name": "98.json", "name": "98.json", "type": "CFG", "blocks": [{"id": 1, "label": "#1\n{'name': 'example_script', 'type': 'CFG', 'start_line': 1, 'end_line': 466,\n    'functions': [], 'classes': [{'name': 'TestValidadeFormat', 'type':\n    'class', 'start_line': 17, 'end_line': 466, 'functions': [{'name':\n    'test_error_message_return_and_return_type', 'type': 'function',\n    'start_line': 19, 'end_line': 40, 'functions': [], 'classes': [],\n    'simplified_code':\n    \"\"\"    def test_error_message_return_and_return_type(self):\n        line_num_unity = 1\n        line_num_ten = 10\n        line_num_hundred = 100\n        line_num_thousand = 1000\n\n        msg = 'This is a unit test'\n\n        err_msg_unity = error_message(line_num_unity, msg)\n        err_msg_ten = error_message(line_num_ten, msg)\n        err_msg_hundred = error_message(line_num_hundred, msg)\n        err_msg_thousand = error_message(line_num_thousand, msg)\n\n        self.assertIsInstance(err_msg_unity, str)\n        self.assertIsInstance(err_msg_ten, str)\n        self.assertIsInstance(err_msg_hundred, str)\n        self.assertIsInstance(err_msg_thousand, str)\n\n        self.assertEqual(err_msg_unity, '(L002) This is a unit test')\n        self.assertEqual(err_msg_ten, '(L011) This is a unit test')\n        self.assertEqual(err_msg_hundred, '(L101) This is a unit test')\n        self.assertEqual(err_msg_thousand, '(L1001) This is a unit test')\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    'def test_error_message_return_and_return_type(self):', 'successors': [\n    2]}, {'id': 2, 'label':\n    \"\"\"line_num_unity = 1\nline_num_ten = 10\nline_num_hundred = 100\nline_num_thousand = 1000\n\nmsg = 'This is a unit test'\n\nerr_msg_unity = error_message(line_num_unity, msg)\nerr_msg_ten = error_message(line_num_ten, msg)\nerr_msg_hundred = error_message(line_num_hundred, msg)\nerr_msg_thousand = error_message(line_num_thousand, msg)\n\nself.assertIsInstance(err_msg_unity, str)\nself.assertIsInstance(err_msg_ten, str)\nself.assertIsInstance(err_msg_hundred, str)\nself.assertIsInstance(err_msg_thousand, str)\n\nself.assertEqual(err_msg_unity, '(L002) This is a unit test')\nself.assertEqual(err_msg_ten, '(L011) This is a unit test')\nself.assertEqual(err_msg_hundred, '(L101) This is a unit test')\nself.assertEqual(err_msg_thousand, '(L1001) This is a unit test')\"\"\"\n    , 'successors': []}]}, {'name':\n    'test_if_get_categories_content_return_correct_data_of_categories',\n    'type': 'function', 'start_line': 42, 'end_line': 69, 'functions': [],\n    'classes': [], 'simplified_code':\n    \"\"\"    def test_if_get_categories_content_return_correct_data_of_categories(self):\n        fake_contents = [\n            '### A',\n            'API | Description | Auth | HTTPS | CORS |',\n            '|---|---|---|---|---|',\n            '| [AA](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n            '| [AB](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n            '',\n            '### B',\n            'API | Description | Auth | HTTPS | CORS |',\n            '|---|---|---|---|---|',\n            '| [BA](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n            '| [BB](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |'\n        ]\n\n        result = get_categories_content(fake_contents)\n        self.assertIsInstance(result, tuple)\n\n        categories, category_line_num = result\n        self.assertIsInstance(categories, dict)\n        self.assertIsInstance(category_line_num, dict)\n\n        expected_result = ({'A': ['AA', 'AB'], 'B': ['BA', 'BB']}, {'A': 0, 'B': 6})\n\n        for res, ex_res in zip(result, expected_result):\n\n            with self.subTest():\n                self.assertEqual(res, ex_res)\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"fake_contents = [ '### A', 'API | Description | Auth | HTTPS | CORS |', '|---|---|---|---|---|', '| [AA](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |', '| [AB](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |', '', '### B', 'API | Description | Auth | HTTPS | CORS |', '|---|---|---|---|---|', '| [BA](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |', '| [BB](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |' ]\"\n    , 'successors': [2]}, {'id': 2, 'label':\n    'result = get_categories_content(fake_contents)', 'successors': [3]}, {\n    'id': 3, 'label': 'self.assertIsInstance(result, tuple)', 'successors':\n    [4]}, {'id': 4, 'label': 'categories, category_line_num = result',\n    'successors': [5]}, {'id': 5, 'label':\n    'self.assertIsInstance(categories, dict)', 'successors': [6]}, {'id': 6,\n    'label': 'self.assertIsInstance(category_line_num, dict)', 'successors':\n    [7]}, {'id': 7, 'label':\n    \"expected_result = ({'A': ['AA', 'AB'], 'B': ['BA', 'BB']}, {'A': 0, 'B': 6})\"\n    , 'successors': [8]}, {'id': 8, 'label':\n    'for res, ex_res in zip(result, expected_result):', 'successors': [9, \n    10]}, {'id': 9, 'label': 'with self.subTest():', 'successors': [10]}, {\n    'id': 10, 'label': 'self.assertEqual(res, ex_res)', 'successors': [8]}]\n    }, {'name': 'test_if_check_alphabetical_order_return_correct_msg_error',\n    'type': 'function', 'start_line': 71, 'end_line': 118, 'functions': [],\n    'classes': [], 'simplified_code':\n    \"\"\"    def test_if_check_alphabetical_order_return_correct_msg_error(self):\n        correct_lines = [\n            '### A',\n            'API | Description | Auth | HTTPS | CORS |',\n            '|---|---|---|---|---|',\n            '| [AA](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n            '| [AB](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n            '',\n            '### B',\n            'API | Description | Auth | HTTPS | CORS |',\n            '|---|---|---|---|---|',\n            '| [BA](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n            '| [BB](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |'\n        ]\n\n        incorrect_lines = [\n            '### A',\n            'API | Description | Auth | HTTPS | CORS |',\n            '|---|---|---|---|---|',\n            '| [AB](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n            '| [AA](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n            '',\n            '### B',\n            'API | Description | Auth | HTTPS | CORS |',\n            '|---|---|---|---|---|',\n            '| [BB](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n            '| [BA](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |'\n        ]\n\n\n        err_msgs_1 = check_alphabetical_order(correct_lines)\n        err_msgs_2 = check_alphabetical_order(incorrect_lines)\n\n        self.assertIsInstance(err_msgs_1, list)\n        self.assertIsInstance(err_msgs_2, list)\n\n        self.assertEqual(len(err_msgs_1), 0)\n        self.assertEqual(len(err_msgs_2), 2)\n\n        expected_err_msgs = [\n            '(L001) A category is not alphabetical order',\n            '(L007) B category is not alphabetical order'\n        ]\n\n        for err_msg, ex_err_msg in zip(err_msgs_2, expected_err_msgs):\n\n            with self.subTest():\n                self.assertEqual(err_msg, ex_err_msg)\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"correct_lines = [\n    '### A',\n    'API | Description | Auth | HTTPS | CORS |',\n    '|---|---|---|---|---|',\n    '| [AA](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n    '| [AB](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n    '',\n    '### B',\n    'API | Description | Auth | HTTPS | CORS |',\n    '|---|---|---|---|---|',\n    '| [BA](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n    '| [BB](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |'\n]\"\"\"\n    , 'successors': [2]}, {'id': 2, 'label':\n    \"\"\"incorrect_lines = [\n    '### A',\n    'API | Description | Auth | HTTPS | CORS |',\n    '|---|---|---|---|---|',\n    '| [AB](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n    '| [AA](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n    '',\n    '### B',\n    'API | Description | Auth | HTTPS | CORS |',\n    '|---|---|---|---|---|',\n    '| [BB](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n    '| [BA](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |'\n]\"\"\"\n    , 'successors': [3]}, {'id': 3, 'label':\n    \"\"\"err_msgs_1 = check_alphabetical_order(correct_lines)\nerr_msgs_2 = check_alphabetical_order(incorrect_lines)\"\"\"\n    , 'successors': [4]}, {'id': 4, 'label':\n    \"\"\"self.assertIsInstance(err_msgs_1, list)\nself.assertIsInstance(err_msgs_2, list)\"\"\"\n    , 'successors': [5]}, {'id': 5, 'label':\n    \"\"\"self.assertEqual(len(err_msgs_1), 0)\nself.assertEqual(len(err_msgs_2), 2)\"\"\"\n    , 'successors': [6]}, {'id': 6, 'label':\n    \"\"\"expected_err_msgs = [\n    '(L001) A category is not alphabetical order',\n    '(L007) B category is not alphabetical order'\n]\"\"\"\n    , 'successors': [7]}, {'id': 7, 'label':\n    'for err_msg, ex_err_msg in zip(err_msgs_2, expected_err_msgs):',\n    'successors': [8, 9]}, {'id': 8, 'label':\n    'self.assertEqual(err_msg, ex_err_msg)', 'successors': [9]}, {'id': 9,\n    'label': '', 'successors': []}]}, {'name':\n    'test_check_title_with_correct_title', 'type': 'function', 'start_line':\n    120, 'end_line': 127, 'functions': [], 'classes': [], 'simplified_code':\n    \"\"\"    def test_check_title_with_correct_title(self):\n        raw_title = '[A](https://www.ex.com)'\n\n        err_msgs = check_title(0, raw_title)\n\n        self.assertIsInstance(err_msgs, list)\n        self.assertEqual(len(err_msgs), 0)\n        self.assertEqual(err_msgs, [])\"\"\"\n    , 'blocks': [{'id': 1, 'label': \"raw_title = '[A](https://www.ex.com)'\",\n    'successors': [2]}, {'id': 2, 'label':\n    'err_msgs = check_title(0, raw_title)', 'successors': [3]}, {'id': 3,\n    'label': 'self.assertIsInstance(err_msgs, list)', 'successors': [4]}, {\n    'id': 4, 'label': 'self.assertEqual(len(err_msgs), 0)', 'successors': [\n    5]}, {'id': 5, 'label': 'self.assertEqual(err_msgs, [])', 'successors':\n    []}]}, {'name': 'test_check_title_with_markdown_syntax_incorrect',\n    'type': 'function', 'start_line': 129, 'end_line': 140, 'functions': [],\n    'classes': [], 'simplified_code':\n    \"\"\"    def test_check_title_with_markdown_syntax_incorrect(self):\n        raw_title = '[A(https://www.ex.com)'\n\n        err_msgs = check_title(0, raw_title)\n\n        self.assertIsInstance(err_msgs, list)\n        self.assertEqual(len(err_msgs), 1)\n        \n        err_msg = err_msgs[0]\n        expected_err_msg = '(L001) Title syntax should be \"[TITLE](LINK)\"'\n\n        self.assertEqual(err_msg, expected_err_msg)\"\"\"\n    , 'blocks': [{'id': 1, 'label': \"raw_title = '[A(https://www.ex.com)'\",\n    'successors': [2]}, {'id': 2, 'label':\n    'err_msgs = check_title(0, raw_title)', 'successors': [3]}, {'id': 3,\n    'label':\n    \"\"\"self.assertIsInstance(err_msgs, list)\nself.assertEqual(len(err_msgs), 1)\"\"\"\n    , 'successors': [4]}, {'id': 4, 'label':\n    \"\"\"err_msg = err_msgs[0]\nexpected_err_msg = '(L001) Title syntax should be \"[TITLE](LINK)\"'\"\"\"\n    , 'successors': [5]}, {'id': 5, 'label':\n    'self.assertEqual(err_msg, expected_err_msg)', 'successors': []}]}, {\n    'name': 'test_check_title_with_api_at_the_end_of_the_title', 'type':\n    'function', 'start_line': 142, 'end_line': 153, 'functions': [],\n    'classes': [], 'simplified_code':\n    \"\"\"    def test_check_title_with_api_at_the_end_of_the_title(self):\n        raw_title = '[A API](https://www.ex.com)'\n\n        err_msgs = check_title(0, raw_title)\n        \n        self.assertIsInstance(err_msgs, list)\n        self.assertEqual(len(err_msgs), 1)\n        \n        err_msg = err_msgs[0]\n\n        self.assertEqual(err_msg, expected_err_msg)\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"def test_check_title_with_api_at_the_end_of_the_title(self):\n    raw_title = '[A API](https://www.ex.com)'\"\"\"\n    , 'successors': [2]}, {'id': 2, 'label':\n    'err_msgs = check_title(0, raw_title)', 'successors': [3]}, {'id': 3,\n    'label':\n    \"\"\"self.assertIsInstance(err_msgs, list)\nself.assertEqual(len(err_msgs), 1)\"\"\"\n    , 'successors': [4]}, {'id': 4, 'label':\n    \"\"\"err_msg = err_msgs[0]\n    , 'successors': [5]}, {'id': 5, 'label':\n    'self.assertEqual(err_msg, expected_err_msg)', 'successors': []}]}, {\n    'name': 'test_check_description_with_correct_description', 'type':\n    'function', 'start_line': 155, 'end_line': 162, 'functions': [],\n    'classes': [], 'simplified_code':\n    \"\"\"    def test_check_description_with_correct_description(self):\n        desc = 'This is a fake description'\n\n        err_msgs = check_description(0, desc)\n\n        self.assertIsInstance(err_msgs, list)\n        self.assertEqual(len(err_msgs), 0)\n        self.assertEqual(err_msgs, [])\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"def test_check_description_with_correct_description(self):\n    desc = 'This is a fake description'\"\"\"\n    , 'successors': [2]}, {'id': 2, 'label':\n    'err_msgs = check_description(0, desc)', 'successors': [3]}, {'id': 3,\n    'label':\n    \"\"\"self.assertIsInstance(err_msgs, list)\nself.assertEqual(len(err_msgs), 0)\nself.assertEqual(err_msgs, [])\"\"\"\n    , 'successors': []}]}, {'name':\n    'test_check_description_with_first_char_is_not_capitalized', 'type':\n    'function', 'start_line': 164, 'end_line': 176, 'functions': [],\n    'classes': [], 'simplified_code':\n    \"\"\"    def test_check_description_with_first_char_is_not_capitalized(self):\n        desc = 'this is a fake description'\n\n        err_msgs = check_description(0, desc)\n\n        self.assertIsInstance(err_msgs, list)\n        self.assertEqual(len(err_msgs), 1)\n        \n        err_msg = err_msgs[0]\n        expected_err_msg = '(L001) first character of description is not capitalized'\n\n        self.assertIsInstance(err_msg, str)\n        self.assertEqual(err_msg, expected_err_msg)\"\"\"\n    , 'blocks': [{'id': 1, 'label': \"desc = 'this is a fake description'\",\n    'successors': [2]}, {'id': 2, 'label':\n    'err_msgs = check_description(0, desc)', 'successors': [3]}, {'id': 3,\n    'label': 'self.assertIsInstance(err_msgs, list)', 'successors': [4]}, {\n    'id': 4, 'label': 'self.assertEqual(len(err_msgs), 1)', 'successors': [\n    5]}, {'id': 5, 'label': 'err_msg = err_msgs[0]', 'successors': [6]}, {\n    'id': 6, 'label':\n    \"expected_err_msg = '(L001) first character of description is not capitalized'\"\n    , 'successors': [7]}, {'id': 7, 'label':\n    'self.assertIsInstance(err_msg, str)', 'successors': [8]}, {'id': 8,\n    'label': 'self.assertEqual(err_msg, expected_err_msg)', 'successors': [\n    ]}]}, {'name': 'test_check_description_with_punctuation_in_the_end',\n    'type': 'function', 'start_line': 178, 'end_line': 195, 'functions': [],\n    'classes': [], 'simplified_code':\n    \"\"\"    def test_check_description_with_punctuation_in_the_end(self):\n        base_desc = 'This is a fake description'\n        punctuation = r\"\"\\\"!\"#$%&'*+,-./:;<=>?@[\\\\]^_`{|}~\"\"\\\"\n        desc_with_punc = [base_desc + punc for punc in punctuation]\n        \n        for desc in desc_with_punc:\n\n            with self.subTest():\n                err_msgs = check_description(0, desc)\n\n                self.assertIsInstance(err_msgs, list)\n                self.assertEqual(len(err_msgs), 1)\n        \n                err_msg = err_msgs[0]\n                expected_err_msg = f'(L001) description should not end with {desc[-1]}'\n\n                self.assertIsInstance(err_msg, str)\n                self.assertEqual(err_msg, expected_err_msg)\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    'def test_check_description_with_punctuation_in_the_end(self):',\n    'successors': [2]}, {'id': 2, 'label':\n    \"\"\"base_desc = 'This is a fake description'\npunctuation = r\"\"\\\"!\"#$%&'*+,-./:;<=>?@[\\\\]^_`{|}~\"\"\\\"\ndesc_with_punc = [base_desc + punc for punc in punctuation]\"\"\"\n    , 'successors': [3]}, {'id': 3, 'label': 'for desc in desc_with_punc:',\n    'successors': [4, 8]}, {'id': 4, 'label': 'with self.subTest():',\n    'successors': [5]}, {'id': 5, 'label':\n    'err_msgs = check_description(0, desc)', 'successors': [6]}, {'id': 6,\n    'label':\n    \"\"\"self.assertIsInstance(err_msgs, list)\nself.assertEqual(len(err_msgs), 1)\"\"\"\n    , 'successors': [7]}, {'id': 7, 'label':\n    \"\"\"err_msg = err_msgs[0]\nexpected_err_msg = f'(L001) description should not end with {desc[-1]}'\n\nself.assertIsInstance(err_msg, str)\nself.assertEqual(err_msg, expected_err_msg)\"\"\"\n    , 'successors': [3]}, {'id': 8, 'label': '', 'successors': []}]}, {\n    'name': 'test_check_description_that_exceeds_the_character_limit',\n    'type': 'function', 'start_line': 197, 'end_line': 210, 'functions': [],\n    'classes': [], 'simplified_code':\n    \"\"\"    def test_check_description_that_exceeds_the_character_limit(self):\n        long_desc = 'Desc' * max_description_length\n        long_desc_length = len(long_desc)\n\n        err_msgs = check_description(0, long_desc)\n\n        self.assertIsInstance(err_msgs, list)\n        self.assertEqual(len(err_msgs), 1)\n\n        err_msg = err_msgs[0]\n        expected_err_msg = f'(L001) description should not exceed {max_description_length} characters (currently {long_desc_length})'\n\n        self.assertIsInstance(err_msg, str)\n        self.assertEqual(err_msg, expected_err_msg)\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"long_desc = 'Desc' * max_description_length\nlong_desc_length = len(long_desc)\"\"\"\n    , 'successors': [2]}, {'id': 2, 'label':\n    'err_msgs = check_description(0, long_desc)', 'successors': [3]}, {'id':\n    3, 'label':\n    \"\"\"self.assertIsInstance(err_msgs, list)\nself.assertEqual(len(err_msgs), 1)\"\"\"\n    , 'successors': [4]}, {'id': 4, 'label':\n    \"\"\"err_msg = err_msgs[0]\nexpected_err_msg = f'(L001) description should not exceed {max_description_length} characters (currently {long_desc_length})'\"\"\"\n    , 'successors': [5]}, {'id': 5, 'label':\n    \"\"\"self.assertIsInstance(err_msg, str)\nself.assertEqual(err_msg, expected_err_msg)\"\"\"\n    , 'successors': []}]}, {'name': 'test_check_auth_with_valid_auth',\n    'type': 'function', 'start_line': 212, 'end_line': 221, 'functions': [],\n    'classes': [], 'simplified_code':\n    \"\"\"    def test_check_auth_with_valid_auth(self):\n        auth_valid = [f'`{auth}`' for auth in auth_keys if auth != 'No']\n        auth_valid.append('No')\n\n        for auth in auth_valid:\n            with self.subTest():\n                err_msgs = check_auth(0, auth)\n                self.assertIsInstance(err_msgs, list)\n                self.assertEqual(len(err_msgs), 0)\n                self.assertEqual(err_msgs, [])\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"auth_valid = [f'`{auth}`' for auth in auth_keys if auth != 'No']\nauth_valid.append('No')\"\"\"\n    , 'successors': [2]}, {'id': 2, 'label': 'for auth in auth_valid:',\n    'successors': [3, 4]}, {'id': 3, 'label':\n    \"\"\"with self.subTest():\n    err_msgs = check_auth(0, auth)\n    self.assertIsInstance(err_msgs, list)\n    self.assertEqual(len(err_msgs), 0)\n    self.assertEqual(err_msgs, [])\"\"\"\n    , 'successors': [2]}, {'id': 4, 'label': '', 'successors': []}]}, {\n    'name': 'test_check_auth_without_backtick', 'type': 'function',\n    'start_line': 223, 'end_line': 236, 'functions': [], 'classes': [],\n    'simplified_code':\n    \"\"\"    def test_check_auth_without_backtick(self):\n        auth_without_backtick = [auth for auth in auth_keys if auth != 'No']\n\n        for auth in auth_without_backtick:\n            with self.subTest():\n                err_msgs = check_auth(0, auth)\n                self.assertIsInstance(err_msgs, list)\n                self.assertEqual(len(err_msgs), 1)\n\n                err_msg = err_msgs[0]\n                expected_err_msg = '(L001) auth value is not enclosed with `backticks`'\n\n                self.assertIsInstance(err_msg, str)\n                self.assertEqual(err_msg, expected_err_msg)\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"auth_without_backtick = [auth for auth in auth_keys if auth != 'No']\",\n    'successors': [2]}, {'id': 2, 'label':\n    'for auth in auth_without_backtick:', 'successors': [3, 5]}, {'id': 3,\n    'label': 'with self.subTest():', 'successors': [4]}, {'id': 4, 'label':\n    \"\"\"err_msgs = check_auth(0, auth)\nself.assertIsInstance(err_msgs, list)\nself.assertEqual(len(err_msgs), 1)\nerr_msg = err_msgs[0]\nexpected_err_msg = '(L001) auth value is not enclosed with `backticks`'\nself.assertIsInstance(err_msg, str)\nself.assertEqual(err_msg, expected_err_msg)\"\"\"\n    , 'successors': [2]}, {'id': 5, 'label': '# End of function',\n    'successors': []}]}, {'name': 'test_check_auth_with_invalid_auth',\n    'type': 'function', 'start_line': 238, 'end_line': 269, 'functions': [],\n    'classes': [], 'simplified_code':\n    \"\"\"    def test_check_auth_with_invalid_auth(self):\n        auth_invalid_without_backtick = ['Yes', 'yes', 'no', 'random', 'Unknown']\n        auth_invalid_with_backtick = ['`Yes`', '`yes`', '`no`', '`random`', '`Unknown`']\n\n        for auth in auth_invalid_without_backtick:\n            with self.subTest():\n                err_msgs = check_auth(0, auth)\n                self.assertIsInstance(err_msgs, list)\n                self.assertEqual(len(err_msgs), 2)\n\n                err_msg_1 = err_msgs[0]\n                err_msg_2 = err_msgs[1]\n\n                expected_err_msg_1 = f'(L001) auth value is not enclosed with `backticks`'\n                expected_err_msg_2 = f'(L001) {auth} is not a valid Auth option'\n\n                self.assertIsInstance(err_msg_1, str)\n                self.assertIsInstance(err_msg_2, str)\n                self.assertEqual(err_msg_1, expected_err_msg_1)\n                self.assertEqual(err_msg_2, expected_err_msg_2)\n\n        for auth in auth_invalid_with_backtick:\n            with self.subTest():\n                err_msgs = check_auth(0, auth)\n                self.assertIsInstance(err_msgs, list)\n                self.assertEqual(len(err_msgs), 1)\n\n                err_msg = err_msgs[0]\n                expected_err_msg = f'(L001) {auth} is not a valid Auth option'\n\n                self.assertIsInstance(err_msg, str)\n                self.assertEqual(err_msg, expected_err_msg)\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"auth_invalid_without_backtick = ['Yes', 'yes', 'no', 'random', 'Unknown']\nauth_invalid_with_backtick = ['`Yes`', '`yes`', '`no`', '`random`', '`Unknown`']\"\"\"\n    , 'successors': [2]}, {'id': 2, 'label':\n    'for auth in auth_invalid_without_backtick:', 'successors': [3, 8]}, {\n    'id': 3, 'label': 'with self.subTest():', 'successors': [4]}, {'id': 4,\n    'label':\n    \"\"\"err_msgs = check_auth(0, auth)\nself.assertIsInstance(err_msgs, list)\nself.assertEqual(len(err_msgs), 2)\n\nerr_msg_1 = err_msgs[0]\nerr_msg_2 = err_msgs[1]\n\nexpected_err_msg_1 = f'(L001) auth value is not enclosed with `backticks`'\nexpected_err_msg_2 = f'(L001) {auth} is not a valid Auth option'\"\"\"\n    , 'successors': [5]}, {'id': 5, 'label':\n    \"\"\"self.assertIsInstance(err_msg_1, str)\nself.assertIsInstance(err_msg_2, str)\nself.assertEqual(err_msg_1, expected_err_msg_1)\nself.assertEqual(err_msg_2, expected_err_msg_2)\"\"\"\n    , 'successors': [2]}, {'id': 6, 'label':\n    'for auth in auth_invalid_with_backtick:', 'successors': [7, 12]}, {\n    'id': 7, 'label': 'with self.subTest():', 'successors': [9]}, {'id': 8,\n    'label':\n    \"\"\"err_msgs = check_auth(0, auth)\nself.assertIsInstance(err_msgs, list)\nself.assertEqual(len(err_msgs), 1)\n\nerr_msg = err_msgs[0]\nexpected_err_msg = f'(L001) {auth} is not a valid Auth option'\"\"\"\n    , 'successors': [9]}, {'id': 9, 'label':\n    \"\"\"self.assertIsInstance(err_msg, str)\nself.assertEqual(err_msg, expected_err_msg)\"\"\"\n    , 'successors': [6]}]}, {'name': 'test_check_https_with_valid_https',\n    'type': 'function', 'start_line': 271, 'end_line': 277, 'functions': [],\n    'classes': [], 'simplified_code':\n    \"\"\"    def test_check_https_with_valid_https(self):\n        for https in https_keys:\n            with self.subTest():\n                err_msgs = check_https(0, https)\n                self.assertIsInstance(err_msgs, list)\n                self.assertEqual(len(err_msgs), 0)\n                self.assertEqual(err_msgs, [])\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    'def test_check_https_with_valid_https(self):', 'successors': [2]}, {\n    'id': 2, 'label': 'for https in https_keys:', 'successors': [3, 5]}, {\n    'id': 3, 'label': 'with self.subTest():', 'successors': [4]}, {'id': 4,\n    'label':\n    \"\"\"err_msgs = check_https(0, https)\nself.assertIsInstance(err_msgs, list)\nself.assertEqual(len(err_msgs), 0)\nself.assertEqual(err_msgs, [])\"\"\"\n    , 'successors': [2]}, {'id': 5, 'label': '', 'successors': []}]}, {\n    'name': 'test_check_https_with_invalid_https', 'type': 'function',\n    'start_line': 279, 'end_line': 292, 'functions': [], 'classes': [],\n    'simplified_code':\n    \"\"\"    def test_check_https_with_invalid_https(self):\n        invalid_https_keys = ['yes', 'no', 'Unknown', 'https', 'http']\n\n        for https in invalid_https_keys:\n            with self.subTest():\n                err_msgs = check_https(0, https)\n                self.assertIsInstance(err_msgs, list)\n                self.assertEqual(len(err_msgs), 1)\n\n                err_msg = err_msgs[0]\n                expected_err_msg = f'(L001) {https} is not a valid HTTPS option'\n\n                self.assertIsInstance(err_msg, str)\n                self.assertEqual(err_msg, expected_err_msg)\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    'def test_check_https_with_invalid_https(self):', 'successors': [2]}, {\n    'id': 2, 'label':\n    \"invalid_https_keys = ['yes', 'no', 'Unknown', 'https', 'http']\",\n    'successors': [3]}, {'id': 3, 'label':\n    'for https in invalid_https_keys:', 'successors': [4, 8]}, {'id': 4,\n    'label': 'with self.subTest():', 'successors': [5, 8]}, {'id': 5,\n    'label':\n    \"\"\"err_msgs = check_https(0, https)\nself.assertIsInstance(err_msgs, list)\nself.assertEqual(len(err_msgs), 1)\"\"\"\n    , 'successors': [6]}, {'id': 6, 'label':\n    \"\"\"err_msg = err_msgs[0]\nexpected_err_msg = f'(L001) {https} is not a valid HTTPS option'\"\"\"\n    , 'successors': [7]}, {'id': 7, 'label':\n    \"\"\"self.assertIsInstance(err_msg, str)\nself.assertEqual(err_msg, expected_err_msg)\"\"\"\n    , 'successors': [8]}, {'id': 8, 'label':\n    \"\"\"# end of for loop, returns to the next iteration if there is any\n# corresponds to 'with' and 'for' loop ending\"\"\"\n    , 'successors': [3]}]}, {'name': 'test_check_cors_with_valid_cors',\n    'type': 'function', 'start_line': 294, 'end_line': 300, 'functions': [],\n    'classes': [], 'simplified_code':\n    \"\"\"    def test_check_cors_with_valid_cors(self):\n        for cors in cors_keys:\n            with self.subTest():\n                err_msgs = check_cors(0, cors)\n                self.assertIsInstance(err_msgs, list)\n                self.assertEqual(len(err_msgs), 0)\n                self.assertEqual(err_msgs, [])\"\"\"\n    , 'blocks': [{'id': 1, 'label': 'for cors in cors_keys:', 'successors':\n    [2, 3]}, {'id': 2, 'label':\n    \"\"\"with self.subTest():\n    err_msgs = check_cors(0, cors)\n    self.assertIsInstance(err_msgs, list)\n    self.assertEqual(len(err_msgs), 0)\n    self.assertEqual(err_msgs, [])\"\"\"\n    , 'successors': [1]}, {'id': 3, 'label': '', 'successors': []}]}, {\n    'name': 'test_check_cors_with_invalid_cors', 'type': 'function',\n    'start_line': 302, 'end_line': 315, 'functions': [], 'classes': [],\n    'simplified_code':\n    \"\"\"    def test_check_cors_with_invalid_cors(self):\n        invalid_cors_keys = ['yes', 'no', 'unknown', 'cors']\n\n        for cors in invalid_cors_keys:\n            with self.subTest():\n                err_msgs = check_cors(0, cors)\n                self.assertIsInstance(err_msgs, list)\n                self.assertEqual(len(err_msgs), 1)\n\n                err_msg = err_msgs[0]\n                expected_err_msg = f'(L001) {cors} is not a valid CORS option'\n\n                self.assertIsInstance(err_msg, str)\n                self.assertEqual(err_msg, expected_err_msg)\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"invalid_cors_keys = ['yes', 'no', 'unknown', 'cors']\", 'successors': [\n    2]}, {'id': 2, 'label': 'for cors in invalid_cors_keys:', 'successors':\n    [3, 7]}, {'id': 3, 'label': 'with self.subTest():', 'successors': [4]},\n    {'id': 4, 'label': 'err_msgs = check_cors(0, cors)', 'successors': [5]},\n    {'id': 5, 'label': 'self.assertIsInstance(err_msgs, list)',\n    'successors': [6]}, {'id': 6, 'label':\n    'self.assertEqual(len(err_msgs), 1)', 'successors': [8]}, {'id': 7,\n    'label':\n    \"\"\"err_msg = err_msgs[0]\nexpected_err_msg = f'(L001) {cors} is not a valid CORS option'\"\"\"\n    , 'successors': [5]}, {'id': 8, 'label':\n    'self.assertIsInstance(err_msg, str)', 'successors': [9]}, {'id': 9,\n    'label': 'self.assertEqual(err_msg, expected_err_msg)', 'successors': [\n    2]}]}, {'name': 'test_check_entry_with_correct_segments', 'type':\n    'function', 'start_line': 317, 'end_line': 324, 'functions': [],\n    'classes': [], 'simplified_code':\n    \"\"\"    def test_check_entry_with_correct_segments(self):\n        correct_segments = ['[A](https://www.ex.com)', 'Desc', '`apiKey`', 'Yes', 'Yes']\n\n        err_msgs = check_entry(0, correct_segments)\n        \n        self.assertIsInstance(err_msgs, list)\n        self.assertEqual(len(err_msgs), 0)\n        self.assertEqual(err_msgs, [])\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"def test_check_entry_with_correct_segments(self):\n    correct_segments = ['[A](https://www.ex.com)', 'Desc', '`apiKey`', 'Yes', 'Yes']\"\"\"\n    , 'successors': [2]}, {'id': 2, 'label':\n    'err_msgs = check_entry(0, correct_segments)', 'successors': [3]}, {\n    'id': 3, 'label': 'self.assertIsInstance(err_msgs, list)', 'successors':\n    [4]}, {'id': 4, 'label': 'self.assertEqual(len(err_msgs), 0)',\n    'successors': [5]}, {'id': 5, 'label': 'self.assertEqual(err_msgs, [])',\n    'successors': []}]}, {'name':\n    'test_check_entry_with_incorrect_segments', 'type': 'function',\n    'start_line': 326, 'end_line': 345, 'functions': [], 'classes': [],\n    'simplified_code':\n    \"\"\"    def test_check_entry_with_incorrect_segments(self):\n        incorrect_segments = ['[A API](https://www.ex.com)', 'desc.', 'yes', 'yes', 'yes']\n\n        err_msgs = check_entry(0, incorrect_segments)\n        expected_err_msgs = [\n            '(L001) first character of description is not capitalized',\n            '(L001) description should not end with .',\n            '(L001) auth value is not enclosed with `backticks`',\n            '(L001) yes is not a valid Auth option',\n            '(L001) yes is not a valid HTTPS option',\n            '(L001) yes is not a valid CORS option'\n        ]\n\n        self.assertIsInstance(err_msgs, list)\n        self.assertEqual(len(err_msgs), 7)\n        for err_msg in err_msgs:\n            with self.subTest():\n                self.assertIsInstance(err_msg, str)\n        self.assertEqual(err_msgs, expected_err_msgs)\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"incorrect_segments = ['[A API](https://www.ex.com)', 'desc.', 'yes', 'yes', 'yes']\"\n    , 'successors': [2]}, {'id': 2, 'label':\n    'err_msgs = check_entry(0, incorrect_segments)', 'successors': [3]}, {\n    'id': 3, 'label':\n    \"\"\"expected_err_msgs = [\n    '(L001) first character of description is not capitalized',\n    '(L001) description should not end with .',\n    '(L001) auth value is not enclosed with `backticks`',\n    '(L001) yes is not a valid Auth option',\n    '(L001) yes is not a valid HTTPS option',\n    '(L001) yes is not a valid CORS option'\n]\"\"\"\n    , 'successors': [4]}, {'id': 4, 'label':\n    'self.assertIsInstance(err_msgs, list)', 'successors': [5]}, {'id': 5,\n    'label': 'self.assertEqual(len(err_msgs), 7)', 'successors': [6]}, {\n    'id': 6, 'label': 'for err_msg in err_msgs:', 'successors': [6, 7]}, {\n    'id': 7, 'label':\n    \"\"\"with self.subTest():\n    self.assertIsInstance(err_msg, str)\"\"\",\n    'successors': [8]}, {'id': 8, 'label':\n    'self.assertEqual(err_msgs, expected_err_msgs)', 'successors': []}]}, {\n    'name': 'test_check_file_format_with_correct_format', 'type':\n    'function', 'start_line': 347, 'end_line': 372, 'functions': [],\n    'classes': [], 'simplified_code':\n    \"\"\"    def test_check_file_format_with_correct_format(self):\n        correct_format = [\n            '## Index',\n            '* [A](#a)',\n            '* [B](#b)',\n            '',\n            '### A',\n            'API | Description | Auth | HTTPS | CORS |',\n            '|---|---|---|---|---|',\n            '| [AA](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n            '| [AB](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n            '| [AC](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n            '',\n            '### B',\n            'API | Description | Auth | HTTPS | CORS |',\n            '|---|---|---|---|---|',\n            '| [BA](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n            '| [BB](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n            '| [BC](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |'\n        ]\n\n        err_msgs = check_file_format(lines=correct_format)\n\n        self.assertIsInstance(err_msgs, list)\n        self.assertEqual(len(err_msgs), 0)\n        self.assertEqual(err_msgs, [])\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"correct_format = [\n            '## Index',\n            '* [A](#a)',\n            '* [B](#b)',\n            '',\n            '### A',\n            'API | Description | Auth | HTTPS | CORS |',\n            '|---|---|---|---|---|',\n            '| [AA](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n            '| [AB](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n            '| [AC](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n            '',\n            '### B',\n            'API | Description | Auth | HTTPS | CORS |',\n            '|---|---|---|---|---|',\n            '| [BA](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n            '| [BB](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n            '| [BC](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |'\n        ]\"\"\"\n    , 'successors': [2]}, {'id': 2, 'label':\n    'err_msgs = check_file_format(lines=correct_format)', 'successors': [3]\n    }, {'id': 3, 'label': 'self.assertIsInstance(err_msgs, list)',\n    'successors': [4]}, {'id': 4, 'label':\n    'self.assertEqual(len(err_msgs), 0)', 'successors': [5]}, {'id': 5,\n    'label': 'self.assertEqual(err_msgs, [])', 'successors': []}]}, {'name':\n    'test_check_file_format_with_category_header_not_added_to_index',\n    'type': 'function', 'start_line': 374, 'end_line': 392, 'functions': [],\n    'classes': [], 'simplified_code':\n    \"\"\"    def test_check_file_format_with_category_header_not_added_to_index(self):\n        incorrect_format = [\n            '## Index',\n            '',\n            '### A',\n            'API | Description | Auth | HTTPS | CORS |',\n            '|---|---|---|---|---|',\n            '| [AA](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n            '| [AB](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n            '| [AC](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n        ]\n\n        err_msgs = check_file_format(lines=incorrect_format)\n        expected_err_msg = '(L003) category header (A) not added to Index section'\n\n        self.assertIsInstance(err_msgs, list)\n        self.assertEqual(len(err_msgs), 1)\n        err_msg = err_msgs[0]\n        self.assertEqual(err_msg, expected_err_msg)\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"incorrect_format = [\n    '## Index',\n    '',\n    '### A',\n    'API | Description | Auth | HTTPS | CORS |',\n    '|---|---|---|---|---|',\n    '| [AA](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n    '| [AB](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n    '| [AC](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n]\"\"\"\n    , 'successors': [2]}, {'id': 2, 'label':\n    'err_msgs = check_file_format(lines=incorrect_format)', 'successors': [\n    3]}, {'id': 3, 'label':\n    \"expected_err_msg = '(L003) category header (A) not added to Index section'\"\n    , 'successors': [4]}, {'id': 4, 'label':\n    'self.assertIsInstance(err_msgs, list)', 'successors': [5]}, {'id': 5,\n    'label': 'self.assertEqual(len(err_msgs), 1)', 'successors': [6]}, {\n    'id': 6, 'label': 'err_msg = err_msgs[0]', 'successors': [7]}, {'id': 7,\n    'label': 'self.assertEqual(err_msg, expected_err_msg)', 'successors': [\n    ]}]}, {'name':\n    'test_check_file_format_with_category_without_min_entries', 'type':\n    'function', 'start_line': 394, 'end_line': 422, 'functions': [],\n    'classes': [], 'simplified_code':\n    \"\"\"    def test_check_file_format_with_category_without_min_entries(self):\n        incorrect_format = [\n            '## Index',\n            '* [A](#a)',\n            '* [B](#b)',\n            '',\n            '### A',\n            'API | Description | Auth | HTTPS | CORS |',\n            '|---|---|---|---|---|',\n            '| [AA](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n            '',\n            '### B',\n            'API | Description | Auth | HTTPS | CORS |',\n            '|---|---|---|---|---|',\n            '| [BA](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n            '| [BB](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n            '| [BC](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |'\n        ]\n\n        category_with_err = 'A'\n        num_in_category = 1\n\n        err_msgs = check_file_format(lines=incorrect_format)\n        expected_err_msg = f'(L005) {category_with_err} category does not have the minimum {min_entries_per_category} entries (only has {num_in_category})'\n\n        self.assertIsInstance(err_msgs, list)\n        self.assertEqual(len(err_msgs), 1)\n        err_msg = err_msgs[0]\n        self.assertEqual(err_msg, expected_err_msg)\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    'def test_check_file_format_with_category_without_min_entries(self):',\n    'successors': [2]}, {'id': 2, 'label':\n    \"\"\"incorrect_format = [\n    '## Index',\n    '* [A](#a)',\n    '* [B](#b)',\n    '',\n    '### A',\n    'API | Description | Auth | HTTPS | CORS |',\n    '|---|---|---|---|---|',\n    '| [AA](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n    '',\n    '### B',\n    'API | Description | Auth | HTTPS | CORS |',\n    '|---|---|---|---|---|',\n    '| [BA](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n    '| [BB](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n    '| [BC](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |'\n]\"\"\"\n    , 'successors': [3]}, {'id': 3, 'label': \"category_with_err = 'A'\",\n    'successors': [4]}, {'id': 4, 'label': 'num_in_category = 1',\n    'successors': [5]}, {'id': 5, 'label':\n    'err_msgs = check_file_format(lines=incorrect_format)', 'successors': [\n    6]}, {'id': 6, 'label':\n    \"expected_err_msg = f'(L005) {category_with_err} category does not have the minimum {min_entries_per_category} entries (only has {num_in_category})'\"\n    , 'successors': [7]}, {'id': 7, 'label':\n    'self.assertIsInstance(err_msgs, list)', 'successors': [8]}, {'id': 8,\n    'label': 'self.assertEqual(len(err_msgs), 1)', 'successors': [9]}, {\n    'id': 9, 'label': 'err_msg = err_msgs[0]', 'successors': [10]}, {'id': \n    10, 'label': 'self.assertEqual(err_msg, expected_err_msg)',\n    'successors': []}]}, {'name':\n    'test_check_file_format_entry_without_all_necessary_columns', 'type':\n    'function', 'start_line': 424, 'end_line': 445, 'functions': [],\n    'classes': [], 'simplified_code':\n    \"\"\"    def test_check_file_format_entry_without_all_necessary_columns(self):\n        incorrect_format = [\n            '## Index',\n            '* [A](#a)',\n            '',\n            '### A',\n            'API | Description | Auth | HTTPS | CORS |',\n            '|---|---|---|---|---|',\n            '| [AA](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n            '| [AB](https://www.ex.com) | Desc | `apiKey` |',  # missing https and cors\n            '| [AC](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n        ]\n\n        current_segments_num = 3\n\n        err_msgs = check_file_format(lines=incorrect_format)\n        expected_err_msg = f'(L008) entry does not have all the required columns (have {current_segments_num}, need {num_segments})'\n\n        self.assertIsInstance(err_msgs, list)\n        self.assertEqual(len(err_msgs), 1)\n        err_msg = err_msgs[0]\n        self.assertEqual(err_msg, expected_err_msg)\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    'def test_check_file_format_entry_without_all_necessary_columns(self):',\n    'successors': [2]}, {'id': 2, 'label':\n    \"\"\"incorrect_format = [\n    '## Index',\n    '* [A](#a)',\n    '',\n    '### A',\n    'API | Description | Auth | HTTPS | CORS |',\n    '|---|---|---|---|---|',\n    '| [AA](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n    '| [AB](https://www.ex.com) | Desc | `apiKey` |',\n    '| [AC](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n]\"\"\"\n    , 'successors': [3]}, {'id': 3, 'label': 'current_segments_num = 3',\n    'successors': [4]}, {'id': 4, 'label':\n    'err_msgs = check_file_format(lines=incorrect_format)', 'successors': [\n    5]}, {'id': 5, 'label':\n    \"expected_err_msg = f'(L008) entry does not have all the required columns (have {current_segments_num}, need {num_segments})'\"\n    , 'successors': [6]}, {'id': 6, 'label':\n    'self.assertIsInstance(err_msgs, list)', 'successors': [7]}, {'id': 7,\n    'label': 'self.assertEqual(len(err_msgs), 1)', 'successors': [8]}, {\n    'id': 8, 'label': 'err_msg = err_msgs[0]', 'successors': [9]}, {'id': 9,\n    'label': 'self.assertEqual(err_msg, expected_err_msg)', 'successors': [\n    ]}]}, {'name':\n    'test_check_file_format_without_1_space_between_the_segments', 'type':\n    'function', 'start_line': 447, 'end_line': 466, 'functions': [],\n    'classes': [], 'simplified_code':\n    \"\"\"    def test_check_file_format_without_1_space_between_the_segments(self):\n        incorrect_format = [\n            '## Index',\n            '* [A](#a)',\n            '',\n            '### A',\n            'API | Description | Auth | HTTPS | CORS |',\n            '|---|---|---|---|---|',\n            '| [AA](https://www.ex.com) | Desc |`apiKey`| Yes | Yes |',  # space between segment of auth column missing\n            '| [AB](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n            '| [AC](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n        ]\n\n        err_msgs = check_file_format(lines=incorrect_format)\n        expected_err_msg = f'(L007) each segment must start and end with exactly 1 space'\n\n        self.assertIsInstance(err_msgs, list)\n        self.assertEqual(len(err_msgs), 1)\n        err_msg = err_msgs[0]\n        self.assertEqual(err_msg, expected_err_msg)\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"incorrect_format = [\n    '## Index',\n    '* [A](#a)',\n    '',\n    '### A',\n    'API | Description | Auth | HTTPS | CORS |',\n    '|---|---|---|---|---|',\n    '| [AA](https://www.ex.com) | Desc |`apiKey`| Yes | Yes |',  # space between segment of auth column missing\n    '| [AB](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n    '| [AC](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n]\n\nerr_msgs = check_file_format(lines=incorrect_format)\nexpected_err_msg = f'(L007) each segment must start and end with exactly 1 space'\"\"\"\n    , 'successors': [2]}, {'id': 2, 'label':\n    'self.assertIsInstance(err_msgs, list)', 'successors': [3]}, {'id': 3,\n    'label': 'self.assertEqual(len(err_msgs), 1)', 'successors': [4]}, {\n    'id': 4, 'label': 'err_msg = err_msgs[0]', 'successors': [5]}, {'id': 5,\n    'label': 'self.assertEqual(err_msg, expected_err_msg)', 'successors': [\n    ]}]}], 'classes': [], 'simplified_code':\n    \"\"\"class TestValidadeFormat(unittest.TestCase):\n    \n        self.assertEqual(err_msg_thousand, '(L1001) This is a unit test')\n\n                self.assertEqual(res, ex_res)\n\n                self.assertEqual(err_msg, ex_err_msg)\n    \n        self.assertEqual(err_msgs, [])\n\n        self.assertEqual(err_msg, expected_err_msg)\n\n        self.assertEqual(err_msg, expected_err_msg)\n\n        self.assertEqual(err_msgs, [])\n    \n        self.assertEqual(err_msg, expected_err_msg)\n    \n                self.assertEqual(err_msg, expected_err_msg)\n\n        self.assertEqual(err_msg, expected_err_msg)\n\n                self.assertEqual(err_msgs, [])\n\n                self.assertEqual(err_msg, expected_err_msg)\n\n                self.assertEqual(err_msg, expected_err_msg)\n\n                self.assertEqual(err_msgs, [])\n\n                self.assertEqual(err_msg, expected_err_msg)\n\n                self.assertEqual(err_msgs, [])\n\n                self.assertEqual(err_msg, expected_err_msg)\n\n        self.assertEqual(err_msgs, [])\n\n        self.assertEqual(err_msgs, expected_err_msgs)\n\n        self.assertEqual(err_msgs, [])\n\n        self.assertEqual(err_msg, expected_err_msg)\n\n        self.assertEqual(err_msg, expected_err_msg)\n\n        self.assertEqual(err_msg, expected_err_msg)\n\n        self.assertEqual(err_msg, expected_err_msg)\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"self.assertEqual(err_msg_thousand, '(L1001) This is a unit test')\",\n    'successors': [2]}, {'id': 2, 'label': 'self.assertEqual(res, ex_res)',\n    'successors': [3]}, {'id': 3, 'label':\n    'self.assertEqual(err_msg, ex_err_msg)', 'successors': [4]}, {'id': 4,\n    'label': 'self.assertEqual(err_msgs, [])', 'successors': [5]}, {'id': 5,\n    'label': 'self.assertEqual(err_msg, expected_err_msg)', 'successors': [\n    6]}, {'id': 6, 'label': 'self.assertEqual(err_msg, expected_err_msg)',\n    'successors': [7]}, {'id': 7, 'label': 'self.assertEqual(err_msgs, [])',\n    'successors': [8]}, {'id': 8, 'label':\n    'self.assertEqual(err_msg, expected_err_msg)', 'successors': [9]}, {\n    'id': 9, 'label': 'self.assertEqual(err_msg, expected_err_msg)',\n    'successors': [10]}, {'id': 10, 'label':\n    'self.assertEqual(err_msgs, [])', 'successors': [11]}, {'id': 11,\n    'label': 'self.assertEqual(err_msg, expected_err_msg)', 'successors': [\n    12]}, {'id': 12, 'label': 'self.assertEqual(err_msg, expected_err_msg)',\n    'successors': [13]}, {'id': 13, 'label':\n    'self.assertEqual(err_msgs, [])', 'successors': [14]}, {'id': 14,\n    'label': 'self.assertEqual(err_msgs, expected_err_msgs)', 'successors':\n    [15]}, {'id': 15, 'label': 'self.assertEqual(err_msgs, [])',\n    'successors': [16]}, {'id': 16, 'label':\n    'self.assertEqual(err_msg, expected_err_msg)', 'successors': [17]}, {\n    'id': 17, 'label': 'self.assertEqual(err_msg, expected_err_msg)',\n    'successors': [18]}, {'id': 18, 'label':\n    'self.assertEqual(err_msg, expected_err_msg)', 'successors': [19]}, {\n    'id': 19, 'label': 'self.assertEqual(err_msg, expected_err_msg)',\n    'successors': []}]}], 'simplified_code':\n    \"\"\"# -*- coding: utf-8 -*-\n\nimport unittest\n\nfrom validate.format import error_message\nfrom validate.format import get_categories_content\nfrom validate.format import check_alphabetical_order\nfrom validate.format import check_title\nfrom validate.format import check_description, max_description_length\nfrom validate.format import check_auth, auth_keys\nfrom validate.format import check_https, https_keys\nfrom validate.format import check_cors, cors_keys\nfrom validate.format import check_entry\nfrom validate.format import check_file_format, min_entries_per_category, num_segments\n\n\n        self.assertEqual(err_msg, expected_err_msg)\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"# -*- coding: utf-8 -*-\n\nimport unittest\n\nfrom validate.format import error_message\nfrom validate.format import get_categories_content\nfrom validate.format import check_alphabetical_order\nfrom validate.format import check_title\nfrom validate.format import check_description, max_description_length\nfrom validate.format import check_auth, auth_keys\nfrom validate.format import check_https, https_keys\nfrom validate.format import check_cors, cors_keys\nfrom validate.format import check_entry\nfrom validate.format import check_file_format, min_entries_per_category, num_segments\"\"\"\n    , 'successors': [2]}, {'id': 2, 'label':\n    'self.assertEqual(err_msg, expected_err_msg)', 'successors': []}]}", "successors": []}], "functions": [], "classes": []}
{"file_name": "99.json", "name": "99.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema\nfrom backend.data.model import SchemaField", "successors": []}], "functions": [], "classes": [{"name": "WordCharacterCountBlock", "type": "CFG", "blocks": [{"id": 3, "label": "#3", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 11, "label": "#11\nsuper().__init__(id='ab2a782d-22cf-4587-8a70-55b59b3f9f90', description=\n    'Counts the number of words and characters in a given text.',\n    categories={BlockCategory.TEXT}, input_schema=WordCharacterCountBlock.\n    Input, output_schema=WordCharacterCountBlock.Output, test_input={'text':\n    'Hello, how are you?'}, test_output=[('word_count', 4), (\n    'character_count', 19)])", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 14, "label": "#14\ntry:", "successors": [{"id": 15, "label": "#15\ntext = input_data.text\nword_count = len(text.split())\ncharacter_count = len(text)\nyield 'word_count', word_count", "successors": [{"id": 18, "label": "#18\nyield 'character_count', character_count", "successors": []}]}, {"id": 16, "label": "#16\nyield 'error', str(e)", "successors": []}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 5, "label": "#5\ntext: str = SchemaField(description=\n    'Input text to count words and characters', placeholder=\n    'Enter your text here', advanced=False)", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 8, "label": "#8\nword_count: int = SchemaField(description='Number of words in the input text')\ncharacter_count: int = SchemaField(description=\n    'Number of characters in the input text')\nerror: str = SchemaField(description=\n    'Error message if the counting operation failed')", "successors": []}], "functions": [], "classes": []}]}]}
{"file_name": "100.json", "name": "100.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom backend.blocks.jina._auth import JinaCredentials, JinaCredentialsField, JinaCredentialsInput\nfrom backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema\nfrom backend.data.model import SchemaField\nfrom backend.util.request import requests", "successors": []}], "functions": [], "classes": [{"name": "JinaChunkingBlock", "type": "CFG", "blocks": [{"id": 3, "label": "#3", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 11, "label": "#11\nsuper().__init__(id='806fb15e-830f-4796-8692-557d300ff43c', description=\n    \"Chunks texts using Jina AI's segmentation service\", categories={\n    BlockCategory.AI, BlockCategory.TEXT}, input_schema=JinaChunkingBlock.\n    Input, output_schema=JinaChunkingBlock.Output)", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 14, "label": "#14\nurl = 'https://segment.jina.ai/'\nheaders = {'Content-Type': 'application/json', 'Authorization':\n    f'Bearer {credentials.api_key.get_secret_value()}'}\nall_chunks = []\nall_tokens = []", "successors": [{"id": 15, "label": "#15\nfor text in input_data.texts:", "successors": [{"id": 16, "label": "#16\ndata = {'content': text, 'return_tokens': str(input_data.return_tokens).\n    lower(), 'return_chunks': 'true', 'max_chunk_length': str(input_data.\n    max_chunk_length)}\nresponse = requests.post(url, headers=headers, json=data)\nresult = response.json()\nall_chunks.extend(result.get('chunks', []))\nif input_data.return_tokens:", "successors": [{"id": 18, "label": "#18\nall_tokens.extend(result.get('tokens', []))", "successors": []}]}, {"id": 17, "label": "#17\nyield 'chunks', all_chunks", "successors": [{"id": 20, "label": "#20\nif input_data.return_tokens:", "successors": [{"id": 21, "label": "#21\nyield 'tokens', all_tokens", "successors": []}]}]}]}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 5, "label": "#5\ntexts: list = SchemaField(description='List of texts to chunk')\ncredentials: JinaCredentialsInput = JinaCredentialsField()\nmax_chunk_length: int = SchemaField(description=\n    'Maximum length of each chunk', default=1000)\nreturn_tokens: bool = SchemaField(description=\n    'Whether to return token information', default=False)", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 8, "label": "#8\nchunks: list = SchemaField(description='List of chunked texts')\ntokens: list = SchemaField(description=\n    'List of token information for each chunk', optional=True)", "successors": []}], "functions": [], "classes": []}]}]}
{"file_name": "101.json", "name": "101.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom typing import Literal\nfrom urllib.parse import quote\nfrom pydantic import SecretStr\nfrom backend.blocks.helpers.http import GetRequest\nfrom backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema\nfrom backend.data.model import APIKeyCredentials, CredentialsField, CredentialsMetaInput, SchemaField\nfrom backend.integrations.providers import ProviderName\nTEST_CREDENTIALS = APIKeyCredentials(id=\n    '01234567-89ab-cdef-0123-456789abcdef', provider='openweathermap',\n    api_key=SecretStr('mock-openweathermap-api-key'), title=\n    'Mock OpenWeatherMap API key', expires_at=None)\nTEST_CREDENTIALS_INPUT = {'provider': TEST_CREDENTIALS.provider, 'id':\n    TEST_CREDENTIALS.id, 'type': TEST_CREDENTIALS.type, 'title':\n    TEST_CREDENTIALS.type}", "successors": []}], "functions": [], "classes": [{"name": "GetWikipediaSummaryBlock", "type": "CFG", "blocks": [{"id": 3, "label": "#3", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 11, "label": "#11\nsuper().__init__(id='f5b0f5d0-1862-4d61-94be-3ad0fa772760', description=\n    'This block fetches the summary of a given topic from Wikipedia.',\n    categories={BlockCategory.SEARCH}, input_schema=\n    GetWikipediaSummaryBlock.Input, output_schema=GetWikipediaSummaryBlock.\n    Output, test_input={'topic': 'Artificial Intelligence'}, test_output=(\n    'summary', 'summary content'), test_mock={'get_request': lambda url,\n    json: {'extract': 'summary content'}})", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 14, "label": "#14\ntopic = input_data.topic\nurl = f'https://en.wikipedia.org/api/rest_v1/page/summary/{topic}'\nresponse = self.get_request(url, json=True)\nif 'extract' not in response:", "successors": [{"id": 15, "label": "#15\nraise RuntimeError(f'Unable to parse Wikipedia response: {response}')", "successors": []}, {"id": 16, "label": "#16\nyield 'summary', response['extract']", "successors": []}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 5, "label": "#5\ntopic: str = SchemaField(description='The topic to fetch the summary for')", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 8, "label": "#8\nsummary: str = SchemaField(description='The summary of the given topic')\nerror: str = SchemaField(description=\n    'Error message if the summary cannot be retrieved')", "successors": []}], "functions": [], "classes": []}]}, {"name": "GetWeatherInformationBlock", "type": "CFG", "blocks": [{"id": 22, "label": "#22", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 30, "label": "#30\nsuper().__init__(id='f7a8b2c3-6d4e-5f8b-9e7f-6d4e5f8b9e7f', input_schema=\n    GetWeatherInformationBlock.Input, output_schema=\n    GetWeatherInformationBlock.Output, description=\n    'Retrieves weather information for a specified location using OpenWeatherMap API.'\n    , test_input={'location': 'New York', 'use_celsius': True,\n    'credentials': TEST_CREDENTIALS_INPUT}, test_output=[('temperature',\n    '21.66'), ('humidity', '32'), ('condition', 'overcast clouds')],\n    test_mock={'get_request': lambda url, json: {'main': {'temp': 21.66,\n    'humidity': 32}, 'weather': [{'description': 'overcast clouds'}]}},\n    test_credentials=TEST_CREDENTIALS)", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 33, "label": "#33\nunits = 'metric' if input_data.use_celsius else 'imperial'\napi_key = credentials.api_key\nlocation = input_data.location\nurl = (\n    f'http://api.openweathermap.org/data/2.5/weather?q={quote(location)}&appid={api_key}&units={units}'\n    )\nweather_data = self.get_request(url, json=True)\nif 'main' in weather_data and 'weather' in weather_data:", "successors": [{"id": 34, "label": "#34\nyield 'temperature', str(weather_data['main']['temp'])", "successors": [{"id": 38, "label": "#38\nyield 'humidity', str(weather_data['main']['humidity'])", "successors": [{"id": 39, "label": "#39\nyield 'condition', weather_data['weather'][0]['description']", "successors": []}]}]}, {"id": 36, "label": "#36\nraise RuntimeError(f'Expected keys not found in response: {weather_data}')", "successors": []}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 24, "label": "#24\nlocation: str = SchemaField(description=\n    'Location to get weather information for')\ncredentials: CredentialsMetaInput[Literal[ProviderName.OPENWEATHERMAP],\n    Literal['api_key']] = CredentialsField(description=\n    'The OpenWeatherMap integration can be used with any API key with sufficient permissions for the blocks it is used on.'\n    )\nuse_celsius: bool = SchemaField(default=True, description=\n    'Whether to use Celsius or Fahrenheit for temperature')", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 27, "label": "#27\ntemperature: str = SchemaField(description=\n    'Temperature in the specified location')\nhumidity: str = SchemaField(description='Humidity in the specified location')\ncondition: str = SchemaField(description=\n    'Weather condition in the specified location')\nerror: str = SchemaField(description=\n    'Error message if the weather information cannot be retrieved')", "successors": []}], "functions": [], "classes": []}]}]}
{"file_name": "102.json", "name": "102.json", "type": "CFG", "blocks": [{"id": 1, "label": "#1\n{'name': 'example_script', 'type': 'CFG', 'start_line': 1, 'end_line': 25,\n    'functions': [], 'classes': [{'name': 'RemoveDuplicateUrls', 'type':\n    'class', 'start_line': 6, 'end_line': 21, 'functions': [{'name':\n    'mapper', 'type': 'function', 'start_line': 8, 'end_line': 9,\n    'functions': [], 'classes': [], 'simplified_code':\n    \"\"\"    def mapper(self, _, line):\n        yield line, 1\"\"\", 'blocks': [\n    {'id': 1, 'label': 'def mapper(self, _, line):', 'successors': [2]}, {\n    'id': 2, 'label': 'yield line, 1', 'successors': []}]}, {'name':\n    'reducer', 'type': 'function', 'start_line': 11, 'end_line': 14,\n    'functions': [], 'classes': [], 'simplified_code':\n    \"\"\"    def reducer(self, key, values):\n        total = sum(values)\n        if total == 1:\n            yield key, total\"\"\"\n    , 'blocks': [{'id': 1, 'label': 'total = sum(values)', 'successors': [2\n    ]}, {'id': 2, 'label': 'if total == 1:', 'successors': [3]}, {'id': 3,\n    'label': 'yield key, total', 'successors': []}]}, {'name': 'steps',\n    'type': 'function', 'start_line': 16, 'end_line': 21, 'functions': [],\n    'classes': [], 'simplified_code':\n    \"\"\"    def steps(self):\n        \"\"\\\"Run the map and reduce steps.\"\"\\\"\n        return [\n            self.mr(mapper=self.mapper,\n                    reducer=self.reducer)\n        ]\"\"\"\n    , 'blocks': [{'id': 1, 'label': 'def steps(self):', 'successors': [2]},\n    {'id': 2, 'label':\n    \"\"\"\"\"\\\"Run the map and reduce steps.\"\"\\\"\nreturn [\n    self.mr(mapper=self.mapper,\n            reducer=self.reducer)\n]\"\"\"\n    , 'successors': []}]}], 'simplified_code':\n    \"\"\"class RemoveDuplicateUrls(MRJob):\n\n        yield line, 1\n\n            yield key, total\n\n        ]\"\"\"\n    , 'blocks': [{'id': 1, 'label': 'class RemoveDuplicateUrls(MRJob):',\n    'successors': []}]}], 'simplified_code':\n    \"\"\"# -*- coding: utf-8 -*-\n\nfrom mrjob.job import MRJob\n\n\n        ]\n\n\nif __name__ == '__main__':\n    RemoveDuplicateUrls.run()\"\"\"\n    , 'blocks': [{'id': 1, 'label': '# -*- coding: utf-8 -*-', 'successors':\n    [2]}, {'id': 2, 'label': 'from mrjob.job import MRJob', 'successors': [\n    3]}, {'id': 3, 'label': \"if __name__ == '__main__':\", 'successors': [4]\n    }, {'id': 4, 'label': '    RemoveDuplicateUrls.run()', 'successors': []}]}", "successors": []}], "functions": [], "classes": []}
{"file_name": "103.json", "name": "103.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport secrets\nfrom datetime import datetime, timedelta, timezone\nfrom typing import TYPE_CHECKING\nfrom pydantic import SecretStr\nif TYPE_CHECKING:", "successors": [{"id": 2, "label": "#2\nfrom backend.executor.database import DatabaseManager", "successors": [{"id": 3, "label": "#3\nfrom autogpt_libs.utils.cache import thread_cached\nfrom autogpt_libs.utils.synchronize import RedisKeyedMutex\nfrom backend.data.model import APIKeyCredentials, Credentials, OAuth2Credentials, OAuthState, UserIntegrations\nfrom backend.util.settings import Settings\nsettings = Settings()\nrevid_credentials = APIKeyCredentials(id=\n    'fdb7f412-f519-48d1-9b5f-d2f73d0e01fe', provider='revid', api_key=\n    SecretStr(settings.secrets.revid_api_key), title=\n    'Use Credits for Revid', expires_at=None)\nideogram_credentials = APIKeyCredentials(id=\n    '760f84fc-b270-42de-91f6-08efe1b512d0', provider='ideogram', api_key=\n    SecretStr(settings.secrets.ideogram_api_key), title=\n    'Use Credits for Ideogram', expires_at=None)\nreplicate_credentials = APIKeyCredentials(id=\n    '6b9fc200-4726-4973-86c9-cd526f5ce5db', provider='replicate', api_key=\n    SecretStr(settings.secrets.replicate_api_key), title=\n    'Use Credits for Replicate', expires_at=None)\nopenai_credentials = APIKeyCredentials(id=\n    '53c25cb8-e3ee-465c-a4d1-e75a4c899c2a', provider='openai', api_key=\n    SecretStr(settings.secrets.openai_api_key), title=\n    'Use Credits for OpenAI', expires_at=None)\nanthropic_credentials = APIKeyCredentials(id=\n    '24e5d942-d9e3-4798-8151-90143ee55629', provider='anthropic', api_key=\n    SecretStr(settings.secrets.anthropic_api_key), title=\n    'Use Credits for Anthropic', expires_at=None)\ngroq_credentials = APIKeyCredentials(id=\n    '4ec22295-8f97-4dd1-b42b-2c6957a02545', provider='groq', api_key=\n    SecretStr(settings.secrets.groq_api_key), title='Use Credits for Groq',\n    expires_at=None)\ndid_credentials = APIKeyCredentials(id=\n    '7f7b0654-c36b-4565-8fa7-9a52575dfae2', provider='d_id', api_key=\n    SecretStr(settings.secrets.did_api_key), title='Use Credits for D-ID',\n    expires_at=None)\njina_credentials = APIKeyCredentials(id=\n    '7f26de70-ba0d-494e-ba76-238e65e7b45f', provider='jina', api_key=\n    SecretStr(settings.secrets.jina_api_key), title='Use Credits for Jina',\n    expires_at=None)\nunreal_credentials = APIKeyCredentials(id=\n    '66f20754-1b81-48e4-91d0-f4f0dd82145f', provider='unreal', api_key=\n    SecretStr(settings.secrets.unreal_speech_api_key), title=\n    'Use Credits for Unreal', expires_at=None)\nopen_router_credentials = APIKeyCredentials(id=\n    'b5a0e27d-0c98-4df3-a4b9-10193e1f3c40', provider='open_router', api_key\n    =SecretStr(settings.secrets.open_router_api_key), title=\n    'Use Credits for Open Router', expires_at=None)\nDEFAULT_CREDENTIALS = [revid_credentials, ideogram_credentials,\n    replicate_credentials, openai_credentials, anthropic_credentials,\n    groq_credentials, did_credentials, jina_credentials, unreal_credentials,\n    open_router_credentials]", "successors": []}]}]}], "functions": [], "classes": [{"name": "IntegrationCredentialsStore", "type": "CFG", "blocks": [{"id": 5, "label": "#5", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 7, "label": "#7\nfrom backend.data.redis import get_redis\nself.locks = RedisKeyedMutex(get_redis())", "successors": []}], "functions": [], "classes": []}, {"name": "db_manager", "type": "CFG", "blocks": [{"id": 10, "label": "#10\nfrom backend.executor.database import DatabaseManager\nfrom backend.util.service import get_service_client\nreturn get_service_client(DatabaseManager)", "successors": []}], "functions": [], "classes": []}, {"name": "add_creds", "type": "CFG", "blocks": [{"id": 14, "label": "#14\nwith self.locked_user_integrations(user_id):", "successors": [{"id": 15, "label": "#15\nif self.get_creds_by_id(user_id, credentials.id):", "successors": [{"id": 17, "label": "#17\nraise ValueError(\n    f'Can not re-create existing credentials #{credentials.id} for user #{user_id}'\n    )", "successors": []}, {"id": 18, "label": "#18\nself._set_user_integration_creds(user_id, [*self.get_all_creds(user_id),\n    credentials])", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "get_all_creds", "type": "CFG", "blocks": [{"id": 22, "label": "#22\nusers_credentials = self._get_user_integrations(user_id).credentials\nall_credentials = users_credentials\nif settings.secrets.revid_api_key:", "successors": [{"id": 23, "label": "#23\nall_credentials.append(revid_credentials)", "successors": [{"id": 24, "label": "#24\nif settings.secrets.ideogram_api_key:", "successors": [{"id": 25, "label": "#25\nall_credentials.append(ideogram_credentials)", "successors": [{"id": 26, "label": "#26\nif settings.secrets.groq_api_key:", "successors": [{"id": 27, "label": "#27\nall_credentials.append(groq_credentials)", "successors": [{"id": 28, "label": "#28\nif settings.secrets.replicate_api_key:", "successors": [{"id": 29, "label": "#29\nall_credentials.append(replicate_credentials)", "successors": [{"id": 30, "label": "#30\nif settings.secrets.openai_api_key:", "successors": [{"id": 31, "label": "#31\nall_credentials.append(openai_credentials)", "successors": [{"id": 32, "label": "#32\nif settings.secrets.anthropic_api_key:", "successors": [{"id": 33, "label": "#33\nall_credentials.append(anthropic_credentials)", "successors": [{"id": 34, "label": "#34\nif settings.secrets.did_api_key:", "successors": [{"id": 35, "label": "#35\nall_credentials.append(did_credentials)", "successors": [{"id": 36, "label": "#36\nif settings.secrets.jina_api_key:", "successors": [{"id": 37, "label": "#37\nall_credentials.append(jina_credentials)", "successors": [{"id": 38, "label": "#38\nif settings.secrets.unreal_speech_api_key:", "successors": [{"id": 39, "label": "#39\nall_credentials.append(unreal_credentials)", "successors": [{"id": 40, "label": "#40\nif settings.secrets.open_router_api_key:", "successors": [{"id": 41, "label": "#41\nall_credentials.append(open_router_credentials)", "successors": [{"id": 42, "label": "#42\nreturn all_credentials", "successors": []}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}], "functions": [], "classes": []}, {"name": "get_creds_by_id", "type": "CFG", "blocks": [{"id": 46, "label": "#46\nall_credentials = self.get_all_creds(user_id)\nreturn next((c for c in all_credentials if c.id == credentials_id), None)", "successors": []}], "functions": [], "classes": []}, {"name": "get_creds_by_provider", "type": "CFG", "blocks": [{"id": 50, "label": "#50\ncredentials = self.get_all_creds(user_id)\nreturn [c for c in credentials if c.provider == provider]", "successors": []}], "functions": [], "classes": []}, {"name": "get_authorized_providers", "type": "CFG", "blocks": [{"id": 54, "label": "#54\ncredentials = self.get_all_creds(user_id)\nreturn list(set(c.provider for c in credentials))", "successors": []}], "functions": [], "classes": []}, {"name": "update_creds", "type": "CFG", "blocks": [{"id": 58, "label": "#58\nwith self.locked_user_integrations(user_id):", "successors": [{"id": 59, "label": "#59\ncurrent = self.get_creds_by_id(user_id, updated.id)\nif not current:", "successors": [{"id": 61, "label": "#61\nraise ValueError(\n    f'Credentials with ID {updated.id} for user with ID {user_id} not found')", "successors": []}, {"id": 62, "label": "#62\nif type(current) is not type(updated):", "successors": [{"id": 64, "label": "#64\nraise TypeError(\n    f'Can not update credentials with ID {updated.id} from type {type(current)} to type {type(updated)}'\n    )", "successors": []}, {"id": 65, "label": "#65\nif isinstance(updated, OAuth2Credentials) and isinstance(current,", "successors": [{"id": 67, "label": "#67\nraise ValueError(\n    f'Can not update credentials with ID {updated.id} and scopes {current.scopes} to more restrictive set of scopes {updated.scopes}'\n    )", "successors": []}, {"id": 68, "label": "#68\nupdated_credentials_list = [(updated if c.id == updated.id else c) for c in\n    self.get_all_creds(user_id)]\nself._set_user_integration_creds(user_id, updated_credentials_list)", "successors": []}]}]}]}]}], "functions": [], "classes": []}, {"name": "delete_creds_by_id", "type": "CFG", "blocks": [{"id": 72, "label": "#72\nwith self.locked_user_integrations(user_id):", "successors": [{"id": 73, "label": "#73\nfiltered_credentials = [c for c in self.get_all_creds(user_id) if c.id !=\n    credentials_id]\nself._set_user_integration_creds(user_id, filtered_credentials)", "successors": []}]}], "functions": [], "classes": []}, {"name": "store_state_token", "type": "CFG", "blocks": [{"id": 77, "label": "#77\ntoken = secrets.token_urlsafe(32)\nexpires_at = datetime.now(timezone.utc) + timedelta(minutes=10)\nstate = OAuthState(token=token, provider=provider, expires_at=int(\n    expires_at.timestamp()), scopes=scopes)\nwith self.locked_user_integrations(user_id):", "successors": [{"id": 78, "label": "#78\nuser_integrations = self._get_user_integrations(user_id)\noauth_states = user_integrations.oauth_states\noauth_states.append(state)\nuser_integrations.oauth_states = oauth_states\nself.db_manager.update_user_integrations(user_id=user_id, data=\n    user_integrations)", "successors": [{"id": 79, "label": "#79\nreturn token", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "get_any_valid_scopes_from_state_token", "type": "CFG", "blocks": [{"id": 83, "label": "#83\n\"\"\"\n        Get the valid scopes from the OAuth state token. This will return any valid scopes\n        from any OAuth state token for the given provider. If no valid scopes are found,\n        an empty list is returned. DO NOT RELY ON THIS TOKEN TO AUTHENTICATE A USER, AS IT\n        IS TO CHECK IF THE USER HAS GIVEN PERMISSIONS TO THE APPLICATION BEFORE EXCHANGING\n        THE CODE FOR TOKENS.\n        \"\"\"\nuser_integrations = self._get_user_integrations(user_id)\noauth_states = user_integrations.oauth_states\nnow = datetime.now(timezone.utc)\nvalid_state = next((state for state in oauth_states if state.token == token and\n    state.provider == provider and state.expires_at > now.timestamp()), None)\nif valid_state:", "successors": [{"id": 84, "label": "#84\nreturn valid_state.scopes", "successors": []}, {"id": 85, "label": "#85\nreturn []", "successors": []}]}], "functions": [], "classes": []}, {"name": "verify_state_token", "type": "CFG", "blocks": [{"id": 90, "label": "#90\nwith self.locked_user_integrations(user_id):", "successors": [{"id": 91, "label": "#91\nuser_integrations = self._get_user_integrations(user_id)\noauth_states = user_integrations.oauth_states\nnow = datetime.now(timezone.utc)\nvalid_state = next((state for state in oauth_states if state.token == token and\n    state.provider == provider and state.expires_at > now.timestamp()), None)\nif valid_state:", "successors": [{"id": 93, "label": "#93\noauth_states.remove(valid_state)\nuser_integrations.oauth_states = oauth_states\nself.db_manager.update_user_integrations(user_id, user_integrations)\nreturn True", "successors": []}, {"id": 92, "label": "#92\nreturn False", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "_set_user_integration_creds", "type": "CFG", "blocks": [{"id": 99, "label": "#99\nintegrations = self._get_user_integrations(user_id)\ncredentials = [c for c in credentials if c not in DEFAULT_CREDENTIALS]\nintegrations.credentials = credentials\nself.db_manager.update_user_integrations(user_id, integrations)", "successors": []}], "functions": [], "classes": []}, {"name": "_get_user_integrations", "type": "CFG", "blocks": [{"id": 102, "label": "#102\nintegrations: UserIntegrations = self.db_manager.get_user_integrations(user_id\n    =user_id)\nreturn integrations", "successors": []}], "functions": [], "classes": []}, {"name": "locked_user_integrations", "type": "CFG", "blocks": [{"id": 106, "label": "#106\nkey = f'user:{user_id}', 'integrations'\nreturn self.locks.locked(key)", "successors": []}], "functions": [], "classes": []}], "classes": []}]}
{"file_name": "104.json", "name": "104.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport datetime\nimport typing\nimport fuzzywuzzy.fuzz\nimport prisma.enums\nimport prisma.errors\nimport prisma.models\nimport prisma.types\nimport pydantic\nimport market.model\nimport market.utils.extension_types", "successors": []}], "functions": [{"name": "delete_agent", "type": "CFG", "blocks": [{"id": 12, "label": "#12\n\"\"\"\n    Delete an agent from the database.\n\n    Args:\n        agent_id (str): The ID of the agent to delete.\n\n    Returns:\n        prisma.models.Agents | None: The deleted agent if found, None otherwise.\n\n    Raises:\n        AgentQueryError: If there is an error deleting the agent from the database.\n    \"\"\"\ntry:", "successors": [{"id": 13, "label": "#13\ndeleted_agent = await prisma.models.Agents.prisma().delete(where={'id':\n    agent_id})", "successors": [{"id": 17, "label": "#17\nreturn deleted_agent", "successors": []}]}, {"id": 14, "label": "#14\nraise AgentQueryError(f'Database query failed: {str(e)}')", "successors": []}, {"id": 15, "label": "#15\nraise AgentQueryError(f'Unexpected error occurred: {str(e)}')", "successors": []}]}], "functions": [], "classes": []}, {"name": "create_agent_entry", "type": "CFG", "blocks": [{"id": 23, "label": "#23\n\"\"\"\n    Create a new agent entry in the database.\n\n    Args:\n        name (str): The name of the agent.\n        description (str): The description of the agent.\n        author (str): The author of the agent.\n        keywords (List[str]): The keywords associated with the agent.\n        categories (List[str]): The categories associated with the agent.\n        graph (dict): The graph data of the agent.\n\n    Returns:\n        dict: The newly created agent entry.\n\n    Raises:\n        AgentQueryError: If there is an error creating the agent entry.\n    \"\"\"\ntry:", "successors": [{"id": 24, "label": "#24\nagent = await prisma.models.Agents.prisma().create(data={'name': name,\n    'description': description, 'author': author, 'keywords': keywords,\n    'categories': categories, 'graph': graph, 'AnalyticsTracker': {'create':\n    {'downloads': 0, 'views': 0}}, 'submissionStatus': submission_state})", "successors": [{"id": 28, "label": "#28\nreturn agent", "successors": []}]}, {"id": 25, "label": "#25\nraise AgentQueryError(f'Database query failed: {str(e)}')", "successors": []}, {"id": 26, "label": "#26\nraise AgentQueryError(f'Unexpected error occurred: {str(e)}')", "successors": []}]}], "functions": [], "classes": []}, {"name": "update_agent_entry", "type": "CFG", "blocks": [{"id": 34, "label": "#34\n\"\"\"\n    Update an existing agent entry in the database.\n\n    Args:\n        agent_id (str): The ID of the agent.\n        version (int): The version of the agent.\n        submission_state (prisma.enums.SubmissionStatus): The submission state of the agent.\n    \"\"\"\ntry:", "successors": [{"id": 35, "label": "#35\nagent = await prisma.models.Agents.prisma().update(where={'id': agent_id},\n    data={'version': version, 'submissionStatus': submission_state,\n    'submissionReviewDate': datetime.datetime.now(datetime.timezone.utc),\n    'submissionReviewComments': comments})", "successors": [{"id": 39, "label": "#39\nreturn agent", "successors": []}]}, {"id": 36, "label": "#36\nraise AgentQueryError(f'Agent Update Failed Database query failed: {str(e)}')", "successors": []}, {"id": 37, "label": "#37\nraise AgentQueryError(f'Unexpected error occurred: {str(e)}')", "successors": []}]}], "functions": [], "classes": []}, {"name": "get_agents", "type": "CFG", "blocks": [{"id": 45, "label": "#45\n\"\"\"\n    Retrieve a list of agents from the database based on the provided filters and pagination parameters.\n\n    Args:\n        page (int, optional): The page number to retrieve. Defaults to 1.\n        page_size (int, optional): The number of agents per page. Defaults to 10.\n        name (str, optional): Filter agents by name. Defaults to None.\n        keyword (str, optional): Filter agents by keyword. Defaults to None.\n        category (str, optional): Filter agents by category. Defaults to None.\n        description (str, optional): Filter agents by description. Defaults to None.\n        description_threshold (int, optional): The minimum fuzzy search threshold for the description. Defaults to 60.\n        sort_by (str, optional): The field to sort the agents by. Defaults to \"createdAt\".\n        sort_order (str, optional): The sort order (\"asc\" or \"desc\"). Defaults to \"desc\".\n\n    Returns:\n        dict: A dictionary containing the list of agents, total count, current page number, page size, and total number of pages.\n    \"\"\"\ntry:", "successors": [{"id": 46, "label": "#46\nquery = {}\nif name:", "successors": [{"id": 51, "label": "#51\nquery['name'] = {'contains': name, 'mode': 'insensitive'}", "successors": [{"id": 52, "label": "#52\nif keyword:", "successors": [{"id": 53, "label": "#53\nquery['keywords'] = {'has': keyword}", "successors": [{"id": 54, "label": "#54\nif category:", "successors": [{"id": 55, "label": "#55\nquery['categories'] = {'has': category}", "successors": [{"id": 56, "label": "#56\nquery['submissionStatus'] = submission_status\norder = {sort_by: sort_order}\nskip = (page - 1) * page_size\ntry:", "successors": [{"id": 57, "label": "#57\nagents = await prisma.models.Agents.prisma().find_many(where=query, order=\n    order, skip=skip, take=page_size)", "successors": [{"id": 59, "label": "#59\nif description:", "successors": [{"id": 62, "label": "#62\ntry:", "successors": [{"id": 64, "label": "#64\nfiltered_agents = []", "successors": [{"id": 67, "label": "#67\nfor agent in agents:", "successors": [{"id": 68, "label": "#68\nif agent.description and fuzzywuzzy.fuzz.partial_ratio(description.lower(),", "successors": [{"id": 70, "label": "#70\nfiltered_agents.append(agent)", "successors": []}]}, {"id": 69, "label": "#69\nagents = filtered_agents", "successors": [{"id": 63, "label": "#63\ntotal_count = len(agents)\nreturn {'agents': agents, 'total_count': total_count, 'page': page,\n    'page_size': page_size, 'total_pages': (total_count + page_size - 1) //\n    page_size}", "successors": []}]}]}]}, {"id": 65, "label": "#65\nraise AgentQueryError(f'Error during fuzzy search: {str(e)}')", "successors": []}]}]}]}, {"id": 58, "label": "#58\nraise AgentQueryError(f'Database query failed: {str(e)}')", "successors": []}]}]}]}]}]}]}]}, {"id": 47, "label": "#47\nraise e", "successors": []}, {"id": 48, "label": "#48\nraise AgentQueryError(f'Invalid input parameter: {str(e)}')", "successors": []}, {"id": 49, "label": "#49\nraise AgentQueryError(f'Unexpected error occurred: {str(e)}')", "successors": []}]}], "functions": [], "classes": []}, {"name": "get_agent_details", "type": "CFG", "blocks": [{"id": 79, "label": "#79\n\"\"\"\n    Retrieve agent details from the database.\n\n    Args:\n        agent_id (str): The ID of the agent.\n        version (int | None, optional): The version of the agent. Defaults to None.\n\n    Returns:\n        dict: The agent details.\n\n    Raises:\n        AgentQueryError: If the agent is not found or if there is an error querying the database.\n    \"\"\"\ntry:", "successors": [{"id": 80, "label": "#80\nquery = {'id': agent_id}\nif version is not None:", "successors": [{"id": 84, "label": "#84\nquery['version'] = version", "successors": [{"id": 85, "label": "#85\nagent = await prisma.models.Agents.prisma().find_first(where=query)", "successors": [{"id": 86, "label": "#86\nif not agent:", "successors": [{"id": 87, "label": "#87\nraise AgentQueryError('Agent not found')", "successors": []}, {"id": 88, "label": "#88\nreturn agent", "successors": []}]}]}]}]}, {"id": 81, "label": "#81\nraise AgentQueryError(f'Database query failed: {str(e)}')", "successors": []}, {"id": 82, "label": "#82\nraise AgentQueryError(f'Unexpected error occurred: {str(e)}')", "successors": []}]}], "functions": [], "classes": []}, {"name": "search_db", "type": "CFG", "blocks": [{"id": 95, "label": "#95\n\"\"\"Perform a search for agents based on the provided query string.\n\n    Args:\n        query (str): the search string\n        page (int, optional): page for searching. Defaults to 1.\n        page_size (int, optional): the number of results to return. Defaults to 10.\n        categories (List[str] | None, optional): list of category filters. Defaults to None.\n        description_threshold (int, optional): number of characters to return. Defaults to 60.\n        sort_by (str, optional): sort by option. Defaults to \"rank\".\n        sort_order (\"asc\" | \"desc\", optional): the sort order. Defaults to \"desc\".\n\n    Raises:\n        AgentQueryError: Raises an error if the query fails.\n        AgentQueryError: Raises if an unexpected error occurs.\n\n    Returns:\n        List[AgentsWithRank]: List of agents matching the search criteria.\n    \"\"\"\ntry:", "successors": [{"id": 96, "label": "#96\noffset = (page - 1) * page_size\ncategory_filter = '1=1'\nif categories:", "successors": [{"id": 100, "label": "#100\ncategory_conditions = [f\"'{cat}' = ANY(categories)\" for cat in categories]\ncategory_filter = 'AND (' + ' OR '.join(category_conditions) + ')'", "successors": [{"id": 101, "label": "#101\nif sort_by in ['createdAt', 'updatedAt']:", "successors": [{"id": 102, "label": "#102\norder_by_clause = f'\"{sort_by}\" {sort_order.upper()}, rank DESC'", "successors": [{"id": 103, "label": "#103\nsubmission_status_filter = f'\"submissionStatus\" = \\'{submission_status}\\''\nsql_query = f\"\"\"\n        WITH query AS (\n            SELECT to_tsquery(string_agg(lexeme || ':*', ' & ' ORDER BY positions)) AS q \n            FROM unnest(to_tsvector('{query}'))\n        )\n        SELECT \n            id, \n            \"createdAt\", \n            \"updatedAt\", \n            version, \n            name, \n            LEFT(description, {description_threshold}) AS description, \n            author, \n            keywords, \n            categories, \n            graph,\n            \"submissionStatus\",\n            \"submissionDate\",\n            CASE \n                WHEN query.q::text = '' THEN 1.0\n                ELSE COALESCE(ts_rank(CAST(search AS tsvector), query.q), 0.0)\n            END AS rank\n        FROM market.\"Agents\", query\n        WHERE \n            (query.q::text = '' OR search @@ query.q)\n            AND {category_filter} \n            AND {submission_status_filter}\n        ORDER BY {order_by_clause}\n        LIMIT {page_size}\n        OFFSET {offset};\n        \"\"\"\nresults = await prisma.client.get_client().query_raw(query=sql_query, model\n    =market.utils.extension_types.AgentsWithRank)", "successors": [{"id": 108, "label": "#108\ncount_query = f\"\"\"\n        WITH query AS (\n            SELECT to_tsquery(string_agg(lexeme || ':*', ' & ' ORDER BY positions)) AS q \n            FROM unnest(to_tsvector('{query}'))\n        )\n        SELECT COUNT(*)\n        FROM market.\"Agents\", query\n        WHERE (search @@ query.q OR query.q = '') AND {category_filter} AND {submission_status_filter};\n        \"\"\"\ntotal_count = await prisma.client.get_client().query_first(query=\n    count_query, model=CountResponse)", "successors": [{"id": 112, "label": "#112\ntotal_count = total_count.count if total_count else 0\nreturn market.model.ListResponse(items=results, total_count=total_count,\n    page=page, page_size=page_size, total_pages=(total_count + page_size - \n    1) // page_size)", "successors": []}]}]}]}, {"id": 104, "label": "#104\nif sort_by == 'name':", "successors": [{"id": 105, "label": "#105\norder_by_clause = f'name {sort_order.upper()}, rank DESC'", "successors": []}, {"id": 107, "label": "#107\norder_by_clause = 'rank DESC, \"createdAt\" DESC'", "successors": []}]}]}]}]}, {"id": 97, "label": "#97\nraise AgentQueryError(f'Database query failed: {str(e)}')", "successors": []}, {"id": 98, "label": "#98\nraise AgentQueryError(f'Unexpected error occurred: {str(e)}')", "successors": []}]}], "functions": [], "classes": [{"name": "CountResponse", "type": "CFG", "blocks": [{"id": 110, "label": "#110\ncount: int", "successors": []}], "functions": [], "classes": []}]}, {"name": "get_top_agents_by_downloads", "type": "CFG", "blocks": [{"id": 118, "label": "#118\n\"\"\"Retrieve the top agents by download count.\n\n    Args:\n        page (int, optional): The page number. Defaults to 1.\n        page_size (int, optional): The number of agents per page. Defaults to 10.\n\n    Returns:\n        dict: A dictionary containing the list of agents, total count, current page number, page size, and total number of pages.\n    \"\"\"\ntry:", "successors": [{"id": 119, "label": "#119\nskip = (page - 1) * page_size\ntry:", "successors": [{"id": 124, "label": "#124\nanalytics = await prisma.models.AnalyticsTracker.prisma().find_many(include\n    ={'agent': True}, order={'downloads': 'desc'}, where={'agent': {'is': {\n    'submissionStatus': submission_status}}}, skip=skip, take=page_size)", "successors": [{"id": 126, "label": "#126\ntry:", "successors": [{"id": 129, "label": "#129\ntotal_count = await prisma.models.AnalyticsTracker.prisma().count(where={\n    'agent': {'is': {'submissionStatus': submission_status}}})", "successors": [{"id": 131, "label": "#131\nreturn market.model.ListResponse(items=analytics, total_count=total_count,\n    page=page, page_size=page_size, total_pages=(total_count + page_size - \n    1) // page_size)", "successors": []}]}, {"id": 130, "label": "#130\nraise AgentQueryError(f'Database query failed: {str(e)}')", "successors": []}]}]}, {"id": 125, "label": "#125\nraise AgentQueryError(f'Database query failed: {str(e)}')", "successors": []}]}, {"id": 120, "label": "#120\nraise e from e", "successors": []}, {"id": 121, "label": "#121\nraise AgentQueryError(f'Invalid input parameter: {str(e)}') from e", "successors": []}, {"id": 122, "label": "#122\nraise AgentQueryError(f'Unexpected error occurred: {str(e)}') from e", "successors": []}]}], "functions": [], "classes": []}, {"name": "set_agent_featured", "type": "CFG", "blocks": [{"id": 140, "label": "#140\n\"\"\"Set an agent as featured in the database.\n\n    Args:\n        agent_id (str): The ID of the agent.\n        category (str, optional): The category to set the agent as featured. Defaults to \"featured\".\n\n    Raises:\n        AgentQueryError: If there is an error setting the agent as featured.\n    \"\"\"\ntry:", "successors": [{"id": 141, "label": "#141\nagent = await prisma.models.Agents.prisma().find_unique(where={'id': agent_id})", "successors": [{"id": 145, "label": "#145\nif not agent:", "successors": [{"id": 146, "label": "#146\nraise AgentQueryError(f'Agent with ID {agent_id} not found.')", "successors": []}, {"id": 147, "label": "#147\nfeatured = await prisma.models.FeaturedAgent.prisma().upsert(where={\n    'agentId': agent_id}, data={'update': {'featuredCategories':\n    featured_categories, 'isActive': is_active}, 'create': {\n    'featuredCategories': featured_categories, 'isActive': is_active,\n    'agent': {'connect': {'id': agent_id}}}})", "successors": [{"id": 149, "label": "#149\nreturn featured", "successors": []}]}]}]}, {"id": 142, "label": "#142\nraise AgentQueryError(f'Database query failed: {str(e)}')", "successors": []}, {"id": 143, "label": "#143\nraise AgentQueryError(f'Unexpected error occurred: {str(e)}')", "successors": []}]}], "functions": [], "classes": []}, {"name": "get_featured_agents", "type": "CFG", "blocks": [{"id": 155, "label": "#155\n\"\"\"Retrieve a list of featured agents from the database based on the provided category.\n\n    Args:\n        category (str, optional): The category of featured agents to retrieve. Defaults to \"featured\".\n        page (int, optional): The page number to retrieve. Defaults to 1.\n        page_size (int, optional): The number of agents per page. Defaults to 10.\n\n    Returns:\n        dict: A dictionary containing the list of featured agents, total count, current page number, page size, and total number of pages.\n    \"\"\"\ntry:", "successors": [{"id": 156, "label": "#156\nskip = (page - 1) * page_size\ntry:", "successors": [{"id": 161, "label": "#161\nfeatured_agents = await prisma.models.FeaturedAgent.prisma().find_many(where\n    ={'featuredCategories': {'has': category}, 'isActive': True, 'agent': {\n    'is': {'submissionStatus': submission_status}}}, include={'agent': {\n    'include': {'AnalyticsTracker': True}}}, skip=skip, take=page_size)", "successors": [{"id": 163, "label": "#163\ntotal_count = len(featured_agents)\nreturn FeaturedAgentResponse(featured_agents=featured_agents, total_count=\n    total_count, page=page, page_size=page_size, total_pages=(total_count +\n    page_size - 1) // page_size)", "successors": []}]}, {"id": 162, "label": "#162\nraise AgentQueryError(f'Database query failed: {str(e)}')", "successors": []}]}, {"id": 157, "label": "#157\nraise e from e", "successors": []}, {"id": 158, "label": "#158\nraise AgentQueryError(f'Invalid input parameter: {str(e)}') from e", "successors": []}, {"id": 159, "label": "#159\nraise AgentQueryError(f'Unexpected error occurred: {str(e)}') from e", "successors": []}]}], "functions": [], "classes": []}, {"name": "remove_featured_category", "type": "CFG", "blocks": [{"id": 172, "label": "#172\n\"\"\"Adds a featured category to an agent.\n\n    Args:\n        agent_id (str): The ID of the agent.\n        category (str): The category to add to the agent.\n\n    Returns:\n        FeaturedAgentResponse: The updated list of featured agents.\n    \"\"\"\ntry:", "successors": [{"id": 173, "label": "#173\nfeatured_agent = await prisma.models.FeaturedAgent.prisma().find_unique(where\n    ={'agentId': agent_id}, include={'agent': True})", "successors": [{"id": 177, "label": "#177\nif not featured_agent:", "successors": [{"id": 178, "label": "#178\nraise AgentQueryError(f'Agent with ID {agent_id} not found.')", "successors": []}, {"id": 179, "label": "#179\nfeatured_agent.featuredCategories.remove(category)\nfeatured_agent = await prisma.models.FeaturedAgent.prisma().update(where={\n    'agentId': agent_id}, data={'featuredCategories': featured_agent.\n    featuredCategories})", "successors": [{"id": 181, "label": "#181\nreturn featured_agent", "successors": []}]}]}]}, {"id": 174, "label": "#174\nraise AgentQueryError(f'Database query failed: {str(e)}')", "successors": []}, {"id": 175, "label": "#175\nraise AgentQueryError(f'Unexpected error occurred: {str(e)}')", "successors": []}]}], "functions": [], "classes": []}, {"name": "add_featured_category", "type": "CFG", "blocks": [{"id": 187, "label": "#187\n\"\"\"Removes a featured category from an agent.\n\n    Args:\n        agent_id (str): The ID of the agent.\n        category (str): The category to remove from the agent.\n\n    Returns:\n        FeaturedAgentResponse: The updated list of featured agents.\n    \"\"\"\ntry:", "successors": [{"id": 188, "label": "#188\nfeatured_agent = await prisma.models.FeaturedAgent.prisma().update(where={\n    'agentId': agent_id}, data={'featuredCategories': {'push': [category]}})", "successors": [{"id": 192, "label": "#192\nreturn featured_agent", "successors": []}]}, {"id": 189, "label": "#189\nraise AgentQueryError(f'Database query failed: {str(e)}')", "successors": []}, {"id": 190, "label": "#190\nraise AgentQueryError(f'Unexpected error occurred: {str(e)}')", "successors": []}]}], "functions": [], "classes": []}, {"name": "get_agent_featured", "type": "CFG", "blocks": [{"id": 198, "label": "#198\n\"\"\"Retrieve an agent's featured categories from the database.\n\n    Args:\n        agent_id (str): The ID of the agent.\n\n    Returns:\n        FeaturedAgentResponse: The list of featured agents.\n    \"\"\"\ntry:", "successors": [{"id": 199, "label": "#199\nfeatured_agent = await prisma.models.FeaturedAgent.prisma().find_unique(where\n    ={'agentId': agent_id})", "successors": [{"id": 203, "label": "#203\nreturn featured_agent", "successors": []}]}, {"id": 200, "label": "#200\nraise AgentQueryError(f'Database query failed: {str(e)}')", "successors": []}, {"id": 201, "label": "#201\nraise AgentQueryError(f'Unexpected error occurred: {str(e)}')", "successors": []}]}], "functions": [], "classes": []}, {"name": "get_not_featured_agents", "type": "CFG", "blocks": [{"id": 209, "label": "#209\n\"\"\"\n    Retrieve a list of not featured agents from the database.\n    \"\"\"\ntry:", "successors": [{"id": 210, "label": "#210\nagents = await prisma.client.get_client().query_raw(query=\n    f\"\"\"\n            SELECT \n                \"market\".\"Agents\".id, \n                \"market\".\"Agents\".\"createdAt\", \n                \"market\".\"Agents\".\"updatedAt\", \n                \"market\".\"Agents\".version, \n                \"market\".\"Agents\".name, \n                LEFT(\"market\".\"Agents\".description, 500) AS description, \n                \"market\".\"Agents\".author, \n                \"market\".\"Agents\".keywords, \n                \"market\".\"Agents\".categories, \n                \"market\".\"Agents\".graph,\n                \"market\".\"Agents\".\"submissionStatus\",\n                \"market\".\"Agents\".\"submissionDate\",\n                \"market\".\"Agents\".search::text AS search\n            FROM \"market\".\"Agents\"\n            LEFT JOIN \"market\".\"FeaturedAgent\" ON \"market\".\"Agents\".\"id\" = \"market\".\"FeaturedAgent\".\"agentId\"\n            WHERE (\"market\".\"FeaturedAgent\".\"agentId\" IS NULL OR \"market\".\"FeaturedAgent\".\"featuredCategories\" = '{{}}')\n                AND \"market\".\"Agents\".\"submissionStatus\" = 'APPROVED'\n            ORDER BY \"market\".\"Agents\".\"createdAt\" DESC\n            LIMIT {page_size} OFFSET {page_size * (page - 1)}\n            \"\"\"\n    , model=prisma.models.Agents)", "successors": [{"id": 214, "label": "#214\nreturn agents", "successors": []}]}, {"id": 211, "label": "#211\nraise AgentQueryError(f'Database query failed: {str(e)}')", "successors": []}, {"id": 212, "label": "#212\nraise AgentQueryError(f'Unexpected error occurred: {str(e)}')", "successors": []}]}], "functions": [], "classes": []}, {"name": "get_all_categories", "type": "CFG", "blocks": [{"id": 220, "label": "#220\n\"\"\"\n    Retrieve all unique categories from the database.\n\n    Returns:\n        CategoriesResponse: A list of unique categories.\n    \"\"\"\ntry:", "successors": [{"id": 221, "label": "#221\nagents = await prisma.models.Agents.prisma().find_many(distinct=['categories'])", "successors": [{"id": 225, "label": "#225\nall_categories = set()", "successors": [{"id": 226, "label": "#226\nfor agent in agents:", "successors": [{"id": 227, "label": "#227\nall_categories.update(agent.categories)", "successors": []}, {"id": 228, "label": "#228\nunique_categories = sorted(list(all_categories))\nreturn market.model.CategoriesResponse(unique_categories=unique_categories)", "successors": []}]}]}]}, {"id": 222, "label": "#222\nraise AgentQueryError(f'Database query failed: {str(e)}')", "successors": []}, {"id": 223, "label": "#223\nreturn market.model.CategoriesResponse(unique_categories=[])", "successors": []}]}], "functions": [], "classes": []}, {"name": "create_agent_installed_event", "type": "CFG", "blocks": [{"id": 234, "label": "#234\ntry:", "successors": [{"id": 235, "label": "#235\nawait prisma.models.InstallTracker.prisma().create(data={'installedAgentId':\n    event_data.installed_agent_id, 'marketplaceAgentId': event_data.\n    marketplace_agent_id, 'installationLocation': prisma.enums.\n    InstallationLocation(event_data.installation_location.name)})", "successors": []}, {"id": 236, "label": "#236\nraise AgentQueryError(f'Database query failed: {str(e)}')", "successors": []}, {"id": 237, "label": "#237\nraise AgentQueryError(f'Unexpected error occurred: {str(e)}')", "successors": []}]}], "functions": [], "classes": []}], "classes": [{"name": "AgentQueryError", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"Custom exception for agent query errors\"\"\"\npass", "successors": []}], "functions": [], "classes": []}, {"name": "TopAgentsDBResponse", "type": "CFG", "blocks": [{"id": 6, "label": "#6\n\"\"\"\n    Represents a response containing a list of top agents.\n\n    Attributes:\n        analytics (list[AgentResponse]): The list of top agents.\n        total_count (int): The total count of agents.\n        page (int): The current page number.\n        page_size (int): The number of agents per page.\n        total_pages (int): The total number of pages.\n    \"\"\"\nanalytics: list[prisma.models.AnalyticsTracker]\ntotal_count: int\npage: int\npage_size: int\ntotal_pages: int", "successors": []}], "functions": [], "classes": []}, {"name": "FeaturedAgentResponse", "type": "CFG", "blocks": [{"id": 9, "label": "#9\n\"\"\"\n    Represents a response containing a list of featured agents.\n\n    Attributes:\n        featured_agents (list[FeaturedAgent]): The list of featured agents.\n        total_count (int): The total count of featured agents.\n        page (int): The current page number.\n        page_size (int): The number of agents per page.\n        total_pages (int): The total number of pages.\n    \"\"\"\nfeatured_agents: list[prisma.models.FeaturedAgent]\ntotal_count: int\npage: int\npage_size: int\ntotal_pages: int", "successors": []}], "functions": [], "classes": []}]}
{"file_name": "105.json", "name": "105.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1", "successors": []}], "functions": [], "classes": [{"name": "Node", "type": "CFG", "blocks": [{"id": 3, "label": "#3", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 5, "label": "#5\nself.results = results\nself.next = next", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "LinkedList", "type": "CFG", "blocks": [{"id": 9, "label": "#9", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 11, "label": "#11\nself.head = None\nself.tail = None", "successors": []}], "functions": [], "classes": []}, {"name": "move_to_front", "type": "CFG", "blocks": [{"id": 14, "label": "#14\npass", "successors": []}], "functions": [], "classes": []}, {"name": "append_to_front", "type": "CFG", "blocks": [{"id": 17, "label": "#17\npass", "successors": []}], "functions": [], "classes": []}, {"name": "remove_from_tail", "type": "CFG", "blocks": [{"id": 20, "label": "#20\npass", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "Cache", "type": "CFG", "blocks": [{"id": 24, "label": "#24", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 26, "label": "#26\nself.MAX_SIZE = MAX_SIZE\nself.size = 0\nself.lookup = {}\nself.linked_list = LinkedList()", "successors": []}], "functions": [], "classes": []}, {"name": "get", "type": "CFG", "blocks": [{"id": 29, "label": "#29\n\"\"\"Get the stored query result from the cache.\n\n        Accessing a node updates its position to the front of the LRU list.\n        \"\"\"\nnode = self.lookup.get(query)\nif node is None:", "successors": [{"id": 30, "label": "#30\nreturn None", "successors": []}, {"id": 31, "label": "#31\nself.linked_list.move_to_front(node)\nreturn node.results", "successors": []}]}], "functions": [], "classes": []}, {"name": "set", "type": "CFG", "blocks": [{"id": 36, "label": "#36\n\"\"\"Set the result for the given query key in the cache.\n\n        When updating an entry, updates its position to the front of the LRU list.\n        If the entry is new and the cache is at capacity, removes the oldest entry\n        before the new entry is added.\n        \"\"\"\nnode = self.lookup.get(query)\nif node is not None:", "successors": [{"id": 37, "label": "#37\nnode.results = results\nself.linked_list.move_to_front(node)", "successors": []}, {"id": 39, "label": "#39\nif self.size == self.MAX_SIZE:", "successors": [{"id": 40, "label": "#40\nself.lookup.pop(self.linked_list.tail.query, None)\nself.linked_list.remove_from_tail()", "successors": [{"id": 41, "label": "#41\nnew_node = Node(results)\nself.linked_list.append_to_front(new_node)\nself.lookup[query] = new_node", "successors": []}]}, {"id": 42, "label": "#42\nself.size += 1", "successors": []}]}]}], "functions": [], "classes": []}], "classes": []}]}
{"file_name": "106.json", "name": "106.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom enum import Enum\nfrom typing import Literal\nfrom e2b_code_interpreter import Sandbox\nfrom pydantic import SecretStr\nfrom backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema\nfrom backend.data.model import APIKeyCredentials, CredentialsField, CredentialsMetaInput, SchemaField\nfrom backend.integrations.providers import ProviderName\nTEST_CREDENTIALS = APIKeyCredentials(id=\n    '01234567-89ab-cdef-0123-456789abcdef', provider='e2b', api_key=\n    SecretStr('mock-e2b-api-key'), title='Mock E2B API key', expires_at=None)\nTEST_CREDENTIALS_INPUT = {'provider': TEST_CREDENTIALS.provider, 'id':\n    TEST_CREDENTIALS.id, 'type': TEST_CREDENTIALS.type, 'title':\n    TEST_CREDENTIALS.type}", "successors": []}], "functions": [], "classes": [{"name": "ProgrammingLanguage", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nPYTHON = 'python'\nJAVASCRIPT = 'js'\nBASH = 'bash'\nR = 'r'\nJAVA = 'java'", "successors": []}], "functions": [], "classes": []}, {"name": "CodeExecutionBlock", "type": "CFG", "blocks": [{"id": 6, "label": "#6", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 14, "label": "#14\nsuper().__init__(id='0b02b072-abe7-11ef-8372-fb5d162dd712', description=\n    'Executes code in an isolated sandbox environment with internet access.',\n    categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=\n    CodeExecutionBlock.Input, output_schema=CodeExecutionBlock.Output,\n    test_credentials=TEST_CREDENTIALS, test_input={'credentials':\n    TEST_CREDENTIALS_INPUT, 'code': \"print('Hello World')\", 'language':\n    ProgrammingLanguage.PYTHON.value, 'setup_commands': [], 'timeout': 300,\n    'template_id': ''}, test_output=[('response', 'Hello World'), (\n    'stdout_logs', 'Hello World\\n')], test_mock={'execute_code': lambda\n    code, language, setup_commands, timeout, api_key, template_id: (\n    'Hello World', 'Hello World\\n', '')})", "successors": []}], "functions": [], "classes": []}, {"name": "execute_code", "type": "CFG", "blocks": [{"id": 17, "label": "#17\ntry:", "successors": [{"id": 18, "label": "#18\nsandbox = None\nif template_id:", "successors": [{"id": 21, "label": "#21\nsandbox = Sandbox(template=template_id, api_key=api_key, timeout=timeout)", "successors": [{"id": 22, "label": "#22\nif not sandbox:", "successors": [{"id": 24, "label": "#24\nraise Exception('Sandbox not created')", "successors": []}, {"id": 25, "label": "#25\nfor cmd in setup_commands:", "successors": [{"id": 27, "label": "#27\nsandbox.commands.run(cmd)", "successors": []}, {"id": 28, "label": "#28\nexecution = sandbox.run_code(code, language=language.value, on_error=lambda\n    e: sandbox.kill())\nif execution.error:", "successors": [{"id": 29, "label": "#29\nraise Exception(execution.error)", "successors": []}, {"id": 30, "label": "#30\nresponse = execution.text\nstdout_logs = ''.join(execution.logs.stdout)\nstderr_logs = ''.join(execution.logs.stderr)\nreturn response, stdout_logs, stderr_logs", "successors": []}]}]}]}]}, {"id": 23, "label": "#23\nsandbox = Sandbox(api_key=api_key, timeout=timeout)", "successors": []}]}, {"id": 19, "label": "#19\nraise e", "successors": []}]}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 36, "label": "#36\ntry:", "successors": [{"id": 37, "label": "#37\nresponse, stdout_logs, stderr_logs = self.execute_code(input_data.code,\n    input_data.language, input_data.setup_commands, input_data.timeout,\n    credentials.api_key.get_secret_value(), input_data.template_id)\nif response:", "successors": [{"id": 40, "label": "#40\nyield 'response', response", "successors": [{"id": 41, "label": "#41\nif stdout_logs:", "successors": [{"id": 43, "label": "#43\nyield 'stdout_logs', stdout_logs", "successors": [{"id": 44, "label": "#44\nif stderr_logs:", "successors": [{"id": 46, "label": "#46\nyield 'stderr_logs', stderr_logs", "successors": []}]}]}]}]}]}, {"id": 38, "label": "#38\nyield 'error', str(e)", "successors": []}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 8, "label": "#8\ncredentials: CredentialsMetaInput[Literal[ProviderName.E2B], Literal['api_key']\n    ] = CredentialsField(description=\n    'Enter your api key for the E2B Sandbox. You can get it in here - https://e2b.dev/docs'\n    )\nsetup_commands: list[str] = SchemaField(description=\n    \"\"\"Shell commands to set up the sandbox before running the code. You can use `curl` or `git` to install your desired Debian based package manager. `pip` and `npm` are pre-installed.\n\nThese commands are executed with `sh`, in the foreground.\"\"\"\n    , placeholder='pip install cowsay', default=[], advanced=False)\ncode: str = SchemaField(description='Code to execute in the sandbox',\n    placeholder=\"print('Hello, World!')\", default='', advanced=False)\nlanguage: ProgrammingLanguage = SchemaField(description=\n    'Programming language to execute', default=ProgrammingLanguage.PYTHON,\n    advanced=False)\ntimeout: int = SchemaField(description='Execution timeout in seconds',\n    default=300)\ntemplate_id: str = SchemaField(description=\n    'You can use an E2B sandbox template by entering its ID here. Check out the E2B docs for more details: [E2B - Sandbox template](https://e2b.dev/docs/sandbox-template)'\n    , default='', advanced=True)", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 11, "label": "#11\nresponse: str = SchemaField(description='Response from code execution')\nstdout_logs: str = SchemaField(description=\n    'Standard output logs from execution')\nstderr_logs: str = SchemaField(description='Standard error logs from execution'\n    )\nerror: str = SchemaField(description='Error message if execution failed')", "successors": []}], "functions": [], "classes": []}]}]}
{"file_name": "107.json", "name": "107.json", "type": "CFG", "blocks": [{"id": 1, "label": "#1\n{'name': 'example_script', 'type': 'CFG', 'start_line': 1, 'end_line': 73,\n    'functions': [], 'classes': [{'name': 'StepThroughItemsBlock', 'type':\n    'class', 'start_line': 8, 'end_line': 73, 'functions': [{'name':\n    '__init__', 'type': 'function', 'start_line': 35, 'end_line': 54,\n    'functions': [], 'classes': [], 'simplified_code':\n    \"\"\"    def __init__(self):\n        super().__init__(\n            id=\"f66a3543-28d3-4ab5-8945-9b336371e2ce\",\n            input_schema=StepThroughItemsBlock.Input,\n            output_schema=StepThroughItemsBlock.Output,\n            categories={BlockCategory.LOGIC},\n            description=\"Iterates over a list or dictionary and outputs each item.\",\n            test_input={\"items\": [1, 2, 3, {\"key1\": \"value1\", \"key2\": \"value2\"}]},\n            test_output=[\n                (\"item\", 1),\n                (\"key\", 0),\n                (\"item\", 2),\n                (\"key\", 1),\n                (\"item\", 3),\n                (\"key\", 2),\n                (\"item\", {\"key1\": \"value1\", \"key2\": \"value2\"}),\n                (\"key\", 3),\n            ],\n            test_mock={},\n        )\"\"\"\n    , 'blocks': [{'id': 1, 'label': 'def __init__(self):', 'successors': [2\n    ]}, {'id': 2, 'label':\n    \"\"\"super().__init__(\n    id=\"f66a3543-28d3-4ab5-8945-9b336371e2ce\",\n    input_schema=StepThroughItemsBlock.Input,\n    output_schema=StepThroughItemsBlock.Output,\n    categories={BlockCategory.LOGIC},\n    description=\"Iterates over a list or dictionary and outputs each item.\",\n    test_input={\"items\": [1, 2, 3, {\"key1\": \"value1\", \"key2\": \"value2\"}]},\n    test_output=[\n        (\"item\", 1),\n        (\"key\", 0),\n        (\"item\", 2),\n        (\"key\", 1),\n        (\"item\", 3),\n        (\"key\", 2),\n        (\"item\", {\"key1\": \"value1\", \"key2\": \"value2\"}),\n        (\"key\", 3),\n    ],\n    test_mock={},\n)\"\"\"\n    , 'successors': []}]}, {'name': 'run', 'type': 'function', 'start_line':\n    56, 'end_line': 73, 'functions': [], 'classes': [], 'simplified_code':\n    \"\"\"    def run(self, input_data: Input, **kwargs) -> BlockOutput:\n        for data in [input_data.items, input_data.items_object, input_data.items_str]:\n            if not data:\n                continue\n            if isinstance(data, str):\n                items = json.loads(data)\n            else:\n                items = data\n            if isinstance(items, dict):\n                # If items is a dictionary, iterate over its values\n                for item in items.values():\n                    yield \"item\", item\n                    yield \"key\", item\n            else:\n                # If items is a list, iterate over the list\n                for index, item in enumerate(items):\n                    yield \"item\", item\n                    yield \"key\", index\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    'for data in [input_data.items, input_data.items_object, input_data.items_str]:'\n    , 'successors': [2, 9]}, {'id': 2, 'label': 'if not data:',\n    'successors': [3, 4]}, {'id': 3, 'label': 'continue', 'successors': [9]\n    }, {'id': 4, 'label': 'if isinstance(data, str):', 'successors': [5, 6]\n    }, {'id': 5, 'label': 'items = json.loads(data)', 'successors': [7]}, {\n    'id': 6, 'label': 'items = data', 'successors': [7]}, {'id': 7, 'label':\n    'if isinstance(items, dict):', 'successors': [8, 10]}, {'id': 8,\n    'label':\n    \"\"\"for item in items.values():\n    yield \"item\", item\n    yield \"key\", item\"\"\"\n    , 'successors': [9]}, {'id': 9, 'label':\n    \"\"\"else:\n    for index, item in enumerate(items):\n        yield \"item\", item\n        yield \"key\", index\"\"\"\n    , 'successors': [1]}]}], 'classes': [{'name': 'Input', 'type': 'class',\n    'start_line': 9, 'end_line': 27, 'functions': [], 'classes': [],\n    'simplified_code':\n    \"\"\"    class Input(BlockSchema):\n        items: list = SchemaField(\n            advanced=False,\n            description=\"The list or dictionary of items to iterate over\",\n            placeholder=\"[1, 2, 3, 4, 5] or {'key1': 'value1', 'key2': 'value2'}\",\n            default=[],\n        )\n        items_object: dict = SchemaField(\n            advanced=False,\n            description=\"The list or dictionary of items to iterate over\",\n            placeholder=\"[1, 2, 3, 4, 5] or {'key1': 'value1', 'key2': 'value2'}\",\n            default={},\n        )\n        items_str: str = SchemaField(\n            advanced=False,\n            description=\"The list or dictionary of items to iterate over\",\n            placeholder=\"[1, 2, 3, 4, 5] or {'key1': 'value1', 'key2': 'value2'}\",\n            default=\"\",\n        )\"\"\"\n    , 'blocks': [{'id': 1, 'label': 'class Input(BlockSchema):',\n    'successors': [2, 3, 4]}, {'id': 2, 'label':\n    \"\"\"items: list = SchemaField(\n    advanced=False,\n    description=\"The list or dictionary of items to iterate over\",\n    placeholder=\"[1, 2, 3, 4, 5] or {'key1': 'value1', 'key2': 'value2'}\",\n    default=[],\n)\"\"\"\n    , 'successors': [3]}, {'id': 3, 'label':\n    \"\"\"items_object: dict = SchemaField(\n    advanced=False,\n    description=\"The list or dictionary of items to iterate over\",\n    placeholder=\"[1, 2, 3, 4, 5] or {'key1': 'value1', 'key2': 'value2'}\",\n    default={},\n)\"\"\"\n    , 'successors': [4]}, {'id': 4, 'label':\n    \"\"\"items_str: str = SchemaField(\n    advanced=False,\n    description=\"The list or dictionary of items to iterate over\",\n    placeholder=\"[1, 2, 3, 4, 5] or {'key1': 'value1', 'key2': 'value2'}\",\n    default=\"\",\n)\"\"\"\n    , 'successors': []}]}, {'name': 'Output', 'type': 'class', 'start_line':\n    29, 'end_line': 33, 'functions': [], 'classes': [], 'simplified_code':\n    \"\"\"    class Output(BlockSchema):\n        item: Any = SchemaField(description=\"The current item in the iteration\")\n        key: Any = SchemaField(\n            description=\"The key or index of the current item in the iteration\",\n        )\"\"\"\n    , 'blocks': [{'id': 1, 'label': 'class Output(BlockSchema):',\n    'successors': [2, 3]}, {'id': 2, 'label':\n    'item: Any = SchemaField(description=\"The current item in the iteration\")',\n    'successors': [3]}, {'id': 3, 'label':\n    'key: Any = SchemaField(description=\"The key or index of the current item in the iteration\",)'\n    , 'successors': []}]}], 'simplified_code':\n    \"\"\"class StepThroughItemsBlock(Block):\n        )\n\n        )\n\n        )\n\n                    yield \"key\", index\"\"\"\n    , 'blocks': [{'id': 1, 'label': 'class StepThroughItemsBlock(Block):',\n    'successors': [3, 4], '': 'foryield (key, index) index: , '}, {'id': 3,\n    'label': 'key', 'successors': []}, {'id': 4, 'label':\n    \"yield 'key', index\", 'successors': []}]}], 'simplified_code':\n    \"\"\"from typing import Any\n\nfrom backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema\nfrom backend.data.model import SchemaField\nfrom backend.util.json import json\n\n\n                    yield \"key\", index\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"from typing import Any\n\nfrom backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema\nfrom backend.data.model import SchemaField\nfrom backend.util.json import json\"\"\"\n    , 'successors': [2]}, {'id': 2, 'label': 'yield \"key\", index',\n    'successors': []}]}", "successors": []}], "functions": [], "classes": []}
{"file_name": "108.json", "name": "108.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom base64 import b64encode\nfrom urllib.parse import urlencode\nfrom backend.data.model import OAuth2Credentials\nfrom backend.integrations.providers import ProviderName\nfrom backend.util.request import requests\nfrom .base import BaseOAuthHandler", "successors": []}], "functions": [], "classes": [{"name": "NotionOAuthHandler", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"\n    Based on the documentation at https://developers.notion.com/docs/authorization\n\n    Notes:\n    - Notion uses non-expiring access tokens and therefore doesn't have a refresh flow\n    - Notion doesn't use scopes\n    \"\"\"\nPROVIDER_NAME = ProviderName.NOTION", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 5, "label": "#5\nself.client_id = client_id\nself.client_secret = client_secret\nself.redirect_uri = redirect_uri\nself.auth_base_url = 'https://api.notion.com/v1/oauth/authorize'\nself.token_url = 'https://api.notion.com/v1/oauth/token'", "successors": []}], "functions": [], "classes": []}, {"name": "get_login_url", "type": "CFG", "blocks": [{"id": 8, "label": "#8\nparams = {'client_id': self.client_id, 'redirect_uri': self.redirect_uri,\n    'response_type': 'code', 'owner': 'user', 'state': state}\nreturn f'{self.auth_base_url}?{urlencode(params)}'", "successors": []}], "functions": [], "classes": []}, {"name": "exchange_code_for_tokens", "type": "CFG", "blocks": [{"id": 12, "label": "#12\nrequest_body = {'grant_type': 'authorization_code', 'code': code,\n    'redirect_uri': self.redirect_uri}\nauth_str = b64encode(f'{self.client_id}:{self.client_secret}'.encode()).decode(\n    )\nheaders = {'Authorization': f'Basic {auth_str}', 'Accept': 'application/json'}\nresponse = requests.post(self.token_url, json=request_body, headers=headers)\ntoken_data = response.json()\nemail = token_data['owner']['person']['email'] if 'person' in token_data[\n    'owner'] and 'email' in token_data['owner']['person'] else None\nreturn OAuth2Credentials(provider=self.PROVIDER_NAME, title=token_data.get(\n    'workspace_name'), username=email, access_token=token_data[\n    'access_token'], refresh_token=None, access_token_expires_at=None,\n    refresh_token_expires_at=None, scopes=[], metadata={'owner': token_data\n    ['owner'], 'bot_id': token_data['bot_id'], 'workspace_id': token_data[\n    'workspace_id'], 'workspace_name': token_data.get('workspace_name'),\n    'workspace_icon': token_data.get('workspace_icon')})", "successors": []}], "functions": [], "classes": []}, {"name": "revoke_tokens", "type": "CFG", "blocks": [{"id": 16, "label": "#16\nreturn False", "successors": []}], "functions": [], "classes": []}, {"name": "_refresh_tokens", "type": "CFG", "blocks": [{"id": 20, "label": "#20\nreturn credentials", "successors": []}], "functions": [], "classes": []}, {"name": "needs_refresh", "type": "CFG", "blocks": [{"id": 24, "label": "#24\nreturn False", "successors": []}], "functions": [], "classes": []}], "classes": []}]}
{"file_name": "109.json", "name": "109.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nif __name__ == '__main__':", "successors": [{"id": 29, "label": "#29\nimport doctest\ndoctest.testmod()", "successors": []}]}], "functions": [{"name": "logical_left_shift", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"\n    Take in 2 positive integers.\n    'number' is the integer to be logically left shifted 'shift_amount' times.\n    i.e. (number << shift_amount)\n    Return the shifted binary representation.\n\n    >>> logical_left_shift(0, 1)\n    '0b00'\n    >>> logical_left_shift(1, 1)\n    '0b10'\n    >>> logical_left_shift(1, 5)\n    '0b100000'\n    >>> logical_left_shift(17, 2)\n    '0b1000100'\n    >>> logical_left_shift(1983, 4)\n    '0b111101111110000'\n    >>> logical_left_shift(1, -1)\n    Traceback (most recent call last):\n    ValueError: both inputs must be positive integers\n    \"\"\"\nif number < 0 or shift_amount < 0:", "successors": [{"id": 4, "label": "#4\nraise ValueError('both inputs must be positive integers')", "successors": []}, {"id": 5, "label": "#5\nbinary_number = str(bin(number))\nbinary_number += '0' * shift_amount\nreturn binary_number", "successors": []}]}], "functions": [], "classes": []}, {"name": "logical_right_shift", "type": "CFG", "blocks": [{"id": 10, "label": "#10\n\"\"\"\n    Take in positive 2 integers.\n    'number' is the integer to be logically right shifted 'shift_amount' times.\n    i.e. (number >>> shift_amount)\n    Return the shifted binary representation.\n\n    >>> logical_right_shift(0, 1)\n    '0b0'\n    >>> logical_right_shift(1, 1)\n    '0b0'\n    >>> logical_right_shift(1, 5)\n    '0b0'\n    >>> logical_right_shift(17, 2)\n    '0b100'\n    >>> logical_right_shift(1983, 4)\n    '0b1111011'\n    >>> logical_right_shift(1, -1)\n    Traceback (most recent call last):\n    ValueError: both inputs must be positive integers\n    \"\"\"\nif number < 0 or shift_amount < 0:", "successors": [{"id": 11, "label": "#11\nraise ValueError('both inputs must be positive integers')", "successors": []}, {"id": 12, "label": "#12\nbinary_number = str(bin(number))[2:]\nif shift_amount >= len(binary_number):", "successors": [{"id": 14, "label": "#14\nreturn '0b0'", "successors": []}, {"id": 15, "label": "#15\nshifted_binary_number = binary_number[:len(binary_number) - shift_amount]\nreturn '0b' + shifted_binary_number", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "arithmetic_right_shift", "type": "CFG", "blocks": [{"id": 20, "label": "#20\n\"\"\"\n    Take in 2 integers.\n    'number' is the integer to be arithmetically right shifted 'shift_amount' times.\n    i.e. (number >> shift_amount)\n    Return the shifted binary representation.\n\n    >>> arithmetic_right_shift(0, 1)\n    '0b00'\n    >>> arithmetic_right_shift(1, 1)\n    '0b00'\n    >>> arithmetic_right_shift(-1, 1)\n    '0b11'\n    >>> arithmetic_right_shift(17, 2)\n    '0b000100'\n    >>> arithmetic_right_shift(-17, 2)\n    '0b111011'\n    >>> arithmetic_right_shift(-1983, 4)\n    '0b111110000100'\n    \"\"\"\nif number >= 0:", "successors": [{"id": 21, "label": "#21\nbinary_number = '0' + str(bin(number)).strip('-')[2:]", "successors": [{"id": 22, "label": "#22\nif shift_amount >= len(binary_number):", "successors": [{"id": 24, "label": "#24\nreturn '0b' + binary_number[0] * len(binary_number)", "successors": []}, {"id": 25, "label": "#25\nreturn '0b' + binary_number[0] * shift_amount + binary_number[:len(\n    binary_number) - shift_amount]", "successors": []}]}]}, {"id": 23, "label": "#23\nbinary_number_length = len(bin(number)[3:])\nbinary_number = bin(abs(number) - (1 << binary_number_length))[3:]\nbinary_number = '1' + '0' * (binary_number_length - len(binary_number)\n    ) + binary_number", "successors": []}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "110.json", "name": "110.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport prisma\nAGENT_NODE_INCLUDE: prisma.types.AgentNodeInclude = {'Input': True,\n    'Output': True, 'Webhook': True, 'AgentBlock': True}\nAGENT_GRAPH_INCLUDE: prisma.types.AgentGraphInclude = {'AgentNodes': {\n    'include': AGENT_NODE_INCLUDE}}\nEXECUTION_RESULT_INCLUDE: prisma.types.AgentNodeExecutionInclude = {'Input':\n    True, 'Output': True, 'AgentNode': True, 'AgentGraphExecution': True}\nGRAPH_EXECUTION_INCLUDE: prisma.types.AgentGraphExecutionInclude = {\n    'AgentNodeExecutions': {'include': {'Input': True, 'Output': True,\n    'AgentNode': True, 'AgentGraphExecution': True}}}\nINTEGRATION_WEBHOOK_INCLUDE: prisma.types.IntegrationWebhookInclude = {\n    'AgentNodes': {'include': AGENT_NODE_INCLUDE}}", "successors": []}], "functions": [], "classes": []}
{"file_name": "111.json", "name": "111.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport sentry_sdk\nfrom backend.util.settings import Settings", "successors": []}], "functions": [{"name": "sentry_init", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nsentry_dsn = Settings().secrets.sentry_dsn\nsentry_sdk.init(dsn=sentry_dsn, traces_sample_rate=1.0,\n    profiles_sample_rate=1.0)", "successors": []}], "functions": [], "classes": []}], "classes": []}
{"file_name": "112.json", "name": "112.json", "type": "CFG", "blocks": [{"id": 1, "label": "#1\n{'name': 'example_script', 'type': 'CFG', 'start_line': 1, 'end_line': 12,\n    'functions': [], 'classes': [{'name': 'MockObject', 'type': 'class',\n    'start_line': 1, 'end_line': 12, 'functions': [{'name': '__init__',\n    'type': 'function', 'start_line': 2, 'end_line': 3, 'functions': [],\n    'classes': [], 'simplified_code':\n    \"\"\"    def __init__(self, **kwargs):\n        self.__dict__.update(kwargs)\"\"\"\n    , 'blocks': [{'id': 1, 'label': 'def __init__(self, **kwargs):',\n    'successors': [2]}, {'id': 2, 'label': 'self.__dict__.update(kwargs)',\n    'successors': []}]}, {'name': '__getattr__', 'type': 'function',\n    'start_line': 5, 'end_line': 6, 'functions': [], 'classes': [],\n    'simplified_code':\n    \"\"\"    def __getattr__(self, name):\n        return self.__dict__.get(name)\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"def __getattr__(self, name):\n    return self.__dict__.get(name)\"\"\",\n    'successors': []}]}, {'name': '__call__', 'type': 'function',\n    'start_line': 8, 'end_line': 9, 'functions': [], 'classes': [],\n    'simplified_code':\n    \"\"\"    def __call__(self, *args, **kwargs):\n        return self\"\"\",\n    'blocks': [{'id': 1, 'label': 'def __call__(self, *args, **kwargs):',\n    'successors': [2]}, {'id': 2, 'label': 'return self', 'successors': []}\n    ]}, {'name': '__setattr__', 'type': 'function', 'start_line': 11,\n    'end_line': 12, 'functions': [], 'classes': [], 'simplified_code':\n    \"\"\"    def __setattr__(self, name, value):\n        self.__dict__[name] = value\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"def __setattr__(self, name, value):\n    self.__dict__[name] = value\"\"\",\n    'successors': []}]}], 'simplified_code':\n    \"\"\"class MockObject:\n        self.__dict__.update(kwargs)\n\n        return self.__dict__.get(name)\n\n        return self\n\n        self.__dict__[name] = value\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"class MockObject:\n    def __init__(self, **kwargs):\n        self.__dict__.update(kwargs)\"\"\"\n    , 'successors': [2]}, {'id': 2, 'label':\n    \"\"\"def __getattr__(self, name):\n        return self.__dict__.get(name)\"\"\",\n    'successors': [3]}, {'id': 3, 'label':\n    \"\"\"def __setattr__(self, name, value):\n        self.__dict__[name] = value\n        return self\"\"\"\n    , 'successors': []}]}], 'simplified_code':\n    '        self.__dict__[name] = value', 'blocks': [{'id': 1, 'label':\n    'self.__dict__[name] = value', 'successors': []}]}", "successors": []}], "functions": [], "classes": []}
{"file_name": "113.json", "name": "113.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom typing import Literal\nimport googlemaps\nfrom pydantic import BaseModel, SecretStr\nfrom backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema\nfrom backend.data.model import APIKeyCredentials, CredentialsField, CredentialsMetaInput, SchemaField\nfrom backend.integrations.providers import ProviderName\nTEST_CREDENTIALS = APIKeyCredentials(id=\n    '01234567-89ab-cdef-0123-456789abcdef', provider='google_maps', api_key\n    =SecretStr('mock-google-maps-api-key'), title=\n    'Mock Google Maps API key', expires_at=None)\nTEST_CREDENTIALS_INPUT = {'provider': TEST_CREDENTIALS.provider, 'id':\n    TEST_CREDENTIALS.id, 'type': TEST_CREDENTIALS.type, 'title':\n    TEST_CREDENTIALS.type}", "successors": []}], "functions": [], "classes": [{"name": "Place", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nname: str\naddress: str\nphone: str\nrating: float\nreviews: int\nwebsite: str", "successors": []}], "functions": [], "classes": []}, {"name": "GoogleMapsSearchBlock", "type": "CFG", "blocks": [{"id": 6, "label": "#6", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 14, "label": "#14\nsuper().__init__(id='f47ac10b-58cc-4372-a567-0e02b2c3d479', description=\n    'This block searches for local businesses using Google Maps API.',\n    categories={BlockCategory.SEARCH}, input_schema=GoogleMapsSearchBlock.\n    Input, output_schema=GoogleMapsSearchBlock.Output, test_input={\n    'credentials': TEST_CREDENTIALS_INPUT, 'query':\n    'restaurants in new york', 'radius': 5000, 'max_results': 5},\n    test_output=[('place', {'name': 'Test Restaurant', 'address':\n    '123 Test St, New York, NY 10001', 'phone': '+1 (555) 123-4567',\n    'rating': 4.5, 'reviews': 100, 'website': 'https://testrestaurant.com'}\n    )], test_mock={'search_places': lambda *args, **kwargs: [{'name':\n    'Test Restaurant', 'address': '123 Test St, New York, NY 10001',\n    'phone': '+1 (555) 123-4567', 'rating': 4.5, 'reviews': 100, 'website':\n    'https://testrestaurant.com'}]}, test_credentials=TEST_CREDENTIALS)", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 17, "label": "#17\nplaces = self.search_places(credentials.api_key, input_data.query,\n    input_data.radius, input_data.max_results)", "successors": [{"id": 18, "label": "#18\nfor place in places:", "successors": [{"id": 19, "label": "#19\nyield 'place', place", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "search_places", "type": "CFG", "blocks": [{"id": 24, "label": "#24\nclient = googlemaps.Client(key=api_key.get_secret_value())\nreturn self._search_places(client, query, radius, max_results)", "successors": []}], "functions": [], "classes": []}, {"name": "_search_places", "type": "CFG", "blocks": [{"id": 28, "label": "#28\nresults = []\nnext_page_token = None", "successors": [{"id": 29, "label": "#29\nwhile len(results) < max_results:", "successors": [{"id": 30, "label": "#30\nresponse = client.places(query=query, radius=radius, page_token=next_page_token\n    )", "successors": [{"id": 32, "label": "#32\nfor place in response['results']:", "successors": [{"id": 33, "label": "#33\nif len(results) >= max_results:", "successors": [{"id": 36, "label": "#36\nplace_details = client.place(place['place_id'])['result']\nresults.append(Place(name=place_details.get('name', ''), address=\n    place_details.get('formatted_address', ''), phone=place_details.get(\n    'formatted_phone_number', ''), rating=place_details.get('rating', 0),\n    reviews=place_details.get('user_ratings_total', 0), website=\n    place_details.get('website', '')))", "successors": []}, {"id": 34, "label": "#34\nnext_page_token = response.get('next_page_token')\nif not next_page_token:", "successors": [{"id": 31, "label": "#31\nreturn results", "successors": []}]}]}]}]}]}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 8, "label": "#8\ncredentials: CredentialsMetaInput[Literal[ProviderName.GOOGLE_MAPS],\n    Literal['api_key']] = CredentialsField(description='Google Maps API Key')\nquery: str = SchemaField(description='Search query for local businesses',\n    placeholder=\"e.g., 'restaurants in New York'\")\nradius: int = SchemaField(description='Search radius in meters (max 50000)',\n    default=5000, ge=1, le=50000)\nmax_results: int = SchemaField(description=\n    'Maximum number of results to return (max 60)', default=20, ge=1, le=60)", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 11, "label": "#11\nplace: Place = SchemaField(description='Place found')\nerror: str = SchemaField(description='Error message if the search failed')", "successors": []}], "functions": [], "classes": []}]}]}
{"file_name": "114.json", "name": "114.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom backend.app import run_processes\nfrom backend.executor import DatabaseManager, ExecutionScheduler\nfrom backend.server.rest_api import AgentServer\nif __name__ == '__main__':", "successors": [{"id": 5, "label": "#5\nmain()", "successors": []}]}], "functions": [{"name": "main", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"\n    Run all the processes required for the AutoGPT-server REST API.\n    \"\"\"\nrun_processes(DatabaseManager(), ExecutionScheduler(), AgentServer())", "successors": []}], "functions": [], "classes": []}], "classes": []}
{"file_name": "115.json", "name": "115.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom typing import Literal\nfrom pydantic import SecretStr\nfrom backend.data.model import APIKeyCredentials, CredentialsField, CredentialsMetaInput\nfrom backend.integrations.providers import ProviderName\nJinaCredentials = APIKeyCredentials\nJinaCredentialsInput = CredentialsMetaInput[Literal[ProviderName.JINA],\n    Literal['api_key']]\nTEST_CREDENTIALS = APIKeyCredentials(id=\n    '01234567-89ab-cdef-0123-456789abcdef', provider='jina', api_key=\n    SecretStr('mock-jina-api-key'), title='Mock Jina API key', expires_at=None)\nTEST_CREDENTIALS_INPUT = {'provider': TEST_CREDENTIALS.provider, 'id':\n    TEST_CREDENTIALS.id, 'type': TEST_CREDENTIALS.type, 'title':\n    TEST_CREDENTIALS.type}", "successors": []}], "functions": [{"name": "JinaCredentialsField", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"\n    Creates a Jina credentials input on a block.\n\n    \"\"\"\nreturn CredentialsField(description=\n    'The Jina integration can be used with an API Key.')", "successors": []}], "functions": [], "classes": []}], "classes": []}
{"file_name": "116.json", "name": "116.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport logging\nfrom colorama import Fore, Style\nfrom google.cloud.logging_v2.handlers import CloudLoggingFilter, StructuredLogHandler\nfrom .utils import remove_color_codes", "successors": []}], "functions": [], "classes": [{"name": "FancyConsoleFormatter", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"\n    A custom logging formatter designed for console output.\n\n    This formatter enhances the standard logging output with color coding. The color\n    coding is based on the level of the log message, making it easier to distinguish\n    between different types of messages in the console output.\n\n    The color for each level is defined in the LEVEL_COLOR_MAP class attribute.\n    \"\"\"\nLEVEL_COLOR_MAP = {logging.DEBUG: Fore.LIGHTBLACK_EX, logging.INFO: Fore.\n    BLUE, logging.WARNING: Fore.YELLOW, logging.ERROR: Fore.RED, logging.\n    CRITICAL: Fore.RED + Style.BRIGHT}", "successors": []}], "functions": [{"name": "format", "type": "CFG", "blocks": [{"id": 5, "label": "#5\nif not hasattr(record, 'msg'):", "successors": [{"id": 6, "label": "#6\nrecord.msg = ''", "successors": [{"id": 7, "label": "#7\nlevel_color = ''\nif record.levelno in self.LEVEL_COLOR_MAP:", "successors": [{"id": 11, "label": "#11\nlevel_color = self.LEVEL_COLOR_MAP[record.levelno]\nrecord.levelname = f'{level_color}{record.levelname}{Style.RESET_ALL}'", "successors": [{"id": 12, "label": "#12\ncolor = getattr(record, 'color', level_color)\ncolor_is_specified = hasattr(record, 'color')\nif color and (record.levelno != logging.INFO or color_is_specified):", "successors": [{"id": 13, "label": "#13\nrecord.msg = f'{color}{record.msg}{Style.RESET_ALL}'", "successors": [{"id": 14, "label": "#14\nreturn super().format(record)", "successors": []}]}]}]}]}]}, {"id": 8, "label": "#8\nif type(record.msg) is not str:", "successors": [{"id": 9, "label": "#9\nrecord.msg = str(record.msg)", "successors": []}]}]}], "functions": [], "classes": []}], "classes": []}, {"name": "AGPTFormatter", "type": "CFG", "blocks": [{"id": 19, "label": "#19", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 21, "label": "#21\nsuper().__init__(*args, **kwargs)\nself.no_color = no_color", "successors": []}], "functions": [], "classes": []}, {"name": "format", "type": "CFG", "blocks": [{"id": 24, "label": "#24\nif not hasattr(record, 'msg'):", "successors": [{"id": 25, "label": "#25\nrecord.msg = ''", "successors": [{"id": 26, "label": "#26\nif record.msg and not getattr(record, 'preserve_color', False):", "successors": [{"id": 30, "label": "#30\nrecord.msg = remove_color_codes(record.msg)", "successors": [{"id": 31, "label": "#31\ntitle = getattr(record, 'title', '')\ntitle_color = getattr(record, 'title_color', '') or self.LEVEL_COLOR_MAP.get(\n    record.levelno, '')\nif title and title_color:", "successors": [{"id": 32, "label": "#32\ntitle = f'{title_color + Style.BRIGHT}{title}{Style.RESET_ALL}'", "successors": [{"id": 33, "label": "#33\nrecord.title = f'{title} ' if title else ''\nif self.no_color:", "successors": [{"id": 34, "label": "#34\nreturn remove_color_codes(super().format(record))", "successors": []}, {"id": 36, "label": "#36\nreturn super().format(record)", "successors": []}]}]}]}]}]}]}, {"id": 27, "label": "#27\nif type(record.msg) is not str:", "successors": [{"id": 28, "label": "#28\nrecord.msg = str(record.msg)", "successors": []}]}]}], "functions": [], "classes": []}], "classes": []}, {"name": "StructuredLoggingFormatter", "type": "CFG", "blocks": [{"id": 42, "label": "#42", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 44, "label": "#44\nself.cloud_logging_filter = CloudLoggingFilter()\nsuper().__init__()", "successors": []}], "functions": [], "classes": []}, {"name": "format", "type": "CFG", "blocks": [{"id": 47, "label": "#47\nself.cloud_logging_filter.filter(record)\nreturn super().format(record)", "successors": []}], "functions": [], "classes": []}], "classes": []}]}
{"file_name": "117.json", "name": "117.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom typing import Type\nimport pytest\nfrom backend.data.block import Block, get_blocks\nfrom backend.util.test import execute_block_test", "successors": []}], "functions": [{"name": "test_available_blocks", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nexecute_block_test(block())", "successors": []}], "functions": [], "classes": []}], "classes": []}
{"file_name": "118.json", "name": "118.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\n\"\"\"\nauthor: Aayush Soni\nGiven n pairs of parentheses, write a function to generate all\ncombinations of well-formed parentheses.\nInput: n = 2\nOutput: [\"(())\",\"()()\"]\nLeetcode link: https://leetcode.com/problems/generate-parentheses/description/\n\"\"\"\nif __name__ == '__main__':", "successors": [{"id": 16, "label": "#16\nimport doctest\ndoctest.testmod()", "successors": []}]}], "functions": [{"name": "backtrack", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"\n    Generate valid combinations of balanced parentheses using recursion.\n\n    :param partial: A string representing the current combination.\n    :param open_count: An integer representing the count of open parentheses.\n    :param close_count: An integer representing the count of close parentheses.\n    :param n: An integer representing the total number of pairs.\n    :param result: A list to store valid combinations.\n    :return: None\n\n    This function uses recursion to explore all possible combinations,\n    ensuring that at each step, the parentheses remain balanced.\n\n    Example:\n    >>> result = []\n    >>> backtrack(\"\", 0, 0, 2, result)\n    >>> result\n    ['(())', '()()']\n    \"\"\"\nif len(partial) == 2 * n:", "successors": [{"id": 4, "label": "#4\nresult.append(partial)\nreturn", "successors": []}, {"id": 5, "label": "#5\nif open_count < n:", "successors": [{"id": 7, "label": "#7\nbacktrack(partial + '(', open_count + 1, close_count, n, result)", "successors": [{"id": 8, "label": "#8\nif close_count < open_count:", "successors": [{"id": 9, "label": "#9\nbacktrack(partial + ')', open_count, close_count + 1, n, result)", "successors": []}]}]}]}]}], "functions": [], "classes": []}, {"name": "generate_parenthesis", "type": "CFG", "blocks": [{"id": 13, "label": "#13\n\"\"\"\n    Generate valid combinations of balanced parentheses for a given n.\n\n    :param n: An integer representing the number of pairs of parentheses.\n    :return: A list of strings with valid combinations.\n\n    This function uses a recursive approach to generate the combinations.\n\n    Time Complexity: O(2^(2n)) - In the worst case, we have 2^(2n) combinations.\n    Space Complexity: O(n) - where 'n' is the number of pairs.\n\n    Example 1:\n    >>> generate_parenthesis(3)\n    ['((()))', '(()())', '(())()', '()(())', '()()()']\n\n    Example 2:\n    >>> generate_parenthesis(1)\n    ['()']\n    \"\"\"\nresult: list[str] = []\nbacktrack('', 0, 0, n, result)\nreturn result", "successors": []}], "functions": [], "classes": []}], "classes": []}
{"file_name": "119.json", "name": "119.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom timeit import timeit\nif __name__ == '__main__':", "successors": [{"id": 33, "label": "#33\nimport doctest\ndoctest.testmod()\nbenchmark()", "successors": []}]}], "functions": [{"name": "get_set_bits_count_using_brian_kernighans_algorithm", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"\n    Count the number of set bits in a 32 bit integer\n    >>> get_set_bits_count_using_brian_kernighans_algorithm(25)\n    3\n    >>> get_set_bits_count_using_brian_kernighans_algorithm(37)\n    3\n    >>> get_set_bits_count_using_brian_kernighans_algorithm(21)\n    3\n    >>> get_set_bits_count_using_brian_kernighans_algorithm(58)\n    4\n    >>> get_set_bits_count_using_brian_kernighans_algorithm(0)\n    0\n    >>> get_set_bits_count_using_brian_kernighans_algorithm(256)\n    1\n    >>> get_set_bits_count_using_brian_kernighans_algorithm(-1)\n    Traceback (most recent call last):\n    ValueError: the value of input must not be negative\n    \"\"\"\nif number < 0:", "successors": [{"id": 4, "label": "#4\nraise ValueError('the value of input must not be negative')", "successors": []}, {"id": 5, "label": "#5\nresult = 0", "successors": [{"id": 7, "label": "#7\nwhile number:", "successors": [{"id": 8, "label": "#8\nnumber &= number - 1\nresult += 1", "successors": []}, {"id": 9, "label": "#9\nreturn result", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "get_set_bits_count_using_modulo_operator", "type": "CFG", "blocks": [{"id": 13, "label": "#13\n\"\"\"\n    Count the number of set bits in a 32 bit integer\n    >>> get_set_bits_count_using_modulo_operator(25)\n    3\n    >>> get_set_bits_count_using_modulo_operator(37)\n    3\n    >>> get_set_bits_count_using_modulo_operator(21)\n    3\n    >>> get_set_bits_count_using_modulo_operator(58)\n    4\n    >>> get_set_bits_count_using_modulo_operator(0)\n    0\n    >>> get_set_bits_count_using_modulo_operator(256)\n    1\n    >>> get_set_bits_count_using_modulo_operator(-1)\n    Traceback (most recent call last):\n    ValueError: the value of input must not be negative\n    \"\"\"\nif number < 0:", "successors": [{"id": 14, "label": "#14\nraise ValueError('the value of input must not be negative')", "successors": []}, {"id": 15, "label": "#15\nresult = 0", "successors": [{"id": 17, "label": "#17\nwhile number:", "successors": [{"id": 18, "label": "#18\nif number % 2 == 1:", "successors": [{"id": 20, "label": "#20\nresult += 1", "successors": [{"id": 21, "label": "#21\nnumber >>= 1", "successors": []}]}]}, {"id": 19, "label": "#19\nreturn result", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "benchmark", "type": "CFG", "blocks": [{"id": 25, "label": "#25\n\"\"\"\n    Benchmark code for comparing 2 functions, with different length int values.\n    Brian Kernighan's algorithm is consistently faster than using modulo_operator.\n    \"\"\"", "successors": [{"id": 29, "label": "#29\nfor number in (25, 37, 58, 0):", "successors": [{"id": 30, "label": "#30\ndo_benchmark(number)\nprint()", "successors": []}]}]}], "functions": [{"name": "do_benchmark", "type": "CFG", "blocks": [{"id": 27, "label": "#27\nsetup = 'import __main__ as z'\nprint(f'Benchmark when number = {number!r}:')\nprint(\n    f'get_set_bits_count_using_modulo_operator(number) = {get_set_bits_count_using_modulo_operator(number)!r}'\n    )\ntiming = timeit(f'z.get_set_bits_count_using_modulo_operator({number})',\n    setup=setup)\nprint(f'timeit() runs in {timing} seconds')\nprint(\n    f'get_set_bits_count_using_brian_kernighans_algorithm(number) = {get_set_bits_count_using_brian_kernighans_algorithm(number)!r}'\n    )\ntiming = timeit(\n    f'z.get_set_bits_count_using_brian_kernighans_algorithm({number})',\n    setup=setup)\nprint(f'timeit() runs in {timing} seconds')", "successors": []}], "functions": [], "classes": []}], "classes": []}], "classes": []}
{"file_name": "120.json", "name": "120.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport inspect\nfrom abc import ABC, abstractmethod\nfrom enum import Enum\nfrom typing import Any, ClassVar, Generator, Generic, Optional, Type, TypeVar, cast, get_origin\nimport jsonref\nimport jsonschema\nfrom prisma.models import AgentBlock\nfrom pydantic import BaseModel\nfrom backend.util import json\nfrom backend.util.settings import Config\nfrom .model import CREDENTIALS_FIELD_NAME, ContributorDetails, Credentials, CredentialsMetaInput\napp_config = Config()\nBlockData = tuple[str, Any]\nBlockInput = dict[str, Any]\nBlockOutput = Generator[BlockData, None, None]\nCompletedBlockOutput = dict[str, list[Any]]\nBlockSchemaInputType = TypeVar('BlockSchemaInputType', bound=BlockSchema)\nBlockSchemaOutputType = TypeVar('BlockSchemaOutputType', bound=BlockSchema)", "successors": []}], "functions": [{"name": "get_blocks", "type": "CFG", "blocks": [{"id": 170, "label": "#170\nfrom backend.blocks import AVAILABLE_BLOCKS\nreturn AVAILABLE_BLOCKS", "successors": []}], "functions": [], "classes": []}, {"name": "initialize_blocks", "type": "CFG", "blocks": [{"id": 174, "label": "#174\nfor cls in get_blocks().values():", "successors": [{"id": 175, "label": "#175\nblock = cls()\nexisting_block = await AgentBlock.prisma().find_first(where={'OR': [{'id':\n    block.id}, {'name': block.name}]})", "successors": [{"id": 177, "label": "#177\nif not existing_block:", "successors": [{"id": 178, "label": "#178\nawait AgentBlock.prisma().create(data={'id': block.id, 'name': block.name,\n    'inputSchema': json.dumps(block.input_schema.jsonschema()),\n    'outputSchema': json.dumps(block.output_schema.jsonschema())})", "successors": []}, {"id": 179, "label": "#179\ninput_schema = json.dumps(block.input_schema.jsonschema())\noutput_schema = json.dumps(block.output_schema.jsonschema())\nif block.id != existing_block.id or block.name != existing_block.name or input_schema != existing_block.inputSchema or output_schema != existing_block.outputSchema:", "successors": [{"id": 181, "label": "#181\nawait AgentBlock.prisma().update(where={'id': existing_block.id}, data={\n    'id': block.id, 'name': block.name, 'inputSchema': input_schema,\n    'outputSchema': output_schema})", "successors": []}]}]}]}]}], "functions": [], "classes": []}, {"name": "get_block", "type": "CFG", "blocks": [{"id": 186, "label": "#186\ncls = get_blocks().get(block_id)\nreturn cls() if cls else None", "successors": []}], "functions": [], "classes": []}], "classes": [{"name": "BlockType", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nSTANDARD = 'Standard'\nINPUT = 'Input'\nOUTPUT = 'Output'\nNOTE = 'Note'\nWEBHOOK = 'Webhook'\nWEBHOOK_MANUAL = 'Webhook (manual)'\nAGENT = 'Agent'", "successors": []}], "functions": [], "classes": []}, {"name": "BlockCategory", "type": "CFG", "blocks": [{"id": 6, "label": "#6\nAI = 'Block that leverages AI to perform a task.'\nSOCIAL = 'Block that interacts with social media platforms.'\nTEXT = 'Block that processes text data.'\nSEARCH = 'Block that searches or extracts information from the internet.'\nBASIC = 'Block that performs basic operations.'\nINPUT = 'Block that interacts with input of the graph.'\nOUTPUT = 'Block that interacts with output of the graph.'\nLOGIC = 'Programming logic to control the flow of your agent'\nCOMMUNICATION = 'Block that interacts with communication platforms.'\nDEVELOPER_TOOLS = 'Developer tools such as GitHub blocks.'\nDATA = 'Block that interacts with structured data.'\nHARDWARE = 'Block that interacts with hardware.'\nAGENT = 'Block that interacts with other agents.'\nCRM = 'Block that interacts with CRM services.'", "successors": []}], "functions": [{"name": "dict", "type": "CFG", "blocks": [{"id": 8, "label": "#8\nreturn {'category': self.name, 'description': self.value}", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "BlockSchema", "type": "CFG", "blocks": [{"id": 13, "label": "#13\ncached_jsonschema: ClassVar[dict[str, Any]]", "successors": []}], "functions": [{"name": "jsonschema", "type": "CFG", "blocks": [{"id": 15, "label": "#15\nif cls.cached_jsonschema:", "successors": [{"id": 16, "label": "#16\nreturn cls.cached_jsonschema", "successors": []}, {"id": 17, "label": "#17\nmodel = jsonref.replace_refs(cls.model_json_schema(), merge_props=True)\ncls.cached_jsonschema = cast(dict[str, Any], ref_to_dict(model))", "successors": [{"id": 32, "label": "#32\nfor field in cls.cached_jsonschema.get('properties', {}).values():", "successors": [{"id": 33, "label": "#33\nif isinstance(field, dict) and 'advanced' not in field:", "successors": [{"id": 35, "label": "#35\nfield['advanced'] = True", "successors": []}]}, {"id": 34, "label": "#34\nreturn cls.cached_jsonschema", "successors": []}]}]}]}], "functions": [{"name": "ref_to_dict", "type": "CFG", "blocks": [{"id": 20, "label": "#20\nif isinstance(obj, dict):", "successors": [{"id": 21, "label": "#21\nkeys = {'allOf', 'anyOf', 'oneOf'}\none_key = next((k for k in keys if k in obj and len(obj[k]) == 1), None)\nif one_key:", "successors": [{"id": 27, "label": "#27\nobj.update(obj[one_key][0])", "successors": [{"id": 28, "label": "#28\nreturn {key: ref_to_dict(value) for key, value in obj.items() if not key.\n    startswith('$') and key != one_key}", "successors": []}]}]}, {"id": 23, "label": "#23\nif isinstance(obj, list):", "successors": [{"id": 24, "label": "#24\nreturn [ref_to_dict(item) for item in obj]", "successors": []}, {"id": 22, "label": "#22\nreturn obj", "successors": []}]}]}], "functions": [], "classes": []}], "classes": []}, {"name": "validate_data", "type": "CFG", "blocks": [{"id": 40, "label": "#40\nreturn json.validate_with_jsonschema(schema=cls.jsonschema(), data=data)", "successors": []}], "functions": [], "classes": []}, {"name": "validate_field", "type": "CFG", "blocks": [{"id": 44, "label": "#44\n\"\"\"\n        Validate the data against a specific property (one of the input/output name).\n        Returns the validation error message if the data does not match the schema.\n        \"\"\"\nmodel_schema = cls.jsonschema().get('properties', {})\nif not model_schema:", "successors": [{"id": 45, "label": "#45\nreturn f'Invalid model schema {cls}'", "successors": []}, {"id": 46, "label": "#46\nproperty_schema = model_schema.get(field_name)\nif not property_schema:", "successors": [{"id": 48, "label": "#48\nreturn f'Invalid property name {field_name}'", "successors": []}, {"id": 49, "label": "#49\ntry:", "successors": [{"id": 51, "label": "#51\njsonschema.validate(json.to_dict(data), property_schema)\nreturn None", "successors": []}, {"id": 52, "label": "#52\nreturn str(e)", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "get_fields", "type": "CFG", "blocks": [{"id": 58, "label": "#58\nreturn set(cls.model_fields.keys())", "successors": []}], "functions": [], "classes": []}, {"name": "get_required_fields", "type": "CFG", "blocks": [{"id": 62, "label": "#62\nreturn {field for field, field_info in cls.model_fields.items() if\n    field_info.is_required()}", "successors": []}], "functions": [], "classes": []}, {"name": "__pydantic_init_subclass__", "type": "CFG", "blocks": [{"id": 66, "label": "#66\n\"\"\"Validates the schema definition. Rules:\n        - Only one `CredentialsMetaInput` field may be present.\n          - This field MUST be called `credentials`.\n        - A field that is called `credentials` MUST be a `CredentialsMetaInput`.\n        \"\"\"\nsuper().__pydantic_init_subclass__(**kwargs)\ncls.cached_jsonschema = {}\ncredentials_fields = [field_name for field_name, info in cls.model_fields.\n    items() if inspect.isclass(info.annotation) and issubclass(get_origin(\n    info.annotation) or info.annotation, CredentialsMetaInput)]\nif len(credentials_fields) > 1:", "successors": [{"id": 67, "label": "#67\nraise ValueError(\n    f'{cls.__qualname__} can only have one CredentialsMetaInput field')", "successors": []}, {"id": 69, "label": "#69\nif len(credentials_fields) == 1 and credentials_fields[0", "successors": [{"id": 70, "label": "#70\nraise ValueError(\n    f\"CredentialsMetaInput field on {cls.__qualname__} must be named 'credentials'\"\n    )", "successors": []}, {"id": 72, "label": "#72\nif len(credentials_fields", "successors": [{"id": 73, "label": "#73\nraise TypeError(\n    f\"Field 'credentials' on {cls.__qualname__} must be of type {CredentialsMetaInput.__name__}\"\n    )", "successors": []}, {"id": 68, "label": "#68\nif (credentials_field := cls.model_fields.get(CREDENTIALS_FIELD_NAME)):", "successors": [{"id": 78, "label": "#78\ncredentials_input_type = cast(CredentialsMetaInput, credentials_field.\n    annotation)\ncredentials_input_type.validate_credentials_field_schema(cls)", "successors": []}]}]}]}]}], "functions": [], "classes": []}], "classes": []}, {"name": "EmptySchema", "type": "CFG", "blocks": [{"id": 83, "label": "#83\npass", "successors": []}], "functions": [], "classes": []}, {"name": "BlockManualWebhookConfig", "type": "CFG", "blocks": [{"id": 86, "label": "#86\n\"\"\"\n    Configuration model for webhook-triggered blocks on which\n    the user has to manually set up the webhook at the provider.\n    \"\"\"\nprovider: str\n\"\"\"The service provider that the webhook connects to\"\"\"\nwebhook_type: str\n\"\"\"\n    Identifier for the webhook type. E.g. GitHub has repo and organization level hooks.\n\n    Only for use in the corresponding `WebhooksManager`.\n    \"\"\"\nevent_filter_input: str = ''\n\"\"\"\n    Name of the block's event filter input.\n    Leave empty if the corresponding webhook doesn't have distinct event/payload types.\n    \"\"\"\nevent_format: str = '{event}'\n\"\"\"\n    Template string for the event(s) that a block instance subscribes to.\n    Applied individually to each event selected in the event filter input.\n\n    Example: `\"pull_request.{event}\"` -> `\"pull_request.opened\"`\n    \"\"\"", "successors": []}], "functions": [], "classes": []}, {"name": "BlockWebhookConfig", "type": "CFG", "blocks": [{"id": 89, "label": "#89\n\"\"\"\n    Configuration model for webhook-triggered blocks for which\n    the webhook can be automatically set up through the provider's API.\n    \"\"\"\nresource_format: str\n\"\"\"\n    Template string for the resource that a block instance subscribes to.\n    Fields will be filled from the block's inputs (except `payload`).\n\n    Example: `f\"{repo}/pull_requests\"` (note: not how it's actually implemented)\n\n    Only for use in the corresponding `WebhooksManager`.\n    \"\"\"", "successors": []}], "functions": [], "classes": []}, {"name": "Block", "type": "CFG", "blocks": [{"id": 92, "label": "#92", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 94, "label": "#94\n\"\"\"\n        Initialize the block with the given schema.\n\n        Args:\n            id: The unique identifier for the block, this value will be persisted in the\n                DB. So it should be a unique and constant across the application run.\n                Use the UUID format for the ID.\n            description: The description of the block, explaining what the block does.\n            contributors: The list of contributors who contributed to the block.\n            input_schema: The schema, defined as a Pydantic model, for the input data.\n            output_schema: The schema, defined as a Pydantic model, for the output data.\n            test_input: The list or single sample input data for the block, for testing.\n            test_output: The list or single expected output if the test_input is run.\n            test_mock: function names on the block implementation to mock on test run.\n            disabled: If the block is disabled, it will not be available for execution.\n            static_output: Whether the output links of the block are static by default.\n        \"\"\"\nself.id = id\nself.input_schema = input_schema\nself.output_schema = output_schema\nself.test_input = test_input\nself.test_output = test_output\nself.test_mock = test_mock\nself.test_credentials = test_credentials\nself.description = description\nself.categories = categories or set()\nself.contributors = contributors or set()\nself.disabled = disabled\nself.static_output = static_output\nself.block_type = block_type\nself.webhook_config = webhook_config\nself.execution_stats = {}\nif self.webhook_config:", "successors": [{"id": 95, "label": "#95\nif isinstance(self.webhook_config, BlockWebhookConfig):", "successors": [{"id": 97, "label": "#97\nif CREDENTIALS_FIELD_NAME not in self.input_schema.model_fields:", "successors": [{"id": 100, "label": "#100\nraise TypeError('credentials field is required on auto-setup webhook blocks')", "successors": []}, {"id": 101, "label": "#101\nself.block_type = BlockType.WEBHOOK", "successors": [{"id": 98, "label": "#98\nif self.webhook_config.event_filter_input:", "successors": [{"id": 103, "label": "#103\nevent_filter_field = self.input_schema.model_fields[self.webhook_config.\n    event_filter_input]\nif not (isinstance(event_filter_field.annotation, type) and issubclass(", "successors": [{"id": 105, "label": "#105\nraise NotImplementedError(\n    f'{self.name} has an invalid webhook event selector: field must be a BaseModel and all its fields must be boolean'\n    )", "successors": []}, {"id": 104, "label": "#104\nif 'payload' not in self.input_schema.model_fields:", "successors": [{"id": 108, "label": "#108\nraise TypeError(f\"{self.name} is webhook-triggered but has no 'payload' input\")", "successors": []}, {"id": 109, "label": "#109\nif not app_config.platform_base_url:", "successors": [{"id": 111, "label": "#111\nself.disabled = True", "successors": []}]}]}]}]}]}]}, {"id": 99, "label": "#99\nself.block_type = BlockType.WEBHOOK_MANUAL", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "create", "type": "CFG", "blocks": [{"id": 115, "label": "#115\nreturn cls()", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 119, "label": "#119\n\"\"\"\n        Run the block with the given input data.\n        Args:\n            input_data: The input data with the structure of input_schema.\n        Returns:\n            A Generator that yields (output_name, output_data).\n            output_name: One of the output name defined in Block's output_schema.\n            output_data: The data for the output_name, matching the defined schema.\n        \"\"\"\npass", "successors": []}], "functions": [], "classes": []}, {"name": "run_once", "type": "CFG", "blocks": [{"id": 122, "label": "#122\nfor name, data in self.run(input_data, **kwargs):", "successors": [{"id": 123, "label": "#123\nif name == output:", "successors": [{"id": 125, "label": "#125\nreturn data", "successors": []}]}, {"id": 124, "label": "#124\nraise ValueError(f'{self.name} did not produce any output for {output}')", "successors": []}]}], "functions": [], "classes": []}, {"name": "merge_stats", "type": "CFG", "blocks": [{"id": 131, "label": "#131\nfor key, value in stats.items():", "successors": [{"id": 132, "label": "#132\nif isinstance(value, dict):", "successors": [{"id": 134, "label": "#134\nself.execution_stats.setdefault(key, {}).update(value)", "successors": []}, {"id": 136, "label": "#136\nif isinstance(value, (int, float)):", "successors": [{"id": 137, "label": "#137\nself.execution_stats.setdefault(key, 0)\nself.execution_stats[key] += value", "successors": []}, {"id": 139, "label": "#139\nif isinstance(value, list):", "successors": [{"id": 140, "label": "#140\nself.execution_stats.setdefault(key, [])\nself.execution_stats[key].extend(value)", "successors": []}, {"id": 142, "label": "#142\nself.execution_stats[key] = value", "successors": []}]}]}]}, {"id": 133, "label": "#133\nreturn self.execution_stats", "successors": []}]}], "functions": [], "classes": []}, {"name": "name", "type": "CFG", "blocks": [{"id": 146, "label": "#146\nreturn self.__class__.__name__", "successors": []}], "functions": [], "classes": []}, {"name": "to_dict", "type": "CFG", "blocks": [{"id": 150, "label": "#150\nreturn {'id': self.id, 'name': self.name, 'inputSchema': self.input_schema.\n    jsonschema(), 'outputSchema': self.output_schema.jsonschema(),\n    'description': self.description, 'categories': [category.dict() for\n    category in self.categories], 'contributors': [contributor.model_dump() for\n    contributor in self.contributors], 'staticOutput': self.static_output,\n    'uiType': self.block_type.value}", "successors": []}], "functions": [], "classes": []}, {"name": "execute", "type": "CFG", "blocks": [{"id": 154, "label": "#154\nif (error := self.input_schema.validate_data(input_data)):", "successors": [{"id": 155, "label": "#155\nraise ValueError(f'Unable to execute block with invalid input data: {error}')", "successors": []}, {"id": 156, "label": "#156\nfor output_name, output_data in self.run(self.input_schema(**input_data),", "successors": [{"id": 158, "label": "#158\nif output_name == 'error':", "successors": [{"id": 160, "label": "#160\nraise RuntimeError(output_data)", "successors": []}, {"id": 161, "label": "#161\nif self.block_type == BlockType.STANDARD and (error := self.output_schema.", "successors": [{"id": 163, "label": "#163\nraise ValueError(f'Block produced an invalid output data: {error}')", "successors": []}, {"id": 164, "label": "#164\nyield output_name, output_data", "successors": []}]}]}]}]}], "functions": [], "classes": []}], "classes": []}]}
{"file_name": "121.json", "name": "121.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport time\nfrom backend.util.decorator import error_logged, time_measured", "successors": []}], "functions": [{"name": "example_function", "type": "CFG", "blocks": [{"id": 3, "label": "#3\ntime.sleep(0.5)\nreturn a + b + c", "successors": []}], "functions": [], "classes": []}, {"name": "example_function_with_error", "type": "CFG", "blocks": [{"id": 7, "label": "#7\nraise ValueError('This is a test error')", "successors": []}], "functions": [], "classes": []}, {"name": "test_timer_decorator", "type": "CFG", "blocks": [{"id": 11, "label": "#11\ninfo, res = example_function(1, 2, 3)\nassert info.cpu_time >= 0", "successors": [{"id": 13, "label": "#13\nassert info.wall_time >= 0.4", "successors": [{"id": 15, "label": "#15\nassert res == 6", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "test_error_decorator", "type": "CFG", "blocks": [{"id": 20, "label": "#20\nres = example_function_with_error(1, 2, 3)\nassert res is None", "successors": []}], "functions": [], "classes": []}], "classes": []}
{"file_name": "122.json", "name": "122.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom collections import defaultdict\nfrom datetime import datetime, timezone\nfrom multiprocessing import Manager\nfrom typing import Any, AsyncGenerator, Generator, Generic, TypeVar\nfrom prisma.enums import AgentExecutionStatus\nfrom prisma.models import AgentGraphExecution, AgentNodeExecution, AgentNodeExecutionInputOutput\nfrom pydantic import BaseModel\nfrom backend.data.block import BlockData, BlockInput, CompletedBlockOutput\nfrom backend.data.includes import EXECUTION_RESULT_INCLUDE, GRAPH_EXECUTION_INCLUDE\nfrom backend.data.queue import AsyncRedisEventBus, RedisEventBus\nfrom backend.util import json, mock\nfrom backend.util.settings import Config\nExecutionStatus = AgentExecutionStatus\nT = TypeVar('T')\nLIST_SPLIT = '_$_'\nDICT_SPLIT = '_#_'\nOBJC_SPLIT = '_@_'\nconfig = Config()", "successors": []}], "functions": [{"name": "create_graph_execution", "type": "CFG", "blocks": [{"id": 47, "label": "#47\n\"\"\"\n    Create a new AgentGraphExecution record.\n    Returns:\n        The id of the AgentGraphExecution and the list of ExecutionResult for each node.\n    \"\"\"\nresult = await AgentGraphExecution.prisma().create(data={'agentGraphId':\n    graph_id, 'agentGraphVersion': graph_version, 'executionStatus':\n    ExecutionStatus.QUEUED, 'AgentNodeExecutions': {'create': [{\n    'agentNodeId': node_id, 'executionStatus': ExecutionStatus.INCOMPLETE,\n    'Input': {'create': [{'name': name, 'data': json.dumps(data)} for name,\n    data in node_input.items()]}} for node_id, node_input in nodes_input]},\n    'userId': user_id}, include=GRAPH_EXECUTION_INCLUDE)", "successors": [{"id": 48, "label": "#48\nreturn result.id, [ExecutionResult.from_db(execution) for execution in \n    result.AgentNodeExecutions or []]", "successors": []}]}], "functions": [], "classes": []}, {"name": "upsert_execution_input", "type": "CFG", "blocks": [{"id": 52, "label": "#52\n\"\"\"\n    Insert AgentNodeExecutionInputOutput record for as one of AgentNodeExecution.Input.\n    If there is no AgentNodeExecution that has no `input_name` as input, create new one.\n\n    Args:\n        node_id: The id of the AgentNode.\n        graph_exec_id: The id of the AgentGraphExecution.\n        input_name: The name of the input data.\n        input_data: The input data to be inserted.\n        node_exec_id: [Optional] The id of the AgentNodeExecution that has no `input_name` as input. If not provided, it will find the eligible incomplete AgentNodeExecution or create a new one.\n\n    Returns:\n        * The id of the created or existing AgentNodeExecution.\n        * Dict of node input data, key is the input name, value is the input data.\n    \"\"\"\nexisting_execution = await AgentNodeExecution.prisma().find_first(where={**\n    {'id': node_exec_id} if node_exec_id else {}, 'agentNodeId': node_id,\n    'agentGraphExecutionId': graph_exec_id, 'executionStatus':\n    ExecutionStatus.INCOMPLETE, 'Input': {'every': {'name': {'not':\n    input_name}}}}, order={'addedTime': 'asc'}, include={'Input': True})", "successors": [{"id": 53, "label": "#53\njson_input_data = json.dumps(input_data)\nif existing_execution:", "successors": [{"id": 54, "label": "#54\nawait AgentNodeExecutionInputOutput.prisma().create(data={'name':\n    input_name, 'data': json_input_data, 'referencedByInputExecId':\n    existing_execution.id})", "successors": [{"id": 63, "label": "#63\nreturn existing_execution.id, {**{input_data.name: json.loads(input_data.\n    data) for input_data in existing_execution.Input or []}, input_name:\n    input_data}", "successors": []}]}, {"id": 56, "label": "#56\nif not node_exec_id:", "successors": [{"id": 57, "label": "#57\nresult = await AgentNodeExecution.prisma().create(data={'agentNodeId':\n    node_id, 'agentGraphExecutionId': graph_exec_id, 'executionStatus':\n    ExecutionStatus.INCOMPLETE, 'Input': {'create': {'name': input_name,\n    'data': json_input_data}}})", "successors": [{"id": 61, "label": "#61\nreturn result.id, {input_name: input_data}", "successors": []}]}, {"id": 59, "label": "#59\nraise ValueError(\n    f'NodeExecution {node_exec_id} not found or already has input {input_name}.'\n    )", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "upsert_execution_output", "type": "CFG", "blocks": [{"id": 67, "label": "#67\n\"\"\"\n    Insert AgentNodeExecutionInputOutput record for as one of AgentNodeExecution.Output.\n    \"\"\"\nawait AgentNodeExecutionInputOutput.prisma().create(data={'name':\n    output_name, 'data': json.dumps(output_data),\n    'referencedByOutputExecId': node_exec_id})", "successors": []}], "functions": [], "classes": []}, {"name": "update_graph_execution_start_time", "type": "CFG", "blocks": [{"id": 71, "label": "#71\nawait AgentGraphExecution.prisma().update(where={'id': graph_exec_id}, data\n    ={'executionStatus': ExecutionStatus.RUNNING, 'startedAt': datetime.now\n    (tz=timezone.utc)})", "successors": []}], "functions": [], "classes": []}, {"name": "update_graph_execution_stats", "type": "CFG", "blocks": [{"id": 75, "label": "#75\nstatus = ExecutionStatus.FAILED if stats.get('error'\n    ) else ExecutionStatus.COMPLETED\nres = await AgentGraphExecution.prisma().update(where={'id': graph_exec_id},\n    data={'executionStatus': status, 'stats': json.dumps(stats)})", "successors": [{"id": 76, "label": "#76\nif not res:", "successors": [{"id": 77, "label": "#77\nraise ValueError(f'Execution {graph_exec_id} not found.')", "successors": []}, {"id": 78, "label": "#78\nreturn ExecutionResult.from_graph(res)", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "update_node_execution_stats", "type": "CFG", "blocks": [{"id": 83, "label": "#83\nawait AgentNodeExecution.prisma().update(where={'id': node_exec_id}, data={\n    'stats': json.dumps(stats)})", "successors": []}], "functions": [], "classes": []}, {"name": "update_execution_status", "type": "CFG", "blocks": [{"id": 87, "label": "#87\nif status == ExecutionStatus.QUEUED and execution_data is None:", "successors": [{"id": 88, "label": "#88\nraise ValueError('Execution data must be provided when queuing an execution.')", "successors": []}, {"id": 89, "label": "#89\nnow = datetime.now(tz=timezone.utc)\ndata = {**{'executionStatus': status}, **{'queuedTime': now} if status ==\n    ExecutionStatus.QUEUED else {}, **{'startedTime': now} if status ==\n    ExecutionStatus.RUNNING else {}, **{'endedTime': now} if status ==\n    ExecutionStatus.FAILED else {}, **{'endedTime': now} if status ==\n    ExecutionStatus.COMPLETED else {}, **{'executionData': json.dumps(\n    execution_data)} if execution_data else {}, **{'stats': json.dumps(\n    stats)} if stats else {}}\nres = await AgentNodeExecution.prisma().update(where={'id': node_exec_id},\n    data=data, include=EXECUTION_RESULT_INCLUDE)", "successors": [{"id": 91, "label": "#91\nif not res:", "successors": [{"id": 92, "label": "#92\nraise ValueError(f'Execution {node_exec_id} not found.')", "successors": []}, {"id": 93, "label": "#93\nreturn ExecutionResult.from_db(res)", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "get_execution_results", "type": "CFG", "blocks": [{"id": 98, "label": "#98\nexecutions = await AgentNodeExecution.prisma().find_many(where={\n    'agentGraphExecutionId': graph_exec_id}, include=\n    EXECUTION_RESULT_INCLUDE, order=[{'queuedTime': 'asc'}, {'addedTime':\n    'asc'}])", "successors": [{"id": 99, "label": "#99\nres = [ExecutionResult.from_db(execution) for execution in executions]\nreturn res", "successors": []}]}], "functions": [], "classes": []}, {"name": "parse_execution_output", "type": "CFG", "blocks": [{"id": 103, "label": "#103\noutput_name, output_data = output\nif name == output_name:", "successors": [{"id": 104, "label": "#104\nreturn output_data", "successors": []}, {"id": 105, "label": "#105\nif name.startswith(f'{output_name}{LIST_SPLIT}'):", "successors": [{"id": 107, "label": "#107\nindex = int(name.split(LIST_SPLIT)[1])\nif not isinstance(output_data, list) or len(output_data) <= index:", "successors": [{"id": 109, "label": "#109\nreturn None", "successors": []}, {"id": 110, "label": "#110\nreturn output_data[int(name.split(LIST_SPLIT)[1])]", "successors": []}]}, {"id": 108, "label": "#108\nif name.startswith(f'{output_name}{DICT_SPLIT}'):", "successors": [{"id": 113, "label": "#113\nindex = name.split(DICT_SPLIT)[1]\nif not isinstance(output_data, dict) or index not in output_data:", "successors": [{"id": 115, "label": "#115\nreturn None", "successors": []}, {"id": 116, "label": "#116\nreturn output_data[index]", "successors": []}]}, {"id": 114, "label": "#114\nif name.startswith(f'{output_name}{OBJC_SPLIT}'):", "successors": [{"id": 119, "label": "#119\nindex = name.split(OBJC_SPLIT)[1]\nif isinstance(output_data, object) and hasattr(output_data, index):", "successors": [{"id": 121, "label": "#121\nreturn getattr(output_data, index)", "successors": []}, {"id": 122, "label": "#122\nreturn None", "successors": []}]}, {"id": 120, "label": "#120\nreturn None", "successors": []}]}]}]}]}], "functions": [], "classes": []}, {"name": "merge_execution_input", "type": "CFG", "blocks": [{"id": 128, "label": "#128\n\"\"\"\n    Merge all dynamic input pins which described by the following pattern:\n    - <input_name>_$_<index> for list input.\n    - <input_name>_#_<index> for dict input.\n    - <input_name>_@_<index> for object input.\n    This function will construct pins with the same name into a single list/dict/object.\n    \"\"\"\nitems = list(data.items())", "successors": [{"id": 129, "label": "#129\nfor key, value in items:", "successors": [{"id": 130, "label": "#130\nif LIST_SPLIT not in key:", "successors": [{"id": 133, "label": "#133\nname, index = key.split(LIST_SPLIT)\nif not index.isdigit():", "successors": [{"id": 134, "label": "#134\nraise ValueError(f'Invalid key: {key}, #{index} index must be an integer.')", "successors": []}, {"id": 135, "label": "#135\ndata[name] = data.get(name, [])\nif int(index) >= len(data[name]):", "successors": [{"id": 137, "label": "#137\ndata[name].extend([''] * (int(index) - len(data[name]) + 1))", "successors": [{"id": 138, "label": "#138\ndata[name][int(index)] = value", "successors": []}]}]}]}]}, {"id": 131, "label": "#131\nfor key, value in items:", "successors": [{"id": 139, "label": "#139\nif DICT_SPLIT not in key:", "successors": [{"id": 142, "label": "#142\nname, index = key.split(DICT_SPLIT)\ndata[name] = data.get(name, {})\ndata[name][index] = value", "successors": []}]}, {"id": 140, "label": "#140\nfor key, value in items:", "successors": [{"id": 143, "label": "#143\nif OBJC_SPLIT not in key:", "successors": [{"id": 146, "label": "#146\nname, index = key.split(OBJC_SPLIT)\nif name not in data or not isinstance(data[name], object):", "successors": [{"id": 147, "label": "#147\ndata[name] = mock.MockObject()", "successors": [{"id": 148, "label": "#148\nsetattr(data[name], index, value)", "successors": []}]}]}]}, {"id": 144, "label": "#144\nreturn data", "successors": []}]}]}]}]}], "functions": [], "classes": []}, {"name": "get_latest_execution", "type": "CFG", "blocks": [{"id": 152, "label": "#152\nexecution = await AgentNodeExecution.prisma().find_first(where={\n    'agentNodeId': node_id, 'agentGraphExecutionId': graph_eid,\n    'executionStatus': {'not': ExecutionStatus.INCOMPLETE}, 'executionData':\n    {'not': None}}, order={'queuedTime': 'desc'}, include=\n    EXECUTION_RESULT_INCLUDE)", "successors": [{"id": 153, "label": "#153\nif not execution:", "successors": [{"id": 154, "label": "#154\nreturn None", "successors": []}, {"id": 155, "label": "#155\nreturn ExecutionResult.from_db(execution)", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "get_incomplete_executions", "type": "CFG", "blocks": [{"id": 160, "label": "#160\nexecutions = await AgentNodeExecution.prisma().find_many(where={\n    'agentNodeId': node_id, 'agentGraphExecutionId': graph_eid,\n    'executionStatus': ExecutionStatus.INCOMPLETE}, include=\n    EXECUTION_RESULT_INCLUDE)", "successors": [{"id": 161, "label": "#161\nreturn [ExecutionResult.from_db(execution) for execution in executions]", "successors": []}]}], "functions": [], "classes": []}], "classes": [{"name": "GraphExecutionEntry", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nuser_id: str\ngraph_exec_id: str\ngraph_id: str\nstart_node_execs: list['NodeExecutionEntry']", "successors": []}], "functions": [], "classes": []}, {"name": "NodeExecutionEntry", "type": "CFG", "blocks": [{"id": 6, "label": "#6\nuser_id: str\ngraph_exec_id: str\ngraph_id: str\nnode_exec_id: str\nnode_id: str\ndata: BlockInput", "successors": []}], "functions": [], "classes": []}, {"name": "ExecutionQueue", "type": "CFG", "blocks": [{"id": 9, "label": "#9\n\"\"\"\n    Queue for managing the execution of agents.\n    This will be shared between different processes\n    \"\"\"", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 11, "label": "#11\nself.queue = Manager().Queue()", "successors": []}], "functions": [], "classes": []}, {"name": "add", "type": "CFG", "blocks": [{"id": 14, "label": "#14\nself.queue.put(execution)\nreturn execution", "successors": []}], "functions": [], "classes": []}, {"name": "get", "type": "CFG", "blocks": [{"id": 18, "label": "#18\nreturn self.queue.get()", "successors": []}], "functions": [], "classes": []}, {"name": "empty", "type": "CFG", "blocks": [{"id": 22, "label": "#22\nreturn self.queue.empty()", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "ExecutionResult", "type": "CFG", "blocks": [{"id": 27, "label": "#27\ngraph_id: str\ngraph_version: int\ngraph_exec_id: str\nnode_exec_id: str\nnode_id: str\nblock_id: str\nstatus: ExecutionStatus\ninput_data: BlockInput\noutput_data: CompletedBlockOutput\nadd_time: datetime\nqueue_time: datetime | None\nstart_time: datetime | None\nend_time: datetime | None", "successors": []}], "functions": [{"name": "from_graph", "type": "CFG", "blocks": [{"id": 29, "label": "#29\nreturn ExecutionResult(graph_id=graph.agentGraphId, graph_version=graph.\n    agentGraphVersion, graph_exec_id=graph.id, node_exec_id='', node_id='',\n    block_id='', status=graph.executionStatus, input_data={}, output_data={\n    }, add_time=graph.createdAt, queue_time=graph.createdAt, start_time=\n    graph.startedAt, end_time=graph.updatedAt)", "successors": []}], "functions": [], "classes": []}, {"name": "from_db", "type": "CFG", "blocks": [{"id": 33, "label": "#33\nif execution.executionData:", "successors": [{"id": 34, "label": "#34\ninput_data = json.loads(execution.executionData, target_type=dict[str, Any])", "successors": [{"id": 35, "label": "#35\noutput_data: CompletedBlockOutput = defaultdict(list)", "successors": [{"id": 40, "label": "#40\nfor data in (execution.Output or []):", "successors": [{"id": 41, "label": "#41\noutput_data[data.name].append(json.loads(data.data))", "successors": []}, {"id": 42, "label": "#42\ngraph_execution: AgentGraphExecution | None = execution.AgentGraphExecution\nreturn ExecutionResult(graph_id=graph_execution.agentGraphId if\n    graph_execution else '', graph_version=graph_execution.\n    agentGraphVersion if graph_execution else 0, graph_exec_id=execution.\n    agentGraphExecutionId, block_id=execution.AgentNode.agentBlockId if\n    execution.AgentNode else '', node_exec_id=execution.id, node_id=\n    execution.agentNodeId, status=execution.executionStatus, input_data=\n    input_data, output_data=output_data, add_time=execution.addedTime,\n    queue_time=execution.queuedTime, start_time=execution.startedTime,\n    end_time=execution.endedTime)", "successors": []}]}]}]}, {"id": 36, "label": "#36\ninput_data: BlockInput = defaultdict()", "successors": [{"id": 37, "label": "#37\nfor data in (execution.Input or []):", "successors": [{"id": 38, "label": "#38\ninput_data[data.name] = json.loads(data.data)", "successors": []}]}]}]}], "functions": [], "classes": []}], "classes": []}, {"name": "RedisExecutionEventBus", "type": "CFG", "blocks": [{"id": 165, "label": "#165\nModel = ExecutionResult", "successors": []}], "functions": [{"name": "event_bus_name", "type": "CFG", "blocks": [{"id": 167, "label": "#167\nreturn config.execution_event_bus_name", "successors": []}], "functions": [], "classes": []}, {"name": "publish", "type": "CFG", "blocks": [{"id": 171, "label": "#171\nself.publish_event(res, f'{res.graph_id}/{res.graph_exec_id}')", "successors": []}], "functions": [], "classes": []}, {"name": "listen", "type": "CFG", "blocks": [{"id": 174, "label": "#174\nfor execution_result in self.listen_events(f'{graph_id}/{graph_exec_id}'):", "successors": [{"id": 175, "label": "#175\nyield execution_result", "successors": []}]}], "functions": [], "classes": []}], "classes": []}, {"name": "AsyncRedisExecutionEventBus", "type": "CFG", "blocks": [{"id": 181, "label": "#181\nModel = ExecutionResult", "successors": []}], "functions": [{"name": "event_bus_name", "type": "CFG", "blocks": [{"id": 183, "label": "#183\nreturn config.execution_event_bus_name", "successors": []}], "functions": [], "classes": []}, {"name": "publish", "type": "CFG", "blocks": [{"id": 187, "label": "#187\nawait self.publish_event(res, f'{res.graph_id}/{res.graph_exec_id}')", "successors": []}], "functions": [], "classes": []}, {"name": "listen", "type": "CFG", "blocks": [{"id": 191, "label": "#191\nasync for execution_result in self.listen_events(f'{graph_id}/{graph_exec_id}'\n    ):\n    yield execution_result", "successors": [{"id": 192, "label": "#192\nyield execution_result", "successors": []}]}], "functions": [], "classes": []}], "classes": []}]}
{"file_name": "123.json", "name": "123.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport uuid\nfrom typing import List\nimport requests as baserequests\nfrom backend.data.block import BlockOutput, BlockSchema\nfrom backend.data.model import APIKeyCredentials, SchemaField\nfrom backend.util import settings\nfrom backend.util.settings import BehaveAs\nfrom ._api import TEST_CREDENTIALS, TEST_CREDENTIALS_INPUT, CustomerDetails, OrderItem, Slant3DCredentialsField, Slant3DCredentialsInput\nfrom .base import Slant3DBlockBase", "successors": []}], "functions": [], "classes": [{"name": "Slant3DCreateOrderBlock", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"Block for creating new orders\"\"\"", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 11, "label": "#11\nsuper().__init__(id='f73007d6-f48f-4aaf-9e6b-6883998a09b4', description=\n    'Create a new print order', input_schema=self.Input, output_schema=self\n    .Output, test_input={'credentials': TEST_CREDENTIALS_INPUT,\n    'order_number': 'TEST-001', 'customer': {'name': 'John Doe', 'email':\n    'john@example.com', 'phone': '123-456-7890', 'address': '123 Test St',\n    'city': 'Test City', 'state': 'TS', 'zip': '12345'}, 'items': [{\n    'file_url': 'https://example.com/model.stl', 'quantity': '1', 'color':\n    'black', 'profile': 'PLA'}]}, test_credentials=TEST_CREDENTIALS,\n    test_output=[('order_id', '314144241')], test_mock={'_make_request': lambda\n    *args, **kwargs: {'orderId': '314144241'}, '_convert_to_color': lambda\n    *args, **kwargs: 'black'})", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 14, "label": "#14\ntry:", "successors": [{"id": 15, "label": "#15\norder_data = self._format_order_data(input_data.customer, input_data.\n    order_number, input_data.items, credentials.api_key.get_secret_value())\nresult = self._make_request('POST', 'order', credentials.api_key.\n    get_secret_value(), json=order_data)\nyield 'order_id', result['orderId']", "successors": []}, {"id": 16, "label": "#16\nyield 'error', str(e)", "successors": [{"id": 19, "label": "#19\nraise", "successors": []}]}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 5, "label": "#5\ncredentials: Slant3DCredentialsInput = Slant3DCredentialsField()\norder_number: str = SchemaField(description=\n    'Your custom order number (or leave blank for a random one)',\n    default_factory=lambda : str(uuid.uuid4()))\ncustomer: CustomerDetails = SchemaField(description=\n    'Customer details for where to ship the item', advanced=False)\nitems: List[OrderItem] = SchemaField(description='List of items to print',\n    advanced=False)", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 8, "label": "#8\norder_id: str = SchemaField(description='Slant3D order ID')\nerror: str = SchemaField(description='Error message if order failed')", "successors": []}], "functions": [], "classes": []}]}, {"name": "Slant3DEstimateOrderBlock", "type": "CFG", "blocks": [{"id": 24, "label": "#24\n\"\"\"Block for getting order cost estimates\"\"\"", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 32, "label": "#32\nsuper().__init__(id='bf8823d6-b42a-48c7-b558-d7c117f2ae85', description=\n    'Get order cost estimate', input_schema=self.Input, output_schema=self.\n    Output, test_input={'credentials': TEST_CREDENTIALS_INPUT,\n    'order_number': 'TEST-001', 'customer': {'name': 'John Doe', 'email':\n    'john@example.com', 'phone': '123-456-7890', 'address': '123 Test St',\n    'city': 'Test City', 'state': 'TS', 'zip': '12345'}, 'items': [{\n    'file_url': 'https://example.com/model.stl', 'quantity': '1', 'color':\n    'black', 'profile': 'PLA'}]}, test_credentials=TEST_CREDENTIALS,\n    test_output=[('total_price', 9.31), ('shipping_cost', 5.56), (\n    'printing_cost', 3.75)], test_mock={'_make_request': lambda *args, **\n    kwargs: {'totalPrice': 9.31, 'shippingCost': 5.56, 'printingCost': 3.75\n    }, '_convert_to_color': lambda *args, **kwargs: 'black'})", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 35, "label": "#35\norder_data = self._format_order_data(input_data.customer, input_data.\n    order_number, input_data.items, credentials.api_key.get_secret_value())\ntry:", "successors": [{"id": 36, "label": "#36\nresult = self._make_request('POST', 'order/estimate', credentials.api_key.\n    get_secret_value(), json=order_data)\nyield 'total_price', result['totalPrice']", "successors": [{"id": 39, "label": "#39\nyield 'shipping_cost', result['shippingCost']", "successors": [{"id": 40, "label": "#40\nyield 'printing_cost', result['printingCost']", "successors": []}]}]}, {"id": 37, "label": "#37\nyield 'error', str(f'Error estimating order: {e} {e.response.text}')", "successors": [{"id": 42, "label": "#42\nraise", "successors": []}]}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 26, "label": "#26\ncredentials: Slant3DCredentialsInput = Slant3DCredentialsField()\norder_number: str = SchemaField(description=\n    'Your custom order number (or leave blank for a random one)',\n    default_factory=lambda : str(uuid.uuid4()))\ncustomer: CustomerDetails = SchemaField(description=\n    'Customer details for where to ship the item', advanced=False)\nitems: List[OrderItem] = SchemaField(description='List of items to print',\n    advanced=False)", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 29, "label": "#29\ntotal_price: float = SchemaField(description='Total price in USD')\nshipping_cost: float = SchemaField(description='Shipping cost')\nprinting_cost: float = SchemaField(description='Printing cost')\nerror: str = SchemaField(description='Error message if estimation failed')", "successors": []}], "functions": [], "classes": []}]}, {"name": "Slant3DEstimateShippingBlock", "type": "CFG", "blocks": [{"id": 47, "label": "#47\n\"\"\"Block for getting shipping cost estimates\"\"\"", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 55, "label": "#55\nsuper().__init__(id='00aae2a1-caf6-4a74-8175-39a0615d44e1', description=\n    'Get shipping cost estimate', input_schema=self.Input, output_schema=\n    self.Output, test_input={'credentials': TEST_CREDENTIALS_INPUT,\n    'order_number': 'TEST-001', 'customer': {'name': 'John Doe', 'email':\n    'john@example.com', 'phone': '123-456-7890', 'address': '123 Test St',\n    'city': 'Test City', 'state': 'TS', 'zip': '12345'}, 'items': [{\n    'file_url': 'https://example.com/model.stl', 'quantity': '1', 'color':\n    'black', 'profile': 'PLA'}]}, test_credentials=TEST_CREDENTIALS,\n    test_output=[('shipping_cost', 4.81), ('currency_code', 'usd')],\n    test_mock={'_make_request': lambda *args, **kwargs: {'shippingCost': \n    4.81, 'currencyCode': 'usd'}, '_convert_to_color': lambda *args, **\n    kwargs: 'black'})", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 58, "label": "#58\ntry:", "successors": [{"id": 59, "label": "#59\norder_data = self._format_order_data(input_data.customer, input_data.\n    order_number, input_data.items, credentials.api_key.get_secret_value())\nresult = self._make_request('POST', 'order/estimateShipping', credentials.\n    api_key.get_secret_value(), json=order_data)\nyield 'shipping_cost', result['shippingCost']", "successors": [{"id": 62, "label": "#62\nyield 'currency_code', result['currencyCode']", "successors": []}]}, {"id": 60, "label": "#60\nyield 'error', str(e)", "successors": [{"id": 64, "label": "#64\nraise", "successors": []}]}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 49, "label": "#49\ncredentials: Slant3DCredentialsInput = Slant3DCredentialsField()\norder_number: str = SchemaField(description=\n    'Your custom order number (or leave blank for a random one)',\n    default_factory=lambda : str(uuid.uuid4()))\ncustomer: CustomerDetails = SchemaField(description=\n    'Customer details for where to ship the item')\nitems: List[OrderItem] = SchemaField(description='List of items to print',\n    advanced=False)", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 52, "label": "#52\nshipping_cost: float = SchemaField(description='Estimated shipping cost')\ncurrency_code: str = SchemaField(description=\"Currency code (e.g., 'usd')\")\nerror: str = SchemaField(description='Error message if estimation failed')", "successors": []}], "functions": [], "classes": []}]}, {"name": "Slant3DGetOrdersBlock", "type": "CFG", "blocks": [{"id": 69, "label": "#69\n\"\"\"Block for retrieving all orders\"\"\"", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 77, "label": "#77\nsuper().__init__(id='42283bf5-8a32-4fb4-92a2-60a9ea48e105', description=\n    'Get all orders for the account', input_schema=self.Input,\n    output_schema=self.Output, disabled=settings.Settings().config.\n    behave_as == BehaveAs.CLOUD, test_input={'credentials':\n    TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output\n    =[('orders', ['1234567890'])], test_mock={'_make_request': lambda *args,\n    **kwargs: {'ordersData': [{'orderId': 1234567890, 'orderTimestamp': {\n    '_seconds': 1719510986, '_nanoseconds': 710000000}}]}})", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 80, "label": "#80\ntry:", "successors": [{"id": 81, "label": "#81\nresult = self._make_request('GET', 'order', credentials.api_key.\n    get_secret_value())\nyield 'orders', [str(order['orderId']) for order in result['ordersData']]", "successors": []}, {"id": 82, "label": "#82\nyield 'error', str(e)", "successors": [{"id": 85, "label": "#85\nraise", "successors": []}]}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 71, "label": "#71\ncredentials: Slant3DCredentialsInput = Slant3DCredentialsField()", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 74, "label": "#74\norders: List[str] = SchemaField(description='List of orders with their details'\n    )\nerror: str = SchemaField(description='Error message if request failed')", "successors": []}], "functions": [], "classes": []}]}, {"name": "Slant3DTrackingBlock", "type": "CFG", "blocks": [{"id": 90, "label": "#90\n\"\"\"Block for tracking order status and shipping\"\"\"", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 98, "label": "#98\nsuper().__init__(id='dd7c0293-c5af-4551-ba3e-fc162fb1fb89', description=\n    'Track order status and shipping', input_schema=self.Input,\n    output_schema=self.Output, test_input={'credentials':\n    TEST_CREDENTIALS_INPUT, 'order_id': '314144241'}, test_credentials=\n    TEST_CREDENTIALS, test_output=[('status', 'awaiting_shipment'), (\n    'tracking_numbers', [])], test_mock={'_make_request': lambda *args, **\n    kwargs: {'status': 'awaiting_shipment', 'trackingNumbers': []}})", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 101, "label": "#101\ntry:", "successors": [{"id": 102, "label": "#102\nresult = self._make_request('GET',\n    f'order/{input_data.order_id}/get-tracking', credentials.api_key.\n    get_secret_value())\nyield 'status', result['status']", "successors": [{"id": 105, "label": "#105\nyield 'tracking_numbers', result['trackingNumbers']", "successors": []}]}, {"id": 103, "label": "#103\nyield 'error', str(e)", "successors": [{"id": 107, "label": "#107\nraise", "successors": []}]}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 92, "label": "#92\ncredentials: Slant3DCredentialsInput = Slant3DCredentialsField()\norder_id: str = SchemaField(description='Slant3D order ID to track')", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 95, "label": "#95\nstatus: str = SchemaField(description='Order status')\ntracking_numbers: List[str] = SchemaField(description=\n    'List of tracking numbers')\nerror: str = SchemaField(description='Error message if tracking failed')", "successors": []}], "functions": [], "classes": []}]}, {"name": "Slant3DCancelOrderBlock", "type": "CFG", "blocks": [{"id": 112, "label": "#112\n\"\"\"Block for canceling orders\"\"\"", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 120, "label": "#120\nsuper().__init__(id='54de35e1-407f-450b-b5fa-3b5e2eba8185', description=\n    'Cancel an existing order', input_schema=self.Input, output_schema=self\n    .Output, test_input={'credentials': TEST_CREDENTIALS_INPUT, 'order_id':\n    '314144241'}, test_credentials=TEST_CREDENTIALS, test_output=[('status',\n    'Order cancelled')], test_mock={'_make_request': lambda *args, **kwargs:\n    {'status': 'Order cancelled'}})", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 123, "label": "#123\ntry:", "successors": [{"id": 124, "label": "#124\nresult = self._make_request('DELETE', f'order/{input_data.order_id}',\n    credentials.api_key.get_secret_value())\nyield 'status', result['status']", "successors": []}, {"id": 125, "label": "#125\nyield 'error', str(e)", "successors": [{"id": 128, "label": "#128\nraise", "successors": []}]}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 114, "label": "#114\ncredentials: Slant3DCredentialsInput = Slant3DCredentialsField()\norder_id: str = SchemaField(description='Slant3D order ID to cancel')", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 117, "label": "#117\nstatus: str = SchemaField(description='Cancellation status message')\nerror: str = SchemaField(description='Error message if cancellation failed')", "successors": []}], "functions": [], "classes": []}]}]}
{"file_name": "124.json", "name": "124.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport hashlib\nimport hmac\nimport logging\nimport requests\nfrom fastapi import HTTPException, Request\nfrom strenum import StrEnum\nfrom backend.data import integrations\nfrom backend.data.model import Credentials\nfrom backend.integrations.providers import ProviderName\nfrom ._base import BaseWebhooksManager\nlogger = logging.getLogger(__name__)", "successors": []}], "functions": [{"name": "extract_github_error_msg", "type": "CFG", "blocks": [{"id": 60, "label": "#60\nerror_msgs = []\nresp = response.json()\nif resp.get('message'):", "successors": [{"id": 61, "label": "#61\nerror_msgs.append(resp['message'])", "successors": [{"id": 62, "label": "#62\nif resp.get('errors'):", "successors": [{"id": 63, "label": "#63\nerror_msgs.extend(f\"* {err.get('message', err)}\" for err in resp['errors'])", "successors": [{"id": 64, "label": "#64\nif resp.get('error'):", "successors": [{"id": 65, "label": "#65\nif isinstance(resp['error'], dict):", "successors": [{"id": 67, "label": "#67\nerror_msgs.append(resp['error'].get('message', resp['error']))", "successors": [{"id": 66, "label": "#66\nreturn '\\n'.join(error_msgs)", "successors": []}]}, {"id": 69, "label": "#69\nerror_msgs.append(resp['error'])", "successors": []}]}]}]}]}]}]}], "functions": [], "classes": []}], "classes": [{"name": "GithubWebhookType", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nREPO = 'repo'", "successors": []}], "functions": [], "classes": []}, {"name": "GithubWebhooksManager", "type": "CFG", "blocks": [{"id": 6, "label": "#6\nPROVIDER_NAME = ProviderName.GITHUB\nWebhookType = GithubWebhookType\nGITHUB_API_URL = 'https://api.github.com'\nGITHUB_API_DEFAULT_HEADERS = {'Accept': 'application/vnd.github.v3+json'}", "successors": []}], "functions": [{"name": "validate_payload", "type": "CFG", "blocks": [{"id": 8, "label": "#8\nif not (event_type := request.headers.get('X-GitHub-Event')):", "successors": [{"id": 9, "label": "#9\nraise HTTPException(status_code=400, detail='X-GitHub-Event header is missing!'\n    )", "successors": []}, {"id": 10, "label": "#10\nif not (signature_header := request.headers.get('X-Hub-Signature-256')):", "successors": [{"id": 12, "label": "#12\nraise HTTPException(status_code=403, detail=\n    'X-Hub-Signature-256 header is missing!')", "successors": []}, {"id": 13, "label": "#13\npayload_body = await request.body()", "successors": [{"id": 15, "label": "#15\nhash_object = hmac.new(webhook.secret.encode('utf-8'), msg=payload_body,\n    digestmod=hashlib.sha256)\nexpected_signature = 'sha256=' + hash_object.hexdigest()\nif not hmac.compare_digest(expected_signature, signature_header):", "successors": [{"id": 16, "label": "#16\nraise HTTPException(status_code=403, detail=\"Request signatures didn't match!\")", "successors": []}, {"id": 17, "label": "#17\npayload = await request.json()", "successors": [{"id": 19, "label": "#19\nif (action := payload.get('action')):", "successors": [{"id": 20, "label": "#20\nevent_type += f'.{action}'", "successors": [{"id": 21, "label": "#21\nreturn payload, event_type", "successors": []}]}]}]}]}]}]}]}], "functions": [], "classes": []}, {"name": "trigger_ping", "type": "CFG", "blocks": [{"id": 25, "label": "#25\nif not credentials:", "successors": [{"id": 26, "label": "#26\nraise ValueError('Credentials are required but were not passed')", "successors": []}, {"id": 27, "label": "#27\nheaders = {**self.GITHUB_API_DEFAULT_HEADERS, 'Authorization': credentials.\n    bearer()}\nrepo, github_hook_id = webhook.resource, webhook.provider_webhook_id\nping_url = f'{self.GITHUB_API_URL}/repos/{repo}/hooks/{github_hook_id}/pings'\nresponse = requests.post(ping_url, headers=headers)\nif response.status_code != 204:", "successors": [{"id": 29, "label": "#29\nerror_msg = extract_github_error_msg(response)\nraise ValueError(f'Failed to ping GitHub webhook: {error_msg}')", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "_register_webhook", "type": "CFG", "blocks": [{"id": 34, "label": "#34\nif webhook_type == self.WebhookType.REPO and resource.count('/') > 1:", "successors": [{"id": 35, "label": "#35\nraise ValueError(\"Invalid repo format: expected 'owner/repo'\")", "successors": []}, {"id": 36, "label": "#36\ngithub_events = list({event.split('.')[0] for event in events})\nheaders = {**self.GITHUB_API_DEFAULT_HEADERS, 'Authorization': credentials.\n    bearer()}\nwebhook_data = {'name': 'web', 'active': True, 'events': github_events,\n    'config': {'url': ingress_url, 'content_type': 'json', 'insecure_ssl':\n    '0', 'secret': secret}}\nresponse = requests.post(f'{self.GITHUB_API_URL}/repos/{resource}/hooks',\n    headers=headers, json=webhook_data)\nif response.status_code != 201:", "successors": [{"id": 38, "label": "#38\nerror_msg = extract_github_error_msg(response)\nif 'not found' in error_msg.lower():", "successors": [{"id": 40, "label": "#40\nerror_msg = (\n    f\"{error_msg} (Make sure the GitHub account or API key has 'repo' or webhook create permissions to '{resource}')\"\n    )", "successors": [{"id": 41, "label": "#41\nraise ValueError(f'Failed to create GitHub webhook: {error_msg}')", "successors": []}]}]}, {"id": 39, "label": "#39\nwebhook_id = response.json()['id']\nconfig = response.json()['config']\nreturn str(webhook_id), config", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "_deregister_webhook", "type": "CFG", "blocks": [{"id": 46, "label": "#46\nwebhook_type = self.WebhookType(webhook.webhook_type)\nif webhook.credentials_id != credentials.id:", "successors": [{"id": 47, "label": "#47\nraise ValueError(\n    f'Webhook #{webhook.id} does not belong to credentials {credentials.id}')", "successors": []}, {"id": 48, "label": "#48\nheaders = {**self.GITHUB_API_DEFAULT_HEADERS, 'Authorization': credentials.\n    bearer()}\nif webhook_type == self.WebhookType.REPO:", "successors": [{"id": 50, "label": "#50\nrepo = webhook.resource\ndelete_url = (\n    f'{self.GITHUB_API_URL}/repos/{repo}/hooks/{webhook.provider_webhook_id}')", "successors": [{"id": 51, "label": "#51\nresponse = requests.delete(delete_url, headers=headers)\nif response.status_code not in [204, 404]:", "successors": [{"id": 54, "label": "#54\nerror_msg = extract_github_error_msg(response)\nraise ValueError(f'Failed to delete GitHub webhook: {error_msg}')", "successors": []}]}]}, {"id": 52, "label": "#52\nraise NotImplementedError(f\"Unsupported webhook type '{webhook.webhook_type}'\")", "successors": []}]}]}], "functions": [], "classes": []}], "classes": []}]}
{"file_name": "125.json", "name": "125.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport logging\nimport time\nfrom enum import Enum\nfrom typing import Any\nimport httpx\nfrom backend.blocks.fal._auth import TEST_CREDENTIALS, TEST_CREDENTIALS_INPUT, FalCredentials, FalCredentialsField, FalCredentialsInput\nfrom backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema\nfrom backend.data.model import SchemaField\nlogger = logging.getLogger(__name__)", "successors": []}], "functions": [], "classes": [{"name": "FalModel", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nMOCHI = 'fal-ai/mochi-v1'\nLUMA = 'fal-ai/luma-dream-machine'", "successors": []}], "functions": [], "classes": []}, {"name": "AIVideoGeneratorBlock", "type": "CFG", "blocks": [{"id": 6, "label": "#6", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 14, "label": "#14\nsuper().__init__(id='530cf046-2ce0-4854-ae2c-659db17c7a46', description=\n    'Generate videos using FAL AI models.', categories={BlockCategory.AI},\n    input_schema=self.Input, output_schema=self.Output, test_input={\n    'prompt': 'A dog running in a field.', 'model': FalModel.MOCHI,\n    'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=\n    TEST_CREDENTIALS, test_output=[('video_url',\n    'https://fal.media/files/example/video.mp4')], test_mock={\n    'generate_video': lambda *args, **kwargs:\n    'https://fal.media/files/example/video.mp4'})", "successors": []}], "functions": [], "classes": []}, {"name": "_get_headers", "type": "CFG", "blocks": [{"id": 17, "label": "#17\n\"\"\"Get headers for FAL API requests.\"\"\"\nreturn {'Authorization': f'Key {api_key}', 'Content-Type': 'application/json'}", "successors": []}], "functions": [], "classes": []}, {"name": "_submit_request", "type": "CFG", "blocks": [{"id": 21, "label": "#21\n\"\"\"Submit a request to the FAL API.\"\"\"\ntry:", "successors": [{"id": 22, "label": "#22\nresponse = httpx.post(url, headers=headers, json=data)\nresponse.raise_for_status()\nreturn response.json()", "successors": []}, {"id": 23, "label": "#23\nlogger.error(f'FAL API request failed: {str(e)}')\nraise RuntimeError(f'Failed to submit request: {str(e)}')", "successors": []}]}], "functions": [], "classes": []}, {"name": "_poll_status", "type": "CFG", "blocks": [{"id": 29, "label": "#29\n\"\"\"Poll the status endpoint until completion or failure.\"\"\"\ntry:", "successors": [{"id": 30, "label": "#30\nresponse = httpx.get(status_url, headers=headers)\nresponse.raise_for_status()\nreturn response.json()", "successors": []}, {"id": 31, "label": "#31\nlogger.error(f'Failed to get status: {str(e)}')\nraise RuntimeError(f'Failed to get status: {str(e)}')", "successors": []}]}], "functions": [], "classes": []}, {"name": "generate_video", "type": "CFG", "blocks": [{"id": 37, "label": "#37\n\"\"\"Generate video using the specified FAL model.\"\"\"\nbase_url = 'https://queue.fal.run'\napi_key = credentials.api_key.get_secret_value()\nheaders = self._get_headers(api_key)\nsubmit_url = f'{base_url}/{input_data.model.value}'\nsubmit_data = {'prompt': input_data.prompt}\nseen_logs = set()\ntry:", "successors": [{"id": 38, "label": "#38\nsubmit_response = httpx.post(submit_url, headers=headers, json=submit_data)\nsubmit_response.raise_for_status()\nrequest_data = submit_response.json()\nrequest_id = request_data.get('request_id')\nstatus_url = request_data.get('status_url')\nresult_url = request_data.get('response_url')\nif not all([request_id, status_url, result_url]):", "successors": [{"id": 41, "label": "#41\nraise ValueError('Missing required data in submission response')", "successors": []}, {"id": 42, "label": "#42\nmax_attempts = 30\nattempt = 0\nbase_wait_time = 5", "successors": [{"id": 44, "label": "#44\nwhile attempt < max_attempts:", "successors": [{"id": 45, "label": "#45\nstatus_response = httpx.get(f'{status_url}?logs=1', headers=headers)\nstatus_response.raise_for_status()\nstatus_data = status_response.json()\nlogs = status_data.get('logs', [])\nif logs and isinstance(logs, list):", "successors": [{"id": 47, "label": "#47\nfor log in logs:", "successors": [{"id": 49, "label": "#49\nif isinstance(log, dict):", "successors": [{"id": 51, "label": "#51\nlog_key = f\"{log.get('timestamp', '')}-{log.get('message', '')}\"\nif log_key not in seen_logs:", "successors": [{"id": 53, "label": "#53\nseen_logs.add(log_key)\nmessage = log.get('message', '')\nif message:", "successors": [{"id": 55, "label": "#55\nlogger.debug(\n    f\"[FAL Generation] [{log.get('level', 'INFO')}] [{log.get('source', '')}] [{log.get('timestamp', '')}] {message}\"\n    )", "successors": []}]}]}]}, {"id": 48, "label": "#48\nstatus = status_data.get('status')\nif status == 'COMPLETED':", "successors": [{"id": 57, "label": "#57\nresult_response = httpx.get(result_url, headers=headers)\nresult_response.raise_for_status()\nresult_data = result_response.json()\nif 'video' not in result_data or not isinstance(result_data['video'], dict):", "successors": [{"id": 70, "label": "#70\nraise ValueError('Invalid response format - missing video data')", "successors": []}, {"id": 71, "label": "#71\nvideo_url = result_data['video'].get('url')\nif not video_url:", "successors": [{"id": 73, "label": "#73\nraise ValueError('No video URL in response')", "successors": []}, {"id": 74, "label": "#74\nreturn video_url", "successors": []}]}]}, {"id": 59, "label": "#59\nif status == 'FAILED':", "successors": [{"id": 60, "label": "#60\nerror_msg = status_data.get('error', 'No error details provided')\nraise RuntimeError(f'Video generation failed: {error_msg}')", "successors": []}, {"id": 62, "label": "#62\nif status == 'IN_QUEUE':", "successors": [{"id": 63, "label": "#63\nposition = status_data.get('queue_position', 'unknown')\nlogger.debug(f'[FAL Generation] Status: In queue, position: {position}')", "successors": [{"id": 58, "label": "#58\nwait_time = min(base_wait_time * 2 ** attempt, 60)\ntime.sleep(wait_time)\nattempt += 1", "successors": []}]}, {"id": 65, "label": "#65\nif status == 'IN_PROGRESS':", "successors": [{"id": 66, "label": "#66", "successors": []}, {"id": 68, "label": "#68\nlogger.info(f'[FAL Generation] Status: Unknown status: {status}')", "successors": []}]}]}]}]}]}]}, {"id": 46, "label": "#46\nraise RuntimeError('Maximum polling attempts reached')", "successors": []}]}]}]}, {"id": 39, "label": "#39\nraise RuntimeError(f'API request failed: {str(e)}')", "successors": []}]}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 81, "label": "#81\ntry:", "successors": [{"id": 82, "label": "#82\nvideo_url = self.generate_video(input_data, credentials)\nyield 'video_url', video_url", "successors": []}, {"id": 83, "label": "#83\nerror_message = str(e)\nyield 'error', error_message", "successors": []}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 8, "label": "#8\nprompt: str = SchemaField(description=\n    'Description of the video to generate.', placeholder=\n    'A dog running in a field.')\nmodel: FalModel = SchemaField(title='FAL Model', default=FalModel.MOCHI,\n    description='The FAL model to use for video generation.')\ncredentials: FalCredentialsInput = FalCredentialsField()", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 11, "label": "#11\nvideo_url: str = SchemaField(description='The URL of the generated video.')\nerror: str = SchemaField(description=\n    'Error message if video generation failed.')\nlogs: list[str] = SchemaField(description='Generation progress logs.',\n    optional=True)", "successors": []}], "functions": [], "classes": []}]}]}
{"file_name": "126.json", "name": "126.json", "type": "CFG", "blocks": [{"id": 1, "label": "#1\n{'name': 'example_script', 'type': 'CFG', 'start_line': 1, 'end_line': 30,\n    'functions': [{'name': 'find_previous_power_of_two', 'type': 'function',\n    'start_line': 1, 'end_line': 24, 'functions': [], 'classes': [],\n    'simplified_code':\n    \"\"\"def find_previous_power_of_two(number: int) -> int:\n    \"\"\\\"\n    Find the largest power of two that is less than or equal to a given integer.\n    https://stackoverflow.com/questions/1322510\n\n    >>> [find_previous_power_of_two(i) for i in range(18)]\n    [0, 1, 2, 2, 4, 4, 4, 4, 8, 8, 8, 8, 8, 8, 8, 8, 16, 16]\n    >>> find_previous_power_of_two(-5)\n    Traceback (most recent call last):\n    ValueError: Input must be a non-negative integer\n    >>> find_previous_power_of_two(10.5)\n    Traceback (most recent call last):\n    ValueError: Input must be a non-negative integer\n    \"\"\\\"\n    if not isinstance(number, int) or number < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n    if number == 0:\n        return 0\n    power = 1\n    while power <= number:\n        power <<= 1  # Equivalent to multiplying by 2\n    return power >> 1 if number > 1 else 1\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"def find_previous_power_of_two(number: int) -> int:\n    \"\"\\\"\n    Find the largest power of two that is less than or equal to a given integer.\n    https://stackoverflow.com/questions/1322510\n\n    >>> [find_previous_power_of_two(i) for i in range(18)]\n    [0, 1, 2, 2, 4, 4, 4, 4, 8, 8, 8, 8, 8, 8, 8, 8, 16, 16]\n    >>> find_previous_power_of_two(-5)\n    Traceback (most recent call last):\n    ValueError: Input must be a non-negative integer\n    >>> find_previous_power_of_two(10.5)\n    Traceback (most recent call last):\n    ValueError: Input must be a non-negative integer\n    \"\"\\\"\"\"\"\n    , 'successors': [2]}, {'id': 2, 'label':\n    'if not isinstance(number, int) or number < 0:', 'successors': [3, 4]},\n    {'id': 3, 'label':\n    'raise ValueError(\"Input must be a non-negative integer\")',\n    'successors': []}, {'id': 4, 'label': 'if number == 0:', 'successors':\n    [5, 6]}, {'id': 5, 'label': 'return 0', 'successors': []}, {'id': 6,\n    'label': 'power = 1', 'successors': [7]}, {'id': 7, 'label':\n    'while power <= number:', 'successors': [8, 9]}, {'id': 8, 'label':\n    'power <<= 1  # Equivalent to multiplying by 2', 'successors': [7]}, {\n    'id': 9, 'label': 'return power >> 1 if number > 1 else 1',\n    'successors': []}]}], 'classes': [], 'simplified_code':\n    \"\"\"    return power >> 1 if number > 1 else 1\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    'return power >> 1 if number > 1 else 1', 'successors': []}, {'id': 2,\n    'label': 'if __name__ == \"__main__\":', 'successors': [3]}, {'id': 3,\n    'label': \"\"\"import doctest\n\ndoctest.testmod()\"\"\", 'successors': []}]}", "successors": []}], "functions": [], "classes": []}
{"file_name": "127.json", "name": "127.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom __future__ import annotations\nif __name__ == '__main__':", "successors": [{"id": 28, "label": "#28\nimport doctest\ndoctest.testmod(optionflags=doctest.NORMALIZE_WHITESPACE)", "successors": []}]}], "functions": [{"name": "solve_maze", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"\n    This method solves the \"rat in maze\" problem.\n    Parameters :\n        - maze: A two dimensional matrix of zeros and ones.\n        - source_row: The row index of the starting point.\n        - source_column: The column index of the starting point.\n        - destination_row: The row index of the destination point.\n        - destination_column: The column index of the destination point.\n    Returns:\n        - solution: A 2D matrix representing the solution path if it exists.\n    Raises:\n        - ValueError: If no solution exists or if the source or\n            destination coordinates are invalid.\n    Description:\n        This method navigates through a maze represented as an n by n matrix,\n        starting from a specified source cell and\n        aiming to reach a destination cell.\n        The maze consists of walls (1s) and open paths (0s).\n        By providing custom row and column values, the source and destination\n        cells can be adjusted.\n    >>> maze = [[0, 1, 0, 1, 1],\n    >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE\n    [[0, 1, 1, 1, 1],\n    [0, 0, 0, 0, 1],\n    [1, 1, 1, 0, 1],\n    [1, 1, 1, 0, 0],\n    [1, 1, 1, 1, 0]]\n\n    Note:\n        In the output maze, the zeros (0s) represent one of the possible\n        paths from the source to the destination.\n\n    >>> maze = [[0, 1, 0, 1, 1],\n    >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE\n    [[0, 1, 1, 1, 1],\n    [0, 1, 1, 1, 1],\n    [0, 1, 1, 1, 1],\n    [0, 1, 1, 1, 1],\n    [0, 0, 0, 0, 0]]\n\n    >>> maze = [[0, 0, 0],\n    >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE\n    [[0, 0, 0],\n    [1, 1, 0],\n    [1, 1, 0]]\n\n    >>> maze = [[1, 0, 0],\n    >>> solve_maze(maze,0,1,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE\n    [[1, 0, 0],\n    [1, 1, 0],\n    [1, 1, 0]]\n\n    >>> maze = [[1, 1, 0, 0, 1, 0, 0, 1],\n    >>> solve_maze(maze,0,2,len(maze)-1,2)  # doctest: +NORMALIZE_WHITESPACE\n    [[1, 1, 0, 0, 1, 1, 1, 1],\n    [1, 1, 1, 0, 0, 1, 1, 1],\n    [1, 1, 1, 1, 0, 1, 1, 1],\n    [1, 1, 1, 0, 0, 1, 1, 1],\n    [1, 1, 0, 0, 1, 1, 1, 1],\n    [1, 1, 0, 1, 1, 1, 1, 1],\n    [1, 1, 0, 1, 1, 1, 1, 1],\n    [1, 1, 0, 1, 1, 1, 1, 1]]\n    >>> maze = [[1, 0, 0],\n    >>> solve_maze(maze,0,1,len(maze)-1,len(maze)-1)\n    Traceback (most recent call last):\n    ValueError: No solution exists!\n\n    >>> maze = [[0, 0],\n    >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)\n    Traceback (most recent call last):\n    ValueError: No solution exists!\n\n    >>> maze = [[0, 1],\n    >>> solve_maze(maze,2,0,len(maze)-1,len(maze)-1)\n    Traceback (most recent call last):\n    ValueError: Invalid source or destination coordinates\n\n    >>> maze = [[1, 0, 0],\n    >>> solve_maze(maze,0,1,len(maze),len(maze)-1)\n    Traceback (most recent call last):\n    ValueError: Invalid source or destination coordinates\n    \"\"\"\nsize = len(maze)\nif not (0 <= source_row <= size - 1 and 0 <= source_column <= size - 1", "successors": [{"id": 4, "label": "#4\nraise ValueError('Invalid source or destination coordinates')", "successors": []}, {"id": 5, "label": "#5\nsolutions = [[(1) for _ in range(size)] for _ in range(size)]\nsolved = run_maze(maze, source_row, source_column, destination_row,\n    destination_column, solutions)\nif solved:", "successors": [{"id": 7, "label": "#7\nreturn solutions", "successors": []}, {"id": 9, "label": "#9\nraise ValueError('No solution exists!')", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "run_maze", "type": "CFG", "blocks": [{"id": 14, "label": "#14\n\"\"\"\n    This method is recursive starting from (i, j) and going in one of four directions:\n    up, down, left, right.\n    If a path is found to destination it returns True otherwise it returns False.\n    Parameters\n        maze: A two dimensional matrix of zeros and ones.\n        i, j : coordinates of matrix\n        solutions: A two dimensional matrix of solutions.\n    Returns:\n        Boolean if path is found True, Otherwise False.\n    \"\"\"\nsize = len(maze)\nif i == destination_row and j == destination_column and maze[i][j] == 0:", "successors": [{"id": 15, "label": "#15\nsolutions[i][j] = 0\nreturn True", "successors": []}, {"id": 16, "label": "#16\nlower_flag = not i < 0 and not j < 0\nupper_flag = i < size and j < size\nif lower_flag and upper_flag:", "successors": [{"id": 18, "label": "#18\nblock_flag = solutions[i][j] and not maze[i][j]\nif block_flag:", "successors": [{"id": 20, "label": "#20\nsolutions[i][j] = 0\nif run_maze(maze, i + 1, j, destination_row, destination_column, solutions", "successors": [{"id": 22, "label": "#22\nreturn True", "successors": []}, {"id": 23, "label": "#23\nsolutions[i][j] = 1\nreturn False", "successors": []}]}, {"id": 19, "label": "#19\nreturn False", "successors": []}]}]}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "128.json", "name": "128.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport logging\nimport time\nfrom abc import ABC, abstractmethod\nfrom typing import ClassVar\nfrom backend.data.model import OAuth2Credentials\nfrom backend.integrations.providers import ProviderName\nlogger = logging.getLogger(__name__)", "successors": []}], "functions": [], "classes": [{"name": "BaseOAuthHandler", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nPROVIDER_NAME: ClassVar[ProviderName]\nDEFAULT_SCOPES: ClassVar[list[str]] = []", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 5, "label": "#5", "successors": []}], "functions": [], "classes": []}, {"name": "get_login_url", "type": "CFG", "blocks": [{"id": 8, "label": "#8\n\"\"\"Constructs a login URL that the user can be redirected to\"\"\"", "successors": []}], "functions": [], "classes": []}, {"name": "exchange_code_for_tokens", "type": "CFG", "blocks": [{"id": 11, "label": "#11\n\"\"\"Exchanges the acquired authorization code from login for a set of tokens\"\"\"", "successors": []}], "functions": [], "classes": []}, {"name": "_refresh_tokens", "type": "CFG", "blocks": [{"id": 14, "label": "#14\n\"\"\"Implements the token refresh mechanism\"\"\"", "successors": []}], "functions": [], "classes": []}, {"name": "revoke_tokens", "type": "CFG", "blocks": [{"id": 17, "label": "#17\n\"\"\"Revokes the given token at provider,\n        returns False provider does not support it\"\"\"", "successors": []}], "functions": [], "classes": []}, {"name": "refresh_tokens", "type": "CFG", "blocks": [{"id": 20, "label": "#20\nif credentials.provider != self.PROVIDER_NAME:", "successors": [{"id": 21, "label": "#21\nraise ValueError(\n    f\"{self.__class__.__name__} can not refresh tokens for other provider '{credentials.provider}'\"\n    )", "successors": []}, {"id": 22, "label": "#22\nreturn self._refresh_tokens(credentials)", "successors": []}]}], "functions": [], "classes": []}, {"name": "get_access_token", "type": "CFG", "blocks": [{"id": 27, "label": "#27\n\"\"\"Returns a valid access token, refreshing it first if needed\"\"\"\nif self.needs_refresh(credentials):", "successors": [{"id": 28, "label": "#28\ncredentials = self.refresh_tokens(credentials)", "successors": [{"id": 29, "label": "#29\nreturn credentials.access_token.get_secret_value()", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "needs_refresh", "type": "CFG", "blocks": [{"id": 33, "label": "#33\n\"\"\"Indicates whether the given tokens need to be refreshed\"\"\"\nreturn credentials.access_token_expires_at is not None and credentials.access_token_expires_at < int(\n    time.time()) + 300", "successors": []}], "functions": [], "classes": []}, {"name": "handle_default_scopes", "type": "CFG", "blocks": [{"id": 37, "label": "#37\n\"\"\"Handles the default scopes for the provider\"\"\"\nif not scopes:", "successors": [{"id": 38, "label": "#38\nlogger.debug(f'Using default scopes for provider {self.PROVIDER_NAME.value}')\nscopes = self.DEFAULT_SCOPES", "successors": [{"id": 39, "label": "#39\nreturn scopes", "successors": []}]}]}], "functions": [], "classes": []}], "classes": []}]}
{"file_name": "129.json", "name": "129.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport datetime\nimport prisma.enums\nimport backend.server.v2.store.model", "successors": []}], "functions": [{"name": "test_pagination", "type": "CFG", "blocks": [{"id": 3, "label": "#3\npagination = backend.server.v2.store.model.Pagination(total_items=100,\n    total_pages=5, current_page=2, page_size=20)\nassert pagination.total_items == 100", "successors": [{"id": 5, "label": "#5\nassert pagination.total_pages == 5", "successors": [{"id": 7, "label": "#7\nassert pagination.current_page == 2", "successors": [{"id": 9, "label": "#9\nassert pagination.page_size == 20", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "test_store_agent", "type": "CFG", "blocks": [{"id": 14, "label": "#14\nagent = backend.server.v2.store.model.StoreAgent(slug='test-agent',\n    agent_name='Test Agent', agent_image='test.jpg', creator='creator1',\n    creator_avatar='avatar.jpg', sub_heading='Test subheading', description\n    ='Test description', runs=50, rating=4.5)\nassert agent.slug == 'test-agent'", "successors": [{"id": 16, "label": "#16\nassert agent.agent_name == 'Test Agent'", "successors": [{"id": 18, "label": "#18\nassert agent.runs == 50", "successors": [{"id": 20, "label": "#20\nassert agent.rating == 4.5", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "test_store_agents_response", "type": "CFG", "blocks": [{"id": 25, "label": "#25\nresponse = backend.server.v2.store.model.StoreAgentsResponse(agents=[\n    backend.server.v2.store.model.StoreAgent(slug='test-agent', agent_name=\n    'Test Agent', agent_image='test.jpg', creator='creator1',\n    creator_avatar='avatar.jpg', sub_heading='Test subheading', description\n    ='Test description', runs=50, rating=4.5)], pagination=backend.server.\n    v2.store.model.Pagination(total_items=1, total_pages=1, current_page=1,\n    page_size=20))\nassert len(response.agents) == 1", "successors": [{"id": 27, "label": "#27\nassert response.pagination.total_items == 1", "successors": []}]}], "functions": [], "classes": []}, {"name": "test_store_agent_details", "type": "CFG", "blocks": [{"id": 32, "label": "#32\ndetails = backend.server.v2.store.model.StoreAgentDetails(\n    store_listing_version_id='version123', slug='test-agent', agent_name=\n    'Test Agent', agent_video='video.mp4', agent_image=['image1.jpg',\n    'image2.jpg'], creator='creator1', creator_avatar='avatar.jpg',\n    sub_heading='Test subheading', description='Test description',\n    categories=['cat1', 'cat2'], runs=50, rating=4.5, versions=['1.0',\n    '2.0'], last_updated=datetime.datetime.now())\nassert details.slug == 'test-agent'", "successors": [{"id": 34, "label": "#34\nassert len(details.agent_image) == 2", "successors": [{"id": 36, "label": "#36\nassert len(details.categories) == 2", "successors": [{"id": 38, "label": "#38\nassert len(details.versions) == 2", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "test_creator", "type": "CFG", "blocks": [{"id": 43, "label": "#43\ncreator = backend.server.v2.store.model.Creator(agent_rating=4.8,\n    agent_runs=1000, name='Test Creator', username='creator1', description=\n    'Test description', avatar_url='avatar.jpg', num_agents=5, is_featured=\n    False)\nassert creator.name == 'Test Creator'", "successors": [{"id": 45, "label": "#45\nassert creator.num_agents == 5", "successors": []}]}], "functions": [], "classes": []}, {"name": "test_creators_response", "type": "CFG", "blocks": [{"id": 50, "label": "#50\nresponse = backend.server.v2.store.model.CreatorsResponse(creators=[backend\n    .server.v2.store.model.Creator(agent_rating=4.8, agent_runs=1000, name=\n    'Test Creator', username='creator1', description='Test description',\n    avatar_url='avatar.jpg', num_agents=5, is_featured=False)], pagination=\n    backend.server.v2.store.model.Pagination(total_items=1, total_pages=1,\n    current_page=1, page_size=20))\nassert len(response.creators) == 1", "successors": [{"id": 52, "label": "#52\nassert response.pagination.total_items == 1", "successors": []}]}], "functions": [], "classes": []}, {"name": "test_creator_details", "type": "CFG", "blocks": [{"id": 57, "label": "#57\ndetails = backend.server.v2.store.model.CreatorDetails(name='Test Creator',\n    username='creator1', description='Test description', links=['link1.com',\n    'link2.com'], avatar_url='avatar.jpg', agent_rating=4.8, agent_runs=\n    1000, top_categories=['cat1', 'cat2'])\nassert details.name == 'Test Creator'", "successors": [{"id": 59, "label": "#59\nassert len(details.links) == 2", "successors": [{"id": 61, "label": "#61\nassert details.agent_rating == 4.8", "successors": [{"id": 63, "label": "#63\nassert len(details.top_categories) == 2", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "test_store_submission", "type": "CFG", "blocks": [{"id": 68, "label": "#68\nsubmission = backend.server.v2.store.model.StoreSubmission(agent_id=\n    'agent123', agent_version=1, sub_heading='Test subheading', name=\n    'Test Agent', slug='test-agent', description='Test description',\n    image_urls=['image1.jpg', 'image2.jpg'], date_submitted=datetime.\n    datetime(2023, 1, 1), status=prisma.enums.SubmissionStatus.PENDING,\n    runs=50, rating=4.5)\nassert submission.name == 'Test Agent'", "successors": [{"id": 70, "label": "#70\nassert len(submission.image_urls) == 2", "successors": [{"id": 72, "label": "#72\nassert submission.status == prisma.enums.SubmissionStatus.PENDING", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "test_store_submissions_response", "type": "CFG", "blocks": [{"id": 77, "label": "#77\nresponse = backend.server.v2.store.model.StoreSubmissionsResponse(submissions\n    =[backend.server.v2.store.model.StoreSubmission(agent_id='agent123',\n    agent_version=1, sub_heading='Test subheading', name='Test Agent', slug\n    ='test-agent', description='Test description', image_urls=['image1.jpg'\n    ], date_submitted=datetime.datetime(2023, 1, 1), status=prisma.enums.\n    SubmissionStatus.PENDING, runs=50, rating=4.5)], pagination=backend.\n    server.v2.store.model.Pagination(total_items=1, total_pages=1,\n    current_page=1, page_size=20))\nassert len(response.submissions) == 1", "successors": [{"id": 79, "label": "#79\nassert response.pagination.total_items == 1", "successors": []}]}], "functions": [], "classes": []}, {"name": "test_store_submission_request", "type": "CFG", "blocks": [{"id": 84, "label": "#84\nrequest = backend.server.v2.store.model.StoreSubmissionRequest(agent_id=\n    'agent123', agent_version=1, slug='test-agent', name='Test Agent',\n    sub_heading='Test subheading', video_url='video.mp4', image_urls=[\n    'image1.jpg', 'image2.jpg'], description='Test description', categories\n    =['cat1', 'cat2'])\nassert request.agent_id == 'agent123'", "successors": [{"id": 86, "label": "#86\nassert request.agent_version == 1", "successors": [{"id": 88, "label": "#88\nassert len(request.image_urls) == 2", "successors": [{"id": 90, "label": "#90\nassert len(request.categories) == 2", "successors": []}]}]}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "130.json", "name": "130.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom typing import List, Optional\nfrom pydantic import BaseModel\nfrom backend.blocks.exa._auth import ExaCredentials, ExaCredentialsField, ExaCredentialsInput\nfrom backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema\nfrom backend.data.model import SchemaField\nfrom backend.util.request import requests", "successors": []}], "functions": [], "classes": [{"name": "ContentRetrievalSettings", "type": "CFG", "blocks": [{"id": 3, "label": "#3\ntext: Optional[dict] = SchemaField(description='Text content settings',\n    default={'maxCharacters': 1000, 'includeHtmlTags': False}, advanced=True)\nhighlights: Optional[dict] = SchemaField(description='Highlight settings',\n    default={'numSentences': 3, 'highlightsPerUrl': 3, 'query': ''},\n    advanced=True)\nsummary: Optional[dict] = SchemaField(description='Summary settings',\n    default={'query': ''}, advanced=True)", "successors": []}], "functions": [], "classes": []}, {"name": "ExaContentsBlock", "type": "CFG", "blocks": [{"id": 6, "label": "#6", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 14, "label": "#14\nsuper().__init__(id='c52be83f-f8cd-4180-b243-af35f986b461', description=\n    \"Retrieves document contents using Exa's contents API\", categories={\n    BlockCategory.SEARCH}, input_schema=ExaContentsBlock.Input,\n    output_schema=ExaContentsBlock.Output)", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 17, "label": "#17\nurl = 'https://api.exa.ai/contents'\nheaders = {'Content-Type': 'application/json', 'x-api-key': credentials.\n    api_key.get_secret_value()}\npayload = {'ids': input_data.ids, 'text': input_data.contents.text,\n    'highlights': input_data.contents.highlights, 'summary': input_data.\n    contents.summary}\ntry:", "successors": [{"id": 18, "label": "#18\nresponse = requests.post(url, headers=headers, json=payload)\nresponse.raise_for_status()\ndata = response.json()\nyield 'results', data.get('results', [])", "successors": []}, {"id": 19, "label": "#19\nyield 'error', str(e)", "successors": [{"id": 22, "label": "#22\nyield 'results', []", "successors": []}]}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 8, "label": "#8\ncredentials: ExaCredentialsInput = ExaCredentialsField()\nids: List[str] = SchemaField(description=\n    'Array of document IDs obtained from searches')\ncontents: ContentRetrievalSettings = SchemaField(description=\n    'Content retrieval settings', default=ContentRetrievalSettings(),\n    advanced=True)", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 11, "label": "#11\nresults: list = SchemaField(description='List of document contents', default=[]\n    )", "successors": []}], "functions": [], "classes": []}]}]}
{"file_name": "131.json", "name": "131.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport logging\nfrom typing import TYPE_CHECKING, AsyncGenerator, Optional\nfrom prisma import Json\nfrom prisma.models import IntegrationWebhook\nfrom pydantic import Field, computed_field\nfrom backend.data.includes import INTEGRATION_WEBHOOK_INCLUDE\nfrom backend.data.queue import AsyncRedisEventBus\nfrom backend.integrations.providers import ProviderName\nfrom backend.integrations.webhooks.utils import webhook_ingress_url\nfrom .db import BaseDbModel\nif TYPE_CHECKING:", "successors": [{"id": 2, "label": "#2\nfrom .graph import NodeModel", "successors": [{"id": 3, "label": "#3\nlogger = logging.getLogger(__name__)\n_webhook_event_bus = WebhookEventBus()", "successors": []}]}]}], "functions": [{"name": "create_webhook", "type": "CFG", "blocks": [{"id": 16, "label": "#16\ncreated_webhook = await IntegrationWebhook.prisma().create(data={'id':\n    webhook.id, 'userId': webhook.user_id, 'provider': webhook.provider.\n    value, 'credentialsId': webhook.credentials_id, 'webhookType': webhook.\n    webhook_type, 'resource': webhook.resource, 'events': webhook.events,\n    'config': Json(webhook.config), 'secret': webhook.secret,\n    'providerWebhookId': webhook.provider_webhook_id})", "successors": [{"id": 17, "label": "#17\nreturn Webhook.from_db(created_webhook)", "successors": []}]}], "functions": [], "classes": []}, {"name": "get_webhook", "type": "CFG", "blocks": [{"id": 21, "label": "#21\n\"\"\"\u26a0\ufe0f No `user_id` check: DO NOT USE without check in user-facing endpoints.\"\"\"\nwebhook = await IntegrationWebhook.prisma().find_unique_or_raise(where={\n    'id': webhook_id}, include=INTEGRATION_WEBHOOK_INCLUDE)", "successors": [{"id": 22, "label": "#22\nreturn Webhook.from_db(webhook)", "successors": []}]}], "functions": [], "classes": []}, {"name": "get_all_webhooks_by_creds", "type": "CFG", "blocks": [{"id": 26, "label": "#26\n\"\"\"\u26a0\ufe0f No `user_id` check: DO NOT USE without check in user-facing endpoints.\"\"\"\nif not credentials_id:", "successors": [{"id": 27, "label": "#27\nraise ValueError('credentials_id must not be empty')", "successors": []}, {"id": 28, "label": "#28\nwebhooks = await IntegrationWebhook.prisma().find_many(where={\n    'credentialsId': credentials_id}, include=INTEGRATION_WEBHOOK_INCLUDE)", "successors": [{"id": 30, "label": "#30\nreturn [Webhook.from_db(webhook) for webhook in webhooks]", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "find_webhook_by_credentials_and_props", "type": "CFG", "blocks": [{"id": 34, "label": "#34\n\"\"\"\u26a0\ufe0f No `user_id` check: DO NOT USE without check in user-facing endpoints.\"\"\"\nwebhook = await IntegrationWebhook.prisma().find_first(where={\n    'credentialsId': credentials_id, 'webhookType': webhook_type,\n    'resource': resource, 'events': {'has_every': events}}, include=\n    INTEGRATION_WEBHOOK_INCLUDE)", "successors": [{"id": 35, "label": "#35\nreturn Webhook.from_db(webhook) if webhook else None", "successors": []}]}], "functions": [], "classes": []}, {"name": "find_webhook_by_graph_and_props", "type": "CFG", "blocks": [{"id": 39, "label": "#39\n\"\"\"\u26a0\ufe0f No `user_id` check: DO NOT USE without check in user-facing endpoints.\"\"\"\nwebhook = await IntegrationWebhook.prisma().find_first(where={'provider':\n    provider, 'webhookType': webhook_type, 'events': {'has_every': events},\n    'AgentNodes': {'some': {'agentGraphId': graph_id}}}, include=\n    INTEGRATION_WEBHOOK_INCLUDE)", "successors": [{"id": 40, "label": "#40\nreturn Webhook.from_db(webhook) if webhook else None", "successors": []}]}], "functions": [], "classes": []}, {"name": "update_webhook_config", "type": "CFG", "blocks": [{"id": 44, "label": "#44\n\"\"\"\u26a0\ufe0f No `user_id` check: DO NOT USE without check in user-facing endpoints.\"\"\"\n_updated_webhook = await IntegrationWebhook.prisma().update(where={'id':\n    webhook_id}, data={'config': Json(updated_config)}, include=\n    INTEGRATION_WEBHOOK_INCLUDE)", "successors": [{"id": 45, "label": "#45\nif _updated_webhook is None:", "successors": [{"id": 46, "label": "#46\nraise ValueError(f'Webhook #{webhook_id} not found')", "successors": []}, {"id": 47, "label": "#47\nreturn Webhook.from_db(_updated_webhook)", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "delete_webhook", "type": "CFG", "blocks": [{"id": 52, "label": "#52\n\"\"\"\u26a0\ufe0f No `user_id` check: DO NOT USE without check in user-facing endpoints.\"\"\"\ndeleted = await IntegrationWebhook.prisma().delete(where={'id': webhook_id})", "successors": [{"id": 53, "label": "#53\nif not deleted:", "successors": [{"id": 54, "label": "#54\nraise ValueError(f'Webhook #{webhook_id} not found')", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "publish_webhook_event", "type": "CFG", "blocks": [{"id": 69, "label": "#69\nawait _webhook_event_bus.publish_event(event,\n    f'{event.webhook_id}/{event.event_type}')", "successors": []}], "functions": [], "classes": []}, {"name": "listen_for_webhook_events", "type": "CFG", "blocks": [{"id": 73, "label": "#73\nasync for event in _webhook_event_bus.listen_events(\n    f\"{webhook_id}/{event_type or '*'}\"):\n    yield event", "successors": [{"id": 74, "label": "#74\nyield event", "successors": []}]}], "functions": [], "classes": []}, {"name": "wait_for_webhook_event", "type": "CFG", "blocks": [{"id": 79, "label": "#79\nreturn await _webhook_event_bus.wait_for_event(\n    f\"{webhook_id}/{event_type or '*'}\", timeout)", "successors": []}], "functions": [], "classes": []}], "classes": [{"name": "Webhook", "type": "CFG", "blocks": [{"id": 5, "label": "#5\nuser_id: str\nprovider: ProviderName\ncredentials_id: str\nwebhook_type: str\nresource: str\nevents: list[str]\nconfig: dict = Field(default_factory=dict)\nsecret: str\nprovider_webhook_id: str\nattached_nodes: Optional[list['NodeModel']] = None", "successors": []}], "functions": [{"name": "url", "type": "CFG", "blocks": [{"id": 7, "label": "#7\nreturn webhook_ingress_url(self.provider.value, self.id)", "successors": []}], "functions": [], "classes": []}, {"name": "from_db", "type": "CFG", "blocks": [{"id": 11, "label": "#11\nfrom .graph import NodeModel\nreturn Webhook(id=webhook.id, user_id=webhook.userId, provider=ProviderName\n    (webhook.provider), credentials_id=webhook.credentialsId, webhook_type=\n    webhook.webhookType, resource=webhook.resource, events=webhook.events,\n    config=dict(webhook.config), secret=webhook.secret, provider_webhook_id\n    =webhook.providerWebhookId, attached_nodes=[NodeModel.from_db(node) for\n    node in webhook.AgentNodes] if webhook.AgentNodes is not None else None)", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "WebhookEvent", "type": "CFG", "blocks": [{"id": 59, "label": "#59\nprovider: str\nwebhook_id: str\nevent_type: str\npayload: dict", "successors": []}], "functions": [], "classes": []}, {"name": "WebhookEventBus", "type": "CFG", "blocks": [{"id": 62, "label": "#62\nModel = WebhookEvent", "successors": []}], "functions": [{"name": "event_bus_name", "type": "CFG", "blocks": [{"id": 64, "label": "#64\nreturn 'webhooks'", "successors": []}], "functions": [], "classes": []}], "classes": []}]}
{"file_name": "132.json", "name": "132.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nif __name__ == '__main__':", "successors": [{"id": 12, "label": "#12\nimport doctest\ndoctest.testmod()", "successors": []}]}], "functions": [{"name": "get_1s_count", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"\n    Count the number of set bits in a 32 bit integer using Brian Kernighan's way.\n    Ref - https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetKernighan\n    >>> get_1s_count(25)\n    3\n    >>> get_1s_count(37)\n    3\n    >>> get_1s_count(21)\n    3\n    >>> get_1s_count(58)\n    4\n    >>> get_1s_count(0)\n    0\n    >>> get_1s_count(256)\n    1\n    >>> get_1s_count(-1)\n    Traceback (most recent call last):\n    ValueError: Input must be a non-negative integer\n    >>> get_1s_count(0.8)\n    Traceback (most recent call last):\n    ValueError: Input must be a non-negative integer\n    >>> get_1s_count(\"25\")\n    Traceback (most recent call last):\n    ValueError: Input must be a non-negative integer\n    \"\"\"\nif not isinstance(number, int) or number < 0:", "successors": [{"id": 4, "label": "#4\nraise ValueError('Input must be a non-negative integer')", "successors": []}, {"id": 5, "label": "#5\ncount = 0", "successors": [{"id": 7, "label": "#7\nwhile number:", "successors": [{"id": 8, "label": "#8\nnumber &= number - 1\ncount += 1", "successors": []}, {"id": 9, "label": "#9\nreturn count", "successors": []}]}]}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "133.json", "name": "133.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport asyncio\nimport random\nfrom datetime import datetime\nimport prisma.enums\nfrom faker import Faker\nfrom prisma import Prisma\nfaker = Faker()\nNUM_USERS = 100\nNUM_AGENT_BLOCKS = 100\nMIN_GRAPHS_PER_USER = 1\nMAX_GRAPHS_PER_USER = 5\nMIN_NODES_PER_GRAPH = 2\nMAX_NODES_PER_GRAPH = 5\nMIN_PRESETS_PER_USER = 1\nMAX_PRESETS_PER_USER = 5\nMIN_AGENTS_PER_USER = 1\nMAX_AGENTS_PER_USER = 10\nMIN_EXECUTIONS_PER_GRAPH = 1\nMAX_EXECUTIONS_PER_GRAPH = 20\nMIN_REVIEWS_PER_VERSION = 1\nMAX_REVIEWS_PER_VERSION = 5\nif __name__ == '__main__':", "successors": [{"id": 120, "label": "#120\nasyncio.run(main())", "successors": []}]}], "functions": [{"name": "get_image", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nurl = faker.image_url()", "successors": [{"id": 4, "label": "#4\nwhile 'placekitten.com' in url:", "successors": [{"id": 5, "label": "#5\nurl = faker.image_url()", "successors": []}, {"id": 6, "label": "#6\nreturn url", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "main", "type": "CFG", "blocks": [{"id": 10, "label": "#10\ndb = Prisma()\nawait db.connect()", "successors": [{"id": 11, "label": "#11\nprint(f'Inserting {NUM_USERS} users')\nusers = []", "successors": [{"id": 12, "label": "#12\nfor _ in range(NUM_USERS):", "successors": [{"id": 13, "label": "#13\nuser = await db.user.create(data={'id': str(faker.uuid4()), 'email': faker.\n    unique.email(), 'name': faker.name(), 'metadata': prisma.Json({}),\n    'integrations': ''})", "successors": [{"id": 15, "label": "#15\nusers.append(user)", "successors": []}]}, {"id": 14, "label": "#14\nagent_blocks = []\nprint(f'Inserting {NUM_AGENT_BLOCKS} agent blocks')", "successors": [{"id": 16, "label": "#16\nfor _ in range(NUM_AGENT_BLOCKS):", "successors": [{"id": 17, "label": "#17\nblock = await db.agentblock.create(data={'name':\n    f'{faker.word()}_{str(faker.uuid4())[:8]}', 'inputSchema': '{}',\n    'outputSchema': '{}'})", "successors": [{"id": 19, "label": "#19\nagent_blocks.append(block)", "successors": []}]}, {"id": 18, "label": "#18\nagent_graphs = []\nprint(f'Inserting {NUM_USERS * MAX_GRAPHS_PER_USER} agent graphs')", "successors": [{"id": 20, "label": "#20\nfor user in users:", "successors": [{"id": 21, "label": "#21\nfor _ in range(random.randint(MIN_GRAPHS_PER_USER, MAX_GRAPHS_PER_USER)):", "successors": [{"id": 23, "label": "#23\ngraph = await db.agentgraph.create(data={'name': faker.sentence(nb_words=3),\n    'description': faker.text(max_nb_chars=200), 'userId': user.id,\n    'isActive': True, 'isTemplate': False})", "successors": [{"id": 25, "label": "#25\nagent_graphs.append(graph)", "successors": []}]}]}, {"id": 22, "label": "#22\nagent_nodes = []\nprint(\n    f'Inserting {NUM_USERS * MAX_GRAPHS_PER_USER * MAX_NODES_PER_GRAPH} agent nodes'\n    )", "successors": [{"id": 26, "label": "#26\nfor graph in agent_graphs:", "successors": [{"id": 27, "label": "#27\nnum_nodes = random.randint(MIN_NODES_PER_GRAPH, MAX_NODES_PER_GRAPH)", "successors": [{"id": 29, "label": "#29\nfor _ in range(num_nodes):", "successors": [{"id": 30, "label": "#30\nblock = random.choice(agent_blocks)\nnode = await db.agentnode.create(data={'agentBlockId': block.id,\n    'agentGraphId': graph.id, 'agentGraphVersion': graph.version,\n    'constantInput': '{}', 'metadata': '{}'})", "successors": [{"id": 32, "label": "#32\nagent_nodes.append(node)", "successors": []}]}]}]}, {"id": 28, "label": "#28\nagent_presets = []\nprint(f'Inserting {NUM_USERS * MAX_PRESETS_PER_USER} agent presets')", "successors": [{"id": 33, "label": "#33\nfor user in users:", "successors": [{"id": 34, "label": "#34\nnum_presets = random.randint(MIN_PRESETS_PER_USER, MAX_PRESETS_PER_USER)", "successors": [{"id": 36, "label": "#36\nfor _ in range(num_presets):", "successors": [{"id": 37, "label": "#37\ngraph = random.choice(agent_graphs)\npreset = await db.agentpreset.create(data={'name': faker.sentence(nb_words=\n    3), 'description': faker.text(max_nb_chars=200), 'userId': user.id,\n    'agentId': graph.id, 'agentVersion': graph.version, 'isActive': True})", "successors": [{"id": 39, "label": "#39\nagent_presets.append(preset)", "successors": []}]}]}]}, {"id": 35, "label": "#35\nuser_agents = []\nprint(f'Inserting {NUM_USERS * MAX_AGENTS_PER_USER} user agents')", "successors": [{"id": 40, "label": "#40\nfor user in users:", "successors": [{"id": 41, "label": "#41\nnum_agents = random.randint(MIN_AGENTS_PER_USER, MAX_AGENTS_PER_USER)", "successors": [{"id": 43, "label": "#43\nfor _ in range(num_agents):", "successors": [{"id": 44, "label": "#44\ngraph = random.choice(agent_graphs)\npreset = random.choice(agent_presets)\nuser_agent = await db.useragent.create(data={'userId': user.id, 'agentId':\n    graph.id, 'agentVersion': graph.version, 'agentPresetId': preset.id,\n    'isFavorite': random.choice([True, False]), 'isCreatedByUser': random.\n    choice([True, False]), 'isArchived': random.choice([True, False]),\n    'isDeleted': random.choice([True, False])})", "successors": [{"id": 46, "label": "#46\nuser_agents.append(user_agent)", "successors": []}]}]}]}, {"id": 42, "label": "#42\nagent_graph_executions = []\nprint(\n    f'Inserting {NUM_USERS * MAX_GRAPHS_PER_USER * MAX_EXECUTIONS_PER_GRAPH} agent graph executions'\n    )\ngraph_execution_data = []", "successors": [{"id": 47, "label": "#47\nfor graph in agent_graphs:", "successors": [{"id": 48, "label": "#48\nuser = random.choice(users)\nnum_executions = random.randint(MIN_EXECUTIONS_PER_GRAPH,\n    MAX_EXECUTIONS_PER_GRAPH)", "successors": [{"id": 50, "label": "#50\nfor _ in range(num_executions):", "successors": [{"id": 51, "label": "#51\nmatching_presets = [p for p in agent_presets if p.agentId == graph.id]\npreset = random.choice(matching_presets) if matching_presets and random.random(\n    ) < 0.5 else None\ngraph_execution_data.append({'agentGraphId': graph.id, 'agentGraphVersion':\n    graph.version, 'userId': user.id, 'executionStatus': prisma.enums.\n    AgentExecutionStatus.COMPLETED, 'startedAt': faker.date_time_this_year(\n    ), 'agentPresetId': preset.id if preset else None})", "successors": []}]}]}, {"id": 49, "label": "#49\nagent_graph_executions = await db.agentgraphexecution.create_many(data=\n    graph_execution_data)", "successors": [{"id": 53, "label": "#53\nagent_graph_executions = await db.agentgraphexecution.find_many()", "successors": [{"id": 54, "label": "#54\nprint(\n    f'Inserting {NUM_USERS * MAX_GRAPHS_PER_USER * MAX_EXECUTIONS_PER_GRAPH} agent node executions'\n    )\nnode_execution_data = []", "successors": [{"id": 55, "label": "#55\nfor execution in agent_graph_executions:", "successors": [{"id": 56, "label": "#56\nnodes = [node for node in agent_nodes if node.agentGraphId == execution.\n    agentGraphId]", "successors": [{"id": 58, "label": "#58\nfor node in nodes:", "successors": [{"id": 59, "label": "#59\nnode_execution_data.append({'agentGraphExecutionId': execution.id,\n    'agentNodeId': node.id, 'executionStatus': prisma.enums.\n    AgentExecutionStatus.COMPLETED, 'addedTime': datetime.now()})", "successors": []}]}]}, {"id": 57, "label": "#57\nagent_node_executions = await db.agentnodeexecution.create_many(data=\n    node_execution_data)", "successors": [{"id": 61, "label": "#61\nagent_node_executions = await db.agentnodeexecution.find_many()", "successors": [{"id": 62, "label": "#62\nprint(\n    f'Inserting {NUM_USERS * MAX_GRAPHS_PER_USER * MAX_EXECUTIONS_PER_GRAPH} agent node execution input/outputs'\n    )\ninput_output_data = []", "successors": [{"id": 63, "label": "#63\nfor node_execution in agent_node_executions:", "successors": [{"id": 64, "label": "#64\ninput_output_data.append({'name': 'input1', 'data': '{}', 'time': datetime.\n    now(), 'referencedByInputExecId': node_execution.id})\ninput_output_data.append({'name': 'output1', 'data': '{}', 'time': datetime\n    .now(), 'referencedByOutputExecId': node_execution.id})", "successors": []}, {"id": 65, "label": "#65\nawait db.agentnodeexecutioninputoutput.create_many(data=input_output_data)", "successors": [{"id": 66, "label": "#66\nprint(f'Inserting {NUM_USERS * MAX_GRAPHS_PER_USER} agent node links')", "successors": [{"id": 67, "label": "#67\nfor graph in agent_graphs:", "successors": [{"id": 68, "label": "#68\nnodes = [node for node in agent_nodes if node.agentGraphId == graph.id]\nif len(nodes) >= 2:", "successors": [{"id": 70, "label": "#70\nsource_node = nodes[0]\nsink_node = nodes[1]\nawait db.agentnodelink.create(data={'agentNodeSourceId': source_node.id,\n    'sourceName': 'output1', 'agentNodeSinkId': sink_node.id, 'sinkName':\n    'input1', 'isStatic': False})", "successors": []}]}, {"id": 69, "label": "#69\nprint(f'Inserting {NUM_USERS} analytics details')", "successors": [{"id": 73, "label": "#73\nfor user in users:", "successors": [{"id": 74, "label": "#74\nfor _ in range(1):", "successors": [{"id": 76, "label": "#76\nawait db.analyticsdetails.create(data={'userId': user.id, 'type': faker.\n    word(), 'data': prisma.Json({}), 'dataIndex': faker.word()})", "successors": []}]}, {"id": 75, "label": "#75\nprint(f'Inserting {NUM_USERS} analytics metrics')", "successors": [{"id": 79, "label": "#79\nfor user in users:", "successors": [{"id": 80, "label": "#80\nfor _ in range(1):", "successors": [{"id": 82, "label": "#82\nawait db.analyticsmetrics.create(data={'userId': user.id, 'analyticMetric':\n    faker.word(), 'value': random.uniform(0, 100), 'dataString': faker.word()})", "successors": []}]}, {"id": 81, "label": "#81\nprint(f'Inserting {NUM_USERS} credit transactions')", "successors": [{"id": 85, "label": "#85\nfor user in users:", "successors": [{"id": 86, "label": "#86\nfor _ in range(1):", "successors": [{"id": 88, "label": "#88\nblock = random.choice(agent_blocks)\nawait db.credittransaction.create(data={'transactionKey': str(faker.uuid4()\n    ), 'userId': user.id, 'blockId': block.id, 'amount': random.randint(1, \n    100), 'type': prisma.enums.CreditTransactionType.TOP_UP if random.\n    random() < 0.5 else prisma.enums.CreditTransactionType.USAGE,\n    'metadata': prisma.Json({})})", "successors": []}]}, {"id": 87, "label": "#87\nprofiles = []\nprint(f'Inserting {NUM_USERS} profiles')", "successors": [{"id": 91, "label": "#91\nfor user in users:", "successors": [{"id": 92, "label": "#92\nprofile = await db.profile.create(data={'userId': user.id, 'name': user.\n    name or faker.name(), 'username': faker.unique.user_name(),\n    'description': faker.text(), 'links': [faker.url() for _ in range(3)],\n    'avatarUrl': get_image()})", "successors": [{"id": 94, "label": "#94\nprofiles.append(profile)", "successors": []}]}, {"id": 93, "label": "#93\nstore_listings = []\nprint(f'Inserting {NUM_USERS} store listings')", "successors": [{"id": 95, "label": "#95\nfor graph in agent_graphs:", "successors": [{"id": 96, "label": "#96\nuser = random.choice(users)\nlisting = await db.storelisting.create(data={'agentId': graph.id,\n    'agentVersion': graph.version, 'owningUserId': user.id, 'isApproved':\n    random.choice([True, False])})", "successors": [{"id": 98, "label": "#98\nstore_listings.append(listing)", "successors": []}]}, {"id": 97, "label": "#97\nstore_listing_versions = []\nprint(f'Inserting {NUM_USERS} store listing versions')", "successors": [{"id": 99, "label": "#99\nfor listing in store_listings:", "successors": [{"id": 100, "label": "#100\ngraph = [g for g in agent_graphs if g.id == listing.agentId][0]\nversion = await db.storelistingversion.create(data={'agentId': graph.id,\n    'agentVersion': graph.version, 'slug': faker.slug(), 'name': graph.name or\n    faker.sentence(nb_words=3), 'subHeading': faker.sentence(), 'videoUrl':\n    faker.url(), 'imageUrls': [get_image() for _ in range(3)],\n    'description': faker.text(), 'categories': [faker.word() for _ in range\n    (3)], 'isFeatured': random.choice([True, False]), 'isAvailable': True,\n    'isApproved': random.choice([True, False]), 'storeListingId': listing.id})", "successors": [{"id": 102, "label": "#102\nstore_listing_versions.append(version)", "successors": []}]}, {"id": 101, "label": "#101\nprint(f'Inserting {NUM_USERS * MAX_REVIEWS_PER_VERSION} store listing reviews')", "successors": [{"id": 103, "label": "#103\nfor version in store_listing_versions:", "successors": [{"id": 104, "label": "#104\navailable_reviewers = users.copy()\nrandom.shuffle(available_reviewers)\nnum_reviews = min(random.randint(MIN_REVIEWS_PER_VERSION,\n    MAX_REVIEWS_PER_VERSION), len(available_reviewers))", "successors": [{"id": 106, "label": "#106\nfor reviewer in available_reviewers[:num_reviews]:", "successors": [{"id": 107, "label": "#107\nawait db.storelistingreview.create(data={'storeListingVersionId': version.\n    id, 'reviewByUserId': reviewer.id, 'score': random.randint(1, 5),\n    'comments': faker.text()})", "successors": []}]}]}, {"id": 105, "label": "#105\nprint(f'Inserting {NUM_USERS} store listing submissions')", "successors": [{"id": 110, "label": "#110\nfor listing in store_listings:", "successors": [{"id": 111, "label": "#111\nversion = random.choice(store_listing_versions)\nreviewer = random.choice(users)\nstatus: prisma.enums.SubmissionStatus = random.choice([prisma.enums.\n    SubmissionStatus.PENDING, prisma.enums.SubmissionStatus.APPROVED,\n    prisma.enums.SubmissionStatus.REJECTED])\nawait db.storelistingsubmission.create(data={'storeListingId': listing.id,\n    'storeListingVersionId': version.id, 'reviewerId': reviewer.id,\n    'Status': status, 'reviewComments': faker.text()})", "successors": []}, {"id": 112, "label": "#112\nprint(f'Inserting {NUM_USERS} api keys')", "successors": [{"id": 114, "label": "#114\nfor user in users:", "successors": [{"id": 115, "label": "#115\nawait db.apikey.create(data={'name': faker.word(), 'prefix': str(faker.\n    uuid4())[:8], 'postfix': str(faker.uuid4())[-8:], 'key': str(faker.\n    sha256()), 'status': prisma.enums.APIKeyStatus.ACTIVE, 'permissions': [\n    prisma.enums.APIKeyPermission.EXECUTE_GRAPH, prisma.enums.\n    APIKeyPermission.READ_GRAPH], 'description': faker.text(), 'userId':\n    user.id})", "successors": []}, {"id": 116, "label": "#116\nawait db.disconnect()", "successors": []}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "134.json", "name": "134.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport json\nimport logging\nfrom pathlib import Path\nfrom pydantic import BaseModel\nfrom backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema, BlockWebhookConfig\nfrom backend.data.model import SchemaField\nfrom ._auth import TEST_CREDENTIALS, TEST_CREDENTIALS_INPUT, GithubCredentialsField, GithubCredentialsInput\nlogger = logging.getLogger(__name__)", "successors": []}], "functions": [], "classes": [{"name": "GitHubTriggerBase", "type": "CFG", "blocks": [{"id": 3, "label": "#3", "successors": []}], "functions": [{"name": "run", "type": "CFG", "blocks": [{"id": 11, "label": "#11\nyield 'payload', input_data.payload", "successors": [{"id": 12, "label": "#12\nyield 'triggered_by_user', input_data.payload['sender']", "successors": []}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 5, "label": "#5\ncredentials: GithubCredentialsInput = GithubCredentialsField('repo')\nrepo: str = SchemaField(description=\n    \"\"\"Repository to subscribe to.\n\n**Note:** Make sure your GitHub credentials have permissions to create webhooks on this repo.\"\"\"\n    , placeholder='{owner}/{repo}')\npayload: dict = SchemaField(hidden=True, default={})", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 8, "label": "#8\npayload: dict = SchemaField(description=\n    'The complete webhook payload that was received from GitHub. Includes information about the affected resource (e.g. pull request), the event, and the user who triggered the event.'\n    )\ntriggered_by_user: dict = SchemaField(description=\n    'Object representing the GitHub user who triggered the event')\nerror: str = SchemaField(description=\n    'Error message if the payload could not be processed')", "successors": []}], "functions": [], "classes": []}]}, {"name": "GithubPullRequestTriggerBlock", "type": "CFG", "blocks": [{"id": 17, "label": "#17\nEXAMPLE_PAYLOAD_FILE = Path(__file__\n    ).parent / 'example_payloads' / 'pull_request.synchronize.json'", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 28, "label": "#28\nfrom backend.integrations.webhooks.github import GithubWebhookType\nexample_payload = json.loads(self.EXAMPLE_PAYLOAD_FILE.read_text(encoding=\n    'utf-8'))\nsuper().__init__(id='6c60ec01-8128-419e-988f-96a063ee2fea', description=\n    'This block triggers on pull request events and outputs the event type and payload.'\n    , categories={BlockCategory.DEVELOPER_TOOLS, BlockCategory.INPUT},\n    input_schema=GithubPullRequestTriggerBlock.Input, output_schema=\n    GithubPullRequestTriggerBlock.Output, webhook_config=BlockWebhookConfig\n    (provider='github', webhook_type=GithubWebhookType.REPO,\n    resource_format='{repo}', event_filter_input='events', event_format=\n    'pull_request.{event}'), test_input={'repo':\n    'Significant-Gravitas/AutoGPT', 'events': {'opened': True,\n    'synchronize': True}, 'credentials': TEST_CREDENTIALS_INPUT, 'payload':\n    example_payload}, test_credentials=TEST_CREDENTIALS, test_output=[(\n    'payload', example_payload), ('triggered_by_user', example_payload[\n    'sender']), ('event', example_payload['action']), ('number',\n    example_payload['number']), ('pull_request', example_payload[\n    'pull_request']), ('pull_request_url', example_payload['pull_request'][\n    'html_url'])])", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 31, "label": "#31\nyield from super().run(input_data, **kwargs)\nyield 'event', input_data.payload['action']", "successors": [{"id": 32, "label": "#32\nyield 'number', input_data.payload['number']", "successors": [{"id": 33, "label": "#33\nyield 'pull_request', input_data.payload['pull_request']", "successors": [{"id": 34, "label": "#34\nyield 'pull_request_url', input_data.payload['pull_request']['html_url']", "successors": []}]}]}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 19, "label": "#19\nevents: EventsFilter = SchemaField(title='Events', description=\n    'The events to subscribe to')", "successors": []}], "functions": [], "classes": [{"name": "EventsFilter", "type": "CFG", "blocks": [{"id": 21, "label": "#21\n\"\"\"\n            https://docs.github.com/en/webhooks/webhook-events-and-payloads#pull_request\n            \"\"\"\nopened: bool = False\nedited: bool = False\nclosed: bool = False\nreopened: bool = False\nsynchronize: bool = False\nassigned: bool = False\nunassigned: bool = False\nlabeled: bool = False\nunlabeled: bool = False\nconverted_to_draft: bool = False\nlocked: bool = False\nunlocked: bool = False\nenqueued: bool = False\ndequeued: bool = False\nmilestoned: bool = False\ndemilestoned: bool = False\nready_for_review: bool = False\nreview_requested: bool = False\nreview_request_removed: bool = False\nauto_merge_enabled: bool = False\nauto_merge_disabled: bool = False", "successors": []}], "functions": [], "classes": []}]}, {"name": "Output", "type": "CFG", "blocks": [{"id": 25, "label": "#25\nevent: str = SchemaField(description=\n    \"The PR event that triggered the webhook (e.g. 'opened')\")\nnumber: int = SchemaField(description='The number of the affected pull request'\n    )\npull_request: dict = SchemaField(description=\n    'Object representing the affected pull request')\npull_request_url: str = SchemaField(description=\n    'The URL of the affected pull request')", "successors": []}], "functions": [], "classes": []}]}]}
{"file_name": "135.json", "name": "135.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom mrjob.job import MRJob\nif __name__ == '__main__':", "successors": [{"id": 23, "label": "#23\nHitCounts.run()", "successors": []}]}], "functions": [], "classes": [{"name": "HitCounts", "type": "CFG", "blocks": [{"id": 3, "label": "#3", "successors": []}], "functions": [{"name": "extract_url", "type": "CFG", "blocks": [{"id": 5, "label": "#5\n\"\"\"Extract the generated url from the log line.\"\"\"\npass", "successors": []}], "functions": [], "classes": []}, {"name": "extract_year_month", "type": "CFG", "blocks": [{"id": 8, "label": "#8\n\"\"\"Return the year and month portions of the timestamp.\"\"\"\npass", "successors": []}], "functions": [], "classes": []}, {"name": "mapper", "type": "CFG", "blocks": [{"id": 11, "label": "#11\n\"\"\"Parse each log line, extract and transform relevant lines.\n\n        Emit key value pairs of the form:\n\n        (2016-01, url0), 1\n        (2016-01, url0), 1\n        (2016-01, url1), 1\n        \"\"\"\nurl = self.extract_url(line)\nperiod = self.extract_year_month(line)\nyield (period, url), 1", "successors": []}], "functions": [], "classes": []}, {"name": "reducer", "type": "CFG", "blocks": [{"id": 15, "label": "#15\n\"\"\"Sum values for each key.\n\n        (2016-01, url0), 2\n        (2016-01, url1), 1\n        \"\"\"\nyield key, sum(values)", "successors": []}], "functions": [], "classes": []}, {"name": "steps", "type": "CFG", "blocks": [{"id": 19, "label": "#19\n\"\"\"Run the map and reduce steps.\"\"\"\nreturn [self.mr(mapper=self.mapper, reducer=self.reducer)]", "successors": []}], "functions": [], "classes": []}], "classes": []}]}
{"file_name": "136.json", "name": "136.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport logging\nimport requests\nfrom fastapi import Request\nfrom backend.data import integrations\nfrom backend.data.model import APIKeyCredentials, Credentials\nfrom backend.integrations.providers import ProviderName\nfrom backend.integrations.webhooks._base import BaseWebhooksManager\nlogger = logging.getLogger(__name__)", "successors": []}], "functions": [], "classes": [{"name": "Slant3DWebhooksManager", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"Manager for Slant3D webhooks\"\"\"\nPROVIDER_NAME = ProviderName.SLANT3D\nBASE_URL = 'https://www.slant3dapi.com/api'", "successors": []}], "functions": [{"name": "_register_webhook", "type": "CFG", "blocks": [{"id": 5, "label": "#5\n\"\"\"Register a new webhook with Slant3D\"\"\"\nif not isinstance(credentials, APIKeyCredentials):", "successors": [{"id": 6, "label": "#6\nraise ValueError('API key is required to register a webhook')", "successors": []}, {"id": 7, "label": "#7\nheaders = {'api-key': credentials.api_key.get_secret_value(),\n    'Content-Type': 'application/json'}\npayload = {'endPoint': ingress_url}\nresponse = requests.post(f'{self.BASE_URL}/customer/webhookSubscribe',\n    headers=headers, json=payload)\nif not response.ok:", "successors": [{"id": 9, "label": "#9\nerror = response.json().get('error', 'Unknown error')\nraise RuntimeError(f'Failed to register webhook: {error}')", "successors": []}, {"id": 10, "label": "#10\nwebhook_config = {'endpoint': ingress_url, 'provider': self.PROVIDER_NAME,\n    'events': ['order.shipped'], 'type': webhook_type}\nreturn '', webhook_config", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "validate_payload", "type": "CFG", "blocks": [{"id": 15, "label": "#15\n\"\"\"Validate incoming webhook payload from Slant3D\"\"\"\npayload = await request.json()", "successors": [{"id": 16, "label": "#16\nrequired_fields = ['orderId', 'status', 'trackingNumber', 'carrierCode']\nmissing_fields = [field for field in required_fields if field not in payload]\nif missing_fields:", "successors": [{"id": 17, "label": "#17\nraise ValueError(f\"Missing required fields: {', '.join(missing_fields)}\")", "successors": []}, {"id": 18, "label": "#18\nnormalized_payload = {'orderId': payload['orderId'], 'status': payload[\n    'status'], 'trackingNumber': payload['trackingNumber'], 'carrierCode':\n    payload['carrierCode']}\nevent_type = f\"order.{payload['status'].lower()}\"\nreturn normalized_payload, event_type", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "_deregister_webhook", "type": "CFG", "blocks": [{"id": 23, "label": "#23\n\"\"\"\n        Note: Slant3D API currently doesn't provide a deregistration endpoint.\n        This would need to be handled through support.\n        \"\"\"\nlogger.warning(\n    f'Warning: Manual deregistration required for webhook {webhook.id}')\npass", "successors": []}], "functions": [], "classes": []}], "classes": []}]}
{"file_name": "137.json", "name": "137.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport logging\nimport os\nimport uuid\nimport fastapi\nfrom google.cloud import storage\nimport backend.server.v2.store.exceptions\nfrom backend.util.settings import Settings\nlogger = logging.getLogger(__name__)\nALLOWED_IMAGE_TYPES = {'image/jpeg', 'image/png', 'image/gif', 'image/webp'}\nALLOWED_VIDEO_TYPES = {'video/mp4', 'video/webm'}\nMAX_FILE_SIZE = 50 * 1024 * 1024", "successors": []}], "functions": [{"name": "check_media_exists", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"\n    Check if a media file exists in storage for the given user.\n    Tries both images and videos directories.\n\n    Args:\n        user_id (str): ID of the user who uploaded the file\n        filename (str): Name of the file to check\n\n    Returns:\n        str | None: URL of the blob if it exists, None otherwise\n    \"\"\"\ntry:", "successors": [{"id": 4, "label": "#4\nsettings = Settings()\nstorage_client = storage.Client()\nbucket = storage_client.bucket(settings.config.media_gcs_bucket_name)\nimage_path = f'users/{user_id}/images/{filename}'\nimage_blob = bucket.blob(image_path)\nif image_blob.exists():", "successors": [{"id": 7, "label": "#7\nreturn image_blob.public_url", "successors": []}, {"id": 8, "label": "#8\nvideo_path = f'users/{user_id}/videos/{filename}'\nvideo_blob = bucket.blob(video_path)\nif video_blob.exists():", "successors": [{"id": 10, "label": "#10\nreturn video_blob.public_url", "successors": []}, {"id": 11, "label": "#11\nreturn None", "successors": []}]}]}, {"id": 5, "label": "#5\nlogger.error(f'Error checking if media file exists: {str(e)}')\nreturn None", "successors": []}]}], "functions": [], "classes": []}, {"name": "upload_media", "type": "CFG", "blocks": [{"id": 17, "label": "#17\ntry:", "successors": [{"id": 18, "label": "#18\ncontent = await file.read(1024)", "successors": [{"id": 21, "label": "#21\nawait file.seek(0)", "successors": [{"id": 20, "label": "#20\nif file.content_type in ALLOWED_IMAGE_TYPES:", "successors": [{"id": 24, "label": "#24\nif content.startswith(b'\\xff\\xd8\\xff'):", "successors": [{"id": 42, "label": "#42\nif file.content_type != 'image/jpeg':", "successors": [{"id": 64, "label": "#64\nraise backend.server.v2.store.exceptions.InvalidFileTypeError(\n    'File signature does not match content type')", "successors": []}, {"id": 25, "label": "#25\nsettings = Settings()\nif not settings.config.media_gcs_bucket_name:", "successors": [{"id": 67, "label": "#67\nlogger.error('Missing GCS bucket name setting')\nraise backend.server.v2.store.exceptions.StorageConfigError(\n    'Missing storage bucket configuration')", "successors": []}, {"id": 68, "label": "#68\ntry:", "successors": [{"id": 70, "label": "#70\ncontent_type = file.content_type\nif content_type is None:", "successors": [{"id": 74, "label": "#74\ncontent_type = 'image/jpeg'", "successors": [{"id": 75, "label": "#75\nif content_type not in ALLOWED_IMAGE_TYPES and content_type not in ALLOWED_VIDEO_TYPES:", "successors": [{"id": 76, "label": "#76\nlogger.warning(f'Invalid file type attempted: {content_type}')\nraise backend.server.v2.store.exceptions.InvalidFileTypeError(\n    f'File type not supported. Must be jpeg, png, gif, webp, mp4 or webm. Content type: {content_type}'\n    )", "successors": []}, {"id": 77, "label": "#77\nfile_size = 0\nchunk_size = 8192\ntry:", "successors": [{"id": 79, "label": "#79\nwhile (chunk := await file.read(chunk_size)):", "successors": [{"id": 83, "label": "#83\nfile_size += len(chunk)\nif file_size > MAX_FILE_SIZE:", "successors": [{"id": 85, "label": "#85\nlogger.warning(f'File size too large: {file_size} bytes')\nraise backend.server.v2.store.exceptions.FileSizeTooLargeError(\n    'File too large. Maximum size is 50MB')", "successors": []}]}, {"id": 82, "label": "#82\nawait file.seek(0)", "successors": [{"id": 90, "label": "#90\nfilename = file.filename or ''\nfile_ext = os.path.splitext(filename)[1].lower()\nif use_file_name:", "successors": [{"id": 91, "label": "#91\nunique_filename = filename", "successors": [{"id": 92, "label": "#92\nmedia_type = 'images' if content_type in ALLOWED_IMAGE_TYPES else 'videos'\nstorage_path = f'users/{user_id}/{media_type}/{unique_filename}'\ntry:", "successors": [{"id": 94, "label": "#94\nstorage_client = storage.Client()\nbucket = storage_client.bucket(settings.config.media_gcs_bucket_name)\nblob = bucket.blob(storage_path)\nblob.content_type = content_type\nfile_bytes = await file.read()", "successors": [{"id": 97, "label": "#97\nblob.upload_from_string(file_bytes, content_type=content_type)\npublic_url = blob.public_url\nlogger.info(f'Successfully uploaded file to: {storage_path}')\nreturn public_url", "successors": []}]}, {"id": 95, "label": "#95\nlogger.error(f'GCS storage error: {str(e)}')\nraise backend.server.v2.store.exceptions.StorageUploadError(\n    'Failed to upload file to storage') from e", "successors": []}]}]}, {"id": 93, "label": "#93\nunique_filename = f'{uuid.uuid4()}{file_ext}'", "successors": []}]}]}]}, {"id": 80, "label": "#80\nraise", "successors": []}, {"id": 81, "label": "#81\nlogger.error(f'Error reading file chunks: {str(e)}')\nraise backend.server.v2.store.exceptions.FileReadError(\n    'Failed to read uploaded file') from e", "successors": []}]}]}]}]}, {"id": 71, "label": "#71\nraise", "successors": []}, {"id": 72, "label": "#72\nlogger.exception('Unexpected error in upload_media')\nraise backend.server.v2.store.exceptions.MediaUploadError(\n    'Unexpected error during media upload') from e", "successors": []}]}]}]}, {"id": 44, "label": "#44\nif content.startswith(b'\\x89PNG\\r\\n\\x1a\\n'):", "successors": [{"id": 45, "label": "#45\nif file.content_type != 'image/png':", "successors": [{"id": 61, "label": "#61\nraise backend.server.v2.store.exceptions.InvalidFileTypeError(\n    'File signature does not match content type')", "successors": []}]}, {"id": 47, "label": "#47\nif content.startswith(b'GIF87a') or content.startswith(b'GIF89a'):", "successors": [{"id": 48, "label": "#48\nif file.content_type != 'image/gif':", "successors": [{"id": 58, "label": "#58\nraise backend.server.v2.store.exceptions.InvalidFileTypeError(\n    'File signature does not match content type')", "successors": []}]}, {"id": 50, "label": "#50\nif content.startswith(b'RIFF') and content[8:12] == b'WEBP':", "successors": [{"id": 51, "label": "#51\nif file.content_type != 'image/webp':", "successors": [{"id": 55, "label": "#55\nraise backend.server.v2.store.exceptions.InvalidFileTypeError(\n    'File signature does not match content type')", "successors": []}]}, {"id": 53, "label": "#53\nraise backend.server.v2.store.exceptions.InvalidFileTypeError(\n    'Invalid image file signature')", "successors": []}]}]}]}]}, {"id": 26, "label": "#26\nif file.content_type in ALLOWED_VIDEO_TYPES:", "successors": [{"id": 27, "label": "#27\nif content.startswith(b'\\x00\\x00\\x00') and content[4:8] == b'ftyp':", "successors": [{"id": 29, "label": "#29\nif file.content_type != 'video/mp4':", "successors": [{"id": 39, "label": "#39\nraise backend.server.v2.store.exceptions.InvalidFileTypeError(\n    'File signature does not match content type')", "successors": []}]}, {"id": 31, "label": "#31\nif content.startswith(b'\\x1aE\\xdf\\xa3'):", "successors": [{"id": 32, "label": "#32\nif file.content_type != 'video/webm':", "successors": [{"id": 36, "label": "#36\nraise backend.server.v2.store.exceptions.InvalidFileTypeError(\n    'File signature does not match content type')", "successors": []}]}, {"id": 34, "label": "#34\nraise backend.server.v2.store.exceptions.InvalidFileTypeError(\n    'Invalid video file signature')", "successors": []}]}]}]}]}]}]}, {"id": 19, "label": "#19\nlogger.error(f'Error reading file content: {str(e)}')\nraise backend.server.v2.store.exceptions.FileReadError(\n    'Failed to read file content') from e", "successors": []}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "138.json", "name": "138.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport time\nfrom typing import Literal\nfrom pydantic import SecretStr\nfrom backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema\nfrom backend.data.model import APIKeyCredentials, CredentialsField, CredentialsMetaInput, SchemaField\nfrom backend.integrations.providers import ProviderName\nfrom backend.util.request import requests\nTEST_CREDENTIALS = APIKeyCredentials(id=\n    '01234567-89ab-cdef-0123-456789abcdef', provider='d_id', api_key=\n    SecretStr('mock-d-id-api-key'), title='Mock D-ID API key', expires_at=None)\nTEST_CREDENTIALS_INPUT = {'provider': TEST_CREDENTIALS.provider, 'id':\n    TEST_CREDENTIALS.id, 'type': TEST_CREDENTIALS.type, 'title':\n    TEST_CREDENTIALS.type}", "successors": []}], "functions": [], "classes": [{"name": "CreateTalkingAvatarVideoBlock", "type": "CFG", "blocks": [{"id": 3, "label": "#3", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 11, "label": "#11\nsuper().__init__(id='98c6f503-8c47-4b1c-a96d-351fc7c87dab', description=\n    'This block integrates with D-ID to create video clips and retrieve their URLs.'\n    , categories={BlockCategory.AI}, input_schema=\n    CreateTalkingAvatarVideoBlock.Input, output_schema=\n    CreateTalkingAvatarVideoBlock.Output, test_input={'credentials':\n    TEST_CREDENTIALS_INPUT, 'script_input': 'Welcome to AutoGPT',\n    'voice_id': 'en-US-JennyNeural', 'presenter_id': 'amy-Aq6OmGZnMt',\n    'driver_id': 'Vcq0R4a8F0', 'result_format': 'mp4', 'crop_type': 'wide',\n    'subtitles': False, 'ssml': False, 'max_polling_attempts': 5,\n    'polling_interval': 5}, test_output=[('video_url',\n    'https://d-id.com/api/clips/abcd1234-5678-efgh-ijkl-mnopqrstuvwx/video'\n    )], test_mock={'create_clip': lambda *args, **kwargs: {'id':\n    'abcd1234-5678-efgh-ijkl-mnopqrstuvwx', 'status': 'created'},\n    'get_clip_status': lambda *args, **kwargs: {'status': 'done',\n    'result_url':\n    'https://d-id.com/api/clips/abcd1234-5678-efgh-ijkl-mnopqrstuvwx/video'\n    }}, test_credentials=TEST_CREDENTIALS)", "successors": []}], "functions": [], "classes": []}, {"name": "create_clip", "type": "CFG", "blocks": [{"id": 14, "label": "#14\nurl = 'https://api.d-id.com/clips'\nheaders = {'accept': 'application/json', 'content-type': 'application/json',\n    'authorization': f'Basic {api_key.get_secret_value()}'}\nresponse = requests.post(url, json=payload, headers=headers)\nreturn response.json()", "successors": []}], "functions": [], "classes": []}, {"name": "get_clip_status", "type": "CFG", "blocks": [{"id": 18, "label": "#18\nurl = f'https://api.d-id.com/clips/{clip_id}'\nheaders = {'accept': 'application/json', 'authorization':\n    f'Basic {api_key.get_secret_value()}'}\nresponse = requests.get(url, headers=headers)\nreturn response.json()", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 22, "label": "#22\npayload = {'script': {'type': 'text', 'subtitles': str(input_data.subtitles\n    ).lower(), 'provider': {'type': input_data.provider, 'voice_id':\n    input_data.voice_id}, 'ssml': str(input_data.ssml).lower(), 'input':\n    input_data.script_input}, 'config': {'result_format': input_data.\n    result_format}, 'presenter_config': {'crop': {'type': input_data.\n    crop_type}}, 'presenter_id': input_data.presenter_id, 'driver_id':\n    input_data.driver_id}\nresponse = self.create_clip(credentials.api_key, payload)\nclip_id = response['id']", "successors": [{"id": 23, "label": "#23\nfor _ in range(input_data.max_polling_attempts):", "successors": [{"id": 24, "label": "#24\nstatus_response = self.get_clip_status(credentials.api_key, clip_id)\nif status_response['status'] == 'done':", "successors": [{"id": 26, "label": "#26\nyield 'video_url', status_response['result_url']", "successors": [{"id": 32, "label": "#32\nreturn", "successors": []}]}, {"id": 28, "label": "#28\nif status_response['status'] == 'error':", "successors": [{"id": 29, "label": "#29\nraise RuntimeError(\n    f\"Clip creation failed: {status_response.get('error', 'Unknown error')}\")", "successors": []}, {"id": 27, "label": "#27\ntime.sleep(input_data.polling_interval)", "successors": []}]}]}, {"id": 25, "label": "#25\nraise TimeoutError('Clip creation timed out')", "successors": []}]}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 5, "label": "#5\ncredentials: CredentialsMetaInput[Literal[ProviderName.D_ID], Literal[\n    'api_key']] = CredentialsField(description=\n    'The D-ID integration can be used with any API key with sufficient permissions for the blocks it is used on.'\n    )\nscript_input: str = SchemaField(description='The text input for the script',\n    placeholder='Welcome to AutoGPT')\nprovider: Literal['microsoft', 'elevenlabs', 'amazon'] = SchemaField(\n    description='The voice provider to use', default='microsoft')\nvoice_id: str = SchemaField(description=\n    'The voice ID to use, get list of voices [here](https://docs.agpt.co/server/d_id)'\n    , default='en-US-JennyNeural')\npresenter_id: str = SchemaField(description='The presenter ID to use',\n    default='amy-Aq6OmGZnMt')\ndriver_id: str = SchemaField(description='The driver ID to use', default=\n    'Vcq0R4a8F0')\nresult_format: Literal['mp4', 'gif', 'wav'] = SchemaField(description=\n    'The desired result format', default='mp4')\ncrop_type: Literal['wide', 'square', 'vertical'] = SchemaField(description=\n    'The crop type for the presenter', default='wide')\nsubtitles: bool = SchemaField(description='Whether to include subtitles',\n    default=False)\nssml: bool = SchemaField(description='Whether the input is SSML', default=False\n    )\nmax_polling_attempts: int = SchemaField(description=\n    'Maximum number of polling attempts', default=30, ge=5)\npolling_interval: int = SchemaField(description=\n    'Interval between polling attempts in seconds', default=10, ge=5)", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 8, "label": "#8\nvideo_url: str = SchemaField(description='The URL of the created video')\nerror: str = SchemaField(description='Error message if the request failed')", "successors": []}], "functions": [], "classes": []}]}]}
{"file_name": "139.json", "name": "139.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom pydantic import BaseModel\nfrom backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema, BlockWebhookConfig\nfrom backend.data.model import SchemaField\nfrom backend.util import settings\nfrom backend.util.settings import AppEnvironment, BehaveAs\nfrom ._api import TEST_CREDENTIALS, TEST_CREDENTIALS_INPUT, Slant3DCredentialsField, Slant3DCredentialsInput", "successors": []}], "functions": [], "classes": [{"name": "Slant3DTriggerBase", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"Base class for Slant3D webhook triggers\"\"\"", "successors": []}], "functions": [{"name": "run", "type": "CFG", "blocks": [{"id": 11, "label": "#11\nyield 'payload', input_data.payload", "successors": [{"id": 12, "label": "#12\nyield 'order_id', input_data.payload['orderId']", "successors": []}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 5, "label": "#5\ncredentials: Slant3DCredentialsInput = Slant3DCredentialsField()\npayload: dict = SchemaField(hidden=True, default={})", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 8, "label": "#8\npayload: dict = SchemaField(description=\n    'The complete webhook payload received from Slant3D')\norder_id: str = SchemaField(description='The ID of the affected order')\nerror: str = SchemaField(description=\n    'Error message if payload processing failed')", "successors": []}], "functions": [], "classes": []}]}, {"name": "Slant3DOrderWebhookBlock", "type": "CFG", "blocks": [{"id": 17, "label": "#17\n\"\"\"Block for handling Slant3D order webhooks\"\"\"", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 28, "label": "#28\nsuper().__init__(id='8a74c2ad-0104-4640-962f-26c6b69e58cd', description=\n    'This block triggers on Slant3D order status updates and outputs the event details, including tracking information when orders are shipped.'\n    , disabled=settings.Settings().config.behave_as == BehaveAs.CLOUD and \n    settings.Settings().config.app_env != AppEnvironment.LOCAL, categories=\n    {BlockCategory.DEVELOPER_TOOLS}, input_schema=self.Input, output_schema\n    =self.Output, webhook_config=BlockWebhookConfig(provider='slant3d',\n    webhook_type='orders', resource_format='', event_filter_input='events',\n    event_format='order.{event}'), test_input={'credentials':\n    TEST_CREDENTIALS_INPUT, 'events': {'shipped': True}, 'payload': {\n    'orderId': '1234567890', 'status': 'SHIPPED', 'trackingNumber':\n    'ABCDEF123456', 'carrierCode': 'usps'}}, test_credentials=\n    TEST_CREDENTIALS, test_output=[('payload', {'orderId': '1234567890',\n    'status': 'SHIPPED', 'trackingNumber': 'ABCDEF123456', 'carrierCode':\n    'usps'}), ('order_id', '1234567890'), ('status', 'SHIPPED'), (\n    'tracking_number', 'ABCDEF123456'), ('carrier_code', 'usps')])", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 31, "label": "#31\nyield from super().run(input_data, **kwargs)\nyield 'status', input_data.payload['status']", "successors": [{"id": 32, "label": "#32\nyield 'tracking_number', input_data.payload['trackingNumber']", "successors": [{"id": 33, "label": "#33\nyield 'carrier_code', input_data.payload['carrierCode']", "successors": []}]}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 19, "label": "#19\nevents: EventsFilter = SchemaField(title='Events', description=\n    'Order status events to subscribe to', default=EventsFilter(shipped=True))", "successors": []}], "functions": [], "classes": [{"name": "EventsFilter", "type": "CFG", "blocks": [{"id": 21, "label": "#21\n\"\"\"\n            Currently Slant3D only supports 'SHIPPED' status updates\n            Could be expanded in the future with more status types\n            \"\"\"\nshipped: bool = True", "successors": []}], "functions": [], "classes": []}]}, {"name": "Output", "type": "CFG", "blocks": [{"id": 25, "label": "#25\nstatus: str = SchemaField(description='The new status of the order')\ntracking_number: str = SchemaField(description=\n    'The tracking number for the shipment')\ncarrier_code: str = SchemaField(description=\"The carrier code (e.g., 'usps')\")", "successors": []}], "functions": [], "classes": []}]}]}
{"file_name": "140.json", "name": "140.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport json\nfrom typing import Any, Type, TypeVar, cast, get_args, get_origin\nNUM = TypeVar('NUM', int, float)\nT = TypeVar('T')", "successors": []}], "functions": [{"name": "__convert_list", "type": "CFG", "blocks": [{"id": 6, "label": "#6\nif isinstance(value, (list, tuple, set)):", "successors": [{"id": 7, "label": "#7\nreturn list(value)", "successors": []}, {"id": 9, "label": "#9\nif isinstance(value, dict):", "successors": [{"id": 10, "label": "#10\nreturn list(value.items())", "successors": []}, {"id": 12, "label": "#12\nif isinstance(value, str):", "successors": [{"id": 13, "label": "#13\nvalue = value.strip()\nif value.startswith('[') and value.endswith(']'):", "successors": [{"id": 17, "label": "#17\ntry:", "successors": [{"id": 21, "label": "#21\nreturn json.loads(value)", "successors": []}, {"id": 22, "label": "#22\nreturn [value]", "successors": []}]}, {"id": 19, "label": "#19\nreturn [value]", "successors": []}]}, {"id": 15, "label": "#15\nreturn [value]", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "__convert_dict", "type": "CFG", "blocks": [{"id": 30, "label": "#30\nif isinstance(value, str):", "successors": [{"id": 31, "label": "#31\ntry:", "successors": [{"id": 47, "label": "#47\nresult = json.loads(value)\nif isinstance(result, dict):", "successors": [{"id": 50, "label": "#50\nreturn result", "successors": []}, {"id": 52, "label": "#52\nreturn {'value': result}", "successors": []}]}, {"id": 48, "label": "#48\nreturn {'value': value}", "successors": []}]}, {"id": 33, "label": "#33\nif isinstance(value, list):", "successors": [{"id": 34, "label": "#34\nreturn {i: value[i] for i in range(len(value))}", "successors": []}, {"id": 36, "label": "#36\nif isinstance(value, tuple):", "successors": [{"id": 37, "label": "#37\nreturn {i: value[i] for i in range(len(value))}", "successors": []}, {"id": 39, "label": "#39\nif isinstance(value, dict):", "successors": [{"id": 40, "label": "#40\nreturn value", "successors": []}, {"id": 42, "label": "#42\nreturn {'value': value}", "successors": []}]}]}]}]}], "functions": [], "classes": []}, {"name": "__convert_tuple", "type": "CFG", "blocks": [{"id": 58, "label": "#58\nif isinstance(value, (str, list, set)):", "successors": [{"id": 59, "label": "#59\nreturn tuple(value)", "successors": []}, {"id": 61, "label": "#61\nif isinstance(value, dict):", "successors": [{"id": 62, "label": "#62\nreturn tuple(value.items())", "successors": []}, {"id": 64, "label": "#64\nif isinstance(value, (int, float, bool)):", "successors": [{"id": 65, "label": "#65\nreturn value,", "successors": []}, {"id": 67, "label": "#67\nif isinstance(value, tuple):", "successors": [{"id": 68, "label": "#68\nreturn value", "successors": []}, {"id": 70, "label": "#70\nreturn value,", "successors": []}]}]}]}]}], "functions": [], "classes": []}, {"name": "__convert_set", "type": "CFG", "blocks": [{"id": 78, "label": "#78\nif isinstance(value, (str, list, tuple)):", "successors": [{"id": 79, "label": "#79\nreturn set(value)", "successors": []}, {"id": 81, "label": "#81\nif isinstance(value, dict):", "successors": [{"id": 82, "label": "#82\nreturn set(value.items())", "successors": []}, {"id": 84, "label": "#84\nif isinstance(value, set):", "successors": [{"id": 85, "label": "#85\nreturn value", "successors": []}, {"id": 87, "label": "#87\nreturn {value}", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "__convert_str", "type": "CFG", "blocks": [{"id": 94, "label": "#94\nif isinstance(value, str):", "successors": [{"id": 95, "label": "#95\nreturn value", "successors": []}, {"id": 97, "label": "#97\nreturn json.dumps(value)", "successors": []}]}], "functions": [], "classes": []}, {"name": "__convert_num", "type": "CFG", "blocks": [{"id": 102, "label": "#102\nif isinstance(value, (list, dict, tuple, set)):", "successors": [{"id": 103, "label": "#103\nreturn num_type(len(value))", "successors": []}, {"id": 105, "label": "#105\nif isinstance(value, num_type):", "successors": [{"id": 106, "label": "#106\nreturn value", "successors": []}, {"id": 108, "label": "#108\ntry:", "successors": [{"id": 109, "label": "#109\nreturn num_type(float(value))", "successors": []}, {"id": 110, "label": "#110\nreturn num_type(0)", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "__convert_bool", "type": "CFG", "blocks": [{"id": 118, "label": "#118\nif isinstance(value, bool):", "successors": [{"id": 119, "label": "#119\nreturn value", "successors": []}, {"id": 121, "label": "#121\nif isinstance(value, str):", "successors": [{"id": 122, "label": "#122\nif value.lower() in ['true', '1']:", "successors": [{"id": 126, "label": "#126\nreturn True", "successors": []}, {"id": 128, "label": "#128\nreturn False", "successors": []}]}, {"id": 124, "label": "#124\nreturn bool(value)", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "_try_convert", "type": "CFG", "blocks": [{"id": 134, "label": "#134\norigin = get_origin(target_type)\nargs = get_args(target_type)\nif origin is None:", "successors": [{"id": 135, "label": "#135\norigin = target_type", "successors": [{"id": 136, "label": "#136\nif origin not in [list, dict, tuple, str, set, int, float, bool]:", "successors": [{"id": 137, "label": "#137\nreturn value", "successors": []}, {"id": 138, "label": "#138\nif isinstance(value, origin):", "successors": [{"id": 140, "label": "#140\nif not args:", "successors": [{"id": 200, "label": "#200\nreturn value", "successors": []}, {"id": 202, "label": "#202\nif origin is list:", "successors": [{"id": 203, "label": "#203\nreturn [convert(v, args[0]) for v in value]", "successors": []}, {"id": 205, "label": "#205\nif origin is tuple:", "successors": [{"id": 206, "label": "#206\nif len(args) == 1:", "successors": [{"id": 218, "label": "#218\nreturn tuple(convert(v, args[0]) for v in value)", "successors": []}, {"id": 220, "label": "#220\nreturn tuple(convert(v, t) for v, t in zip(value, args))", "successors": []}]}, {"id": 208, "label": "#208\nif origin is dict:", "successors": [{"id": 209, "label": "#209\nkey_type, val_type = args\nreturn {convert(k, key_type): convert(v, val_type) for k, v in value.items()}", "successors": []}, {"id": 211, "label": "#211\nif origin is set:", "successors": [{"id": 212, "label": "#212\nreturn {convert(v, args[0]) for v in value}", "successors": []}, {"id": 214, "label": "#214\nreturn value", "successors": []}]}]}]}]}]}, {"id": 142, "label": "#142\nif raise_on_mismatch:", "successors": [{"id": 143, "label": "#143\nraise TypeError(f'Value {value} is not of expected type {target_type}')", "successors": []}, {"id": 145, "label": "#145\nif origin is list:", "successors": [{"id": 146, "label": "#146\nvalue = __convert_list(value)\nif args:", "successors": [{"id": 194, "label": "#194\nreturn [convert(v, args[0]) for v in value]", "successors": []}, {"id": 196, "label": "#196\nreturn value", "successors": []}]}, {"id": 148, "label": "#148\nif origin is dict:", "successors": [{"id": 149, "label": "#149\nvalue = __convert_dict(value)\nif args:", "successors": [{"id": 189, "label": "#189\nkey_type, val_type = args\nreturn {convert(k, key_type): convert(v, val_type) for k, v in value.items()}", "successors": []}, {"id": 191, "label": "#191\nreturn value", "successors": []}]}, {"id": 151, "label": "#151\nif origin is tuple:", "successors": [{"id": 152, "label": "#152\nvalue = __convert_tuple(value)\nif args:", "successors": [{"id": 180, "label": "#180\nif len(args) == 1:", "successors": [{"id": 184, "label": "#184\nreturn tuple(convert(v, args[0]) for v in value)", "successors": []}, {"id": 186, "label": "#186\nreturn tuple(convert(v, t) for v, t in zip(value, args))", "successors": []}]}, {"id": 182, "label": "#182\nreturn value", "successors": []}]}, {"id": 154, "label": "#154\nif origin is str:", "successors": [{"id": 155, "label": "#155\nreturn __convert_str(value)", "successors": []}, {"id": 157, "label": "#157\nif origin is set:", "successors": [{"id": 158, "label": "#158\nvalue = __convert_set(value)\nif args:", "successors": [{"id": 174, "label": "#174\nreturn {convert(v, args[0]) for v in value}", "successors": []}, {"id": 176, "label": "#176\nreturn value", "successors": []}]}, {"id": 160, "label": "#160\nif origin is int:", "successors": [{"id": 161, "label": "#161\nreturn __convert_num(value, int)", "successors": []}, {"id": 163, "label": "#163\nif origin is float:", "successors": [{"id": 164, "label": "#164\nreturn __convert_num(value, float)", "successors": []}, {"id": 166, "label": "#166\nif origin is bool:", "successors": [{"id": 167, "label": "#167\nreturn __convert_bool(value)", "successors": []}, {"id": 169, "label": "#169\nreturn value", "successors": []}]}]}]}]}]}]}]}]}]}]}]}]}]}], "functions": [], "classes": []}, {"name": "type_match", "type": "CFG", "blocks": [{"id": 227, "label": "#227\nreturn cast(T, _try_convert(value, target_type, raise_on_mismatch=True))", "successors": []}], "functions": [], "classes": []}, {"name": "convert", "type": "CFG", "blocks": [{"id": 231, "label": "#231\ntry:", "successors": [{"id": 232, "label": "#232\nreturn cast(T, _try_convert(value, target_type, raise_on_mismatch=False))", "successors": []}, {"id": 233, "label": "#233\nraise ConversionError(f'Failed to convert {value} to {target_type}') from e", "successors": []}]}], "functions": [], "classes": []}], "classes": [{"name": "ConversionError", "type": "CFG", "blocks": [{"id": 3, "label": "#3\npass", "successors": []}], "functions": [], "classes": []}]}
{"file_name": "141.json", "name": "141.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport re\nfrom typing_extensions import TypedDict\nfrom backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema\nfrom backend.data.model import SchemaField\nfrom ._api import get_api\nfrom ._auth import TEST_CREDENTIALS, TEST_CREDENTIALS_INPUT, GithubCredentials, GithubCredentialsField, GithubCredentialsInput", "successors": []}], "functions": [{"name": "prepare_pr_api_url", "type": "CFG", "blocks": [{"id": 154, "label": "#154\npattern = '^(?:https?://)?([^/]+/[^/]+/[^/]+)/pull/(\\\\d+)'\nmatch = re.match(pattern, pr_url)\nif not match:", "successors": [{"id": 155, "label": "#155\nreturn pr_url", "successors": []}, {"id": 156, "label": "#156\nbase_url, pr_number = match.groups()\nreturn f'{base_url}/pulls/{pr_number}/{path}'", "successors": []}]}], "functions": [], "classes": []}], "classes": [{"name": "GithubListPullRequestsBlock", "type": "CFG", "blocks": [{"id": 3, "label": "#3", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 14, "label": "#14\nsuper().__init__(id='ffef3c4c-6cd0-48dd-817d-459f975219f4', description=\n    'This block lists all pull requests for a specified GitHub repository.',\n    categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=\n    GithubListPullRequestsBlock.Input, output_schema=\n    GithubListPullRequestsBlock.Output, test_input={'repo_url':\n    'https://github.com/owner/repo', 'credentials': TEST_CREDENTIALS_INPUT},\n    test_credentials=TEST_CREDENTIALS, test_output=[('pull_request', {\n    'title': 'Pull request 1', 'url':\n    'https://github.com/owner/repo/pull/1'})], test_mock={'list_prs': lambda\n    *args, **kwargs: [{'title': 'Pull request 1', 'url':\n    'https://github.com/owner/repo/pull/1'}]})", "successors": []}], "functions": [], "classes": []}, {"name": "list_prs", "type": "CFG", "blocks": [{"id": 17, "label": "#17\napi = get_api(credentials)\npulls_url = repo_url + '/pulls'\nresponse = api.get(pulls_url)\ndata = response.json()\npull_requests: list[GithubListPullRequestsBlock.Output.PRItem] = [{'title':\n    pr['title'], 'url': pr['html_url']} for pr in data]\nreturn pull_requests", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 21, "label": "#21\npull_requests = self.list_prs(credentials, input_data.repo_url)\nyield from (('pull_request', pr) for pr in pull_requests)", "successors": []}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 5, "label": "#5\ncredentials: GithubCredentialsInput = GithubCredentialsField('repo')\nrepo_url: str = SchemaField(description='URL of the GitHub repository',\n    placeholder='https://github.com/owner/repo')", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 8, "label": "#8\npull_request: PRItem = SchemaField(title='Pull Request', description=\n    'PRs with their title and URL')\nerror: str = SchemaField(description='Error message if listing issues failed')", "successors": []}], "functions": [], "classes": [{"name": "PRItem", "type": "CFG", "blocks": [{"id": 10, "label": "#10\ntitle: str\nurl: str", "successors": []}], "functions": [], "classes": []}]}]}, {"name": "GithubMakePullRequestBlock", "type": "CFG", "blocks": [{"id": 25, "label": "#25", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 33, "label": "#33\nsuper().__init__(id='dfb987f8-f197-4b2e-bf19-111812afd692', description=\n    'This block creates a new pull request on a specified GitHub repository.',\n    categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=\n    GithubMakePullRequestBlock.Input, output_schema=\n    GithubMakePullRequestBlock.Output, test_input={'repo_url':\n    'https://github.com/owner/repo', 'title': 'Test Pull Request', 'body':\n    'This is a test pull request.', 'head': 'feature-branch', 'base':\n    'main', 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=\n    TEST_CREDENTIALS, test_output=[('number', 1), ('url',\n    'https://github.com/owner/repo/pull/1')], test_mock={'create_pr': lambda\n    *args, **kwargs: (1, 'https://github.com/owner/repo/pull/1')})", "successors": []}], "functions": [], "classes": []}, {"name": "create_pr", "type": "CFG", "blocks": [{"id": 36, "label": "#36\napi = get_api(credentials)\npulls_url = repo_url + '/pulls'\ndata = {'title': title, 'body': body, 'head': head, 'base': base}\nresponse = api.post(pulls_url, json=data)\npr_data = response.json()\nreturn pr_data['number'], pr_data['html_url']", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 40, "label": "#40\ntry:", "successors": [{"id": 41, "label": "#41\nnumber, url = self.create_pr(credentials, input_data.repo_url, input_data.\n    title, input_data.body, input_data.head, input_data.base)\nyield 'number', number", "successors": [{"id": 44, "label": "#44\nyield 'url', url", "successors": []}]}, {"id": 42, "label": "#42\nyield 'error', str(e)", "successors": []}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 27, "label": "#27\ncredentials: GithubCredentialsInput = GithubCredentialsField('repo')\nrepo_url: str = SchemaField(description='URL of the GitHub repository',\n    placeholder='https://github.com/owner/repo')\ntitle: str = SchemaField(description='Title of the pull request',\n    placeholder='Enter the pull request title')\nbody: str = SchemaField(description='Body of the pull request', placeholder\n    ='Enter the pull request body')\nhead: str = SchemaField(description=\n    'The name of the branch where your changes are implemented. For cross-repository pull requests in the same network, namespace head with a user like this: username:branch.'\n    , placeholder='Enter the head branch')\nbase: str = SchemaField(description=\n    'The name of the branch you want the changes pulled into.', placeholder\n    ='Enter the base branch')", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 30, "label": "#30\nnumber: int = SchemaField(description='Number of the created pull request')\nurl: str = SchemaField(description='URL of the created pull request')\nerror: str = SchemaField(description=\n    'Error message if the pull request creation failed')", "successors": []}], "functions": [], "classes": []}]}, {"name": "GithubReadPullRequestBlock", "type": "CFG", "blocks": [{"id": 50, "label": "#50", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 58, "label": "#58\nsuper().__init__(id='bf94b2a4-1a30-4600-a783-a8a44ee31301', description=\n    'This block reads the body, title, user, and changes of a specified GitHub pull request.'\n    , categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=\n    GithubReadPullRequestBlock.Input, output_schema=\n    GithubReadPullRequestBlock.Output, test_input={'pr_url':\n    'https://github.com/owner/repo/pull/1', 'include_pr_changes': True,\n    'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=\n    TEST_CREDENTIALS, test_output=[('title', 'Title of the pull request'),\n    ('body', 'This is the body of the pull request.'), ('author',\n    'username'), ('changes', 'List of changes made in the pull request.')],\n    test_mock={'read_pr': lambda *args, **kwargs: (\n    'Title of the pull request', 'This is the body of the pull request.',\n    'username'), 'read_pr_changes': lambda *args, **kwargs:\n    'List of changes made in the pull request.'})", "successors": []}], "functions": [], "classes": []}, {"name": "read_pr", "type": "CFG", "blocks": [{"id": 61, "label": "#61\napi = get_api(credentials)\nissue_url = pr_url.replace('/pull/', '/issues/')\nresponse = api.get(issue_url)\ndata = response.json()\ntitle = data.get('title', 'No title found')\nbody = data.get('body', 'No body content found')\nauthor = data.get('user', {}).get('login', 'No user found')\nreturn title, body, author", "successors": []}], "functions": [], "classes": []}, {"name": "read_pr_changes", "type": "CFG", "blocks": [{"id": 65, "label": "#65\napi = get_api(credentials)\nfiles_url = prepare_pr_api_url(pr_url=pr_url, path='files')\nresponse = api.get(files_url)\nfiles = response.json()\nchanges = []", "successors": [{"id": 66, "label": "#66\nfor file in files:", "successors": [{"id": 67, "label": "#67\nfilename = file.get('filename')\npatch = file.get('patch')\nif filename and patch:", "successors": [{"id": 69, "label": "#69\nchanges.append(f\"\"\"File: {filename}\n{patch}\"\"\")", "successors": []}]}, {"id": 68, "label": "#68\nreturn '\\n\\n'.join(changes)", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 74, "label": "#74\ntitle, body, author = self.read_pr(credentials, input_data.pr_url)\nyield 'title', title", "successors": [{"id": 75, "label": "#75\nyield 'body', body", "successors": [{"id": 76, "label": "#76\nyield 'author', author", "successors": [{"id": 77, "label": "#77\nif input_data.include_pr_changes:", "successors": [{"id": 78, "label": "#78\nchanges = self.read_pr_changes(credentials, input_data.pr_url)\nyield 'changes', changes", "successors": []}]}]}]}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 52, "label": "#52\ncredentials: GithubCredentialsInput = GithubCredentialsField('repo')\npr_url: str = SchemaField(description='URL of the GitHub pull request',\n    placeholder='https://github.com/owner/repo/pull/1')\ninclude_pr_changes: bool = SchemaField(description=\n    'Whether to include the changes made in the pull request', default=False)", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 55, "label": "#55\ntitle: str = SchemaField(description='Title of the pull request')\nbody: str = SchemaField(description='Body of the pull request')\nauthor: str = SchemaField(description='User who created the pull request')\nchanges: str = SchemaField(description='Changes made in the pull request')\nerror: str = SchemaField(description=\n    'Error message if reading the pull request failed')", "successors": []}], "functions": [], "classes": []}]}, {"name": "GithubAssignPRReviewerBlock", "type": "CFG", "blocks": [{"id": 84, "label": "#84", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 92, "label": "#92\nsuper().__init__(id='c0d22c5e-e688-43e3-ba43-d5faba7927fd', description=\n    'This block assigns a reviewer to a specified GitHub pull request.',\n    categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=\n    GithubAssignPRReviewerBlock.Input, output_schema=\n    GithubAssignPRReviewerBlock.Output, test_input={'pr_url':\n    'https://github.com/owner/repo/pull/1', 'reviewer': 'reviewer_username',\n    'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=\n    TEST_CREDENTIALS, test_output=[('status',\n    'Reviewer assigned successfully')], test_mock={'assign_reviewer': lambda\n    *args, **kwargs: 'Reviewer assigned successfully'})", "successors": []}], "functions": [], "classes": []}, {"name": "assign_reviewer", "type": "CFG", "blocks": [{"id": 95, "label": "#95\napi = get_api(credentials)\nreviewers_url = prepare_pr_api_url(pr_url=pr_url, path='requested_reviewers')\ndata = {'reviewers': [reviewer]}\napi.post(reviewers_url, json=data)\nreturn 'Reviewer assigned successfully'", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 99, "label": "#99\ntry:", "successors": [{"id": 100, "label": "#100\nstatus = self.assign_reviewer(credentials, input_data.pr_url, input_data.\n    reviewer)\nyield 'status', status", "successors": []}, {"id": 101, "label": "#101\nyield 'error', str(e)", "successors": []}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 86, "label": "#86\ncredentials: GithubCredentialsInput = GithubCredentialsField('repo')\npr_url: str = SchemaField(description='URL of the GitHub pull request',\n    placeholder='https://github.com/owner/repo/pull/1')\nreviewer: str = SchemaField(description=\n    'Username of the reviewer to assign', placeholder=\n    \"Enter the reviewer's username\")", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 89, "label": "#89\nstatus: str = SchemaField(description=\n    'Status of the reviewer assignment operation')\nerror: str = SchemaField(description=\n    'Error message if the reviewer assignment failed')", "successors": []}], "functions": [], "classes": []}]}, {"name": "GithubUnassignPRReviewerBlock", "type": "CFG", "blocks": [{"id": 108, "label": "#108", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 116, "label": "#116\nsuper().__init__(id='9637945d-c602-4875-899a-9c22f8fd30de', description=\n    'This block unassigns a reviewer from a specified GitHub pull request.',\n    categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=\n    GithubUnassignPRReviewerBlock.Input, output_schema=\n    GithubUnassignPRReviewerBlock.Output, test_input={'pr_url':\n    'https://github.com/owner/repo/pull/1', 'reviewer': 'reviewer_username',\n    'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=\n    TEST_CREDENTIALS, test_output=[('status',\n    'Reviewer unassigned successfully')], test_mock={'unassign_reviewer': \n    lambda *args, **kwargs: 'Reviewer unassigned successfully'})", "successors": []}], "functions": [], "classes": []}, {"name": "unassign_reviewer", "type": "CFG", "blocks": [{"id": 119, "label": "#119\napi = get_api(credentials)\nreviewers_url = prepare_pr_api_url(pr_url=pr_url, path='requested_reviewers')\ndata = {'reviewers': [reviewer]}\napi.delete(reviewers_url, json=data)\nreturn 'Reviewer unassigned successfully'", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 123, "label": "#123\ntry:", "successors": [{"id": 124, "label": "#124\nstatus = self.unassign_reviewer(credentials, input_data.pr_url, input_data.\n    reviewer)\nyield 'status', status", "successors": []}, {"id": 125, "label": "#125\nyield 'error', str(e)", "successors": []}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 110, "label": "#110\ncredentials: GithubCredentialsInput = GithubCredentialsField('repo')\npr_url: str = SchemaField(description='URL of the GitHub pull request',\n    placeholder='https://github.com/owner/repo/pull/1')\nreviewer: str = SchemaField(description=\n    'Username of the reviewer to unassign', placeholder=\n    \"Enter the reviewer's username\")", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 113, "label": "#113\nstatus: str = SchemaField(description=\n    'Status of the reviewer unassignment operation')\nerror: str = SchemaField(description=\n    'Error message if the reviewer unassignment failed')", "successors": []}], "functions": [], "classes": []}]}, {"name": "GithubListPRReviewersBlock", "type": "CFG", "blocks": [{"id": 132, "label": "#132", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 143, "label": "#143\nsuper().__init__(id='2646956e-96d5-4754-a3df-034017e7ed96', description=\n    'This block lists all reviewers for a specified GitHub pull request.',\n    categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=\n    GithubListPRReviewersBlock.Input, output_schema=\n    GithubListPRReviewersBlock.Output, test_input={'pr_url':\n    'https://github.com/owner/repo/pull/1', 'credentials':\n    TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output\n    =[('reviewer', {'username': 'reviewer1', 'url':\n    'https://github.com/reviewer1'})], test_mock={'list_reviewers': lambda\n    *args, **kwargs: [{'username': 'reviewer1', 'url':\n    'https://github.com/reviewer1'}]})", "successors": []}], "functions": [], "classes": []}, {"name": "list_reviewers", "type": "CFG", "blocks": [{"id": 146, "label": "#146\napi = get_api(credentials)\nreviewers_url = prepare_pr_api_url(pr_url=pr_url, path='requested_reviewers')\nresponse = api.get(reviewers_url)\ndata = response.json()\nreviewers: list[GithubListPRReviewersBlock.Output.ReviewerItem] = [{\n    'username': reviewer['login'], 'url': reviewer['html_url']} for\n    reviewer in data.get('users', [])]\nreturn reviewers", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 150, "label": "#150\nreviewers = self.list_reviewers(credentials, input_data.pr_url)\nyield from (('reviewer', reviewer) for reviewer in reviewers)", "successors": []}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 134, "label": "#134\ncredentials: GithubCredentialsInput = GithubCredentialsField('repo')\npr_url: str = SchemaField(description='URL of the GitHub pull request',\n    placeholder='https://github.com/owner/repo/pull/1')", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 137, "label": "#137\nreviewer: ReviewerItem = SchemaField(title='Reviewer', description=\n    'Reviewers with their username and profile URL')\nerror: str = SchemaField(description=\n    'Error message if listing reviewers failed')", "successors": []}], "functions": [], "classes": [{"name": "ReviewerItem", "type": "CFG", "blocks": [{"id": 139, "label": "#139\nusername: str\nurl: str", "successors": []}], "functions": [], "classes": []}]}]}]}
{"file_name": "142.json", "name": "142.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport smtplib\nfrom email.mime.multipart import MIMEMultipart\nfrom email.mime.text import MIMEText\nfrom pydantic import BaseModel, ConfigDict\nfrom backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema\nfrom backend.data.model import BlockSecret, SchemaField, SecretField", "successors": []}], "functions": [], "classes": [{"name": "EmailCredentials", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nsmtp_server: str = SchemaField(default='smtp.gmail.com', description=\n    'SMTP server address')\nsmtp_port: int = SchemaField(default=25, description='SMTP port number')\nsmtp_username: BlockSecret = SecretField(key='smtp_username')\nsmtp_password: BlockSecret = SecretField(key='smtp_password')\nmodel_config = ConfigDict(title='Email Credentials')", "successors": []}], "functions": [], "classes": []}, {"name": "SendEmailBlock", "type": "CFG", "blocks": [{"id": 6, "label": "#6", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 14, "label": "#14\nsuper().__init__(disabled=True, id='4335878a-394e-4e67-adf2-919877ff49ae',\n    description=\n    'This block sends an email using the provided SMTP credentials.',\n    categories={BlockCategory.OUTPUT}, input_schema=SendEmailBlock.Input,\n    output_schema=SendEmailBlock.Output, test_input={'to_email':\n    'recipient@example.com', 'subject': 'Test Email', 'body':\n    'This is a test email.', 'creds': {'smtp_server': 'smtp.gmail.com',\n    'smtp_port': 25, 'smtp_username': 'your-email@gmail.com',\n    'smtp_password': 'your-gmail-password'}}, test_output=[('status',\n    'Email sent successfully')], test_mock={'send_email': lambda *args, **\n    kwargs: 'Email sent successfully'})", "successors": []}], "functions": [], "classes": []}, {"name": "send_email", "type": "CFG", "blocks": [{"id": 17, "label": "#17\nsmtp_server = creds.smtp_server\nsmtp_port = creds.smtp_port\nsmtp_username = creds.smtp_username.get_secret_value()\nsmtp_password = creds.smtp_password.get_secret_value()\nmsg = MIMEMultipart()\nmsg['From'] = smtp_username\nmsg['To'] = to_email\nmsg['Subject'] = subject\nmsg.attach(MIMEText(body, 'plain'))\nwith smtplib.SMTP(smtp_server, smtp_port) as server:", "successors": [{"id": 18, "label": "#18\nserver.starttls()\nserver.login(smtp_username, smtp_password)\nserver.sendmail(smtp_username, to_email, msg.as_string())", "successors": [{"id": 19, "label": "#19\nreturn 'Email sent successfully'", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 23, "label": "#23\nyield 'status', self.send_email(input_data.creds, input_data.to_email,\n    input_data.subject, input_data.body)", "successors": []}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 8, "label": "#8\nto_email: str = SchemaField(description='Recipient email address',\n    placeholder='recipient@example.com')\nsubject: str = SchemaField(description='Subject of the email', placeholder=\n    'Enter the email subject')\nbody: str = SchemaField(description='Body of the email', placeholder=\n    'Enter the email body')\ncreds: EmailCredentials = SchemaField(description='SMTP credentials',\n    default=EmailCredentials())", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 11, "label": "#11\nstatus: str = SchemaField(description='Status of the email sending operation')\nerror: str = SchemaField(description=\n    'Error message if the email sending failed')", "successors": []}], "functions": [], "classes": []}]}]}
{"file_name": "143.json", "name": "143.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport contextlib\nimport logging\nimport typing\nimport fastapi\nimport fastapi.responses\nimport starlette.middleware.cors\nimport uvicorn\nfrom autogpt_libs.feature_flag.client import initialize_launchdarkly, shutdown_launchdarkly\nimport backend.data.block\nimport backend.data.db\nimport backend.data.graph\nimport backend.data.user\nimport backend.server.routers.v1\nimport backend.server.v2.library.routes\nimport backend.server.v2.store.routes\nimport backend.util.service\nimport backend.util.settings\nsettings = backend.util.settings.Settings()\nlogger = logging.getLogger(__name__)\nlogging.getLogger('autogpt_libs').setLevel(logging.INFO)\ndocs_url = ('/docs' if settings.config.app_env == backend.util.settings.\n    AppEnvironment.LOCAL else None)\napp = fastapi.FastAPI(title='AutoGPT Agent Server', description=\n    'This server is used to execute agents that are created by the AutoGPT system.'\n    , summary='AutoGPT Agent Server', version='0.1', lifespan=\n    lifespan_context, docs_url=docs_url)\napp.add_exception_handler(ValueError, handle_internal_http_error(400))\napp.add_exception_handler(Exception, handle_internal_http_error(500))\napp.include_router(backend.server.routers.v1.v1_router, tags=['v1'], prefix\n    ='/api')\napp.include_router(backend.server.v2.store.routes.router, tags=['v2'],\n    prefix='/api/store')\napp.include_router(backend.server.v2.library.routes.router, tags=['v2'],\n    prefix='/api/library')", "successors": []}], "functions": [{"name": "launch_darkly_context", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nif settings.config.app_env != backend.util.settings.AppEnvironment.LOCAL:", "successors": [{"id": 4, "label": "#4\ninitialize_launchdarkly()\ntry:", "successors": [{"id": 8, "label": "#8\nyield", "successors": []}]}, {"id": 6, "label": "#6\nyield", "successors": []}]}], "functions": [], "classes": []}, {"name": "lifespan_context", "type": "CFG", "blocks": [{"id": 13, "label": "#13\nawait backend.data.db.connect()", "successors": [{"id": 14, "label": "#14\nawait backend.data.block.initialize_blocks()", "successors": [{"id": 15, "label": "#15\nawait backend.data.user.migrate_and_encrypt_user_integrations()", "successors": [{"id": 16, "label": "#16\nawait backend.data.graph.fix_llm_provider_credentials()", "successors": [{"id": 17, "label": "#17\nwith launch_darkly_context():", "successors": [{"id": 18, "label": "#18\nyield", "successors": [{"id": 19, "label": "#19\nawait backend.data.db.disconnect()", "successors": []}]}]}]}]}]}]}], "functions": [], "classes": []}, {"name": "handle_internal_http_error", "type": "CFG", "blocks": [{"id": 24, "label": "#24\nreturn handler", "successors": []}], "functions": [{"name": "handler", "type": "CFG", "blocks": [{"id": 26, "label": "#26\nif log_error:", "successors": [{"id": 27, "label": "#27\nlogger.exception(f'{request.method} {request.url.path} failed: {exc}')", "successors": [{"id": 28, "label": "#28\nreturn fastapi.responses.JSONResponse(content={'message':\n    f'{request.method} {request.url.path} failed', 'detail': str(exc)},\n    status_code=status_code)", "successors": []}]}]}], "functions": [], "classes": []}], "classes": []}, {"name": "health", "type": "CFG", "blocks": [{"id": 34, "label": "#34\nreturn {'status': 'healthy'}", "successors": []}], "functions": [], "classes": []}], "classes": [{"name": "AgentServer", "type": "CFG", "blocks": [{"id": 38, "label": "#38", "successors": []}], "functions": [{"name": "run", "type": "CFG", "blocks": [{"id": 40, "label": "#40\nserver_app = starlette.middleware.cors.CORSMiddleware(app=app,\n    allow_origins=settings.config.backend_cors_allow_origins,\n    allow_credentials=True, allow_methods=['*'], allow_headers=['*'])\nuvicorn.run(server_app, host=backend.util.settings.Config().agent_api_host,\n    port=backend.util.settings.Config().agent_api_port)", "successors": []}], "functions": [], "classes": []}, {"name": "test_execute_graph", "type": "CFG", "blocks": [{"id": 43, "label": "#43\nreturn backend.server.routers.v1.execute_graph(graph_id, node_input, user_id)", "successors": []}], "functions": [], "classes": []}, {"name": "test_create_graph", "type": "CFG", "blocks": [{"id": 47, "label": "#47\nreturn await backend.server.routers.v1.create_new_graph(create_graph, user_id)", "successors": []}], "functions": [], "classes": []}, {"name": "test_get_graph_run_status", "type": "CFG", "blocks": [{"id": 51, "label": "#51\nexecution = await backend.data.graph.get_execution(user_id=user_id,\n    execution_id=graph_exec_id)", "successors": [{"id": 52, "label": "#52\nif not execution:", "successors": [{"id": 53, "label": "#53\nraise ValueError(f'Execution {graph_exec_id} not found')", "successors": []}, {"id": 54, "label": "#54\nreturn execution.status", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "test_get_graph_run_node_execution_results", "type": "CFG", "blocks": [{"id": 59, "label": "#59\nreturn await backend.server.routers.v1.get_graph_run_node_execution_results(\n    graph_id, graph_exec_id, user_id)", "successors": []}], "functions": [], "classes": []}, {"name": "test_delete_graph", "type": "CFG", "blocks": [{"id": 63, "label": "#63\nreturn await backend.server.routers.v1.delete_graph(graph_id, user_id)", "successors": []}], "functions": [], "classes": []}, {"name": "set_test_dependency_overrides", "type": "CFG", "blocks": [{"id": 67, "label": "#67\napp.dependency_overrides.update(overrides)", "successors": []}], "functions": [], "classes": []}], "classes": []}]}
{"file_name": "144.json", "name": "144.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom __future__ import annotations\nimport json\nimport logging", "successors": []}], "functions": [], "classes": [{"name": "JsonFileHandler", "type": "CFG", "blocks": [{"id": 3, "label": "#3", "successors": []}], "functions": [{"name": "format", "type": "CFG", "blocks": [{"id": 5, "label": "#5\nrecord.json_data = json.loads(record.getMessage())\nreturn json.dumps(getattr(record, 'json_data'), ensure_ascii=False, indent=4)", "successors": []}], "functions": [], "classes": []}, {"name": "emit", "type": "CFG", "blocks": [{"id": 9, "label": "#9\nwith open(self.baseFilename, 'w', encoding='utf-8') as f:", "successors": [{"id": 10, "label": "#10\nf.write(self.format(record))", "successors": []}]}], "functions": [], "classes": []}], "classes": []}]}
{"file_name": "145.json", "name": "145.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom abc import ABCMeta, abstractmethod\nfrom enum import Enum\nimport sys", "successors": []}], "functions": [], "classes": [{"name": "Suit", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nHEART = 0\nDIAMOND = 1\nCLUBS = 2\nSPADE = 3", "successors": []}], "functions": [], "classes": []}, {"name": "Card", "type": "CFG", "blocks": [{"id": 6, "label": "#6", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 8, "label": "#8\nself.value = value\nself.suit = suit\nself.is_available = True", "successors": []}], "functions": [], "classes": []}, {"name": "value", "type": "CFG", "blocks": [{"id": 14, "label": "#14\npass", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "BlackJackCard", "type": "CFG", "blocks": [{"id": 18, "label": "#18", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 20, "label": "#20\nsuper(BlackJackCard, self).__init__(value, suit)", "successors": []}], "functions": [], "classes": []}, {"name": "is_ace", "type": "CFG", "blocks": [{"id": 23, "label": "#23\nreturn True if self._value == 1 else False", "successors": []}], "functions": [], "classes": []}, {"name": "is_face_card", "type": "CFG", "blocks": [{"id": 27, "label": "#27\n\"\"\"Jack = 11, Queen = 12, King = 13\"\"\"\nreturn True if 10 < self._value <= 13 else False", "successors": []}], "functions": [], "classes": []}, {"name": "value", "type": "CFG", "blocks": [{"id": 43, "label": "#43\nif 1 <= new_value <= 13:", "successors": [{"id": 44, "label": "#44\nself._value = new_value", "successors": []}, {"id": 46, "label": "#46\nraise ValueError('Invalid card value: {}'.format(new_value))", "successors": []}]}], "functions": [], "classes": []}], "classes": []}, {"name": "Hand", "type": "CFG", "blocks": [{"id": 51, "label": "#51", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 53, "label": "#53\nself.cards = cards", "successors": []}], "functions": [], "classes": []}, {"name": "add_card", "type": "CFG", "blocks": [{"id": 56, "label": "#56\nself.cards.append(card)", "successors": []}], "functions": [], "classes": []}, {"name": "score", "type": "CFG", "blocks": [{"id": 59, "label": "#59\ntotal_value = 0", "successors": [{"id": 60, "label": "#60\nfor card in self.cards:", "successors": [{"id": 61, "label": "#61\ntotal_value += card.value", "successors": []}, {"id": 62, "label": "#62\nreturn total_value", "successors": []}]}]}], "functions": [], "classes": []}], "classes": []}, {"name": "BlackJackHand", "type": "CFG", "blocks": [{"id": 67, "label": "#67\nBLACKJACK = 21", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 69, "label": "#69\nsuper(BlackJackHand, self).__init__(cards)", "successors": []}], "functions": [], "classes": []}, {"name": "score", "type": "CFG", "blocks": [{"id": 72, "label": "#72\nmin_over = sys.MAXSIZE\nmax_under = -sys.MAXSIZE", "successors": [{"id": 73, "label": "#73\nfor score in self.possible_scores():", "successors": [{"id": 74, "label": "#74\nif self.BLACKJACK < score < min_over:", "successors": [{"id": 76, "label": "#76\nmin_over = score", "successors": []}, {"id": 78, "label": "#78\nif max_under < score <= self.BLACKJACK:", "successors": [{"id": 79, "label": "#79\nmax_under = score", "successors": []}]}]}, {"id": 75, "label": "#75\nreturn max_under if max_under != -sys.MAXSIZE else min_over", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "possible_scores", "type": "CFG", "blocks": [{"id": 84, "label": "#84\n\"\"\"Return a list of possible scores, taking Aces into account.\"\"\"\npass", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "Deck", "type": "CFG", "blocks": [{"id": 88, "label": "#88", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 90, "label": "#90\nself.cards = cards\nself.deal_index = 0", "successors": []}], "functions": [], "classes": []}, {"name": "remaining_cards", "type": "CFG", "blocks": [{"id": 93, "label": "#93\nreturn len(self.cards) - self.deal_index", "successors": []}], "functions": [], "classes": []}, {"name": "deal_card", "type": "CFG", "blocks": [{"id": 97, "label": "#97\ntry:", "successors": [{"id": 98, "label": "#98\ncard = self.cards[self.deal_index]\ncard.is_available = False\nself.deal_index += 1", "successors": [{"id": 100, "label": "#100\nreturn card", "successors": []}]}, {"id": 99, "label": "#99\nreturn None", "successors": []}]}], "functions": [], "classes": []}, {"name": "shuffle", "type": "CFG", "blocks": [{"id": 105, "label": "#105\npass", "successors": []}], "functions": [], "classes": []}], "classes": []}]}
{"file_name": "146.json", "name": "146.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport logging\nimport typing\nimport urllib.parse\nimport autogpt_libs.auth.depends\nimport autogpt_libs.auth.middleware\nimport fastapi\nimport fastapi.responses\nimport backend.data.graph\nimport backend.server.v2.store.db\nimport backend.server.v2.store.image_gen\nimport backend.server.v2.store.media\nimport backend.server.v2.store.model\nlogger = logging.getLogger(__name__)\nrouter = fastapi.APIRouter()", "successors": []}], "functions": [{"name": "get_profile", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"\n    Get the profile details for the authenticated user.\n    \"\"\"\ntry:", "successors": [{"id": 4, "label": "#4\nprofile = await backend.server.v2.store.db.get_user_profile(user_id)", "successors": [{"id": 7, "label": "#7\nreturn profile", "successors": []}]}, {"id": 5, "label": "#5\nlogger.exception('Exception occurred whilst getting user profile')\nreturn fastapi.responses.JSONResponse(status_code=500, content={'detail':\n    'An error occurred while retrieving the user profile'})", "successors": []}]}], "functions": [], "classes": []}, {"name": "update_or_create_profile", "type": "CFG", "blocks": [{"id": 12, "label": "#12\n\"\"\"\n    Update the store profile for the authenticated user.\n\n    Args:\n        profile (Profile): The updated profile details\n        user_id (str): ID of the authenticated user\n\n    Returns:\n        CreatorDetails: The updated profile\n\n    Raises:\n        HTTPException: If there is an error updating the profile\n    \"\"\"\ntry:", "successors": [{"id": 13, "label": "#13\nupdated_profile = await backend.server.v2.store.db.update_or_create_profile(\n    user_id=user_id, profile=profile)", "successors": [{"id": 16, "label": "#16\nreturn updated_profile", "successors": []}]}, {"id": 14, "label": "#14\nlogger.exception('Exception occurred whilst updating profile')\nreturn fastapi.responses.JSONResponse(status_code=500, content={'detail':\n    'An error occurred while updating the user profile'})", "successors": []}]}], "functions": [], "classes": []}, {"name": "get_agents", "type": "CFG", "blocks": [{"id": 21, "label": "#21\n\"\"\"\n    Get a paginated list of agents from the store with optional filtering and sorting.\n\n    Args:\n        featured (bool, optional): Filter to only show featured agents. Defaults to False.\n        creator (str | None, optional): Filter agents by creator username. Defaults to None.\n        sorted_by (str | None, optional): Sort agents by \"runs\" or \"rating\". Defaults to None.\n        search_query (str | None, optional): Search agents by name, subheading and description. Defaults to None.\n        category (str | None, optional): Filter agents by category. Defaults to None.\n        page (int, optional): Page number for pagination. Defaults to 1.\n        page_size (int, optional): Number of agents per page. Defaults to 20.\n\n    Returns:\n        StoreAgentsResponse: Paginated list of agents matching the filters\n\n    Raises:\n        HTTPException: If page or page_size are less than 1\n\n    Used for:\n    - Home Page Featured Agents\n    - Home Page Top Agents\n    - Search Results\n    - Agent Details - Other Agents By Creator\n    - Agent Details - Similar Agents\n    - Creator Details - Agents By Creator\n    \"\"\"\nif page < 1:", "successors": [{"id": 22, "label": "#22\nraise fastapi.HTTPException(status_code=422, detail=\n    'Page must be greater than 0')", "successors": []}, {"id": 23, "label": "#23\nif page_size < 1:", "successors": [{"id": 25, "label": "#25\nraise fastapi.HTTPException(status_code=422, detail=\n    'Page size must be greater than 0')", "successors": []}, {"id": 26, "label": "#26\ntry:", "successors": [{"id": 28, "label": "#28\nagents = await backend.server.v2.store.db.get_store_agents(featured=\n    featured, creator=creator, sorted_by=sorted_by, search_query=\n    search_query, category=category, page=page, page_size=page_size)", "successors": [{"id": 31, "label": "#31\nreturn agents", "successors": []}]}, {"id": 29, "label": "#29\nlogger.exception('Exception occured whilst getting store agents')\nreturn fastapi.responses.JSONResponse(status_code=500, content={'detail':\n    'An error occurred while retrieving the store agents'})", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "get_agent", "type": "CFG", "blocks": [{"id": 36, "label": "#36\n\"\"\"\n    This is only used on the AgentDetails Page\n\n    It returns the store listing agents details.\n    \"\"\"\ntry:", "successors": [{"id": 37, "label": "#37\nusername = urllib.parse.unquote(username).lower()\nagent_name = urllib.parse.unquote(agent_name).lower()\nagent = await backend.server.v2.store.db.get_store_agent_details(username=\n    username, agent_name=agent_name)", "successors": [{"id": 40, "label": "#40\nreturn agent", "successors": []}]}, {"id": 38, "label": "#38\nlogger.exception('Exception occurred whilst getting store agent details')\nreturn fastapi.responses.JSONResponse(status_code=500, content={'detail':\n    'An error occurred while retrieving the store agent details'})", "successors": []}]}], "functions": [], "classes": []}, {"name": "create_review", "type": "CFG", "blocks": [{"id": 45, "label": "#45\n\"\"\"\n    Create a review for a store agent.\n\n    Args:\n        username: Creator's username\n        agent_name: Name/slug of the agent\n        review: Review details including score and optional comments\n        user_id: ID of authenticated user creating the review\n\n    Returns:\n        The created review\n    \"\"\"\ntry:", "successors": [{"id": 46, "label": "#46\nusername = urllib.parse.unquote(username).lower()\nagent_name = urllib.parse.unquote(agent_name)\ncreated_review = await backend.server.v2.store.db.create_store_review(user_id\n    =user_id, store_listing_version_id=review.store_listing_version_id,\n    score=review.score, comments=review.comments)", "successors": [{"id": 49, "label": "#49\nreturn created_review", "successors": []}]}, {"id": 47, "label": "#47\nlogger.exception('Exception occurred whilst creating store review')\nreturn fastapi.responses.JSONResponse(status_code=500, content={'detail':\n    'An error occurred while creating the store review'})", "successors": []}]}], "functions": [], "classes": []}, {"name": "get_creators", "type": "CFG", "blocks": [{"id": 54, "label": "#54\n\"\"\"\n    This is needed for:\n    - Home Page Featured Creators\n    - Search Results Page\n\n    ---\n\n    To support this functionality we need:\n    - featured: bool - to limit the list to just featured agents\n    - search_query: str - vector search based on the creators profile description.\n    - sorted_by: [agent_rating, agent_runs] -\n    \"\"\"\nif page < 1:", "successors": [{"id": 55, "label": "#55\nraise fastapi.HTTPException(status_code=422, detail=\n    'Page must be greater than 0')", "successors": []}, {"id": 56, "label": "#56\nif page_size < 1:", "successors": [{"id": 58, "label": "#58\nraise fastapi.HTTPException(status_code=422, detail=\n    'Page size must be greater than 0')", "successors": []}, {"id": 59, "label": "#59\ntry:", "successors": [{"id": 61, "label": "#61\ncreators = await backend.server.v2.store.db.get_store_creators(featured=\n    featured, search_query=search_query, sorted_by=sorted_by, page=page,\n    page_size=page_size)", "successors": [{"id": 64, "label": "#64\nreturn creators", "successors": []}]}, {"id": 62, "label": "#62\nlogger.exception('Exception occurred whilst getting store creators')\nreturn fastapi.responses.JSONResponse(status_code=500, content={'detail':\n    'An error occurred while retrieving the store creators'})", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "get_creator", "type": "CFG", "blocks": [{"id": 69, "label": "#69\n\"\"\"\n    Get the details of a creator\n    - Creator Details Page\n    \"\"\"\ntry:", "successors": [{"id": 70, "label": "#70\nusername = urllib.parse.unquote(username).lower()\ncreator = await backend.server.v2.store.db.get_store_creator_details(username\n    =username.lower())", "successors": [{"id": 73, "label": "#73\nreturn creator", "successors": []}]}, {"id": 71, "label": "#71\nlogger.exception('Exception occurred whilst getting creator details')\nreturn fastapi.responses.JSONResponse(status_code=500, content={'detail':\n    'An error occurred while retrieving the creator details'})", "successors": []}]}], "functions": [], "classes": []}, {"name": "get_my_agents", "type": "CFG", "blocks": [{"id": 78, "label": "#78\ntry:", "successors": [{"id": 79, "label": "#79\nagents = await backend.server.v2.store.db.get_my_agents(user_id)", "successors": [{"id": 82, "label": "#82\nreturn agents", "successors": []}]}, {"id": 80, "label": "#80\nlogger.exception('Exception occurred whilst getting my agents')\nreturn fastapi.responses.JSONResponse(status_code=500, content={'detail':\n    'An error occurred while retrieving the my agents'})", "successors": []}]}], "functions": [], "classes": []}, {"name": "delete_submission", "type": "CFG", "blocks": [{"id": 87, "label": "#87\n\"\"\"\n    Delete a store listing submission.\n\n    Args:\n        user_id (str): ID of the authenticated user\n        submission_id (str): ID of the submission to be deleted\n\n    Returns:\n        bool: True if the submission was successfully deleted, False otherwise\n    \"\"\"\ntry:", "successors": [{"id": 88, "label": "#88\nresult = await backend.server.v2.store.db.delete_store_submission(user_id=\n    user_id, submission_id=submission_id)", "successors": [{"id": 91, "label": "#91\nreturn result", "successors": []}]}, {"id": 89, "label": "#89\nlogger.exception('Exception occurred whilst deleting store submission')\nreturn fastapi.responses.JSONResponse(status_code=500, content={'detail':\n    'An error occurred while deleting the store submission'})", "successors": []}]}], "functions": [], "classes": []}, {"name": "get_submissions", "type": "CFG", "blocks": [{"id": 96, "label": "#96\n\"\"\"\n    Get a paginated list of store submissions for the authenticated user.\n\n    Args:\n        user_id (str): ID of the authenticated user\n        page (int, optional): Page number for pagination. Defaults to 1.\n        page_size (int, optional): Number of submissions per page. Defaults to 20.\n\n    Returns:\n        StoreListingsResponse: Paginated list of store submissions\n\n    Raises:\n        HTTPException: If page or page_size are less than 1\n    \"\"\"\nif page < 1:", "successors": [{"id": 97, "label": "#97\nraise fastapi.HTTPException(status_code=422, detail=\n    'Page must be greater than 0')", "successors": []}, {"id": 98, "label": "#98\nif page_size < 1:", "successors": [{"id": 100, "label": "#100\nraise fastapi.HTTPException(status_code=422, detail=\n    'Page size must be greater than 0')", "successors": []}, {"id": 101, "label": "#101\ntry:", "successors": [{"id": 103, "label": "#103\nlistings = await backend.server.v2.store.db.get_store_submissions(user_id=\n    user_id, page=page, page_size=page_size)", "successors": [{"id": 106, "label": "#106\nreturn listings", "successors": []}]}, {"id": 104, "label": "#104\nlogger.exception('Exception occurred whilst getting store submissions')\nreturn fastapi.responses.JSONResponse(status_code=500, content={'detail':\n    'An error occurred while retrieving the store submissions'})", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "create_submission", "type": "CFG", "blocks": [{"id": 111, "label": "#111\n\"\"\"\n    Create a new store listing submission.\n\n    Args:\n        submission_request (StoreSubmissionRequest): The submission details\n        user_id (str): ID of the authenticated user submitting the listing\n\n    Returns:\n        StoreSubmission: The created store submission\n\n    Raises:\n        HTTPException: If there is an error creating the submission\n    \"\"\"\ntry:", "successors": [{"id": 112, "label": "#112\nsubmission = await backend.server.v2.store.db.create_store_submission(user_id\n    =user_id, agent_id=submission_request.agent_id, agent_version=\n    submission_request.agent_version, slug=submission_request.slug, name=\n    submission_request.name, video_url=submission_request.video_url,\n    image_urls=submission_request.image_urls, description=\n    submission_request.description, sub_heading=submission_request.\n    sub_heading, categories=submission_request.categories)", "successors": [{"id": 115, "label": "#115\nreturn submission", "successors": []}]}, {"id": 113, "label": "#113\nlogger.exception('Exception occurred whilst creating store submission')\nreturn fastapi.responses.JSONResponse(status_code=500, content={'detail':\n    'An error occurred while creating the store submission'})", "successors": []}]}], "functions": [], "classes": []}, {"name": "upload_submission_media", "type": "CFG", "blocks": [{"id": 120, "label": "#120\n\"\"\"\n    Upload media (images/videos) for a store listing submission.\n\n    Args:\n        file (UploadFile): The media file to upload\n        user_id (str): ID of the authenticated user uploading the media\n\n    Returns:\n        str: URL of the uploaded media file\n\n    Raises:\n        HTTPException: If there is an error uploading the media\n    \"\"\"\ntry:", "successors": [{"id": 121, "label": "#121\nmedia_url = await backend.server.v2.store.media.upload_media(user_id=\n    user_id, file=file)", "successors": [{"id": 124, "label": "#124\nreturn media_url", "successors": []}]}, {"id": 122, "label": "#122\nlogger.exception('Exception occurred whilst uploading submission media')\nreturn fastapi.responses.JSONResponse(status_code=500, content={'detail':\n    'An error occurred while uploading the media file'})", "successors": []}]}], "functions": [], "classes": []}, {"name": "generate_image", "type": "CFG", "blocks": [{"id": 129, "label": "#129\n\"\"\"\n    Generate an image for a store listing submission.\n\n    Args:\n        agent_id (str): ID of the agent to generate an image for\n        user_id (str): ID of the authenticated user\n\n    Returns:\n        JSONResponse: JSON containing the URL of the generated image\n    \"\"\"\ntry:", "successors": [{"id": 130, "label": "#130\nagent = await backend.data.graph.get_graph(agent_id, user_id=user_id)", "successors": [{"id": 133, "label": "#133\nif not agent:", "successors": [{"id": 134, "label": "#134\nraise fastapi.HTTPException(status_code=404, detail=\n    f'Agent with ID {agent_id} not found')", "successors": []}, {"id": 135, "label": "#135\nfilename = f'agent_{agent_id}.jpeg'\nexisting_url = await backend.server.v2.store.media.check_media_exists(user_id,\n    filename)", "successors": [{"id": 137, "label": "#137\nif existing_url:", "successors": [{"id": 138, "label": "#138\nlogger.info(f'Using existing image for agent {agent_id}')\nreturn fastapi.responses.JSONResponse(content={'image_url': existing_url})", "successors": []}, {"id": 139, "label": "#139\nimage = await backend.server.v2.store.image_gen.generate_agent_image(agent=\n    agent)", "successors": [{"id": 141, "label": "#141\nimage_file = fastapi.UploadFile(file=image, filename=filename)\nimage_url = await backend.server.v2.store.media.upload_media(user_id=\n    user_id, file=image_file, use_file_name=True)", "successors": [{"id": 142, "label": "#142\nreturn fastapi.responses.JSONResponse(content={'image_url': image_url})", "successors": []}]}]}]}]}]}]}, {"id": 131, "label": "#131\nlogger.exception('Exception occurred whilst generating submission image')\nreturn fastapi.responses.JSONResponse(status_code=500, content={'detail':\n    'An error occurred while generating the image'})", "successors": []}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "147.json", "name": "147.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1", "successors": []}], "functions": [], "classes": [{"name": "QueryApi", "type": "CFG", "blocks": [{"id": 3, "label": "#3", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 5, "label": "#5\nself.memory_cache = memory_cache\nself.reverse_index_cluster = reverse_index_cluster", "successors": []}], "functions": [], "classes": []}, {"name": "parse_query", "type": "CFG", "blocks": [{"id": 8, "label": "#8\n\"\"\"Remove markup, break text into terms, deal with typos,\n        normalize capitalization, convert to use boolean operations.\n        \"\"\"", "successors": []}], "functions": [], "classes": []}, {"name": "process_query", "type": "CFG", "blocks": [{"id": 11, "label": "#11\nquery = self.parse_query(query)\nresults = self.memory_cache.get(query)\nif results is None:", "successors": [{"id": 12, "label": "#12\nresults = self.reverse_index_cluster.process_search(query)\nself.memory_cache.set(query, results)", "successors": [{"id": 13, "label": "#13\nreturn results", "successors": []}]}]}], "functions": [], "classes": []}], "classes": []}, {"name": "Node", "type": "CFG", "blocks": [{"id": 18, "label": "#18", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 20, "label": "#20\nself.query = query\nself.results = results", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "LinkedList", "type": "CFG", "blocks": [{"id": 24, "label": "#24", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 26, "label": "#26\nself.head = None\nself.tail = None", "successors": []}], "functions": [], "classes": []}, {"name": "move_to_front", "type": "CFG", "blocks": [{"id": 29, "label": "#29", "successors": []}], "functions": [], "classes": []}, {"name": "append_to_front", "type": "CFG", "blocks": [{"id": 32, "label": "#32", "successors": []}], "functions": [], "classes": []}, {"name": "remove_from_tail", "type": "CFG", "blocks": [{"id": 35, "label": "#35", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "Cache", "type": "CFG", "blocks": [{"id": 39, "label": "#39", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 41, "label": "#41\nself.MAX_SIZE = MAX_SIZE\nself.size = 0\nself.lookup = {}\nself.linked_list = LinkedList()", "successors": []}], "functions": [], "classes": []}, {"name": "get", "type": "CFG", "blocks": [{"id": 44, "label": "#44\n\"\"\"Get the stored query result from the cache.\n\n        Accessing a node updates its position to the front of the LRU list.\n        \"\"\"\nnode = self.lookup[query]\nif node is None:", "successors": [{"id": 45, "label": "#45\nreturn None", "successors": []}, {"id": 46, "label": "#46\nself.linked_list.move_to_front(node)\nreturn node.results", "successors": []}]}], "functions": [], "classes": []}, {"name": "set", "type": "CFG", "blocks": [{"id": 51, "label": "#51\n\"\"\"Set the result for the given query key in the cache.\n\n        When updating an entry, updates its position to the front of the LRU list.\n        If the entry is new and the cache is at capacity, removes the oldest entry\n        before the new entry is added.\n        \"\"\"\nnode = self.map[query]\nif node is not None:", "successors": [{"id": 52, "label": "#52\nnode.results = results\nself.linked_list.move_to_front(node)", "successors": []}, {"id": 54, "label": "#54\nif self.size == self.MAX_SIZE:", "successors": [{"id": 55, "label": "#55\nself.lookup.pop(self.linked_list.tail.query, None)\nself.linked_list.remove_from_tail()", "successors": [{"id": 56, "label": "#56\nnew_node = Node(query, results)\nself.linked_list.append_to_front(new_node)\nself.lookup[query] = new_node", "successors": []}]}, {"id": 57, "label": "#57\nself.size += 1", "successors": []}]}]}], "functions": [], "classes": []}], "classes": []}]}
{"file_name": "148.json", "name": "148.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom abc import ABCMeta\nfrom enum import Enum", "successors": []}], "functions": [], "classes": [{"name": "UserService", "type": "CFG", "blocks": [{"id": 3, "label": "#3", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 5, "label": "#5\nself.users_by_id = {}", "successors": []}], "functions": [], "classes": []}, {"name": "add_user", "type": "CFG", "blocks": [{"id": 8, "label": "#8\npass", "successors": []}], "functions": [], "classes": []}, {"name": "remove_user", "type": "CFG", "blocks": [{"id": 11, "label": "#11\npass", "successors": []}], "functions": [], "classes": []}, {"name": "add_friend_request", "type": "CFG", "blocks": [{"id": 14, "label": "#14\npass", "successors": []}], "functions": [], "classes": []}, {"name": "approve_friend_request", "type": "CFG", "blocks": [{"id": 17, "label": "#17\npass", "successors": []}], "functions": [], "classes": []}, {"name": "reject_friend_request", "type": "CFG", "blocks": [{"id": 20, "label": "#20\npass", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "User", "type": "CFG", "blocks": [{"id": 24, "label": "#24", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 26, "label": "#26\nself.user_id = user_id\nself.name = name\nself.pass_hash = pass_hash\nself.friends_by_id = {}\nself.friend_ids_to_private_chats = {}\nself.group_chats_by_id = {}\nself.received_friend_requests_by_friend_id = {}\nself.sent_friend_requests_by_friend_id = {}", "successors": []}], "functions": [], "classes": []}, {"name": "message_user", "type": "CFG", "blocks": [{"id": 29, "label": "#29\npass", "successors": []}], "functions": [], "classes": []}, {"name": "message_group", "type": "CFG", "blocks": [{"id": 32, "label": "#32\npass", "successors": []}], "functions": [], "classes": []}, {"name": "send_friend_request", "type": "CFG", "blocks": [{"id": 35, "label": "#35\npass", "successors": []}], "functions": [], "classes": []}, {"name": "receive_friend_request", "type": "CFG", "blocks": [{"id": 38, "label": "#38\npass", "successors": []}], "functions": [], "classes": []}, {"name": "approve_friend_request", "type": "CFG", "blocks": [{"id": 41, "label": "#41\npass", "successors": []}], "functions": [], "classes": []}, {"name": "reject_friend_request", "type": "CFG", "blocks": [{"id": 44, "label": "#44\npass", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "Chat", "type": "CFG", "blocks": [{"id": 48, "label": "#48", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 50, "label": "#50\nself.chat_id = chat_id\nself.users = []\nself.messages = []", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "PrivateChat", "type": "CFG", "blocks": [{"id": 54, "label": "#54", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 56, "label": "#56\nsuper(PrivateChat, self).__init__()\nself.users.append(first_user)\nself.users.append(second_user)", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "GroupChat", "type": "CFG", "blocks": [{"id": 60, "label": "#60", "successors": []}], "functions": [{"name": "add_user", "type": "CFG", "blocks": [{"id": 62, "label": "#62\npass", "successors": []}], "functions": [], "classes": []}, {"name": "remove_user", "type": "CFG", "blocks": [{"id": 65, "label": "#65\npass", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "Message", "type": "CFG", "blocks": [{"id": 69, "label": "#69", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 71, "label": "#71\nself.message_id = message_id\nself.message = message\nself.timestamp = timestamp", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "AddRequest", "type": "CFG", "blocks": [{"id": 75, "label": "#75", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 77, "label": "#77\nself.from_user_id = from_user_id\nself.to_user_id = to_user_id\nself.request_status = request_status\nself.timestamp = timestamp", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "RequestStatus", "type": "CFG", "blocks": [{"id": 81, "label": "#81\nUNREAD = 0\nREAD = 1\nACCEPTED = 2\nREJECTED = 3", "successors": []}], "functions": [], "classes": []}]}
{"file_name": "149.json", "name": "149.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport logging\nfrom fastapi import Request\nfrom strenum import StrEnum\nfrom backend.data import integrations\nfrom backend.integrations.providers import ProviderName\nfrom ._manual_base import ManualWebhookManagerBase\nlogger = logging.getLogger(__name__)", "successors": []}], "functions": [], "classes": [{"name": "CompassWebhookType", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nTRANSCRIPTION = 'transcription'\nTASK = 'task'", "successors": []}], "functions": [], "classes": []}, {"name": "CompassWebhookManager", "type": "CFG", "blocks": [{"id": 6, "label": "#6\nPROVIDER_NAME = ProviderName.COMPASS\nWebhookType = CompassWebhookType", "successors": []}], "functions": [{"name": "validate_payload", "type": "CFG", "blocks": [{"id": 8, "label": "#8\npayload = await request.json()", "successors": [{"id": 9, "label": "#9\nevent_type = CompassWebhookType.TRANSCRIPTION\nreturn payload, event_type", "successors": []}]}], "functions": [], "classes": []}], "classes": []}]}
{"file_name": "150.json", "name": "150.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\n\"\"\"\nProblem:\n\nThe n queens problem is: placing N queens on a N * N chess board such that no queen\ncan attack any other queens placed on that chess board.  This means that one queen\ncannot have any other queen on its horizontal, vertical and diagonal lines.\n\nSolution:\n\nTo solve this problem we will use simple math. First we know the queen can move in all\nthe possible ways, we can simplify it in this: vertical, horizontal, diagonal left and\n diagonal right.\n\nWe can visualize it like this:\n\nleft diagonal = \\\\\nright diagonal = /\n\nOn a chessboard vertical movement could be the rows and horizontal movement could be\nthe columns.\n\nIn programming we can use an array, and in this array each index could be the rows and\neach value in the array could be the column. For example:\n\n    . Q . .     We have this chessboard with one queen in each column and each queen\n    . . . Q     can't attack to each other.\n    Q . . .     The array for this example would look like this: [1, 3, 0, 2]\n    . . Q .\n\nSo if we use an array and we verify that each value in the array is different to each\nother we know that at least the queens can't attack each other in horizontal and\nvertical.\n\nAt this point we have it halfway completed and we will treat the chessboard as a\nCartesian plane.  Hereinafter we are going to remember basic math, so in the school we\nlearned this formula:\n\n    Slope of a line:\n\n           y2 - y1\n     m = ----------\n          x2 - x1\n\nThis formula allow us to get the slope. For the angles 45\u00ba (right diagonal) and 135\u00ba\n(left diagonal) this formula gives us m = 1, and m = -1 respectively.\n\nSee::\nhttps://www.enotes.com/homework-help/write-equation-line-that-hits-origin-45-degree-1474860\n\nThen we have this other formula:\n\nSlope intercept:\n\ny = mx + b\n\nb is where the line crosses the Y axis (to get more information see:\nhttps://www.mathsisfun.com/y_intercept.html), if we change the formula to solve for b\nwe would have:\n\ny - mx = b\n\nAnd since we already have the m values for the angles 45\u00ba and 135\u00ba, this formula would\nlook like this:\n\n45\u00ba: y - (1)x = b\n45\u00ba: y - x = b\n\n135\u00ba: y - (-1)x = b\n135\u00ba: y + x = b\n\ny = row\nx = column\n\nApplying these two formulas we can check if a queen in some position is being attacked\nfor another one or vice versa.\n\n\"\"\"\nfrom __future__ import annotations\nif __name__ == '__main__':", "successors": [{"id": 20, "label": "#20\nimport doctest\ndoctest.testmod()\nn_queens_solution(4)", "successors": []}]}], "functions": [{"name": "depth_first_search", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"\n    >>> boards = []\n    >>> depth_first_search([], [], [], boards, 4)\n    >>> for board in boards:\n    ['. Q . . ', '. . . Q ', 'Q . . . ', '. . Q . ']\n    ['. . Q . ', 'Q . . . ', '. . . Q ', '. Q . . ']\n    \"\"\"\nrow = len(possible_board)\nif row == n:", "successors": [{"id": 4, "label": "#4\nboards.append([('. ' * i + 'Q ' + '. ' * (n - 1 - i)) for i in possible_board])\nreturn", "successors": []}, {"id": 5, "label": "#5\nfor col in range(n):", "successors": [{"id": 7, "label": "#7\nif col in possible_board or row - col in diagonal_right_collisions or row + col in diagonal_left_collisions:", "successors": [{"id": 10, "label": "#10\ndepth_first_search([*possible_board, col], [*diagonal_right_collisions, row -\n    col], [*diagonal_left_collisions, row + col], boards, n)", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "n_queens_solution", "type": "CFG", "blocks": [{"id": 13, "label": "#13\nboards: list[list[str]] = []\ndepth_first_search([], [], [], boards, n)", "successors": [{"id": 14, "label": "#14\nfor board in boards:", "successors": [{"id": 15, "label": "#15\nfor column in board:", "successors": [{"id": 17, "label": "#17\nprint(column)", "successors": []}, {"id": 18, "label": "#18\nprint('')", "successors": []}]}, {"id": 16, "label": "#16\nprint(len(boards), 'solutions were found.')", "successors": []}]}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "151.json", "name": "151.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom typing import Any, List\nfrom backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema, BlockType\nfrom backend.data.model import SchemaField\nfrom backend.util.mock import MockObject\nfrom backend.util.text import TextFormatter\nformatter = TextFormatter()", "successors": []}], "functions": [], "classes": [{"name": "StoreValueBlock", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"\n    This block allows you to provide a constant value as a block, in a stateless manner.\n    The common use-case is simply pass the `input` data, it will `output` the same data.\n    The block output will be static, the output can be consumed multiple times.\n    \"\"\"", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 11, "label": "#11\nsuper().__init__(id='1ff065e9-88e8-4358-9d82-8dc91f622ba9', description=\n    'This block forwards an input value as output, allowing reuse without change.'\n    , categories={BlockCategory.BASIC}, input_schema=StoreValueBlock.Input,\n    output_schema=StoreValueBlock.Output, test_input=[{'input':\n    'Hello, World!'}, {'input': 'Hello, World!', 'data': 'Existing Data'}],\n    test_output=[('output', 'Hello, World!'), ('output', 'Existing Data')],\n    static_output=True)", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 14, "label": "#14\nyield 'output', input_data.data or input_data.input", "successors": []}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 5, "label": "#5\ninput: Any = SchemaField(description=\n    'Trigger the block to produce the output. The value is only used when `data` is None.'\n    )\ndata: Any = SchemaField(description=\n    'The constant data to be retained in the block. This value is passed as `output`.'\n    , default=None)", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 8, "label": "#8\noutput: Any = SchemaField(description='The stored data retained in the block.')", "successors": []}], "functions": [], "classes": []}]}, {"name": "PrintToConsoleBlock", "type": "CFG", "blocks": [{"id": 19, "label": "#19", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 27, "label": "#27\nsuper().__init__(id='f3b1c1b2-4c4f-4f0d-8d2f-4c4f0d8d2f4c', description=\n    'Print the given text to the console, this is used for a debugging purpose.'\n    , categories={BlockCategory.BASIC}, input_schema=PrintToConsoleBlock.\n    Input, output_schema=PrintToConsoleBlock.Output, test_input={'text':\n    'Hello, World!'}, test_output=('status', 'printed'))", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 30, "label": "#30\nprint('>>>>> Print: ', input_data.text)\nyield 'status', 'printed'", "successors": []}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 21, "label": "#21\ntext: str = SchemaField(description='The text to print to the console.')", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 24, "label": "#24\nstatus: str = SchemaField(description='The status of the print operation.')", "successors": []}], "functions": [], "classes": []}]}, {"name": "FindInDictionaryBlock", "type": "CFG", "blocks": [{"id": 35, "label": "#35", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 43, "label": "#43\nsuper().__init__(id='0e50422c-6dee-4145-83d6-3a5a392f65de', description=\n    'Lookup the given key in the input dictionary/object/list and return the value.'\n    , input_schema=FindInDictionaryBlock.Input, output_schema=\n    FindInDictionaryBlock.Output, test_input=[{'input': {'apple': 1,\n    'banana': 2, 'cherry': 3}, 'key': 'banana'}, {'input': {'x': 10, 'y': \n    20, 'z': 30}, 'key': 'w'}, {'input': [1, 2, 3], 'key': 1}, {'input': [1,\n    2, 3], 'key': 3}, {'input': MockObject(value='!!', key='key'), 'key':\n    'key'}, {'input': [{'k1': 'v1'}, {'k2': 'v2'}, {'k1': 'v3'}], 'key':\n    'k1'}], test_output=[('output', 2), ('missing', {'x': 10, 'y': 20, 'z':\n    30}), ('output', 2), ('missing', [1, 2, 3]), ('output', 'key'), (\n    'output', ['v1', 'v3'])], categories={BlockCategory.BASIC})", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 46, "label": "#46\nobj = input_data.input\nkey = input_data.key\nif isinstance(obj, dict) and key in obj:", "successors": [{"id": 47, "label": "#47\nyield 'output', obj[key]", "successors": []}, {"id": 49, "label": "#49\nif isinstance(obj, list) and isinstance(key, int) and 0 <= key < len(obj):", "successors": [{"id": 50, "label": "#50\nyield 'output', obj[key]", "successors": []}, {"id": 52, "label": "#52\nif isinstance(obj, list) and isinstance(key, str):", "successors": [{"id": 53, "label": "#53\nif len(obj) == 0:", "successors": [{"id": 61, "label": "#61\nyield 'output', []", "successors": []}, {"id": 63, "label": "#63\nif isinstance(obj[0], dict) and key in obj[0]:", "successors": [{"id": 64, "label": "#64\nyield 'output', [item[key] for item in obj if key in item]", "successors": []}, {"id": 66, "label": "#66\nyield 'output', [getattr(val, key) for val in obj if hasattr(val, key)]", "successors": []}]}]}, {"id": 55, "label": "#55\nif isinstance(obj, object) and isinstance(key, str) and hasattr(obj, key):", "successors": [{"id": 56, "label": "#56\nyield 'output', getattr(obj, key)", "successors": []}, {"id": 58, "label": "#58\nyield 'missing', input_data.input", "successors": []}]}]}]}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 37, "label": "#37\ninput: Any = SchemaField(description='Dictionary to lookup from')\nkey: str | int = SchemaField(description='Key to lookup in the dictionary')", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 40, "label": "#40\noutput: Any = SchemaField(description='Value found for the given key')\nmissing: Any = SchemaField(description=\n    'Value of the input that missing the key')", "successors": []}], "functions": [], "classes": []}]}, {"name": "AgentInputBlock", "type": "CFG", "blocks": [{"id": 75, "label": "#75\n\"\"\"\n    This block is used to provide input to the graph.\n\n    It takes in a value, name, description, default values list and bool to limit selection to default values.\n\n    It Outputs the value passed as input.\n    \"\"\"", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 83, "label": "#83\nsuper().__init__(id='c0a8e994-ebf1-4a9c-a4d8-89d09c86741b', description=\n    'This block is used to provide input to the graph.', input_schema=\n    AgentInputBlock.Input, output_schema=AgentInputBlock.Output, test_input\n    =[{'value': 'Hello, World!', 'name': 'input_1', 'description':\n    'This is a test input.', 'placeholder_values': [],\n    'limit_to_placeholder_values': False}, {'value': 'Hello, World!',\n    'name': 'input_2', 'description': 'This is a test input.',\n    'placeholder_values': ['Hello, World!'], 'limit_to_placeholder_values':\n    True}], test_output=[('result', 'Hello, World!'), ('result',\n    'Hello, World!')], categories={BlockCategory.INPUT, BlockCategory.BASIC\n    }, block_type=BlockType.INPUT, static_output=True)", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 86, "label": "#86\nyield 'result', input_data.value", "successors": []}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 77, "label": "#77\nname: str = SchemaField(description='The name of the input.')\nvalue: Any = SchemaField(description='The value to be passed as input.',\n    default=None)\ntitle: str | None = SchemaField(description='The title of the input.',\n    default=None, advanced=True)\ndescription: str | None = SchemaField(description=\n    'The description of the input.', default=None, advanced=True)\nplaceholder_values: List[Any] = SchemaField(description=\n    'The placeholder values to be passed as input.', default=[], advanced=True)\nlimit_to_placeholder_values: bool = SchemaField(description=\n    'Whether to limit the selection to placeholder values.', default=False,\n    advanced=True)\nadvanced: bool = SchemaField(description=\n    'Whether to show the input in the advanced section, if the field is not required.'\n    , default=False, advanced=True)\nsecret: bool = SchemaField(description=\n    'Whether the input should be treated as a secret.', default=False,\n    advanced=True)", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 80, "label": "#80\nresult: Any = SchemaField(description='The value passed as input.')", "successors": []}], "functions": [], "classes": []}]}, {"name": "AgentOutputBlock", "type": "CFG", "blocks": [{"id": 91, "label": "#91\n\"\"\"\n    Records the output of the graph for users to see.\n\n    Behavior:\n        If `format` is provided and the `value` is of a type that can be formatted,\n        the block attempts to format the recorded_value using the `format`.\n        If formatting fails or no `format` is provided, the raw `value` is output.\n    \"\"\"", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 99, "label": "#99\nsuper().__init__(id='363ae599-353e-4804-937e-b2ee3cef3da4', description=\n    'Stores the output of the graph for users to see.', input_schema=\n    AgentOutputBlock.Input, output_schema=AgentOutputBlock.Output,\n    test_input=[{'value': 'Hello, World!', 'name': 'output_1',\n    'description': 'This is a test output.', 'format': '{{ output_1 }}!!'},\n    {'value': '42', 'name': 'output_2', 'description':\n    'This is another test output.', 'format': '{{ output_2 }}'}, {'value':\n    MockObject(value='!!', key='key'), 'name': 'output_3', 'description':\n    'This is a test output with a mock object.', 'format': '{{ output_3 }}'\n    }], test_output=[('output', 'Hello, World!!!'), ('output', '42'), (\n    'output', MockObject(value='!!', key='key'))], categories={\n    BlockCategory.OUTPUT, BlockCategory.BASIC}, block_type=BlockType.OUTPUT,\n    static_output=True)", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 102, "label": "#102\n\"\"\"\n        Attempts to format the recorded_value using the fmt_string if provided.\n        If formatting fails or no fmt_string is given, returns the original recorded_value.\n        \"\"\"\nif input_data.format:", "successors": [{"id": 103, "label": "#103\ntry:", "successors": [{"id": 107, "label": "#107\nyield 'output', formatter.format_string(input_data.format, {input_data.name:\n    input_data.value})", "successors": []}, {"id": 108, "label": "#108\nyield 'output', f'Error: {e}, {input_data.value}'", "successors": []}]}, {"id": 105, "label": "#105\nyield 'output', input_data.value", "successors": []}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 93, "label": "#93\nvalue: Any = SchemaField(description='The value to be recorded as output.',\n    default=None, advanced=False)\nname: str = SchemaField(description='The name of the output.')\ntitle: str | None = SchemaField(description='The title of the output.',\n    default=None, advanced=True)\ndescription: str | None = SchemaField(description=\n    'The description of the output.', default=None, advanced=True)\nformat: str = SchemaField(description=\n    'The format string to be used to format the recorded_value.', default=\n    '', advanced=True)\nadvanced: bool = SchemaField(description=\n    'Whether to treat the output as advanced.', default=False, advanced=True)\nsecret: bool = SchemaField(description=\n    'Whether the output should be treated as a secret.', default=False,\n    advanced=True)", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 96, "label": "#96\noutput: Any = SchemaField(description='The value recorded as output.')", "successors": []}], "functions": [], "classes": []}]}, {"name": "AddToDictionaryBlock", "type": "CFG", "blocks": [{"id": 115, "label": "#115", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 123, "label": "#123\nsuper().__init__(id='31d1064e-7446-4693-a7d4-65e5ca1180d1', description=\n    'Adds a new key-value pair to a dictionary. If no dictionary is provided, a new one is created.'\n    , categories={BlockCategory.BASIC}, input_schema=AddToDictionaryBlock.\n    Input, output_schema=AddToDictionaryBlock.Output, test_input=[{\n    'dictionary': {'existing_key': 'existing_value'}, 'key': 'new_key',\n    'value': 'new_value'}, {'key': 'first_key', 'value': 'first_value'}, {\n    'dictionary': {'existing_key': 'existing_value'}, 'entries': {'new_key':\n    'new_value', 'first_key': 'first_value'}}], test_output=[(\n    'updated_dictionary', {'existing_key': 'existing_value', 'new_key':\n    'new_value'}), ('updated_dictionary', {'first_key': 'first_value'}), (\n    'updated_dictionary', {'existing_key': 'existing_value', 'new_key':\n    'new_value', 'first_key': 'first_value'})])", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 126, "label": "#126\nupdated_dict = input_data.dictionary.copy()\nif input_data.value is not None and input_data.key:", "successors": [{"id": 127, "label": "#127\nupdated_dict[input_data.key] = input_data.value", "successors": [{"id": 128, "label": "#128\nfor key, value in input_data.entries.items():", "successors": [{"id": 129, "label": "#129\nupdated_dict[key] = value", "successors": []}, {"id": 130, "label": "#130\nyield 'updated_dictionary', updated_dict", "successors": []}]}]}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 117, "label": "#117\ndictionary: dict[Any, Any] = SchemaField(default={}, description=\n    'The dictionary to add the entry to. If not provided, a new dictionary will be created.'\n    )\nkey: str = SchemaField(default='', description='The key for the new entry.',\n    placeholder='new_key', advanced=False)\nvalue: Any = SchemaField(default=None, description=\n    'The value for the new entry.', placeholder='new_value', advanced=False)\nentries: dict[Any, Any] = SchemaField(default={}, description=\n    'The entries to add to the dictionary. This is the batch version of the `key` and `value` fields.'\n    , advanced=True)", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 120, "label": "#120\nupdated_dictionary: dict = SchemaField(description=\n    'The dictionary with the new entry added.')\nerror: str = SchemaField(description='Error message if the operation failed.')", "successors": []}], "functions": [], "classes": []}]}, {"name": "AddToListBlock", "type": "CFG", "blocks": [{"id": 135, "label": "#135", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 143, "label": "#143\nsuper().__init__(id='aeb08fc1-2fc1-4141-bc8e-f758f183a822', description=\n    'Adds a new entry to a list. The entry can be of any type. If no list is provided, a new one is created.'\n    , categories={BlockCategory.BASIC}, input_schema=AddToListBlock.Input,\n    output_schema=AddToListBlock.Output, test_input=[{'list': [1, 'string',\n    {'existing_key': 'existing_value'}], 'entry': {'new_key': 'new_value'},\n    'position': 1}, {'entry': 'first_entry'}, {'list': ['a', 'b', 'c'],\n    'entry': 'd'}, {'entry': 'e', 'entries': ['f', 'g'], 'list': ['a', 'b'],\n    'position': 1}], test_output=[('updated_list', [1, {'new_key':\n    'new_value'}, 'string', {'existing_key': 'existing_value'}]), (\n    'updated_list', ['first_entry']), ('updated_list', ['a', 'b', 'c', 'd']\n    ), ('updated_list', ['a', 'f', 'g', 'e', 'b'])])", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 146, "label": "#146\nentries_added = input_data.entries.copy()\nif input_data.entry:", "successors": [{"id": 147, "label": "#147\nentries_added.append(input_data.entry)", "successors": [{"id": 148, "label": "#148\nupdated_list = input_data.list.copy()\nif (pos := input_data.position) is not None:", "successors": [{"id": 149, "label": "#149\nupdated_list = updated_list[:pos] + entries_added + updated_list[pos:]", "successors": [{"id": 150, "label": "#150\nyield 'updated_list', updated_list", "successors": []}]}, {"id": 151, "label": "#151\nupdated_list += entries_added", "successors": []}]}]}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 137, "label": "#137\nlist: List[Any] = SchemaField(default=[], advanced=False, description=\n    'The list to add the entry to. If not provided, a new list will be created.'\n    )\nentry: Any = SchemaField(description=\n    'The entry to add to the list. Can be of any type (string, int, dict, etc.).'\n    , advanced=False, default=None)\nentries: List[Any] = SchemaField(default=[], description=\n    'The entries to add to the list. This is the batch version of the `entry` field.'\n    , advanced=True)\nposition: int | None = SchemaField(default=None, description=\n    'The position to insert the new entry. If not provided, the entry will be appended to the end of the list.'\n    )", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 140, "label": "#140\nupdated_list: List[Any] = SchemaField(description=\n    'The list with the new entry added.')\nerror: str = SchemaField(description='Error message if the operation failed.')", "successors": []}], "functions": [], "classes": []}]}, {"name": "NoteBlock", "type": "CFG", "blocks": [{"id": 156, "label": "#156", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 164, "label": "#164\nsuper().__init__(id='cc10ff7b-7753-4ff2-9af6-9399b1a7eddc', description=\n    'This block is used to display a sticky note with the given text.',\n    categories={BlockCategory.BASIC}, input_schema=NoteBlock.Input,\n    output_schema=NoteBlock.Output, test_input={'text': 'Hello, World!'},\n    test_output=[('output', 'Hello, World!')], block_type=BlockType.NOTE)", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 167, "label": "#167\nyield 'output', input_data.text", "successors": []}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 158, "label": "#158\ntext: str = SchemaField(description='The text to display in the sticky note.')", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 161, "label": "#161\noutput: str = SchemaField(description='The text to display in the sticky note.'\n    )", "successors": []}], "functions": [], "classes": []}]}, {"name": "CreateDictionaryBlock", "type": "CFG", "blocks": [{"id": 172, "label": "#172", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 180, "label": "#180\nsuper().__init__(id='b924ddf4-de4f-4b56-9a85-358930dcbc91', description=\n    'Creates a dictionary with the specified key-value pairs. Use this when you know all the values you want to add upfront.'\n    , categories={BlockCategory.DATA}, input_schema=CreateDictionaryBlock.\n    Input, output_schema=CreateDictionaryBlock.Output, test_input=[{\n    'values': {'name': 'Alice', 'age': 25, 'city': 'New York'}}, {'values':\n    {'numbers': [1, 2, 3], 'active': True, 'score': 95.5}}], test_output=[(\n    'dictionary', {'name': 'Alice', 'age': 25, 'city': 'New York'}), (\n    'dictionary', {'numbers': [1, 2, 3], 'active': True, 'score': 95.5})])", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 183, "label": "#183\ntry:", "successors": [{"id": 184, "label": "#184\nyield 'dictionary', input_data.values", "successors": []}, {"id": 185, "label": "#185\nyield 'error', f'Failed to create dictionary: {str(e)}'", "successors": []}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 174, "label": "#174\nvalues: dict[str, Any] = SchemaField(description=\n    'Key-value pairs to create the dictionary with', placeholder=\n    \"e.g., {'name': 'Alice', 'age': 25}\")", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 177, "label": "#177\ndictionary: dict[str, Any] = SchemaField(description=\n    'The created dictionary containing the specified key-value pairs')\nerror: str = SchemaField(description=\n    'Error message if dictionary creation failed')", "successors": []}], "functions": [], "classes": []}]}, {"name": "CreateListBlock", "type": "CFG", "blocks": [{"id": 192, "label": "#192", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 200, "label": "#200\nsuper().__init__(id='a912d5c7-6e00-4542-b2a9-8034136930e4', description=\n    'Creates a list with the specified values. Use this when you know all the values you want to add upfront.'\n    , categories={BlockCategory.DATA}, input_schema=CreateListBlock.Input,\n    output_schema=CreateListBlock.Output, test_input=[{'values': ['Alice', \n    25, True]}, {'values': [1, 2, 3, 'four', {'key': 'value'}]}],\n    test_output=[('list', ['Alice', 25, True]), ('list', [1, 2, 3, 'four',\n    {'key': 'value'}])])", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 203, "label": "#203\ntry:", "successors": [{"id": 204, "label": "#204\nyield 'list', input_data.values", "successors": []}, {"id": 205, "label": "#205\nyield 'error', f'Failed to create list: {str(e)}'", "successors": []}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 194, "label": "#194\nvalues: List[Any] = SchemaField(description=\n    'A list of values to be combined into a new list.', placeholder=\n    \"e.g., ['Alice', 25, True]\")", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 197, "label": "#197\nlist: List[Any] = SchemaField(description=\n    'The created list containing the specified values.')\nerror: str = SchemaField(description='Error message if list creation failed.')", "successors": []}], "functions": [], "classes": []}]}]}
{"file_name": "152.json", "name": "152.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport subprocess\nimport sys\nimport time", "successors": []}], "functions": [{"name": "wait_for_postgres", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nfor _ in range(max_retries):", "successors": [{"id": 4, "label": "#4\ntry:", "successors": [{"id": 6, "label": "#6\nresult = subprocess.run(['docker', 'compose', '-f',\n    'docker-compose.test.yaml', 'exec', 'postgres-test', 'pg_isready', '-U',\n    'postgres', '-d', 'postgres'], check=True, capture_output=True, text=True)\nif 'accepting connections' in result.stdout:", "successors": [{"id": 9, "label": "#9\nprint('PostgreSQL is ready.')\nreturn True", "successors": []}]}, {"id": 7, "label": "#7\ntime.sleep(delay)", "successors": []}]}, {"id": 5, "label": "#5\nprint('Failed to connect to PostgreSQL.')\nreturn False", "successors": []}]}], "functions": [], "classes": []}, {"name": "run_command", "type": "CFG", "blocks": [{"id": 15, "label": "#15\ntry:", "successors": [{"id": 16, "label": "#16\nsubprocess.run(command, check=check)", "successors": []}, {"id": 17, "label": "#17\nprint(f'Command failed: {e}')\nsys.exit(1)", "successors": []}]}], "functions": [], "classes": []}, {"name": "test", "type": "CFG", "blocks": [{"id": 21, "label": "#21\nrun_command(['docker', 'compose', '-f', 'docker-compose.test.yaml', 'up',\n    '-d', 'postgres-test'])\nif not wait_for_postgres():", "successors": [{"id": 22, "label": "#22\nrun_command(['docker', 'compose', '-f', 'docker-compose.test.yaml', 'down'])\nsys.exit(1)", "successors": [{"id": 23, "label": "#23\nrun_command(['prisma', 'migrate', 'dev'])\nresult = subprocess.run(['pytest'] + sys.argv[1:], check=False)\nrun_command(['docker', 'compose', '-f', 'docker-compose.test.yaml', 'down'])\nsys.exit(result.returncode)", "successors": []}]}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "153.json", "name": "153.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom datetime import datetime, timezone\nfrom typing import Iterator\nimport praw\nfrom pydantic import BaseModel, ConfigDict\nfrom backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema\nfrom backend.data.model import BlockSecret, SchemaField, SecretField\nfrom backend.util.mock import MockObject", "successors": []}], "functions": [{"name": "get_praw", "type": "CFG", "blocks": [{"id": 12, "label": "#12\nclient = praw.Reddit(client_id=creds.client_id.get_secret_value(),\n    client_secret=creds.client_secret.get_secret_value(), username=creds.\n    username.get_secret_value(), password=creds.password.get_secret_value(),\n    user_agent=creds.user_agent)\nme = client.user.me()\nif not me:", "successors": [{"id": 13, "label": "#13\nraise ValueError('Invalid Reddit credentials.')", "successors": []}, {"id": 14, "label": "#14\nprint(f'Logged in as Reddit user: {me.name}')\nreturn client", "successors": []}]}], "functions": [], "classes": []}], "classes": [{"name": "RedditCredentials", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nclient_id: BlockSecret = SecretField(key='reddit_client_id')\nclient_secret: BlockSecret = SecretField(key='reddit_client_secret')\nusername: BlockSecret = SecretField(key='reddit_username')\npassword: BlockSecret = SecretField(key='reddit_password')\nuser_agent: str = 'AutoGPT:1.0 (by /u/autogpt)'\nmodel_config = ConfigDict(title='Reddit Credentials')", "successors": []}], "functions": [], "classes": []}, {"name": "RedditPost", "type": "CFG", "blocks": [{"id": 6, "label": "#6\nid: str\nsubreddit: str\ntitle: str\nbody: str", "successors": []}], "functions": [], "classes": []}, {"name": "RedditComment", "type": "CFG", "blocks": [{"id": 9, "label": "#9\npost_id: str\ncomment: str", "successors": []}], "functions": [], "classes": []}, {"name": "GetRedditPostsBlock", "type": "CFG", "blocks": [{"id": 19, "label": "#19", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 27, "label": "#27\nsuper().__init__(disabled=True, id='c6731acb-4285-4ee1-bc9b-03d0766c370f',\n    description=\n    'This block fetches Reddit posts from a defined subreddit name.',\n    categories={BlockCategory.SOCIAL}, input_schema=GetRedditPostsBlock.\n    Input, output_schema=GetRedditPostsBlock.Output, test_input={'creds': {\n    'client_id': 'client_id', 'client_secret': 'client_secret', 'username':\n    'username', 'password': 'password', 'user_agent': 'user_agent'},\n    'subreddit': 'subreddit', 'last_post': 'id3', 'post_limit': 2},\n    test_output=[('post', RedditPost(id='id1', subreddit='subreddit', title\n    ='title1', body='body1')), ('post', RedditPost(id='id2', subreddit=\n    'subreddit', title='title2', body='body2'))], test_mock={'get_posts': \n    lambda _: [MockObject(id='id1', title='title1', selftext='body1'),\n    MockObject(id='id2', title='title2', selftext='body2'), MockObject(id=\n    'id3', title='title2', selftext='body2')]})", "successors": []}], "functions": [], "classes": []}, {"name": "get_posts", "type": "CFG", "blocks": [{"id": 30, "label": "#30\nclient = get_praw(input_data.creds)\nsubreddit = client.subreddit(input_data.subreddit)\nreturn subreddit.new(limit=input_data.post_limit or 10)", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 34, "label": "#34\ncurrent_time = datetime.now(tz=timezone.utc)", "successors": [{"id": 35, "label": "#35\nfor post in self.get_posts(input_data):", "successors": [{"id": 36, "label": "#36\nif input_data.last_minutes:", "successors": [{"id": 38, "label": "#38\npost_datetime = datetime.fromtimestamp(post.created_utc, tz=timezone.utc)\ntime_difference = current_time - post_datetime\nif time_difference.total_seconds() / 60 > input_data.last_minutes:", "successors": [{"id": 39, "label": "#39\nif input_data.last_post and post.id == input_data.last_post:", "successors": [{"id": 43, "label": "#43\nyield 'post', RedditPost(id=post.id, subreddit=input_data.subreddit, title=\n    post.title, body=post.selftext)", "successors": []}]}]}]}]}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 21, "label": "#21\nsubreddit: str = SchemaField(description='Subreddit name')\ncreds: RedditCredentials = SchemaField(description='Reddit credentials',\n    default=RedditCredentials())\nlast_minutes: int | None = SchemaField(description=\n    'Post time to stop minutes ago while fetching posts', default=None)\nlast_post: str | None = SchemaField(description=\n    'Post ID to stop when reached while fetching posts', default=None)\npost_limit: int | None = SchemaField(description='Number of posts to fetch',\n    default=10)", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 24, "label": "#24\npost: RedditPost = SchemaField(description='Reddit post')", "successors": []}], "functions": [], "classes": []}]}, {"name": "PostRedditCommentBlock", "type": "CFG", "blocks": [{"id": 48, "label": "#48", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 56, "label": "#56\nsuper().__init__(id='4a92261b-701e-4ffb-8970-675fd28e261f', description=\n    'This block posts a Reddit comment on a specified Reddit post.',\n    categories={BlockCategory.SOCIAL}, input_schema=PostRedditCommentBlock.\n    Input, output_schema=PostRedditCommentBlock.Output, test_input={'data':\n    {'post_id': 'id', 'comment': 'comment'}}, test_output=[('comment_id',\n    'dummy_comment_id')], test_mock={'reply_post': lambda creds, comment:\n    'dummy_comment_id'})", "successors": []}], "functions": [], "classes": []}, {"name": "reply_post", "type": "CFG", "blocks": [{"id": 59, "label": "#59\nclient = get_praw(creds)\nsubmission = client.submission(id=comment.post_id)\nnew_comment = submission.reply(comment.comment)\nif not new_comment:", "successors": [{"id": 60, "label": "#60\nraise ValueError('Failed to post comment.')", "successors": []}, {"id": 61, "label": "#61\nreturn new_comment.id", "successors": []}]}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 66, "label": "#66\nyield 'comment_id', self.reply_post(input_data.creds, input_data.data)", "successors": []}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 50, "label": "#50\ncreds: RedditCredentials = SchemaField(description='Reddit credentials',\n    default=RedditCredentials())\ndata: RedditComment = SchemaField(description='Reddit comment')", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 53, "label": "#53\ncomment_id: str = SchemaField(description='Posted comment ID')", "successors": []}], "functions": [], "classes": []}]}]}
{"file_name": "154.json", "name": "154.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport unittest\nfrom validate.links import find_links_in_text\nfrom validate.links import check_duplicate_links\nfrom validate.links import fake_user_agent\nfrom validate.links import get_host_from_link\nfrom validate.links import has_cloudflare_protection", "successors": []}], "functions": [], "classes": [{"name": "FakeResponse", "type": "CFG", "blocks": [{"id": 3, "label": "#3", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 5, "label": "#5\nself.status_code = code\nself.headers = headers\nself.text = text", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "TestValidateLinks", "type": "CFG", "blocks": [{"id": 9, "label": "#9", "successors": []}], "functions": [{"name": "setUp", "type": "CFG", "blocks": [{"id": 11, "label": "#11\nself.duplicate_links = ['https://www.example.com',\n    'https://www.example.com', 'https://www.example.com',\n    'https://www.anotherexample.com']\nself.no_duplicate_links = ['https://www.firstexample.com',\n    'https://www.secondexample.com', 'https://www.anotherexample.com']\nself.code_200 = 200\nself.code_403 = 403\nself.code_503 = 503\nself.cloudflare_headers = {'Server': 'cloudflare'}\nself.no_cloudflare_headers = {'Server': 'google'}\nself.text_with_cloudflare_flags = (\nself.text_without_cloudflare_flags = 'Lorem Ipsum'", "successors": []}], "functions": [], "classes": []}, {"name": "test_find_link_in_text", "type": "CFG", "blocks": [{"id": 14, "label": "#14\ntext = \"\"\"\n            # this is valid\n\n            http://example.com?param1=1&param2=2#anchor\n            https://www.example.com?param1=1&param2=2#anchor\n            https://www.example.com.br\n            https://www.example.com.gov.br\n            [Example](https://www.example.com?param1=1&param2=2#anchor)\n            lorem ipsum https://www.example.com?param1=1&param2=2#anchor\n            https://www.example.com?param1=1&param2=2#anchor lorem ipsum\n\n            # this not is valid\n\n            example.com\n            https:example.com\n            https:/example.com\n            https//example.com\n            https//.com\n        \"\"\"\nlinks = find_links_in_text(text)\nself.assertIsInstance(links, list)\nself.assertEqual(len(links), 7)", "successors": [{"id": 15, "label": "#15\nfor link in links:", "successors": [{"id": 16, "label": "#16\nwith self.subTest():", "successors": [{"id": 18, "label": "#18\nself.assertIsInstance(link, str)", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "test_find_link_in_text_with_invalid_argument", "type": "CFG", "blocks": [{"id": 22, "label": "#22\nwith self.assertRaises(TypeError):", "successors": [{"id": 23, "label": "#23\nfind_links_in_text()\nfind_links_in_text(1)\nfind_links_in_text(True)", "successors": []}]}], "functions": [], "classes": []}, {"name": "test_if_check_duplicate_links_has_the_correct_return", "type": "CFG", "blocks": [{"id": 27, "label": "#27\nresult_1 = check_duplicate_links(self.duplicate_links)\nresult_2 = check_duplicate_links(self.no_duplicate_links)\nself.assertIsInstance(result_1, tuple)\nself.assertIsInstance(result_2, tuple)\nhas_duplicate_links, links = result_1\nno_duplicate_links, no_links = result_2\nself.assertTrue(has_duplicate_links)\nself.assertFalse(no_duplicate_links)\nself.assertIsInstance(links, list)\nself.assertIsInstance(no_links, list)\nself.assertEqual(len(links), 2)\nself.assertEqual(len(no_links), 0)", "successors": []}], "functions": [], "classes": []}, {"name": "test_if_fake_user_agent_has_a_str_as_return", "type": "CFG", "blocks": [{"id": 30, "label": "#30\nuser_agent = fake_user_agent()\nself.assertIsInstance(user_agent, str)", "successors": []}], "functions": [], "classes": []}, {"name": "test_get_host_from_link", "type": "CFG", "blocks": [{"id": 33, "label": "#33\nlinks = ['example.com', 'https://example.com', 'https://www.example.com',\n    'https://www.example.com.br', 'https://www.example.com/route',\n    'https://www.example.com?p=1&q=2', 'https://www.example.com#anchor']", "successors": [{"id": 34, "label": "#34\nfor link in links:", "successors": [{"id": 35, "label": "#35\nhost = get_host_from_link(link)\nwith self.subTest():", "successors": [{"id": 37, "label": "#37\nself.assertIsInstance(host, str)\nself.assertNotIn('://', host)\nself.assertNotIn('/', host)\nself.assertNotIn('?', host)\nself.assertNotIn('#', host)", "successors": []}]}, {"id": 36, "label": "#36\nwith self.assertRaises(TypeError):", "successors": [{"id": 39, "label": "#39\nget_host_from_link()", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "test_has_cloudflare_protection_with_code_403_and_503_in_response", "type": "CFG", "blocks": [{"id": 43, "label": "#43\nresp_with_cloudflare_protection_code_403 = FakeResponse(code=self.code_403,\n    headers=self.cloudflare_headers, text=self.text_with_cloudflare_flags)\nresp_with_cloudflare_protection_code_503 = FakeResponse(code=self.code_503,\n    headers=self.cloudflare_headers, text=self.text_with_cloudflare_flags)\nresult1 = has_cloudflare_protection(resp_with_cloudflare_protection_code_403)\nresult2 = has_cloudflare_protection(resp_with_cloudflare_protection_code_503)\nself.assertTrue(result1)\nself.assertTrue(result2)", "successors": []}], "functions": [], "classes": []}, {"name": "test_has_cloudflare_protection_when_there_is_no_protection", "type": "CFG", "blocks": [{"id": 46, "label": "#46\nresp_without_cloudflare_protection1 = FakeResponse(code=self.code_200,\n    headers=self.no_cloudflare_headers, text=self.text_without_cloudflare_flags\n    )\nresp_without_cloudflare_protection2 = FakeResponse(code=self.code_403,\n    headers=self.no_cloudflare_headers, text=self.text_without_cloudflare_flags\n    )\nresp_without_cloudflare_protection3 = FakeResponse(code=self.code_503,\n    headers=self.no_cloudflare_headers, text=self.text_without_cloudflare_flags\n    )\nresult1 = has_cloudflare_protection(resp_without_cloudflare_protection1)\nresult2 = has_cloudflare_protection(resp_without_cloudflare_protection2)\nresult3 = has_cloudflare_protection(resp_without_cloudflare_protection3)\nself.assertFalse(result1)\nself.assertFalse(result2)\nself.assertFalse(result3)", "successors": []}], "functions": [], "classes": []}], "classes": []}]}
{"file_name": "155.json", "name": "155.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom abc import ABCMeta, abstractmethod\nfrom enum import Enum", "successors": []}], "functions": [], "classes": [{"name": "VehicleSize", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nMOTORCYCLE = 0\nCOMPACT = 1\nLARGE = 2", "successors": []}], "functions": [], "classes": []}, {"name": "Vehicle", "type": "CFG", "blocks": [{"id": 6, "label": "#6", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 8, "label": "#8\nself.vehicle_size = vehicle_size\nself.license_plate = license_plate\nself.spot_size\nself.spots_taken = []", "successors": []}], "functions": [], "classes": []}, {"name": "clear_spots", "type": "CFG", "blocks": [{"id": 11, "label": "#11\nfor spot in self.spots_taken:", "successors": [{"id": 12, "label": "#12\nspot.remove_vehicle(self)", "successors": []}, {"id": 13, "label": "#13\nself.spots_taken = []", "successors": []}]}], "functions": [], "classes": []}, {"name": "take_spot", "type": "CFG", "blocks": [{"id": 16, "label": "#16\nself.spots_taken.append(spot)", "successors": []}], "functions": [], "classes": []}, {"name": "can_fit_in_spot", "type": "CFG", "blocks": [{"id": 19, "label": "#19\npass", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "Motorcycle", "type": "CFG", "blocks": [{"id": 23, "label": "#23", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 25, "label": "#25\nsuper(Motorcycle, self).__init__(VehicleSize.MOTORCYCLE, license_plate,\n    spot_size=1)", "successors": []}], "functions": [], "classes": []}, {"name": "can_fit_in_spot", "type": "CFG", "blocks": [{"id": 28, "label": "#28\nreturn True", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "Car", "type": "CFG", "blocks": [{"id": 33, "label": "#33", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 35, "label": "#35\nsuper(Car, self).__init__(VehicleSize.COMPACT, license_plate, spot_size=1)", "successors": []}], "functions": [], "classes": []}, {"name": "can_fit_in_spot", "type": "CFG", "blocks": [{"id": 38, "label": "#38\nreturn spot.size in (VehicleSize.LARGE, VehicleSize.COMPACT)", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "Bus", "type": "CFG", "blocks": [{"id": 43, "label": "#43", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 45, "label": "#45\nsuper(Bus, self).__init__(VehicleSize.LARGE, license_plate, spot_size=5)", "successors": []}], "functions": [], "classes": []}, {"name": "can_fit_in_spot", "type": "CFG", "blocks": [{"id": 48, "label": "#48\nreturn spot.size == VehicleSize.LARGE", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "ParkingLot", "type": "CFG", "blocks": [{"id": 53, "label": "#53", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 55, "label": "#55\nself.num_levels = num_levels\nself.levels = []", "successors": []}], "functions": [], "classes": []}, {"name": "park_vehicle", "type": "CFG", "blocks": [{"id": 58, "label": "#58\nfor level in self.levels:", "successors": [{"id": 59, "label": "#59\nif level.park_vehicle(vehicle):", "successors": [{"id": 61, "label": "#61\nreturn True", "successors": []}]}, {"id": 60, "label": "#60\nreturn False", "successors": []}]}], "functions": [], "classes": []}], "classes": []}, {"name": "Level", "type": "CFG", "blocks": [{"id": 68, "label": "#68\nSPOTS_PER_ROW = 10", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 70, "label": "#70\nself.floor = floor\nself.num_spots = total_spots\nself.available_spots = 0\nself.spots = []", "successors": []}], "functions": [], "classes": []}, {"name": "spot_freed", "type": "CFG", "blocks": [{"id": 73, "label": "#73\nself.available_spots += 1", "successors": []}], "functions": [], "classes": []}, {"name": "park_vehicle", "type": "CFG", "blocks": [{"id": 76, "label": "#76\nspot = self._find_available_spot(vehicle)\nif spot is None:", "successors": [{"id": 77, "label": "#77\nreturn None", "successors": []}, {"id": 79, "label": "#79\nspot.park_vehicle(vehicle)\nreturn spot", "successors": []}]}], "functions": [], "classes": []}, {"name": "_find_available_spot", "type": "CFG", "blocks": [{"id": 84, "label": "#84\n\"\"\"Find an available spot where vehicle can fit, or return None\"\"\"\npass", "successors": []}], "functions": [], "classes": []}, {"name": "_park_starting_at_spot", "type": "CFG", "blocks": [{"id": 87, "label": "#87\n\"\"\"Occupy starting at spot.spot_number to vehicle.spot_size.\"\"\"\npass", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "ParkingSpot", "type": "CFG", "blocks": [{"id": 91, "label": "#91", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 93, "label": "#93\nself.level = level\nself.row = row\nself.spot_number = spot_number\nself.spot_size = spot_size\nself.vehicle_size = vehicle_size\nself.vehicle = None", "successors": []}], "functions": [], "classes": []}, {"name": "is_available", "type": "CFG", "blocks": [{"id": 96, "label": "#96\nreturn True if self.vehicle is None else False", "successors": []}], "functions": [], "classes": []}, {"name": "can_fit_vehicle", "type": "CFG", "blocks": [{"id": 100, "label": "#100\nif self.vehicle is not None:", "successors": [{"id": 101, "label": "#101\nreturn False", "successors": []}, {"id": 102, "label": "#102\nreturn vehicle.can_fit_in_spot(self)", "successors": []}]}], "functions": [], "classes": []}, {"name": "park_vehicle", "type": "CFG", "blocks": [{"id": 107, "label": "#107\npass", "successors": []}], "functions": [], "classes": []}, {"name": "remove_vehicle", "type": "CFG", "blocks": [{"id": 110, "label": "#110\npass", "successors": []}], "functions": [], "classes": []}], "classes": []}]}
{"file_name": "156.json", "name": "156.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom fastapi import HTTPException, Request\nfrom starlette.middleware.base import RequestResponseEndpoint\nfrom .limiter import RateLimiter", "successors": []}], "functions": [{"name": "rate_limit_middleware", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"FastAPI middleware for rate limiting API requests.\"\"\"\nlimiter = RateLimiter()\nif not request.url.path.startswith('/api'):", "successors": [{"id": 4, "label": "#4\nreturn await call_next(request)", "successors": []}, {"id": 5, "label": "#5\napi_key = request.headers.get('Authorization')\nif not api_key:", "successors": [{"id": 7, "label": "#7\nreturn await call_next(request)", "successors": []}, {"id": 8, "label": "#8\napi_key = api_key.replace('Bearer ', '')\nis_allowed, remaining, reset_time = await limiter.check_rate_limit(api_key)", "successors": [{"id": 10, "label": "#10\nif not is_allowed:", "successors": [{"id": 11, "label": "#11\nraise HTTPException(status_code=429, detail=\n    'Rate limit exceeded. Please try again later.')", "successors": []}, {"id": 12, "label": "#12\nresponse = await call_next(request)", "successors": [{"id": 14, "label": "#14\nresponse.headers['X-RateLimit-Limit'] = str(limiter.max_requests)\nresponse.headers['X-RateLimit-Remaining'] = str(remaining)\nresponse.headers['X-RateLimit-Reset'] = str(reset_time)\nreturn response", "successors": []}]}]}]}]}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "157.json", "name": "157.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport logging\nimport os\nfrom dotenv import load_dotenv\nfrom redis import Redis\nfrom redis.asyncio import Redis as AsyncRedis\nfrom backend.util.retry import conn_retry\nload_dotenv()\nHOST = os.getenv('REDIS_HOST', 'localhost')\nPORT = int(os.getenv('REDIS_PORT', '6379'))\nPASSWORD = os.getenv('REDIS_PASSWORD', 'password')\nlogger = logging.getLogger(__name__)\nconnection: Redis | None = None\nconnection_async: AsyncRedis | None = None", "successors": []}], "functions": [{"name": "connect", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nglobal connection\nif connection:", "successors": [{"id": 4, "label": "#4\nreturn connection", "successors": []}, {"id": 5, "label": "#5\nc = Redis(host=HOST, port=PORT, password=PASSWORD, decode_responses=True)\nc.ping()\nconnection = c\nreturn connection", "successors": []}]}], "functions": [], "classes": []}, {"name": "disconnect", "type": "CFG", "blocks": [{"id": 10, "label": "#10\nglobal connection\nif connection:", "successors": [{"id": 11, "label": "#11\nconnection.close()", "successors": [{"id": 12, "label": "#12\nconnection = None", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "get_redis", "type": "CFG", "blocks": [{"id": 15, "label": "#15\nif connection:", "successors": [{"id": 16, "label": "#16\nreturn connection", "successors": []}, {"id": 17, "label": "#17\nif auto_connect:", "successors": [{"id": 19, "label": "#19\nreturn connect()", "successors": []}, {"id": 20, "label": "#20\nraise RuntimeError('Redis connection is not established')", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "connect_async", "type": "CFG", "blocks": [{"id": 25, "label": "#25\nglobal connection_async\nif connection_async:", "successors": [{"id": 26, "label": "#26\nreturn connection_async", "successors": []}, {"id": 27, "label": "#27\nc = AsyncRedis(host=HOST, port=PORT, password=PASSWORD, decode_responses=True)\nawait c.ping()", "successors": [{"id": 29, "label": "#29\nconnection_async = c\nreturn connection_async", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "disconnect_async", "type": "CFG", "blocks": [{"id": 33, "label": "#33\nglobal connection_async\nif connection_async:", "successors": [{"id": 34, "label": "#34\nawait connection_async.close()", "successors": [{"id": 35, "label": "#35\nconnection_async = None", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "get_redis_async", "type": "CFG", "blocks": [{"id": 39, "label": "#39\nif connection_async:", "successors": [{"id": 40, "label": "#40\nreturn connection_async", "successors": []}, {"id": 41, "label": "#41\nif auto_connect:", "successors": [{"id": 43, "label": "#43\nreturn await connect_async()", "successors": []}, {"id": 44, "label": "#44\nraise RuntimeError('AsyncRedis connection is not established')", "successors": []}]}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "158.json", "name": "158.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport io\nimport unittest.mock\nimport fastapi\nimport pytest\nimport starlette.datastructures\nimport backend.server.v2.store.exceptions\nimport backend.server.v2.store.media\nfrom backend.util.settings import Settings", "successors": []}], "functions": [{"name": "mock_settings", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nsettings = Settings()\nsettings.config.media_gcs_bucket_name = 'test-bucket'\nsettings.config.google_application_credentials = 'test-credentials'\nmonkeypatch.setattr('backend.server.v2.store.media.Settings', lambda : settings\n    )\nreturn settings", "successors": []}], "functions": [], "classes": []}, {"name": "mock_storage_client", "type": "CFG", "blocks": [{"id": 7, "label": "#7\nmock_client = unittest.mock.MagicMock()\nmock_bucket = unittest.mock.MagicMock()\nmock_blob = unittest.mock.MagicMock()\nmock_client.bucket.return_value = mock_bucket\nmock_bucket.blob.return_value = mock_blob\nmock_blob.public_url = 'http://test-url/media/laptop.jpeg'\nmocker.patch('google.cloud.storage.Client', return_value=mock_client)\nreturn mock_client", "successors": []}], "functions": [], "classes": []}, {"name": "test_upload_media_success", "type": "CFG", "blocks": [{"id": 11, "label": "#11\ntest_data = b'\\xff\\xd8\\xff' + b'test data'\ntest_file = fastapi.UploadFile(filename='laptop.jpeg', file=io.BytesIO(\n    test_data), headers=starlette.datastructures.Headers({'content-type':\n    'image/jpeg'}))\nresult = await backend.server.v2.store.media.upload_media('test-user',\n    test_file)", "successors": [{"id": 12, "label": "#12\nassert result == 'http://test-url/media/laptop.jpeg'", "successors": [{"id": 14, "label": "#14\nmock_bucket = mock_storage_client.bucket.return_value\nmock_blob = mock_bucket.blob.return_value\nmock_blob.upload_from_string.assert_called_once()", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "test_upload_media_invalid_type", "type": "CFG", "blocks": [{"id": 17, "label": "#17\ntest_file = fastapi.UploadFile(filename='test.txt', file=io.BytesIO(\n    b'test data'), headers=starlette.datastructures.Headers({'content-type':\n    'text/plain'}))\nwith pytest.raises(backend.server.v2.store.exceptions.InvalidFileTypeError):", "successors": [{"id": 18, "label": "#18\nawait backend.server.v2.store.media.upload_media('test-user', test_file)", "successors": [{"id": 19, "label": "#19\nmock_bucket = mock_storage_client.bucket.return_value\nmock_blob = mock_bucket.blob.return_value\nmock_blob.upload_from_string.assert_not_called()", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "test_upload_media_missing_credentials", "type": "CFG", "blocks": [{"id": 23, "label": "#23\nsettings = Settings()\nsettings.config.media_gcs_bucket_name = ''\nsettings.config.google_application_credentials = ''\nmonkeypatch.setattr('backend.server.v2.store.media.Settings', lambda : settings\n    )\ntest_file = fastapi.UploadFile(filename='laptop.jpeg', file=io.BytesIO(\n    b'\\xff\\xd8\\xff' + b'test data'), headers=starlette.datastructures.\n    Headers({'content-type': 'image/jpeg'}))\nwith pytest.raises(backend.server.v2.store.exceptions.StorageConfigError):", "successors": [{"id": 24, "label": "#24\nawait backend.server.v2.store.media.upload_media('test-user', test_file)", "successors": []}]}], "functions": [], "classes": []}, {"name": "test_upload_media_video_type", "type": "CFG", "blocks": [{"id": 29, "label": "#29\ntest_file = fastapi.UploadFile(filename='test.mp4', file=io.BytesIO(\n    b'\\x00\\x00\\x00\\x18ftypmp42'), headers=starlette.datastructures.Headers(\n    {'content-type': 'video/mp4'}))\nresult = await backend.server.v2.store.media.upload_media('test-user',\n    test_file)", "successors": [{"id": 30, "label": "#30\nassert result == 'http://test-url/media/laptop.jpeg'", "successors": [{"id": 32, "label": "#32\nmock_bucket = mock_storage_client.bucket.return_value\nmock_blob = mock_bucket.blob.return_value\nmock_blob.upload_from_string.assert_called_once()", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "test_upload_media_file_too_large", "type": "CFG", "blocks": [{"id": 35, "label": "#35\nlarge_data = b'\\xff\\xd8\\xff' + b'x' * (50 * 1024 * 1024 + 1)\ntest_file = fastapi.UploadFile(filename='laptop.jpeg', file=io.BytesIO(\n    large_data), headers=starlette.datastructures.Headers({'content-type':\n    'image/jpeg'}))\nwith pytest.raises(backend.server.v2.store.exceptions.FileSizeTooLargeError):", "successors": [{"id": 36, "label": "#36\nawait backend.server.v2.store.media.upload_media('test-user', test_file)", "successors": []}]}], "functions": [], "classes": []}, {"name": "test_upload_media_file_read_error", "type": "CFG", "blocks": [{"id": 41, "label": "#41\ntest_file = fastapi.UploadFile(filename='laptop.jpeg', file=io.BytesIO(b''),\n    headers=starlette.datastructures.Headers({'content-type': 'image/jpeg'}))\ntest_file.read = unittest.mock.AsyncMock(side_effect=Exception('Read error'))\nwith pytest.raises(backend.server.v2.store.exceptions.FileReadError):", "successors": [{"id": 42, "label": "#42\nawait backend.server.v2.store.media.upload_media('test-user', test_file)", "successors": []}]}], "functions": [], "classes": []}, {"name": "test_upload_media_png_success", "type": "CFG", "blocks": [{"id": 47, "label": "#47\ntest_file = fastapi.UploadFile(filename='test.png', file=io.BytesIO(\n    b'\\x89PNG\\r\\n\\x1a\\n'), headers=starlette.datastructures.Headers({\n    'content-type': 'image/png'}))\nresult = await backend.server.v2.store.media.upload_media('test-user',\n    test_file)", "successors": [{"id": 48, "label": "#48\nassert result == 'http://test-url/media/laptop.jpeg'", "successors": []}]}], "functions": [], "classes": []}, {"name": "test_upload_media_gif_success", "type": "CFG", "blocks": [{"id": 53, "label": "#53\ntest_file = fastapi.UploadFile(filename='test.gif', file=io.BytesIO(\n    b'GIF89a'), headers=starlette.datastructures.Headers({'content-type':\n    'image/gif'}))\nresult = await backend.server.v2.store.media.upload_media('test-user',\n    test_file)", "successors": [{"id": 54, "label": "#54\nassert result == 'http://test-url/media/laptop.jpeg'", "successors": []}]}], "functions": [], "classes": []}, {"name": "test_upload_media_webp_success", "type": "CFG", "blocks": [{"id": 59, "label": "#59\ntest_file = fastapi.UploadFile(filename='test.webp', file=io.BytesIO(\n    b'RIFF\\x00\\x00\\x00\\x00WEBP'), headers=starlette.datastructures.Headers(\n    {'content-type': 'image/webp'}))\nresult = await backend.server.v2.store.media.upload_media('test-user',\n    test_file)", "successors": [{"id": 60, "label": "#60\nassert result == 'http://test-url/media/laptop.jpeg'", "successors": []}]}], "functions": [], "classes": []}, {"name": "test_upload_media_webm_success", "type": "CFG", "blocks": [{"id": 65, "label": "#65\ntest_file = fastapi.UploadFile(filename='test.webm', file=io.BytesIO(\n    b'\\x1aE\\xdf\\xa3'), headers=starlette.datastructures.Headers({\n    'content-type': 'video/webm'}))\nresult = await backend.server.v2.store.media.upload_media('test-user',\n    test_file)", "successors": [{"id": 66, "label": "#66\nassert result == 'http://test-url/media/laptop.jpeg'", "successors": []}]}], "functions": [], "classes": []}, {"name": "test_upload_media_mismatched_signature", "type": "CFG", "blocks": [{"id": 71, "label": "#71\ntest_file = fastapi.UploadFile(filename='test.jpeg', file=io.BytesIO(\n    b'\\x89PNG\\r\\n\\x1a\\n'), headers=starlette.datastructures.Headers({\n    'content-type': 'image/jpeg'}))\nwith pytest.raises(backend.server.v2.store.exceptions.InvalidFileTypeError):", "successors": [{"id": 72, "label": "#72\nawait backend.server.v2.store.media.upload_media('test-user', test_file)", "successors": []}]}], "functions": [], "classes": []}, {"name": "test_upload_media_invalid_signature", "type": "CFG", "blocks": [{"id": 77, "label": "#77\ntest_file = fastapi.UploadFile(filename='test.jpeg', file=io.BytesIO(\n    b'invalid signature'), headers=starlette.datastructures.Headers({\n    'content-type': 'image/jpeg'}))\nwith pytest.raises(backend.server.v2.store.exceptions.InvalidFileTypeError):", "successors": [{"id": 78, "label": "#78\nawait backend.server.v2.store.media.upload_media('test-user', test_file)", "successors": []}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "159.json", "name": "159.json", "type": "CFG", "blocks": [{"id": 1, "label": "#1\n{'name': 'example_script', 'type': 'CFG', 'start_line': 1, 'end_line': 176,\n    'functions': [{'name': 'valid_connection', 'type': 'function',\n    'start_line': 11, 'end_line': 46, 'functions': [], 'classes': [],\n    'simplified_code':\n    \"\"\"def valid_connection(\n    graph: list[list[int]], next_ver: int, curr_ind: int, path: list[int]\n) -> bool:\n    \"\"\\\"\n    Checks whether it is possible to add next into path by validating 2 statements\n    1. There should be path between current and next vertex\n    2. Next vertex should not be in path\n    If both validations succeed we return True, saying that it is possible to connect\n    this vertices, otherwise we return False\n\n    Case 1:Use exact graph as in main function, with initialized values\n    >>> graph = [[0, 1, 0, 1, 0],\n    >>> path = [0, -1, -1, -1, -1, 0]\n    >>> curr_ind = 1\n    >>> next_ver = 1\n    >>> valid_connection(graph, next_ver, curr_ind, path)\n    True\n\n    Case 2: Same graph, but trying to connect to node that is already in path\n    >>> path = [0, 1, 2, 4, -1, 0]\n    >>> curr_ind = 4\n    >>> next_ver = 1\n    >>> valid_connection(graph, next_ver, curr_ind, path)\n    False\n    \"\"\\\"\n\n    # 1. Validate that path exists between current and next vertices\n    if graph[path[curr_ind - 1]][next_ver] == 0:\n        return False\n\n    # 2. Validate that next vertex is not already in path\n    return not any(vertex == next_ver for vertex in path)\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"def valid_connection(\n    graph: list[list[int]], next_ver: int, curr_ind: int, path: list[int]\n) -> bool:\"\"\"\n    , 'successors': [2]}, {'id': 2, 'label':\n    'if graph[path[curr_ind - 1]][next_ver] == 0:', 'successors': [3, 4]},\n    {'id': 3, 'label': 'return False', 'successors': []}, {'id': 4, 'label':\n    'return not any(vertex == next_ver for vertex in path)', 'successors':\n    []}]}, {'name': 'util_hamilton_cycle', 'type': 'function', 'start_line':\n    49, 'end_line': 107, 'functions': [], 'classes': [], 'simplified_code':\n    \"\"\"def util_hamilton_cycle(graph: list[list[int]], path: list[int], curr_ind: int) -> bool:\n    \"\"\\\"\n    Pseudo-Code\n    Base Case:\n    1. Check if we visited all of vertices\n        1.1 If last visited vertex has path to starting vertex return True either\n            return False\n    Recursive Step:\n    2. Iterate over each vertex\n        Check if next vertex is valid for transiting from current vertex\n            2.1 Remember next vertex as next transition\n            2.2 Do recursive call and check if going to this vertex solves problem\n            2.3 If next vertex leads to solution return True\n            2.4 Else backtrack, delete remembered vertex\n\n    Case 1: Use exact graph as in main function, with initialized values\n    >>> graph = [[0, 1, 0, 1, 0],\n    >>> path = [0, -1, -1, -1, -1, 0]\n    >>> curr_ind = 1\n    >>> util_hamilton_cycle(graph, path, curr_ind)\n    True\n    >>> path\n    [0, 1, 2, 4, 3, 0]\n\n    Case 2: Use exact graph as in previous case, but in the properties taken from\n        middle of calculation\n    >>> graph = [[0, 1, 0, 1, 0],\n    >>> path = [0, 1, 2, -1, -1, 0]\n    >>> curr_ind = 3\n    >>> util_hamilton_cycle(graph, path, curr_ind)\n    True\n    >>> path\n    [0, 1, 2, 4, 3, 0]\n    \"\"\\\"\n\n    # Base Case\n    if curr_ind == len(graph):\n        # return whether path exists between current and starting vertices\n        return graph[path[curr_ind - 1]][path[0]] == 1\n\n    # Recursive Step\n    for next_ver in range(len(graph)):\n        if valid_connection(graph, next_ver, curr_ind, path):\n            # Insert current vertex  into path as next transition\n            path[curr_ind] = next_ver\n            # Validate created path\n            if util_hamilton_cycle(graph, path, curr_ind + 1):\n                return True\n            # Backtrack\n            path[curr_ind] = -1\n    return False\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"def util_hamilton_cycle(graph: list[list[int]], path: list[int], curr_ind: int) -> bool:\n    if curr_ind == len(graph):\n        return graph[path[curr_ind - 1]][path[0]] == 1\"\"\"\n    , 'successors': [2, 4]}, {'id': 2, 'label':\n    \"\"\"for next_ver in range(len(graph)):\n        if valid_connection(graph, next_ver, curr_ind, path):\n            path[curr_ind] = next_ver\n            if util_hamilton_cycle(graph, path, curr_ind + 1):\n                return True\n            path[curr_ind] = -1\"\"\"\n    , 'successors': [3, 4]}, {'id': 3, 'label': 'return True', 'successors':\n    []}, {'id': 4, 'label': 'return False', 'successors': []}]}, {'name':\n    'hamilton_cycle', 'type': 'function', 'start_line': 110, 'end_line': \n    176, 'functions': [], 'classes': [], 'simplified_code':\n    \"\"\"def hamilton_cycle(graph: list[list[int]], start_index: int = 0) -> list[int]:\n    r\"\"\\\"\n    Wrapper function to call subroutine called util_hamilton_cycle,\n    which will either return array of vertices indicating hamiltonian cycle\n    or an empty list indicating that hamiltonian cycle was not found.\n    Case 1:\n    Following graph consists of 5 edges.\n    If we look closely, we can see that there are multiple Hamiltonian cycles.\n    For example one result is when we iterate like:\n    (0)->(1)->(2)->(4)->(3)->(0)\n\n    (0)---(1)---(2)\n     |   /   \\\\   |\n     |  /     \\\\  |\n     | /       \\\\ |\n     |/         \\\\|\n    (3)---------(4)\n    >>> graph = [[0, 1, 0, 1, 0],\n    >>> hamilton_cycle(graph)\n    [0, 1, 2, 4, 3, 0]\n\n    Case 2:\n    Same Graph as it was in Case 1, changed starting index from default to 3\n\n    (0)---(1)---(2)\n     |   /   \\\\   |\n     |  /     \\\\  |\n     | /       \\\\ |\n     |/         \\\\|\n    (3)---------(4)\n    >>> graph = [[0, 1, 0, 1, 0],\n    >>> hamilton_cycle(graph, 3)\n    [3, 0, 1, 2, 4, 3]\n\n    Case 3:\n    Following Graph is exactly what it was before, but edge 3-4 is removed.\n    Result is that there is no Hamiltonian Cycle anymore.\n\n    (0)---(1)---(2)\n     |   /   \\\\   |\n     |  /     \\\\  |\n     | /       \\\\ |\n     |/         \\\\|\n    (3)         (4)\n    >>> graph = [[0, 1, 0, 1, 0],\n    >>> hamilton_cycle(graph,4)\n    []\n    \"\"\\\"\n\n    # Initialize path with -1, indicating that we have not visited them yet\n    path = [-1] * (len(graph) + 1)\n    # initialize start and end of path with starting index\n    path[0] = path[-1] = start_index\n    # evaluate and if we find answer return path either return empty array\n    return path if util_hamilton_cycle(graph, path, 1) else []\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    'def hamilton_cycle(graph: list[list[int]], start_index: int = 0) -> list[int]:'\n    , 'successors': [2]}, {'id': 2, 'label':\n    \"\"\"path = [-1] * (len(graph) + 1)\npath[0] = path[-1] = start_index\"\"\",\n    'successors': [3]}, {'id': 3, 'label':\n    'return path if util_hamilton_cycle(graph, path, 1) else []',\n    'successors': []}]}], 'classes': [], 'simplified_code':\n    \"\"\"\"\"\\\"\nA Hamiltonian cycle (Hamiltonian circuit) is a graph cycle\nthrough a graph that visits each node exactly once.\nDetermining whether such paths and cycles exist in graphs\nis the 'Hamiltonian path problem', which is NP-complete.\n\nWikipedia: https://en.wikipedia.org/wiki/Hamiltonian_path\n\"\"\\\"\n\n\n    return not any(vertex == next_ver for vertex in path)\n\n\n    return False\n\n\n    return path if util_hamilton_cycle(graph, path, 1) else []\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    'return not any(vertex == next_ver for vertex in path)', 'successors':\n    []}, {'id': 2, 'label': 'return False', 'successors': []}, {'id': 3,\n    'label': 'return path if util_hamilton_cycle(graph, path, 1) else []',\n    'successors': []}]}", "successors": []}], "functions": [], "classes": []}
{"file_name": "160.json", "name": "160.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport datetime\nimport typing\nfrom enum import Enum\nfrom typing import Generic, Literal, TypeVar, Union\nimport prisma.enums\nimport pydantic\nAnalyticsEvent = Union[AgentInstalledFromMarketplaceEvent,\n    AgentInstalledFromTemplateEvent]\nT = TypeVar('T')", "successors": []}], "functions": [], "classes": [{"name": "InstallationLocation", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nLOCAL = 'local'\nCLOUD = 'cloud'", "successors": []}], "functions": [], "classes": []}, {"name": "AgentInstalledFromMarketplaceEventData", "type": "CFG", "blocks": [{"id": 6, "label": "#6\nmarketplace_agent_id: str\ninstalled_agent_id: str\ninstallation_location: InstallationLocation", "successors": []}], "functions": [], "classes": []}, {"name": "AgentInstalledFromTemplateEventData", "type": "CFG", "blocks": [{"id": 9, "label": "#9\ntemplate_id: str\ninstalled_agent_id: str\ninstallation_location: InstallationLocation", "successors": []}], "functions": [], "classes": []}, {"name": "AgentInstalledFromMarketplaceEvent", "type": "CFG", "blocks": [{"id": 12, "label": "#12\nevent_name: Literal['agent_installed_from_marketplace']\nevent_data: AgentInstalledFromMarketplaceEventData", "successors": []}], "functions": [], "classes": []}, {"name": "AgentInstalledFromTemplateEvent", "type": "CFG", "blocks": [{"id": 15, "label": "#15\nevent_name: Literal['agent_installed_from_template']\nevent_data: AgentInstalledFromTemplateEventData", "successors": []}], "functions": [], "classes": []}, {"name": "AnalyticsRequest", "type": "CFG", "blocks": [{"id": 18, "label": "#18\nevent: AnalyticsEvent", "successors": []}], "functions": [], "classes": []}, {"name": "AddAgentRequest", "type": "CFG", "blocks": [{"id": 21, "label": "#21\ngraph: dict[str, typing.Any]\nauthor: str\nkeywords: list[str]\ncategories: list[str]", "successors": []}], "functions": [], "classes": []}, {"name": "SubmissionReviewRequest", "type": "CFG", "blocks": [{"id": 24, "label": "#24\nagent_id: str\nversion: int\nstatus: prisma.enums.SubmissionStatus\ncomments: str | None", "successors": []}], "functions": [], "classes": []}, {"name": "AgentResponse", "type": "CFG", "blocks": [{"id": 27, "label": "#27\n\"\"\"\n    Represents a response from an agent.\n\n    Attributes:\n        id (str): The ID of the agent.\n        name (str, optional): The name of the agent.\n        description (str, optional): The description of the agent.\n        author (str, optional): The author of the agent.\n        keywords (list[str]): The keywords associated with the agent.\n        categories (list[str]): The categories the agent belongs to.\n        version (int): The version of the agent.\n        createdAt (str): The creation date of the agent.\n        updatedAt (str): The last update date of the agent.\n    \"\"\"\nid: str\nname: typing.Optional[str]\ndescription: typing.Optional[str]\nauthor: typing.Optional[str]\nkeywords: list[str]\ncategories: list[str]\nversion: int\ncreatedAt: datetime.datetime\nupdatedAt: datetime.datetime\nsubmissionStatus: str\nviews: int = 0\ndownloads: int = 0", "successors": []}], "functions": [], "classes": []}, {"name": "AgentDetailResponse", "type": "CFG", "blocks": [{"id": 30, "label": "#30\n\"\"\"\n    Represents the response data for an agent detail.\n\n    Attributes:\n        id (str): The ID of the agent.\n        name (Optional[str]): The name of the agent.\n        description (Optional[str]): The description of the agent.\n        author (Optional[str]): The author of the agent.\n        keywords (List[str]): The keywords associated with the agent.\n        categories (List[str]): The categories the agent belongs to.\n        version (int): The version of the agent.\n        createdAt (str): The creation date of the agent.\n        updatedAt (str): The last update date of the agent.\n        graph (Dict[str, Any]): The graph data of the agent.\n    \"\"\"\nid: str\nname: typing.Optional[str]\ndescription: typing.Optional[str]\nauthor: typing.Optional[str]\nkeywords: list[str]\ncategories: list[str]\nversion: int\ncreatedAt: datetime.datetime\nupdatedAt: datetime.datetime\ngraph: dict[str, typing.Any]", "successors": []}], "functions": [], "classes": []}, {"name": "FeaturedAgentResponse", "type": "CFG", "blocks": [{"id": 33, "label": "#33\n\"\"\"\n    Represents the response data for an agent detail.\n    \"\"\"\nagentId: str\nfeaturedCategories: list[str]\ncreatedAt: datetime.datetime\nupdatedAt: datetime.datetime\nisActive: bool", "successors": []}], "functions": [], "classes": []}, {"name": "CategoriesResponse", "type": "CFG", "blocks": [{"id": 36, "label": "#36\n\"\"\"\n    Represents the response data for a list of categories.\n\n    Attributes:\n        unique_categories (list[str]): The list of unique categories.\n    \"\"\"\nunique_categories: list[str]", "successors": []}], "functions": [], "classes": []}, {"name": "ListResponse", "type": "CFG", "blocks": [{"id": 39, "label": "#39\n\"\"\"\n    Represents a list response.\n\n    Attributes:\n        items (list[T]): The list of items.\n        total_count (int): The total count of items.\n        page (int): The current page number.\n        page_size (int): The number of items per page.\n        total_pages (int): The total number of pages.\n    \"\"\"\nitems: list[T]\ntotal_count: int\npage: int\npage_size: int\ntotal_pages: int", "successors": []}], "functions": [], "classes": []}]}
{"file_name": "161.json", "name": "161.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport random\nfrom collections import defaultdict\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Union\nfrom backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema\nfrom backend.data.model import SchemaField", "successors": []}], "functions": [], "classes": [{"name": "SamplingMethod", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nRANDOM = 'random'\nSYSTEMATIC = 'systematic'\nTOP = 'top'\nBOTTOM = 'bottom'\nSTRATIFIED = 'stratified'\nWEIGHTED = 'weighted'\nRESERVOIR = 'reservoir'\nCLUSTER = 'cluster'", "successors": []}], "functions": [], "classes": []}, {"name": "DataSamplingBlock", "type": "CFG", "blocks": [{"id": 6, "label": "#6", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 14, "label": "#14\nsuper().__init__(id='4a448883-71fa-49cf-91cf-70d793bd7d87', description=\n    'This block samples data from a given dataset using various sampling methods.'\n    , categories={BlockCategory.LOGIC}, input_schema=DataSamplingBlock.\n    Input, output_schema=DataSamplingBlock.Output, test_input={'data': [{\n    'id': i, 'value': chr(97 + i), 'group': i % 3} for i in range(10)],\n    'sample_size': 3, 'sampling_method': SamplingMethod.STRATIFIED,\n    'accumulate': False, 'random_seed': 42, 'stratify_key': 'group'},\n    test_output=[('sampled_data', [{'id': 0, 'value': 'a', 'group': 0}, {\n    'id': 1, 'value': 'b', 'group': 1}, {'id': 8, 'value': 'i', 'group': 2}\n    ]), ('sample_indices', [0, 1, 8])])\nself.accumulated_data = []", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 17, "label": "#17\nif input_data.accumulate:", "successors": [{"id": 18, "label": "#18\nif isinstance(input_data.data, dict):", "successors": [{"id": 21, "label": "#21\nself.accumulated_data.append(input_data.data)", "successors": [{"id": 22, "label": "#22\nif len(self.accumulated_data) < input_data.sample_size:", "successors": [{"id": 28, "label": "#28\nreturn", "successors": []}, {"id": 29, "label": "#29\ndata_to_sample = self.accumulated_data", "successors": [{"id": 19, "label": "#19\nif input_data.random_seed is not None:", "successors": [{"id": 31, "label": "#31\nrandom.seed(input_data.random_seed)", "successors": [{"id": 32, "label": "#32\ndata_size = len(data_to_sample)\nif input_data.sample_size > data_size:", "successors": [{"id": 33, "label": "#33\nraise ValueError(\n    f'Sample size ({input_data.sample_size}) cannot be larger than the dataset size ({data_size}).'\n    )", "successors": []}, {"id": 34, "label": "#34\nindices = []\nif input_data.sampling_method == SamplingMethod.RANDOM:", "successors": [{"id": 36, "label": "#36\nindices = random.sample(range(data_size), input_data.sample_size)", "successors": [{"id": 37, "label": "#37\nsampled_data = [data_to_sample[i] for i in indices]\nif input_data.accumulate:", "successors": [{"id": 135, "label": "#135\nself.accumulated_data = []", "successors": [{"id": 136, "label": "#136\nyield 'sampled_data', sampled_data", "successors": [{"id": 137, "label": "#137\nyield 'sample_indices', indices", "successors": []}]}]}]}]}, {"id": 38, "label": "#38\nif input_data.sampling_method == SamplingMethod.SYSTEMATIC:", "successors": [{"id": 39, "label": "#39\nstep = data_size // input_data.sample_size\nstart = random.randint(0, step - 1)\nindices = list(range(start, data_size, step))[:input_data.sample_size]", "successors": []}, {"id": 41, "label": "#41\nif input_data.sampling_method == SamplingMethod.TOP:", "successors": [{"id": 42, "label": "#42\nindices = list(range(input_data.sample_size))", "successors": []}, {"id": 44, "label": "#44\nif input_data.sampling_method == SamplingMethod.BOTTOM:", "successors": [{"id": 45, "label": "#45\nindices = list(range(data_size - input_data.sample_size, data_size))", "successors": []}, {"id": 47, "label": "#47\nif input_data.sampling_method == SamplingMethod.STRATIFIED:", "successors": [{"id": 48, "label": "#48\nif not input_data.stratify_key:", "successors": [{"id": 111, "label": "#111\nraise ValueError('Stratify key must be provided for stratified sampling.')", "successors": []}, {"id": 112, "label": "#112\nstrata = defaultdict(list)", "successors": [{"id": 114, "label": "#114\nfor i, item in enumerate(data_to_sample):", "successors": [{"id": 115, "label": "#115\nif isinstance(item, dict):", "successors": [{"id": 117, "label": "#117\nstrata_value = item.get(input_data.stratify_key)", "successors": [{"id": 118, "label": "#118\nif strata_value is None:", "successors": [{"id": 124, "label": "#124\nraise ValueError(f\"Stratify value for key '{input_data.stratify_key}' is None\")", "successors": []}, {"id": 125, "label": "#125\nstrata[str(strata_value)].append(i)", "successors": []}]}]}, {"id": 119, "label": "#119\nif hasattr(item, input_data.stratify_key):", "successors": [{"id": 120, "label": "#120\nstrata_value = getattr(item, input_data.stratify_key)", "successors": []}, {"id": 122, "label": "#122\nraise ValueError(\n    f\"Stratify key '{input_data.stratify_key}' not found in item {item}\")", "successors": []}]}]}, {"id": 116, "label": "#116\nstratum_sizes = {k: max(1, int(len(v) / data_size * input_data.sample_size)\n    ) for k, v in strata.items()}", "successors": [{"id": 127, "label": "#127\nwhile sum(stratum_sizes.values()) != input_data.sample_size:", "successors": [{"id": 128, "label": "#128\nif sum(stratum_sizes.values()) < input_data.sample_size:", "successors": [{"id": 130, "label": "#130\nstratum_sizes[max(stratum_sizes, key=lambda k: stratum_sizes[k])] += 1", "successors": []}, {"id": 132, "label": "#132\nstratum_sizes[max(stratum_sizes, key=lambda k: stratum_sizes[k])] -= 1", "successors": []}]}, {"id": 129, "label": "#129\nfor stratum, size in stratum_sizes.items():", "successors": [{"id": 133, "label": "#133\nindices.extend(random.sample(strata[stratum], size))", "successors": []}]}]}]}]}]}]}, {"id": 50, "label": "#50\nif input_data.sampling_method == SamplingMethod.WEIGHTED:", "successors": [{"id": 51, "label": "#51\nif not input_data.weight_key:", "successors": [{"id": 88, "label": "#88\nraise ValueError('Weight key must be provided for weighted sampling.')", "successors": []}, {"id": 89, "label": "#89\nweights = []", "successors": [{"id": 91, "label": "#91\nfor item in data_to_sample:", "successors": [{"id": 92, "label": "#92\nif isinstance(item, dict):", "successors": [{"id": 94, "label": "#94\nweight = item.get(input_data.weight_key)", "successors": [{"id": 95, "label": "#95\nif weight is None:", "successors": [{"id": 101, "label": "#101\nraise ValueError(f\"Weight value for key '{input_data.weight_key}' is None\")", "successors": []}, {"id": 102, "label": "#102\ntry:", "successors": [{"id": 104, "label": "#104\nweights.append(float(weight))", "successors": []}, {"id": 105, "label": "#105\nraise ValueError(f\"Weight value '{weight}' cannot be converted to a number\")", "successors": []}]}]}]}, {"id": 96, "label": "#96\nif hasattr(item, input_data.weight_key):", "successors": [{"id": 97, "label": "#97\nweight = getattr(item, input_data.weight_key)", "successors": []}, {"id": 99, "label": "#99\nraise ValueError(\n    f\"Weight key '{input_data.weight_key}' not found in item {item}\")", "successors": []}]}]}, {"id": 93, "label": "#93\nif not weights:", "successors": [{"id": 108, "label": "#108\nraise ValueError(f\"No valid weights found using key '{input_data.weight_key}'\")", "successors": []}, {"id": 109, "label": "#109\nindices = random.choices(range(data_size), weights=weights, k=input_data.\n    sample_size)", "successors": []}]}]}]}]}, {"id": 53, "label": "#53\nif input_data.sampling_method == SamplingMethod.RESERVOIR:", "successors": [{"id": 54, "label": "#54\nindices = list(range(input_data.sample_size))", "successors": [{"id": 83, "label": "#83\nfor i in range(input_data.sample_size, data_size):", "successors": [{"id": 84, "label": "#84\nj = random.randint(0, i)\nif j < input_data.sample_size:", "successors": [{"id": 86, "label": "#86\nindices[j] = i", "successors": []}]}]}]}, {"id": 56, "label": "#56\nif input_data.sampling_method == SamplingMethod.CLUSTER:", "successors": [{"id": 57, "label": "#57\nif not input_data.cluster_key:", "successors": [{"id": 61, "label": "#61\nraise ValueError('Cluster key must be provided for cluster sampling.')", "successors": []}, {"id": 62, "label": "#62\nclusters = defaultdict(list)", "successors": [{"id": 64, "label": "#64\nfor i, item in enumerate(data_to_sample):", "successors": [{"id": 65, "label": "#65\nif isinstance(item, dict):", "successors": [{"id": 67, "label": "#67\ncluster_value = item.get(input_data.cluster_key)", "successors": [{"id": 68, "label": "#68\nclusters[str(cluster_value)].append(i)", "successors": []}]}, {"id": 69, "label": "#69\nif hasattr(item, input_data.cluster_key):", "successors": [{"id": 70, "label": "#70\ncluster_value = getattr(item, input_data.cluster_key)", "successors": []}, {"id": 72, "label": "#72\nraise TypeError(\n    f\"Item {item} does not have the cluster key '{input_data.cluster_key}'\")", "successors": []}]}]}, {"id": 66, "label": "#66\nselected_clusters = []", "successors": [{"id": 74, "label": "#74\nwhile sum(len(clusters[c]) for c in selected_clusters", "successors": [{"id": 75, "label": "#75\navailable_clusters = [c for c in clusters if c not in selected_clusters]\nif not available_clusters:", "successors": [{"id": 78, "label": "#78\nselected_clusters.append(random.choice(available_clusters))", "successors": []}, {"id": 76, "label": "#76\nfor cluster in selected_clusters:", "successors": [{"id": 79, "label": "#79\nindices.extend(clusters[cluster])", "successors": []}, {"id": 80, "label": "#80\nif len(indices) > input_data.sample_size:", "successors": [{"id": 81, "label": "#81\nindices = random.sample(indices, input_data.sample_size)", "successors": []}]}]}]}]}]}]}]}]}, {"id": 59, "label": "#59\nraise ValueError(f'Unknown sampling method: {input_data.sampling_method}')", "successors": []}]}]}]}]}]}]}]}]}]}]}]}]}]}]}, {"id": 23, "label": "#23\nif isinstance(input_data.data, list):", "successors": [{"id": 24, "label": "#24\nself.accumulated_data.extend(input_data.data)", "successors": []}, {"id": 26, "label": "#26\nraise ValueError(f'Unsupported data type: {type(input_data.data)}')", "successors": []}]}]}, {"id": 20, "label": "#20\ndata_to_sample = input_data.data if isinstance(input_data.data, list) else [\n    input_data.data]", "successors": []}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 8, "label": "#8\ndata: Union[Dict[str, Any], List[Union[dict, List[Any]]]] = SchemaField(\n    description=\n    'The dataset to sample from. Can be a single dictionary, a list of dictionaries, or a list of lists.'\n    , placeholder=\n    )\nsample_size: int = SchemaField(description=\n    'The number of samples to take from the dataset.', placeholder='10',\n    default=10)\nsampling_method: SamplingMethod = SchemaField(description=\n    'The method to use for sampling.', default=SamplingMethod.RANDOM)\naccumulate: bool = SchemaField(description=\n    'Whether to accumulate data before sampling.', default=False)\nrandom_seed: Optional[int] = SchemaField(description=\n    'Seed for random number generator (optional).', default=None)\nstratify_key: Optional[str] = SchemaField(description=\n    'Key to use for stratified sampling (required for stratified sampling).',\n    default=None)\nweight_key: Optional[str] = SchemaField(description=\n    'Key to use for weighted sampling (required for weighted sampling).',\n    default=None)\ncluster_key: Optional[str] = SchemaField(description=\n    'Key to use for cluster sampling (required for cluster sampling).',\n    default=None)", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 11, "label": "#11\nsampled_data: List[Union[dict, List[Any]]] = SchemaField(description=\n    'The sampled subset of the input data.')\nsample_indices: List[int] = SchemaField(description=\n    'The indices of the sampled data in the original dataset.')", "successors": []}], "functions": [], "classes": []}]}]}
{"file_name": "162.json", "name": "162.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom abc import ABCMeta, abstractmethod\nfrom collections import deque\nfrom enum import Enum", "successors": []}], "functions": [], "classes": [{"name": "Rank", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nOPERATOR = 0\nSUPERVISOR = 1\nDIRECTOR = 2", "successors": []}], "functions": [], "classes": []}, {"name": "Employee", "type": "CFG", "blocks": [{"id": 6, "label": "#6", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 8, "label": "#8\nself.employee_id = employee_id\nself.name = name\nself.rank = rank\nself.call = None\nself.call_center = call_center", "successors": []}], "functions": [], "classes": []}, {"name": "take_call", "type": "CFG", "blocks": [{"id": 11, "label": "#11\n\"\"\"Assume the employee will always successfully take the call.\"\"\"\nself.call = call\nself.call.employee = self\nself.call.state = CallState.IN_PROGRESS", "successors": []}], "functions": [], "classes": []}, {"name": "complete_call", "type": "CFG", "blocks": [{"id": 14, "label": "#14\nself.call.state = CallState.COMPLETE\nself.call_center.notify_call_completed(self.call)", "successors": []}], "functions": [], "classes": []}, {"name": "escalate_call", "type": "CFG", "blocks": [{"id": 17, "label": "#17\npass", "successors": []}], "functions": [], "classes": []}, {"name": "_escalate_call", "type": "CFG", "blocks": [{"id": 20, "label": "#20\nself.call.state = CallState.READY\ncall = self.call\nself.call = None\nself.call_center.notify_call_escalated(call)", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "Operator", "type": "CFG", "blocks": [{"id": 24, "label": "#24", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 26, "label": "#26\nsuper(Operator, self).__init__(employee_id, name, Rank.OPERATOR)", "successors": []}], "functions": [], "classes": []}, {"name": "escalate_call", "type": "CFG", "blocks": [{"id": 29, "label": "#29\nself.call.level = Rank.SUPERVISOR\nself._escalate_call()", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "Supervisor", "type": "CFG", "blocks": [{"id": 33, "label": "#33", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 35, "label": "#35\nsuper(Operator, self).__init__(employee_id, name, Rank.SUPERVISOR)", "successors": []}], "functions": [], "classes": []}, {"name": "escalate_call", "type": "CFG", "blocks": [{"id": 38, "label": "#38\nself.call.level = Rank.DIRECTOR\nself._escalate_call()", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "Director", "type": "CFG", "blocks": [{"id": 42, "label": "#42", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 44, "label": "#44\nsuper(Operator, self).__init__(employee_id, name, Rank.DIRECTOR)", "successors": []}], "functions": [], "classes": []}, {"name": "escalate_call", "type": "CFG", "blocks": [{"id": 47, "label": "#47\nraise NotImplementedError('Directors must be able to handle any call')", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "CallState", "type": "CFG", "blocks": [{"id": 52, "label": "#52\nREADY = 0\nIN_PROGRESS = 1\nCOMPLETE = 2", "successors": []}], "functions": [], "classes": []}, {"name": "Call", "type": "CFG", "blocks": [{"id": 55, "label": "#55", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 57, "label": "#57\nself.state = CallState.READY\nself.rank = rank\nself.employee = None", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "CallCenter", "type": "CFG", "blocks": [{"id": 61, "label": "#61", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 63, "label": "#63\nself.operators = operators\nself.supervisors = supervisors\nself.directors = directors\nself.queued_calls = deque()", "successors": []}], "functions": [], "classes": []}, {"name": "dispatch_call", "type": "CFG", "blocks": [{"id": 66, "label": "#66\nif call.rank not in (Rank.OPERATOR, Rank.SUPERVISOR, Rank.DIRECTOR):", "successors": [{"id": 67, "label": "#67\nraise ValueError('Invalid call rank: {}'.format(call.rank))", "successors": []}, {"id": 68, "label": "#68\nemployee = None\nif call.rank == Rank.OPERATOR:", "successors": [{"id": 70, "label": "#70\nemployee = self._dispatch_call(call, self.operators)", "successors": [{"id": 71, "label": "#71\nif call.rank == Rank.SUPERVISOR or employee is None:", "successors": [{"id": 72, "label": "#72\nemployee = self._dispatch_call(call, self.supervisors)", "successors": [{"id": 73, "label": "#73\nif call.rank == Rank.DIRECTOR or employee is None:", "successors": [{"id": 74, "label": "#74\nemployee = self._dispatch_call(call, self.directors)", "successors": [{"id": 75, "label": "#75\nif employee is None:", "successors": [{"id": 76, "label": "#76\nself.queued_calls.append(call)", "successors": []}]}]}]}]}]}]}]}]}], "functions": [], "classes": []}, {"name": "_dispatch_call", "type": "CFG", "blocks": [{"id": 80, "label": "#80\nfor employee in employees:", "successors": [{"id": 81, "label": "#81\nif employee.call is None:", "successors": [{"id": 83, "label": "#83\nemployee.take_call(call)\nreturn employee", "successors": []}]}, {"id": 82, "label": "#82\nreturn None", "successors": []}]}], "functions": [], "classes": []}, {"name": "notify_call_escalated", "type": "CFG", "blocks": [{"id": 89, "label": "#89\npass", "successors": []}], "functions": [], "classes": []}, {"name": "notify_call_completed", "type": "CFG", "blocks": [{"id": 92, "label": "#92\npass", "successors": []}], "functions": [], "classes": []}, {"name": "dispatch_queued_call_to_newly_freed_employee", "type": "CFG", "blocks": [{"id": 95, "label": "#95\npass", "successors": []}], "functions": [], "classes": []}], "classes": []}]}
{"file_name": "163.json", "name": "163.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1", "successors": []}], "functions": [], "classes": [{"name": "PagesDataStore", "type": "CFG", "blocks": [{"id": 3, "label": "#3", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 5, "label": "#5\nself.db = db\npass", "successors": []}], "functions": [], "classes": []}, {"name": "add_link_to_crawl", "type": "CFG", "blocks": [{"id": 8, "label": "#8\n\"\"\"Add the given link to `links_to_crawl`.\"\"\"\npass", "successors": []}], "functions": [], "classes": []}, {"name": "remove_link_to_crawl", "type": "CFG", "blocks": [{"id": 11, "label": "#11\n\"\"\"Remove the given link from `links_to_crawl`.\"\"\"\npass", "successors": []}], "functions": [], "classes": []}, {"name": "reduce_priority_link_to_crawl", "type": "CFG", "blocks": [{"id": 14, "label": "#14\n\"\"\"Reduce the priority of a link in `links_to_crawl` to avoid cycles.\"\"\"\npass", "successors": []}], "functions": [], "classes": []}, {"name": "extract_max_priority_page", "type": "CFG", "blocks": [{"id": 17, "label": "#17\n\"\"\"Return the highest priority link in `links_to_crawl`.\"\"\"\npass", "successors": []}], "functions": [], "classes": []}, {"name": "insert_crawled_link", "type": "CFG", "blocks": [{"id": 20, "label": "#20\n\"\"\"Add the given link to `crawled_links`.\"\"\"\npass", "successors": []}], "functions": [], "classes": []}, {"name": "crawled_similar", "type": "CFG", "blocks": [{"id": 23, "label": "#23\n\"\"\"Determine if we've already crawled a page matching the given signature\"\"\"\npass", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "Page", "type": "CFG", "blocks": [{"id": 27, "label": "#27", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 29, "label": "#29\nself.url = url\nself.contents = contents\nself.child_urls = child_urls\nself.signature = self.create_signature()", "successors": []}], "functions": [], "classes": []}, {"name": "create_signature", "type": "CFG", "blocks": [{"id": 32, "label": "#32\npass", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "Crawler", "type": "CFG", "blocks": [{"id": 36, "label": "#36", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 38, "label": "#38\nself.pages = pages\nself.data_store = data_store\nself.reverse_index_queue = reverse_index_queue\nself.doc_index_queue = doc_index_queue", "successors": []}], "functions": [], "classes": []}, {"name": "crawl_page", "type": "CFG", "blocks": [{"id": 41, "label": "#41\nfor url in page.child_urls:", "successors": [{"id": 42, "label": "#42\nself.data_store.add_link_to_crawl(url)", "successors": []}, {"id": 43, "label": "#43\nself.reverse_index_queue.generate(page)\nself.doc_index_queue.generate(page)\nself.data_store.remove_link_to_crawl(page.url)\nself.data_store.insert_crawled_link(page.url, page.signature)", "successors": []}]}], "functions": [], "classes": []}, {"name": "crawl", "type": "CFG", "blocks": [{"id": 46, "label": "#46\nwhile True:", "successors": [{"id": 47, "label": "#47\npage = self.data_store.extract_max_priority_page()\nif page is None:", "successors": [{"id": 50, "label": "#50\nif self.data_store.crawled_similar(page.signature):", "successors": [{"id": 51, "label": "#51\nself.data_store.reduce_priority_link_to_crawl(page.url)", "successors": [{"id": 52, "label": "#52\npage = self.data_store.extract_max_priority_page()", "successors": []}]}, {"id": 53, "label": "#53\nself.crawl_page(page)", "successors": []}]}]}]}], "functions": [], "classes": []}], "classes": []}]}
{"file_name": "164.json", "name": "164.json", "type": "CFG", "blocks": [{"id": 1, "label": "#1\n{'name': 'example_script', 'type': 'CFG', 'start_line': 1, 'end_line': 34,\n    'functions': [{'name': 'get_highest_set_bit_position', 'type':\n    'function', 'start_line': 1, 'end_line': 28, 'functions': [], 'classes':\n    [], 'simplified_code':\n    \"\"\"def get_highest_set_bit_position(number: int) -> int:\n    \"\"\\\"\n    Returns position of the highest set bit of a number.\n    Ref - https://graphics.stanford.edu/~seander/bithacks.html#IntegerLogObvious\n    >>> get_highest_set_bit_position(25)\n    5\n    >>> get_highest_set_bit_position(37)\n    6\n    >>> get_highest_set_bit_position(1)\n    1\n    >>> get_highest_set_bit_position(4)\n    3\n    >>> get_highest_set_bit_position(0)\n    0\n    >>> get_highest_set_bit_position(0.8)\n    Traceback (most recent call last):\n    TypeError: Input value must be an 'int' type\n    \"\"\\\"\n    if not isinstance(number, int):\n        raise TypeError(\"Input value must be an 'int' type\")\n\n    position = 0\n    while number:\n        position += 1\n        number >>= 1\n\n    return position\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"def get_highest_set_bit_position(number: int) -> int:\n    \"\"\\\"\n    Returns position of the highest set bit of a number.\n    Ref - https://graphics.stanford.edu/~seander/bithacks.html#IntegerLogObvious\n    >>> get_highest_set_bit_position(25)\n    5\n    >>> get_highest_set_bit_position(37)\n    6\n    >>> get_highest_set_bit_position(1)\n    1\n    >>> get_highest_set_bit_position(4)\n    3\n    >>> get_highest_set_bit_position(0)\n    0\n    >>> get_highest_set_bit_position(0.8)\n    Traceback (most recent call last):\n    TypeError: Input value must be an 'int' type\n    \"\"\\\"\"\"\"\n    , 'successors': [2]}, {'id': 2, 'label':\n    \"\"\"if not isinstance(number, int):\n        raise TypeError(\"Input value must be an 'int' type\")\"\"\"\n    , 'successors': [3]}, {'id': 3, 'label': 'position = 0', 'successors':\n    [4]}, {'id': 4, 'label':\n    \"\"\"while number:\n        position += 1\n        number >>= 1\"\"\",\n    'successors': [5, 6]}, {'id': 5, 'label':\n    \"\"\"position += 1\n        number >>= 1\"\"\", 'successors': [4]}, {'id': 6,\n    'label': 'return position', 'successors': []}]}], 'classes': [],\n    'simplified_code':\n    \"\"\"    return position\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\"\"\"\n    , 'blocks': [{'id': 1, 'label': 'return position', 'successors': []}, {\n    'id': 2, 'label': 'if __name__ == \"__main__\":', 'successors': [3]}, {\n    'id': 3, 'label': \"\"\"import doctest\n\ndoctest.testmod()\"\"\", 'successors':\n    []}]}", "successors": []}], "functions": [], "classes": []}
{"file_name": "165.json", "name": "165.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport pytest\nfrom ldclient import LDClient\nfrom autogpt_libs.feature_flag.client import feature_flag, mock_flag_variation", "successors": []}], "functions": [{"name": "ld_client", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nclient = mocker.Mock(spec=LDClient)\nmocker.patch('ldclient.get', return_value=client)\nclient.is_initialized.return_value = True\nreturn client", "successors": []}], "functions": [], "classes": []}, {"name": "test_feature_flag_enabled", "type": "CFG", "blocks": [{"id": 7, "label": "#7\nld_client.variation.return_value = True\nresult = test_function(user_id='test-user')\nassert result == 'success'", "successors": [{"id": 13, "label": "#13\nld_client.variation.assert_called_once()", "successors": []}]}], "functions": [{"name": "test_function", "type": "CFG", "blocks": [{"id": 9, "label": "#9\nreturn 'success'", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "test_feature_flag_unauthorized_response", "type": "CFG", "blocks": [{"id": 16, "label": "#16\nld_client.variation.return_value = False\nresult = test_function(user_id='test-user')\nassert result == {'error': 'disabled'}", "successors": []}], "functions": [{"name": "test_function", "type": "CFG", "blocks": [{"id": 18, "label": "#18\nreturn 'success'", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "test_mock_flag_variation", "type": "CFG", "blocks": [{"id": 25, "label": "#25\nwith mock_flag_variation('test-flag', True):", "successors": [{"id": 26, "label": "#26\nassert ld_client.variation('test-flag', None, False)", "successors": [{"id": 27, "label": "#27\nwith mock_flag_variation('test-flag', False):", "successors": [{"id": 30, "label": "#30\nassert ld_client.variation('test-flag', None, False)", "successors": []}]}]}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "166.json", "name": "166.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport base64\nfrom email.utils import parseaddr\nfrom typing import List\nfrom google.oauth2.credentials import Credentials\nfrom googleapiclient.discovery import build\nfrom pydantic import BaseModel\nfrom backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema\nfrom backend.data.model import SchemaField\nfrom ._auth import GOOGLE_OAUTH_IS_CONFIGURED, TEST_CREDENTIALS, TEST_CREDENTIALS_INPUT, GoogleCredentials, GoogleCredentialsField, GoogleCredentialsInput", "successors": []}], "functions": [], "classes": [{"name": "Attachment", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nfilename: str\ncontent_type: str\nsize: int\nattachment_id: str", "successors": []}], "functions": [], "classes": []}, {"name": "Email", "type": "CFG", "blocks": [{"id": 6, "label": "#6\nid: str\nsubject: str\nsnippet: str\nfrom_: str\nto: str\ndate: str\nbody: str = ''\nsizeEstimate: int\nattachments: List[Attachment]", "successors": []}], "functions": [], "classes": []}, {"name": "GmailReadBlock", "type": "CFG", "blocks": [{"id": 9, "label": "#9", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 17, "label": "#17\nsuper().__init__(id='25310c70-b89b-43ba-b25c-4dfa7e2a481c', description=\n    'This block reads emails from Gmail.', categories={BlockCategory.\n    COMMUNICATION}, disabled=not GOOGLE_OAUTH_IS_CONFIGURED, input_schema=\n    GmailReadBlock.Input, output_schema=GmailReadBlock.Output, test_input={\n    'query': 'is:unread', 'max_results': 5, 'credentials':\n    TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output\n    =[('email', {'id': '1', 'subject': 'Test Email', 'snippet':\n    'This is a test email', 'from_': 'test@example.com', 'to':\n    'recipient@example.com', 'date': '2024-01-01', 'body':\n    'This is a test email', 'sizeEstimate': 100, 'attachments': []}), (\n    'emails', [{'id': '1', 'subject': 'Test Email', 'snippet':\n    'This is a test email', 'from_': 'test@example.com', 'to':\n    'recipient@example.com', 'date': '2024-01-01', 'body':\n    'This is a test email', 'sizeEstimate': 100, 'attachments': []}])],\n    test_mock={'_read_emails': lambda *args, **kwargs: [{'id': '1',\n    'subject': 'Test Email', 'snippet': 'This is a test email', 'from_':\n    'test@example.com', 'to': 'recipient@example.com', 'date': '2024-01-01',\n    'body': 'This is a test email', 'sizeEstimate': 100, 'attachments': []}\n    ], '_send_email': lambda *args, **kwargs: {'id': '1', 'status': 'sent'}})", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 20, "label": "#20\nservice = self._build_service(credentials, **kwargs)\nmessages = self._read_emails(service, input_data.query, input_data.max_results)", "successors": [{"id": 21, "label": "#21\nfor email in messages:", "successors": [{"id": 22, "label": "#22\nyield 'email', email", "successors": []}, {"id": 23, "label": "#23\nyield 'emails', messages", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "_build_service", "type": "CFG", "blocks": [{"id": 28, "label": "#28\ncreds = Credentials(token=credentials.access_token.get_secret_value() if\n    credentials.access_token else None, refresh_token=credentials.\n    refresh_token.get_secret_value() if credentials.refresh_token else None,\n    token_uri='https://oauth2.googleapis.com/token', client_id=kwargs.get(\n    'client_id'), client_secret=kwargs.get('client_secret'), scopes=\n    credentials.scopes)\nreturn build('gmail', 'v1', credentials=creds)", "successors": []}], "functions": [], "classes": []}, {"name": "_read_emails", "type": "CFG", "blocks": [{"id": 32, "label": "#32\nresults = service.users().messages().list(userId='me', q=query or '',\n    maxResults=max_results or 10).execute()\nmessages = results.get('messages', [])\nemail_data = []", "successors": [{"id": 33, "label": "#33\nfor message in messages:", "successors": [{"id": 34, "label": "#34\nmsg = service.users().messages().get(userId='me', id=message['id'], format=\n    'full').execute()\nheaders = {header['name'].lower(): header['value'] for header in msg[\n    'payload']['headers']}\nattachments = self._get_attachments(service, msg)\nemail = Email(id=msg['id'], subject=headers.get('subject', 'No Subject'),\n    snippet=msg['snippet'], from_=parseaddr(headers.get('from', ''))[1], to\n    =parseaddr(headers.get('to', ''))[1], date=headers.get('date', ''),\n    body=self._get_email_body(msg), sizeEstimate=msg['sizeEstimate'],\n    attachments=attachments)\nemail_data.append(email)", "successors": []}, {"id": 35, "label": "#35\nreturn email_data", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "_get_email_body", "type": "CFG", "blocks": [{"id": 39, "label": "#39\nif 'parts' in msg['payload']:", "successors": [{"id": 40, "label": "#40\nfor part in msg['payload']['parts']:", "successors": [{"id": 46, "label": "#46\nif part['mimeType'] == 'text/plain':", "successors": [{"id": 48, "label": "#48\nreturn base64.urlsafe_b64decode(part['body']['data']).decode('utf-8')", "successors": []}]}, {"id": 41, "label": "#41\nreturn 'This email does not contain a text body.'", "successors": []}]}, {"id": 42, "label": "#42\nif msg['payload']['mimeType'] == 'text/plain':", "successors": [{"id": 43, "label": "#43\nreturn base64.urlsafe_b64decode(msg['payload']['body']['data']).decode('utf-8')", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "_get_attachments", "type": "CFG", "blocks": [{"id": 54, "label": "#54\nattachments = []\nif 'parts' in message['payload']:", "successors": [{"id": 55, "label": "#55\nfor part in message['payload']['parts']:", "successors": [{"id": 57, "label": "#57\nif part['filename']:", "successors": [{"id": 59, "label": "#59\nattachment = Attachment(filename=part['filename'], content_type=part[\n    'mimeType'], size=int(part['body'].get('size', 0)), attachment_id=part[\n    'body']['attachmentId'])\nattachments.append(attachment)", "successors": []}]}, {"id": 56, "label": "#56\nreturn attachments", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "download_attachment", "type": "CFG", "blocks": [{"id": 64, "label": "#64\nattachment = service.users().messages().attachments().get(userId='me',\n    messageId=message_id, id=attachment_id).execute()\nfile_data = base64.urlsafe_b64decode(attachment['data'].encode('UTF-8'))\nreturn file_data", "successors": []}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 11, "label": "#11\ncredentials: GoogleCredentialsInput = GoogleCredentialsField([\n    'https://www.googleapis.com/auth/gmail.readonly'])\nquery: str = SchemaField(description='Search query for reading emails',\n    default='is:unread')\nmax_results: int = SchemaField(description=\n    'Maximum number of emails to retrieve', default=10)", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 14, "label": "#14\nemail: Email = SchemaField(description='Email data')\nemails: list[Email] = SchemaField(description='List of email data')\nerror: str = SchemaField(description='Error message if any')", "successors": []}], "functions": [], "classes": []}]}, {"name": "GmailSendBlock", "type": "CFG", "blocks": [{"id": 69, "label": "#69", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 77, "label": "#77\nsuper().__init__(id='6c27abc2-e51d-499e-a85f-5a0041ba94f0', description=\n    'This block sends an email using Gmail.', categories={BlockCategory.\n    COMMUNICATION}, input_schema=GmailSendBlock.Input, output_schema=\n    GmailSendBlock.Output, disabled=not GOOGLE_OAUTH_IS_CONFIGURED,\n    test_input={'to': 'recipient@example.com', 'subject': 'Test Email',\n    'body': 'This is a test email sent from GmailSendBlock.', 'credentials':\n    TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output\n    =[('result', {'id': '1', 'status': 'sent'})], test_mock={'_send_email':\n    lambda *args, **kwargs: {'id': '1', 'status': 'sent'}})", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 80, "label": "#80\nservice = GmailReadBlock._build_service(credentials, **kwargs)\nsend_result = self._send_email(service, input_data.to, input_data.subject,\n    input_data.body)\nyield 'result', send_result", "successors": []}], "functions": [], "classes": []}, {"name": "_send_email", "type": "CFG", "blocks": [{"id": 84, "label": "#84\nif not to or not subject or not body:", "successors": [{"id": 85, "label": "#85\nraise ValueError('To, subject, and body are required for sending an email')", "successors": []}, {"id": 86, "label": "#86\nmessage = self._create_message(to, subject, body)\nsent_message = service.users().messages().send(userId='me', body=message\n    ).execute()\nreturn {'id': sent_message['id'], 'status': 'sent'}", "successors": []}]}], "functions": [], "classes": []}, {"name": "_create_message", "type": "CFG", "blocks": [{"id": 91, "label": "#91\nimport base64\nfrom email.mime.text import MIMEText\nmessage = MIMEText(body)\nmessage['to'] = to\nmessage['subject'] = subject\nraw_message = base64.urlsafe_b64encode(message.as_bytes()).decode('utf-8')\nreturn {'raw': raw_message}", "successors": []}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 71, "label": "#71\ncredentials: GoogleCredentialsInput = GoogleCredentialsField([\n    'https://www.googleapis.com/auth/gmail.send'])\nto: str = SchemaField(description='Recipient email address')\nsubject: str = SchemaField(description='Email subject')\nbody: str = SchemaField(description='Email body')", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 74, "label": "#74\nresult: dict = SchemaField(description='Send confirmation')\nerror: str = SchemaField(description='Error message if any')", "successors": []}], "functions": [], "classes": []}]}, {"name": "GmailListLabelsBlock", "type": "CFG", "blocks": [{"id": 96, "label": "#96", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 104, "label": "#104\nsuper().__init__(id='3e1c2c1c-c689-4520-b956-1f3bf4e02bb7', description=\n    'This block lists all labels in Gmail.', categories={BlockCategory.\n    COMMUNICATION}, input_schema=GmailListLabelsBlock.Input, output_schema=\n    GmailListLabelsBlock.Output, disabled=not GOOGLE_OAUTH_IS_CONFIGURED,\n    test_input={'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=\n    TEST_CREDENTIALS, test_output=[('result', [{'id': 'Label_1', 'name':\n    'Important'}, {'id': 'Label_2', 'name': 'Work'}])], test_mock={\n    '_list_labels': lambda *args, **kwargs: [{'id': 'Label_1', 'name':\n    'Important'}, {'id': 'Label_2', 'name': 'Work'}]})", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 107, "label": "#107\nservice = GmailReadBlock._build_service(credentials, **kwargs)\nlabels = self._list_labels(service)\nyield 'result', labels", "successors": []}], "functions": [], "classes": []}, {"name": "_list_labels", "type": "CFG", "blocks": [{"id": 111, "label": "#111\nresults = service.users().labels().list(userId='me').execute()\nlabels = results.get('labels', [])\nreturn [{'id': label['id'], 'name': label['name']} for label in labels]", "successors": []}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 98, "label": "#98\ncredentials: GoogleCredentialsInput = GoogleCredentialsField([\n    'https://www.googleapis.com/auth/gmail.labels'])", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 101, "label": "#101\nresult: list[dict] = SchemaField(description='List of labels')\nerror: str = SchemaField(description='Error message if any')", "successors": []}], "functions": [], "classes": []}]}, {"name": "GmailAddLabelBlock", "type": "CFG", "blocks": [{"id": 116, "label": "#116", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 124, "label": "#124\nsuper().__init__(id='f884b2fb-04f4-4265-9658-14f433926ac9', description=\n    'This block adds a label to a Gmail message.', categories={\n    BlockCategory.COMMUNICATION}, input_schema=GmailAddLabelBlock.Input,\n    output_schema=GmailAddLabelBlock.Output, disabled=not\n    GOOGLE_OAUTH_IS_CONFIGURED, test_input={'message_id': '12345',\n    'label_name': 'Important', 'credentials': TEST_CREDENTIALS_INPUT},\n    test_credentials=TEST_CREDENTIALS, test_output=[('result', {'status':\n    'Label added successfully', 'label_id': 'Label_1'})], test_mock={\n    '_add_label': lambda *args, **kwargs: {'status':\n    'Label added successfully', 'label_id': 'Label_1'}})", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 127, "label": "#127\nservice = GmailReadBlock._build_service(credentials, **kwargs)\nresult = self._add_label(service, input_data.message_id, input_data.label_name)\nyield 'result', result", "successors": []}], "functions": [], "classes": []}, {"name": "_add_label", "type": "CFG", "blocks": [{"id": 131, "label": "#131\nlabel_id = self._get_or_create_label(service, label_name)\nservice.users().messages().modify(userId='me', id=message_id, body={\n    'addLabelIds': [label_id]}).execute()\nreturn {'status': 'Label added successfully', 'label_id': label_id}", "successors": []}], "functions": [], "classes": []}, {"name": "_get_or_create_label", "type": "CFG", "blocks": [{"id": 135, "label": "#135\nlabel_id = self._get_label_id(service, label_name)\nif not label_id:", "successors": [{"id": 136, "label": "#136\nlabel = service.users().labels().create(userId='me', body={'name': label_name}\n    ).execute()\nlabel_id = label['id']", "successors": [{"id": 137, "label": "#137\nreturn label_id", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "_get_label_id", "type": "CFG", "blocks": [{"id": 141, "label": "#141\nresults = service.users().labels().list(userId='me').execute()\nlabels = results.get('labels', [])", "successors": [{"id": 142, "label": "#142\nfor label in labels:", "successors": [{"id": 143, "label": "#143\nif label['name'] == label_name:", "successors": [{"id": 145, "label": "#145\nreturn label['id']", "successors": []}]}, {"id": 144, "label": "#144\nreturn None", "successors": []}]}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 118, "label": "#118\ncredentials: GoogleCredentialsInput = GoogleCredentialsField([\n    'https://www.googleapis.com/auth/gmail.modify'])\nmessage_id: str = SchemaField(description='Message ID to add label to')\nlabel_name: str = SchemaField(description='Label name to add')", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 121, "label": "#121\nresult: dict = SchemaField(description='Label addition result')\nerror: str = SchemaField(description='Error message if any')", "successors": []}], "functions": [], "classes": []}]}, {"name": "GmailRemoveLabelBlock", "type": "CFG", "blocks": [{"id": 152, "label": "#152", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 160, "label": "#160\nsuper().__init__(id='0afc0526-aba1-4b2b-888e-a22b7c3f359d', description=\n    'This block removes a label from a Gmail message.', categories={\n    BlockCategory.COMMUNICATION}, input_schema=GmailRemoveLabelBlock.Input,\n    output_schema=GmailRemoveLabelBlock.Output, disabled=not\n    GOOGLE_OAUTH_IS_CONFIGURED, test_input={'message_id': '12345',\n    'label_name': 'Important', 'credentials': TEST_CREDENTIALS_INPUT},\n    test_credentials=TEST_CREDENTIALS, test_output=[('result', {'status':\n    'Label removed successfully', 'label_id': 'Label_1'})], test_mock={\n    '_remove_label': lambda *args, **kwargs: {'status':\n    'Label removed successfully', 'label_id': 'Label_1'}})", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 163, "label": "#163\nservice = GmailReadBlock._build_service(credentials, **kwargs)\nresult = self._remove_label(service, input_data.message_id, input_data.\n    label_name)\nyield 'result', result", "successors": []}], "functions": [], "classes": []}, {"name": "_remove_label", "type": "CFG", "blocks": [{"id": 167, "label": "#167\nlabel_id = self._get_label_id(service, label_name)\nif label_id:", "successors": [{"id": 168, "label": "#168\nservice.users().messages().modify(userId='me', id=message_id, body={\n    'removeLabelIds': [label_id]}).execute()\nreturn {'status': 'Label removed successfully', 'label_id': label_id}", "successors": []}, {"id": 170, "label": "#170\nreturn {'status': 'Label not found', 'label_name': label_name}", "successors": []}]}], "functions": [], "classes": []}, {"name": "_get_label_id", "type": "CFG", "blocks": [{"id": 175, "label": "#175\nresults = service.users().labels().list(userId='me').execute()\nlabels = results.get('labels', [])", "successors": [{"id": 176, "label": "#176\nfor label in labels:", "successors": [{"id": 177, "label": "#177\nif label['name'] == label_name:", "successors": [{"id": 179, "label": "#179\nreturn label['id']", "successors": []}]}, {"id": 178, "label": "#178\nreturn None", "successors": []}]}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 154, "label": "#154\ncredentials: GoogleCredentialsInput = GoogleCredentialsField([\n    'https://www.googleapis.com/auth/gmail.modify'])\nmessage_id: str = SchemaField(description='Message ID to remove label from')\nlabel_name: str = SchemaField(description='Label name to remove')", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 157, "label": "#157\nresult: dict = SchemaField(description='Label removal result')\nerror: str = SchemaField(description='Error message if any')", "successors": []}], "functions": [], "classes": []}]}]}
{"file_name": "167.json", "name": "167.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport json\nfrom typing import Optional\nfrom cryptography.fernet import Fernet\nfrom backend.util.settings import Settings\nENCRYPTION_KEY = Settings().secrets.encryption_key", "successors": []}], "functions": [], "classes": [{"name": "JSONCryptor", "type": "CFG", "blocks": [{"id": 3, "label": "#3", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 5, "label": "#5\nself.key = key or ENCRYPTION_KEY\nif not self.key:", "successors": [{"id": 6, "label": "#6\nraise ValueError(\n    'Encryption key must be provided or set in ENCRYPTION_KEY environment variable'\n    )", "successors": []}, {"id": 7, "label": "#7\nself.fernet = Fernet(self.key.encode() if isinstance(self.key, str) else\n    self.key)", "successors": []}]}], "functions": [], "classes": []}, {"name": "encrypt", "type": "CFG", "blocks": [{"id": 11, "label": "#11\n\"\"\"Encrypt dictionary data to string\"\"\"\njson_str = json.dumps(data)\nencrypted = self.fernet.encrypt(json_str.encode())\nreturn encrypted.decode()", "successors": []}], "functions": [], "classes": []}, {"name": "decrypt", "type": "CFG", "blocks": [{"id": 15, "label": "#15\n\"\"\"Decrypt string to dictionary\"\"\"\nif not encrypted_str:", "successors": [{"id": 16, "label": "#16\nreturn {}", "successors": []}, {"id": 17, "label": "#17\ndecrypted = self.fernet.decrypt(encrypted_str.encode())\nreturn json.loads(decrypted.decode())", "successors": []}]}], "functions": [], "classes": []}], "classes": []}]}
{"file_name": "168.json", "name": "168.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport time\nfrom typing import Tuple\nfrom redis import Redis\nfrom .config import RATE_LIMIT_SETTINGS", "successors": []}], "functions": [], "classes": [{"name": "RateLimiter", "type": "CFG", "blocks": [{"id": 3, "label": "#3", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 5, "label": "#5\nself.redis = Redis(host=redis_host, port=int(redis_port), password=\n    redis_password, decode_responses=True)\nself.window = 60\nself.max_requests = requests_per_minute", "successors": []}], "functions": [], "classes": []}, {"name": "check_rate_limit", "type": "CFG", "blocks": [{"id": 8, "label": "#8\n\"\"\"\n        Check if request is within rate limits.\n\n        Args:\n            api_key_id: The API key identifier to check\n\n        Returns:\n            Tuple of (is_allowed, remaining_requests, reset_time)\n        \"\"\"\nnow = time.time()\nwindow_start = now - self.window\nkey = f'ratelimit:{api_key_id}:1min'\npipe = self.redis.pipeline()\npipe.zremrangebyscore(key, 0, window_start)\npipe.zadd(key, {str(now): now})\npipe.zcount(key, window_start, now)\npipe.expire(key, self.window)\n_, _, request_count, _ = pipe.execute()\nremaining = max(0, self.max_requests - request_count)\nreset_time = int(now + self.window)\nreturn request_count <= self.max_requests, remaining, reset_time", "successors": []}], "functions": [], "classes": []}], "classes": []}]}
{"file_name": "169.json", "name": "169.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport re\nfrom backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema\nfrom backend.data.model import SchemaField", "successors": []}], "functions": [], "classes": [{"name": "CodeExtractionBlock", "type": "CFG", "blocks": [{"id": 3, "label": "#3", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 11, "label": "#11\nsuper().__init__(id='d3a7d896-3b78-4f44-8b4b-48fbf4f0bcd8', description=\n    'Extracts code blocks from text and identifies their programming languages'\n    , categories={BlockCategory.TEXT}, input_schema=CodeExtractionBlock.\n    Input, output_schema=CodeExtractionBlock.Output, test_input={'text':\n    \"\"\"Here's a Python example:\n```python\nprint('Hello World')\n```\nAnd some HTML:\n```html\n<h1>Title</h1>\n```\"\"\"\n    }, test_output=[('html', '<h1>Title</h1>'), ('python',\n    \"print('Hello World')\"), ('remaining_text',\n    \"\"\"Here's a Python example:\nAnd some HTML:\"\"\")])", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 14, "label": "#14\nlanguage_aliases = {'html': ['html', 'htm'], 'css': ['css'], 'javascript':\n    ['javascript', 'js'], 'python': ['python', 'py'], 'sql': ['sql'],\n    'java': ['java'], 'cpp': ['cpp', 'c++'], 'csharp': ['csharp', 'c#',\n    'cs'], 'json_code': ['json'], 'bash': ['bash', 'shell', 'sh'], 'php': [\n    'php'], 'ruby': ['ruby', 'rb'], 'yaml': ['yaml', 'yml'], 'markdown': [\n    'markdown', 'md'], 'typescript': ['typescript', 'ts'], 'xml': ['xml']}", "successors": [{"id": 15, "label": "#15\nfor canonical_name, aliases in language_aliases.items():", "successors": [{"id": 16, "label": "#16\ncode = ''", "successors": [{"id": 18, "label": "#18\nfor alias in aliases:", "successors": [{"id": 19, "label": "#19\ncode_for_alias = self.extract_code(input_data.text, alias)\nif code_for_alias:", "successors": [{"id": 21, "label": "#21\ncode = code + '\\n\\n' + code_for_alias if code else code_for_alias", "successors": []}]}, {"id": 20, "label": "#20\nif code:", "successors": [{"id": 23, "label": "#23\nyield canonical_name, code", "successors": []}]}]}]}, {"id": 17, "label": "#17\npattern = '```(?:' + '|'.join(re.escape(alias) for aliases in\n    language_aliases.values() for alias in aliases) + ')\\\\s+[\\\\s\\\\S]*?```'\nremaining_text = re.sub(pattern, '', input_data.text).strip()\nremaining_text = re.sub('\\\\n\\\\s*\\\\n', '\\n', remaining_text)\nif remaining_text:", "successors": [{"id": 26, "label": "#26\nyield 'remaining_text', remaining_text", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "extract_code", "type": "CFG", "blocks": [{"id": 31, "label": "#31\nlanguage = re.escape(language)\npattern = re.compile(f'```{language}\\\\s+(.*?)```', re.DOTALL | re.IGNORECASE)\nmatches = pattern.finditer(text)\ncode_blocks = [match.group(1).strip() for match in matches]\nreturn '\\n\\n'.join(code_blocks) if code_blocks else ''", "successors": []}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 5, "label": "#5\ntext: str = SchemaField(description=\n    'Text containing code blocks to extract (e.g., AI response)',\n    placeholder='Enter text containing code blocks')", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 8, "label": "#8\nhtml: str = SchemaField(description='Extracted HTML code')\ncss: str = SchemaField(description='Extracted CSS code')\njavascript: str = SchemaField(description='Extracted JavaScript code')\npython: str = SchemaField(description='Extracted Python code')\nsql: str = SchemaField(description='Extracted SQL code')\njava: str = SchemaField(description='Extracted Java code')\ncpp: str = SchemaField(description='Extracted C++ code')\ncsharp: str = SchemaField(description='Extracted C# code')\njson_code: str = SchemaField(description='Extracted JSON code')\nbash: str = SchemaField(description='Extracted Bash code')\nphp: str = SchemaField(description='Extracted PHP code')\nruby: str = SchemaField(description='Extracted Ruby code')\nyaml: str = SchemaField(description='Extracted YAML code')\nmarkdown: str = SchemaField(description='Extracted Markdown code')\ntypescript: str = SchemaField(description='Extracted TypeScript code')\nxml: str = SchemaField(description='Extracted XML code')\nremaining_text: str = SchemaField(description=\n    'Remaining text after code extraction')", "successors": []}], "functions": [], "classes": []}]}]}
{"file_name": "170.json", "name": "170.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom mrjob.job import MRJob\nif __name__ == '__main__':", "successors": [{"id": 31, "label": "#31\nSpendingByCategory.run()", "successors": []}]}], "functions": [], "classes": [{"name": "SpendingByCategory", "type": "CFG", "blocks": [{"id": 3, "label": "#3", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 5, "label": "#5\nself.categorizer = categorizer", "successors": []}], "functions": [], "classes": []}, {"name": "current_year_month", "type": "CFG", "blocks": [{"id": 8, "label": "#8\n\"\"\"Return the current year and month.\"\"\"", "successors": []}], "functions": [], "classes": []}, {"name": "extract_year_month", "type": "CFG", "blocks": [{"id": 11, "label": "#11\n\"\"\"Return the year and month portions of the timestamp.\"\"\"", "successors": []}], "functions": [], "classes": []}, {"name": "handle_budget_notifications", "type": "CFG", "blocks": [{"id": 14, "label": "#14\n\"\"\"Call notification API if nearing or exceeded budget.\"\"\"", "successors": []}], "functions": [], "classes": []}, {"name": "mapper", "type": "CFG", "blocks": [{"id": 17, "label": "#17\n\"\"\"Parse each log line, extract and transform relevant lines.\n\n        Emit key value pairs of the form:\n\n        (2016-01, shopping), 25\n        (2016-01, shopping), 100\n        (2016-01, gas), 50\n        \"\"\"\ntimestamp, category, amount = line.split('\\t')\nperiod = self.extract_year_month(timestamp)\nif period == self.current_year_month():", "successors": [{"id": 18, "label": "#18\nyield (period, category), amount", "successors": []}]}], "functions": [], "classes": []}, {"name": "reducer", "type": "CFG", "blocks": [{"id": 23, "label": "#23\n\"\"\"Sum values for each key.\n\n        (2016-01, shopping), 125\n        (2016-01, gas), 50\n        \"\"\"\ntotal = sum(values)\nself.handle_budget_notifications(key, total)\nyield key, sum(values)", "successors": []}], "functions": [], "classes": []}, {"name": "steps", "type": "CFG", "blocks": [{"id": 27, "label": "#27\n\"\"\"Run the map and reduce steps.\"\"\"\nreturn [self.mr(mapper=self.mapper, reducer=self.reducer)]", "successors": []}], "functions": [], "classes": []}], "classes": []}]}
{"file_name": "171.json", "name": "171.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport asyncio\nimport builtins\nimport logging\nimport os\nimport threading\nimport time\nimport typing\nfrom abc import ABC, abstractmethod\nfrom enum import Enum\nfrom types import NoneType, UnionType\nfrom typing import Annotated, Any, Awaitable, Callable, Coroutine, Dict, FrozenSet, Iterator, List, Set, Tuple, Type, TypeVar, Union, cast, get_args, get_origin\nimport Pyro5.api\nfrom pydantic import BaseModel\nfrom Pyro5 import api as pyro\nfrom Pyro5 import config as pyro_config\nfrom backend.data import db, redis\nfrom backend.util.process import AppProcess\nfrom backend.util.retry import conn_retry\nfrom backend.util.settings import Config, Secrets\nlogger = logging.getLogger(__name__)\nT = TypeVar('T')\nC = TypeVar('C', bound=Callable)\nconfig = Config()\npyro_host = config.pyro_host\npyro_config.MAX_RETRIES = config.pyro_client_comm_retry\npyro_config.COMMTIMEOUT = config.pyro_client_comm_timeout\nAS = TypeVar('AS', bound=AppService)\nbuiltin_types = [*vars(builtins).values(), NoneType, Enum]", "successors": []}], "functions": [{"name": "expose", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"\n    Decorator to mark a method or class to be exposed for remote calls.\n\n    ## \u26a0\ufe0f Gotcha\n    Aside from \"simple\" types, only Pydantic models are passed unscathed *if annotated*.\n    Any other passed or returned class objects are converted to dictionaries by Pyro.\n    \"\"\"\nregister_pydantic_serializers(func)\nreturn pyro.expose(wrapper)", "successors": []}], "functions": [{"name": "wrapper", "type": "CFG", "blocks": [{"id": 5, "label": "#5\ntry:", "successors": [{"id": 6, "label": "#6\nreturn func(*args, **kwargs)", "successors": []}, {"id": 7, "label": "#7\nmsg = f'Error in {func.__name__}: {e.__str__()}'\nlogger.exception(msg)\nraise", "successors": []}]}], "functions": [], "classes": []}], "classes": []}, {"name": "register_pydantic_serializers", "type": "CFG", "blocks": [{"id": 15, "label": "#15\n\"\"\"Register custom serializers and deserializers for annotated Pydantic models\"\"\"", "successors": [{"id": 16, "label": "#16\nfor name, annotation in func.__annotations__.items():", "successors": [{"id": 17, "label": "#17\ntry:", "successors": [{"id": 19, "label": "#19\npydantic_types = _pydantic_models_from_type_annotation(annotation)", "successors": [{"id": 21, "label": "#21\nfor model in pydantic_types:", "successors": [{"id": 23, "label": "#23\nlogger.debug(\n    f\"Registering Pyro (de)serializers for {func.__name__} annotation '{name}': {model.__qualname__}\"\n    )\npyro.register_class_to_dict(model, _make_custom_serializer(model))\npyro.register_dict_to_class(model.__qualname__, _make_custom_deserializer(\n    model))", "successors": []}]}]}, {"id": 20, "label": "#20\nraise TypeError(f'Error while exposing {func.__name__}: {e.__str__()}')", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "_make_custom_serializer", "type": "CFG", "blocks": [{"id": 27, "label": "#27\nreturn custom_class_to_dict", "successors": []}], "functions": [{"name": "custom_class_to_dict", "type": "CFG", "blocks": [{"id": 29, "label": "#29\ndata = {'__class__': obj.__class__.__qualname__, **obj.model_dump()}\nlogger.debug(f'Serializing {obj.__class__.__qualname__} with data: {data}')\nreturn data", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "_make_custom_deserializer", "type": "CFG", "blocks": [{"id": 35, "label": "#35\nreturn custom_dict_to_class", "successors": []}], "functions": [{"name": "custom_dict_to_class", "type": "CFG", "blocks": [{"id": 37, "label": "#37\nlogger.debug(f'Deserializing {model.__qualname__} from data: {data}')\nreturn model(**data)", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "close_service_client", "type": "CFG", "blocks": [{"id": 94, "label": "#94\nif isinstance(client, PyroClient):", "successors": [{"id": 95, "label": "#95\nclient.proxy._pyroRelease()", "successors": []}, {"id": 97, "label": "#97\nraise RuntimeError(f'Client {client.__class__} is not a Pyro client.')", "successors": []}]}], "functions": [], "classes": []}, {"name": "get_service_client", "type": "CFG", "blocks": [{"id": 101, "label": "#101\nservice_name = service_type.service_name\nreturn cast(AS, DynamicClient())", "successors": []}], "functions": [], "classes": [{"name": "DynamicClient", "type": "CFG", "blocks": [{"id": 103, "label": "#103", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 105, "label": "#105\nhost = os.environ.get(f'{service_name.upper()}_HOST', pyro_host)\nuri = f'PYRO:{service_type.service_name}@{host}:{service_type.get_port()}'\nlogger.debug(f'Connecting to service [{service_name}]. URI = {uri}')\nself.proxy = Pyro5.api.Proxy(uri)\nself.proxy._pyroBind()\nlogger.debug(f'Successfully connected to service [{service_name}]')", "successors": []}], "functions": [], "classes": []}, {"name": "__getattr__", "type": "CFG", "blocks": [{"id": 108, "label": "#108\nres = getattr(self.proxy, name)\nreturn res", "successors": []}], "functions": [], "classes": []}], "classes": []}]}, {"name": "_pydantic_models_from_type_annotation", "type": "CFG", "blocks": [{"id": 115, "label": "#115\nif (origin := get_origin(annotation)) and origin is Annotated:", "successors": [{"id": 116, "label": "#116\nannotation = get_args(annotation)[0]", "successors": [{"id": 117, "label": "#117\norigin = get_origin(annotation)\nargs = get_args(annotation)\nif origin in (Union, UnionType, list, List, tuple, Tuple, set, Set,", "successors": [{"id": 118, "label": "#118\nfor arg in args:", "successors": [{"id": 136, "label": "#136\nyield from _pydantic_models_from_type_annotation(arg)", "successors": []}]}, {"id": 120, "label": "#120\nif origin in (dict, Dict):", "successors": [{"id": 121, "label": "#121\nkey_type, value_type = args\nyield from _pydantic_models_from_type_annotation(key_type)\nyield from _pydantic_models_from_type_annotation(value_type)", "successors": []}, {"id": 123, "label": "#123\nif origin in (Awaitable, Coroutine):", "successors": [{"id": 124, "label": "#124\nreturn_type = args[-1]\nyield from _pydantic_models_from_type_annotation(return_type)", "successors": []}, {"id": 126, "label": "#126\nannotype = annotation if origin is None else origin\nif annotype is not None and not hasattr(typing, getattr(annotype,", "successors": [{"id": 127, "label": "#127\nif issubclass(annotype, BaseModel):", "successors": [{"id": 129, "label": "#129\nyield annotype", "successors": []}, {"id": 131, "label": "#131\nif annotype not in builtin_types and not issubclass(annotype, Enum):", "successors": [{"id": 132, "label": "#132\nraise TypeError(f'Unsupported type encountered: {annotype}')", "successors": []}]}]}]}]}]}]}]}]}], "functions": [], "classes": []}], "classes": [{"name": "AppService", "type": "CFG", "blocks": [{"id": 43, "label": "#43\nshared_event_loop: asyncio.AbstractEventLoop\nuse_db: bool = False\nuse_redis: bool = False\nuse_supabase: bool = False", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 45, "label": "#45\nself.uri = None", "successors": []}], "functions": [], "classes": []}, {"name": "get_port", "type": "CFG", "blocks": [{"id": 48, "label": "#48\npass", "successors": []}], "functions": [], "classes": []}, {"name": "get_host", "type": "CFG", "blocks": [{"id": 51, "label": "#51\nreturn os.environ.get(f'{cls.service_name.upper()}_HOST', config.pyro_host)", "successors": []}], "functions": [], "classes": []}, {"name": "run_service", "type": "CFG", "blocks": [{"id": 55, "label": "#55\nwhile True:", "successors": [{"id": 56, "label": "#56\ntime.sleep(10)", "successors": []}]}], "functions": [], "classes": []}, {"name": "__run_async", "type": "CFG", "blocks": [{"id": 60, "label": "#60\nreturn asyncio.run_coroutine_threadsafe(coro, self.shared_event_loop)", "successors": []}], "functions": [], "classes": []}, {"name": "run_and_wait", "type": "CFG", "blocks": [{"id": 64, "label": "#64\nfuture = self.__run_async(coro)\nreturn future.result()", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 68, "label": "#68\nself.shared_event_loop = asyncio.get_event_loop()\nif self.use_db:", "successors": [{"id": 69, "label": "#69\nself.shared_event_loop.run_until_complete(db.connect())", "successors": [{"id": 70, "label": "#70\nif self.use_redis:", "successors": [{"id": 71, "label": "#71\nredis.connect()", "successors": [{"id": 72, "label": "#72\nif self.use_supabase:", "successors": [{"id": 73, "label": "#73\nfrom supabase import create_client\nsecrets = Secrets()\nself.supabase = create_client(secrets.supabase_url, secrets.\n    supabase_service_role_key)", "successors": [{"id": 74, "label": "#74\nasync_thread = threading.Thread(target=self.__start_async_loop)\nasync_thread.daemon = True\nasync_thread.start()\ndaemon_thread = threading.Thread(target=self.__start_pyro)\ndaemon_thread.daemon = True\ndaemon_thread.start()\nself.run_service()", "successors": []}]}]}]}]}]}]}], "functions": [], "classes": []}, {"name": "cleanup", "type": "CFG", "blocks": [{"id": 77, "label": "#77\nif self.use_db:", "successors": [{"id": 78, "label": "#78\nself.run_and_wait(db.disconnect())", "successors": [{"id": 79, "label": "#79\nif self.use_redis:", "successors": [{"id": 80, "label": "#80\nredis.disconnect()", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "__start_pyro", "type": "CFG", "blocks": [{"id": 84, "label": "#84\nmaximum_connection_thread_count = max(Pyro5.config.THREADPOOL_SIZE, config.\n    num_node_workers * config.num_graph_workers)\nPyro5.config.THREADPOOL_SIZE = maximum_connection_thread_count\ndaemon = Pyro5.api.Daemon(host=config.pyro_host, port=self.get_port())\nself.uri = daemon.register(self, objectId=self.service_name)\nlogger.info(f'[{self.service_name}] Connected to Pyro; URI = {self.uri}')\ndaemon.requestLoop()", "successors": []}], "functions": [], "classes": []}, {"name": "__start_async_loop", "type": "CFG", "blocks": [{"id": 87, "label": "#87\nself.shared_event_loop.run_forever()", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "PyroClient", "type": "CFG", "blocks": [{"id": 91, "label": "#91\nproxy: Pyro5.api.Proxy", "successors": []}], "functions": [], "classes": []}]}
{"file_name": "172.json", "name": "172.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\n\"\"\"\nThe command line interface for the agent server\n\"\"\"\nimport os\nimport pathlib\nimport click\nimport psutil\nfrom backend import app\nfrom backend.util.process import AppProcess\nmain.add_command(test)\nif __name__ == '__main__':", "successors": [{"id": 92, "label": "#92\nmain()", "successors": []}]}], "functions": [{"name": "get_pid_path", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nhome_dir = pathlib.Path.home()\nnew_dir = home_dir / '.config' / 'agpt'\nfile_path = new_dir / 'running.tmp'\nreturn file_path", "successors": []}], "functions": [], "classes": []}, {"name": "get_pid", "type": "CFG", "blocks": [{"id": 7, "label": "#7\nfile_path = get_pid_path()\nif not file_path.exists():", "successors": [{"id": 8, "label": "#8\nreturn None", "successors": []}, {"id": 9, "label": "#9\nos.makedirs(file_path.parent, exist_ok=True)\nwith open(file_path, 'r', encoding='utf-8') as file:", "successors": [{"id": 11, "label": "#11\npid = file.read()", "successors": [{"id": 12, "label": "#12\ntry:", "successors": [{"id": 13, "label": "#13\nreturn int(pid)", "successors": []}, {"id": 14, "label": "#14\nreturn None", "successors": []}]}]}]}]}], "functions": [], "classes": []}, {"name": "write_pid", "type": "CFG", "blocks": [{"id": 20, "label": "#20\nfile_path = get_pid_path()\nos.makedirs(file_path.parent, exist_ok=True)\nwith open(file_path, 'w', encoding='utf-8') as file:", "successors": [{"id": 21, "label": "#21\nfile.write(str(pid))", "successors": []}]}], "functions": [], "classes": []}, {"name": "main", "type": "CFG", "blocks": [{"id": 31, "label": "#31\n\"\"\"AutoGPT Server CLI Tool\"\"\"\npass", "successors": []}], "functions": [], "classes": []}, {"name": "start", "type": "CFG", "blocks": [{"id": 34, "label": "#34\n\"\"\"\n    Starts the server in the background and saves the PID\n    \"\"\"\npid = get_pid()\nif pid and psutil.pid_exists(pid):", "successors": [{"id": 35, "label": "#35\nprint('Server is already running')\nexit(1)", "successors": [{"id": 36, "label": "#36\nprint('Starting server')\npid = MainApp().start(background=True, silent=True)\nprint(f'Server running in process: {pid}')\nwrite_pid(pid)\nprint('done')\nos._exit(status=0)", "successors": []}]}, {"id": 37, "label": "#37\nif pid:", "successors": [{"id": 38, "label": "#38\nprint('PID does not exist deleting file')\nos.remove(get_pid_path())", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "stop", "type": "CFG", "blocks": [{"id": 42, "label": "#42\n\"\"\"\n    Stops the server\n    \"\"\"\npid = get_pid()\nif not pid:", "successors": [{"id": 43, "label": "#43\nprint('Server is not running')\nreturn", "successors": []}, {"id": 44, "label": "#44\nos.remove(get_pid_path())\nprocess = psutil.Process(int(pid))", "successors": [{"id": 46, "label": "#46\nfor child in process.children(recursive=True):", "successors": [{"id": 47, "label": "#47\nchild.terminate()", "successors": []}, {"id": 48, "label": "#48\nprocess.terminate()\nprint('Server Stopped')", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "gen_encrypt_key", "type": "CFG", "blocks": [{"id": 51, "label": "#51\n\"\"\"\n    Generate a new encryption key\n    \"\"\"\nfrom cryptography.fernet import Fernet\nprint(Fernet.generate_key().decode())", "successors": []}], "functions": [], "classes": []}, {"name": "test", "type": "CFG", "blocks": [{"id": 54, "label": "#54\n\"\"\"\n    Group for test commands\n    \"\"\"\npass", "successors": []}], "functions": [], "classes": []}, {"name": "reddit", "type": "CFG", "blocks": [{"id": 57, "label": "#57\n\"\"\"\n    Create an event graph\n    \"\"\"\nimport requests\nfrom backend.usecases.reddit_marketing import create_test_graph\ntest_graph = create_test_graph()\nurl = f'{server_address}/graphs'\nheaders = {'Content-Type': 'application/json'}\ndata = test_graph.model_dump_json()\nresponse = requests.post(url, headers=headers, data=data)\ngraph_id = response.json()['id']\nprint(f'Graph created with ID: {graph_id}')", "successors": []}], "functions": [], "classes": []}, {"name": "populate_db", "type": "CFG", "blocks": [{"id": 60, "label": "#60\n\"\"\"\n    Create an event graph\n    \"\"\"\nimport requests\nfrom backend.usecases.sample import create_test_graph\ntest_graph = create_test_graph()\nurl = f'{server_address}/graphs'\nheaders = {'Content-Type': 'application/json'}\ndata = test_graph.model_dump_json()\nresponse = requests.post(url, headers=headers, data=data)\ngraph_id = response.json()['id']\nif response.status_code == 200:", "successors": [{"id": 61, "label": "#61\nexecute_url = f\"{server_address}/graphs/{response.json()['id']}/execute\"\ntext = 'Hello, World!'\ninput_data = {'input': text}\nresponse = requests.post(execute_url, headers=headers, json=input_data)\nschedule_url = f'{server_address}/graphs/{graph_id}/schedules'\ndata = {'graph_id': graph_id, 'cron': '*/5 * * * *', 'input_data': {'input':\n    'Hello, World!'}}\nresponse = requests.post(schedule_url, headers=headers, json=data)", "successors": [{"id": 62, "label": "#62\nprint(\"\"\"Database populated with: \n- graph\n- execution\n- schedule\"\"\")", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "graph", "type": "CFG", "blocks": [{"id": 65, "label": "#65\n\"\"\"\n    Create an event graph\n    \"\"\"\nimport requests\nfrom backend.usecases.sample import create_test_graph\nurl = f'{server_address}/graphs'\nheaders = {'Content-Type': 'application/json'}\ndata = create_test_graph().model_dump_json()\nresponse = requests.post(url, headers=headers, data=data)\nif response.status_code == 200:", "successors": [{"id": 66, "label": "#66\nprint(response.json()['id'])\nexecute_url = f\"{server_address}/graphs/{response.json()['id']}/execute\"\ntext = 'Hello, World!'\ninput_data = {'input': text}\nresponse = requests.post(execute_url, headers=headers, json=input_data)", "successors": []}, {"id": 68, "label": "#68\nprint('Failed to send graph')\nprint(f'Response: {response.text}')", "successors": []}]}], "functions": [], "classes": []}, {"name": "execute", "type": "CFG", "blocks": [{"id": 71, "label": "#71\n\"\"\"\n    Create an event graph\n    \"\"\"\nimport requests\nheaders = {'Content-Type': 'application/json'}\nexecute_url = f'http://0.0.0.0:8000/graphs/{graph_id}/execute'\nrequests.post(execute_url, headers=headers, json=content)", "successors": []}], "functions": [], "classes": []}, {"name": "event", "type": "CFG", "blocks": [{"id": 74, "label": "#74\n\"\"\"\n    Send an event to the running server\n    \"\"\"\nprint('Event sent')", "successors": []}], "functions": [], "classes": []}, {"name": "websocket", "type": "CFG", "blocks": [{"id": 77, "label": "#77\n\"\"\"\n    Tests the websocket connection.\n    \"\"\"\nimport asyncio\nimport websockets.asyncio.client\nfrom backend.server.ws_api import ExecutionSubscription, Methods, WsMessage\nasyncio.run(send_message(server_address))\nprint('Testing WS')", "successors": []}], "functions": [{"name": "send_message", "type": "CFG", "blocks": [{"id": 79, "label": "#79\nuri = f'ws://{server_address}'\nasync with websockets.asyncio.client.connect(uri) as websocket:\n    try:\n        msg = WsMessage(method=Methods.SUBSCRIBE, data=\n            ExecutionSubscription(graph_id=graph_id).model_dump()\n            ).model_dump_json()\n        await websocket.send(msg)\n        print(f'Sending: {msg}')\n        while True:\n            response = await websocket.recv()\n            print(f'Response from server: {response}')\n    except InterruptedError:\n        exit(0)", "successors": [{"id": 80, "label": "#80\ntry:", "successors": [{"id": 82, "label": "#82\nmsg = WsMessage(method=Methods.SUBSCRIBE, data=ExecutionSubscription(\n    graph_id=graph_id).model_dump()).model_dump_json()\nawait websocket.send(msg)", "successors": [{"id": 85, "label": "#85\nprint(f'Sending: {msg}')", "successors": [{"id": 86, "label": "#86\nwhile True:", "successors": [{"id": 87, "label": "#87\nresponse = await websocket.recv()", "successors": [{"id": 89, "label": "#89\nprint(f'Response from server: {response}')", "successors": []}]}]}]}]}, {"id": 83, "label": "#83\nexit(0)", "successors": []}]}]}], "functions": [], "classes": []}], "classes": []}], "classes": [{"name": "MainApp", "type": "CFG", "blocks": [{"id": 25, "label": "#25", "successors": []}], "functions": [{"name": "run", "type": "CFG", "blocks": [{"id": 27, "label": "#27\napp.main(silent=True)", "successors": []}], "functions": [], "classes": []}], "classes": []}]}
{"file_name": "173.json", "name": "173.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom mrjob.job import MRJob\nif __name__ == '__main__':", "successors": [{"id": 30, "label": "#30\nSalesRanker.run()", "successors": []}]}], "functions": [], "classes": [{"name": "SalesRanker", "type": "CFG", "blocks": [{"id": 3, "label": "#3", "successors": []}], "functions": [{"name": "within_past_week", "type": "CFG", "blocks": [{"id": 5, "label": "#5\n\"\"\"Return True if timestamp is within past week, False otherwise.\"\"\"", "successors": []}], "functions": [], "classes": []}, {"name": "mapper", "type": "CFG", "blocks": [{"id": 8, "label": "#8\n\"\"\"Parse each log line, extract and transform relevant lines.\n\n        Emit key value pairs of the form:\n\n        (foo, p1), 2\n        (bar, p1), 2\n        (bar, p1), 1\n        (foo, p2), 3\n        (bar, p3), 10\n        (foo, p4), 1\n        \"\"\"\ntimestamp, product_id, category, quantity = line.split('\\t')\nif self.within_past_week(timestamp):", "successors": [{"id": 9, "label": "#9\nyield (category, product_id), quantity", "successors": []}]}], "functions": [], "classes": []}, {"name": "reducer", "type": "CFG", "blocks": [{"id": 14, "label": "#14\n\"\"\"Sum values for each key.\n\n        (foo, p1), 2\n        (bar, p1), 3\n        (foo, p2), 3\n        (bar, p3), 10\n        (foo, p4), 1\n        \"\"\"\nyield key, sum(values)", "successors": []}], "functions": [], "classes": []}, {"name": "mapper_sort", "type": "CFG", "blocks": [{"id": 18, "label": "#18\n\"\"\"Construct key to ensure proper sorting.\n\n        Transform key and value to the form:\n\n        (foo, 2), p1\n        (bar, 3), p1\n        (foo, 3), p2\n        (bar, 10), p3\n        (foo, 1), p4\n\n        The shuffle/sort step of MapReduce will then do a\n        distributed sort on the keys, resulting in:\n\n        (category1, 1), product4\n        (category1, 2), product1\n        (category1, 3), product2\n        (category2, 3), product1\n        (category2, 7), product3\n        \"\"\"\ncategory, product_id = key\nquantity = value\nyield (category, quantity), product_id", "successors": []}], "functions": [], "classes": []}, {"name": "reducer_identity", "type": "CFG", "blocks": [{"id": 22, "label": "#22\nyield key, value", "successors": []}], "functions": [], "classes": []}, {"name": "steps", "type": "CFG", "blocks": [{"id": 26, "label": "#26\n\"\"\"Run the map and reduce steps.\"\"\"\nreturn [self.mr(mapper=self.mapper, reducer=self.reducer), self.mr(mapper=\n    self.mapper_sort, reducer=self.reducer_identity)]", "successors": []}], "functions": [], "classes": []}], "classes": []}]}
{"file_name": "174.json", "name": "174.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom collections import deque\nfrom enum import Enum", "successors": []}], "functions": [], "classes": [{"name": "State", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nunvisited = 0\nvisited = 1", "successors": []}], "functions": [], "classes": []}, {"name": "Graph", "type": "CFG", "blocks": [{"id": 6, "label": "#6", "successors": []}], "functions": [{"name": "bfs", "type": "CFG", "blocks": [{"id": 8, "label": "#8\nif source is None:", "successors": [{"id": 9, "label": "#9\nreturn False", "successors": []}, {"id": 10, "label": "#10\nqueue = deque()\nqueue.append(source)\nsource.visit_state = State.visited", "successors": [{"id": 12, "label": "#12\nwhile queue:", "successors": [{"id": 13, "label": "#13\nnode = queue.popleft()\nprint(node)\nif dest is node:", "successors": [{"id": 15, "label": "#15\nreturn True", "successors": []}, {"id": 16, "label": "#16\nfor adjacent_node in node.adj_nodes.values():", "successors": [{"id": 18, "label": "#18\nif adjacent_node.visit_state == State.unvisited:", "successors": [{"id": 20, "label": "#20\nqueue.append(adjacent_node)\nadjacent_node.visit_state = State.visited", "successors": []}]}]}]}, {"id": 14, "label": "#14\nreturn False", "successors": []}]}]}]}], "functions": [], "classes": []}], "classes": []}, {"name": "Person", "type": "CFG", "blocks": [{"id": 26, "label": "#26", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 28, "label": "#28\nself.id = id\nself.name = name\nself.friend_ids = []", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "LookupService", "type": "CFG", "blocks": [{"id": 32, "label": "#32", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 34, "label": "#34\nself.lookup = {}", "successors": []}], "functions": [], "classes": []}, {"name": "get_person", "type": "CFG", "blocks": [{"id": 37, "label": "#37\nperson_server = self.lookup[person_id]\nreturn person_server.people[person_id]", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "PersonServer", "type": "CFG", "blocks": [{"id": 42, "label": "#42", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 44, "label": "#44\nself.people = {}", "successors": []}], "functions": [], "classes": []}, {"name": "get_people", "type": "CFG", "blocks": [{"id": 47, "label": "#47\nresults = []", "successors": [{"id": 48, "label": "#48\nfor id in ids:", "successors": [{"id": 49, "label": "#49\nif id in self.people:", "successors": [{"id": 51, "label": "#51\nresults.append(self.people[id])", "successors": []}]}, {"id": 50, "label": "#50\nreturn results", "successors": []}]}]}], "functions": [], "classes": []}], "classes": []}, {"name": "UserGraphService", "type": "CFG", "blocks": [{"id": 57, "label": "#57", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 59, "label": "#59\nself.lookup = lookup\nself.person_ids = person_ids\nself.visited_ids = set()", "successors": []}], "functions": [], "classes": []}, {"name": "bfs", "type": "CFG", "blocks": [{"id": 62, "label": "#62\npass", "successors": []}], "functions": [], "classes": []}], "classes": []}]}
{"file_name": "175.json", "name": "175.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport logging\nimport os\nfrom urllib.parse import parse_qs, urlencode, urlparse, urlunparse\nfrom apscheduler.events import EVENT_JOB_ERROR, EVENT_JOB_EXECUTED\nfrom apscheduler.job import Job as JobObj\nfrom apscheduler.jobstores.sqlalchemy import SQLAlchemyJobStore\nfrom apscheduler.schedulers.blocking import BlockingScheduler\nfrom apscheduler.triggers.cron import CronTrigger\nfrom autogpt_libs.utils.cache import thread_cached\nfrom dotenv import load_dotenv\nfrom pydantic import BaseModel\nfrom sqlalchemy import MetaData, create_engine\nfrom backend.data.block import BlockInput\nfrom backend.executor.manager import ExecutionManager\nfrom backend.util.service import AppService, expose, get_service_client\nfrom backend.util.settings import Config\nlogger = logging.getLogger(__name__)\nconfig = Config()", "successors": []}], "functions": [{"name": "_extract_schema_from_url", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"\n    Extracts the schema from the DATABASE_URL and returns the schema and cleaned URL.\n    \"\"\"\nparsed_url = urlparse(database_url)\nquery_params = parse_qs(parsed_url.query)\nschema_list = query_params.pop('schema', None)\nschema = schema_list[0] if schema_list else 'public'\nnew_query = urlencode(query_params, doseq=True)\nnew_parsed_url = parsed_url._replace(query=new_query)\ndatabase_url_clean = str(urlunparse(new_parsed_url))\nreturn schema, database_url_clean", "successors": []}], "functions": [], "classes": []}, {"name": "log", "type": "CFG", "blocks": [{"id": 7, "label": "#7\nlogger.info('[ExecutionScheduler] ' + msg, **kwargs)", "successors": []}], "functions": [], "classes": []}, {"name": "job_listener", "type": "CFG", "blocks": [{"id": 10, "label": "#10\n\"\"\"Logs job execution outcomes for better monitoring.\"\"\"\nif event.exception:", "successors": [{"id": 11, "label": "#11\nlog(f'Job {event.job_id} failed.')", "successors": []}, {"id": 13, "label": "#13\nlog(f'Job {event.job_id} completed successfully.')", "successors": []}]}], "functions": [], "classes": []}, {"name": "get_execution_client", "type": "CFG", "blocks": [{"id": 16, "label": "#16\nreturn get_service_client(ExecutionManager)", "successors": []}], "functions": [], "classes": []}, {"name": "execute_graph", "type": "CFG", "blocks": [{"id": 20, "label": "#20\nargs = JobArgs(**kwargs)\ntry:", "successors": [{"id": 21, "label": "#21\nlog(f'Executing recurring job for graph #{args.graph_id}')\nget_execution_client().add_execution(args.graph_id, args.input_data, args.\n    user_id)", "successors": []}, {"id": 22, "label": "#22\nlogger.exception(f'Error executing graph {args.graph_id}: {e}')", "successors": []}]}], "functions": [], "classes": []}], "classes": [{"name": "JobArgs", "type": "CFG", "blocks": [{"id": 26, "label": "#26\ngraph_id: str\ninput_data: BlockInput\nuser_id: str\ngraph_version: int\ncron: str", "successors": []}], "functions": [], "classes": []}, {"name": "JobInfo", "type": "CFG", "blocks": [{"id": 29, "label": "#29\nid: str\nname: str\nnext_run_time: str", "successors": []}], "functions": [{"name": "from_db", "type": "CFG", "blocks": [{"id": 31, "label": "#31\nreturn JobInfo(id=job_obj.id, name=job_obj.name, next_run_time=job_obj.\n    next_run_time.isoformat(), **job_args.model_dump())", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "ExecutionScheduler", "type": "CFG", "blocks": [{"id": 36, "label": "#36\nscheduler: BlockingScheduler", "successors": []}], "functions": [{"name": "get_port", "type": "CFG", "blocks": [{"id": 38, "label": "#38\nreturn config.execution_scheduler_port", "successors": []}], "functions": [], "classes": []}, {"name": "execution_client", "type": "CFG", "blocks": [{"id": 42, "label": "#42\nreturn get_service_client(ExecutionManager)", "successors": []}], "functions": [], "classes": []}, {"name": "run_service", "type": "CFG", "blocks": [{"id": 46, "label": "#46\nload_dotenv()\ndb_schema, db_url = _extract_schema_from_url(os.getenv('DATABASE_URL'))\nself.scheduler = BlockingScheduler(jobstores={'default': SQLAlchemyJobStore\n    (engine=create_engine(db_url), metadata=MetaData(schema=db_schema))})\nself.scheduler.add_listener(job_listener, EVENT_JOB_EXECUTED | EVENT_JOB_ERROR)\nself.scheduler.start()", "successors": []}], "functions": [], "classes": []}, {"name": "add_execution_schedule", "type": "CFG", "blocks": [{"id": 49, "label": "#49\njob_args = JobArgs(graph_id=graph_id, input_data=input_data, user_id=\n    user_id, graph_version=graph_version, cron=cron)\njob = self.scheduler.add_job(execute_graph, CronTrigger.from_crontab(cron),\n    kwargs=job_args.model_dump(), replace_existing=True)\nlog(f\"Added job {job.id} with cron schedule '{cron}' input data: {input_data}\")\nreturn JobInfo.from_db(job_args, job)", "successors": []}], "functions": [], "classes": []}, {"name": "delete_schedule", "type": "CFG", "blocks": [{"id": 53, "label": "#53\njob = self.scheduler.get_job(schedule_id)\nif not job:", "successors": [{"id": 54, "label": "#54\nlog(f'Job {schedule_id} not found.')\nraise ValueError(f'Job #{schedule_id} not found.')", "successors": []}, {"id": 55, "label": "#55\njob_args = JobArgs(**job.kwargs)\nif job_args.user_id != user_id:", "successors": [{"id": 57, "label": "#57\nraise ValueError(\"User ID does not match the job's user ID.\")", "successors": []}, {"id": 58, "label": "#58\nlog(f'Deleting job {schedule_id}')\njob.remove()\nreturn JobInfo.from_db(job_args, job)", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "get_execution_schedules", "type": "CFG", "blocks": [{"id": 63, "label": "#63\nschedules = []", "successors": [{"id": 64, "label": "#64\nfor job in self.scheduler.get_jobs():", "successors": [{"id": 65, "label": "#65\njob_args = JobArgs(**job.kwargs)\nif job.next_run_time is not None and (graph_id is None or job_args.graph_id ==", "successors": [{"id": 67, "label": "#67\nschedules.append(JobInfo.from_db(job_args, job))", "successors": []}]}, {"id": 66, "label": "#66\nreturn schedules", "successors": []}]}]}], "functions": [], "classes": []}], "classes": []}]}
{"file_name": "176.json", "name": "176.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport asyncio\nimport logging\nfrom contextlib import asynccontextmanager\nimport uvicorn\nfrom autogpt_libs.auth import parse_jwt_token\nfrom fastapi import Depends, FastAPI, WebSocket, WebSocketDisconnect\nfrom starlette.middleware.cors import CORSMiddleware\nfrom backend.data import redis\nfrom backend.data.execution import AsyncRedisExecutionEventBus\nfrom backend.data.user import DEFAULT_USER_ID\nfrom backend.server.conn_manager import ConnectionManager\nfrom backend.server.model import ExecutionSubscription, Methods, WsMessage\nfrom backend.util.service import AppProcess\nfrom backend.util.settings import AppEnvironment, Config, Settings\nlogger = logging.getLogger(__name__)\nsettings = Settings()\ndocs_url = '/docs' if settings.config.app_env == AppEnvironment.LOCAL else None\napp = FastAPI(lifespan=lifespan, docs_url=docs_url)\n_connection_manager = None", "successors": []}], "functions": [{"name": "lifespan", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nmanager = get_connection_manager()\nfut = asyncio.create_task(event_broadcaster(manager))\nfut.add_done_callback(lambda _: logger.info('Event broadcaster stopped'))\nyield", "successors": []}], "functions": [], "classes": []}, {"name": "get_connection_manager", "type": "CFG", "blocks": [{"id": 7, "label": "#7\nglobal _connection_manager\nif _connection_manager is None:", "successors": [{"id": 8, "label": "#8\n_connection_manager = ConnectionManager()", "successors": [{"id": 9, "label": "#9\nreturn _connection_manager", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "event_broadcaster", "type": "CFG", "blocks": [{"id": 13, "label": "#13\ntry:", "successors": [{"id": 14, "label": "#14\nredis.connect()\nevent_queue = AsyncRedisExecutionEventBus()", "successors": [{"id": 17, "label": "#17\nasync for event in event_queue.listen():\n    await manager.send_execution_result(event)", "successors": [{"id": 18, "label": "#18\nawait manager.send_execution_result(event)", "successors": []}]}]}, {"id": 15, "label": "#15\nlogger.exception(f'Event broadcaster error: {e}')\nraise", "successors": []}]}], "functions": [], "classes": []}, {"name": "authenticate_websocket", "type": "CFG", "blocks": [{"id": 24, "label": "#24\nif not settings.config.enable_auth:", "successors": [{"id": 25, "label": "#25\nreturn DEFAULT_USER_ID", "successors": []}, {"id": 26, "label": "#26\ntoken = websocket.query_params.get('token')\nif not token:", "successors": [{"id": 28, "label": "#28\nawait websocket.close(code=4001, reason='Missing authentication token')", "successors": [{"id": 30, "label": "#30\nreturn ''", "successors": []}]}, {"id": 29, "label": "#29\ntry:", "successors": [{"id": 32, "label": "#32\npayload = parse_jwt_token(token)\nuser_id = payload.get('sub')\nif not user_id:", "successors": [{"id": 35, "label": "#35\nawait websocket.close(code=4002, reason='Invalid token')", "successors": [{"id": 37, "label": "#37\nreturn ''", "successors": []}]}, {"id": 36, "label": "#36\nreturn user_id", "successors": []}]}, {"id": 33, "label": "#33\nawait websocket.close(code=4003, reason='Invalid token')", "successors": [{"id": 40, "label": "#40\nreturn ''", "successors": []}]}]}]}]}], "functions": [], "classes": []}, {"name": "handle_subscribe", "type": "CFG", "blocks": [{"id": 44, "label": "#44\nif not message.data:", "successors": [{"id": 45, "label": "#45\nawait websocket.send_text(WsMessage(method=Methods.ERROR, success=False,\n    error='Subscription data missing').model_dump_json())", "successors": []}, {"id": 47, "label": "#47\nex_sub = ExecutionSubscription.model_validate(message.data)\nawait manager.subscribe(ex_sub.graph_id, websocket)", "successors": [{"id": 48, "label": "#48\nlogger.debug(f'New execution subscription for graph {ex_sub.graph_id}')\nawait websocket.send_text(WsMessage(method=Methods.SUBSCRIBE, success=True,\n    channel=ex_sub.graph_id).model_dump_json())", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "handle_unsubscribe", "type": "CFG", "blocks": [{"id": 53, "label": "#53\nif not message.data:", "successors": [{"id": 54, "label": "#54\nawait websocket.send_text(WsMessage(method=Methods.ERROR, success=False,\n    error='Subscription data missing').model_dump_json())", "successors": []}, {"id": 56, "label": "#56\nex_sub = ExecutionSubscription.model_validate(message.data)\nawait manager.unsubscribe(ex_sub.graph_id, websocket)", "successors": [{"id": 57, "label": "#57\nlogger.debug(f'Removed execution subscription for graph {ex_sub.graph_id}')\nawait websocket.send_text(WsMessage(method=Methods.UNSUBSCRIBE, success=\n    True, channel=ex_sub.graph_id).model_dump_json())", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "health", "type": "CFG", "blocks": [{"id": 62, "label": "#62\nreturn {'status': 'healthy'}", "successors": []}], "functions": [], "classes": []}, {"name": "websocket_router", "type": "CFG", "blocks": [{"id": 66, "label": "#66\nuser_id = await authenticate_websocket(websocket)", "successors": [{"id": 67, "label": "#67\nif not user_id:", "successors": [{"id": 68, "label": "#68\nreturn", "successors": []}, {"id": 69, "label": "#69\nawait manager.connect(websocket)", "successors": [{"id": 71, "label": "#71\ntry:", "successors": [{"id": 72, "label": "#72\nwhile True:", "successors": [{"id": 75, "label": "#75\ndata = await websocket.receive_text()", "successors": [{"id": 77, "label": "#77\nmessage = WsMessage.model_validate_json(data)\nif message.method == Methods.HEARTBEAT:", "successors": [{"id": 78, "label": "#78\nawait websocket.send_json({'method': Methods.HEARTBEAT.value, 'data':\n    'pong', 'success': True})", "successors": []}, {"id": 79, "label": "#79\nif message.method == Methods.SUBSCRIBE:", "successors": [{"id": 81, "label": "#81\nawait handle_subscribe(websocket, manager, message)", "successors": []}, {"id": 83, "label": "#83\nif message.method == Methods.UNSUBSCRIBE:", "successors": [{"id": 84, "label": "#84\nawait handle_unsubscribe(websocket, manager, message)", "successors": []}, {"id": 86, "label": "#86\nif message.method == Methods.ERROR:", "successors": [{"id": 87, "label": "#87\nlogger.error(f'WebSocket Error message received: {message.data}')", "successors": []}, {"id": 89, "label": "#89\nlogger.warning(\n    f'Unknown WebSocket message type {message.method} received: {message.data}'\n    )\nawait websocket.send_text(WsMessage(method=Methods.ERROR, success=False,\n    error='Message type is not processed by the server').model_dump_json())", "successors": []}]}]}]}]}]}]}, {"id": 73, "label": "#73\nmanager.disconnect(websocket)\nlogger.debug('WebSocket client disconnected')", "successors": []}]}]}]}]}], "functions": [], "classes": []}], "classes": [{"name": "WebsocketServer", "type": "CFG", "blocks": [{"id": 95, "label": "#95", "successors": []}], "functions": [{"name": "run", "type": "CFG", "blocks": [{"id": 97, "label": "#97\nlogger.info(f'CORS allow origins: {settings.config.backend_cors_allow_origins}'\n    )\nserver_app = CORSMiddleware(app=app, allow_origins=settings.config.\n    backend_cors_allow_origins, allow_credentials=True, allow_methods=['*'],\n    allow_headers=['*'])\nuvicorn.run(server_app, host=Config().websocket_server_host, port=Config().\n    websocket_server_port)", "successors": []}], "functions": [], "classes": []}], "classes": []}]}
{"file_name": "177.json", "name": "177.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom contextlib import contextmanager\nfrom threading import Lock\nfrom typing import TYPE_CHECKING, Any\nfrom expiringdict import ExpiringDict\nif TYPE_CHECKING:", "successors": [{"id": 2, "label": "#2\nfrom redis import Redis\nfrom redis.lock import Lock as RedisLock", "successors": [{"id": 3, "label": "#3", "successors": []}]}]}], "functions": [], "classes": [{"name": "RedisKeyedMutex", "type": "CFG", "blocks": [{"id": 5, "label": "#5\n\"\"\"\n    This class provides a mutex that can be locked and unlocked by a specific key,\n    using Redis as a distributed locking provider.\n    It uses an ExpiringDict to automatically clear the mutex after a specified timeout,\n    in case the key is not unlocked for a specified duration, to prevent memory leaks.\n    \"\"\"", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 7, "label": "#7\nself.redis = redis\nself.timeout = timeout\nself.locks: dict[Any, 'RedisLock'] = ExpiringDict(max_len=6000,\n    max_age_seconds=self.timeout)\nself.locks_lock = Lock()", "successors": []}], "functions": [], "classes": []}, {"name": "locked", "type": "CFG", "blocks": [{"id": 10, "label": "#10\nlock = self.acquire(key)\ntry:", "successors": [{"id": 11, "label": "#11\nyield", "successors": []}]}], "functions": [], "classes": []}, {"name": "acquire", "type": "CFG", "blocks": [{"id": 16, "label": "#16\n\"\"\"Acquires and returns a lock with the given key\"\"\"\nwith self.locks_lock:", "successors": [{"id": 17, "label": "#17\nif key not in self.locks:", "successors": [{"id": 19, "label": "#19\nself.locks[key] = self.redis.lock(str(key), self.timeout, thread_local=False)", "successors": [{"id": 20, "label": "#20\nlock = self.locks[key]", "successors": [{"id": 18, "label": "#18\nlock.acquire()\nreturn lock", "successors": []}]}]}]}]}], "functions": [], "classes": []}, {"name": "release", "type": "CFG", "blocks": [{"id": 24, "label": "#24\nif (lock := self.locks.get(key)) and lock.locked() and lock.owned():", "successors": [{"id": 25, "label": "#25\nlock.release()", "successors": []}]}], "functions": [], "classes": []}, {"name": "release_all_locks", "type": "CFG", "blocks": [{"id": 29, "label": "#29\n\"\"\"Call this on process termination to ensure all locks are released\"\"\"\nself.locks_lock.acquire(blocking=False)", "successors": [{"id": 30, "label": "#30\nfor lock in self.locks.values():", "successors": [{"id": 31, "label": "#31\nif lock.locked() and lock.owned():", "successors": [{"id": 33, "label": "#33\nlock.release()", "successors": []}]}]}]}], "functions": [], "classes": []}], "classes": []}]}
{"file_name": "178.json", "name": "178.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport os\nfrom enum import Enum\nfrom typing import Literal\nimport replicate\nfrom pydantic import SecretStr\nfrom replicate.helpers import FileOutput\nfrom backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema\nfrom backend.data.model import APIKeyCredentials, CredentialsField, CredentialsMetaInput, SchemaField\nfrom backend.integrations.providers import ProviderName\nTEST_CREDENTIALS = APIKeyCredentials(id=\n    '01234567-89ab-cdef-0123-456789abcdef', provider='replicate', api_key=\n    SecretStr('mock-replicate-api-key'), title='Mock Replicate API key',\n    expires_at=None)\nTEST_CREDENTIALS_INPUT = {'provider': TEST_CREDENTIALS.provider, 'id':\n    TEST_CREDENTIALS.id, 'type': TEST_CREDENTIALS.type, 'title':\n    TEST_CREDENTIALS.type}", "successors": []}], "functions": [], "classes": [{"name": "ReplicateFluxModelName", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nFLUX_SCHNELL = 'Flux Schnell',\nFLUX_PRO = 'Flux Pro',\nFLUX_PRO1_1 = 'Flux Pro 1.1',", "successors": []}], "functions": [{"name": "api_name", "type": "CFG", "blocks": [{"id": 5, "label": "#5\napi_names = {ReplicateFluxModelName.FLUX_SCHNELL:\n    'black-forest-labs/flux-schnell', ReplicateFluxModelName.FLUX_PRO:\n    'black-forest-labs/flux-pro', ReplicateFluxModelName.FLUX_PRO1_1:\n    'black-forest-labs/flux-1.1-pro'}\nreturn api_names[self]", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "ImageType", "type": "CFG", "blocks": [{"id": 10, "label": "#10\nWEBP = 'webp'\nJPG = 'jpg'\nPNG = 'png'", "successors": []}], "functions": [], "classes": []}, {"name": "ReplicateFluxAdvancedModelBlock", "type": "CFG", "blocks": [{"id": 13, "label": "#13", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 21, "label": "#21\nsuper().__init__(id='90f8c45e-e983-4644-aa0b-b4ebe2f531bc', description=\n    'This block runs Flux models on Replicate with advanced settings.',\n    categories={BlockCategory.AI}, input_schema=\n    ReplicateFluxAdvancedModelBlock.Input, output_schema=\n    ReplicateFluxAdvancedModelBlock.Output, test_input={'credentials':\n    TEST_CREDENTIALS_INPUT, 'replicate_model_name': ReplicateFluxModelName.\n    FLUX_SCHNELL, 'prompt':\n    'A beautiful landscape painting of a serene lake at sunrise', 'seed':\n    None, 'steps': 25, 'guidance': 3.0, 'interval': 2.0, 'aspect_ratio':\n    '1:1', 'output_format': ImageType.PNG, 'output_quality': 80,\n    'safety_tolerance': 2}, test_output=[('result',\n    'https://replicate.com/output/generated-image-url.jpg')], test_mock={\n    'run_model': lambda api_key, model_name, prompt, seed, steps, guidance,\n    interval, aspect_ratio, output_format, output_quality, safety_tolerance:\n    'https://replicate.com/output/generated-image-url.jpg'},\n    test_credentials=TEST_CREDENTIALS)", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 24, "label": "#24\nseed = input_data.seed\nif seed is None:", "successors": [{"id": 25, "label": "#25\nseed = int.from_bytes(os.urandom(4), 'big')", "successors": [{"id": 26, "label": "#26\nresult = self.run_model(api_key=credentials.api_key, model_name=input_data.\n    replicate_model_name.api_name, prompt=input_data.prompt, seed=seed,\n    steps=input_data.steps, guidance=input_data.guidance, interval=\n    input_data.interval, aspect_ratio=input_data.aspect_ratio,\n    output_format=input_data.output_format, output_quality=input_data.\n    output_quality, safety_tolerance=input_data.safety_tolerance)\nyield 'result', result", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "run_model", "type": "CFG", "blocks": [{"id": 30, "label": "#30\nclient = replicate.Client(api_token=api_key.get_secret_value())\noutput: FileOutput | list[FileOutput] = client.run(f'{model_name}', input={\n    'prompt': prompt, 'seed': seed, 'steps': steps, 'guidance': guidance,\n    'interval': interval, 'aspect_ratio': aspect_ratio, 'output_format':\n    output_format, 'output_quality': output_quality, 'safety_tolerance':\n    safety_tolerance}, wait=False)\nif isinstance(output, list) and len(output) > 0:", "successors": [{"id": 31, "label": "#31\nif isinstance(output[0], FileOutput):", "successors": [{"id": 40, "label": "#40\nresult_url = output[0].url", "successors": [{"id": 32, "label": "#32\nreturn result_url", "successors": []}]}, {"id": 42, "label": "#42\nresult_url = output[0]", "successors": []}]}, {"id": 33, "label": "#33\nif isinstance(output, FileOutput):", "successors": [{"id": 34, "label": "#34\nresult_url = output.url", "successors": []}, {"id": 36, "label": "#36\nif isinstance(output, str):", "successors": [{"id": 37, "label": "#37\nresult_url = output", "successors": []}, {"id": 39, "label": "#39\nresult_url = 'No output received'", "successors": []}]}]}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 15, "label": "#15\ncredentials: CredentialsMetaInput[Literal[ProviderName.REPLICATE], Literal[\n    'api_key']] = CredentialsField(description=\n    'The Replicate integration can be used with any API key with sufficient permissions for the blocks it is used on.'\n    )\nprompt: str = SchemaField(description='Text prompt for image generation',\n    placeholder=\"e.g., 'A futuristic cityscape at sunset'\", title='Prompt')\nreplicate_model_name: ReplicateFluxModelName = SchemaField(description=\n    'The name of the Image Generation Model, i.e Flux Schnell', default=\n    ReplicateFluxModelName.FLUX_SCHNELL, title='Image Generation Model',\n    advanced=False)\nseed: int | None = SchemaField(description=\n    'Random seed. Set for reproducible generation', default=None, title='Seed')\nsteps: int = SchemaField(description='Number of diffusion steps', default=\n    25, title='Steps')\nguidance: float = SchemaField(description=\n    'Controls the balance between adherence to the text prompt and image quality/diversity. Higher values make the output more closely match the prompt but may reduce overall image quality.'\n    , default=3, title='Guidance')\ninterval: float = SchemaField(description=\n    'Interval is a setting that increases the variance in possible outputs. Setting this value low will ensure strong prompt following with more consistent outputs.'\n    , default=2, title='Interval')\naspect_ratio: str = SchemaField(description=\n    'Aspect ratio for the generated image', default='1:1', title=\n    'Aspect Ratio', placeholder=\n    'Choose from: 1:1, 16:9, 2:3, 3:2, 4:5, 5:4, 9:16')\noutput_format: ImageType = SchemaField(description=\n    'File format of the output image', default=ImageType.WEBP, title=\n    'Output Format')\noutput_quality: int = SchemaField(description=\n    'Quality when saving the output images, from 0 to 100. Not relevant for .png outputs'\n    , default=80, title='Output Quality')\nsafety_tolerance: int = SchemaField(description=\n    'Safety tolerance, 1 is most strict and 5 is most permissive', default=\n    2, title='Safety Tolerance')", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 18, "label": "#18\nresult: str = SchemaField(description='Generated output')\nerror: str = SchemaField(description='Error message if the model run failed')", "successors": []}], "functions": [], "classes": []}]}]}
{"file_name": "179.json", "name": "179.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom typing import List\nfrom backend.data.block import BlockOutput, BlockSchema\nfrom backend.data.model import APIKeyCredentials, SchemaField\nfrom ._api import TEST_CREDENTIALS, TEST_CREDENTIALS_INPUT, Filament, Slant3DCredentialsField, Slant3DCredentialsInput\nfrom .base import Slant3DBlockBase", "successors": []}], "functions": [], "classes": [{"name": "Slant3DFilamentBlock", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"Block for retrieving available filaments\"\"\"", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 11, "label": "#11\nsuper().__init__(id='7cc416f4-f305-4606-9b3b-452b8a81031c', description=\n    'Get list of available filaments', input_schema=self.Input,\n    output_schema=self.Output, test_input={'credentials':\n    TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output\n    =[('filaments', [{'filament': 'PLA BLACK', 'hexColor': '000000',\n    'colorTag': 'black', 'profile': 'PLA'}, {'filament': 'PLA WHITE',\n    'hexColor': 'ffffff', 'colorTag': 'white', 'profile': 'PLA'}])],\n    test_mock={'_make_request': lambda *args, **kwargs: {'filaments': [{\n    'filament': 'PLA BLACK', 'hexColor': '000000', 'colorTag': 'black',\n    'profile': 'PLA'}, {'filament': 'PLA WHITE', 'hexColor': 'ffffff',\n    'colorTag': 'white', 'profile': 'PLA'}]}})", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 14, "label": "#14\ntry:", "successors": [{"id": 15, "label": "#15\nresult = self._make_request('GET', 'filament', credentials.api_key.\n    get_secret_value())\nyield 'filaments', result['filaments']", "successors": []}, {"id": 16, "label": "#16\nyield 'error', str(e)", "successors": [{"id": 19, "label": "#19\nraise", "successors": []}]}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 5, "label": "#5\ncredentials: Slant3DCredentialsInput = Slant3DCredentialsField()", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 8, "label": "#8\nfilaments: List[Filament] = SchemaField(description=\n    'List of available filaments')\nerror: str = SchemaField(description='Error message if request failed')", "successors": []}], "functions": [], "classes": []}]}]}
{"file_name": "180.json", "name": "180.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport logging\nfrom typing import Optional, cast\nfrom autogpt_libs.auth.models import DEFAULT_USER_ID\nfrom fastapi import HTTPException\nfrom prisma import Json\nfrom prisma.models import User\nfrom backend.data.db import prisma\nfrom backend.data.model import UserIntegrations, UserMetadata, UserMetadataRaw\nfrom backend.util.encryption import JSONCryptor\nlogger = logging.getLogger(__name__)", "successors": []}], "functions": [{"name": "get_or_create_user", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nuser_id = user_data.get('sub')\nif not user_id:", "successors": [{"id": 4, "label": "#4\nraise HTTPException(status_code=401, detail='User ID not found in token')", "successors": []}, {"id": 5, "label": "#5\nuser_email = user_data.get('email')\nif not user_email:", "successors": [{"id": 7, "label": "#7\nraise HTTPException(status_code=401, detail='Email not found in token')", "successors": []}, {"id": 8, "label": "#8\nuser = await prisma.user.find_unique(where={'id': user_id})", "successors": [{"id": 10, "label": "#10\nif not user:", "successors": [{"id": 11, "label": "#11\nuser = await prisma.user.create(data={'id': user_id, 'email': user_email,\n    'name': user_data.get('user_metadata', {}).get('name')})", "successors": [{"id": 12, "label": "#12\nreturn User.model_validate(user)", "successors": []}]}]}]}]}]}], "functions": [], "classes": []}, {"name": "get_user_by_id", "type": "CFG", "blocks": [{"id": 17, "label": "#17\nuser = await prisma.user.find_unique(where={'id': user_id})", "successors": [{"id": 18, "label": "#18\nreturn User.model_validate(user) if user else None", "successors": []}]}], "functions": [], "classes": []}, {"name": "create_default_user", "type": "CFG", "blocks": [{"id": 22, "label": "#22\nuser = await prisma.user.find_unique(where={'id': DEFAULT_USER_ID})", "successors": [{"id": 23, "label": "#23\nif not user:", "successors": [{"id": 24, "label": "#24\nuser = await prisma.user.create(data={'id': DEFAULT_USER_ID, 'email':\n    'default@example.com', 'name': 'Default User'})", "successors": [{"id": 25, "label": "#25\nreturn User.model_validate(user)", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "get_user_metadata", "type": "CFG", "blocks": [{"id": 30, "label": "#30\nuser = await User.prisma().find_unique_or_raise(where={'id': user_id})", "successors": [{"id": 31, "label": "#31\nmetadata = cast(UserMetadataRaw, user.metadata)\nreturn UserMetadata.model_validate(metadata)", "successors": []}]}], "functions": [], "classes": []}, {"name": "update_user_metadata", "type": "CFG", "blocks": [{"id": 35, "label": "#35\nawait User.prisma().update(where={'id': user_id}, data={'metadata': Json(\n    metadata.model_dump())})", "successors": []}], "functions": [], "classes": []}, {"name": "get_user_integrations", "type": "CFG", "blocks": [{"id": 39, "label": "#39\nuser = await User.prisma().find_unique_or_raise(where={'id': user_id})", "successors": [{"id": 40, "label": "#40\nencrypted_integrations = user.integrations\nif not encrypted_integrations:", "successors": [{"id": 41, "label": "#41\nreturn UserIntegrations()", "successors": []}, {"id": 43, "label": "#43\nreturn UserIntegrations.model_validate(JSONCryptor().decrypt(\n    encrypted_integrations))", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "update_user_integrations", "type": "CFG", "blocks": [{"id": 48, "label": "#48\nencrypted_data = JSONCryptor().encrypt(data.model_dump())\nawait User.prisma().update(where={'id': user_id}, data={'integrations':\n    encrypted_data})", "successors": []}], "functions": [], "classes": []}, {"name": "migrate_and_encrypt_user_integrations", "type": "CFG", "blocks": [{"id": 52, "label": "#52\n\"\"\"Migrate integration credentials and OAuth states from metadata to integrations column.\"\"\"\nusers = await User.prisma().find_many(where={'metadata': {'path': [\n    'integration_credentials'], 'not': Json({'a': 'yolo'})}})", "successors": [{"id": 53, "label": "#53\nlogger.info(f'Migrating integration credentials for {len(users)} users')", "successors": [{"id": 54, "label": "#54\nfor user in users:", "successors": [{"id": 55, "label": "#55\nraw_metadata = cast(UserMetadataRaw, user.metadata)\nmetadata = UserMetadata.model_validate(raw_metadata)\nintegrations = await get_user_integrations(user_id=user.id)", "successors": [{"id": 57, "label": "#57\nif metadata.integration_credentials and not integrations.credentials:", "successors": [{"id": 58, "label": "#58\nintegrations.credentials = metadata.integration_credentials", "successors": [{"id": 59, "label": "#59\nif metadata.integration_oauth_states:", "successors": [{"id": 60, "label": "#60\nintegrations.oauth_states = metadata.integration_oauth_states", "successors": [{"id": 61, "label": "#61\nawait update_user_integrations(user_id=user.id, data=integrations)", "successors": [{"id": 62, "label": "#62\nraw_metadata = dict(raw_metadata)\nraw_metadata.pop('integration_credentials', None)\nraw_metadata.pop('integration_oauth_states', None)\nawait User.prisma().update(where={'id': user.id}, data={'metadata': Json(\n    raw_metadata)})", "successors": []}]}]}]}]}]}]}]}]}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "181.json", "name": "181.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport logging\nimport secrets\nfrom abc import ABC, abstractmethod\nfrom typing import ClassVar, Generic, Optional, TypeVar\nfrom uuid import uuid4\nfrom fastapi import Request\nfrom strenum import StrEnum\nfrom backend.data import integrations\nfrom backend.data.model import Credentials\nfrom backend.integrations.providers import ProviderName\nfrom backend.integrations.webhooks.utils import webhook_ingress_url\nfrom backend.util.exceptions import MissingConfigError\nfrom backend.util.settings import Config\nlogger = logging.getLogger(__name__)\napp_config = Config()\nWT = TypeVar('WT', bound=StrEnum)", "successors": []}], "functions": [], "classes": [{"name": "BaseWebhooksManager", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nPROVIDER_NAME: ClassVar[ProviderName]\nWebhookType: WT", "successors": []}], "functions": [{"name": "get_suitable_auto_webhook", "type": "CFG", "blocks": [{"id": 5, "label": "#5\nif not app_config.platform_base_url:", "successors": [{"id": 6, "label": "#6\nraise MissingConfigError(\n    'PLATFORM_BASE_URL must be set to use Webhook functionality')", "successors": []}, {"id": 7, "label": "#7\nif (webhook := await integrations.find_webhook_by_credentials_and_props(", "successors": [{"id": 9, "label": "#9\nreturn webhook", "successors": []}, {"id": 10, "label": "#10\nreturn await self._create_webhook(user_id, webhook_type, events, resource,\n    credentials)", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "get_manual_webhook", "type": "CFG", "blocks": [{"id": 15, "label": "#15\nif (current_webhook := await integrations.find_webhook_by_graph_and_props(", "successors": [{"id": 16, "label": "#16\nreturn current_webhook", "successors": []}, {"id": 17, "label": "#17\nreturn await self._create_webhook(user_id, webhook_type, events, register=False\n    )", "successors": []}]}], "functions": [], "classes": []}, {"name": "prune_webhook_if_dangling", "type": "CFG", "blocks": [{"id": 22, "label": "#22\nwebhook = await integrations.get_webhook(webhook_id)", "successors": [{"id": 23, "label": "#23\nif webhook.attached_nodes is None:", "successors": [{"id": 24, "label": "#24\nraise ValueError('Error retrieving webhook including attached nodes')", "successors": []}, {"id": 25, "label": "#25\nif webhook.attached_nodes:", "successors": [{"id": 27, "label": "#27\nreturn False", "successors": []}, {"id": 28, "label": "#28\nif credentials:", "successors": [{"id": 30, "label": "#30\nawait self._deregister_webhook(webhook, credentials)", "successors": [{"id": 31, "label": "#31\nawait integrations.delete_webhook(webhook.id)", "successors": [{"id": 33, "label": "#33\nreturn True", "successors": []}]}]}]}]}]}]}], "functions": [], "classes": []}, {"name": "validate_payload", "type": "CFG", "blocks": [{"id": 37, "label": "#37\n\"\"\"\n        Validates an incoming webhook request and returns its payload and type.\n\n        Params:\n            webhook: Object representing the configured webhook and its properties in our system.\n            request: Incoming FastAPI `Request`\n\n        Returns:\n            dict: The validated payload\n            str: The event type associated with the payload\n        \"\"\"", "successors": []}], "functions": [], "classes": []}, {"name": "trigger_ping", "type": "CFG", "blocks": [{"id": 40, "label": "#40\n\"\"\"\n        Triggers a ping to the given webhook.\n\n        Raises:\n            NotImplementedError: if the provider doesn't support pinging\n        \"\"\"\nraise NotImplementedError(f\"{self.__class__.__name__} doesn't support pinging\")", "successors": []}], "functions": [], "classes": []}, {"name": "_register_webhook", "type": "CFG", "blocks": [{"id": 44, "label": "#44\n\"\"\"\n        Registers a new webhook with the provider.\n\n        Params:\n            credentials: The credentials with which to create the webhook\n            webhook_type: The provider-specific webhook type to create\n            resource: The resource to receive events for\n            events: The events to subscribe to\n            ingress_url: The ingress URL for webhook payloads\n            secret: Secret used to verify webhook payloads\n\n        Returns:\n            str: Webhook ID assigned by the provider\n            config: Provider-specific configuration for the webhook\n        \"\"\"", "successors": []}], "functions": [], "classes": []}, {"name": "_deregister_webhook", "type": "CFG", "blocks": [{"id": 47, "label": "#47", "successors": []}], "functions": [], "classes": []}, {"name": "_create_webhook", "type": "CFG", "blocks": [{"id": 50, "label": "#50\nif not app_config.platform_base_url:", "successors": [{"id": 51, "label": "#51\nraise MissingConfigError(\n    'PLATFORM_BASE_URL must be set to use Webhook functionality')", "successors": []}, {"id": 52, "label": "#52\nid = str(uuid4())\nsecret = secrets.token_hex(32)\nprovider_name = self.PROVIDER_NAME\ningress_url = webhook_ingress_url(provider_name=provider_name, webhook_id=id)\nif register:", "successors": [{"id": 54, "label": "#54\nif not credentials:", "successors": [{"id": 57, "label": "#57\nraise TypeError('credentials are required if register = True')", "successors": []}, {"id": 58, "label": "#58\nprovider_webhook_id, config = await self._register_webhook(credentials,\n    webhook_type, resource, events, ingress_url, secret)", "successors": [{"id": 55, "label": "#55\nreturn await integrations.create_webhook(integrations.Webhook(id=id,\n    user_id=user_id, provider=provider_name, credentials_id=credentials.id if\n    credentials else '', webhook_type=webhook_type, resource=resource,\n    events=events, provider_webhook_id=provider_webhook_id, config=config,\n    secret=secret))", "successors": []}]}]}, {"id": 56, "label": "#56\nprovider_webhook_id, config = '', {}", "successors": []}]}]}], "functions": [], "classes": []}], "classes": []}]}
{"file_name": "182.json", "name": "182.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom enum import Enum\nseller_category_map = {}\nseller_category_map['Exxon'] = DefaultCategories.GAS\nseller_category_map['Target'] = DefaultCategories.SHOPPING", "successors": []}], "functions": [], "classes": [{"name": "DefaultCategories", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nHOUSING = 0\nFOOD = 1\nGAS = 2\nSHOPPING = 3", "successors": []}], "functions": [], "classes": []}, {"name": "Categorizer", "type": "CFG", "blocks": [{"id": 6, "label": "#6", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 8, "label": "#8\nself.seller_category_map = seller_category_map\nself.seller_category_overrides_map = seller_category_overrides_map", "successors": []}], "functions": [], "classes": []}, {"name": "categorize", "type": "CFG", "blocks": [{"id": 11, "label": "#11\nif transaction.seller in self.seller_category_map:", "successors": [{"id": 12, "label": "#12\nreturn self.seller_category_map[transaction.seller]", "successors": []}, {"id": 13, "label": "#13\nif transaction.seller in self.seller_category_overrides_map:", "successors": [{"id": 15, "label": "#15\nseller_category_map[transaction.seller] = self.manual_overrides[transaction\n    .seller].peek_min()\nreturn self.seller_category_map[transaction.seller]", "successors": []}, {"id": 16, "label": "#16\nreturn None", "successors": []}]}]}], "functions": [], "classes": []}], "classes": []}, {"name": "Transaction", "type": "CFG", "blocks": [{"id": 22, "label": "#22", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 24, "label": "#24\nself.timestamp = timestamp\nself.seller = seller\nself.amount = amount", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "Budget", "type": "CFG", "blocks": [{"id": 28, "label": "#28", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 30, "label": "#30\nself.categories_to_budget_map = template_categories_to_budget_map", "successors": []}], "functions": [], "classes": []}, {"name": "override_category_budget", "type": "CFG", "blocks": [{"id": 33, "label": "#33\nself.categories_to_budget_map[category] = amount", "successors": []}], "functions": [], "classes": []}], "classes": []}]}
{"file_name": "183.json", "name": "183.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1", "successors": []}], "functions": [], "classes": [{"name": "Item", "type": "CFG", "blocks": [{"id": 3, "label": "#3", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 5, "label": "#5\nself.key = key\nself.value = value", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "HashTable", "type": "CFG", "blocks": [{"id": 9, "label": "#9", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 11, "label": "#11\nself.size = size\nself.table = [[] for _ in range(self.size)]", "successors": []}], "functions": [], "classes": []}, {"name": "_hash_function", "type": "CFG", "blocks": [{"id": 14, "label": "#14\nreturn key % self.size", "successors": []}], "functions": [], "classes": []}, {"name": "set", "type": "CFG", "blocks": [{"id": 18, "label": "#18\nhash_index = self._hash_function(key)", "successors": [{"id": 19, "label": "#19\nfor item in self.table[hash_index]:", "successors": [{"id": 20, "label": "#20\nif item.key == key:", "successors": [{"id": 22, "label": "#22\nitem.value = value\nreturn", "successors": []}]}, {"id": 21, "label": "#21\nself.table[hash_index].append(Item(key, value))", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "get", "type": "CFG", "blocks": [{"id": 27, "label": "#27\nhash_index = self._hash_function(key)", "successors": [{"id": 28, "label": "#28\nfor item in self.table[hash_index]:", "successors": [{"id": 29, "label": "#29\nif item.key == key:", "successors": [{"id": 31, "label": "#31\nreturn item.value", "successors": []}]}, {"id": 30, "label": "#30\nraise KeyError('Key not found')", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "remove", "type": "CFG", "blocks": [{"id": 37, "label": "#37\nhash_index = self._hash_function(key)", "successors": [{"id": 38, "label": "#38\nfor index, item in enumerate(self.table[hash_index]):", "successors": [{"id": 39, "label": "#39\nif item.key == key:", "successors": [{"id": 41, "label": "#41\ndel self.table[hash_index][index]\nreturn", "successors": []}]}, {"id": 40, "label": "#40\nraise KeyError('Key not found')", "successors": []}]}]}], "functions": [], "classes": []}], "classes": []}]}
{"file_name": "184.json", "name": "184.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom typing import Dict, Set\nfrom fastapi import WebSocket\nfrom backend.data import execution\nfrom backend.server.model import Methods, WsMessage", "successors": []}], "functions": [], "classes": [{"name": "ConnectionManager", "type": "CFG", "blocks": [{"id": 3, "label": "#3", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 5, "label": "#5\nself.active_connections: Set[WebSocket] = set()\nself.subscriptions: Dict[str, Set[WebSocket]] = {}", "successors": []}], "functions": [], "classes": []}, {"name": "connect", "type": "CFG", "blocks": [{"id": 8, "label": "#8\nawait websocket.accept()", "successors": [{"id": 9, "label": "#9\nself.active_connections.add(websocket)", "successors": []}]}], "functions": [], "classes": []}, {"name": "disconnect", "type": "CFG", "blocks": [{"id": 12, "label": "#12\nself.active_connections.remove(websocket)", "successors": [{"id": 13, "label": "#13\nfor subscribers in self.subscriptions.values():", "successors": [{"id": 14, "label": "#14\nsubscribers.discard(websocket)", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "subscribe", "type": "CFG", "blocks": [{"id": 18, "label": "#18\nif graph_id not in self.subscriptions:", "successors": [{"id": 19, "label": "#19\nself.subscriptions[graph_id] = set()", "successors": [{"id": 20, "label": "#20\nself.subscriptions[graph_id].add(websocket)", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "unsubscribe", "type": "CFG", "blocks": [{"id": 23, "label": "#23\nif graph_id in self.subscriptions:", "successors": [{"id": 24, "label": "#24\nself.subscriptions[graph_id].discard(websocket)\nif not self.subscriptions[graph_id]:", "successors": [{"id": 26, "label": "#26\ndel self.subscriptions[graph_id]", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "send_execution_result", "type": "CFG", "blocks": [{"id": 30, "label": "#30\ngraph_id = result.graph_id\nif graph_id in self.subscriptions:", "successors": [{"id": 31, "label": "#31\nmessage = WsMessage(method=Methods.EXECUTION_EVENT, channel=graph_id, data=\n    result.model_dump()).model_dump_json()", "successors": [{"id": 33, "label": "#33\nfor connection in self.subscriptions[graph_id]:", "successors": [{"id": 34, "label": "#34\nawait connection.send_text(message)", "successors": []}]}]}]}], "functions": [], "classes": []}], "classes": []}]}
{"file_name": "185.json", "name": "185.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\n\"\"\"\nIn this problem, we want to determine all possible combinations of k\n\nTime complexity: O(C(n,k)) which is O(n choose k) = O((n!/(k! * (n - k)!))),\n\"\"\"\nfrom __future__ import annotations\nfrom itertools import combinations\nif __name__ == '__main__':", "successors": [{"id": 24, "label": "#24\nfrom doctest import testmod\ntestmod()\nprint(generate_all_combinations(n=4, k=2))\ntests = ((n, k) for n in range(1, 5) for k in range(1, 5))", "successors": [{"id": 26, "label": "#26\nfor n, k in tests:", "successors": [{"id": 27, "label": "#27\nprint(n, k, generate_all_combinations(n, k) == combination_lists(n, k))", "successors": []}, {"id": 28, "label": "#28\nprint('Benchmark:')\nfrom timeit import timeit", "successors": [{"id": 29, "label": "#29\nfor func in ('combination_lists', 'generate_all_combinations'):", "successors": [{"id": 30, "label": "#30\nprint(f\"{func:>25}(): {timeit(f'{func}(n=4, k = 2)', globals=globals())}\")", "successors": []}]}]}]}]}]}], "functions": [{"name": "combination_lists", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"\n    >>> combination_lists(n=4, k=2)\n    [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n    \"\"\"\nreturn [list(x) for x in combinations(range(1, n + 1), k)]", "successors": []}], "functions": [], "classes": []}, {"name": "generate_all_combinations", "type": "CFG", "blocks": [{"id": 7, "label": "#7\n\"\"\"\n    >>> generate_all_combinations(n=4, k=2)\n    [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n    >>> generate_all_combinations(n=0, k=0)\n    [[]]\n    >>> generate_all_combinations(n=10, k=-1)\n    Traceback (most recent call last):\n    ValueError: k must not be negative\n    >>> generate_all_combinations(n=-1, k=10)\n    Traceback (most recent call last):\n    ValueError: n must not be negative\n    >>> generate_all_combinations(n=5, k=4)\n    [[1, 2, 3, 4], [1, 2, 3, 5], [1, 2, 4, 5], [1, 3, 4, 5], [2, 3, 4, 5]]\n    >>> from itertools import combinations\n    >>> all(generate_all_combinations(n, k) == combination_lists(n, k)\n    True\n    \"\"\"\nif k < 0:", "successors": [{"id": 8, "label": "#8\nraise ValueError('k must not be negative')", "successors": []}, {"id": 9, "label": "#9\nif n < 0:", "successors": [{"id": 11, "label": "#11\nraise ValueError('n must not be negative')", "successors": []}, {"id": 12, "label": "#12\nresult: list[list[int]] = []\ncreate_all_state(1, n, k, [], result)\nreturn result", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "create_all_state", "type": "CFG", "blocks": [{"id": 17, "label": "#17\nif level == 0:", "successors": [{"id": 18, "label": "#18\ntotal_list.append(current_list[:])\nreturn", "successors": []}, {"id": 19, "label": "#19\nfor i in range(increment, total_number - level + 2):", "successors": [{"id": 21, "label": "#21\ncurrent_list.append(i)\ncreate_all_state(i + 1, total_number, level - 1, current_list, total_list)\ncurrent_list.pop()", "successors": []}]}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "186.json", "name": "186.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport ast\nimport logging\nfrom enum import Enum, EnumMeta\nfrom json import JSONDecodeError\nfrom types import MappingProxyType\nfrom typing import TYPE_CHECKING, Any, List, Literal, NamedTuple\nfrom pydantic import SecretStr\nfrom backend.integrations.providers import ProviderName\nif TYPE_CHECKING:", "successors": [{"id": 2, "label": "#2\nfrom enum import _EnumMemberT", "successors": [{"id": 3, "label": "#3\nimport anthropic\nimport ollama\nimport openai\nfrom groq import Groq\nfrom backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema\nfrom backend.data.model import APIKeyCredentials, CredentialsField, CredentialsMetaInput, SchemaField\nfrom backend.util import json\nfrom backend.util.settings import BehaveAs, Settings\nlogger = logging.getLogger(__name__)\nLLMProviderName = Literal[ProviderName.ANTHROPIC, ProviderName.GROQ,\n    ProviderName.OLLAMA, ProviderName.OPENAI, ProviderName.OPEN_ROUTER]\nAICredentials = CredentialsMetaInput[LLMProviderName, Literal['api_key']]\nTEST_CREDENTIALS = APIKeyCredentials(id=\n    'ed55ac19-356e-4243-a6cb-bc599e9b716f', provider='openai', api_key=\n    SecretStr('mock-openai-api-key'), title='Mock OpenAI API key',\n    expires_at=None)\nTEST_CREDENTIALS_INPUT = {'provider': TEST_CREDENTIALS.provider, 'id':\n    TEST_CREDENTIALS.id, 'type': TEST_CREDENTIALS.type, 'title':\n    TEST_CREDENTIALS.title}\nMODEL_METADATA = {LlmModel.O1_PREVIEW: ModelMetadata('openai', 32000),\n    LlmModel.O1_MINI: ModelMetadata('openai', 62000), LlmModel.GPT4O_MINI:\n    ModelMetadata('openai', 128000), LlmModel.GPT4O: ModelMetadata('openai',\n    128000), LlmModel.GPT4_TURBO: ModelMetadata('openai', 128000), LlmModel\n    .GPT3_5_TURBO: ModelMetadata('openai', 16385), LlmModel.\n    CLAUDE_3_5_SONNET: ModelMetadata('anthropic', 200000), LlmModel.\n    CLAUDE_3_HAIKU: ModelMetadata('anthropic', 200000), LlmModel.LLAMA3_8B:\n    ModelMetadata('groq', 8192), LlmModel.LLAMA3_70B: ModelMetadata('groq',\n    8192), LlmModel.MIXTRAL_8X7B: ModelMetadata('groq', 32768), LlmModel.\n    GEMMA_7B: ModelMetadata('groq', 8192), LlmModel.GEMMA2_9B:\n    ModelMetadata('groq', 8192), LlmModel.LLAMA3_1_405B: ModelMetadata(\n    'groq', 8192), LlmModel.LLAMA3_1_70B: ModelMetadata('groq', 131072),\n    LlmModel.LLAMA3_1_8B: ModelMetadata('groq', 131072), LlmModel.\n    OLLAMA_LLAMA3_8B: ModelMetadata('ollama', 8192), LlmModel.\n    OLLAMA_LLAMA3_405B: ModelMetadata('ollama', 8192), LlmModel.\n    OLLAMA_DOLPHIN: ModelMetadata('ollama', 32768), LlmModel.\n    GEMINI_FLASH_1_5_8B: ModelMetadata('open_router', 8192), LlmModel.\n    GROK_BETA: ModelMetadata('open_router', 8192), LlmModel.MISTRAL_NEMO:\n    ModelMetadata('open_router', 4000), LlmModel.COHERE_COMMAND_R_08_2024:\n    ModelMetadata('open_router', 4000), LlmModel.\n    COHERE_COMMAND_R_PLUS_08_2024: ModelMetadata('open_router', 4000),\n    LlmModel.EVA_QWEN_2_5_32B: ModelMetadata('open_router', 4000), LlmModel\n    .DEEPSEEK_CHAT: ModelMetadata('open_router', 8192), LlmModel.\n    PERPLEXITY_LLAMA_3_1_SONAR_LARGE_128K_ONLINE: ModelMetadata(\n    'open_router', 8192), LlmModel.QWEN_QWQ_32B_PREVIEW: ModelMetadata(\n    'open_router', 4000), LlmModel.NOUSRESEARCH_HERMES_3_LLAMA_3_1_405B:\n    ModelMetadata('open_router', 4000), LlmModel.\n    NOUSRESEARCH_HERMES_3_LLAMA_3_1_70B: ModelMetadata('open_router', 4000),\n    LlmModel.AMAZON_NOVA_LITE_V1: ModelMetadata('open_router', 4000),\n    LlmModel.AMAZON_NOVA_MICRO_V1: ModelMetadata('open_router', 4000),\n    LlmModel.AMAZON_NOVA_PRO_V1: ModelMetadata('open_router', 4000),\n    LlmModel.MICROSOFT_WIZARDLM_2_8X22B: ModelMetadata('open_router', 4000),\n    LlmModel.GRYPHE_MYTHOMAX_L2_13B: ModelMetadata('open_router', 4000)}", "successors": [{"id": 37, "label": "#37\nfor model in LlmModel:", "successors": [{"id": 38, "label": "#38\nif model not in MODEL_METADATA:", "successors": [{"id": 40, "label": "#40\nraise ValueError(f'Missing MODEL_METADATA metadata for model: {model}')", "successors": []}]}, {"id": 39, "label": "#39", "successors": []}]}]}]}]}], "functions": [{"name": "AICredentialsField", "type": "CFG", "blocks": [{"id": 5, "label": "#5\nreturn CredentialsField(description='API key for the LLM provider.',\n    discriminator='model', discriminator_mapping={model.value: model.\n    metadata.provider for model in LlmModel})", "successors": []}], "functions": [], "classes": []}], "classes": [{"name": "ModelMetadata", "type": "CFG", "blocks": [{"id": 9, "label": "#9\nprovider: str\ncontext_window: int", "successors": []}], "functions": [], "classes": []}, {"name": "LlmModelMeta", "type": "CFG", "blocks": [{"id": 12, "label": "#12", "successors": []}], "functions": [{"name": "__members__", "type": "CFG", "blocks": [{"id": 14, "label": "#14\nif Settings().config.behave_as == BehaveAs.LOCAL:", "successors": [{"id": 15, "label": "#15\nmembers = super().__members__\nreturn members", "successors": []}, {"id": 17, "label": "#17\nremoved_providers = ['ollama']\nexisting_members = super().__members__\nmembers = {name: member for name, member in existing_members.items() if \n    LlmModel[name].provider not in removed_providers}\nreturn MappingProxyType(members)", "successors": []}]}], "functions": [], "classes": []}], "classes": []}, {"name": "LlmModel", "type": "CFG", "blocks": [{"id": 23, "label": "#23\nO1_PREVIEW = 'o1-preview'\nO1_MINI = 'o1-mini'\nGPT4O_MINI = 'gpt-4o-mini'\nGPT4O = 'gpt-4o'\nGPT4_TURBO = 'gpt-4-turbo'\nGPT3_5_TURBO = 'gpt-3.5-turbo'\nCLAUDE_3_5_SONNET = 'claude-3-5-sonnet-latest'\nCLAUDE_3_HAIKU = 'claude-3-haiku-20240307'\nLLAMA3_8B = 'llama3-8b-8192'\nLLAMA3_70B = 'llama3-70b-8192'\nMIXTRAL_8X7B = 'mixtral-8x7b-32768'\nGEMMA_7B = 'gemma-7b-it'\nGEMMA2_9B = 'gemma2-9b-it'\nLLAMA3_1_405B = 'llama-3.1-405b-reasoning'\nLLAMA3_1_70B = 'llama-3.1-70b-versatile'\nLLAMA3_1_8B = 'llama-3.1-8b-instant'\nOLLAMA_LLAMA3_8B = 'llama3'\nOLLAMA_LLAMA3_405B = 'llama3.1:405b'\nOLLAMA_DOLPHIN = 'dolphin-mistral:latest'\nGEMINI_FLASH_1_5_8B = 'google/gemini-flash-1.5'\nGROK_BETA = 'x-ai/grok-beta'\nMISTRAL_NEMO = 'mistralai/mistral-nemo'\nCOHERE_COMMAND_R_08_2024 = 'cohere/command-r-08-2024'\nCOHERE_COMMAND_R_PLUS_08_2024 = 'cohere/command-r-plus-08-2024'\nEVA_QWEN_2_5_32B = 'eva-unit-01/eva-qwen-2.5-32b'\nDEEPSEEK_CHAT = 'deepseek/deepseek-chat'\nPERPLEXITY_LLAMA_3_1_SONAR_LARGE_128K_ONLINE = (\n    'perplexity/llama-3.1-sonar-large-128k-online')\nQWEN_QWQ_32B_PREVIEW = 'qwen/qwq-32b-preview'\nNOUSRESEARCH_HERMES_3_LLAMA_3_1_405B = 'nousresearch/hermes-3-llama-3.1-405b'\nNOUSRESEARCH_HERMES_3_LLAMA_3_1_70B = 'nousresearch/hermes-3-llama-3.1-70b'\nAMAZON_NOVA_LITE_V1 = 'amazon/nova-lite-v1'\nAMAZON_NOVA_MICRO_V1 = 'amazon/nova-micro-v1'\nAMAZON_NOVA_PRO_V1 = 'amazon/nova-pro-v1'\nMICROSOFT_WIZARDLM_2_8X22B = 'microsoft/wizardlm-2-8x22b'\nGRYPHE_MYTHOMAX_L2_13B = 'gryphe/mythomax-l2-13b'", "successors": []}], "functions": [{"name": "metadata", "type": "CFG", "blocks": [{"id": 25, "label": "#25\nreturn MODEL_METADATA[self]", "successors": []}], "functions": [], "classes": []}, {"name": "provider", "type": "CFG", "blocks": [{"id": 29, "label": "#29\nreturn self.metadata.provider", "successors": []}], "functions": [], "classes": []}, {"name": "context_window", "type": "CFG", "blocks": [{"id": 33, "label": "#33\nreturn self.metadata.context_window", "successors": []}], "functions": [], "classes": []}], "classes": []}, {"name": "MessageRole", "type": "CFG", "blocks": [{"id": 44, "label": "#44\nSYSTEM = 'system'\nUSER = 'user'\nASSISTANT = 'assistant'", "successors": []}], "functions": [], "classes": []}, {"name": "Message", "type": "CFG", "blocks": [{"id": 47, "label": "#47\nrole: MessageRole\ncontent: str", "successors": []}], "functions": [], "classes": []}, {"name": "AIStructuredResponseGeneratorBlock", "type": "CFG", "blocks": [{"id": 50, "label": "#50", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 58, "label": "#58\nsuper().__init__(id='ed55ac19-356e-4243-a6cb-bc599e9b716f', description=\n    'Call a Large Language Model (LLM) to generate formatted object based on the given prompt.'\n    , categories={BlockCategory.AI}, input_schema=\n    AIStructuredResponseGeneratorBlock.Input, output_schema=\n    AIStructuredResponseGeneratorBlock.Output, test_input={'model':\n    LlmModel.GPT4_TURBO, 'credentials': TEST_CREDENTIALS_INPUT,\n    'expected_format': {'key1': 'value1', 'key2': 'value2'}, 'prompt':\n    'User prompt'}, test_credentials=TEST_CREDENTIALS, test_output=(\n    'response', {'key1': 'key1Value', 'key2': 'key2Value'}), test_mock={\n    'llm_call': lambda *args, **kwargs: (json.dumps({'key1': 'key1Value',\n    'key2': 'key2Value'}), 0, 0)})", "successors": []}], "functions": [], "classes": []}, {"name": "llm_call", "type": "CFG", "blocks": [{"id": 61, "label": "#61\n\"\"\"\n        Args:\n            api_key: API key for the LLM provider.\n            llm_model: The LLM model to use.\n            prompt: The prompt to send to the LLM.\n            json_format: Whether the response should be in JSON format.\n            max_tokens: The maximum number of tokens to generate in the chat completion.\n            ollama_host: The host for ollama to use\n\n        Returns:\n            The response from the LLM.\n            The number of tokens used in the prompt.\n            The number of tokens used in the completion.\n        \"\"\"\nprovider = llm_model.metadata.provider\nif provider == 'openai':", "successors": [{"id": 62, "label": "#62\noai_client = openai.OpenAI(api_key=credentials.api_key.get_secret_value())\nresponse_format = None\nif llm_model in [LlmModel.O1_MINI, LlmModel.O1_PREVIEW]:", "successors": [{"id": 104, "label": "#104\nsys_messages = [p['content'] for p in prompt if p['role'] == 'system']\nusr_messages = [p['content'] for p in prompt if p['role'] != 'system']\nprompt = [{'role': 'user', 'content': '\\n'.join(sys_messages)}, {'role':\n    'user', 'content': '\\n'.join(usr_messages)}]", "successors": [{"id": 105, "label": "#105\nresponse = oai_client.chat.completions.create(model=llm_model.value,\n    messages=prompt, response_format=response_format, max_completion_tokens\n    =max_tokens)\nreturn response.choices[0\n    ].message.content or '', response.usage.prompt_tokens if response.usage else 0, response.usage.completion_tokens if response.usage else 0", "successors": []}]}, {"id": 106, "label": "#106\nif json_format:", "successors": [{"id": 107, "label": "#107\nresponse_format = {'type': 'json_object'}", "successors": []}]}]}, {"id": 64, "label": "#64\nif provider == 'anthropic':", "successors": [{"id": 65, "label": "#65\nsystem_messages = [p['content'] for p in prompt if p['role'] == 'system']\nsysprompt = ' '.join(system_messages)\nmessages = []\nlast_role = None", "successors": [{"id": 88, "label": "#88\nfor p in prompt:", "successors": [{"id": 89, "label": "#89\nif p['role'] in ['user', 'assistant']:", "successors": [{"id": 91, "label": "#91\nif p['role'] != last_role:", "successors": [{"id": 93, "label": "#93\nmessages.append({'role': p['role'], 'content': p['content']})\nlast_role = p['role']", "successors": []}, {"id": 95, "label": "#95\nmessages[-1]['content'] += '\\n' + p['content']", "successors": []}]}]}, {"id": 90, "label": "#90\nclient = anthropic.Anthropic(api_key=credentials.api_key.get_secret_value())\ntry:", "successors": [{"id": 96, "label": "#96\nresp = client.messages.create(model=llm_model.value, system=sysprompt,\n    messages=messages, max_tokens=max_tokens or 8192)\nif not resp.content:", "successors": [{"id": 99, "label": "#99\nraise ValueError('No content returned from Anthropic.')", "successors": []}, {"id": 100, "label": "#100\nreturn resp.content[0].name if isinstance(resp.content[0], anthropic.types.\n    ToolUseBlock) else resp.content[0\n    ].text, resp.usage.input_tokens, resp.usage.output_tokens", "successors": []}]}, {"id": 97, "label": "#97\nerror_message = f'Anthropic API error: {str(e)}'\nlogger.error(error_message)\nraise ValueError(error_message)", "successors": []}]}]}]}, {"id": 67, "label": "#67\nif provider == 'groq':", "successors": [{"id": 68, "label": "#68\nclient = Groq(api_key=credentials.api_key.get_secret_value())\nresponse_format = {'type': 'json_object'} if json_format else None\nresponse = client.chat.completions.create(model=llm_model.value, messages=\n    prompt, response_format=response_format, max_tokens=max_tokens)\nreturn response.choices[0\n    ].message.content or '', response.usage.prompt_tokens if response.usage else 0, response.usage.completion_tokens if response.usage else 0", "successors": []}, {"id": 70, "label": "#70\nif provider == 'ollama':", "successors": [{"id": 71, "label": "#71\nclient = ollama.Client(host=ollama_host)\nsys_messages = [p['content'] for p in prompt if p['role'] == 'system']\nusr_messages = [p['content'] for p in prompt if p['role'] != 'system']\nresponse = client.generate(model=llm_model.value, prompt=\n    f\"\"\"{sys_messages}\n\n{usr_messages}\"\"\", stream=False)\nreturn response.get('response') or '', response.get('prompt_eval_count'\n    ) or 0, response.get('eval_count') or 0", "successors": []}, {"id": 73, "label": "#73\nif provider == 'open_router':", "successors": [{"id": 74, "label": "#74\nclient = openai.OpenAI(base_url='https://openrouter.ai/api/v1', api_key=\n    credentials.api_key.get_secret_value())\nresponse = client.chat.completions.create(extra_headers={'HTTP-Referer':\n    'https://agpt.co', 'X-Title': 'AutoGPT'}, model=llm_model.value,\n    messages=prompt, max_tokens=max_tokens)\nif not response.choices:", "successors": [{"id": 78, "label": "#78\nif response:", "successors": [{"id": 80, "label": "#80\nraise ValueError(f'OpenRouter error: {response}')", "successors": []}, {"id": 82, "label": "#82\nraise ValueError('No response from OpenRouter.')", "successors": []}]}, {"id": 79, "label": "#79\nreturn response.choices[0\n    ].message.content or '', response.usage.prompt_tokens if response.usage else 0, response.usage.completion_tokens if response.usage else 0", "successors": []}]}, {"id": 76, "label": "#76\nraise ValueError(f'Unsupported LLM provider: {provider}')", "successors": []}]}]}]}]}]}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 112, "label": "#112\nlogger.debug(f'Calling LLM with input data: {input_data}')\nprompt = [p.model_dump() for p in input_data.conversation_history]\nvalues = input_data.prompt_values\nif values:", "successors": [{"id": 117, "label": "#117\ninput_data.prompt = input_data.prompt.format(**values)\ninput_data.sys_prompt = input_data.sys_prompt.format(**values)", "successors": [{"id": 118, "label": "#118\nif input_data.sys_prompt:", "successors": [{"id": 119, "label": "#119\nprompt.append({'role': 'system', 'content': input_data.sys_prompt})", "successors": [{"id": 120, "label": "#120\nif input_data.expected_format:", "successors": [{"id": 121, "label": "#121\nexpected_format = [f'\"{k}\": \"{v}\"' for k, v in input_data.expected_format.\n    items()]\nformat_prompt = ',\\n  '.join(expected_format)\nsys_prompt = trim_prompt(\n    f\"\"\"\n                  |Reply strictly only in the following JSON format:\n                  |{{\n                  |  {format_prompt}\n                  |}}\n                \"\"\"\n    )\nprompt.append({'role': 'system', 'content': sys_prompt})", "successors": [{"id": 122, "label": "#122\nif input_data.prompt:", "successors": [{"id": 123, "label": "#123\nprompt.append({'role': 'user', 'content': input_data.prompt})", "successors": [{"id": 124, "label": "#124\nlogger.info(f'LLM request: {prompt}')\nretry_prompt = ''\nllm_model = input_data.model", "successors": [{"id": 139, "label": "#139\nfor retry_count in range(input_data.retry):", "successors": [{"id": 140, "label": "#140\ntry:", "successors": [{"id": 142, "label": "#142\nresponse_text, input_token, output_token = self.llm_call(credentials=\n    credentials, llm_model=llm_model, prompt=prompt, json_format=bool(\n    input_data.expected_format), ollama_host=input_data.ollama_host,\n    max_tokens=input_data.max_tokens)\nself.merge_stats({'input_token_count': input_token, 'output_token_count':\n    output_token})\nlogger.info(f'LLM attempt-{retry_count} response: {response_text}')\nif input_data.expected_format:", "successors": [{"id": 145, "label": "#145\nparsed_dict, parsed_error = parse_response(response_text)\nif not parsed_error:", "successors": [{"id": 150, "label": "#150\nyield 'response', {k: (json.loads(v) if isinstance(v, str) and v.startswith\n    ('[') and v.endswith(']') else ', '.join(v) if isinstance(v, list) else\n    v) for k, v in parsed_dict.items()}", "successors": [{"id": 152, "label": "#152\nreturn", "successors": []}]}, {"id": 146, "label": "#146\nretry_prompt = trim_prompt(\n    f\"\"\"\n                  |This is your previous error response:\n                  |--\n                  |{response_text}\n                  |--\n                  |\n                  |And this is the error:\n                  |--\n                  |{parsed_error}\n                  |--\n                \"\"\"\n    )\nprompt.append({'role': 'user', 'content': retry_prompt})", "successors": []}]}, {"id": 147, "label": "#147\nyield 'response', {'response': response_text}", "successors": [{"id": 148, "label": "#148\nreturn", "successors": []}]}]}, {"id": 143, "label": "#143\nlogger.exception(f'Error calling LLM: {e}')\nretry_prompt = f'Error calling LLM: {e}'", "successors": []}]}, {"id": 141, "label": "#141\nraise RuntimeError(retry_prompt)", "successors": []}]}]}]}]}]}]}]}]}]}]}], "functions": [{"name": "trim_prompt", "type": "CFG", "blocks": [{"id": 114, "label": "#114\nlines = s.strip().split('\\n')\nreturn '\\n'.join([line.strip().lstrip('|') for line in lines])", "successors": []}], "functions": [], "classes": []}, {"name": "parse_response", "type": "CFG", "blocks": [{"id": 126, "label": "#126\ntry:", "successors": [{"id": 127, "label": "#127\nparsed = json.loads(resp)\nif not isinstance(parsed, dict):", "successors": [{"id": 130, "label": "#130\nreturn {}, f'Expected a dictionary, but got {type(parsed)}'", "successors": []}, {"id": 131, "label": "#131\nmiss_keys = set(input_data.expected_format.keys()) - set(parsed.keys())\nif miss_keys:", "successors": [{"id": 133, "label": "#133\nreturn parsed, f'Missing keys: {miss_keys}'", "successors": []}, {"id": 134, "label": "#134\nreturn parsed, None", "successors": []}]}]}, {"id": 128, "label": "#128\nreturn {}, f'JSON decode error: {e}'", "successors": []}]}], "functions": [], "classes": []}], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 52, "label": "#52\nprompt: str = SchemaField(description=\n    'The prompt to send to the language model.', placeholder=\nexpected_format: dict[str, str] = SchemaField(description=\n    'Expected format of the response. If provided, the response will be validated against this format. The keys should be the expected fields in the response, and the values should be the description of the field.'\n    )\nmodel: LlmModel = SchemaField(title='LLM Model', default=LlmModel.\n    GPT4_TURBO, description=\n    'The language model to use for answering the prompt.', advanced=False)\ncredentials: AICredentials = AICredentialsField()\nsys_prompt: str = SchemaField(title='System Prompt', default='',\n    description='The system prompt to provide additional context to the model.'\n    )\nconversation_history: list[Message] = SchemaField(default=[], description=\n    'The conversation history to provide context for the prompt.')\nretry: int = SchemaField(title='Retry Count', default=3, description=\n    'Number of times to retry the LLM call if the response does not match the expected format.'\n    )\nprompt_values: dict[str, str] = SchemaField(advanced=False, default={},\n    description='Values used to fill in the prompt.')\nmax_tokens: int | None = SchemaField(advanced=True, default=None,\n    description=\n    'The maximum number of tokens to generate in the chat completion.')\nollama_host: str = SchemaField(advanced=True, default='localhost:11434',\n    description='Ollama host for local  models')", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 55, "label": "#55\nresponse: dict[str, Any] = SchemaField(description=\n    'The response object generated by the language model.')\nerror: str = SchemaField(description='Error message if the API call failed.')", "successors": []}], "functions": [], "classes": []}]}, {"name": "AITextGeneratorBlock", "type": "CFG", "blocks": [{"id": 158, "label": "#158", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 166, "label": "#166\nsuper().__init__(id='1f292d4a-41a4-4977-9684-7c8d560b9f91', description=\n    'Call a Large Language Model (LLM) to generate a string based on the given prompt.'\n    , categories={BlockCategory.AI}, input_schema=AITextGeneratorBlock.\n    Input, output_schema=AITextGeneratorBlock.Output, test_input={'prompt':\n    'User prompt', 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials\n    =TEST_CREDENTIALS, test_output=('response', 'Response text'), test_mock\n    ={'llm_call': lambda *args, **kwargs: 'Response text'})", "successors": []}], "functions": [], "classes": []}, {"name": "llm_call", "type": "CFG", "blocks": [{"id": 169, "label": "#169\nblock = AIStructuredResponseGeneratorBlock()\nresponse = block.run_once(input_data, 'response', credentials=credentials)\nself.merge_stats(block.execution_stats)\nreturn response['response']", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 173, "label": "#173\nobject_input_data = AIStructuredResponseGeneratorBlock.Input(**{attr:\n    getattr(input_data, attr) for attr in input_data.model_fields},\n    expected_format={})\nyield 'response', self.llm_call(object_input_data, credentials)", "successors": []}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 160, "label": "#160\nprompt: str = SchemaField(description=\n    'The prompt to send to the language model. You can use any of the {keys} from Prompt Values to fill in the prompt with values from the prompt values dictionary by putting them in curly braces.'\nmodel: LlmModel = SchemaField(title='LLM Model', default=LlmModel.\n    GPT4_TURBO, description=\n    'The language model to use for answering the prompt.', advanced=False)\ncredentials: AICredentials = AICredentialsField()\nsys_prompt: str = SchemaField(title='System Prompt', default='',\n    description='The system prompt to provide additional context to the model.'\n    )\nretry: int = SchemaField(title='Retry Count', default=3, description=\n    'Number of times to retry the LLM call if the response does not match the expected format.'\n    )\nprompt_values: dict[str, str] = SchemaField(advanced=False, default={},\n    description='Values used to fill in the prompt.')\nollama_host: str = SchemaField(advanced=True, default='localhost:11434',\n    description='Ollama host for local  models')\nmax_tokens: int | None = SchemaField(advanced=True, default=None,\n    description=\n    'The maximum number of tokens to generate in the chat completion.')", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 163, "label": "#163\nresponse: str = SchemaField(description=\n    'The response generated by the language model.')\nerror: str = SchemaField(description='Error message if the API call failed.')", "successors": []}], "functions": [], "classes": []}]}, {"name": "SummaryStyle", "type": "CFG", "blocks": [{"id": 178, "label": "#178\nCONCISE = 'concise'\nDETAILED = 'detailed'\nBULLET_POINTS = 'bullet points'\nNUMBERED_LIST = 'numbered list'", "successors": []}], "functions": [], "classes": []}, {"name": "AITextSummarizerBlock", "type": "CFG", "blocks": [{"id": 181, "label": "#181", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 189, "label": "#189\nsuper().__init__(id='a0a69be1-4528-491c-a85a-a4ab6873e3f0', description=\n    'Utilize a Large Language Model (LLM) to summarize a long text.',\n    categories={BlockCategory.AI, BlockCategory.TEXT}, input_schema=\n    AITextSummarizerBlock.Input, output_schema=AITextSummarizerBlock.Output,\n    TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output\n    =('summary', 'Final summary of a long text'), test_mock={'llm_call': lambda\n    input_data, credentials: {'final_summary':\n    'Final summary of a long text'} if 'final_summary' in input_data.\n    expected_format else {'summary': 'Summary of a chunk of text'}})", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 192, "label": "#192\nfor output in self._run(input_data, credentials):", "successors": [{"id": 193, "label": "#193\nyield output", "successors": []}]}], "functions": [], "classes": []}, {"name": "_run", "type": "CFG", "blocks": [{"id": 198, "label": "#198\nchunks = self._split_text(input_data.text, input_data.max_tokens,\n    input_data.chunk_overlap)\nsummaries = []", "successors": [{"id": 199, "label": "#199\nfor chunk in chunks:", "successors": [{"id": 200, "label": "#200\nchunk_summary = self._summarize_chunk(chunk, input_data, credentials)\nsummaries.append(chunk_summary)", "successors": []}, {"id": 201, "label": "#201\nfinal_summary = self._combine_summaries(summaries, input_data, credentials)\nyield 'summary', final_summary", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "_split_text", "type": "CFG", "blocks": [{"id": 205, "label": "#205\nwords = text.split()\nchunks = []\nchunk_size = max_tokens - overlap", "successors": [{"id": 206, "label": "#206\nfor i in range(0, len(words), chunk_size):", "successors": [{"id": 207, "label": "#207\nchunk = ' '.join(words[i:i + max_tokens])\nchunks.append(chunk)", "successors": []}, {"id": 208, "label": "#208\nreturn chunks", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "llm_call", "type": "CFG", "blocks": [{"id": 212, "label": "#212\nblock = AIStructuredResponseGeneratorBlock()\nresponse = block.run_once(input_data, 'response', credentials=credentials)\nself.merge_stats(block.execution_stats)\nreturn response", "successors": []}], "functions": [], "classes": []}, {"name": "_summarize_chunk", "type": "CFG", "blocks": [{"id": 216, "label": "#216\nprompt = f\"\"\"Summarize the following text in a {input_data.style} form. Focus your summary on the topic of `{input_data.focus}` if present, otherwise just provide a general summary:\n\n```{chunk}```\"\"\"\nllm_response = self.llm_call(AIStructuredResponseGeneratorBlock.Input(\n    prompt=prompt, credentials=input_data.credentials, model=input_data.\n    model, expected_format={'summary': 'The summary of the given text.'}),\n    credentials=credentials)\nreturn llm_response['summary']", "successors": []}], "functions": [], "classes": []}, {"name": "_combine_summaries", "type": "CFG", "blocks": [{"id": 220, "label": "#220\ncombined_text = '\\n\\n'.join(summaries)\nif len(combined_text.split()) <= input_data.max_tokens:", "successors": [{"id": 221, "label": "#221\nprompt = f\"\"\"Provide a final summary of the following section summaries in a {input_data.style} form, focus your summary on the topic of `{input_data.focus}` if present:\n\n ```{combined_text}```\n\n Just respond with the final_summary in the format specified.\"\"\"\nllm_response = self.llm_call(AIStructuredResponseGeneratorBlock.Input(\n    prompt=prompt, credentials=input_data.credentials, model=input_data.\n    model, expected_format={'final_summary':\n    'The final summary of all provided summaries.'}), credentials=credentials)\nreturn llm_response['final_summary']", "successors": []}, {"id": 223, "label": "#223\nreturn self._run(AITextSummarizerBlock.Input(text=combined_text,\n    credentials=input_data.credentials, model=input_data.model, max_tokens=\n    input_data.max_tokens, chunk_overlap=input_data.chunk_overlap),\n    credentials=credentials).send(None)[1]", "successors": []}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 183, "label": "#183\ntext: str = SchemaField(description='The text to summarize.', placeholder=\nmodel: LlmModel = SchemaField(title='LLM Model', default=LlmModel.\n    GPT4_TURBO, description=\n    'The language model to use for summarizing the text.')\nfocus: str = SchemaField(title='Focus', default='general information',\n    description='The topic to focus on in the summary')\nstyle: SummaryStyle = SchemaField(title='Summary Style', default=\n    SummaryStyle.CONCISE, description='The style of the summary to generate.')\ncredentials: AICredentials = AICredentialsField()\nmax_tokens: int = SchemaField(title='Max Tokens', default=4096, description\n    ='The maximum number of tokens to generate in the chat completion.', ge=1)\nchunk_overlap: int = SchemaField(title='Chunk Overlap', default=100,\n    description=\n    'The number of overlapping tokens between chunks to maintain context.',\n    ge=0)\nollama_host: str = SchemaField(advanced=True, default='localhost:11434',\n    description='Ollama host for local  models')", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 186, "label": "#186\nsummary: str = SchemaField(description='The final summary of the text.')\nerror: str = SchemaField(description='Error message if the API call failed.')", "successors": []}], "functions": [], "classes": []}]}, {"name": "AIConversationBlock", "type": "CFG", "blocks": [{"id": 229, "label": "#229", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 237, "label": "#237\nsuper().__init__(id='32a87eab-381e-4dd4-bdb8-4c47151be35a', description=\n    'Advanced LLM call that takes a list of messages and sends them to the language model.'\n    , categories={BlockCategory.AI}, input_schema=AIConversationBlock.Input,\n    output_schema=AIConversationBlock.Output, test_input={'messages': [{\n    'role': 'system', 'content': 'You are a helpful assistant.'}, {'role':\n    'user', 'content': 'Who won the world series in 2020?'}, {'role':\n    'assistant', 'content':\n    'The Los Angeles Dodgers won the World Series in 2020.'}, {'role':\n    'user', 'content': 'Where was it played?'}], 'model': LlmModel.\n    GPT4_TURBO, 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=\n    TEST_CREDENTIALS, test_output=('response',\n    'The 2020 World Series was played at Globe Life Field in Arlington, Texas.'\n    ), test_mock={'llm_call': lambda *args, **kwargs:\n    'The 2020 World Series was played at Globe Life Field in Arlington, Texas.'\n    })", "successors": []}], "functions": [], "classes": []}, {"name": "llm_call", "type": "CFG", "blocks": [{"id": 240, "label": "#240\nblock = AIStructuredResponseGeneratorBlock()\nresponse = block.run_once(input_data, 'response', credentials=credentials)\nself.merge_stats(block.execution_stats)\nreturn response['response']", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 244, "label": "#244\nresponse = self.llm_call(AIStructuredResponseGeneratorBlock.Input(prompt='',\n    credentials=input_data.credentials, model=input_data.model,\n    conversation_history=input_data.messages, max_tokens=input_data.\n    max_tokens, expected_format={}), credentials=credentials)\nyield 'response', response", "successors": []}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 231, "label": "#231\nmessages: List[Message] = SchemaField(description=\n    'List of messages in the conversation.', min_length=1)\nmodel: LlmModel = SchemaField(title='LLM Model', default=LlmModel.\n    GPT4_TURBO, description='The language model to use for the conversation.')\ncredentials: AICredentials = AICredentialsField()\nmax_tokens: int | None = SchemaField(advanced=True, default=None,\n    description=\n    'The maximum number of tokens to generate in the chat completion.')\nollama_host: str = SchemaField(advanced=True, default='localhost:11434',\n    description='Ollama host for local  models')", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 234, "label": "#234\nresponse: str = SchemaField(description=\n    \"The model's response to the conversation.\")\nerror: str = SchemaField(description='Error message if the API call failed.')", "successors": []}], "functions": [], "classes": []}]}, {"name": "AIListGeneratorBlock", "type": "CFG", "blocks": [{"id": 249, "label": "#249", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 257, "label": "#257\nsuper().__init__(id='9c0b0450-d199-458b-a731-072189dd6593', description=\n    'Generate a Python list based on the given prompt using a Large Language Model (LLM).'\n    , categories={BlockCategory.AI, BlockCategory.TEXT}, input_schema=\n    AIListGeneratorBlock.Input, output_schema=AIListGeneratorBlock.Output,\n    test_input={'focus': 'planets', 'source_data':\n    \"Zylora Prime is a glowing jungle world with bioluminescent plants, while Kharon-9 is a harsh desert planet with underground cities. Vortexia's constant storms power floating cities, and Oceara is a water-covered world home to intelligent marine life. On icy Draknos, ancient ruins lie buried beneath its frozen landscape, drawing explorers to uncover its mysteries. Each planet showcases the limitless possibilities of fictional worlds.\"\n    , 'model': LlmModel.GPT4_TURBO, 'credentials': TEST_CREDENTIALS_INPUT,\n    'max_retries': 3}, test_credentials=TEST_CREDENTIALS, test_output=[(\n    'generated_list', ['Zylora Prime', 'Kharon-9', 'Vortexia', 'Oceara',\n    'Draknos']), ('list_item', 'Zylora Prime'), ('list_item', 'Kharon-9'),\n    ('list_item', 'Vortexia'), ('list_item', 'Oceara'), ('list_item',\n    'Draknos')], test_mock={'llm_call': lambda input_data, credentials: {\n    'response':\n    \"['Zylora Prime', 'Kharon-9', 'Vortexia', 'Oceara', 'Draknos']\"}})", "successors": []}], "functions": [], "classes": []}, {"name": "llm_call", "type": "CFG", "blocks": [{"id": 260, "label": "#260\nllm_block = AIStructuredResponseGeneratorBlock()\nresponse = llm_block.run_once(input_data, 'response', credentials=credentials)\nreturn response", "successors": []}], "functions": [], "classes": []}, {"name": "string_to_list", "type": "CFG", "blocks": [{"id": 264, "label": "#264\n\"\"\"\n        Converts a string representation of a list into an actual Python list object.\n        \"\"\"\nlogger.debug(f'Converting string to list. Input string: {string}')\ntry:", "successors": [{"id": 265, "label": "#265\npython_list = ast.literal_eval(string)\nif isinstance(python_list, list):", "successors": [{"id": 268, "label": "#268\nlogger.debug(f'Successfully converted string to list: {python_list}')\nreturn python_list", "successors": []}, {"id": 270, "label": "#270\nlogger.error(f\"The provided string '{string}' is not a valid list\")\nraise ValueError(f\"The provided string '{string}' is not a valid list.\")", "successors": []}]}, {"id": 266, "label": "#266\nlogger.error(f'Failed to convert string to list: {e}')\nraise ValueError('Invalid list format. Could not convert to list.')", "successors": []}]}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 276, "label": "#276\nlogger.debug(f'Starting AIListGeneratorBlock.run with input data: {input_data}'\n    )\napi_key_check = credentials.api_key.get_secret_value()\nif not api_key_check:", "successors": [{"id": 277, "label": "#277\nraise ValueError('No LLM API key provided.')", "successors": []}, {"id": 278, "label": "#278\nsys_prompt = \"\"\"You are a Python list generator. Your task is to generate a Python list based on the user's prompt. \n            |Respond ONLY with a valid python list. \n            |The list can contain strings, numbers, or nested lists as appropriate. \n            |Do not include any explanations or additional text.\n\n            |Valid Example string formats:\n\n            |Example 1:\n            |```\n            |['1', '2', '3', '4']\n            |```\n\n            |Example 2:\n            |```\n            |[['1', '2'], ['3', '4'], ['5', '6']]\n            |```\n\n            |Example 3:\n            |```\n            |['1', ['2', '3'], ['4', ['5', '6']]]\n            |```\n\n            |Example 4:\n            |```\n            |['a', 'b', 'c']\n            |```\n\n            |Example 5:\n            |```\n            |['1', '2.5', 'string', 'True', ['False', 'None']]\n            |```\n\n            |Do not include any explanations or additional text, just respond with the list in the format specified above.\n            \"\"\"\nif input_data.focus:", "successors": [{"id": 280, "label": "#280\nprompt = f\"\"\"Generate a list with the following focus:\n<focus>\n\n{input_data.focus}</focus>\"\"\"", "successors": [{"id": 281, "label": "#281\nif input_data.source_data:", "successors": [{"id": 286, "label": "#286\nprompt += f\"\"\"\n\nUse the following source data to generate the list from:\n\n<source_data>\n\n{input_data.source_data}</source_data>\n\nDo not invent fictional data that is not present in the source data.\"\"\"", "successors": [{"id": 287, "label": "#287\nfor attempt in range(input_data.max_retries):", "successors": [{"id": 289, "label": "#289\ntry:", "successors": [{"id": 291, "label": "#291\nlogger.debug('Calling LLM')\nllm_response = self.llm_call(AIStructuredResponseGeneratorBlock.Input(\n    sys_prompt=sys_prompt, prompt=prompt, credentials=input_data.\n    credentials, model=input_data.model, expected_format={}, ollama_host=\n    input_data.ollama_host), credentials=credentials)\nlogger.debug(f'LLM response: {llm_response}')\nresponse_string = llm_response['response']\nlogger.debug(f'Response string: {response_string}')\nlogger.debug('Converting string to Python list')\nparsed_list = self.string_to_list(response_string)\nlogger.debug(f'Parsed list: {parsed_list}')\nlogger.debug('Successfully generated a valid Python list')\nyield 'generated_list', parsed_list", "successors": [{"id": 294, "label": "#294\nfor item in parsed_list:", "successors": [{"id": 295, "label": "#295\nyield 'list_item', item", "successors": []}, {"id": 296, "label": "#296\nreturn", "successors": []}]}]}, {"id": 292, "label": "#292\nlogger.error(f'Error in attempt {attempt + 1}: {str(e)}')\nif attempt == input_data.max_retries - 1:", "successors": [{"id": 299, "label": "#299\nlogger.error(\n    f'Failed to generate a valid Python list after {input_data.max_retries} attempts'\n    )\nraise RuntimeError(\n    f'Failed to generate a valid Python list after {input_data.max_retries} attempts. Last error: {str(e)}'\n    )", "successors": []}, {"id": 301, "label": "#301\nlogger.debug('Preparing retry prompt')\nprompt = f\"\"\"\n                    The previous attempt failed due to `{e}`\n                    Generate a valid Python list based on the original prompt.\n                    Remember to respond ONLY with a valid Python list as per the format specified earlier.\n                    Original prompt: \n                    ```{prompt}```\n                    \n                    Respond only with the list in the format specified with no commentary or apologies.\n                    \"\"\"\nlogger.debug(f'Retry prompt: {prompt}')", "successors": []}]}]}, {"id": 290, "label": "#290\nlogger.debug('AIListGeneratorBlock.run completed')", "successors": []}]}]}, {"id": 288, "label": "#288\nprompt += \"\"\"\n\nInvent the data to generate the list from.\"\"\"", "successors": []}]}]}, {"id": 282, "label": "#282\nif input_data.source_data:", "successors": [{"id": 283, "label": "#283\nprompt = \"\"\"Extract the main focus of the source data to a list.\ni.e if the source data is a news website, the focus would be the news stories rather than the social links in the footer.\"\"\"", "successors": []}, {"id": 285, "label": "#285\nprompt = 'Generate a random list.'", "successors": []}]}]}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 251, "label": "#251\nfocus: str | None = SchemaField(description=\n    'The focus of the list to generate.', placeholder=\n    'The top 5 most interesting news stories in the data.', default=None,\n    advanced=False)\nsource_data: str | None = SchemaField(description=\n    'The data to generate the list from.', placeholder=\n    'News Today: Humans land on Mars: Today humans landed on mars. -- AI wins Nobel Prize: AI wins Nobel Prize for solving world hunger. -- New AI Model: A new AI model has been released.'\n    , default=None, advanced=False)\nmodel: LlmModel = SchemaField(title='LLM Model', default=LlmModel.\n    GPT4_TURBO, description=\n    'The language model to use for generating the list.', advanced=True)\ncredentials: AICredentials = AICredentialsField()\nmax_retries: int = SchemaField(default=3, description=\n    'Maximum number of retries for generating a valid list.', ge=1, le=5)\nmax_tokens: int | None = SchemaField(advanced=True, default=None,\n    description=\n    'The maximum number of tokens to generate in the chat completion.')\nollama_host: str = SchemaField(advanced=True, default='localhost:11434',\n    description='Ollama host for local  models')", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 254, "label": "#254\ngenerated_list: List[str] = SchemaField(description='The generated list.')\nlist_item: str = SchemaField(description='Each individual item in the list.')\nerror: str = SchemaField(description=\n    'Error message if the list generation failed.')", "successors": []}], "functions": [], "classes": []}]}]}
{"file_name": "187.json", "name": "187.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom backend.app import run_processes\nfrom backend.executor import DatabaseManager, ExecutionManager\nif __name__ == '__main__':", "successors": [{"id": 5, "label": "#5\nmain()", "successors": []}]}], "functions": [{"name": "main", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"\n    Run all the processes required for the AutoGPT-server REST API.\n    \"\"\"\nrun_processes(DatabaseManager(), ExecutionManager())", "successors": []}], "functions": [], "classes": []}], "classes": []}
{"file_name": "188.json", "name": "188.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom datetime import datetime\nimport prisma.errors\nimport prisma.models\nimport pytest\nfrom prisma import Prisma\nimport backend.server.v2.store.db as db\nfrom backend.server.v2.store.model import Profile", "successors": []}], "functions": [{"name": "setup_prisma", "type": "CFG", "blocks": [{"id": 3, "label": "#3\ntry:", "successors": [{"id": 4, "label": "#4\nPrisma()", "successors": [{"id": 6, "label": "#6\nyield", "successors": []}]}, {"id": 5, "label": "#5\npass", "successors": []}]}], "functions": [], "classes": []}, {"name": "test_get_store_agents", "type": "CFG", "blocks": [{"id": 10, "label": "#10\nmock_agents = [prisma.models.StoreAgent(listing_id='test-id',\n    storeListingVersionId='version123', slug='test-agent', agent_name=\n    'Test Agent', agent_video=None, agent_image=['image.jpg'], featured=\n    False, creator_username='creator', creator_avatar='avatar.jpg',\n    sub_heading='Test heading', description='Test description', categories=\n    [], runs=10, rating=4.5, versions=['1.0'], updated_at=datetime.now())]\nmock_store_agent = mocker.patch('prisma.models.StoreAgent.prisma')\nmock_store_agent.return_value.find_many = mocker.AsyncMock(return_value=\n    mock_agents)\nmock_store_agent.return_value.count = mocker.AsyncMock(return_value=1)\nresult = await db.get_store_agents()", "successors": [{"id": 11, "label": "#11\nassert len(result.agents) == 1", "successors": [{"id": 13, "label": "#13\nassert result.agents[0].slug == 'test-agent'", "successors": [{"id": 15, "label": "#15\nassert result.pagination.total_items == 1", "successors": [{"id": 17, "label": "#17\nmock_store_agent.return_value.find_many.assert_called_once()\nmock_store_agent.return_value.count.assert_called_once()", "successors": []}]}]}]}]}], "functions": [], "classes": []}, {"name": "test_get_store_agent_details", "type": "CFG", "blocks": [{"id": 20, "label": "#20\nmock_agent = prisma.models.StoreAgent(listing_id='test-id',\n    storeListingVersionId='version123', slug='test-agent', agent_name=\n    'Test Agent', agent_video='video.mp4', agent_image=['image.jpg'],\n    featured=False, creator_username='creator', creator_avatar='avatar.jpg',\n    sub_heading='Test heading', description='Test description', categories=\n    ['test'], runs=10, rating=4.5, versions=['1.0'], updated_at=datetime.now())\nmock_store_agent = mocker.patch('prisma.models.StoreAgent.prisma')\nmock_store_agent.return_value.find_first = mocker.AsyncMock(return_value=\n    mock_agent)\nresult = await db.get_store_agent_details('creator', 'test-agent')", "successors": [{"id": 21, "label": "#21\nassert result.slug == 'test-agent'", "successors": [{"id": 23, "label": "#23\nassert result.agent_name == 'Test Agent'", "successors": [{"id": 25, "label": "#25\nmock_store_agent.return_value.find_first.assert_called_once_with(where={\n    'creator_username': 'creator', 'slug': 'test-agent'})", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "test_get_store_creator_details", "type": "CFG", "blocks": [{"id": 28, "label": "#28\nmock_creator_data = prisma.models.Creator(name='Test Creator', username=\n    'creator', description='Test description', links=['link1'], avatar_url=\n    'avatar.jpg', num_agents=1, agent_rating=4.5, agent_runs=10,\n    top_categories=['test'], is_featured=False)\nmock_creator = mocker.patch('prisma.models.Creator.prisma')\nmock_creator.return_value.find_unique = mocker.AsyncMock()\nmock_creator.return_value.find_unique.return_value = mock_creator_data\nresult = await db.get_store_creator_details('creator')", "successors": [{"id": 29, "label": "#29\nassert result.username == 'creator'", "successors": [{"id": 31, "label": "#31\nassert result.name == 'Test Creator'", "successors": [{"id": 33, "label": "#33\nassert result.description == 'Test description'", "successors": [{"id": 35, "label": "#35\nassert result.avatar_url == 'avatar.jpg'", "successors": [{"id": 37, "label": "#37\nmock_creator.return_value.find_unique.assert_called_once_with(where={\n    'username': 'creator'})", "successors": []}]}]}]}]}]}], "functions": [], "classes": []}, {"name": "test_create_store_submission", "type": "CFG", "blocks": [{"id": 40, "label": "#40\nmock_agent = prisma.models.AgentGraph(id='agent-id', version=1, userId=\n    'user-id', createdAt=datetime.now(), isActive=True, isTemplate=False)\nmock_listing = prisma.models.StoreListing(id='listing-id', createdAt=\n    datetime.now(), updatedAt=datetime.now(), isDeleted=False, isApproved=\n    False, agentId='agent-id', agentVersion=1, owningUserId='user-id')\nmock_agent_graph = mocker.patch('prisma.models.AgentGraph.prisma')\nmock_agent_graph.return_value.find_first = mocker.AsyncMock(return_value=\n    mock_agent)\nmock_store_listing = mocker.patch('prisma.models.StoreListing.prisma')\nmock_store_listing.return_value.find_first = mocker.AsyncMock(return_value=None\n    )\nmock_store_listing.return_value.create = mocker.AsyncMock(return_value=\n    mock_listing)\nresult = await db.create_store_submission(user_id='user-id', agent_id=\n    'agent-id', agent_version=1, slug='test-agent', name='Test Agent',\n    description='Test description')", "successors": [{"id": 41, "label": "#41\nassert result.name == 'Test Agent'", "successors": [{"id": 43, "label": "#43\nassert result.description == 'Test description'", "successors": [{"id": 45, "label": "#45\nmock_agent_graph.return_value.find_first.assert_called_once()\nmock_store_listing.return_value.find_first.assert_called_once()\nmock_store_listing.return_value.create.assert_called_once()", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "test_update_profile", "type": "CFG", "blocks": [{"id": 48, "label": "#48\nmock_profile = prisma.models.Profile(id='profile-id', name='Test Creator',\n    username='creator', description='Test description', links=['link1'],\n    avatarUrl='avatar.jpg', isFeatured=False, createdAt=datetime.now(),\n    updatedAt=datetime.now())\nmock_profile_db = mocker.patch('prisma.models.Profile.prisma')\nmock_profile_db.return_value.find_first = mocker.AsyncMock(return_value=\n    mock_profile)\nmock_profile_db.return_value.update = mocker.AsyncMock(return_value=\n    mock_profile)\nprofile = Profile(name='Test Creator', username='creator', description=\n    'Test description', links=['link1'], avatar_url='avatar.jpg',\n    is_featured=False)\nresult = await db.update_or_create_profile('user-id', profile)", "successors": [{"id": 49, "label": "#49\nassert result.username == 'creator'", "successors": [{"id": 51, "label": "#51\nassert result.name == 'Test Creator'", "successors": [{"id": 53, "label": "#53\nmock_profile_db.return_value.find_first.assert_called_once()\nmock_profile_db.return_value.update.assert_called_once()", "successors": []}]}]}]}], "functions": [], "classes": []}, {"name": "test_get_user_profile", "type": "CFG", "blocks": [{"id": 56, "label": "#56\nmock_profile = prisma.models.Profile(id='profile-id', name=\n    'No Profile Data', username='testuser', description='Test description',\n    links=['link1', 'link2'], avatarUrl='avatar.jpg', isFeatured=False,\n    createdAt=datetime.now(), updatedAt=datetime.now())\nmock_profile_db = mocker.patch('prisma.models.Profile.prisma')\nmock_profile_db.return_value.find_unique = mocker.AsyncMock(return_value=\n    mock_profile)\nresult = await db.get_user_profile('user-id')", "successors": [{"id": 57, "label": "#57\nassert result.name == 'No Profile Data'", "successors": [{"id": 59, "label": "#59\nassert result.username == 'No Profile Data'", "successors": [{"id": 61, "label": "#61\nassert result.description == 'No Profile Data'", "successors": [{"id": 63, "label": "#63\nassert result.links == []", "successors": [{"id": 65, "label": "#65\nassert result.avatar_url == ''", "successors": []}]}]}]}]}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "189.json", "name": "189.json", "type": "CFG", "blocks": [{"id": 1, "label": "#1\n{'name': 'example_script', 'type': 'CFG', 'start_line': 1, 'end_line': 30,\n    'functions': [], 'classes': [{'name': 'LogConfig', 'type': 'class',\n    'start_line': 4, 'end_line': 30, 'functions': [], 'classes': [],\n    'simplified_code':\n    \"\"\"class LogConfig(BaseModel):\n    \"\"\\\"Logging configuration to be set for the server\"\"\\\"\n\n    LOGGER_NAME: str = \"marketplace\"\n    LOG_FORMAT: str = \"%(levelprefix)s | %(asctime)s | %(message)s\"\n    LOG_LEVEL: str = \"DEBUG\"\n\n    # Logging config\n    version: int = 1\n    disable_existing_loggers: bool = False\n    formatters: dict = {\n        \"default\": {\n            \"()\": \"uvicorn.logging.DefaultFormatter\",\n            \"fmt\": LOG_FORMAT,\n            \"datefmt\": \"%Y-%m-%d %H:%M:%S\",\n        },\n    }\n    handlers: dict = {\n        \"default\": {\n            \"formatter\": \"default\",\n            \"class\": \"logging.StreamHandler\",\n            \"stream\": \"ext://sys.stderr\",\n        },\n    }\n    loggers: dict = {\n        LOGGER_NAME: {\"handlers\": [\"default\"], \"level\": LOG_LEVEL},\n    }\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"class LogConfig(BaseModel):\n    \"\"\\\"Logging configuration to be set for the server\"\"\\\"\n\n    LOGGER_NAME: str = \"marketplace\"\n    LOG_FORMAT: str = \"%(levelprefix)s | %(asctime)s | %(message)s\"\n    LOG_LEVEL: str = \"DEBUG\"\n\n    # Logging config\n    version: int = 1\n    disable_existing_loggers: bool = False\n    formatters: dict = {\n        \"default\": {\n            \"()\": \"uvicorn.logging.DefaultFormatter\",\n            \"fmt\": LOG_FORMAT,\n            \"datefmt\": \"%Y-%m-%d %H:%M:%S\",\n        },\n    }\n    handlers: dict = {\n        \"default\": {\n            \"formatter\": \"default\",\n            \"class\": \"logging.StreamHandler\",\n            \"stream\": \"ext://sys.stderr\",\n        },\n    }\n    loggers: dict = {\n        LOGGER_NAME: {\"handlers\": [\"default\"], \"level\": LOG_LEVEL},\n    }\"\"\"\n    , 'successors': []}]}], 'simplified_code':\n    \"\"\"from pydantic import BaseModel\n\n\n    }\"\"\", 'blocks': []}", "successors": []}], "functions": [], "classes": []}
{"file_name": "190.json", "name": "190.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1", "successors": []}], "functions": [], "classes": [{"name": "MissingConfigError", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"The attempted operation requires configuration which is not available\"\"\"", "successors": []}], "functions": [], "classes": []}, {"name": "NeedConfirmation", "type": "CFG", "blocks": [{"id": 6, "label": "#6\n\"\"\"The user must explicitly confirm that they want to proceed\"\"\"", "successors": []}], "functions": [], "classes": []}]}
{"file_name": "191.json", "name": "191.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom __future__ import annotations\nif __name__ == '__main__':", "successors": [{"id": 41, "label": "#41\nimport doctest\ndoctest.testmod()", "successors": []}]}], "functions": [{"name": "get_valid_pos", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"\n    Find all the valid positions a knight can move to from the current position.\n\n    >>> get_valid_pos((1, 3), 4)\n    [(2, 1), (0, 1), (3, 2)]\n    \"\"\"\ny, x = position\npositions = [(y + 1, x + 2), (y - 1, x + 2), (y + 1, x - 2), (y - 1, x - 2),\n    (y + 2, x + 1), (y + 2, x - 1), (y - 2, x + 1), (y - 2, x - 1)]\npermissible_positions = []", "successors": [{"id": 4, "label": "#4\nfor inner_position in positions:", "successors": [{"id": 5, "label": "#5\ny_test, x_test = inner_position\nif 0 <= y_test < n and 0 <= x_test < n:", "successors": [{"id": 7, "label": "#7\npermissible_positions.append(inner_position)", "successors": []}]}, {"id": 6, "label": "#6\nreturn permissible_positions", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "is_complete", "type": "CFG", "blocks": [{"id": 12, "label": "#12\n\"\"\"\n    Check if the board (matrix) has been completely filled with non-zero values.\n\n    >>> is_complete([[1]])\n    True\n\n    >>> is_complete([[1, 2], [3, 0]])\n    False\n    \"\"\"\nreturn not any(elem == 0 for row in board for elem in row)", "successors": []}], "functions": [], "classes": []}, {"name": "open_knight_tour_helper", "type": "CFG", "blocks": [{"id": 16, "label": "#16\n\"\"\"\n    Helper function to solve knight tour problem.\n    \"\"\"\nif is_complete(board):", "successors": [{"id": 17, "label": "#17\nreturn True", "successors": []}, {"id": 18, "label": "#18\nfor position in get_valid_pos(pos, len(board)):", "successors": [{"id": 20, "label": "#20\ny, x = position\nif board[y][x] == 0:", "successors": [{"id": 22, "label": "#22\nboard[y][x] = curr + 1\nif open_knight_tour_helper(board, position, curr + 1):", "successors": [{"id": 24, "label": "#24\nreturn True", "successors": []}, {"id": 25, "label": "#25\nboard[y][x] = 0", "successors": []}]}]}, {"id": 21, "label": "#21\nreturn False", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "open_knight_tour", "type": "CFG", "blocks": [{"id": 30, "label": "#30\n\"\"\"\n    Find the solution for the knight tour problem for a board of size n. Raises\n    ValueError if the tour cannot be performed for the given size.\n\n    >>> open_knight_tour(1)\n    [[1]]\n\n    >>> open_knight_tour(2)\n    Traceback (most recent call last):\n    ValueError: Open Knight Tour cannot be performed on a board of size 2\n    \"\"\"\nboard = [[(0) for i in range(n)] for j in range(n)]", "successors": [{"id": 31, "label": "#31\nfor i in range(n):", "successors": [{"id": 32, "label": "#32\nfor j in range(n):", "successors": [{"id": 34, "label": "#34\nboard[i][j] = 1\nif open_knight_tour_helper(board, (i, j), 1):", "successors": [{"id": 36, "label": "#36\nreturn board", "successors": []}, {"id": 37, "label": "#37\nboard[i][j] = 0", "successors": []}]}]}, {"id": 33, "label": "#33\nmsg = f'Open Knight Tour cannot be performed on a board of size {n}'\nraise ValueError(msg)", "successors": []}]}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "192.json", "name": "192.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport operator\nfrom enum import Enum\nfrom typing import Any\nfrom backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema\nfrom backend.data.model import SchemaField", "successors": []}], "functions": [], "classes": [{"name": "Operation", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nADD = 'Add'\nSUBTRACT = 'Subtract'\nMULTIPLY = 'Multiply'\nDIVIDE = 'Divide'\nPOWER = 'Power'", "successors": []}], "functions": [], "classes": []}, {"name": "CalculatorBlock", "type": "CFG", "blocks": [{"id": 6, "label": "#6", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 14, "label": "#14\nsuper().__init__(id='b1ab9b19-67a6-406d-abf5-2dba76d00c79', input_schema=\n    CalculatorBlock.Input, output_schema=CalculatorBlock.Output,\n    description='Performs a mathematical operation on two numbers.',\n    categories={BlockCategory.LOGIC}, test_input={'operation': Operation.\n    ADD.value, 'a': 10.0, 'b': 5.0, 'round_result': False}, test_output=[(\n    'result', 15.0)])", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 17, "label": "#17\noperation = input_data.operation\na = input_data.a\nb = input_data.b\noperations = {Operation.ADD: operator.add, Operation.SUBTRACT: operator.sub,\n    Operation.MULTIPLY: operator.mul, Operation.DIVIDE: operator.truediv,\n    Operation.POWER: operator.pow}\nop_func = operations[operation]\ntry:", "successors": [{"id": 18, "label": "#18\nif operation == Operation.DIVIDE and b == 0:", "successors": [{"id": 22, "label": "#22\nraise ZeroDivisionError('Cannot divide by zero')", "successors": []}, {"id": 23, "label": "#23\nresult = op_func(a, b)\nif input_data.round_result:", "successors": [{"id": 25, "label": "#25\nresult = round(result)", "successors": [{"id": 26, "label": "#26\nyield 'result', result", "successors": []}]}]}]}, {"id": 19, "label": "#19\nyield 'result', float('inf')", "successors": []}, {"id": 20, "label": "#20\nyield 'result', float('nan')", "successors": []}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 8, "label": "#8\noperation: Operation = SchemaField(description=\n    'Choose the math operation you want to perform', placeholder=\n    'Select an operation')\na: float = SchemaField(description='Enter the first number (A)',\n    placeholder='For example: 10')\nb: float = SchemaField(description='Enter the second number (B)',\n    placeholder='For example: 5')\nround_result: bool = SchemaField(description=\n    'Do you want to round the result to a whole number?', default=False)", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 11, "label": "#11\nresult: float = SchemaField(description='The result of your calculation')", "successors": []}], "functions": [], "classes": []}]}, {"name": "CountItemsBlock", "type": "CFG", "blocks": [{"id": 33, "label": "#33", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 41, "label": "#41\nsuper().__init__(id='3c9c2f42-b0c3-435f-ba35-05f7a25c772a', input_schema=\n    CountItemsBlock.Input, output_schema=CountItemsBlock.Output,\n    description='Counts the number of items in a collection.', categories={\n    BlockCategory.LOGIC}, test_input={'collection': [1, 2, 3, 4, 5]},\n    test_output=[('count', 5)])", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 44, "label": "#44\ncollection = input_data.collection\ntry:", "successors": [{"id": 45, "label": "#45\nif isinstance(collection, (str, list, tuple, set, dict)):", "successors": [{"id": 48, "label": "#48\ncount = len(collection)", "successors": [{"id": 49, "label": "#49\nyield 'count', count", "successors": []}]}, {"id": 50, "label": "#50\nif hasattr(collection, '__iter__'):", "successors": [{"id": 51, "label": "#51\ncount = sum(1 for _ in collection)", "successors": []}, {"id": 53, "label": "#53\nraise ValueError('Input is not a countable collection')", "successors": []}]}]}, {"id": 46, "label": "#46\nyield 'count', -1", "successors": []}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 35, "label": "#35\ncollection: Any = SchemaField(description=\n    'Enter the collection you want to count. This can be a list, dictionary, string, or any other iterable.'\n    , placeholder=\"For example: [1, 2, 3] or {'a': 1, 'b': 2} or 'hello'\")", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 38, "label": "#38\ncount: int = SchemaField(description='The number of items in the collection')", "successors": []}], "functions": [], "classes": []}]}]}
{"file_name": "193.json", "name": "193.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport pytest\nfrom .depends import requires_admin_user, requires_user, verify_user", "successors": []}], "functions": [{"name": "test_verify_user_no_payload", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nuser = verify_user(None, admin_only=False)\nassert user.user_id == '3e53486c-cf57-477e-ba2a-cb02dc828e1a'", "successors": [{"id": 5, "label": "#5\nassert user.role == 'admin'", "successors": []}]}], "functions": [], "classes": []}, {"name": "test_verify_user_no_user_id", "type": "CFG", "blocks": [{"id": 10, "label": "#10\nwith pytest.raises(Exception):", "successors": [{"id": 11, "label": "#11\nverify_user({'role': 'admin'}, admin_only=False)", "successors": []}]}], "functions": [], "classes": []}, {"name": "test_verify_user_not_admin", "type": "CFG", "blocks": [{"id": 15, "label": "#15\nwith pytest.raises(Exception):", "successors": [{"id": 16, "label": "#16\nverify_user({'sub': '3e53486c-cf57-477e-ba2a-cb02dc828e1a', 'role': 'user'},\n    admin_only=True)", "successors": []}]}], "functions": [], "classes": []}, {"name": "test_verify_user_with_admin_role", "type": "CFG", "blocks": [{"id": 20, "label": "#20\nuser = verify_user({'sub': '3e53486c-cf57-477e-ba2a-cb02dc828e1a', 'role':\n    'admin'}, admin_only=True)\nassert user.user_id == '3e53486c-cf57-477e-ba2a-cb02dc828e1a'", "successors": [{"id": 22, "label": "#22\nassert user.role == 'admin'", "successors": []}]}], "functions": [], "classes": []}, {"name": "test_verify_user_with_user_role", "type": "CFG", "blocks": [{"id": 27, "label": "#27\nuser = verify_user({'sub': '3e53486c-cf57-477e-ba2a-cb02dc828e1a', 'role':\n    'user'}, admin_only=False)\nassert user.user_id == '3e53486c-cf57-477e-ba2a-cb02dc828e1a'", "successors": [{"id": 29, "label": "#29\nassert user.role == 'user'", "successors": []}]}], "functions": [], "classes": []}, {"name": "test_requires_user", "type": "CFG", "blocks": [{"id": 34, "label": "#34\nuser = requires_user({'sub': '3e53486c-cf57-477e-ba2a-cb02dc828e1a', 'role':\n    'user'})\nassert user.user_id == '3e53486c-cf57-477e-ba2a-cb02dc828e1a'", "successors": [{"id": 36, "label": "#36\nassert user.role == 'user'", "successors": []}]}], "functions": [], "classes": []}, {"name": "test_requires_user_no_user_id", "type": "CFG", "blocks": [{"id": 41, "label": "#41\nwith pytest.raises(Exception):", "successors": [{"id": 42, "label": "#42\nrequires_user({'role': 'user'})", "successors": []}]}], "functions": [], "classes": []}, {"name": "test_requires_admin_user", "type": "CFG", "blocks": [{"id": 46, "label": "#46\nuser = requires_admin_user({'sub': '3e53486c-cf57-477e-ba2a-cb02dc828e1a',\n    'role': 'admin'})\nassert user.user_id == '3e53486c-cf57-477e-ba2a-cb02dc828e1a'", "successors": [{"id": 48, "label": "#48\nassert user.role == 'admin'", "successors": []}]}], "functions": [], "classes": []}, {"name": "test_requires_admin_user_not_admin", "type": "CFG", "blocks": [{"id": 53, "label": "#53\nwith pytest.raises(Exception):", "successors": [{"id": 54, "label": "#54\nrequires_admin_user({'sub': '3e53486c-cf57-477e-ba2a-cb02dc828e1a', 'role':\n    'user'})", "successors": []}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "194.json", "name": "194.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\n\"\"\"\nIn this problem, we want to determine all possible permutations\nof the given sequence. We use backtracking to solve this problem.\n\nTime complexity: O(n! * n),\nwhere n denotes the length of the given sequence.\n\"\"\"\nfrom __future__ import annotations\n\"\"\"\nremove the comment to take an input from the user\n\nprint(\"Enter the elements\")\nsequence = list(map(int, input().split()))\n\"\"\"\nsequence: list[int | str] = [3, 1, 2, 4]\ngenerate_all_permutations(sequence)\nsequence_2: list[int | str] = ['A', 'B', 'C']\ngenerate_all_permutations(sequence_2)", "successors": []}], "functions": [{"name": "generate_all_permutations", "type": "CFG", "blocks": [{"id": 3, "label": "#3\ncreate_state_space_tree(sequence, [], 0, [(0) for i in range(len(sequence))])", "successors": []}], "functions": [], "classes": []}, {"name": "create_state_space_tree", "type": "CFG", "blocks": [{"id": 6, "label": "#6\n\"\"\"\n    Creates a state space tree to iterate through each branch using DFS.\n    We know that each state has exactly len(sequence) - index children.\n    It terminates when it reaches the end of the given sequence.\n\n    :param sequence: The input sequence for which permutations are generated.\n    :param current_sequence: The current permutation being built.\n    :param index: The current index in the sequence.\n    :param index_used: list to track which elements are used in permutation.\n\n    Example 1:\n    >>> sequence = [1, 2, 3]\n    >>> current_sequence = []\n    >>> index_used = [False, False, False]\n    >>> create_state_space_tree(sequence, current_sequence, 0, index_used)\n    [1, 2, 3]\n    [1, 3, 2]\n    [2, 1, 3]\n    [2, 3, 1]\n    [3, 1, 2]\n    [3, 2, 1]\n\n    Example 2:\n    >>> sequence = [\"A\", \"B\", \"C\"]\n    >>> current_sequence = []\n    >>> index_used = [False, False, False]\n    >>> create_state_space_tree(sequence, current_sequence, 0, index_used)\n    ['A', 'B', 'C']\n    ['A', 'C', 'B']\n    ['B', 'A', 'C']\n    ['B', 'C', 'A']\n    ['C', 'A', 'B']\n    ['C', 'B', 'A']\n\n    Example 3:\n    >>> sequence = [1]\n    >>> current_sequence = []\n    >>> index_used = [False]\n    >>> create_state_space_tree(sequence, current_sequence, 0, index_used)\n    [1]\n    \"\"\"\nif index == len(sequence):", "successors": [{"id": 7, "label": "#7\nprint(current_sequence)\nreturn", "successors": []}, {"id": 8, "label": "#8\nfor i in range(len(sequence)):", "successors": [{"id": 10, "label": "#10\nif not index_used[i]:", "successors": [{"id": 12, "label": "#12\ncurrent_sequence.append(sequence[i])\nindex_used[i] = True\ncreate_state_space_tree(sequence, current_sequence, index + 1, index_used)\ncurrent_sequence.pop()\nindex_used[i] = False", "successors": []}]}]}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "195.json", "name": "195.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport uuid\nfrom typing import Any, Literal\nfrom pinecone import Pinecone, ServerlessSpec\nfrom backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema\nfrom backend.data.model import APIKeyCredentials, CredentialsField, CredentialsMetaInput, SchemaField\nfrom backend.integrations.providers import ProviderName\nPineconeCredentials = APIKeyCredentials\nPineconeCredentialsInput = CredentialsMetaInput[Literal[ProviderName.\n    PINECONE], Literal['api_key']]", "successors": []}], "functions": [{"name": "PineconeCredentialsField", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"Creates a Pinecone credentials input on a block.\"\"\"\nreturn CredentialsField(description=\n    'The Pinecone integration can be used with an API Key.')", "successors": []}], "functions": [], "classes": []}], "classes": [{"name": "PineconeInitBlock", "type": "CFG", "blocks": [{"id": 7, "label": "#7", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 15, "label": "#15\nsuper().__init__(id='48d8fdab-8f03-41f3-8407-8107ba11ec9b', description=\n    'Initializes a Pinecone index', categories={BlockCategory.LOGIC},\n    input_schema=PineconeInitBlock.Input, output_schema=PineconeInitBlock.\n    Output)", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 18, "label": "#18\npc = Pinecone(api_key=credentials.api_key.get_secret_value())\ntry:", "successors": [{"id": 19, "label": "#19\nexisting_indexes = pc.list_indexes()\nif input_data.index_name not in [index.name for index in existing_indexes]:", "successors": [{"id": 22, "label": "#22\npc.create_index(name=input_data.index_name, dimension=input_data.dimension,\n    metric=input_data.metric, spec=ServerlessSpec(cloud=input_data.cloud,\n    region=input_data.region))\nmessage = f'Created new index: {input_data.index_name}'", "successors": [{"id": 23, "label": "#23\nyield 'index', input_data.index_name", "successors": [{"id": 25, "label": "#25\nyield 'message', message", "successors": []}]}]}, {"id": 24, "label": "#24\nmessage = f'Using existing index: {input_data.index_name}'", "successors": []}]}, {"id": 20, "label": "#20\nyield 'message', f'Error initializing Pinecone index: {str(e)}'", "successors": []}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 9, "label": "#9\ncredentials: PineconeCredentialsInput = PineconeCredentialsField()\nindex_name: str = SchemaField(description='Name of the Pinecone index')\ndimension: int = SchemaField(description='Dimension of the vectors',\n    default=768)\nmetric: str = SchemaField(description='Distance metric for the index',\n    default='cosine')\ncloud: str = SchemaField(description='Cloud provider for serverless',\n    default='aws')\nregion: str = SchemaField(description='Region for serverless', default=\n    'us-east-1')", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 12, "label": "#12\nindex: str = SchemaField(description='Name of the initialized Pinecone index')\nmessage: str = SchemaField(description='Status message')", "successors": []}], "functions": [], "classes": []}]}, {"name": "PineconeQueryBlock", "type": "CFG", "blocks": [{"id": 31, "label": "#31", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 39, "label": "#39\nsuper().__init__(id='9ad93d0f-91b4-4c9c-8eb1-82e26b4a01c5', description=\n    'Queries a Pinecone index', categories={BlockCategory.LOGIC},\n    input_schema=PineconeQueryBlock.Input, output_schema=PineconeQueryBlock\n    .Output)", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 42, "label": "#42\ntry:", "successors": [{"id": 43, "label": "#43\npc = Pinecone(api_key=credentials.api_key.get_secret_value())\nidx = pc.Index(input_data.idx_name)\nquery_vector = input_data.query_vector\nif isinstance(query_vector, list) and len(query_vector) > 0:", "successors": [{"id": 46, "label": "#46\nif isinstance(query_vector[0], list):", "successors": [{"id": 48, "label": "#48\nquery_vector = query_vector[0]", "successors": [{"id": 47, "label": "#47\nresults = idx.query(namespace=input_data.namespace, vector=query_vector,\n    top_k=input_data.top_k, include_values=input_data.include_values,\n    include_metadata=input_data.include_metadata).to_dict()\ncombined_text = ''\nif results['matches']:", "successors": [{"id": 50, "label": "#50\ntexts = [match['metadata']['text'] for match in results['matches'] if match\n    .get('metadata', {}).get('text')]\ncombined_text = '\\n\\n'.join(texts)", "successors": [{"id": 51, "label": "#51\nyield 'results', {'matches': results['matches'], 'combined_text': combined_text\n    }", "successors": [{"id": 52, "label": "#52\nyield 'combined_results', combined_text", "successors": []}]}]}]}]}]}]}, {"id": 44, "label": "#44\nerror_msg = f'Error querying Pinecone: {str(e)}'\nraise RuntimeError(error_msg) from e", "successors": []}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 33, "label": "#33\ncredentials: PineconeCredentialsInput = PineconeCredentialsField()\nquery_vector: list = SchemaField(description='Query vector')\nnamespace: str = SchemaField(description='Namespace to query in Pinecone',\n    default='')\ntop_k: int = SchemaField(description='Number of top results to return',\n    default=3)\ninclude_values: bool = SchemaField(description=\n    'Whether to include vector values in the response', default=False)\ninclude_metadata: bool = SchemaField(description=\n    'Whether to include metadata in the response', default=True)\nhost: str = SchemaField(description='Host for pinecone', default='')\nidx_name: str = SchemaField(description='Index name for pinecone')", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 36, "label": "#36\nresults: Any = SchemaField(description='Query results from Pinecone')\ncombined_results: Any = SchemaField(description=\n    'Combined results from Pinecone')", "successors": []}], "functions": [], "classes": []}]}, {"name": "PineconeInsertBlock", "type": "CFG", "blocks": [{"id": 58, "label": "#58", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 66, "label": "#66\nsuper().__init__(id='477f2168-cd91-475a-8146-9499a5982434', description=\n    'Upload data to a Pinecone index', categories={BlockCategory.LOGIC},\n    input_schema=PineconeInsertBlock.Input, output_schema=\n    PineconeInsertBlock.Output)", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 69, "label": "#69\ntry:", "successors": [{"id": 70, "label": "#70\npc = Pinecone(api_key=credentials.api_key.get_secret_value())\nidx = pc.Index(input_data.index)\nvectors = []", "successors": [{"id": 73, "label": "#73\nfor chunk, embedding in zip(input_data.chunks, input_data.embeddings):", "successors": [{"id": 74, "label": "#74\nvector_metadata = input_data.metadata.copy()\nvector_metadata['text'] = chunk\nvectors.append({'id': str(uuid.uuid4()), 'values': embedding, 'metadata':\n    vector_metadata})", "successors": []}, {"id": 75, "label": "#75\nidx.upsert(vectors=vectors, namespace=input_data.namespace)\nyield 'upsert_response', 'successfully upserted'", "successors": []}]}]}, {"id": 71, "label": "#71\nerror_msg = f'Error uploading to Pinecone: {str(e)}'\nraise RuntimeError(error_msg) from e", "successors": []}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 60, "label": "#60\ncredentials: PineconeCredentialsInput = PineconeCredentialsField()\nindex: str = SchemaField(description='Initialized Pinecone index')\nchunks: list = SchemaField(description='List of text chunks to ingest')\nembeddings: list = SchemaField(description=\n    'List of embeddings corresponding to the chunks')\nnamespace: str = SchemaField(description='Namespace to use in Pinecone',\n    default='')\nmetadata: dict = SchemaField(description=\n    'Additional metadata to store with each vector', default={})", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 63, "label": "#63\nupsert_response: str = SchemaField(description=\n    'Response from Pinecone upsert operation')", "successors": []}], "functions": [], "classes": []}]}]}
{"file_name": "196.json", "name": "196.json", "type": "CFG", "blocks": [{"id": 1, "label": "#1\n{'name': 'example_script', 'type': 'CFG', 'start_line': 1, 'end_line': 48,\n    'functions': [{'name': 'server', 'type': 'function', 'start_line': 20,\n    'end_line': 22, 'functions': [], 'classes': [], 'simplified_code':\n    \"\"\"async def server():\n    async with SpinTestServer() as server:\n        yield server\"\"\"\n    , 'blocks': [{'id': 1, 'label': 'async def server():', 'successors': [2\n    ]}, {'id': 2, 'label': 'async with SpinTestServer() as server:',\n    'successors': [3]}, {'id': 3, 'label': 'yield server', 'successors': []\n    }]}, {'name': 'graph_cleanup', 'type': 'function', 'start_line': 26,\n    'end_line': 48, 'functions': [{'name': 'create_graph_wrapper', 'type':\n    'function', 'start_line': 30, 'end_line': 35, 'functions': [],\n    'classes': [], 'simplified_code':\n    \"\"\"    async def create_graph_wrapper(*args, **kwargs):\n        created_graph = await original_create_graph(*args, **kwargs)\n        # Extract user_id correctly\n        user_id = kwargs.get(\"user_id\", args[2] if len(args) > 2 else None)\n        created_graph_ids.append((created_graph.id, user_id))\n        return created_graph\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    'created_graph = await original_create_graph(*args, **kwargs)',\n    'successors': [2]}, {'id': 2, 'label':\n    'user_id = kwargs.get(\"user_id\", args[2] if len(args) > 2 else None)',\n    'successors': [3]}, {'id': 3, 'label':\n    'created_graph_ids.append((created_graph.id, user_id))', 'successors':\n    [4]}, {'id': 4, 'label': 'return created_graph', 'successors': []}]}],\n    'classes': [], 'simplified_code':\n    \"\"\"async def graph_cleanup(server):\n    created_graph_ids = []\n    original_create_graph = server.agent_server.test_create_graph\n\n        return created_graph\n\n    try:\n        server.agent_server.test_create_graph = create_graph_wrapper\n        yield  # This runs the test function\n    finally:\n        server.agent_server.test_create_graph = original_create_graph\n\n        # Delete the created graphs and assert they were deleted\n        for graph_id, user_id in created_graph_ids:\n            if user_id:\n                resp = await server.agent_server.test_delete_graph(graph_id, user_id)\n                num_deleted = resp[\"version_counts\"]\n                assert num_deleted > 0, f\"Graph {graph_id} was not deleted.\\\"\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"async def graph_cleanup(server):\n    created_graph_ids = []\n    original_create_graph = server.agent_server.test_create_graph\"\"\"\n    , 'successors': [2, 3]}, {'id': 2, 'label':\n    \"\"\"def create_graph_wrapper(*args, **kwargs):\n    graph_id, user_id = original_create_graph(*args, **kwargs)\n    created_graph_ids.append((graph_id, user_id))\n    return created_graph\"\"\"\n    , 'successors': [3]}, {'id': 3, 'label':\n    \"\"\"try:\n    server.agent_server.test_create_graph = create_graph_wrapper\n    yield\nfinally:\n    server.agent_server.test_create_graph = original_create_graph\"\"\"\n    , 'successors': [4]}, {'id': 4, 'label':\n    \"\"\"for graph_id, user_id in created_graph_ids:\n    if user_id:\n        resp = await server.agent_server.test_delete_graph(graph_id, user_id)\n        num_deleted = resp[\"version_counts\"]\n        assert num_deleted > 0, f\"Graph {graph_id} was not deleted.\\\"\"\"\"\n    , 'successors': []}]}], 'classes': [], 'simplified_code':\n    \"\"\"import logging\n\nimport pytest\n\nfrom backend.util.test import SpinTestServer\n\n#  NOTE: You can run tests like with the --log-cli-level=INFO to see the logs\n# Set up logging\nlogger = logging.getLogger(__name__)\n\n# Create console handler with formatting\nch = logging.StreamHandler()\nch.setLevel(logging.INFO)\nformatter = logging.Formatter(\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\")\nch.setFormatter(formatter)\nlogger.addHandler(ch)\n\n\n@pytest.fixture(scope=\"session\")\n        yield server\n\n\n@pytest.fixture(scope=\"session\", autouse=True)\n                assert num_deleted > 0, f\"Graph {graph_id} was not deleted.\\\"\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"import logging\n\nimport pytest\n\nfrom backend.util.test import SpinTestServer\n\n#  NOTE: You can run tests like with the --log-cli-level=INFO to see the logs\n# Set up logging\nlogger = logging.getLogger(__name__)\n\n# Create console handler with formatting\nch = logging.StreamHandler()\nch.setLevel(logging.INFO)\nformatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\nch.setFormatter(formatter)\nlogger.addHandler(ch)\"\"\"\n    , 'successors': [2, 3]}, {'id': 2, 'label':\n    \"\"\"@pytest.fixture(scope='session')\nyield server\"\"\", 'successors': [3]},\n    {'id': 3, 'label':\n    \"\"\"@pytest.fixture(scope='session', autouse=True)\nassert num_deleted > 0, f'Graph {graph_id} was not deleted.'\"\"\"\n    , 'successors': []}]}", "successors": []}], "functions": [], "classes": []}
{"file_name": "197.json", "name": "197.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nif __name__ == '__main__':", "successors": [{"id": 9, "label": "#9\nimport doctest\ndoctest.testmod()", "successors": []}]}], "functions": [{"name": "binary_or", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"\n    Take in 2 integers, convert them to binary, and return a binary number that is the\n    result of a binary or operation on the integers provided.\n\n    >>> binary_or(25, 32)\n    '0b111001'\n    >>> binary_or(37, 50)\n    '0b110111'\n    >>> binary_or(21, 30)\n    '0b11111'\n    >>> binary_or(58, 73)\n    '0b1111011'\n    >>> binary_or(0, 255)\n    '0b11111111'\n    >>> binary_or(0, 256)\n    '0b100000000'\n    >>> binary_or(0, -1)\n    Traceback (most recent call last):\n    ValueError: the value of both inputs must be positive\n    >>> binary_or(0, 1.1)\n    Traceback (most recent call last):\n    TypeError: 'float' object cannot be interpreted as an integer\n    >>> binary_or(\"0\", \"1\")\n    Traceback (most recent call last):\n    TypeError: '<' not supported between instances of 'str' and 'int'\n    \"\"\"\nif a < 0 or b < 0:", "successors": [{"id": 4, "label": "#4\nraise ValueError('the value of both inputs must be positive')", "successors": []}, {"id": 5, "label": "#5\na_binary = str(bin(a))[2:]\nb_binary = str(bin(b))[2:]\nmax_len = max(len(a_binary), len(b_binary))\nreturn '0b' + ''.join(str(int('1' in (char_a, char_b))) for char_a, char_b in\n    zip(a_binary.zfill(max_len), b_binary.zfill(max_len)))", "successors": []}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "198.json", "name": "198.json", "type": "CFG", "blocks": [{"id": 1, "label": "#1\n{'name': 'example_script', 'type': 'CFG', 'start_line': 1, 'end_line': 20,\n    'functions': [{'name': 'configure_logging', 'type': 'function',\n    'start_line': 6, 'end_line': 20, 'functions': [], 'classes': [],\n    'simplified_code':\n    \"\"\"def configure_logging():\n    import logging\n\n    import autogpt_libs.logging.config\n\n    if (\n        settings.config.behave_as == BehaveAs.LOCAL\n        or settings.config.app_env == AppEnvironment.LOCAL\n    ):\n        autogpt_libs.logging.config.configure_logging(force_cloud_logging=False)\n    else:\n        autogpt_libs.logging.config.configure_logging(force_cloud_logging=True)\n\n    # Silence httpx logger\n    logging.getLogger(\"httpx\").setLevel(logging.WARNING)\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"def configure_logging():\n    import logging\n\n    import autogpt_libs.logging.config\"\"\"\n    , 'successors': [2]}, {'id': 2, 'label':\n    \"\"\"if (\n        settings.config.behave_as == BehaveAs.LOCAL\n        or settings.config.app_env == AppEnvironment.LOCAL\n    ):\"\"\"\n    , 'successors': [3, 4]}, {'id': 3, 'label':\n    'autogpt_libs.logging.config.configure_logging(force_cloud_logging=False)',\n    'successors': [5]}, {'id': 4, 'label':\n    'autogpt_libs.logging.config.configure_logging(force_cloud_logging=True)',\n    'successors': [5]}, {'id': 5, 'label':\n    'logging.getLogger(\"httpx\").setLevel(logging.WARNING)', 'successors': [\n    ]}]}], 'classes': [], 'simplified_code':\n    \"\"\"from backend.util.settings import AppEnvironment, BehaveAs, Settings\n\nsettings = Settings()\n\n\n    logging.getLogger(\"httpx\").setLevel(logging.WARNING)\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"from backend.util.settings import AppEnvironment, BehaveAs, Settings\n\nsettings = Settings()\"\"\"\n    , 'successors': [2]}, {'id': 2, 'label':\n    'logging.getLogger(\"httpx\").setLevel(logging.WARNING)', 'successors': []}]}", "successors": []}], "functions": [], "classes": []}
{"file_name": "199.json", "name": "199.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nif __name__ == '__main__':", "successors": [{"id": 12, "label": "#12\n\"\"\"\n    Finding the index of rightmost set bit has some very peculiar use-cases,\n    especially in finding missing or/and repeating numbers in a list of\n    positive integers.\n    \"\"\"\nimport doctest\ndoctest.testmod(verbose=True)", "successors": []}]}], "functions": [{"name": "get_index_of_rightmost_set_bit", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"\n    Take in a positive integer 'number'.\n    Returns the zero-based index of first set bit in that 'number' from right.\n    Returns -1, If no set bit found.\n\n    >>> get_index_of_rightmost_set_bit(0)\n    -1\n    >>> get_index_of_rightmost_set_bit(5)\n    0\n    >>> get_index_of_rightmost_set_bit(36)\n    2\n    >>> get_index_of_rightmost_set_bit(8)\n    3\n    >>> get_index_of_rightmost_set_bit(-18)\n    Traceback (most recent call last):\n    ValueError: Input must be a non-negative integer\n    >>> get_index_of_rightmost_set_bit('test')\n    Traceback (most recent call last):\n    ValueError: Input must be a non-negative integer\n    >>> get_index_of_rightmost_set_bit(1.25)\n    Traceback (most recent call last):\n    ValueError: Input must be a non-negative integer\n    \"\"\"\nif not isinstance(number, int) or number < 0:", "successors": [{"id": 4, "label": "#4\nraise ValueError('Input must be a non-negative integer')", "successors": []}, {"id": 5, "label": "#5\nintermediate = number & ~(number - 1)\nindex = 0", "successors": [{"id": 7, "label": "#7\nwhile intermediate:", "successors": [{"id": 8, "label": "#8\nintermediate >>= 1\nindex += 1", "successors": []}, {"id": 9, "label": "#9\nreturn index - 1", "successors": []}]}]}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "200.json", "name": "200.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport ipaddress\nimport re\nimport socket\nfrom typing import Callable\nfrom urllib.parse import urlparse, urlunparse\nimport idna\nimport requests as req\nfrom backend.util.settings import Config\nBLOCKED_IP_NETWORKS = [ipaddress.ip_network('0.0.0.0/8'), ipaddress.\n    ip_network('10.0.0.0/8'), ipaddress.ip_network('127.0.0.0/8'),\n    ipaddress.ip_network('169.254.0.0/16'), ipaddress.ip_network(\n    '172.16.0.0/12'), ipaddress.ip_network('192.168.0.0/16'), ipaddress.\n    ip_network('224.0.0.0/4'), ipaddress.ip_network('240.0.0.0/4')]\nALLOWED_SCHEMES = ['http', 'https']\nHOSTNAME_REGEX = re.compile('^[A-Za-z0-9.-]+$')\nrequests = Requests(trusted_origins=Config().trust_endpoints_for_requests)", "successors": []}], "functions": [{"name": "_canonicalize_url", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nurl = url.strip().strip('/')\nif not url.startswith(('http://', 'https://')):", "successors": [{"id": 4, "label": "#4\nurl = 'http://' + url", "successors": [{"id": 5, "label": "#5\nurl = url.replace('\\\\', '/')\nreturn url", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "_is_ip_blocked", "type": "CFG", "blocks": [{"id": 9, "label": "#9\n\"\"\"\n    Checks if the IP address is in a blocked network.\n    \"\"\"\nip_addr = ipaddress.ip_address(ip)\nreturn any(ip_addr in network for network in BLOCKED_IP_NETWORKS)", "successors": []}], "functions": [], "classes": []}, {"name": "validate_url", "type": "CFG", "blocks": [{"id": 13, "label": "#13\n\"\"\"\n    Validates the URL to prevent SSRF attacks by ensuring it does not point to a private\n    or untrusted IP address, unless whitelisted.\n    \"\"\"\nurl = _canonicalize_url(url)\nparsed = urlparse(url)\nif parsed.scheme not in ALLOWED_SCHEMES:", "successors": [{"id": 14, "label": "#14\nraise ValueError(\n    f\"Scheme '{parsed.scheme}' is not allowed. Only HTTP/HTTPS are supported.\")", "successors": []}, {"id": 15, "label": "#15\nif not parsed.hostname:", "successors": [{"id": 17, "label": "#17\nraise ValueError('Invalid URL: No hostname found.')", "successors": []}, {"id": 18, "label": "#18\ntry:", "successors": [{"id": 20, "label": "#20\nascii_hostname = idna.encode(parsed.hostname).decode('ascii')", "successors": [{"id": 22, "label": "#22\nif not HOSTNAME_REGEX.match(ascii_hostname):", "successors": [{"id": 24, "label": "#24\nraise ValueError('Hostname contains invalid characters.')", "successors": []}, {"id": 25, "label": "#25\nparsed = parsed._replace(netloc=ascii_hostname)\nurl = str(urlunparse(parsed))\nif ascii_hostname in trusted_origins:", "successors": [{"id": 27, "label": "#27\nreturn url", "successors": []}, {"id": 28, "label": "#28\ntry:", "successors": [{"id": 30, "label": "#30\nip_addresses = {res[4][0] for res in socket.getaddrinfo(ascii_hostname, None)}", "successors": [{"id": 32, "label": "#32\nif not ip_addresses:", "successors": [{"id": 34, "label": "#34\nraise ValueError(f'No IP addresses found for {ascii_hostname}')", "successors": []}, {"id": 35, "label": "#35\nfor ip in ip_addresses:", "successors": [{"id": 37, "label": "#37\nif _is_ip_blocked(ip):", "successors": [{"id": 39, "label": "#39\nraise ValueError(\n    f'Access to private IP address {ip} for hostname {ascii_hostname} is not allowed.'\n    )", "successors": []}]}, {"id": 38, "label": "#38\nreturn url", "successors": []}]}]}]}, {"id": 31, "label": "#31\nraise ValueError(f'Unable to resolve IP address for hostname {ascii_hostname}')", "successors": []}]}]}]}]}, {"id": 21, "label": "#21\nraise ValueError('Invalid hostname with unsupported characters.')", "successors": []}]}]}]}], "functions": [], "classes": []}], "classes": [{"name": "Requests", "type": "CFG", "blocks": [{"id": 45, "label": "#45\n\"\"\"\n    A wrapper around the requests library that validates URLs before making requests.\n    \"\"\"", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 47, "label": "#47\nself.trusted_origins = []", "successors": [{"id": 48, "label": "#48\nfor url in (trusted_origins or []):", "successors": [{"id": 49, "label": "#49\nhostname = urlparse(url).hostname\nif not hostname:", "successors": [{"id": 51, "label": "#51\nraise ValueError(f'Invalid URL: Unable to determine hostname of {url}')", "successors": []}, {"id": 52, "label": "#52\nself.trusted_origins.append(hostname)", "successors": []}]}, {"id": 50, "label": "#50\nself.raise_for_status = raise_for_status\nself.extra_url_validator = extra_url_validator\nself.extra_headers = extra_headers", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "request", "type": "CFG", "blocks": [{"id": 56, "label": "#56\nif self.extra_headers is not None:", "successors": [{"id": 57, "label": "#57\nheaders = {**headers or {}, **self.extra_headers}", "successors": [{"id": 58, "label": "#58\nurl = validate_url(url, self.trusted_origins)\nif self.extra_url_validator is not None:", "successors": [{"id": 59, "label": "#59\nurl = self.extra_url_validator(url)", "successors": [{"id": 60, "label": "#60\nresponse = req.request(method, url, *args, headers=headers, allow_redirects\n    =allow_redirects, **kwargs)\nif self.raise_for_status:", "successors": [{"id": 61, "label": "#61\nresponse.raise_for_status()", "successors": [{"id": 62, "label": "#62\nreturn response", "successors": []}]}]}]}]}]}]}], "functions": [], "classes": []}, {"name": "get", "type": "CFG", "blocks": [{"id": 66, "label": "#66\nreturn self.request('GET', url, *args, **kwargs)", "successors": []}], "functions": [], "classes": []}, {"name": "post", "type": "CFG", "blocks": [{"id": 70, "label": "#70\nreturn self.request('POST', url, *args, **kwargs)", "successors": []}], "functions": [], "classes": []}, {"name": "put", "type": "CFG", "blocks": [{"id": 74, "label": "#74\nreturn self.request('PUT', url, *args, **kwargs)", "successors": []}], "functions": [], "classes": []}, {"name": "delete", "type": "CFG", "blocks": [{"id": 78, "label": "#78\nreturn self.request('DELETE', url, *args, **kwargs)", "successors": []}], "functions": [], "classes": []}, {"name": "head", "type": "CFG", "blocks": [{"id": 82, "label": "#82\nreturn self.request('HEAD', url, *args, **kwargs)", "successors": []}], "functions": [], "classes": []}, {"name": "options", "type": "CFG", "blocks": [{"id": 86, "label": "#86\nreturn self.request('OPTIONS', url, *args, **kwargs)", "successors": []}], "functions": [], "classes": []}, {"name": "patch", "type": "CFG", "blocks": [{"id": 90, "label": "#90\nreturn self.request('PATCH', url, *args, **kwargs)", "successors": []}], "functions": [], "classes": []}], "classes": []}]}
{"file_name": "201.json", "name": "201.json", "type": "CFG", "blocks": [{"id": 1, "label": "#1\n{'name': 'example_script', 'type': 'CFG', 'start_line': 1, 'end_line': 95,\n    'functions': [{'name': 'get_bounds', 'type': 'function', 'start_line': \n    22, 'end_line': 35, 'functions': [], 'classes': [], 'simplified_code':\n    \"\"\"def get_bounds(\n    fft_results: np.ndarray, samplerate: int\n) -> tuple[int | float, int | float]:\n    \"\"\\\"\n    Get bounds for printing fft results\n\n    >>> import numpy\n    >>> array = numpy.linspace(-20.0, 20.0, 1000)\n    >>> get_bounds(array, 1000)\n    (-20, 20)\n    \"\"\\\"\n    lowest = min([-20, np.min(fft_results[1 : samplerate // 2 - 1])])\n    highest = max([20, np.max(fft_results[1 : samplerate // 2 - 1])])\n    return lowest, highest\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    'lowest = min([-20, np.min(fft_results[1 : samplerate // 2 - 1])])',\n    'successors': [2]}, {'id': 2, 'label':\n    'highest = max([20, np.max(fft_results[1 : samplerate // 2 - 1])])',\n    'successors': [3]}, {'id': 3, 'label': 'return lowest, highest',\n    'successors': []}]}, {'name': 'show_frequency_response', 'type':\n    'function', 'start_line': 38, 'end_line': 67, 'functions': [],\n    'classes': [], 'simplified_code':\n    \"\"\"def show_frequency_response(filter_type: FilterType, samplerate: int) -> None:\n    \"\"\\\"\n    Show frequency response of a filter\n\n    >>> from audio_filters.iir_filter import IIRFilter\n    >>> filt = IIRFilter(4)\n    >>> show_frequency_response(filt, 48000)\n    \"\"\\\"\n\n    size = 512\n    inputs = [1] + [0] * (size - 1)\n    outputs = [filter_type.process(item) for item in inputs]\n\n    filler = [0] * (samplerate - size)  # zero-padding\n    outputs += filler\n    fft_out = np.abs(np.fft.fft(outputs))\n    fft_db = 20 * np.log10(fft_out)\n\n    # Frequencies on log scale from 24 to nyquist frequency\n    plt.xlim(24, samplerate / 2 - 1)\n    plt.xlabel(\"Frequency (Hz)\")\n    plt.xscale(\"log\")\n\n    # Display within reasonable bounds\n    bounds = get_bounds(fft_db, samplerate)\n    plt.ylim(max([-80, bounds[0]]), min([80, bounds[1]]))\n    plt.ylabel(\"Gain (dB)\")\n\n    plt.plot(fft_db)\n    plt.show()\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    'def show_frequency_response(filter_type: FilterType, samplerate: int) -> None:'\n    , 'successors': [2]}, {'id': 2, 'label':\n    \"\"\"    size = 512\n    inputs = [1] + [0] * (size - 1)\n    outputs = [filter_type.process(item) for item in inputs]\"\"\"\n    , 'successors': [3]}, {'id': 3, 'label':\n    \"\"\"    filler = [0] * (samplerate - size)  # zero-padding\n    outputs += filler\n    fft_out = np.abs(np.fft.fft(outputs))\n    fft_db = 20 * np.log10(fft_out)\"\"\"\n    , 'successors': [4]}, {'id': 4, 'label':\n    \"\"\"    plt.xlim(24, samplerate / 2 - 1)\n    plt.xlabel(\"Frequency (Hz)\")\n    plt.xscale(\"log\")\"\"\"\n    , 'successors': [5]}, {'id': 5, 'label':\n    \"\"\"    bounds = get_bounds(fft_db, samplerate)\n    plt.ylim(max([-80, bounds[0]]), min([80, bounds[1]]))\n    plt.ylabel(\"Gain (dB)\")\"\"\"\n    , 'successors': [6]}, {'id': 6, 'label':\n    \"\"\"    plt.plot(fft_db)\n    plt.show()\"\"\", 'successors': []}]}, {'name':\n    'show_phase_response', 'type': 'function', 'start_line': 70, 'end_line':\n    95, 'functions': [], 'classes': [], 'simplified_code':\n    \"\"\"def show_phase_response(filter_type: FilterType, samplerate: int) -> None:\n    \"\"\\\"\n    Show phase response of a filter\n\n    >>> from audio_filters.iir_filter import IIRFilter\n    >>> filt = IIRFilter(4)\n    >>> show_phase_response(filt, 48000)\n    \"\"\\\"\n\n    size = 512\n    inputs = [1] + [0] * (size - 1)\n    outputs = [filter_type.process(item) for item in inputs]\n\n    filler = [0] * (samplerate - size)  # zero-padding\n    outputs += filler\n    fft_out = np.angle(np.fft.fft(outputs))\n\n    # Frequencies on log scale from 24 to nyquist frequency\n    plt.xlim(24, samplerate / 2 - 1)\n    plt.xlabel(\"Frequency (Hz)\")\n    plt.xscale(\"log\")\n\n    plt.ylim(-2 * pi, 2 * pi)\n    plt.ylabel(\"Phase shift (Radians)\")\n    plt.plot(np.unwrap(fft_out, -2 * pi))\n    plt.show()\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"def show_phase_response(filter_type: FilterType, samplerate: int) -> None:\n    \"\"\\\"\n    Show phase response of a filter\n\n    >>> from audio_filters.iir_filter import IIRFilter\n    >>> filt = IIRFilter(4)\n    >>> show_phase_response(filt, 48000)\n    \"\"\\\"\n\n    size = 512\n    inputs = [1] + [0] * (size - 1)\n    outputs = [filter_type.process(item) for item in inputs]\"\"\"\n    , 'successors': [2]}, {'id': 2, 'label':\n    \"\"\"filler = [0] * (samplerate - size)  # zero-padding\n    outputs += filler\n    fft_out = np.angle(np.fft.fft(outputs))\"\"\"\n    , 'successors': [3]}, {'id': 3, 'label':\n    \"\"\"plt.xlim(24, samplerate / 2 - 1)\n    plt.xlabel(\"Frequency (Hz)\")\n    plt.xscale(\"log\")\"\"\"\n    , 'successors': [4]}, {'id': 4, 'label':\n    \"\"\"plt.ylim(-2 * pi, 2 * pi)\n    plt.ylabel(\"Phase shift (Radians)\")\n    plt.plot(np.unwrap(fft_out, -2 * pi))\n    plt.show()\"\"\"\n    , 'successors': []}]}], 'classes': [{'name': 'FilterType', 'type':\n    'class', 'start_line': 11, 'end_line': 20, 'functions': [{'name':\n    'process', 'type': 'function', 'start_line': 13, 'end_line': 19,\n    'functions': [], 'classes': [], 'simplified_code':\n    \"\"\"    def process(self, sample: float) -> float:\n        \"\"\\\"\n        Calculate y[n]\n\n        >>> issubclass(FilterType, Protocol)\n        True\n        \"\"\\\"\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"def process(self, sample: float) -> float:\n    \"\"\\\"\n    Calculate y[n]\n\n    >>> issubclass(FilterType, Protocol)\n    True\n    \"\"\\\"\"\"\"\n    , 'successors': []}]}], 'classes': [], 'simplified_code':\n    \"\"\"class FilterType(Protocol):\n    @abstractmethod\n        \"\"\\\"\n\"\"\",\n    'blocks': [{'id': 1, 'label': 'pass', 'successors': []}]}],\n    'simplified_code':\n    \"\"\"from __future__ import annotations\n\nfrom abc import abstractmethod\nfrom math import pi\nfrom typing import Protocol\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\n\n\n    return lowest, highest\n\n\n    plt.show()\n\n\n    plt.show()\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"from __future__ import annotations\n\nfrom abc import abstractmethod\nfrom math import pi\nfrom typing import Protocol\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\n\n\n    return lowest, highest\n\n\n    plt.show()\n\n\n    plt.show()\"\"\"\n    , 'successors': []}]}", "successors": []}], "functions": [], "classes": []}
{"file_name": "202.json", "name": "202.json", "type": "CFG", "blocks": [{"id": 1, "label": "#1\n{'name': 'example_script', 'type': 'CFG', 'start_line': 1, 'end_line': 46,\n    'functions': [{'name': 'requires_user', 'type': 'function',\n    'start_line': 8, 'end_line': 9, 'functions': [], 'classes': [],\n    'simplified_code':\n    \"\"\"def requires_user(payload: dict = fastapi.Depends(auth_middleware)) -> User:\n    return verify_user(payload, admin_only=False)\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"def requires_user(payload: dict = fastapi.Depends(auth_middleware)) -> User:\n    return verify_user(payload, admin_only=False)\"\"\"\n    , 'successors': []}]}, {'name': 'requires_admin_user', 'type':\n    'function', 'start_line': 12, 'end_line': 15, 'functions': [],\n    'classes': [], 'simplified_code':\n    \"\"\"def requires_admin_user(\n    payload: dict = fastapi.Depends(auth_middleware),\n) -> User:\n    return verify_user(payload, admin_only=True)\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"def requires_admin_user(\n    payload: dict = fastapi.Depends(auth_middleware),\n) -> User:\n    return verify_user(payload, admin_only=True)\"\"\"\n    , 'successors': []}]}, {'name': 'verify_user', 'type': 'function',\n    'start_line': 18, 'end_line': 37, 'functions': [], 'classes': [],\n    'simplified_code':\n    \"\"\"def verify_user(payload: dict | None, admin_only: bool) -> User:\n    if not payload:\n        if Settings.ENABLE_AUTH:\n            raise fastapi.HTTPException(\n                status_code=401, detail=\"Authorization header is missing\"\n            )\n        # This handles the case when authentication is disabled\n        payload = {\"sub\": DEFAULT_USER_ID, \"role\": \"admin\"}\n\n    user_id = payload.get(\"sub\")\n\n    if not user_id:\n        raise fastapi.HTTPException(\n            status_code=401, detail=\"User ID not found in token\"\n        )\n\n    if admin_only and payload[\"role\"] != \"admin\":\n        raise fastapi.HTTPException(status_code=403, detail=\"Admin access required\")\n\n    return User.from_payload(payload)\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    'def verify_user(payload: dict | None, admin_only: bool) -> User:',\n    'successors': [2]}, {'id': 2, 'label': 'if not payload:', 'successors':\n    [3, 6]}, {'id': 3, 'label': 'if Settings.ENABLE_AUTH:', 'successors': [\n    4, 5]}, {'id': 4, 'label':\n    \"\"\"raise fastapi.HTTPException(\n    status_code=401, detail=\"Authorization header is missing\"\n)\"\"\"\n    , 'successors': []}, {'id': 5, 'label':\n    'payload = {\"sub\": DEFAULT_USER_ID, \"role\": \"admin\"}', 'successors': [6\n    ]}, {'id': 6, 'label': 'user_id = payload.get(\"sub\")', 'successors': [7\n    ]}, {'id': 7, 'label': 'if not user_id:', 'successors': [8, 9]}, {'id':\n    8, 'label':\n    \"\"\"raise fastapi.HTTPException(\n    status_code=401, detail=\"User ID not found in token\"\n)\"\"\"\n    , 'successors': []}, {'id': 9, 'label':\n    'if admin_only and payload[\"role\"] != \"admin\":', 'successors': [10, 11]\n    }, {'id': 10, 'label':\n    'raise fastapi.HTTPException(status_code=403, detail=\"Admin access required\")'\n    , 'successors': []}, {'id': 11, 'label':\n    'return User.from_payload(payload)', 'successors': []}]}, {'name':\n    'get_user_id', 'type': 'function', 'start_line': 40, 'end_line': 46,\n    'functions': [], 'classes': [], 'simplified_code':\n    \"\"\"def get_user_id(payload: dict = fastapi.Depends(auth_middleware)) -> str:\n    user_id = payload.get(\"sub\")\n    if not user_id:\n        raise fastapi.HTTPException(\n            status_code=401, detail=\"User ID not found in token\"\n        )\n    return user_id\"\"\"\n    , 'blocks': [{'id': 1, 'label': 'user_id = payload.get(\"sub\")',\n    'successors': [2]}, {'id': 2, 'label': 'if not user_id:', 'successors':\n    [3, 4]}, {'id': 3, 'label':\n    \"\"\"raise fastapi.HTTPException(\n    status_code=401, detail=\"User ID not found in token\"\n)\"\"\"\n    , 'successors': []}, {'id': 4, 'label': 'return user_id', 'successors':\n    []}]}], 'classes': [], 'simplified_code':\n    \"\"\"import fastapi\n\nfrom .config import Settings\nfrom .middleware import auth_middleware\nfrom .models import DEFAULT_USER_ID, User\n\n\n    return verify_user(payload, admin_only=False)\n\n\n    return verify_user(payload, admin_only=True)\n\n\n    return User.from_payload(payload)\n\n\n    return user_id\"\"\"\n    , 'blocks': [{'id': 1, 'label': 'import fastapi', 'successors': [2]}, {\n    'id': 2, 'label': 'from .config import Settings', 'successors': [3]}, {\n    'id': 3, 'label': 'from .middleware import auth_middleware',\n    'successors': [4]}, {'id': 4, 'label':\n    'from .models import DEFAULT_USER_ID, User', 'successors': [5]}, {'id':\n    5, 'label': 'return verify_user(payload, admin_only=False)',\n    'successors': []}, {'id': 6, 'label':\n    'return verify_user(payload, admin_only=True)', 'successors': []}, {\n    'id': 7, 'label': 'return User.from_payload(payload)', 'successors': []\n    }, {'id': 8, 'label': 'return user_id', 'successors': []}]}", "successors": []}], "functions": [], "classes": []}
{"file_name": "203.json", "name": "203.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport contextlib\nimport logging.config\nimport os\nimport dotenv\nimport fastapi\nimport fastapi.middleware.cors\nimport fastapi.middleware.gzip\nimport prisma\nimport prometheus_fastapi_instrumentator\nimport sentry_sdk\nimport sentry_sdk.integrations.asyncio\nimport sentry_sdk.integrations.fastapi\nimport sentry_sdk.integrations.starlette\nimport market.config\nimport market.routes.admin\nimport market.routes.agents\nimport market.routes.analytics\nimport market.routes.search\nimport market.routes.submissions\ndotenv.load_dotenv()\nlogging.config.dictConfig(market.config.LogConfig().model_dump())\nif os.environ.get('SENTRY_DSN'):", "successors": [{"id": 2, "label": "#2\nsentry_sdk.init(dsn=os.environ.get('SENTRY_DSN'), traces_sample_rate=1.0,\n    profiles_sample_rate=1.0, enable_tracing=True, environment=os.environ.\n    get('RUN_ENV', default='CLOUD').lower(), integrations=[sentry_sdk.\n    integrations.starlette.StarletteIntegration(transaction_style='url'),\n    sentry_sdk.integrations.fastapi.FastApiIntegration(transaction_style=\n    'url'), sentry_sdk.integrations.asyncio.AsyncioIntegration()])", "successors": [{"id": 3, "label": "#3\ndb_client = prisma.Prisma(auto_register=True)\ndocs_url = '/docs'\napp = fastapi.FastAPI(title='Marketplace API', description=\n    'AutoGPT Marketplace API is a service that allows users to share AI agents.'\n    , summary='Maketplace API', version='0.1', lifespan=lifespan, root_path\n    ='/api/v1/market', docs_url=docs_url)\napp.add_middleware(fastapi.middleware.gzip.GZipMiddleware, minimum_size=1000)\napp.add_middleware(middleware_class=fastapi.middleware.cors.CORSMiddleware,\n    allow_origins=os.environ.get('BACKEND_CORS_ALLOW_ORIGINS',\n    'http://localhost:3000,http://127.0.0.1:3000').split(','),\n    allow_credentials=True, allow_methods=['*'], allow_headers=['*'])\napp.include_router(market.routes.agents.router, tags=['agents'])\napp.include_router(market.routes.search.router, tags=['search'])\napp.include_router(market.routes.submissions.router, tags=['submissions'])\napp.include_router(market.routes.admin.router, prefix='/admin', tags=['admin'])\napp.include_router(market.routes.analytics.router, prefix='/analytics',\n    tags=['analytics'])\nprometheus_fastapi_instrumentator.Instrumentator().instrument(app).expose(app)", "successors": []}]}]}], "functions": [{"name": "lifespan", "type": "CFG", "blocks": [{"id": 5, "label": "#5\nawait db_client.connect()", "successors": [{"id": 6, "label": "#6\nyield", "successors": [{"id": 7, "label": "#7\nawait db_client.disconnect()", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "health", "type": "CFG", "blocks": [{"id": 11, "label": "#11\nreturn fastapi.responses.HTMLResponse(content='<h1>Marketplace API</h1>',\n    status_code=200)", "successors": []}], "functions": [], "classes": []}, {"name": "default", "type": "CFG", "blocks": [{"id": 15, "label": "#15\nreturn fastapi.responses.HTMLResponse(content='<h1>Marketplace API</h1>',\n    status_code=200)", "successors": []}], "functions": [], "classes": []}], "classes": []}
{"file_name": "204.json", "name": "204.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom backend.blocks.hubspot._auth import HubSpotCredentials, HubSpotCredentialsField, HubSpotCredentialsInput\nfrom backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema\nfrom backend.data.model import SchemaField\nfrom backend.util.request import requests", "successors": []}], "functions": [], "classes": [{"name": "HubSpotCompanyBlock", "type": "CFG", "blocks": [{"id": 3, "label": "#3", "successors": []}], "functions": [{"name": "__init__", "type": "CFG", "blocks": [{"id": 11, "label": "#11\nsuper().__init__(id='3ae02219-d540-47cd-9c78-3ad6c7d9820a', description=\n    'Manages HubSpot companies - create, update, and retrieve company information'\n    , categories={BlockCategory.CRM}, input_schema=HubSpotCompanyBlock.\n    Input, output_schema=HubSpotCompanyBlock.Output)", "successors": []}], "functions": [], "classes": []}, {"name": "run", "type": "CFG", "blocks": [{"id": 14, "label": "#14\nbase_url = 'https://api.hubapi.com/crm/v3/objects/companies'\nheaders = {'Authorization':\n    f'Bearer {credentials.api_key.get_secret_value()}', 'Content-Type':\n    'application/json'}\nif input_data.operation == 'create':", "successors": [{"id": 15, "label": "#15\nresponse = requests.post(base_url, headers=headers, json={'properties':\n    input_data.company_data})\nresult = response.json()\nyield 'company', result", "successors": [{"id": 32, "label": "#32\nyield 'status', 'created'", "successors": []}]}, {"id": 17, "label": "#17\nif input_data.operation == 'get':", "successors": [{"id": 18, "label": "#18\nsearch_url = f'{base_url}/search'\nsearch_data = {'filterGroups': [{'filters': [{'propertyName': 'domain',\n    'operator': 'EQ', 'value': input_data.domain}]}]}\nresponse = requests.post(search_url, headers=headers, json=search_data)\nresult = response.json()\nyield 'company', result.get('results', [{}])[0]", "successors": [{"id": 30, "label": "#30\nyield 'status', 'retrieved'", "successors": []}]}, {"id": 20, "label": "#20\nif input_data.operation == 'update':", "successors": [{"id": 21, "label": "#21\nsearch_response = requests.post(f'{base_url}/search', headers=headers, json\n    ={'filterGroups': [{'filters': [{'propertyName': 'domain', 'operator':\n    'EQ', 'value': input_data.domain}]}]})\ncompany_id = search_response.json().get('results', [{}])[0].get('id')\nif company_id:", "successors": [{"id": 23, "label": "#23\nresponse = requests.patch(f'{base_url}/{company_id}', headers=headers, json\n    ={'properties': input_data.company_data})\nresult = response.json()\nyield 'company', result", "successors": [{"id": 28, "label": "#28\nyield 'status', 'updated'", "successors": []}]}, {"id": 25, "label": "#25\nyield 'company', {}", "successors": [{"id": 26, "label": "#26\nyield 'status', 'company_not_found'", "successors": []}]}]}]}]}]}], "functions": [], "classes": []}], "classes": [{"name": "Input", "type": "CFG", "blocks": [{"id": 5, "label": "#5\ncredentials: HubSpotCredentialsInput = HubSpotCredentialsField()\noperation: str = SchemaField(description=\n    'Operation to perform (create, update, get)', default='get')\ncompany_data: dict = SchemaField(description=\n    'Company data for create/update operations', default={})\ndomain: str = SchemaField(description=\n    'Company domain for get/update operations', default='')", "successors": []}], "functions": [], "classes": []}, {"name": "Output", "type": "CFG", "blocks": [{"id": 8, "label": "#8\ncompany: dict = SchemaField(description='Company information')\nstatus: str = SchemaField(description='Operation status')", "successors": []}], "functions": [], "classes": []}]}]}
{"file_name": "205.json", "name": "205.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\n\"\"\"Analytics API\"\"\"\nfrom typing import Annotated\nimport fastapi\nimport backend.data.analytics\nfrom backend.server.utils import get_user_id\nrouter = fastapi.APIRouter()", "successors": []}], "functions": [{"name": "log_raw_metric", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nresult = await backend.data.analytics.log_raw_metric(user_id=user_id,\n    metric_name=metric_name, metric_value=metric_value, data_string=data_string\n    )", "successors": [{"id": 4, "label": "#4\nreturn result.id", "successors": []}]}], "functions": [], "classes": []}, {"name": "log_raw_analytics", "type": "CFG", "blocks": [{"id": 8, "label": "#8\nresult = await backend.data.analytics.log_raw_analytics(user_id, type, data,\n    data_index)", "successors": [{"id": 9, "label": "#9\nreturn result.id", "successors": []}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "206.json", "name": "206.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nimport pytest\nfrom backend.data import db\nfrom backend.executor import ExecutionScheduler\nfrom backend.server.model import CreateGraph\nfrom backend.usecases.sample import create_test_graph, create_test_user\nfrom backend.util.service import get_service_client\nfrom backend.util.test import SpinTestServer", "successors": []}], "functions": [{"name": "test_agent_schedule", "type": "CFG", "blocks": [{"id": 3, "label": "#3\nawait db.connect()", "successors": [{"id": 4, "label": "#4\ntest_user = await create_test_user()", "successors": [{"id": 5, "label": "#5\ntest_graph = await server.agent_server.test_create_graph(create_graph=\n    CreateGraph(graph=create_test_graph()), user_id=test_user.id)", "successors": [{"id": 6, "label": "#6\nscheduler = get_service_client(ExecutionScheduler)\nschedules = scheduler.get_execution_schedules(test_graph.id, test_user.id)\nassert len(schedules) == 0", "successors": [{"id": 8, "label": "#8\nschedule = scheduler.add_execution_schedule(graph_id=test_graph.id, user_id\n    =test_user.id, graph_version=1, cron='0 0 * * *', input_data={'input':\n    'data'})\nassert schedule", "successors": [{"id": 10, "label": "#10\nschedules = scheduler.get_execution_schedules(test_graph.id, test_user.id)\nassert len(schedules) == 1", "successors": [{"id": 12, "label": "#12\nassert schedules[0].cron == '0 0 * * *'", "successors": [{"id": 14, "label": "#14\nscheduler.delete_schedule(schedule.id, user_id=test_user.id)\nschedules = scheduler.get_execution_schedules(test_graph.id, user_id=\n    test_user.id)\nassert len(schedules) == 0", "successors": []}]}]}]}]}]}]}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "207.json", "name": "207.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\n\"\"\"\nWord Ladder is a classic problem in computer science.\nThe problem is to transform a start word into an end word\nby changing one letter at a time.\nEach intermediate word must be a valid word from a given list of words.\nThe goal is to find a transformation sequence\nfrom the start word to the end word.\n\nWikipedia: https://en.wikipedia.org/wiki/Word_ladder\n\"\"\"\nimport string", "successors": []}], "functions": [{"name": "backtrack", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"\n    Helper function to perform backtracking to find the transformation\n    from the current_word to the end_word.\n\n    Parameters:\n    current_word (str): The current word in the transformation sequence.\n    path (list[str]): The list of transformations from begin_word to current_word.\n    end_word (str): The target word for transformation.\n    word_set (set[str]): The set of valid words for transformation.\n\n    Returns:\n    list[str]: The list of transformations from begin_word to end_word.\n               Returns an empty list if there is no valid\n                transformation from current_word to end_word.\n\n    Example:\n    >>> backtrack(\"hit\", [\"hit\"], \"cog\", {\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"})\n    ['hit', 'hot', 'dot', 'lot', 'log', 'cog']\n\n    >>> backtrack(\"hit\", [\"hit\"], \"cog\", {\"hot\", \"dot\", \"dog\", \"lot\", \"log\"})\n    []\n\n    >>> backtrack(\"lead\", [\"lead\"], \"gold\", {\"load\", \"goad\", \"gold\", \"lead\", \"lord\"})\n    ['lead', 'lead', 'load', 'goad', 'gold']\n\n    >>> backtrack(\"game\", [\"game\"], \"code\", {\"came\", \"cage\", \"code\", \"cade\", \"gave\"})\n    ['game', 'came', 'cade', 'code']\n    \"\"\"\nif current_word == end_word:", "successors": [{"id": 4, "label": "#4\nreturn path", "successors": []}, {"id": 5, "label": "#5\nfor i in range(len(current_word)):", "successors": [{"id": 7, "label": "#7\nfor c in string.ascii_lowercase:", "successors": [{"id": 9, "label": "#9\ntransformed_word = current_word[:i] + c + current_word[i + 1:]\nif transformed_word in word_set:", "successors": [{"id": 11, "label": "#11\nword_set.remove(transformed_word)\nresult = backtrack(transformed_word, [*path, transformed_word], end_word,\n    word_set)\nif result:", "successors": [{"id": 13, "label": "#13\nreturn result", "successors": []}, {"id": 14, "label": "#14\nword_set.add(transformed_word)", "successors": []}]}]}]}, {"id": 8, "label": "#8\nreturn []", "successors": []}]}]}], "functions": [], "classes": []}, {"name": "word_ladder", "type": "CFG", "blocks": [{"id": 19, "label": "#19\n\"\"\"\n    Solve the Word Ladder problem using Backtracking and return\n    the list of transformations from begin_word to end_word.\n\n    Parameters:\n    begin_word (str): The word from which the transformation starts.\n    end_word (str): The target word for transformation.\n    word_list (list[str]): The list of valid words for transformation.\n\n    Returns:\n    list[str]: The list of transformations from begin_word to end_word.\n               Returns an empty list if there is no valid transformation.\n\n    Example:\n    >>> word_ladder(\"hit\", \"cog\", [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"])\n    ['hit', 'hot', 'dot', 'lot', 'log', 'cog']\n\n    >>> word_ladder(\"hit\", \"cog\", [\"hot\", \"dot\", \"dog\", \"lot\", \"log\"])\n    []\n\n    >>> word_ladder(\"lead\", \"gold\", [\"load\", \"goad\", \"gold\", \"lead\", \"lord\"])\n    ['lead', 'lead', 'load', 'goad', 'gold']\n\n    >>> word_ladder(\"game\", \"code\", [\"came\", \"cage\", \"code\", \"cade\", \"gave\"])\n    ['game', 'came', 'cade', 'code']\n    \"\"\"\nif end_word not in word_set:", "successors": [{"id": 20, "label": "#20\nreturn []", "successors": []}, {"id": 21, "label": "#21\nreturn backtrack(begin_word, [begin_word], end_word, word_set)", "successors": []}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "208.json", "name": "208.json", "type": "CFG", "blocks": [{"id": 1, "label": "#1\n{'name': 'example_script', 'type': 'CFG', 'start_line': 1, 'end_line': 49,\n    'functions': [{'name': 'test_conn_retry_sync_function', 'type':\n    'function', 'start_line': 8, 'end_line': 26, 'functions': [{'name':\n    'test_function', 'type': 'function', 'start_line': 12, 'end_line': 17,\n    'functions': [], 'classes': [], 'simplified_code':\n    \"\"\"    def test_function():\n        nonlocal retry_count\n        retry_count -= 1\n        if retry_count > 0:\n            raise ValueError(\"Test error\")\n        return \"Success\\\"\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"nonlocal retry_count\nretry_count -= 1\"\"\", 'successors': [2]}, {'id':\n    2, 'label': 'if retry_count > 0:', 'successors': [3, 4]}, {'id': 3,\n    'label': 'raise ValueError(\"Test error\")', 'successors': []}, {'id': 4,\n    'label': 'return \"Success\"', 'successors': []}]}], 'classes': [],\n    'simplified_code':\n    \"\"\"def test_conn_retry_sync_function():\n    retry_count = 0\n\n    @conn_retry(\"Test\", \"Test function\", max_retry=2, max_wait=0.1, min_wait=0.1)\n        return \"Success\"\n\n    retry_count = 2\n    res = test_function()\n    assert res == \"Success\"\n\n    retry_count = 100\n    with pytest.raises(ValueError) as e:\n        test_function()\n        assert str(e.value) == \"Test error\\\"\"\"\"\n    , 'blocks': [{'id': 1, 'label': 'def test_conn_retry_sync_function():',\n    'successors': [2]}, {'id': 2, 'label': 'retry_count = 0', 'successors':\n    [3]}, {'id': 3, 'label':\n    \"\"\"@conn_retry(\"Test\", \"Test function\", max_retry=2, max_wait=0.1, min_wait=0.1)\n    def test_function():\n        if retry_count > 1:\n            raise ValueError(\"Test error\")\n        return \"Success\\\"\"\"\"\n    , 'successors': [4]}, {'id': 4, 'label':\n    \"\"\"retry_count = 2\nres = test_function()\nassert res == \"Success\\\"\"\"\",\n    'successors': [5]}, {'id': 5, 'label':\n    \"\"\"retry_count = 100\nwith pytest.raises(ValueError) as e:\n    test_function()\n    assert str(e.value) == \"Test error\\\"\"\"\"\n    , 'successors': []}]}, {'name': 'test_conn_retry_async_function',\n    'type': 'function', 'start_line': 30, 'end_line': 49, 'functions': [{\n    'name': 'test_function', 'type': 'function', 'start_line': 34,\n    'end_line': 40, 'functions': [], 'classes': [], 'simplified_code':\n    \"\"\"    async def test_function():\n        nonlocal retry_count\n        await asyncio.sleep(1)\n        retry_count -= 1\n        if retry_count > 0:\n            raise ValueError(\"Test error\")\n        return \"Success\\\"\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"nonlocal retry_count\nawait asyncio.sleep(1)\nretry_count -= 1\"\"\",\n    'successors': [2]}, {'id': 2, 'label': 'if retry_count > 0:',\n    'successors': [3, 4]}, {'id': 3, 'label':\n    'raise ValueError(\"Test error\")', 'successors': []}, {'id': 4, 'label':\n    'return \"Success\"', 'successors': []}]}], 'classes': [],\n    'simplified_code':\n    \"\"\"async def test_conn_retry_async_function():\n    retry_count = 0\n\n    @conn_retry(\"Test\", \"Test function\", max_retry=2, max_wait=0.1, min_wait=0.1)\n        return \"Success\"\n\n    retry_count = 2\n    res = await test_function()\n    assert res == \"Success\"\n\n    retry_count = 100\n    with pytest.raises(ValueError) as e:\n        await test_function()\n        assert str(e.value) == \"Test error\\\"\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    'async def test_conn_retry_async_function():', 'successors': [2]}, {\n    'id': 2, 'label': 'retry_count = 0', 'successors': [3]}, {'id': 3,\n    'label':\n    \"\"\"@conn_retry(\"Test\", \"Test function\", max_retry=2, max_wait=0.1, min_wait=0.1)\nasync def test_function():\n    if retry_count < 2:\n        raise ValueError(\"Test error\")\n    return \"Success\\\"\"\"\"\n    , 'successors': [4]}, {'id': 4, 'label':\n    \"\"\"retry_count = 2\nres = await test_function()\nassert res == \"Success\\\"\"\"\",\n    'successors': [5]}, {'id': 5, 'label':\n    \"\"\"retry_count = 100\nwith pytest.raises(ValueError) as e:\n    await test_function()\n    assert str(e.value) == \"Test error\\\"\"\"\"\n    , 'successors': []}]}], 'classes': [], 'simplified_code':\n    \"\"\"import asyncio\n\nimport pytest\n\nfrom backend.util.retry import conn_retry\n\n\n        assert str(e.value) == \"Test error\"\n\n\n@pytest.mark.asyncio\n        assert str(e.value) == \"Test error\\\"\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"import asyncio\n\nimport pytest\n\nfrom backend.util.retry import conn_retry\"\"\"\n    , 'successors': []}, {'id': 2, 'label':\n    'assert str(e.value) == \"Test error\"', 'successors': []}, {'id': 3,\n    'label':\n    \"\"\"@pytest.mark.asyncio\nassert str(e.value) == \"Test error\\\"\"\"\",\n    'successors': []}]}", "successors": []}], "functions": [], "classes": []}
{"file_name": "209.json", "name": "209.py", "type": "CFG", "blocks": [{"id": 1, "label": "#1\nfrom typing import Any, Dict\nimport jwt\nfrom .config import settings", "successors": []}], "functions": [{"name": "parse_jwt_token", "type": "CFG", "blocks": [{"id": 3, "label": "#3\n\"\"\"\n    Parse and validate a JWT token.\n\n    :param token: The token to parse\n    :return: The decoded payload\n    :raises ValueError: If the token is invalid or expired\n    \"\"\"\ntry:", "successors": [{"id": 4, "label": "#4\npayload = jwt.decode(token, settings.JWT_SECRET_KEY, algorithms=[settings.\n    JWT_ALGORITHM], audience='authenticated')\nreturn payload", "successors": []}, {"id": 5, "label": "#5\nraise ValueError('Token has expired')", "successors": []}, {"id": 6, "label": "#6\nraise ValueError(f'Invalid token: {str(e)}')", "successors": []}]}], "functions": [], "classes": []}], "classes": []}
{"file_name": "210.json", "name": "210.json", "type": "CFG", "blocks": [{"id": 1, "label": "#1\n{'name': 'example_script', 'type': 'CFG', 'start_line': 1, 'end_line': 29,\n    'functions': [{'name': 'binary_coded_decimal', 'type': 'function',\n    'start_line': 1, 'end_line': 23, 'functions': [], 'classes': [],\n    'simplified_code':\n    \"\"\"def binary_coded_decimal(number: int) -> str:\n    \"\"\\\"\n    Find binary coded decimal (bcd) of integer base 10.\n    Each digit of the number is represented by a 4-bit binary.\n    Example:\n    >>> binary_coded_decimal(-2)\n    '0b0000'\n    >>> binary_coded_decimal(-1)\n    '0b0000'\n    >>> binary_coded_decimal(0)\n    '0b0000'\n    >>> binary_coded_decimal(3)\n    '0b0011'\n    >>> binary_coded_decimal(2)\n    '0b0010'\n    >>> binary_coded_decimal(12)\n    '0b00010010'\n    >>> binary_coded_decimal(987)\n    '0b100110000111'\n    \"\"\\\"\n    return \"0b\" + \"\".join(\n        str(bin(int(digit)))[2:].zfill(4) for digit in str(max(0, number))\n    )\"\"\"\n    , 'blocks': [{'id': 1, 'label':\n    \"\"\"def binary_coded_decimal(number: int) -> str:\n    \"\"\\\"\n    Find binary coded decimal (bcd) of integer base 10.\n    Each digit of the number is represented by a 4-bit binary.\n    Example:\n    >>> binary_coded_decimal(-2)\n    '0b0000'\n    >>> binary_coded_decimal(-1)\n    '0b0000'\n    >>> binary_coded_decimal(0)\n    '0b0000'\n    >>> binary_coded_decimal(3)\n    '0b0011'\n    >>> binary_coded_decimal(2)\n    '0b0010'\n    >>> binary_coded_decimal(12)\n    '0b00010010'\n    >>> binary_coded_decimal(987)\n    '0b100110000111'\n    \"\"\\\"\n    return \"0b\" + \"\".join(\n        str(bin(int(digit)))[2:].zfill(4) for digit in str(max(0, number))\n    )\"\"\"\n    , 'successors': []}]}], 'classes': [], 'simplified_code':\n    \"\"\"    )\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\"\"\"\n    , 'blocks': [{'id': 1, 'label': 'if __name__ == \"__main__\":',\n    'successors': [2]}, {'id': 2, 'label': 'import doctest', 'successors':\n    [3]}, {'id': 3, 'label': 'doctest.testmod()', 'successors': []}]}", "successors": []}], "functions": [], "classes": []}
