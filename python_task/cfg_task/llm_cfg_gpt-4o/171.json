{
  "name": "example_script",
  "type": "CFG",
  "start_line": 1,
  "end_line": 276,
  "functions": [
    {
      "name": "expose",
      "type": "function",
      "start_line": 51,
      "end_line": 70,
      "functions": [
        {
          "name": "wrapper",
          "type": "function",
          "start_line": 60,
          "end_line": 66,
          "functions": [],
          "classes": [],
          "simplified_code": "    def wrapper(*args, **kwargs):\n        try:\n            return func(*args, **kwargs)\n        except Exception as e:\n            msg = f\"Error in {func.__name__}: {e.__str__()}\"\n            logger.exception(msg)\n            raise",
          "blocks": [
            {
              "id": 1,
              "label": "def wrapper(*args, **kwargs):",
              "successors": [
                2
              ]
            },
            {
              "id": 2,
              "label": "try:",
              "successors": [
                3,
                5
              ]
            },
            {
              "id": 3,
              "label": "return func(*args, **kwargs)",
              "successors": []
            },
            {
              "id": 4,
              "label": "except Exception as e:",
              "successors": [
                5
              ]
            },
            {
              "id": 5,
              "label": "msg = f\"Error in {func.__name__}: {e.__str__()}\"",
              "successors": [
                6
              ]
            },
            {
              "id": 6,
              "label": "logger.exception(msg)",
              "successors": [
                7
              ]
            },
            {
              "id": 7,
              "label": "raise",
              "successors": []
            }
          ]
        }
      ],
      "classes": [],
      "simplified_code": "def expose(func: C) -> C:\n    \"\"\"\n    Decorator to mark a method or class to be exposed for remote calls.\n\n    ## \u26a0\ufe0f Gotcha\n    Aside from \"simple\" types, only Pydantic models are passed unscathed *if annotated*.\n    Any other passed or returned class objects are converted to dictionaries by Pyro.\n    \"\"\"\n\n            raise\n\n    register_pydantic_serializers(func)\n\n    return pyro.expose(wrapper)  # type: ignore",
      "blocks": [
        {
          "id": 1,
          "label": "def expose(func: C) -> C:",
          "successors": [
            2
          ]
        },
        {
          "id": 2,
          "label": "\"\"\"\nDecorator to mark a method or class to be exposed for remote calls.\n\n## \u26a0\ufe0f Gotcha\nAside from \"simple\" types, only Pydantic models are passed unscathed *if annotated*.\nAny other passed or returned class objects are converted to dictionaries by Pyro.\n\"\"\"",
          "successors": [
            3
          ]
        },
        {
          "id": 3,
          "label": "register_pydantic_serializers(func)",
          "successors": [
            4
          ]
        },
        {
          "id": 4,
          "label": "return pyro.expose(wrapper)  # type: ignore",
          "successors": []
        }
      ]
    },
    {
      "name": "register_pydantic_serializers",
      "type": "function",
      "start_line": 73,
      "end_line": 89,
      "functions": [],
      "classes": [],
      "simplified_code": "def register_pydantic_serializers(func: Callable):\n    \"\"\"Register custom serializers and deserializers for annotated Pydantic models\"\"\"\n    for name, annotation in func.__annotations__.items():\n        try:\n            pydantic_types = _pydantic_models_from_type_annotation(annotation)\n        except Exception as e:\n            raise TypeError(f\"Error while exposing {func.__name__}: {e.__str__()}\")\n\n        for model in pydantic_types:\n            logger.debug(\n                f\"Registering Pyro (de)serializers for {func.__name__} annotation \"\n                f\"'{name}': {model.__qualname__}\"\n            )\n            pyro.register_class_to_dict(model, _make_custom_serializer(model))\n            pyro.register_dict_to_class(\n                model.__qualname__, _make_custom_deserializer(model)\n            )",
      "blocks": [
        {
          "id": 1,
          "label": "def register_pydantic_serializers(func: Callable):",
          "successors": [
            2
          ]
        },
        {
          "id": 2,
          "label": "for name, annotation in func.__annotations__.items():",
          "successors": [
            3,
            7
          ]
        },
        {
          "id": 3,
          "label": "try:",
          "successors": [
            4,
            5
          ]
        },
        {
          "id": 4,
          "label": "pydantic_types = _pydantic_models_from_type_annotation(annotation)",
          "successors": [
            6
          ]
        },
        {
          "id": 5,
          "label": "except Exception as e:",
          "successors": [
            6
          ]
        },
        {
          "id": 6,
          "label": "raise TypeError(f\"Error while exposing {func.__name__}: {e.__str__()}\")",
          "successors": []
        },
        {
          "id": 7,
          "label": "for model in pydantic_types:",
          "successors": [
            8,
            10
          ]
        },
        {
          "id": 8,
          "label": "logger.debug( f\"Registering Pyro (de)serializers for {func.__name__} annotation '{name}': {model.__qualname__}\" )",
          "successors": [
            9
          ]
        },
        {
          "id": 9,
          "label": "pyro.register_class_to_dict(model, _make_custom_serializer(model))",
          "successors": [
            9
          ]
        },
        {
          "id": 10,
          "label": "pyro.register_dict_to_class( model.__qualname__, _make_custom_deserializer(model) )",
          "successors": [
            2
          ]
        }
      ]
    },
    {
      "name": "_make_custom_serializer",
      "type": "function",
      "start_line": 92,
      "end_line": 101,
      "functions": [
        {
          "name": "custom_class_to_dict",
          "type": "function",
          "start_line": 93,
          "end_line": 99,
          "functions": [],
          "classes": [],
          "simplified_code": "    def custom_class_to_dict(obj):\n        data = {\n            \"__class__\": obj.__class__.__qualname__,\n            **obj.model_dump(),\n        }\n        logger.debug(f\"Serializing {obj.__class__.__qualname__} with data: {data}\")\n        return data",
          "blocks": [
            {
              "id": 1,
              "label": "data = {\"__class__\": obj.__class__.__qualname__, **obj.model_dump()}",
              "successors": [
                2
              ]
            },
            {
              "id": 2,
              "label": "logger.debug(f\"Serializing {obj.__class__.__qualname__} with data: {data}\")",
              "successors": [
                3
              ]
            },
            {
              "id": 3,
              "label": "return data",
              "successors": []
            }
          ]
        }
      ],
      "classes": [],
      "simplified_code": "def _make_custom_serializer(model: Type[BaseModel]):\n        return data\n\n    return custom_class_to_dict",
      "blocks": [
        {
          "id": 1,
          "label": "def _make_custom_serializer(model: Type[BaseModel]):",
          "successors": [
            2
          ]
        },
        {
          "id": 2,
          "label": "return data",
          "successors": []
        }
      ]
    },
    {
      "name": "_make_custom_deserializer",
      "type": "function",
      "start_line": 104,
      "end_line": 109,
      "functions": [
        {
          "name": "custom_dict_to_class",
          "type": "function",
          "start_line": 105,
          "end_line": 107,
          "functions": [],
          "classes": [],
          "simplified_code": "    def custom_dict_to_class(qualname, data: dict):\n        logger.debug(f\"Deserializing {model.__qualname__} from data: {data}\")\n        return model(**data)",
          "blocks": [
            {
              "id": 1,
              "label": "logger.debug(f\"Deserializing {model.__qualname__} from data: {data}\")",
              "successors": [
                2
              ]
            },
            {
              "id": 2,
              "label": "return model(**data)",
              "successors": []
            }
          ]
        }
      ],
      "classes": [],
      "simplified_code": "def _make_custom_deserializer(model: Type[BaseModel]):\n        return model(**data)\n\n    return custom_dict_to_class",
      "blocks": [
        {
          "id": 1,
          "label": "def _make_custom_deserializer(model: Type[BaseModel]):",
          "successors": [
            2
          ]
        },
        {
          "id": 2,
          "label": "return model(**data)",
          "successors": [
            3
          ]
        },
        {
          "id": 3,
          "label": "return custom_dict_to_class",
          "successors": []
        }
      ]
    },
    {
      "name": "close_service_client",
      "type": "function",
      "start_line": 203,
      "end_line": 207,
      "functions": [],
      "classes": [],
      "simplified_code": "def close_service_client(client: AppService) -> None:\n    if isinstance(client, PyroClient):\n        client.proxy._pyroRelease()\n    else:\n        raise RuntimeError(f\"Client {client.__class__} is not a Pyro client.\")",
      "blocks": [
        {
          "id": 1,
          "label": "if isinstance(client, PyroClient):",
          "successors": [
            2,
            3
          ]
        },
        {
          "id": 2,
          "label": "client.proxy._pyroRelease()",
          "successors": []
        },
        {
          "id": 3,
          "label": "raise RuntimeError(f\"Client {client.__class__} is not a Pyro client.\")",
          "successors": []
        }
      ]
    },
    {
      "name": "get_service_client",
      "type": "function",
      "start_line": 210,
      "end_line": 228,
      "functions": [
        {
          "name": "DynamicClient",
          "type": "class",
          "start_line": 213,
          "end_line": 228,
          "functions": [
            {
              "name": "__init__",
              "type": "function",
              "start_line": 215,
              "end_line": 222,
              "functions": [],
              "classes": [],
              "simplified_code": "        def __init__(self):\n            host = os.environ.get(f\"{service_name.upper()}_HOST\", pyro_host)\n            uri = f\"PYRO:{service_type.service_name}@{host}:{service_type.get_port()}\"\n            logger.debug(f\"Connecting to service [{service_name}]. URI = {uri}\")\n            self.proxy = Pyro5.api.Proxy(uri)\n            # Attempt to bind to ensure the connection is established\n            self.proxy._pyroBind()\n            logger.debug(f\"Successfully connected to service [{service_name}]\")",
              "blocks": [
                {
                  "id": 1,
                  "label": "host = os.environ.get(f\"{service_name.upper()}_HOST\", pyro_host)\nuri = f\"PYRO:{service_type.service_name}@{host}:{service_type.get_port()}\"\nlogger.debug(f\"Connecting to service [{service_name}]. URI = {uri}\")\nself.proxy = Pyro5.api.Proxy(uri)",
                  "successors": [
                    2
                  ]
                },
                {
                  "id": 2,
                  "label": "self.proxy._pyroBind()\nlogger.debug(f\"Successfully connected to service [{service_name}]\")",
                  "successors": []
                }
              ]
            },
            {
              "name": "__getattr__",
              "type": "function",
              "start_line": 224,
              "end_line": 226,
              "functions": [],
              "classes": [],
              "simplified_code": "        def __getattr__(self, name: str) -> Callable[..., Any]:\n            res = getattr(self.proxy, name)\n            return res",
              "blocks": [
                {
                  "id": 1,
                  "label": "res = getattr(self.proxy, name)",
                  "successors": [
                    2
                  ]
                },
                {
                  "id": 2,
                  "label": "return res",
                  "successors": []
                }
              ]
            }
          ],
          "classes": [],
          "simplified_code": "    class DynamicClient(PyroClient):\n        @conn_retry(\"Pyro\", f\"Connecting to [{service_name}]\")\n            logger.debug(f\"Successfully connected to service [{service_name}]\")\n\n            return res\n\n    return cast(AS, DynamicClient())",
          "blocks": [
            {
              "id": 1,
              "label": "class DynamicClient(PyroClient):",
              "successors": [
                2
              ]
            },
            {
              "id": 2,
              "label": "@conn_retry(\"Pyro\", f\"Connecting to [{service_name}]\")",
              "successors": [
                3
              ]
            },
            {
              "id": 3,
              "label": "logger.debug(f\"Successfully connected to service [{service_name}]\")",
              "successors": [
                4
              ]
            },
            {
              "id": 4,
              "label": "return res",
              "successors": [
                5
              ]
            },
            {
              "id": 5,
              "label": "return cast(AS, DynamicClient())",
              "successors": []
            }
          ]
        }
      ],
      "classes": [],
      "simplified_code": "def get_service_client(service_type: Type[AS]) -> AS:\n    service_name = service_type.service_name\n\n    return cast(AS, DynamicClient())",
      "blocks": [
        {
          "id": 1,
          "label": "service_name = service_type.service_name",
          "successors": [
            2
          ]
        },
        {
          "id": 2,
          "label": "return cast(AS, DynamicClient())",
          "successors": []
        }
      ]
    },
    {
      "name": "_pydantic_models_from_type_annotation",
      "type": "function",
      "start_line": 234,
      "end_line": 276,
      "functions": [],
      "classes": [],
      "simplified_code": "def _pydantic_models_from_type_annotation(annotation) -> Iterator[type[BaseModel]]:\n    # Peel Annotated parameters\n    if (origin := get_origin(annotation)) and origin is Annotated:\n        annotation = get_args(annotation)[0]\n\n    origin = get_origin(annotation)\n    args = get_args(annotation)\n\n    if origin in (\n        Union,\n        UnionType,\n        list,\n        List,\n        tuple,\n        Tuple,\n        set,\n        Set,\n        frozenset,\n        FrozenSet,\n    ):\n        for arg in args:\n            yield from _pydantic_models_from_type_annotation(arg)\n    elif origin in (dict, Dict):\n        key_type, value_type = args\n        yield from _pydantic_models_from_type_annotation(key_type)\n        yield from _pydantic_models_from_type_annotation(value_type)\n    elif origin in (Awaitable, Coroutine):\n        # For coroutines and awaitables, check the return type\n        return_type = args[-1]\n        yield from _pydantic_models_from_type_annotation(return_type)\n    else:\n        annotype = annotation if origin is None else origin\n\n        # Exclude generic types and aliases\n        if (\n            annotype is not None\n            and not hasattr(typing, getattr(annotype, \"__name__\", \"\"))\n            and isinstance(annotype, type)\n        ):\n            if issubclass(annotype, BaseModel):\n                yield annotype\n            elif annotype not in builtin_types and not issubclass(annotype, Enum):\n                raise TypeError(f\"Unsupported type encountered: {annotype}\")",
      "blocks": [
        {
          "id": 1,
          "label": "# Peel Annotated parameters\nif (origin := get_origin(annotation)) and origin is Annotated:",
          "successors": [
            2,
            3
          ]
        },
        {
          "id": 2,
          "label": "annotation = get_args(annotation)[0]",
          "successors": [
            3
          ]
        },
        {
          "id": 3,
          "label": "origin = get_origin(annotation)\nargs = get_args(annotation)",
          "successors": [
            4
          ]
        },
        {
          "id": 4,
          "label": "if origin in (\n    Union,\n    UnionType,\n    list,\n    List,\n    tuple,\n    Tuple,\n    set,\n    Set,\n    frozenset,\n    FrozenSet,\n):",
          "successors": [
            5,
            8
          ]
        },
        {
          "id": 5,
          "label": "for arg in args:\n    yield from _pydantic_models_from_type_annotation(arg)",
          "successors": [
            8
          ]
        },
        {
          "id": 6,
          "label": "elif origin in (dict, Dict):",
          "successors": [
            7,
            8
          ]
        },
        {
          "id": 7,
          "label": "key_type, value_type = args\nyield from _pydantic_models_from_type_annotation(key_type)\nyield from _pydantic_models_from_type_annotation(value_type)",
          "successors": [
            8
          ]
        },
        {
          "id": 8,
          "label": "elif origin in (Awaitable, Coroutine):",
          "successors": [
            9,
            10
          ]
        },
        {
          "id": 9,
          "label": "return_type = args[-1]\nyield from _pydantic_models_from_type_annotation(return_type)",
          "successors": [
            10
          ]
        },
        {
          "id": 10,
          "label": "else:\n    annotype = annotation if origin is None else origin",
          "successors": [
            11
          ]
        },
        {
          "id": 11,
          "label": "# Exclude generic types and aliases\nif (\n    annotype is not None\n    and not hasattr(typing, getattr(annotype, \"__name__\", \"\"))\n    and isinstance(annotype, type)\n):",
          "successors": [
            12,
            14
          ]
        },
        {
          "id": 12,
          "label": "if issubclass(annotype, BaseModel):",
          "successors": [
            13,
            14
          ]
        },
        {
          "id": 13,
          "label": "yield annotype",
          "successors": [
            14
          ]
        },
        {
          "id": 14,
          "label": "elif annotype not in builtin_types and not issubclass(annotype, Enum):",
          "successors": [
            15
          ]
        },
        {
          "id": 15,
          "label": "raise TypeError(f\"Unsupported type encountered: {annotype}\")",
          "successors": []
        }
      ]
    }
  ],
  "classes": [
    {
      "name": "AppService",
      "type": "class",
      "start_line": 112,
      "end_line": 190,
      "functions": [
        {
          "name": "__init__",
          "type": "function",
          "start_line": 118,
          "end_line": 119,
          "functions": [],
          "classes": [],
          "simplified_code": "    def __init__(self):\n        self.uri = None",
          "blocks": [
            {
              "id": 1,
              "label": "def __init__(self):",
              "successors": [
                2
              ]
            },
            {
              "id": 2,
              "label": "self.uri = None",
              "successors": []
            }
          ]
        },
        {
          "name": "get_port",
          "type": "function",
          "start_line": 123,
          "end_line": 124,
          "functions": [],
          "classes": [],
          "simplified_code": "    def get_port(cls) -> int:\n        pass",
          "blocks": [
            {
              "id": 1,
              "label": "def get_port(cls) -> int:\n    pass",
              "successors": []
            }
          ]
        },
        {
          "name": "get_host",
          "type": "function",
          "start_line": 127,
          "end_line": 128,
          "functions": [],
          "classes": [],
          "simplified_code": "    def get_host(cls) -> str:\n        return os.environ.get(f\"{cls.service_name.upper()}_HOST\", config.pyro_host)",
          "blocks": [
            {
              "id": 1,
              "label": "def get_host(cls) -> str:",
              "successors": [
                2
              ]
            },
            {
              "id": 2,
              "label": "return os.environ.get(f\"{cls.service_name.upper()}_HOST\", config.pyro_host)",
              "successors": []
            }
          ]
        },
        {
          "name": "run_service",
          "type": "function",
          "start_line": 130,
          "end_line": 132,
          "functions": [],
          "classes": [],
          "simplified_code": "    def run_service(self) -> None:\n        while True:\n            time.sleep(10)",
          "blocks": [
            {
              "id": 1,
              "label": "while True:",
              "successors": [
                2
              ]
            },
            {
              "id": 2,
              "label": "time.sleep(10)",
              "successors": [
                1
              ]
            }
          ]
        },
        {
          "name": "__run_async",
          "type": "function",
          "start_line": 134,
          "end_line": 135,
          "functions": [],
          "classes": [],
          "simplified_code": "    def __run_async(self, coro: Coroutine[Any, Any, T]):\n        return asyncio.run_coroutine_threadsafe(coro, self.shared_event_loop)",
          "blocks": [
            {
              "id": 1,
              "label": "def __run_async(self, coro: Coroutine[Any, Any, T]):",
              "successors": [
                2
              ]
            },
            {
              "id": 2,
              "label": "return asyncio.run_coroutine_threadsafe(coro, self.shared_event_loop)",
              "successors": []
            }
          ]
        },
        {
          "name": "run_and_wait",
          "type": "function",
          "start_line": 137,
          "end_line": 139,
          "functions": [],
          "classes": [],
          "simplified_code": "    def run_and_wait(self, coro: Coroutine[Any, Any, T]) -> T:\n        future = self.__run_async(coro)\n        return future.result()",
          "blocks": [
            {
              "id": 1,
              "label": "def run_and_wait(self, coro: Coroutine[Any, Any, T]) -> T:",
              "successors": [
                2
              ]
            },
            {
              "id": 2,
              "label": "future = self.__run_async(coro)",
              "successors": [
                3
              ]
            },
            {
              "id": 3,
              "label": "return future.result()",
              "successors": []
            }
          ]
        },
        {
          "name": "run",
          "type": "function",
          "start_line": 141,
          "end_line": 166,
          "functions": [],
          "classes": [],
          "simplified_code": "    def run(self):\n        self.shared_event_loop = asyncio.get_event_loop()\n        if self.use_db:\n            self.shared_event_loop.run_until_complete(db.connect())\n        if self.use_redis:\n            redis.connect()\n        if self.use_supabase:\n            from supabase import create_client\n\n            secrets = Secrets()\n            self.supabase = create_client(\n                secrets.supabase_url, secrets.supabase_service_role_key\n            )\n\n        # Initialize the async loop.\n        async_thread = threading.Thread(target=self.__start_async_loop)\n        async_thread.daemon = True\n        async_thread.start()\n\n        # Initialize pyro service\n        daemon_thread = threading.Thread(target=self.__start_pyro)\n        daemon_thread.daemon = True\n        daemon_thread.start()\n\n        # Run the main service (if it's not implemented, just sleep).\n        self.run_service()",
          "blocks": [
            {
              "id": 1,
              "label": "self.shared_event_loop = asyncio.get_event_loop()",
              "successors": [
                2
              ]
            },
            {
              "id": 2,
              "label": "if self.use_db:",
              "successors": [
                3,
                4
              ]
            },
            {
              "id": 3,
              "label": "self.shared_event_loop.run_until_complete(db.connect())",
              "successors": [
                4
              ]
            },
            {
              "id": 4,
              "label": "if self.use_redis:",
              "successors": [
                5,
                6
              ]
            },
            {
              "id": 5,
              "label": "redis.connect()",
              "successors": [
                6
              ]
            },
            {
              "id": 6,
              "label": "if self.use_supabase:",
              "successors": [
                7,
                8
              ]
            },
            {
              "id": 7,
              "label": "from supabase import create_client\n\nsecrets = Secrets()\nself.supabase = create_client(\n    secrets.supabase_url, secrets.supabase_service_role_key\n)",
              "successors": [
                8
              ]
            },
            {
              "id": 8,
              "label": "async_thread = threading.Thread(target=self.__start_async_loop)\nasync_thread.daemon = True\nasync_thread.start()",
              "successors": [
                9
              ]
            },
            {
              "id": 9,
              "label": "daemon_thread = threading.Thread(target=self.__start_pyro)\ndaemon_thread.daemon = True\ndaemon_thread.start()",
              "successors": [
                10
              ]
            },
            {
              "id": 10,
              "label": "self.run_service()",
              "successors": []
            }
          ]
        },
        {
          "name": "cleanup",
          "type": "function",
          "start_line": 168,
          "end_line": 174,
          "functions": [],
          "classes": [],
          "simplified_code": "    def cleanup(self):\n        if self.use_db:\n            logger.info(f\"[{self.__class__.__name__}] \u23f3 Disconnecting DB...\")\n            self.run_and_wait(db.disconnect())\n        if self.use_redis:\n            logger.info(f\"[{self.__class__.__name__}] \u23f3 Disconnecting Redis...\")\n            redis.disconnect()",
          "blocks": [
            {
              "id": 1,
              "label": "def cleanup(self):",
              "successors": [
                2
              ]
            },
            {
              "id": 2,
              "label": "if self.use_db:",
              "successors": [
                3,
                4
              ]
            },
            {
              "id": 3,
              "label": "logger.info(f\"[{self.__class__.__name__}] \u23f3 Disconnecting DB...\")\nself.run_and_wait(db.disconnect())",
              "successors": [
                4
              ]
            },
            {
              "id": 4,
              "label": "if self.use_redis:",
              "successors": [
                5,
                6
              ]
            },
            {
              "id": 5,
              "label": "logger.info(f\"[{self.__class__.__name__}] \u23f3 Disconnecting Redis...\")\nredis.disconnect()",
              "successors": []
            },
            {
              "id": 6,
              "label": "",
              "successors": []
            }
          ]
        },
        {
          "name": "__start_pyro",
          "type": "function",
          "start_line": 177,
          "end_line": 187,
          "functions": [],
          "classes": [],
          "simplified_code": "    def __start_pyro(self):\n        maximum_connection_thread_count = max(\n            Pyro5.config.THREADPOOL_SIZE,\n            config.num_node_workers * config.num_graph_workers,\n        )\n\n        Pyro5.config.THREADPOOL_SIZE = maximum_connection_thread_count  # type: ignore\n        daemon = Pyro5.api.Daemon(host=config.pyro_host, port=self.get_port())\n        self.uri = daemon.register(self, objectId=self.service_name)\n        logger.info(f\"[{self.service_name}] Connected to Pyro; URI = {self.uri}\")\n        daemon.requestLoop()",
          "blocks": [
            {
              "id": 1,
              "label": "maximum_connection_thread_count = max(Pyro5.config.THREADPOOL_SIZE, config.num_node_workers * config.num_graph_workers)",
              "successors": [
                2
              ]
            },
            {
              "id": 2,
              "label": "Pyro5.config.THREADPOOL_SIZE = maximum_connection_thread_count",
              "successors": [
                3
              ]
            },
            {
              "id": 3,
              "label": "daemon = Pyro5.api.Daemon(host=config.pyro_host, port=self.get_port())",
              "successors": [
                4
              ]
            },
            {
              "id": 4,
              "label": "self.uri = daemon.register(self, objectId=self.service_name)",
              "successors": [
                5
              ]
            },
            {
              "id": 5,
              "label": "logger.info(f\"[{self.service_name}] Connected to Pyro; URI = {self.uri}\")",
              "successors": [
                6
              ]
            },
            {
              "id": 6,
              "label": "daemon.requestLoop()",
              "successors": []
            }
          ]
        },
        {
          "name": "__start_async_loop",
          "type": "function",
          "start_line": 189,
          "end_line": 190,
          "functions": [],
          "classes": [],
          "simplified_code": "    def __start_async_loop(self):\n        self.shared_event_loop.run_forever()",
          "blocks": [
            {
              "id": 1,
              "label": "def __start_async_loop(self):",
              "successors": [
                2
              ]
            },
            {
              "id": 2,
              "label": "self.shared_event_loop.run_forever()",
              "successors": []
            }
          ]
        }
      ],
      "classes": [],
      "simplified_code": "class AppService(AppProcess, ABC):\n    shared_event_loop: asyncio.AbstractEventLoop\n    use_db: bool = False\n    use_redis: bool = False\n    use_supabase: bool = False\n\n        self.uri = None\n\n    @classmethod\n    @abstractmethod\n        pass\n\n    @classmethod\n        return os.environ.get(f\"{cls.service_name.upper()}_HOST\", config.pyro_host)\n\n            time.sleep(10)\n\n        return asyncio.run_coroutine_threadsafe(coro, self.shared_event_loop)\n\n        return future.result()\n\n        self.run_service()\n\n            redis.disconnect()\n\n    @conn_retry(\"Pyro\", \"Starting Pyro Service\")\n        daemon.requestLoop()\n\n        self.shared_event_loop.run_forever()",
      "blocks": [
        {
          "id": 1,
          "label": "class AppService(AppProcess, ABC):",
          "successors": [
            2
          ]
        },
        {
          "id": 2,
          "label": "shared_event_loop: asyncio.AbstractEventLoop\nuse_db: bool = False\nuse_redis: bool = False\nuse_supabase: bool = False\nself.uri = None",
          "successors": [
            3
          ]
        },
        {
          "id": 3,
          "label": "@classmethod\n@abstractmethod\npass",
          "successors": [
            4
          ]
        },
        {
          "id": 4,
          "label": "@classmethod\nreturn os.environ.get(f\"{cls.service_name.upper()}_HOST\", config.pyro_host)",
          "successors": [
            5
          ]
        },
        {
          "id": 5,
          "label": "time.sleep(10)",
          "successors": [
            6
          ]
        },
        {
          "id": 6,
          "label": "return asyncio.run_coroutine_threadsafe(coro, self.shared_event_loop)",
          "successors": [
            7
          ]
        },
        {
          "id": 7,
          "label": "return future.result()",
          "successors": [
            8
          ]
        },
        {
          "id": 8,
          "label": "self.run_service()",
          "successors": [
            9
          ]
        },
        {
          "id": 9,
          "label": "redis.disconnect()",
          "successors": [
            10
          ]
        },
        {
          "id": 10,
          "label": "@conn_retry(\"Pyro\", \"Starting Pyro Service\")\ndaemon.requestLoop()",
          "successors": [
            11
          ]
        },
        {
          "id": 11,
          "label": "self.shared_event_loop.run_forever()",
          "successors": []
        }
      ]
    },
    {
      "name": "PyroClient",
      "type": "class",
      "start_line": 199,
      "end_line": 200,
      "functions": [],
      "classes": [],
      "simplified_code": "class PyroClient:\n    proxy: Pyro5.api.Proxy",
      "blocks": [
        {
          "id": 1,
          "label": "class PyroClient:",
          "successors": []
        },
        {
          "id": 2,
          "label": "proxy: Pyro5.api.Proxy",
          "successors": []
        }
      ]
    }
  ],
  "simplified_code": "import asyncio\nimport builtins\nimport logging\nimport os\nimport threading\nimport time\nimport typing\nfrom abc import ABC, abstractmethod\nfrom enum import Enum\nfrom types import NoneType, UnionType\nfrom typing import (\n    Annotated,\n    Any,\n    Awaitable,\n    Callable,\n    Coroutine,\n    Dict,\n    FrozenSet,\n    Iterator,\n    List,\n    Set,\n    Tuple,\n    Type,\n    TypeVar,\n    Union,\n    cast,\n    get_args,\n    get_origin,\n)\n\nimport Pyro5.api\nfrom pydantic import BaseModel\nfrom Pyro5 import api as pyro\nfrom Pyro5 import config as pyro_config\n\nfrom backend.data import db, redis\nfrom backend.util.process import AppProcess\nfrom backend.util.retry import conn_retry\nfrom backend.util.settings import Config, Secrets\n\nlogger = logging.getLogger(__name__)\nT = TypeVar(\"T\")\nC = TypeVar(\"C\", bound=Callable)\n\nconfig = Config()\npyro_host = config.pyro_host\npyro_config.MAX_RETRIES = config.pyro_client_comm_retry  # type: ignore\npyro_config.COMMTIMEOUT = config.pyro_client_comm_timeout  # type: ignore\n\n\n    return pyro.expose(wrapper)  # type: ignore\n\n\n            )\n\n\n    return custom_class_to_dict\n\n\n    return custom_dict_to_class\n\n\n        self.shared_event_loop.run_forever()\n\n\n# --------- UTILITIES --------- #\n\n\nAS = TypeVar(\"AS\", bound=AppService)\n\n\n    proxy: Pyro5.api.Proxy\n\n\n        raise RuntimeError(f\"Client {client.__class__} is not a Pyro client.\")\n\n\n    return cast(AS, DynamicClient())\n\n\nbuiltin_types = [*vars(builtins).values(), NoneType, Enum]\n\n\n                raise TypeError(f\"Unsupported type encountered: {annotype}\")",
  "blocks": [
    {
      "id": 1,
      "label": "import asyncio\nimport builtins\nimport logging\nimport os\nimport threading\nimport time\nimport typing\nfrom abc import ABC, abstractmethod\nfrom enum import Enum\nfrom types import NoneType, UnionType\nfrom typing import (\n    Annotated,\n    Any,\n    Awaitable,\n    Callable,\n    Coroutine,\n    Dict,\n    FrozenSet,\n    Iterator,\n    List,\n    Set,\n    Tuple,\n    Type,\n    TypeVar,\n    Union,\n    cast,\n    get_args,\n    get_origin,\n)\n\nimport Pyro5.api\nfrom pydantic import BaseModel\nfrom Pyro5 import api as pyro\nfrom Pyro5 import config as pyro_config\n\nfrom backend.data import db, redis\nfrom backend.util.process import AppProcess\nfrom backend.util.retry import conn_retry\nfrom backend.util.settings import Config, Secrets\n\nlogger = logging.getLogger(__name__)\nT = TypeVar(\"T\")\nC = TypeVar(\"C\", bound= Callable)",
      "successors": [
        2
      ]
    },
    {
      "id": 2,
      "label": "config = Config()\npyro_host = config.pyro_host\npyro_config.MAX_RETRIES = config.pyro_client_comm_retry\npyro_config.COMMTIMEOUT = config.pyro_client_comm_timeout",
      "successors": [
        3
      ]
    },
    {
      "id": 3,
      "label": "return pyro.expose(wrapper)",
      "successors": []
    },
    {
      "id": 4,
      "label": "return custom_class_to_dict",
      "successors": []
    },
    {
      "id": 5,
      "label": "return custom_dict_to_class",
      "successors": []
    },
    {
      "id": 6,
      "label": "self.shared_event_loop.run_forever()",
      "successors": []
    },
    {
      "id": 7,
      "label": "AS = TypeVar(\"AS\", bound=AppService)\nproxy: Pyro5.api.Proxy",
      "successors": [
        8
      ]
    },
    {
      "id": 8,
      "label": "raise RuntimeError(f\"Client {client.__class__} is not a Pyro client.\")",
      "successors": []
    },
    {
      "id": 9,
      "label": "return cast(AS, DynamicClient())",
      "successors": []
    },
    {
      "id": 10,
      "label": "builtin_types = [*vars(builtins).values(), NoneType, Enum]",
      "successors": [
        11
      ]
    },
    {
      "id": 11,
      "label": "raise TypeError(f\"Unsupported type encountered: {annotype}\")",
      "successors": []
    }
  ]
}