{
  "name": "example_script",
  "type": "CFG",
  "start_line": 1,
  "end_line": 67,
  "functions": [
    {
      "name": "_start_measurement",
      "type": "function",
      "start_line": 15,
      "end_line": 16,
      "functions": [],
      "classes": [],
      "simplified_code": "def _start_measurement() -> Tuple[float, float]:\n    return time.time(), os.times()[0] + os.times()[1]",
      "blocks": [
        {
          "id": 1,
          "label": "def _start_measurement() -> Tuple[float, float]:",
          "successors": [
            2
          ]
        },
        {
          "id": 2,
          "label": "return time.time(), os.times()[0] + os.times()[1]",
          "successors": []
        }
      ]
    },
    {
      "name": "_end_measurement",
      "type": "function",
      "start_line": 19,
      "end_line": 24,
      "functions": [],
      "classes": [],
      "simplified_code": "def _end_measurement(\n    start_wall_time: float, start_cpu_time: float\n) -> Tuple[float, float]:\n    end_wall_time = time.time()\n    end_cpu_time = os.times()[0] + os.times()[1]\n    return end_wall_time - start_wall_time, end_cpu_time - start_cpu_time",
      "blocks": [
        {
          "id": 1,
          "label": "end_wall_time = time.time(); end_cpu_time = os.times()[0] + os.times()[1]",
          "successors": [
            2
          ]
        },
        {
          "id": 2,
          "label": "return end_wall_time - start_wall_time, end_cpu_time - start_cpu_time",
          "successors": []
        }
      ]
    },
    {
      "name": "time_measured",
      "type": "function",
      "start_line": 33,
      "end_line": 50,
      "functions": [
        {
          "name": "wrapper",
          "type": "function",
          "start_line": 39,
          "end_line": 48,
          "functions": [],
          "classes": [],
          "simplified_code": "    def wrapper(*args: P.args, **kwargs: P.kwargs) -> Tuple[TimingInfo, T]:\n        start_wall_time, start_cpu_time = _start_measurement()\n        try:\n            result = func(*args, **kwargs)\n        finally:\n            wall_duration, cpu_duration = _end_measurement(\n                start_wall_time, start_cpu_time\n            )\n            timing_info = TimingInfo(cpu_time=cpu_duration, wall_time=wall_duration)\n        return timing_info, result",
          "blocks": [
            {
              "id": 1,
              "label": "start_wall_time, start_cpu_time = _start_measurement()",
              "successors": [
                2
              ]
            },
            {
              "id": 2,
              "label": "try:",
              "successors": [
                3,
                4
              ]
            },
            {
              "id": 3,
              "label": "result = func(*args, **kwargs)",
              "successors": [
                4
              ]
            },
            {
              "id": 4,
              "label": "finally:",
              "successors": [
                5
              ]
            },
            {
              "id": 5,
              "label": "wall_duration, cpu_duration = _end_measurement(start_wall_time, start_cpu_time)",
              "successors": [
                6
              ]
            },
            {
              "id": 6,
              "label": "timing_info = TimingInfo(cpu_time=cpu_duration, wall_time=wall_duration)",
              "successors": [
                7
              ]
            },
            {
              "id": 7,
              "label": "return timing_info, result",
              "successors": []
            }
          ]
        }
      ],
      "classes": [],
      "simplified_code": "def time_measured(func: Callable[P, T]) -> Callable[P, Tuple[TimingInfo, T]]:\n    \"\"\"\n    Decorator to measure the time taken by a function to execute.\n    \"\"\"\n\n    @functools.wraps(func)\n        return timing_info, result\n\n    return wrapper",
      "blocks": [
        {
          "id": 1,
          "label": "def time_measured(func: Callable[P, T]) -> Callable[P, Tuple[TimingInfo, T]]:",
          "successors": [
            2
          ]
        },
        {
          "id": 2,
          "label": "\"\"\"\n    Decorator to measure the time taken by a function to execute.\n    \"\"\"",
          "successors": [
            3
          ]
        },
        {
          "id": 3,
          "label": "@functools.wraps(func)",
          "successors": [
            4
          ]
        },
        {
          "id": 4,
          "label": "def wrapper(*args: P.args, **kwargs: P.kwargs) -> Tuple[TimingInfo, T]:",
          "successors": [
            5
          ]
        },
        {
          "id": 5,
          "label": "start_time = time.monotonic()",
          "successors": [
            6
          ]
        },
        {
          "id": 6,
          "label": "result = func(*args, **kwargs)",
          "successors": [
            7
          ]
        },
        {
          "id": 7,
          "label": "end_time = time.monotonic()",
          "successors": [
            8
          ]
        },
        {
          "id": 8,
          "label": "timing_info = TimingInfo(\n    function_name=func.__name__,\n    execution_time=end_time - start_time\n)",
          "successors": [
            9
          ]
        },
        {
          "id": 9,
          "label": "return timing_info, result",
          "successors": [
            10
          ]
        },
        {
          "id": 10,
          "label": "return wrapper",
          "successors": []
        }
      ]
    },
    {
      "name": "error_logged",
      "type": "function",
      "start_line": 53,
      "end_line": 67,
      "functions": [
        {
          "name": "wrapper",
          "type": "function",
          "start_line": 59,
          "end_line": 65,
          "functions": [],
          "classes": [],
          "simplified_code": "    def wrapper(*args: P.args, **kwargs: P.kwargs) -> T | None:\n        try:\n            return func(*args, **kwargs)\n        except Exception as e:\n            logger.exception(\n                f\"Error when calling function {func.__name__} with arguments {args} {kwargs}: {e}\"\n            )",
          "blocks": [
            {
              "id": 1,
              "label": "def wrapper(*args: P.args, **kwargs: P.kwargs) -> T | None:",
              "successors": [
                2
              ]
            },
            {
              "id": 2,
              "label": "try:",
              "successors": [
                3,
                4
              ]
            },
            {
              "id": 3,
              "label": "return func(*args, **kwargs)",
              "successors": []
            },
            {
              "id": 4,
              "label": "except Exception as e:",
              "successors": [
                5
              ]
            },
            {
              "id": 5,
              "label": "logger.exception(f\"Error when calling function {func.__name__} with arguments {args} {kwargs}: {e}\")",
              "successors": []
            }
          ]
        }
      ],
      "classes": [],
      "simplified_code": "def error_logged(func: Callable[P, T]) -> Callable[P, T | None]:\n    \"\"\"\n    Decorator to suppress and log any exceptions raised by a function.\n    \"\"\"\n\n    @functools.wraps(func)\n            )\n\n    return wrapper",
      "blocks": [
        {
          "id": 1,
          "label": "def error_logged(func: Callable[P, T]) -> Callable[P, T | None]:",
          "successors": [
            2
          ]
        },
        {
          "id": 2,
          "label": "\"\"\"\nDecorator to suppress and log any exceptions raised by a function.\n\"\"\"",
          "successors": [
            3
          ]
        },
        {
          "id": 3,
          "label": "@functools.wraps(func)",
          "successors": [
            4
          ]
        },
        {
          "id": 4,
          "label": "def wrapper(*args: P.args, **kwargs: P.kwargs) -> T | None:",
          "successors": [
            5
          ]
        },
        {
          "id": 5,
          "label": "try:",
          "successors": [
            6,
            8
          ]
        },
        {
          "id": 6,
          "label": "return func(*args, **kwargs)",
          "successors": [
            11
          ]
        },
        {
          "id": 7,
          "label": "except Exception as e:",
          "successors": [
            9
          ]
        },
        {
          "id": 8,
          "label": "logger.error(\"Error occurred: %s\", str(e))",
          "successors": [
            10
          ]
        },
        {
          "id": 9,
          "label": "return None",
          "successors": [
            11
          ]
        },
        {
          "id": 10,
          "label": "finally:",
          "successors": [
            11
          ]
        },
        {
          "id": 11,
          "label": "return wrapper",
          "successors": []
        }
      ]
    }
  ],
  "classes": [
    {
      "name": "TimingInfo",
      "type": "class",
      "start_line": 10,
      "end_line": 12,
      "functions": [],
      "classes": [],
      "simplified_code": "class TimingInfo(BaseModel):\n    cpu_time: float\n    wall_time: float",
      "blocks": [
        {
          "id": 1,
          "label": "class TimingInfo(BaseModel):",
          "successors": [
            2
          ]
        },
        {
          "id": 2,
          "label": "cpu_time: float",
          "successors": [
            3
          ]
        },
        {
          "id": 3,
          "label": "wall_time: float",
          "successors": []
        }
      ]
    }
  ],
  "simplified_code": "import functools\nimport logging\nimport os\nimport time\nfrom typing import Callable, ParamSpec, Tuple, TypeVar\n\nfrom pydantic import BaseModel\n\n\n    wall_time: float\n\n\n    return time.time(), os.times()[0] + os.times()[1]\n\n\n    return end_wall_time - start_wall_time, end_cpu_time - start_cpu_time\n\n\nP = ParamSpec(\"P\")\nT = TypeVar(\"T\")\n\nlogger = logging.getLogger(__name__)\n\n\n    return wrapper\n\n\n    return wrapper",
  "blocks": [
    {
      "id": 1,
      "label": "import statements",
      "successors": [
        2
      ]
    },
    {
      "id": 2,
      "label": "class TimerResult(BaseModel):\n        user_cpu_time: float\n        wall_time: float",
      "successors": [
        3
      ]
    },
    {
      "id": 3,
      "label": "def get_current_time() -> Tuple[float, float]:\n        return time.time(), os.times()[0] + os.times()[1]",
      "successors": [
        4
      ]
    },
    {
      "id": 4,
      "label": "def subtract_times(start: Tuple[float, float], end: Tuple[float, float]) -> TimerResult:\n        end_wall_time, end_cpu_time = end\n        start_wall_time, start_cpu_time = start\n        return TimerResult(wall_time=end_wall_time - start_wall_time, user_cpu_time=end_cpu_time - start_cpu_time)",
      "successors": [
        5
      ]
    },
    {
      "id": 5,
      "label": "def some_decorator(func: Callable[P, T]) -> Callable[P, T]:\n    @functools.wraps(func)\n    def wrapper(*args: P.args, **kwargs: P.kwargs) -> T:\n        start = get_current_time()\n        try:\n            result = func(*args, **kwargs)\n        finally:\n            end = get_current_time()\n            elapsed = subtract_times(start, end)\n            logger.info(f\"Elapsed time: {elapsed}\")\n        return result\n    return wrapper",
      "successors": []
    }
  ]
}