{
  "name": "4.py",
  "type": "CFG",
  "blocks": [
    {
      "id": 1,
      "label": "#1\nimport atexit\nimport logging\nimport multiprocessing\nimport os\nimport signal\nimport sys\nimport threading\nfrom concurrent.futures import Future, ProcessPoolExecutor\nfrom contextlib import contextmanager\nfrom multiprocessing.pool import AsyncResult, Pool\nfrom typing import TYPE_CHECKING, Any, Generator, TypeVar, cast\nfrom pydantic import BaseModel\nfrom redis.lock import Lock as RedisLock\nif TYPE_CHECKING:",
      "successors": [
        {
          "id": 2,
          "label": "#2\nfrom backend.executor import DatabaseManager",
          "successors": [
            {
              "id": 3,
              "label": "#3\nfrom autogpt_libs.utils.cache import thread_cached\nfrom backend.blocks.agent import AgentExecutorBlock\nfrom backend.data import redis\nfrom backend.data.block import Block, BlockData, BlockInput, BlockType, get_block\nfrom backend.data.execution import ExecutionQueue, ExecutionResult, ExecutionStatus, GraphExecutionEntry, NodeExecutionEntry, merge_execution_input, parse_execution_output\nfrom backend.data.graph import GraphModel, Link, Node\nfrom backend.data.model import CREDENTIALS_FIELD_NAME, CredentialsMetaInput\nfrom backend.integrations.creds_manager import IntegrationCredentialsManager\nfrom backend.util import json\nfrom backend.util.decorator import error_logged, time_measured\nfrom backend.util.logging import configure_logging\nfrom backend.util.process import set_service_name\nfrom backend.util.service import AppService, close_service_client, expose, get_service_client\nfrom backend.util.settings import Settings\nfrom backend.util.type import convert\nlogger = logging.getLogger(__name__)\nsettings = Settings()\nT = TypeVar('T')\nExecutionStream = Generator[NodeExecutionEntry, None, None]",
              "successors": []
            }
          ]
        }
      ]
    }
  ],
  "functions": [
    {
      "name": "execute_node",
      "type": "CFG",
      "blocks": [
        {
          "id": 30,
          "label": "#30\n\"\"\"\n    Execute a node in the graph. This will trigger a block execution on a node,\n    persist the execution result, and return the subsequent node to be executed.\n\n    Args:\n        db_client: The client to send execution updates to the server.\n        creds_manager: The manager to acquire and release credentials.\n        data: The execution data for executing the current node.\n        execution_stats: The execution statistics to be updated.\n\n    Returns:\n        The subsequent node to be enqueued, or None if there is no subsequent node.\n    \"\"\"\nuser_id = data.user_id\ngraph_exec_id = data.graph_exec_id\ngraph_id = data.graph_id\nnode_exec_id = data.node_exec_id\nnode_id = data.node_id\nnode = db_client.get_node(node_id)\nnode_block = get_block(node.block_id)\nif not node_block:",
          "successors": [
            {
              "id": 35,
              "label": "#35\nlogger.error(f'Block {node.block_id} not found.')\nreturn",
              "successors": []
            },
            {
              "id": 36,
              "label": "#36\nlog_metadata = LogMetadata(user_id=user_id, graph_eid=graph_exec_id,\n    graph_id=graph_id, node_eid=node_exec_id, node_id=node_id, block_name=\n    node_block.name)\ninput_data, error = validate_exec(node, data.data, resolve_input=False)\nif input_data is None:",
              "successors": [
                {
                  "id": 38,
                  "label": "#38\nlog_metadata.error(f'Skip execution, input validation error: {error}')\ndb_client.upsert_execution_output(node_exec_id, 'error', error)\nupdate_execution(ExecutionStatus.FAILED)\nreturn",
                  "successors": []
                },
                {
                  "id": 39,
                  "label": "#39\nif isinstance(node_block, AgentExecutorBlock):",
                  "successors": [
                    {
                      "id": 41,
                      "label": "#41\ninput_data = {**node.input_default, 'data': input_data}",
                      "successors": [
                        {
                          "id": 42,
                          "label": "#42\ninput_data_str = json.dumps(input_data)\ninput_size = len(input_data_str)\nlog_metadata.info('Executed node with input', input=input_data_str)\nupdate_execution(ExecutionStatus.RUNNING)\nextra_exec_kwargs = {}\ncreds_lock = None\nif CREDENTIALS_FIELD_NAME in input_data:",
                          "successors": [
                            {
                              "id": 43,
                              "label": "#43\ncredentials_meta = CredentialsMetaInput(**input_data[CREDENTIALS_FIELD_NAME])\ncredentials, creds_lock = creds_manager.acquire(user_id, credentials_meta.id)\nextra_exec_kwargs['credentials'] = credentials",
                              "successors": [
                                {
                                  "id": 44,
                                  "label": "#44\noutput_size = 0\nend_status = ExecutionStatus.COMPLETED\ncredit = db_client.get_or_refill_credit(user_id)\nif credit < 0:",
                                  "successors": [
                                    {
                                      "id": 45,
                                      "label": "#45\nraise ValueError(f'Insufficient credit: {credit}')",
                                      "successors": []
                                    },
                                    {
                                      "id": 46,
                                      "label": "#46\ntry:",
                                      "successors": [
                                        {
                                          "id": 48,
                                          "label": "#48\nfor output_name, output_data in node_block.execute(input_data, **",
                                          "successors": [
                                            {
                                              "id": 51,
                                              "label": "#51\noutput_size += len(json.dumps(output_data))\nlog_metadata.info('Node produced output', **{output_name: output_data})\ndb_client.upsert_execution_output(node_exec_id, output_name, output_data)",
                                              "successors": [
                                                {
                                                  "id": 53,
                                                  "label": "#53\nfor execution in _enqueue_next_nodes(db_client=db_client, node=node, output",
                                                  "successors": [
                                                    {
                                                      "id": 54,
                                                      "label": "#54\nyield execution",
                                                      "successors": []
                                                    }
                                                  ]
                                                }
                                              ]
                                            }
                                          ]
                                        },
                                        {
                                          "id": 49,
                                          "label": "#49\nend_status = ExecutionStatus.FAILED\nerror_msg = str(e)\nlog_metadata.exception(f'Node execution failed with error {error_msg}')\ndb_client.upsert_execution_output(node_exec_id, 'error', error_msg)",
                                          "successors": [
                                            {
                                              "id": 57,
                                              "label": "#57\nfor execution in _enqueue_next_nodes(db_client=db_client, node=node, output",
                                              "successors": [
                                                {
                                                  "id": 58,
                                                  "label": "#58\nyield execution",
                                                  "successors": []
                                                },
                                                {
                                                  "id": 59,
                                                  "label": "#59\nraise e",
                                                  "successors": []
                                                }
                                              ]
                                            }
                                          ]
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "update_execution",
          "type": "CFG",
          "blocks": [
            {
              "id": 32,
              "label": "#32\nexec_update = db_client.update_execution_status(node_exec_id, status)\ndb_client.send_execution_update(exec_update)\nreturn exec_update",
              "successors": []
            }
          ],
          "functions": [],
          "classes": []
        }
      ],
      "classes": []
    },
    {
      "name": "_enqueue_next_nodes",
      "type": "CFG",
      "blocks": [
        {
          "id": 64,
          "label": "#64\nreturn [execution for link in node.output_links for execution in\n    register_next_executions(link)]",
          "successors": []
        }
      ],
      "functions": [
        {
          "name": "add_enqueued_execution",
          "type": "CFG",
          "blocks": [
            {
              "id": 66,
              "label": "#66\nexec_update = db_client.update_execution_status(node_exec_id,\n    ExecutionStatus.QUEUED, data)\ndb_client.send_execution_update(exec_update)\nreturn NodeExecutionEntry(user_id=user_id, graph_exec_id=graph_exec_id,\n    graph_id=graph_id, node_exec_id=node_exec_id, node_id=node_id, data=data)",
              "successors": []
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "register_next_executions",
          "type": "CFG",
          "blocks": [
            {
              "id": 70,
              "label": "#70\nenqueued_executions = []\nnext_output_name = node_link.source_name\nnext_input_name = node_link.sink_name\nnext_node_id = node_link.sink_id\nnext_data = parse_execution_output(output, next_output_name)\nif next_data is None:",
              "successors": [
                {
                  "id": 71,
                  "label": "#71\nreturn enqueued_executions",
                  "successors": []
                },
                {
                  "id": 72,
                  "label": "#72\nnext_node = db_client.get_node(next_node_id)\nwith synchronized(f'upsert_input-{next_node_id}-{graph_exec_id}'):",
                  "successors": [
                    {
                      "id": 74,
                      "label": "#74\nnext_node_exec_id, next_node_input = db_client.upsert_execution_input(node_id\n    =next_node_id, graph_exec_id=graph_exec_id, input_name=next_input_name,\n    input_data=next_data)\nstatic_link_names = {link.sink_name for link in next_node.input_links if \n    link.is_static and link.sink_name not in next_node_input}\nif static_link_names and (latest_execution := db_client.",
                      "successors": [
                        {
                          "id": 76,
                          "label": "#76\nfor name in static_link_names:",
                          "successors": [
                            {
                              "id": 78,
                              "label": "#78\nnext_node_input[name] = latest_execution.input_data.get(name)",
                              "successors": []
                            },
                            {
                              "id": 77,
                              "label": "#77\nnext_node_input, validation_msg = validate_exec(next_node, next_node_input)\nsuffix = (\n    f'{next_output_name}>{next_input_name}~{next_node_exec_id}:{validation_msg}'\n    )\nif not next_node_input:",
                              "successors": [
                                {
                                  "id": 80,
                                  "label": "#80\nlog_metadata.warning(f'Skipped queueing {suffix}')\nreturn enqueued_executions",
                                  "successors": []
                                },
                                {
                                  "id": 81,
                                  "label": "#81\nlog_metadata.info(f'Enqueued {suffix}')\nenqueued_executions.append(add_enqueued_execution(next_node_exec_id,\n    next_node_id, next_node_input))\nif not node_link.is_static:",
                                  "successors": [
                                    {
                                      "id": 83,
                                      "label": "#83\nreturn enqueued_executions",
                                      "successors": []
                                    },
                                    {
                                      "id": 84,
                                      "label": "#84\nfor iexec in db_client.get_incomplete_executions(next_node_id, graph_exec_id):",
                                      "successors": [
                                        {
                                          "id": 86,
                                          "label": "#86\nidata = iexec.input_data\nineid = iexec.node_exec_id\nstatic_link_names = {link.sink_name for link in next_node.input_links if \n    link.is_static and link.sink_name not in idata}",
                                          "successors": [
                                            {
                                              "id": 88,
                                              "label": "#88\nfor input_name in static_link_names:",
                                              "successors": [
                                                {
                                                  "id": 89,
                                                  "label": "#89\nidata[input_name] = next_node_input[input_name]",
                                                  "successors": []
                                                },
                                                {
                                                  "id": 90,
                                                  "label": "#90\nidata, msg = validate_exec(next_node, idata)\nsuffix = f'{next_output_name}>{next_input_name}~{ineid}:{msg}'\nif not idata:",
                                                  "successors": [
                                                    {
                                                      "id": 91,
                                                      "label": "#91\nlog_metadata.info(f'Enqueueing static-link skipped: {suffix}')",
                                                      "successors": []
                                                    },
                                                    {
                                                      "id": 92,
                                                      "label": "#92\nlog_metadata.info(f'Enqueueing static-link execution {suffix}')\nenqueued_executions.append(add_enqueued_execution(iexec.node_exec_id,\n    next_node_id, idata))",
                                                      "successors": []
                                                    }
                                                  ]
                                                }
                                              ]
                                            }
                                          ]
                                        },
                                        {
                                          "id": 87,
                                          "label": "#87\nreturn enqueued_executions",
                                          "successors": []
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "functions": [],
          "classes": []
        }
      ],
      "classes": []
    },
    {
      "name": "validate_exec",
      "type": "CFG",
      "blocks": [
        {
          "id": 98,
          "label": "#98\n\"\"\"\n    Validate the input data for a node execution.\n\n    Args:\n        node: The node to execute.\n        data: The input data for the node execution.\n        resolve_input: Whether to resolve dynamic pins into dict/list/object.\n\n    Returns:\n        A tuple of the validated data and the block name.\n        If the data is invalid, the first element will be None, and the second element\n        will be an error message.\n        If the data is valid, the first element will be the resolved input data, and\n        the second element will be the block name.\n    \"\"\"\nnode_block: Block | None = get_block(node.block_id)\nif not node_block:",
          "successors": [
            {
              "id": 99,
              "label": "#99\nreturn None, f'Block for {node.block_id} not found.'",
              "successors": []
            },
            {
              "id": 100,
              "label": "#100\nif isinstance(node_block, AgentExecutorBlock):",
              "successors": [
                {
                  "id": 102,
                  "label": "#102\ntry:",
                  "successors": [
                    {
                      "id": 109,
                      "label": "#109\nexec_data = AgentExecutorBlock.Input(**node.input_default)",
                      "successors": [
                        {
                          "id": 111,
                          "label": "#111\ninput_schema = exec_data.input_schema\nrequired_fields = set(input_schema['required'])\ninput_default = exec_data.data",
                          "successors": [
                            {
                              "id": 103,
                              "label": "#103\nerror_prefix = f'Input data missing or mismatch for `{node_block.name}`:'\ninput_fields_from_nodes = {link.sink_name for link in node.input_links}\nif not input_fields_from_nodes.issubset(data):",
                              "successors": [
                                {
                                  "id": 113,
                                  "label": "#113\nreturn None, f'{error_prefix} {input_fields_from_nodes - set(data)}'",
                                  "successors": []
                                },
                                {
                                  "id": 114,
                                  "label": "#114\ndata = {**input_default, **data}\nif resolve_input:",
                                  "successors": [
                                    {
                                      "id": 116,
                                      "label": "#116\ndata = merge_execution_input(data)",
                                      "successors": [
                                        {
                                          "id": 117,
                                          "label": "#117\nif not required_fields.issubset(data):",
                                          "successors": [
                                            {
                                              "id": 118,
                                              "label": "#118\nreturn None, f'{error_prefix} {required_fields - set(data)}'",
                                              "successors": []
                                            },
                                            {
                                              "id": 119,
                                              "label": "#119\nif (error := json.validate_with_jsonschema(schema=input_schema, data=data)):",
                                              "successors": [
                                                {
                                                  "id": 121,
                                                  "label": "#121\nerror_message = f'{error_prefix} {error}'\nlogger.error(error_message)\nreturn None, error_message",
                                                  "successors": []
                                                },
                                                {
                                                  "id": 122,
                                                  "label": "#122\nreturn data, node_block.name",
                                                  "successors": []
                                                }
                                              ]
                                            }
                                          ]
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "id": 110,
                      "label": "#110\nreturn None, f\"Input data doesn't match {node_block.name}: {str(e)}\"",
                      "successors": []
                    }
                  ]
                },
                {
                  "id": 104,
                  "label": "#104\nfor name, data_type in node_block.input_schema.__annotations__.items():",
                  "successors": [
                    {
                      "id": 105,
                      "label": "#105\nif (value := data.get(name)) and type(value) is not data_type:",
                      "successors": [
                        {
                          "id": 107,
                          "label": "#107\ndata[name] = convert(value, data_type)",
                          "successors": []
                        }
                      ]
                    },
                    {
                      "id": 106,
                      "label": "#106\ninput_schema = node_block.input_schema.jsonschema()\nrequired_fields = node_block.input_schema.get_required_fields()\ninput_default = node.input_default",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "get_db_client",
      "type": "CFG",
      "blocks": [
        {
          "id": 297,
          "label": "#297\nfrom backend.executor import DatabaseManager\nreturn get_service_client(DatabaseManager)",
          "successors": []
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "synchronized",
      "type": "CFG",
      "blocks": [
        {
          "id": 301,
          "label": "#301\nlock: RedisLock = redis.get_redis().lock(f'lock:{key}', timeout=timeout)\ntry:",
          "successors": [
            {
              "id": 302,
              "label": "#302\nlock.acquire()\nyield",
              "successors": []
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "llprint",
      "type": "CFG",
      "blocks": [
        {
          "id": 307,
          "label": "#307\n\"\"\"\n    Low-level print/log helper function for use in signal handlers.\n    Regular log/print statements are not allowed in signal handlers.\n    \"\"\"\nif logger.getEffectiveLevel() == logging.DEBUG:",
          "successors": [
            {
              "id": 308,
              "label": "#308\nos.write(sys.stdout.fileno(), (message + '\\n').encode())",
              "successors": []
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    }
  ],
  "classes": [
    {
      "name": "LogMetadata",
      "type": "CFG",
      "blocks": [
        {
          "id": 5,
          "label": "#5",
          "successors": []
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "type": "CFG",
          "blocks": [
            {
              "id": 7,
              "label": "#7\nself.metadata = {'component': 'ExecutionManager', 'user_id': user_id,\n    'graph_eid': graph_eid, 'graph_id': graph_id, 'node_eid': node_eid,\n    'node_id': node_id, 'block_name': block_name}\nself.prefix = (\n    f'[ExecutionManager|uid:{user_id}|gid:{graph_id}|nid:{node_id}]|geid:{graph_eid}|nid:{node_eid}|{block_name}]'\n    )",
              "successors": []
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "info",
          "type": "CFG",
          "blocks": [
            {
              "id": 10,
              "label": "#10\nmsg = self._wrap(msg, **extra)\nlogger.info(msg, extra={'json_fields': {**self.metadata, **extra}})",
              "successors": []
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "warning",
          "type": "CFG",
          "blocks": [
            {
              "id": 13,
              "label": "#13\nmsg = self._wrap(msg, **extra)\nlogger.warning(msg, extra={'json_fields': {**self.metadata, **extra}})",
              "successors": []
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "error",
          "type": "CFG",
          "blocks": [
            {
              "id": 16,
              "label": "#16\nmsg = self._wrap(msg, **extra)\nlogger.error(msg, extra={'json_fields': {**self.metadata, **extra}})",
              "successors": []
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "debug",
          "type": "CFG",
          "blocks": [
            {
              "id": 19,
              "label": "#19\nmsg = self._wrap(msg, **extra)\nlogger.debug(msg, extra={'json_fields': {**self.metadata, **extra}})",
              "successors": []
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "exception",
          "type": "CFG",
          "blocks": [
            {
              "id": 22,
              "label": "#22\nmsg = self._wrap(msg, **extra)\nlogger.exception(msg, extra={'json_fields': {**self.metadata, **extra}})",
              "successors": []
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "_wrap",
          "type": "CFG",
          "blocks": [
            {
              "id": 25,
              "label": "#25\nreturn f'{self.prefix} {msg} {extra}'",
              "successors": []
            }
          ],
          "functions": [],
          "classes": []
        }
      ],
      "classes": []
    },
    {
      "name": "Executor",
      "type": "CFG",
      "blocks": [
        {
          "id": 127,
          "label": "#127\n\"\"\"\n    This class contains event handlers for the process pool executor events.\n\n    The main events are:\n        on_node_executor_start: Initialize the process that executes the node.\n        on_node_execution: Execution logic for a node.\n\n        on_graph_executor_start: Initialize the process that executes the graph.\n        on_graph_execution: Execution logic for a graph.\n\n    The execution flow:\n        1. Graph execution request is added to the queue.\n        2. Graph executor loop picks the request from the queue.\n        3. Graph executor loop submits the graph execution request to the executor pool.\n      [on_graph_execution]\n        4. Graph executor initialize the node execution queue.\n        5. Graph executor adds the starting nodes to the node execution queue.\n        6. Graph executor waits for all nodes to be executed.\n      [on_node_execution]\n        7. Node executor picks the node execution request from the queue.\n        8. Node executor executes the node.\n        9. Node executor enqueues the next executed nodes to the node execution queue.\n    \"\"\"",
          "successors": []
        }
      ],
      "functions": [
        {
          "name": "on_node_executor_start",
          "type": "CFG",
          "blocks": [
            {
              "id": 129,
              "label": "#129\nconfigure_logging()\nset_service_name('NodeExecutor')\nredis.connect()\ncls.pid = os.getpid()\ncls.db_client = get_db_client()\ncls.creds_manager = IntegrationCredentialsManager()\ncls.shutdown_lock = threading.Lock()\natexit.register(cls.on_node_executor_stop)\nsignal.signal(signal.SIGTERM, lambda _, __: cls.on_node_executor_sigterm())",
              "successors": []
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "on_node_executor_stop",
          "type": "CFG",
          "blocks": [
            {
              "id": 132,
              "label": "#132\nif not cls.shutdown_lock.acquire(blocking=False):",
              "successors": [
                {
                  "id": 133,
                  "label": "#133\nreturn",
                  "successors": []
                },
                {
                  "id": 134,
                  "label": "#134\ncls.creds_manager.release_all_locks()\nredis.disconnect()\nclose_service_client(cls.db_client)\nlogger.info(f'[on_node_executor_stop {cls.pid}] \u2705 Finished cleanup')",
                  "successors": []
                }
              ]
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "on_node_executor_sigterm",
          "type": "CFG",
          "blocks": [
            {
              "id": 138,
              "label": "#138\nllprint(f'[on_node_executor_sigterm {cls.pid}] \u26a0\ufe0f SIGTERM received')\nif not cls.shutdown_lock.acquire(blocking=False):",
              "successors": [
                {
                  "id": 139,
                  "label": "#139\nreturn",
                  "successors": []
                },
                {
                  "id": 140,
                  "label": "#140\ncls.creds_manager.release_all_locks()\nredis.disconnect()\nllprint(f'[on_node_executor_stop {cls.pid}] \u2705 Finished cleanup')\nsys.exit(0)",
                  "successors": []
                }
              ]
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "on_node_execution",
          "type": "CFG",
          "blocks": [
            {
              "id": 144,
              "label": "#144\nlog_metadata = LogMetadata(user_id=node_exec.user_id, graph_eid=node_exec.\n    graph_exec_id, graph_id=node_exec.graph_id, node_eid=node_exec.\n    node_exec_id, node_id=node_exec.node_id, block_name='-')\nexecution_stats = {}\ntiming_info, _ = cls._on_node_execution(q, node_exec, log_metadata,\n    execution_stats)\nexecution_stats['walltime'] = timing_info.wall_time\nexecution_stats['cputime'] = timing_info.cpu_time\ncls.db_client.update_node_execution_stats(node_exec.node_exec_id,\n    execution_stats)\nreturn execution_stats",
              "successors": []
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "_on_node_execution",
          "type": "CFG",
          "blocks": [
            {
              "id": 148,
              "label": "#148\ntry:",
              "successors": [
                {
                  "id": 149,
                  "label": "#149\nlog_metadata.info(f'Start node execution {node_exec.node_exec_id}')",
                  "successors": [
                    {
                      "id": 152,
                      "label": "#152\nfor execution in execute_node(cls.db_client, cls.creds_manager, node_exec,",
                      "successors": [
                        {
                          "id": 153,
                          "label": "#153\nq.add(execution)",
                          "successors": []
                        },
                        {
                          "id": 154,
                          "label": "#154\nlog_metadata.info(f'Finished node execution {node_exec.node_exec_id}')",
                          "successors": []
                        }
                      ]
                    }
                  ]
                },
                {
                  "id": 150,
                  "label": "#150\nlog_metadata.exception(f'Failed node execution {node_exec.node_exec_id}: {e}')",
                  "successors": []
                }
              ]
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "on_graph_executor_start",
          "type": "CFG",
          "blocks": [
            {
              "id": 157,
              "label": "#157\nconfigure_logging()\nset_service_name('GraphExecutor')\ncls.db_client = get_db_client()\ncls.pool_size = settings.config.num_node_workers\ncls.pid = os.getpid()\ncls._init_node_executor_pool()\nlogger.info(\n    f'Graph executor {cls.pid} started with {cls.pool_size} node workers')\natexit.register(cls.on_graph_executor_stop)",
              "successors": []
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "on_graph_executor_stop",
          "type": "CFG",
          "blocks": [
            {
              "id": 160,
              "label": "#160\nprefix = f'[on_graph_executor_stop {cls.pid}]'\ncls.executor.terminate()\nclose_service_client(cls.db_client)\nlogger.info(f'{prefix} \u2705 Finished cleanup')",
              "successors": []
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "_init_node_executor_pool",
          "type": "CFG",
          "blocks": [
            {
              "id": 163,
              "label": "#163\ncls.executor = Pool(processes=cls.pool_size, initializer=cls.\n    on_node_executor_start)",
              "successors": []
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "on_graph_execution",
          "type": "CFG",
          "blocks": [
            {
              "id": 166,
              "label": "#166\nlog_metadata = LogMetadata(user_id=graph_exec.user_id, graph_eid=graph_exec\n    .graph_exec_id, graph_id=graph_exec.graph_id, node_id='*', node_eid='*',\n    block_name='-')\ntiming_info, (exec_stats, error) = cls._on_graph_execution(graph_exec,\n    cancel, log_metadata)\nexec_stats['walltime'] = timing_info.wall_time\nexec_stats['cputime'] = timing_info.cpu_time\nexec_stats['error'] = str(error) if error else None\nresult = cls.db_client.update_graph_execution_stats(graph_exec_id=\n    graph_exec.graph_exec_id, stats=exec_stats)\ncls.db_client.send_execution_update(result)",
              "successors": []
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "_on_graph_execution",
          "type": "CFG",
          "blocks": [
            {
              "id": 169,
              "label": "#169\n\"\"\"\n        Returns:\n            The execution statistics of the graph execution.\n            The error that occurred during the execution.\n        \"\"\"\nlog_metadata.info(f'Start graph execution {graph_exec.graph_exec_id}')\nexec_stats = {'nodes_walltime': 0, 'nodes_cputime': 0, 'node_count': 0}\nerror = None\nfinished = False\ncancel_thread = threading.Thread(target=cancel_handler)\ncancel_thread.start()\ntry:",
              "successors": [
                {
                  "id": 178,
                  "label": "#178\nqueue = ExecutionQueue[NodeExecutionEntry]()",
                  "successors": [
                    {
                      "id": 181,
                      "label": "#181\nfor node_exec in graph_exec.start_node_execs:",
                      "successors": [
                        {
                          "id": 182,
                          "label": "#182\nqueue.add(node_exec)",
                          "successors": []
                        },
                        {
                          "id": 183,
                          "label": "#183\nrunning_executions: dict[str, AsyncResult] = {}",
                          "successors": [
                            {
                              "id": 193,
                              "label": "#193\nwhile not queue.empty():",
                              "successors": [
                                {
                                  "id": 194,
                                  "label": "#194\nif cancel.is_set():",
                                  "successors": [
                                    {
                                      "id": 196,
                                      "label": "#196\nerror = RuntimeError('Execution is cancelled')\nreturn exec_stats, error",
                                      "successors": []
                                    },
                                    {
                                      "id": 197,
                                      "label": "#197\nexec_data = queue.get()\nexecution = running_executions.get(exec_data.node_id)\nif execution and not execution.ready():",
                                      "successors": [
                                        {
                                          "id": 199,
                                          "label": "#199\nexecution.wait()",
                                          "successors": [
                                            {
                                              "id": 200,
                                              "label": "#200\nlog_metadata.debug(\n    f'Dispatching node execution {exec_data.node_exec_id} for node {exec_data.node_id}'\n    )\nrunning_executions[exec_data.node_id] = cls.executor.apply_async(cls.\n    on_node_execution, (queue, exec_data), callback=make_exec_callback(\n    exec_data))",
                                              "successors": [
                                                {
                                                  "id": 201,
                                                  "label": "#201\nwhile queue.empty() and running_executions:",
                                                  "successors": [
                                                    {
                                                      "id": 202,
                                                      "label": "#202\nlog_metadata.debug(\n    f'Queue empty; running nodes: {list(running_executions.keys())}')",
                                                      "successors": [
                                                        {
                                                          "id": 204,
                                                          "label": "#204\nfor node_id, execution in list(running_executions.items()):",
                                                          "successors": [
                                                            {
                                                              "id": 205,
                                                              "label": "#205\nif cancel.is_set():",
                                                              "successors": [
                                                                {
                                                                  "id": 207,
                                                                  "label": "#207\nerror = RuntimeError('Execution is cancelled')\nreturn exec_stats, error",
                                                                  "successors": []
                                                                },
                                                                {
                                                                  "id": 208,
                                                                  "label": "#208\nif not queue.empty():",
                                                                  "successors": [
                                                                    {
                                                                      "id": 211,
                                                                      "label": "#211\nlog_metadata.debug(f'Waiting on execution of node {node_id}')\nexecution.wait(3)",
                                                                      "successors": []
                                                                    }
                                                                  ]
                                                                }
                                                              ]
                                                            }
                                                          ]
                                                        }
                                                      ]
                                                    }
                                                  ]
                                                }
                                              ]
                                            }
                                          ]
                                        }
                                      ]
                                    }
                                  ]
                                },
                                {
                                  "id": 195,
                                  "label": "#195\nlog_metadata.info(f'Finished graph execution {graph_exec.graph_exec_id}')",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "id": 179,
                  "label": "#179\nlog_metadata.exception(\n    f'Failed graph execution {graph_exec.graph_exec_id}: {e}')\nerror = e",
                  "successors": []
                }
              ]
            }
          ],
          "functions": [
            {
              "name": "cancel_handler",
              "type": "CFG",
              "blocks": [
                {
                  "id": 171,
                  "label": "#171\nwhile not cancel.is_set():",
                  "successors": [
                    {
                      "id": 172,
                      "label": "#172\ncancel.wait(1)",
                      "successors": []
                    },
                    {
                      "id": 173,
                      "label": "#173\nif finished:",
                      "successors": [
                        {
                          "id": 174,
                          "label": "#174\nreturn",
                          "successors": []
                        },
                        {
                          "id": 175,
                          "label": "#175\ncls.executor.terminate()\nlog_metadata.info(f'Terminated graph execution {graph_exec.graph_exec_id}')\ncls._init_node_executor_pool()",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ],
              "functions": [],
              "classes": []
            },
            {
              "name": "make_exec_callback",
              "type": "CFG",
              "blocks": [
                {
                  "id": 185,
                  "label": "#185\nnode_id = exec_data.node_id\nreturn callback",
                  "successors": []
                }
              ],
              "functions": [
                {
                  "name": "callback",
                  "type": "CFG",
                  "blocks": [
                    {
                      "id": 187,
                      "label": "#187\nrunning_executions.pop(node_id)\nnonlocal exec_stats\nif isinstance(result, dict):",
                      "successors": [
                        {
                          "id": 188,
                          "label": "#188\nexec_stats['node_count'] += 1\nexec_stats['nodes_cputime'] += result.get('cputime', 0)\nexec_stats['nodes_walltime'] += result.get('walltime', 0)",
                          "successors": []
                        }
                      ]
                    }
                  ],
                  "functions": [],
                  "classes": []
                }
              ],
              "classes": []
            }
          ],
          "classes": []
        }
      ],
      "classes": []
    },
    {
      "name": "ExecutionManager",
      "type": "CFG",
      "blocks": [
        {
          "id": 215,
          "label": "#215",
          "successors": []
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "type": "CFG",
          "blocks": [
            {
              "id": 217,
              "label": "#217\nsuper().__init__()\nself.use_redis = True\nself.use_supabase = True\nself.pool_size = settings.config.num_graph_workers\nself.queue = ExecutionQueue[GraphExecutionEntry]()\nself.active_graph_runs: dict[str, tuple[Future, threading.Event]] = {}",
              "successors": []
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "get_port",
          "type": "CFG",
          "blocks": [
            {
              "id": 220,
              "label": "#220\nreturn settings.config.execution_manager_port",
              "successors": []
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "run_service",
          "type": "CFG",
          "blocks": [
            {
              "id": 224,
              "label": "#224\nfrom backend.integrations.credentials_store import IntegrationCredentialsStore\nself.credentials_store = IntegrationCredentialsStore()\nself.executor = ProcessPoolExecutor(max_workers=self.pool_size, initializer\n    =Executor.on_graph_executor_start)\nsync_manager = multiprocessing.Manager()\nlogger.info(\n    f'[{self.service_name}] Started with max-{self.pool_size} graph workers')",
              "successors": [
                {
                  "id": 225,
                  "label": "#225\nwhile True:",
                  "successors": [
                    {
                      "id": 226,
                      "label": "#226\ngraph_exec_data = self.queue.get()\ngraph_exec_id = graph_exec_data.graph_exec_id\nlogger.debug(f'[ExecutionManager] Dispatching graph execution {graph_exec_id}')\ncancel_event = sync_manager.Event()\nfuture = self.executor.submit(Executor.on_graph_execution, graph_exec_data,\n    cancel_event)\nself.active_graph_runs[graph_exec_id] = future, cancel_event\nfuture.add_done_callback(lambda _: self.active_graph_runs.pop(graph_exec_id,\n    None))",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "cleanup",
          "type": "CFG",
          "blocks": [
            {
              "id": 230,
              "label": "#230\nself.executor.shutdown(cancel_futures=True)\nsuper().cleanup()",
              "successors": []
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "db_client",
          "type": "CFG",
          "blocks": [
            {
              "id": 233,
              "label": "#233\nreturn get_db_client()",
              "successors": []
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "add_execution",
          "type": "CFG",
          "blocks": [
            {
              "id": 237,
              "label": "#237\ngraph: GraphModel | None = self.db_client.get_graph(graph_id=graph_id,\n    user_id=user_id, version=graph_version)\nif not graph:",
              "successors": [
                {
                  "id": 238,
                  "label": "#238\nraise ValueError(f'Graph #{graph_id} not found.')",
                  "successors": []
                },
                {
                  "id": 239,
                  "label": "#239\ngraph.validate_graph(for_run=True)\nself._validate_node_input_credentials(graph, user_id)\nnodes_input = []",
                  "successors": [
                    {
                      "id": 241,
                      "label": "#241\nfor node in graph.starting_nodes:",
                      "successors": [
                        {
                          "id": 242,
                          "label": "#242\ninput_data = {}\nblock = get_block(node.block_id)\nif not block or block.block_type == BlockType.NOTE:",
                          "successors": [
                            {
                              "id": 245,
                              "label": "#245\nif block.block_type == BlockType.INPUT:",
                              "successors": [
                                {
                                  "id": 246,
                                  "label": "#246\nname = node.input_default.get('name')\nif name and name in data:",
                                  "successors": [
                                    {
                                      "id": 248,
                                      "label": "#248\ninput_data = {'value': data[name]}",
                                      "successors": [
                                        {
                                          "id": 247,
                                          "label": "#247\nwebhook_payload_key = f'webhook_{node.webhook_id}_payload'\nif block.block_type in (BlockType.WEBHOOK, BlockType.WEBHOOK_MANUAL",
                                          "successors": [
                                            {
                                              "id": 250,
                                              "label": "#250\nif webhook_payload_key not in data:",
                                              "successors": [
                                                {
                                                  "id": 252,
                                                  "label": "#252\nraise ValueError(f'Node {block.name} #{node.id} webhook payload is missing')",
                                                  "successors": []
                                                },
                                                {
                                                  "id": 253,
                                                  "label": "#253\ninput_data = {'payload': data[webhook_payload_key]}",
                                                  "successors": [
                                                    {
                                                      "id": 251,
                                                      "label": "#251\ninput_data, error = validate_exec(node, input_data)\nif input_data is None:",
                                                      "successors": [
                                                        {
                                                          "id": 255,
                                                          "label": "#255\nraise ValueError(error)",
                                                          "successors": []
                                                        },
                                                        {
                                                          "id": 257,
                                                          "label": "#257\nnodes_input.append((node.id, input_data))",
                                                          "successors": []
                                                        }
                                                      ]
                                                    }
                                                  ]
                                                }
                                              ]
                                            }
                                          ]
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        },
                        {
                          "id": 243,
                          "label": "#243\ngraph_exec_id, node_execs = self.db_client.create_graph_execution(graph_id=\n    graph_id, graph_version=graph.version, nodes_input=nodes_input, user_id\n    =user_id)\nstarting_node_execs = []",
                          "successors": [
                            {
                              "id": 259,
                              "label": "#259\nfor node_exec in node_execs:",
                              "successors": [
                                {
                                  "id": 260,
                                  "label": "#260\nstarting_node_execs.append(NodeExecutionEntry(user_id=user_id,\n    graph_exec_id=node_exec.graph_exec_id, graph_id=node_exec.graph_id,\n    node_exec_id=node_exec.node_exec_id, node_id=node_exec.node_id, data=\n    node_exec.input_data))\nexec_update = self.db_client.update_execution_status(node_exec.node_exec_id,\n    ExecutionStatus.QUEUED, node_exec.input_data)\nself.db_client.send_execution_update(exec_update)",
                                  "successors": []
                                },
                                {
                                  "id": 261,
                                  "label": "#261\ngraph_exec = GraphExecutionEntry(user_id=user_id, graph_id=graph_id,\n    graph_exec_id=graph_exec_id, start_node_execs=starting_node_execs)\nself.queue.add(graph_exec)\nreturn graph_exec",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "cancel_execution",
          "type": "CFG",
          "blocks": [
            {
              "id": 265,
              "label": "#265\n\"\"\"\n        Mechanism:\n        1. Set the cancel event\n        2. Graph executor's cancel handler thread detects the event, terminates workers,\n           reinitializes worker pool, and returns.\n        3. Update execution statuses in DB and set `error` outputs to `\"TERMINATED\"`.\n        \"\"\"\nif graph_exec_id not in self.active_graph_runs:",
              "successors": [
                {
                  "id": 266,
                  "label": "#266\nraise Exception(\n    f'Graph execution #{graph_exec_id} not active/running: possibly already completed/cancelled.'\n    )",
                  "successors": []
                },
                {
                  "id": 267,
                  "label": "#267\nfuture, cancel_event = self.active_graph_runs[graph_exec_id]\nif cancel_event.is_set():",
                  "successors": [
                    {
                      "id": 269,
                      "label": "#269\nreturn",
                      "successors": []
                    },
                    {
                      "id": 270,
                      "label": "#270\ncancel_event.set()\nfuture.result()\nnode_execs = self.db_client.get_execution_results(graph_exec_id)",
                      "successors": [
                        {
                          "id": 272,
                          "label": "#272\nfor node_exec in node_execs:",
                          "successors": [
                            {
                              "id": 273,
                              "label": "#273\nif node_exec.status not in (ExecutionStatus.COMPLETED, ExecutionStatus.FAILED):",
                              "successors": [
                                {
                                  "id": 275,
                                  "label": "#275\nself.db_client.upsert_execution_output(node_exec.node_exec_id, 'error',\n    'TERMINATED')\nexec_update = self.db_client.update_execution_status(node_exec.node_exec_id,\n    ExecutionStatus.FAILED)\nself.db_client.send_execution_update(exec_update)",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "_validate_node_input_credentials",
          "type": "CFG",
          "blocks": [
            {
              "id": 279,
              "label": "#279\n\"\"\"Checks all credentials for all nodes of the graph\"\"\"",
              "successors": [
                {
                  "id": 280,
                  "label": "#280\nfor node in graph.nodes:",
                  "successors": [
                    {
                      "id": 281,
                      "label": "#281\nblock = get_block(node.block_id)\nif not block:",
                      "successors": [
                        {
                          "id": 283,
                          "label": "#283\nraise ValueError(f'Unknown block {node.block_id} for node #{node.id}')",
                          "successors": []
                        },
                        {
                          "id": 284,
                          "label": "#284\nmodel_fields = cast(type[BaseModel], block.input_schema).model_fields\nif CREDENTIALS_FIELD_NAME not in model_fields:",
                          "successors": [
                            {
                              "id": 287,
                              "label": "#287\nfield = model_fields[CREDENTIALS_FIELD_NAME]\ncredentials_meta_type = cast(CredentialsMetaInput, field.annotation)\ncredentials_meta = credentials_meta_type.model_validate(node.input_default[\n    CREDENTIALS_FIELD_NAME])\ncredentials = self.credentials_store.get_creds_by_id(user_id,\n    credentials_meta.id)\nif not credentials:",
                              "successors": [
                                {
                                  "id": 288,
                                  "label": "#288\nraise ValueError(\n    f'Unknown credentials #{credentials_meta.id} for node #{node.id}')",
                                  "successors": []
                                },
                                {
                                  "id": 289,
                                  "label": "#289\nif credentials.provider != credentials_meta.provider or credentials.type != credentials_meta.type:",
                                  "successors": [
                                    {
                                      "id": 291,
                                      "label": "#291\nlogger.warning(\n    f'Invalid credentials #{credentials.id} for node #{node.id}: type/provider mismatch: {credentials_meta.type}<>{credentials.type};{credentials_meta.provider}<>{credentials.provider}'\n    )\nraise ValueError(\n    f'Invalid credentials #{credentials.id} for node #{node.id}: type/provider mismatch'\n    )",
                                      "successors": []
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "functions": [],
          "classes": []
        }
      ],
      "classes": []
    }
  ]
}