{
  "name": "120.py",
  "type": "CFG",
  "blocks": [
    {
      "id": 1,
      "label": "#1\nimport inspect\nfrom abc import ABC, abstractmethod\nfrom enum import Enum\nfrom typing import Any, ClassVar, Generator, Generic, Optional, Type, TypeVar, cast, get_origin\nimport jsonref\nimport jsonschema\nfrom prisma.models import AgentBlock\nfrom pydantic import BaseModel\nfrom backend.util import json\nfrom backend.util.settings import Config\nfrom .model import CREDENTIALS_FIELD_NAME, ContributorDetails, Credentials, CredentialsMetaInput\napp_config = Config()\nBlockData = tuple[str, Any]\nBlockInput = dict[str, Any]\nBlockOutput = Generator[BlockData, None, None]\nCompletedBlockOutput = dict[str, list[Any]]\nBlockSchemaInputType = TypeVar('BlockSchemaInputType', bound=BlockSchema)\nBlockSchemaOutputType = TypeVar('BlockSchemaOutputType', bound=BlockSchema)",
      "successors": []
    }
  ],
  "functions": [
    {
      "name": "get_blocks",
      "type": "CFG",
      "blocks": [
        {
          "id": 170,
          "label": "#170\nfrom backend.blocks import AVAILABLE_BLOCKS\nreturn AVAILABLE_BLOCKS",
          "successors": []
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "initialize_blocks",
      "type": "CFG",
      "blocks": [
        {
          "id": 174,
          "label": "#174\nfor cls in get_blocks().values():",
          "successors": [
            {
              "id": 175,
              "label": "#175\nblock = cls()\nexisting_block = await AgentBlock.prisma().find_first(where={'OR': [{'id':\n    block.id}, {'name': block.name}]})",
              "successors": [
                {
                  "id": 177,
                  "label": "#177\nif not existing_block:",
                  "successors": [
                    {
                      "id": 178,
                      "label": "#178\nawait AgentBlock.prisma().create(data={'id': block.id, 'name': block.name,\n    'inputSchema': json.dumps(block.input_schema.jsonschema()),\n    'outputSchema': json.dumps(block.output_schema.jsonschema())})",
                      "successors": []
                    },
                    {
                      "id": 179,
                      "label": "#179\ninput_schema = json.dumps(block.input_schema.jsonschema())\noutput_schema = json.dumps(block.output_schema.jsonschema())\nif block.id != existing_block.id or block.name != existing_block.name or input_schema != existing_block.inputSchema or output_schema != existing_block.outputSchema:",
                      "successors": [
                        {
                          "id": 181,
                          "label": "#181\nawait AgentBlock.prisma().update(where={'id': existing_block.id}, data={\n    'id': block.id, 'name': block.name, 'inputSchema': input_schema,\n    'outputSchema': output_schema})",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "get_block",
      "type": "CFG",
      "blocks": [
        {
          "id": 186,
          "label": "#186\ncls = get_blocks().get(block_id)\nreturn cls() if cls else None",
          "successors": []
        }
      ],
      "functions": [],
      "classes": []
    }
  ],
  "classes": [
    {
      "name": "BlockType",
      "type": "CFG",
      "blocks": [
        {
          "id": 3,
          "label": "#3\nSTANDARD = 'Standard'\nINPUT = 'Input'\nOUTPUT = 'Output'\nNOTE = 'Note'\nWEBHOOK = 'Webhook'\nWEBHOOK_MANUAL = 'Webhook (manual)'\nAGENT = 'Agent'",
          "successors": []
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "BlockCategory",
      "type": "CFG",
      "blocks": [
        {
          "id": 6,
          "label": "#6\nAI = 'Block that leverages AI to perform a task.'\nSOCIAL = 'Block that interacts with social media platforms.'\nTEXT = 'Block that processes text data.'\nSEARCH = 'Block that searches or extracts information from the internet.'\nBASIC = 'Block that performs basic operations.'\nINPUT = 'Block that interacts with input of the graph.'\nOUTPUT = 'Block that interacts with output of the graph.'\nLOGIC = 'Programming logic to control the flow of your agent'\nCOMMUNICATION = 'Block that interacts with communication platforms.'\nDEVELOPER_TOOLS = 'Developer tools such as GitHub blocks.'\nDATA = 'Block that interacts with structured data.'\nHARDWARE = 'Block that interacts with hardware.'\nAGENT = 'Block that interacts with other agents.'\nCRM = 'Block that interacts with CRM services.'",
          "successors": []
        }
      ],
      "functions": [
        {
          "name": "dict",
          "type": "CFG",
          "blocks": [
            {
              "id": 8,
              "label": "#8\nreturn {'category': self.name, 'description': self.value}",
              "successors": []
            }
          ],
          "functions": [],
          "classes": []
        }
      ],
      "classes": []
    },
    {
      "name": "BlockSchema",
      "type": "CFG",
      "blocks": [
        {
          "id": 13,
          "label": "#13\ncached_jsonschema: ClassVar[dict[str, Any]]",
          "successors": []
        }
      ],
      "functions": [
        {
          "name": "jsonschema",
          "type": "CFG",
          "blocks": [
            {
              "id": 15,
              "label": "#15\nif cls.cached_jsonschema:",
              "successors": [
                {
                  "id": 16,
                  "label": "#16\nreturn cls.cached_jsonschema",
                  "successors": []
                },
                {
                  "id": 17,
                  "label": "#17\nmodel = jsonref.replace_refs(cls.model_json_schema(), merge_props=True)\ncls.cached_jsonschema = cast(dict[str, Any], ref_to_dict(model))",
                  "successors": [
                    {
                      "id": 32,
                      "label": "#32\nfor field in cls.cached_jsonschema.get('properties', {}).values():",
                      "successors": [
                        {
                          "id": 33,
                          "label": "#33\nif isinstance(field, dict) and 'advanced' not in field:",
                          "successors": [
                            {
                              "id": 35,
                              "label": "#35\nfield['advanced'] = True",
                              "successors": []
                            }
                          ]
                        },
                        {
                          "id": 34,
                          "label": "#34\nreturn cls.cached_jsonschema",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "functions": [
            {
              "name": "ref_to_dict",
              "type": "CFG",
              "blocks": [
                {
                  "id": 20,
                  "label": "#20\nif isinstance(obj, dict):",
                  "successors": [
                    {
                      "id": 21,
                      "label": "#21\nkeys = {'allOf', 'anyOf', 'oneOf'}\none_key = next((k for k in keys if k in obj and len(obj[k]) == 1), None)\nif one_key:",
                      "successors": [
                        {
                          "id": 27,
                          "label": "#27\nobj.update(obj[one_key][0])",
                          "successors": [
                            {
                              "id": 28,
                              "label": "#28\nreturn {key: ref_to_dict(value) for key, value in obj.items() if not key.\n    startswith('$') and key != one_key}",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "id": 23,
                      "label": "#23\nif isinstance(obj, list):",
                      "successors": [
                        {
                          "id": 24,
                          "label": "#24\nreturn [ref_to_dict(item) for item in obj]",
                          "successors": []
                        },
                        {
                          "id": 22,
                          "label": "#22\nreturn obj",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ],
              "functions": [],
              "classes": []
            }
          ],
          "classes": []
        },
        {
          "name": "validate_data",
          "type": "CFG",
          "blocks": [
            {
              "id": 40,
              "label": "#40\nreturn json.validate_with_jsonschema(schema=cls.jsonschema(), data=data)",
              "successors": []
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "validate_field",
          "type": "CFG",
          "blocks": [
            {
              "id": 44,
              "label": "#44\n\"\"\"\n        Validate the data against a specific property (one of the input/output name).\n        Returns the validation error message if the data does not match the schema.\n        \"\"\"\nmodel_schema = cls.jsonschema().get('properties', {})\nif not model_schema:",
              "successors": [
                {
                  "id": 45,
                  "label": "#45\nreturn f'Invalid model schema {cls}'",
                  "successors": []
                },
                {
                  "id": 46,
                  "label": "#46\nproperty_schema = model_schema.get(field_name)\nif not property_schema:",
                  "successors": [
                    {
                      "id": 48,
                      "label": "#48\nreturn f'Invalid property name {field_name}'",
                      "successors": []
                    },
                    {
                      "id": 49,
                      "label": "#49\ntry:",
                      "successors": [
                        {
                          "id": 51,
                          "label": "#51\njsonschema.validate(json.to_dict(data), property_schema)\nreturn None",
                          "successors": []
                        },
                        {
                          "id": 52,
                          "label": "#52\nreturn str(e)",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "get_fields",
          "type": "CFG",
          "blocks": [
            {
              "id": 58,
              "label": "#58\nreturn set(cls.model_fields.keys())",
              "successors": []
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "get_required_fields",
          "type": "CFG",
          "blocks": [
            {
              "id": 62,
              "label": "#62\nreturn {field for field, field_info in cls.model_fields.items() if\n    field_info.is_required()}",
              "successors": []
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "__pydantic_init_subclass__",
          "type": "CFG",
          "blocks": [
            {
              "id": 66,
              "label": "#66\n\"\"\"Validates the schema definition. Rules:\n        - Only one `CredentialsMetaInput` field may be present.\n          - This field MUST be called `credentials`.\n        - A field that is called `credentials` MUST be a `CredentialsMetaInput`.\n        \"\"\"\nsuper().__pydantic_init_subclass__(**kwargs)\ncls.cached_jsonschema = {}\ncredentials_fields = [field_name for field_name, info in cls.model_fields.\n    items() if inspect.isclass(info.annotation) and issubclass(get_origin(\n    info.annotation) or info.annotation, CredentialsMetaInput)]\nif len(credentials_fields) > 1:",
              "successors": [
                {
                  "id": 67,
                  "label": "#67\nraise ValueError(\n    f'{cls.__qualname__} can only have one CredentialsMetaInput field')",
                  "successors": []
                },
                {
                  "id": 69,
                  "label": "#69\nif len(credentials_fields) == 1 and credentials_fields[0",
                  "successors": [
                    {
                      "id": 70,
                      "label": "#70\nraise ValueError(\n    f\"CredentialsMetaInput field on {cls.__qualname__} must be named 'credentials'\"\n    )",
                      "successors": []
                    },
                    {
                      "id": 72,
                      "label": "#72\nif len(credentials_fields",
                      "successors": [
                        {
                          "id": 73,
                          "label": "#73\nraise TypeError(\n    f\"Field 'credentials' on {cls.__qualname__} must be of type {CredentialsMetaInput.__name__}\"\n    )",
                          "successors": []
                        },
                        {
                          "id": 68,
                          "label": "#68\nif (credentials_field := cls.model_fields.get(CREDENTIALS_FIELD_NAME)):",
                          "successors": [
                            {
                              "id": 78,
                              "label": "#78\ncredentials_input_type = cast(CredentialsMetaInput, credentials_field.\n    annotation)\ncredentials_input_type.validate_credentials_field_schema(cls)",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "functions": [],
          "classes": []
        }
      ],
      "classes": []
    },
    {
      "name": "EmptySchema",
      "type": "CFG",
      "blocks": [
        {
          "id": 83,
          "label": "#83\npass",
          "successors": []
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "BlockManualWebhookConfig",
      "type": "CFG",
      "blocks": [
        {
          "id": 86,
          "label": "#86\n\"\"\"\n    Configuration model for webhook-triggered blocks on which\n    the user has to manually set up the webhook at the provider.\n    \"\"\"\nprovider: str\n\"\"\"The service provider that the webhook connects to\"\"\"\nwebhook_type: str\n\"\"\"\n    Identifier for the webhook type. E.g. GitHub has repo and organization level hooks.\n\n    Only for use in the corresponding `WebhooksManager`.\n    \"\"\"\nevent_filter_input: str = ''\n\"\"\"\n    Name of the block's event filter input.\n    Leave empty if the corresponding webhook doesn't have distinct event/payload types.\n    \"\"\"\nevent_format: str = '{event}'\n\"\"\"\n    Template string for the event(s) that a block instance subscribes to.\n    Applied individually to each event selected in the event filter input.\n\n    Example: `\"pull_request.{event}\"` -> `\"pull_request.opened\"`\n    \"\"\"",
          "successors": []
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "BlockWebhookConfig",
      "type": "CFG",
      "blocks": [
        {
          "id": 89,
          "label": "#89\n\"\"\"\n    Configuration model for webhook-triggered blocks for which\n    the webhook can be automatically set up through the provider's API.\n    \"\"\"\nresource_format: str\n\"\"\"\n    Template string for the resource that a block instance subscribes to.\n    Fields will be filled from the block's inputs (except `payload`).\n\n    Example: `f\"{repo}/pull_requests\"` (note: not how it's actually implemented)\n\n    Only for use in the corresponding `WebhooksManager`.\n    \"\"\"",
          "successors": []
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "Block",
      "type": "CFG",
      "blocks": [
        {
          "id": 92,
          "label": "#92",
          "successors": []
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "type": "CFG",
          "blocks": [
            {
              "id": 94,
              "label": "#94\n\"\"\"\n        Initialize the block with the given schema.\n\n        Args:\n            id: The unique identifier for the block, this value will be persisted in the\n                DB. So it should be a unique and constant across the application run.\n                Use the UUID format for the ID.\n            description: The description of the block, explaining what the block does.\n            contributors: The list of contributors who contributed to the block.\n            input_schema: The schema, defined as a Pydantic model, for the input data.\n            output_schema: The schema, defined as a Pydantic model, for the output data.\n            test_input: The list or single sample input data for the block, for testing.\n            test_output: The list or single expected output if the test_input is run.\n            test_mock: function names on the block implementation to mock on test run.\n            disabled: If the block is disabled, it will not be available for execution.\n            static_output: Whether the output links of the block are static by default.\n        \"\"\"\nself.id = id\nself.input_schema = input_schema\nself.output_schema = output_schema\nself.test_input = test_input\nself.test_output = test_output\nself.test_mock = test_mock\nself.test_credentials = test_credentials\nself.description = description\nself.categories = categories or set()\nself.contributors = contributors or set()\nself.disabled = disabled\nself.static_output = static_output\nself.block_type = block_type\nself.webhook_config = webhook_config\nself.execution_stats = {}\nif self.webhook_config:",
              "successors": [
                {
                  "id": 95,
                  "label": "#95\nif isinstance(self.webhook_config, BlockWebhookConfig):",
                  "successors": [
                    {
                      "id": 97,
                      "label": "#97\nif CREDENTIALS_FIELD_NAME not in self.input_schema.model_fields:",
                      "successors": [
                        {
                          "id": 100,
                          "label": "#100\nraise TypeError('credentials field is required on auto-setup webhook blocks')",
                          "successors": []
                        },
                        {
                          "id": 101,
                          "label": "#101\nself.block_type = BlockType.WEBHOOK",
                          "successors": [
                            {
                              "id": 98,
                              "label": "#98\nif self.webhook_config.event_filter_input:",
                              "successors": [
                                {
                                  "id": 103,
                                  "label": "#103\nevent_filter_field = self.input_schema.model_fields[self.webhook_config.\n    event_filter_input]\nif not (isinstance(event_filter_field.annotation, type) and issubclass(",
                                  "successors": [
                                    {
                                      "id": 105,
                                      "label": "#105\nraise NotImplementedError(\n    f'{self.name} has an invalid webhook event selector: field must be a BaseModel and all its fields must be boolean'\n    )",
                                      "successors": []
                                    },
                                    {
                                      "id": 104,
                                      "label": "#104\nif 'payload' not in self.input_schema.model_fields:",
                                      "successors": [
                                        {
                                          "id": 108,
                                          "label": "#108\nraise TypeError(f\"{self.name} is webhook-triggered but has no 'payload' input\")",
                                          "successors": []
                                        },
                                        {
                                          "id": 109,
                                          "label": "#109\nif not app_config.platform_base_url:",
                                          "successors": [
                                            {
                                              "id": 111,
                                              "label": "#111\nself.disabled = True",
                                              "successors": []
                                            }
                                          ]
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "id": 99,
                      "label": "#99\nself.block_type = BlockType.WEBHOOK_MANUAL",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "create",
          "type": "CFG",
          "blocks": [
            {
              "id": 115,
              "label": "#115\nreturn cls()",
              "successors": []
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "run",
          "type": "CFG",
          "blocks": [
            {
              "id": 119,
              "label": "#119\n\"\"\"\n        Run the block with the given input data.\n        Args:\n            input_data: The input data with the structure of input_schema.\n        Returns:\n            A Generator that yields (output_name, output_data).\n            output_name: One of the output name defined in Block's output_schema.\n            output_data: The data for the output_name, matching the defined schema.\n        \"\"\"\npass",
              "successors": []
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "run_once",
          "type": "CFG",
          "blocks": [
            {
              "id": 122,
              "label": "#122\nfor name, data in self.run(input_data, **kwargs):",
              "successors": [
                {
                  "id": 123,
                  "label": "#123\nif name == output:",
                  "successors": [
                    {
                      "id": 125,
                      "label": "#125\nreturn data",
                      "successors": []
                    }
                  ]
                },
                {
                  "id": 124,
                  "label": "#124\nraise ValueError(f'{self.name} did not produce any output for {output}')",
                  "successors": []
                }
              ]
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "merge_stats",
          "type": "CFG",
          "blocks": [
            {
              "id": 131,
              "label": "#131\nfor key, value in stats.items():",
              "successors": [
                {
                  "id": 132,
                  "label": "#132\nif isinstance(value, dict):",
                  "successors": [
                    {
                      "id": 134,
                      "label": "#134\nself.execution_stats.setdefault(key, {}).update(value)",
                      "successors": []
                    },
                    {
                      "id": 136,
                      "label": "#136\nif isinstance(value, (int, float)):",
                      "successors": [
                        {
                          "id": 137,
                          "label": "#137\nself.execution_stats.setdefault(key, 0)\nself.execution_stats[key] += value",
                          "successors": []
                        },
                        {
                          "id": 139,
                          "label": "#139\nif isinstance(value, list):",
                          "successors": [
                            {
                              "id": 140,
                              "label": "#140\nself.execution_stats.setdefault(key, [])\nself.execution_stats[key].extend(value)",
                              "successors": []
                            },
                            {
                              "id": 142,
                              "label": "#142\nself.execution_stats[key] = value",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "id": 133,
                  "label": "#133\nreturn self.execution_stats",
                  "successors": []
                }
              ]
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "name",
          "type": "CFG",
          "blocks": [
            {
              "id": 146,
              "label": "#146\nreturn self.__class__.__name__",
              "successors": []
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "to_dict",
          "type": "CFG",
          "blocks": [
            {
              "id": 150,
              "label": "#150\nreturn {'id': self.id, 'name': self.name, 'inputSchema': self.input_schema.\n    jsonschema(), 'outputSchema': self.output_schema.jsonschema(),\n    'description': self.description, 'categories': [category.dict() for\n    category in self.categories], 'contributors': [contributor.model_dump() for\n    contributor in self.contributors], 'staticOutput': self.static_output,\n    'uiType': self.block_type.value}",
              "successors": []
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "execute",
          "type": "CFG",
          "blocks": [
            {
              "id": 154,
              "label": "#154\nif (error := self.input_schema.validate_data(input_data)):",
              "successors": [
                {
                  "id": 155,
                  "label": "#155\nraise ValueError(f'Unable to execute block with invalid input data: {error}')",
                  "successors": []
                },
                {
                  "id": 156,
                  "label": "#156\nfor output_name, output_data in self.run(self.input_schema(**input_data),",
                  "successors": [
                    {
                      "id": 158,
                      "label": "#158\nif output_name == 'error':",
                      "successors": [
                        {
                          "id": 160,
                          "label": "#160\nraise RuntimeError(output_data)",
                          "successors": []
                        },
                        {
                          "id": 161,
                          "label": "#161\nif self.block_type == BlockType.STANDARD and (error := self.output_schema.",
                          "successors": [
                            {
                              "id": 163,
                              "label": "#163\nraise ValueError(f'Block produced an invalid output data: {error}')",
                              "successors": []
                            },
                            {
                              "id": 164,
                              "label": "#164\nyield output_name, output_data",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "functions": [],
          "classes": []
        }
      ],
      "classes": []
    }
  ]
}