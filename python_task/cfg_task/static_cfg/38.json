{
  "name": "38.py",
  "type": "CFG",
  "blocks": [
    {
      "id": 1,
      "label": "#1\nimport asyncio\nimport logging\nimport uuid\nfrom collections import defaultdict\nfrom datetime import datetime, timezone\nfrom typing import Any, Literal, Optional, Type\nimport prisma\nfrom prisma.models import AgentGraph, AgentGraphExecution, AgentNode, AgentNodeLink\nfrom prisma.types import AgentGraphWhereInput\nfrom pydantic.fields import computed_field\nfrom backend.blocks.agent import AgentExecutorBlock\nfrom backend.blocks.basic import AgentInputBlock, AgentOutputBlock\nfrom backend.util import json\nfrom .block import BlockInput, BlockType, get_block, get_blocks\nfrom .db import BaseDbModel, transaction\nfrom .execution import ExecutionStatus\nfrom .includes import AGENT_GRAPH_INCLUDE, AGENT_NODE_INCLUDE\nfrom .integrations import Webhook\nlogger = logging.getLogger(__name__)\nWebhook.model_rebuild()",
      "successors": []
    }
  ],
  "functions": [
    {
      "name": "get_node",
      "type": "CFG",
      "blocks": [
        {
          "id": 176,
          "label": "#176\nnode = await AgentNode.prisma().find_unique_or_raise(where={'id': node_id},\n    include=AGENT_NODE_INCLUDE)",
          "successors": [
            {
              "id": 177,
              "label": "#177\nreturn NodeModel.from_db(node)",
              "successors": []
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "set_node_webhook",
      "type": "CFG",
      "blocks": [
        {
          "id": 181,
          "label": "#181\nnode = await AgentNode.prisma().update(where={'id': node_id}, data={\n    'Webhook': {'connect': {'id': webhook_id}}} if webhook_id else {\n    'Webhook': {'disconnect': True}}, include=AGENT_NODE_INCLUDE)",
          "successors": [
            {
              "id": 182,
              "label": "#182\nif not node:",
              "successors": [
                {
                  "id": 183,
                  "label": "#183\nraise ValueError(f'Node #{node_id} not found')",
                  "successors": []
                },
                {
                  "id": 184,
                  "label": "#184\nreturn NodeModel.from_db(node)",
                  "successors": []
                }
              ]
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "get_graphs",
      "type": "CFG",
      "blocks": [
        {
          "id": 189,
          "label": "#189\n\"\"\"\n    Retrieves graph metadata objects.\n    Default behaviour is to get all currently active graphs.\n\n    Args:\n        filter_by: An optional filter to either select templates or active graphs.\n        user_id: The ID of the user that owns the graph.\n\n    Returns:\n        list[GraphModel]: A list of objects representing the retrieved graphs.\n    \"\"\"\nwhere_clause: AgentGraphWhereInput = {'userId': user_id}\nif filter_by == 'active':",
          "successors": [
            {
              "id": 190,
              "label": "#190\nwhere_clause['isActive'] = True",
              "successors": [
                {
                  "id": 191,
                  "label": "#191\ngraphs = await AgentGraph.prisma().find_many(where=where_clause, distinct=[\n    'id'], order={'version': 'desc'}, include=AGENT_GRAPH_INCLUDE)",
                  "successors": [
                    {
                      "id": 195,
                      "label": "#195\ngraph_models = []",
                      "successors": [
                        {
                          "id": 196,
                          "label": "#196\nfor graph in graphs:",
                          "successors": [
                            {
                              "id": 197,
                              "label": "#197\ntry:",
                              "successors": [
                                {
                                  "id": 199,
                                  "label": "#199\ngraph_models.append(GraphModel.from_db(graph))",
                                  "successors": []
                                },
                                {
                                  "id": 200,
                                  "label": "#200\nlogger.error(f'Error processing graph {graph.id}: {e}')",
                                  "successors": []
                                }
                              ]
                            },
                            {
                              "id": 198,
                              "label": "#198\nreturn graph_models",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "id": 192,
              "label": "#192\nif filter_by == 'template':",
              "successors": [
                {
                  "id": 193,
                  "label": "#193\nwhere_clause['isTemplate'] = True",
                  "successors": []
                }
              ]
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "get_executions",
      "type": "CFG",
      "blocks": [
        {
          "id": 205,
          "label": "#205\nexecutions = await AgentGraphExecution.prisma().find_many(where={'userId':\n    user_id}, order={'createdAt': 'desc'})",
          "successors": [
            {
              "id": 206,
              "label": "#206\nreturn [GraphExecution.from_db(execution) for execution in executions]",
              "successors": []
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "get_execution",
      "type": "CFG",
      "blocks": [
        {
          "id": 210,
          "label": "#210\nexecution = await AgentGraphExecution.prisma().find_first(where={'id':\n    execution_id, 'userId': user_id})",
          "successors": [
            {
              "id": 211,
              "label": "#211\nreturn GraphExecution.from_db(execution) if execution else None",
              "successors": []
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "get_graph",
      "type": "CFG",
      "blocks": [
        {
          "id": 215,
          "label": "#215\n\"\"\"\n    Retrieves a graph from the DB.\n    Defaults to the version with `is_active` if `version` is not passed,\n    or the latest version with `is_template` if `template=True`.\n\n    Returns `None` if the record is not found.\n    \"\"\"\nwhere_clause: AgentGraphWhereInput = {'id': graph_id}\nif version is not None:",
          "successors": [
            {
              "id": 216,
              "label": "#216\nwhere_clause['version'] = version",
              "successors": [
                {
                  "id": 217,
                  "label": "#217\nif user_id is not None and not template:",
                  "successors": [
                    {
                      "id": 221,
                      "label": "#221\nwhere_clause['userId'] = user_id",
                      "successors": [
                        {
                          "id": 222,
                          "label": "#222\ngraph = await AgentGraph.prisma().find_first(where=where_clause, include=\n    AGENT_GRAPH_INCLUDE, order={'version': 'desc'})",
                          "successors": [
                            {
                              "id": 223,
                              "label": "#223\nreturn GraphModel.from_db(graph, for_export) if graph else None",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "id": 218,
              "label": "#218\nif not template:",
              "successors": [
                {
                  "id": 219,
                  "label": "#219\nwhere_clause['isActive'] = True",
                  "successors": []
                }
              ]
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "set_graph_active_version",
      "type": "CFG",
      "blocks": [
        {
          "id": 227,
          "label": "#227\nupdated_count = await AgentGraph.prisma().update_many(data={'isActive': \n    True}, where={'id': graph_id, 'version': version, 'userId': user_id})",
          "successors": [
            {
              "id": 228,
              "label": "#228\nif updated_count == 0:",
              "successors": [
                {
                  "id": 229,
                  "label": "#229\nraise Exception(f'Graph #{graph_id} v{version} not found or not owned by user')",
                  "successors": []
                },
                {
                  "id": 230,
                  "label": "#230\nawait AgentGraph.prisma().update_many(data={'isActive': False}, where={'id':\n    graph_id, 'version': {'not': version}, 'userId': user_id, 'isActive': True}\n    )",
                  "successors": []
                }
              ]
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "get_graph_all_versions",
      "type": "CFG",
      "blocks": [
        {
          "id": 235,
          "label": "#235\ngraph_versions = await AgentGraph.prisma().find_many(where={'id': graph_id,\n    'userId': user_id}, order={'version': 'desc'}, include=AGENT_GRAPH_INCLUDE)",
          "successors": [
            {
              "id": 236,
              "label": "#236\nif not graph_versions:",
              "successors": [
                {
                  "id": 237,
                  "label": "#237\nreturn []",
                  "successors": []
                },
                {
                  "id": 238,
                  "label": "#238\nreturn [GraphModel.from_db(graph) for graph in graph_versions]",
                  "successors": []
                }
              ]
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "delete_graph",
      "type": "CFG",
      "blocks": [
        {
          "id": 243,
          "label": "#243\nentries_count = await AgentGraph.prisma().delete_many(where={'id': graph_id,\n    'userId': user_id})",
          "successors": [
            {
              "id": 244,
              "label": "#244\nif entries_count:",
              "successors": [
                {
                  "id": 245,
                  "label": "#245\nlogger.info(f'Deleted {entries_count} graph entries for Graph #{graph_id}')",
                  "successors": [
                    {
                      "id": 246,
                      "label": "#246\nreturn entries_count",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "create_graph",
      "type": "CFG",
      "blocks": [
        {
          "id": 250,
          "label": "#250\nasync with transaction() as tx:\n    await __create_graph(tx, graph, user_id)",
          "successors": [
            {
              "id": 251,
              "label": "#251\nawait __create_graph(tx, graph, user_id)",
              "successors": [
                {
                  "id": 252,
                  "label": "#252\nif (created_graph := await get_graph(graph.id, graph.version, graph.",
                  "successors": [
                    {
                      "id": 254,
                      "label": "#254\nreturn created_graph",
                      "successors": []
                    },
                    {
                      "id": 255,
                      "label": "#255\nraise ValueError(f'Created graph {graph.id} v{graph.version} is not in DB')",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "__create_graph",
      "type": "CFG",
      "blocks": [
        {
          "id": 260,
          "label": "#260\nawait AgentGraph.prisma(tx).create(data={'id': graph.id, 'version': graph.\n    version, 'name': graph.name, 'description': graph.description,\n    'isTemplate': graph.is_template, 'isActive': graph.is_active, 'userId':\n    user_id})",
          "successors": [
            {
              "id": 261,
              "label": "#261\nawait asyncio.gather(*[AgentNode.prisma(tx).create({'id': node.id,\n    'agentBlockId': node.block_id, 'agentGraphId': graph.id,\n    'agentGraphVersion': graph.version, 'constantInput': json.dumps(node.\n    input_default), 'metadata': json.dumps(node.metadata)}) for node in\n    graph.nodes])",
              "successors": [
                {
                  "id": 262,
                  "label": "#262\nawait asyncio.gather(*[AgentNodeLink.prisma(tx).create({'id': str(uuid.\n    uuid4()), 'sourceName': link.source_name, 'sinkName': link.sink_name,\n    'agentNodeSourceId': link.source_id, 'agentNodeSinkId': link.sink_id,\n    'isStatic': link.is_static}) for link in graph.links])",
                  "successors": []
                }
              ]
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "make_graph_model",
      "type": "CFG",
      "blocks": [
        {
          "id": 266,
          "label": "#266\n\"\"\"\n    Convert a Graph to a GraphModel, setting graph_id and graph_version on all nodes.\n\n    Args:\n        creatable_graph (Graph): The creatable graph to convert.\n        user_id (str): The ID of the user creating the graph.\n\n    Returns:\n        GraphModel: The converted Graph object.\n    \"\"\"\nreturn GraphModel(**creatable_graph.model_dump(exclude={'nodes'}), user_id=\n    user_id, nodes=[NodeModel(**creatable_node.model_dump(), graph_id=\n    creatable_graph.id, graph_version=creatable_graph.version) for\n    creatable_node in creatable_graph.nodes])",
          "successors": []
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "fix_llm_provider_credentials",
      "type": "CFG",
      "blocks": [
        {
          "id": 270,
          "label": "#270\n\"\"\"Fix node credentials with provider `llm`\"\"\"\nfrom backend.integrations.credentials_store import IntegrationCredentialsStore\nfrom .user import get_user_integrations\nstore = IntegrationCredentialsStore()\nbroken_nodes = await prisma.get_client().query_raw(\n    \"\"\"\n        SELECT    graph.\"userId\"       user_id,\n                  node.id              node_id,\n                  node.\"constantInput\" node_preset_input\n        FROM      platform.\"AgentNode\"  node\n        LEFT JOIN platform.\"AgentGraph\" graph\n        ON        node.\"agentGraphId\" = graph.id\n        WHERE     node.\"constantInput\"::jsonb->'credentials'->>'provider' = 'llm'\n        ORDER BY  graph.\"userId\";\n        \"\"\"\n    )",
          "successors": [
            {
              "id": 271,
              "label": "#271\nlogger.info(f'Fixing LLM credential inputs on {len(broken_nodes)} nodes')\nuser_id: str = ''\nuser_integrations = None",
              "successors": [
                {
                  "id": 272,
                  "label": "#272\nfor node in broken_nodes:",
                  "successors": [
                    {
                      "id": 273,
                      "label": "#273\nif node['user_id'] != user_id:",
                      "successors": [
                        {
                          "id": 275,
                          "label": "#275\nuser_id = node['user_id']\nuser_integrations = await get_user_integrations(user_id)",
                          "successors": [
                            {
                              "id": 276,
                              "label": "#276\nnode_id: str = node['node_id']\nnode_preset_input: dict = json.loads(node['node_preset_input'])\ncredentials_meta: dict = node_preset_input['credentials']\ncredentials = next((c for c in user_integrations.credentials if c.id ==\n    credentials_meta['id']), None)\nif not credentials:",
                              "successors": [
                                {
                                  "id": 283,
                                  "label": "#283\nif credentials.type != 'api_key':",
                                  "successors": [
                                    {
                                      "id": 284,
                                      "label": "#284\nlogger.warning(\n    f\"User {user_id} credentials {credentials.id} with provider 'llm' has invalid type '{credentials.type}'\"\n    )",
                                      "successors": []
                                    },
                                    {
                                      "id": 285,
                                      "label": "#285\napi_key = credentials.api_key.get_secret_value()\nif api_key.startswith('sk-ant-api03-'):",
                                      "successors": [
                                        {
                                          "id": 286,
                                          "label": "#286\ncredentials.provider = credentials_meta['provider'] = 'anthropic'",
                                          "successors": [
                                            {
                                              "id": 287,
                                              "label": "#287\nstore.update_creds(user_id, credentials)\nawait AgentNode.prisma().update(where={'id': node_id}, data={\n    'constantInput': json.dumps(node_preset_input)})",
                                              "successors": []
                                            }
                                          ]
                                        },
                                        {
                                          "id": 288,
                                          "label": "#288\nif api_key.startswith('sk-'):",
                                          "successors": [
                                            {
                                              "id": 289,
                                              "label": "#289\ncredentials.provider = credentials_meta['provider'] = 'openai'",
                                              "successors": []
                                            },
                                            {
                                              "id": 291,
                                              "label": "#291\nif api_key.startswith('gsk_'):",
                                              "successors": [
                                                {
                                                  "id": 292,
                                                  "label": "#292\ncredentials.provider = credentials_meta['provider'] = 'groq'",
                                                  "successors": []
                                                },
                                                {
                                                  "id": 294,
                                                  "label": "#294\nlogger.warning(\n    f'Could not identify provider from key prefix {api_key[:13]}*****')",
                                                  "successors": []
                                                }
                                              ]
                                            }
                                          ]
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        },
                        {
                          "id": 277,
                          "label": "#277\nif not user_integrations:",
                          "successors": [
                            {
                              "id": 278,
                              "label": "#278\nraise RuntimeError(f'Impossible state while processing node {node}')",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "functions": [],
      "classes": []
    }
  ],
  "classes": [
    {
      "name": "Link",
      "type": "CFG",
      "blocks": [
        {
          "id": 3,
          "label": "#3\nsource_id: str\nsink_id: str\nsource_name: str\nsink_name: str\nis_static: bool = False",
          "successors": []
        }
      ],
      "functions": [
        {
          "name": "from_db",
          "type": "CFG",
          "blocks": [
            {
              "id": 5,
              "label": "#5\nreturn Link(id=link.id, source_name=link.sourceName, source_id=link.\n    agentNodeSourceId, sink_name=link.sinkName, sink_id=link.\n    agentNodeSinkId, is_static=link.isStatic)",
              "successors": []
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "__hash__",
          "type": "CFG",
          "blocks": [
            {
              "id": 9,
              "label": "#9\nreturn hash((self.source_id, self.sink_id, self.source_name, self.sink_name))",
              "successors": []
            }
          ],
          "functions": [],
          "classes": []
        }
      ],
      "classes": []
    },
    {
      "name": "Node",
      "type": "CFG",
      "blocks": [
        {
          "id": 14,
          "label": "#14\nblock_id: str\ninput_default: BlockInput = {}\nmetadata: dict[str, Any] = {}\ninput_links: list[Link] = []\noutput_links: list[Link] = []\nwebhook_id: Optional[str] = None",
          "successors": []
        }
      ],
      "functions": [],
      "classes": []
    },
    {
      "name": "NodeModel",
      "type": "CFG",
      "blocks": [
        {
          "id": 17,
          "label": "#17\ngraph_id: str\ngraph_version: int\nwebhook: Optional[Webhook] = None",
          "successors": []
        }
      ],
      "functions": [
        {
          "name": "from_db",
          "type": "CFG",
          "blocks": [
            {
              "id": 19,
              "label": "#19\nif not node.AgentBlock:",
              "successors": [
                {
                  "id": 20,
                  "label": "#20\nraise ValueError(f'Invalid node {node.id}, invalid AgentBlock.')",
                  "successors": []
                },
                {
                  "id": 21,
                  "label": "#21\nobj = NodeModel(id=node.id, block_id=node.AgentBlock.id, input_default=json\n    .loads(node.constantInput, target_type=dict[str, Any]), metadata=json.\n    loads(node.metadata, target_type=dict[str, Any]), graph_id=node.\n    agentGraphId, graph_version=node.agentGraphVersion, webhook_id=node.\n    webhookId, webhook=Webhook.from_db(node.Webhook) if node.Webhook else None)\nobj.input_links = [Link.from_db(link) for link in node.Input or []]\nobj.output_links = [Link.from_db(link) for link in node.Output or []]\nreturn obj",
                  "successors": []
                }
              ]
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "is_triggered_by_event_type",
          "type": "CFG",
          "blocks": [
            {
              "id": 26,
              "label": "#26\nif not (block := get_block(self.block_id)):",
              "successors": [
                {
                  "id": 27,
                  "label": "#27\nraise ValueError(f'Block #{self.block_id} not found for node #{self.id}')",
                  "successors": []
                },
                {
                  "id": 28,
                  "label": "#28\nif not block.webhook_config:",
                  "successors": [
                    {
                      "id": 30,
                      "label": "#30\nraise TypeError(\"This method can't be used on non-webhook blocks\")",
                      "successors": []
                    },
                    {
                      "id": 31,
                      "label": "#31\nif not block.webhook_config.event_filter_input:",
                      "successors": [
                        {
                          "id": 33,
                          "label": "#33\nreturn True",
                          "successors": []
                        },
                        {
                          "id": 34,
                          "label": "#34\nevent_filter = self.input_default.get(block.webhook_config.event_filter_input)\nif not event_filter:",
                          "successors": [
                            {
                              "id": 36,
                              "label": "#36\nraise ValueError(f'Event filter is not configured on node #{self.id}')",
                              "successors": []
                            },
                            {
                              "id": 37,
                              "label": "#37\nreturn event_type in [block.webhook_config.event_format.format(event=k) for\n    k in event_filter if event_filter[k] is True]",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "functions": [],
          "classes": []
        }
      ],
      "classes": []
    },
    {
      "name": "GraphExecution",
      "type": "CFG",
      "blocks": [
        {
          "id": 43,
          "label": "#43\nexecution_id: str\nstarted_at: datetime\nended_at: datetime\nduration: float\ntotal_run_time: float\nstatus: ExecutionStatus\ngraph_id: str\ngraph_version: int",
          "successors": []
        }
      ],
      "functions": [
        {
          "name": "from_db",
          "type": "CFG",
          "blocks": [
            {
              "id": 45,
              "label": "#45\nnow = datetime.now(timezone.utc)\nstart_time = execution.startedAt or execution.createdAt\nend_time = execution.updatedAt or now\nduration = (end_time - start_time).total_seconds()\ntotal_run_time = duration\ntry:",
              "successors": [
                {
                  "id": 46,
                  "label": "#46\nstats = json.loads(execution.stats or '{}', target_type=dict[str, Any])",
                  "successors": [
                    {
                      "id": 48,
                      "label": "#48\nduration = stats.get('walltime', duration)\ntotal_run_time = stats.get('nodes_walltime', total_run_time)\nreturn GraphExecution(id=execution.id, execution_id=execution.id,\n    started_at=start_time, ended_at=end_time, duration=duration,\n    total_run_time=total_run_time, status=ExecutionStatus(execution.\n    executionStatus), graph_id=execution.agentGraphId, graph_version=\n    execution.agentGraphVersion)",
                      "successors": []
                    }
                  ]
                },
                {
                  "id": 47,
                  "label": "#47\nstats = {}",
                  "successors": []
                }
              ]
            }
          ],
          "functions": [],
          "classes": []
        }
      ],
      "classes": []
    },
    {
      "name": "Graph",
      "type": "CFG",
      "blocks": [
        {
          "id": 53,
          "label": "#53\nversion: int = 1\nis_active: bool = True\nis_template: bool = False\nname: str\ndescription: str\nnodes: list[Node] = []\nlinks: list[Link] = []",
          "successors": []
        }
      ],
      "functions": [
        {
          "name": "input_schema",
          "type": "CFG",
          "blocks": [
            {
              "id": 55,
              "label": "#55\nreturn self._generate_schema(AgentInputBlock.Input, [node.input_default for\n    node in self.nodes if (b := get_block(node.block_id)) and b.block_type ==\n    BlockType.INPUT and 'name' in node.input_default])",
              "successors": []
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "output_schema",
          "type": "CFG",
          "blocks": [
            {
              "id": 59,
              "label": "#59\nreturn self._generate_schema(AgentOutputBlock.Input, [node.input_default for\n    node in self.nodes if (b := get_block(node.block_id)) and b.block_type ==\n    BlockType.OUTPUT and 'name' in node.input_default])",
              "successors": []
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "_generate_schema",
          "type": "CFG",
          "blocks": [
            {
              "id": 63,
              "label": "#63\nprops = []",
              "successors": [
                {
                  "id": 64,
                  "label": "#64\nfor p in data:",
                  "successors": [
                    {
                      "id": 65,
                      "label": "#65\ntry:",
                      "successors": [
                        {
                          "id": 67,
                          "label": "#67\nprops.append(type_class(**p))",
                          "successors": []
                        },
                        {
                          "id": 68,
                          "label": "#68\nlogger.warning(f'Invalid {type_class}: {p}, {e}')",
                          "successors": []
                        }
                      ]
                    },
                    {
                      "id": 66,
                      "label": "#66\nreturn {'type': 'object', 'properties': {p.name: {'secret': p.secret,\n    'advanced': p.advanced, 'title': p.title or p.name, **{'description': p\n    .description} if p.description else {}, **{'default': p.value} if p.\n    value is not None else {}} for p in props}, 'required': [p.name for p in\n    props if p.value is None]}",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ],
          "functions": [],
          "classes": []
        }
      ],
      "classes": []
    },
    {
      "name": "GraphModel",
      "type": "CFG",
      "blocks": [
        {
          "id": 74,
          "label": "#74\nuser_id: str\nnodes: list[NodeModel] = []",
          "successors": []
        }
      ],
      "functions": [
        {
          "name": "starting_nodes",
          "type": "CFG",
          "blocks": [
            {
              "id": 76,
              "label": "#76\noutbound_nodes = {link.sink_id for link in self.links}\ninput_nodes = {v.id for v in self.nodes if (b := get_block(v.block_id)) and\n    b.block_type == BlockType.INPUT}\nreturn [node for node in self.nodes if node.id not in outbound_nodes or \n    node.id in input_nodes]",
              "successors": []
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "reassign_ids",
          "type": "CFG",
          "blocks": [
            {
              "id": 80,
              "label": "#80\n\"\"\"\n        Reassigns all IDs in the graph to new UUIDs.\n        This method can be used before storing a new graph to the database.\n        \"\"\"\nid_map = {node.id: str(uuid.uuid4()) for node in self.nodes}\nif reassign_graph_id:",
              "successors": [
                {
                  "id": 81,
                  "label": "#81\nself.id = str(uuid.uuid4())",
                  "successors": [
                    {
                      "id": 82,
                      "label": "#82\nfor node in self.nodes:",
                      "successors": [
                        {
                          "id": 83,
                          "label": "#83\nnode.id = id_map[node.id]",
                          "successors": []
                        },
                        {
                          "id": 84,
                          "label": "#84\nfor link in self.links:",
                          "successors": [
                            {
                              "id": 85,
                              "label": "#85\nlink.source_id = id_map[link.source_id]\nlink.sink_id = id_map[link.sink_id]",
                              "successors": []
                            },
                            {
                              "id": 86,
                              "label": "#86\nfor node in self.nodes:",
                              "successors": [
                                {
                                  "id": 87,
                                  "label": "#87\nif node.block_id != AgentExecutorBlock().id:",
                                  "successors": [
                                    {
                                      "id": 90,
                                      "label": "#90\nnode.input_default['user_id'] = user_id\nnode.input_default.setdefault('data', {})",
                                      "successors": []
                                    }
                                  ]
                                },
                                {
                                  "id": 88,
                                  "label": "#88\nself.validate_graph()",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "validate_graph",
          "type": "CFG",
          "blocks": [
            {
              "id": 93,
              "label": "#93\ninput_links = defaultdict(list)",
              "successors": [
                {
                  "id": 98,
                  "label": "#98\nfor link in self.links:",
                  "successors": [
                    {
                      "id": 99,
                      "label": "#99\ninput_links[link.sink_id].append(link)",
                      "successors": []
                    },
                    {
                      "id": 100,
                      "label": "#100\nfor node in self.nodes:",
                      "successors": [
                        {
                          "id": 101,
                          "label": "#101\nblock = get_block(node.block_id)\nif block is None:",
                          "successors": [
                            {
                              "id": 103,
                              "label": "#103\nraise ValueError(f'Invalid block {node.block_id} for node #{node.id}')",
                              "successors": []
                            },
                            {
                              "id": 104,
                              "label": "#104\nprovided_inputs = set([sanitize(name) for name in node.input_default] + [\n    sanitize(link.sink_name) for link in input_links.get(node.id, [])])",
                              "successors": [
                                {
                                  "id": 106,
                                  "label": "#106\nfor name in block.input_schema.get_required_fields():",
                                  "successors": [
                                    {
                                      "id": 107,
                                      "label": "#107\nif name not in provided_inputs and not (name == 'payload' and block.",
                                      "successors": [
                                        {
                                          "id": 109,
                                          "label": "#109\nraise ValueError(\n    f'Node {block.name} #{node.id} required input missing: `{name}`')",
                                          "successors": []
                                        }
                                      ]
                                    },
                                    {
                                      "id": 108,
                                      "label": "#108\ninput_schema = block.input_schema.model_fields\nrequired_fields = block.input_schema.get_required_fields()",
                                      "successors": [
                                        {
                                          "id": 116,
                                          "label": "#116\nfor field_name, field_info in input_schema.items():",
                                          "successors": [
                                            {
                                              "id": 117,
                                              "label": "#117\njson_schema_extra = field_info.json_schema_extra or {}\ndependencies = json_schema_extra.get('depends_on', [])\nif not for_run or not dependencies:",
                                              "successors": [
                                                {
                                                  "id": 120,
                                                  "label": "#120\nfield_has_value = has_value(field_name)\nfield_is_required = field_name in required_fields\nmissing_deps = [dep for dep in dependencies if not has_value(dep)]\nif missing_deps and (field_has_value or field_is_required):",
                                                  "successors": [
                                                    {
                                                      "id": 121,
                                                      "label": "#121\nraise ValueError(\n    f\"Node {block.name} #{node.id}: Field `{field_name}` requires [{', '.join(missing_deps)}] to be set\"\n    )",
                                                      "successors": []
                                                    }
                                                  ]
                                                }
                                              ]
                                            }
                                          ]
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        },
                        {
                          "id": 102,
                          "label": "#102\nnode_map = {v.id: v for v in self.nodes}",
                          "successors": [
                            {
                              "id": 128,
                              "label": "#128\nfor link in self.links:",
                              "successors": [
                                {
                                  "id": 129,
                                  "label": "#129\nsource = link.source_id, link.source_name\nsink = link.sink_id, link.sink_name\nsuffix = f'Link {source} <-> {sink}'",
                                  "successors": [
                                    {
                                      "id": 131,
                                      "label": "#131\nfor i, (node_id, name) in enumerate([source, sink]):",
                                      "successors": [
                                        {
                                          "id": 132,
                                          "label": "#132\nnode = node_map.get(node_id)\nif not node:",
                                          "successors": [
                                            {
                                              "id": 134,
                                              "label": "#134\nraise ValueError(\n    f'{suffix}, {node_id} is invalid node id, available nodes: {node_map.keys()}'\n    )",
                                              "successors": []
                                            },
                                            {
                                              "id": 135,
                                              "label": "#135\nblock = get_block(node.block_id)\nif not block:",
                                              "successors": [
                                                {
                                                  "id": 137,
                                                  "label": "#137\nblocks = {v().id: v().name for v in get_blocks().values()}\nraise ValueError(\n    f'{suffix}, {node.block_id} is invalid block id, available blocks: {blocks}'\n    )",
                                                  "successors": []
                                                },
                                                {
                                                  "id": 138,
                                                  "label": "#138\nsanitized_name = sanitize(name)\nvals = node.input_default\nif i == 0:",
                                                  "successors": [
                                                    {
                                                      "id": 140,
                                                      "label": "#140\nfields = block.output_schema.get_fields(\n    ) if block.block_type != BlockType.AGENT else vals.get('output_schema', {}\n    ).get('properties', {}).keys()",
                                                      "successors": [
                                                        {
                                                          "id": 141,
                                                          "label": "#141\nif sanitized_name not in fields:",
                                                          "successors": [
                                                            {
                                                              "id": 143,
                                                              "label": "#143\nfields_msg = f'Allowed fields: {fields}'\nraise ValueError(f'{suffix}, `{name}` invalid, {fields_msg}')",
                                                              "successors": []
                                                            }
                                                          ]
                                                        }
                                                      ]
                                                    },
                                                    {
                                                      "id": 142,
                                                      "label": "#142\nfields = block.input_schema.get_fields(\n    ) if block.block_type != BlockType.AGENT else vals.get('input_schema', {}\n    ).get('properties', {}).keys()",
                                                      "successors": []
                                                    }
                                                  ]
                                                }
                                              ]
                                            }
                                          ]
                                        },
                                        {
                                          "id": 133,
                                          "label": "#133\nif is_static_output_block(link.source_id):",
                                          "successors": [
                                            {
                                              "id": 146,
                                              "label": "#146\nlink.is_static = True",
                                              "successors": []
                                            }
                                          ]
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "functions": [
            {
              "name": "sanitize",
              "type": "CFG",
              "blocks": [
                {
                  "id": 95,
                  "label": "#95\nreturn name.split('_#_')[0].split('_@_')[0].split('_$_')[0]",
                  "successors": []
                }
              ],
              "functions": [],
              "classes": []
            },
            {
              "name": "has_value",
              "type": "CFG",
              "blocks": [
                {
                  "id": 113,
                  "label": "#113\nreturn node is not None and name in node.input_default and node.input_default[\n    name] is not None and str(node.input_default[name]).strip(\n    ) != '' or name in input_schema and input_schema[name].default is not None",
                  "successors": []
                }
              ],
              "functions": [],
              "classes": []
            },
            {
              "name": "is_static_output_block",
              "type": "CFG",
              "blocks": [
                {
                  "id": 125,
                  "label": "#125\nbid = node_map[nid].block_id\nb = get_block(bid)\nreturn b.static_output if b else False",
                  "successors": []
                }
              ],
              "functions": [],
              "classes": []
            }
          ],
          "classes": []
        },
        {
          "name": "from_db",
          "type": "CFG",
          "blocks": [
            {
              "id": 150,
              "label": "#150\nreturn GraphModel(id=graph.id, user_id=graph.userId, version=graph.version,\n    is_active=graph.isActive, is_template=graph.isTemplate, name=graph.name or\n    '', description=graph.description or '', nodes=[NodeModel.from_db(\n    GraphModel._process_node(node, for_export)) for node in graph.\n    AgentNodes or []], links=list({Link.from_db(link) for node in graph.\n    AgentNodes or [] for link in (node.Input or []) + (node.Output or [])}))",
              "successors": []
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "_process_node",
          "type": "CFG",
          "blocks": [
            {
              "id": 154,
              "label": "#154\nif for_export:",
              "successors": [
                {
                  "id": 155,
                  "label": "#155\nif node.constantInput:",
                  "successors": [
                    {
                      "id": 157,
                      "label": "#157\nconstant_input = json.loads(node.constantInput, target_type=dict[str, Any])\nconstant_input = GraphModel._hide_node_input_credentials(constant_input)\nnode.constantInput = json.dumps(constant_input)",
                      "successors": [
                        {
                          "id": 158,
                          "label": "#158\nnode.webhookId = None\nnode.Webhook = None",
                          "successors": [
                            {
                              "id": 156,
                              "label": "#156\nreturn node",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "functions": [],
          "classes": []
        },
        {
          "name": "_hide_node_input_credentials",
          "type": "CFG",
          "blocks": [
            {
              "id": 162,
              "label": "#162\nsensitive_keys = ['credentials', 'api_key', 'password', 'token', 'secret']\nresult = {}",
              "successors": [
                {
                  "id": 163,
                  "label": "#163\nfor key, value in input_data.items():",
                  "successors": [
                    {
                      "id": 164,
                      "label": "#164\nif isinstance(value, dict):",
                      "successors": [
                        {
                          "id": 166,
                          "label": "#166\nresult[key] = GraphModel._hide_node_input_credentials(value)",
                          "successors": []
                        },
                        {
                          "id": 168,
                          "label": "#168\nif isinstance(value, str) and any(sensitive_key in key.lower() for",
                          "successors": [
                            {
                              "id": 171,
                              "label": "#171\nresult[key] = value",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "id": 165,
                      "label": "#165\nreturn result",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ],
          "functions": [],
          "classes": []
        }
      ],
      "classes": []
    }
  ]
}