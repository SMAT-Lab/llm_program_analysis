{"source_code": "import UIAbility from '@ohos.app.ability.UIAbility';\nimport hilog from '@ohos.hilog';\nimport window from '@ohos.window';\n\nexport default class EntryAbility extends UIAbility {\n  onCreate(want, launchParam) {\n    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onCreate');\n  }\n\n  onDestroy() {\n    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onDestroy');\n  }\n\n  onWindowStageCreate(windowStage: window.WindowStage) {\n    // Main window is created, set main page for this ability\n    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageCreate');\n\n    windowStage.loadContent('pages/Index', (err, data) => {\n      if (err.code) {\n        hilog.error(0x0000, 'testTag', 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');\n        return;\n      }\n      hilog.info(0x0000, 'testTag', 'Succeeded in loading the content. Data: %{public}s', JSON.stringify(data) ?? '');\n    });\n  }\n\n  onWindowStageDestroy() {\n    // Main window is destroyed, release UI related resources\n    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageDestroy');\n  }\n\n  onForeground() {\n    // Ability has brought to foreground\n    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onForeground');\n  }\n\n  onBackground() {\n    // Ability has back to background\n    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onBackground');\n  }\n}\n", "llm_cg": {"EntryAbility.onCreate(want, launchParam)": [], "EntryAbility.onDestroy()": [], "EntryAbility.onWindowStageCreate(window.WindowStage)": ["window.WindowStage.loadContent(pages/Index, (err, data))"], "EntryAbility.onWindowStageDestroy()": [], "EntryAbility.onForeground()": [], "EntryAbility.onBackground()": []}, "static_cg": {"@test/0.ts: EntryAbility.onWindowStageCreate(window.WindowStage)": ["@test/0.ts: EntryAbility.%AM0$onWindowStageCreate(unknown, unknown)"]}}
{"source_code": "/*\n * Copyright (C) 2023 Huawei Device Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// 构造单例对象\nexport class GlobalContext {\n  private constructor() {}\n  private static instance: GlobalContext;\n  private _objects = new Map<string,Object>();\n\n  public static getContext(): GlobalContext {\n    if (!GlobalContext.instance) {\n      GlobalContext.instance = new GlobalContext();\n    }\n    return GlobalContext.instance;\n  }\n\n  getObject(value: string):Object {\n    return this._objects.get(value);\n  }\n\n  setObject(key: string, objectClass: Object): void {\n    this._objects.set(key, objectClass);\n  }\n\n}", "llm_cg": {"GlobalContext.getContext()": ["GlobalContext.%AM0$GlobalContext()"], "GlobalContext.getObject(value: string)": [], "GlobalContext.setObject(key: string, objectClass: Object)": []}, "static_cg": {"@test/1.ts: GlobalContext.[static]getContext()": ["@test/1.ts: GlobalContext.constructor()"]}}
{"source_code": "/*\n * Copyright (c) 2022 Huawei Device Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport UIAbility from '@ohos.app.ability.UIAbility';\nimport hilog from '@ohos.hilog';\nimport window from '@ohos.window';\nimport { GlobalContext } from './GlobalContext'\n\nexport default class EntryAbility extends UIAbility {\n\n    onCreate(want, launchParam) {\n        hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onCreate');\n    }\n\n    onDestroy() {\n        hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onDestroy');\n    }\n\n    onWindowStageCreate(windowStage: window.WindowStage) {\n        // Main window is created, set main page for this ability\n        hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageCreate');\n        GlobalContext.getContext().setObject(\"context\", this.context);\n        GlobalContext.getContext().setObject(\"filesPath\", this.context.filesDir);\n        windowStage.loadContent('pages/Index', (err, data) => {\n            if (err.code) {\n                hilog.error(0x0000, 'testTag', 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');\n                return;\n            }\n            hilog.info(0x0000, 'testTag', 'Succeeded in loading the content. Data: %{public}s', JSON.stringify(data) ?? '');\n        });\n    }\n\n    onWindowStageDestroy() {\n        // Main window is destroyed, release UI related resources\n        hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageDestroy');\n    }\n\n}\n", "llm_cg": {"EntryAbility.onCreate(want, launchParam)": [], "EntryAbility.onDestroy()": [], "EntryAbility.onWindowStageCreate(window.WindowStage)": ["GlobalContext.getContext()", "GlobalContext.getContext().setObject(\"context\", this.context)", "GlobalContext.getContext().setObject(\"filesPath\", this.context.filesDir)", "windowStage.loadContent('pages/Index', (err, data) => {})"], "EntryAbility.onWindowStageDestroy()": []}, "static_cg": {"@test/2.ts: EntryAbility.onWindowStageCreate(window.WindowStage)": ["@test/2.ts: EntryAbility.%AM0$onWindowStageCreate(unknown, unknown)"]}}
{"source_code": "/*\n * Copyright (C) 2023 Huawei Device Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport common from '@ohos.app.ability.common'\nimport Pop3Command, { Pop3LoginBean } from '@ohos/node-pop3'\n\nexport default class GlobalObj {\n  private CONTEXT_STR: string = 'getContext';\n  private CLIENT_STR: string = 'getClient';\n  private static instance: GlobalObj;\n  private _objects = new Map<string, Object | null>();\n\n  private constructor() {\n\n  }\n\n  public static getInstance(): GlobalObj {\n    if (!GlobalObj.instance) {\n      GlobalObj.instance = new GlobalObj()\n    }\n    return GlobalObj.instance;\n  }\n\n  getContext(): common.UIAbilityContext | null {\n    return this._objects?.get(this.CONTEXT_STR) ? this._objects?.get(this.CONTEXT_STR) as common.UIAbilityContext : null\n  }\n\n  setContext(objectClass: common.UIAbilityContext): void {\n    this._objects?.set(this.CONTEXT_STR, objectClass)\n  }\n\n  getClient(): Pop3Command | null {\n    return this._objects?.get(this.CLIENT_STR) ? this._objects?.get(this.CLIENT_STR) as Pop3Command : null\n  }\n\n  setClient(objectClass: Pop3Command | null): void {\n    this._objects?.set(this.CLIENT_STR, objectClass)\n  }\n}", "llm_cg": {"GlobalObj.getInstance()": ["GlobalObj.%AM0$GlobalObj()"], "GlobalObj.getContext()": [], "GlobalObj.setContext(common.UIAbilityContext)": [], "GlobalObj.getClient()": [], "GlobalObj.setClient(Pop3Command | null)": []}, "static_cg": {"@test/3.ts: GlobalObj.[static]getInstance()": ["@test/3.ts: GlobalObj.constructor()"]}}
{"source_code": "/*\n * Copyright (C) 2023 Huawei Device Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport default class MsgBean {\n  private index: number;\n  private size: number;\n  private subject: string;\n  private from: string;\n  private to: string;\n  private cc: string;\n  private bcc: string;\n  private content: string;\n  private attachment: Array<object>;\n\n  constructor() {\n  }\n\n  public setIndex(index: number) {\n    this.index = index;\n  }\n\n  public setSize(size: number) {\n    this.size = size;\n  }\n\n  public setSubject(subject: string) {\n    this.subject = subject;\n  }\n\n  public setFrom(from: string) {\n    this.from = from;\n  }\n\n  public setTo(to: string) {\n    this.to = to;\n  }\n\n  public setCc(cc: string) {\n    this.cc = cc;\n  }\n\n  public setBcc(bcc: string) {\n    this.bcc = bcc;\n  }\n\n  public setContent(content: string) {\n    this.content = content;\n  }\n\n  public setAttachment(attachment: Array<object>) {\n    this.attachment = attachment;\n  }\n\n  public getIndex(): number {\n    return this.index;\n  }\n\n  public getSize(): number {\n    return this.size;\n  }\n\n  public getSubject(): string {\n    return this.subject;\n  }\n\n  public getFrom(): string {\n    return this.from;\n  }\n\n  public getTo(): string {\n    return this.to;\n  }\n\n  public getCc(): string {\n    return this.cc;\n  }\n\n  public getBcc(): string {\n    return this.bcc;\n  }\n\n  public getContent(): string {\n    return this.content;\n  }\n\n  public getAttachment(): Array<object> {\n    return this.attachment;\n  }\n}", "llm_cg": {"MsgBean.setIndex(index: number)": [], "MsgBean.setSize(size: number)": [], "MsgBean.setSubject(subject: string)": [], "MsgBean.setFrom(from: string)": [], "MsgBean.setTo(to: string)": [], "MsgBean.setCc(cc: string)": [], "MsgBean.setBcc(bcc: string)": [], "MsgBean.setContent(content: string)": [], "MsgBean.setAttachment(attachment: Array<object>)": [], "MsgBean.getIndex()": [], "MsgBean.getSize()": [], "MsgBean.getSubject()": [], "MsgBean.getFrom()": [], "MsgBean.getTo()": [], "MsgBean.getCc()": [], "MsgBean.getBcc()": [], "MsgBean.getContent()": [], "MsgBean.getAttachment()": []}, "static_cg": {}}
{"source_code": "/*\n * Copyright (c) 2024 Huawei Device Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport interface CameraConfig {\n  mirrorBol: boolean, // 镜像使能\n  videoStabilizationMode: number, // 视频防抖\n  exposureMode: number, // 曝光模式\n  focusMode: number, // 对焦模式\n  photoQuality: number, // 拍照质量\n  locationBol: boolean, // 显示地理位置\n  photoFormat: number, // 照片格式\n  photoOrientation: number, // 照片方向\n  photoResolution: number, // 照片分辨率\n  videoResolution: number, // 照片分辨率\n  videoFrame: number, // 录像帧率\n  referenceLineBol: boolean, // 分割线\n  hdrPhotoBol: boolean, // HDR 拍摄\n  hdrVideoBol: boolean, // HDR 录制\n}", "llm_cg": {"CameraConfig": []}, "static_cg": {}}
{"source_code": "/*\n * Copyright (c) 2023 Huawei Device Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport class Constants {\n  // aspect ratio: width/height\n  static readonly MIN_ASPECT_RATIO = 4 / 3;\n  static readonly MAX_ASPECT_RATIO = 16 / 9;\n\n  static readonly VIDEO_MAX_WIDTH = 2048;\n  static readonly PHOTO_MAX_WIDTH = 2048;\n  static readonly SURFACE_BOTTOM_MARGIN = 50;\n\n  // device type\n  static readonly TABLET = 'tablet';\n  static readonly DEFAULT = 'default';\n  static readonly PHONE = 'phone';\n\n  // video frame\n  static readonly VIDEO_FRAME_60 = 60;\n  static readonly VIDEO_FRAME_30 = 30;\n  static readonly VIDEO_FRAME_15 = 15;\n}\n\n", "llm_cg": {"Constants.MIN_ASPECT_RATIO": [], "Constants.MAX_ASPECT_RATIO": [], "Constants.VIDEO_MAX_WIDTH": [], "Constants.PHOTO_MAX_WIDTH": [], "Constants.SURFACE_BOTTOM_MARGIN": [], "Constants.TABLET": [], "Constants.DEFAULT": [], "Constants.PHONE": [], "Constants.VIDEO_FRAME_60": [], "Constants.VIDEO_FRAME_30": [], "Constants.VIDEO_FRAME_15": []}, "static_cg": {}}
{"source_code": "/*\n * Copyright (c) 2024 Huawei Device Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport display from '@ohos.display';\nimport type common from '@ohos.app.ability.common';\nimport type Want from '@ohos.app.ability.Want';\nimport type window from '@ohos.window';\nimport type { PromptAction } from '@ohos.arkui.UIContext';\n\nconst TAG: string = 'GlobalContext';\n\nexport class GlobalContext {\n\n  private constructor() {\n  }\n\n  private static instance: GlobalContext;\n  private _objects = new Map<string, Object>();\n  private mDisplay: display.Display | undefined = undefined;\n  private mCutoutInfo: display.CutoutInfo | undefined = undefined;\n  private cameraAbilityContext: common.UIAbilityContext;\n  private cameraAbilityStageContext: common.AbilityStageContext;\n  private cameraAbilityWant: Want;\n  private cameraNewWant: Want;\n  private windowStage: window.WindowStage;\n  private cameraWinClass: window.Window;\n  private cameraSettingContext: common.UIAbilityContext;\n  private cameraWindowStageEvent: window.WindowStageEventType;\n  private xComponentController: XComponentController;\n  private promptAction: PromptAction;\n\n  public static get(): GlobalContext {\n    if (!Boolean(GlobalContext.instance).valueOf()) {\n      GlobalContext.instance = new GlobalContext();\n    }\n    return GlobalContext.instance;\n  }\n\n  getObject(value: string): Object {\n    return this._objects.get(value);\n  }\n\n  getT<T>(value: string): T {\n    return this._objects.get(value) as T;\n  }\n\n  setObject(key: string, objectClass: Object): void {\n    this._objects.set(key, objectClass);\n  }\n\n  apply(value: string): void {\n    const func = this._objects.get(value);\n    if (func) {\n      (func as Function)();\n    }\n  }\n\n  // 显示实例，在 phone设备上用 display获得的长宽与 State变量中 windowSize一致。\n  public getDisplayInfo(): display.Display {\n    if (!this.mDisplay) {\n      this.mDisplay = display.getDefaultDisplaySync();\n    }\n    return this.mDisplay;\n  }\n\n  public async getCutoutInfo(): Promise<display.CutoutInfo> {\n    if (!this.mCutoutInfo) {\n      this.mCutoutInfo = await this.getDisplayInfo().getCutoutInfo();\n    }\n    return this.mCutoutInfo;\n  }\n\n  public getCameraAbilityContext(): common.UIAbilityContext {\n    return this.cameraAbilityContext;\n  }\n\n  public setCameraAbilityContext(context: common.UIAbilityContext): void {\n    this.cameraAbilityContext = context;\n  }\n\n  public getCameraAbilityWant(): Want {\n    return this.cameraAbilityWant;\n  }\n\n  public setCameraAbilityWant(want: Want): void {\n    this.cameraAbilityWant = want;\n  }\n\n  public getCameraNewWant(): Want {\n    return this.cameraNewWant;\n  }\n\n  public setCameraNewWant(want: Want): void {\n    this.cameraNewWant = want;\n  }\n\n  public getWindowStage(): window.WindowStage {\n    return this.windowStage;\n  }\n\n  public setWindowStage(stage: window.WindowStage): void {\n    this.windowStage = stage;\n  }\n\n  public getCameraAbilityStageContext(): common.AbilityStageContext {\n    return this.cameraAbilityStageContext;\n  }\n\n  public setCameraAbilityStageContext(context: common.AbilityStageContext): void {\n    this.cameraAbilityStageContext = context;\n  }\n\n  public getCameraWinClass(): window.Window {\n    return this.cameraWinClass;\n  }\n\n  public setCameraWinClass(win: window.Window): void {\n    this.cameraWinClass = win;\n  }\n\n  public getCameraSettingContext(): common.UIAbilityContext {\n    return this.cameraSettingContext;\n  }\n\n  public setCameraSettingContext(context: common.UIAbilityContext): void {\n    this.cameraSettingContext = context;\n  }\n\n  public setPromptAction(promptAction: PromptAction): void {\n    this.promptAction = promptAction;\n  }\n\n  public getPromptAction(): PromptAction {\n    return this.promptAction;\n  }\n\n  public getCameraWindowStageEvent(): window.WindowStageEventType {\n    return this.cameraWindowStageEvent;\n  }\n\n  public setCameraWindowStageEvent(event: window.WindowStageEventType): void {\n    this.cameraWindowStageEvent = event;\n  }\n\n  public getXComponentController(): XComponentController {\n    return this.xComponentController;\n  }\n\n  public setXComponentController(controller): void {\n    this.xComponentController = controller;\n  }\n}", "llm_cg": {"GlobalContext.get()": ["GlobalContext.%AM0$GlobalContext()"], "GlobalContext.getDisplayInfo()": ["display.%AM1$getDefaultDisplaySync()"], "GlobalContext.getCutoutInfo()": ["GlobalContext.%AM2$getDisplayInfo()", "display.Display.%AM3$getCutoutInfo()"], "GlobalContext.apply(value: string)": ["Map.%AM4$get(value: string)", "Function.%AM5$call()"]}, "static_cg": {"@test/7.ts: GlobalContext.getCutoutInfo()": ["@test/7.ts: GlobalContext.getDisplayInfo()"], "@test/7.ts: GlobalContext.[static]get()": ["@test/7.ts: GlobalContext.constructor()"]}}
{"source_code": "/*\n * Copyright (c) 2023 Huawei Device Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Constants } from '../common/Constants';\n\nexport default class DisplayCalculator {\n  public static calcSurfaceDisplaySize(screenWidth: number, screenHeight: number, defaultAspectRatio: number): {\n    width: number,\n    height: number\n  } {\n    const displaySize = {\n      width: 1920, height: 1080\n    };\n    if (AppStorage.get<string>('deviceType') === Constants.TABLET || screenWidth > screenHeight) {\n      if (screenWidth / screenHeight > defaultAspectRatio) {\n        displaySize.width = Math.floor(screenHeight * defaultAspectRatio);\n        displaySize.height = Math.floor(screenHeight);\n      } else {\n        displaySize.width = Math.floor(screenWidth);\n        displaySize.height = Math.floor(screenWidth / defaultAspectRatio);\n      }\n    } else {\n      if (screenWidth / screenHeight > defaultAspectRatio) {\n        displaySize.width = Math.floor(screenHeight / defaultAspectRatio);\n        displaySize.height = Math.floor(screenHeight);\n      } else {\n        displaySize.width = Math.floor(screenWidth);\n        displaySize.height = Math.floor(screenWidth * defaultAspectRatio);\n      }\n    }\n    return displaySize;\n  }\n}", "llm_cg": {"DisplayCalculator.calcSurfaceDisplaySize(number, number, number)": []}, "static_cg": {}}
{"source_code": "/*\n * Copyright (c) 2023-2024 Huawei Device Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type window from '@ohos.window';\nimport deviceInfo from '@ohos.deviceInfo';\nimport abilityAccessCtrl from '@ohos.abilityAccessCtrl';\nimport type Want from '@ohos.app.ability.Want';\nimport type AbilityConstant from '@ohos.app.ability.AbilityConstant';\nimport { BusinessError } from '@ohos.base';\nimport Logger from '../model/Logger';\nimport { Constants } from '../common/Constants';\nimport UIAbility from '@ohos.app.ability.UIAbility';\nimport { GlobalContext } from '../common/GlobalContext';\n\nconst TAG: string = 'EntryAbility';\n\nexport default class EntryAbility extends UIAbility {\n\n  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {\n    Logger.info(TAG, 'Ability onCreate');\n    Logger.debug(TAG, `want param: ${JSON.stringify(want)}`);\n    Logger.debug(TAG, `launchParam: ${JSON.stringify(launchParam)}`);\n    GlobalContext.get().setCameraSettingContext(this.context);\n    GlobalContext.get().getCameraSettingContext();\n  }\n\n  onDestroy(): void {\n    Logger.info(TAG, 'Ability onDestroy');\n  }\n\n  onWindowStageCreate(windowStage: window.WindowStage): void {\n    // Main window is created, set main page for this ability\n    Logger.info(TAG, 'Ability onWindowStageCreate');\n    windowStage.loadContent('pages/Index', (): void => {\n      Logger.info(TAG, 'Succeeded in loading the content.');\n    });\n    this.requestPermissionsFn();\n    AppStorage.setOrCreate<string>('deviceType', deviceInfo.deviceType);\n    windowStage.getMainWindow().then((win: window.Window): void => {\n      GlobalContext.get().setPromptAction(win.getUIContext().getPromptAction());\n      Logger.debug(TAG, 'Succeeded get promptAction.');\n      if (deviceInfo.deviceType === Constants.TABLET) {\n        win.setWindowLayoutFullScreen(true).then((): void => {\n          win.setWindowSystemBarEnable(['navigation']).then((): void => {\n          });\n        });\n        win.setWindowSystemBarProperties({\n          navigationBarColor: '#00000000',\n          navigationBarContentColor: '#B3B3B3'\n        })\n          .then((): void => {\n          });\n      }\n    });\n  }\n\n  /**\n   * 获取权限\n   */\n  requestPermissionsFn(): void {\n    let atManager = abilityAccessCtrl.createAtManager();\n    atManager.requestPermissionsFromUser(this.context, [\n      'ohos.permission.CAMERA',\n      'ohos.permission.MICROPHONE',\n      'ohos.permission.READ_MEDIA',\n      'ohos.permission.WRITE_MEDIA',\n      'ohos.permission.READ_IMAGEVIDEO',\n      'ohos.permission.WRITE_IMAGEVIDEO'\n    ]).then((): void => {\n      AppStorage.setOrCreate<boolean>('isShow', true);\n      Logger.info(TAG, 'request Permissions success!');\n    }).catch((error: BusinessError): void => {\n      Logger.info(TAG, `requestPermissionsFromUser call Failed! error: ${error.code}`);\n    });\n  }\n}\n", "llm_cg": {"EntryAbility.onCreate(Want, AbilityConstant.LaunchParam)": ["Logger.info(string, string)", "Logger.debug(string, string)", "Logger.debug(string, string)", "GlobalContext.get().setCameraSettingContext(unknown)", "GlobalContext.get().getCameraSettingContext()"], "EntryAbility.onDestroy()": ["Logger.info(string, string)"], "EntryAbility.onWindowStageCreate(window.WindowStage)": ["Logger.info(string, string)", "windowStage.loadContent(string, Function)", "EntryAbility.requestPermissionsFn()", "AppStorage.setOrCreate<string>(string, string)", "windowStage.getMainWindow()", "GlobalContext.get().setPromptAction(unknown)", "Logger.debug(string, string)", "window.Window.setWindowLayoutFullScreen(boolean)", "window.Window.setWindowSystemBarEnable(string[])", "window.Window.setWindowSystemBarProperties(unknown)"], "EntryAbility.requestPermissionsFn()": ["abilityAccessCtrl.createAtManager()", "AtManager.requestPermissionsFromUser(unknown, string[])", "AppStorage.setOrCreate<boolean>(string, boolean)", "Logger.info(string, string)", "Logger.info(string, string)"]}, "static_cg": {"@test/9.ts: EntryAbility.onWindowStageCreate(window.WindowStage)": ["@test/9.ts: EntryAbility.%AM0$onWindowStageCreate()", "@test/9.ts: EntryAbility.requestPermissionsFn()", "@test/9.ts: EntryAbility.%AM1$onWindowStageCreate(window.Window)"], "@test/9.ts: EntryAbility.requestPermissionsFn()": ["@test/9.ts: EntryAbility.%AM6$requestPermissionsFn()", "@test/9.ts: EntryAbility.%AM5$requestPermissionsFn(BusinessError)"], "@test/9.ts: EntryAbility.%AM2$%AM1$onWindowStageCreate()": ["@test/9.ts: EntryAbility.%AM3$%AM2$%AM1$onWindowStageCreate()"], "@test/9.ts: EntryAbility.%AM1$onWindowStageCreate(window.Window)": ["@test/9.ts: EntryAbility.%AM2$%AM1$onWindowStageCreate()", "@test/9.ts: EntryAbility.%AM4$%AM1$onWindowStageCreate()"]}}
{"source_code": "/*\n * Copyright (c) 2023 Huawei Device Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport hiLog from '@ohos.hilog';\n\nconst TAG = 'cameraSample';\n\nclass Logger {\n  private domain: number;\n  private prefix: string;\n  private format: string = '%{public}s, %{public}s';\n\n  constructor(prefix: string) {\n    this.prefix = prefix;\n    this.domain = 0xFF00;\n  }\n\n  debug(...args: any[]): void {\n    hiLog.debug(this.domain, this.prefix, this.format, args);\n  }\n\n  info(...args: any[]): void {\n    hiLog.info(this.domain, this.prefix, this.format, args);\n  }\n\n  warn(...args: any[]): void {\n    hiLog.warn(this.domain, this.prefix, this.format, args);\n  }\n\n  error(...args: any[]): void {\n    hiLog.error(this.domain, this.prefix, this.format, args);\n  }\n}\n\nexport default new Logger(TAG);", "llm_cg": {"Logger.debug(...args: any[])": ["hiLog.debug(number, string, string, any[])"], "Logger.info(...args: any[])": ["hiLog.info(number, string, string, any[])"], "Logger.warn(...args: any[])": ["hiLog.warn(number, string, string, any[])"], "Logger.error(...args: any[])": ["hiLog.error(number, string, string, any[])"]}, "static_cg": {"@test/10.ts: %dflt.[static]%dflt()": ["@test/10.ts: Logger.constructor(string)"]}}
{"source_code": "/*\n * Copyright (c) 2023 Huawei Device Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport class Setting {\n  private mirrorBol: boolean; // 镜像使能 -> 关闭\n  private videoStabilizationMode: number; // 视频防抖 -> 关闭\n  private exposureMode: number; // 曝光模式 -> 自动\n  private focusMode: number; // 对焦模式 -> 自动\n  private photoQuality: number; // 拍照质量 -> 中\n  private locationBol: boolean; // 显示地理位置 -> 关闭\n  private photoFormat: number; // 照片格式 -> JPG\n  private photoOrientation: number; // 照片方向 -> 0\n  private photoResolution: number; // 照片分辨率 -> 1920 * 1080\n  private videoResolution: number; // 照片分辨率 -> 1920 * 1080\n  private videoFrame: number; // 录像帧率 -> 15\n  private dividerBol: boolean; // 分割线 -> 关闭\n}\n", "llm_cg": {"Setting": []}, "static_cg": {}}
{"source_code": "/*\n * Copyright (c) 2023-2024 Huawei Device Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// @ts-nocheck\nimport camera from '@ohos.multimedia.camera';\nimport image from '@ohos.multimedia.image';\nimport media from '@ohos.multimedia.media';\nimport { BusinessError } from '@ohos.base';\nimport Logger from '../model/Logger';\nimport { Constants } from '../common/Constants';\nimport photoAccessHelper from '@ohos.file.photoAccessHelper';\nimport fs from '@ohos.file.fs';\nimport { GlobalContext } from '../common/GlobalContext';\nimport type { CameraConfig } from '../common/CameraConfig';\nimport colorSpaceManager from '@ohos.graphics.colorSpaceManager';\n\nconst cameraSize = {\n  width: 1280,\n  height: 720\n};\n\nenum PhotoOrientation {\n  ORIENTATION_0 = 0,\n  ORIENTATION_1,\n  ORIENTATION_2,\n  ORIENTATION_3\n}\n\nenum CaptureMode {\n  OLD_CAPTURE = 0,\n  NEW_CAPTURE,\n  NEW_DEFERRED_PHOTO\n}\n\nenum CameraMode {\n  NORMAL = 0,\n  VIDEO,\n  PORTRAIT,\n  SUPER_STAB,\n  NIGHT,\n  MACRO_PHOTO = 8,\n  MACRO_VIDEO = 9\n}\n\nfunction mockInterface(): void {\n  if (!camera.SceneFeatureType) {\n    camera.SceneFeatureType = { MOON_CAPTURE_BOOST: 0 };\n  }\n  if (!camera.SceneMode) {\n    camera.SceneMode = {\n      NORMAL_PHOTO: 1,\n      NORMAL_VIDEO: 2,\n      PORTRAIT_PHOTO: 3,\n      NIGHT_PHOTO: 4\n    };\n  }\n}\n\nconst TAG: string = 'CameraService';\nconst TAG_AB: string = '-----AB-----';\n\nclass CameraService {\n  private captureMode: CaptureMode = CaptureMode.OLD_CAPTURE;\n  private cameraManager: camera.CameraManager | undefined = undefined;\n  private cameras: Array<camera.CameraDevice> | undefined = undefined;\n  private sceneModes: Array<camera.SceneMode> | undefined = undefined;\n  private cameraOutputCapability: camera.CameraOutputCapability | undefined = undefined;\n  private cameraInput: camera.CameraInput | undefined = undefined;\n  private previewOutput: camera.PreviewOutput | undefined = undefined;\n  private photoOutPut: camera.PhotoOutput | undefined = undefined;\n  private photoSession: camera.PhotoSession | undefined = undefined;\n  private videoSession: camera.VideoSession | undefined = undefined;\n  private portraitSession: camera.PortraitPhotoSession | undefined = undefined;\n  private nightSession: camera.NightPhotoSession | undefined = undefined;\n  private macroPhotoSession: camera.MacroPhotoSession | undefined = undefined;\n  private mReceiver: image.ImageReceiver | undefined = undefined;\n  private fileAsset: photoAccessHelper.PhotoAsset | undefined = undefined;\n  private fd: number = -1;\n  private videoRecorder: media.AVRecorder | undefined = undefined;\n  private videoOutput: camera.VideoOutput | undefined = undefined;\n  private handleTakePicture: (photoUri: string) => void | undefined = undefined;\n  private videoConfig: media.AVRecorderConfig = {\n    audioSourceType: media.AudioSourceType.AUDIO_SOURCE_TYPE_MIC,\n    videoSourceType: media.VideoSourceType.VIDEO_SOURCE_TYPE_SURFACE_YUV,\n    profile: {\n      audioBitrate: 48000,\n      audioChannels: 2,\n      audioCodec: media.CodecMimeType.AUDIO_AAC,\n      audioSampleRate: 48000,\n      fileFormat: media.ContainerFormatType.CFT_MPEG_4,\n      videoBitrate: 512000,\n      videoCodec: media.CodecMimeType.VIDEO_AVC,\n      videoFrameWidth: 640,\n      videoFrameHeight: 480,\n      videoFrameRate: Constants.VIDEO_FRAME_30\n    },\n    url: '',\n    rotation: 0\n  };\n  private videoProfiles: Array<camera.VideoProfile>;\n  private videoProfileObj: camera.VideoProfile = {\n    format: 1003,\n    size: {\n      width: 1920,\n      height: 1080\n    },\n    frameRateRange: {\n      min: Constants.VIDEO_FRAME_30,\n      max: Constants.VIDEO_FRAME_30\n    }\n  };\n  private defaultProfile: camera.Profile = {\n    format: 1003,\n    size: {\n      width: 1920,\n      height: 1080\n    }\n  };\n  private photoProfileObj: camera.Profile = {\n    format: 1003,\n    size: {\n      width: 1920,\n      height: 1080\n    }\n  };\n  private previewProfileObj: camera.Profile = {\n    format: 1003,\n    size: {\n      width: 1920,\n      height: 1080\n    }\n  };\n  private photoRotationMap = {\n    rotation0: 0,\n    rotation90: 90,\n    rotation180: 180,\n    rotation270: 270,\n  };\n  private videoOutputStatus: boolean = false;\n  private colorEffect: camera.ColorEffectType | undefined = undefined;\n  private cameraMode: number = 0;\n  private accessHelper: photoAccessHelper.PhotoAccessHelper;\n  private globalContext: GlobalContext = GlobalContext.get();\n  private isFirstRecord = true;\n  private isMoonCaptureBoostSupported: Boolean = false;\n\n  constructor() {\n    mockInterface();\n    this.accessHelper = photoAccessHelper.getPhotoAccessHelper(this.globalContext.getCameraSettingContext());\n    // image capacity\n    let imageCapacity = 8;\n    try {\n      this.mReceiver = image.createImageReceiver(cameraSize.width, cameraSize.height, image.ImageFormat.JPEG, imageCapacity);\n      Logger.debug(TAG, `createImageReceiver value: ${this.mReceiver}`);\n      // debug版本可能监听进不来\n      this.mReceiver.on('imageArrival', (): void => {\n        Logger.debug(TAG, 'imageArrival start');\n        this.mReceiver.readNextImage((errCode: BusinessError, imageObj: image.Image): void => {\n          Logger.info(TAG, 'readNextImage start');\n          Logger.info(TAG, `err: ${JSON.stringify(errCode)}`);\n          if (errCode || imageObj === undefined) {\n            Logger.error(TAG, 'readNextImage failed');\n            return;\n          }\n          imageObj.getComponent(image.ComponentType.JPEG, (errCode: BusinessError, component: image.Component): void => {\n            Logger.debug(TAG, 'getComponent start');\n            Logger.info(TAG, `err: ${JSON.stringify(errCode)}`);\n            if (errCode || component === undefined) {\n              Logger.info(TAG, 'getComponent failed');\n              return;\n            }\n            let buffer: ArrayBuffer;\n            if (component.byteBuffer) {\n              buffer = component.byteBuffer;\n            } else {\n              Logger.error(TAG, 'component byteBuffer is undefined');\n            }\n            this.savePicture(buffer, imageObj);\n          });\n        });\n      });\n    } catch (error) {\n      let err = error as BusinessError;\n      Logger.error(TAG, `savePicture err: ${JSON.stringify(err)}`);\n    }\n  }\n\n  /**\n   * 读取图像\n   */\n  async savePicture(buffer: ArrayBuffer, img: image.Image): Promise<void> {\n    try {\n      Logger.info(TAG, 'savePicture start');\n      let fileName = `${Date.now()}.jpg`;\n      let fileAsset = await this.accessHelper.createAsset(fileName);\n      let imgPhotoUri: string = fileAsset.uri;\n      const fd = await fileAsset.open('rw');\n      await fs.write(fd, buffer);\n      await fileAsset.close(fd);\n      await img.release();\n      Logger.info(TAG, 'savePicture End');\n      if (this.handleTakePicture) {\n        this.handleTakePicture(imgPhotoUri);\n      }\n    } catch (error) {\n      let err = error as BusinessError;\n      Logger.error(TAG, `savePicture err: ${JSON.stringify(err)}`);\n    }\n  }\n\n  /**\n   * 判断两浮点数是否相等\n   */\n  withinErrorMargin(left: number, right: number): boolean {\n    // 底数\n    let baseNumber = 2;\n    // 指数\n    let indexNumber = 2;\n    return Math.abs(left - right) < Number.EPSILON * Math.pow(baseNumber, indexNumber);\n  }\n\n  switchProfiles(profiles: camera.CameraOutputCapability): void {\n    let previewProfiles: Array<camera.Profile> = profiles.previewProfiles;\n    let videoProfiles: Array<camera.Profile> = profiles.videoProfiles;\n    let photoProfiles: Array<camera.Profile> = profiles.photoProfiles;\n    let isValidProfiles = true;\n    if (!previewProfiles || previewProfiles.length < 1) {\n      isValidProfiles = false;\n    }\n    if (isValidProfiles && (!photoProfiles || photoProfiles.length < 1)) {\n      isValidProfiles = false;\n    }\n    if (isValidProfiles && this.cameraMode !== CameraMode.PORTRAIT && (!videoProfiles || videoProfiles.length < 1)) {\n      isValidProfiles = false;\n    }\n    if (!isValidProfiles) {\n      Logger.error('Profile is invalid');\n      return;\n    }\n    let defaultAspectRatio: number = AppStorage.get<number>('defaultAspectRatio');\n    let previewProfileObj: camera.Profile;\n    let photoProfileObj: camera.Profile;\n    const deviceType = AppStorage.get<string>('deviceType');\n    switch (this.cameraMode) {\n      case CameraMode.PORTRAIT:\n        previewProfileObj = previewProfiles.find((profile: camera.Profile) => {\n          return profile.size.height === this.defaultProfile.size.height &&\n            profile.size.width === this.defaultProfile.size.width;\n        });\n        Logger.info(`previewProfileObj: ${JSON.stringify(previewProfileObj)}`);\n        this.previewProfileObj = previewProfileObj;\n        photoProfileObj = photoProfiles.find((profile: camera.Profile) => {\n          return profile.size.height === this.defaultProfile.size.height &&\n            profile.size.width === this.defaultProfile.size.width;\n        });\n        Logger.info(`photoProfileObj: ${JSON.stringify(photoProfileObj)}`);\n        this.photoProfileObj = photoProfileObj;\n        break;\n      case CameraMode.SUPER_STAB:\n        previewProfileObj = previewProfiles.find((profile: camera.Profile) => {\n          return profile.size.height === this.defaultProfile.size.height &&\n            profile.size.width === this.defaultProfile.size.width;\n        });\n        Logger.info(`previewProfileObj: ${JSON.stringify(previewProfileObj)}`);\n        this.previewProfileObj = previewProfileObj;\n        photoProfileObj = photoProfiles.find((profile: camera.Profile) => {\n          return profile.size.height === this.defaultProfile.size.height &&\n            profile.size.width === this.defaultProfile.size.width;\n        });\n        Logger.info(`photoProfileObj: ${JSON.stringify(photoProfileObj)}`);\n        this.photoProfileObj = photoProfileObj;\n        this.videoProfileObj = {\n          format: 1003,\n          size: {\n            width: 1920,\n            height: 1080\n          },\n          frameRateRange: {\n            min: 60,\n            max: 60\n          }\n        };\n        let videoProfileObj = videoProfiles.find((profile: camera.VideoProfile) => {\n          return profile.size.height === this.videoProfileObj.size.height &&\n            profile.size.width === this.videoProfileObj.size.width &&\n            profile.frameRateRange.min === this.videoProfileObj.frameRateRange.min &&\n            profile.frameRateRange.max === this.videoProfileObj.frameRateRange.max;\n        });\n        Logger.info(`videoProfileObj: ${JSON.stringify(videoProfileObj)}`);\n        if (!videoProfileObj) {\n          Logger.error('videoProfileObj not supported');\n        }\n        break;\n      case CameraMode.NIGHT:\n        previewProfileObj = previewProfiles.find((profile: camera.Profile) => {\n          return profile.size.height === this.defaultProfile.size.height &&\n            profile.size.width === this.defaultProfile.size.width;\n        });\n        Logger.info(`previewProfileObj: ${JSON.stringify(previewProfileObj)}`);\n        this.previewProfileObj = previewProfileObj;\n        photoProfileObj = photoProfiles.find((profile: camera.Profile) => {\n          return profile.size.height === this.defaultProfile.size.height &&\n            profile.size.width === this.defaultProfile.size.width;\n        });\n        Logger.info(`photoProfileObj: ${JSON.stringify(photoProfileObj)}`);\n        this.photoProfileObj = photoProfileObj;\n        break;\n      case CameraMode.NORMAL:\n      case CameraMode.VIDEO:\n      default:\n        for (let index = profiles.previewProfiles.length - 1; index >= 0; index--) {\n          const previewProfile = profiles.previewProfiles[index];\n          if (this.withinErrorMargin(defaultAspectRatio, previewProfile.size.width / previewProfile.size.height)) {\n            if (previewProfile.size.width <= Constants.PHOTO_MAX_WIDTH &&\n              previewProfile.size.height <= Constants.PHOTO_MAX_WIDTH) {\n              let previewProfileTemp = {\n                format: deviceType === Constants.DEFAULT ? previewProfile.format : this.defaultProfile.format,\n                size: {\n                  width: previewProfile.size.width,\n                  height: previewProfile.size.height\n                }\n              };\n              this.previewProfileObj = previewProfileTemp;\n              Logger.debug(TAG, `previewProfileObj: ${JSON.stringify(this.previewProfileObj)}`);\n              break;\n            }\n          }\n        }\n        for (let index = profiles.photoProfiles.length - 1; index >= 0; index--) {\n          const photoProfile = profiles.photoProfiles[index];\n          if (this.withinErrorMargin(defaultAspectRatio, photoProfile.size.width / photoProfile.size.height)) {\n            if (photoProfile.size.width <= Constants.PHOTO_MAX_WIDTH &&\n              photoProfile.size.height <= Constants.PHOTO_MAX_WIDTH) {\n              let photoProfileTemp = {\n                format: photoProfile.format,\n                size: {\n                  width: photoProfile.size.width,\n                  height: photoProfile.size.height\n                }\n              };\n              this.photoProfileObj = photoProfileTemp;\n              Logger.debug(TAG, `photoProfileObj: ${JSON.stringify(this.photoProfileObj)}`);\n              break;\n            }\n          }\n        }\n    }\n    if (deviceType === Constants.DEFAULT) {\n      let cameraConfig = this.globalContext.getObject('cameraConfig') as CameraConfig;\n      for (let index = this.videoProfiles.length - 1; index >= 0; index--) {\n        const videoProfileObj = this.videoProfiles[index];\n        if (this.withinErrorMargin(defaultAspectRatio, videoProfileObj.size.width / videoProfileObj.size.height)) {\n          if (videoProfileObj.size.width <= Constants.VIDEO_MAX_WIDTH &&\n            videoProfileObj.size.height <= Constants.VIDEO_MAX_WIDTH) {\n            let videoProfileTemp = {\n              format: videoProfileObj.format,\n              size: {\n                width: videoProfileObj.size.width,\n                height: videoProfileObj.size.height\n              },\n              frameRateRange: {\n                min: Constants.VIDEO_FRAME_30,\n                max: Constants.VIDEO_FRAME_30\n              }\n            };\n            if ((cameraConfig.videoFrame === 0 ? Constants.VIDEO_FRAME_15 : Constants.VIDEO_FRAME_30) ===\n            videoProfileObj.frameRateRange.min) {\n              videoProfileTemp.frameRateRange.min = videoProfileObj.frameRateRange.min;\n              videoProfileTemp.frameRateRange.max = videoProfileObj.frameRateRange.max;\n              this.videoProfileObj = videoProfileTemp;\n              Logger.info(TAG, `videoProfileObj: ${JSON.stringify(this.videoProfileObj)}`);\n              break;\n            }\n            Logger.info(TAG, `videoProfileTemp: ${JSON.stringify(videoProfileTemp)}`);\n            this.videoProfileObj = videoProfileTemp;\n          }\n        }\n      }\n    }\n  }\n\n  setCameraMode(cameraMode: number): void {\n    this.cameraMode = cameraMode;\n  }\n\n  initProfile(cameraDeviceIndex: number): void {\n    let profiles;\n    if (this.cameraMode === CameraMode.PORTRAIT) {\n      profiles = this.cameraManager.getSupportedOutputCapability(this.cameras[cameraDeviceIndex], camera.SceneMode.PORTRAIT_PHOTO);\n    } else if (this.cameraMode === CameraMode.VIDEO) {\n      profiles = this.cameraManager.getSupportedOutputCapability(this.cameras[cameraDeviceIndex], camera.SceneMode.NORMAL_VIDEO);\n    } else {\n      profiles = this.cameraManager.getSupportedOutputCapability(this.cameras[cameraDeviceIndex]);\n    }\n    this.videoProfiles = profiles.videoProfiles;\n    this.switchProfiles(profiles);\n  }\n\n  /**\n   * 初始化\n   */\n  async initCamera(surfaceId: string, cameraDeviceIndex: number): Promise<void> {\n    try {\n      this.isFirstRecord = true;\n      // 获取传入摄像头\n      Logger.debug(TAG, `initCamera cameraDeviceIndex: ${cameraDeviceIndex}`);\n      await this.releaseCamera();\n      // 获取相机管理器实例\n      this.getCameraManagerFn();\n      let newModes = [CameraMode.PORTRAIT, CameraMode.NIGHT, CameraMode.MACRO_PHOTO, CameraMode.MACRO_VIDEO];\n\n      if (newModes.indexOf(this.cameraMode) >= 0) {\n        this.getModeManagerFn();\n      }\n      // 获取支持指定的相机设备对象\n      this.getSupportedCamerasFn();\n      if (newModes.indexOf(this.cameraMode) >= 0) {\n        this.getSupportedModeFn(cameraDeviceIndex);\n      }\n      this.initProfile(cameraDeviceIndex);\n      // 创建previewOutput输出对象\n      this.createPreviewOutputFn(this.previewProfileObj, surfaceId);\n      // 监听预览事件\n      this.previewOutputCallBack();\n      if (this.cameraMode === CameraMode.SUPER_STAB || this.cameraMode === CameraMode.VIDEO) {\n        await this.createAVRecorder();\n        await this.createVideoOutput();\n        // 监听录像事件\n        this.onVideoOutputChange();\n      }\n      // 创建photoOutPut输出对象\n      let mSurfaceId = await this.mReceiver.getReceivingSurfaceId();\n      this.createPhotoOutputFn(this.photoProfileObj, mSurfaceId);\n      // 拍照监听事件\n      this.photoOutPutCallBack();\n      // 创建cameraInput输出对象\n      this.createCameraInputFn(this.cameras[cameraDeviceIndex]);\n      // 打开相机\n      await this.cameraInputOpenFn();\n      // 镜头状态回调\n      this.onCameraStatusChange();\n      // 监听CameraInput的错误事件\n      this.onCameraInputChange();\n      // 会话流程\n      switch (this.cameraMode) {\n        case CameraMode.PORTRAIT:\n          await this.portraitSessionFlowFn(); break;\n        case CameraMode.NIGHT:\n          await this.nightSessionFlowFn(); break;\n        case CameraMode.MACRO_PHOTO:\n          await this.macroPhotoSessionFlowFn(); break;\n        case CameraMode.MACRO_VIDEO:\n          break;\n        case CameraMode.VIDEO:\n          await this.videoSessionFlowFn(); break;\n        default:\n          await this.photoSessionFlowFn();\n          break;\n      }\n      this.testAbilityFunction();\n    } catch (error) {\n      let err = error as BusinessError;\n      Logger.error(TAG, `initCamera fail: ${JSON.stringify(err)}`);\n    }\n  }\n\n  isVideoFrameSupportedFn(videoFrame: number): boolean {\n    let videoProfile: camera.VideoProfile | undefined = this.videoProfiles.find((videoProfile: camera.VideoProfile) => {\n      return videoProfile.size.height === this.videoProfileObj.size.height &&\n        videoProfile.size.width === this.videoProfileObj.size.width &&\n        videoProfile.format === this.videoProfileObj.format &&\n        videoProfile.frameRateRange.min === videoFrame &&\n        videoProfile.frameRateRange.max === videoFrame;\n    });\n    return videoProfile === undefined ? false : true;\n  }\n\n  /**\n   * 曝光\n   */\n  isExposureModeSupportedFn(aeMode: camera.ExposureMode): boolean {\n    // 检测曝光模式是否支持\n    let isSupported: boolean = false;\n    let session: camera.PortraitPhotoSession | camera.CaptureSession | camera.NightPhotoSession = this.getSession();\n    if (!session) {\n      return isSupported;\n    }\n    isSupported = session.isExposureModeSupported(aeMode);\n    Logger.info(TAG, `isExposureModeSupported success, isSupported: ${isSupported}`);\n    return isSupported;\n  }\n\n  setExposureMode(aeMode: camera.ExposureMode): void {\n    let session: camera.PortraitPhotoSession | camera.CaptureSession | camera.NightPhotoSession = this.getSession();\n    if (!session) {\n      return;\n    }\n    session.setExposureMode(aeMode);\n    let exposureMode: camera.ExposureMode | undefined = undefined;\n    exposureMode = session.getExposureMode();\n    Logger.info(TAG, `getExposureMode success, exposureMode: ${exposureMode}`);\n  }\n\n  /**\n   * 曝光区域\n   */\n  isMeteringPoint(point: camera.Point): void {\n    // 获取当前曝光模式\n    let session: camera.PortraitPhotoSession | camera.CaptureSession | camera.NightPhotoSession = this.getSession();\n    if (!session) {\n      return;\n    }\n    let exposureMode: camera.ExposureMode | undefined = undefined;\n    exposureMode = session.getExposureMode();\n    Logger.info(TAG, `getExposureMode success, exposureMode: ${exposureMode}`);\n    session.setMeteringPoint(point);\n    let exposurePoint: camera.Point | undefined = undefined;\n    exposurePoint = session.getMeteringPoint();\n    Logger.info(TAG, `getMeteringPoint exposurePoint: ${JSON.stringify(exposurePoint)}`);\n  }\n\n  /**\n   * 曝光补偿\n   */\n  isExposureBiasRange(exposureBias: number): void {\n    Logger.debug(TAG, `setExposureBias value ${exposureBias}`);\n    // 查询曝光补偿范围\n    let session: camera.PortraitPhotoSession | camera.CaptureSession | camera.NightPhotoSession = this.getSession();\n    if (!session) {\n      return;\n    }\n    let biasRangeArray: Array<number> = [];\n    biasRangeArray = session.getExposureBiasRange();\n    Logger.debug(TAG, `getExposureBiasRange success, biasRangeArray: ${JSON.stringify(biasRangeArray)}`);\n    // 设置曝光补偿\n    session.setExposureBias(exposureBias);\n  }\n\n  /**\n   * 是否支持对应对焦模式\n   */\n  isFocusModeSupported(focusMode: camera.FocusMode): boolean {\n    let session: camera.PortraitPhotoSession | camera.CaptureSession | camera.NightPhotoSession = this.getSession();\n    if (!session) {\n      return false;\n    }\n    return session.isFocusModeSupported(focusMode);\n  }\n\n  /**\n   * 对焦模式\n   */\n  isFocusMode(focusMode: camera.FocusMode): void {\n    // 检测对焦模式是否支持\n    let isSupported = this.isFocusModeSupported(focusMode);\n    Logger.info(TAG, `isFocusModeSupported isSupported: ${JSON.stringify(isSupported)}`);\n    // 设置对焦模式\n    if (!isSupported) {\n      return;\n    }\n    let session: camera.PortraitPhotoSession | camera.CaptureSession | camera.NightPhotoSession = this.getSession();\n    if (!session) {\n      return;\n    }\n    session.setFocusMode(focusMode);\n  }\n\n  /**\n   * 焦点\n   */\n  isFocusPoint(point: camera.Point): void {\n    // 设置焦点\n    let session: camera.PortraitPhotoSession | camera.CaptureSession | camera.NightPhotoSession = this.getSession();\n    if (!session) {\n      return;\n    }\n    session.setFocusPoint(point);\n    Logger.info(TAG, 'setFocusPoint success');\n    // 获取当前的焦点\n    let nowPoint: camera.Point | undefined = undefined;\n    nowPoint = session.getFocusPoint();\n    Logger.info(TAG, `getFocusPoint success, nowPoint: ${JSON.stringify(nowPoint)}`);\n  }\n\n  /**\n   * 闪关灯\n   */\n  hasFlashFn(flashMode: camera.FlashMode): void {\n    let session: camera.PortraitPhotoSession | camera.CaptureSession | camera.NightPhotoSession = this.getSession();\n    if (!session) {\n      return;\n    }\n    // 检测是否有闪关灯\n    let hasFlash = session.hasFlash();\n    Logger.debug(TAG, `hasFlash success, hasFlash: ${hasFlash}`);\n    // 检测闪光灯模式是否支持\n    let isFlashModeSupported = session.isFlashModeSupported(flashMode);\n    Logger.debug(TAG, `isFlashModeSupported success, isFlashModeSupported: ${isFlashModeSupported}`);\n    // 设置闪光灯模式\n    session.setFlashMode(flashMode);\n    // 获取当前设备的闪光灯模式\n    let nowFlashMode = session.getFlashMode();\n    Logger.debug(TAG, `getFlashMode success, nowFlashMode: ${nowFlashMode}`);\n  }\n\n  getSession(): camera.PortraitPhotoSession | camera.CaptureSession | camera.NightPhotoSession | undefined {\n    let session: camera.PortraitPhotoSession | camera.CaptureSession | camera.NightPhotoSession = undefined;\n    switch (this.cameraMode) {\n      case CameraMode.PORTRAIT:\n        return this.portraitSession;\n      case CameraMode.NIGHT:\n        return this.nightSession;\n      case CameraMode.MACRO_PHOTO:\n        return this.macroPhotoSession;\n      case CameraMode.VIDEO:\n        return this.videoSession;\n      case CameraMode.NORMAL:\n        return this.photoSession;\n      default:\n        return this.captureSession;\n    }\n  }\n\n  /**\n   * 变焦\n   */\n  setZoomRatioFn(zoomRatio: number): void {\n    Logger.info(TAG, `setZoomRatioFn value ${zoomRatio}`);\n    // 获取支持的变焦范围\n    let session: camera.PortraitPhotoSession | camera.CaptureSession | camera.NightPhotoSession = this.getSession();\n    if (!session) {\n      return;\n    }\n    try {\n      let zoomRatioRange = session.getZoomRatioRange();\n      Logger.info(TAG, `getZoomRatioRange success: ${JSON.stringify(zoomRatioRange)}`);\n    } catch (error) {\n      let err = error as BusinessError;\n      Logger.error(TAG, `getZoomRatioRange fail: ${JSON.stringify(err)}`);\n    }\n\n    try {\n      session.setZoomRatio(zoomRatio);\n      Logger.info(TAG, 'setZoomRatioFn success');\n    } catch (error) {\n      let err = error as BusinessError;\n      Logger.error(TAG, `setZoomRatioFn fail: ${JSON.stringify(err)}`);\n    }\n\n    try {\n      let nowZoomRatio = session.getZoomRatio();\n      Logger.info(TAG, `getZoomRatio nowZoomRatio: ${JSON.stringify(nowZoomRatio)}`);\n    } catch (error) {\n      let err = error as BusinessError;\n      Logger.error(TAG, `getZoomRatio fail: ${JSON.stringify(err)}`);\n    }\n  }\n\n  /**\n   * 防抖\n   */\n  isVideoStabilizationModeSupportedFn(videoStabilizationMode: camera.VideoStabilizationMode): boolean {\n    // 查询是否支持指定的视频防抖模式\n    let session: camera.PortraitPhotoSession | camera.Session | camera.NightPhotoSession = this.getSession();\n    let isVideoStabilizationModeSupported: boolean = session.isVideoStabilizationModeSupported(videoStabilizationMode);\n    Logger.info(TAG, `isVideoStabilizationModeSupported success: ${JSON.stringify(isVideoStabilizationModeSupported)}`);\n    return isVideoStabilizationModeSupported;\n  }\n\n  setVideoStabilizationMode(videoStabilizationMode: camera.VideoStabilizationMode): void {\n    // 设置视频防抖\n    Logger.info(TAG, `setVideoStabilizationMode: ${videoStabilizationMode}`);\n    let session: camera.PortraitPhotoSession | camera.Session | camera.NightPhotoSession = this.getSession();\n    session.setVideoStabilizationMode(videoStabilizationMode);\n    let nowVideoStabilizationMod: camera.VideoStabilizationMode = session.getActiveVideoStabilizationMode();\n    Logger.info(TAG, `getActiveVideoStabilizationMode nowVideoStabilizationMod: ${nowVideoStabilizationMod}`);\n  }\n\n  /**\n   * 是否支持夜景模式\n   */\n  isNightModeSupportedFn(): boolean {\n    let isSupportNightMode: boolean = this.sceneModes.indexOf(CameraMode.NIGHT) >= 0;\n    Logger.info(TAG, `isSupportNightMode success: ${JSON.stringify(isSupportNightMode)}`);\n    return isSupportNightMode;\n  }\n\n  /**\n   * 是否支持人像模式\n   */\n  isPortraitModeSupportedFn(): boolean {\n    let isSupportPortraitMode: boolean = this.sceneModes.indexOf(CameraMode.PORTRAIT) >= 0;\n    Logger.info(TAG, `isSupportPortraitMode success: ${JSON.stringify(isSupportPortraitMode)}`);\n    return isSupportPortraitMode;\n  }\n\n  /**\n   * 是否支持微距模式\n   */\n  isMacroPhotoModeSupportedFn(): boolean {\n    let isSupportMacroMode: boolean = this.sceneModes.indexOf(CameraMode.MACRO_PHOTO) >= 0;\n    Logger.info(TAG, `isSupportMacroMode success: ${JSON.stringify(isSupportMacroMode)}`);\n    return isSupportMacroMode;\n  }\n\n  /**\n   * 是否支持镜像\n   */\n  isMirrorSupportedFn(): void {\n    let isSupported = this.photoOutPut.isMirrorSupported();\n    Logger.info(TAG, `isMirrorSupported success Bol: ${JSON.stringify(isSupported)}`);\n  }\n\n  setTakePictureCallback(callback: (photoUri: string) => void): void {\n    this.handleTakePicture = callback;\n  }\n\n  /**\n   * 照片方向判断\n   */\n  onChangeRotation(): number {\n    let cameraConfig = (this.globalContext.getObject('cameraConfig') as CameraConfig);\n    switch (cameraConfig.photoOrientation) {\n      case PhotoOrientation.ORIENTATION_1:\n        return this.photoRotationMap.rotation90;\n      case PhotoOrientation.ORIENTATION_2:\n        return this.photoRotationMap.rotation180;\n      case PhotoOrientation.ORIENTATION_3:\n        return this.photoRotationMap.rotation270;\n      case PhotoOrientation.ORIENTATION_0:\n      default:\n        return this.photoRotationMap.rotation0;\n    }\n  }\n\n  /**\n   * 照片地理位置逻辑 ，后续需要靠定位实现 目前传入固定值\n   */\n  onChangeLocation(): {\n    latitude: number,\n    longitude: number,\n    altitude: number\n  } {\n    let cameraConfig = (this.globalContext.getObject('cameraConfig') as CameraConfig);\n    if (cameraConfig.locationBol) {\n      return {\n        // 位置信息，经纬度\n        latitude: 12.9698,\n        longitude: 77.7500,\n        altitude: 1000\n      };\n    }\n    return {\n      latitude: 0,\n      longitude: 0,\n      altitude: 0\n    };\n  }\n\n  /**\n   * 拍照\n   */\n  async takePicture(mirrorBol?: boolean): Promise<void> {\n    Logger.info(TAG, 'takePicture start');\n    mirrorBol = mirrorBol || false;\n    this.isMirrorSupportedFn();\n    let cameraConfig = (this.globalContext.getObject('cameraConfig') as CameraConfig);\n    let photoSettings = {\n      rotation: this.onChangeRotation(),\n      quality: cameraConfig.photoQuality,\n      location: this.onChangeLocation(),\n      mirror: cameraConfig.mirrorBol\n    };\n    Logger.debug(TAG, `takePicture photoSettings:${JSON.stringify(photoSettings)}`);\n    await this.photoOutPut.capture(photoSettings);\n    Logger.info(TAG, 'takePicture end');\n  }\n\n  async prepareAVRecorder(): Promise<void> {\n    await this.initUrl();\n    let deviceType = AppStorage.get<string>('deviceType');\n    if (deviceType === Constants.DEFAULT) {\n      this.videoConfig.videoSourceType = media.VideoSourceType.VIDEO_SOURCE_TYPE_SURFACE_ES;\n    }\n    if (deviceType === Constants.PHONE) {\n      this.videoConfig.videoSourceType = media.VideoSourceType.VIDEO_SOURCE_TYPE_SURFACE_YUV;\n      this.videoConfig.profile.videoCodec = media.CodecMimeType.VIDEO_AVC;\n      this.videoConfig.rotation = this.photoRotationMap.rotation90;\n    }\n    if (deviceType === Constants.TABLET) {\n      this.videoConfig.videoSourceType = media.VideoSourceType.VIDEO_SOURCE_TYPE_SURFACE_YUV;\n    }\n    this.videoConfig.profile.videoFrameWidth = this.videoProfileObj.size.width;\n    this.videoConfig.profile.videoFrameHeight = this.videoProfileObj.size.height;\n    this.videoConfig.profile.videoFrameRate = this.videoProfileObj.frameRateRange.max;\n    Logger.info(TAG, `prepareAVRecorder deviceType: ${deviceType}, videoSourceType: ${JSON.stringify(this.videoConfig)}`);\n    await this.videoRecorder.prepare(this.videoConfig).catch((err: { code?: number }): void => {\n      Logger.error(TAG, `prepareAVRecorder prepare err: ${JSON.stringify(err)}`);\n    });\n  }\n\n  async getAVRecorderSurfaceId(): Promise<string> {\n    return await this.videoRecorder.getInputSurface();\n  }\n\n  async createAVRecorder(): Promise<void> {\n    this.videoRecorder = await media.createAVRecorder();\n  }\n\n  /**\n   * 配置videoOutput流\n   */\n  async createVideoOutput(): Promise<void> {\n    Logger.info(TAG, 'createVideoOutput start');\n    await this.prepareAVRecorder();\n    let videoId = await this.getAVRecorderSurfaceId();\n    Logger.debug(TAG, `createVideoOutput videoProfileObj: ${JSON.stringify(this.videoProfileObj)}`);\n    let hdrVideoBol: boolean = (this.globalContext.getObject('cameraConfig') as CameraConfig).hdrVideoBol;\n    if (this.cameraMode === CameraMode.VIDEO && hdrVideoBol) {\n       this.videoProfileObj.format = camera.CameraFormat.CAMERA_FORMAT_YCRCB_P010;\n    }\n    this.videoOutput = this.cameraManager.createVideoOutput(this.videoProfileObj, videoId);\n    Logger.info(TAG, 'createVideoOutput end');\n  }\n\n  /**\n   * 暂停录制\n   */\n  async pauseVideo(): Promise<void> {\n    await this.videoRecorder.pause().then((): void => {\n      this.videoOutput.stop();\n      this.videoOutputStatus = false;\n      Logger.info(TAG, 'pauseVideo success');\n    }).catch((err: BusinessError): void => {\n      Logger.error(TAG, `pauseVideo failed: ${JSON.stringify(err)}`);\n    });\n  }\n\n  /**\n   * 恢复视频录制\n   */\n  async resumeVideo(): Promise<void> {\n    this.videoOutput.start().then((): void => {\n      this.videoOutputStatus = true;\n      Logger.info(TAG, 'resumeVideo start');\n      this.videoRecorder.resume().then((): void => {\n        Logger.info(TAG, 'resumeVideo success');\n      }).catch((err: { code?: number }): void => {\n        Logger.error(TAG, `resumeVideo failed: ${JSON.stringify(err)}`);\n      });\n    });\n  }\n\n  /**\n   * 初始化录制适配地址\n   */\n  async initUrl(): Promise<void> {\n    let fileName = `${Date.now()}.mp4`;\n    this.fileAsset = await this.accessHelper.createAsset(fileName);\n    this.fd = await this.fileAsset.open('rw');\n    this.videoConfig.url = `fd://${this.fd.toString()}`;\n  }\n\n  /**\n   * 开始录制\n   */\n  async startVideo(): Promise<void> {\n    try {\n      Logger.info(TAG, 'startVideo begin');\n      await this.videoOutput.start();\n      this.videoOutputStatus = true;\n      if (!this.isFirstRecord) {\n        await this.prepareAVRecorder();\n        await this.getAVRecorderSurfaceId();\n      }\n      await this.videoRecorder.start();\n      this.isFirstRecord = false;\n      AppStorage.setOrCreate<boolean>('isRecorder', true);\n      Logger.info(TAG, 'startVideo end');\n    } catch (error) {\n      let err = error as BusinessError;\n      Logger.error(TAG, `startVideo err: ${JSON.stringify(err)}`);\n    }\n  }\n\n  async releaseVideoRecorder(): Promise<void> {\n    if (this.videoRecorder) {\n      try {\n        await this.videoRecorder.release();\n        this.videoOutputStatus = false;\n        AppStorage.setOrCreate<boolean>('isRecorder', false);\n      } catch (error) {\n        let err = error as BusinessError;\n        Logger.error(TAG, 'stopVideo err: ' + JSON.stringify(err));\n      }\n    }\n  }\n\n  /**\n   * 停止录制\n   */\n  async stopVideo(): Promise<photoAccessHelper.PhotoAsset> {\n    let isRecorder: boolean = AppStorage.get<boolean>('isRecorder');\n    if (!isRecorder) {\n      Logger.info(TAG, 'not in recording');\n      return undefined;\n    }\n    try {\n      Logger.info(TAG, 'stopVideo start');\n      AppStorage.setOrCreate<boolean>('isRecorder', false);\n      if (this.videoRecorder) {\n        await this.videoRecorder.stop();\n      }\n      if (this.videoOutputStatus) {\n        await this.videoOutput.stop();\n        this.videoOutputStatus = false;\n      }\n      if (this.fileAsset) {\n        await this.fileAsset.close(this.fd);\n        return this.fileAsset;\n      }\n      return undefined;\n    } catch (error) {\n      let err = error as BusinessError;\n      Logger.error(TAG, 'stopVideo err: ' + JSON.stringify(err));\n      return undefined;\n    }\n  }\n\n  /**\n   * 释放会话及其相关参数\n   */\n  async releaseCamera(): Promise<void> {\n    Logger.info(TAG, 'releaseCamera is called');\n    await this.stopVideo();\n    await this.releaseVideoRecorder();\n    if (this.previewOutput) {\n      try {\n        await this.previewOutput.stop();\n        await this.previewOutput.release();\n      } catch (error) {\n        let err = error as BusinessError;\n        Logger.error(TAG, `previewOutput release fail: error: ${JSON.stringify(err)}`);\n      } finally {\n        this.previewOutput = null;\n      }\n\n    }\n    if (this.photoOutPut) {\n      try {\n        await this.photoOutPut.release();\n      } catch (error) {\n        let err = error as BusinessError;\n        Logger.error(TAG, `photoOutPut release fail: error: ${JSON.stringify(err)}`);\n      } finally {\n        this.photoOutPut = null;\n      }\n    }\n    if (this.videoOutput) {\n      try {\n        await this.videoOutput.release();\n      } catch (error) {\n        let err = error as BusinessError;\n        Logger.error(TAG, `videoOutput release fail: error: ${JSON.stringify(err)}`);\n      } finally {\n        this.videoOutput = null;\n      }\n    }\n    if (this.photoSession) {\n      try {\n        await this.photoSession.release();\n      } catch (error) {\n        let err = error as BusinessError;\n        Logger.error(TAG, `photoSession release fail: error: ${JSON.stringify(err)}`);\n      } finally {\n        this.photoSession = null;\n      }\n    }\n    if (this.videoSession) {\n      try {\n        await this.videoSession.release();\n      } catch (error) {\n        let err = error as BusinessError;\n        Logger.error(TAG, `videoSession release fail: error: ${JSON.stringify(err)}`);\n      } finally {\n        this.videoSession = null;\n      }\n    }\n    if (this.portraitSession) {\n      try {\n        await this.portraitSession.release();\n      } catch (error) {\n        let err = error as BusinessError;\n        Logger.error(TAG, `portraitSession release fail: error: ${JSON.stringify(err)}`);\n      } finally {\n        this.portraitSession = null;\n      }\n    }\n    if (this.nightSession) {\n      try {\n        await this.nightSession.release();\n      } catch (error) {\n        let err = error as BusinessError;\n        Logger.error(TAG, `nightSession release fail: error: ${JSON.stringify(err)}`);\n      } finally {\n        this.nightSession = null;\n      }\n    }\n    if (this.cameraInput) {\n      try {\n        await this.cameraInput.close();\n      } catch (error) {\n        let err = error as BusinessError;\n        Logger.error(TAG, `cameraInput close fail: error: ${JSON.stringify(err)}`);\n      } finally {\n        this.cameraInput = null;\n      }\n    }\n    Logger.info(TAG, 'releaseCamera success');\n  }\n\n  /**\n   * 获取相机管理器实例\n   */\n  getCameraManagerFn(): void {\n    if (this.cameraManager) {\n      return;\n    }\n    try {\n      this.cameraManager = camera.getCameraManager(GlobalContext.get().getCameraSettingContext());\n      Logger.info(TAG, `getCameraManager success: ${this.cameraManager}`);\n    } catch (error) {\n      let err = error as BusinessError;\n      Logger.error(TAG, `getCameraManager failed: ${JSON.stringify(err)}`);\n    }\n  }\n\n  getModeManagerFn(): void {\n    try {\n      this.cameraManager = camera.getCameraManager(GlobalContext.get().getCameraSettingContext());\n      Logger.info(TAG, `getModeManagerFn success: ${this.cameraManager}`);\n    } catch (error) {\n      let err = error as BusinessError;\n      Logger.error(TAG, `getModeManagerFn failed: ${JSON.stringify(err)}`);\n    }\n  }\n\n  /**\n   * 获取支持指定的相机设备对象\n   */\n  getSupportedCamerasFn(): void {\n    try {\n      this.cameras = this.cameraManager.getSupportedCameras();\n      Logger.info(TAG, `getSupportedCameras success: ${this.cameras}, length: ${this.cameras.length}`);\n    } catch (error) {\n      let err = error as BusinessError;\n      Logger.error(TAG, `getSupportedCameras failed: ${JSON.stringify(err)}`);\n    }\n  }\n\n  getSupportedModeFn(cameraIndex: number): void {\n    try {\n      this.sceneModes = this.cameraManager.getSupportedSceneModes(this.cameras[cameraIndex]);\n      Logger.info(TAG, `getSupportedModeFn success: ${this.sceneModes}, length: ${this.sceneModes.length}`);\n    } catch (error) {\n      let err = error as BusinessError;\n      Logger.error(TAG, `getSupportedModeFn failed: ${JSON.stringify(err)}`);\n    }\n  }\n\n  /**\n   * 查询相机设备在模式下支持的输出能力\n   */\n  async getSupportedOutputCapabilityFn(cameraDeviceIndex: number): Promise<void> {\n    this.cameraOutputCapability = this.cameraManager.getSupportedOutputCapability(this.cameras[cameraDeviceIndex]);\n  }\n\n  /**\n   * 创建previewOutput输出对象\n   */\n  createPreviewOutputFn(photoProfileObj: camera.Profile, surfaceId: string): void {\n    try {\n      let hdrVideoBol: boolean = (this.globalContext.getObject('cameraConfig') as CameraConfig).hdrVideoBol;\n      if (this.cameraMode === CameraMode.VIDEO && hdrVideoBol) {\n        photoProfileObj.format = camera.CameraFormat.CAMERA_FORMAT_YCRCB_P010;\n      }\n      this.previewOutput = this.cameraManager.createPreviewOutput(photoProfileObj, surfaceId);\n      Logger.info(TAG, `createPreviewOutput success: ${this.previewOutput}`);\n    } catch (error) {\n      let err = error as BusinessError;\n      Logger.error(TAG, `createPreviewOutput failed: ${JSON.stringify(err)}`);\n    }\n  }\n\n  /**\n   * 创建photoOutPut输出对象\n   */\n  createPhotoOutputFn(photoProfileObj: camera.Profile, surfaceId: string): void {\n    Logger.info(TAG, `createPhotoOutputFn photoProfiles: ${JSON.stringify(photoProfileObj)} ,captureMode: ${this.captureMode}, surfaceId: ${surfaceId}`);\n    switch (this.captureMode) {\n      case CaptureMode.OLD_CAPTURE:\n        this.photoOutPut = this.cameraManager.createPhotoOutput(photoProfileObj, surfaceId);\n        break;\n      case CaptureMode.NEW_CAPTURE:\n      case CaptureMode.NEW_DEFERRED_PHOTO:\n        this.photoOutPut = this.cameraManager.createPhotoOutput(photoProfileObj);\n        if (this.photoOutPut == null) {\n          Logger.error(TAG, 'createPhotoOutputFn createPhotoOutput failed');\n        }\n        break;\n    }\n  }\n\n  /**\n   * 创建cameraInput输出对象\n   */\n  createCameraInputFn(cameraDevice: camera.CameraDevice): void {\n    Logger.info(TAG, 'createCameraInputFn is called.');\n    try {\n      this.cameraInput = this.cameraManager.createCameraInput(cameraDevice);\n    } catch (err) {\n\n    }\n  }\n\n  /**\n   * 打开相机\n   */\n  async cameraInputOpenFn(): Promise<void> {\n    try {\n      await this.cameraInput.open();\n      Logger.info(TAG, 'cameraInput open success');\n    } catch (error) {\n      let err = error as BusinessError;\n      Logger.error(TAG, `createCameraInput failed : ${JSON.stringify(err)}`);\n    }\n  }\n\n  /**\n   * 处理望月信息\n   */\n  configMoonCaptureBoost(): void {\n    try {\n      this.isMoonCaptureBoostSupported =\n        this.photoSession.isSceneFeatureSupported(camera.SceneFeatureType.MOON_CAPTURE_BOOST);\n      if (this.isMoonCaptureBoostSupported) {\n        this.photoSession.on('featureDetectionStatus', camera.SceneFeatureType.MOON_CAPTURE_BOOST,\n          (error, statusObject) => {\n            Logger.info(TAG,\n              `on featureDetectionStatus featureType:${statusObject.featureType} detected:${statusObject.detected}`);\n            if (statusObject.featureType === camera.SceneFeatureType.MOON_CAPTURE_BOOST) {\n              let status = statusObject.detected;\n              Logger.info(TAG, `on moonCaptureBoostStatus change:${status}`);\n              AppStorage.setOrCreate('moonCaptureComponentIsShow', status);\n              if (!status) {\n                this.setMoonCaptureBoostEnable(status);\n              }\n            }\n          });\n      }\n    } catch (error) {\n      let err = error as BusinessError;\n      Logger.error(TAG, `isMoonCaptureBoostSupported fail: error code ${err.code}`);\n    }\n  }\n\n  /**\n   * 拍照会话流程\n   */\n  async photoSessionFlowFn(): Promise<void> {\n    try {\n      Logger.info(TAG, 'photoSessionFlowFn start');\n      // 创建CaptureSession实例\n      this.photoSession = this.cameraManager.createSession(camera.SceneMode.NORMAL_PHOTO);\n      // 监听焦距的状态变化\n      this.onFocusStateChange();\n      // 监听拍照会话的错误事件\n      this.onCaptureSessionErrorChange();\n      // 开始配置会话\n      this.photoSession.beginConfig();\n      // 把CameraInput加入到会话\n      this.photoSession.addInput(this.cameraInput);\n      // 把previewOutput加入到会话\n      this.photoSession.addOutput(this.previewOutput);\n      // 把photoOutPut加入到会话\n      this.photoSession.addOutput(this.photoOutPut);\n\n      // hdr 拍照\n      let hdrPhotoBol: boolean = (this.globalContext.getObject('cameraConfig') as CameraConfig).hdrPhotoBol;\n      Logger.info(TAG, 'hdrPhotoBol:' + hdrPhotoBol);\n      if (hdrPhotoBol) {\n        this.setColorSpace(this.photoSession, colorSpaceManager.ColorSpace.DISPLAY_P3);\n      } else {\n        this.setColorSpace(this.photoSession, colorSpaceManager.ColorSpace.SRGB);\n      }\n\n      if (this.captureMode === CaptureMode.NEW_DEFERRED_PHOTO) {\n        if (this.isDeferredImageDeliverySupported(camera.DeferredDeliveryImageType.PHOTO)) {\n          this.deferImageDeliveryFor(camera.DeferredDeliveryImageType.PHOTO);\n          this.isDeferredImageDeliveryEnabled(camera.DeferredDeliveryImageType.PHOTO);\n        }\n      }\n\n      // 提交配置信息\n      await this.photoSession.commitConfig();\n\n      // 处理变焦条信息\n      try {\n        let range: Array<number> = this.photoSession.getZoomRatioRange();\n        Logger.info(TAG, `getZoomRatioRange:${range}`);\n        if (range) {\n          AppStorage.setOrCreate('zoomRatioMin', range[0]);\n          AppStorage.setOrCreate('zoomRatioMax', range[1]);\n        }\n      } catch (error) {\n        let err = error as BusinessError;\n        Logger.error(TAG, `getZoomRatioRange fail: error code ${err.code}`);\n      }\n\n      // 获取当前模式等效焦距\n      try {\n        let zoomPointInfo: Array<ZoomPointInfo> = this.photoSession.getZoomPointInfos();\n        if (zoomPointInfo) {\n          Logger.info(TAG, `getZoomPointInfos zoomRatio:${zoomPointInfo[0].zoomRatio} equivalentFocalLength:${zoomPointInfo[0].equivalentFocalLength}`);\n          AppStorage.setOrCreate('equivalentFocalLength', zoomPointInfo[0].equivalentFocalLength);\n        }\n      } catch (error) {\n        let err = error as BusinessError;\n        Logger.error(TAG, `getZoomPointInfos fail: error code ${err.code}`);\n      }\n\n      this.configMoonCaptureBoost();\n\n      AppStorage.setOrCreate('colorEffectComponentIsHidden', this.getSupportedColorEffects().length > 0 ? false : true);\n      AppStorage.setOrCreate('deferredPhotoComponentIsHidden', false);\n      AppStorage.setOrCreate('moonCaptureComponentIsShow', false);\n\n      if (this.colorEffect) {\n        this.setColorEffect(this.colorEffect);\n      }\n      // 开始会话工作\n      await this.photoSession.start();\n      if (this.cameraMode === CameraMode.SUPER_STAB) {\n        let isSupported = this.isVideoStabilizationModeSupportedFn(camera.VideoStabilizationMode.HIGH);\n        if (isSupported) {\n          this.setVideoStabilizationMode(camera.VideoStabilizationMode.HIGH);\n        }\n      }\n      this.isFocusMode((this.globalContext.getObject('cameraConfig') as CameraConfig).focusMode);\n      Logger.info(TAG, 'photoSessionFlowFn success');\n    } catch (error) {\n      let err = error as BusinessError;\n      Logger.error(TAG, `photoSessionFlowFn fail : ${JSON.stringify(err)}`);\n    }\n  }\n\n  /**\n   * 会话流程\n   */\n  async videoSessionFlowFn(): Promise<void> {\n    try {\n      Logger.info(TAG, 'videoSessionFlowFn start');\n      // 创建CaptureSession实例\n      this.videoSession = this.cameraManager.createSession(camera.SceneMode.NORMAL_VIDEO);\n\n      // 监听焦距的状态变化\n      this.onFocusStateChange();\n      // 监听拍照会话的错误事件\n      this.onCaptureSessionErrorChange();\n      // 开始配置会话\n      this.videoSession.beginConfig();\n      // 把CameraInput加入到会话\n      this.videoSession.addInput(this.cameraInput);\n      // 把previewOutput加入到会话\n      this.videoSession.addOutput(this.previewOutput);\n\n      this.videoSession.addOutput(this.videoOutput);\n\n      // 提交配置信息\n      await this.videoSession.commitConfig();\n\n      // hdr 录像\n      let hdrVideoBol: boolean = (this.globalContext.getObject('cameraConfig') as CameraConfig).hdrVideoBol;\n      Logger.info(TAG, 'hdrVideoBol:' + hdrVideoBol);\n\n      if (hdrVideoBol) {\n        let isSupportedVideoStabilization = this.isVideoStabilizationModeSupportedFn(camera.VideoStabilizationMode.HIGH);\n        if (isSupportedVideoStabilization) {\n          this.setVideoStabilizationMode(camera.VideoStabilizationMode.HIGH);\n          this.setColorSpace(this.videoSession, colorSpaceManager.ColorSpace.BT2020_HLG_LIMIT);\n        } else {\n          Logger.info(TAG, 'VideoStabilization not support');\n        }\n      } else {\n        this.setColorSpace(this.videoSession, colorSpaceManager.ColorSpace.BT709_LIMIT);\n      }\n\n      // 处理变焦条信息\n      try {\n        let range: Array<number> = this.videoSession.getZoomRatioRange();\n        Logger.info(TAG, `getZoomRatioRange:${range}`);\n        if (range) {\n          AppStorage.setOrCreate('zoomRatioMin', range[0]);\n          AppStorage.setOrCreate('zoomRatioMax', range[1]);\n        }\n      } catch (error) {\n        let err = error as BusinessError;\n        Logger.error(TAG, `getZoomRatioRange fail: error code ${err.code}`);\n      }\n\n      // 获取当前模式等效焦距\n      try {\n        let zoomPointInfo: Array<ZoomPointInfo> = this.videoSession.getZoomPointInfos();\n        if (zoomPointInfo) {\n          Logger.info(TAG, `getZoomPointInfos zoomRatio:${zoomPointInfo[0].zoomRatio} equivalentFocalLength:${zoomPointInfo[0].equivalentFocalLength}`);\n          AppStorage.setOrCreate('equivalentFocalLength', zoomPointInfo[0].equivalentFocalLength);\n        }\n      } catch (error) {\n        let err = error as BusinessError;\n        Logger.error(TAG, `getZoomPointInfos fail: error code ${err.code}`);\n      }\n\n      AppStorage.setOrCreate('colorEffectComponentIsHidden', this.getSupportedColorEffects().length > 0 ? false : true);\n      AppStorage.setOrCreate('deferredPhotoComponentIsHidden', false);\n      AppStorage.setOrCreate('moonCaptureComponentIsShow', false);\n\n      if (this.colorEffect) {\n        this.setColorEffect(this.colorEffect);\n      }\n\n      // 开始会话工作\n      await this.videoSession.start();\n\n      if (this.cameraMode === CameraMode.SUPER_STAB) {\n        let isSupported = this.isVideoStabilizationModeSupportedFn(camera.VideoStabilizationMode.HIGH);\n        if (isSupported) {\n          this.setVideoStabilizationMode(camera.VideoStabilizationMode.HIGH);\n        }\n      }\n      this.isFocusMode((this.globalContext.getObject('cameraConfig') as CameraConfig).focusMode);\n    } catch (error) {\n      let err = error as BusinessError;\n      Logger.error(TAG, `videoSessionFlowFn fail : ${JSON.stringify(err)}`);\n    }\n  }\n \n  async portraitSessionFlowFn(sceneModeIndex?: number): Promise<void> {\n    try {\n      // 创建PortraitSession实例\n      this.portraitSession = this.cameraManager.createSession(camera.SceneMode.PORTRAIT_PHOTO);\n      // 监听焦距的状态变化\n      this.onFocusStateChange();\n      // 监听能力值发生变化\n      this.onAbilityChange();\n      // 监听拍照会话的错误事件\n      this.onCaptureSessionErrorChange();\n      // 开始配置会话\n      this.portraitSession.beginConfig();\n      // 把CameraInput加入到会话\n      this.portraitSession.addInput(this.cameraInput);\n      // 把previewOutput加入到会话\n      this.portraitSession.addOutput(this.previewOutput);\n      // 把photoOutPut加入到会话\n      this.portraitSession.addOutput(this.photoOutPut);\n      if (this.captureMode === CaptureMode.NEW_DEFERRED_PHOTO) {\n        if (this.isDeferredImageDeliverySupported(camera.DeferredDeliveryImageType.PHOTO)) {\n          this.deferImageDeliveryFor(camera.DeferredDeliveryImageType.PHOTO);\n          this.isDeferredImageDeliveryEnabled(camera.DeferredDeliveryImageType.PHOTO);\n        }\n      }\n\n      // 提交配置信息\n      await this.portraitSession.commitConfig();\n\n      // 处理变焦条信息\n      try {\n        let range: Array<number> = this.portraitSession.getZoomRatioRange();\n        Logger.info(TAG, `getZoomRatioRange:${range}`);\n        if (range) {\n          AppStorage.setOrCreate('zoomRatioMin', range[0]);\n          AppStorage.setOrCreate('zoomRatioMax', range[1]);\n        }\n      } catch (error) {\n        let err = error as BusinessError;\n        Logger.error(TAG, `getZoomRatioRange fail: error code ${err.code}`);\n      }\n\n      this.setPortraitEffect();\n      const deviceType = AppStorage.get<string>('deviceType');\n      if (deviceType !== Constants.DEFAULT) {\n        AppStorage.setOrCreate('colorEffectComponentIsHidden', this.getSupportedColorEffects().length > 0 ? false : true);\n        if (this.colorEffect) {\n          this.setColorEffect(this.colorEffect);\n        }\n      }\n      // 开始会话工作\n      await this.portraitSession.start();\n      this.isFocusMode((this.globalContext.getObject('cameraConfig') as CameraConfig).focusMode);\n      Logger.info(TAG, 'portraitSessionFlowFn success');\n    } catch (error) {\n      let err = error as BusinessError;\n      Logger.error(TAG, `portraitSessionFlowFn fail : ${JSON.stringify(err)}`);\n    }\n  }\n\n  async nightSessionFlowFn(sceneModeIndex?: number): Promise<void> {\n    try {\n      // 创建PortraitSession实例\n      this.nightSession = this.cameraManager.createSession(camera.SceneMode.NIGHT_PHOTO);\n      // 监听焦距的状态变化\n      this.onFocusStateChange();\n      // 监听拍照会话的错误事件\n      this.onCaptureSessionErrorChange();\n      // 开始配置会话\n      this.nightSession.beginConfig();\n      // 把CameraInput加入到会话\n      this.nightSession.addInput(this.cameraInput);\n      // 把previewOutput加入到会话\n      this.nightSession.addOutput(this.previewOutput);\n      // 把photoOutPut加入到会话\n      this.nightSession.addOutput(this.photoOutPut);\n      if (this.captureMode === CaptureMode.NEW_DEFERRED_PHOTO) {\n        if (this.isDeferredImageDeliverySupported(camera.DeferredDeliveryImageType.PHOTO)) {\n          this.deferImageDeliveryFor(camera.DeferredDeliveryImageType.PHOTO);\n          this.isDeferredImageDeliveryEnabled(camera.DeferredDeliveryImageType.PHOTO);\n        }\n      }\n\n      // 提交配置信息\n      await this.nightSession.commitConfig();\n\n      // 处理变焦条信息\n      try {\n        let range: Array<number> = this.nightSession.getZoomRatioRange();\n        Logger.info(TAG, `getZoomRatioRange:${range}`);\n        if (range) {\n          AppStorage.setOrCreate('zoomRatioMin', range[0]);\n          AppStorage.setOrCreate('zoomRatioMax', range[1]);\n        }\n      } catch (error) {\n        let err = error as BusinessError;\n        Logger.error(TAG, `getZoomRatioRange fail: error code ${err.code}`);\n      }\n\n      const deviceType = AppStorage.get<string>('deviceType');\n      if (deviceType !== Constants.DEFAULT) {\n        AppStorage.setOrCreate('colorEffectComponentIsHidden', this.getSupportedColorEffects().length > 0 ? false : true);\n        if (this.colorEffect) {\n          this.setColorEffect(this.colorEffect);\n        }\n      }\n      // 开始会话工作\n      await this.nightSession.start();\n      this.isFocusMode((this.globalContext.getObject('cameraConfig') as CameraConfig).focusMode);\n      Logger.info(TAG, 'nightSessionFlowFn success');\n    } catch (error) {\n      let err = error as BusinessError;\n      Logger.error(TAG, `nightSessionFlowFn fail : ${JSON.stringify(err)}`);\n    }\n  }\n\n  async macroPhotoSessionFlowFn(sceneModeIndex?: number): Promise<void> {\n    Logger.info(TAG, `macroPhotoSessionFlowFn enter`);\n    try {\n      // 创建MacroPhotoSession实例\n      this.macroPhotoSession = this.cameraManager.createSession(camera.SceneMode.MACRO_PHOTO);\n      // 监听焦距的状态变化\n      this.onFocusStateChange();\n      // 监听拍照会话的错误事件\n      this.onCaptureSessionErrorChange();\n      // 开始配置会话\n      this.macroPhotoSession.beginConfig();\n      // 把CameraInput加入到会话\n      this.macroPhotoSession.addInput(this.cameraInput);\n      // 把previewOutput加入到会话\n      this.macroPhotoSession.addOutput(this.previewOutput);\n      // 把photoOutPut加入到会话\n      this.macroPhotoSession.addOutput(this.photoOutPut);\n      if (this.captureMode === CaptureMode.NEW_DEFERRED_PHOTO) {\n        if (this.isDeferredImageDeliverySupported(camera.DeferredDeliveryImageType.PHOTO)) {\n          this.deferImageDeliveryFor(camera.DeferredDeliveryImageType.PHOTO);\n          this.isDeferredImageDeliveryEnabled(camera.DeferredDeliveryImageType.PHOTO);\n        }\n      }\n\n      let isSketchSupported = this.previewOutput.isSketchSupported();\n      Logger.info(TAG, `isSketchSupported:${isSketchSupported}`);\n\n      // 提交配置信息\n      await this.macroPhotoSession.commitConfig();\n\n      // 处理变焦条信息\n      try {\n        let range: Array<number> = this.macroPhotoSession.getZoomRatioRange();\n        Logger.info(TAG, `getZoomRatioRange:${range}`);\n        if (range) {\n          AppStorage.setOrCreate('zoomRatioMin', range[0]);\n          AppStorage.setOrCreate('zoomRatioMax', range[1]);\n        }\n      } catch (error) {\n        let err = error as BusinessError;\n        Logger.error(TAG, `getZoomRatioRange fail: error code ${err.code}`);\n      }\n\n      const deviceType = AppStorage.get<string>('deviceType');\n      if (deviceType !== Constants.DEFAULT) {\n        AppStorage.setOrCreate('colorEffectComponentIsHidden', this.getSupportedColorEffects().length > 0 ? false : true);\n        if (this.colorEffect) {\n          this.setColorEffect(this.colorEffect);\n        }\n      }\n\n      // 开始会话工作\n      await this.macroPhotoSession.start();\n      this.isFocusMode((this.globalContext.getObject('cameraConfig') as CameraConfig).focusMode);\n      Logger.info(TAG, 'macroPhotoSessionFlowFn success');\n    } catch (error) {\n      let err = error as BusinessError;\n      Logger.error(TAG, `macroPhotoSessionFlowFn fail : ${JSON.stringify(err)}`);\n    }\n  }\n\n  setColorSpace(session: camera.PhotoSession | camera.VideoSession, colorSpace: colorSpaceManager.ColorSpace): void {\n    try {\n      let colorSpaces: Array<colorSpaceManager.ColorSpace> = session.getSupportedColorSpaces();\n      Logger.info(TAG, `supportedColorSpaces: ${JSON.stringify(colorSpaces)}`);\n      let isSupportedUseColorSpaces = colorSpaces.indexOf(colorSpace);\n      if (isSupportedUseColorSpaces) {\n        Logger.info(TAG, `setColorSpace: ${colorSpace}`);\n        session.setColorSpace(colorSpace);\n        Logger.info(TAG, `activeColorSpace: ${session.getActiveColorSpace()}`);\n        return;\n      }\n    } catch (error) {\n      let err = error as BusinessError;\n      Logger.error(TAG, `setColorSpace fail : ${JSON.stringify(err)}`);\n    }\n  }\n\n  setPortraitEffect(): void {\n    try {\n      this.portraitSession.setPortraitEffect(camera.PortraitEffect.CIRCLES);\n    } catch (error) {\n      let err = error as BusinessError;\n      Logger.error(TAG, `setPortraitEffect error code: ${err.code}`);\n    }\n    this.getPortraitEffect();\n  }\n\n  getPortraitEffect(): void {\n    try {\n      let portraitEffect = this.portraitSession.getPortraitEffect();\n      Logger.info(TAG, `getPortraitEffect portraitEffect: ${portraitEffect}`);\n    } catch (error) {\n      let err = error as BusinessError;\n      Logger.error(TAG, `setPortraitEffect error code: ${err.code}`);\n    }\n  }\n\n  setMoonCaptureBoostEnable(moonCaptureBoostEnable: Boolean): boolean {\n    Logger.info(TAG, 'moonCaptureBoostEnable is called.');\n    let session: camera.CaptureSession = this.getSession();\n    if (!session) {\n      return false;\n    }\n    try {\n      session.enableSceneFeature(camera.SceneFeatureType.MOON_CAPTURE_BOOST, moonCaptureBoostEnable);\n      AppStorage.setOrCreate<boolean>('moonCaptureComponentEnable', moonCaptureBoostEnable);\n    } catch (error) {\n      let err = error as BusinessError;\n      Logger.error(TAG, `setMoonCaptureBoostEnable fail: error code ${err.code}`);\n      return false;\n    }\n    return true;\n  }\n\n  setColorEffect(colorEffect: camera.ColorEffectType): void {\n    Logger.info(TAG, 'setColorEffect is called.');\n    if (this.photoSession || this.videoSession || this.portraitSession || this.nightSession) {\n      let res: Array<camera.ColorEffectType> | undefined = [];\n      res = this.getSupportedColorEffects();\n      let session: camera.PortraitPhotoSession | camera.CaptureSession | camera.NightPhotoSession = this.getSession();\n      if (!session) {\n        return;\n      }\n      for (let i = 0; i < res.length; i++) {\n        if (res[i] === colorEffect) {\n          Logger.info(TAG, 'setColorEffect success.');\n          session.setColorEffect(colorEffect);\n          this.colorEffect = colorEffect;\n          return;\n        }\n      }\n      Logger.error(TAG, `setColorEffect fail: The colorEffect ${colorEffect} was not found`);\n    }\n  }\n\n  getColorEffect(): camera.ColorEffectType | undefined {\n    Logger.info(TAG, 'getColorEffect is called.');\n    let colorEffect: camera.ColorEffectType | undefined = undefined;\n    let session: camera.PortraitPhotoSession | camera.CaptureSession | camera.NightPhotoSession = this.getSession();\n    if (!session) {\n      return colorEffect;\n    }\n    try {\n      colorEffect = session.getColorEffect();\n    } catch (error) {\n      let err = error as BusinessError;\n      Logger.error(TAG, `setColorEffect fail: error code ${err.code}`);\n    }\n    return colorEffect;\n  }\n\n  getSupportedColorEffects(): Array<camera.ColorEffectType> | undefined {\n    Logger.info(TAG, 'getSupportedColorEffects is called.');\n    let res: Array<camera.ColorEffectType> | undefined = [];\n    let session: camera.PortraitPhotoSession | camera.CaptureSession | camera.NightPhotoSession = this.getSession();\n    if (!session) {\n      return res;\n    }\n    res = session.getSupportedColorEffects();\n    Logger.info(TAG, `getSupportedColorEffects length: ${res.length}`);\n    return res;\n  }\n\n  /**\n   * 监听拍照事件\n   */\n  photoOutPutCallBack(): void {\n    // 监听拍照开始\n    this.photoOutPut.on('captureStart', (err: BusinessError, captureId: number): void => {\n      Logger.info(TAG, `photoOutPutCallBack captureStart captureId success: ${captureId}`);\n    });\n    // 监听拍照帧输出捕获\n    // 获取时间戳转化异常\n    this.photoOutPut.on('frameShutter', (err: BusinessError, frameShutterInfo: camera.FrameShutterInfo): void => {\n      Logger.info(TAG, `photoOutPutCallBack frameShutter captureId: ${frameShutterInfo.captureId}, timestamp: ${frameShutterInfo.timestamp}`);\n    });\n    // 监听拍照结束\n    this.photoOutPut.on('captureEnd', (err: BusinessError, captureEndInfo: camera.CaptureEndInfo): void => {\n      Logger.info(TAG, `photoOutPutCallBack captureEnd captureId: ${captureEndInfo.captureId}, frameCount: ${captureEndInfo.frameCount}`);\n    });\n    this.photoOutPut.on('error', (data: BusinessError): void => {\n      Logger.info(TAG, `photoOutPut data: ${JSON.stringify(data)}`);\n    });\n    this.photoOutPut.on('photoAvailable', (err: BusinessError, photo: camera.Photo): void => {\n      Logger.info(TAG, 'photoOutPutCallBack photoAvailable 3');\n      if (err) {\n        Logger.info(TAG, `photoAvailable error: ${JSON.stringify(err)}.`);\n        return;\n      }\n      let mainImage: image.Image = photo.main;\n      AppStorage.setOrCreate('mainImage', mainImage);\n      mainImage.getComponent(image.ComponentType.JPEG, (errCode: BusinessError, component: image.Component): void => {\n        Logger.debug(TAG, 'getComponent start');\n        Logger.info(TAG, `err: ${JSON.stringify(errCode)}`);\n        if (errCode || component === undefined) {\n          Logger.info(TAG, 'getComponent failed');\n          return;\n        }\n        let buffer: ArrayBuffer;\n        if (component.byteBuffer) {\n          buffer = component.byteBuffer;\n        } else {\n          Logger.error(TAG, 'component byteBuffer is undefined');\n        }\n        this.savePicture(buffer, mainImage);\n      });\n      photo.release();\n    });\n    this.photoOutPut.on('deferredPhotoProxyAvailable', (err: BusinessError, proxyObj: camera.DeferredPhotoProxy): void => {\n      if (err) {\n        Logger.info(TAG, `deferredPhotoProxyAvailable error: ${JSON.stringify(err)}.`);\n        return;\n      }\n      Logger.info(TAG, 'photoOutPutCallBack deferredPhotoProxyAvailable');\n      proxyObj.getThumbnail().then((thumbnail: image.PixelMap) => {\n        AppStorage.setOrCreate('proxyThumbnail', thumbnail);\n      });\n      this.saveDeferredPhoto(proxyObj);\n    });\n  }\n\n  /**\n   * 调用媒体库方式落盘缩略图\n   */\n  async saveDeferredPhoto(proxyObj: camera.DeferredPhotoProxy): Promise<void> {\n    try {\n      // 创建 photoAsset\n      let photoHelper = photoAccessHelper.getPhotoAccessHelper(this.globalContext.getCameraSettingContext());\n      let fileName = Date.now() + '.jpg';\n      let photoAsset = await photoHelper.createAsset(fileName);\n      let imgPhotoUri: string = photoAsset.uri;\n      // 将缩略图代理类传递给媒体库\n      let mediaRequest: photoAccessHelper.MediaAssetChangeRequest = new photoAccessHelper.MediaAssetChangeRequest(photoAsset);\n      mediaRequest.addResource(photoAccessHelper.ResourceType.PHOTO_PROXY, proxyObj);\n      let res = await photoHelper.applyChanges(mediaRequest);\n      this.handleTakePicture(imgPhotoUri);\n      Logger.info(TAG, `saveDeferredPhoto res:${res}.`);\n    } catch (err) {\n      Logger.error(TAG, `Failed to saveDeferredPhoto. error: ${JSON.stringify(err)}`);\n    }\n  }\n\n  /**\n   * 监听预览事件\n   */\n  previewOutputCallBack(): void {\n    Logger.info(TAG, 'previewOutputCallBack is called');\n    this.previewOutput.on('frameStart', (): void => {\n      Logger.debug(TAG, 'Preview frame started');\n    });\n    this.previewOutput.on('frameEnd', (): void => {\n      Logger.debug(TAG, 'Preview frame ended');\n    });\n    this.previewOutput.on('error', (previewOutputError: BusinessError): void => {\n      Logger.info(TAG, `Preview output previewOutputError: ${JSON.stringify(previewOutputError)}`);\n    });\n  }\n\n  /**\n   * 监听录像事件\n   */\n  onVideoOutputChange(): void {\n    this.videoOutput.on('frameStart', (): void => {\n      Logger.info(TAG, 'onVideoOutputChange frame started');\n    });\n    this.videoOutput.on('frameEnd', (): void => {\n      Logger.info(TAG, 'onVideoOutputChange frame frameEnd');\n    });\n    this.videoOutput.on('error', (videoOutputError: BusinessError) => {\n      Logger.error(TAG, `onVideoOutputChange fail: ${JSON.stringify(videoOutputError)}`);\n    });\n  }\n\n  /**\n   * 镜头状态回调\n   */\n  onCameraStatusChange(): void {\n    Logger.info(TAG, 'onCameraStatusChange is called');\n    this.cameraManager.on('cameraStatus', async (err: BusinessError, cameraStatusInfo: camera.CameraStatusInfo): Promise<void> => {\n      Logger.info(TAG, `onCameraStatusChange cameraStatus success, cameraId: ${cameraStatusInfo.camera.cameraId}, status: ${cameraStatusInfo.status}`);\n    });\n  }\n\n  /**\n   * 监听CameraInput的错误事件\n   */\n  onCameraInputChange(): void {\n    try {\n      this.cameraInput.on('error', this.cameras[(this.globalContext.getObject('cameraDeviceIndex') as number)], (cameraInputError: BusinessError): void => {\n        Logger.info(TAG, `onCameraInputChange cameraInput error code: ${cameraInputError.code}`);\n      });\n    } catch (error) {\n      Logger.info(TAG, `onCameraInputChange cameraInput occur error: error`);\n    }\n  }\n\n  /**\n   * 监听焦距的状态变化\n   */\n  onFocusStateChange(): void {\n    let session: camera.PortraitPhotoSession | camera.CaptureSession | camera.NightPhotoSession = this.getSession();\n    if (!session) {\n      return;\n    }\n    session.on('focusStateChange', (err: BusinessError, focusState: camera.FocusState): void => {\n      Logger.info(TAG, `onFocusStateChange captureSession focusStateChange success : ${focusState}`);\n    });\n  }\n\n  onAbilityChange(): void {\n    let session: camera.PortraitPhotoSession | camera.CaptureSession | camera.NightPhotoSession = this.getSession();\n    if (!session) {\n      return;\n    }\n    session.on('abilityChange', async (err: BusinessError): Promise<void> => {\n      let zoomRatioRange: Array<number> = session.getZoomRatioRange();\n      let isMacroSupported: bool = session.isMacroSupported();\n      Logger.info(TAG_AB, `call abilityChange  getZoomRatioRange:${zoomRatioRange[0]},${zoomRatioRange[1]} isMacroSupported:${isMacroSupported}`);\n    });\n  }\n  /**\n   * 监听拍照会话的错误事件\n   */\n  onCaptureSessionErrorChange(): void {\n    let session: camera.PortraitPhotoSession | camera.CaptureSession | camera.NightPhotoSession = this.getSession();\n    if (!session) {\n      return;\n    }\n    session.on('error', (captureSessionError: BusinessError): void => {\n      Logger.info(TAG, 'onCaptureSessionErrorChange captureSession fail: ' + JSON.stringify(captureSessionError.code));\n    });\n\n  }\n\n  setCaptureMode(mode: number): void {\n    this.captureMode = mode;\n  }\n\n  getCaptureMode(): number {\n    return this.captureMode;\n  }\n\n  /**\n   * 查询是否支持二阶段\n   */\n  isDeferredImageDeliverySupported(deferredType: camera.DeferredDeliveryImageType): boolean {\n    let res: boolean = this.photoOutPut.isDeferredImageDeliverySupported(deferredType);\n    Logger.info(TAG, `isDeferredImageDeliverySupported deferredType:${deferredType} res: ${res}`);\n    return res;\n  }\n\n  /**\n   * 查询是否已使能二阶段\n   */\n  isDeferredImageDeliveryEnabled(deferredType: camera.DeferredDeliveryImageType): boolean {\n    let res: boolean = this.photoOutPut.isDeferredImageDeliveryEnabled(deferredType);\n    Logger.info(TAG, `isDeferredImageDeliveryEnabled deferredType:${deferredType} res: ${res}`);\n  }\n\n  /**\n   * 使能二阶段\n   */\n  deferImageDeliveryFor(deferredType: camera.DeferredDeliveryImageType): void {\n    Logger.info(TAG, `deferImageDeliveryFor type: ${deferredType}`);\n    this.photoOutPut.deferImageDelivery(deferredType);\n  }\n\n  testAbilityFunction(): void {\n    if (this.cameraMode === CameraMode.PORTRAIT) {\n      Logger.info(TAG_AB, `portraitSession ability`);\n      let session: camera.PortraitPhotoSession = this.getSession();\n      this.logPortraitSession(session);\n    } else if (this.cameraMode === CameraMode.VIDEO) {\n      Logger.info(TAG_AB, `videoSession ability`);\n      let session: camera.VideoSession = this.getSession();\n      this.logVideoSession(session);\n    } else if (this.cameraMode === CameraMode.NORMAL) {\n      Logger.info(TAG_AB, `photoSession ability`);\n      let session: camera.PhotoSession = this.getSession();\n      this.logPhotoSession(session);\n    } else {\n      Logger.info(TAG, `not support ability`);\n    }\n  }\n  \n  logPortraitSession(session: camera.PortraitPhotoSession): void {\n    let list: Array<camera.PortraitPhotoConflictFunctions> = session.getSessionConflictFunctions();\n    list.forEach((conflictFunctions) => {\n      this.logPortraitPhotoConflictFunctions(conflictFunctions);\n    });\n    let cocList: Array<camera.CameraOutputCapability> = session.getCameraOutputCapabilities(this.cameras[(this.globalContext.getObject('cameraDeviceIndex') as number)]);\n    let coc: camera.CameraOutputCapability = cocList[0];\n    this.logCameraOutputCapabilities(coc);\n    if (coc) {\n      let functionsList: Array<camera.PortraitPhotoFunctions> = session.getSessionFunctions(coc);\n      functionsList.forEach((functions) => {\n        this.logPortraitPhotoFunctions(functions);\n      });\n    }\n  }\n  \n  logVideoSession(session: camera.VideoSession): void {\n    let list: Array<camera.PortraitPhotoFunctions> = session.getSessionConflictFunctions();\n    list.forEach((conflictFunctions) => {\n      let zoomRatioRange: Array<number> = conflictFunctions.getZoomRatioRange();\n      Logger.info(TAG_AB, `VideoConflictFunctions getZoomRatioRange:${zoomRatioRange[0]},${zoomRatioRange[1]}`);\n      let isMacroSupported: bool = conflictFunctions.isMacroSupported();\n      Logger.info(TAG_AB, `VideoConflictFunctions isMacroSupported:${isMacroSupported}`);\n    });\n    let cocList: Array<camera.CameraOutputCapability> = session.getCameraOutputCapabilities(this.cameras[(this.globalContext.getObject('cameraDeviceIndex') as number)]);\n    let coc: camera.CameraOutputCapability = cocList[0];\n    this.logCameraOutputCapabilities(coc);\n    if (coc) {\n      let functionsList: Array<camera.VideoFunctions> = session.getSessionFunctions(coc);\n      functionsList.forEach((functions) => {\n        this.logVideoFunctions(functions);\n      });\n    }\n  }\n  \n  logPhotoSession(session: camera.PhotoSession): void {\n    let list: Array<camera.PhotoConflictFunctions> = session.getSessionConflictFunctions();\n    list.forEach((conflictFunctions) => {\n      let zoomRatioRange: Array<number> = conflictFunctions.getZoomRatioRange();\n      Logger.info(TAG_AB, `PhotoConflictFunctions getZoomRatioRange:${zoomRatioRange[0]},${zoomRatioRange[1]}`);\n      let isMacroSupported: bool = conflictFunctions.isMacroSupported();\n      Logger.info(TAG_AB, `PhotoConflictFunctions isMacroSupported:${isMacroSupported}`);\n    });\n    let cocList: Array<camera.CameraOutputCapability> = session.getCameraOutputCapabilities(this.cameras[(this.globalContext.getObject('cameraDeviceIndex') as number)]);\n    let coc: camera.CameraOutputCapability = cocList[0];\n    this.logCameraOutputCapabilities(coc);\n    if (coc) {\n      let functionsList: Array<camera.PhotoFunctions> = session.getSessionFunctions(coc);\n      functionsList.forEach((functions) => {\n        this.logPhotoFunctions(functions);\n      });\n    }\n  }\n  \n  logPortraitPhotoFunctions(functions: camera.PortraitPhotoFunctions): void {\n    let hasFlash: bool = functions.hasFlash();\n    Logger.info(TAG_AB, `PortraitPhotoFunctions hasFlash:${hasFlash}`);\n    let isFlashModeSupported: bool = functions.isFlashModeSupported(camera.FlashMode.FLASH_MODE_CLOSE);\n    Logger.info(TAG_AB, `PortraitPhotoFunctions isFlashModeSupported:${isFlashModeSupported}`);\n    let isLcdFlashSupported: bool = functions.isLcdFlashSupported();\n    Logger.info(TAG_AB, `PortraitPhotoFunctions isLcdFlashSupported:${isLcdFlashSupported}`);\n    let isExposureModeSupported: bool = functions.isExposureModeSupported(camera.ExposureMode.EXPOSURE_MODE_LOCKED);\n    Logger.info(TAG_AB, `PortraitPhotoFunctions isExposureModeSupported:${isExposureModeSupported}`);\n    let exposureBiasRange: Array<number> = functions.getExposureBiasRange();\n    Logger.info(TAG_AB, `PortraitPhotoFunctions getExposureBiasRange:${exposureBiasRange[0]},${exposureBiasRange[1]}`);\n    let isFocusModeSupported: boolean = functions.isFocusModeSupported(camera.FocusMode.FOCUS_MODE_MANUAL);\n    Logger.info(TAG_AB, `PortraitPhotoFunctions isFocusModeSupported:${isFocusModeSupported}`);\n    let zoomRatioRange: Array<number> = functions.getZoomRatioRange();\n    Logger.info(TAG_AB, `PortraitPhotoFunctions getZoomRatioRange:${zoomRatioRange[0]},${zoomRatioRange[1]}`);\n    let beautyTypeList: Array<camera.BeautyType> = functions.getSupportedBeautyTypes();\n    Logger.info(TAG_AB, `PortraitPhotoFunctions getSupportedBeautyTypes:${beautyTypeList[0]},${beautyTypeList[1]}`);\n    let beautyRange: Array<number> = functions.getSupportedBeautyRange(beautyTypeList[0]);\n    Logger.info(TAG_AB, `PortraitPhotoFunctions getSupportedBeautyRange:${beautyRange[0]},${beautyRange[1]}`);\n    let colorEffectList: Array<camera.ColorEffectType> = functions.getSupportedColorEffects();\n    Logger.info(TAG_AB, `PortraitPhotoFunctions getSupportedColorEffects:${colorEffectList[0]},${colorEffectList[1]}`);\n    let colorSpacesList: Array<camera.colorSpaceManager.ColorSpace> = functions.getSupportedColorSpaces();\n    Logger.info(TAG_AB, `PortraitPhotoFunctions getSupportedColorSpaces:${colorSpacesList[0]},${colorSpacesList[1]}`);\n    let portraitEffectsList: Array<camera.PortraitEffect> = functions.getSupportedPortraitEffects();\n    Logger.info(TAG_AB, `PortraitPhotoFunctions getSupportedPortraitEffects:${portraitEffectsList[0]},${portraitEffectsList[1]}`);\n    let virtualAperturesList: Array<number> = functions.getSupportedVirtualApertures();\n    Logger.info(TAG_AB, `PortraitPhotoFunctions getSupportedVirtualApertures:${virtualAperturesList[0]},${virtualAperturesList[1]}`);\n    let physicalAperturesList: Array<camera.PhysicalAperture> = functions.getSupportedPhysicalApertures();\n    physicalAperturesList.forEach((physicalAperture) => {\n      Logger.info(TAG_AB, `PortraitPhotoFunctions PhysicalAperture: zoomRange${physicalAperture.zoomRange.min},${physicalAperture.zoomRange.max}`);\n      physicalAperture.apertures.forEach((aperture) => {\n        Logger.info(TAG_AB, `           with aperture: ${aperture} `);\n      });\n    });\n  }\n  \n  logVideoFunctions(functions: camera.VideoFunctions): void {\n    let hasFlash: bool = functions.hasFlash();\n    Logger.info(TAG_AB, `VideoFunctions hasFlash:${hasFlash}`);\n    let isFlashModeSupported: bool = functions.isFlashModeSupported(camera.FlashMode.FLASH_MODE_CLOSE);\n    Logger.info(TAG_AB, `VideoFunctions isFlashModeSupported:${isFlashModeSupported}`);\n    let isLcdFlashSupported: bool = functions.isLcdFlashSupported();\n    Logger.info(TAG_AB, `VideoFunctions isLcdFlashSupported:${isLcdFlashSupported}`);\n    let isExposureModeSupported: bool = functions.isExposureModeSupported(camera.ExposureMode.EXPOSURE_MODE_LOCKED);\n    Logger.info(TAG_AB, `VideoFunctions isExposureModeSupported:${isExposureModeSupported}`);\n    let exposureBiasRange: Array<number> = functions.getExposureBiasRange();\n    Logger.info(TAG_AB, `VideoFunctions getExposureBiasRange:${exposureBiasRange[0]},${exposureBiasRange[1]}`);\n    let isFocusModeSupported: boolean = functions.isFocusModeSupported(camera.FocusMode.FOCUS_MODE_MANUAL);\n    Logger.info(TAG_AB, `VideoFunctions isFocusModeSupported:${isFocusModeSupported}`);\n    let zoomRatioRange: Array<number> = functions.getZoomRatioRange();\n    Logger.info(TAG_AB, `VideoFunctions getZoomRatioRange:${zoomRatioRange[0]},${zoomRatioRange[1]}`);\n    let beautyTypeList: Array<camera.BeautyType> = functions.getSupportedBeautyTypes();\n    Logger.info(TAG_AB, `VideoFunctions getSupportedBeautyTypes:${beautyTypeList[0]},${beautyTypeList[1]}`);\n    let beautyRange: Array<number> = functions.getSupportedBeautyRange(beautyTypeList[0]);\n    Logger.info(TAG_AB, `VideoFunctions getSupportedBeautyRange:${beautyRange[0]},${beautyRange[1]}`);\n    let colorEffectList: Array<camera.ColorEffectType> = functions.getSupportedColorEffects();\n    Logger.info(TAG_AB, `VideoFunctions getSupportedColorEffects:${colorEffectList[0]},${colorEffectList[1]}`);\n    let colorSpacesList: Array<camera.colorSpaceManager.ColorSpace> = functions.getSupportedColorSpaces();\n    Logger.info(TAG_AB, `VideoFunctions getSupportedColorSpaces:${colorSpacesList[0]},${colorSpacesList[1]}`);\n    let isVideoStabilizationModeSupported: bool = functions.isVideoStabilizationModeSupported();\n    Logger.info(TAG_AB, `VideoFunctions isVideoStabilizationModeSupported:${isVideoStabilizationModeSupported}`);\n    let isMacroSupported: bool = functions.isMacroSupported();\n    Logger.info(TAG_AB, `VideoFunctions isMacroSupported:${isMacroSupported}`);\n  }\n  \n  logPhotoFunctions(functions: camera.PhotoFunctions): void {\n    let isMoonSupported: bool = functions.isSceneFeatureSupported(camera.SceneFeatureType.MOON_CAPTURE_BOOST);\n    Logger.info(TAG_AB, `PhotoFunctions isSceneFeatureSupported moon:${isMoonSupported}`);\n    let isTripodDetectionSupported: bool = functions.isSceneFeatureSupported(camera.SceneFeatureType.TRIPOD_DETECTION);\n    Logger.info(TAG_AB, `PhotoFunctions isSceneFeatureSupported tripod:${isTripodDetectionSupported}`);\n    let isLowLightSupported: bool = functions.isSceneFeatureSupported(camera.SceneFeatureType.LOW_LIGHT_BOOTST);\n    Logger.info(TAG_AB, `PhotoFunctions isSceneFeatureSupported lowlight:${isLowLightSupported}`);\n    let exposureRange: Array<number> = functions.getSupportedExposureRange();\n    Logger.info(TAG_AB, `PhotoFunctions getSupportedExposureRange size:${exposureRange.length}`);\n    let hasFlash: bool = functions.hasFlash();\n    Logger.info(TAG_AB, `PhotoFunctions hasFlash:${hasFlash}`);\n    let isFlashModeSupported: bool = functions.isFlashModeSupported(camera.FlashMode.FLASH_MODE_CLOSE);\n    Logger.info(TAG_AB, `PhotoFunctions isFlashModeSupported:${isFlashModeSupported}`);\n    let isLcdFlashSupported: bool = functions.isLcdFlashSupported();\n    Logger.info(TAG_AB, `PhotoFunctions isLcdFlashSupported:${isLcdFlashSupported}`);\n    let isExposureModeSupported: bool = functions.isExposureModeSupported(camera.ExposureMode.EXPOSURE_MODE_LOCKED);\n    Logger.info(TAG_AB, `PhotoFunctions isExposureModeSupported:${isExposureModeSupported}`);\n    let exposureBiasRange: Array<number> = functions.getExposureBiasRange();\n    Logger.info(TAG_AB, `PhotoFunctions getExposureBiasRange:${exposureBiasRange[0]},${exposureBiasRange[1]}`);\n    let isFocusModeSupported: boolean = functions.isFocusModeSupported(camera.FocusMode.FOCUS_MODE_MANUAL);\n    Logger.info(TAG_AB, `PhotoFunctions isFocusModeSupported:${isFocusModeSupported}`);\n    let zoomRatioRange: Array<number> = functions.getZoomRatioRange();\n    Logger.info(TAG_AB, `PhotoFunctions getZoomRatioRange:${zoomRatioRange[0]},${zoomRatioRange[1]}`);\n    let beautyTypeList: Array<camera.BeautyType> = functions.getSupportedBeautyTypes();\n    Logger.info(TAG_AB, `PhotoFunctions getSupportedBeautyTypes:${beautyTypeList[0]},${beautyTypeList[1]}`);\n    let beautyRange: Array<number> = functions.getSupportedBeautyRange(beautyTypeList[0]);\n    Logger.info(TAG_AB, `PhotoFunctions getSupportedBeautyRange:${beautyRange[0]},${beautyRange[1]}`);\n    let colorEffectList: Array<camera.ColorEffectType> = functions.getSupportedColorEffects();\n    Logger.info(TAG_AB, `PhotoFunctions getSupportedColorEffects:${colorEffectList[0]},${colorEffectList[1]}`);\n    let colorSpacesList: Array<camera.colorSpaceManager.ColorSpace> = functions.getSupportedColorSpaces();\n    Logger.info(TAG_AB, `PhotoFunctions getSupportedColorSpaces:${colorSpacesList[0]},${colorSpacesList[1]}`);\n    let isMacroSupported: bool = functions.isMacroSupported();\n    Logger.info(TAG_AB, `PhotoFunctions isMacroSupported:${isMacroSupported}`);\n  }\n\n  logPortraitPhotoConflictFunctions(conflictFunctions: camera.PortraitPhotoConflictFunctions): void {\n    let zoomRatioRange: Array<number> = conflictFunctions.getZoomRatioRange();\n    Logger.info(TAG_AB, `PortraitPhotoConflictFunctions getZoomRatioRange:${zoomRatioRange[0]},${zoomRatioRange[1]}`);\n    let portraitEffectsList: Array<camera.PortraitEffect> = conflictFunctions.getSupportedPortraitEffects();\n    Logger.info(TAG_AB, `PortraitPhotoConflictFunctions getSupportedPortraitEffects:${portraitEffectsList[0]},${portraitEffectsList[1]}`);\n    let virtualAperturesList: Array<number> = conflictFunctions.getSupportedVirtualApertures();\n    Logger.info(TAG_AB, `PortraitPhotoConflictFunctions getSupportedVirtualApertures:${virtualAperturesList[0]},${virtualAperturesList[1]}`);\n    let physicalAperturesList: Array<camera.PhysicalAperture> = conflictFunctions.getSupportedPhysicalApertures();\n    physicalAperturesList.forEach((physicalAperture) => {\n      Logger.info(TAG_AB, `PortraitPhotoConflictFunctions PhysicalAperture: zoomRange${physicalAperture.zoomRange.min},${physicalAperture.zoomRange.max}`);\n      physicalAperture.apertures.forEach((aperture) => {\n        Logger.info(TAG_AB, `           with aperture: ${aperture} `);\n      });\n    });\n  }\n  \n  logCameraOutputCapabilities(coc: camera.CameraOutputCapability): void {\n    let previewProfiles: Array<camera.Profile> = coc.previewProfiles;\n    Logger.info(TAG_AB, `getCameraOutputCapabilities previewProfiles: ${JSON.stringify(previewProfiles)}`);\n    let photoProfiles: Array<camera.Profile> = coc.photoProfiles;\n    Logger.info(TAG_AB, `getCameraOutputCapabilities photoProfiles: ${JSON.stringify(photoProfiles)}`);\n    let videoProfiles: Array<camera.VideoProfile> = coc.videoProfiles;\n    Logger.info(TAG_AB, `getCameraOutputCapabilities videoProfiles: ${JSON.stringify(videoProfiles)}`);\n  }\n}\n\nexport default new CameraService();", "llm_cg": {"CameraService.Constructor()": ["CameraService.%AM0$mockInterface()", "photoAccessHelper.getPhotoAccessHelper(any)", "image.createImageReceiver(any, any, any, any)"], "CameraService.savePicture(ArrayBuffer, Image)": ["photoAccessHelper.PhotoAccessHelper.createAsset(any)", "photoAccessHelper.PhotoAsset.open(any)", "fs.write(any, any)", "photoAccessHelper.PhotoAsset.close(any)", "CameraService.%AM1$handleTakePicture(any)"], "CameraService.switchProfiles(camera.CameraOutputCapability)": ["AppStorage.get(any)", "CameraService.%AM5$withinErrorMargin(any, any)", "AppStorage.get(any)", "CameraService.%AM6$withinErrorMargin(any, any)", "AppStorage.get(any)", "AppStorage.get(any)", "CameraService.%AM5$withinErrorMargin(any, any)", "CameraService.%AM5$withinErrorMargin(any, any)", "CameraService.%AM5$withinErrorMargin(any, any)", "CameraService.%AM1$switchProfiles(camera.CameraOutputCapability)"], "CameraService.initProfile(any)": ["CameraService.getCameraManagerFn()", "CameraService.getSupportedCamerasFn()", "CameraService.getModeManagerFn()", "CameraService.getSupportedModeFn(any)", "camera.CameraManager.getSupportedOutputCapability(any, any)", "CameraService.switchProfiles(camera.CameraOutputCapability)"], "CameraService.initCamera(any, any)": ["CameraService.releaseCamera()", "CameraService.getCameraManagerFn()", "Logger.debug(any, any)", "CameraService.getModeManagerFn()", "CameraService.getSupportedCamerasFn()", "CameraService.getSupportedModeFn(any)", "CameraService.initProfile(any)", "CameraService.createPreviewOutputFn(any, any)", "CameraService.previewOutputCallBack()", "CameraService.createAVRecorder()", "CameraService.createVideoOutput()", "CameraService.onVideoOutputChange()", "CameraService.mReceiver.getReceivingSurfaceId()", "CameraService.createPhotoOutputFn(any, any)", "CameraService.photoOutPutCallBack()", "CameraService.createCameraInputFn(any)", "CameraService.cameraInputOpenFn()", "CameraService.onCameraStatusChange()", "CameraService.onCameraInputChange()", "promise.all([CameraService.portraitSessionFlowFn(), CameraService.nightSessionFlowFn(), CameraService.macroPhotoSessionFlowFn(), CameraService.videoSessionFlowFn(), CameraService.photoSessionFlowFn()])"], "CameraService.takePicture(any)": ["CameraService.isMirrorSupportedFn()", "CameraService.onChangeRotation()", "CameraService.onChangeLocation()", "camera.PhotoOutput.capture(any)"], "CameraService.startVideo()": ["CameraService.videoOutput.start()", "CameraService.videoRecorder.start()"], "CameraService.stopVideo()": ["CameraService.videoRecorder.stop()", "CameraService.videoOutput.stop()", "photoAccessHelper.PhotoAsset.close(any)"], "CameraService.releaseCamera()": ["CameraService.stopVideo()", "CameraService.releaseVideoRecorder()", "CameraService.previewOutput.stop()", "CameraService.previewOutput.release()", "CameraService.photoOutPut.release()", "CameraService.videoOutput.release()", "CameraService.photoSession.release()", "CameraService.videoSession.release()", "CameraService.portraitSession.release()", "CameraService.nightSession.release()", "CameraService.cameraInput.close()"], "CameraService.photoSessionFlowFn()": ["camera.CaptureSession.beginConfig()", "camera.PhotoSession.addInput(any)", "camera.PhotoSession.addOutput(any)", "camera.PhotoSession.commitConfig()", "camera.CaptureSession.start()", "CameraService.configMoonCaptureBoost()", "CameraService.getSupportedColorEffects()", "CameraService.isFocusMode(any)"], "CameraService.videoSessionFlowFn()": ["camera.CaptureSession.beginConfig()", "camera.VideoSession.addInput(any)", "camera.VideoSession.addOutput(any)", "camera.VideoSession.commitConfig()", "camera.CaptureSession.start()", "CameraService.getSupportedColorEffects()", "CameraService.isFocusMode(any)"], "CameraService.portraitSessionFlowFn(any)": ["camera.CaptureSession.beginConfig()", "camera.PortraitPhotoSession.addInput(any)", "camera.PortraitPhotoSession.addOutput(any)", "camera.PortraitPhotoSession.commitConfig()", "camera.CaptureSession.start()", "CameraService.configMoonCaptureBoost()", "CameraService.getSupportedColorEffects()", "CameraService.isFocusMode(any)"], "CameraService.nightSessionFlowFn(any)": ["camera.CaptureSession.beginConfig()", "camera.NightPhotoSession.addInput(any)", "camera.NightPhotoSession.addOutput(any)", "camera.NightPhotoSession.commitConfig()", "camera.CaptureSession.start()", "CameraService.configMoonCaptureBoost()", "CameraService.getSupportedColorEffects()", "CameraService.isFocusMode(any)"], "CameraService.photoOutPutCallBack()": ["camera.PhotoOutput.on('imageArrival', () => {}])", "camera.PhotoOutput.on('photoAvailable', () => {}])", "camera.PhotoOutput.on('deferredPhotoProxyAvailable', () => {}])", "CameraService.testAbilityFunction()"], "CameraService.getCameraManagerFn()": ["camera.getCameraManager(any)"], "CameraService.getModeManagerFn()": ["camera.getCameraManager(any)"], "CameraService.getSupportedCamerasFn()": ["camera.CameraManager.getSupportedCameras()"], "CameraService.getSupportedModeFn(any)": ["camera.CameraManager.getSupportedSceneModes(any)"], "camera.CaptureSession.beginConfig()": ["camera.CaptureSession.beginConfig()"], "camera.PhotoSession.addInput(any)": ["camera.PhotoSession.addInput(any)"], "camera.PhotoSession.addOutput(any)": ["camera.PhotoSession.addOutput(any)"], "camera.PhotoSession.commitConfig()": ["camera.PhotoSession.commitConfig()"], "camera.CaptureSession.start()": ["camera.CaptureSession.start()"]}, "static_cg": {"@test/12.ts: %dflt.[static]%dflt()": ["@test/12.ts: CameraService.constructor()"], "@test/12.ts: CameraService.constructor()": ["@test/12.ts: %dflt.mockInterface()", "@test/12.ts: CameraService.%AM2$constructor()"], "@test/12.ts: CameraService.switchProfiles(camera.CameraOutputCapability)": ["@test/12.ts: CameraService.%AM5$switchProfiles(camera.Profile)", "@test/12.ts: CameraService.%AM6$switchProfiles(camera.Profile)", "@test/12.ts: CameraService.%AM7$switchProfiles(camera.Profile)", "@test/12.ts: CameraService.%AM8$switchProfiles(camera.Profile)", "@test/12.ts: CameraService.%AM9$switchProfiles(camera.VideoProfile)", "@test/12.ts: CameraService.withinErrorMargin(number, number)", "@test/12.ts: CameraService.%AM10$switchProfiles(camera.Profile)", "@test/12.ts: CameraService.%AM11$switchProfiles(camera.Profile)"], "@test/12.ts: CameraService.initProfile(number)": ["@test/12.ts: CameraService.switchProfiles(camera.CameraOutputCapability)"], "@test/12.ts: CameraService.initCamera(string, number)": ["@test/12.ts: CameraService.releaseCamera()", "@test/12.ts: CameraService.getCameraManagerFn()", "@test/12.ts: CameraService.getModeManagerFn()", "@test/12.ts: CameraService.getSupportedCamerasFn()", "@test/12.ts: CameraService.getSupportedModeFn(number)", "@test/12.ts: CameraService.initProfile(number)", "@test/12.ts: CameraService.createPreviewOutputFn(camera.Profile, string)", "@test/12.ts: CameraService.previewOutputCallBack()", "@test/12.ts: CameraService.createAVRecorder()", "@test/12.ts: CameraService.createVideoOutput()", "@test/12.ts: CameraService.onVideoOutputChange()", "@test/12.ts: CameraService.createPhotoOutputFn(camera.Profile, string)", "@test/12.ts: CameraService.photoOutPutCallBack()", "@test/12.ts: CameraService.createCameraInputFn(camera.CameraDevice)", "@test/12.ts: CameraService.cameraInputOpenFn()", "@test/12.ts: CameraService.onCameraStatusChange()", "@test/12.ts: CameraService.onCameraInputChange()", "@test/12.ts: CameraService.portraitSessionFlowFn(number)", "@test/12.ts: CameraService.nightSessionFlowFn(number)", "@test/12.ts: CameraService.macroPhotoSessionFlowFn(number)", "@test/12.ts: CameraService.videoSessionFlowFn()", "@test/12.ts: CameraService.photoSessionFlowFn()", "@test/12.ts: CameraService.testAbilityFunction()"], "@test/12.ts: CameraService.isVideoFrameSupportedFn(number)": ["@test/12.ts: CameraService.%AM12$isVideoFrameSupportedFn([videoFrame], camera.VideoProfile)"], "@test/12.ts: CameraService.isExposureModeSupportedFn(camera.ExposureMode)": ["@test/12.ts: CameraService.getSession()"], "@test/12.ts: CameraService.setExposureMode(camera.ExposureMode)": ["@test/12.ts: CameraService.getSession()"], "@test/12.ts: CameraService.isMeteringPoint(camera.Point)": ["@test/12.ts: CameraService.getSession()"], "@test/12.ts: CameraService.isExposureBiasRange(number)": ["@test/12.ts: CameraService.getSession()"], "@test/12.ts: CameraService.isFocusModeSupported(camera.FocusMode)": ["@test/12.ts: CameraService.getSession()"], "@test/12.ts: CameraService.isFocusMode(camera.FocusMode)": ["@test/12.ts: CameraService.isFocusModeSupported(camera.FocusMode)", "@test/12.ts: CameraService.getSession()"], "@test/12.ts: CameraService.isFocusPoint(camera.Point)": ["@test/12.ts: CameraService.getSession()"], "@test/12.ts: CameraService.hasFlashFn(camera.FlashMode)": ["@test/12.ts: CameraService.getSession()"], "@test/12.ts: CameraService.setZoomRatioFn(number)": ["@test/12.ts: CameraService.getSession()"], "@test/12.ts: CameraService.isVideoStabilizationModeSupportedFn(camera.VideoStabilizationMode)": ["@test/12.ts: CameraService.getSession()"], "@test/12.ts: CameraService.setVideoStabilizationMode(camera.VideoStabilizationMode)": ["@test/12.ts: CameraService.getSession()"], "@test/12.ts: CameraService.takePicture(boolean)": ["@test/12.ts: CameraService.isMirrorSupportedFn()"], "@test/12.ts: CameraService.prepareAVRecorder()": ["@test/12.ts: CameraService.initUrl()", "@test/12.ts: CameraService.%AM13$prepareAVRecorder(@test/12.ts: %AC$29)"], "@test/12.ts: CameraService.createVideoOutput()": ["@test/12.ts: CameraService.prepareAVRecorder()", "@test/12.ts: CameraService.getAVRecorderSurfaceId()"], "@test/12.ts: CameraService.pauseVideo()": ["@test/12.ts: CameraService.%AM15$pauseVideo()", "@test/12.ts: CameraService.%AM14$pauseVideo(BusinessError)"], "@test/12.ts: CameraService.resumeVideo()": ["@test/12.ts: CameraService.%AM16$resumeVideo()"], "@test/12.ts: CameraService.startVideo()": ["@test/12.ts: CameraService.prepareAVRecorder()", "@test/12.ts: CameraService.getAVRecorderSurfaceId()"], "@test/12.ts: CameraService.releaseCamera()": ["@test/12.ts: CameraService.stopVideo()", "@test/12.ts: CameraService.releaseVideoRecorder()"], "@test/12.ts: CameraService.configMoonCaptureBoost()": ["@test/12.ts: CameraService.%AM19$configMoonCaptureBoost(unknown, unknown)"], "@test/12.ts: CameraService.photoSessionFlowFn()": ["@test/12.ts: CameraService.onFocusStateChange()", "@test/12.ts: CameraService.onCaptureSessionErrorChange()", "@test/12.ts: CameraService.setColorSpace(camera.PhotoSession|camera.VideoSession, colorSpaceManager.ColorSpace)", "@test/12.ts: CameraService.isDeferredImageDeliverySupported(camera.DeferredDeliveryImageType)", "@test/12.ts: CameraService.deferImageDeliveryFor(camera.DeferredDeliveryImageType)", "@test/12.ts: CameraService.isDeferredImageDeliveryEnabled(camera.DeferredDeliveryImageType)", "@test/12.ts: CameraService.setColorEffect(camera.ColorEffectType)", "@test/12.ts: CameraService.isVideoStabilizationModeSupportedFn(camera.VideoStabilizationMode)", "@test/12.ts: CameraService.setVideoStabilizationMode(camera.VideoStabilizationMode)", "@test/12.ts: CameraService.isFocusMode(camera.FocusMode)", "@test/12.ts: CameraService.configMoonCaptureBoost()", "@test/12.ts: CameraService.getSupportedColorEffects()"], "@test/12.ts: CameraService.videoSessionFlowFn()": ["@test/12.ts: CameraService.onFocusStateChange()", "@test/12.ts: CameraService.onCaptureSessionErrorChange()", "@test/12.ts: CameraService.isVideoStabilizationModeSupportedFn(camera.VideoStabilizationMode)", "@test/12.ts: CameraService.setVideoStabilizationMode(camera.VideoStabilizationMode)", "@test/12.ts: CameraService.setColorSpace(camera.PhotoSession|camera.VideoSession, colorSpaceManager.ColorSpace)", "@test/12.ts: CameraService.setColorEffect(camera.ColorEffectType)", "@test/12.ts: CameraService.isFocusMode(camera.FocusMode)", "@test/12.ts: CameraService.getSupportedColorEffects()"], "@test/12.ts: CameraService.portraitSessionFlowFn(number)": ["@test/12.ts: CameraService.onFocusStateChange()", "@test/12.ts: CameraService.onAbilityChange()", "@test/12.ts: CameraService.onCaptureSessionErrorChange()", "@test/12.ts: CameraService.isDeferredImageDeliverySupported(camera.DeferredDeliveryImageType)", "@test/12.ts: CameraService.deferImageDeliveryFor(camera.DeferredDeliveryImageType)", "@test/12.ts: CameraService.isDeferredImageDeliveryEnabled(camera.DeferredDeliveryImageType)", "@test/12.ts: CameraService.setPortraitEffect()", "@test/12.ts: CameraService.setColorEffect(camera.ColorEffectType)", "@test/12.ts: CameraService.isFocusMode(camera.FocusMode)", "@test/12.ts: CameraService.getSupportedColorEffects()"], "@test/12.ts: CameraService.nightSessionFlowFn(number)": ["@test/12.ts: CameraService.onFocusStateChange()", "@test/12.ts: CameraService.onCaptureSessionErrorChange()", "@test/12.ts: CameraService.isDeferredImageDeliverySupported(camera.DeferredDeliveryImageType)", "@test/12.ts: CameraService.deferImageDeliveryFor(camera.DeferredDeliveryImageType)", "@test/12.ts: CameraService.isDeferredImageDeliveryEnabled(camera.DeferredDeliveryImageType)", "@test/12.ts: CameraService.setColorEffect(camera.ColorEffectType)", "@test/12.ts: CameraService.isFocusMode(camera.FocusMode)", "@test/12.ts: CameraService.getSupportedColorEffects()"], "@test/12.ts: CameraService.macroPhotoSessionFlowFn(number)": ["@test/12.ts: CameraService.onFocusStateChange()", "@test/12.ts: CameraService.onCaptureSessionErrorChange()", "@test/12.ts: CameraService.isDeferredImageDeliverySupported(camera.DeferredDeliveryImageType)", "@test/12.ts: CameraService.deferImageDeliveryFor(camera.DeferredDeliveryImageType)", "@test/12.ts: CameraService.isDeferredImageDeliveryEnabled(camera.DeferredDeliveryImageType)", "@test/12.ts: CameraService.setColorEffect(camera.ColorEffectType)", "@test/12.ts: CameraService.isFocusMode(camera.FocusMode)", "@test/12.ts: CameraService.getSupportedColorEffects()"], "@test/12.ts: CameraService.setPortraitEffect()": ["@test/12.ts: CameraService.getPortraitEffect()"], "@test/12.ts: CameraService.setMoonCaptureBoostEnable(Boolean)": ["@test/12.ts: CameraService.getSession()"], "@test/12.ts: CameraService.setColorEffect(camera.ColorEffectType)": ["@test/12.ts: CameraService.getSupportedColorEffects()", "@test/12.ts: CameraService.getSession()"], "@test/12.ts: CameraService.getColorEffect()": ["@test/12.ts: CameraService.getSession()"], "@test/12.ts: CameraService.getSupportedColorEffects()": ["@test/12.ts: CameraService.getSession()"], "@test/12.ts: CameraService.photoOutPutCallBack()": ["@test/12.ts: CameraService.%AM20$photoOutPutCallBack(BusinessError, number)", "@test/12.ts: CameraService.%AM21$photoOutPutCallBack(BusinessError, camera.FrameShutterInfo)", "@test/12.ts: CameraService.%AM22$photoOutPutCallBack(BusinessError, camera.CaptureEndInfo)", "@test/12.ts: CameraService.%AM23$photoOutPutCallBack(BusinessError)", "@test/12.ts: CameraService.%AM24$photoOutPutCallBack(BusinessError, camera.Photo)", "@test/12.ts: CameraService.%AM26$photoOutPutCallBack(BusinessError, camera.DeferredPhotoProxy)"], "@test/12.ts: CameraService.previewOutputCallBack()": ["@test/12.ts: CameraService.%AM28$previewOutputCallBack()", "@test/12.ts: CameraService.%AM29$previewOutputCallBack()", "@test/12.ts: CameraService.%AM30$previewOutputCallBack(BusinessError)"], "@test/12.ts: CameraService.onVideoOutputChange()": ["@test/12.ts: CameraService.%AM31$onVideoOutputChange()", "@test/12.ts: CameraService.%AM32$onVideoOutputChange()", "@test/12.ts: CameraService.%AM33$onVideoOutputChange(BusinessError)"], "@test/12.ts: CameraService.onCameraStatusChange()": ["@test/12.ts: CameraService.%AM34$onCameraStatusChange(BusinessError, camera.CameraStatusInfo)"], "@test/12.ts: CameraService.onCameraInputChange()": ["@test/12.ts: CameraService.%AM35$onCameraInputChange(BusinessError)"], "@test/12.ts: CameraService.onFocusStateChange()": ["@test/12.ts: CameraService.getSession()", "@test/12.ts: CameraService.%AM36$onFocusStateChange(BusinessError, camera.FocusState)"], "@test/12.ts: CameraService.onAbilityChange()": ["@test/12.ts: CameraService.getSession()", "@test/12.ts: CameraService.%AM37$onAbilityChange([session], BusinessError)"], "@test/12.ts: CameraService.onCaptureSessionErrorChange()": ["@test/12.ts: CameraService.getSession()", "@test/12.ts: CameraService.%AM38$onCaptureSessionErrorChange(BusinessError)"], "@test/12.ts: CameraService.testAbilityFunction()": ["@test/12.ts: CameraService.getSession()", "@test/12.ts: CameraService.logPortraitSession(camera.PortraitPhotoSession)", "@test/12.ts: CameraService.logVideoSession(camera.VideoSession)", "@test/12.ts: CameraService.logPhotoSession(camera.PhotoSession)"], "@test/12.ts: CameraService.logPortraitSession(camera.PortraitPhotoSession)": ["@test/12.ts: CameraService.%AM39$logPortraitSession(unknown)", "@test/12.ts: CameraService.logCameraOutputCapabilities(camera.CameraOutputCapability)", "@test/12.ts: CameraService.%AM40$logPortraitSession(unknown)"], "@test/12.ts: CameraService.logVideoSession(camera.VideoSession)": ["@test/12.ts: CameraService.%AM41$logVideoSession(unknown)", "@test/12.ts: CameraService.logCameraOutputCapabilities(camera.CameraOutputCapability)", "@test/12.ts: CameraService.%AM42$logVideoSession(unknown)"], "@test/12.ts: CameraService.logPhotoSession(camera.PhotoSession)": ["@test/12.ts: CameraService.%AM43$logPhotoSession(unknown)", "@test/12.ts: CameraService.logCameraOutputCapabilities(camera.CameraOutputCapability)", "@test/12.ts: CameraService.%AM44$logPhotoSession(unknown)"], "@test/12.ts: CameraService.logPortraitPhotoFunctions(camera.PortraitPhotoFunctions)": ["@test/12.ts: CameraService.%AM45$logPortraitPhotoFunctions(unknown)"], "@test/12.ts: CameraService.logPortraitPhotoConflictFunctions(camera.PortraitPhotoConflictFunctions)": ["@test/12.ts: CameraService.%AM47$logPortraitPhotoConflictFunctions(unknown)"], "@test/12.ts: CameraService.%AM4$%AM3$%AM2$constructor(BusinessError, image.Component)": ["@test/12.ts: CameraService.savePicture(ArrayBuffer, image.Image)"], "@test/12.ts: CameraService.%AM3$%AM2$constructor(BusinessError, image.Image)": ["@test/12.ts: CameraService.%AM4$%AM3$%AM2$constructor(BusinessError, image.Component)"], "@test/12.ts: CameraService.%AM2$constructor()": ["@test/12.ts: CameraService.%AM3$%AM2$constructor(BusinessError, image.Image)"], "@test/12.ts: CameraService.%AM16$resumeVideo()": ["@test/12.ts: CameraService.%AM18$%AM16$resumeVideo()", "@test/12.ts: CameraService.%AM17$%AM16$resumeVideo(@test/12.ts: %AC$30)"], "@test/12.ts: CameraService.%AM19$configMoonCaptureBoost(unknown, unknown)": ["@test/12.ts: CameraService.setMoonCaptureBoostEnable(Boolean)"], "@test/12.ts: CameraService.%AM25$%AM24$photoOutPutCallBack(BusinessError, image.Component)": ["@test/12.ts: CameraService.savePicture(ArrayBuffer, image.Image)"], "@test/12.ts: CameraService.%AM24$photoOutPutCallBack(BusinessError, camera.Photo)": ["@test/12.ts: CameraService.%AM25$%AM24$photoOutPutCallBack(BusinessError, image.Component)"], "@test/12.ts: CameraService.%AM26$photoOutPutCallBack(BusinessError, camera.DeferredPhotoProxy)": ["@test/12.ts: CameraService.%AM27$%AM26$photoOutPutCallBack(image.PixelMap)", "@test/12.ts: CameraService.saveDeferredPhoto(camera.DeferredPhotoProxy)"], "@test/12.ts: CameraService.%AM39$logPortraitSession(unknown)": ["@test/12.ts: CameraService.logPortraitPhotoConflictFunctions(camera.PortraitPhotoConflictFunctions)"], "@test/12.ts: CameraService.%AM40$logPortraitSession(unknown)": ["@test/12.ts: CameraService.logPortraitPhotoFunctions(camera.PortraitPhotoFunctions)"], "@test/12.ts: CameraService.%AM42$logVideoSession(unknown)": ["@test/12.ts: CameraService.logVideoFunctions(camera.VideoFunctions)"], "@test/12.ts: CameraService.%AM44$logPhotoSession(unknown)": ["@test/12.ts: CameraService.logPhotoFunctions(camera.PhotoFunctions)"], "@test/12.ts: CameraService.%AM45$logPortraitPhotoFunctions(unknown)": ["@test/12.ts: CameraService.%AM46$%AM45$logPortraitPhotoFunctions(unknown)"], "@test/12.ts: CameraService.%AM47$logPortraitPhotoConflictFunctions(unknown)": ["@test/12.ts: CameraService.%AM48$%AM47$logPortraitPhotoConflictFunctions(unknown)"]}}
{"source_code": "/*\n * Copyright (c) 2023 Huawei Device Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @file 日期工具\n */\nexport default class DateTimeUtil {\n\n  /**\n   * 时分秒\n   */\n  getTime(): string {\n    const DATETIME = new Date();\n    return this.concatTime(DATETIME.getHours(), DATETIME.getMinutes(), DATETIME.getSeconds());\n  }\n\n  /**\n   * 年月日\n   */\n  getDate(): string {\n    const DATETIME = new Date();\n    return this.concatDate(DATETIME.getFullYear(), DATETIME.getMonth() + 1, DATETIME.getDate());\n  }\n\n  /**\n   * 日期不足两位补充0\n   * @param value-数据值\n   */\n  fill(value: number): string {\n    let maxNumber = 9;\n    return (value > maxNumber ? '' : '0') + value;\n  }\n  /**\n   * 录制时间定时器\n   * @param millisecond-数据值\n   */\n  getVideoTime(millisecond: number): string {\n    let millisecond2minute = 60000;\n    let millisecond2second = 1000;\n    let minute = Math.floor(millisecond / millisecond2minute);\n    let second = Math.floor((millisecond - minute * millisecond2minute) / millisecond2second);\n    return `${this.fill(minute)} : ${this.fill(second)}`;\n  }\n  /**\n   * 年月日格式修饰\n   * @param year\n   * @param month\n   * @param date\n   */\n  concatDate(year: number, month: number, date: number): string {\n    return `${year}${this.fill(month)}${this.fill(date)}`;\n  }\n\n  /**\n   * 时分秒格式修饰\n   * @param hours\n   * @param minutes\n   * @param seconds\n   */\n  concatTime(hours: number, minutes: number, seconds: number): string {\n    return `${this.fill(hours)}${this.fill(minutes)}${this.fill(seconds)}`;\n  }\n}", "llm_cg": {"DateTimeUtil.getTime()": ["DateTimeUtil.concatTime(unknown, unknown, unknown)"], "DateTimeUtil.getDate()": ["DateTimeUtil.concatDate(unknown, unknown, unknown)"], "DateTimeUtil.getVideoTime(millisecond)": ["DateTimeUtil.fill(unknown)", "DateTimeUtil.fill(unknown)"], "DateTimeUtil.concatDate(year, month, date)": ["DateTimeUtil.fill(unknown)", "DateTimeUtil.fill(unknown)"], "DateTimeUtil.concatTime(hours, minutes, seconds)": ["DateTimeUtil.fill(unknown)", "DateTimeUtil.fill(unknown)", "DateTimeUtil.fill(unknown)"]}, "static_cg": {"@test/13.ts: DateTimeUtil.getTime()": ["@test/13.ts: DateTimeUtil.concatTime(number, number, number)"], "@test/13.ts: DateTimeUtil.getDate()": ["@test/13.ts: DateTimeUtil.concatDate(number, number, number)"], "@test/13.ts: DateTimeUtil.getVideoTime(number)": ["@test/13.ts: DateTimeUtil.fill(number)"], "@test/13.ts: DateTimeUtil.concatDate(number, number, number)": ["@test/13.ts: DateTimeUtil.fill(number)"], "@test/13.ts: DateTimeUtil.concatTime(number, number, number)": ["@test/13.ts: DateTimeUtil.fill(number)"]}}
{"source_code": "/*\n * Copyright (c) 2023 Huawei Device Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport AbilityStage from '@ohos.app.ability.AbilityStage';\nimport Logger from '../model/Logger';\n\nconst TAG: string = 'MyAbilityStage';\n\nexport default class MyAbilityStage extends AbilityStage {\n  async onCreate(): Promise<void> {\n    Logger.info(TAG, 'AbilityStage onCreate');\n  }\n}", "llm_cg": {"MyAbilityStage.onCreate()": []}, "static_cg": {}}
{"source_code": "/*\n * Copyright (c) 2023 Huawei Device Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Ability from '@ohos.app.ability.UIAbility';\nimport type Want from '@ohos.app.ability.Want';\nimport type AbilityConstant from '@ohos.app.ability.AbilityConstant';\nimport type Window from '@ohos.window';\nimport Logger from '../model/Logger';\n\nconst TAG: string = 'MainAbility';\n\nexport default class MainAbility extends Ability {\n  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {\n    Logger.info(TAG, 'Ability onCreate');\n    Logger.debug(TAG, `want param: ${JSON.stringify(want)}`);\n    Logger.debug(TAG, `launchParam: ${JSON.stringify(launchParam)}`);\n  }\n\n  onDestroy(): void {\n    Logger.info(TAG, 'Ability onDestroy');\n  }\n\n  onWindowStageCreate(windowStage: Window.WindowStage): void {\n    // Main window is created, set main page for this ability\n    Logger.info(TAG, 'Ability onWindowStageCreate');\n    windowStage.getMainWindow().then((win: Window.Window): void => {\n      win.setWindowLayoutFullScreen(true).then((): void => {\n        win.setWindowSystemBarEnable(['navigation']).then((): void => {\n        });\n      });\n      win.setWindowSystemBarProperties({\n        navigationBarColor: '#00000000',\n        navigationBarContentColor: '#B3B3B3'\n      }).then((): void => {\n      });\n    })\n    this.onLoadContent(windowStage, 'pages/Index');\n  }\n\n  onLoadContent(windowStage: Window.WindowStage, page: string): void {\n    windowStage.loadContent(page, (): void => {\n    });\n\n  }\n\n  onWindowStageDestroy(): void {\n    // Main window is destroyed, release UI related resources\n    Logger.info(TAG, 'Ability onWindowStageDestroy');\n  }\n\n  onForeground(): void {\n    // Ability has brought to foreground\n    Logger.info(TAG, 'Ability onForeground');\n  }\n\n  onBackground(): void {\n    // Ability has back to background\n    Logger.info(TAG, 'Ability onBackground');\n  }\n}\n", "llm_cg": {"MainAbility.onCreate(Want, AbilityConstant.LaunchParam)": ["Logger.info(string, string)", "Logger.debug(string, string)", "Logger.debug(string, string)"], "MainAbility.onDestroy()": ["Logger.info(string, string)"], "MainAbility.onWindowStageCreate(Window.WindowStage)": ["Logger.info(string, string)", "Window.WindowStage.getMainWindow()", "Window.Window.setWindowLayoutFullScreen(boolean)", "Window.Window.setWindowSystemBarEnable(string[])", "Window.Window.setWindowSystemBarProperties(Window.SystemBarProperties)", "MainAbility.onLoadContent(Window.WindowStage, string)"], "MainAbility.onLoadContent(Window.WindowStage, string)": ["Window.WindowStage.loadContent(string, Function)"], "MainAbility.onWindowStageDestroy()": ["Logger.info(string, string)"], "MainAbility.onForeground()": ["Logger.info(string, string)"], "MainAbility.onBackground()": ["Logger.info(string, string)"]}, "static_cg": {"@test/15.ts: MainAbility.onWindowStageCreate(Window.WindowStage)": ["@test/15.ts: MainAbility.%AM0$onWindowStageCreate(Window.Window)", "@test/15.ts: MainAbility.onLoadContent(Window.WindowStage, string)"], "@test/15.ts: MainAbility.onLoadContent(Window.WindowStage, string)": ["@test/15.ts: MainAbility.%AM4$onLoadContent()"], "@test/15.ts: MainAbility.%AM1$%AM0$onWindowStageCreate()": ["@test/15.ts: MainAbility.%AM2$%AM1$%AM0$onWindowStageCreate()"], "@test/15.ts: MainAbility.%AM0$onWindowStageCreate(Window.Window)": ["@test/15.ts: MainAbility.%AM1$%AM0$onWindowStageCreate()", "@test/15.ts: MainAbility.%AM3$%AM0$onWindowStageCreate()"]}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport UIAbility from '@ohos.app.ability.UIAbility';\nimport window from '@ohos.window';\nimport deviceInfo from '@ohos.deviceInfo';\nimport Ability from '@ohos.app.ability.UIAbility';\nimport wantConstant from '@ohos.ability.wantConstant';\nimport { Log } from '../utils/Log';\nimport { screenManager } from '../common/ScreenManager';\nimport { Constants } from '../constants/Constants';\nimport { broadcastManager } from '../common/BroadcastManager';\nimport { BroadcastConstants } from '../constants/BroadcastConstants';\nimport { userFileModel } from '../base/UserFileModel';\nimport router from '@system.router';\nimport { RouterOptions } from '@system.router';\nimport { GroupItemDataSource } from '../common/GroupItemDataSource';\nimport atManager from '@ohos.abilityAccessCtrl';\nimport bundleManager from '@ohos.bundle.bundleManager';\nimport { MediaConstants } from '../constants/MediaConstants';\nimport { getResourceString } from '../utils/ResourceUtils';\nimport { GlobalContext } from '../common/GlobalContext';\nimport Want from '@ohos.app.ability.Want';\n\nlet mCallerUid: number = 0;\nlet mMaxSelectCount: number = 0;\nlet mFilterMediaType: number = MediaConstants.SELECT_TYPE_ALL;\nlet appBroadcast = broadcastManager.getBroadcast();\nlet pagePath: string = 'pages/Index';\n\nexport default class EntryAbility extends UIAbility {\n  private TAG: string = 'EntryAbility';\n  private static readonly RETRY_MAX_TIMES = 100;\n  private static readonly ACTION_URI_SINGLE_SELECT = 'singleselect';\n  private static readonly ACTION_URI_MULTIPLE_SELECT = 'multipleselect';\n  private static readonly ACTION_URI_PHOTO_DETAIL = 'photodetail';\n  private browserDataSource: GroupItemDataSource = new GroupItemDataSource();\n\n  onCreate(want: Want, launchParam): void {\n    Log.info(this.TAG, 'Application onCreate');\n    // Ability is creating, initialize resources for this ability\n    GlobalContext.getContext().setObject('appContext', this.context);\n    userFileModel.onCreate(this.context);\n    mFilterMediaType = MediaConstants.SELECT_TYPE_ALL;\n    AppStorage.SetOrCreate<number>(Constants.ENTRY_FROM_HAP, Constants.ENTRY_FROM_NONE);\n    Log.info(this.TAG, 'Application onCreate end');\n  }\n\n  onNewWant(want: Want): void {\n    AppStorage.SetOrCreate<number>(Constants.ENTRY_FROM_HAP, Constants.ENTRY_FROM_NONE);\n  }\n\n  onDestroy(): void {\n    // Ability is creating, release resources for this ability\n    Log.info(this.TAG, 'Application onDestroy');\n    AppStorage.Delete(Constants.ENTRY_FROM_HAP);\n  }\n\n  onWindowStageCreate(windowStage): void {\n    // Main window is created, set main page for this ability\n    Log.info(this.TAG, 'Application onWindowStageCreate');\n    GlobalContext.getContext().setObject('photosWindowStage', windowStage);\n    windowStage.getMainWindow().then((win: window.Window): void => {\n      AppStorage.SetOrCreate<window.Window>(Constants.MAIN_WINDOW, win);\n      screenManager.initializationSize(win).then<void, void>((): void => {\n        windowStage.setUIContent(this.context, pagePath, null);\n      }).catch<void>((): void => {\n        Log.error(this.TAG, 'get device screen info failed.');\n      });\n    });\n  }\n\n  onWindowStageDestroy(): void {\n  }\n\n  onForeground(): void {\n  }\n\n  onBackground(): void {\n  }\n}\n", "llm_cg": {"EntryAbility.onCreate(Want, unknown)": ["GlobalContext.getContext()", "GlobalContext.getContext().setObject(string, unknown)", "userFileModel.onCreate(unknown)", "AppStorage.SetOrCreate<number>(string, number)", "Log.info(string, string)"], "EntryAbility.onNewWant(Want)": ["AppStorage.SetOrCreate<number>(string, number)"], "EntryAbility.onDestroy()": ["Log.info(string, string)", "AppStorage.Delete(string)"], "EntryAbility.onWindowStageCreate(unknown)": ["Log.info(string, string)", "GlobalContext.getContext()", "GlobalContext.getContext().setObject(string, unknown)", "windowStage.getMainWindow()", "AppStorage.SetOrCreate<window.Window>(string, window.Window)", "screenManager.initializationSize(window.Window)", "windowStage.setUIContent(unknown, string, null)", "Log.error(string, string)"]}, "static_cg": {"@test/16.ts: EntryAbility.onWindowStageCreate(unknown)": ["@test/16.ts: EntryAbility.%AM0$onWindowStageCreate(window.Window)"], "@test/16.ts: EntryAbility.%AM0$onWindowStageCreate(window.Window)": ["@test/16.ts: EntryAbility.%AM2$%AM0$onWindowStageCreate()", "@test/16.ts: EntryAbility.%AM1$%AM0$onWindowStageCreate()"]}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport interface AsyncCallback<T> {\n  callback(t: T): void;\n}", "llm_cg": {"AsyncCallback.callback(T)": []}, "static_cg": {}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Log } from '../utils/Log';\nimport { ItemDataSource } from '../common/ItemDataSource';\nimport { MenuContext } from './MenuContext';\nimport { BroadcastConstants } from '../constants/BroadcastConstants';\nimport { ProcessMenuOperation } from './ProcessMenuOperation';\nimport { UserFileDataItem } from '../base/UserFileDataItem';\nimport { MediaConstants } from '../constants/MediaConstants';\nimport { AlbumDataImpl } from '../common/AlbumDataImpl';\n\nconst TAG = 'BatchRemoveMenuOperation';\n\nexport class BatchRemoveMenuOperation extends ProcessMenuOperation {\n  private albumDataImpl: AlbumDataImpl = new AlbumDataImpl();\n\n  constructor(menuContext: MenuContext) {\n    super(menuContext);\n  }\n\n  doAction(): void {\n    Log.info(TAG, 'remove doAction');\n    if (this.menuContext == null) {\n      Log.warn(TAG, 'menuContext is null, return');\n      return;\n    }\n\n    let dataSource: ItemDataSource = this.menuContext.dataSource;\n    if (dataSource == null) {\n      this.count = this.menuContext.items.length;\n    } else {\n      this.count = dataSource.getSelectedCount();\n    }\n    if (this.count <= 0) {\n      Log.warn(TAG, 'count <= 0, return');\n      return;\n    }\n\n    this.confirmCallback = (): void => this.confirmCallbackBindImpl();\n    this.cancelCallback = (): void => this.cancelCallbackBindImpl();\n\n    let resource: Resource = this.getRemoveMessageResource(dataSource);\n    let removeResource: Resource = $r('app.string.dialog_remove');\n    this.menuContext.broadCast.emit(BroadcastConstants.SHOW_DELETE_DIALOG, [resource, removeResource, this.confirmCallback, this.cancelCallback]);\n  }\n\n  getResourceFromGrid(dataSource: ItemDataSource): Resource {\n    if (dataSource != null && dataSource.isSelect()) {\n      return $r('app.string.remove_all_files_tips');\n    } else if (this.count === 1) {\n      return $r('app.string.remove_single_file_tips');\n    } else {\n      return $r('app.string.remove_files_tips', this.count);\n    }\n  }\n\n  getRemoveMessageResource(dataSource: ItemDataSource): Resource {\n    let resource: Resource;\n    resource = this.getResourceFromGrid(dataSource);\n    return resource;\n  }\n\n  confirmCallback(): void {\n    this.confirmCallbackBindImpl();\n  }\n\n  protected confirmCallbackBindImpl(): void {\n    Log.info(TAG, 'Batch remove confirm');\n    AppStorage.SetOrCreate<number>('isRemove', 1);\n\n    // 1. Variable initialization\n    this.onOperationEnd = this.menuContext.onOperationEnd;\n\n    // 2. onRemoveStart exit selection mode\n    let onOperationStart: Function = this.menuContext.onOperationStart;\n    if (onOperationStart != null) {\n      onOperationStart();\n    }\n\n    this.menuContext.broadCast.emit(BroadcastConstants.DELETE_PROGRESS_DIALOG,\n      [$r('app.string.action_remove'), this.count]);\n\n    // 3. selectManager gets the URI of the data and starts processing deletion in the callback\n    let dataSource: ItemDataSource = this.menuContext.dataSource;\n    if (dataSource == null) {\n      this.items = this.menuContext.items;\n    } else {\n      this.items = dataSource.getSelectedItems();\n    }\n    this.processOperation();\n  }\n\n  requestOneBatchOperation(): void {\n    let item = this.items[this.currentBatch] as UserFileDataItem;\n    if (item != null) {\n      if(this.menuContext.albumId === MediaConstants.ALBUM_ID_USER){\n        Log.error(TAG,'Remove from user album:'+this.menuContext.albumInfo.uri);\n        this.albumDataImpl.removeFileFromAlbum(this.menuContext.albumInfo.uri,item.uri).then<void, void>((): void => {\n          this.currentBatch++;\n          this.menuContext.broadCast.emit(BroadcastConstants.UPDATE_PROGRESS, [this.getExpectProgress(), this.currentBatch]);\n          this.cyclicOperation();\n        })\n      }\n    }\n  }\n\n  cancelCallback(): void {\n    this.cancelCallbackBindImpl();\n  }\n\n  protected cancelCallbackBindImpl(): void {\n    Log.info(TAG, 'Batch remove cancel');\n  }\n}\n", "llm_cg": {"BatchRemoveMenuOperation.doAction()": ["Log.info(string, string)", "Log.warn(string, string)", "ItemDataSource.getSelectedCount()", "BatchRemoveMenuOperation.getRemoveMessageResource(ItemDataSource)", "MenuContext.broadCast.emit(string, [Resource, Resource, Function, Function])"], "BatchRemoveMenuOperation.getResourceFromGrid(ItemDataSource)": ["ItemDataSource.isSelect()", "$r(string)", "$r(string, number)"], "BatchRemoveMenuOperation.getRemoveMessageResource(ItemDataSource)": ["BatchRemoveMenuOperation.getResourceFromGrid(ItemDataSource)"], "BatchRemoveMenuOperation.confirmCallback()": ["BatchRemoveMenuOperation.confirmCallbackBindImpl()"], "BatchRemoveMenuOperation.confirmCallbackBindImpl()": ["Log.info(string, string)", "AppStorage.SetOrCreate(string, number)", "MenuContext.onOperationStart()", "MenuContext.broadCast.emit(string, [Resource, number])", "ItemDataSource.getSelectedItems()", "BatchRemoveMenuOperation.processOperation()"], "BatchRemoveMenuOperation.requestOneBatchOperation()": ["Log.error(string, string)", "AlbumDataImpl.removeFileFromAlbum(string, string)", "MenuContext.broadCast.emit(string, [number, number])", "BatchRemoveMenuOperation.cyclicOperation()"], "BatchRemoveMenuOperation.cancelCallback()": ["BatchRemoveMenuOperation.cancelCallbackBindImpl()"], "BatchRemoveMenuOperation.cancelCallbackBindImpl()": ["Log.info(string, string)"]}, "static_cg": {"@test/18.ts: BatchRemoveMenuOperation.doAction()": ["@test/18.ts: BatchRemoveMenuOperation.getRemoveMessageResource(ItemDataSource)"], "@test/18.ts: BatchRemoveMenuOperation.getRemoveMessageResource(ItemDataSource)": ["@test/18.ts: BatchRemoveMenuOperation.getResourceFromGrid(ItemDataSource)"], "@test/18.ts: BatchRemoveMenuOperation.confirmCallback()": ["@test/18.ts: BatchRemoveMenuOperation.confirmCallbackBindImpl()"], "@test/18.ts: BatchRemoveMenuOperation.requestOneBatchOperation()": ["@test/18.ts: BatchRemoveMenuOperation.%AM2$requestOneBatchOperation()"], "@test/18.ts: BatchRemoveMenuOperation.cancelCallback()": ["@test/18.ts: BatchRemoveMenuOperation.cancelCallbackBindImpl()"], "@test/18.ts: BatchRemoveMenuOperation.%AM0$doAction()": ["@test/18.ts: BatchRemoveMenuOperation.confirmCallbackBindImpl()"], "@test/18.ts: BatchRemoveMenuOperation.%AM1$doAction()": ["@test/18.ts: BatchRemoveMenuOperation.cancelCallbackBindImpl()"]}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport interface MenuOperation {\n  doAction(): void;\n}", "llm_cg": {"MenuOperation.doAction()": []}, "static_cg": {}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport router from '@system.router';\nimport { RouterOptions } from '@system.router';\nimport { Log } from '../utils/Log';\nimport { getResourceString } from '../utils/ResourceUtils';\nimport { BroadcastConstants } from '../constants/BroadcastConstants';\nimport { MenuOperationCallback } from './MenuOperationCallback';\nimport { MenuOperation } from './MenuOperation';\nimport { MenuContext } from './MenuContext';\nimport { JumpSourceToMain } from '../models/JumpSourceToMain';\nimport { SimpleAlbumDataItem } from '../common/SimpleAlbumDataItem';\nimport { showToast } from '../utils/UiUtil';\nimport { userFileModel } from '../base/UserFileModel';\nimport { AlbumDataItem } from '../common/AlbumDataItem';\nimport { LazyItem } from '../common/ItemDataSource';\nimport { MediaConstants } from '../constants/MediaConstants';\nimport { AlbumsDataSource } from '../common/AlbumsDataSource';\n\nconst TAG = 'AlbumSetNewMenuOperation';\n\nexport class AlbumSetNewMenuOperation implements MenuOperation, MenuOperationCallback {\n  private menuContext: MenuContext;\n  private onOperationEnd: Function;\n\n  constructor(menuContext: MenuContext) {\n    this.menuContext = menuContext;\n  }\n\n  doAction(): void {\n    if (this.menuContext == null) {\n      Log.warn(TAG, 'menuContext is null, return');\n      return;\n    }\n    getResourceString($r('app.string.album_new_album')).then<void, void>((name: string): void => {\n      Log.info(TAG, 'The display name is ' + name);\n      let newAlbumDisplayName = this.getNewAlbumDefaultName(name);\n      Log.info(TAG, `The display name of new album is ${newAlbumDisplayName}`);\n      this.confirmCallback = (displayName: string): Promise<void> => this.confirmCallbackBindImpl(displayName);\n      this.cancelCallback = (): void => this.cancelCallbackBindImpl();\n\n      this.menuContext.broadCast.emit(BroadcastConstants.SHOW_NEW_ALBUM_PHOTO_DIALOG,\n          [newAlbumDisplayName, this.confirmCallback, this.cancelCallback]);\n    })\n  }\n\n  private async confirmCallback(displayName: string): Promise<void> {\n    return await this.confirmCallbackBindImpl(displayName);\n  }\n\n  private async confirmCallbackBindImpl(displayName: string): Promise<void> {\n    Log.info(TAG, 'AlbumSet new album confirm and the new name is: ' + displayName);\n    let simpleAlbumDataItem: SimpleAlbumDataItem = new SimpleAlbumDataItem('', displayName, '', '', '', -1, -1);\n    if (displayName != undefined && displayName != null) {\n      let isExit = await this.checkAlbumExit(simpleAlbumDataItem);\n      if (isExit) {\n        getResourceString($r('app.string.name_already_use')).then<void, void>((message: string): void => {\n            showToast(message);\n        })\n        return;\n      }\n    }\n    this.onOperationEnd = this.menuContext.onOperationEnd;\n    let onOperationStart: Function = this.menuContext.onOperationStart;\n    if (onOperationStart != null) onOperationStart();\n\n    if (this.menuContext.jumpSourceToMain === JumpSourceToMain.ALBUM) {\n      Log.info(TAG, 'go back to photo grid');\n      this.menuContext.broadCast.emit(BroadcastConstants.MEDIA_OPERATION, [simpleAlbumDataItem, (): void => this.onCompletedBindImpl()]);\n    } else {\n      let params: Object = {\n        albumInfo: JSON.stringify(simpleAlbumDataItem),\n        isNewAlbum: true\n      };\n      let routerOptions: RouterOptions = {\n        uri: 'pages/AlbumSelect',\n        params: params\n      };\n      router.push(routerOptions);\n      this.onCompleted();\n    }\n  }\n\n  private async checkAlbumExit(simpleAlbumDataItem: SimpleAlbumDataItem): Promise<boolean> {\n    return await userFileModel.getUserAlbumCountByName(simpleAlbumDataItem.displayName) > 0;\n  }\n\n  private cancelCallback(): void {\n    this.cancelCallbackBindImpl();\n  }\n\n  private cancelCallbackBindImpl(): void {\n    Log.info(TAG, 'AlbumSet new album cancel');\n  }\n\n  onCompleted(): void {\n    this.onCompletedBindImpl();\n  }\n\n  private onCompletedBindImpl(): void {\n    Log.info(TAG, 'new album data succeed!');\n    if (this.onOperationEnd != null) this.onOperationEnd();\n  }\n\n  onError(): void {\n    Log.error(TAG, 'new album data failed!');\n    if (this.onOperationEnd != null) this.onOperationEnd();\n  }\n\n  private checkAndAddNumber(albumInfo: AlbumDataItem, prefixName: string, numbers: number[]): void {\n    let res = albumInfo.displayName.match(new RegExp('^' + prefixName + '[1-9][0-9]*$'));\n    Log.info(TAG, `check name res ${res}`);\n    if (res) {\n      let number = res[0].match(new RegExp(`[1-9][0-9]*`));\n      numbers.push(parseInt(number[0]));\n    }\n  }\n\n  private getNewAlbumDefaultName(prefixName: string): string {\n    let numbers: number[] = [];\n    for (let i = 0; i < this.menuContext.dataSource.totalCount(); i++) {\n      let album = this.menuContext.dataSource as AlbumsDataSource;\n      this.checkAndAddNumber(album.getDataByIndex(i), prefixName, numbers);\n    }\n\n    Log.debug(TAG, `${JSON.stringify(numbers)}`);\n\n    if (numbers.length <= 0) {\n      return `${prefixName}1`;\n    } else if (numbers.length === 1) {\n      if (numbers[0] - 1 > 0) {\n        return `${prefixName}1`;\n      } else {\n        return `${prefixName}${numbers[0] + 1}`;\n      }\n    }\n\n    numbers.sort(function (a, b) {\n      return a - b;\n    });\n\n    if (numbers[0] - 1 > 0) {\n      return `${prefixName}1`;\n    }\n\n    for (let i = 1; i < numbers.length; i++) {\n      let res = numbers[i - 1] + 1;\n      if (res < numbers[i]) {\n        return `${prefixName}${res}`;\n      }\n    }\n    return `${prefixName}${numbers[numbers.length - 1] + 1}`;\n  }\n}\n", "llm_cg": {"AlbumSetNewMenuOperation.doAction()": ["AlbumSetNewMenuOperation.%AM0$getNewAlbumDefaultName(string)", "AlbumSetNewMenuOperation.%AM1$confirmCallbackBindImpl(string)", "AlbumSetNewMenuOperation.%AM2$cancelCallbackBindImpl()"], "AlbumSetNewMenuOperation.confirmCallback(string)": ["AlbumSetNewMenuOperation.%AM3$confirmCallbackBindImpl(string)"], "AlbumSetNewMenuOperation.confirmCallbackBindImpl(string)": ["AlbumSetNewMenuOperation.%AM4$checkAlbumExit(SimpleAlbumDataItem)", "AlbumSetNewMenuOperation.%AM5$onCompletedBindImpl()"], "AlbumSetNewMenuOperation.checkAlbumExit(SimpleAlbumDataItem)": ["userFileModel.%AM6$getUserAlbumCountByName(string)"], "AlbumSetNewMenuOperation.cancelCallback()": ["AlbumSetNewMenuOperation.%AM7$cancelCallbackBindImpl()"], "AlbumSetNewMenuOperation.cancelCallbackBindImpl()": [], "AlbumSetNewMenuOperation.onCompleted()": ["AlbumSetNewMenuOperation.%AM8$onCompletedBindImpl()"], "AlbumSetNewMenuOperation.onCompletedBindImpl()": [], "AlbumSetNewMenuOperation.onError()": [], "AlbumSetNewMenuOperation.checkAndAddNumber(AlbumDataItem, string, number[])": [], "AlbumSetNewMenuOperation.getNewAlbumDefaultName(string)": ["AlbumSetNewMenuOperation.%AM9$checkAndAddNumber(AlbumDataItem, string, number[])"]}, "static_cg": {"@test/20.ts: AlbumSetNewMenuOperation.doAction()": ["@test/20.ts: AlbumSetNewMenuOperation.%AM0$doAction(string)"], "@test/20.ts: AlbumSetNewMenuOperation.confirmCallback(string)": ["@test/20.ts: AlbumSetNewMenuOperation.confirmCallbackBindImpl(string)"], "@test/20.ts: AlbumSetNewMenuOperation.confirmCallbackBindImpl(string)": ["@test/20.ts: AlbumSetNewMenuOperation.checkAlbumExit(SimpleAlbumDataItem)", "@test/20.ts: AlbumSetNewMenuOperation.%AM3$confirmCallbackBindImpl(string)", "@test/20.ts: AlbumSetNewMenuOperation.onCompleted()"], "@test/20.ts: AlbumSetNewMenuOperation.cancelCallback()": ["@test/20.ts: AlbumSetNewMenuOperation.cancelCallbackBindImpl()"], "@test/20.ts: AlbumSetNewMenuOperation.onCompleted()": ["@test/20.ts: AlbumSetNewMenuOperation.onCompletedBindImpl()"], "@test/20.ts: AlbumSetNewMenuOperation.getNewAlbumDefaultName(string)": ["@test/20.ts: AlbumSetNewMenuOperation.checkAndAddNumber(AlbumDataItem, string, number[])", "@test/20.ts: AlbumSetNewMenuOperation.%AM5$getNewAlbumDefaultName(unknown, unknown)"], "@test/20.ts: AlbumSetNewMenuOperation.%AM1$%AM0$doAction(string)": ["@test/20.ts: AlbumSetNewMenuOperation.confirmCallbackBindImpl(string)"], "@test/20.ts: AlbumSetNewMenuOperation.%AM2$%AM0$doAction()": ["@test/20.ts: AlbumSetNewMenuOperation.cancelCallbackBindImpl()"], "@test/20.ts: AlbumSetNewMenuOperation.%AM0$doAction(string)": ["@test/20.ts: AlbumSetNewMenuOperation.getNewAlbumDefaultName(string)"], "@test/20.ts: AlbumSetNewMenuOperation.%AM4$confirmCallbackBindImpl()": ["@test/20.ts: AlbumSetNewMenuOperation.onCompletedBindImpl()"]}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Log } from '../utils/Log';\nimport { BroadcastConstants } from '../constants/BroadcastConstants';\nimport { MenuOperationCallback } from './MenuOperationCallback';\nimport { MenuOperation } from './MenuOperation';\nimport { MenuContext } from './MenuContext';\nimport { userFileModel } from '../base/UserFileModel';\nimport { Constants } from '../constants/BrowserConstants';\nimport { getResourceString } from '../utils/ResourceUtils';\nimport { showToast } from '../utils/UiUtil';\nimport { UserFileDataItem } from '../base/UserFileDataItem';\n\nconst TAG = 'RenameMenuOperation';\n\nexport class RenameMenuOperation implements MenuOperation, MenuOperationCallback {\n  private menuContext: MenuContext;\n\n  constructor(menuContext: MenuContext) {\n    this.menuContext = menuContext;\n  }\n\n  doAction(): void {\n    if (this.menuContext == null) {\n      Log.warn(TAG, 'menuContext is null, return');\n      return;\n    }\n    let mediaItem = this.menuContext.items[0];\n    if (mediaItem == null) {\n      Log.warn(TAG, 'mediaItem is null, return');\n      return;\n    }\n\n    this.confirmCallback = (title: string): Promise<void> => this.confirmCallbackBindImpl(title);\n    this.cancelCallback = (): void => this.cancelCallbackBindImpl();\n    let fileName = '';\n    if (mediaItem.title != null) {\n      fileName = mediaItem.title;\n    } else if (mediaItem.displayName != null) {\n      let index = mediaItem.displayName.lastIndexOf('.');\n      fileName = mediaItem.displayName.substr(0, index);\n    }\n\n    this.menuContext.broadCast.emit(BroadcastConstants.SHOW_RENAME_PHOTO_DIALOG,\n      [fileName, this.confirmCallback, this.cancelCallback]);\n  }\n\n  onCompleted(): void {\n    Log.info(TAG, 'Rename data succeed!');\n  }\n\n  onError(): void {\n    Log.error(TAG, 'Rename data failed!');\n  }\n\n  private async confirmCallback(title: string): Promise<void> {\n    return await this.confirmCallbackBindImpl(title);\n  }\n\n  private async confirmCallbackBindImpl(title: string): Promise<void> {\n    Log.info(TAG, 'Rename confirm new name: ' + title);\n    let mediaItem = (this.menuContext.items[0] as UserFileDataItem);\n    if (mediaItem == null) {\n      Log.warn(TAG, 'mediaItem is null, return');\n      return;\n    }\n\n    let hasSameName = await this.hasSameNameAsset(mediaItem, title);\n    if (hasSameName) {\n      Log.info(TAG, 'show find same file dialog');\n      getResourceString($r('app.string.name_already_use')).then<void, void>((message: string): void => {\n        showToast(message);\n      })\n      return;\n    }\n    try {\n      let result = await this.rename(mediaItem, title);\n      Log.info(TAG, 'Rename confirm result: ' + result);\n      this.menuContext.broadCast.emit(Constants.RENAME, [result]);\n    } catch (err) {\n      Log.error(TAG, 'Rename error: ' + err);\n      getResourceString($r('app.string.rename_failed')).then<void, void>((message: string): void => {\n        showToast(message);\n      })\n    }\n\n  }\n\n  private async rename(item: UserFileDataItem, name: string): Promise<Object[]> {\n    Log.info(TAG, 'renameSinglePhoto start');\n    await item.setName(name);\n    return [item.title, item.displayName] as Object[];\n  }\n\n  private async hasSameNameAsset(item: UserFileDataItem, name: string): Promise<boolean> {\n    Log.debug(TAG, 'hasSameNameAsset start');\n    let fileAsset = await item.loadFileAsset();\n    let displayName = fileAsset.displayName;\n    let index = displayName.lastIndexOf('.');\n    displayName = name + displayName.slice(index);\n    let counts = (await userFileModel.getMediaItemCountsByDisplayName(fileAsset.uri));\n    if (counts === 0) {\n      Log.info(TAG, 'hasSameNameAsset is false');\n      return false;\n    }\n    Log.info(TAG, 'hasSameNameAsset true');\n    return true;\n  }\n\n  private cancelCallback(): void {\n    this.cancelCallbackBindImpl();\n  }\n\n  private cancelCallbackBindImpl(): void {\n    Log.info(TAG, 'Rename cancel');\n  }\n}\n", "llm_cg": {"RenameMenuOperation.doAction()": ["RenameMenuOperation.%AM0$confirmCallbackBindImpl(string)", "RenameMenuOperation.%AM1$cancelCallbackBindImpl()"], "RenameMenuOperation.confirmCallback(string)": ["RenameMenuOperation.%AM0$confirmCallbackBindImpl(string)"], "RenameMenuOperation.confirmCallbackBindImpl(string)": ["RenameMenuOperation.%AM0$hasSameNameAsset(UserFileDataItem, string)", "RenameMenuOperation.%AM1$rename(UserFileDataItem, string)", "RenameMenuOperation.%AM2$getResourceString(unknown)", "RenameMenuOperation.%AM3$showToast(string)"], "RenameMenuOperation.rename(UserFileDataItem, string)": ["UserFileDataItem.%AM0$setName(string)"], "RenameMenuOperation.hasSameNameAsset(UserFileDataItem, string)": ["UserFileDataItem.%AM0$loadFileAsset()", "userFileModel.%AM0$getMediaItemCountsByDisplayName(string)"], "RenameMenuOperation.cancelCallback()": ["RenameMenuOperation.%AM0$cancelCallbackBindImpl()"]}, "static_cg": {"@test/21.ts: RenameMenuOperation.confirmCallback(string)": ["@test/21.ts: RenameMenuOperation.confirmCallbackBindImpl(string)"], "@test/21.ts: RenameMenuOperation.confirmCallbackBindImpl(string)": ["@test/21.ts: RenameMenuOperation.hasSameNameAsset(UserFileDataItem, string)", "@test/21.ts: RenameMenuOperation.%AM2$confirmCallbackBindImpl(string)", "@test/21.ts: RenameMenuOperation.rename(UserFileDataItem, string)", "@test/21.ts: RenameMenuOperation.%AM3$confirmCallbackBindImpl(string)"], "@test/21.ts: RenameMenuOperation.cancelCallback()": ["@test/21.ts: RenameMenuOperation.cancelCallbackBindImpl()"], "@test/21.ts: RenameMenuOperation.%AM0$doAction(string)": ["@test/21.ts: RenameMenuOperation.confirmCallbackBindImpl(string)"], "@test/21.ts: RenameMenuOperation.%AM1$doAction()": ["@test/21.ts: RenameMenuOperation.cancelCallbackBindImpl()"]}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Log } from '../utils/Log';\nimport { BroadcastConstants } from '../constants/BroadcastConstants';\nimport { ItemDataSource } from '../common/ItemDataSource';\nimport { AlbumDataItem } from '../common/AlbumDataItem';\nimport { MenuContext } from './MenuContext';\nimport { ProcessMenuOperation } from './ProcessMenuOperation';\n\nconst TAG = 'AlbumSetDeleteMenuOperation';\n\nexport class AlbumSetDeleteMenuOperation extends ProcessMenuOperation {\n  constructor(menuContext: MenuContext) {\n    super(menuContext);\n  }\n\n  doAction(): void {\n    if (this.menuContext == null) {\n      Log.warn(TAG, 'menuContext is null, return');\n      return;\n    }\n    let dataSource: ItemDataSource = this.menuContext.dataSource;\n    if (dataSource == null) {\n      this.count = this.menuContext.items.length;\n      this.items = this.menuContext.items;\n    } else {\n      this.count = dataSource.getSelectedCount();\n      this.items = dataSource.getSelectedItems();\n    }\n    if (this.count as number <= 0) {\n      Log.warn(TAG, 'count <= 0, return');\n      return;\n    }\n\n    this.confirmCallback = (): void => this.confirmCallbackBindImpl();\n    this.cancelCallback = (): void => this.cancelCallbackBindImpl();\n\n    let deleteResource: Resource = $r('app.string.dialog_delete');\n    this.getDialogTitle().then<void, void>((dialogTitle: Resource): void => {\n      this.menuContext.broadCast.emit(BroadcastConstants.SHOW_DELETE_DIALOG, [dialogTitle, deleteResource, this.confirmCallback, this.cancelCallback]);\n    })\n  }\n\n  private async getDialogTitle(): Promise<Resource> {\n    let videoCount = 0;\n    let photoCount = 0;\n    for (let i = 0; i < this.items.length; i++) {\n      let itemVideoCount = await  (this.items[i] as AlbumDataItem).getVideoCount();\n      videoCount += itemVideoCount;\n      photoCount += ((this.items[i] as AlbumDataItem).count - itemVideoCount);\n    }\n\n    if (this.count as number === 1) {\n      if (videoCount > 0 && photoCount > 0) {\n        return $r('app.string.recycle_single_album_tips', photoCount, videoCount);\n      }\n      if (videoCount > 0 && photoCount <= 0) {\n        return $r('app.string.recycle_single_album_with_videos_tips', videoCount);\n      }\n      if (videoCount <= 0 && photoCount > 0) {\n        return $r('app.string.recycle_single_album_with_photos_tips', photoCount);\n      }\n    } else {\n      if (videoCount > 0 && photoCount > 0) {\n        return $r('app.string.recycle_albums_tips', this.count, photoCount, videoCount);\n      }\n      if (videoCount > 0 && photoCount <= 0) {\n        return $r('app.string.recycle_albums_with_videos_tips', this.count, videoCount);\n      }\n      if (videoCount <= 0 && photoCount > 0) {\n        return $r('app.string.recycle_albums_with_photos_tips', this.count, photoCount);\n      }\n    }\n  }\n\n  requestOneBatchOperation(): void {\n    let item = this.items[this.currentBatch] as AlbumDataItem;\n    let promise: Promise<boolean> = item.onDelete();\n    promise.then<void, void>((): void => {\n      this.currentBatch++;\n      this.menuContext.broadCast.emit(BroadcastConstants.UPDATE_PROGRESS, [this.getExpectProgress(), this.currentBatch]);\n      this.cyclicOperation();\n    }).catch<void>((): void => {\n      this.onError();\n    })\n    }\n\n  private confirmCallback(): void {\n    this.confirmCallbackBindImpl();\n  }\n\n  private confirmCallbackBindImpl(): void {\n    Log.info(TAG, 'AlbumSet delete confirm');\n    this.onOperationEnd = this.menuContext.onOperationEnd;\n    let onOperationStart: Function = this.menuContext.onOperationStart;\n\n    if (onOperationStart != null) onOperationStart();\n\n    this.menuContext.broadCast.emit(BroadcastConstants.DELETE_PROGRESS_DIALOG, [$r('app.string.action_delete'), this.count]);\n    this.processOperation();\n  }\n\n  private cancelCallback(): void {\n    this.cancelCallbackBindImpl();\n  }\n\n  private cancelCallbackBindImpl(): void {\n    Log.info(TAG, 'AlbumSet delete cancel');\n  }\n}\n", "llm_cg": {"AlbumSetDeleteMenuOperation.doAction()": ["ItemDataSource.getSelectedCount()", "ItemDataSource.getSelectedItems()", "AlbumSetDeleteMenuOperation.getDialogTitle()", "MenuContext.broadCast.emit(BroadcastConstants.SHOW_DELETE_DIALOG, [dialogTitle, deleteResource, this.confirmCallback, this.cancelCallback])"], "AlbumSetDeleteMenuOperation.getDialogTitle()": ["AlbumDataItem.getVideoCount()"], "AlbumSetDeleteMenuOperation.requestOneBatchOperation()": ["AlbumDataItem.onDelete()", "MenuContext.broadCast.emit(BroadcastConstants.UPDATE_PROGRESS, [this.getExpectProgress(), this.currentBatch])", "AlbumSetDeleteMenuOperation.cyclicOperation()", "AlbumSetDeleteMenuOperation.onError()"], "AlbumSetDeleteMenuOperation.confirmCallbackBindImpl()": ["MenuContext.onOperationStart()", "MenuContext.broadCast.emit(BroadcastConstants.DELETE_PROGRESS_DIALOG, [$r('app.string.action_delete'), this.count])", "AlbumSetDeleteMenuOperation.processOperation()"]}, "static_cg": {"@test/22.ts: AlbumSetDeleteMenuOperation.doAction()": ["@test/22.ts: AlbumSetDeleteMenuOperation.getDialogTitle()", "@test/22.ts: AlbumSetDeleteMenuOperation.%AM2$doAction([deleteResource], Resource)"], "@test/22.ts: AlbumSetDeleteMenuOperation.requestOneBatchOperation()": ["@test/22.ts: AlbumSetDeleteMenuOperation.%AM4$requestOneBatchOperation()", "@test/22.ts: AlbumSetDeleteMenuOperation.%AM3$requestOneBatchOperation()"], "@test/22.ts: AlbumSetDeleteMenuOperation.confirmCallback()": ["@test/22.ts: AlbumSetDeleteMenuOperation.confirmCallbackBindImpl()"], "@test/22.ts: AlbumSetDeleteMenuOperation.cancelCallback()": ["@test/22.ts: AlbumSetDeleteMenuOperation.cancelCallbackBindImpl()"], "@test/22.ts: AlbumSetDeleteMenuOperation.%AM0$doAction()": ["@test/22.ts: AlbumSetDeleteMenuOperation.confirmCallbackBindImpl()"], "@test/22.ts: AlbumSetDeleteMenuOperation.%AM1$doAction()": ["@test/22.ts: AlbumSetDeleteMenuOperation.cancelCallbackBindImpl()"]}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { TrashUserFileDataItem } from '../base/TrashUserFileDataItem';\nimport { Log } from '../utils/Log';\nimport { ItemDataSource } from '../common/ItemDataSource';\nimport { MenuContext } from './MenuContext'\nimport { ProcessMenuOperation } from './ProcessMenuOperation';\nimport { BroadcastConstants } from '../constants/BroadcastConstants';\n\nconst TAG = 'BatchRecoverMenuOperation';\n\nexport class BatchRecoverMenuOperation extends ProcessMenuOperation {\n  constructor(menuContext: MenuContext) {\n    super(menuContext);\n  }\n\n  doAction(): void {\n    Log.info(TAG, 'delete doAction');\n    if (this.menuContext == null) {\n      Log.warn(TAG, 'menuContext is null, return');\n      return;\n    }\n\n    let dataSource: ItemDataSource = this.menuContext.dataSource;\n    if (dataSource == null) {\n      this.count = this.menuContext.items.length;\n    } else {\n      this.count = dataSource.getSelectedCount();\n    }\n    if (this.count <= 0) {\n      Log.warn(TAG, 'count <= 0, return');\n      return;\n    }\n\n    this.onOperationEnd = this.menuContext.onOperationEnd;\n    let onOperationStart = this.menuContext.onOperationStart;\n    if (onOperationStart != null) onOperationStart();\n\n    this.menuContext.broadCast.emit(BroadcastConstants.DELETE_PROGRESS_DIALOG,\n      [$r('app.string.action_recover'), this.count]);\n\n    if (dataSource == null) {\n      this.items = this.menuContext.items;\n    } else {\n      this.items = dataSource.getSelectedItems();\n    }\n    this.processOperation();\n  }\n\n  // Delete a batch of data\n  requestOneBatchOperation(): void {\n    let item = this.items[this.currentBatch] as TrashUserFileDataItem;\n    item.onRecover().then<void, void>((): void => {\n      this.currentBatch++;\n      this.menuContext.broadCast.emit(BroadcastConstants.UPDATE_PROGRESS, [this.getExpectProgress(), this.currentBatch]);\n      this.cyclicOperation();\n    })\n  }\n}\n", "llm_cg": {"BatchRecoverMenuOperation.doAction()": ["Log.info(unknown, unknown)", "Log.warn(unknown, unknown)", "ItemDataSource.getSelectedCount()", "MenuContext.onOperationStart()", "MenuContext.broadCast.emit(unknown, unknown)", "ItemDataSource.getSelectedItems()", "BatchRecoverMenuOperation.processOperation()"], "BatchRecoverMenuOperation.requestOneBatchOperation()": ["TrashUserFileDataItem.onRecover()", "MenuContext.broadCast.emit(unknown, unknown)", "BatchRecoverMenuOperation.cyclicOperation()"]}, "static_cg": {"@test/23.ts: BatchRecoverMenuOperation.requestOneBatchOperation()": ["@test/23.ts: BatchRecoverMenuOperation.%AM0$requestOneBatchOperation()"]}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ItemDataSource } from '../common/ItemDataSource';\nimport { UserFileDataItem } from '../base/UserFileDataItem'\nimport { Broadcast } from '../common/Broadcast'\nimport { SimpleAlbumDataItem } from '../common/SimpleAlbumDataItem';\nimport photoAccessHelper from '@ohos.file.photoAccessHelper';\n\nexport class MenuContext {\n  items: UserFileDataItem[] = [];\n  dataSource: ItemDataSource;\n\n  albumInfo: SimpleAlbumDataItem;\n\n  albumObject: photoAccessHelper.Album;\n\n  broadCast: Broadcast;\n  onOperationStart: Function;\n  onOperationCancel: Function;\n  onOperationEnd: Function;\n\n  jumpSourceToMain: number;\n  deviceId: string;\n\n  albumId: string;\n  deletePageFromType: number; // 0. photoBrowser  1. photoGridPage\n\n  withDeletePageFromType(deletePageFromType: number): MenuContext {\n    this.deletePageFromType = deletePageFromType;\n    return this;\n  }\n\n  withItems(items: UserFileDataItem[]): MenuContext {\n    this.items = items;\n    return this;\n  }\n\n  withAlbumId(albumId: string): MenuContext {\n    this.albumId = albumId;\n    return this;\n  }\n\n  withAlbumObject(albumObject: photoAccessHelper.Album): MenuContext {\n    this.albumObject = albumObject;\n    return this;\n  }\n\n  withDataSource(dataSource): MenuContext {\n    this.dataSource = dataSource;\n    return this;\n  }\n\n  withOperationStartCallback(onOperationStart: Function): MenuContext {\n    this.onOperationStart = onOperationStart;\n    return this;\n  }\n\n  withOperationEndCallback(onOperationEnd: Function): MenuContext {\n    this.onOperationEnd = onOperationEnd;\n    return this;\n  }\n\n  withOperationCancelCallback(onOperationCancel: Function): MenuContext {\n    this.onOperationCancel = onOperationCancel;\n    return this;\n  }\n\n  withBroadCast(param: Broadcast): MenuContext {\n    this.broadCast = param;\n    return this;\n  }\n\n  withJumpSourceToMain(jumpSourceToMain: number): MenuContext {\n    this.jumpSourceToMain = jumpSourceToMain;\n    return this;\n  }\n\n  withRemoteDevice(deviceId): MenuContext {\n    this.deviceId = deviceId;\n    return this;\n  }\n\n  withAlbumInfo(albumInfo: SimpleAlbumDataItem): MenuContext {\n    this.albumInfo = albumInfo;\n    return this;\n  }\n}", "llm_cg": {"MenuContext.withDeletePageFromType(deletePageFromType: number)": [], "MenuContext.withItems(items: UserFileDataItem[])": [], "MenuContext.withAlbumId(albumId: string)": [], "MenuContext.withAlbumObject(albumObject: photoAccessHelper.Album)": [], "MenuContext.withDataSource(dataSource)": [], "MenuContext.withOperationStartCallback(onOperationStart: Function)": [], "MenuContext.withOperationEndCallback(onOperationEnd: Function)": [], "MenuContext.withOperationCancelCallback(onOperationCancel: Function)": [], "MenuContext.withBroadCast(param: Broadcast)": [], "MenuContext.withJumpSourceToMain(jumpSourceToMain: number)": [], "MenuContext.withRemoteDevice(deviceId)": [], "MenuContext.withAlbumInfo(albumInfo: SimpleAlbumDataItem)": []}, "static_cg": {}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ItemDataSource } from '../common/ItemDataSource';\nimport { MenuContext } from './MenuContext';\nimport { BatchDeleteMenuOperation } from './BatchDeleteMenuOperation';\nimport { Log } from '../utils/Log';\nimport { BroadcastConstants } from '../constants/BroadcastConstants';\n\nconst TAG = 'ClearRecycleMenuOperation';\n\nexport class ClearRecycleMenuOperation extends BatchDeleteMenuOperation {\n  constructor(menuContext: MenuContext) {\n    super(menuContext);\n  }\n\n  doAction(): void {\n    Log.info(TAG, 'delete doAction');\n    if (this.menuContext == null) {\n      Log.warn(TAG, 'menuContext is null, return');\n      return;\n    }\n\n    let dataSource: ItemDataSource = this.menuContext.dataSource;\n    if (dataSource == null) {\n      this.count = this.menuContext.items.length;\n    } else {\n      //@ts-ignore\n      this.count = dataSource.getItems().length;\n    }\n    if (this.count <= 0) {\n      Log.warn(TAG, 'count <= 0, return');\n      return;\n    }\n\n    this.confirmCallback = (): void => this.confirmCallbackBindImpl();\n    this.cancelCallback = (): void => this.cancelCallbackBindImpl();\n\n    this.menuContext.broadCast.emit(BroadcastConstants.SHOW_DELETE_DIALOG, [$r('app.string.recycleAlbum_clear_message'), $r('app.string.dialog_clear'), this.confirmCallback, this.cancelCallback]);\n  }\n\n  confirmCallback(): void {\n    this.confirmCallbackBindImpl();\n  }\n\n  protected confirmCallbackBindImpl(): void {\n    Log.info(TAG, 'Clear Recycle confirm');\n    // 1. Variable initialization\n    this.onOperationEnd = this.menuContext.onOperationEnd;\n\n    // 2. onDeleteStart exit selection mode\n    let onOperationStart: Function = this.menuContext.onOperationStart;\n    if (onOperationStart != null) onOperationStart();\n\n    this.menuContext.broadCast.emit(BroadcastConstants.DELETE_PROGRESS_DIALOG,\n      [$r('app.string.action_delete'), this.count]);\n\n    // 3. selectManager gets the URI of the data and starts processing deletion in the callback\n    let dataSource: ItemDataSource = this.menuContext.dataSource;\n    if (dataSource == null) {\n      this.items = this.menuContext.items;\n    } else {\n      //@ts-ignore\n      this.items = dataSource.getItems();\n    }\n    this.processOperation();\n  }\n}\n", "llm_cg": {"ClearRecycleMenuOperation.doAction()": ["Log.info(string, string)", "Log.warn(string, string)", "ClearRecycleMenuOperation.confirmCallbackBindImpl()", "ClearRecycleMenuOperation.cancelCallbackBindImpl()", "MenuContext.broadCast.emit(string, Array)"], "ClearRecycleMenuOperation.confirmCallback()": ["ClearRecycleMenuOperation.confirmCallbackBindImpl()"], "ClearRecycleMenuOperation.confirmCallbackBindImpl()": ["Log.info(string, string)", "MenuContext.onOperationStart()", "MenuContext.broadCast.emit(string, Array)", "ItemDataSource.getItems()", "ClearRecycleMenuOperation.processOperation()"]}, "static_cg": {"@test/25.ts: ClearRecycleMenuOperation.confirmCallback()": ["@test/25.ts: ClearRecycleMenuOperation.confirmCallbackBindImpl()"], "@test/25.ts: ClearRecycleMenuOperation.%AM0$doAction()": ["@test/25.ts: ClearRecycleMenuOperation.confirmCallbackBindImpl()"]}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport router from '@system.router';\nimport { RouterOptions } from '@system.router';\nimport { Log } from '../utils/Log';\nimport { MenuOperation } from './MenuOperation';\nimport { MenuContext } from './MenuContext';\nimport { screenManager } from '../common/ScreenManager';\nimport { JumpSourceToMain } from '../models/JumpSourceToMain';\nimport { RouterConstants } from '../constants/RouterConstants';\n\nconst TAG = 'GotoPhotosMenuOperation';\n\nexport class GotoPhotosMenuOperation implements MenuOperation {\n  private menuContext: MenuContext;\n\n  constructor(menuContext: MenuContext) {\n    this.menuContext = menuContext;\n  }\n\n  doAction(): void {\n    if (this.menuContext == null) {\n      Log.warn(TAG, 'menuContext is null, return');\n      return;\n    }\n    let jumpSourceToMain = this.menuContext.jumpSourceToMain;\n    Log.info(TAG, 'router to pages/index, jumpSource: ' + jumpSourceToMain);\n    let leftPos = screenManager.isSidebar();\n    let pageFrom = RouterConstants.ENTRY_FROM.NORMAL;\n    if (jumpSourceToMain === JumpSourceToMain.CAMERA) {\n      pageFrom = RouterConstants.ENTRY_FROM_CAMERA;\n    }\n    let params: Object = {\n      jumpSource: jumpSourceToMain,\n      pageFrom: pageFrom\n    };\n    let routerOptions: RouterOptions = {\n      uri: 'pages/index',\n      params: params\n    };\n    router.replace(routerOptions);\n  }\n}\n", "llm_cg": {"GotoPhotosMenuOperation.doAction()": ["Log.warn(TAG, string)", "Log.info(TAG, string)", "screenManager.isSidebar()", "router.replace(RouterOptions)"]}, "static_cg": {}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport photoAccessHelper from '@ohos.file.photoAccessHelper';\nimport { userFileModel } from '../base/UserFileModel';\nimport { Log } from '../utils/Log';\nimport { ItemDataSource } from '../common/ItemDataSource';\nimport { AlbumDataItem } from '../common/AlbumDataItem';\nimport { BroadcastConstants } from '../constants/BroadcastConstants';\nimport { MenuOperationCallback } from './MenuOperationCallback';\nimport { MenuOperation } from './MenuOperation';\nimport { MenuContext } from './MenuContext';\nimport { getResourceString } from '../utils/ResourceUtils';\nimport { showToast } from '../utils/UiUtil';\nimport { SimpleAlbumDataItem } from '../common/SimpleAlbumDataItem';\nimport { MediaConstants } from '../constants/MediaConstants';\n\n\nconst TAG = 'AlbumSetRenameMenuOperation';\n\nexport class AlbumSetRenameMenuOperation implements MenuOperation, MenuOperationCallback {\n  private menuContext: MenuContext;\n  private onOperationEnd: Function;\n  private item: AlbumDataItem;\n\n  constructor(menuContext: MenuContext) {\n    this.menuContext = menuContext;\n  }\n\n  doAction(): void {\n    if (this.menuContext == null) {\n      Log.warn(TAG, 'menuContext is null, return');\n      return;\n    }\n    let dataSource: ItemDataSource = this.menuContext.dataSource;\n    let count: number;\n    let items: Object[];\n    if (dataSource == null) {\n      count = this.menuContext.items.length;\n      items = this.menuContext.items;\n    } else {\n      count = dataSource.getSelectedCount();\n      items = dataSource.getSelectedItems();\n    }\n    if (count !== 1) {\n      Log.warn(TAG, 'count is invalid');\n      return;\n    }\n\n    this.item = items[0] as AlbumDataItem;\n\n    this.confirmCallback = (newName: string): Promise<void> => this.confirmCallbackBindImpl(newName);\n    this.cancelCallback = (): void => this.cancelCallbackBindImpl();\n\n    Log.info(TAG, 'The name of clicked album is ' + this.item.displayName);\n\n    this.menuContext.broadCast.emit(BroadcastConstants.SHOW_RENAME_PHOTO_DIALOG,\n      [this.item.displayName, this.confirmCallback, this.cancelCallback]);\n  }\n\n  private async confirmCallback(newName: string): Promise<void> {\n    return await this.confirmCallbackBindImpl(newName);\n  }\n\n  private async confirmCallbackBindImpl(newName: string): Promise<void> {\n    Log.info(TAG, 'AlbumSet rename confirm and the new name is: ' + newName);\n\n    this.onOperationEnd = this.menuContext.onOperationEnd;\n    let onOperationStart: Function = this.menuContext.onOperationStart;\n    if (onOperationStart != null) onOperationStart();\n\n    this.rename(newName);\n  }\n\n  private async checkAlbumExit(simpleAlbumDataItem: SimpleAlbumDataItem): Promise<boolean> {\n    return await userFileModel.getUserAlbumCountByName(simpleAlbumDataItem.displayName) > 0;\n  }\n\n  private async rename(name): Promise<void> {\n    try {\n      let simpleAlbumDataItem: SimpleAlbumDataItem = new SimpleAlbumDataItem('', name, this.item.uri, '', '', -1, -1);\n      if (name != undefined && name != null) {\n        let isExit = await this.checkAlbumExit(simpleAlbumDataItem);\n        if (isExit) {\n          getResourceString($r('app.string.name_already_use')).then<void, void>((message: string): void => {\n            showToast(message);\n          })\n          Log.warn(TAG, 'album is miss');\n          this.onError();\n          return;\n        }\n      }\n      Log.info(TAG, 'change album_name:' + this.item.displayName + ' to ' + name);\n      let albums: photoAccessHelper.Album = await userFileModel.getUserAlbumByName(this.item.displayName);\n      albums.albumName = name;\n      await albums.commitModify();\n      this.onCompleted();\n    } catch (error) {\n      Log.error(TAG, 'AlbumSet rename failed: ' + error);\n      this.onError();\n    }\n  }\n\n  private cancelCallback(): void {\n    this.cancelCallbackBindImpl();\n  }\n\n  private cancelCallbackBindImpl(): void {\n    Log.info(TAG, 'AlbumSet rename cancel');\n  }\n\n  onCompleted(): void {\n    Log.info(TAG, 'Rename data succeed!');\n    if (this.onOperationEnd != null) this.onOperationEnd();\n  }\n\n  onError(): void {\n    Log.error(TAG, 'Rename data failed!');\n    if (this.onOperationEnd != null) this.onOperationEnd();\n  }\n}\n", "llm_cg": {"AlbumSetRenameMenuOperation.doAction()": ["Log.warn(string, string)", "ItemDataSource.getSelectedCount()", "ItemDataSource.getSelectedItems()", "Log.warn(string, string)", "Log.info(string, string)", "MenuContext.broadCast.emit(string, Array)"], "AlbumSetRenameMenuOperation.confirmCallback(string)": ["AlbumSetRenameMenuOperation.confirmCallbackBindImpl(string)"], "AlbumSetRenameMenuOperation.confirmCallbackBindImpl(string)": ["Log.info(string, string)", "MenuContext.onOperationStart()", "AlbumSetRenameMenuOperation.rename(string)"], "AlbumSetRenameMenuOperation.checkAlbumExit(SimpleAlbumDataItem)": ["userFileModel.getUserAlbumCountByName(string)"], "AlbumSetRenameMenuOperation.rename(string)": ["AlbumSetRenameMenuOperation.checkAlbumExit(SimpleAlbumDataItem)", "getResourceString(string)", "showToast(string)", "Log.warn(string, string)", "AlbumSetRenameMenuOperation.onError()", "Log.info(string, string)", "userFileModel.getUserAlbumByName(string)", "photoAccessHelper.Album.commitModify()", "AlbumSetRenameMenuOperation.onCompleted()", "Log.error(string, string)", "AlbumSetRenameMenuOperation.onError()"], "AlbumSetRenameMenuOperation.cancelCallback()": ["AlbumSetRenameMenuOperation.cancelCallbackBindImpl()"], "AlbumSetRenameMenuOperation.cancelCallbackBindImpl()": ["Log.info(string, string)"], "AlbumSetRenameMenuOperation.onCompleted()": ["Log.info(string, string)", "MenuContext.onOperationEnd()"], "AlbumSetRenameMenuOperation.onError()": ["Log.error(string, string)", "MenuContext.onOperationEnd()"]}, "static_cg": {"@test/27.ts: AlbumSetRenameMenuOperation.confirmCallback(string)": ["@test/27.ts: AlbumSetRenameMenuOperation.confirmCallbackBindImpl(string)"], "@test/27.ts: AlbumSetRenameMenuOperation.confirmCallbackBindImpl(string)": ["@test/27.ts: AlbumSetRenameMenuOperation.rename(unknown)"], "@test/27.ts: AlbumSetRenameMenuOperation.rename(unknown)": ["@test/27.ts: AlbumSetRenameMenuOperation.checkAlbumExit(SimpleAlbumDataItem)", "@test/27.ts: AlbumSetRenameMenuOperation.%AM2$rename(string)", "@test/27.ts: AlbumSetRenameMenuOperation.onError()", "@test/27.ts: AlbumSetRenameMenuOperation.onCompleted()"], "@test/27.ts: AlbumSetRenameMenuOperation.cancelCallback()": ["@test/27.ts: AlbumSetRenameMenuOperation.cancelCallbackBindImpl()"], "@test/27.ts: AlbumSetRenameMenuOperation.%AM0$doAction(string)": ["@test/27.ts: AlbumSetRenameMenuOperation.confirmCallbackBindImpl(string)"], "@test/27.ts: AlbumSetRenameMenuOperation.%AM1$doAction()": ["@test/27.ts: AlbumSetRenameMenuOperation.cancelCallbackBindImpl()"]}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Log } from '../utils/Log';\nimport { ItemDataSource } from '../common/ItemDataSource';\nimport { MenuContext } from './MenuContext';\nimport { BroadcastConstants } from '../constants/BroadcastConstants';\nimport { ProcessMenuOperation } from './ProcessMenuOperation';\nimport { UserFileDataItem } from '../base/UserFileDataItem';\nimport { MediaConstants } from '../constants/MediaConstants';\n\nconst TAG = 'BatchDeleteMenuOperation';\n\nexport class BatchDeleteMenuOperation extends ProcessMenuOperation {\n\n  constructor(menuContext: MenuContext) {\n    super(menuContext);\n  }\n\n  doAction(): void {\n    Log.info(TAG, 'delete doAction');\n    if (this.menuContext == null) {\n      Log.warn(TAG, 'menuContext is null, return');\n      return;\n    }\n\n    let dataSource: ItemDataSource = this.menuContext.dataSource;\n    if (dataSource == null) {\n      this.count = this.menuContext.items.length;\n    } else {\n      this.count = dataSource.getSelectedCount();\n    }\n    if (this.count <= 0) {\n      Log.warn(TAG, 'count <= 0, return');\n      return;\n    }\n\n    this.confirmCallback = (): void => this.confirmCallbackBindImpl();\n    this.cancelCallback = (): void => this.cancelCallbackBindImpl();\n\n    let resource: Resource = this.getDeleteMessageResource(dataSource);\n    let deleteResource: Resource = this.menuContext.albumId === MediaConstants.ALBUM_ID_RECYCLE ? $r('app.string.dialog_recycle') : $r('app.string.dialog_delete');\n    this.menuContext.broadCast.emit(BroadcastConstants.SHOW_DELETE_DIALOG, [resource, deleteResource, this.confirmCallback, this.cancelCallback]);\n  }\n\n  getResourceFromBrowser(): Resource {\n    return this.menuContext.albumId === MediaConstants.ALBUM_ID_RECYCLE ? $r('app.string.recycle_single_file_tips') : $r('app.string.delete_single_file_tips');\n  }\n\n  getResourceFromGrid(dataSource: ItemDataSource): Resource {\n    if (dataSource != null && dataSource.isSelect()) {\n      return this.menuContext.albumId === MediaConstants.ALBUM_ID_RECYCLE ? $r('app.string.recycle_all_files_tips') : $r('app.string.delete_all_files_tips');\n    } else if (this.count === 1) {\n      return this.menuContext.albumId === MediaConstants.ALBUM_ID_RECYCLE ? $r('app.string.recycle_single_file_tips') : $r('app.string.delete_single_file_tips');\n    } else {\n      return this.menuContext.albumId === MediaConstants.ALBUM_ID_RECYCLE ? $r('app.string.recycle_files_tips', this.count) : $r('app.string.delete_files_tips', this.count);\n    }\n  }\n\n  getDeleteMessageResource(dataSource: ItemDataSource): Resource {\n    let resource: Resource;\n    if (this.menuContext.deletePageFromType === BroadcastConstants.DELETE_FROM_BROWSER) {\n      resource = this.getResourceFromBrowser();\n    } else {\n      resource = this.getResourceFromGrid(dataSource);\n    }\n    return resource;\n  }\n\n  confirmCallback(): void {\n    this.confirmCallbackBindImpl();\n  }\n\n  protected confirmCallbackBindImpl(): void {\n    Log.info(TAG, 'Batch delete confirm');\n    AppStorage.SetOrCreate<number>('isDelete', 1);\n\n    // 1. Variable initialization\n    this.onOperationEnd = this.menuContext.onOperationEnd;\n\n    // 2. onDeleteStart exit selection mode\n    let onOperationStart: Function = this.menuContext.onOperationStart;\n    if (onOperationStart != null) {\n      onOperationStart();\n    }\n\n    this.menuContext.broadCast.emit(BroadcastConstants.DELETE_PROGRESS_DIALOG,\n      [$r('app.string.action_delete'), this.count]);\n\n    // 3. selectManager gets the URI of the data and starts processing deletion in the callback\n    let dataSource: ItemDataSource = this.menuContext.dataSource;\n    if (dataSource == null) {\n      this.items = this.menuContext.items;\n    } else {\n      this.items = dataSource.getSelectedItems();\n    }\n    this.processOperation();\n  }\n\n  requestOneBatchOperation(): void {\n    let item = this.items[this.currentBatch] as UserFileDataItem;\n    if (item != null) {\n      item.onDelete().then<void, void>((): void => {\n        this.currentBatch++;\n        this.menuContext.broadCast.emit(BroadcastConstants.UPDATE_PROGRESS, [this.getExpectProgress(), this.currentBatch]);\n        this.cyclicOperation();\n      })\n    }\n  }\n\n  cancelCallback(): void {\n    this.cancelCallbackBindImpl();\n  }\n\n  protected cancelCallbackBindImpl(): void {\n    Log.info(TAG, 'Batch delete cancel');\n  }\n}\n", "llm_cg": {"BatchDeleteMenuOperation.doAction()": ["Log.info(unknown, unknown)", "Log.warn(unknown, unknown)", "ItemDataSource.getSelectedCount()", "BatchDeleteMenuOperation.getDeleteMessageResource(ItemDataSource)", "MenuContext.broadCast.emit(unknown, unknown)"], "BatchDeleteMenuOperation.getResourceFromBrowser()": [], "BatchDeleteMenuOperation.getResourceFromGrid(ItemDataSource)": ["ItemDataSource.isSelect()"], "BatchDeleteMenuOperation.getDeleteMessageResource(ItemDataSource)": ["BatchDeleteMenuOperation.getResourceFromBrowser()", "BatchDeleteMenuOperation.getResourceFromGrid(ItemDataSource)"], "BatchDeleteMenuOperation.confirmCallback()": ["BatchDeleteMenuOperation.confirmCallbackBindImpl()"], "BatchDeleteMenuOperation.confirmCallbackBindImpl()": ["Log.info(unknown, unknown)", "AppStorage.SetOrCreate(unknown, unknown)", "MenuContext.onOperationStart()", "MenuContext.broadCast.emit(unknown, unknown)", "ItemDataSource.getSelectedItems()", "BatchDeleteMenuOperation.processOperation()"], "BatchDeleteMenuOperation.requestOneBatchOperation()": ["UserFileDataItem.onDelete()", "MenuContext.broadCast.emit(unknown, unknown)", "BatchDeleteMenuOperation.cyclicOperation()"], "BatchDeleteMenuOperation.cancelCallback()": ["BatchDeleteMenuOperation.cancelCallbackBindImpl()"], "BatchDeleteMenuOperation.cancelCallbackBindImpl()": ["Log.info(unknown, unknown)"]}, "static_cg": {"@test/28.ts: BatchDeleteMenuOperation.doAction()": ["@test/28.ts: BatchDeleteMenuOperation.getDeleteMessageResource(ItemDataSource)"], "@test/28.ts: BatchDeleteMenuOperation.getDeleteMessageResource(ItemDataSource)": ["@test/28.ts: BatchDeleteMenuOperation.getResourceFromBrowser()", "@test/28.ts: BatchDeleteMenuOperation.getResourceFromGrid(ItemDataSource)"], "@test/28.ts: BatchDeleteMenuOperation.confirmCallback()": ["@test/28.ts: BatchDeleteMenuOperation.confirmCallbackBindImpl()"], "@test/28.ts: BatchDeleteMenuOperation.requestOneBatchOperation()": ["@test/28.ts: BatchDeleteMenuOperation.%AM2$requestOneBatchOperation()"], "@test/28.ts: BatchDeleteMenuOperation.cancelCallback()": ["@test/28.ts: BatchDeleteMenuOperation.cancelCallbackBindImpl()"], "@test/28.ts: BatchDeleteMenuOperation.%AM0$doAction()": ["@test/28.ts: BatchDeleteMenuOperation.confirmCallbackBindImpl()"], "@test/28.ts: BatchDeleteMenuOperation.%AM1$doAction()": ["@test/28.ts: BatchDeleteMenuOperation.cancelCallbackBindImpl()"]}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport photoAccessHelper from '@ohos.file.photoAccessHelper';\nimport { AsyncCallback } from './AsyncCallback';\nimport { Log } from '../utils/Log';\nimport { MenuOperationCallback } from './MenuOperationCallback';\nimport { MenuOperation } from './MenuOperation';\nimport { MenuContext } from './MenuContext';\nimport { BroadcastConstants } from '../constants/BroadcastConstants';\nimport { SimpleAlbumDataItem } from '../common/SimpleAlbumDataItem';\nimport { userFileModel } from '../base/UserFileModel';\n\nexport enum FindSameOperation {\n  NONE,\n  REPLACE,\n  SKIP\n}\n\nexport interface Assets {\n  sourceAsset: photoAccessHelper.PhotoAsset,\n  targetAsset: photoAccessHelper.PhotoAsset\n}\n\nconst TAG = 'ProcessMenuOperation';\n\nexport class ProcessMenuOperation implements MenuOperation, AsyncCallback<String[]>, MenuOperationCallback {\n  // Number of data operated in a batch\n  readonly BATCH_SIZE: number = 1;\n\n  // Maximum progress\n  readonly MAX_PROGRESS: number = 100;\n  items: Object[] = [];\n  menuContext: MenuContext;\n  uris: string[];\n  count: number;\n  onOperationEnd: Function;\n\n  // Total batches operated\n  totalBatches: number;\n\n  // Currently operated batch\n  currentBatch: number = 0;\n  successBatch: number = 0;\n  isCancelled: boolean = false;\n  startTime: number;\n  isPause: boolean = false;\n  isError: boolean = false;\n  findSameOperation: number = FindSameOperation.NONE;\n  requestTime: number;\n\n  constructor(menuContext: MenuContext) {\n    this.menuContext = menuContext;\n    this.requestTime = Date.now();\n  }\n\n  doAction(): void {\n  }\n\n  // Asynchronous callback for getSelection\n  callback(uris: string[]): void {\n    this.callbackBindImpl(uris);\n  }\n\n  protected callbackBindImpl(uris: string[]): void {\n  }\n\n  onCompleted(): void {\n    Log.info(TAG, 'onCompleted ' + this.isPause);\n    this.successBatch++;\n    if (!this.isPause) {\n      this.cyclicOperation();\n    }\n  }\n\n  onError(): void {\n    Log.error(TAG, 'Operate the ' + this.currentBatch + ' batch data error, total ' + this.totalBatches + ' batches');\n    this.isError = true;\n    this.cyclicOperation();\n  }\n\n  // Start processing operation\n  processOperation(): void {\n    Log.info(TAG, 'processOperation start');\n    let length = this.items.length;\n    Log.info(TAG, 'selected count: ' + this.count + ', uris length: ' + length);\n    // Batch deletion\n    this.totalBatches = Math.floor(length / this.BATCH_SIZE) + (((length % this.BATCH_SIZE) ? 1 : 0) as number);\n    Log.info(TAG, 'The count to be operate is ' + length + ', operate in ' + this.totalBatches + ' batches');\n    if (this.isCancelled) {\n      this.isCancelled = false;\n    }\n    this.startTime = Date.now();\n\n    this.requestOneBatchOperation();\n  }\n\n  // Batch circular deletion\n  cyclicOperation(): void {\n    Log.info(TAG, 'cyclicOperation');\n    this.menuContext.broadCast.emit(BroadcastConstants.UPDATE_PROGRESS, [this.getExpectProgress(), this.currentBatch]);\n\n    if (this.isCancelled) {\n      this.onProcessDone();\n    }\n\n    if (this.currentBatch >= this.totalBatches || this.isError) {\n      this.onProcessDone();\n    } else {\n      this.requestOneBatchOperation();\n    }\n  }\n\n  // Operate a batch of data\n  requestOneBatchOperation(): void {\n  }\n\n  onProcessDone(): void {\n    this.menuContext.broadCast.emit(BroadcastConstants.UPDATE_PROGRESS, [100]);\n    this.findSameOperation = FindSameOperation.NONE;\n    if (this.startTime != null) {\n      let operateCount = this.currentBatch >= this.totalBatches ? this.count : this.currentBatch * this.BATCH_SIZE;\n      let costTime = Date.now() - this.startTime;\n      Log.debug(TAG, 'process data operate done, operate ' + operateCount + ' items, cost time ' + costTime +\n      ' ms, average ' + (costTime / operateCount) + ' ms/item.');\n    }\n    this.isCancelled = false;\n    if (this.onOperationEnd != null) this.onOperationEnd(this.isError, this.successBatch, this.count);\n  }\n\n  // Operate cancel callback\n  onOperateCancelled(): void {\n    this.onOperateCancelledBindImpl();\n  }\n\n  protected onOperateCancelledBindImpl(): void {\n    Log.info(TAG, 'Operate Cancel');\n    this.isCancelled = true;\n    this.onProcessDone();\n  }\n\n  // Operate cancel callback\n  onOperatePause(): void {\n    Log.info(TAG, 'Operate Pause');\n    this.isPause = true;\n  }\n\n  // Calculate the operation progress according to the batch\n  getExpectProgress(): number {\n    Log.info(TAG, 'getExpectProgress');\n    let progress = Math.min(\n      Math.floor(this.MAX_PROGRESS * this.currentBatch * this.BATCH_SIZE / this.count), this.MAX_PROGRESS);\n    return progress;\n  }\n\n  setFindSameOperation(newOperation: number): void {\n    this.setFindSameOperationBindImpl(newOperation);\n  }\n\n  protected setFindSameOperationBindImpl(newOperation: number): void {\n    Log.info(TAG, 'setFindSameOperation ' + newOperation);\n    this.findSameOperation = newOperation;\n  }\n}\n", "llm_cg": {"ProcessMenuOperation.callback(string[])": ["ProcessMenuOperation.%AM0$callbackBindImpl(string[])"], "ProcessMenuOperation.onCompleted()": ["Log.info(string, string)", "ProcessMenuOperation.cyclicOperation()"], "ProcessMenuOperation.onError()": ["Log.error(string, string)", "ProcessMenuOperation.cyclicOperation()"], "ProcessMenuOperation.processOperation()": ["Log.info(string, string)", "Log.info(string, string)", "Log.info(string, string)", "ProcessMenuOperation.requestOneBatchOperation()"], "ProcessMenuOperation.cyclicOperation()": ["Log.info(string, string)", "MenuContext.broadCast.emit(string, [number, number])", "ProcessMenuOperation.onProcessDone()", "ProcessMenuOperation.requestOneBatchOperation()"], "ProcessMenuOperation.onProcessDone()": ["MenuContext.broadCast.emit(string, [number])", "Log.debug(string, string)"], "ProcessMenuOperation.onOperateCancelled()": ["ProcessMenuOperation.%AM1$onOperateCancelledBindImpl()"], "ProcessMenuOperation.%AM1$onOperateCancelledBindImpl()": ["Log.info(string, string)", "ProcessMenuOperation.onProcessDone()"], "ProcessMenuOperation.onOperatePause()": ["Log.info(string, string)"], "ProcessMenuOperation.getExpectProgress()": ["Log.info(string, string)"], "ProcessMenuOperation.setFindSameOperation(number)": ["ProcessMenuOperation.%AM2$setFindSameOperationBindImpl(number)"], "ProcessMenuOperation.%AM2$setFindSameOperationBindImpl(number)": ["Log.info(string, string)"]}, "static_cg": {"@test/29.ts: ProcessMenuOperation.callback(string[])": ["@test/29.ts: ProcessMenuOperation.callbackBindImpl(string[])"], "@test/29.ts: ProcessMenuOperation.onCompleted()": ["@test/29.ts: ProcessMenuOperation.cyclicOperation()"], "@test/29.ts: ProcessMenuOperation.onError()": ["@test/29.ts: ProcessMenuOperation.cyclicOperation()"], "@test/29.ts: ProcessMenuOperation.processOperation()": ["@test/29.ts: ProcessMenuOperation.requestOneBatchOperation()"], "@test/29.ts: ProcessMenuOperation.cyclicOperation()": ["@test/29.ts: ProcessMenuOperation.getExpectProgress()", "@test/29.ts: ProcessMenuOperation.onProcessDone()", "@test/29.ts: ProcessMenuOperation.requestOneBatchOperation()"], "@test/29.ts: ProcessMenuOperation.onOperateCancelled()": ["@test/29.ts: ProcessMenuOperation.onOperateCancelledBindImpl()"], "@test/29.ts: ProcessMenuOperation.onOperateCancelledBindImpl()": ["@test/29.ts: ProcessMenuOperation.onProcessDone()"], "@test/29.ts: ProcessMenuOperation.setFindSameOperation(number)": ["@test/29.ts: ProcessMenuOperation.setFindSameOperationBindImpl(number)"]}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport interface MenuOperationCallback {\n  onCompleted(): void;\n\n  onError(): void;\n}", "llm_cg": {"MenuOperationCallback.onCompleted()": [], "MenuOperationCallback.onError()": []}, "static_cg": {}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Log } from '../utils/Log';\nimport { AlbumDataItem } from './AlbumDataItem';\nimport { MediaConstants } from '../constants/MediaConstants';\nimport { userFileModel } from '../base/UserFileModel';\nimport { getAlbumDisplayName } from '../base/UserFileDataHelper';\nimport photoAccessHelper from '@ohos.file.photoAccessHelper';\nimport dataSharePredicates from '@ohos.data.dataSharePredicates';\n\nconst TAG = 'AlbumDataImpl';\n\nexport class AlbumDataImpl {\n  private blackList: string[] = [];\n  private selectType: number = MediaConstants.SELECT_TYPE_ALL;\n  private deviceId: string = '';\n\n  setBlackList(blackList: string[]): void {\n    this.blackList = blackList;\n  }\n\n  setSelectType(selectType: number): void {\n    this.selectType = selectType;\n  }\n\n  setDeviceId(deviceId: string): void {\n    this.deviceId = deviceId;\n  }\n\n  async reloadAlbumItemData(): Promise<AlbumDataItem[]> {\n    Log.info(TAG, 'reloadAlbumItemData');\n    let albumDataItems: AlbumDataItem[] = [];\n    for (let i = 0;i < MediaConstants.ALBUM_DEFAULT_SORT_LIST.length; i++) {\n      await this.getAlbumItem(MediaConstants.ALBUM_DEFAULT_SORT_LIST[i], albumDataItems);\n    }\n    await this.getAlbumItem(MediaConstants.ALBUM_ID_USER, albumDataItems);\n    await this.getAlbumItem(MediaConstants.ALBUM_ID_RECYCLE, albumDataItems);\n    return albumDataItems;\n  }\n\n  private async getAlbumItem(id: string, albumDataItems: AlbumDataItem[]): Promise<void> {\n    Log.info(TAG, 'getAlbumItem: ' + id);\n    if (this.blackList.indexOf(id) >= 0) {\n      Log.debug(TAG, 'no need as in black list');\n      return;\n    }\n    if (this.deviceId.length > 0 && (id !== MediaConstants.ALBUM_ID_SNAPSHOT && id !== MediaConstants.ALBUM_ID_CAMERA)) {\n      Log.info(TAG, 'no need');\n      return;\n    }\n    let albumType = MediaConstants.ALBUM_TYPE_SYSTEM;\n    let albumSubType = MediaConstants.ALBUM_SUBTYPE_USER_GENERIC;\n    switch (id) {\n      case MediaConstants.ALBUM_ID_FAVOR:\n        albumSubType = MediaConstants.ALBUM_SUBTYPE_FAVOR;\n        break;\n      case MediaConstants.ALBUM_ID_CAMERA:\n        albumSubType = MediaConstants.ALBUM_SUBTYPE_CAMERA;\n        break;\n      case MediaConstants.ALBUM_ID_RECYCLE:\n        albumSubType = MediaConstants.ALBUM_SUBTYPE_RECYCLE;\n        break;\n      case MediaConstants.ALBUM_ID_SNAPSHOT:\n        albumSubType = MediaConstants.ALBUM_SUBTYPE_SNAPSHOT;\n        break;\n      case MediaConstants.ALBUM_ID_VIDEO:\n        albumSubType = MediaConstants.ALBUM_SUBTYPE_VIDEO;\n        break;\n      case MediaConstants.ALBUM_ID_ALL:\n        await this.getAllPhotoAlbum(albumDataItems);\n        return;\n      case MediaConstants.ALBUM_ID_USER:\n        albumType = MediaConstants.ALBUM_TYPE_USER;\n        albumSubType = MediaConstants.ALBUM_SUBTYPE_USER_GENERIC;\n        break;\n      case MediaConstants.ALBUM_ID_MOVING_PHOTO:\n        await this.getMovingPhotoAbstractAlbum(albumDataItems);\n        return;\n      default:\n        break;\n    }\n    await this.getAlbumItemByUserFileMgr(id, albumType, albumSubType, albumDataItems);\n  }\n\n  private async getAlbumItemByUserFileMgr(id: string, type: photoAccessHelper.AlbumType, subType: photoAccessHelper.AlbumSubtype, albumDataItems: AlbumDataItem[]): Promise<void> {\n    let fetchResult:photoAccessHelper.FetchResult<photoAccessHelper.Album> = null;\n    try {\n      Log.info(TAG, 'getAlbumItemByUserFileMgr');\n      fetchResult = await userFileModel.getUserFileMgr().getAlbums(type, subType);\n      Log.info(TAG, 'type:' + type);\n      Log.info(TAG, 'subType:' + subType);\n      Log.info(TAG, 'get Album fetchResult, count: ' + fetchResult.getCount());\n      for (let i = 0; i < fetchResult.getCount(); i++) {\n        let albumAsset:photoAccessHelper.Album = await fetchResult.getObjectByPosition(i);\n        Log.info(TAG, 'albumAsset albumType: ' + i + '---' + albumAsset.albumType);\n        Log.info(TAG, 'albumAsset albumSubType: ' + i + '---' + albumAsset.albumSubtype);\n        Log.info(TAG, 'albumAsset albumName: ' + i + '---' + albumAsset.albumName);\n        Log.info(TAG, 'albumAsset albumUri: ' + i + '---' + albumAsset.albumUri);\n        if (this.blackList.indexOf(albumAsset.albumUri) >= 0) {\n          Log.debug(TAG, 'no need as in black list:'+albumAsset.albumUri);\n          continue;\n        }\n        Log.info(TAG, 'albumAsset count: ' + i + '---' + albumAsset.count);\n        Log.info(TAG, 'albumAsset coverUri: ' + i + '---' + albumAsset.coverUri);\n        let photoFetchResult:photoAccessHelper.FetchResult<photoAccessHelper.PhotoAsset> = null;\n        let fileAsset:photoAccessHelper.PhotoAsset = null;\n        let count = 0;\n        try {\n          let predicates = new dataSharePredicates.DataSharePredicates();\n          let fetchOptions = {\n            fetchColumns: MediaConstants.FILE_ASSET_FETCH_COLUMNS,\n            predicates: predicates\n          };\n          photoFetchResult = await albumAsset.getAssets(fetchOptions);\n          count = photoFetchResult.getCount();\n          Log.info(TAG, 'photoFetchResult count: ' + count);\n          let displayName = 'unknown';\n          if (id === MediaConstants.ALBUM_ID_USER) {\n            displayName = albumAsset.albumName;\n          } else {\n            displayName = await getAlbumDisplayName(id);\n          }\n          let albumType = albumAsset.albumType;\n          let albumSubType = albumAsset.albumSubtype;\n          let albumItem: AlbumDataItem = new AlbumDataItem(id, count, displayName, this.selectType, this.deviceId, albumType, albumSubType);\n          albumItem.uri = albumAsset.albumUri;\n          if (count > 0) {\n            fileAsset = await photoFetchResult.getFirstObject();\n            Log.info(TAG, 'getFirstObject file displayName: ' + fileAsset.displayName);\n            await albumItem.update(fileAsset);\n          }\n          albumDataItems.push(albumItem);\n        } catch (err) {\n          Log.error(TAG, 'get Album getPhotoAssets failed with err: ' + err);\n        } finally {\n          if (photoFetchResult != null) {\n            photoFetchResult.close();\n          }\n        }\n      }\n    } catch (err) {\n      Log.error(TAG, 'get Album fetchResult failed with err: ' + err);\n    } finally {\n      if (fetchResult != null) {\n        fetchResult.close();\n      }\n    }\n  }\n\n  async getUserAlbumItemByUri(uri: string): Promise<photoAccessHelper.Album> {\n    let fetchResult:photoAccessHelper.FetchResult<photoAccessHelper.Album> = null;\n    let album: photoAccessHelper.Album = null;\n    try {\n      Log.info(TAG, 'getUserAlbumItemByUri');\n      let predicates = new dataSharePredicates.DataSharePredicates();\n      predicates.equalTo(photoAccessHelper.AlbumKeys.URI, uri);\n      let fetchOptions = {\n        fetchColumns: MediaConstants.EMPTY_FETCH_COLUMNS,\n        predicates: predicates\n      };\n      fetchResult = await userFileModel.getUserFileMgr().getAlbums(photoAccessHelper.AlbumType.USER, photoAccessHelper.AlbumSubtype.USER_GENERIC, fetchOptions);\n      Log.info(TAG, 'get Album fetchResult, count: ' + fetchResult.getCount());\n      if (fetchResult.getCount() > 0) {\n        album = await fetchResult.getFirstObject();\n      }\n    } catch (err) {\n      Log.error(TAG, 'get Album fetchResult failed with err: ' + err);\n    } finally {\n      if (fetchResult != null) {\n        fetchResult.close();\n      }\n    }\n    return album;\n  }\n\n  async removeFileFromAlbum(albumUri: string, uri: string): Promise<boolean> {\n    let album = await this.getUserAlbumItemByUri(albumUri);\n    let fileAsset = await userFileModel.getMediaItemByUri(uri);\n    if (album != null && fileAsset != null) {\n      try {\n        await album.removeAssets([fileAsset]);\n        return true;\n      } catch (err) {\n        Log.error(TAG, 'album removePhotoAssets failed with error: ' + err);\n      }\n    }\n    return false;\n  }\n\n  async getAllPhotoAlbum(albumDataItems: AlbumDataItem[]): Promise<void> {\n    let photoFetchResult = null;\n    try {\n      let predicates = new dataSharePredicates.DataSharePredicates();\n      let fetchOptions = {\n        fetchColumns: MediaConstants.FILE_ASSET_FETCH_COLUMNS,\n        predicates: predicates\n      };\n      photoFetchResult = await userFileModel.getUserFileMgr().getAssets(fetchOptions);\n      let count = photoFetchResult.getCount();\n      Log.info(TAG, 'getAllPhotoAlbum count: ' + count);\n      let displayName = '';\n      let id = MediaConstants.ALBUM_ID_ALL;\n      displayName = await getAlbumDisplayName(id);\n      let albumItem: AlbumDataItem = new AlbumDataItem(id, count, displayName, this.selectType, this.deviceId, -1, -1);\n      if (count > 0) {\n        let fileAsset = await photoFetchResult.getFirstObject();\n        await albumItem.update(fileAsset);\n        Log.info(TAG, 'getFirstObject file displayName: ' + fileAsset.displayName);\n      }\n      albumDataItems.push(albumItem);\n    } catch (err) {\n      Log.error(TAG, 'get Album getPhotoAssets failed with err: ' + err);\n    } finally {\n      if (photoFetchResult != null) {\n        photoFetchResult.close();\n      }\n    }\n  }\n\n  async getMovingPhotoAbstractAlbum(albumDataItems: AlbumDataItem[]): Promise<void> {\n    let photoFetchResult: photoAccessHelper.FetchResult<photoAccessHelper.PhotoAsset> = null;\n    try {\n      let predicates = new dataSharePredicates.DataSharePredicates();\n      predicates.equalTo(MediaConstants.PHOTO_SUBTYPE, MediaConstants.MOVING_PHOTO);\n      let fetchOptions: photoAccessHelper.FetchOptions = {\n        fetchColumns: MediaConstants.FILE_ASSET_FETCH_COLUMNS,\n        predicates: predicates\n      };\n      photoFetchResult = await userFileModel.getUserFileMgr().getAssets(fetchOptions);\n      let count = photoFetchResult.getCount();\n      Log.info(TAG, 'getMovingPhotoAbstractAlbum count: ' + count);\n      let id = MediaConstants.ALBUM_ID_MOVING_PHOTO;\n      let albumName = await getAlbumDisplayName(id);\n      let albumItem: AlbumDataItem = new AlbumDataItem(id, count, albumName, this.selectType, this.deviceId,\n        MediaConstants.ABSTRACT_ALBUM_TYPE_MOVING_PHOTO, -1);\n      if (count > 0) {\n        let fileAsset = await photoFetchResult.getFirstObject();\n        await albumItem.update(fileAsset);\n        Log.info(TAG, 'first moving photo displayName: ' + fileAsset.displayName);\n      }\n      albumDataItems.push(albumItem);\n    } catch (err) {\n      Log.error(TAG, 'getMovingPhotoAbstractAlbum failed with err: ' + err);\n    } finally {\n      if (photoFetchResult != null) {\n        photoFetchResult.close();\n      }\n    }\n  }\n\n  async reloadAlbumListItemData(): Promise<AlbumDataItem[]> {\n    Log.info(TAG, 'reloadAlbumListItemData start');\n    let albumDataItems: AlbumDataItem[] = [];\n    for (let i = 0;i < MediaConstants.ALBUM_DEFAULT_SORT_LIST.length; i++) {\n      await this.getAlbumItem(MediaConstants.ALBUM_DEFAULT_SORT_LIST[i], albumDataItems);\n    }\n    await this.getCommonListAlbumItem(albumDataItems);\n    return albumDataItems;\n  }\n\n  private async getCommonListAlbumItem(albumDataItems: AlbumDataItem[]): Promise<void> {\n    let predicates = new dataSharePredicates.DataSharePredicates();\n    let fetchOptions = {\n      fetchColumns: MediaConstants.EMPTY_FETCH_COLUMNS,\n      predicates: predicates\n    };\n    let albums: photoAccessHelper.Album[] = await userFileModel.getAlbums(fetchOptions);\n    await this.getAlbumDataItem(albumDataItems, albums);\n  }\n\n  private async getAlbumDataItem(albumDataItems: AlbumDataItem[], albums: photoAccessHelper.Album[]): Promise<void> {\n    for (let i = 0;i < albums.length; i++) {\n      let album: photoAccessHelper.Album = albums[i];\n      if (this.blackList.indexOf(album.albumUri.toString()) >= 0) {\n        continue;\n      }\n      let predicates = new dataSharePredicates.DataSharePredicates();\n      let fetchOptions = {\n        fetchColumns: MediaConstants.FILE_ASSET_FETCH_COLUMNS,\n        predicates: predicates\n      };\n      let fetchFileResult = await album.getAssets(fetchOptions);\n      try {\n        let count = fetchFileResult.getCount();\n        if (count === 0) {\n          continue;\n        }\n        let item = new AlbumDataItem(MediaConstants.ALBUM_ID_USER, count, album.albumName, this.selectType, this.deviceId, 0, 0);\n        item.uri = album.albumUri;\n        await item.update(await fetchFileResult.getFirstObject());\n        albumDataItems.push(item);\n      } catch (err) {\n        Log.error(TAG, 'on err: ' + JSON.stringify(err));\n      } finally {\n        fetchFileResult.close();\n      }\n    }\n  }\n}\n", "llm_cg": {"AlbumDataImpl.reloadAlbumItemData()": ["AlbumDataImpl.getAlbumItem(string, AlbumDataItem[])"], "AlbumDataImpl.getAlbumItem(string, AlbumDataItem[])": ["AlbumDataImpl.getAlbumItemByUserFileMgr(string, photoAccessHelper.AlbumType, photoAccessHelper.AlbumSubtype, AlbumDataItem[])", "AlbumDataImpl.getAllPhotoAlbum(AlbumDataItem[])", "AlbumDataImpl.getMovingPhotoAbstractAlbum(AlbumDataItem[])"], "AlbumDataImpl.getAlbumItemByUserFileMgr(string, photoAccessHelper.AlbumType, photoAccessHelper.AlbumSubtype, AlbumDataItem[])": ["userFileModel.getUserFileMgr().getAlbums(photoAccessHelper.AlbumType, photoAccessHelper.AlbumSubtype)", "fetchResult.getCount()", "fetchResult.getObjectByPosition(number)", "albumAsset.getAssets(dataSharePredicates.DataSharePredicates)", "photoFetchResult.getCount()", "getAlbumDisplayName(string)", "AlbumDataItem.update(photoAccessHelper.PhotoAsset)", "photoFetchResult.getFirstObject()", "photoFetchResult.close()"], "AlbumDataImpl.getUserAlbumItemByUri(string)": ["userFileModel.getUserFileMgr().getAlbums(photoAccessHelper.AlbumType, photoAccessHelper.AlbumSubtype, dataSharePredicates.DataSharePredicates)", "fetchResult.getCount()", "fetchResult.getFirstObject()", "fetchResult.close()"], "AlbumDataImpl.removeFileFromAlbum(string, string)": ["AlbumDataImpl.getUserAlbumItemByUri(string)", "userFileModel.getMediaItemByUri(string)", "album.removeAssets(photoAccessHelper.PhotoAsset[])"], "AlbumDataImpl.getAllPhotoAlbum(AlbumDataItem[])": ["userFileModel.getUserFileMgr().getAssets(dataSharePredicates.DataSharePredicates)", "photoFetchResult.getCount()", "getAlbumDisplayName(string)", "AlbumDataItem.update(photoAccessHelper.PhotoAsset)", "photoFetchResult.getFirstObject()", "photoFetchResult.close()"], "AlbumDataImpl.getMovingPhotoAbstractAlbum(AlbumDataItem[])": ["userFileModel.getUserFileMgr().getAssets(dataSharePredicates.DataSharePredicates)", "photoFetchResult.getCount()", "getAlbumDisplayName(string)", "AlbumDataItem.update(photoAccessHelper.PhotoAsset)", "photoFetchResult.getFirstObject()", "photoFetchResult.close()"], "AlbumDataImpl.reloadAlbumListItemData()": ["AlbumDataImpl.getAlbumItem(string, AlbumDataItem[])", "AlbumDataImpl.getCommonListAlbumItem(AlbumDataItem[])"], "AlbumDataImpl.getCommonListAlbumItem(AlbumDataItem[])": ["userFileModel.getAlbums(dataSharePredicates.DataSharePredicates)", "AlbumDataImpl.getAlbumDataItem(AlbumDataItem[], photoAccessHelper.Album[])"], "AlbumDataImpl.getAlbumDataItem(AlbumDataItem[], photoAccessHelper.Album[])": ["album.getAssets(dataSharePredicates.DataSharePredicates)", "fetchFileResult.getCount()", "AlbumDataItem.update(photoAccessHelper.PhotoAsset)", "fetchFileResult.getFirstObject()", "fetchFileResult.close()"]}, "static_cg": {"@test/31.ts: AlbumDataImpl.reloadAlbumItemData()": ["@test/31.ts: AlbumDataImpl.getAlbumItem(string, AlbumDataItem[])"], "@test/31.ts: AlbumDataImpl.getAlbumItem(string, AlbumDataItem[])": ["@test/31.ts: AlbumDataImpl.getAllPhotoAlbum(AlbumDataItem[])", "@test/31.ts: AlbumDataImpl.getAlbumItemByUserFileMgr(string, photoAccessHelper.AlbumType, photoAccessHelper.AlbumSubtype, AlbumDataItem[])", "@test/31.ts: AlbumDataImpl.getMovingPhotoAbstractAlbum(AlbumDataItem[])"], "@test/31.ts: AlbumDataImpl.removeFileFromAlbum(string, string)": ["@test/31.ts: AlbumDataImpl.getUserAlbumItemByUri(string)"], "@test/31.ts: AlbumDataImpl.reloadAlbumListItemData()": ["@test/31.ts: AlbumDataImpl.getAlbumItem(string, AlbumDataItem[])", "@test/31.ts: AlbumDataImpl.getCommonListAlbumItem(AlbumDataItem[])"], "@test/31.ts: AlbumDataImpl.getCommonListAlbumItem(AlbumDataItem[])": ["@test/31.ts: AlbumDataImpl.getAlbumDataItem(AlbumDataItem[], photoAccessHelper.Album[])"]}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport deviceInfo from '@ohos.deviceInfo';\nimport window from '@ohos.window';\nimport { stashOrGetObject } from '../utils/SingleInstanceUtils';\nimport { Log } from '../utils/Log';\nimport { BroadcastConstants } from '../constants/BroadcastConstants';\nimport { Constants } from '../constants/Constants';\nimport { getResourceString } from '../utils/ResourceUtils';\nimport { GlobalContext } from './GlobalContext';\n\nexport enum ColumnSize {\n  COLUMN_TWO = 2,\n  COLUMN_FOUR = 4,\n  COLUMN_SIX = 6,\n  COLUMN_EIGHT = 8,\n  COLUMN_TWELVE = 12\n}\n\nenum ScreenWidth {\n  WIDTH_MEDIUM = 520,\n  WIDTH_LARGE = 840\n}\n\nenum WindowMode {\n  UNDEFINED = 1,\n  FULL_SCREEN,\n  PRIMARY,\n  SECONDARY,\n  FLOATING\n}\n\ninterface Size {\n  width: number;\n  height: number;\n}\n\ninterface StatusNaviHeight {\n  status: number;\n  navi: number;\n}\n\ninterface GetWindowMode {\n  getWindowMode(): Promise<WindowMode>;\n}\n\nconst TAG = 'ScreenManager';\n\nconst APP_KEY_SCREEN_MANAGER = 'app_key_screen_manager';\n\nconst SCREEN_ORIENTATION_HORIZONTAL: string = 'isHorizontal';\nconst SCREEN_SIDEBAR: string = 'isSidebar';\n\nconst COLUMN_MARGIN: number = 12;\nconst COLUMN_GUTTER: number = 12;\n\ntype CallbackType = Function;\n\nclass ScreenManager {\n  readonly ON_WIN_SIZE_CHANGED = 'on_win_size_changed';\n  readonly ON_LEFT_BLANK_CHANGED = 'on_left_blank_changed';\n  readonly DEFAULT_WIDTH: number = 1920;\n  readonly DEFAULT_HEIGHT: number = 1080;\n  readonly SPLIT_THRESHOLD = 1.7;\n  private winWidth = 0.0;\n  private winHeight = 0.0;\n  private statusBarHeight = 0;\n  private naviBarHeight = 0;\n  private leftBlank: number[] = [0, 0, 0, 0];\n  private events: Map<string, CallbackType[]> = new Map<string, CallbackType[]>();\n  private mainWindow: window.Window = undefined;\n  private globalThis = GlobalContext.getContext();\n\n  // Default orientation\n  private horizontal = deviceInfo.deviceType === 'phone' || deviceInfo.deviceType === 'default' ? false : true;\n\n  // Default sidebar\n  private sidebar = deviceInfo.deviceType === 'phone' || deviceInfo.deviceType === 'default' ? false : true;\n  private windowMode = WindowMode.UNDEFINED;\n\n  constructor() {\n    Log.info(TAG, 'constructor');\n  }\n\n  async initializationSize(win): Promise<void> {\n    this.mainWindow = win;\n    this.setMainWindow(win);\n    await this.checkWindowMode();\n    this.getWindowProperties(win);\n  }\n\n  /**\n   * Add Listeners\n   *\n   * @param event\n   * @param fn\n   */\n  on(event, fn): void {\n    if (Array.isArray(event)) {\n      for (let i = 0, l = event.length; i < l; i++) {\n        this.on(event[i], fn);\n      }\n    } else {\n      if (this.events.get(event) === null || this.events.get(event) === undefined) {\n        this.events.set(event, []);\n      }\n      this.events.get(event).push(fn);\n    }\n  }\n\n  /**\n   * Delete Listeners\n   *\n   * @param event\n   * @param fn\n   */\n  off(event, fn): void {\n    if (event == null || event == undefined) {\n      return;\n    }\n    if (Array.isArray(event)) {\n      for (let i = 0, l = event.length; i < l; i++) {\n        this.off(event[i], fn);\n      }\n    }\n    const cbs: CallbackType[] = this.events.get(event);\n    if (!new Boolean(cbs).valueOf()) {\n      return;\n    }\n    if (fn == null || fn == undefined) {\n      return;\n    }\n    let cb;\n    let i = cbs.length;\n    while (i-- > 0) {\n      cb = cbs[i];\n      if (cb === fn || cb.fn === fn) {\n        cbs.splice(i, 1);\n        break;\n      }\n    }\n  }\n\n  private emit(event, argument: Object[]): void {\n    let _self = this;\n    if (!new Boolean(this.events.get(event)).valueOf()) {\n      return;\n    }\n\n    let cbs: CallbackType[] = [];\n    for (let i = 0; i < this.events.get(event).length; i++) {\n      cbs.push(this.events.get(event)[i]);\n    }\n\n    if (cbs.length > 0) {\n      for (let i = 0, l = cbs.length; i < l; i++) {\n        let ref = cbs[i];\n        if (ref != null) {\n          try {\n            ref.apply(_self, argument);\n          } catch (e) {\n            new Error(e);\n          }\n        }\n      }\n    }\n  }\n\n  private isLeftBlankInitialized(): boolean {\n    return this.leftBlank[0] !== 0 || this.leftBlank[1] !== 0 || this.leftBlank[2] !== 0 || this.leftBlank[3] !== 0;\n  }\n\n  // Unit：vp\n  getWinWidth(): number {\n    return px2vp(this.winWidth);\n  }\n\n  setWinWidth(width: number): void {\n    this.winWidth = width;\n  }\n\n  // Unit：vp\n  getWinHeight(): number {\n    return px2vp(this.winHeight);\n  }\n\n  getStatusBarHeight(): number {\n    return px2vp(this.statusBarHeight);\n  }\n\n  getNaviBarHeight(): number {\n    return px2vp(this.naviBarHeight);\n  }\n\n  async initWindowMode(): Promise<void> {\n    Log.debug(TAG, 'start to initialize photos application window mode: ' + this.windowMode);\n  }\n\n  isSplitMode(): boolean {\n    return (WindowMode.PRIMARY === this.windowMode || WindowMode.SECONDARY === this.windowMode)\n  }\n\n  async checkWindowMode(): Promise<void> {\n    let before = this.windowMode;\n    let photosWindowStage = this.globalThis.getObject('photosWindowStage') as GetWindowMode;\n    let mode = await photosWindowStage.getWindowMode();\n    Log.info(TAG, 'photos application before/current window mode: ' + before + '/' + mode);\n\n    if (before === mode) {\n      return;\n    }\n    this.windowMode = mode;\n\n    if (WindowMode.FULL_SCREEN == this.windowMode) {\n      this.setFullScreen();\n    } else {\n      this.setSplitScreen();\n    }\n  }\n\n  private setMainWindow(win: window.Window): void {\n        Log.debug(TAG, 'setMainWindow');\n        win.on('windowSizeChange', (data: window.Size): void => {\n            Log.debug(TAG, 'windowSizeChange ' + JSON.stringify(data));\n            this.checkWindowMode();\n            this.onWinSizeChanged(data);\n        })\n    }\n\n  private getWindowProperties(win: window.Window): void {\n    Log.debug(TAG, 'getWindowProperties');\n    try {\n      let properties = win.getWindowProperties();\n      if (properties.windowRect.width !== 0 && properties.windowRect.height !== 0) {\n        this.winWidth = properties.windowRect.width;\n        this.winHeight = properties.windowRect.height;\n      }\n      Log.debug(TAG, 'this.winWidth = ' + this.winWidth + ' this.winHeight = ' + this.winHeight);\n    } catch (exception) {\n      console.error('Failed to obtain the window properties. Cause: ' + JSON.stringify(exception));\n    }\n  }\n\n  private async setFullScreen(): Promise<void> {\n    let topWindow: window.Window = AppStorage.Get<window.Window>(Constants.MAIN_WINDOW);\n    Log.debug(TAG, 'getTopWindow start');\n    try {\n      await topWindow.setWindowLayoutFullScreen(true);\n      Log.debug(TAG, 'setFullScreen true Succeeded');\n      await this.hideStatusBar(topWindow);\n    } catch (err) {\n      Log.error(TAG, 'setFullScreen err: ' + err);\n    }\n  }\n\n  setSplitScreen(): void {\n    try {\n      this.statusBarHeight = 0;\n      this.naviBarHeight = 0;\n      this.leftBlank = [0, 0, 0, 0];\n      AppStorage.SetOrCreate<number[]>(BroadcastConstants.LEFT_BLANK, this.leftBlank);\n    } catch (err) {\n      Log.error(TAG, 'setSplitScreen err: ' + err);\n    }\n  }\n\n  private async hideStatusBar(topWindow: window.Window): Promise<void> {\n    Log.debug(TAG, 'hideStatusBar start');\n    let names: string[] = ['navigation'];\n    Log.debug(TAG, 'getTopWindow names: ' + names + ' end');\n    try {\n      // @ts-ignore\n      await topWindow.setWindowSystemBarEnable(names);\n      Log.debug(TAG, 'hideStatusBar Succeeded');\n      let data = await topWindow.getWindowAvoidArea(0)\n      Log.debug(TAG, 'Succeeded in obtaining the area. Data: ' + JSON.stringify(data));\n      this.onLeftBlankChanged(data);\n      let barColor: string = await getResourceString($r('app.color.default_background_color'));\n      let barContentColor: string = await getResourceString($r('app.color.default_bar_content_color'));\n      if (!barColor) {\n        barColor = '#FFF1F3F5';\n      }\n      if (!barContentColor) {\n        barContentColor = '#FF000000';\n      }\n      let systemBarProperties: window.SystemBarProperties = {\n        navigationBarColor: barColor,\n        navigationBarContentColor: barContentColor\n      };\n      await topWindow.setWindowSystemBarProperties(systemBarProperties);\n      Log.info(TAG, 'setStatusBarColor done');\n    } catch (err) {\n      Log.error(TAG, 'hideStatusBar err: ' + err);\n    }\n  }\n\n  async setNavigationBarColor(barColor: string, barContentColor: string): Promise<void> {\n    Log.debug(TAG, 'setNavigationBarColor start');\n    let topWindow: window.Window = AppStorage.Get<window.Window>(Constants.MAIN_WINDOW);\n    try {\n      let systemBarProperties: window.SystemBarProperties = {\n        navigationBarColor: barColor,\n        navigationBarContentColor: barContentColor\n      };\n      topWindow.setWindowSystemBarProperties(\n        systemBarProperties,\n        (): void  => Log.info(TAG, 'setStatusBarColor done')\n      );\n      } catch (err) {\n      Log.error(TAG, 'setNavigationBarColor err: ' + err);\n    }\n  }\n\n  setSystemUi(isShowBar: boolean): void {\n    Log.debug(TAG, 'setSystemUi start');\n    let topWindow: window.Window = AppStorage.Get<window.Window>(Constants.MAIN_WINDOW);\n    Log.debug(TAG, 'getTopWindow start');\n    let names: string[] = ['navigation'];\n    if (!isShowBar) {\n      names = [];\n    }\n    Log.debug(TAG, 'getTopWindow names: ' + names + ' end');\n    try {\n            // @ts-ignore\n            topWindow.setWindowSystemBarEnable(names, async (): Promise<void> => {\n                Log.debug(TAG, 'setFullScreen Succeeded');\n                if (isShowBar) {\n                    let data = await topWindow.getWindowAvoidArea(0);\n                    this.onLeftBlankChanged(data);\n                }\n            })\n        } catch (err) {\n      Log.error(TAG, 'setSystemUi err: ' + err);\n    }\n  }\n\n  private onLeftBlankChanged(area: window.AvoidArea): void {\n    if (area == null || area == undefined || area.bottomRect.height === 0) {\n      return;\n    }\n    let leftBlankBefore: StatusNaviHeight = {\n      status: this.statusBarHeight,\n      navi: this.naviBarHeight\n    };\n    this.statusBarHeight = 0;\n    this.naviBarHeight = area.bottomRect.height;\n    this.leftBlank = [this.leftBlank[0], this.leftBlank[1], this.leftBlank[2], area.bottomRect.height];\n    if (leftBlankBefore.status !== this.statusBarHeight || leftBlankBefore.navi !== this.naviBarHeight) {\n      Log.info(TAG, 'leftBlank changed: ' + JSON.stringify(leftBlankBefore) + '-' + JSON.stringify(this.leftBlank))\n      AppStorage.SetOrCreate<number[]>(BroadcastConstants.LEFT_BLANK, this.leftBlank);\n    }\n  }\n\n  private onWinSizeChanged(size): void {\n    Log.info(TAG, 'onWinSizeChanged ' + JSON.stringify(size));\n    if (size == null || size == undefined) {\n      return;\n    }\n    let sizeBefore: Size = {\n      width: this.winWidth,\n      height: this.winHeight\n    };\n    this.winWidth = size.width;\n    this.winHeight = size.height;\n\n\n    if (sizeBefore.width !== this.winWidth || sizeBefore.height !== this.winHeight) {\n      Log.info(TAG, 'winSize changed: ' + JSON.stringify(sizeBefore) + ' -> ' + JSON.stringify(size));\n      this.emit(screenManager.ON_WIN_SIZE_CHANGED, [size]);\n    }\n  }\n\n  private onRotationAngleChanged(angle): void {\n    if (angle == null || angle == undefined) {\n      return;\n    }\n\n    if (angle === 0) {\n      this.horizontal = false;\n    } else {\n      this.horizontal = true;\n    }\n    AppStorage.SetOrCreate<boolean>(SCREEN_ORIENTATION_HORIZONTAL, this.horizontal);\n  }\n\n  isHorizontal(): boolean {\n    if (AppStorage.Get<boolean>(SCREEN_ORIENTATION_HORIZONTAL) == null) {\n      AppStorage.SetOrCreate<boolean>(SCREEN_ORIENTATION_HORIZONTAL, this.horizontal);\n    }\n    return AppStorage.Get<boolean>(SCREEN_ORIENTATION_HORIZONTAL);\n  }\n\n  isSidebar(): boolean {\n    if (AppStorage.Get<boolean>(SCREEN_SIDEBAR) == null) {\n      AppStorage.SetOrCreate<boolean>(SCREEN_SIDEBAR, this.sidebar);\n    }\n    return AppStorage.Get<boolean>(SCREEN_SIDEBAR);\n  }\n\n  getColumnsWidth(count: number): number {\n    let columns = this.getScreenColumns();\n    Log.info(TAG, 'getColumnsWidth count is ' + count + ' columns: ' + columns);\n    let columnWidth = (px2vp(this.winWidth) - COLUMN_MARGIN) / columns;\n    return columnWidth * count - COLUMN_GUTTER;\n  }\n\n  getScreenColumns(): number {\n    let width = px2vp(this.winWidth);\n    if (width < ScreenWidth.WIDTH_MEDIUM) {\n      return ColumnSize.COLUMN_FOUR;\n    } else if (width >= ScreenWidth.WIDTH_MEDIUM && width < ScreenWidth.WIDTH_LARGE) {\n      return ColumnSize.COLUMN_EIGHT;\n    } else {\n      return ColumnSize.COLUMN_TWELVE;\n    }\n  }\n\n  setKeepScreenOn(): void {\n    Log.info(TAG, 'setKeepScreenOn start');\n    let topWindow: window.Window = AppStorage.Get<window.Window>('mainWindow');\n    try {\n          topWindow.setWindowKeepScreenOn(true, (): void => Log.info(TAG, 'setKeepScreenOn Succeeded'))\n      } catch (err) {\n      Log.error(TAG, 'setKeepScreenOn err: ' + err);\n    }\n  }\n\n  setKeepScreenOff(): void {\n    Log.info(TAG, 'setKeepScreenOff start');\n    let topWindow: window.Window = AppStorage.Get<window.Window>('mainWindow');\n    try {\n          topWindow.setWindowKeepScreenOn(false, (): void => Log.info(TAG, 'setKeepScreenOff Succeeded'))\n      } catch (err) {\n      Log.error(TAG, 'setKeepScreenOff err: ' + err);\n    }\n  }\n}\n\nexport let screenManager: ScreenManager = stashOrGetObject<ScreenManager>(new ScreenManager(), TAG);\n", "llm_cg": {"ScreenManager.initializationSize(window.Window)": ["ScreenManager.setMainWindow(window.Window)", "ScreenManager.checkWindowMode()", "ScreenManager.getWindowProperties(window.Window)"], "ScreenManager.on(string, Function)": [], "ScreenManager.off(string, Function)": [], "ScreenManager.emit(string, Object[])": [], "ScreenManager.isLeftBlankInitialized()": [], "ScreenManager.getWinWidth()": [], "ScreenManager.setWinWidth(number)": [], "ScreenManager.getWinHeight()": [], "ScreenManager.getStatusBarHeight()": [], "ScreenManager.getNaviBarHeight()": [], "ScreenManager.initWindowMode()": [], "ScreenManager.isSplitMode()": [], "ScreenManager.checkWindowMode()": ["ScreenManager.setFullScreen()", "ScreenManager.setSplitScreen()"], "ScreenManager.setMainWindow(window.Window)": ["ScreenManager.checkWindowMode()", "ScreenManager.onWinSizeChanged(window.Size)"], "ScreenManager.getWindowProperties(window.Window)": [], "ScreenManager.setFullScreen()": ["ScreenManager.hideStatusBar(window.Window)"], "ScreenManager.setSplitScreen()": [], "ScreenManager.hideStatusBar(window.Window)": ["ScreenManager.onLeftBlankChanged(window.AvoidArea)"], "ScreenManager.setNavigationBarColor(string, string)": [], "ScreenManager.setSystemUi(boolean)": ["ScreenManager.onLeftBlankChanged(window.AvoidArea)"], "ScreenManager.onLeftBlankChanged(window.AvoidArea)": [], "ScreenManager.onWinSizeChanged(window.Size)": [], "ScreenManager.onRotationAngleChanged(number)": [], "ScreenManager.isHorizontal()": [], "ScreenManager.isSidebar()": [], "ScreenManager.getColumnsWidth(number)": ["ScreenManager.getScreenColumns()"], "ScreenManager.getScreenColumns()": [], "ScreenManager.setKeepScreenOn()": [], "ScreenManager.setKeepScreenOff()": []}, "static_cg": {"@test/32.ts: %dflt.[static]%dflt()": ["@test/32.ts: ScreenManager.constructor()"], "@test/32.ts: ScreenManager.initializationSize(unknown)": ["@test/32.ts: ScreenManager.setMainWindow(window.Window)", "@test/32.ts: ScreenManager.checkWindowMode()", "@test/32.ts: ScreenManager.getWindowProperties(window.Window)"], "@test/32.ts: ScreenManager.on(unknown, unknown)": ["@test/32.ts: ScreenManager.on(unknown, unknown)"], "@test/32.ts: ScreenManager.off(unknown, unknown)": ["@test/32.ts: ScreenManager.off(unknown, unknown)"], "@test/32.ts: ScreenManager.checkWindowMode()": ["@test/32.ts: GetWindowMode.getWindowMode()", "@test/32.ts: ScreenManager.setFullScreen()", "@test/32.ts: ScreenManager.setSplitScreen()"], "@test/32.ts: ScreenManager.setMainWindow(window.Window)": ["@test/32.ts: ScreenManager.%AM0$setMainWindow(window.Size)"], "@test/32.ts: ScreenManager.setFullScreen()": ["@test/32.ts: ScreenManager.hideStatusBar(window.Window)"], "@test/32.ts: ScreenManager.hideStatusBar(window.Window)": ["@test/32.ts: ScreenManager.onLeftBlankChanged(window.AvoidArea)"], "@test/32.ts: ScreenManager.setNavigationBarColor(string, string)": ["@test/32.ts: ScreenManager.%AM1$setNavigationBarColor()"], "@test/32.ts: ScreenManager.setSystemUi(boolean)": ["@test/32.ts: ScreenManager.%AM2$setSystemUi([isShowBar, topWindow])"], "@test/32.ts: ScreenManager.onWinSizeChanged(unknown)": ["@test/32.ts: ScreenManager.emit(unknown, Object[])"], "@test/32.ts: ScreenManager.getColumnsWidth(number)": ["@test/32.ts: ScreenManager.getScreenColumns()"], "@test/32.ts: ScreenManager.setKeepScreenOn()": ["@test/32.ts: ScreenManager.%AM3$setKeepScreenOn()"], "@test/32.ts: ScreenManager.setKeepScreenOff()": ["@test/32.ts: ScreenManager.%AM4$setKeepScreenOff()"], "@test/32.ts: ScreenManager.%AM0$setMainWindow(window.Size)": ["@test/32.ts: ScreenManager.checkWindowMode()", "@test/32.ts: ScreenManager.onWinSizeChanged(unknown)"], "@test/32.ts: ScreenManager.%AM2$setSystemUi([isShowBar, topWindow])": ["@test/32.ts: ScreenManager.onLeftBlankChanged(window.AvoidArea)"]}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Action } from '../models/Action'\nimport { ActionBarMode, ActionBarColorMode, ActionBarSelectionMode } from '../models/ActionBarMode'\n\n// ActionBarProp\nexport class ActionBarProp {\n  public static NORMAL_BACKGROUND_COLOR: Resource = $r('app.color.default_background_color');\n  public static TRANSPARENT_BACKGROUND_COLOR: Resource = $r('app.color.transparent');\n  public static NORMAL_TEXT_COLOR: Resource = $r('sys.color.ohos_id_color_titlebar_text');\n  public static NORMAL_SUBTITLE_TEXT_COLOR: Resource = $r('sys.color.ohos_id_color_titlebar_subtitle_text');\n  public static ICON_COLOR: Resource = $r('sys.color.ohos_id_color_primary');\n  public static TRANSPARENT_TEXT_COLOR: Resource = $r('app.color.title_text_color_on_transparent_bg');\n  public static TRANSPARENT_SUBTITLE_TEXT_COLOR: Resource = $r('app.color.subtitle_text_color_on_transparent_bg');\n  public static HEAD_TITLE_TEXT_SIZE: Resource = $r('sys.float.ohos_id_text_size_headline6');\n  public static HEAD_TITLE_ONE_LINE_TEXT_SIZE: Resource = $r('sys.float.ohos_id_text_size_headline7');\n  public static TITLE_TEXT_SIZE: Resource = $r('sys.float.ohos_id_text_size_headline8');\n  public static TITLE_FONT_WEIGHT = 500;\n  public static SUBTITLE_TEXT_SIZE: Resource = $r('sys.float.ohos_id_text_size_body2');\n  public static MEDIUM_FONT: Resource = $r('app.string.id_text_font_family_medium');\n  public static REGULAR_FONT: Resource = $r('app.string.id_text_font_family_regular');\n  public static SINGLE_UNSELECT_TITLE: Resource = $r('app.string.title_select_photos');\n  public static SINGLE_SELECT_ALBUM_TITLE: Resource = $r('app.string.title_select_album');\n  public static MULTI_UNSELECT_TITLE: Resource = $r('app.string.title_none_selected');\n  public static PHOTO_BROWSER_ACTIONBAR_ALPHA = 0.95;\n  private hasTabBar = false;\n  private leftAction = Action.NONE;\n  private isHeadTitle = false;\n  private title: Object = null;\n  private subTitle: Object = null;\n  private menuList: Action[] = [];\n  private backgroundColor: Resource = ActionBarProp.NORMAL_BACKGROUND_COLOR;\n  private alpha = 1;\n  private selectionMode: ActionBarSelectionMode = ActionBarSelectionMode.MULTI;\n  private colorMode: ActionBarColorMode = ActionBarColorMode.NORMAL;\n  private mode: ActionBarMode = ActionBarMode.STANDARD_MODE;\n  private maxSelectCount = 0;\n\n  constructor() {\n  }\n\n  public static getCountDetailSelectedTitle(count: number): Resource {\n    return $r('app.plural.count_details_selected', count, count);\n  }\n\n  /**\n   * External selection quantity display\n   * @param count The selected quantity, same as the current count above\n   * @param maxSelectCount Maximum number of options\n   */\n  public static getCountDetailExternalSelectedTitle(count: number, maxSelectCount: number): Resource {\n    return $r('app.string.count_details_external_selected', count, maxSelectCount);\n  }\n\n  public setHasTabBar(hasTabBar: boolean): ActionBarProp {\n    this.hasTabBar = hasTabBar;\n    return this;\n  }\n\n  public getHasTabBar(): boolean {\n    return this.hasTabBar;\n  }\n\n  public setLeftAction(leftAction: Action): ActionBarProp {\n    this.leftAction = leftAction;\n    return this;\n  }\n\n  public getLeftAction(): Action {\n    return this.leftAction;\n  }\n\n  public setIsHeadTitle(isHeadTitle: boolean): ActionBarProp {\n    this.isHeadTitle = isHeadTitle;\n    return this;\n  }\n\n  public getIsHeadTitle(): boolean {\n    return this.isHeadTitle;\n  }\n\n  public setTitle(title: Object): ActionBarProp {\n    this.title = title;\n    return this;\n  }\n\n  public getTitle(): Object {\n    return this.title;\n  }\n\n  public setSubTitle(subTitle: Object): ActionBarProp {\n    this.subTitle = subTitle;\n    return this;\n  }\n\n  public getSubTitle(): Object {\n    return this.subTitle;\n  }\n\n  public setMenuList(menuList: Action[]): ActionBarProp {\n    this.menuList = menuList;\n    return this;\n  }\n\n  public getMenuList(): Action[] {\n    return this.menuList;\n  }\n\n  public setBackgroundColor(backgroundColor: Resource): ActionBarProp {\n    this.backgroundColor = backgroundColor;\n    return this;\n  }\n\n  public getBackgroundColor(): Resource {\n    return this.colorMode === ActionBarColorMode.TRANSPARENT\n      ? ActionBarProp.TRANSPARENT_BACKGROUND_COLOR : this.backgroundColor;\n  }\n\n  public setAlpha(alpha: number): ActionBarProp {\n    this.alpha = alpha;\n    return this;\n  }\n\n  public getAlpha(): number {\n    return this.alpha;\n  }\n\n  public setMode(mode: ActionBarMode): ActionBarProp {\n    this.mode = mode;\n    return this;\n  }\n\n  public getMode(): ActionBarMode {\n    return this.mode;\n  }\n\n  public setColorMode(colorMode: ActionBarColorMode): ActionBarProp {\n    this.colorMode = colorMode;\n    return this;\n  }\n\n  public getColorMode(): ActionBarColorMode {\n    return this.colorMode;\n  }\n\n  public setSelectionMode(selectionMode: ActionBarSelectionMode): ActionBarProp {\n    this.selectionMode = selectionMode;\n    return this;\n  }\n\n  public getSelectionMode(): ActionBarSelectionMode {\n    return this.selectionMode;\n  }\n\n  public setMaxSelectCount(maxSelectCount: number): ActionBarProp {\n    this.maxSelectCount = maxSelectCount;\n    return this;\n  }\n\n  public getMaxSelectCount(): number {\n    return this.maxSelectCount;\n  }\n}", "llm_cg": {"ActionBarProp.getCountDetailSelectedTitle(number)": [], "ActionBarProp.getCountDetailExternalSelectedTitle(number, number)": [], "ActionBarProp.setHasTabBar(boolean)": [], "ActionBarProp.getHasTabBar()": [], "ActionBarProp.setLeftAction(Action)": [], "ActionBarProp.getLeftAction()": [], "ActionBarProp.setIsHeadTitle(boolean)": [], "ActionBarProp.getIsHeadTitle()": [], "ActionBarProp.setTitle(Object)": [], "ActionBarProp.getTitle()": [], "ActionBarProp.setSubTitle(Object)": [], "ActionBarProp.getSubTitle()": [], "ActionBarProp.setMenuList(Action[])": [], "ActionBarProp.getMenuList()": [], "ActionBarProp.setBackgroundColor(Resource)": [], "ActionBarProp.getBackgroundColor()": [], "ActionBarProp.setAlpha(number)": [], "ActionBarProp.getAlpha()": [], "ActionBarProp.setMode(ActionBarMode)": [], "ActionBarProp.getMode()": [], "ActionBarProp.setColorMode(ActionBarColorMode)": [], "ActionBarProp.getColorMode()": [], "ActionBarProp.setSelectionMode(ActionBarSelectionMode)": [], "ActionBarProp.getSelectionMode()": [], "ActionBarProp.setMaxSelectCount(number)": [], "ActionBarProp.getMaxSelectCount()": []}, "static_cg": {}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ntype CallbackType = Function;\n\nexport class Broadcast {\n  private callBackArray: Map<string, CallbackType[]> = new Map<string, CallbackType[]>();\n\n  constructor() {\n  }\n\n  public on(event: string, callback: CallbackType): void {\n    if (this.callBackArray.get(event) === null || this.callBackArray.get(event) === undefined) {\n      this.callBackArray.set(event, []);\n    }\n    this.callBackArray.get(event).push(callback);\n  }\n\n  public off(event: string | null, callback: CallbackType | null): void {\n    if (event == null) {\n      this.callBackArray.clear();\n    }\n\n    const cbs: CallbackType[] = this.callBackArray.get(event);\n    if (!Boolean<Function[]>(cbs).valueOf()) {\n      return;\n    }\n    if (callback == null) {\n      this.callBackArray.set(event, null);\n    }\n    let cb;\n    let l = cbs.length;\n    for (let i = 0; i < l; i++) {\n      cb = cbs[i];\n      if (cb === callback || cb.fn === callback) {\n        cbs.splice(i, 1);\n        break;\n      }\n    }\n  }\n\n  public emit(event: string, args: Object[]): void {\n    let _self = this;\n    if (!Boolean<Function[]>(this.callBackArray.get(event)).valueOf()) {\n      return;\n    }\n\n    let cbs: CallbackType[] = [];\n    for (let i = 0; i < this.callBackArray.get(event).length; i++) {\n      cbs.push(this.callBackArray.get(event)[i])\n    }\n\n    if (cbs != null) {\n      let l = cbs.length;\n      for (let i = 0; i < l; i++) {\n        try {\n          cbs[i].apply(_self, args);\n        } catch (e) {\n          new Error(e);\n        }\n      }\n    }\n  }\n\n  public release(): void {\n    this.callBackArray.forEach((array: Object[]): void => {\n      array.length = 0;\n    });\n    this.callBackArray.clear();\n  }\n}\n", "llm_cg": {"Broadcast.on(string, CallbackType)": ["Broadcast.%AM0$on(unknown, unknown)"], "Broadcast.off(string | null, CallbackType | null)": ["Broadcast.%AM1$off(unknown, unknown)"], "Broadcast.emit(string, Object[])": ["Broadcast.%AM2$emit(unknown, unknown)"], "Broadcast.release()": ["Broadcast.%AM3$release()"]}, "static_cg": {"@test/34.ts: Broadcast.release()": ["@test/34.ts: Broadcast.%AM0$release(Object[])"]}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport inputConsumer from '@ohos.multimodalInput.inputConsumer';\nimport { Log } from '../utils/Log';\n\n\nconst TAG = 'MultimodalInputManager';\n\nexport class MultimodalInputManager {\n\n  //win + N\n  leftKeyOptions: inputConsumer.KeyOptions = {\n    preKeys: Array<number>(),\n    finalKey: 2014,\n    isFinalKeyDown: true,\n    finalKeyDownDuration: 0\n  };\n\n  //win + I\n  rightKeyOptions: inputConsumer.KeyOptions = {\n    preKeys: Array<number>(),\n    finalKey: 2015,\n    isFinalKeyDown: true,\n    finalKeyDownDuration: 0\n  };\n  escKeyOptions: inputConsumer.KeyOptions = {\n    preKeys: Array<number>(),\n    finalKey: 2070,\n    isFinalKeyDown: true,\n    finalKeyDownDuration: 0\n  };\n\n  async registerListener(callback): Promise<void> {\n    Log.debug(TAG, 'registerListener start');\n    inputConsumer.on('key', this.leftKeyOptions, (data: inputConsumer.KeyOptions): void => {\n      Log.debug(TAG, 'notificationRegister data: ' + JSON.stringify(data));\n      callback(0);\n    });\n    inputConsumer.on('key', this.rightKeyOptions, (data: inputConsumer.KeyOptions): void => {\n      Log.debug(TAG, 'controlRegister data: ' + JSON.stringify(data));\n      callback(1);\n    });\n    inputConsumer.on('key', this.escKeyOptions, (data: inputConsumer.KeyOptions): void => {\n      Log.debug(TAG, 'escRegister data: ' + JSON.stringify(data));\n      callback(2);\n    });\n    Log.debug(TAG, 'registerListener end');\n  }\n\n  async unregisterListener(): Promise<void> {\n    Log.debug(TAG, 'unregisterListener start');\n    inputConsumer.off('key', this.leftKeyOptions, (data: inputConsumer.KeyOptions): void  => {\n      Log.debug(TAG, 'notificationUnregister data: ' + JSON.stringify(data));\n    });\n    inputConsumer.off('key', this.rightKeyOptions, (data: inputConsumer.KeyOptions): void  => {\n      Log.debug(TAG, 'controlUnregister data: ' + JSON.stringify(data));\n    });\n    inputConsumer.off('key', this.escKeyOptions, (data: inputConsumer.KeyOptions): void  => {\n      Log.debug(TAG, 'escUnregister data: ' + JSON.stringify(data));\n    });\n    Log.debug(TAG, 'unregisterListener end');\n  }\n}\n\nexport let mMultimodalInputManager = new MultimodalInputManager();\n", "llm_cg": {"MultimodalInputManager.registerListener(callback)": ["inputConsumer.on(key, MultimodalInputManager.leftKeyOptions, Function)", "inputConsumer.on(key, MultimodalInputManager.rightKeyOptions, Function)", "inputConsumer.on(key, MultimodalInputManager.escKeyOptions, Function)"], "MultimodalInputManager.unregisterListener()": ["inputConsumer.off(key, MultimodalInputManager.leftKeyOptions, Function)", "inputConsumer.off(key, MultimodalInputManager.rightKeyOptions, Function)", "inputConsumer.off(key, MultimodalInputManager.escKeyOptions, Function)"]}, "static_cg": {"@test/35.ts: MultimodalInputManager.registerListener(unknown)": ["@test/35.ts: MultimodalInputManager.%AM0$registerListener([callback], inputConsumer.KeyOptions)", "@test/35.ts: MultimodalInputManager.%AM1$registerListener([callback], inputConsumer.KeyOptions)", "@test/35.ts: MultimodalInputManager.%AM2$registerListener([callback], inputConsumer.KeyOptions)"], "@test/35.ts: MultimodalInputManager.unregisterListener()": ["@test/35.ts: MultimodalInputManager.%AM3$unregisterListener(inputConsumer.KeyOptions)", "@test/35.ts: MultimodalInputManager.%AM4$unregisterListener(inputConsumer.KeyOptions)", "@test/35.ts: MultimodalInputManager.%AM5$unregisterListener(inputConsumer.KeyOptions)"]}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport class GlobalContext {\n  private constructor() {\n  }\n\n  private static instance: GlobalContext;\n  private _objects = new Map<string, Object>();\n\n  public static getContext(): GlobalContext {\n    if (!(new Boolean(GlobalContext.instance)).valueOf()) {\n      GlobalContext.instance = new GlobalContext();\n    }\n    return GlobalContext.instance;\n  }\n\n  getObject(value: string): Object {\n    return this._objects.get(value);\n  }\n\n  setObject(key: string, objectClass: Object): void {\n    this._objects.set(key, objectClass);\n  }\n}", "llm_cg": {"GlobalContext.getContext()": ["GlobalContext.%AM0$constructor()"], "GlobalContext.getObject(value: string)": [], "GlobalContext.setObject(key: string, objectClass: Object)": []}, "static_cg": {"@test/36.ts: GlobalContext.[static]getContext()": ["@test/36.ts: GlobalContext.constructor()"]}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Log } from '../utils/Log';\n\nconst TAG = 'ItemDataSource'\n\nexport class LazyItem<T> {\n  item: T;\n  onItemUpdate: Function;\n  index: number = -1;\n\n  constructor(item: T, index: number, onItemUpdate?: Function) {\n    this.item = item;\n    this.onItemUpdate = onItemUpdate;\n    this.index = index;\n  }\n\n  update(item: T): void {\n    if (this.onItemUpdate != null && this.index !== -1) {\n      this.onItemUpdate(this.index, item);\n    }\n  }\n\n  getHashCode(): string {\n    // @ts-ignore\n    return this.index + '' + this.item.getHashCode();\n  }\n\n  get(): T {\n    return this.item;\n  }\n\n  set(item: T): void {\n    this.item = item;\n  }\n}\n\nexport abstract class ItemDataSource implements IDataSource {\n  private listeners: DataChangeListener[] = [];\n\n  abstract totalCount(): number;\n\n  abstract getData(index: number): Object;\n\n  abstract isSelect(): boolean;\n\n  abstract getSelectedCount(): number;\n\n  abstract getSelectedItems(): Object[];\n\n  abstract getSelectedUris(): string[];\n\n  abstract dataRemove(): void;\n\n  registerDataChangeListener(listener: DataChangeListener): void {\n    Log.info(TAG, 'registerDataChangeListener');\n    if (this.listeners.indexOf(listener) < 0) {\n      this.listeners.push(listener);\n      Log.info(TAG, 'registerDataChangeListener, add listener, length: ' + this.listeners.length);\n    }\n  }\n\n  unregisterDataChangeListener(listener: DataChangeListener): void {\n    Log.info(TAG, 'unregisterDataChangeListener');\n    const pos = this.listeners.indexOf(listener);\n    if (pos >= 0) {\n      this.listeners.splice(pos, 1);\n      Log.info(TAG, 'registerDataChangeListener, remove listener, length: ' + this.listeners.length);\n    }\n  }\n\n  notifyDataChange(index: number): void {\n    this.listeners.forEach((listener: DataChangeListener): void => {\n      listener.onDataChange(index);\n    })\n  }\n\n  notifyDataReload(): void {\n    this.listeners.forEach((listener: DataChangeListener): void => {\n      listener.onDataReloaded();\n    })\n  }\n\n  notifyDataDelete(index: number): void {\n    this.listeners.forEach((listener: DataChangeListener): void => {\n      listener.onDataDelete(index);\n    })\n  }\n}\n", "llm_cg": {"LazyItem.update(T)": ["LazyItem.%AM0$onItemUpdate(number, T)"], "ItemDataSource.registerDataChangeListener(DataChangeListener)": ["Log.info(string, string)", "Log.info(string, string)"], "ItemDataSource.unregisterDataChangeListener(DataChangeListener)": ["Log.info(string, string)", "Log.info(string, string)"], "ItemDataSource.notifyDataChange(number)": ["DataChangeListener.onDataChange(number)"], "ItemDataSource.notifyDataReload()": ["DataChangeListener.onDataReloaded()"], "ItemDataSource.notifyDataDelete(number)": ["DataChangeListener.onDataDelete(number)"]}, "static_cg": {"@test/37.ts: ItemDataSource.notifyDataChange(number)": ["@test/37.ts: ItemDataSource.%AM0$notifyDataChange([index], DataChangeListener)"], "@test/37.ts: ItemDataSource.notifyDataReload()": ["@test/37.ts: ItemDataSource.%AM1$notifyDataReload(DataChangeListener)"], "@test/37.ts: ItemDataSource.notifyDataDelete(number)": ["@test/37.ts: ItemDataSource.%AM2$notifyDataDelete([index], DataChangeListener)"]}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport class SimpleAlbumDataItem {\n  readonly id: string;\n  readonly displayName: string;\n  readonly uri: string; //as uri\n  readonly deviceId: string;\n  readonly deviceName: string;\n  readonly albumType: number;\n  readonly albumSubType: number;\n\n  constructor(id: string, displayName: string, uri: string, deviceId: string, deviceName: string, albumType: number, albumSubType: number) {\n    this.id = id;\n    this.displayName = displayName;\n    this.uri = uri;\n    this.deviceId = deviceId;\n    this.deviceName = deviceName;\n    this.albumType = albumType;\n    this.albumSubType = albumSubType;\n  }\n}", "llm_cg": {"SimpleAlbumDataItem.constructor(id: string, displayName: string, uri: string, deviceId: string, deviceName: string, albumType: number, albumSubType: number)": []}, "static_cg": {}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Log } from '../utils/Log';\nimport { GroupDataImpl } from './GroupDataImpl';\nimport { LazyItem, ItemDataSource } from './ItemDataSource';\nimport { UserFileDataItem } from '../base/UserFileDataItem';\n\nconst TAG = 'GroupItemDataSource';\n\nexport class GroupItemDataSource extends ItemDataSource {\n  groupDataItem: UserFileDataItem[] = [];\n  private groupDataImpl: GroupDataImpl = new GroupDataImpl();\n\n  constructor() {\n    super();\n  }\n\n  setSelectType(selectType: number): void {\n    this.groupDataImpl.setSelectType(selectType);\n  }\n\n  setAlbumId(id: string): void {\n    Log.info(TAG, 'setAlbumId: ' + id);\n    this.groupDataImpl.setAlbumId(id);\n  }\n\n  setAlbumType(id: number): void {\n    Log.info(TAG, 'setAlbumType: ' + id);\n    this.groupDataImpl.setAlbumType(id);\n  }\n\n  setAlbumSubtype(id: number): void {\n    Log.info(TAG, 'setAlbumSubtype: ' + id);\n    this.groupDataImpl.setAlbumSubtype(id);\n  }\n\n  setAlbumName(name: string): void {\n    Log.info(TAG, 'setAlbumName: ' + name);\n    this.groupDataImpl.setAlbumName(name);\n  }\n\n  setDeviceId(id: string): void {\n    Log.info(TAG, 'setDeviceId: ' + id);\n    this.groupDataImpl.setDeviceId(id);\n  }\n\n  totalCount(): number {\n    return this.groupDataItem.length;\n  }\n\n  getIndexByItem(item: UserFileDataItem): number {\n    let index = -1;\n    let length = this.groupDataItem.length;\n    for (let i = 0;i < length; i++) {\n      if (this.groupDataItem[i].uri === item.uri) {\n        index = i;\n        break;\n      }\n    }\n    return index;\n  }\n\n  getData(index: number): LazyItem<UserFileDataItem> {\n    if (index < 0 || index >= this.groupDataItem.length) {\n      Log.warn(TAG, index + '/' + this.groupDataItem.length);\n      return undefined;\n    }\n    if (this.groupDataItem[index] != null && this.groupDataItem[index] != undefined) {\n      this.groupDataItem[index].index = index;\n    }\n    return new LazyItem<UserFileDataItem>(this.groupDataItem[index], index, (index: number): void => this.onDataUpdateBindImpl(index));\n  }\n\n  getDataByIndex(index: number): UserFileDataItem {\n    if (index < 0 || index >= this.groupDataItem.length) {\n      Log.warn(TAG, index + '/' + this.groupDataItem.length);\n      return undefined;\n    }\n    if (this.groupDataItem[index] != null && this.groupDataItem[index] != undefined) {\n      this.groupDataItem[index].index = index;\n    }\n    return this.groupDataItem[index];\n  }\n\n  isSelect(): boolean {\n    let isSelect = true;\n    for (let i = 0;i < this.groupDataItem.length; i++) {\n      if (!this.groupDataItem[i].isSelect) {\n        isSelect = false;\n        break;\n      }\n    }\n    return isSelect;\n  }\n\n  getSelectedCount(): number {\n    let count = 0;\n    this.groupDataItem.forEach((item: UserFileDataItem): void => {\n      if (item.isSelect) {\n        count++;\n      }\n    })\n    return count;\n  }\n\n  getItems(): UserFileDataItem[] {\n    let items: UserFileDataItem[] = [];\n    this.groupDataItem.forEach((item: UserFileDataItem): void => {\n      items.push(item);\n    })\n    return items;\n  }\n\n  getSelectedItems(): Object[] {\n    let items: UserFileDataItem[] = [];\n    this.groupDataItem.forEach((item: UserFileDataItem): void => {\n      if (item.isSelect) {\n        items.push(item);\n      }\n    })\n    return items;\n  }\n\n  getSelectedUris(): string[] {\n    let uris: string[] = [];\n    this.groupDataItem.forEach((item: UserFileDataItem): void => {\n      if (item.isSelect) {\n        uris.push(item.uri);\n      }\n    })\n    return uris;\n  }\n\n  setSelect(isSelect: boolean): void {\n    this.groupDataItem.forEach((item: UserFileDataItem): void => {\n      item.setSelect(isSelect);\n    })\n    this.notifyDataReload();\n  }\n\n  async reloadGroupItemData(isGrid: boolean): Promise<boolean> {\n    this.groupDataItem = await this.groupDataImpl.reloadGroupItemData(isGrid);\n    return this.groupDataItem.length === 0;\n  }\n\n  onDataUpdate(index: number): void {\n    this.onDataUpdateBindImpl(index);\n  }\n\n  private onDataUpdateBindImpl(index: number): void {\n    Log.debug(TAG, 'onDataUpdate ' + index);\n    if (index !== -1) {\n      this.notifyDataChange(index);\n    }\n  }\n\n  dataReload(isGrid: boolean): void {\n    this.reloadGroupItemData(isGrid).then<void, void>((isEmpty: boolean): void => {\n      this.notifyDataReload();\n    })\n  }\n\n  dataRemove(): void {\n    for (let i = this.groupDataItem.length - 1;i >= 0; i--) {\n      if (this.groupDataItem[i] != undefined && this.groupDataItem[i].isDeleted()) {\n        this.groupDataItem.splice(i, 1);\n        super.notifyDataDelete(i);\n      }\n    }\n  }\n\n  dataDelete(uri: string): void {\n    const mediaDataItemIndex = this.groupDataItem.findIndex((item: UserFileDataItem): boolean => {\n      return item.uri === uri;\n    })\n    if (mediaDataItemIndex !== -1 && this.groupDataItem[mediaDataItemIndex].isDeleted()) {\n      this.groupDataItem.splice(mediaDataItemIndex, 1);\n      super.notifyDataDelete(mediaDataItemIndex);\n    }\n  }\n}\n", "llm_cg": {"GroupItemDataSource.setSelectType(selectType: number)": ["GroupDataImpl.setSelectType(selectType: number)"], "GroupItemDataSource.setAlbumId(id: string)": ["GroupDataImpl.setAlbumId(id: string)"], "GroupItemDataSource.setAlbumType(id: number)": ["GroupDataImpl.setAlbumType(id: number)"], "GroupItemDataSource.setAlbumSubtype(id: number)": ["GroupDataImpl.setAlbumSubtype(id: number)"], "GroupItemDataSource.setAlbumName(name: string)": ["GroupDataImpl.setAlbumName(name: string)"], "GroupItemDataSource.setDeviceId(id: string)": ["GroupDataImpl.setDeviceId(id: string)"], "GroupItemDataSource.getData(index: number)": ["GroupItemDataSource.onDataUpdateBindImpl(index: number)"], "GroupItemDataSource.reloadGroupItemData(isGrid: boolean)": ["GroupDataImpl.reloadGroupItemData(isGrid: boolean)"], "GroupItemDataSource.onDataUpdate(index: number)": ["GroupItemDataSource.onDataUpdateBindImpl(index: number)"], "GroupItemDataSource.dataReload(isGrid: boolean)": ["GroupItemDataSource.reloadGroupItemData(isGrid: boolean)", "GroupItemDataSource.notifyDataReload()"], "GroupItemDataSource.dataRemove()": ["GroupItemDataSource.notifyDataDelete(index: number)"], "GroupItemDataSource.dataDelete(uri: string)": ["GroupItemDataSource.notifyDataDelete(mediaDataItemIndex: number)"]}, "static_cg": {"@test/39.ts: GroupItemDataSource.getData(number)": ["@test/39.ts: GroupItemDataSource.%AM0$getData(number)"], "@test/39.ts: GroupItemDataSource.getSelectedCount()": ["@test/39.ts: GroupItemDataSource.%AM1$getSelectedCount([count], UserFileDataItem)"], "@test/39.ts: GroupItemDataSource.getItems()": ["@test/39.ts: GroupItemDataSource.%AM2$getItems([items], UserFileDataItem)"], "@test/39.ts: GroupItemDataSource.getSelectedItems()": ["@test/39.ts: GroupItemDataSource.%AM3$getSelectedItems([items], UserFileDataItem)"], "@test/39.ts: GroupItemDataSource.getSelectedUris()": ["@test/39.ts: GroupItemDataSource.%AM4$getSelectedUris([uris], UserFileDataItem)"], "@test/39.ts: GroupItemDataSource.setSelect(boolean)": ["@test/39.ts: GroupItemDataSource.%AM5$setSelect([isSelect], UserFileDataItem)"], "@test/39.ts: GroupItemDataSource.onDataUpdate(number)": ["@test/39.ts: GroupItemDataSource.onDataUpdateBindImpl(number)"], "@test/39.ts: GroupItemDataSource.dataReload(boolean)": ["@test/39.ts: GroupItemDataSource.reloadGroupItemData(boolean)", "@test/39.ts: GroupItemDataSource.%AM6$dataReload(boolean)"], "@test/39.ts: GroupItemDataSource.dataDelete(string)": ["@test/39.ts: GroupItemDataSource.%AM7$dataDelete([uri], UserFileDataItem)"], "@test/39.ts: GroupItemDataSource.%AM0$getData(number)": ["@test/39.ts: GroupItemDataSource.onDataUpdateBindImpl(number)"]}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { UserFileObserverCallback } from '../base/UserFileObserverCallback';\nimport { UserFileDataChangeCallback } from '../base/UserFileDataChangeCallback';\n\nexport class CommonObserverCallback implements UserFileObserverCallback {\n  private source: UserFileDataChangeCallback;\n\n  constructor(source: UserFileDataChangeCallback) {\n    this.source = source;\n  }\n\n  onChange(mediaType: string): void {\n    this.source.onUserFileDataChange(mediaType);\n  }\n}", "llm_cg": {"CommonObserverCallback.onChange(mediaType: string)": ["UserFileDataChangeCallback.onUserFileDataChange(mediaType: string)"]}, "static_cg": {}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport photoAccessHelper from '@ohos.file.photoAccessHelper';\nimport { Log } from '../utils/Log';\nimport { Constants } from '../constants/Constants';\nimport { userFileModel } from '../base/UserFileModel';\nimport { screenManager } from './ScreenManager';\nimport { MediaConstants } from '../constants/MediaConstants';\nimport { UserFileDataItem } from '../base/UserFileDataItem';\nimport { FavorUserFileDataItem } from '../base/FavorUserFileDataItem';\nimport { userFileDataItemCache } from '../base/UserFileDataItemCache';\nimport { trashUserFileDataItemCache } from '../base/TrashUserFileDataItemCache';\nimport { TrashUserFileDataItem } from '../base/TrashUserFileDataItem';\nimport dataSharePredicates from '@ohos.data.dataSharePredicates';\n\n\nconst TAG = 'GroupDataImpl';\n\nexport class GroupDataImpl {\n  private selectType: number = MediaConstants.SELECT_TYPE_ALL;\n  private albumId: string = '';\n  private deviceId: string = '';\n  private albumType: number = -1;\n  private albumSubType: number = -1;\n  private albumName: string = '';\n\n  setSelectType(selectType: number): void {\n    this.selectType = selectType;\n  }\n\n  setAlbumId(id: string): void {\n    Log.info(TAG, 'setAlbumId: ' + id);\n    this.albumId = id;\n  }\n\n  setDeviceId(id: string): void {\n    Log.info(TAG, 'setDeviceId: ' + id);\n    this.deviceId = id;\n  }\n\n  setAlbumType(albumType: number): void {\n    Log.info(TAG, 'setAlbumType: ' + albumType);\n    this.albumType = albumType;\n  }\n\n  setAlbumSubtype(albumSubType: number): void {\n    Log.info(TAG, 'setAlbumSubtype: ' + albumSubType);\n    this.albumSubType = albumSubType;\n  }\n\n  setAlbumName(name: string): void {\n    Log.info(TAG, 'setAlbumName: ' + name);\n    this.albumName = name;\n  }\n\n  async reloadGroupItemData(isGrid: boolean): Promise<UserFileDataItem[]> {\n    if (isGrid) {\n      return this.reloadGridGroupItemData();\n    } else {\n      return this.reloadBrowserGroupItemData();\n    }\n  }\n\n  async reloadBrowserGroupItemData(): Promise<UserFileDataItem[]> {\n    Log.info(TAG, 'reloadBrowserGroupItemData');\n    let groupDataItem: UserFileDataItem[] = [];\n    let mediaFileAssets = await this.getMediaItemFileAssets(this.albumName, this.albumType, this.albumSubType);\n    if (this.albumId === MediaConstants.ALBUM_ID_FAVOR) {\n      for (let i = 0;i < mediaFileAssets.length; i++) {\n        let favorMediaItem = new FavorUserFileDataItem('', [], i);\n        if (userFileDataItemCache.hasKey(mediaFileAssets[i].uri)) {\n          favorMediaItem.favouriteStatus = userFileDataItemCache.get(mediaFileAssets[i].uri).favouriteStatus;\n          favorMediaItem.orientation = userFileDataItemCache.get(mediaFileAssets[i].uri).orientation;\n        }\n        favorMediaItem.update(mediaFileAssets[i]);\n        groupDataItem.push(favorMediaItem);\n      }\n    } else if (this.albumId === MediaConstants.ALBUM_ID_RECYCLE) {\n      for (let i = 0;i < mediaFileAssets.length; i++) {\n        let trashMediaItem = new TrashUserFileDataItem('', [], i);\n        if (userFileDataItemCache.hasKey(mediaFileAssets[i].uri)) {\n          trashMediaItem.favouriteStatus = userFileDataItemCache.get(mediaFileAssets[i].uri).favouriteStatus;\n          trashMediaItem.orientation = userFileDataItemCache.get(mediaFileAssets[i].uri).orientation;\n        }\n        trashMediaItem.update(mediaFileAssets[i]);\n        groupDataItem.push(trashMediaItem);\n      }\n    } else {\n      for (let i = 0;i < mediaFileAssets.length; i++) {\n        let mediaItem: UserFileDataItem = new UserFileDataItem('', [], this.deviceId, i);\n        if (userFileDataItemCache.hasKey(mediaFileAssets[i].uri)) {\n          mediaItem = userFileDataItemCache.get(mediaFileAssets[i].uri);\n        } else {\n          userFileDataItemCache.set(mediaFileAssets[i].uri, mediaItem);\n        }\n        mediaItem.update(mediaFileAssets[i]);\n        groupDataItem.push(mediaItem);\n      }\n    }\n    Log.info(TAG, 'reload finish');\n    return groupDataItem;\n  }\n\n  async reloadGridGroupItemData(): Promise<UserFileDataItem[]> {\n    Log.info(TAG, 'reloadGridGroupItemData');\n    let groupDataItem: UserFileDataItem[] = [];\n    let mediaFileAssets = await this.getMediaItemFileAssets(this.albumName, this.albumType, this.albumSubType);\n    if (this.albumId === MediaConstants.ALBUM_ID_FAVOR) {\n      for (let i = 0;i < mediaFileAssets.length; i++) {\n        let item = new FavorUserFileDataItem('', [], i);\n        if (userFileDataItemCache.hasKey(mediaFileAssets[i].uri)) {\n          Log.info(TAG, 'hasKey');\n          item = userFileDataItemCache.get(mediaFileAssets[i].uri);\n        } else {\n          userFileDataItemCache.set(mediaFileAssets[i].uri, item);\n        }\n        item.update(mediaFileAssets[i]);\n        groupDataItem.push(item);\n      }\n    } else if (this.albumId === MediaConstants.ALBUM_ID_RECYCLE) {\n      for (let i = 0;i < mediaFileAssets.length; i++) {\n        let item = new TrashUserFileDataItem('', [], i);\n        if (trashUserFileDataItemCache.hasKey(mediaFileAssets[i].uri)) {\n          item = trashUserFileDataItemCache.get(mediaFileAssets[i].uri);\n        } else {\n          trashUserFileDataItemCache.set(mediaFileAssets[i].uri, item);\n        }\n        item.update(mediaFileAssets[i]);\n        groupDataItem.push(item);\n      }\n    } else {\n      for (let i = 0;i < mediaFileAssets.length; i++) {\n        let item = new UserFileDataItem('', [], this.deviceId, i);\n        if (userFileDataItemCache.hasKey(mediaFileAssets[i].uri)) {\n          item = userFileDataItemCache.get(mediaFileAssets[i].uri);\n        } else {\n          userFileDataItemCache.set(mediaFileAssets[i].uri, item);\n        }\n        item.update(mediaFileAssets[i]);\n        groupDataItem.push(item);\n      }\n    }\n    Log.info(TAG, 'reload finish');\n    return groupDataItem;\n  }\n\n  private async getMediaItemFileAssets(albumName: string, albumType: number, albumSubType: number): Promise<photoAccessHelper.PhotoAsset[]> {\n    let predicates = new dataSharePredicates.DataSharePredicates();\n    predicates.equalTo(photoAccessHelper.AlbumKeys.ALBUM_NAME, albumName)\n    let fetchOption = {\n      fetchColumns: MediaConstants.EMPTY_FETCH_COLUMNS,\n      predicates: predicates\n    };\n    Log.info(TAG, 'albumName:' + albumName);\n    if (albumType === MediaConstants.ALBUM_TYPE_ALL) {\n      return await userFileModel.getAllMediaItems();\n    } else if (albumType === MediaConstants.ABSTRACT_ALBUM_TYPE_MOVING_PHOTO) {\n      return await userFileModel.getAllMovingPhotoItems();\n    }\n    let emptyPredicates = new dataSharePredicates.DataSharePredicates();\n    emptyPredicates.orderByDesc(photoAccessHelper.PhotoKeys.DATE_ADDED);\n    let emptyFetchOption = {\n      fetchColumns: MediaConstants.FILE_ASSET_FETCH_COLUMNS,\n      predicates: emptyPredicates\n    };\n    return await userFileModel.getAllMediaItemsByType(albumType, albumSubType, fetchOption, emptyFetchOption);\n  }\n\n  private getCount(): number {\n    let contentWidth = screenManager.getWinWidth();\n    let maxThumbWidth = px2vp(Constants.GRID_IMAGE_SIZE) * Constants.GRID_MAX_SIZE_RATIO;\n    let columns = Math.max(Constants.GRID_MIN_COUNT, Math.ceil((contentWidth + Constants.GRID_GUTTER) / (maxThumbWidth + Constants.GRID_GUTTER)));\n    let contentHeight = screenManager.getWinHeight() - Constants.ACTION_BAR_HEIGHT - screenManager.getNaviBarHeight();\n    let rows = Math.ceil((contentHeight + Constants.GRID_GUTTER) / (maxThumbWidth + Constants.GRID_GUTTER)) + 4;\n    return columns * rows;\n  }\n}\n", "llm_cg": {"GroupDataImpl.setAlbumId(id: string)": ["Log.info(TAG, 'setAlbumId: ' + id)"], "GroupDataImpl.setDeviceId(id: string)": ["Log.info(TAG, 'setDeviceId: ' + id)"], "GroupDataImpl.setAlbumType(albumType: number)": ["Log.info(TAG, 'setAlbumType: ' + albumType)"], "GroupDataImpl.setAlbumSubtype(albumSubType: number)": ["Log.info(TAG, 'setAlbumSubtype: ' + albumSubType)"], "GroupDataImpl.setAlbumName(name: string)": ["Log.info(TAG, 'setAlbumName: ' + name)"], "GroupDataImpl.reloadGroupItemData(isGrid: boolean)": ["GroupDataImpl.reloadGridGroupItemData()", "GroupDataImpl.reloadBrowserGroupItemData()"], "GroupDataImpl.reloadBrowserGroupItemData()": ["Log.info(TAG, 'reloadBrowserGroupItemData')", "GroupDataImpl.getMediaItemFileAssets(this.albumName, this.albumType, this.albumSubType)", "FavorUserFileDataItem.update(mediaFileAssets[i])", "TrashUserFileDataItem.update(mediaFileAssets[i])", "UserFileDataItem.update(mediaFileAssets[i])", "Log.info(TAG, 'reload finish')"], "GroupDataImpl.reloadGridGroupItemData()": ["Log.info(TAG, 'reloadGridGroupItemData')", "GroupDataImpl.getMediaItemFileAssets(this.albumName, this.albumType, this.albumSubType)", "FavorUserFileDataItem.update(mediaFileAssets[i])", "TrashUserFileDataItem.update(mediaFileAssets[i])", "UserFileDataItem.update(mediaFileAssets[i])", "Log.info(TAG, 'reload finish')"], "GroupDataImpl.getMediaItemFileAssets(albumName: string, albumType: number, albumSubType: number)": ["Log.info(TAG, 'albumName:' + albumName)", "userFileModel.getAllMediaItems()", "userFileModel.getAllMovingPhotoItems()", "userFileModel.getAllMediaItemsByType(albumType, albumSubType, fetchOption, emptyFetchOption)"], "GroupDataImpl.getCount()": ["screenManager.getWinWidth()", "screenManager.getWinHeight()", "screenManager.getNaviBarHeight()"]}, "static_cg": {"@test/41.ts: GroupDataImpl.reloadGroupItemData(boolean)": ["@test/41.ts: GroupDataImpl.reloadGridGroupItemData()", "@test/41.ts: GroupDataImpl.reloadBrowserGroupItemData()"], "@test/41.ts: GroupDataImpl.reloadBrowserGroupItemData()": ["@test/41.ts: GroupDataImpl.getMediaItemFileAssets(string, number, number)"], "@test/41.ts: GroupDataImpl.reloadGridGroupItemData()": ["@test/41.ts: GroupDataImpl.getMediaItemFileAssets(string, number, number)"]}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Log } from '../utils/Log';\nimport { AlbumDataImpl } from './AlbumDataImpl';\nimport { LazyItem, ItemDataSource } from './ItemDataSource';\nimport { AlbumDataItem } from './AlbumDataItem';\nimport { MediaConstants } from '../constants/MediaConstants'\n\nconst TAG = 'AlbumsDataSource'\n\nexport class AlbumsDataSource extends ItemDataSource {\n  private albumDataItems: AlbumDataItem[] = [];\n  private albumDataImpl: AlbumDataImpl = new AlbumDataImpl();\n\n  setBlackList(blackList: string[]): void {\n    this.albumDataImpl.setBlackList(blackList);\n  }\n\n  setSelectType(selectType: number): void {\n    this.albumDataImpl.setSelectType(selectType);\n  }\n\n  setDeviceId(deviceId: string): void {\n    this.albumDataImpl.setDeviceId(deviceId);\n  }\n\n  totalCount(): number {\n    return this.albumDataItems.length;\n  }\n\n  getData(index: number): LazyItem<AlbumDataItem> {\n    return new LazyItem<AlbumDataItem>(this.getDataByIndex(index), index, (index: number): void => this.onDataUpdateBindImpl(index));\n  }\n\n  getDataByIndex(index: number): AlbumDataItem {\n    if (index < 0 || index >= this.albumDataItems.length) {\n      Log.warn(TAG, index + '/' + this.albumDataItems.length);\n      return undefined;\n    }\n    this.albumDataItems[index].index = index;\n    return this.albumDataItems[index];\n  }\n\n  isSelect(): boolean {\n    let isSelect = true;\n    for (let i = 0;i < this.albumDataItems.length; i++) {\n      if (!this.albumDataItems[i].isSelect) {\n        isSelect = false;\n        break;\n      }\n    }\n    return isSelect;\n  }\n\n  resetLoadState(): void {\n    for (let i = 0;i < this.albumDataItems.length; i++) {\n      if (this.albumDataItems[i].status === MediaConstants.LOADED) {\n        this.albumDataItems[i].status = MediaConstants.UNDEFINED;\n      }\n    }\n  }\n\n  getAlbumDataItemById(id: string): AlbumDataItem | null {\n    let albumDataItem: AlbumDataItem = null;\n    for (let i = 0;i < this.albumDataItems.length; i++) {\n      if (this.albumDataItems[i].id === id) {\n        albumDataItem = this.albumDataItems[i];\n      }\n    }\n    return albumDataItem;\n  }\n\n  getSelectedUris(): string[] {\n    let uris: string[] = [];\n    this.albumDataItems.forEach((item: AlbumDataItem): void => {\n      if (item.isSelect) {\n        uris.push(item.uri);\n      }\n    })\n    return uris;\n  }\n\n  isDisableRename(): boolean {\n    let isDisableRename = false;\n    for (let i = 0;i < this.albumDataItems.length; i++) {\n      if (this.albumDataItems[i].isSelect && this.albumDataItems[i].isDisableRename) {\n        isDisableRename = true;\n        break;\n      }\n    }\n    return isDisableRename;\n  }\n\n  isDisableDelete(): boolean {\n    let isDisableDelete = false;\n    for (let i = 0;i < this.albumDataItems.length; i++) {\n      if (this.albumDataItems[i].isSelect && this.albumDataItems[i].isDisableDelete) {\n        isDisableDelete = true;\n        break;\n      }\n    }\n    return isDisableDelete;\n  }\n\n  setSelect(isSelect: boolean): void {\n    this.albumDataItems.forEach((item: AlbumDataItem): void => {\n      item.setSelect(isSelect);\n    })\n  }\n\n  getSelectedCount(): number {\n    let count = 0;\n    for (let i = 0;i < this.albumDataItems.length; i++) {\n      if (this.albumDataItems[i].isSelect) {\n        count++;\n      }\n    }\n    return count;\n  }\n\n  getSelectedItems(): Object[] {\n    let items: AlbumDataItem[] = [];\n    this.albumDataItems.forEach((item: AlbumDataItem): void => {\n      if (item.isSelect) {\n        items.push(item);\n      }\n    })\n    return items;\n  }\n\n  onDataUpdate(index: number): void {\n    this.onDataUpdateBindImpl(index);\n  }\n\n  private onDataUpdateBindImpl(index: number): void {\n    Log.info(TAG, 'onDataUpdate ' + index);\n    this.notifyDataChange(index);\n  }\n\n  dataReload(): void {\n    this.reloadAlbumItemData().then<void, void>((isEmpty: boolean): void => {\n      this.notifyDataReload();\n    })\n  }\n\n  dataRemove(): void {\n    for (let i = this.albumDataItems.length - 1;i >= 0; i--) {\n      if (this.albumDataItems[i].isDeleted()) {\n        this.albumDataItems.splice(i, 1);\n        super.notifyDataDelete(i);\n      }\n    }\n  }\n\n  async reloadAlbumItemData(): Promise<boolean> {\n    this.albumDataItems = await this.albumDataImpl.reloadAlbumItemData();\n    return this.albumDataItems.length === 0;\n  }\n\n  async reloadAlbumListItemData(): Promise<boolean> {\n    Log.info(TAG, 'reloadAlbumListItemData');\n    this.albumDataItems = await this.albumDataImpl.reloadAlbumItemData();\n    this.notifyDataReload();\n    return this.albumDataItems.length === 0;\n  }\n}\n", "llm_cg": {"AlbumsDataSource.setBlackList(blackList: string[])": ["AlbumDataImpl.setBlackList(blackList: string[])"], "AlbumsDataSource.setSelectType(selectType: number)": ["AlbumDataImpl.setSelectType(selectType: number)"], "AlbumsDataSource.setDeviceId(deviceId: string)": ["AlbumDataImpl.setDeviceId(deviceId: string)"], "AlbumsDataSource.getData(index: number)": ["AlbumsDataSource.getDataByIndex(index: number)", "AlbumsDataSource.%AM0$onDataUpdateBindImpl(index: number)"], "AlbumsDataSource.getDataByIndex(index: number)": [], "AlbumsDataSource.isSelect()": [], "AlbumsDataSource.resetLoadState()": [], "AlbumsDataSource.getAlbumDataItemById(id: string)": [], "AlbumsDataSource.getSelectedUris()": [], "AlbumsDataSource.isDisableRename()": [], "AlbumsDataSource.isDisableDelete()": [], "AlbumsDataSource.setSelect(isSelect: boolean)": ["AlbumDataItem.setSelect(isSelect: boolean)"], "AlbumsDataSource.getSelectedCount()": [], "AlbumsDataSource.getSelectedItems()": [], "AlbumsDataSource.onDataUpdate(index: number)": ["AlbumsDataSource.onDataUpdateBindImpl(index: number)"], "AlbumsDataSource.onDataUpdateBindImpl(index: number)": ["Log.info(TAG: string, message: string)", "AlbumsDataSource.notifyDataChange(index: number)"], "AlbumsDataSource.dataReload()": ["AlbumsDataSource.reloadAlbumItemData()", "AlbumsDataSource.notifyDataReload()"], "AlbumsDataSource.dataRemove()": ["AlbumDataItem.isDeleted()", "AlbumsDataSource.notifyDataDelete(index: number)"], "AlbumsDataSource.reloadAlbumItemData()": ["AlbumDataImpl.reloadAlbumItemData()"], "AlbumsDataSource.reloadAlbumListItemData()": ["Log.info(TAG: string, message: string)", "AlbumDataImpl.reloadAlbumItemData()", "AlbumsDataSource.notifyDataReload()"]}, "static_cg": {"@test/42.ts: AlbumsDataSource.getData(number)": ["@test/42.ts: AlbumsDataSource.getDataByIndex(number)", "@test/42.ts: AlbumsDataSource.%AM0$getData(number)"], "@test/42.ts: AlbumsDataSource.getSelectedUris()": ["@test/42.ts: AlbumsDataSource.%AM1$getSelectedUris([uris], AlbumDataItem)"], "@test/42.ts: AlbumsDataSource.setSelect(boolean)": ["@test/42.ts: AlbumsDataSource.%AM2$setSelect([isSelect], AlbumDataItem)"], "@test/42.ts: AlbumsDataSource.getSelectedItems()": ["@test/42.ts: AlbumsDataSource.%AM3$getSelectedItems([items], AlbumDataItem)"], "@test/42.ts: AlbumsDataSource.onDataUpdate(number)": ["@test/42.ts: AlbumsDataSource.onDataUpdateBindImpl(number)"], "@test/42.ts: AlbumsDataSource.dataReload()": ["@test/42.ts: AlbumsDataSource.reloadAlbumItemData()", "@test/42.ts: AlbumsDataSource.%AM4$dataReload(boolean)"], "@test/42.ts: AlbumsDataSource.%AM0$getData(number)": ["@test/42.ts: AlbumsDataSource.onDataUpdateBindImpl(number)"]}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Log } from '../utils/Log';\nimport { Broadcast } from './Broadcast';\nimport { stashOrGetObject } from '../utils/SingleInstanceUtils';\n\nconst TAG = 'BroadcastManager';\n\nexport class BroadcastManager {\n  // The global Broadcast of the application process. Event registration and destruction should be paired\n  private appBroadcast: Broadcast;\n\n  constructor() {\n    Log.info(TAG, 'constructor');\n    this.appBroadcast = new Broadcast();\n  }\n\n  public getBroadcast(): Broadcast {\n    return this.appBroadcast;\n  }\n}\n\nexport let broadcastManager: BroadcastManager = stashOrGetObject<BroadcastManager>(new BroadcastManager(), TAG);\n", "llm_cg": {"BroadcastManager.constructor()": ["Log.info(string, string)", "Broadcast.constructor()"], "BroadcastManager.getBroadcast()": [], "stashOrGetObject<BroadcastManager>(BroadcastManager, string)": []}, "static_cg": {"@test/43.ts: %dflt.[static]%dflt()": ["@test/43.ts: BroadcastManager.constructor()"]}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Matrix4 from '@ohos.matrix4';\nimport { UserFileDataItem } from '../base/UserFileDataItem';\nimport { Log } from '../utils/Log';\nimport { Broadcast } from './Broadcast';\nimport { MathUtils } from '../utils/MathUtils';\nimport { Constants } from '../constants/BrowserConstants';\nimport { screenManager } from './ScreenManager';\nimport { MediaConstants } from '../constants/MediaConstants';\n\nconst TAG = 'EventPipeline'\n\nexport interface Matrix4TransitWithMatrix4x4 extends Matrix4.Matrix4Transit {\n  matrix4x4: number[];\n}\n\nexport interface AnimationOption {\n  duration: number,\n  curve: Curve\n}\n\nexport class EventPipeline {\n\n  // last offset\n  private lastOffset: number[] = [0, 0];\n\n  // offset\n  private offset: number[] = [0, 0];\n\n  // default scale\n  private defaultScale = 1.0;\n\n  // last scale\n  private lastScale = 1.0;\n\n  // scale\n  private scale = 1.0;\n\n  // the zoom center point is a percentage position relative to the control, not an absolute position\n  private center: number[] = [Constants.CENTER_DEFAULT, Constants.CENTER_DEFAULT];\n\n  // leftmost zoom Center，(1 - leftMost)is rightmost zoom Center\n  private leftMost = 0.0;\n\n  // top zoom center，(1 - topMost)is bottom zoom center\n  private topMost = 0.0;\n\n  // double tap scale\n  private doubleTapScale = 1.0;\n\n  // max scale\n  private maxScale = 1.0;\n\n  // has reached the far left\n  private hasReachLeft = true;\n\n  // has reached the far right\n  private hasReachRight = true;\n\n  // has reached the far top\n  private hasReachTop = true;\n\n  // has reached the far bottom\n  private hasReachBottom = true;\n\n  // Broadcast\n  private broadCast: Broadcast;\n\n  // item\n  private item: UserFileDataItem;\n\n  // timeStamp\n  private timeStamp: string;\n\n  // width\n  private width: number;\n\n  // height\n  private height: number;\n\n  // Large display control width\n  private componentWidth: number = vp2px(screenManager.getWinWidth());\n\n  // Large display control height\n  private componentHeight = vp2px(screenManager.getWinHeight());\n\n  // is now in animation\n  private isInAnimation = false;\n\n  // pull down to return flag to prevent multiple triggers\n  private isExiting = false;\n\n  private updateMatrix: Function;\n\n  constructor(broadCastParam: Broadcast, item: UserFileDataItem, timeStamp: string, updateMatrix: Function) {\n    this.broadCast = broadCastParam;\n    this.item = item;\n    this.timeStamp = timeStamp;\n    this.updateMatrix = updateMatrix;\n    this.width = this.item.imgWidth === 0 ? MediaConstants.DEFAULT_SIZE : this.item.imgWidth;\n    this.height = this.item.imgHeight === 0 ? MediaConstants.DEFAULT_SIZE : this.item.imgHeight;\n    this.evaluateScales();\n  }\n\n  onDataChanged(item: UserFileDataItem): void {\n    this.item = item;\n    this.width = this.item.imgWidth === 0 ? MediaConstants.DEFAULT_SIZE : this.item.imgWidth;\n    this.height = this.item.imgHeight === 0 ? MediaConstants.DEFAULT_SIZE : this.item.imgHeight;\n    this.evaluateScales();\n  }\n\n  setDefaultScale(scale): void {\n    this.defaultScale = scale;\n    this.lastScale = scale;\n  }\n\n  onComponentSizeChanged(): void {\n    this.evaluateScales();\n  }\n\n  onTouch(event: TouchEvent): void {\n    Log.debug(TAG, 'onTouch trigger: ' + event.type + ', ' + this.isInAnimation + ', ' + this.isExiting);\n    if (this.isInAnimation || this.isExiting) {\n      return;\n    }\n    if (event.type === TouchType.Down || event.type === TouchType.Up) {\n      this.emitDirectionChange();\n    }\n\n    if (event.type === TouchType.Up) {\n      this.lastOffset = this.evaluateOffset();\n      this.lastScale = this.lastScale * this.scale;\n      this.scale = 1;\n      this.offset = [0, 0];\n    }\n  }\n\n  private emitDirectionChange(): void {\n\n    /**\n     * reachLeft reachRight scale>1，only five possible situations（when scale<=1,reachLeft、reachRight is true）：\n     * T T T：Vertical\n     * T T F：Vertical（initial state）\n     * T F T：Vertical | Left\n     * F T T：Vertical | Right\n     * F F T：All\n     */\n    let direction;\n    let scale = this.lastScale * this.scale;\n    let isEnlarged = Number(scale.toFixed(Constants.RESERVED_DIGITS)) > Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS));\n    if (!this.hasReachLeft && !this.hasReachRight && isEnlarged) {\n      direction = PanDirection.All;\n    } else if (!this.hasReachLeft && this.hasReachRight && isEnlarged) {\n      direction = (PanDirection.Vertical as number) | (PanDirection.Right as number);\n    } else if (this.hasReachLeft && !this.hasReachRight && isEnlarged) {\n      direction = (PanDirection.Vertical as number) | (PanDirection.Left as number);\n    } else {\n      direction = PanDirection.Vertical;\n    }\n\n    Log.info(TAG, 'emitDirectionChange reaches: ' + this.hasReachLeft + ', ' + this.hasReachRight + ', ' + this.hasReachTop + ', ' + this.hasReachBottom +\n    ', scale ' + scale + ', direction: ' + direction);\n    if (this.isExiting) {\n      return;\n    }\n\n    if (direction === (PanDirection.Vertical as number) || direction === ((PanDirection.Vertical as number) | (PanDirection.Left as number)) ||\n    direction === ((PanDirection.Vertical as number) | (PanDirection.Right as number))) {\n      this.broadCast.emit(Constants.SET_DISABLE_SWIPE, [false]);\n    } else {\n      this.broadCast.emit(Constants.SET_DISABLE_SWIPE, [true]);\n    }\n    this.broadCast.emit(Constants.DIRECTION_CHANGE + this.item.uri + this.timeStamp, [direction]);\n  }\n\n  private evaluateOffset(): number[] {\n    Log.info(TAG, 'evaluateOffset lastOffset: ' + this.lastOffset + ', offset: ' + this.offset);\n    let centerX = (this.center[0] - Constants.CENTER_DEFAULT) * this.componentWidth * (this.defaultScale - this.scale) * this.lastScale;\n    let centerY = (this.center[1] - Constants.CENTER_DEFAULT) * this.componentHeight * (this.defaultScale - this.scale) * this.lastScale;\n    let offsetX = this.lastOffset[0] + this.offset[0] + centerX;\n    let offsetY = this.lastOffset[1] + this.offset[1] + centerY;\n    Log.debug(TAG, 'evaluateOffset offsetX: ' + offsetX + ', offsetY: ' + offsetY);\n    return [offsetX, offsetY];\n  }\n\n  private emitTouchEvent(): void {\n    let offset: number[];\n    let scale = this.lastScale * this.scale;\n    if (Number(scale.toFixed(Constants.RESERVED_DIGITS)) > Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) {\n      let limits = this.evaluateOffsetRange(scale);\n      offset = this.evaluateOffset();\n      // the offset in the X direction is always limited for non shrinking scenes\n      offset[0] = MathUtils.clamp(offset[0], limits[0], limits[1]);\n      if (Number(scale.toFixed(Constants.RESERVED_DIGITS)) > Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) {\n        // cannot pull down to return, limit y\n        offset[1] = MathUtils.clamp(offset[1], limits[2], limits[3]);\n      } else {\n        // can pull down to return to the scene, and only limit y to drag upward, limit the lower bound\n        offset[1] = Math.max(limits[2], offset[1]);\n      }\n    } else {\n      // When zooming in, adjust the zoom center to the display center point\n      offset = [0, 0];\n    }\n    let moveX = offset[0];\n    let moveY = offset[1];\n    Log.debug(TAG, 'emitTouchEvent moveX: ' + moveX + ', moveY: ' + moveY);\n    let scaleOption: Matrix4.ScaleOption = {\n      x: scale,\n      y: scale,\n    };\n    let translateOption: Matrix4.TranslateOption = {\n      x: moveX,\n      y: moveY\n    };\n    let matrix = Matrix4.identity()\n      .scale(scaleOption)\n      .translate(translateOption)\n      .copy();\n    Log.debug(TAG, 'emitTouchEvent lastOffset: ' + this.lastOffset + ', offset: ' + this.offset +\n    ',center: ' + this.center + ', scale: ' + this.lastScale + ', ' + this.scale);\n    this.updateMatrix(matrix);\n    this.evaluateBounds();\n  }\n\n  private evaluateScales(): void {\n    if (this.width * this.componentHeight < this.componentWidth * this.height) {\n      // The aspect ratio is less than the display aspect ratio of the control\n      // the height of the control is equal to the height of the picture\n      this.maxScale = this.height / this.componentHeight;\n      // Double click the enlarged scale to ensure that the left and right boundaries are filled\n      this.doubleTapScale = this.componentWidth * this.height / this.width / this.componentHeight;\n      // leftMost = (1 - dspW / compW) / 2 = (1 - compH * imgW / imgH / compW) / 2\n      this.leftMost = (1 - this.componentHeight * this.width / this.height / this.componentWidth) / Constants.NUMBER_2;\n      this.topMost = 0.0;\n    } else if (this.width * this.componentHeight === this.componentWidth * this.height) {\n      // The aspect ratio is equal to the display aspect ratio of the control\n      this.doubleTapScale = Constants.SAME_RATIO_SCALE_FACTOR;\n      this.maxScale = this.doubleTapScale * Constants.MAX_SCALE_EXTRA_FACTOR;\n      this.leftMost = 0;\n      this.topMost = 0;\n    } else {\n      // The aspect ratio is greater than the display aspect ratio of the control\n      // the width of the control is equal to the width of the picture\n      this.maxScale = this.width / this.componentWidth;\n      // Double click the enlarged scale to ensure that the top and bottom fill the boundary\n      this.doubleTapScale = this.componentHeight * this.width / this.height / this.componentWidth;\n      this.leftMost = 0.0;\n      this.topMost = (1 - this.componentWidth * this.height / this.width / this.componentHeight) / Constants.NUMBER_2;\n    }\n\n    this.maxScale = Math.max(this.maxScale, Constants.COMPONENT_SCALE_CEIL);\n    if (this.doubleTapScale > this.maxScale) {\n      this.maxScale = this.doubleTapScale * Constants.MAX_SCALE_EXTRA_FACTOR;\n    }\n    Log.debug(TAG, 'evaluateScales: ' + this.width + '*' + this.height + ' &' +\n    this.componentWidth + '*' + this.componentHeight +\n    ',max: ' + this.maxScale + ', most: [' + this.leftMost + ',' + this.topMost + '], double: ' + this.doubleTapScale);\n  }\n\n  private evaluateCompBounds(): number[] {\n    let scale = this.lastScale * this.scale;\n    let offset = this.evaluateOffset();\n    let result: number[] = [\n      offset[0] - this.componentWidth * (Number(scale.toFixed(Constants.RESERVED_DIGITS)) - Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) / Constants.NUMBER_2,\n      offset[1] - this.componentHeight * (Number(scale.toFixed(Constants.RESERVED_DIGITS)) - Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) / Constants.NUMBER_2\n    ];\n    Log.debug(TAG, 'evaluateCompBounds: ' + result);\n    return result;\n  }\n\n  private evaluateImgDisplaySize(): number[] {\n    let screenScale = 1;\n    let widthScale = this.componentWidth / this.item.imgWidth;\n    let heightScale = this.componentHeight / this.item.imgHeight;\n    screenScale = widthScale > heightScale ? heightScale : widthScale;\n    let scale = this.lastScale * this.scale * screenScale;\n    let imgDisplayWidth = 0;\n    let imgDisplayHeight = 0;\n    imgDisplayWidth = this.width * scale;\n    imgDisplayHeight = this.height * scale;\n    return [imgDisplayWidth, imgDisplayHeight];\n  }\n\n  private evaluateImgDisplayBounds(): number[] {\n    // For the left boundary of the component,\n    // the offset caused by amplification is - compw * (scale-1) / 2,\n    // plus the offset of the gesture to obtain the left boundary of the control.\n    // The same is true for the upper boundary\n    let scale = this.lastScale * this.scale;\n    let leftTop = this.evaluateCompBounds();\n    let imgDisplaySize: number[] = this.evaluateImgDisplaySize();\n    let imgDisplayWidth = imgDisplaySize[0];\n    let imgDisplayHeight = imgDisplaySize[1];\n    let imgLeftBound = 0;\n    let imgTopBound = 0;\n    if (this.width / this.height > this.componentWidth / this.componentHeight) {\n      imgLeftBound = leftTop[0];\n      imgTopBound = leftTop[1] + (this.componentHeight * scale - imgDisplayHeight) / Constants.NUMBER_2;\n    } else {\n      // Control width minus the picture width, divided by 2,\n      // you can get the distance from the left of the picture to the left of the control.\n      // Plus offsetX is the left boundary of the picture currently displayed\n      imgLeftBound = (this.componentWidth * scale - imgDisplayWidth) / Constants.NUMBER_2 + leftTop[0];\n      imgTopBound = leftTop[1];\n    }\n    return [imgLeftBound, imgTopBound];\n  }\n\n  // Calculate picture display boundary\n  private evaluateBounds(): void {\n    let imgDisplaySize: number[] = this.evaluateImgDisplaySize();\n    let imgDisplayWidth = imgDisplaySize[0];\n\n    let imgDisplayBounds = this.evaluateImgDisplayBounds();\n    let imgLeftBound = imgDisplayBounds[0];\n    this.hasReachLeft = imgLeftBound > -1;\n    this.hasReachRight = imgLeftBound + imgDisplayWidth < this.componentWidth + 1;\n  }\n\n  /**\n   * Calculate the upper and lower bounds of offset in X and Y directions under the current scale\n   *\n   * @param scale The display magnification of the current control, usually this.lastScale * this.scale\n   * @returns 0&1 X-direction offset lower & upper bound, 2&3 Y-direction offset lower & upper bound\n   */\n  private evaluateOffsetRange(scale: number): number[] {\n    let result: number[] = [0, 0, 0, 0];\n    let screenScale = 1;\n    let widthScale = this.componentWidth / this.item.imgWidth;\n    let heightScale = this.componentHeight / this.item.imgHeight;\n    screenScale = widthScale > heightScale ? heightScale : widthScale;\n    let left = (screenScale * scale * this.width - this.componentWidth) / Constants.NUMBER_2;\n    let top = (screenScale * scale * this.height - this.componentHeight) / Constants.NUMBER_2;\n    top = Math.max(top, 0);\n    left = Math.max(left, 0);\n    result = [-left, left, -top, top];\n    Log.debug(TAG, 'evaluateOffsetRange scale: ' + scale + ', defaultScale: ' + this.defaultScale + ', result: ' + result);\n    return result;\n  }\n\n  private emitPullDownToBackEvent(): void {\n    Log.debug(TAG, 'emitPullDownToBackEvent');\n    if (this.isExiting) {\n      Log.info(TAG, 'emitPullDownToBack isExiting: ' + this.isExiting);\n      return;\n    }\n    this.broadCast.emit(Constants.PULL_DOWN_END, []);\n    this.isExiting = true;\n  }\n\n  private emitPullDownCancelEvent(): void {\n    Log.debug(TAG, 'emitPullDownCancelEvent');\n    this.broadCast.emit(Constants.PULL_DOWN_CANCEL, []);\n  }\n\n  onMoveStart(offsetX: number, offsetY: number): void {\n    if (this.isInAnimation || this.isExiting) {\n      return;\n    }\n    // Reset offset at the beginning of dragging to prevent jumping\n    this.offset = [0, 0];\n    this.evaluateBounds();\n    let scale = this.lastScale * this.scale;\n    if (Number(scale.toFixed(Constants.RESERVED_DIGITS)) > Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) {\n      // Hide bars with zoom drag\n      this.broadCast.emit(Constants.HIDE_BARS, []);\n    }\n    if (scale.toFixed(Constants.RESERVED_DIGITS) === this.defaultScale.toFixed(Constants.RESERVED_DIGITS) && offsetY > 0) {\n      // Drop down return to hide details first\n      this.broadCast.emit(Constants.PULL_DOWN_START, []);\n    }\n  }\n\n  /**\n   * Each callback returns the displacement relative to the start point of the gesture\n   *\n   * @param offsetX offsetX\n   * @param offsetY offsetY\n   */\n  onMove(offsetX: number, offsetY: number): void {\n    if (this.isInAnimation || this.isExiting) {\n      return;\n    }\n    let scale = this.lastScale * this.scale;\n    let limits = this.evaluateOffsetRange(scale);\n    let measureX = this.lastOffset[0] + (this.center[0] - Constants.CENTER_DEFAULT) * this.componentWidth\n    * (this.defaultScale - this.scale) * this.lastScale;\n    let measureY = this.lastOffset[1] + (this.center[1] - Constants.CENTER_DEFAULT) * this.componentHeight\n    * (this.defaultScale - this.scale) * this.lastScale;\n    let moveX = offsetX;\n    let moveY = offsetY;\n    let offX = measureX + moveX;\n    let offY = measureY + moveY;\n    if (Number(scale.toFixed(Constants.RESERVED_DIGITS)) > Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) {\n      // The offset in the X direction is always limited for non shrinking scenes\n      offX = MathUtils.clamp(offX, limits[0], limits[1]);\n      if (Number(scale.toFixed(Constants.RESERVED_DIGITS)) > Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) {\n        // cannot drop down to return to the scene, limit y\n        offY = MathUtils.clamp(offY, limits[Constants.NUMBER_2], limits[Constants.NUMBER_3]);\n      } else {\n        // pull down to return to the scene, and only limit y to drag upward, that is, limit the lower bound\n        offY = Math.max(limits[Constants.NUMBER_2], offY);\n      }\n    }\n    let tmpX = offX - measureX;\n    let tmpY = offY - measureY;\n    this.offset = [tmpX, tmpY];\n    this.emitTouchEvent();\n  }\n\n  onMoveEnd(offsetX, offsetY): void {\n    if (this.isInAnimation || this.isExiting) {\n      return;\n    }\n    let scale = this.lastScale * this.scale;\n    Log.debug(TAG, 'onMoveEnd: scale is ' + scale + ' offsetY is ' + offsetY);\n    if (scale.toFixed(Constants.RESERVED_DIGITS) === this.defaultScale.toFixed(Constants.RESERVED_DIGITS) && offsetY > Constants.PULL_DOWN_THRESHOLD) {\n      this.emitPullDownToBackEvent();\n    } else if (scale.toFixed(Constants.RESERVED_DIGITS) === this.defaultScale.toFixed(Constants.RESERVED_DIGITS)) {\n      // The reset animation is triggered when the threshold is not reached\n      let scaleOption: Matrix4.ScaleOption = {\n        x: this.defaultScale,\n        y: this.defaultScale\n      };\n      this.startAnimation(Matrix4.identity().scale(scaleOption).copy() as Matrix4TransitWithMatrix4x4);\n      this.emitPullDownCancelEvent();\n    } else {\n      this.emitDirectionChange();\n    }\n  }\n\n  onScaleStart(scale: number, centerX: number, centerY: number): void {\n    Log.info(TAG, 'onScaleStart: ' + this.isInAnimation + ', ' + this.isExiting);\n    if (this.isInAnimation || this.isExiting) {\n      return;\n    }\n    this.scale = 1;\n    this.evaluateBounds();\n    // Adjust action bar status\n    this.broadCast.emit(Constants.HIDE_BARS, []);\n    this.center = this.evaluateCenter(centerX, centerY);\n  }\n\n  /**\n   * Calculates the percentage position of the current zoom center relative to the control\n   *\n   * @param centerX The absolute position of the touch point on the screen\n   * @param centerY The absolute position of the touch point on the screen\n   * @returns The percentage position of the current zoom center relative to the control\n   */\n  private evaluateCenter(centerX: number, centerY: number): number[] {\n    // Calculate the coordinates of the upper left corner of the control relative to\n    // the upper left corner of the current display\n    let scale = this.lastScale * this.scale;\n    let leftTop = this.evaluateCompBounds();\n\n    // Get the touch coordinates relative to the control\n    let cxRelativeToComp = MathUtils.clamp((centerX - leftTop[0])\n    / (this.componentWidth * scale), this.leftMost, 1 - this.leftMost);\n    let cyRelativeToComp = MathUtils.clamp((centerY - leftTop[1])\n    / (this.componentHeight * scale), this.topMost, 1 - this.topMost);\n\n    let imgDisplaySize: number[] = this.evaluateImgDisplaySize();\n    let imgDisplayWidth = imgDisplaySize[0];\n    let imgDisplayHeight = imgDisplaySize[1];\n\n    let imgDisplayBounds = this.evaluateImgDisplayBounds();\n    let imgLeftBound = imgDisplayBounds[0];\n    let imgTopBound = imgDisplayBounds[1];\n\n    // When the touch center point is outside the picture display area, take the midpoint\n    if (this.width / this.height > this.componentWidth / this.componentHeight) {\n      if (centerY < imgTopBound || centerY > imgTopBound + imgDisplayHeight) {\n        cyRelativeToComp = Constants.CENTER_DEFAULT;\n      }\n    } else {\n      if (centerX < imgLeftBound || centerX > imgLeftBound + imgDisplayWidth) {\n        cxRelativeToComp = Constants.CENTER_DEFAULT;\n      }\n    }\n\n    // Calculate the percentage of the center point of the touch\n    let center: number[] = [cxRelativeToComp, cyRelativeToComp];\n    Log.debug(TAG, 'evaluateCenter center: ' + center + ', ' + centerX + ',' + centerY +\n    ',size: ' + imgDisplaySize + ', bounds: ' + imgDisplayBounds + ', leftTop: ' + leftTop +\n    ',compSize: ' + this.componentWidth * scale + ',' + this.componentHeight * scale);\n    return center;\n  }\n\n  onScale(scale: number): void {\n    Log.debug(TAG, 'onScale: ' + this.isInAnimation + ', ' + this.isExiting + ', scale: ' + scale);\n    if (this.isInAnimation || this.isExiting) {\n      return;\n    }\n    this.evaluateBounds();\n    this.scale = scale;\n    if (this.lastScale * scale <= Constants.COMPONENT_SCALE_FLOOR) {\n      this.scale = Constants.COMPONENT_SCALE_FLOOR / this.lastScale;\n    }\n    if (this.lastScale * scale >= this.maxScale * Constants.OVER_SCALE_EXTRA_FACTOR) {\n      this.scale = this.maxScale * Constants.OVER_SCALE_EXTRA_FACTOR / this.lastScale;\n    }\n    this.emitTouchEvent();\n  }\n\n  onScaleEnd(): void {\n    Log.info(TAG, 'onScaleEnd: ' + this.isInAnimation + ', ' + this.isExiting);\n    if (this.isInAnimation || this.isExiting) {\n      return;\n    }\n    this.evaluateBounds();\n    let scale = this.lastScale * this.scale;\n    if (Number(scale.toFixed(Constants.RESERVED_DIGITS)) >= Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS)) && scale <= this.maxScale) {\n      Log.info(TAG, 'does not need to do animation: ' + scale);\n      this.emitDirectionChange();\n      return;\n    }\n    let animationEndMatrix: Matrix4.Matrix4Transit = null;\n    if (Number(scale.toFixed(Constants.RESERVED_DIGITS)) <= Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) {\n      // Zoom out too small to trigger the restored animation\n      let scaleOption: Matrix4.ScaleOption = {\n        x: this.defaultScale,\n        y: this.defaultScale\n      };\n      animationEndMatrix = Matrix4.identity().scale(scaleOption).copy();\n    } else {\n      // Do the animation of retracting maxScale when zooming in\n      animationEndMatrix = this.evaluateAnimeMatrix(this.maxScale, this.center);\n    }\n    this.startAnimation(animationEndMatrix as Matrix4TransitWithMatrix4x4);\n  }\n\n  private evaluateAnimeMatrix(scale: number, center: number[]): Matrix4.Matrix4Transit {\n    let offset: number[] = [\n      this.lastOffset[0] + this.offset[0] + (center[0] - Constants.CENTER_DEFAULT) * this.componentWidth\n      * (this.defaultScale - scale / this.lastScale) * this.lastScale,\n      this.lastOffset[1] + this.offset[1] + (center[1] - Constants.CENTER_DEFAULT) * this.componentHeight\n      * (this.defaultScale - scale / this.lastScale) * this.lastScale\n    ];\n    if (Number(scale.toFixed(Constants.RESERVED_DIGITS)) > Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) {\n      let limits = this.evaluateOffsetRange(scale);\n      // The offset in the X direction is always limited for non shrinking scenes\n      offset[0] = MathUtils.clamp(offset[0], limits[0], limits[1]);\n      if (Number(scale.toFixed(Constants.RESERVED_DIGITS)) > Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) {\n        // Cannot drop down to return to the scene, limit y\n        offset[1] = MathUtils.clamp(offset[1], limits[Constants.NUMBER_2], limits[Constants.NUMBER_3]);\n      } else {\n        // You can pull down to return to the scene, and only limit y to drag upward,\n        // that is, limit the lower bound\n        offset[1] = Math.max(limits[Constants.NUMBER_2], offset[1]);\n      }\n    } else {\n      // When zooming in, adjust the zoom center to the display center point\n      offset = [0, 0];\n    }\n    let scaleOption: Matrix4.ScaleOption = {\n      x: scale,\n      y: scale,\n    };\n    let translateOption: Matrix4.TranslateOption = {\n      x: offset[0],\n      y: offset[1]\n    };\n    let animationEndMatrix = Matrix4.identity()\n      .copy()\n      .scale(scaleOption)\n      .translate(translateOption)\n      .copy();\n    Log.debug(TAG, 'evaluateAnimeMatrix scale:' + scale + ', center:' + center);\n    return animationEndMatrix;\n  }\n\n  /**\n   * Double click to trigger zoom.\n   * If the current scale is less than or equal to 1, zoom to doubleTapScale;\n   * If the current scale is greater than 1, scale to 1;\n   *\n   * @param centerX the location of double click\n   * @param centerY the location of double click\n   */\n  onDoubleTap(centerX: number, centerY: number): void {\n    if (this.isInAnimation || this.isExiting) {\n      Log.debug(TAG, 'onDoubleTap not avaliable: ' + this.isInAnimation + ', ' + this.isExiting);\n      return;\n    }\n    // Adjust action bar status\n    this.broadCast.emit(Constants.HIDE_BARS, []);\n    let matrix: Matrix4TransitWithMatrix4x4;\n    Log.debug(TAG, 'onDoubleTap lastScale: ' + this.lastScale + ', scale: ' + this.scale + ', defaultScale: ' + this.defaultScale);\n    if (Number(this.lastScale.toFixed(Constants.RESERVED_DIGITS)) * this.scale > Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) {\n      // Scale to original state when scale is greater than 1\n      let scaleOption: Matrix4.ScaleOption = {\n        x: this.defaultScale,\n        y: this.defaultScale\n      };\n      matrix = Matrix4.identity().scale(scaleOption).copy() as Matrix4TransitWithMatrix4x4;\n    } else {\n      // The zoom in status calculates the zoom in center according to the click position\n      let center = this.evaluateCenter(centerX, centerY);\n      // When the picture aspect ratio is less than the control aspect ratio,\n      // centerX is set to 0.5,\n      // whereas centerY is set to 0.5 to ensure that\n      // the short side is close to the side after double clicking and enlarging\n      if (this.width / this.height < this.componentWidth / this.componentHeight) {\n        center = [Constants.CENTER_DEFAULT, center[1]];\n      } else {\n        center = [center[0], Constants.CENTER_DEFAULT];\n      }\n      matrix = this.evaluateAnimeMatrix(this.doubleTapScale * this.defaultScale, center) as Matrix4TransitWithMatrix4x4;\n    }\n    Log.debug(TAG, 'onDoubleTap matrix: ' + matrix.matrix4x4);\n    this.startAnimation(matrix);\n  }\n\n  reset(): void {\n    this.lastOffset = [0, 0];\n    this.offset = [0, 0];\n    this.lastScale = 1.0;\n    this.scale = 1;\n    this.hasReachLeft = true;\n    this.hasReachRight = true;\n    this.hasReachTop = true;\n    this.hasReachBottom = true;\n    this.isInAnimation = false;\n    this.isExiting = false;\n    this.emitDirectionChange();\n  }\n\n  onDisAppear(): void {\n    Log.info(TAG, 'onDisAppear');\n  }\n\n  private startAnimation(animationEndMatrix: Matrix4TransitWithMatrix4x4): void {\n    this.isInAnimation = true;\n    let animationOption: AnimationOption = {\n      duration: Constants.OVER_SCALE_ANIME_DURATION,\n      curve: Curve.Ease\n    };\n    Log.debug(TAG, 'animationEndMatrix: ' + animationEndMatrix.matrix4x4);\n    this.broadCast.emit(Constants.ANIMATION_EVENT + this.item.uri + this.timeStamp, [animationOption, animationEndMatrix]);\n  }\n\n  /**\n   * At the end of the animation,\n   * refresh the current parameter values according to the end transformation matrix to ensure continuity and\n   * prevent jumping during the next gesture operation\n   *\n   * @param animationEndMatrix Transformation matrix at end\n   */\n  onAnimationEnd(animationEndMatrix: Matrix4TransitWithMatrix4x4): void {\n    if (animationEndMatrix != null) {\n      Log.info(TAG, 'onAnimationEnd: ' + animationEndMatrix.matrix4x4);\n      this.lastScale = animationEndMatrix.matrix4x4[0];\n      this.scale = 1;\n      this.lastOffset = [animationEndMatrix.matrix4x4[Constants.NUMBER_12], animationEndMatrix.matrix4x4[Constants.NUMBER_13]];\n      this.offset = [0, 0];\n      this.evaluateBounds();\n      this.isInAnimation = false;\n      this.emitDirectionChange();\n    }\n  }\n}\n", "llm_cg": {"EventPipeline.onWindowStageCreate(window.WindowStage)": [], "EventPipeline.onDataChanged(UserFileDataItem)": ["EventPipeline.evaluateScales()"], "EventPipeline.setDefaultScale(scale)": [], "EventPipeline.onComponentSizeChanged()": ["EventPipeline.evaluateScales()"], "EventPipeline.onTouch(TouchEvent)": ["EventPipeline.emitDirectionChange()", "EventPipeline.evaluateOffset()"], "EventPipeline.emitDirectionChange()": ["Broadcast.emit(Constants.SET_DISABLE_SWIPE, [false])", "Broadcast.emit(Constants.SET_DISABLE_SWIPE, [true])", "Broadcast.emit(Constants.DIRECTION_CHANGE + this.item.uri + this.timeStamp, [direction])"], "EventPipeline.evaluateOffset()": [], "EventPipeline.emitTouchEvent()": ["EventPipeline.evaluateOffsetRange(scale)", "EventPipeline.evaluateOffset()", "MathUtils.clamp(offset[0], limits[0], limits[1])", "MathUtils.clamp(offset[1], limits[2], limits[3])", "Matrix4.identity().scale(scaleOption).translate(translateOption).copy()", "EventPipeline.evaluateBounds()"], "EventPipeline.evaluateScales()": [], "EventPipeline.evaluateCompBounds()": ["EventPipeline.evaluateOffset()"], "EventPipeline.evaluateImgDisplaySize()": [], "EventPipeline.evaluateImgDisplayBounds()": ["EventPipeline.evaluateCompBounds()", "EventPipeline.evaluateImgDisplaySize()"], "EventPipeline.evaluateBounds()": ["EventPipeline.evaluateImgDisplaySize()", "EventPipeline.evaluateImgDisplayBounds()"], "EventPipeline.evaluateOffsetRange(scale)": [], "EventPipeline.emitPullDownToBackEvent()": ["Broadcast.emit(Constants.PULL_DOWN_END, [])"], "EventPipeline.emitPullDownCancelEvent()": ["Broadcast.emit(Constants.PULL_DOWN_CANCEL, [])"], "EventPipeline.onMoveStart(offsetX: number, offsetY: number)": ["EventPipeline.evaluateBounds()", "Broadcast.emit(Constants.HIDE_BARS, [])", "Broadcast.emit(Constants.PULL_DOWN_START, [])"], "EventPipeline.onMove(offsetX: number, offsetY: number)": ["EventPipeline.evaluateOffsetRange(scale)", "MathUtils.clamp(offX, limits[0], limits[1])", "MathUtils.clamp(offY, limits[2], limits[3])", "EventPipeline.emitTouchEvent()"], "EventPipeline.onMoveEnd(offsetX, offsetY)": ["EventPipeline.emitPullDownToBackEvent()", "Matrix4.identity().scale(scaleOption).copy()", "EventPipeline.emitPullDownCancelEvent()", "EventPipeline.emitDirectionChange()"], "EventPipeline.onScaleStart(scale: number, centerX: number, centerY: number)": ["EventPipeline.evaluateBounds()", "Broadcast.emit(Constants.HIDE_BARS, [])", "EventPipeline.evaluateCenter(centerX, centerY)"], "EventPipeline.evaluateCenter(centerX: number, centerY: number)": ["EventPipeline.evaluateCompBounds()", "MathUtils.clamp((centerX - leftTop[0]) / (this.componentWidth * scale), this.leftMost, 1 - this.leftMost)", "MathUtils.clamp((centerY - leftTop[1]) / (this.componentHeight * scale), this.topMost, 1 - this.topMost)", "EventPipeline.evaluateImgDisplaySize()", "EventPipeline.evaluateImgDisplayBounds()"], "EventPipeline.onScale(scale: number)": ["EventPipeline.evaluateBounds()", "EventPipeline.emitTouchEvent()"], "EventPipeline.onScaleEnd()": ["EventPipeline.evaluateBounds()", "Matrix4.identity().scale(scaleOption).copy()", "EventPipeline.evaluateAnimeMatrix(this.maxScale, this.center)", "EventPipeline.startAnimation(animationEndMatrix as Matrix4TransitWithMatrix4x4)"], "EventPipeline.evaluateAnimeMatrix(scale: number, center: number[])": ["MathUtils.clamp(offset[0], limits[0], limits[1])", "MathUtils.clamp(offset[1], limits[2], limits[3])", "Matrix4.identity().copy().scale(scaleOption).translate(translateOption).copy()"], "EventPipeline.onDoubleTap(centerX: number, centerY: number)": ["Broadcast.emit(Constants.HIDE_BARS, [])", "EventPipeline.evaluateCenter(centerX, centerY)", "Matrix4.identity().scale(scaleOption).copy()", "EventPipeline.evaluateAnimeMatrix(this.doubleTapScale * this.defaultScale, center)", "EventPipeline.startAnimation(matrix)"], "EventPipeline.reset()": ["EventPipeline.emitDirectionChange()"], "EventPipeline.onDisAppear()": [], "EventPipeline.startAnimation(animationEndMatrix: Matrix4TransitWithMatrix4x4)": ["Broadcast.emit(Constants.ANIMATION_EVENT + this.item.uri + this.timeStamp, [animationOption, animationEndMatrix])"], "EventPipeline.onAnimationEnd(animationEndMatrix: Matrix4TransitWithMatrix4x4)": ["EventPipeline.evaluateBounds()", "EventPipeline.emitDirectionChange()"]}, "static_cg": {"@test/44.ts: EventPipeline.constructor(Broadcast, UserFileDataItem, string, Function)": ["@test/44.ts: EventPipeline.evaluateScales()"], "@test/44.ts: EventPipeline.onDataChanged(UserFileDataItem)": ["@test/44.ts: EventPipeline.evaluateScales()"], "@test/44.ts: EventPipeline.onComponentSizeChanged()": ["@test/44.ts: EventPipeline.evaluateScales()"], "@test/44.ts: EventPipeline.onTouch(TouchEvent)": ["@test/44.ts: EventPipeline.emitDirectionChange()", "@test/44.ts: EventPipeline.evaluateOffset()"], "@test/44.ts: EventPipeline.emitTouchEvent()": ["@test/44.ts: EventPipeline.evaluateOffsetRange(number)", "@test/44.ts: EventPipeline.evaluateOffset()", "@test/44.ts: EventPipeline.evaluateBounds()"], "@test/44.ts: EventPipeline.evaluateCompBounds()": ["@test/44.ts: EventPipeline.evaluateOffset()"], "@test/44.ts: EventPipeline.evaluateImgDisplayBounds()": ["@test/44.ts: EventPipeline.evaluateCompBounds()", "@test/44.ts: EventPipeline.evaluateImgDisplaySize()"], "@test/44.ts: EventPipeline.evaluateBounds()": ["@test/44.ts: EventPipeline.evaluateImgDisplaySize()", "@test/44.ts: EventPipeline.evaluateImgDisplayBounds()"], "@test/44.ts: EventPipeline.onMoveStart(number, number)": ["@test/44.ts: EventPipeline.evaluateBounds()"], "@test/44.ts: EventPipeline.onMove(number, number)": ["@test/44.ts: EventPipeline.evaluateOffsetRange(number)", "@test/44.ts: EventPipeline.emitTouchEvent()"], "@test/44.ts: EventPipeline.onMoveEnd(unknown, unknown)": ["@test/44.ts: EventPipeline.emitPullDownToBackEvent()", "@test/44.ts: EventPipeline.startAnimation(@test/44.ts: Matrix4TransitWithMatrix4x4)", "@test/44.ts: EventPipeline.emitPullDownCancelEvent()", "@test/44.ts: EventPipeline.emitDirectionChange()"], "@test/44.ts: EventPipeline.onScaleStart(number, number, number)": ["@test/44.ts: EventPipeline.evaluateBounds()", "@test/44.ts: EventPipeline.evaluateCenter(number, number)"], "@test/44.ts: EventPipeline.evaluateCenter(number, number)": ["@test/44.ts: EventPipeline.evaluateCompBounds()", "@test/44.ts: EventPipeline.evaluateImgDisplaySize()", "@test/44.ts: EventPipeline.evaluateImgDisplayBounds()"], "@test/44.ts: EventPipeline.onScale(number)": ["@test/44.ts: EventPipeline.evaluateBounds()", "@test/44.ts: EventPipeline.emitTouchEvent()"], "@test/44.ts: EventPipeline.onScaleEnd()": ["@test/44.ts: EventPipeline.evaluateBounds()", "@test/44.ts: EventPipeline.emitDirectionChange()", "@test/44.ts: EventPipeline.evaluateAnimeMatrix(number, number[])", "@test/44.ts: EventPipeline.startAnimation(@test/44.ts: Matrix4TransitWithMatrix4x4)"], "@test/44.ts: EventPipeline.evaluateAnimeMatrix(number, number[])": ["@test/44.ts: EventPipeline.evaluateOffsetRange(number)"], "@test/44.ts: EventPipeline.onDoubleTap(number, number)": ["@test/44.ts: EventPipeline.evaluateCenter(number, number)", "@test/44.ts: EventPipeline.evaluateAnimeMatrix(number, number[])", "@test/44.ts: EventPipeline.startAnimation(@test/44.ts: Matrix4TransitWithMatrix4x4)"], "@test/44.ts: EventPipeline.reset()": ["@test/44.ts: EventPipeline.emitDirectionChange()"], "@test/44.ts: EventPipeline.onAnimationEnd(@test/44.ts: Matrix4TransitWithMatrix4x4)": ["@test/44.ts: EventPipeline.evaluateBounds()", "@test/44.ts: EventPipeline.emitDirectionChange()"]}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport photoAccessHelper from '@ohos.file.photoAccessHelper';\nimport { userFileModel } from '../base/UserFileModel';\nimport { selectManager } from './SelectManager';\nimport { Log } from '../utils/Log';\nimport { MediaConstants } from '../constants/MediaConstants';\nimport dataSharePredicates from '@ohos.data.dataSharePredicates';\n\nconst TAG = 'AlbumDataItem';\n\nlet objectIndex = 0;\n\nexport class AlbumDataItem {\n  index: number;\n  id: string;\n  uri: string;\n  orientation: number;\n  displayName: string;\n  count: number;\n  isDisableRename: boolean;\n  isDisableDelete: boolean;\n  innerId: number;\n  selectType: number = MediaConstants.SELECT_TYPE_ALL;\n  deviceId: string = '';\n  isSelect: boolean = false;\n  status: number = MediaConstants.UNDEFINED;\n  objectIndex: number;\n  albumType: number;\n  albumSubType: number;\n  fileUir: string = undefined;\n  fileAsset: photoAccessHelper.PhotoAsset;\n  thumbnail: PixelMap = undefined;\n\n  constructor(id: string, count: number, displayName: string, selectType: number, deviceId: string, albumType: number, albumSubType: number) {\n    this.id = id;\n    this.displayName = displayName;\n    this.count = count;\n    this.isDisableRename = MediaConstants.ALBUM_DISABLE_RENAME_LIST.has(id);\n    this.isDisableDelete = MediaConstants.ALBUM_DISABLE_DELETE_LIST.has(id);\n    this.selectType = selectType;\n    this.deviceId = deviceId;\n    this.objectIndex = objectIndex++;\n    this.albumType = albumType;\n    this.albumSubType = albumSubType;\n  }\n\n  getHashCode(): string {\n    return this.objectIndex + '' + this.id + ' ' + this.orientation + ' ' + this.isSelect;\n  }\n\n  async load(): Promise<void> {\n    if (this.status >= MediaConstants.LOADED) {\n      return;\n    }\n    if (this.fileUir !== undefined && this.fileUir !== null) {\n      let fileAsset = (await userFileModel.getMediaItemByUri(this.fileUir));\n      await this.update(fileAsset);\n    }\n  }\n\n  async update(fileAsset: photoAccessHelper.PhotoAsset): Promise<void> {\n    Log.info(TAG, 'this.uri ' + this.displayName);\n    Log.info(TAG, 'this.uri ' + this.uri);\n    if (fileAsset != null) {\n      this.fileUir = fileAsset.uri;\n      this.fileAsset = fileAsset;\n      if (this.fileAsset != null) {\n        await this.getThumbnail();\n      }\n      Log.info(TAG, 'this.fileUri ' + this.fileUir);\n    }\n    this.status = MediaConstants.LOADED;\n    this.isSelect = selectManager.isSelect(this.id, this.isSelect);\n  }\n\n  async getThumbnail(): Promise<PixelMap> {\n    if (this.thumbnail == undefined) {\n      let size = { width: MediaConstants.DEFAULT_SIZE, height: MediaConstants.DEFAULT_SIZE };\n      try {\n        this.thumbnail = await this.fileAsset.getThumbnail(size)\n      } catch (err) {\n        Log.error(TAG, 'getThumbnail error: ' + JSON.stringify(err));\n      }\n    }\n    return this.thumbnail;\n  }\n\n  async getVideoCount(): Promise<number> {\n    if (this.selectType === MediaConstants.SELECT_TYPE_IMAGE) {\n      return 0;\n    }\n    let fileAssets: photoAccessHelper.PhotoAsset[] = [];\n    let albumPredicates = new dataSharePredicates.DataSharePredicates();\n    albumPredicates.equalTo(photoAccessHelper.AlbumKeys.ALBUM_NAME, this.displayName)\n    let albumFetchOption = {\n      fetchColumns: MediaConstants.EMPTY_FETCH_COLUMNS,\n      predicates: albumPredicates\n    };\n    let predicates = new dataSharePredicates.DataSharePredicates();\n    predicates.equalTo(photoAccessHelper.PhotoKeys.PHOTO_TYPE, photoAccessHelper.PhotoType.VIDEO)\n    predicates.orderByDesc(photoAccessHelper.PhotoKeys.DATE_ADDED);\n    let fileFetchOption = {\n      fetchColumns: MediaConstants.FILE_ASSET_FETCH_COLUMNS,\n      predicates: predicates\n    };\n    fileAssets = await userFileModel.getAllMediaItemsByType(this.albumType, this.albumSubType, albumFetchOption, fileFetchOption);\n    return fileAssets.length;\n  }\n\n  setSelect(isSelect: boolean): void {\n    this.isSelect = isSelect;\n    selectManager.setSelect(this.id, this.isSelect);\n  }\n\n  async onDelete(): Promise<boolean> {\n    try {\n      Log.error(TAG, this.displayName);\n      await userFileModel.deleteAlbum(this.displayName);\n      selectManager.deleteSelect(this.uri);\n      this.status = MediaConstants.TRASHED;\n      return true;\n    } catch (err) {\n      Log.error(TAG, 'onDelete error: ' + JSON.stringify(err));\n      return false;\n    }\n  }\n\n  isDeleted(): boolean {\n    return this.status === MediaConstants.TRASHED;\n  }\n}\n", "llm_cg": {"AlbumDataItem.load()": ["AlbumDataItem.update(photoAccessHelper.PhotoAsset)"], "AlbumDataItem.update(photoAccessHelper.PhotoAsset)": ["AlbumDataItem.getThumbnail()", "selectManager.isSelect(string, boolean)"], "AlbumDataItem.getThumbnail()": ["photoAccessHelper.PhotoAsset.getThumbnail({ width: number, height: number })"], "AlbumDataItem.getVideoCount()": ["userFileModel.getAllMediaItemsByType(number, number, { fetchColumns: string[], predicates: dataSharePredicates.DataSharePredicates }, { fetchColumns: string[], predicates: dataSharePredicates.DataSharePredicates })"], "AlbumDataItem.setSelect(boolean)": ["selectManager.setSelect(string, boolean)"], "AlbumDataItem.onDelete()": ["userFileModel.deleteAlbum(string)", "selectManager.deleteSelect(string)"]}, "static_cg": {"@test/45.ts: AlbumDataItem.load()": ["@test/45.ts: AlbumDataItem.update(photoAccessHelper.PhotoAsset)"], "@test/45.ts: AlbumDataItem.update(photoAccessHelper.PhotoAsset)": ["@test/45.ts: AlbumDataItem.getThumbnail()"]}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { stashOrGetObject } from '../utils/SingleInstanceUtils';\n\nconst TAG = 'SelectManager';\n\nclass SelectManager {\n  private status: Map<string, boolean> = new Map<string, boolean>();\n\n  isSelect(key: string, defaultValue: boolean): boolean {\n    if (this.status.has(key)) {\n      return this.status.get(key);\n    } else {\n      return defaultValue;\n    }\n  }\n\n  setSelect(key: string, value: boolean): void {\n    this.status.set(key, value);\n  }\n\n  deleteSelect(key: string): void {\n    this.status.delete(key);\n  }\n}\n\nexport let selectManager: SelectManager = stashOrGetObject<SelectManager>(new SelectManager(), TAG);\n", "llm_cg": {"SelectManager.isSelect(key: string, defaultValue: boolean)": ["SelectManager.status.has(key: string)", "SelectManager.status.get(key: string)"], "SelectManager.setSelect(key: string, value: boolean)": ["SelectManager.status.set(key: string, value: boolean)"], "SelectManager.deleteSelect(key: string)": ["SelectManager.status.delete(key: string)"]}, "static_cg": {}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Log } from './Log';\nimport { screenManager } from '../common/ScreenManager'\nimport { Constants } from '../constants/Constants'\n\nconst TAG = 'UiUtil';\n\nexport class UiUtil {\n  public static getAlbumGridCount(horizontal: boolean): number {\n    Log.info(TAG, 'get screen width is : ' + screenManager.getWinWidth());\n    Log.info(TAG, 'get screen height is : ' + screenManager.getWinHeight());\n    let sideBarWidth = horizontal ? Constants.TAB_BAR_WIDTH : 0;\n    let contentWidth = screenManager.getWinWidth() - sideBarWidth;\n\n    let maxCardWidth = Constants.ALBUM_SET_COVER_SIZE * Constants.GRID_MAX_SIZE_RATIO;\n    let gridColumnsCount = Math.ceil((contentWidth - Constants.ALBUM_SET_MARGIN * 2 + Constants.ALBUM_SET_GUTTER)\n    / (maxCardWidth + Constants.ALBUM_SET_GUTTER));\n    Log.info(TAG, 'the grid count in a line is : ' + gridColumnsCount);\n    return gridColumnsCount;\n  }\n}\n", "llm_cg": {"UiUtil.getAlbumGridCount(boolean)": ["Log.info(string, string)", "screenManager.getWinWidth()", "Log.info(string, string)", "screenManager.getWinHeight()", "screenManager.getWinWidth()"]}, "static_cg": {}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Want from '@ohos.application.Want';\nimport common from '@ohos.app.ability.common';\nimport { Log } from './Log';\nimport { GlobalContext } from '../common/GlobalContext';\n\nconst TAG = 'AbilityUtils';\n\nexport async function startAbility(want: Want): Promise<void> {\n  try {\n    let appContext: common.UIAbilityContext = GlobalContext.getContext().getObject('appContext') as common.UIAbilityContext;\n    await appContext.startAbility(want);\n    Log.debug(TAG, 'raul startAbility complete');\n  } catch (error) {\n    Log.error(TAG, 'raul startAbility failed, error: ' + JSON.stringify(error));\n  }\n}\n\nexport async function terminateSelf(): Promise<void> {\n  let appContext: common.UIAbilityContext = GlobalContext.getContext().getObject('appContext') as common.UIAbilityContext;\n  await appContext.terminateSelf();\n}\n\nexport async function terminateSelfWithResult(parameter): Promise<void> {\n  let appContext: common.UIAbilityContext = GlobalContext.getContext().getObject('appContext') as common.UIAbilityContext;\n  await appContext.terminateSelfWithResult(parameter);\n}\n", "llm_cg": {"AbilityUtils.startAbility(Want)": ["GlobalContext.getContext()", "common.UIAbilityContext.startAbility(Want)", "Log.debug(string, string)"], "AbilityUtils.terminateSelf()": ["GlobalContext.getContext()", "common.UIAbilityContext.terminateSelf()"], "AbilityUtils.terminateSelfWithResult(parameter)": ["GlobalContext.getContext()", "common.UIAbilityContext.terminateSelfWithResult(parameter)"]}, "static_cg": {}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport abstract class MathUtils {\n  static clamp(num: number, min: number, max: number): number {\n    return Math.min(Math.max(num, min), max);\n  }\n}\n", "llm_cg": {"MathUtils.clamp(num: number, min: number, max: number)": ["Math.min(num: number, min: number)", "Math.max(num: number, max: number)"]}, "static_cg": {}}
{"source_code": "// @ts-nocheck\n/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport resourceManager from '@ohos.resourceManager';\nimport { Log } from './Log';\nimport { GlobalContext } from '../common/GlobalContext';\n\nconst TAG = 'ResourceUtils';\n\nexport async function getResourceString(resource: Resource): Promise<string> {\n  try {\n    Log.debug(TAG, 'getResourceString: ' + JSON.stringify(resource));\n    let context = GlobalContext.getContext().getObject('appContext');\n    let mgr: resourceManager.ResourceManager = await resourceManager.getResourceManager(context);\n    if (mgr != null || mgr != undefined) {\n      return await mgr.getStringValue(resource.id);\n    } else {\n      Log.warn(TAG, 'getResourceManager instance is none');\n      return null;\n    }\n  } catch (error) {\n    Log.error(TAG, 'getResourceString error: ' + error);\n    return null;\n  }\n}\n", "llm_cg": {"getResourceString(resource: Resource)": ["Log.debug(TAG, 'getResourceString: ' + JSON.stringify(resource))", "GlobalContext.getContext().getObject('appContext')", "resourceManager.getResourceManager(context)", "mgr.getStringValue(resource.id)", "Log.warn(TAG, 'getResourceManager instance is none')", "Log.error(TAG, 'getResourceString error: ' + error)"]}, "static_cg": {}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Log } from './Log';\nimport { GlobalContext } from '../common/GlobalContext';\n\nconst TAG = 'SingleInstanceHelper';\nlet globalThis = GlobalContext.getContext();\n\nexport function stashOrGetObject<T>(objectClass: object, storageKey: string): T {\n  if (!new Boolean(globalThis.getObject(storageKey)).valueOf()) {\n    globalThis.setObject(storageKey, objectClass);\n    Log.debug(TAG, 'Create key of ' + storageKey);\n  }\n  return globalThis.getObject(storageKey) as T;\n}\n", "llm_cg": {"stashOrGetObject<T>(object, string)": ["GlobalContext.getContext()", "GlobalContext.getObject(string)", "GlobalContext.setObject(string, object)", "Log.debug(string, string)"]}, "static_cg": {}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Log } from './Log';\n\nconst TAG = 'ImageUtil';\nconst MAX_BIT = 30;\nconst BIT_SIXTEEN = 16;\nconst BIT_EIGHT = 8;\nconst BIT_FOUR = 4;\nconst BIT_TWO = 2;\nconst BIT_ONE = 1;\n\nexport function computeSampleSize(width: number, height: number, minSideLength: number, maxNumOfPixels: number): number {\n  if (width === 0 || height === 0 || minSideLength === 0 || maxNumOfPixels === 0) {\n    return 2;\n  }\n  let initialSize = computeInitialSampleSize(width, height, minSideLength, maxNumOfPixels);\n  Log.info(TAG, 'initialSize:  ' + initialSize);\n  return initialSize <= 8 ? nextPowerOf2(initialSize) : Math.floor((initialSize + 8 - 1) / 8) * 8;\n}\n\nfunction computeInitialSampleSize(width: number, height: number, minSideLength: number, maxNumOfPixels: number): number {\n  if ((maxNumOfPixels === -1) && (minSideLength === -1)) {\n    return 1;\n  }\n  let lowerBound: number = (maxNumOfPixels === -1) ? 1 : Math.ceil(Math.sqrt((width * height) / maxNumOfPixels));\n  Log.info(TAG, 'lowerBound: ' + lowerBound);\n  if (minSideLength === -1) {\n    return lowerBound;\n  } else {\n    let sampleSize = Math.min(width / minSideLength, height / minSideLength);\n    return Math.max(sampleSize, lowerBound);\n  }\n}\n\nfunction nextPowerOf2(value: number): number {\n  let useValue = value;\n  if (useValue <= 0 || useValue > (1 << MAX_BIT)) {\n  }\n  useValue -= 1;\n  useValue |= useValue >> BIT_SIXTEEN;\n  useValue |= useValue >> BIT_EIGHT;\n  useValue |= useValue >> BIT_FOUR;\n  useValue |= useValue >> BIT_TWO;\n  useValue |= useValue >> BIT_ONE;\n  Log.info(TAG, 'nextPowerOf2:' + useValue);\n  return useValue + 1;\n}\n", "llm_cg": {"computeSampleSize(width: number, height: number, minSideLength: number, maxNumOfPixels: number)": ["computeInitialSampleSize(width: number, height: number, minSideLength: number, maxNumOfPixels: number)", "nextPowerOf2(value: number)"], "computeInitialSampleSize(width: number, height: number, minSideLength: number, maxNumOfPixels: number)": [], "nextPowerOf2(value: number)": []}, "static_cg": {"@test/52.ts: %dflt.computeSampleSize(number, number, number, number)": ["@test/52.ts: %dflt.computeInitialSampleSize(number, number, number, number)", "@test/52.ts: %dflt.nextPowerOf2(number)"]}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport hiSysEvent from '@ohos.hiSysEvent';\nimport { Log } from './Log';\n\nconst TAG = 'hisysEventUtil';\n\nexport function hiSysEventDataQueryTimedOut(interfaceName: string): number {\n  let timeOutId = setTimeout((): void => {\n    let params: Object = {\n      FAULT_ID: 'DATA_QUERY_OVERTIME',\n      MSG: interfaceName + ' Querying 1s data timed out.'\n    };\n    let info: hiSysEvent.SysEventInfo = {\n      domain: 'PHOTOS_APP',\n      name: 'PHOTOS_FAULT',\n      eventType: hiSysEvent.EventType.FAULT,\n      params: params\n    };\n    hiSysEvent.write(info, (err: Error): void => {\n      if (err != null) {\n        Log.error(TAG, 'fail to return hiSysEvent');\n      }\n    });\n  },1000);\n  return timeOutId;\n}\n", "llm_cg": {"hiSysEventDataQueryTimedOut(interfaceName: string)": ["hiSysEvent.write(info: hiSysEvent.SysEventInfo, callback: (err: Error) => void)", "Log.error(TAG: string, message: string)"]}, "static_cg": {"@test/53.ts: %dflt.hiSysEventDataQueryTimedOut(string)": ["@test/53.ts: %dflt.%AM0$hiSysEventDataQueryTimedOut()"], "@test/53.ts: %dflt.%AM0$hiSysEventDataQueryTimedOut()": ["@test/53.ts: %dflt.%AM1$%AM0$hiSysEventDataQueryTimedOut(Error)"]}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport HiLog from '@ohos.hilog';\n\nexport class Log {\n  private static readonly DOMAIN = 0xF811;\n  private static readonly TAG: string = '[Sample_Photos]';\n  public static readonly LEVEL_DEBUG = HiLog.LogLevel.DEBUG;\n  public static readonly LEVEL_INFO = HiLog.LogLevel.INFO;\n  public static readonly LEVEL_WARN = HiLog.LogLevel.WARN;\n  public static readonly LEVEL_ERROR = HiLog.LogLevel.ERROR;\n  public static readonly LEVEL_FATAL = HiLog.LogLevel.FATAL;\n  public static LOG_LEVEL = Log.LEVEL_INFO;\n\n  public static debug(TAG: string, message: string): void {\n    if (this.LOG_LEVEL <= this.LEVEL_DEBUG) {\n      HiLog.debug(this.DOMAIN, this.TAG, '[' + TAG + ']: ' + message);\n    }\n  }\n\n  public static info(TAG: string, message: string): void {\n    if (this.LOG_LEVEL <= this.LEVEL_INFO) {\n      HiLog.info(this.DOMAIN, this.TAG, '[' + TAG + ']: ' + message);\n    }\n  }\n\n  public static warn(TAG: string, message: string): void {\n    if (this.LOG_LEVEL <= this.LEVEL_WARN) {\n      HiLog.warn(this.DOMAIN, this.TAG, '[' + TAG + ']: ' + message);\n    }\n  }\n\n  public static error(TAG: string, message: string): void {\n    if (this.LOG_LEVEL <= this.LEVEL_ERROR) {\n      HiLog.error(this.DOMAIN, this.TAG, '[' + TAG + ']: ' + message);\n    }\n  }\n\n  public static fatal(TAG: string, message: string): void {\n    if (this.LOG_LEVEL <= this.LEVEL_FATAL) {\n      HiLog.info(this.DOMAIN, this.TAG, '[' + TAG + ']: ' + message);\n    }\n  }\n}", "llm_cg": {"Log.debug(TAG: string, message: string)": ["HiLog.debug(unknown, unknown, unknown)"], "Log.info(TAG: string, message: string)": ["HiLog.info(unknown, unknown, unknown)"], "Log.warn(TAG: string, message: string)": ["HiLog.warn(unknown, unknown, unknown)"], "Log.error(TAG: string, message: string)": ["HiLog.error(unknown, unknown, unknown)"], "Log.fatal(TAG: string, message: string)": ["HiLog.info(unknown, unknown, unknown)"]}, "static_cg": {}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport interface DialogCallback {\n  confirmCallback: Function | null;\n  cancelCallback: Function | undefined;\n}\n", "llm_cg": {"DialogCallback.confirmCallback": [], "DialogCallback.cancelCallback": []}, "static_cg": {}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Log } from './Log';\nimport i18n from '@ohos.i18n';\nimport Intl from '@ohos.intl';\n\nconst TAG = 'DateUtil';\n\nexport class DateUtil {\n  private static LANGUAGE_LOCALES_MAP: Map<string, string> = null;\n\n  private static readonly FORMAT_DECIMAL: number = 10;\n  public static readonly MILLISECONDS_PER_SECOND: number = 1000;\n  public static readonly SECONDS_PER_MINUTE: number = 60;\n  public static readonly SECONDS_PER_HOUR: number = 3600;\n\n  private static readonly NEW_NAME_IMG: string = 'IMG_';\n  private static readonly NEW_NAME_EDIT: string = 'edit_';\n\n\n  private static initLanguageLocalesMap(): void {\n    if (DateUtil.LANGUAGE_LOCALES_MAP == null) {\n      DateUtil.LANGUAGE_LOCALES_MAP = new Map<string, string>();\n      DateUtil.LANGUAGE_LOCALES_MAP.set('zh', 'zh-CN');\n      DateUtil.LANGUAGE_LOCALES_MAP.set('en', 'en-US');\n    }\n  }\n\n  // Get the date after localization (year-month-day)\n  public static getLocalizedDate(milliseconds: number): string {\n    let locales: string = this.getLocales();\n\n    return new Intl.DateTimeFormat(locales, this.buildDateTimeOpt('numeric', 'long', 'numeric', '', '')).format(new Date(milliseconds));\n  }\n\n  public static format(time: Date, format_s?: string): string {\n    if (!Boolean<string>(format_s).valueOf()) {\n      return time.valueOf().toString();\n    }\n    let opts: Map<string, number> = new Map<string, number>();\n    opts.set('MM', time.getMonth() + 1);\n    opts.set('dd', time.getDate());\n    opts.set('HH', time.getHours());\n    opts.set('mm', time.getMinutes());\n    opts.set('ss', time.getSeconds());\n\n    let check: RegExp = new RegExp('/(y+)/');\n    if (check.test(format_s)) {\n      format_s = format_s.replace('yyyy', time.getFullYear().toString().substr(0));\n    }\n    opts.forEach((value: number, key: string): void => {\n      if (new RegExp('(' + key + ')').test(format_s)) {\n        format_s = format_s.replace(key,\n          (key.length === 1)\n          ? value.toString()\n          : (('00' + value).substr(value.toString().length))\n        );\n      }\n    });\n    return format_s;\n  }\n\n  public static getDateTimeFormat(milliseconds: number): string {\n    return DateUtil.format(new Date(milliseconds), 'yyyy/MM/dd HH:mm:ss');\n  }\n\n  // Gets the localization date of the photo page grouping data\n  public static getGroupDataLocalizedDate(milliseconds: number): Resource {\n    let date = new Date(milliseconds);\n    let today = new Date();\n    if (date.getFullYear() === today.getFullYear() && date.getMonth() === today.getMonth()) {\n      if (date.getDate() === today.getDate()) {\n        return $r('app.string.date_today');\n      }\n      if (today.getDate() - date.getDate() === 1) {\n        return $r('app.string.date_yesterday');\n      }\n    }\n    return $r('app.string.common_place_holder', this.getLocalizedDate(milliseconds));\n  }\n\n  public static getLocalizedYear(milliseconds: number): Resource {\n    let locales: string = this.getLocales();\n\n    let yearText = new Intl.DateTimeFormat(locales, this.buildDateTimeOpt('numeric', '', '', '', '')).format(new Date(milliseconds));\n    return $r('app.string.common_place_holder', yearText.toString());\n  }\n\n  public static getLocalizedYearAndMonth(milliseconds: number): string {\n    let locales: string = this.getLocales();\n\n    return new Intl.DateTimeFormat(locales, this.buildDateTimeOpt('numeric', 'long', '', '', '')).format(new Date(milliseconds));\n  }\n\n  public static getLocalizedYearString(milliseconds: number): string {\n    let locales: string = this.getLocales();\n\n    return new Intl.DateTimeFormat(locales, this.buildDateTimeOpt('numeric', '', '', '', '')).format(new Date(milliseconds)).toString();\n  }\n\n  public static getLocalizedTime(milliseconds: number): string {\n    let locales: string = this.getLocales();\n    let is24HourClock = i18n.is24HourClock();\n    Log.info(TAG, 'get is24HourClock ' + is24HourClock);\n\n    return new Intl.DateTimeFormat(locales, this.buildDateTimeOpt('', '', '', (!Boolean<boolean>(is24HourClock).valueOf() ? '2-digit' : 'numeric'), '2-digit')).format(new Date(milliseconds));\n  }\n\n  static getLocales(): string {\n    DateUtil.initLanguageLocalesMap();\n    let systemLocale: string = i18n.getSystemLanguage().toString();\n    let language = systemLocale.split('-')[0];\n    let locales: string = this.LANGUAGE_LOCALES_MAP.get('en');\n    if (this.LANGUAGE_LOCALES_MAP.has(language)) {\n      locales = this.LANGUAGE_LOCALES_MAP.get(language);\n    }\n    return locales;\n  }\n\n  // Format duration\n  public static getFormattedDuration(milliSecond: number): string {\n    if (milliSecond == null) {\n      Log.warn(TAG, 'getFormattedDuration, input is null!');\n      return '00:00';\n    }\n    if (milliSecond <= 0) {\n      Log.warn(TAG, 'getFormattedDuration, input is negative number!');\n      return '00:00';\n    }\n    if (milliSecond < this.MILLISECONDS_PER_SECOND) {\n      return '00:01';\n    }\n    let seconds = Math.floor(milliSecond / this.MILLISECONDS_PER_SECOND);\n    let hourTime: number = Math.floor(seconds / this.SECONDS_PER_HOUR);\n    let minuteTime: number = Math.floor(Math.floor(seconds / this.SECONDS_PER_MINUTE) % this.SECONDS_PER_MINUTE);\n    let secondTime: number = Math.floor(seconds % this.SECONDS_PER_MINUTE);\n    if (hourTime > 0) {\n      return hourTime + ':' + this.checkTime(minuteTime) + ':' + this.checkTime(secondTime);\n    } else {\n      return this.checkTime(minuteTime) + ':' + this.checkTime(secondTime);\n    }\n  }\n\n  private static checkTime(time: number): string {\n    if (time < 0) {\n      Log.warn(TAG, 'checkTime, input is negative number!');\n      return '00';\n    }\n    let formatTime: string = time.toString();\n    if (time < DateUtil.FORMAT_DECIMAL) {\n      let zeroString = '0';\n      formatTime = zeroString.concat(formatTime);\n    }\n    return formatTime;\n  }\n\n  public static isTheSameDay(startTime: number, endTime: number): boolean {\n    if (startTime == null || endTime == null) {\n      return false;\n    }\n    const startTimeMs = new Date(startTime).setHours(0, 0, 0, 0);\n    const endTimeMs = new Date(endTime).setHours(0, 0, 0, 0);\n    return startTimeMs === endTimeMs ? true : false;\n  }\n\n  public static isTheSameYear(startTime: number, endTime: number): boolean {\n    if (startTime == null || endTime == null) {\n      return false;\n    }\n    const startYear = new Date(startTime).getFullYear();\n    const endYear = new Date(endTime).getFullYear();\n    return startYear === endYear ? true : false;\n  }\n\n  public static buildDateTimeOpt(year: string, month: string, day: string, hour: string, minute: string): Object {\n    let obj: Object = {\n      locale: '',\n      dateStyle: '',\n      timeStyle: '',\n      hourCycle: '',\n      timeZone: '',\n      numberingSystem: '',\n      hour12: false,\n      weekday: '',\n      era: '',\n      year: year,\n      month: month,\n      day: day,\n      hour: hour,\n      minute: minute,\n      second: '',\n      timeZoneName: '',\n      dayPeriod: '',\n      localeMatcher: '',\n      formatMatcher: '',\n    };\n    return obj;\n  }\n\n  public static formats(format?: string): string {\n    let time = new Date();\n    if (!Boolean<string>(format).valueOf()) {\n      return time.valueOf().toString();\n    }\n    let opts: Map<string, number> = new Map<string, number>();\n    opts.set('MM', time.getMonth() + 1);\n    opts.set('dd', time.getDate());\n    opts.set('HH', time.getHours());\n    opts.set('mm', time.getMinutes());\n    opts.set('ss', time.getSeconds());\n\n    if (new RegExp('/(y+)/').test(format)) {\n        format = format.replace('yyyy', time.getFullYear().toString().substr(0));\n    }\n    opts.forEach((value: number, key: string): void => {\n      if (new RegExp('(' + key + ')').test(format)) {\n        format = format.replace(key,\n          (key.length === 1)\n          ? value.toString()\n          : (('00' + value).substr(value.toString().length))\n        );\n      }\n    });\n    return format;\n  }\n\n  public static nameByDate(isReplace: Boolean, name?: string): string {\n    if (isReplace != null && isReplace === true) {\n      return (!Boolean<string>(name).valueOf()) ? null : (name.indexOf(DateUtil.NEW_NAME_EDIT) === -1 ? name.split('.')[0] + '_' + DateUtil.NEW_NAME_EDIT + DateUtil.formats() : name.split('.')[0]);\n    } else {\n      return DateUtil.NEW_NAME_IMG + DateUtil.formats('yyyyMMdd_HHmmss');\n    }\n  }\n}\n", "llm_cg": {"DateUtil.initLanguageLocalesMap()": [], "DateUtil.getLocalizedDate(number)": ["DateUtil.getLocales()", "Intl.DateTimeFormat.%AM0$DateTimeFormat(string, Object)"], "DateUtil.format(Date, string)": [], "DateUtil.getDateTimeFormat(number)": ["DateUtil.format(Date, string)"], "DateUtil.getGroupDataLocalizedDate(number)": ["DateUtil.getLocalizedDate(number)"], "DateUtil.getLocalizedYear(number)": ["DateUtil.getLocales()", "Intl.DateTimeFormat.%AM1$DateTimeFormat(string, Object)"], "DateUtil.getLocalizedYearAndMonth(number)": ["DateUtil.getLocales()", "Intl.DateTimeFormat.%AM2$DateTimeFormat(string, Object)"], "DateUtil.getLocalizedYearString(number)": ["DateUtil.getLocales()", "Intl.DateTimeFormat.%AM3$DateTimeFormat(string, Object)"], "DateUtil.getLocalizedTime(number)": ["DateUtil.getLocales()", "i18n.is24HourClock()", "Intl.DateTimeFormat.%AM4$DateTimeFormat(string, Object)"], "DateUtil.getLocales()": ["DateUtil.initLanguageLocalesMap()", "i18n.getSystemLanguage()"], "DateUtil.getFormattedDuration(number)": ["DateUtil.checkTime(number)"], "DateUtil.checkTime(number)": [], "DateUtil.isTheSameDay(number, number)": [], "DateUtil.isTheSameYear(number, number)": [], "DateUtil.buildDateTimeOpt(string, string, string, string, string)": [], "DateUtil.formats(string)": [], "DateUtil.nameByDate(Boolean, string)": ["DateUtil.formats(string)"]}, "static_cg": {"@test/56.ts: DateUtil.[static]getLocalizedDate(number)": ["@test/56.ts: DateUtil.[static]getLocales()", "@test/56.ts: DateUtil.[static]buildDateTimeOpt(string, string, string, string, string)"], "@test/56.ts: DateUtil.[static]format(Date, string)": ["@test/56.ts: DateUtil.%AM0$format([format_s], number, string)"], "@test/56.ts: DateUtil.[static]getDateTimeFormat(number)": ["@test/56.ts: DateUtil.[static]format(Date, string)"], "@test/56.ts: DateUtil.[static]getGroupDataLocalizedDate(number)": ["@test/56.ts: DateUtil.[static]getLocalizedDate(number)"], "@test/56.ts: DateUtil.[static]getLocalizedYear(number)": ["@test/56.ts: DateUtil.[static]getLocales()", "@test/56.ts: DateUtil.[static]buildDateTimeOpt(string, string, string, string, string)"], "@test/56.ts: DateUtil.[static]getLocalizedYearAndMonth(number)": ["@test/56.ts: DateUtil.[static]getLocales()", "@test/56.ts: DateUtil.[static]buildDateTimeOpt(string, string, string, string, string)"], "@test/56.ts: DateUtil.[static]getLocalizedYearString(number)": ["@test/56.ts: DateUtil.[static]getLocales()", "@test/56.ts: DateUtil.[static]buildDateTimeOpt(string, string, string, string, string)"], "@test/56.ts: DateUtil.[static]getLocalizedTime(number)": ["@test/56.ts: DateUtil.[static]getLocales()", "@test/56.ts: DateUtil.[static]buildDateTimeOpt(string, string, string, string, string)"], "@test/56.ts: DateUtil.[static]getLocales()": ["@test/56.ts: DateUtil.[static]initLanguageLocalesMap()"], "@test/56.ts: DateUtil.[static]getFormattedDuration(number)": ["@test/56.ts: DateUtil.[static]checkTime(number)"], "@test/56.ts: DateUtil.[static]formats(string)": ["@test/56.ts: DateUtil.%AM1$formats([format], number, string)"], "@test/56.ts: DateUtil.[static]nameByDate(Boolean, string)": ["@test/56.ts: DateUtil.[static]formats(string)"]}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport prompt, { ShowToastOptions } from '@system.prompt';\nimport { Log } from './Log';\nimport { screenManager } from '../common/ScreenManager';\n\nconst TAG = 'UiUtil';\nconst TOAST_DURATION = 3000;\n\nexport function showToast(message: string): void {\n  let naviBarHeight = screenManager.getNaviBarHeight()\n  Log.debug(TAG, 'showToast: ' + message);\n  let showToastOptions: ShowToastOptions = {\n    message: message,\n    duration: TOAST_DURATION,\n    bottom: (64 + naviBarHeight) + 'vp'\n  };\n  prompt.showToast(showToastOptions);\n}\n", "llm_cg": {"UiUtil.showToast(message: string)": ["screenManager.getNaviBarHeight()", "Log.debug(TAG, 'showToast: ' + message)", "prompt.showToast(showToastOptions)"]}, "static_cg": {}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport interface UserFileObserverCallback {\n  onChange(mediaType: string): void;\n}", "llm_cg": {"UserFileObserverCallback.onChange(mediaType: string)": []}, "static_cg": {}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Log } from '../utils/Log';\nimport { ViewType } from '../models/ViewType';\nimport { userFileModel } from './UserFileModel';\nimport { MediaConstants } from '../constants/MediaConstants';\nimport { selectManager } from '../common/SelectManager';\nimport photoAccessHelper from '@ohos.file.photoAccessHelper';\nimport { screenManager } from '../common/ScreenManager';\n\nconst TAG = 'UserFileDataItem';\nconst STATUS_UNDEFINED = -1;\nconst STATUS_FALSE = 0;\nconst STATUS_TRUE = 1;\n\nexport interface DateAdded {\n  dateAdded: number;\n  viewType: ViewType;\n}\n\nexport class UserFileDataItem implements DateAdded {\n  viewType: ViewType = ViewType.ITEM;\n  readonly hashIndex: number;\n  index: number;\n  dateAdded: number = 0;\n  dateModified: number;\n  dateTaken: number;\n  status: number = MediaConstants.UNDEFINED;\n  isSelect: boolean = false;\n  uri: string;\n  orientation: number;\n  duration: number;\n  size: number;\n  width: number; // width changed by orientation\n  height: number; // height changed by orientation\n  imgWidth: number; // may be smaller than width, as width is too large\n  imgHeight: number; // may be smaller than height, as height is too large\n  path: string = '';\n  title: string;\n  displayName: string;\n  mediaType: photoAccessHelper.PhotoType;\n  favouriteStatus: number = STATUS_UNDEFINED;\n  canRotate: number = STATUS_UNDEFINED;\n  selections: string = '';\n  selectionArgs: string[] = [];\n  deviceId: string = '';\n  fileAsset: photoAccessHelper.PhotoAsset = undefined;\n  defaultThumbnail: PixelMap = undefined;\n  thumbnailArray: Map<string, PixelMap> = new Map<string, PixelMap>();\n\n  constructor(selections: string, selectionArgs: string[], deviceId: string, index: number) {\n    this.selections = selections;\n    this.selectionArgs = selectionArgs;\n    this.deviceId = deviceId;\n    this.hashIndex = index;\n    this.index = index;\n  }\n\n  getHashCode(): string {\n    // 时间线界面角度，收藏状态变更，都需要刷新界面；大图浏览界面角度变更，需要刷新界面\n    return this.status === MediaConstants.UNDEFINED ?\n      '' + this.hashIndex :\n      this.uri + this.favouriteStatus + ' ' + this.orientation + ' ' + this.isSelect;\n  }\n\n  async loadFileAsset(): Promise<photoAccessHelper.PhotoAsset> {\n    return await userFileModel.getMediaItemByUri(this.uri);\n  }\n\n  isLoad(): boolean {\n    if (this.status > MediaConstants.UNDEFINED) {\n      return true;\n    }\n    return false;\n  }\n\n  async load(isForce: boolean): Promise<void> {\n    Log.info(TAG, 'load ' + this.status);\n    if (this.status > (isForce ? MediaConstants.PART_LOADED : MediaConstants.UNDEFINED)) {\n      return;\n    }\n    let fileAsset = await this.loadFileAsset();\n    if (fileAsset != null) {\n      this.update(fileAsset);\n    }\n    return;\n  }\n\n  async update(fileAsset: photoAccessHelper.PhotoAsset): Promise<void> {\n    this.fileAsset = fileAsset;\n    this.uri = fileAsset.uri;\n    this.displayName = fileAsset.displayName;\n    this.mediaType = fileAsset.photoType;\n    this.width = screenManager.getWinWidth();\n    this.height = screenManager.getWinHeight();\n    this.orientation = MediaConstants.ROTATE_NONE;\n    try {\n      this.orientation = fileAsset.get(photoAccessHelper.PhotoKeys.ORIENTATION.toString()) as number;\n      Log.info(TAG, 'orientation ' + this.orientation);\n    } catch (err) {\n      Log.error(TAG, 'get orientation ' + JSON.stringify(err));\n    }\n    try {\n      this.duration = fileAsset.get(photoAccessHelper.PhotoKeys.DURATION.toString()) as number;\n      Log.info(TAG, 'duration ' + this.duration);\n    } catch (err) {\n      Log.error(TAG, 'get duration ' + JSON.stringify(err));\n    }\n    try {\n      if (this.orientation === MediaConstants.ROTATE_ONCE || this.orientation === MediaConstants.ROTATE_THIRD) {\n        this.width = fileAsset.get(photoAccessHelper.PhotoKeys.HEIGHT.toString()) as number;\n        this.height = fileAsset.get(photoAccessHelper.PhotoKeys.WIDTH.toString()) as number;\n      } else {\n        this.width = fileAsset.get(photoAccessHelper.PhotoKeys.WIDTH.toString()) as number;\n        this.height = fileAsset.get(photoAccessHelper.PhotoKeys.HEIGHT.toString()) as number;\n      }\n      Log.info(TAG, 'width ' + this.width);\n      Log.info(TAG, 'height ' + this.height);\n    } catch (err) {\n      Log.error(TAG, 'get width height ' + JSON.stringify(err));\n    }\n    try {\n      this.title = fileAsset.get(photoAccessHelper.PhotoKeys.TITLE.toString()) as string;\n      Log.info(TAG, 'title ' + this.title);\n    } catch (err) {\n      Log.error(TAG, 'get title ' + JSON.stringify(err));\n    }\n    try {\n      this.dateAdded = fileAsset.get(photoAccessHelper.PhotoKeys.DATE_ADDED.toString()) as number * 1000;\n      this.dateModified = fileAsset.get(photoAccessHelper.PhotoKeys.DATE_MODIFIED.toString()) as number * 1000;\n      this.dateTaken = fileAsset.get(photoAccessHelper.PhotoKeys.DATE_TAKEN.toString()) as number * 1000;\n      Log.info(TAG, 'dateAdded ' + this.dateAdded);\n    } catch (err) {\n      Log.error(TAG, 'get date ' + JSON.stringify(err));\n    }\n    try {\n      this.favouriteStatus = fileAsset.get(photoAccessHelper.PhotoKeys.FAVORITE.toString()) as boolean ? STATUS_TRUE : STATUS_FALSE\n      Log.info(TAG, 'favouriteStatus ' + this.favouriteStatus);\n    } catch (err) {\n      Log.error(TAG, 'get favouriteStatus ' + JSON.stringify(err));\n    }\n    try {\n      this.size = fileAsset.get(photoAccessHelper.PhotoKeys.SIZE.toString()) as number;\n      Log.info(TAG, 'size ' + this.size);\n    } catch (err) {\n      Log.error(TAG, 'get favouriteStatus ' + JSON.stringify(err));\n    }\n    let size = { width: MediaConstants.DEFAULT_SIZE, height: MediaConstants.DEFAULT_SIZE };\n    if (fileAsset != null && this.defaultThumbnail == undefined) {\n      try {\n        this.defaultThumbnail = await this.fileAsset.getThumbnail(size);\n      } catch (err) {\n        Log.error(TAG, 'getThumbnail error: ' + JSON.stringify(err));\n      }\n    }\n    this.isSelect = selectManager.isSelect(this.uri, this.isSelect);\n    this.imgWidth = this.width;\n    this.imgHeight = this.height;\n    if (this.width > 0 && this.height > 0) {\n      this.status = MediaConstants.LOADED;\n    } else {\n      this.status = MediaConstants.PART_LOADED;\n    }\n  }\n\n  async getThumbnail(width: number, height: number): Promise<PixelMap> {\n    Log.debug(TAG, 'getThumbnail ' + this.status);\n    if (this.status !== MediaConstants.LOADED && this.status !== MediaConstants.PART_LOADED) {\n      Log.warn(TAG, 'getThumbnail fail as status: ' + this.status);\n      return undefined;\n    }\n    if (width === MediaConstants.DEFAULT_SIZE && height === MediaConstants.DEFAULT_SIZE) {\n      return this.defaultThumbnail;\n    }\n    let newThumbnail: PixelMap = undefined;\n    let size = { width: width, height: height };\n    let cacheThumbnail = this.thumbnailArray.get(width.toString() + height.toString());\n    if (cacheThumbnail != null) {\n      return cacheThumbnail;\n    }\n    if (this.fileAsset != undefined) {\n      try {\n        newThumbnail = await this.fileAsset.getThumbnail(size);\n        this.thumbnailArray.set(width.toString() + height.toString(), newThumbnail);\n      } catch (err) {\n        Log.error(TAG, 'getThumbnail error: ' + JSON.stringify(err));\n      }\n    }\n    return newThumbnail;\n  }\n\n  getAlt(): Resource {\n    if (this.mediaType === photoAccessHelper.PhotoType.VIDEO) {\n      return $r('app.media.alt_video_placeholder');\n    } else {\n      return $r('app.media.alt_placeholder');\n    }\n  }\n\n  setSelect(isSelect: boolean): void {\n    this.isSelect = isSelect;\n    selectManager.setSelect(this.uri, this.isSelect);\n  }\n\n  async onDelete(): Promise<boolean> {\n    try {\n      await userFileModel.deleteOne(this.uri);\n      selectManager.deleteSelect(this.uri);\n      this.status = MediaConstants.TRASHED;\n      return true;\n    } catch (err) {\n      Log.error(TAG, 'onDelete ' + this.index + ' error: ' + JSON.stringify(err));\n      return false;\n    }\n  }\n\n  async addToAlbum(albumUri:string): Promise<boolean> {\n    try {\n      await userFileModel.addPhotoToAlbumByUserFileMgr(albumUri, this.uri);\n      selectManager.deleteSelect(this.uri);\n      this.status = MediaConstants.TRASHED;\n      return true;\n    } catch (err) {\n      Log.error(TAG, 'addToAlbum ' + this.index + ' error: ' + JSON.stringify(err));\n      return false;\n    }\n  }\n\n  isDeleted(): boolean {\n    return this.status === MediaConstants.TRASHED;\n  }\n\n  async isFavor(): Promise<boolean> {\n    if (this.favouriteStatus === STATUS_UNDEFINED) {\n      let fileAsset = await this.loadFileAsset();\n      try {\n        this.favouriteStatus = (fileAsset.get(photoAccessHelper.PhotoKeys.FAVORITE.toString()) as boolean) ? STATUS_TRUE : STATUS_FALSE;\n      } catch (err) {\n        Log.error(TAG, 'isFavor error: ' + JSON.stringify(err));\n      }\n    }\n    return this.favouriteStatus === STATUS_TRUE;\n  }\n\n  async setFavor(): Promise<boolean> {\n    let status = !(await this.isFavor());\n    try {\n      let fileAsset = await this.loadFileAsset();\n      await fileAsset.setFavorite(status);\n      this.favouriteStatus = status ? STATUS_TRUE : STATUS_FALSE;\n      return true;\n    } catch (err) {\n      return false;\n    }\n  }\n\n  async setName(name: string): Promise<void> {\n    let fileAsset = await this.loadFileAsset();\n    let displayName = fileAsset.displayName;\n    let index = displayName.lastIndexOf('.');\n    displayName = name + displayName.slice(index);\n    this.displayName = displayName;\n    this.title = name;\n    try {\n      fileAsset.set(photoAccessHelper.PhotoKeys.TITLE.toString(), name);\n      await fileAsset.commitModify();\n    } catch (err) {\n      Log.error(TAG, 'setName error: ' + JSON.stringify(err));\n    }\n  }\n}\n", "llm_cg": {"UserFileDataItem.constructor(string, string[], string, number)": [], "UserFileDataItem.getHashCode()": [], "UserFileDataItem.loadFileAsset()": ["UserFileModel.getMediaItemByUri(string)"], "UserFileDataItem.isLoad()": [], "UserFileDataItem.load(boolean)": ["UserFileDataItem.loadFileAsset()", "UserFileDataItem.update(photoAccessHelper.PhotoAsset)"], "UserFileDataItem.update(photoAccessHelper.PhotoAsset)": ["ScreenManager.getWinWidth()", "ScreenManager.getWinHeight()", "SelectManager.isSelect(string, boolean)", "photoAccessHelper.PhotoAsset.get(string)", "photoAccessHelper.PhotoAsset.getThumbnail(object)"], "UserFileDataItem.getThumbnail(number, number)": ["photoAccessHelper.PhotoAsset.getThumbnail(object)"], "UserFileDataItem.getAlt()": [], "UserFileDataItem.setSelect(boolean)": ["SelectManager.setSelect(string, boolean)"], "UserFileDataItem.onDelete()": ["UserFileModel.deleteOne(string)", "SelectManager.deleteSelect(string)"], "UserFileDataItem.addToAlbum(string)": ["UserFileModel.addPhotoToAlbumByUserFileMgr(string, string)", "SelectManager.deleteSelect(string)"], "UserFileDataItem.isDeleted()": [], "UserFileDataItem.isFavor()": ["UserFileDataItem.loadFileAsset()", "photoAccessHelper.PhotoAsset.get(string)"], "UserFileDataItem.setFavor()": ["UserFileDataItem.isFavor()", "UserFileDataItem.loadFileAsset()", "photoAccessHelper.PhotoAsset.setFavorite(boolean)"], "UserFileDataItem.setName(string)": ["UserFileDataItem.loadFileAsset()", "photoAccessHelper.PhotoAsset.set(string, string)", "photoAccessHelper.PhotoAsset.commitModify()"]}, "static_cg": {"@test/59.ts: UserFileDataItem.load(boolean)": ["@test/59.ts: UserFileDataItem.loadFileAsset()", "@test/59.ts: UserFileDataItem.update(photoAccessHelper.PhotoAsset)"], "@test/59.ts: UserFileDataItem.isFavor()": ["@test/59.ts: UserFileDataItem.loadFileAsset()"], "@test/59.ts: UserFileDataItem.setFavor()": ["@test/59.ts: UserFileDataItem.isFavor()", "@test/59.ts: UserFileDataItem.loadFileAsset()"], "@test/59.ts: UserFileDataItem.setName(string)": ["@test/59.ts: UserFileDataItem.loadFileAsset()"]}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { UserFileDataItem } from './UserFileDataItem';\nimport { stashOrGetObject } from '../utils/SingleInstanceUtils';\n\nconst TAG = 'UserFileDataItemCache';\n\nclass UserFileDataItemCache {\n    private userFileDataItemMap = new Map<string, UserFileDataItem>();\n\n    hasKey(key: string): boolean {\n        return this.userFileDataItemMap.has(key);\n    }\n\n    deleteKey(key: string): boolean {\n        return this.userFileDataItemMap.delete(key);\n    }\n\n    set(key: string, value: UserFileDataItem): void {\n        this.userFileDataItemMap.set(key, value);\n    }\n\n    get(key: string): UserFileDataItem {\n        return this.userFileDataItemMap.get(key);\n    }\n\n    clearAll(): void {\n        this.userFileDataItemMap.clear();\n    }\n}\n\nexport let userFileDataItemCache: UserFileDataItemCache = stashOrGetObject<UserFileDataItemCache>(new UserFileDataItemCache(), TAG);\n", "llm_cg": {"UserFileDataItemCache.hasKey(key: string)": [], "UserFileDataItemCache.deleteKey(key: string)": [], "UserFileDataItemCache.set(key: string, value: UserFileDataItem)": [], "UserFileDataItemCache.get(key: string)": [], "UserFileDataItemCache.clearAll()": []}, "static_cg": {"@test/60.ts: UserFileDataItemCache.set(string, UserFileDataItem)": ["@test/60.ts: UserFileDataItemCache.set(string, UserFileDataItem)"], "@test/60.ts: UserFileDataItemCache.get(string)": ["@test/60.ts: UserFileDataItemCache.get(string)"]}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { stashOrGetObject } from '../utils/SingleInstanceUtils';\nimport { Log } from '../utils/Log';\nimport { MediaConstants } from '../constants/MediaConstants';\nimport { userFileModel } from './UserFileModel';\nimport { UserFileObserverCallback } from './UserFileObserverCallback';\nimport photoAccessHelper from '@ohos.file.photoAccessHelper';\n\nconst TAG = 'UserFileObserver';\n\nclass UserFileObserver {\n  callbacks: UserFileObserverCallback[] = [];\n  private static readonly OBSERVER_IMAGE_CHANGE: string = 'imageChange';\n  private static readonly OBSERVER_VIDEO_CHANGE: string = 'videoChange';\n  private static readonly OBSERVER_DEVICE_CHANGE: string = 'deviceChange';\n  private static readonly OBSERVER_ALBUM_CHANGE: string = 'albumChange';\n  private static readonly OBSERVER_REMOTE_FILE_CHANGE: string = 'remoteFileChange';\n\n  registerObserver(callback: UserFileObserverCallback | null): void {\n    Log.info(TAG, 'registerObserver');\n    if (callback == null) {\n      Log.warn(TAG, 'registerObserver with empty callback');\n      return;\n    }\n\n    if (this.callbacks.indexOf(callback) < 0) {\n      this.callbacks.push(callback);\n    } else {\n      Log.info(TAG, 'registerObserver already exist');\n      return;\n    }\n\n    if (this.callbacks.length === 1) {\n      Log.info(TAG, 'registerObserver register media');\n      try {\n        userFileModel.getUserFileMgr().registerChange(photoAccessHelper.DefaultChangeUri.DEFAULT_PHOTO_URI, true, (): void => {\n          Log.info(TAG, 'registerObserver on image');\n          this.sendNotify(MediaConstants.MEDIA_TYPE_IMAGE);\n        });\n        userFileModel.getUserFileMgr().registerChange(photoAccessHelper.DefaultChangeUri.DEFAULT_ALBUM_URI, true, (): void => {\n          Log.info(TAG, 'registerObserver on album');\n          this.sendNotify(MediaConstants.MEDIA_TYPE_ALBUM);\n        });\n      } catch (err) {\n        Log.error(TAG, 'registerObserver faild, err: ' + JSON.stringify(err));\n      }\n    }\n  }\n\n  sendNotify(mediaType: string): void {\n    Log.info(TAG, 'registerObserver sendNotify size: ' + this.callbacks.length);\n    for (let callback of this.callbacks) {\n      callback.onChange(mediaType);\n    }\n  }\n\n  unregisterObserver(callback: UserFileObserverCallback | null): void {\n    Log.info(TAG, 'unregisterObserver');\n    const pos = this.callbacks.indexOf(callback);\n    if (pos >= 0) {\n      this.callbacks.splice(pos, 1);\n    }\n  }\n}\n\nexport let userFileObserver: UserFileObserver = stashOrGetObject<UserFileObserver>(new UserFileObserver(), TAG);\n", "llm_cg": {"UserFileObserver.registerObserver(UserFileObserverCallback | null)": ["UserFileObserver.%AM0$sendNotify(string)", "userFileModel.getUserFileMgr().registerChange(photoAccessHelper.DefaultChangeUri.DEFAULT_PHOTO_URI, boolean, Function)", "userFileModel.getUserFileMgr().registerChange(photoAccessHelper.DefaultChangeUri.DEFAULT_ALBUM_URI, boolean, Function)"], "UserFileObserver.sendNotify(string)": ["UserFileObserverCallback.onChange(string)"], "userFileModel.getUserFileMgr().registerChange(photoAccessHelper.DefaultChangeUri.DEFAULT_PHOTO_URI, boolean, Function)": ["UserFileObserver.%AM0$sendNotify(string)"], "userFileModel.getUserFileMgr().registerChange(photoAccessHelper.DefaultChangeUri.DEFAULT_ALBUM_URI, boolean, Function)": ["UserFileObserver.%AM0$sendNotify(string)"]}, "static_cg": {"@test/61.ts: UserFileObserver.registerObserver(UserFileObserverCallback|null)": ["@test/61.ts: UserFileObserver.%AM0$registerObserver()", "@test/61.ts: UserFileObserver.%AM1$registerObserver()"], "@test/61.ts: UserFileObserver.%AM0$registerObserver()": ["@test/61.ts: UserFileObserver.sendNotify(string)"], "@test/61.ts: UserFileObserver.%AM1$registerObserver()": ["@test/61.ts: UserFileObserver.sendNotify(string)"]}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { TrashUserFileDataItem } from './TrashUserFileDataItem';\nimport { stashOrGetObject } from '../utils/SingleInstanceUtils';\n\nconst TAG = 'TrashUserFileDataItemCache';\n\nclass TrashUserFileDataItemCache {\n  private trashMediaDataItemMap = new Map<string, TrashUserFileDataItem>();\n\n  hasKey(key: string): boolean {\n    return this.trashMediaDataItemMap.has(key);\n  }\n\n  deleteKey(key: string): boolean {\n    return this.trashMediaDataItemMap.delete(key);\n  }\n\n  set(key: string, value: TrashUserFileDataItem): void {\n    this.trashMediaDataItemMap.set(key, value);\n  }\n\n  get(key: string): TrashUserFileDataItem {\n    return this.trashMediaDataItemMap.get(key);\n  }\n\n  clearAll(): void {\n    this.trashMediaDataItemMap.clear();\n  }\n}\n\nexport let trashUserFileDataItemCache: TrashUserFileDataItemCache = stashOrGetObject<TrashUserFileDataItemCache>(new TrashUserFileDataItemCache(), TAG);\n", "llm_cg": {"TrashUserFileDataItemCache.hasKey(key)": [], "TrashUserFileDataItemCache.deleteKey(key)": [], "TrashUserFileDataItemCache.set(key, value)": [], "TrashUserFileDataItemCache.get(key)": [], "TrashUserFileDataItemCache.clearAll()": []}, "static_cg": {"@test/62.ts: TrashUserFileDataItemCache.set(string, TrashUserFileDataItem)": ["@test/62.ts: TrashUserFileDataItemCache.set(string, TrashUserFileDataItem)"], "@test/62.ts: TrashUserFileDataItemCache.get(string)": ["@test/62.ts: TrashUserFileDataItemCache.get(string)"]}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport photoAccessHelper from '@ohos.file.photoAccessHelper';\nimport { userFileModel } from './UserFileModel';\nimport { MediaConstants } from '../constants/MediaConstants';\nimport { UserFileDataItem } from './UserFileDataItem';\n\nexport class FavorUserFileDataItem extends UserFileDataItem {\n  constructor(selections: string, selectionArgs: string[], index: number) {\n    super(selections, selectionArgs, '', index);\n  }\n\n  async loadFileAsset(): Promise<photoAccessHelper.PhotoAsset> {\n    return await userFileModel.getMediaItemByUri(this.uri);\n  }\n\n  async setFavor(): Promise<boolean> {\n    let isSuccess: boolean = await super.setFavor();\n    let isFavor: boolean = await super.isFavor();\n    this.status = isFavor ? this.status : MediaConstants.TRASHED;\n    return isSuccess;\n  }\n}\n", "llm_cg": {"FavorUserFileDataItem.loadFileAsset()": ["userFileModel.getMediaItemByUri(string)"], "FavorUserFileDataItem.setFavor()": ["FavorUserFileDataItem.%AM0$setFavor()", "FavorUserFileDataItem.%AM1$isFavor()"]}, "static_cg": {}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Log } from '../utils/Log';\nimport { MediaConstants } from '../constants/MediaConstants';\nimport { getResourceString } from '../utils/ResourceUtils';\n\nconst TAG = 'UserFileDataHelper';\n\nexport class Rotatable {\n  rotatable: boolean;\n  orientation: number;\n}\n\nfunction getPropertyValidOrientation(orientation: number): string {\n  Log.info(TAG, 'getPropertyValidOrientation ' + orientation);\n  if (orientation === MediaConstants.ROTATE_NONE) {\n    return '1';\n  } else if (orientation === MediaConstants.ROTATE_THIRD) {\n    return '8';\n  } else if (orientation === MediaConstants.ROTATE_TWICE) {\n    return '3';\n  } else if (orientation === MediaConstants.ROTATE_ONCE) {\n    return '6';\n  }\n  return '';\n}\n\nexport async function getAlbumDisplayName(name: string): Promise<string> {\n  if (name === MediaConstants.ALBUM_ID_ALL) {\n    return await getResourceString($r('app.string.album_all'));\n  } else if (name === MediaConstants.ALBUM_ID_VIDEO) {\n    return await getResourceString($r('app.string.album_video'));\n  } else if (name === MediaConstants.ALBUM_ID_RECYCLE) {\n    return await getResourceString($r('app.string.album_recycle'));\n  } else if (name === MediaConstants.ALBUM_ID_CAMERA) {\n    return await getResourceString($r('app.string.album_camera'));\n  } else if (name === MediaConstants.ALBUM_ID_FAVOR) {\n    return await getResourceString($r('app.string.album_favor'));\n  } else if (name === MediaConstants.ALBUM_ID_REMOTE) {\n    return await getResourceString($r('app.string.album_remote_device'));\n  } else if (name === MediaConstants.ALBUM_ID_SNAPSHOT) {\n    return await getResourceString($r('app.string.album_screen_shot'));\n  } else if (name === MediaConstants.ALBUM_ID_MOVING_PHOTO) {\n    return await getResourceString($r('app.string.album_moving_photo'));\n  }\n  return null;\n}\n\nexport async function getSystemAlbumDisplayName(): Promise<string[]> {\n  let albumNames = [];\n  albumNames.push(await getResourceString($r('app.string.album_all')));\n  albumNames.push(await getResourceString($r('app.string.album_video')));\n  albumNames.push(await getResourceString($r('app.string.album_recycle')));\n  albumNames.push(await getResourceString($r('app.string.album_camera')));\n  albumNames.push(await getResourceString($r('app.string.album_favor')));\n  albumNames.push(await getResourceString($r('app.string.album_remote_device')));\n  albumNames.push(await getResourceString($r('app.string.album_screen_shot')));\n  albumNames.push(await getResourceString($r('app.string.album_moving_photo')));\n  return albumNames;\n}", "llm_cg": {"getPropertyValidOrientation(orientation: number)": ["Log.info(TAG, 'getPropertyValidOrientation ' + orientation)"], "getAlbumDisplayName(name: string)": ["getResourceString($r('app.string.album_all'))", "getResourceString($r('app.string.album_video'))", "getResourceString($r('app.string.album_recycle'))", "getResourceString($r('app.string.album_camera'))", "getResourceString($r('app.string.album_favor'))", "getResourceString($r('app.string.album_remote_device'))", "getResourceString($r('app.string.album_screen_shot'))", "getResourceString($r('app.string.album_moving_photo'))"], "getSystemAlbumDisplayName()": ["getResourceString($r('app.string.album_all'))", "getResourceString($r('app.string.album_video'))", "getResourceString($r('app.string.album_recycle'))", "getResourceString($r('app.string.album_camera'))", "getResourceString($r('app.string.album_favor'))", "getResourceString($r('app.string.album_remote_device'))", "getResourceString($r('app.string.album_screen_shot'))", "getResourceString($r('app.string.album_moving_photo'))"]}, "static_cg": {}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport photoAccessHelper from '@ohos.file.photoAccessHelper';\nimport { MediaConstants } from '../constants/MediaConstants';\nimport { UserFileDataItem } from './UserFileDataItem';\nimport { screenManager } from '../common/ScreenManager';\n\nexport class InnerUserFileDataItem extends UserFileDataItem {\n  constructor(uri: string, index: number) {\n    super('', [] as string[], '', index);\n    this.mediaType = photoAccessHelper.PhotoType.IMAGE;\n    this.uri = uri;\n    this.size = 256;\n    this.orientation = 0;\n  }\n\n  async load(isForce: boolean): Promise<void> {\n    if (this.status > (isForce ? MediaConstants.PART_LOADED : MediaConstants.UNDEFINED)) {\n      return;\n    }\n    this.width = vp2px(screenManager.getWinWidth());\n    this.height = vp2px(screenManager.getWinHeight());\n    if (this.width === 0 || this.height === 0) {\n      this.status = MediaConstants.PART_LOADED;\n    } else {\n      this.status = MediaConstants.LOADED;\n    }\n  }\n\n  async isFavor(): Promise<boolean> {\n    return false;\n  }\n}", "llm_cg": {"InnerUserFileDataItem.load(isForce: boolean)": ["screenManager.getWinWidth()", "screenManager.getWinHeight()", "vp2px(unknown)", "vp2px(unknown)"]}, "static_cg": {}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport photoAccessHelper from '@ohos.file.photoAccessHelper';\nimport { selectManager } from '../common/SelectManager';\nimport { userFileModel } from './UserFileModel';\nimport { Log } from '../utils/Log';\nimport { MediaConstants } from '../constants/MediaConstants';\nimport { UserFileDataItem } from './UserFileDataItem';\n\nconst TAG = 'TrashUserFileDataItem';\n\nexport class TrashUserFileDataItem extends UserFileDataItem {\n  constructor(selections: string, selectionArgs: string[], index: number) {\n    super(selections, selectionArgs, '', index);\n    this.setSelect(false);\n  }\n\n  async loadFileAsset(): Promise<photoAccessHelper.PhotoAsset> {\n    Log.debug(TAG, 'loadFileAsset' + this.uri);\n    return await userFileModel.getMediaItemByUriFromTrash(this.uri);\n  }\n\n  async onRecover(): Promise<boolean> {\n    try {\n      let fileAsset = await this.loadFileAsset();\n      if (fileAsset == null) {\n        Log.error(TAG, 'onRecover error: cant find file');\n        return false;\n      }\n      await userFileModel.recover(fileAsset);\n      selectManager.deleteSelect(this.uri);\n      this.status = MediaConstants.TRASHED;\n      return true;\n    } catch (err) {\n      Log.error(TAG, 'onRecover error: ' + JSON.stringify(err));\n      return false;\n    }\n  }\n\n  async onDelete(): Promise<boolean> {\n    try {\n      let fileAsset = await this.loadFileAsset();\n      await userFileModel.permanentDelete(fileAsset);\n      selectManager.deleteSelect(this.uri);\n      this.status = MediaConstants.TRASHED;\n      return true;\n    } catch (err) {\n      Log.error(TAG, 'onDelete error: ' + JSON.stringify(err));\n      return false;\n    }\n  }\n}\n", "llm_cg": {"TrashUserFileDataItem.loadFileAsset()": ["Log.debug(TAG, 'loadFileAsset' + this.uri)", "userFileModel.getMediaItemByUriFromTrash(this.uri)"], "TrashUserFileDataItem.onRecover()": ["TrashUserFileDataItem.loadFileAsset()", "Log.error(TAG, 'onRecover error: cant find file')", "userFileModel.recover(fileAsset)", "selectManager.deleteSelect(this.uri)", "Log.error(TAG, 'onRecover error: ' + JSON.stringify(err))"], "TrashUserFileDataItem.onDelete()": ["TrashUserFileDataItem.loadFileAsset()", "userFileModel.permanentDelete(fileAsset)", "selectManager.deleteSelect(this.uri)", "Log.error(TAG, 'onDelete error: ' + JSON.stringify(err))"]}, "static_cg": {"@test/66.ts: TrashUserFileDataItem.onRecover()": ["@test/66.ts: TrashUserFileDataItem.loadFileAsset()"], "@test/66.ts: TrashUserFileDataItem.onDelete()": ["@test/66.ts: TrashUserFileDataItem.loadFileAsset()"]}}
{"source_code": "// @ts-nocheck\n/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport fileIO from '@ohos.fileio';\nimport { stashOrGetObject } from '../utils/SingleInstanceUtils';\nimport { Log } from '../utils/Log';\nimport { hiSysEventDataQueryTimedOut } from '../utils/hisysEventUtil';\nimport photoAccessHelper from '@ohos.file.photoAccessHelper';\nimport dataSharePredicates from '@ohos.data.dataSharePredicates';\nimport { MediaConstants } from '../constants/MediaConstants'\nimport { getSystemAlbumDisplayName } from './UserFileDataHelper';\nimport { SimpleAlbumDataItem } from '../common/SimpleAlbumDataItem';\n\nconst TAG = 'UserFileModel';\n\nexport class UserFileModelItem {\n  fileAsset: photoAccessHelper.PhotoAsset;\n  counts: number;\n}\n\nclass UserFileModel {\n  private userFileMgr: photoAccessHelper.PhotoAccessHelper = undefined;\n\n  constructor() {\n  }\n\n  onCreate(context): void {\n    if (this.userFileMgr == undefined) {\n      this.userFileMgr = photoAccessHelper.getPhotoAccessHelper(context);\n    }\n  }\n\n  getUserFileMgr(): photoAccessHelper.PhotoAccessHelper {\n    return this.userFileMgr;\n  }\n\n  async createOne(displayName: string, albumUri: string): Promise<photoAccessHelper.PhotoAsset> {\n    Log.info(TAG, 'createOne displayName:' + displayName + ' albumUri: ' + albumUri);\n    let fileAsset = await this.userFileMgr.createAsset(displayName, albumUri);\n    let album = await this.getUserAlbumItemByUri(albumUri);\n    await album.addAssets([fileAsset]);\n    return fileAsset;\n  }\n\n  async getUserAlbumItemByUri(uri: string): Promise<photoAccessHelper.Album> {\n    let fetchResult: photoAccessHelper.FetchResult<photoAccessHelper.Album> = null;\n    let album: photoAccessHelper.Album = null;\n    try {\n      Log.info(TAG, 'getUserAlbumItemByUri');\n      let predicates = new dataSharePredicates.DataSharePredicates();\n      predicates.equalTo(photoAccessHelper.AlbumKeys.URI, uri);\n      let fetchOptions = {\n        fetchColumns: MediaConstants.EMPTY_FETCH_COLUMNS,\n        predicates: predicates\n      };\n      fetchResult = await this.userFileMgr.getAlbums(photoAccessHelper.AlbumType.USER, photoAccessHelper.AlbumSubtype.USER_GENERIC, fetchOptions);\n      Log.info(TAG, 'get Album fetchResult, count: ' + fetchResult.getCount());\n      if (fetchResult.getCount() > 0) {\n        album = fetchResult.getFirstObject();\n      }\n    } catch (err) {\n      Log.error(TAG, 'get Album fetchResult failed with err: ' + err);\n    } finally {\n      if (fetchResult != null) {\n        fetchResult.close();\n      }\n    }\n    return album;\n  }\n\n  async copyOne(source: photoAccessHelper.PhotoAsset, target: photoAccessHelper.PhotoAsset): Promise<void> {\n    Log.info(TAG, 'copy start: src:' + source.uri + ' target: ' + target.uri);\n    let fd: Number = await this.openAsset('R', source);\n    if (fd <= 0) {\n      throw new Error('fd is invalid');\n    }\n\n    let targetFd: Number = await this.openAsset('RW', target);\n    if (targetFd <= 0) {\n      throw new Error('targetFd is invalid');\n    }\n\n    await fileIO.copyFile(fd, targetFd);\n\n    await this.closeAsset(fd, source);\n    await this.closeAsset(targetFd, target);\n\n    Log.debug(TAG, 'copy end');\n  }\n\n  async deleteOne(uri: string): Promise<void> {\n    Log.debug(TAG, 'deleteAsset uri: ' + uri);\n    try {\n      await this.userFileMgr.deleteAssets([uri]);\n    } catch (err) {\n      Log.error(TAG, 'deleteOne with error: ' + err);\n    }\n  }\n\n  async recover(fileAsset: photoAccessHelper.PhotoAsset): Promise<void> {\n    let albumFetchResult = null;\n    try {\n      Log.debug(TAG, 'recoverPhotoAssetsDemoPromise:' + fileAsset.displayName);\n      albumFetchResult = await this.userFileMgr.getAlbums(photoAccessHelper.AlbumType.SYSTEM, photoAccessHelper.AlbumSubtype.TRASH);\n      let album = await albumFetchResult.getFirstObject();\n      Log.debug(TAG, 'album  get');\n      album.recoverAssets([fileAsset]).then(() => {\n        Log.debug(TAG, 'album recoverPhotoAssets successfully');\n      }).catch((err) => {\n        Log.info(TAG, 'album recoverPhotoAssets failed with error: ' + err);\n      });\n    } catch (err) {\n      Log.error(TAG, 'recoverPhotoAssetsDemoPromise failed with error: ' + err);\n    } finally {\n      if (albumFetchResult != null) {\n        albumFetchResult.close();\n      }\n    }\n  }\n\n  async permanentDelete(fileAsset: photoAccessHelper.PhotoAsset): Promise<void> {\n    let albumFetchResult = null;\n    try {\n      Log.debug(TAG, 'permanentDelete');\n      albumFetchResult = await this.userFileMgr.getAlbums(photoAccessHelper.AlbumType.SYSTEM, photoAccessHelper.AlbumSubtype.TRASH);\n      let album = await albumFetchResult.getFirstObject();\n      album.deleteAssets([fileAsset]).then(() => {\n        Log.debug('album deletePhotoAssets successfully');\n      }).catch((err) => {\n        Log.error(TAG, 'album deletePhotoAssets failed with error: ' + err);\n      });\n    } catch (err) {\n      Log.error(TAG, 'permanentDelete failed with error: ' + err);\n    } finally {\n      if (albumFetchResult != null) {\n        albumFetchResult.close();\n      }\n    }\n  }\n\n  async createAlbum(albumName: string): Promise<SimpleAlbumDataItem> {\n    let newAlbum: SimpleAlbumDataItem = undefined;\n    try {\n      let album = await this.userFileMgr.createAlbum(albumName);\n      newAlbum = new SimpleAlbumDataItem(MediaConstants.ALBUM_ID_USER, albumName, album.albumUri,\n        '', '', MediaConstants.ALBUM_TYPE_USER, MediaConstants.ALBUM_SUBTYPE_USER_GENERIC);\n    } catch (err) {\n      Log.error(TAG, 'createAlbum failed with error: ' + err);\n    }\n    return newAlbum;\n  }\n\n  async deleteAlbum(albumName: string): Promise<void> {\n    let fetchResult: photoAccessHelper.FetchResult<photoAccessHelper.Album> = null;\n    try {\n      let predicates = new dataSharePredicates.DataSharePredicates();\n      predicates.equalTo(photoAccessHelper.AlbumKeys.ALBUM_NAME, albumName);\n      let fetchOptions = {\n        fetchColumns: MediaConstants.EMPTY_FETCH_COLUMNS,\n        predicates: predicates\n      };\n      fetchResult = await this.userFileMgr.getAlbums(photoAccessHelper.AlbumType.USER, photoAccessHelper.AlbumSubtype.USER_GENERIC, fetchOptions);\n      for (let i = 0; i < fetchResult.getCount(); i++) {\n        let albumAsset = await fetchResult.getObjectByPosition(i);\n        Log.info(TAG, 'deleteAlbum albumUri' + albumAsset.albumUri);\n        Log.info(TAG, 'deleteAlbum albumName' + albumAsset.albumName);\n        this.userFileMgr.deleteAlbums([albumAsset]).then(() => {\n          Log.info(TAG, 'deletePhotoAlbumsPromise successfully');\n        }).catch((err) => {\n          Log.error(TAG, 'deletePhotoAlbumsPromise failed with err: ' + err);\n        });\n      }\n    } catch (err) {\n      Log.error(TAG, 'deletePhotoAlbumsPromise failed with error: ' + err);\n    } finally {\n      if (fetchResult != null) {\n        fetchResult.close();\n      }\n    }\n  }\n\n  async deleteAll(fetchOption: photoAccessHelper.FetchOptions): Promise<void> {\n    Log.info(TAG, 'deleteAll');\n    let fetchFileResult: photoAccessHelper.FetchResult = null;\n    try {\n      fetchFileResult = await this.userFileMgr.getAssets(fetchOption);\n      Log.debug(TAG, 'deleteAll getPhotoAssets');\n      let deleteAllGetAllObject = hiSysEventDataQueryTimedOut('deleteAllGetAllObject');\n      let fileAssets: photoAccessHelper.PhotoAsset[] = await fetchFileResult.getAllObject();\n      clearTimeout(deleteAllGetAllObject);\n      for (let i = 0;i < fileAssets.length; i++) {\n        await this.deleteOne(fileAssets[i].uri);\n      }\n      Log.debug(TAG, 'deleteAll getFirstObject');\n    } catch (err) {\n      Log.error(TAG, 'deleteAll error:' + JSON.stringify(err));\n    } finally {\n      if (fetchFileResult != null) {\n        fetchFileResult.close();\n      }\n    }\n    Log.debug(TAG, 'deleteAll finish');\n  }\n\n  async getAllMediaItems(): Promise<photoAccessHelper.PhotoAsset[]> {\n    let fileAssets: photoAccessHelper.PhotoAsset[] = [];\n    let photoFetchResult: photoAccessHelper.FetchResult<photoAccessHelper.PhotoAsset> = null;\n    try {\n      let predicates = new dataSharePredicates.DataSharePredicates();\n      predicates.orderByDesc(photoAccessHelper.PhotoKeys.DATE_ADDED);\n      let emptyFetchOption = {\n        fetchColumns: MediaConstants.FILE_ASSET_FETCH_COLUMNS,\n        predicates: predicates\n      };\n      photoFetchResult = await this.userFileMgr.getAssets(emptyFetchOption);\n      Log.info(TAG, 'getAllMediaItems count: ' + photoFetchResult.getCount());\n      for (let i = 0;i < photoFetchResult.getCount(); i++) {\n        fileAssets.push(await photoFetchResult.getObjectByPosition(i));\n      }\n    } catch (err) {\n      Log.error(TAG, 'getAllMediaItems failed with err: ' + err);\n    } finally {\n      if (photoFetchResult != null) {\n        photoFetchResult.close();\n      }\n    }\n    return fileAssets;\n  }\n\n  async getAllMovingPhotoItems(): Promise<photoAccessHelper.PhotoAsset[]> {\n    let fileAssets: photoAccessHelper.PhotoAsset[] = [];\n    let photoFetchResult: photoAccessHelper.FetchResult<photoAccessHelper.PhotoAsset> = null;\n    try {\n      let predicates = new dataSharePredicates.DataSharePredicates();\n      predicates.equalTo(MediaConstants.PHOTO_SUBTYPE, MediaConstants.MOVING_PHOTO);\n      predicates.orderByDesc(photoAccessHelper.PhotoKeys.DATE_ADDED);\n      let fetchOptions: photoAccessHelper.FetchOptions = {\n        fetchColumns: MediaConstants.FILE_ASSET_FETCH_COLUMNS,\n        predicates: predicates\n      };\n      photoFetchResult = await this.userFileMgr.getAssets(fetchOptions);\n      Log.info(TAG, 'getAllMovingPhotoItems count: ' + photoFetchResult.getCount());\n      for (let i = 0; i < photoFetchResult.getCount(); i++) {\n        fileAssets.push(await photoFetchResult.getObjectByPosition(i));\n      }\n    } catch (err) {\n      Log.error(TAG, 'getAllMovingPhotoItems failed with err: ' + err);\n    } finally {\n      if (photoFetchResult != null) {\n        photoFetchResult.close();\n      }\n    }\n    return fileAssets;\n  }\n\n  async getAllMediaItemsByType(type: number, subType: number, albumFetchOption, fileFetchOption): Promise<photoAccessHelper.PhotoAsset[]> {\n    let fileAssets: photoAccessHelper.PhotoAsset[] = [];\n    let fetchResult: photoAccessHelper.FetchResult<photoAccessHelper.Album> = null;\n    try {\n      Log.info(TAG, 'getAllMediaItemsByUserFile');\n      Log.info(TAG, 'type:' + type);\n      Log.info(TAG, 'subType:' + subType);\n      if (type === photoAccessHelper.AlbumType.USER && albumFetchOption != null) {\n        Log.info(TAG, 'albumFetchOption ！= null');\n        fetchResult = await this.userFileMgr.getAlbums(type, subType, albumFetchOption);\n      } else {\n        fetchResult = await this.userFileMgr.getAlbums(type, subType);\n      }\n      Log.info(TAG, 'get Album fetchResult, count: ' + fetchResult.getCount());\n      for (let i = 0; i < fetchResult.getCount(); i++) {\n        let albumAsset: photoAccessHelper.Album = await fetchResult.getObjectByPosition(i);\n        let photoFetchResult: photoAccessHelper.FetchResult<photoAccessHelper.PhotoAsset> = null;\n        try {\n          photoFetchResult = await albumAsset.getAssets(fileFetchOption);\n          for (let i = 0; i < photoFetchResult.getCount(); i++) {\n            let photoAsset = await photoFetchResult.getObjectByPosition(i);\n            fileAssets.push(photoAsset);\n            Log.info(TAG, 'getPhotoAssets successfully, file displayName: ' + photoAsset.displayName);\n          }\n        } catch (err) {\n          Log.info(TAG, 'get Album getPhotoAssets failed with err: ' + err);\n        } finally {\n          if (photoFetchResult != null) {\n            photoFetchResult.close();\n          }\n        }\n      }\n    } catch (err) {\n      Log.error(TAG, 'get Album fetchResult failed with err: ' + err);\n    } finally {\n      if (fetchResult != null) {\n        fetchResult.close();\n      }\n    }\n    Log.info(TAG, 'fileAssets: ' + fileAssets.length);\n    return fileAssets;\n  }\n\n  async getMediaItemByUriFromTrash(uri: string): Promise<photoAccessHelper.PhotoAsset> {\n    Log.info(TAG, 'getMediaItemByUriFromTrash');\n    Log.info(TAG, 'uri:' + uri);\n    let albumFetchResult: photoAccessHelper.FetchResult<photoAccessHelper.Album> = null;\n    let fileAsset: photoAccessHelper.PhotoAsset = null;\n    try {\n      albumFetchResult = await this.userFileMgr.getAlbums(photoAccessHelper.AlbumType.SYSTEM, photoAccessHelper.AlbumSubtype.TRASH);\n      let albumAsset = await albumFetchResult.getFirstObject();\n      let photoFetchResult: photoAccessHelper.FetchResult<photoAccessHelper.PhotoAsset> = null;\n      try {\n        let predicates = new dataSharePredicates.DataSharePredicates();\n        let emptyFetchOption = {\n          fetchColumns: MediaConstants.FILE_ASSET_FETCH_COLUMNS,\n          predicates: predicates\n        };\n        photoFetchResult = await albumAsset.getAssets(emptyFetchOption);\n        for (let i = 0; i < photoFetchResult.getCount(); i++) {\n          let photoAsset = await photoFetchResult.getObjectByPosition(i);\n          if (photoAsset.uri === uri) {\n            fileAsset = photoAsset;\n            Log.info(TAG, 'getMediaItemByUriFromTrash success: ' + photoAsset.displayName);\n            break;\n          }\n        }\n      } catch (err) {\n        Log.info(TAG, 'getMediaItemByUriFromTrash getPhotoAssets failed with err: ' + err);\n      } finally {\n        if (photoFetchResult != null) {\n          photoFetchResult.close();\n        }\n      }\n    } catch (err) {\n      Log.error(TAG, 'getMediaItemByUriFromTrash failed with error: ' + err);\n    } finally {\n      if (albumFetchResult != null) {\n        albumFetchResult.close();\n      }\n    }\n    return fileAsset;\n  }\n\n  async getMediaItemByUri(uri: string): Promise<photoAccessHelper.PhotoAsset> {\n    Log.info(TAG, 'getMediaItemByUri');\n    Log.info(TAG, 'uri:' + uri);\n    let predicates = new dataSharePredicates.DataSharePredicates();\n    predicates.equalTo(photoAccessHelper.PhotoKeys.URI, uri);\n    let fetchOptions = {\n      fetchColumns: MediaConstants.FILE_ASSET_FETCH_COLUMNS,\n      predicates: predicates\n    };\n    let fileAsset: photoAccessHelper.PhotoAsset = null;\n    let fetchResult: photoAccessHelper.FetchResult<photoAccessHelper.PhotoAsset> = null\n    try {\n      Log.info(TAG, 'fetchResult start');\n      fetchResult = await this.userFileMgr.getAssets(fetchOptions);\n      Log.info(TAG, 'fetchResult count ' + fetchResult.getCount());\n      fileAsset = await fetchResult.getFirstObject();\n      Log.info(TAG, 'fileAsset ' + fileAsset.displayName);\n    } catch (err) {\n      Log.error(TAG, 'getMediaItemByUri failed, message = ' + err);\n    } finally {\n      if (fetchResult != null) {\n        fetchResult.close();\n      }\n    }\n    return fileAsset;\n  }\n\n  async getMediaItemCountsByDisplayName(displayName: string): Promise<number> {\n    Log.info(TAG, 'getMediaItemCountsByDisplayName');\n    let count = 0;\n    let fetchFileResult: photoAccessHelper.FetchResult = null;\n    let predicates = new dataSharePredicates.DataSharePredicates();\n    predicates.equalTo(photoAccessHelper.PhotoKeys.DISPLAY_NAME, displayName);\n    let fetchOptions = {\n      fetchColumns: MediaConstants.FILE_ASSET_FETCH_COLUMNS,\n      predicates: predicates\n    };\n    try {\n      fetchFileResult = await this.userFileMgr.getAssets(fetchOptions);\n      Log.debug(TAG, 'getMediaItemCountsByDisplayName getPhotoAssets');\n      count = await fetchFileResult.getCount();\n    } catch (err) {\n      Log.error(TAG, 'getMediaItemCountsByDisplayName error:' + JSON.stringify(err));\n    } finally {\n      if (fetchFileResult != null) {\n        fetchFileResult.close();\n      }\n    }\n    Log.debug(TAG, 'getMediaItemCountsByDisplayName finish');\n    return count;\n  }\n\n  async getUserAlbumCountByName(albumName: string): Promise<number> {\n    Log.info(TAG, 'getUserAlbumCountByName');\n    Log.info(TAG, 'album_name：' + albumName);\n    let count = 0;\n    let systemAlbums = await getSystemAlbumDisplayName();\n    if (systemAlbums.indexOf(albumName) >= 0) {\n      return 1;\n    }\n    let fetchResult: photoAccessHelper.FetchResult = null;\n    try {\n      let predicates = new dataSharePredicates.DataSharePredicates();\n      predicates.equalTo(photoAccessHelper.AlbumKeys.ALBUM_NAME, albumName);\n      let fetchOptions = {\n        fetchColumns: MediaConstants.EMPTY_FETCH_COLUMNS,\n        predicates: predicates\n      };\n      fetchResult = await this.userFileMgr.getAlbums(photoAccessHelper.AlbumType.USER, photoAccessHelper.AlbumSubtype.USER_GENERIC, fetchOptions);\n      Log.info(TAG, 'fetchResult' + fetchResult.getCount());\n      count = fetchResult.getCount();\n    } catch (err) {\n      Log.error(TAG, 'getUserAlbumCountByName error:' + JSON.stringify(err));\n    } finally {\n      if (fetchResult != null) {\n        fetchResult.close();\n      }\n    }\n    Log.debug(TAG, 'getUserAlbumCountByName finish');\n    return count;\n  }\n\n  async getActivePeers(): Promise<photoAccessHelper.PeerInfo[]> {\n    Log.info(TAG, 'getActivePeers');\n    let peers: photoAccessHelper.PeerInfo[] = [];\n    try {\n      let getActivePeers = hiSysEventDataQueryTimedOut('getActivePeers')\n      peers = await this.userFileMgr.getActivePeers();\n      clearTimeout(getActivePeers);\n    } catch (err) {\n      Log.error(TAG, 'getActivePeers error:' + JSON.stringify(err));\n    }\n    Log.debug(TAG, 'getActivePeers finish');\n    return peers;\n  }\n\n  async getUserAlbumByName(albumName: string): Promise<photoAccessHelper.Album> {\n    Log.info(TAG, 'getUserAlbumByName');\n    Log.info(TAG, 'album_name' + albumName);\n    let fetchResult: photoAccessHelper.FetchResult = null;\n    let album = null;\n    try {\n      let predicates = new dataSharePredicates.DataSharePredicates();\n      predicates.equalTo(photoAccessHelper.AlbumKeys.ALBUM_NAME, albumName);\n      let fetchOptions = {\n        fetchColumns: MediaConstants.EMPTY_FETCH_COLUMNS,\n        predicates: predicates\n      };\n      fetchResult = await this.userFileMgr.getAlbums(photoAccessHelper.AlbumType.USER, photoAccessHelper.AlbumSubtype.USER_GENERIC, fetchOptions);\n      Log.info(TAG, 'fetchResult' + fetchResult.getCount());\n      if (fetchResult.getCount() > 0) {\n        album = fetchResult.getFirstObject();\n      }\n    } catch (err) {\n      Log.error(TAG, 'getUserAlbumByName error:' + JSON.stringify(err));\n    } finally {\n      if (fetchResult != null) {\n        fetchResult.close();\n      }\n    }\n    Log.debug(TAG, 'getUserAlbumByName finish');\n    return album;\n  }\n\n  async getAlbums(fetchOption: photoAccessHelper.FetchOptions): Promise<photoAccessHelper.Album[]> {\n    Log.info(TAG, 'getAlbums');\n    let albums: photoAccessHelper.Album[] = [];\n    try {\n      albums = await this.userFileMgr.getAlbums(fetchOption);\n      Log.info(TAG, 'getAlbums albums ' + albums.getCounts());\n    } catch (err) {\n      Log.error(TAG, 'getAlbums error:' + JSON.stringify(err));\n    }\n    Log.debug(TAG, 'getAlbums finish');\n    return albums;\n  }\n\n  async openAsset(mode: string, fileAsset: photoAccessHelper.PhotoAsset): Promise<number> {\n    Log.debug(TAG, 'openAsset start');\n    let fd: number = await fileAsset.open(mode);\n    Log.info(TAG, 'openAsset end. fd: ' + fd);\n    if (fd <= 0) {\n      Log.info(TAG, 'openAsset Fail');\n    }\n    return fd;\n  }\n\n  async closeAsset(fd: number, fileAsset: photoAccessHelper.PhotoAsset): Promise<void> {\n    Log.debug(TAG, 'closeAsset start');\n    await fileAsset.close(fd);\n  }\n\n  async addPhotoToAlbumByUserFileMgr(albumUri: string, uri: string): Promise<void> {\n    Log.info(TAG, 'addPhotoAssetsDemoPromise');\n    Log.info(TAG, 'albumUri' + albumUri);\n    Log.info(TAG, 'mediaItem.uri' + uri);\n    try {\n      let album = await this.getUserAlbumItemByUri(albumUri);\n      let predicates = new dataSharePredicates.DataSharePredicates();\n      predicates.equalTo(photoAccessHelper.PhotoKeys.URI, uri);\n      let fetchOptions = {\n        fetchColumns: MediaConstants.FILE_ASSET_FETCH_COLUMNS,\n        predicates: predicates\n      };\n      this.userFileMgr.getAssets(fetchOptions, async (err, fetchResult) => {\n        if (fetchResult != undefined) {\n          Log.info(TAG, 'fetchResult success');\n          let fileAsset = await fetchResult.getFirstObject();\n          if (fileAsset != undefined) {\n            Log.info(TAG, 'addPhotoToAlbumByUserFileMgr photo displayName : ' + fileAsset.displayName);\n            album.addAssets([fileAsset]).then(() => {\n              Log.info(TAG, 'album addPhotoAssets successfully');\n            }).catch((err) => {\n              Log.info(TAG, 'album addPhotoAssets failed with error: ' + err);\n            });\n          }\n          fetchResult.close();\n        } else {\n          Log.info(TAG, 'fetchResult fail' + err);\n        }\n      });\n    } catch (err) {\n      Log.error(TAG, 'addPhotoAssetsDemoPromise failed with error: ' + err);\n    }\n  }\n}\n\nexport let userFileModel: UserFileModel = stashOrGetObject<UserFileModel>(new UserFileModel(), TAG);\n", "llm_cg": {"UserFileModel.onCreate(context)": ["photoAccessHelper.getPhotoAccessHelper(context)"], "UserFileModel.createOne(displayName: string, albumUri: string)": ["UserFileModel.userFileMgr.createAsset(displayName, albumUri)", "UserFileModel.getUserAlbumItemByUri(albumUri)", "photoAccessHelper.Album.addAssets([fileAsset])"], "UserFileModel.getUserAlbumItemByUri(uri: string)": ["dataSharePredicates.DataSharePredicates()", "UserFileModel.userFileMgr.getAlbums(photoAccessHelper.AlbumType.USER, photoAccessHelper.AlbumSubtype.USER_GENERIC, fetchOptions)", "photoAccessHelper.FetchResult.getCount()", "photoAccessHelper.FetchResult.getFirstObject()", "photoAccessHelper.FetchResult.close()"], "UserFileModel.copyOne(source: photoAccessHelper.PhotoAsset, target: photoAccessHelper.PhotoAsset)": ["UserFileModel.openAsset('R', source)", "UserFileModel.openAsset('RW', target)", "fileIO.copyFile(fd, targetFd)", "UserFileModel.closeAsset(fd, source)", "UserFileModel.closeAsset(targetFd, target)"], "UserFileModel.deleteOne(uri: string)": ["UserFileModel.userFileMgr.deleteAssets([uri])"], "UserFileModel.recover(fileAsset: photoAccessHelper.PhotoAsset)": ["UserFileModel.userFileMgr.getAlbums(photoAccessHelper.AlbumType.SYSTEM, photoAccessHelper.AlbumSubtype.TRASH)", "photoAccessHelper.FetchResult.getFirstObject()", "photoAccessHelper.Album.recoverAssets([fileAsset])", "photoAccessHelper.FetchResult.close()"], "UserFileModel.permanentDelete(fileAsset: photoAccessHelper.PhotoAsset)": ["UserFileModel.userFileMgr.getAlbums(photoAccessHelper.AlbumType.SYSTEM, photoAccessHelper.AlbumSubtype.TRASH)", "photoAccessHelper.FetchResult.getFirstObject()", "photoAccessHelper.Album.deleteAssets([fileAsset])", "photoAccessHelper.FetchResult.close()"], "UserFileModel.createAlbum(albumName: string)": ["UserFileModel.userFileMgr.createAlbum(albumName)", "SimpleAlbumDataItem.%AM0$SimpleAlbumDataItem(MediaConstants.ALBUM_ID_USER, albumName, album.albumUri, '', '', MediaConstants.ALBUM_TYPE_USER, MediaConstants.ALBUM_SUBTYPE_USER_GENERIC)"], "UserFileModel.deleteAlbum(albumName: string)": ["dataSharePredicates.DataSharePredicates()", "UserFileModel.userFileMgr.getAlbums(photoAccessHelper.AlbumType.USER, photoAccessHelper.AlbumSubtype.USER_GENERIC, fetchOptions)", "photoAccessHelper.FetchResult.getCount()", "photoAccessHelper.FetchResult.getObjectByPosition(i)", "UserFileModel.userFileMgr.deleteAlbums([albumAsset])", "photoAccessHelper.FetchResult.close()"], "UserFileModel.deleteAll(fetchOption: photoAccessHelper.FetchOptions)": ["UserFileModel.userFileMgr.getAssets(fetchOption)", "photoAccessHelper.FetchResult.getAllObject()", "UserFileModel.deleteOne(fileAssets[i].uri)", "photoAccessHelper.FetchResult.close()"], "UserFileModel.getAllMediaItems()": ["dataSharePredicates.DataSharePredicates()", "UserFileModel.userFileMgr.getAssets(emptyFetchOption)", "photoAccessHelper.FetchResult.getCount()", "photoAccessHelper.FetchResult.getObjectByPosition(i)", "photoAccessHelper.FetchResult.close()"], "UserFileModel.getAllMovingPhotoItems()": ["dataSharePredicates.DataSharePredicates()", "UserFileModel.userFileMgr.getAssets(fetchOptions)", "photoAccessHelper.FetchResult.getCount()", "photoAccessHelper.FetchResult.getObjectByPosition(i)", "photoAccessHelper.FetchResult.close()"], "UserFileModel.getAllMediaItemsByType(type: number, subType: number, albumFetchOption, fileFetchOption)": ["UserFileModel.userFileMgr.getAlbums(type, subType, albumFetchOption)", "photoAccessHelper.FetchResult.getCount()", "photoAccessHelper.FetchResult.getObjectByPosition(i)", "photoAccessHelper.Album.getAssets(fileFetchOption)", "photoAccessHelper.FetchResult.getCount()", "photoAccessHelper.FetchResult.getObjectByPosition(i)", "photoAccessHelper.FetchResult.close()"], "UserFileModel.getMediaItemByUriFromTrash(uri: string)": ["UserFileModel.userFileMgr.getAlbums(photoAccessHelper.AlbumType.SYSTEM, photoAccessHelper.AlbumSubtype.TRASH)", "photoAccessHelper.FetchResult.getFirstObject()", "dataSharePredicates.DataSharePredicates()", "photoAccessHelper.Album.getAssets(emptyFetchOption)", "photoAccessHelper.FetchResult.getCount()", "photoAccessHelper.FetchResult.getObjectByPosition(i)", "photoAccessHelper.FetchResult.close()"], "UserFileModel.getMediaItemByUri(uri: string)": ["dataSharePredicates.DataSharePredicates()", "UserFileModel.userFileMgr.getAssets(fetchOptions)", "photoAccessHelper.FetchResult.getCount()", "photoAccessHelper.FetchResult.getFirstObject()", "photoAccessHelper.FetchResult.close()"], "UserFileModel.getMediaItemCountsByDisplayName(displayName: string)": ["dataSharePredicates.DataSharePredicates()", "UserFileModel.userFileMgr.getAssets(fetchOptions)", "photoAccessHelper.FetchResult.getCount()", "photoAccessHelper.FetchResult.close()"], "UserFileModel.getUserAlbumCountByName(albumName: string)": ["getSystemAlbumDisplayName()", "dataSharePredicates.DataSharePredicates()", "UserFileModel.userFileMgr.getAlbums(photoAccessHelper.AlbumType.USER, photoAccessHelper.AlbumSubtype.USER_GENERIC, fetchOptions)", "photoAccessHelper.FetchResult.getCount()", "photoAccessHelper.FetchResult.close()"], "UserFileModel.getActivePeers()": ["UserFileModel.userFileMgr.getActivePeers()"], "UserFileModel.getUserAlbumByName(albumName: string)": ["dataSharePredicates.DataSharePredicates()", "UserFileModel.userFileMgr.getAlbums(photoAccessHelper.AlbumType.USER, photoAccessHelper.AlbumSubtype.USER_GENERIC, fetchOptions)", "photoAccessHelper.FetchResult.getCount()", "photoAccessHelper.FetchResult.getFirstObject()", "photoAccessHelper.FetchResult.close()"], "UserFileModel.getAlbums(fetchOption: photoAccessHelper.FetchOptions)": ["UserFileModel.userFileMgr.getAlbums(fetchOption)"], "UserFileModel.openAsset(mode: string, fileAsset: photoAccessHelper.PhotoAsset)": ["photoAccessHelper.PhotoAsset.open(mode)"], "UserFileModel.closeAsset(fd: number, fileAsset: photoAccessHelper.PhotoAsset)": ["photoAccessHelper.PhotoAsset.close(fd)"], "UserFileModel.addPhotoToAlbumByUserFileMgr(albumUri: string, uri: string)": ["UserFileModel.getUserAlbumItemByUri(albumUri)", "dataSharePredicates.DataSharePredicates()", "UserFileModel.userFileMgr.getAssets(fetchOptions, async (err, fetchResult))", "photoAccessHelper.FetchResult.getFirstObject()", "photoAccessHelper.Album.addAssets([fileAsset])", "photoAccessHelper.FetchResult.close()"]}, "static_cg": {"@test/67.ts: %dflt.[static]%dflt()": ["@test/67.ts: UserFileModel.constructor()"], "@test/67.ts: UserFileModel.createOne(string, string)": ["@test/67.ts: UserFileModel.getUserAlbumItemByUri(string)"], "@test/67.ts: UserFileModel.copyOne(photoAccessHelper.PhotoAsset, photoAccessHelper.PhotoAsset)": ["@test/67.ts: UserFileModel.openAsset(string, photoAccessHelper.PhotoAsset)", "@test/67.ts: UserFileModel.closeAsset(number, photoAccessHelper.PhotoAsset)"], "@test/67.ts: UserFileModel.recover(photoAccessHelper.PhotoAsset)": ["@test/67.ts: UserFileModel.%AM1$recover()", "@test/67.ts: UserFileModel.%AM0$recover(unknown)"], "@test/67.ts: UserFileModel.permanentDelete(photoAccessHelper.PhotoAsset)": ["@test/67.ts: UserFileModel.%AM3$permanentDelete()", "@test/67.ts: UserFileModel.%AM2$permanentDelete(unknown)"], "@test/67.ts: UserFileModel.deleteAlbum(string)": ["@test/67.ts: UserFileModel.%AM5$deleteAlbum()", "@test/67.ts: UserFileModel.%AM4$deleteAlbum(unknown)"], "@test/67.ts: UserFileModel.deleteAll(photoAccessHelper.FetchOptions)": ["@test/67.ts: UserFileModel.deleteOne(string)"], "@test/67.ts: UserFileModel.addPhotoToAlbumByUserFileMgr(string, string)": ["@test/67.ts: UserFileModel.getUserAlbumItemByUri(string)", "@test/67.ts: UserFileModel.%AM6$addPhotoToAlbumByUserFileMgr([album], unknown, unknown)"], "@test/67.ts: UserFileModel.%AM6$addPhotoToAlbumByUserFileMgr([album], unknown, unknown)": ["@test/67.ts: UserFileModel.%AM8$%AM6$addPhotoToAlbumByUserFileMgr()", "@test/67.ts: UserFileModel.%AM7$%AM6$addPhotoToAlbumByUserFileMgr(unknown)"]}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport interface UserFileDataChangeCallback {\n  onUserFileDataChange(mediaType: string): void;\n}", "llm_cg": {"UserFileDataChangeCallback.onUserFileDataChange(mediaType: string)": []}, "static_cg": {}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport enum JumpSourceToMain {\n  None,\n  CAMERA,\n  ALBUM\n}", "llm_cg": {"JumpSourceToMain.None": [], "JumpSourceToMain.CAMERA": [], "JumpSourceToMain.ALBUM": []}, "static_cg": {}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport enum ActionBarMode {\n  STANDARD_MODE,\n  DETAIL_MODE,\n  SELECTION_MODE,\n  TOP_MODE\n}\n\nexport enum ActionBarColorMode {\n  NORMAL,\n  TRANSPARENT,\n}\n\nexport enum ActionBarSelectionMode {\n  SINGLE,\n  MULTI,\n}", "llm_cg": {"ActionBarMode.STANDARD_MODE": [], "ActionBarMode.DETAIL_MODE": [], "ActionBarMode.SELECTION_MODE": [], "ActionBarMode.TOP_MODE": [], "ActionBarColorMode.NORMAL": [], "ActionBarColorMode.TRANSPARENT": [], "ActionBarSelectionMode.SINGLE": [], "ActionBarSelectionMode.MULTI": []}, "static_cg": {}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { screenManager } from '../common/ScreenManager';\nimport { computeSampleSize } from '../utils/ImageUtil';\nimport { UserFileDataItem } from '../base/UserFileDataItem';\n\nexport async function getThumbnail(mediaItem: UserFileDataItem, isCurrent: boolean): Promise<PixelMap> {\n  await mediaItem.load(true);\n  let imgWidth = mediaItem.width;\n  let imgHeight = mediaItem.height;\n  let scale = generateSampleSize(imgWidth, imgHeight, isCurrent);\n  mediaItem.imgWidth = Math.ceil(mediaItem.width / scale);\n  mediaItem.imgHeight = Math.ceil(mediaItem.height / scale);\n  imgWidth = Math.ceil(imgWidth / scale);\n  imgHeight = Math.ceil(imgHeight / scale);\n  return await mediaItem.getThumbnail(imgWidth, imgHeight);\n}\n\nfunction generateSampleSize(imageWidth: number, imageHeight: number, isCurrent: boolean): number {\n  let width = vp2px(screenManager.getWinWidth());\n  let height = vp2px(screenManager.getWinHeight());\n  width = width === 0 ? screenManager.DEFAULT_WIDTH : width;\n  height = height === 0 ? screenManager.DEFAULT_HEIGHT : height;\n  let maxNumOfPixels;\n  if (isCurrent) {\n    maxNumOfPixels = 2 * width * height;\n  } else {\n    maxNumOfPixels = width * height;\n  }\n  let minSide = Math.min(width, height);\n  return computeSampleSize(imageWidth, imageHeight, minSide, maxNumOfPixels);\n}", "llm_cg": {"getThumbnail(mediaItem: UserFileDataItem, isCurrent: boolean)": ["UserFileDataItem.load(boolean)", "UserFileDataItem.getThumbnail(number, number)"], "generateSampleSize(imageWidth: number, imageHeight: number, isCurrent: boolean)": ["screenManager.getWinWidth()", "screenManager.getWinHeight()", "computeSampleSize(number, number, number, number)"]}, "static_cg": {"@test/71.ts: %dflt.getThumbnail(UserFileDataItem, boolean)": ["@test/71.ts: %dflt.generateSampleSize(number, number, boolean)"]}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Action } from './Action'\nimport { ActionBarProp } from '../common/ActionBarProp'\nimport { ActionBarMode, ActionBarSelectionMode } from './ActionBarMode'\nimport { screenManager } from '../common/ScreenManager'\n\nexport class AlbumBarModel {\n  createActionBar(isAlbumSetSelectedMode: boolean, selectedAlbumsCount: number,\n                  isDisableRename: boolean, isDisableDelete: boolean): ActionBarProp {\n    let actionBarProp: ActionBarProp = new ActionBarProp();\n    let isHorizontal = screenManager.isHorizontal();\n    if (isHorizontal) {\n      this.updateHorizontalActionBar(actionBarProp, isAlbumSetSelectedMode,\n        selectedAlbumsCount, isDisableRename, isDisableDelete);\n    } else {\n      this.updateVerticalActionBar(actionBarProp, isAlbumSetSelectedMode);\n    }\n    return actionBarProp;\n  }\n\n  updateActionBar(actionBarProp: ActionBarProp, isAlbumSetSelectedMode: boolean,\n                  selectedAlbumsCount: number, isDisableRename: boolean, isDisableDelete: boolean): void {\n    let isHorizontal = screenManager.isHorizontal();\n    if (isHorizontal) {\n      this.updateHorizontalActionBar(actionBarProp, isAlbumSetSelectedMode,\n        selectedAlbumsCount, isDisableRename, isDisableDelete);\n    } else {\n      this.updateVerticalActionBar(actionBarProp, isAlbumSetSelectedMode);\n    }\n  }\n\n  private updateHorizontalActionBar(actionBarProp: ActionBarProp, isAlbumSetSelectedMode: boolean, selectedAlbumsCount: number,\n                                    isDisableRename: boolean, isDisableDelete: boolean): ActionBarProp {\n    let isSidebar: boolean = screenManager.isSidebar();\n    actionBarProp\n      .setHasTabBar(isSidebar)\n      .setTitle($r('app.string.tab_albums'))\n      .setIsHeadTitle(true);\n    let menuList: Action[] = this.getMenuList(isAlbumSetSelectedMode, selectedAlbumsCount, isDisableRename, isDisableDelete);\n    if (isAlbumSetSelectedMode) {\n      actionBarProp\n        .setLeftAction(Action.CANCEL)\n        .setMenuList(menuList)\n        .setMode(ActionBarMode.SELECTION_MODE)\n        .setSelectionMode(ActionBarSelectionMode.MULTI);\n    } else {\n      menuList.push(Action.NEW)\n      actionBarProp\n        .setMenuList(menuList)\n        .setMode(ActionBarMode.STANDARD_MODE);\n    }\n    return actionBarProp;\n  }\n\n  private updateVerticalActionBar(actionBarProp: ActionBarProp, isAlbumSetSelectedMode: boolean): ActionBarProp {\n    let menuList: Action[] = [];\n    menuList.push(Action.NEW);\n    let isSidebar: boolean = screenManager.isSidebar();\n    actionBarProp\n      .setHasTabBar(isSidebar)\n      .setTitle($r('app.string.tab_albums'))\n      .setIsHeadTitle(true);\n\n    if (isAlbumSetSelectedMode) {\n      actionBarProp\n        .setLeftAction(Action.CANCEL)\n        .setMode(ActionBarMode.SELECTION_MODE)\n        .setSelectionMode(ActionBarSelectionMode.MULTI);\n    } else {\n      actionBarProp\n        .setMenuList(menuList)\n        .setMode(ActionBarMode.STANDARD_MODE);\n    }\n\n    return actionBarProp;\n  }\n\n  getMenuList(isAlbumSetSelectedMode: boolean, selectedAlbumsCount: number, isDisableRename: boolean, isDisableDelete: boolean): Action[] {\n    let menuList: Action[] = [];\n    if (isAlbumSetSelectedMode) {\n      menuList.push((!isDisableRename && selectedAlbumsCount === 1) ? Action.RENAME : Action.RENAME_INVALID);\n      menuList.push((!isDisableDelete && selectedAlbumsCount > 0) ? Action.DELETE : Action.DELETE_INVALID);\n    }\n    return menuList;\n  }\n}\n", "llm_cg": {"AlbumBarModel.createActionBar(boolean, number, boolean, boolean)": ["AlbumBarModel.updateHorizontalActionBar(ActionBarProp, boolean, number, boolean, boolean)", "AlbumBarModel.updateVerticalActionBar(ActionBarProp, boolean)"], "AlbumBarModel.updateActionBar(ActionBarProp, boolean, number, boolean, boolean)": ["AlbumBarModel.updateHorizontalActionBar(ActionBarProp, boolean, number, boolean, boolean)", "AlbumBarModel.updateVerticalActionBar(ActionBarProp, boolean)"], "AlbumBarModel.updateHorizontalActionBar(ActionBarProp, boolean, number, boolean, boolean)": ["AlbumBarModel.getMenuList(boolean, number, boolean, boolean)"], "AlbumBarModel.updateVerticalActionBar(ActionBarProp, boolean)": [], "AlbumBarModel.getMenuList(boolean, number, boolean, boolean)": []}, "static_cg": {"@test/72.ts: AlbumBarModel.createActionBar(boolean, number, boolean, boolean)": ["@test/72.ts: AlbumBarModel.updateHorizontalActionBar(ActionBarProp, boolean, number, boolean, boolean)", "@test/72.ts: AlbumBarModel.updateVerticalActionBar(ActionBarProp, boolean)"], "@test/72.ts: AlbumBarModel.updateActionBar(ActionBarProp, boolean, number, boolean, boolean)": ["@test/72.ts: AlbumBarModel.updateHorizontalActionBar(ActionBarProp, boolean, number, boolean, boolean)", "@test/72.ts: AlbumBarModel.updateVerticalActionBar(ActionBarProp, boolean)"], "@test/72.ts: AlbumBarModel.updateHorizontalActionBar(ActionBarProp, boolean, number, boolean, boolean)": ["@test/72.ts: AlbumBarModel.getMenuList(boolean, number, boolean, boolean)"]}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Action } from './Action';\nimport { ActionBarMode, ActionBarSelectionMode } from './ActionBarMode';\nimport { ActionBarProp } from '../common/ActionBarProp';\n\nexport class NewAlbumBarModel {\n  createActionBar(isSelectedMode: boolean, selectedCount: number): ActionBarProp {\n    let menuList: Action[] = [];\n    let actionBarProp: ActionBarProp = new ActionBarProp();\n    menuList.push((new Boolean(selectedCount)) ? Action.OK : Action.OK_DISABLE)\n    actionBarProp\n      .setLeftAction(Action.CANCEL)\n      .setMode(ActionBarMode.SELECTION_MODE)\n      .setSelectionMode(ActionBarSelectionMode.MULTI)\n      .setMenuList(menuList);\n    return actionBarProp;\n  }\n}\n", "llm_cg": {"NewAlbumBarModel.createActionBar(isSelectedMode: boolean, selectedCount: number)": ["ActionBarProp.setLeftAction(Action.CANCEL)", "ActionBarProp.setMode(ActionBarMode.SELECTION_MODE)", "ActionBarProp.setSelectionMode(ActionBarSelectionMode.MULTI)", "ActionBarProp.setMenuList(menuList)"]}, "static_cg": {}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nenum ActionID {\n  NONE,\n  OK,\n  OK_DISABLE,\n  CANCEL,\n  BACK,\n  INFO,\n  INFO_INVALID,\n  DELETE,\n  DELETE_RECYCLE,\n  CLEAR_RECYCLE,\n  DELETE_INVALID,\n  RECOVER,\n  RECOVER_INVALID,\n  FAVORITE,\n  NOT_FAVORITE,\n  UN_SELECTED,\n  SELECTED,\n  SELECT_ALL,\n  DESELECT_ALL,\n  SETTING,\n  NAVIGATION,\n  MATERIAL_SELECT,\n  GOTO_PHOTOS,\n  SHARE,\n  SHARE_INVALID,\n  EDIT,\n  EDIT_INVALID,\n  MORE,\n  NEW,\n  RENAME,\n  RENAME_INVALID,\n  ADD_NOTES,\n  ROTATE,\n  MOVE,\n  MOVE_INVALID,\n  REMOVE,\n  REMOVE_INVALID,\n  COPY,\n  COPY_INVALID,\n  NAVIGATION_ALBUMS,\n  DOWNLOAD,\n  DOWNLOAD_INVALID,\n  CLEAR_RECYCLE_INVALID\n}\n\nclass ActionOptions {\n  id: number = ActionID.NONE;\n  iconRes: Resource | null = null;\n  textRes: Resource | null = null;\n  isAutoTint: boolean | null = null;\n  fillColor: Resource | null = null;\n  actionType: Resource | null = null;\n}\n\nexport class Action {\n  public static NONE = new Action({\n    id: ActionID.NONE,\n    iconRes: null,\n    textRes: null,\n    isAutoTint: null,\n    fillColor: null,\n    actionType: null\n  });\n  public static OK = new Action({\n    id: ActionID.OK,\n    iconRes: $r('app.media.ic_gallery_public_ok'),\n    textRes: $r('app.string.action_ok'),\n    isAutoTint: null,\n    fillColor: null,\n    actionType: null\n  });\n  public static OK_DISABLE = new Action({\n    id: ActionID.OK_DISABLE,\n    iconRes: $r('app.media.ic_gallery_public_ok'),\n    textRes: $r('app.string.action_ok'),\n    isAutoTint: null,\n    fillColor: $r('app.color.icon_disabled_color'),\n    actionType: null\n  });\n  public static CANCEL = new Action({\n    id: ActionID.CANCEL,\n    iconRes: $r('app.media.ic_gallery_public_cancel'),\n    textRes: $r('app.string.action_cancel'),\n    isAutoTint: null,\n    fillColor: null,\n    actionType: null\n  });\n  public static BACK = new Action({\n    id: ActionID.BACK,\n    iconRes: $r('app.media.ic_gallery_public_back'),\n    textRes: $r('app.string.action_back'),\n    isAutoTint: null,\n    fillColor: null,\n    actionType: null\n  });\n  public static INFO = new Action({\n    id: ActionID.INFO,\n    iconRes: $r('app.media.ic_gallery_public_details'),\n    textRes: $r('app.string.action_info'),\n    isAutoTint: null,\n    fillColor: null,\n    actionType: null\n  });\n  public static INFO_INVALID = new Action({\n    id: ActionID.INFO,\n    iconRes: $r('app.media.ic_gallery_public_details'),\n    textRes: $r('app.string.action_info'),\n    isAutoTint: null,\n    fillColor: $r('app.color.icon_disabled_color'),\n    actionType: null\n  });\n  public static DELETE = new Action({\n    id: ActionID.DELETE,\n    iconRes: $r('app.media.ic_gallery_public_delete_line'),\n    textRes: $r('app.string.action_delete'),\n    isAutoTint: null,\n    fillColor: null,\n    actionType: $r('app.string.action_delete')\n  });\n  public static DELETE_RECYCLE = new Action({\n    id: ActionID.DELETE_RECYCLE,\n    iconRes: $r('app.media.ic_gallery_public_delete_line'),\n    textRes: $r('app.string.action_delete'),\n    isAutoTint: null,\n    fillColor: null,\n    actionType: $r('app.string.action_delete')\n  });\n  public static CLEAR_RECYCLE = new Action({\n    id: ActionID.CLEAR_RECYCLE,\n    iconRes: $r('app.media.ic_gallery_public_delete_line'),\n    textRes: $r('app.string.action_clear_recycle'),\n    isAutoTint: null,\n    fillColor: null,\n    actionType: $r('app.string.action_clear_recycle')\n  });\n  public static CLEAR_RECYCLE_INVALID = new Action({\n    id: ActionID.CLEAR_RECYCLE_INVALID,\n    iconRes: $r('app.media.ic_gallery_public_delete_line'),\n    textRes: $r('app.string.action_clear_recycle'),\n    isAutoTint: null,\n    fillColor: $r('app.color.icon_disabled_color'),\n    actionType: $r('app.string.action_delete')\n  });\n  public static DELETE_INVALID = new Action({\n    id: ActionID.DELETE_INVALID,\n    iconRes: $r('app.media.ic_gallery_public_delete_line'),\n    textRes: $r('app.string.action_delete'),\n    isAutoTint: null,\n    fillColor: $r('app.color.icon_disabled_color'),\n    actionType: $r('app.string.action_delete_invalid')\n  });\n  public static RECOVER = new Action({\n    id: ActionID.RECOVER,\n    iconRes: $r('app.media.ic_gallery_public_undo'),\n    textRes: $r('app.string.action_recover'),\n    isAutoTint: null,\n    fillColor: null,\n    actionType: $r('app.string.action_recover')\n  });\n  public static RECOVER_INVALID = new Action({\n    id: ActionID.RECOVER_INVALID,\n    iconRes: $r('app.media.ic_gallery_public_undo'),\n    textRes: $r('app.string.action_recover'),\n    isAutoTint: null,\n    fillColor: $r('app.color.icon_disabled_color'),\n    actionType: $r('app.string.action_recover')\n  });\n  public static FAVORITE = new Action({\n    id: ActionID.FAVORITE,\n    iconRes: $r('app.media.ic_gallery_public_Favorite_filled'),\n    textRes: $r('app.string.action_favorite'),\n    isAutoTint: null,\n    fillColor: $r('app.color.color_system_highlight'),\n    actionType: $r('app.string.action_favorite')\n  });\n  public static NOT_FAVORITE = new Action({\n    id: ActionID.NOT_FAVORITE,\n    iconRes: $r('app.media.ic_gallery_public_favorite_line'),\n    textRes: $r('app.string.action_not_favorite'),\n    isAutoTint: null,\n    fillColor: null,\n    actionType: $r('app.string.action_not_favorite')\n  });\n  public static UN_SELECTED = new Action({\n    id: ActionID.UN_SELECTED,\n    iconRes: $r('app.media.ic_checkbox_off'),\n    textRes: $r('app.string.action_unselected'),\n    isAutoTint: null,\n    fillColor: null,\n    actionType: $r('app.string.action_unselected')\n  });\n  public static SELECTED = new Action({\n    id: ActionID.SELECTED,\n    iconRes: $r('app.media.ic_gallery_public_checkbox_filled'),\n    textRes: $r('app.string.action_selected'),\n    isAutoTint: false,\n    fillColor: null,\n    actionType: $r('app.string.action_selected')\n  });\n  public static SELECT_ALL = new Action({\n    id: ActionID.SELECT_ALL,\n    iconRes: $r('app.media.ic_gallery_public_select_all'),\n    textRes: $r('app.string.action_select_all'),\n    isAutoTint: null,\n    fillColor: null,\n    actionType: $r('app.string.action_select_all')\n  });\n  public static DESELECT_ALL = new Action({\n    id: ActionID.DESELECT_ALL,\n    iconRes: $r('app.media.ic_gallery_public_select_all_action'),\n    textRes: $r('app.string.action_deselect_all'),\n    isAutoTint: null,\n    fillColor: null,\n    actionType: $r('app.string.action_deselect_all')\n  });\n  public static SETTING = new Action({\n    id: ActionID.SETTING,\n    iconRes: null,\n    textRes: $r('app.string.action_setting'),\n    isAutoTint: null,\n    fillColor: null,\n    actionType: null\n  });\n  public static NAVIGATION = new Action({\n    id: ActionID.NAVIGATION,\n    iconRes: null,\n    textRes: $r('app.string.action_navigation'),\n    isAutoTint: null,\n    fillColor: null,\n    actionType: null\n  });\n  public static MATERIAL_SELECT = new Action({\n    id: ActionID.MATERIAL_SELECT,\n    iconRes: $r('app.media.ic_checkbox_off_overlay'),\n    textRes: $r('app.string.action_material_select'),\n    isAutoTint: false,\n    fillColor: null,\n    actionType: $r('app.string.action_selected')\n  });\n  public static GOTO_PHOTOS = new Action({\n    id: ActionID.GOTO_PHOTOS,\n    iconRes: $r('app.media.ic_goto_photos'),\n    textRes: $r('app.string.action_goto_photos'),\n    isAutoTint: null,\n    fillColor: null,\n    actionType: null\n  });\n  public static MORE = new Action({\n    id: ActionID.MORE,\n    iconRes: $r('app.media.ic_gallery_public_more'),\n    textRes: $r('app.string.action_more'),\n    isAutoTint: null,\n    fillColor: null,\n    actionType: null\n  });\n  public static NEW = new Action({\n    id: ActionID.NEW,\n    iconRes: $r('app.media.ic_gallery_public_new'),\n    textRes: $r('app.string.action_new'),\n    isAutoTint: null,\n    fillColor: null,\n    actionType: null\n  });\n  public static RENAME = new Action({\n    id: ActionID.RENAME,\n    iconRes: $r('app.media.ic_gallery_public_rename'),\n    textRes: $r('app.string.action_rename'),\n    isAutoTint: null,\n    fillColor: null,\n    actionType: $r('app.string.action_rename')\n  });\n  public static RENAME_INVALID = new Action({\n    id: ActionID.RENAME_INVALID,\n    iconRes: $r('app.media.ic_gallery_public_rename'),\n    textRes: $r('app.string.action_rename'),\n    isAutoTint: null,\n    fillColor: $r('app.color.icon_disabled_color'),\n    actionType: $r('app.string.action_deRename')\n  });\n  public static MOVE = new Action({\n    id: ActionID.MOVE,\n    iconRes: null,\n    textRes: $r('app.string.action_move_to_album'),\n    isAutoTint: null,\n    fillColor: null,\n    actionType: null\n  });\n  public static MOVE_INVALID = new Action({\n    id: ActionID.MOVE_INVALID,\n    iconRes: null,\n    textRes: $r('app.string.action_move_to_album'),\n    isAutoTint: null,\n    fillColor: $r('app.color.icon_disabled_color'),\n    actionType: null\n  });\n  public static REMOVE = new Action({\n    id: ActionID.REMOVE,\n    iconRes: null,\n    textRes: $r('app.string.action_remove_from_album'),\n    isAutoTint: null,\n    fillColor: null,\n    actionType: null\n  });\n  public static REMOVE_INVALID = new Action({\n    id: ActionID.REMOVE_INVALID,\n    iconRes: null,\n    textRes: $r('app.string.action_remove_from_album'),\n    isAutoTint: null,\n    fillColor: $r('app.color.icon_disabled_color'),\n    actionType: null\n  });\n  public static NAVIGATION_ALBUMS = new Action({\n    id: ActionID.NAVIGATION_ALBUMS,\n    iconRes: $r('app.media.ic_navigation_albums_line'),\n    textRes: $r('app.string.rotate_text'),\n    isAutoTint: null,\n    fillColor: null,\n    actionType: null\n  });\n  public static ICON_DEFAULT_COLOR: Resource = $r('app.color.icon_default_color');\n  public static ICON_DEFAULT_COLOR_CONTRARY: Resource = $r('app.color.icon_default_color_contrary');\n  readonly actionID: number;\n  readonly textRes: Resource;\n  readonly iconRes: Resource = $r('app.media.ic_gallery_public_more');\n  readonly isAutoTint: boolean = true;\n  readonly fillColor: Resource = $r('app.color.icon_default_color');\n  readonly actionType: Resource; // It is used to distinguish whether it is the same type of action\n\n  constructor(options: ActionOptions) {\n    this.actionID = options.id;\n    this.textRes = options.textRes;\n    if (options.iconRes != null) {\n      this.iconRes = options.iconRes;\n    }\n    if (options.isAutoTint != null) {\n      this.isAutoTint = options.isAutoTint;\n    }\n    if (options.fillColor != null) {\n      this.fillColor = options.fillColor;\n    }\n    if (options.actionType != null) {\n      this.actionType = options.actionType;\n    }\n  }\n\n  public equals(action: Action): boolean {\n    return (action) ? (action.actionID === this.actionID) : false;\n  }\n}\n", "llm_cg": {"Action.constructor(ActionOptions)": ["Action.%AM0$constructor(unknown, unknown)"], "Action.equals(Action)": []}, "static_cg": {"@test/74.ts: Action.%statInit()": ["@test/74.ts: Action.constructor(@test/74.ts: ActionOptions)"]}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Action } from './Action';\nimport { ActionBarProp } from '../common/ActionBarProp';\nimport { ActionBarMode, ActionBarSelectionMode } from './ActionBarMode';\nimport { screenManager } from '../common/ScreenManager';\nimport { MediaConstants } from '../constants/MediaConstants';\n\nexport class PhotoGridBarModel {\n  private albumId: string = '';\n\n  setAlbumId(albumId: string): void {\n    this.albumId = albumId;\n  }\n\n  createActionBar(title: Object, isSelectedMode: boolean, selectedCount: number,\n                  isAllSelected: boolean, isEmpty: boolean): ActionBarProp {\n    let actionBarProp: ActionBarProp = new ActionBarProp();\n    let isHorizontal = screenManager.isHorizontal()\n    if (isHorizontal) {\n      this.updateHorizontalActionBar(actionBarProp, title, isSelectedMode, selectedCount, isAllSelected, isEmpty);\n    } else {\n      this.updateVerticalActionBar(actionBarProp, title, isSelectedMode);\n    }\n    return actionBarProp;\n  }\n\n  updateActionBar(actionBarProp: ActionBarProp, title: Object, isSelectedMode: boolean,\n                  selectedCount: number, isAllSelected: boolean, isEmpty: boolean): void {\n    let isHorizontal = screenManager.isHorizontal()\n    if (isHorizontal) {\n      this.updateHorizontalActionBar(actionBarProp, title, isSelectedMode, selectedCount, isAllSelected, isEmpty);\n    } else {\n      this.updateVerticalActionBar(actionBarProp, title, isSelectedMode);\n    }\n  }\n\n  private updateHorizontalActionBar(actionBarProp: ActionBarProp, title: Object, isSelectedMode: boolean,\n                                    selectedCount: number, isAllSelected: boolean, isEmpty: boolean): ActionBarProp {\n    actionBarProp\n      .setLeftAction(Action.BACK)\n      .setTitle(title)\n      .setMode(ActionBarMode.STANDARD_MODE);\n    let menuList: Action[] = this.getMenuList(isSelectedMode, selectedCount, isAllSelected, isEmpty);\n    if (isSelectedMode) {\n      actionBarProp\n        .setLeftAction(Action.CANCEL)\n        .setMode(ActionBarMode.SELECTION_MODE)\n        .setSelectionMode(ActionBarSelectionMode.MULTI);\n    } else {\n      if (!MediaConstants.ALBUM_DISABLE_NEW_LIST.has(this.albumId)) {\n        menuList.push(Action.NEW);\n      }\n    }\n    actionBarProp.setMenuList(menuList);\n    return actionBarProp;\n  }\n\n  private updateVerticalActionBar(actionBarProp: ActionBarProp, title: Object, isSelectedMode: boolean): ActionBarProp {\n    let menuList: Action[] = [];\n\n    if (!MediaConstants.ALBUM_DISABLE_NEW_LIST.has(this.albumId)) {\n      menuList.push(Action.NEW);\n    }\n\n    actionBarProp\n      .setLeftAction(Action.BACK)\n      .setTitle(title)\n      .setMenuList(menuList)\n      .setMode(ActionBarMode.STANDARD_MODE);\n    if (isSelectedMode) {\n      menuList = [];\n      actionBarProp\n        .setLeftAction(Action.CANCEL)\n        .setMenuList(menuList)\n        .setMode(ActionBarMode.SELECTION_MODE)\n        .setSelectionMode(ActionBarSelectionMode.MULTI);\n    }\n\n    return actionBarProp;\n  }\n\n  getMenuList(isSelectedMode: boolean, selectedCount: number, isAllSelected: boolean, isEmpty: boolean): Action[] {\n    let menuList: Action[] = [];\n    if (isSelectedMode) {\n      if (this.albumId === MediaConstants.ALBUM_ID_RECYCLE) {\n        menuList.push((new Boolean(selectedCount)) ? Action.RECOVER : Action.RECOVER_INVALID);\n        menuList.push((new Boolean(selectedCount)) ? Action.DELETE : Action.DELETE_INVALID);\n        menuList.push(isAllSelected ? Action.DESELECT_ALL : Action.SELECT_ALL);\n      } else {\n        menuList.push(isAllSelected ? Action.DESELECT_ALL : Action.SELECT_ALL);\n        menuList.push((new Boolean(selectedCount)) ? Action.DELETE : Action.DELETE_INVALID, Action.MORE);\n      }\n    } else {\n      if (this.albumId === MediaConstants.ALBUM_ID_RECYCLE && !isEmpty) {\n        menuList.push(Action.CLEAR_RECYCLE);\n      }\n    }\n    return menuList;\n  }\n}\n", "llm_cg": {"PhotoGridBarModel.createActionBar(title: Object, isSelectedMode: boolean, selectedCount: number, isAllSelected: boolean, isEmpty: boolean)": ["PhotoGridBarModel.updateHorizontalActionBar(actionBarProp: ActionBarProp, title: Object, isSelectedMode: boolean, selectedCount: number, isAllSelected: boolean, isEmpty: boolean)", "PhotoGridBarModel.updateVerticalActionBar(actionBarProp: ActionBarProp, title: Object, isSelectedMode: boolean)"], "PhotoGridBarModel.updateActionBar(actionBarProp: ActionBarProp, title: Object, isSelectedMode: boolean, selectedCount: number, isAllSelected: boolean, isEmpty: boolean)": ["PhotoGridBarModel.updateHorizontalActionBar(actionBarProp: ActionBarProp, title: Object, isSelectedMode: boolean, selectedCount: number, isAllSelected: boolean, isEmpty: boolean)", "PhotoGridBarModel.updateVerticalActionBar(actionBarProp: ActionBarProp, title: Object, isSelectedMode: boolean)"], "PhotoGridBarModel.updateHorizontalActionBar(actionBarProp: ActionBarProp, title: Object, isSelectedMode: boolean, selectedCount: number, isAllSelected: boolean, isEmpty: boolean)": ["PhotoGridBarModel.getMenuList(isSelectedMode: boolean, selectedCount: number, isAllSelected: boolean, isEmpty: boolean)"], "PhotoGridBarModel.updateVerticalActionBar(actionBarProp: ActionBarProp, title: Object, isSelectedMode: boolean)": [], "PhotoGridBarModel.getMenuList(isSelectedMode: boolean, selectedCount: number, isAllSelected: boolean, isEmpty: boolean)": []}, "static_cg": {"@test/75.ts: PhotoGridBarModel.createActionBar(Object, boolean, number, boolean, boolean)": ["@test/75.ts: PhotoGridBarModel.updateHorizontalActionBar(ActionBarProp, Object, boolean, number, boolean, boolean)", "@test/75.ts: PhotoGridBarModel.updateVerticalActionBar(ActionBarProp, Object, boolean)"], "@test/75.ts: PhotoGridBarModel.updateActionBar(ActionBarProp, Object, boolean, number, boolean, boolean)": ["@test/75.ts: PhotoGridBarModel.updateHorizontalActionBar(ActionBarProp, Object, boolean, number, boolean, boolean)", "@test/75.ts: PhotoGridBarModel.updateVerticalActionBar(ActionBarProp, Object, boolean)"], "@test/75.ts: PhotoGridBarModel.updateHorizontalActionBar(ActionBarProp, Object, boolean, number, boolean, boolean)": ["@test/75.ts: PhotoGridBarModel.getMenuList(boolean, number, boolean, boolean)"]}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport class MediaOperationType {\n  static readonly Move = 'Media_move';\n  static readonly Delete = 'Media_delete';\n  static readonly Recover = 'Media_recover';\n}", "llm_cg": {"MediaOperationType.Move": [], "MediaOperationType.Delete": [], "MediaOperationType.Recover": []}, "static_cg": {}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Action } from './Action'\nimport { ActionBarProp } from '../common/ActionBarProp'\nimport { ActionBarMode, ActionBarSelectionMode } from './ActionBarMode'\n\nexport class AlbumSelectBarModel {\n  createActionBar(): ActionBarProp {\n    let actionBarProp: ActionBarProp = new ActionBarProp();\n    actionBarProp\n      .setLeftAction(Action.CANCEL)\n      .setMode(ActionBarMode.STANDARD_MODE)\n      .setSelectionMode(ActionBarSelectionMode.SINGLE)\n      .setTitle($r('app.string.title_select_photos'));\n    return actionBarProp;\n  }\n}", "llm_cg": {"AlbumSelectBarModel.createActionBar()": ["ActionBarProp.setLeftAction(Action)", "ActionBarProp.setMode(ActionBarMode)", "ActionBarProp.setSelectionMode(ActionBarSelectionMode)", "ActionBarProp.setTitle(string)"]}, "static_cg": {}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport enum ViewType {\n  GROUP_TITLE,\n  ITEM,\n}", "llm_cg": {}, "static_cg": {}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport class QueryConstants {\n  static readonly ALBUM_COPY_FIRST_PAGE_QUERY_LENGTH = 12;\n}", "llm_cg": {"QueryConstants.ALBUM_COPY_FIRST_PAGE_QUERY_LENGTH": []}, "static_cg": {}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport class AnimationConstants {\n  static readonly SHARE_TRANSITION_DURATION = 200;\n  static readonly DELETE_ANIMATE_DURATION: number = 150;\n  // Press animation duration\n  static readonly PRESS_ANIM_DURATION = 100;\n  // Press to scale the value at the end of the animation\n  static readonly PRESS_ANIM_SCALE = 0.9;\n}", "llm_cg": {"AnimationConstants.SHARE_TRANSITION_DURATION": [], "AnimationConstants.DELETE_ANIMATE_DURATION": [], "AnimationConstants.PRESS_ANIM_DURATION": [], "AnimationConstants.PRESS_ANIM_SCALE": []}, "static_cg": {}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport deviceInfo from '@ohos.deviceInfo';\n\nenum EntryForm {\n  NORMAL = 0,\n  CAMERA = 1,\n  SINGLE_SELECT = 2,\n  MULTIPLE_SELECT = 3,\n  RECYCLE = 4,\n  CARD = 6,\n  VIEW_DATA = 7\n}\n\nexport class Constants {\n  // illegal value\n  static readonly INVALID = -1;\n\n  // Index of and other operations, the index returned when it is not found\n  static readonly NOT_FOUND = -1;\n\n  // delay 1s\n  static readonly DELAY_ONE_SECOND = 1000;\n\n  // delay 500ms\n  static readonly DELAY_HALF_SECOND = 500;\n\n  // delay 250ms\n  static readonly DELAY_QUARTER_SECOND = 250;\n\n  // delay 100ms\n  static readonly DELAY_TENTH_SECOND = 100;\n\n  // delay 50ms\n  static readonly DELAY_TWENTIETH_SECOND = 50;\n\n  // Default sliding window size\n  static readonly DEFAULT_SLIDING_WIN_SIZE = 500;\n  static readonly DEFAULT_ROTATE_VALUE = 90;\n  static readonly ROTATE_AROUND = 360;\n  static readonly ANGLE_90 = 90;\n  static readonly ANGLE_270 = 270;\n\n  // Step size. When the last obtained data index deviates from the center of the current sliding window by more\n  // than this step, adjust the start and end of the window and re initiate the data request\n  static readonly STEP = 100;\n  static readonly KEY_VIEW_TYPE = 'type';\n  static readonly KEY_VIEW_DATA = 'data';\n  static readonly ActionBarHeight: number = 56;\n  static readonly APP_KEY_PHOTO_BROWSER = 'app_key_photo_browser';\n  static readonly APP_KEY_MENU_OPERATION_FACTORY = 'app_key_menu_operation_factory';\n  static readonly APP_KEY_MENU_MEDIA_OBSERVER = 'app_key_menu_media_observer';\n  static readonly APP_KEY_WORKER_MANAGER = 'app_key_worker_manager';\n  static readonly APP_KEY_SLIDE_SHOW = 'app_key_slide_show';\n  static readonly THIRD_SELECT_MANAGER = 'third_select_manager';\n  static readonly APP_KEY_STATUS_BAR_COLOR_CONTROLLER = 'app_key_status_bar_color_controller';\n  static readonly APP_KEY_NEW_ALBUM = 'app_key_new_album';\n  static readonly APP_KEY_NEW_ALBUM_TARGET = 'app_key_new_album_target';\n  static readonly APP_KEY_NEW_ALBUM_SELECTED = 'app_key_new_album_selected';\n  static readonly APP_KEY_INSTANCE_MEDIA_LIBRARY_ACCESS = 'app_key_instance_media_library_access';\n  static readonly FROM_DATA_STORE_UTIL = 'form_data_store_util';\n\n  // Broadcast\n  static readonly APP_KEY_EVENT_BUS = 'app_key_event_bus';\n  static readonly SCREEN_MANAGER = 'screen_manager';\n  static readonly PIXEL_MAP_MANAGER = 'pixel_map_manager';\n\n  // Load completion event\n  static readonly ON_LOADING_FINISHED = 'on_loading_finished';\n  static readonly FIRST_PATCH_LOAD_FINISH = 'first_patch_load_finish';\n\n  // Large jump source: timeline\n  static readonly PHOTO_TRANSITION_TIMELINE: string = 'TimelinePage';\n\n  // Large jump source: album\n  static readonly PHOTO_TRANSITION_ALBUM: string = 'PhotoGridPage';\n\n  // Large jump source: camera\n  static readonly PHOTO_TRANSITION_CAMERA: string = 'Camera';\n  static readonly PHOTO_TRANSITION_EDIT: string = 'EditPage';\n\n  // Timeline page index\n  static readonly TIMELINE_PAGE_INDEX: number = 0;\n\n  // Album page index\n  static readonly ALBUM_PAGE_INDEX: number = 1;\n  static readonly IMAGE_GIF = 'gif';\n  static readonly GRID_CACHE_ROW_COUNT: number = 4;\n\n  // Press animation duration\n  static readonly PRESS_ANIM_DURATION = 100;\n\n  // Press to scale the value at the end of the animation\n  static readonly PRESS_ANIM_SCALE = 0.9;\n\n  // Default maximum number of external selection pages\n  static readonly DEFAULT_MAX_THIRD_SELECT_COUNT: number = 50;\n\n  // Column flag\n  static readonly SCREEN_COLUMNS: string = 'screen_columns';\n  static readonly ADD_NOTES_MAX_LENGTH: number = 140;\n  static readonly RENAME_MAX_LENGTH: number = 82;\n  static readonly ENTRY_FROM_NONE = 0;\n  static readonly ENTRY_FROM_CAMERA = 1;\n  static readonly ENTRY_FROM_SINGLE_SELECT = 2;\n  static readonly ENTRY_FROM_MULTIPLE_SELECT = 3;\n  static readonly ENTRY_FROM_RECYCLE = 4;\n  static readonly ENTRY_FROM_NORMAL = 6;\n  static readonly ENTRY_FROM_FORM_ABILITY = 7;\n  static readonly ENTRY_FROM_FORM_FORM_EDITOR = 8;\n  static readonly ENTRY_FROM_VIEW_DATA = 9;\n  static readonly ENTRY_FROM_FORM_ABILITY_NONE = 12;\n  static readonly ENTRY_FROM = EntryForm;\n  static readonly DIALOG_BOTTOM_OFFSET: number = 48;\n\n  // Local tab index\n  static readonly LOCAL_TAB_INDEX: number = 0;\n\n  // Other equipment tab index\n  static readonly OTHER_EQUIPMENT_TAB_INDEX: number = 1;\n\n  //the constant for action of the want\n  static readonly ACTION_DELETE_DATA: string = 'ohos.want.action.deleteDialog';\n\n  // editor used\n  static readonly UPDATE_MENU = 'updateMenu';\n  static readonly UPDATE_DOODLE_STYLE = 'update_doodle_style';\n  static readonly ADJUST_PARAMS_VALUE_CHANGED = 'adjust_params_value_changed';\n  static readonly ADJUST_PARAMS_ID_CHANGED = 'adjust_params_id_changed';\n  static readonly IS_IMMERSIVE = 'is_immersive';\n  static readonly UPDATE_DOODLE_STROKE_STYLE = 'update_doodle_stroke_style';\n  static readonly PHOTO_EDITOR_MANAGER: string = 'photo_editor_manager';\n  static readonly PHOTO_EDITOR_EVENT_MANAGER: string = 'photo_editor_event_manager';\n  static readonly INTI_RULER: string = 'inti_ruler';\n  static readonly RULER_CHANGED: string = 'inti_ruler';\n  static readonly LABEL_STYLE_CHANGED: string = 'label_style_changed';\n  static readonly LABEL_TEXT_STYLE_CHANGED: string = 'label_text_style_changed';\n  static readonly LABEL_TEXT_COLOR_CHANGED: string = 'label_text_color_changed';\n  static readonly LABEL_GET_CLIP_RECT: string = 'label_get_clip_rect';\n  static readonly CROP_RESET_CLICKED: string = 'crop_reset_clicked';\n  static readonly IS_BIG_TEXT_SHOW: string = 'is_big_text_show';\n  static readonly RULER_BAR_INTI: string = 'ruler_bar_inti';\n  static readonly COLOR_SLIDER_CHANGED: string = 'color_slider_changed';\n  static readonly MOSAIC_STYLE_CHANGED: string = 'mosaic_style_changed';\n  static readonly LABEL_DELETE: string = 'label_delete';\n  static readonly UPDATE_LABEL_STYLE: string = 'update_label_style';\n  static readonly IS_LABEL_ACTIVE: string = 'is_label_active';\n  static readonly NOT_MAX_INDEX_CLICK_OF_LABEL: string = 'not_max_index_click_of_label';\n  static readonly IS_LABEL_MODE: string = 'is_label_mode';\n  static readonly RESET_LABEL_STYLE_INFO: string = 'reset_label_style_info';\n  static readonly UPDATE_TOUCH_EVENT: string = 'update_touch_event';\n  static readonly PHOTO_COLLAGE_MANAGER: string = 'photo_collage_manager';\n  static readonly RETURN_TO_MAIN: string = 'return_to_main';\n  static readonly NEGATIVE_FORTY: string = '-40.0°';\n  static readonly NEGATIVE_THIRTY: string = '-30.0°';\n  static readonly NEGATIVE_TWENTY: string = '-20.0°';\n  static readonly NEGATIVE_TEN: string = '-10.0°';\n  static readonly ZERO_STR: string = '0.0°';\n  static readonly POSITIVE_TEN: string = '10.0°';\n  static readonly POSITIVE_TWENTY: string = '20.0°';\n  static readonly POSITIVE_THIRTY: string = '30.0°';\n  static readonly POSITIVE_FORTY: string = '40.0°';\n  static readonly RULER_CONTEXT_FONT_10PX: string = '10px SimSun, Songti SC';\n  static readonly RULER_CONTEXT_FONT_20PX: string = '20px SimSun, Songti SC';\n  static readonly RULER_CONTEXT_FONT_30PX: string = '30px SimSun, Songti SC';\n  static readonly RULER_FILL_STYLE_100: string = '#FFFFFF';\n  static readonly RULER_FILL_STYLE_90: string = '#E5FFFFFF';\n  static readonly RULER_FILL_STYLE_40: string = '#66FFFFFF';\n  static readonly RULER_TEXT_ALIGN: string = 'center';\n\n  /**\n   * @deprecated\n   */\n  static readonly MEDIA_TYPE_IMAGE: string = 'image';\n  /**\n   * @deprecated\n   */\n  static readonly MEDIA_TYPE_VIDEO: string = 'video';\n  /**\n   * @deprecated\n   */\n  static readonly MEDIA_TYPE_ALBUM: string = 'album';\n  /**\n   * @deprecated\n   */\n  static readonly MEDIA_TYPE_DEVICE: string = 'device';\n  /**\n   * @deprecated\n   */\n  static readonly MEDIA_TYPE_REMOTE: string = 'remote';\n  static readonly DEVICE_STATE_ONLINE: string = 'online';\n  static readonly DEVICE_STATE_OFFLINE: string = 'offline';\n  static readonly DEVICE_STATE_CHANGE: string = 'change';\n  static readonly TOP_BAR_SIZE: number = 56;\n  static readonly TOOL_BAR_SIZE: number = 72;\n  static readonly BOTTOM_TOOL_BAR_SIZE: number = 196;\n  static readonly FILTER_BOTTOM_TOOL_BAR_SIZE: number = 232;\n  static readonly DEFAULT_WIDTH: number = 360;\n  static readonly RESET_SIZE: number = 20;\n  static readonly RESET_SIZE_HORIZONTAL: number = 48;\n  static readonly TIMEOUT: number = 50;\n  static readonly PADDING_VERTICAL: number = 140;\n  static readonly PADDING_HORIZONTAL: number = 160;\n  static readonly MID_LINE_WIDTH: number = 1.5;\n  static readonly MID_LINE_HEIGHT: number = 20;\n  static readonly RULER_LINE_WIDTH: number = 1;\n  static readonly NEGATIVE_1: number = -1;\n  static readonly NEGATIVE_2: number = -2;\n  static readonly NUMBER_1: number = 1;\n  static readonly NUMBER_2: number = 2;\n  static readonly NUMBER_3: number = 3;\n  static readonly NUMBER_4: number = 4;\n  static readonly NUMBER_5: number = 5;\n  static readonly NUMBER_5_5: number = 5.5;\n  static readonly NUMBER_6: number = 6;\n  static readonly NUMBER_6_5: number = 6.5;\n  static readonly NUMBER_7: number = 7;\n  static readonly NUMBER_7_5: number = 7.5;\n  static readonly NUMBER_8: number = 8;\n  static readonly NUMBER_8_5: number = 8.5;\n  static readonly NUMBER_9: number = 9;\n  static readonly NUMBER_9_5: number = 9.5;\n  static readonly NUMBER_10: number = 10;\n  static readonly NUMBER_10_5: number = 10.5;\n  static readonly NUMBER_11_5: number = 11.5;\n  static readonly NUMBER_15: number = 15;\n  static readonly EDGE_ANGLE: number = 45;\n  static readonly LITTLE_CANVAS_SIZE: number = 60;\n  static readonly NUMBER_40: number = 40;\n  static readonly NUMBER_30: number = 30;\n  static readonly NUMBER_20: number = 20;\n  static readonly NUMBER_0: number = 0;\n\n  // Grid Constants\n  static readonly TAB_BAR_WIDTH: number = 96;\n  static readonly ACTION_BAR_HEIGHT: number = 56;\n  static readonly GRID_GUTTER: number = 2;\n  static readonly GRID_IMAGE_SIZE: number = 128;\n  static readonly GRID_MAX_SIZE_RATIO: number = 1.2;\n  static readonly TIME_GRID_MAX_SIZE_RATIO: number = 1.5;\n  static readonly GRID_MIN_COUNT: number = 2;\n  static readonly SCROLL_BAR_SIDE_MIN_GAP: number = 12;\n  static readonly SCROLL_MARGIN: number = 24;\n  static readonly SCROLL_BAR_VISIBLE_THRESHOLD: number = deviceInfo.deviceType === 'phone' || deviceInfo.deviceType === 'default' ? 7 : 9;\n  static readonly GRID_SCROLL_BAR_VISIBLE_THRESHOLD: number = deviceInfo.deviceType === 'phone' || deviceInfo.deviceType === 'default' ? 7 : 13;\n\n  // Album Card Constants\n  static readonly CARD_ASPECT_RATIO: number = 0.75;\n  static readonly ALBUM_SET_NEW_ICON_SIZE: number = 22;\n  static readonly ALBUM_SET_NEW_ICON_MARGIN: number = 8;\n  static readonly ALBUM_SET_MARGIN: number = 24;\n  static readonly ALBUM_SET_GUTTER: number = 12;\n  static readonly ALBUM_SET_COVER_SIZE: number = 220;\n\n  // System Resource Constants\n  static readonly TEXT_SIZE_SUB_TITLE1: number = 18; // ohos_id_text_size_sub_title1\n  static readonly TEXT_SIZE_BODY2: number = 14; // ohos_id_text_size_body2\n  static readonly TEXT_SIZE_SUB_TITLE2: number = 16; // ohos_id_text_size_sub_title2\n\n  // Empty Page\n  static readonly EMPTY_PAGE_OFFSET_RADIO: number = 0.4;\n  static readonly EMPTY_PAGE_DEFAULT_OFFSET: number = 300;\n  static readonly EMPTY_PAGE_MARGIN: number = 12;\n\n  // Dialog\n  static readonly DETAILS_DIALOG_PATH_MAX_LINE: number = 7;\n  static readonly DETAILS_DIALOG_NAME_MAX_LINE: number = 5;\n  static readonly PROGRESS_MAX: number = 100;\n  static readonly BYTE_TO_MB: number = 1024 * 1024;\n  static readonly BIG_SCREEN_WIDTH: number = 600;\n  static readonly BIG_EMPTY_ICON_SIZE: number = 160;\n  static readonly SMALL_EMPTY_ICON_SIZE: number = 120;\n  // Menu\n  static readonly MENU_DIVIDER_STROKE_WIDTH: number = 1;\n\n  // Duration\n  static readonly SHARE_TRANSITION_DURATION: number = 200;\n  static readonly DELETE_ANIMATE_DURATION: number = 150;\n\n  // Percent\n  static readonly PERCENT_HUNDRED: number = 100;\n  static readonly PERCENT_ONE_THIRD: string = (100 / 3) + '%';\n\n  // AppStorage constants\n  static readonly ENTRY_FROM_HAP: string = 'entryFromHap';\n  static readonly FROM_ALBUM_ID: string = 'form_albumId';\n  static readonly FROM_CURRENT_INDEX: string = 'form_currentIndex';\n  static readonly FA_SETTING_FROM_ID: string = 'FASetting_FormId';\n  static readonly VIEW_DATA_URI: string = 'viewDataUri';\n  static readonly VIEW_DATA_POS: string = 'viewDataPos';\n\n  static readonly FORM_ITEM_NAME: string = 'form_itemName';\n  static readonly FORM_ITEM_ALBUM_ID: string = 'form_itemAlbumId';\n  static readonly FORM_ITEM_DISPLAY_NAME: string = 'form_itemDisplayName';\n  static readonly MAIN_WINDOW: string = 'mainWindow';\n  static readonly ACTION_URI_FORM_ABILITY: string = 'formAbility';\n  static readonly ACTION_URI_FORM_ABILITY_NONE: string = 'formAbilityNone';\n  static readonly PROGRESS_LENGTH_DIFF: number = 88;\n  static readonly ALBUM_NAME_MAX_LENGTH = 82;\n  static readonly BACK_FROM_FORM_DETAIL: string = 'back_from_form_detail';\n\n  // ApplictionInfo\n  static readonly BUNDLE_NAME: string = 'com.ohos.photos';\n\n  // get want info with key\n  static readonly KEY_WANT_PARAMETERS_CALLER_BUNDLE_NAME: string = 'ohos.aafwk.param.callerBundleName';\n  static readonly KEY_WANT_PARAMETERS_CALLERUID: string = 'ohos.aafwk.param.callerUid';\n\n  // camera mainAbility\n  static readonly CAMERA_TYPE_CAPTURE: string = 'capture';\n\n  // camera mainAbility\n  static readonly CAMERA_TYPE_VIDEO: string = 'video';\n\n  // camera bundleName\n  static readonly CAMERA_BUNDLE_NAME: string = 'com.ohos.camera';\n\n  // camera mainAbility\n  static readonly CAMERA_MAIN_ABILITY: string = 'com.ohos.camera.MainAbility';\n\n  // maximum number limit of external selection pages\n  static readonly LIMIT_MAX_THIRD_SELECT_COUNT: number = 500;\n\n  static readonly DEFAULT_DIVIDER_COLOR: string = 'rgb(207, 195, 195)';\n  static readonly DEFAULT_DIVIDER_HEIGHT: string = '24vp';\n  static readonly NAME_PATTERN: RegExp = /[\\\\.\\\\\\\\/:*?\"'`<>|\\[\\]{}]/;\n}\n", "llm_cg": {"Constants.%AM0$INVALID": [], "Constants.%AM1$NOT_FOUND": [], "Constants.%AM2$DELAY_ONE_SECOND": [], "Constants.%AM3$DELAY_HALF_SECOND": [], "Constants.%AM4$DELAY_QUARTER_SECOND": [], "Constants.%AM5$DELAY_TENTH_SECOND": [], "Constants.%AM6$DELAY_TWENTIETH_SECOND": [], "Constants.%AM7$DEFAULT_SLIDING_WIN_SIZE": [], "Constants.%AM8$DEFAULT_ROTATE_VALUE": [], "Constants.%AM9$ROTATE_AROUND": [], "Constants.%AM10$ANGLE_90": [], "Constants.%AM11$ANGLE_270": [], "Constants.%AM12$STEP": [], "Constants.%AM13$KEY_VIEW_TYPE": [], "Constants.%AM14$KEY_VIEW_DATA": [], "Constants.%AM15$ActionBarHeight": [], "Constants.%AM16$APP_KEY_PHOTO_BROWSER": [], "Constants.%AM17$APP_KEY_MENU_OPERATION_FACTORY": [], "Constants.%AM18$APP_KEY_MENU_MEDIA_OBSERVER": [], "Constants.%AM19$APP_KEY_WORKER_MANAGER": [], "Constants.%AM20$APP_KEY_SLIDE_SHOW": [], "Constants.%AM21$THIRD_SELECT_MANAGER": [], "Constants.%AM22$APP_KEY_STATUS_BAR_COLOR_CONTROLLER": [], "Constants.%AM23$APP_KEY_NEW_ALBUM": [], "Constants.%AM24$APP_KEY_NEW_ALBUM_TARGET": [], "Constants.%AM25$APP_KEY_NEW_ALBUM_SELECTED": [], "Constants.%AM26$APP_KEY_INSTANCE_MEDIA_LIBRARY_ACCESS": [], "Constants.%AM27$FROM_DATA_STORE_UTIL": [], "Constants.%AM28$APP_KEY_EVENT_BUS": [], "Constants.%AM29$SCREEN_MANAGER": [], "Constants.%AM30$PIXEL_MAP_MANAGER": [], "Constants.%AM31$ON_LOADING_FINISHED": [], "Constants.%AM32$FIRST_PATCH_LOAD_FINISH": [], "Constants.%AM33$PHOTO_TRANSITION_TIMELINE": [], "Constants.%AM34$PHOTO_TRANSITION_ALBUM": [], "Constants.%AM35$PHOTO_TRANSITION_CAMERA": [], "Constants.%AM36$PHOTO_TRANSITION_EDIT": [], "Constants.%AM37$TIMELINE_PAGE_INDEX": [], "Constants.%AM38$ALBUM_PAGE_INDEX": [], "Constants.%AM39$IMAGE_GIF": [], "Constants.%AM40$GRID_CACHE_ROW_COUNT": [], "Constants.%AM41$PRESS_ANIM_DURATION": [], "Constants.%AM42$PRESS_ANIM_SCALE": [], "Constants.%AM43$DEFAULT_MAX_THIRD_SELECT_COUNT": [], "Constants.%AM44$SCREEN_COLUMNS": [], "Constants.%AM45$ADD_NOTES_MAX_LENGTH": [], "Constants.%AM46$RENAME_MAX_LENGTH": [], "Constants.%AM47$ENTRY_FROM_NONE": [], "Constants.%AM48$ENTRY_FROM_CAMERA": [], "Constants.%AM49$ENTRY_FROM_SINGLE_SELECT": [], "Constants.%AM50$ENTRY_FROM_MULTIPLE_SELECT": [], "Constants.%AM51$ENTRY_FROM_RECYCLE": [], "Constants.%AM52$ENTRY_FROM_NORMAL": [], "Constants.%AM53$ENTRY_FROM_FORM_ABILITY": [], "Constants.%AM54$ENTRY_FROM_FORM_FORM_EDITOR": [], "Constants.%AM55$ENTRY_FROM_VIEW_DATA": [], "Constants.%AM56$ENTRY_FROM_FORM_ABILITY_NONE": [], "Constants.%AM57$ENTRY_FROM": [], "Constants.%AM58$DIALOG_BOTTOM_OFFSET": [], "Constants.%AM59$LOCAL_TAB_INDEX": [], "Constants.%AM60$OTHER_EQUIPMENT_TAB_INDEX": [], "Constants.%AM61$ACTION_DELETE_DATA": [], "Constants.%AM62$UPDATE_MENU": [], "Constants.%AM63$UPDATE_DOODLE_STYLE": [], "Constants.%AM64$ADJUST_PARAMS_VALUE_CHANGED": [], "Constants.%AM65$ADJUST_PARAMS_ID_CHANGED": [], "Constants.%AM66$IS_IMMERSIVE": [], "Constants.%AM67$UPDATE_DOODLE_STROKE_STYLE": [], "Constants.%AM68$PHOTO_EDITOR_MANAGER": [], "Constants.%AM69$PHOTO_EDITOR_EVENT_MANAGER": [], "Constants.%AM70$INTI_RULER": [], "Constants.%AM71$RULER_CHANGED": [], "Constants.%AM72$LABEL_STYLE_CHANGED": [], "Constants.%AM73$LABEL_TEXT_STYLE_CHANGED": [], "Constants.%AM74$LABEL_TEXT_COLOR_CHANGED": [], "Constants.%AM75$LABEL_GET_CLIP_RECT": [], "Constants.%AM76$CROP_RESET_CLICKED": [], "Constants.%AM77$IS_BIG_TEXT_SHOW": [], "Constants.%AM78$RULER_BAR_INTI": [], "Constants.%AM79$COLOR_SLIDER_CHANGED": [], "Constants.%AM80$MOSAIC_STYLE_CHANGED": [], "Constants.%AM81$LABEL_DELETE": [], "Constants.%AM82$UPDATE_LABEL_STYLE": [], "Constants.%AM83$IS_LABEL_ACTIVE": [], "Constants.%AM84$NOT_MAX_INDEX_CLICK_OF_LABEL": [], "Constants.%AM85$IS_LABEL_MODE": [], "Constants.%AM86$RESET_LABEL_STYLE_INFO": [], "Constants.%AM87$UPDATE_TOUCH_EVENT": [], "Constants.%AM88$PHOTO_COLLAGE_MANAGER": [], "Constants.%AM89$RETURN_TO_MAIN": [], "Constants.%AM90$NEGATIVE_FORTY": [], "Constants.%AM91$NEGATIVE_THIRTY": [], "Constants.%AM92$NEGATIVE_TWENTY": [], "Constants.%AM93$NEGATIVE_TEN": [], "Constants.%AM94$ZERO_STR": [], "Constants.%AM95$POSITIVE_TEN": [], "Constants.%AM96$POSITIVE_TWENTY": [], "Constants.%AM97$POSITIVE_THIRTY": [], "Constants.%AM98$POSITIVE_FORTY": [], "Constants.%AM99$RULER_CONTEXT_FONT_10PX": [], "Constants.%AM100$RULER_CONTEXT_FONT_20PX": [], "Constants.%AM101$RULER_CONTEXT_FONT_30PX": [], "Constants.%AM102$RULER_FILL_STYLE_100": [], "Constants.%AM103$RULER_FILL_STYLE_90": [], "Constants.%AM104$RULER_FILL_STYLE_40": [], "Constants.%AM105$RULER_TEXT_ALIGN": [], "Constants.%AM106$MEDIA_TYPE_IMAGE": [], "Constants.%AM107$MEDIA_TYPE_VIDEO": [], "Constants.%AM108$MEDIA_TYPE_ALBUM": [], "Constants.%AM109$MEDIA_TYPE_DEVICE": [], "Constants.%AM110$MEDIA_TYPE_REMOTE": [], "Constants.%AM111$DEVICE_STATE_ONLINE": [], "Constants.%AM112$DEVICE_STATE_OFFLINE": [], "Constants.%AM113$DEVICE_STATE_CHANGE": [], "Constants.%AM114$TOP_BAR_SIZE": [], "Constants.%AM115$TOOL_BAR_SIZE": [], "Constants.%AM116$BOTTOM_TOOL_BAR_SIZE": [], "Constants.%AM117$FILTER_BOTTOM_TOOL_BAR_SIZE": [], "Constants.%AM118$DEFAULT_WIDTH": [], "Constants.%AM119$RESET_SIZE": [], "Constants.%AM120$RESET_SIZE_HORIZONTAL": [], "Constants.%AM121$TIMEOUT": [], "Constants.%AM122$PADDING_VERTICAL": [], "Constants.%AM123$PADDING_HORIZONTAL": [], "Constants.%AM124$MID_LINE_WIDTH": [], "Constants.%AM125$MID_LINE_HEIGHT": [], "Constants.%AM126$RULER_LINE_WIDTH": [], "Constants.%AM127$NEGATIVE_1": [], "Constants.%AM128$NEGATIVE_2": [], "Constants.%AM129$NUMBER_1": [], "Constants.%AM130$NUMBER_2": [], "Constants.%AM131$NUMBER_3": [], "Constants.%AM132$NUMBER_4": [], "Constants.%AM133$NUMBER_5": [], "Constants.%AM134$NUMBER_5_5": [], "Constants.%AM135$NUMBER_6": [], "Constants.%AM136$NUMBER_6_5": [], "Constants.%AM137$NUMBER_7": [], "Constants.%AM138$NUMBER_7_5": [], "Constants.%AM139$NUMBER_8": [], "Constants.%AM140$NUMBER_8_5": [], "Constants.%AM141$NUMBER_9": [], "Constants.%AM142$NUMBER_9_5": [], "Constants.%AM143$NUMBER_10": [], "Constants.%AM144$NUMBER_10_5": [], "Constants.%AM145$NUMBER_11_5": [], "Constants.%AM146$NUMBER_15": [], "Constants.%AM147$EDGE_ANGLE": [], "Constants.%AM148$LITTLE_CANVAS_SIZE": [], "Constants.%AM149$NUMBER_40": [], "Constants.%AM150$NUMBER_30": [], "Constants.%AM151$NUMBER_20": [], "Constants.%AM152$NUMBER_0": [], "Constants.%AM153$TAB_BAR_WIDTH": [], "Constants.%AM154$ACTION_BAR_HEIGHT": [], "Constants.%AM155$GRID_GUTTER": [], "Constants.%AM156$GRID_IMAGE_SIZE": [], "Constants.%AM157$GRID_MAX_SIZE_RATIO": [], "Constants.%AM158$TIME_GRID_MAX_SIZE_RATIO": [], "Constants.%AM159$GRID_MIN_COUNT": [], "Constants.%AM160$SCROLL_BAR_SIDE_MIN_GAP": [], "Constants.%AM161$SCROLL_MARGIN": [], "Constants.%AM162$SCROLL_BAR_VISIBLE_THRESHOLD": [], "Constants.%AM163$GRID_SCROLL_BAR_VISIBLE_THRESHOLD": [], "Constants.%AM164$CARD_ASPECT_RATIO": [], "Constants.%AM165$ALBUM_SET_NEW_ICON_SIZE": [], "Constants.%AM166$ALBUM_SET_NEW_ICON_MARGIN": [], "Constants.%AM167$ALBUM_SET_MARGIN": [], "Constants.%AM168$ALBUM_SET_GUTTER": [], "Constants.%AM169$ALBUM_SET_COVER_SIZE": [], "Constants.%AM170$TEXT_SIZE_SUB_TITLE1": [], "Constants.%AM171$TEXT_SIZE_BODY2": [], "Constants.%AM172$TEXT_SIZE_SUB_TITLE2": [], "Constants.%AM173$EMPTY_PAGE_OFFSET_RADIO": [], "Constants.%AM174$EMPTY_PAGE_DEFAULT_OFFSET": [], "Constants.%AM175$EMPTY_PAGE_MARGIN": [], "Constants.%AM176$DETAILS_DIALOG_PATH_MAX_LINE": [], "Constants.%AM177$DETAILS_DIALOG_NAME_MAX_LINE": [], "Constants.%AM178$PROGRESS_MAX": [], "Constants.%AM179$BYTE_TO_MB": [], "Constants.%AM180$BIG_SCREEN_WIDTH": [], "Constants.%AM181$BIG_EMPTY_ICON_SIZE": [], "Constants.%AM182$SMALL_EMPTY_ICON_SIZE": [], "Constants.%AM183$MENU_DIVIDER_STROKE_WIDTH": [], "Constants.%AM184$SHARE_TRANSITION_DURATION": [], "Constants.%AM185$DELETE_ANIMATE_DURATION": [], "Constants.%AM186$PERCENT_HUNDRED": [], "Constants.%AM187$PERCENT_ONE_THIRD": [], "Constants.%AM188$ENTRY_FROM_HAP": [], "Constants.%AM189$FROM_ALBUM_ID": [], "Constants.%AM190$FROM_CURRENT_INDEX": [], "Constants.%AM191$FA_SETTING_FROM_ID": [], "Constants.%AM192$VIEW_DATA_URI": [], "Constants.%AM193$VIEW_DATA_POS": [], "Constants.%AM194$FORM_ITEM_NAME": [], "Constants.%AM195$FORM_ITEM_ALBUM_ID": [], "Constants.%AM196$FORM_ITEM_DISPLAY_NAME": [], "Constants.%AM197$MAIN_WINDOW": [], "Constants.%AM198$ACTION_URI_FORM_ABILITY": [], "Constants.%AM199$ACTION_URI_FORM_ABILITY_NONE": [], "Constants.%AM200$PROGRESS_LENGTH_DIFF": [], "Constants.%AM201$ALBUM_NAME_MAX_LENGTH": [], "Constants.%AM202$BACK_FROM_FORM_DETAIL": [], "Constants.%AM203$BUNDLE_NAME": [], "Constants.%AM204$KEY_WANT_PARAMETERS_CALLER_BUNDLE_NAME": [], "Constants.%AM205$KEY_WANT_PARAMETERS_CALLERUID": [], "Constants.%AM206$CAMERA_TYPE_CAPTURE": [], "Constants.%AM207$CAMERA_TYPE_VIDEO": [], "Constants.%AM208$CAMERA_BUNDLE_NAME": [], "Constants.%AM209$CAMERA_MAIN_ABILITY": [], "Constants.%AM210$LIMIT_MAX_THIRD_SELECT_COUNT": [], "Constants.%AM211$DEFAULT_DIVIDER_COLOR": [], "Constants.%AM212$DEFAULT_DIVIDER_HEIGHT": [], "Constants.%AM213$NAME_PATTERN": []}, "static_cg": {}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport photoAccessHelper from '@ohos.file.photoAccessHelper';\n\nexport class MediaConstants {\n  // Media item status\n  static readonly UNDEFINED = 0;\n  static readonly PART_LOADED = 1\n  static readonly LOADED = 2;\n  static readonly TRASHED = 3;\n  // Media type\n  static readonly MEDIA_TYPE_IMAGE: string = 'image';\n  static readonly MEDIA_TYPE_VIDEO: string = 'video';\n  static readonly MEDIA_TYPE_ALBUM: string = 'album';\n  static readonly MEDIA_TYPE_DEVICE: string = 'device';\n  static readonly MEDIA_TYPE_REMOTE: string = 'remote';\n\n  static readonly DEVICE_STATE_ONLINE: string = 'online';\n  static readonly DEVICE_STATE_OFFLINE: string = 'offline';\n  static readonly DEVICE_STATE_CHANGE: string = 'change';\n  static readonly ROTATE_NONE = 0;\n  static readonly ROTATE_ONCE = 90;\n  static readonly ROTATE_TWICE = 180;\n  static readonly ROTATE_THIRD = 270;\n  static readonly ROTATE_AROUND = 360;\n  static readonly DEFAULT_SIZE = 256;\n  static readonly DEFAULT_THUMBNAIL_SIZE = 1920;\n  // select type\n  static readonly SELECT_TYPE_ALL = 0;\n  static readonly SELECT_TYPE_VIDEO = 1;\n  static readonly SELECT_TYPE_IMAGE = 2;\n  //album type\n  static readonly ALBUM_TYPE_ALL = -1;\n  static readonly ABSTRACT_ALBUM_TYPE_MOVING_PHOTO = -2;\n  static readonly ALBUM_TYPE_USER = photoAccessHelper.AlbumType.USER;\n  static readonly ALBUM_TYPE_SYSTEM = photoAccessHelper.AlbumType.SYSTEM;\n  // album subtype\n  static readonly ALBUM_SUBTYPE_ALL = photoAccessHelper.AlbumSubtype.ANY\n  static readonly ALBUM_SUBTYPE_CAMERA = photoAccessHelper.AlbumSubtype.CAMERA;\n  static readonly ALBUM_SUBTYPE_VIDEO = photoAccessHelper.AlbumSubtype.VIDEO;\n  static readonly ALBUM_SUBTYPE_RECYCLE = photoAccessHelper.AlbumSubtype.TRASH;\n  static readonly ALBUM_SUBTYPE_FAVOR = photoAccessHelper.AlbumSubtype.FAVORITE;\n  static readonly ALBUM_SUBTYPE_SNAPSHOT = photoAccessHelper.AlbumSubtype.SCREENSHOT;\n  static readonly ALBUM_SUBTYPE_HIDDEN = photoAccessHelper.AlbumSubtype.HIDDEN;\n  static readonly ALBUM_SUBTYPE_USER_GENERIC = photoAccessHelper.AlbumSubtype.USER_GENERIC;\n  static readonly ALBUM_SUBTYPE_REMOTE = -1;\n  // album id\n  static readonly ALBUM_ID_USER = 'default_user';\n  static readonly ALBUM_ID_ALL = 'default_all';\n  static readonly ALBUM_ID_HIDDEN = 'default_hidden';\n  static readonly ALBUM_ID_CAMERA = 'default_camera';\n  static readonly ALBUM_ID_VIDEO = 'default_video';\n  static readonly ALBUM_ID_RECYCLE = 'default_recycle';\n  static readonly ALBUM_ID_FAVOR = 'default_favor';\n  static readonly ALBUM_ID_SNAPSHOT = 'default_snapshot';\n  static readonly ALBUM_ID_REMOTE = 'default_remote';\n  static readonly ALBUM_ID_MOVING_PHOTO = 'default_moving_photo';\n  static readonly ALBUM_DISABLE_COPY_LIST: Set<string> = new Set<string>([\n  MediaConstants.ALBUM_ID_ALL,\n  MediaConstants.ALBUM_ID_VIDEO,\n  MediaConstants.ALBUM_ID_RECYCLE,\n  MediaConstants.ALBUM_ID_FAVOR,\n  MediaConstants.ALBUM_ID_CAMERA,\n  MediaConstants.ALBUM_ID_SNAPSHOT,\n  MediaConstants.ALBUM_ID_MOVING_PHOTO\n  ] as string[]);\n  static readonly ALBUM_DISABLE_DELETE_LIST: Set<string> = new Set<string>([\n  MediaConstants.ALBUM_ID_ALL,\n  MediaConstants.ALBUM_ID_CAMERA,\n  MediaConstants.ALBUM_ID_VIDEO,\n  MediaConstants.ALBUM_ID_RECYCLE,\n  MediaConstants.ALBUM_ID_FAVOR,\n  MediaConstants.ALBUM_ID_SNAPSHOT,\n  MediaConstants.ALBUM_ID_MOVING_PHOTO\n  ] as string[]);\n  static readonly ALBUM_DISABLE_NEW_LIST: Set<string> = new Set<string>([\n  MediaConstants.ALBUM_ID_ALL,\n  MediaConstants.ALBUM_ID_CAMERA,\n  MediaConstants.ALBUM_ID_VIDEO,\n  MediaConstants.ALBUM_ID_RECYCLE,\n  MediaConstants.ALBUM_ID_FAVOR,\n  MediaConstants.ALBUM_ID_SNAPSHOT,\n  MediaConstants.ALBUM_ID_MOVING_PHOTO\n  ] as string[]);\n  static readonly ALBUM_DISABLE_RENAME_LIST: Set<string> = new Set<string>([\n  MediaConstants.ALBUM_ID_ALL,\n  MediaConstants.ALBUM_ID_CAMERA,\n  MediaConstants.ALBUM_ID_VIDEO,\n  MediaConstants.ALBUM_ID_RECYCLE,\n  MediaConstants.ALBUM_ID_FAVOR,\n  MediaConstants.ALBUM_ID_SNAPSHOT,\n  MediaConstants.ALBUM_ID_MOVING_PHOTO\n  ] as string[]);\n  static readonly ALBUM_DEFAULT_SORT_LIST: string[] = [\n  MediaConstants.ALBUM_ID_ALL,\n  MediaConstants.ALBUM_ID_CAMERA,\n  MediaConstants.ALBUM_ID_VIDEO,\n  MediaConstants.ALBUM_ID_SNAPSHOT,\n  MediaConstants.ALBUM_ID_MOVING_PHOTO,\n  MediaConstants.ALBUM_ID_FAVOR\n  ];\n  static readonly CAMERA_ALBUM_PATH = 'Camera'\n  static readonly REMOTE_ALBUM_PATH = 'FromOtherDevices'\n  static readonly SNAPSHOT_ALBUM_PATH = 'Screenshots'\n  static readonly PHOTO_SUBTYPE = photoAccessHelper.PhotoKeys.PHOTO_SUBTYPE.toString();\n  static readonly MOVING_PHOTO = photoAccessHelper.PhotoSubtype.MOVING_PHOTO;\n\n  // 需要过滤的媒体文件类型\n  static readonly FILTER_MEDIA_TYPE_ALL: string = 'FILTER_MEDIA_TYPE_ALL';\n  static readonly FILTER_MEDIA_TYPE_IMAGE: string = 'FILTER_MEDIA_TYPE_IMAGE';\n  static readonly FILTER_MEDIA_TYPE_VIDEO: string = 'FILTER_MEDIA_TYPE_VIDEO';\n  //TODO delete\n  static readonly DIR_CAMERA = 0\n  static readonly DIR_VIDEO = 1\n  static readonly DIR_IMAGE = 2\n  static readonly DIR_AUDIO = 3\n  static readonly DIR_DOCUMENTS = 4\n  static readonly DIR_DOWNLOAD = 5\n  static readonly EMPTY_FETCH_COLUMNS = []\n  static readonly FILE_ASSET_FETCH_COLUMNS = [photoAccessHelper.PhotoKeys.URI,\n  photoAccessHelper.PhotoKeys.PHOTO_TYPE,\n  photoAccessHelper.PhotoKeys.DISPLAY_NAME,\n  photoAccessHelper.PhotoKeys.SIZE,\n  photoAccessHelper.PhotoKeys.DATE_ADDED,\n  photoAccessHelper.PhotoKeys.DATE_MODIFIED,\n  photoAccessHelper.PhotoKeys.DURATION,\n  photoAccessHelper.PhotoKeys.WIDTH,\n  photoAccessHelper.PhotoKeys.HEIGHT,\n  photoAccessHelper.PhotoKeys.DATE_TAKEN,\n  photoAccessHelper.PhotoKeys.ORIENTATION,\n  photoAccessHelper.PhotoKeys.FAVORITE,\n  photoAccessHelper.PhotoKeys.TITLE,\n  photoAccessHelper.PhotoKeys.POSITION,\n  photoAccessHelper.PhotoKeys.DATE_TRASHED,\n  photoAccessHelper.PhotoKeys.HIDDEN]\n  static readonly ALBUM_ASSET_FETCH_COLUMNS = [photoAccessHelper.AlbumKeys.URI, photoAccessHelper.AlbumKeys.ALBUM_NAME]\n}", "llm_cg": {"MediaConstants.<static_initializer>": []}, "static_cg": {}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nenum EntryForm {\n  NORMAL = 0,\n  CAMERA = 1,\n  SINGLE_SELECT = 2,\n  MULTIPLE_SELECT = 3,\n  RECYCLE = 4,\n  DISTRIBUTED = 5,\n  CARD = 6,\n  VIEW_DATA = 7\n}\n\nexport class RouterConstants {\n  static readonly ENTRY_FROM_NONE = 0;\n  static readonly ENTRY_FROM_CAMERA = 1;\n  static readonly ENTRY_FROM_SINGLE_SELECT = 2;\n  static readonly ENTRY_FROM_MULTIPLE_SELECT = 3;\n  static readonly ENTRY_FROM_RECYCLE = 4;\n  static readonly ENTRY_FROM_DISTRIBUTED = 5;\n  static readonly ENTRY_FROM_NORMAL = 6;\n  static readonly ENTRY_FROM_FORM_ABILITY = 7;\n  static readonly ENTRY_FROM_FORM_FORM_EDITOR = 8;\n  static readonly ENTRY_FROM_VIEW_DATA = 9;\n  static readonly ENTRY_FROM_FORM_ABILITY_NONE = 12;\n  static readonly ENTRY_FROM = EntryForm;\n}", "llm_cg": {"RouterConstants.ENTRY_FROM": []}, "static_cg": {}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport class Constants {\n  // Immersive animation duration\n  static readonly IMMERSE_ANIM_DURATION = 300;\n\n  // click event\n  static readonly TOGGLE_BAR = 'single_photo_toggle_bar';\n\n  // hide bars\n  static readonly HIDE_BARS = 'single_photo_hide_bars';\n\n  // pull down to return start\n  static readonly PULL_DOWN_START = 'single_photo_pull_down_start';\n\n  // pull down to return end\n  static readonly PULL_DOWN_END = 'single_photo_pull_down_end';\n\n  // pull down to return cancel\n  static readonly PULL_DOWN_CANCEL = 'single_photo_pull_down_cancel';\n\n  // pull down to return threshold\n  static readonly PULL_DOWN_THRESHOLD = 200;\n\n  // touch event\n  static readonly TOUCH_EVENT = 'single_photo_touch_event';\n\n  // direction change event\n  static readonly DIRECTION_CHANGE = 'single_photo_direction_change';\n\n  // animation event\n  static readonly ANIMATION_EVENT = 'single_photo_animation_event';\n\n  // data quantity change\n  static readonly DATA_SIZE_CHANGED = 'photo_data_size_changed';\n\n  // current data change\n  static readonly DATA_CONTENT_CHANGED = 'photo_data_content_changed';\n\n  // video play\n  static readonly VIDEO_PLAY = 'single_photo_video_play';\n\n  // video pause\n  static readonly VIDEO_PAUSE = 'single_photo_video_pause';\n\n  // popup show\n  static readonly POP_APPEAR = 'single_photo_popup_appear';\n\n  // popup disappear\n  static readonly POP_DISAPPEAR = 'single_photo_popup_disappear';\n\n  // set favor photo\n  static readonly SET_FAVOR = 'single_photo_set_favor';\n\n  // rename photo\n  static readonly RENAME = 'single_photo_rename';\n\n  // rotate photo\n  static readonly ROTATE = 'single_photo_rotate';\n\n  // delete photo\n  static readonly DELETE = 'single_photo_delete';\n\n  // photo show state\n  static readonly PHOTO_SHOW_STATE = 'single_photo_show_state';\n\n  // set swiper can swipe\n  static readonly SET_DISABLE_SWIPE = 'set_disable_swipe';\n\n  // Scale lower limit\n  static readonly COMPONENT_SCALE_FLOOR = 0.5;\n\n  // scale upper limit\n  static readonly COMPONENT_SCALE_CEIL = 2.0;\n\n  // when the double-click scale is larger than maxScale, the maxScale is adjusted to 1.2 times the double-click scale\n  static readonly MAX_SCALE_EXTRA_FACTOR = 1.2;\n\n  // After reaching max scale, you can also scale an additional 0.2x max scale, and rebound after letting go\n  static readonly OVER_SCALE_EXTRA_FACTOR = 1.5;\n\n  // If the aspect ratio of the picture is the same as the display area,\n  // double-click to adjust the zoom factor to 4 / 3\n  static readonly SAME_RATIO_SCALE_FACTOR = 4 / 3;\n\n  // overScale animation duration\n  static readonly OVER_SCALE_ANIME_DURATION = 500;\n  static readonly SHARE_TRANSITION_DURATION = 200;\n  static readonly PAGE_SHOW_ANIMATION_DURATION = 200;\n  static readonly RESERVED_DIGITS = 6;\n  static readonly CENTER_DEFAULT = 0.5;\n  static readonly NUMBER_2 = 2;\n  static readonly NUMBER_3 = 3;\n  static readonly NUMBER_12 = 12;\n  static readonly NUMBER_13 = 13;\n  static readonly DEFAULT_TRANSITION_ID: string = 'default_id';\n}", "llm_cg": {"Constants.IMMERSE_ANIM_DURATION": [], "Constants.TOGGLE_BAR": [], "Constants.HIDE_BARS": [], "Constants.PULL_DOWN_START": [], "Constants.PULL_DOWN_END": [], "Constants.PULL_DOWN_CANCEL": [], "Constants.PULL_DOWN_THRESHOLD": [], "Constants.TOUCH_EVENT": [], "Constants.DIRECTION_CHANGE": [], "Constants.ANIMATION_EVENT": [], "Constants.DATA_SIZE_CHANGED": [], "Constants.DATA_CONTENT_CHANGED": [], "Constants.VIDEO_PLAY": [], "Constants.VIDEO_PAUSE": [], "Constants.POP_APPEAR": [], "Constants.POP_DISAPPEAR": [], "Constants.SET_FAVOR": [], "Constants.RENAME": [], "Constants.ROTATE": [], "Constants.DELETE": [], "Constants.PHOTO_SHOW_STATE": [], "Constants.SET_DISABLE_SWIPE": [], "Constants.COMPONENT_SCALE_FLOOR": [], "Constants.COMPONENT_SCALE_CEIL": [], "Constants.MAX_SCALE_EXTRA_FACTOR": [], "Constants.OVER_SCALE_EXTRA_FACTOR": [], "Constants.SAME_RATIO_SCALE_FACTOR": [], "Constants.OVER_SCALE_ANIME_DURATION": [], "Constants.SHARE_TRANSITION_DURATION": [], "Constants.PAGE_SHOW_ANIMATION_DURATION": [], "Constants.RESERVED_DIGITS": [], "Constants.CENTER_DEFAULT": [], "Constants.NUMBER_2": [], "Constants.NUMBER_3": [], "Constants.NUMBER_12": [], "Constants.NUMBER_13": [], "Constants.DEFAULT_TRANSITION_ID": []}, "static_cg": {}}
{"source_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport class BroadcastConstants {\n  static readonly DELETE_FROM_BROWSER: number = 0;\n  static readonly DELETE_FROM_GRID: number = 1;\n  static readonly SELECT = 'select';\n  static readonly GROUP_SELECT = 'groupSelect';\n  static readonly JUMP_PHOTO_BROWSER = 'JumpPhotoPage';\n  static readonly SHOW_DELETE_DIALOG = 'showDeleteDialog';\n  static readonly UPDATE_PROGRESS = 'updateProgress';\n  static readonly CANCEL_DELETE = 'cancelDelete';\n  static readonly JUMP_THIRD_PHOTO_BROWSER = 'jumpThirdPhotoPage';\n  static readonly BACK_PRESS_EVENT = 'back';\n  static readonly RESET_STATE_EVENT = 'resetState';\n  static readonly ON_TAB_CHANGED = 'onTabChanged';\n  static readonly RESET_ZERO = 'resetZero';\n  static readonly SHOW_DETAIL_DIALOG = 'showDetailDialog';\n  static readonly SHOW_THIRD_DELETE_DIALOG = 'showThirdDeleteDialog';\n  static readonly SHOW_MULTI_SELECT_DIALOG = 'showMultiSelectDialog';\n  static readonly UPDATE_DATA_SOURCE = 'updateDataSource';\n  static readonly SHOW_PROGRESS_DIALOG = 'showProgressDialog';\n  static readonly DELETE_PROGRESS_DIALOG = 'deleteProgressDialog';\n  static readonly CANCEL_OPERATE = 'cancelOperate';\n  static readonly MEDIA_OPERATION = 'mediaOperation';\n  static readonly OPERATE_CONTINUE = 'operateContinue';\n  static readonly OPERATE_PAUSE = 'operatePause';\n  static readonly SHOW_RENAME_PHOTO_DIALOG = 'showRenamePhotoDialog';\n  static readonly SHOW_SAVE_PHOTO_DIALOG = 'showSavePhotoDialog';\n  static readonly SHOW_EDIT_EXIT_PHOTO_DIALOG = 'showEditExitPhotoDialog';\n  static readonly SHOW_ADD_NOTES_PHOTO_DIALOG = 'showAddNotesPhotoDialog';\n  static readonly SHOW_NEW_ALBUM_PHOTO_DIALOG = 'showNewAlbumPhotoDialog';\n  static readonly SHOW_COPY_OR_MOVE_DIALOG = 'showCopyOrMoveDialog';\n  static readonly FIND_SAME_FILE_DIALOG = 'findSameFileDialog';\n  static readonly ON_REMOTE_CHANGED = 'on_remote_changed';\n  static readonly EXIT_SAVE_PROGRESS_CLOSE = 'save_progress_close';\n  static readonly SHOW_EDIT_SAVE_PROGRESS_DIALOG = 'show_exit_save_progress_dialog';\n  static readonly DOWNLOAD_CANCEL_OPERATE = 'download_cancel_operate';\n  static readonly ON_DATA_RELOADED = 'on_data_reloaded';\n  static readonly SAVE_FORM_EDITOR_DATA = 'save_form_editor_data';\n  static readonly INIT_DATE_TEXT = 'init_date_text';\n  static readonly THIRD_ROUTE_PAGE = 'third_route_page';\n  static readonly ON_DATA_RELOADED_WITH_EDIT = 'on_data_reloaded_with_edit';\n  static readonly PHOTO_EDIT_SAVE_COMPLETE: string = 'photo_edit_save_complete';\n  static readonly CHANGE_SWIPER_DURATION = 'change_swiper_duration';\n  // USED for AppStorage\n  static readonly LEFT_BLANK: string = 'leftBlank';\n  static readonly RESET_TAB_SELECTED_STATUE: string = 'reset_tab_selected_statue';\n  static readonly RESET_TAB_SELECTED_TEXT: string = 'reset_tab_selected_text';\n}", "llm_cg": {"BroadcastConstants.DELETE_FROM_BROWSER": [], "BroadcastConstants.DELETE_FROM_GRID": [], "BroadcastConstants.SELECT": [], "BroadcastConstants.GROUP_SELECT": [], "BroadcastConstants.JUMP_PHOTO_BROWSER": [], "BroadcastConstants.SHOW_DELETE_DIALOG": [], "BroadcastConstants.UPDATE_PROGRESS": [], "BroadcastConstants.CANCEL_DELETE": [], "BroadcastConstants.JUMP_THIRD_PHOTO_BROWSER": [], "BroadcastConstants.BACK_PRESS_EVENT": [], "BroadcastConstants.RESET_STATE_EVENT": [], "BroadcastConstants.ON_TAB_CHANGED": [], "BroadcastConstants.RESET_ZERO": [], "BroadcastConstants.SHOW_DETAIL_DIALOG": [], "BroadcastConstants.SHOW_THIRD_DELETE_DIALOG": [], "BroadcastConstants.SHOW_MULTI_SELECT_DIALOG": [], "BroadcastConstants.UPDATE_DATA_SOURCE": [], "BroadcastConstants.SHOW_PROGRESS_DIALOG": [], "BroadcastConstants.DELETE_PROGRESS_DIALOG": [], "BroadcastConstants.CANCEL_OPERATE": [], "BroadcastConstants.MEDIA_OPERATION": [], "BroadcastConstants.OPERATE_CONTINUE": [], "BroadcastConstants.OPERATE_PAUSE": [], "BroadcastConstants.SHOW_RENAME_PHOTO_DIALOG": [], "BroadcastConstants.SHOW_SAVE_PHOTO_DIALOG": [], "BroadcastConstants.SHOW_EDIT_EXIT_PHOTO_DIALOG": [], "BroadcastConstants.SHOW_ADD_NOTES_PHOTO_DIALOG": [], "BroadcastConstants.SHOW_NEW_ALBUM_PHOTO_DIALOG": [], "BroadcastConstants.SHOW_COPY_OR_MOVE_DIALOG": [], "BroadcastConstants.FIND_SAME_FILE_DIALOG": [], "BroadcastConstants.ON_REMOTE_CHANGED": [], "BroadcastConstants.EXIT_SAVE_PROGRESS_CLOSE": [], "BroadcastConstants.SHOW_EDIT_SAVE_PROGRESS_DIALOG": [], "BroadcastConstants.DOWNLOAD_CANCEL_OPERATE": [], "BroadcastConstants.ON_DATA_RELOADED": [], "BroadcastConstants.SAVE_FORM_EDITOR_DATA": [], "BroadcastConstants.INIT_DATE_TEXT": [], "BroadcastConstants.THIRD_ROUTE_PAGE": [], "BroadcastConstants.ON_DATA_RELOADED_WITH_EDIT": [], "BroadcastConstants.PHOTO_EDIT_SAVE_COMPLETE": [], "BroadcastConstants.CHANGE_SWIPER_DURATION": [], "BroadcastConstants.LEFT_BLANK": [], "BroadcastConstants.RESET_TAB_SELECTED_STATUE": [], "BroadcastConstants.RESET_TAB_SELECTED_TEXT": []}, "static_cg": {}}
{"source_code": "/*\n * Copyright (C) 2024 Huawei Device Co., Ltd.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\nexport class Contents {\n  //服务IP\n  public static serverIp: string = '192.168.1.100'\n  //直连交换机\n  public static exchangeType_direct: string = 'direct'\n  //主题交换机\n  public static exchangeType_topic: string = 'topic'\n  //扇形交换机\n  public static exchangeType_fanout: string = 'fanout'\n\n}", "llm_cg": {"Contents.serverIp": [], "Contents.exchangeType_direct": [], "Contents.exchangeType_topic": [], "Contents.exchangeType_fanout": []}, "static_cg": {}}
{"source_code": "/*\n * Copyright (C) 2024 Huawei Device Co., Ltd.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\nimport AbilityConstant from '@ohos.app.ability.AbilityConstant';\nimport hilog from '@ohos.hilog';\nimport UIAbility from '@ohos.app.ability.UIAbility';\nimport Want from '@ohos.app.ability.Want';\nimport window from '@ohos.window';\n\nexport default class EntryAbility extends UIAbility {\n  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {\n    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onCreate');\n  }\n\n  onDestroy(): void {\n    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onDestroy');\n  }\n\n  onWindowStageCreate(windowStage: window.WindowStage): void {\n    // Main window is created, set main page for this ability\n    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageCreate');\n\n    windowStage.loadContent('pages/Index', (err, data) => {\n      if (err.code) {\n        hilog.error(0x0000, 'testTag', 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');\n        return;\n      }\n      hilog.info(0x0000, 'testTag', 'Succeeded in loading the content. Data: %{public}s', JSON.stringify(data) ?? '');\n    });\n  }\n\n  onWindowStageDestroy(): void {\n    // Main window is destroyed, release UI related resources\n    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageDestroy');\n  }\n\n  onForeground(): void {\n    // Ability has brought to foreground\n    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onForeground');\n  }\n\n  onBackground(): void {\n    // Ability has back to background\n    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onBackground');\n  }\n}\n", "llm_cg": {"EntryAbility.onCreate(Want, AbilityConstant.LaunchParam)": [], "EntryAbility.onDestroy()": [], "EntryAbility.onWindowStageCreate(window.WindowStage)": ["window.WindowStage.loadContent(string, (err, data) => void)"], "EntryAbility.onWindowStageDestroy()": [], "EntryAbility.onForeground()": [], "EntryAbility.onBackground()": []}, "static_cg": {"@test/87.ts: EntryAbility.onWindowStageCreate(window.WindowStage)": ["@test/87.ts: EntryAbility.%AM0$onWindowStageCreate(unknown, unknown)"]}}
{"source_code": "/**\n * Copyright (c) 2022 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport hilog from '@ohos.hilog'\n\n/*\n * logger of wifi test\n */\n\nclass Logger {\n  private domain: number\n  private prefix: string\n  private format: string = \"%{public}s, %{public}s\"\n\n  constructor(prefix: string) {\n    this.prefix = prefix\n    this.domain = 0xFF00\n  }\n\n  debug(...args: string[]) {\n    hilog.debug(this.domain, this.prefix, this.format, args)\n  }\n\n  info(...args: string[]) {\n    hilog.info(this.domain, this.prefix, this.format, args)\n  }\n\n  warn(...args: string[]) {\n    hilog.warn(this.domain, this.prefix, this.format, args)\n  }\n\n  error(...args: string[]) {\n    hilog.error(this.domain, this.prefix, this.format, args)\n  }\n}\n\nexport default new Logger('[Screenshot]')", "llm_cg": {"Logger.debug(...args: string[])": ["Logger.%AM0$debug(unknown, unknown, unknown, unknown)"], "Logger.info(...args: string[])": ["Logger.%AM1$info(unknown, unknown, unknown, unknown)"], "Logger.warn(...args: string[])": ["Logger.%AM2$warn(unknown, unknown, unknown, unknown)"], "Logger.error(...args: string[])": ["Logger.%AM3$error(unknown, unknown, unknown, unknown)"]}, "static_cg": {"@test/88.ts: %dflt.[static]%dflt()": ["@test/88.ts: Logger.constructor(string)"]}}
{"source_code": "/**\n * Copyright (c) 2022 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport image from '@ohos.multimedia.image'\nimport fileio from '@ohos.fileio'\nimport fs from '@ohos.file.fs';\nimport prompt from '@ohos.prompt'\nimport photoAccessHelper from '@ohos.file.photoAccessHelper'\nimport DateTimeUtil from './DateTimeUtil'\n\n\n/**\n * mediaUtils of wifi test\n */\n\nconst TAG = \"[MediaUtils]\"\n\nclass MediaUtils {\n  async createAndGetFile(context: any) {\n    let mediaTest = photoAccessHelper.getPhotoAccessHelper(context)\n    let info = {\n      prefix: 'IMG_', suffix: '.jpg', directory: photoAccessHelper.PhotoType.IMAGE\n    }\n    let dateTimeUtil = new DateTimeUtil()\n    let name = `${dateTimeUtil.getDate()}_${dateTimeUtil.getTime()}`\n    let displayName = `${info.prefix}${name}${info.suffix}`\n    let photoType: photoAccessHelper.PhotoType = photoAccessHelper.PhotoType.IMAGE;\n    let options: photoAccessHelper.CreateOptions = {\n      title: displayName\n    }\n    return await mediaTest.createAsset(photoType, '.jpg', options)\n  }\n\n  async savePicture(data: image.PixelMap, context: any) {\n    console.log(TAG, `savePicture`)\n    let packOpts: image.PackingOption = {\n      format: \"image/jpeg\", quality: 100\n    }\n    let imagePackerApi = image.createImagePacker()\n    let arrayBuffer = await imagePackerApi.packing(data, packOpts)\n    let fileAsset = await this.createAndGetFile(context)\n    let file = await fs.open(fileAsset,  fs.OpenMode.READ_WRITE | fs.OpenMode.CREATE);\n    imagePackerApi.release()\n    try {\n      await fs.write(file.fd, arrayBuffer);\n    } catch (err) {\n      console.log(`write failed, code is ${err.code}, message is ${err.message}`)\n    }\n    await fs.close(file.fd);\n    console.log(TAG, `write done`)\n    prompt.showToast({\n      message: '图片保存成功', duration: 1000\n    })\n  }\n}\n\nexport default new MediaUtils()", "llm_cg": {"MediaUtils.createAndGetFile(context)": ["photoAccessHelper.getPhotoAccessHelper(context)", "DateTimeUtil.getDate()", "DateTimeUtil.getTime()", "mediaTest.createAsset(photoType, '.jpg', options)"], "MediaUtils.savePicture(data, context)": ["MediaUtils.createAndGetFile(context)", "image.createImagePacker()", "imagePackerApi.packing(data, packOpts)", "fs.open(fileAsset, fs.OpenMode.READ_WRITE | fs.OpenMode.CREATE)", "imagePackerApi.release()", "fs.write(file.fd, arrayBuffer)", "fs.close(file.fd)", "prompt.showToast({message: '图片保存成功', duration: 1000})"]}, "static_cg": {"@test/89.ts: MediaUtils.savePicture(image.PixelMap, any)": ["@test/89.ts: MediaUtils.createAndGetFile(any)"]}}
{"source_code": "/**\n * Copyright (c) 2022 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @file 日期工具\n */\nexport default class DateTimeUtil {\n\n  /**\n   * 时分秒\n   */\n  getTime() {\n    const DATETIME = new Date()\n    return this.concatTime(DATETIME.getHours(), DATETIME.getMinutes(), DATETIME.getSeconds())\n  }\n\n  /**\n   * 年月日\n   */\n  getDate() {\n    const DATETIME = new Date()\n    return this.concatDate(DATETIME.getFullYear(), DATETIME.getMonth() + 1, DATETIME.getDate())\n  }\n\n  /**\n   * 日期不足两位补充0\n   * @param value-数据值\n   */\n  fill(value: number) {\n    return (value > 9 ? '' : '0') + value\n  }\n\n  /**\n   * 年月日格式修饰\n   * @param year\n   * @param month\n   * @param date\n   */\n  concatDate(year: number, month: number, date: number) {\n    return `${year}${this.fill(month)}${this.fill(date)}`\n  }\n\n  /**\n   * 时分秒格式修饰\n   * @param hours\n   * @param minutes\n   * @param seconds\n   */\n  concatTime(hours: number, minutes: number, seconds: number) {\n    return `${this.fill(hours)}${this.fill(minutes)}${this.fill(seconds)}`\n  }\n}", "llm_cg": {"DateTimeUtil.getTime()": ["DateTimeUtil.concatTime(unknown, unknown, unknown)"], "DateTimeUtil.getDate()": ["DateTimeUtil.concatDate(unknown, unknown, unknown)"], "DateTimeUtil.concatDate(year: number, month: number, date: number)": ["DateTimeUtil.fill(unknown)", "DateTimeUtil.fill(unknown)"], "DateTimeUtil.concatTime(hours: number, minutes: number, seconds: number)": ["DateTimeUtil.fill(unknown)", "DateTimeUtil.fill(unknown)", "DateTimeUtil.fill(unknown)"]}, "static_cg": {"@test/90.ts: DateTimeUtil.getTime()": ["@test/90.ts: DateTimeUtil.concatTime(number, number, number)"], "@test/90.ts: DateTimeUtil.getDate()": ["@test/90.ts: DateTimeUtil.concatDate(number, number, number)"], "@test/90.ts: DateTimeUtil.concatDate(number, number, number)": ["@test/90.ts: DateTimeUtil.fill(number)"], "@test/90.ts: DateTimeUtil.concatTime(number, number, number)": ["@test/90.ts: DateTimeUtil.fill(number)"]}}
{"source_code": "/**\n * Copyright (c) 2022 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport class ConfigData {\n  TAG = 'WIFI_Test'\n  WH_100_100 = '100%';\n  WH_3_100 = '3%';\n  WH_5_100 = '5%';\n  WH_6_100 = '6%';\n  WH_10_100 = '10%';\n  WH_15_100 = '15%';\n  WH_20_100 = '20%';\n  WH_25_100 = '25%';\n  WH_28_100 = '28%';\n  WH_30_100 = '30%';\n  WH_33_100 = '33%';\n  WH_35_100 = '35%';\n  WH_40_100 = '40%';\n  WH_45_100 = '45%';\n  WH_50_100 = '50%';\n  WH_55_100 = '55%';\n  WH_58_100 = '58%';\n  WH_60_100 = '60%';\n  WH_65_100 = '65%';\n  WH_67_100 = '67%';\n  WH_70_100 = '70%';\n  WH_75_100 = '75%';\n  WH_80_100 = '80%';\n  WH_83_100 = '83%';\n  WH_87_100 = '87%';\n  WH_88_100 = '88%';\n  WH_90_100 = '90%';\n  WH_93_100 = '93%';\n  WH_95_100 = '95%';\n  value_20 = 20;\n  value_100 = 100;\n  font_20 = 20;\n  MAX_LINES_1 = 1;\n  MAX_LINES_2 = 2;\n  MAX_LINES_3 = 3;\n  DURATION_TIME = 200;\n  FUNCTION_TYPE_HDC = 4;\n  testLog = \"enableWifi test---------\";\n}\n\nlet configData = new ConfigData();\n\nexport default configData as ConfigData;", "llm_cg": {"ConfigData.constructor()": []}, "static_cg": {}}
{"source_code": "/**\n * Copyright (c) 2022 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport BaseModel from './BaseModel';\n\nlet LogLevel = {\n  /**\n   * debug\n   */\n  DEBUG: 3,\n\n  /**\n   * info\n   */\n  INFO: 4,\n\n  /**\n   * warn\n   */\n  WARN: 5,\n\n  /**\n   * error\n   */\n  ERROR: 6,\n\n  /**\n   * fatal\n   */\n  FATAL: 7,\n};\n\nconst LOG_LEVEL = LogLevel.INFO\n\n/**\n *  log package tool class\n */\nexport class LogUtil extends BaseModel {\n  debug(msg): void {\n    console.log(msg)\n    if (LogLevel.DEBUG >= LOG_LEVEL) {\n      console.log(msg);\n    }\n  }\n\n  log(msg): void {\n    console.log(msg)\n    if (LogLevel.INFO >= LOG_LEVEL) {\n      console.log(msg);\n    }\n  }\n\n  info(msg): void {\n    console.log(msg)\n    if (LogLevel.INFO >= LOG_LEVEL) {\n      console.log(msg);\n    }\n  }\n\n  warn(msg): void {\n    console.log(msg)\n    if (LogLevel.WARN >= LOG_LEVEL) {\n      console.warn(msg);\n    }\n  }\n\n  error(msg): void {\n    if (LogLevel.ERROR >= LOG_LEVEL) {\n      console.error(msg);\n    }\n  }\n}\n\nlet mLogUtil = new LogUtil();\n\nexport default mLogUtil as LogUtil\n;", "llm_cg": {"LogUtil.debug(msg)": ["LogUtil.%AM0$debug(unknown)"], "LogUtil.log(msg)": ["LogUtil.%AM1$log(unknown)"], "LogUtil.info(msg)": ["LogUtil.%AM2$info(unknown)"], "LogUtil.warn(msg)": ["LogUtil.%AM3$warn(unknown)"], "LogUtil.error(msg)": ["LogUtil.%AM4$error(unknown)"]}, "static_cg": {}}
{"source_code": "/**\n * Copyright (c) 2022 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport class LogDataManager {\n  TAG = 'WIFI_Manager_Test'\n  //wifi\n  testEnableWifiManager_StartLog = \"testEnableWifiManager Start----------\"\n  testEnableWifiManager_EndLog = \"testEnableWifi End----------\"\n  testDisableWifiManager_StartLog = \"testDisableWifi Start----------\"\n  testDisableWifiManager_EndLog = \"testDisableWifi End----------\"\n  testIsWifiActiveManager_StartLog = \"testIsWifiActive Start----------\"\n  testIsWifiActiveManager_EndLog = \"testDisableWifi End----------\"\n  testScanManager_StartLog = -\"testScan Start----------\"\n  testScanManager_EndLog = \"testScan End----------\"\n  testForcibleScanManager_StartLog = \"testForcibleScan Start----------\"\n  testForcibleScanManager_EndLog = \"testForcibleScan End----------\"\n  testGetScanInfoListManager_StartLog = \"testGetScanInfoListManager start---------\"\n  testGetScanInfoListManager_EndLog = \"testGetScanInfoListManager End----------\"\n  testGetScanInfosPromiseManager_StartLog = \"testGetScanInfosPromise Start----------\"\n  testGetScanInfosPromiseManager_EndLog = \"testGetScanInfosPromise End----------\"\n  testGetScanInfosPromiseManager_successfulLog = \"getScanInfos promise successful\"\n  testGetScanInfosManager_infoLog = \"wifi received scan info: \"\n  testGetScanInfosCallbackManager_StartLog = \"testGetScanInfosCallback Start----------\"\n  testGetScanInfosCallbackManager_EndLog = \"testGetScanInfosCallback End----------\"\n  testGetScanInfosCallbackManager_successfulLog = \"getScanInfos callback successful\"\n  testAddDeviceConfigPromiseManager_StartLog = \"testAddDeviceConfigPromise Start----------\"\n  testAddDeviceConfigPromiseManager_EndLog = \"testAddDeviceConfigPromise End----------\"\n  testAddDeviceConfigPromiseManager_successfulLog = \"addDeviceConfig promise successful\"\n  testAddDeviceConfigManagerLog = \"addDeviceConfig: \"\n  testAddDeviceConfigCallbackManager_StartLog = \"testAddDeviceConfigCallback Start----------\"\n  testAddDeviceConfigCallbackManager_EndLog = \"testAddDeviceConfigCallback End----------\"\n  testAddDeviceConfigCallbackManager_successfulLog = \"addDeviceConfig Callback successful\"\n  testAddCandidateConfigPromiseManager_StartLog = \"testAddCandidateConfigPromise Start----------\"\n  testAddCandidateConfigPromiseManager_EndLog = \"testAddCandidateConfigPromise End----------\"\n  testAddCandidateConfigPromiseManager_successfulLog = \"addCandidateConfig promise successful\"\n  testAddCandidateConfigManagerLog = \"addCandidateConfig: \"\n  testAddCandidateConfigCallbackManager_StartLog = \"testAddCandidateConfigCallback Start----------\"\n  testAddCandidateConfigCallbackManager_EndLog = \"testAddCandidateConfigCallback End----------\"\n  testAddCandidateConfigCallbackManager_successfulLog = \"addCandidateConfig Callback successful\"\n  testRemoveCandidateConfigPromiseManager_StartLog = \"testRemoveCandidateConfigPromise Start----------\"\n  testRemoveCandidateConfigPromiseManager_EndLog = \"testRemoveCandidateConfigPromise End----------\"\n  testRemoveCandidateConfigPromiseManager_successfulLog = \"removeCandidateConfig promise successful\"\n  testRemoveCandidateConfigManagerLog = \"removeCandidateConfig: \"\n  testRemoveCandidateConfigCallbackManager_StartLog = \"testRemoveCandidateConfigCallback Start----------\"\n  testRemoveCandidateConfigCallbackManager_EndLog = \"testRemoveCandidateConfigCallback End----------\"\n  testRemoveCandidateConfigCallbackManager_successfulLog = \"removeCandidateConfig Callback successful\"\n  testGetCandidateConfigsManager_StartLog = \"testGetCandidateConfigsManager Start----------\"\n  testGetCandidateConfigsManager_EndLog = \"testGetCandidateConfigsManager End----------\"\n  testConnectToCandidateConfigManager_StartLog = \"testConnectToCandidateConfigManager Start----------\"\n  testConnectToCandidateConfigManager_EndLog = \"testConnectToCandidateConfigManager End----------\"\n  testConnectToNetworkManager_StartLog = \"testConnectToNetwork Start----------\"\n  testConnectToNetworkManager_EndLog = \"testConnectToNetwork End----------\"\n  testConnectToDeviceManager_StartLog = \"testConnectToDevice Start----------\"\n  testConnectToDeviceManager_EndLog = \"testConnectToDevice End----------\"\n  testDisconnectManager_StartLog = \"testDisconnect Start----------\"\n  testDisconnectManager_EndLog = \"testDisconnect End----------\"\n  testGetSignalLevelManager_StartLog = \"testGetSignalLevel Start----------\"\n  testGetSignalLevelManager_EndLog = \"testGetSignalLevel End----------\"\n  testGetLinkedInfoPromiseManager_StartLog = \"testGetLinkedInfoPromise Start----------\"\n  testGetLinkedInfoPromiseManager_EndLog = \"testGetLinkedInfoPromise End----------\"\n  testGetLinkedInfoPromiseManager_successfulLog = \"getLinkedInfoPromise test successful\"\n  testGetLinkedInfoCallbackManager_StartLog = \"testGetLinkedInfoCallback Start----------\"\n  testGetLinkedInfoCallbackManager_EndLog = \"testGetLinkedInfoCallback End----------\"\n  testGetLinkedInfoCallbackManager_successfulLog = \"getLinkedInfoCallback test successful\"\n  testIsConnectedManager_StartLog = \"testIsConnected Start----------\"\n  testIsConnectedManager_EndLog = \"testIsConnected End----------\"\n  testGetSupportedFeaturesManager_StartLog = \"testGetSupportedFeatures Start----------\"\n  testGetSupportedFeaturesManager_EndLog = \"testGetSupportedFeatures End----------\"\n  testIsFeatureSupportedManager_StartLog = \"testIsFeatureSupported Start----------\"\n  testIsFeatureSupportedManager_EndLog = \"testIsFeatureSupported End----------\"\n  testGetDeviceMacAddressManager_StartLog = \"testGetDeviceMacAddress Start----------\"\n  testGetDeviceMacAddressManager_EndLog = \"testGetDeviceMacAddress End----------\"\n  testGetIpInfoManager_StartLog = \"testGetIpInfo Start----------\"\n  testGetIpInfoManager_EndLog = \"testGetIpInfo End----------\"\n  testGetCountryCodeManager_StartLog = \"testGetCountryCode Start----------\"\n  testGetCountryCodeManager_EndLog = \"testGetCountryCode End----------\"\n  testReassociateManager_StartLog = \"testReassociate Start----------\"\n  testReassociateManager_EndLog = \"testReassociate End----------\"\n  testReConnectManager_StartLog = \"testReConnect Start----------\"\n  testReConnectManager_EndLog = \"testReConnect End----------\"\n  testGetDeviceConfigsManager_StartLog = \"testGetDeviceConfigs Start----------\"\n  testGetDeviceConfigsManager_EndLog = \"testGetDeviceConfigs End----------\"\n  testUpdateNetworkManager_StartLog = \"testUpdateNetwork Start----------\"\n  testUpdateNetworkManager_EndLog = \"testUpdateNetwork End----------\"\n  testDisableNetworkManager_StartLog = \"testDisableNetwork Start----------\"\n  testDisableNetworkManager_EndLog = \"testDisableNetwork End----------\"\n  testRemoveAllNetworkManager_StartLog = \"testRemoveAllNetwork Start----------\"\n  testRemoveAllNetworkManager_EndLog = \"testRemoveAllNetwork End----------\"\n  testRemoveDeviceManager_StartLog = \"testRemoveDevice Start----------\"\n  testRemoveDeviceManager_EndLog = \"testRemoveDevice End----------\"\n  testOnWifiStateChangeManager_StartLog = \"testOnWifiStateChange Start----------\"\n  testOnWifiStateChangeManager_EndLog = \"testOnWifiStateChange End----------\"\n  testOnWifiConnectionChangeManager_StartLog = \"testOnWifiConnectionChange Start----------\"\n  testOnWifiConnectionChangeManager_EndLog = \"testOnWifiConnectionChange End----------\"\n  testOnWifiScanStateChangeManager_StartLog = \"testOnWifiConnectionChange Start----------\"\n  testOnWifiScanStateChangeManager_EndLog = \"testOnWifiConnectionChange End----------\"\n  testOnWifiRssiChangeManager_StartLog = \"testOnWifiRssiChange Start----------\"\n  testOnWifiRssiChangeManager_EndLog = \"testOnWifiRssiChange End----------\"\n  testOnStreamChangeManager_StartLog = \"testOnStreamChange Start----------\"\n  testOnStreamChangeManager_EndLog = \"testOnStreamChange End----------\"\n  testOnDeviceConfigChangeManager_StartLog = \"testOnDeviceConfigChangeManager Start----------\"\n  testOnDeviceConfigChangeManager_EndLog = \"testOnDeviceConfigChangeManager End----------\"\n  testEnableSemiWifi_StartLog = \"testEnableSemiWifi Start----------\"\n  testEnableSemiWifi_EndLog = \"testEnableSemiWifi End----------\"\n  testStartScanManager_StartLog = \"testStartScan Start----------\"\n  testStartScanManager_EndLog = \"testStartScan End----------\"\n  //hotspot\n  testEnableHotspotManager_StartLog = \"testEnableHotspot start--------------\"\n  testEnableHotspotManager_EndLog = \"testEnableHotspot End--------------\"\n  testDisableHotspotManager_StartLog = \"testDisableHotspot start--------------\"\n  testDisableHotspotManager_EndLog = \"testDisableHotspot End--------------\"\n  testIsHotspotDualBandSupportedManager_StartLog = \"testIsHotspotDualBandSupported start--------------\"\n  testIsHotspotDualBandSupportedManager_EndLog = \"testIsHotspotDualBandSupported End--------------\"\n  testIsHostActiveManager_StartLog = \"testIsHostActive start--------------\"\n  testIsHostActiveManager_EndLog = \"testIsHostActive End--------------\"\n  testSetHotspotConfigManagerManager_StartLog = \"testSetHotspotConfig start--------------\"\n  testSetHotspotConfigManager_EndLog = \"testSetHotspotConfig End--------------\"\n  testGetHotspotConfigManager_StartLog = \"testGetHotspotConfig start--------------\"\n  testGetHotspotConfigManager_EndLog = \"testGetHotspotConfig End--------------\"\n  testGetStationsManager_StartLog = \"testGetStations start--------------\"\n  testGetStationsManager_EndLog = \"testGetStations End--------------\"\n  testOnHotspotStateChangeManager_StartLog = \"testOnHotspotStateChange start--------------\"\n  testOnHotspotStateChangeManager_EndLog = \"testOnHotspotStateChange End--------------\"\n  testOnHotspotStaJoinManager_StartLog = \"testOnHotspotStaJoin start--------------\"\n  testOnHotspotStaJoinManager_EndLog = \"testOnHotspotStaJoin End--------------\"\n  testOnHotspotStaLeaveManager_StartLog = \"testOnHotspotStaLeave start--------------\"\n  testOnHotspotStaLeaveManager_EndLog = \"testOnHotspotStaLeave End--------------\"\n  //p2p\n  testGetP2pLinkedInfoPromiseManager_StartLog = \"testGetP2pLinkedInfoPromise Start----------\"\n  testGetP2pLinkedInfoPromiseManager_EndLog = \"testGetP2pLinkedInfoPromise End----------\"\n  getP2pLinkedInfoPromiseManager_successfulLog = \"getP2pLinkedInfoPromise successful\"\n  testGetP2pLinkedInfoCallbackManager_StartLog = \"testGetP2pLinkedInfoCallback Start----------\"\n  testGetP2pLinkedInfoCallbackManager_EndLog = \"testGetP2pLinkedInfoCallback End----------\"\n  getP2pLinkedInfoCallbackManager_successfulLog = \"getP2pLinkedInfoCallback successful \"\n  testGetCurrentGroupPromiseManager_StartLog = \"testGetCurrentGroupPromise Start----------\"\n  testGetCurrentGroupPromiseManager_EndLog = \"testGetCurrentGroupPromise End----------\"\n  testGetCurrentGroupPromiseManager_successfulLog = \"getCurrentGroupPromise successful\"\n  testGetCurrentGroupCallbackManager_StartLog = \"testGetCurrentGroupCallback Start----------\"\n  testGetCurrentGroupCallbackManager_EndLog = \"testGetCurrentGroupCallback End----------\"\n  getCurrentGroupCallbackManager_successfulLog = \"getCurrentGroupCallback successful\"\n  testGetP2pPeerDevicesPromiseManager_StartLog = \"testGetP2pPeerDevicesPromise Start----------\"\n  testGetP2pPeerDevicesPromiseManager_EndLog = \"testGetP2pPeerDevicesPromise End----------\"\n  getP2pPeerDevicesPromiseManager_successfulLog = \"getP2pPeerDevicesPromise successful\"\n  testGetP2pPeerDevicesCallbackManager_StartLog = \"testGetP2pPeerDevicesCallback Start----------\"\n  testGetP2pPeerDevicesCallbackManager_EndLog = \"testGetP2pPeerDevicesCallback End----------\"\n  getP2pPeerDevicesCallbackManager_successfulLog = \"getP2pPeerDevicesCallback successful\"\n  testCreateGroupManager_StartLog = \"testCreateGroup Start----------\"\n  testCreateGroupManager_EndLog = \"testCreateGroup End----------\"\n  testRemoveGroupManager_StartLog = \"testRemoveGroup Start----------\"\n  testRemoveGroupManager_EndLog = \"testRemoveGroup End----------\"\n  testP2pConnectManager_StartLog = \"testP2pConnect Start----------\"\n  testP2pConnectManager_EndLog = \"testP2pConnect End----------\"\n  testP2pCancelConnectManager_StartLog = \"testP2pCancelConnect Start----------\"\n  testP2pCancelConnectManager_EndLog = \"testP2pCancelConnect End----------\"\n  testStartDiscoverDevicesManager_StartLog = \"testStartDiscoverDevices Start----------\"\n  testStartDiscoverDevicesManager_EndLog = \"testStartDiscoverDevices End----------\"\n  testStopDiscoverDevicesManager_StartLog = \"testStopDiscoverDevices Start----------\"\n  testStopDiscoverDevicesManager_EndLog = \"testStopDiscoverDevices End----------\"\n  testDeletePersistentGroupManager_StartLog = \"testDeletePersistentGroup Start----------\"\n  testDeletePersistentGroupManager_EndLog = \"testDeletePersistentGroup End----------\"\n  testSetDeviceNameManager_StartLog = \"testSetDeviceName Start----------\"\n  testSetDeviceNameManager_EndLog = \"testSetDeviceName End----------\"\n  testOnP2pStateChangeManager_StartLog = \"testOnP2pStateChange Start----------\"\n  testOnP2pStateChangeManager_EndLog = \"testOnP2pStateChange End----------\"\n  testOnP2pConnectionChangeManager_StartLog = \"testOnP2pConnectionChange Start----------\"\n  testOnP2pConnectionChangeManager_EndLog = \"testOnP2pConnectionChange End----------\"\n  testOnP2pDeviceChangeManager_StartLog = \"testOnP2pDeviceChange Start----------\"\n  testOnP2pDeviceChangeManager_EndLog = \"testOnP2pDeviceChange End----------\"\n  testOnP2pPeerDeviceChangeManager_StartLog = \"testOnP2pPeerDeviceChange Start----------\"\n  testOnP2pPeerDeviceChangeManager_EndLog = \"testOnP2pPeerDeviceChange End----------\"\n  testOnP2pPersistentGroupChangeManager_StartLog = \"testOnP2pPersistentGroupChange Start----------\"\n  testOnP2pPersistentGroupChangeManager_EndLog = \"testOnP2pPersistentGroupChange End----------\"\n  testOnP2pDiscoveryChangeManager_StartLog = \"testOnP2pDiscoveryChange Start----------\"\n  testOnP2pDiscoveryChangeManager_EndLog = \"testOnP2pDiscoveryChange End----------\"\n}\n\nlet logDataManager = new LogDataManager();\n\nexport default logDataManager as LogDataManager;", "llm_cg": {"LogDataManager.testEnableWifiManager_StartLog": [], "LogDataManager.testEnableWifiManager_EndLog": [], "LogDataManager.testDisableWifiManager_StartLog": [], "LogDataManager.testDisableWifiManager_EndLog": [], "LogDataManager.testIsWifiActiveManager_StartLog": [], "LogDataManager.testIsWifiActiveManager_EndLog": [], "LogDataManager.testScanManager_StartLog": [], "LogDataManager.testScanManager_EndLog": [], "LogDataManager.testForcibleScanManager_StartLog": [], "LogDataManager.testForcibleScanManager_EndLog": [], "LogDataManager.testGetScanInfoListManager_StartLog": [], "LogDataManager.testGetScanInfoListManager_EndLog": [], "LogDataManager.testGetScanInfosPromiseManager_StartLog": [], "LogDataManager.testGetScanInfosPromiseManager_EndLog": [], "LogDataManager.testGetScanInfosPromiseManager_successfulLog": [], "LogDataManager.testGetScanInfosManager_infoLog": [], "LogDataManager.testGetScanInfosCallbackManager_StartLog": [], "LogDataManager.testGetScanInfosCallbackManager_EndLog": [], "LogDataManager.testGetScanInfosCallbackManager_successfulLog": [], "LogDataManager.testAddDeviceConfigPromiseManager_StartLog": [], "LogDataManager.testAddDeviceConfigPromiseManager_EndLog": [], "LogDataManager.testAddDeviceConfigPromiseManager_successfulLog": [], "LogDataManager.testAddDeviceConfigManagerLog": [], "LogDataManager.testAddDeviceConfigCallbackManager_StartLog": [], "LogDataManager.testAddDeviceConfigCallbackManager_EndLog": [], "LogDataManager.testAddDeviceConfigCallbackManager_successfulLog": [], "LogDataManager.testAddCandidateConfigPromiseManager_StartLog": [], "LogDataManager.testAddCandidateConfigPromiseManager_EndLog": [], "LogDataManager.testAddCandidateConfigPromiseManager_successfulLog": [], "LogDataManager.testAddCandidateConfigManagerLog": [], "LogDataManager.testAddCandidateConfigCallbackManager_StartLog": [], "LogDataManager.testAddCandidateConfigCallbackManager_EndLog": [], "LogDataManager.testAddCandidateConfigCallbackManager_successfulLog": [], "LogDataManager.testRemoveCandidateConfigPromiseManager_StartLog": [], "LogDataManager.testRemoveCandidateConfigPromiseManager_EndLog": [], "LogDataManager.testRemoveCandidateConfigPromiseManager_successfulLog": [], "LogDataManager.testRemoveCandidateConfigManagerLog": [], "LogDataManager.testRemoveCandidateConfigCallbackManager_StartLog": [], "LogDataManager.testRemoveCandidateConfigCallbackManager_EndLog": [], "LogDataManager.testRemoveCandidateConfigCallbackManager_successfulLog": [], "LogDataManager.testGetCandidateConfigsManager_StartLog": [], "LogDataManager.testGetCandidateConfigsManager_EndLog": [], "LogDataManager.testConnectToCandidateConfigManager_StartLog": [], "LogDataManager.testConnectToCandidateConfigManager_EndLog": [], "LogDataManager.testConnectToNetworkManager_StartLog": [], "LogDataManager.testConnectToNetworkManager_EndLog": [], "LogDataManager.testConnectToDeviceManager_StartLog": [], "LogDataManager.testConnectToDeviceManager_EndLog": [], "LogDataManager.testDisconnectManager_StartLog": [], "LogDataManager.testDisconnectManager_EndLog": [], "LogDataManager.testGetSignalLevelManager_StartLog": [], "LogDataManager.testGetSignalLevelManager_EndLog": [], "LogDataManager.testGetLinkedInfoPromiseManager_StartLog": [], "LogDataManager.testGetLinkedInfoPromiseManager_EndLog": [], "LogDataManager.testGetLinkedInfoPromiseManager_successfulLog": [], "LogDataManager.testGetLinkedInfoCallbackManager_StartLog": [], "LogDataManager.testGetLinkedInfoCallbackManager_EndLog": [], "LogDataManager.testGetLinkedInfoCallbackManager_successfulLog": [], "LogDataManager.testIsConnectedManager_StartLog": [], "LogDataManager.testIsConnectedManager_EndLog": [], "LogDataManager.testGetSupportedFeaturesManager_StartLog": [], "LogDataManager.testGetSupportedFeaturesManager_EndLog": [], "LogDataManager.testIsFeatureSupportedManager_StartLog": [], "LogDataManager.testIsFeatureSupportedManager_EndLog": [], "LogDataManager.testGetDeviceMacAddressManager_StartLog": [], "LogDataManager.testGetDeviceMacAddressManager_EndLog": [], "LogDataManager.testGetIpInfoManager_StartLog": [], "LogDataManager.testGetIpInfoManager_EndLog": [], "LogDataManager.testGetCountryCodeManager_StartLog": [], "LogDataManager.testGetCountryCodeManager_EndLog": [], "LogDataManager.testReassociateManager_StartLog": [], "LogDataManager.testReassociateManager_EndLog": [], "LogDataManager.testReConnectManager_StartLog": [], "LogDataManager.testReConnectManager_EndLog": [], "LogDataManager.testGetDeviceConfigsManager_StartLog": [], "LogDataManager.testGetDeviceConfigsManager_EndLog": [], "LogDataManager.testUpdateNetworkManager_StartLog": [], "LogDataManager.testUpdateNetworkManager_EndLog": [], "LogDataManager.testDisableNetworkManager_StartLog": [], "LogDataManager.testDisableNetworkManager_EndLog": [], "LogDataManager.testRemoveAllNetworkManager_StartLog": [], "LogDataManager.testRemoveAllNetworkManager_EndLog": [], "LogDataManager.testRemoveDeviceManager_StartLog": [], "LogDataManager.testRemoveDeviceManager_EndLog": [], "LogDataManager.testOnWifiStateChangeManager_StartLog": [], "LogDataManager.testOnWifiStateChangeManager_EndLog": [], "LogDataManager.testOnWifiConnectionChangeManager_StartLog": [], "LogDataManager.testOnWifiConnectionChangeManager_EndLog": [], "LogDataManager.testOnWifiScanStateChangeManager_StartLog": [], "LogDataManager.testOnWifiScanStateChangeManager_EndLog": [], "LogDataManager.testOnWifiRssiChangeManager_StartLog": [], "LogDataManager.testOnWifiRssiChangeManager_EndLog": [], "LogDataManager.testOnStreamChangeManager_StartLog": [], "LogDataManager.testOnStreamChangeManager_EndLog": [], "LogDataManager.testOnDeviceConfigChangeManager_StartLog": [], "LogDataManager.testOnDeviceConfigChangeManager_EndLog": [], "LogDataManager.testEnableSemiWifi_StartLog": [], "LogDataManager.testEnableSemiWifi_EndLog": [], "LogDataManager.testStartScanManager_StartLog": [], "LogDataManager.testStartScanManager_EndLog": [], "LogDataManager.testEnableHotspotManager_StartLog": [], "LogDataManager.testEnableHotspotManager_EndLog": [], "LogDataManager.testDisableHotspotManager_StartLog": [], "LogDataManager.testDisableHotspotManager_EndLog": [], "LogDataManager.testIsHotspotDualBandSupportedManager_StartLog": [], "LogDataManager.testIsHotspotDualBandSupportedManager_EndLog": [], "LogDataManager.testIsHostActiveManager_StartLog": [], "LogDataManager.testIsHostActiveManager_EndLog": [], "LogDataManager.testSetHotspotConfigManagerManager_StartLog": [], "LogDataManager.testSetHotspotConfigManager_EndLog": [], "LogDataManager.testGetHotspotConfigManager_StartLog": [], "LogDataManager.testGetHotspotConfigManager_EndLog": [], "LogDataManager.testGetStationsManager_StartLog": [], "LogDataManager.testGetStationsManager_EndLog": [], "LogDataManager.testOnHotspotStateChangeManager_StartLog": [], "LogDataManager.testOnHotspotStateChangeManager_EndLog": [], "LogDataManager.testOnHotspotStaJoinManager_StartLog": [], "LogDataManager.testOnHotspotStaJoinManager_EndLog": [], "LogDataManager.testOnHotspotStaLeaveManager_StartLog": [], "LogDataManager.testOnHotspotStaLeaveManager_EndLog": [], "LogDataManager.testGetP2pLinkedInfoPromiseManager_StartLog": [], "LogDataManager.testGetP2pLinkedInfoPromiseManager_EndLog": [], "LogDataManager.getP2pLinkedInfoPromiseManager_successfulLog": [], "LogDataManager.testGetP2pLinkedInfoCallbackManager_StartLog": [], "LogDataManager.testGetP2pLinkedInfoCallbackManager_EndLog": [], "LogDataManager.getP2pLinkedInfoCallbackManager_successfulLog": [], "LogDataManager.testGetCurrentGroupPromiseManager_StartLog": [], "LogDataManager.testGetCurrentGroupPromiseManager_EndLog": [], "LogDataManager.testGetCurrentGroupPromiseManager_successfulLog": [], "LogDataManager.testGetCurrentGroupCallbackManager_StartLog": [], "LogDataManager.testGetCurrentGroupCallbackManager_EndLog": [], "LogDataManager.getCurrentGroupCallbackManager_successfulLog": [], "LogDataManager.testGetP2pPeerDevicesPromiseManager_StartLog": [], "LogDataManager.testGetP2pPeerDevicesPromiseManager_EndLog": [], "LogDataManager.getP2pPeerDevicesPromiseManager_successfulLog": [], "LogDataManager.testGetP2pPeerDevicesCallbackManager_StartLog": [], "LogDataManager.testGetP2pPeerDevicesCallbackManager_EndLog": [], "LogDataManager.getP2pPeerDevicesCallbackManager_successfulLog": [], "LogDataManager.testCreateGroupManager_StartLog": [], "LogDataManager.testCreateGroupManager_EndLog": [], "LogDataManager.testRemoveGroupManager_StartLog": [], "LogDataManager.testRemoveGroupManager_EndLog": [], "LogDataManager.testP2pConnectManager_StartLog": [], "LogDataManager.testP2pConnectManager_EndLog": [], "LogDataManager.testP2pCancelConnectManager_StartLog": [], "LogDataManager.testP2pCancelConnectManager_EndLog": [], "LogDataManager.testStartDiscoverDevicesManager_StartLog": [], "LogDataManager.testStartDiscoverDevicesManager_EndLog": [], "LogDataManager.testStopDiscoverDevicesManager_StartLog": [], "LogDataManager.testStopDiscoverDevicesManager_EndLog": [], "LogDataManager.testDeletePersistentGroupManager_StartLog": [], "LogDataManager.testDeletePersistentGroupManager_EndLog": [], "LogDataManager.testSetDeviceNameManager_StartLog": [], "LogDataManager.testSetDeviceNameManager_EndLog": [], "LogDataManager.testOnP2pStateChangeManager_StartLog": [], "LogDataManager.testOnP2pStateChangeManager_EndLog": [], "LogDataManager.testOnP2pConnectionChangeManager_StartLog": [], "LogDataManager.testOnP2pConnectionChangeManager_EndLog": [], "LogDataManager.testOnP2pDeviceChangeManager_StartLog": [], "LogDataManager.testOnP2pDeviceChangeManager_EndLog": [], "LogDataManager.testOnP2pPeerDeviceChangeManager_StartLog": [], "LogDataManager.testOnP2pPeerDeviceChangeManager_EndLog": [], "LogDataManager.testOnP2pPersistentGroupChangeManager_StartLog": [], "LogDataManager.testOnP2pPersistentGroupChangeManager_EndLog": [], "LogDataManager.testOnP2pDiscoveryChangeManager_StartLog": [], "LogDataManager.testOnP2pDiscoveryChangeManager_EndLog": []}, "static_cg": {}}
{"source_code": "/**\n * Copyright (c) 2022 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport default class BaseModel {\n  constructor() {\n  }\n}", "llm_cg": {"BaseModel.constructor()": []}, "static_cg": {}}
{"source_code": "/**\n * Copyright (c) 2022 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport class MessageDataManager {\n  TAG = 'WIFI_Manager_Test'\n  //wifi\n  testEnableWifi = \"enableWifi test\";\n  testIsActive = \"Wifi已经使能\"\n  testWifiEnableResult = \"Wifi使能执行结果：\"\n  testEnableResult = \"使能结果：\"\n  testWifiEnableMaybe = \"Wifi已打开或打开失败,请确认\"\n  testDisableWifi = \"testDisableWifi\"\n  testIsInactive = \"WIFI还未使能\"\n  testWifiDisableResult = \"Wifi去使能执行结果：\"\n  testDisableResult = \"去使能结果：\"\n  testWifiDisableMaybe = \"Wifi已关闭或关闭失败,请确认\"\n\n  testEnableSemiWifi =\"enableSemiWifi test\";\n\n  testIsWifiActive = \"testIsWifiActive\"\n  testIsActiveResult = \"wifi使能结果为：\"\n  testScan = \"scan test\"\n  testScanResult = \"scan: \"\n  testStartScan = \"startScan test\"\n\n  testForcibleScan = \"ForcibleScan test\"\n  testForcibleScanResult = \"ForcibleScan: \"\n  testGetScanInfoList = \"getScanInfoList test\"\n  testGetScanInfosPromise = \"getScanInfosPromise test\"\n  testGetScanInfo = \"WifiScanInfo: \"\n  testGetScanInfosCallback = \"getScanInfosCallback test\"\n  testAddDeviceConfigPromise = \"addDeviceConfigPromise test\"\n  testAddDeviceConfig = \"addDeviceConfig: \"\n  testAddDeviceConfigCallback = \"addDeviceConfigCallback test\"\n  testAddCandidateConfigPromise = \"addCandidateConfigPromise test\"\n  testAddCandidateConfig = \"addCandidateConfig: \"\n  testAddCandidateConfigCallback = \"addCandidateConfigCallback test\"\n  testRemoveCandidateConfigPromise = \"removeCandidateConfigPromise test\"\n  testRemoveCandidateConfig = \"removeCandidateConfig: \"\n  testRemoveCandidateConfigCallback = \"removeCandidateConfigCallback test\"\n  testGetCandidateConfigs = \"GetCandidateConfigs test\"\n  testConnectToCandidateConfig = \"ConnectToCandidateConfig test\"\n  testConnectToNetwork = \"connectToNetwork test\"\n  testConnectToDevice = \"connectToDevice test\"\n  testDisconnect = \"disconnect test\"\n  testGetSignalLevel = \"getSignalLevel test\"\n  testGetLinkedInfoPromise = \"getLinkedInfoPromise test\"\n  testGetLinkedInfoCallback = \"getLinkedInfoCallback test\"\n  testIsConnected = \"isConnected test\"\n  testGetSupportedFeatures = \"getSupportedFeatures test\"\n  testIsFeatureSupported = \"isFeatureSupported test\"\n  testGetDeviceMacAddress = \"getDeviceMacAddress test\"\n  testGetIpInfo = \"getIpInfo test\"\n  testGetCountryCode = \"getCountryCode test\"\n  testReassociate = \"reAssociate test\"\n  testReConnect = \"reConnect test\"\n  testGetDeviceConfigs = \"getDeviceConfigs test\"\n  testUpdateNetwork = \"updateNetwork test\"\n  testDisableNetwork = \"disableNetWork test\"\n  testRemoveAllNetwork = \"removeAllNetwork test\"\n  testRemoveDevice = \"removeDevice test\"\n  testOnWifiStateChange = \"onWifiStateChange test\"\n  offWifiStateChange = \"on.WifiStateChange监听已关闭\"\n  offWifiStateChangeTest = \"关闭注册WLAN状态改变事件\"\n  onWifiStateChange = \"on.WifiStateChange监听已打开\"\n  onWifiStateChangeTest = \"打开注册WLAN状态变化\"\n  wifiStateChange = \"wifi状态: \"\n  testOnWifiConnectionChange = \"onWifiConnectionChange test\"\n  offWifiConnectionChange = \"on.wifiConnectionChange监听已关闭\"\n  offWifiConnectionChangeTest = \"关闭WLAN连接状态改变事件\"\n  onWifiConnectionChangeTest = \"打开注册WLAN连接状态变化\"\n  testOnWifiScanStateChange = \"onWifiScanStateChange test\"\n  offWifiScanStateChange = \"on.wifiScanStateChange监听已关闭\"\n  offWifiScanStateChangeTest = \"关闭扫描状态改变事件\"\n  onWifiScanStateChangeTest = \"打开注册扫描状态变化\"\n  testOnWifiRssiChange = \"onWifiRssiChange test\"\n  offWifiRssiChange = \"on.wifiRssiChange监听已关闭\"\n  offWifiRssiChangeTest = \"关闭RSSI状态变化事件\"\n  onWifiRssiChangeTest = \"打开注册RSSI状态变化\"\n  testOnStreamChange = \"onStreamChange test\"\n  offStreamChange = \"on.streamChange监听已关闭\"\n  offStreamChangeTest = \"关闭注册流改变事件\"\n  onStreamChangeTest = \"打开注册流变化\"\n  //hotspot\n  testEnableHotspot = \"enableHotspot test\"\n  testDisableHotspot = \"disableHotspot test\"\n  hotspot_enable = \"热点已经使能\"\n  hotspot_disEnable = \"热点还未使能\"\n  testIsHotspotDualBandSupported = \"isHotspotDualBandSupported test\"\n  testIsHotspotActive = \"isHotspotActive test\"\n  testSetHotspotConfig = \"SetHotspotConfig test\"\n  testGetHotspotConfig = \"getHotspotConfig test\"\n  testGetStations = \"GetStations test\"\n  testOnHotspotStateChange = \"onHotspotStateChange test\"\n  offHotspotStateChange = \"on.hotspotStateChange监听已关闭\"\n  offHotspotStateChangeTest = \"关闭注册热点状态改变事件\"\n  onHotspotStateChangeTest = \"打开注册热点状态变化\"\n  testOnHotspotStaJoin = \"onHotspotStaJoin test\"\n  offHotspotStaJoin = \"on.hotspotStaJoin监听已关闭\"\n  offHotspotStaJoinTest = \"关闭注册Wi-Fi 热点 sta加入变化事件\"\n  onHotspotStaJoinTest = \"打开注册Wi-Fi 热点 sta加入变化\"\n  testOnHotspotStaLeave = \"onHotspotStaLeave test\"\n  offHotspotStaLeave = \"on.hotspotStaLeave监听已关闭\"\n  offHotspotStaLeaveTest = \"关闭注册Wi-Fi 热点 sta离开变化事件\"\n  onHotspotStaLeaveTest = \"打开注册Wi-Fi 热点 sta离开变化\"\n  //p2p\n  testGetP2pLinkedInfoPromise = \"getP2pLinkedInfoPromise test\"\n  testGetP2pLinkedInfoCallback = \"getP2pLinkedInfoCallback test\"\n  testGetCurrentGroupPromise = \"getCurrentGroupPromise test\"\n  testGetCurrentGroupCallback = \"getCurrentGroupCallback test\"\n  testGetP2pPeerDevicesPromise = \"getP2pPeerDevicesPromise test\"\n  testGetP2pPeerDevicesCallback = \"getP2pPeerDevicesCallback test\"\n  testCreateGroup = \"createGroup test\"\n  testRemoveGroup = \"removeGroup test\"\n  testP2pConnect = \"P2pConnect test\"\n  testP2pCancelConnect = \"p2pCancelConnect test\"\n  testStartDiscoverDevices = \"startDiscoverDevices test\"\n  testStopDiscoverDevices = \"stopDiscoverDevices test\"\n  testDeletePersistentGroup = \"deletePersistentGroup test\"\n  testSetDeviceName = \"setDeviceName test\"\n  testOnP2pStateChange = \"OnP2pStateChange test\"\n  offP2pStateChange = \"on.p2pStateChange监听已关闭\"\n  onP2pStateChangeTest = \"打开注册P2P开关状态变化\"\n  offP2pStateChangeTest = \"关闭注册P2P开关状态改变事件\"\n  testOnP2pConnectionChange = \"OnP2pConnectionChange test\"\n  offP2pConnectionChange = \"on.P2pConnectionChange监听已关闭\"\n  offP2pConnectionChangeTest = \"关闭P2P连接状态改变事件\"\n  onP2pConnectionChangeTest = \"打开注册p2p连接状态变化\"\n  testOnP2pDeviceChange = \"OnP2pDeviceChange test\"\n  offP2pDeviceChange = \"on.P2pDeviceChange监听已关闭\"\n  offP2pDeviceChangeTest = \"关闭P2P设备状态改变事件\"\n  onP2pDeviceChangeTest = \"打开注册p2p设备连接状态变化\"\n  testOnP2pPeerDeviceChange = \"OnP2pPeerDeviceChange test\"\n  offP2pPeerDeviceChange = \"on.p2pPeerDeviceChange监听已关闭\"\n  offP2pPeerDeviceChangeTest = \"关闭P2P对端设备状态改变事件\"\n  onP2pPeerDeviceChangeTest = \"打开P2P对端设备状态变化\"\n  testOnP2pPersistentGroupChange = \"OnP2pPersistentGroupChange test\"\n  offP2pPersistentGroupChange = \"on.p2pPersistentGroupChange监听已关闭\"\n  offP2pPersistentGroupChangeTest = \"关闭P2P设备状态改变事件\"\n  onP2pPersistentGroupChangeTest = \"打开P2P永久组状态变化\"\n  testOnP2pDiscoveryChange = \"OnP2pDiscoveryChange test\"\n  offP2pDiscoveryChange = \"on.P2pDiscoveryChange监听已关闭\"\n  offP2pDiscoveryChangeTest = \"关闭发现设备状态改变事件\"\n  onP2pDiscoveryChangeTest = \"打开发现设备状态变化\"\n}\n\nlet messageDataManager = new MessageDataManager();\n\nexport default messageDataManager as MessageDataManager;", "llm_cg": {"MessageDataManager.constructor()": []}, "static_cg": {}}
{"source_code": "/**\n * Copyright (c) 2022 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport class LogData {\n  TAG = 'WIFI_Test'\n  //wifi\n  testEnableWifi_StartLog = \"testEnableWifi Start----------\"\n  testEnableWifi_EndLog = \"testEnableWifi End----------\"\n  testDisableWifi_StartLog = \"testDisableWifi Start----------\"\n  testDisableWifi_EndLog = \"testDisableWifi End----------\"\n  testIsWifiActive_StartLog = \"testIsWifiActive Start----------\"\n  testIsWifiActive_EndLog = \"testDisableWifi End----------\"\n  testScan_StartLog = \"testScan Start----------\"\n  testScan_EndLog = \"testScan End----------\"\n  testForcibleScan_StartLog = \"testForcibleScan Start----------\"\n  testForcibleScan_EndLog = \"testForcibleScan End----------\"\n  testGetScanInfosPromise_StartLog = \"testGetScanInfosPromise Start----------\"\n  testGetScanInfosPromise_EndLog = \"testGetScanInfosPromise End----------\"\n  testGetScanInfosPromise_successfulLog = \"getScanInfos promise successful\"\n  testGetScanInfos_infoLog = \"wifi received scan info: \"\n  testGetScanInfosCallback_StartLog = \"testGetScanInfosCallback Start----------\"\n  testGetScanInfosCallback_EndLog = \"testGetScanInfosCallback End----------\"\n  testGetScanInfosCallback_successfulLog = \"getScanInfos callback successful\"\n  testAddDeviceConfigPromise_StartLog = \"testAddDeviceConfigPromise Start----------\"\n  testAddDeviceConfigPromise_EndLog = \"testAddDeviceConfigPromise End----------\"\n  testAddDeviceConfigPromise_successfulLog = \"addDeviceConfig promise successful\"\n  testAddDeviceConfigLog = \"addDeviceConfig: \"\n  testAddDeviceConfigCallback_StartLog = \"testAddDeviceConfigCallback Start----------\"\n  testAddDeviceConfigCallback_EndLog = \"testAddDeviceConfigCallback End----------\"\n  testAddDeviceConfigCallback_successfulLog = \"addDeviceConfig Callback successful\"\n  testAddUntrustedConfigPromise_StartLog = \"testAddUntrustedConfigPromise Start----------\"\n  testAddUntrustedConfigPromise_EndLog = \"testAddUntrustedConfigPromise End----------\"\n  testAddUntrustedConfigPromise_successfulLog = \"addUntrustedConfig promise successful\"\n  testAddUntrustedConfigLog = \"addUntrustedConfig: \"\n  testAddUntrustedConfigCallback_StartLog = \"testAddUntrustedConfigCallback Start----------\"\n  testAddUntrustedConfigCallback_EndLog = \"testAddUntrustedConfigCallback End----------\"\n  testAddUntrustedConfigCallback_successfulLog = \"addUntrustedConfig Callback successful\"\n  testRemoveUntrustedConfigPromise_StartLog = \"testRemoveUntrustedConfigPromise Start----------\"\n  testRemoveUntrustedConfigPromise_EndLog = \"testRemoveUntrustedConfigPromise End----------\"\n  testRemoveUntrustedConfigPromise_successfulLog = \"removeUntrustedConfig promise successful\"\n  testRemoveUntrustedConfigLog = \"removeUntrustedConfig: \"\n  testRemoveUntrustedConfigCallback_StartLog = \"testRemoveUntrustedConfigCallback Start----------\"\n  testRemoveUntrustedConfigCallback_EndLog = \"testRemoveUntrustedConfigCallback End----------\"\n  testRemoveUntrustedConfigCallback_successfulLog = \"removeUntrustedConfig Callback successful\"\n  testConnectToNetwork_StartLog = \"testConnectToNetwork Start----------\"\n  testConnectToNetwork_EndLog = \"testConnectToNetwork End----------\"\n  testConnectToDevice_StartLog = \"testConnectToDevice Start----------\"\n  testConnectToDevice_EndLog = \"testConnectToDevice End----------\"\n  testDisconnect_StartLog = \"testDisconnect Start----------\"\n  testDisconnect_EndLog = \"testDisconnect End----------\"\n  testGetSignalLevel_StartLog = \"testGetSignalLevel Start----------\"\n  testGetSignalLevel_EndLog = \"testGetSignalLevel End----------\"\n  testGetLinkedInfoPromise_StartLog = \"testGetLinkedInfoPromise Start----------\"\n  testGetLinkedInfoPromise_EndLog = \"testGetLinkedInfoPromise End----------\"\n  testGetLinkedInfoPromise_successfulLog = \"getLinkedInfoPromise test successful\"\n  testGetLinkedInfoCallback_StartLog = \"testGetLinkedInfoCallback Start----------\"\n  testGetLinkedInfoCallback_EndLog = \"testGetLinkedInfoCallback End----------\"\n  testGetLinkedInfoCallback_successfulLog = \"getLinkedInfoCallback test successful\"\n  testIsConnected_StartLog = \"testIsConnected Start----------\"\n  testIsConnected_EndLog = \"testIsConnected End----------\"\n  testGetSupportedFeatures_StartLog = \"testGetSupportedFeatures Start----------\"\n  testGetSupportedFeatures_EndLog = \"testGetSupportedFeatures End----------\"\n  testIsFeatureSupported_StartLog = \"testIsFeatureSupported Start----------\"\n  testIsFeatureSupported_EndLog = \"testIsFeatureSupported End----------\"\n  testGetDeviceMacAddress_StartLog = \"testGetDeviceMacAddress Start----------\"\n  testGetDeviceMacAddress_EndLog = \"testGetDeviceMacAddress End----------\"\n  testGetIpInfo_StartLog = \"testGetIpInfo Start----------\"\n  testGetIpInfo_EndLog = \"testGetIpInfo End----------\"\n  testGetCountryCode_StartLog = \"testGetCountryCode Start----------\"\n  testGetCountryCode_EndLog = \"testGetCountryCode End----------\"\n  testReassociate_StartLog = \"testReassociate Start----------\"\n  testReassociate_EndLog = \"testReassociate End----------\"\n  testReConnect_StartLog = \"testReConnect Start----------\"\n  testReConnect_EndLog = \"testReConnect End----------\"\n  testGetDeviceConfigs_StartLog = \"testGetDeviceConfigs Start----------\"\n  testGetDeviceConfigs_EndLog = \"testGetDeviceConfigs End----------\"\n  testUpdateNetwork_StartLog = \"testUpdateNetwork Start----------\"\n  testUpdateNetwork_EndLog = \"testUpdateNetwork End----------\"\n  testDisableNetwork_StartLog = \"testDisableNetwork Start----------\"\n  testDisableNetwork_EndLog = \"testDisableNetwork End----------\"\n  testRemoveAllNetwork_StartLog = \"testRemoveAllNetwork Start----------\"\n  testRemoveAllNetwork_EndLog = \"testRemoveAllNetwork End----------\"\n  testRemoveDevice_StartLog = \"testRemoveDevice Start----------\"\n  testRemoveDevice_EndLog = \"testRemoveDevice End----------\"\n  testOnWifiStateChange_StartLog = \"testOnWifiStateChange Start----------\"\n  testOnWifiStateChange_EndLog = \"testOnWifiStateChange End----------\"\n  testOnWifiConnectionChange_StartLog = \"testOnWifiConnectionChange Start----------\"\n  testOnWifiConnectionChange_EndLog = \"testOnWifiConnectionChange End----------\"\n  testOnWifiScanStateChange_StartLog = \"testOnWifiConnectionChange Start----------\"\n  testOnWifiScanStateChange_EndLog = \"testOnWifiConnectionChange End----------\"\n  testOnWifiRssiChange_StartLog = \"testOnWifiRssiChange Start----------\"\n  testOnWifiRssiChange_EndLog = \"testOnWifiRssiChange End----------\"\n  testOnStreamChange_StartLog = \"testOnStreamChange Start----------\"\n  testOnStreamChange_EndLog = \"testOnStreamChange End----------\"\n  //hotspot\n  testEnableHotspot_StartLog = \"testEnableHotspot start--------------\"\n  testEnableHotspot_EndLog = \"testEnableHotspot End--------------\"\n  testDisableHotspot_StartLog = \"testDisableHotspot start--------------\"\n  testDisableHotspot_EndLog = \"testDisableHotspot End--------------\"\n  testIsHotspotDualBandSupported_StartLog = \"testIsHotspotDualBandSupported start--------------\"\n  testIsHotspotDualBandSupported_EndLog = \"testIsHotspotDualBandSupported End--------------\"\n  testIsHostActive_StartLog = \"testIsHostActive start--------------\"\n  testIsHostActive_EndLog = \"testIsHostActive End--------------\"\n  testSetHotspotConfig_StartLog = \"testSetHotspotConfig start--------------\"\n  testSetHotspotConfig_EndLog = \"testSetHotspotConfig End--------------\"\n  testGetHotspotConfig_StartLog = \"testGetHotspotConfig start--------------\"\n  testGetHotspotConfig_EndLog = \"testGetHotspotConfig End--------------\"\n  testGetStations_StartLog = \"testGetStations start--------------\"\n  testGetStations_EndLog = \"testGetStations End--------------\"\n  testOnHotspotStateChange_StartLog = \"testOnHotspotStateChange start--------------\"\n  testOnHotspotStateChange_EndLog = \"testOnHotspotStateChange End--------------\"\n  testOnHotspotStaJoin_StartLog = \"testOnHotspotStaJoin start--------------\"\n  testOnHotspotStaJoin_EndLog = \"testOnHotspotStaJoin End--------------\"\n  testOnHotspotStaLeave_StartLog = \"testOnHotspotStaLeave start--------------\"\n  testOnHotspotStaLeave_EndLog = \"testOnHotspotStaLeave End--------------\"\n  //p2p\n  testGetP2pLinkedInfoPromise_StartLog = \"testGetP2pLinkedInfoPromise Start----------\"\n  testGetP2pLinkedInfoPromise_EndLog = \"testGetP2pLinkedInfoPromise End----------\"\n  getP2pLinkedInfoPromise_successfulLog = \"getP2pLinkedInfoPromise successful\"\n  testGetP2pLinkedInfoCallback_StartLog = \"testGetP2pLinkedInfoCallback Start----------\"\n  testGetP2pLinkedInfoCallback_EndLog = \"testGetP2pLinkedInfoCallback End----------\"\n  getP2pLinkedInfoCallback_successfulLog = \"getP2pLinkedInfoCallback successful \"\n  testGetCurrentGroupPromise_StartLog = \"testGetCurrentGroupPromise Start----------\"\n  testGetCurrentGroupPromise_EndLog = \"testGetCurrentGroupPromise End----------\"\n  testGetCurrentGroupPromise_successfulLog = \"getCurrentGroupPromise successful\"\n  testGetCurrentGroupCallback_StartLog = \"testGetCurrentGroupCallback Start----------\"\n  testGetCurrentGroupCallback_EndLog = \"testGetCurrentGroupCallback End----------\"\n  getCurrentGroupCallback_successfulLog = \"getCurrentGroupCallback successful\"\n  testGetP2pPeerDevicesPromise_StartLog = \"testGetP2pPeerDevicesPromise Start----------\"\n  testGetP2pPeerDevicesPromise_EndLog = \"testGetP2pPeerDevicesPromise End----------\"\n  getP2pPeerDevicesPromise_successfulLog = \"getP2pPeerDevicesPromise successful\"\n  testGetP2pPeerDevicesCallback_StartLog = \"testGetP2pPeerDevicesCallback Start----------\"\n  testGetP2pPeerDevicesCallback_EndLog = \"testGetP2pPeerDevicesCallback End----------\"\n  getP2pPeerDevicesCallback_successfulLog = \"getP2pPeerDevicesCallback successful\"\n  testCreateGroup_StartLog = \"testCreateGroup Start----------\"\n  testCreateGroup_EndLog = \"testCreateGroup End----------\"\n  testRemoveGroup_StartLog = \"testRemoveGroup Start----------\"\n  testRemoveGroup_EndLog = \"testRemoveGroup End----------\"\n  testP2pConnect_StartLog = \"testP2pConnect Start----------\"\n  testP2pConnect_EndLog = \"testP2pConnect End----------\"\n  testP2pCancelConnect_StartLog = \"testP2pCancelConnect Start----------\"\n  testP2pCancelConnect_EndLog = \"testP2pCancelConnect End----------\"\n  testStartDiscoverDevices_StartLog = \"testStartDiscoverDevices Start----------\"\n  testStartDiscoverDevices_EndLog = \"testStartDiscoverDevices End----------\"\n  testStopDiscoverDevices_StartLog = \"testStopDiscoverDevices Start----------\"\n  testStopDiscoverDevices_EndLog = \"testStopDiscoverDevices End----------\"\n  testDeletePersistentGroup_StartLog = \"testDeletePersistentGroup Start----------\"\n  testDeletePersistentGroup_EndLog = \"testDeletePersistentGroup End----------\"\n  testSetDeviceName_StartLog = \"testSetDeviceName Start----------\"\n  testSetDeviceName_EndLog = \"testSetDeviceName End----------\"\n  testOnP2pStateChange_StartLog = \"testOnP2pStateChange Start----------\"\n  testOnP2pStateChange_EndLog = \"testOnP2pStateChange End----------\"\n  testOnP2pConnectionChange_StartLog = \"testOnP2pConnectionChange Start----------\"\n  testOnP2pConnectionChange_EndLog = \"testOnP2pConnectionChange End----------\"\n  testOnP2pDeviceChange_StartLog = \"testOnP2pDeviceChange Start----------\"\n  testOnP2pDeviceChange_EndLog = \"testOnP2pDeviceChange End----------\"\n  testOnP2pPeerDeviceChange_StartLog = \"testOnP2pPeerDeviceChange Start----------\"\n  testOnP2pPeerDeviceChange_EndLog = \"testOnP2pPeerDeviceChange End----------\"\n  testOnP2pPersistentGroupChange_StartLog = \"testOnP2pPersistentGroupChange Start----------\"\n  testOnP2pPersistentGroupChange_EndLog = \"testOnP2pPersistentGroupChange End----------\"\n  testOnP2pDiscoveryChange_StartLog = \"testOnP2pDiscoveryChange Start----------\"\n  testOnP2pDiscoveryChange_EndLog = \"testOnP2pDiscoveryChange End----------\"\n}\n\nlet logData = new LogData();\n\nexport default logData as LogData;", "llm_cg": {"LogData.constructor()": []}, "static_cg": {}}
{"source_code": "/**\n * Copyright (c) 2022 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport class MessageData {\n  TAG = 'WIFI_Test'\n  //wifi\n  testEnableWifi = \"enableWifi test\";\n  testIsActive = \"Wifi已经使能\"\n  testWifiEnableResult = \"Wifi使能执行结果：\"\n  testEnableResult = \"使能结果：\"\n  testWifiEnableMaybe = \"Wifi已打开或打开失败,请确认\"\n  testDisableWifi = \"testDisableWifi\"\n  testIsInactive = \"WIFI还未使能\"\n  testWifiDisableResult = \"Wifi去使能执行结果：\"\n  testDisableResult = \"去使能结果：\"\n  testWifiDisableMaybe = \"Wifi已关闭或关闭失败,请确认\"\n  testIsWifiActive = \"testIsWifiActive\"\n  testIsActiveResult = \"wifi使能结果为：\"\n  testScan = \"scan test\"\n  testScanResult = \"scan: \"\n  testForcibleScan = \"ForcibleScan test\"\n  testForcibleScanResult = \"ForcibleScan: \"\n  testGetScanInfosPromise = \"getScanInfosPromise test\"\n  testGetScanInfo = \"WifiScanInfo: \"\n  testGetScanInfosCallback = \"getScanInfosCallback test\"\n  testAddDeviceConfigPromise = \"addDeviceConfigPromise test\"\n  testAddDeviceConfig = \"addDeviceConfig: \"\n  testAddDeviceConfigCallback = \"addDeviceConfigCallback test\"\n  testAddUntrustedConfigPromise = \"addUntrustedConfigPromise test\"\n  testAddUntrustedConfig = \"addUntrustedConfig: \"\n  testAddUntrustedConfigCallback = \"addUntrustedConfigCallback test\"\n  testRemoveUntrustedConfigPromise = \"removeUntrustedConfigPromise test\"\n  testRemoveUntrustedConfig = \"removeUntrustedConfig: \"\n  testRemoveUntrustedConfigCallback = \"removeUntrustedConfigCallback test\"\n  testConnectToNetwork = \"connectToNetwork test\"\n  testConnectToDevice = \"connectToDevice test\"\n  testDisconnect = \"disconnect test\"\n  testGetSignalLevel = \"getSignalLevel test\"\n  testGetLinkedInfoPromise = \"getLinkedInfoPromise test\"\n  testGetLinkedInfoCallback = \"getLinkedInfoCallback test\"\n  testIsConnected = \"isConnected test\"\n  testGetSupportedFeatures = \"getSupportedFeatures test\"\n  testIsFeatureSupported = \"isFeatureSupported test\"\n  testGetDeviceMacAddress = \"getDeviceMacAddress test\"\n  testGetIpInfo = \"getIpInfo test\"\n  testGetCountryCode = \"getCountryCode test\"\n  testReassociate = \"reAssociate test\"\n  testReConnect = \"reConnect test\"\n  testGetDeviceConfigs = \"getDeviceConfigs test\"\n  testUpdateNetwork = \"updateNetwork test\"\n  testDisableNetwork = \"disableNetWork test\"\n  testRemoveAllNetwork = \"removeAllNetwork test\"\n  testRemoveDevice = \"removeDevice test\"\n  testOnWifiStateChange = \"onWifiStateChange test\"\n  offWifiStateChange = \"on.WifiStateChange监听已关闭\"\n  offWifiStateChangeTest = \"关闭注册WLAN状态改变事件\"\n  onWifiStateChange = \"on.WifiStateChange监听已打开\"\n  onWifiStateChangeTest = \"打开注册WLAN状态变化\"\n  wifiStateChange = \"wifi状态: \"\n  testOnWifiConnectionChange = \"onWifiConnectionChange test\"\n  offWifiConnectionChange = \"on.wifiConnectionChange监听已关闭\"\n  offWifiConnectionChangeTest = \"关闭WLAN连接状态改变事件\"\n  onWifiConnectionChangeTest = \"打开注册WLAN连接状态变化\"\n  testOnWifiScanStateChange = \"onWifiScanStateChange test\"\n  offWifiScanStateChange = \"on.wifiScanStateChange监听已关闭\"\n  offWifiScanStateChangeTest = \"关闭扫描状态改变事件\"\n  onWifiScanStateChangeTest = \"打开注册扫描状态变化\"\n  testOnWifiRssiChange = \"onWifiRssiChange test\"\n  offWifiRssiChange = \"on.wifiRssiChange监听已关闭\"\n  offWifiRssiChangeTest = \"关闭RSSI状态变化事件\"\n  onWifiRssiChangeTest = \"打开注册RSSI状态变化\"\n  testOnStreamChange = \"onStreamChange test\"\n  offStreamChange = \"on.streamChange监听已关闭\"\n  offStreamChangeTest = \"关闭注册流改变事件\"\n  onStreamChangeTest = \"打开注册流变化\"\n  //hotspot\n  testEnableHotspot = \"enableHotspot test\"\n  testDisableHotspot = \"disableHotspot test\"\n  hotspot_enable = \"热点已经使能\"\n  hotspot_disEnable = \"热点还未使能\"\n  testIsHotspotDualBandSupported = \"isHotspotDualBandSupported test\"\n  testIsHotspotActive = \"isHotspotActive test\"\n  testSetHotspotConfig = \"SetHotspotConfig test\"\n  testGetHotspotConfig = \"getHotspotConfig test\"\n  testGetStations = \"GetStations test\"\n  testOnHotspotStateChange = \"onHotspotStateChange test\"\n  offHotspotStateChange = \"on.hotspotStateChange监听已关闭\"\n  offHotspotStateChangeTest = \"关闭注册热点状态改变事件\"\n  onHotspotStateChangeTest = \"打开注册热点状态变化\"\n  testOnHotspotStaJoin = \"onHotspotStaJoin test\"\n  offHotspotStaJoin = \"on.hotspotStaJoin监听已关闭\"\n  offHotspotStaJoinTest = \"关闭注册Wi-Fi 热点 sta加入变化事件\"\n  onHotspotStaJoinTest = \"打开注册Wi-Fi 热点 sta加入变化\"\n  testOnHotspotStaLeave = \"onHotspotStaLeave test\"\n  offHotspotStaLeave = \"on.hotspotStaLeave监听已关闭\"\n  offHotspotStaLeaveTest = \"关闭注册Wi-Fi 热点 sta离开变化事件\"\n  onHotspotStaLeaveTest = \"打开注册Wi-Fi 热点 sta离开变化\"\n  //p2p\n  testGetP2pLinkedInfoPromise = \"getP2pLinkedInfoPromise test\"\n  testGetP2pLinkedInfoCallback = \"getP2pLinkedInfoCallback test\"\n  testGetCurrentGroupPromise = \"getCurrentGroupPromise test\"\n  testGetCurrentGroupCallback = \"getCurrentGroupCallback test\"\n  testGetP2pPeerDevicesPromise = \"getP2pPeerDevicesPromise test\"\n  testGetP2pPeerDevicesCallback = \"getP2pPeerDevicesCallback test\"\n  testCreateGroup = \"createGroup test\"\n  testRemoveGroup = \"removeGroup test\"\n  testP2pConnect = \"P2pConnect test\"\n  testP2pCancelConnect = \"p2pCancelConnect test\"\n  testStartDiscoverDevices = \"startDiscoverDevices test\"\n  testStopDiscoverDevices = \"stopDiscoverDevices test\"\n  testDeletePersistentGroup = \"deletePersistentGroup test\"\n  testSetDeviceName = \"setDeviceName test\"\n  testOnP2pStateChange = \"OnP2pStateChange test\"\n  offP2pStateChange = \"on.p2pStateChange监听已关闭\"\n  onP2pStateChangeTest = \"打开注册P2P开关状态变化\"\n  offP2pStateChangeTest = \"关闭注册P2P开关状态改变事件\"\n  testOnP2pConnectionChange = \"OnP2pConnectionChange test\"\n  offP2pConnectionChange = \"on.P2pConnectionChange监听已关闭\"\n  offP2pConnectionChangeTest = \"关闭P2P连接状态改变事件\"\n  onP2pConnectionChangeTest = \"打开注册p2p连接状态变化\"\n  testOnP2pDeviceChange = \"OnP2pDeviceChange test\"\n  offP2pDeviceChange = \"on.P2pDeviceChange监听已关闭\"\n  offP2pDeviceChangeTest = \"关闭P2P设备状态改变事件\"\n  onP2pDeviceChangeTest = \"打开注册p2p设备连接状态变化\"\n  testOnP2pPeerDeviceChange = \"OnP2pPeerDeviceChange test\"\n  offP2pPeerDeviceChange = \"on.p2pPeerDeviceChange监听已关闭\"\n  offP2pPeerDeviceChangeTest = \"关闭P2P对端设备状态改变事件\"\n  onP2pPeerDeviceChangeTest = \"打开P2P对端设备状态变化\"\n  testOnP2pPersistentGroupChange = \"OnP2pPersistentGroupChange test\"\n  offP2pPersistentGroupChange = \"on.p2pPersistentGroupChange监听已关闭\"\n  offP2pPersistentGroupChangeTest = \"关闭P2P设备状态改变事件\"\n  onP2pPersistentGroupChangeTest = \"打开P2P永久组状态变化\"\n  testOnP2pDiscoveryChange = \"OnP2pDiscoveryChange test\"\n  offP2pDiscoveryChange = \"on.P2pDiscoveryChange监听已关闭\"\n  offP2pDiscoveryChangeTest = \"关闭发现设备状态改变事件\"\n  onP2pDiscoveryChangeTest = \"打开发现设备状态变化\"\n}\n\nlet messageData = new MessageData();\n\nexport default messageData as MessageData;", "llm_cg": {"MessageData.constructor()": []}, "static_cg": {}}
{"source_code": "/**\n * Copyright (c) 2022 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n *  ISettingsController of wifi test\n */\n\nexport default interface ISettingsController {\n  /**\n   * Bind component.\n   */\n  bindComponent(component: any): ISettingsController;\n\n  /**\n   *  Bind component's properties.\n   */\n  bindProperties(componentProperties: string[], controllerProperties?: string[]): ISettingsController\n\n  /**\n   * Initialize data.\n   */\n  initData(): ISettingsController;\n\n  /**\n   * Subscribe listeners.\n   */\n  subscribe(): ISettingsController;\n\n  /**\n   * Unsubscribe listeners.\n   */\n  unsubscribe(): ISettingsController;\n}", "llm_cg": {"ISettingsController.bindComponent(component: any)": [], "ISettingsController.bindProperties(componentProperties: string[], controllerProperties?: string[])": [], "ISettingsController.initData()": [], "ISettingsController.subscribe()": [], "ISettingsController.unsubscribe()": []}, "static_cg": {}}
{"source_code": "/**\n * Copyright (c) 2022 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport ISettingsController from './ISettingsController'\n\n/**\n * BaseSettingsController Of Wifi test\n */\n\nexport default abstract class BaseSettingsController implements ISettingsController {\n  protected getComponent: () => any;\n\n  /**\n   * Bind component.\n   */\n  bindComponent(component: any): ISettingsController {\n    this.getComponent = () => component;\n\n    // set default property values by component\n    for (let key in this) {\n      if (key in component) {\n        this[key] = component[key];\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Bind component's properties, note that only basic types can be transported.\n   * Type like Resource may meet unexpected error.\n   * If you want to transport resource string or color, ets. AppStorage is suggested @StorageLink.\n   */\n  bindProperties(componentProperties: string[], controllerProperties?: string[]): ISettingsController {\n    for (let i = 0; i < componentProperties.length; i++) {\n      this.defineBoundProperty(componentProperties[i], controllerProperties ? controllerProperties[i] : componentProperties[i]);\n    }\n    return this;\n  }\n\n  /**\n   * Initialize data.\n   */\n  initData(): ISettingsController {\n    return this;\n  };\n\n  /**\n   * Subscribe listeners.\n   */\n  subscribe(): ISettingsController {\n    return this;\n  };\n\n  /**\n   * Unsubscribe listeners.\n   */\n  unsubscribe(): ISettingsController {\n    return this;\n  };\n\n  /**\n   * Define bound properties.\n   */\n  private defineBoundProperty(componentProperty: string, controllerProperty: string): void {\n    let __v = this[controllerProperty];\n\n    Object.defineProperty(this, controllerProperty, {\n      get: function () {\n        return __v;\n      },\n      set: function (value) {\n        __v = value;\n        this.getComponent()[componentProperty] = value;\n      }\n    });\n  }\n}", "llm_cg": {"BaseSettingsController.bindComponent(component)": ["BaseSettingsController.%AM0$getComponent()"], "BaseSettingsController.bindProperties(componentProperties, controllerProperties)": ["BaseSettingsController.%AM1$defineBoundProperty(componentProperty, controllerProperty)"], "BaseSettingsController.defineBoundProperty(componentProperty, controllerProperty)": ["BaseSettingsController.%AM0$getComponent()"]}, "static_cg": {}}
{"source_code": "/**\n * Copyright (c) 2022 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport hilog from '@ohos.hilog';\nimport AbilityStage from \"@ohos.app.ability.AbilityStage\"\n\n/**\n * MyAbilityStage Of Wifi test\n */\n\nexport default class MyAbilityStage extends AbilityStage {\n  onCreate() {\n    hilog.isLoggable(0x0000, 'testTag', hilog.LogLevel.INFO);\n    hilog.info(0x0000, 'testTag', '%{public}s', 'AbilityStage onCreate');\n  }\n}", "llm_cg": {"MyAbilityStage.onCreate()": []}, "static_cg": {}}
{"source_code": "/*\n * Copyright (c) 2022 Huawei Device Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport hilog from '@ohos.hilog'\n\nclass Logger {\n  private domain: number\n  private prefix: string\n  private format: string = '%{public}s, %{public}s'\n\n  constructor(prefix: string) {\n    this.prefix = prefix\n    this.domain = 0xFF00\n  }\n\n  debug(...args: string[]) {\n    hilog.debug(this.domain, this.prefix, this.format, args)\n  }\n\n  info(...args: string[]) {\n    hilog.info(this.domain, this.prefix, this.format, args)\n  }\n\n  warn(...args: string[]) {\n    hilog.warn(this.domain, this.prefix, this.format, args)\n  }\n\n  error(...args: string[]) {\n    hilog.error(this.domain, this.prefix, this.format, args)\n  }\n}\n\nexport default new Logger('Sample_ComponentCollection')", "llm_cg": {"Logger.debug(...args: string[])": ["Logger.%AM0$debug(unknown, unknown, unknown, unknown)"], "Logger.info(...args: string[])": ["Logger.%AM1$info(unknown, unknown, unknown, unknown)"], "Logger.warn(...args: string[])": ["Logger.%AM2$warn(unknown, unknown, unknown, unknown)"], "Logger.error(...args: string[])": ["Logger.%AM3$error(unknown, unknown, unknown, unknown)"]}, "static_cg": {"@test/101.ts: %dflt.[static]%dflt()": ["@test/101.ts: Logger.constructor(string)"]}}
{"source_code": "/*\n * Copyright (c) 2024 Huawei Device Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass InputUtil {\n  isEmpty(str?: string): boolean {\n    return str == 'undefined' || !str || !new RegExp(\"[^\\\\s]\").test(str)\n  }\n\n  checkNeedNumberSpace(numText: string) {\n    let isSpace: RegExp = new RegExp('[\\\\+;,#\\\\*]', 'g')\n    let isRule: RegExp = new RegExp('^\\\\+.*')\n    if (isSpace.test(numText)) {\n      return isRule.test(numText)\n    }\n    return true\n  }\n\n  removeSpace(str: string): string {\n    if (this.isEmpty(str)) {\n      return ''\n    }\n    return str.replace(new RegExp(\"[\\\\s]\", \"g\"), '')\n  }\n}\n\nexport default new InputUtil()", "llm_cg": {"InputUtil.isEmpty(str?: string)": [], "InputUtil.checkNeedNumberSpace(numText: string)": [], "InputUtil.removeSpace(str: string)": ["InputUtil.isEmpty(str?: string)"]}, "static_cg": {"@test/102.ts: InputUtil.removeSpace(string)": ["@test/102.ts: InputUtil.isEmpty(string)"]}}
{"source_code": "/*\n * Copyright (c) 2022-2023 Huawei Device Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport AbilityStage from '@ohos.app.ability.AbilityStage'\nimport Logger from '../util/Logger'\n\nconst TAG: string = 'MyAbilityStage'\n\nexport default class MyAbilityStage extends AbilityStage {\n  onCreate() {\n    Logger.info(TAG, 'onCreate')\n  }\n}", "llm_cg": {"MyAbilityStage.onCreate()": []}, "static_cg": {}}
{"source_code": "/*\n * Copyright (c) 2022-2023 Huawei Device Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport UIAbility from '@ohos.app.ability.UIAbility'\nimport Logger from '../util/Logger'\nimport window from '@ohos.window';\nimport { KeyboardAvoidMode } from '@ohos.arkui.UIContext';\n\nconst TAG: string = 'MainAbility'\n\nexport default class MainAbility extends UIAbility {\n  onCreate(want, launchParam) {\n    Logger.info(TAG, 'onCreate');\n    AppStorage.setOrCreate('context', this.context);\n  }\n\n  onDestroy() {\n    Logger.info(TAG, 'onDestroy')\n  }\n\n  onWindowStageCreate(windowStage) {\n    // Main window is created, set main page for this ability\n    Logger.info(TAG, 'onWindowStageCreate')\n    try {\n      let windowClass = null;\n      window.getLastWindow(this.context, (err, data) => {\n        if (err.code) {\n          Logger.error('Failed to obtain the top window. Cause: ' + JSON.stringify(err));\n          return;\n        }\n        Logger.info('Succeeded in obtaining the top window. Data: ' + JSON.stringify(data));\n        windowClass = data;\n        let systemBarProperties = {\n          statusBarColor: \"#f1f3f5\"\n        };\n        windowClass.setWindowSystemBarProperties(systemBarProperties, (err) => {\n          if (err.code) {\n            Logger.error('Failed to set the system bar properties. Cause: ' + JSON.stringify(err));\n            return;\n          }\n          Logger.info('Succeeded in setting the system bar properties.');\n        })\n        windowClass.on('keyboardHeightChange', (data: number) => {\n          AppStorage.setOrCreate('keyboardHeight', data);\n        })\n      })\n    } catch (exception) {\n      Logger.error('Failed to obtain the top window. Cause: ' + JSON.stringify(exception));\n    }\n    windowStage.loadContent('pages/Index', (err, data) => {\n      let a = windowStage.getMainWindowSync().getUIContext().getKeyboardAvoidMode();\n      windowStage.getMainWindowSync().getUIContext().setKeyboardAvoidMode(KeyboardAvoidMode.OFFSET);\n      if (err) {\n        Logger.error(TAG, `Failed to load the content. Cause: ${JSON.stringify(err)}`)\n        return\n      }\n      Logger.info(TAG, `Succeeded in loading the content. Data: ${JSON.stringify(data)}`)\n    })\n  }\n\n  onWindowStageDestroy() {\n    // Main window is destroyed, release UI related resources\n    Logger.info(TAG, 'onWindowStageDestroy')\n  }\n\n  onForeground() {\n    // Ability has brought to foreground\n    Logger.info(TAG, 'onForeground')\n  }\n\n  onBackground() {\n    // Ability has back to background\n    Logger.info(TAG, 'onBackground')\n  }\n}", "llm_cg": {"MainAbility.onCreate(want, launchParam)": ["Logger.info(TAG, 'onCreate')", "AppStorage.setOrCreate('context', this.context)"], "MainAbility.onDestroy()": ["Logger.info(TAG, 'onDestroy')"], "MainAbility.onWindowStageCreate(windowStage)": ["Logger.info(TAG, 'onWindowStageCreate')", "window.getLastWindow(this.context, (err, data))", "Logger.error('Failed to obtain the top window. Cause: ' + JSON.stringify(err))", "Logger.info('Succeeded in obtaining the top window. Data: ' + JSON.stringify(data))", "windowClass.setWindowSystemBarProperties(systemBarProperties, (err))", "Logger.error('Failed to set the system bar properties. Cause: ' + JSON.stringify(err))", "Logger.info('Succeeded in setting the system bar properties.')", "AppStorage.setOrCreate('keyboardHeight', data)", "Logger.error('Failed to obtain the top window. Cause: ' + JSON.stringify(exception))", "windowStage.loadContent('pages/Index', (err, data))", "windowStage.getMainWindowSync().getUIContext().getKeyboardAvoidMode()", "windowStage.getMainWindowSync().getUIContext().setKeyboardAvoidMode(KeyboardAvoidMode.OFFSET)", "Logger.error(TAG, `Failed to load the content. Cause: ${JSON.stringify(err)}`)", "Logger.info(TAG, `Succeeded in loading the content. Data: ${JSON.stringify(data)}`)"], "MainAbility.onWindowStageDestroy()": ["Logger.info(TAG, 'onWindowStageDestroy')"], "MainAbility.onForeground()": ["Logger.info(TAG, 'onForeground')"], "MainAbility.onBackground()": ["Logger.info(TAG, 'onBackground')"]}, "static_cg": {"@test/104.ts: MainAbility.onWindowStageCreate(unknown)": ["@test/104.ts: MainAbility.%AM0$onWindowStageCreate([windowClass], unknown, unknown)", "@test/104.ts: MainAbility.%AM3$onWindowStageCreate([windowStage], unknown, unknown)"], "@test/104.ts: MainAbility.%AM0$onWindowStageCreate([windowClass], unknown, unknown)": ["@test/104.ts: MainAbility.%AM1$%AM0$onWindowStageCreate(unknown)", "@test/104.ts: MainAbility.%AM2$%AM0$onWindowStageCreate(number)"]}}
{"source_code": "/*\n * Copyright (c) 2023 Huawei Device Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type AbilityConstant from '@ohos.app.ability.AbilityConstant';\nimport hilog from '@ohos.hilog';\nimport UIAbility from '@ohos.app.ability.UIAbility';\nimport type Want from '@ohos.app.ability.Want';\nimport window from '@ohos.window';\nimport type { BusinessError } from '@ohos.base';\nimport type { Configuration } from '@ohos.app.ability.Configuration';\n\nconst TAG: string = '[EntryAbility]';\nconst DOMAIN_NUMBER: number = 0xFF00;\n\nlet systemLanguage: string | undefined; // 系统当前语言\n\nexport default class EntryAbility extends UIAbility {\n  windowStage: window.WindowStage | undefined = undefined;\n\n  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {\n    hilog.info(DOMAIN_NUMBER, TAG, '%{public}s', 'Ability onCreate');\n    // Main window is created, set main page for this ability\n    let uiAbilityContext = this.context;\n    let applicationContext = this.context.getApplicationContext();\n    systemLanguage = this.context.config.language; // UIAbility实例首次加载时，获取系统当前语言\n    hilog.info(DOMAIN_NUMBER, TAG, `systemLanguage is ${systemLanguage}`);\n  }\n\n  onDestroy(): void {\n    // 系统资源的释放、数据的保存等\n    hilog.info(DOMAIN_NUMBER, TAG, '%{public}s', 'Ability onDestroy');\n  }\n\n  onWindowStageCreate(windowStage: window.WindowStage): void {\n    this.windowStage = windowStage;\n    // 设置WindowStage的事件订阅（获焦/失焦、可见/不可见）\n    try {\n      windowStage.on('windowStageEvent', (data) => {\n        let stageEventType: window.WindowStageEventType = data;\n        switch (stageEventType) {\n          case window.WindowStageEventType.SHOWN: // 切到前台\n            hilog.info(DOMAIN_NUMBER, TAG, 'windowStage foreground.');\n            break;\n          case window.WindowStageEventType.ACTIVE: // 获焦状态\n            hilog.info(DOMAIN_NUMBER, TAG, 'windowStage active.');\n            break;\n          case window.WindowStageEventType.INACTIVE: // 失焦状态\n            hilog.info(DOMAIN_NUMBER, TAG, 'windowStage inactive.');\n            break;\n          case window.WindowStageEventType.HIDDEN: // 切到后台\n            hilog.info(DOMAIN_NUMBER, TAG, 'windowStage background.');\n            break;\n          default:\n            break;\n        }\n      });\n    } catch (exception) {\n      hilog.error(DOMAIN_NUMBER, TAG, 'Failed to enable the listener for window stage event changes. Cause:' + JSON.stringify(exception));\n    };\n    hilog.info(DOMAIN_NUMBER, TAG, '%{public}s', 'Ability onWindowStageCreate');\n\n    // 设置UI加载\n    // Main window is created, set main page for this ability\n    windowStage.loadContent('pages/Index', (err, data) => {\n      if (err.code) {\n        hilog.error(DOMAIN_NUMBER, TAG, 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');\n        return;\n      }\n      hilog.info(DOMAIN_NUMBER, TAG, 'Succeeded in loading the content. Data: %{public}s', JSON.stringify(data) ?? '');\n    });\n  }\n\n  onWindowStageDestroy(): void {\n    // Main window is destroyed, release UI related resources\n    hilog.info(DOMAIN_NUMBER, TAG, '%{public}s', 'Ability onWindowStageDestroy');\n    // 释放UI资源\n    // 例如在onWindowStageDestroy()中注销获焦/失焦等WindowStage事件\n    try {\n      if (this.windowStage) {\n        this.windowStage.off('windowStageEvent');\n      }\n    } catch (err) {\n      let code = (err as BusinessError).code;\n      let message = (err as BusinessError).message;\n      hilog.error(DOMAIN_NUMBER, TAG, `Failed to disable the listener for windowStageEvent. Code is ${code}, message is ${message}`);\n    };\n  }\n\n  onForeground(): void {\n    // 申请系统需要的资源，或者重新申请在onBackground()中释放的资源\n    // Ability has brought to foreground\n    hilog.info(DOMAIN_NUMBER, TAG, '%{public}s', 'Ability onForeground');\n  }\n\n  onBackground(): void {\n    // 释放UI不可见时无用的资源，或者在此回调中执行较为耗时的操作\n    // 例如状态保存等\n    // Ability has back to background\n    hilog.info(DOMAIN_NUMBER, TAG, '%{public}s', 'Ability onBackground');\n  }\n\n  onConfigurationUpdate(newConfig: Configuration): void {\n    hilog.info(DOMAIN_NUMBER, TAG, `onConfigurationUpdated systemLanguage is ${systemLanguage}, newConfig: ${JSON.stringify(newConfig)}`);\n\n    if (systemLanguage !== newConfig.language) {\n      hilog.info(DOMAIN_NUMBER, TAG, `systemLanguage from ${systemLanguage} changed to ${newConfig.language}`);\n      systemLanguage = newConfig.language; // 将变化之后的系统语言保存，作为下一次变化前的系统语言\n    }\n  }\n};\n", "llm_cg": {"EntryAbility.onCreate(Want, AbilityConstant.LaunchParam)": ["EntryAbility.context.getApplicationContext()", "EntryAbility.context.config.language"], "EntryAbility.onWindowStageCreate(window.WindowStage)": ["window.WindowStage.on(string, Function)", "window.WindowStage.loadContent(string, Function)"], "EntryAbility.onWindowStageDestroy()": ["window.WindowStage.off(string)"], "EntryAbility.onConfigurationUpdate(Configuration)": []}, "static_cg": {"@test/105.ts: EntryAbility.onWindowStageCreate(window.WindowStage)": ["@test/105.ts: EntryAbility.%AM0$onWindowStageCreate(unknown)", "@test/105.ts: EntryAbility.%AM1$onWindowStageCreate(unknown, unknown)"]}}
{"source_code": "/*\n * Copyright (c) 2023 Huawei Device Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type AbilityConstant from '@ohos.app.ability.AbilityConstant';\nimport hilog from '@ohos.hilog';\nimport UIAbility from '@ohos.app.ability.UIAbility';\nimport type Want from '@ohos.app.ability.Want';\nimport type window from '@ohos.window';\nimport abilityAccessCtrl from '@ohos.abilityAccessCtrl';\nimport type { BusinessError } from '@ohos.base';\nimport type { Context } from '@ohos.abilityAccessCtrl';\nimport type { PermissionRequestResult } from '@ohos.abilityAccessCtrl';\nimport type { Permissions } from '@ohos.abilityAccessCtrl';\n\nconst permissions: Array<Permissions> = ['ohos.permission.DISTRIBUTED_DATASYNC'];\n\nconst TAG: string = '[CollaborateAbility]';\nconst DOMAIN_NUMBER: number = 0xFF00;\n\nexport default class CollaborateAbility extends UIAbility {\n  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {\n    hilog.info(DOMAIN_NUMBER, TAG, '%{public}s', 'Ability onCreate');\n    // Main window is created, set main page for this ability\n    let context: Context = this.context;\n    let atManager: abilityAccessCtrl.AtManager = abilityAccessCtrl.createAtManager();\n    // requestPermissionsFromUser会判断权限的授权状态来决定是否唤起弹窗\n    atManager.requestPermissionsFromUser(context, permissions).then((data: PermissionRequestResult) => {\n      let grantStatus: Array<number> = data.authResults;\n      let length: number = grantStatus.length;\n      for (let i = 0; i < length; i++) {\n        if (grantStatus[i] === 0) {\n          // 用户授权，可以继续访问目标操作\n        } else {\n          // 用户拒绝授权，提示用户必须授权才能访问当前页面的功能，并引导用户到系统设置中打开相应的权限\n          return;\n        }\n      }\n      // 授权成功\n    }).catch((err: BusinessError) => {\n      hilog.error(DOMAIN_NUMBER, TAG, `Failed to request permissions from user. Code is ${err.code}, message is ${err.message}`);\n    });\n  };\n\n  onWindowStageCreate(windowStage: window.WindowStage): void {\n    // Main window is created, set main page for this ability\n    hilog.info(DOMAIN_NUMBER, TAG, '%{public}s', 'Ability onWindowStageCreate');\n    windowStage.loadContent('pages/page_collaborateability/Page_CollaborateAbility', (err, data) => {\n      if (err.code) {\n        hilog.error(DOMAIN_NUMBER, TAG, 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');\n        return;\n      }\n      hilog.info(DOMAIN_NUMBER, TAG, 'Succeeded in loading the content. Data: %{public}s', JSON.stringify(data) ?? '');\n    });\n  };\n};\n", "llm_cg": {"CollaborateAbility.onCreate(Want, AbilityConstant.LaunchParam)": ["abilityAccessCtrl.AtManager.requestPermissionsFromUser(Context, Array<Permissions>)"], "CollaborateAbility.onWindowStageCreate(window.WindowStage)": ["window.WindowStage.loadContent(string, (err: BusinessError, data: any) => void)"]}, "static_cg": {"@test/106.ts: CollaborateAbility.onCreate(Want, AbilityConstant.LaunchParam)": ["@test/106.ts: CollaborateAbility.%AM1$onCreate(PermissionRequestResult)", "@test/106.ts: CollaborateAbility.%AM0$onCreate(BusinessError)"], "@test/106.ts: CollaborateAbility.onWindowStageCreate(window.WindowStage)": ["@test/106.ts: CollaborateAbility.%AM2$onWindowStageCreate(unknown, unknown)"]}}
{"source_code": "/*\n * Copyright (c) 2023 Huawei Device Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type AbilityConstant from '@ohos.app.ability.AbilityConstant';\nimport type AbilityLifecycleCallback from '@ohos.app.ability.AbilityLifecycleCallback';\nimport hilog from '@ohos.hilog';\nimport UIAbility from '@ohos.app.ability.UIAbility';\nimport type Want from '@ohos.app.ability.Want';\nimport type window from '@ohos.window';\n\nconst TAG: string = '[LifecycleAbility]';\nconst DOMAIN_NUMBER: number = 0xFF00;\n\nexport default class LifecycleAbility extends UIAbility {\n  // 定义生命周期ID\n  lifecycleId: number = -1;\n\n  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {\n    // 定义生命周期回调对象\n    let abilityLifecycleCallback: AbilityLifecycleCallback = {\n      // 当UIAbility创建时被调用\n      onAbilityCreate(uiAbility) {\n        hilog.info(DOMAIN_NUMBER, TAG, `onAbilityCreate uiAbility.launchWant: ${JSON.stringify(uiAbility.launchWant)}`);\n      },\n      // 当窗口创建时被调用\n      onWindowStageCreate(uiAbility, windowStage: window.WindowStage) {\n        hilog.info(DOMAIN_NUMBER, TAG, `onWindowStageCreate uiAbility.launchWant: ${JSON.stringify(uiAbility.launchWant)}`);\n        hilog.info(DOMAIN_NUMBER, TAG, `onWindowStageCreate windowStage: ${JSON.stringify(windowStage)}`);\n      },\n      // 当窗口处于活动状态时被调用\n      onWindowStageActive(uiAbility, windowStage: window.WindowStage) {\n        hilog.info(DOMAIN_NUMBER, TAG, `onWindowStageActive uiAbility.launchWant: ${JSON.stringify(uiAbility.launchWant)}`);\n        hilog.info(DOMAIN_NUMBER, TAG, `onWindowStageActive windowStage: ${JSON.stringify(windowStage)}`);\n      },\n      // 当窗口处于非活动状态时被调用\n      onWindowStageInactive(uiAbility, windowStage: window.WindowStage) {\n        hilog.info(DOMAIN_NUMBER, TAG, `onWindowStageInactive uiAbility.launchWant: ${JSON.stringify(uiAbility.launchWant)}`);\n        hilog.info(DOMAIN_NUMBER, TAG, `onWindowStageInactive windowStage: ${JSON.stringify(windowStage)}`);\n      },\n      // 当窗口被销毁时被调用\n      onWindowStageDestroy(uiAbility, windowStage: window.WindowStage) {\n        hilog.info(DOMAIN_NUMBER, TAG, `onWindowStageDestroy uiAbility.launchWant: ${JSON.stringify(uiAbility.launchWant)}`);\n        hilog.info(DOMAIN_NUMBER, TAG, `onWindowStageDestroy windowStage: ${JSON.stringify(windowStage)}`);\n      },\n      // 当UIAbility被销毁时被调用\n      onAbilityDestroy(uiAbility) {\n        hilog.info(DOMAIN_NUMBER, TAG, `onAbilityDestroy uiAbility.launchWant: ${JSON.stringify(uiAbility.launchWant)}`);\n      },\n      // 当UIAbility从后台转到前台时触发回调\n      onAbilityForeground(uiAbility) {\n        hilog.info(DOMAIN_NUMBER, TAG, `onAbilityForeground uiAbility.launchWant: ${JSON.stringify(uiAbility.launchWant)}`);\n      },\n      // 当UIAbility从前台转到后台时触发回调\n      onAbilityBackground(uiAbility) {\n        hilog.info(DOMAIN_NUMBER, TAG, `onAbilityBackground uiAbility.launchWant: ${JSON.stringify(uiAbility.launchWant)}`);\n      },\n      // 当UIAbility迁移时被调用\n      onAbilityContinue(uiAbility) {\n        hilog.info(DOMAIN_NUMBER, TAG, `onAbilityContinue uiAbility.launchWant: ${JSON.stringify(uiAbility.launchWant)}`);\n      }\n    };\n    // 获取应用上下文\n    let applicationContext = this.context.getApplicationContext();\n    // 注册应用内生命周期回调\n    this.lifecycleId = applicationContext.on('abilityLifecycle', abilityLifecycleCallback);\n    hilog.info(DOMAIN_NUMBER, TAG, `register callback number: ${this.lifecycleId}`);\n  }\n\n  onWindowStageCreate(windowStage: window.WindowStage): void {\n    // 设置UI加载\n    windowStage.loadContent('pages/page_funcability/Page_FuncAbilityA', (err, data) => {\n    });\n  }\n\n  onDestroy() : void {\n    // 获取应用上下文\n    let applicationContext = this.context.getApplicationContext();\n    // 取消应用内生命周期回调\n    applicationContext.off('abilityLifecycle', this.lifecycleId);\n  }\n};\n", "llm_cg": {"LifecycleAbility.onCreate(Want, AbilityConstant.LaunchParam)": ["LifecycleAbility.%AM0$onAbilityCreate(UIAbility)", "LifecycleAbility.%AM1$onWindowStageCreate(UIAbility, window.WindowStage)", "LifecycleAbility.%AM2$onWindowStageActive(UIAbility, window.WindowStage)", "LifecycleAbility.%AM3$onWindowStageInactive(UIAbility, window.WindowStage)", "LifecycleAbility.%AM4$onWindowStageDestroy(UIAbility, window.WindowStage)", "LifecycleAbility.%AM5$onAbilityDestroy(UIAbility)", "LifecycleAbility.%AM6$onAbilityForeground(UIAbility)", "LifecycleAbility.%AM7$onAbilityBackground(UIAbility)", "LifecycleAbility.%AM8$onAbilityContinue(UIAbility)"], "LifecycleAbility.onWindowStageCreate(window.WindowStage)": [], "LifecycleAbility.onDestroy()": []}, "static_cg": {"@test/107.ts: LifecycleAbility.onWindowStageCreate(window.WindowStage)": ["@test/107.ts: LifecycleAbility.%AM0$onWindowStageCreate(unknown, unknown)"]}}
{"source_code": "/*\n * Copyright (c) 2023 Huawei Device Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { ProcessDataCallback } from './i_idl_service_ext';\nimport type { InsertDataToMapCallback } from './i_idl_service_ext';\nimport type IIdlServiceExt from './i_idl_service_ext';\nimport hilog from '@ohos.hilog';\nimport rpc from '@ohos.rpc';\n\nconst TAG: string = '[IdlServiceExtProxy]';\nconst DOMAIN_NUMBER: number = 0xFF00;\n\nexport default class IdlServiceExtProxy implements IIdlServiceExt {\n  static readonly COMMAND_PROCESS_DATA = 1;\n  static readonly COMMAND_INSERT_DATA_TO_MAP = 2;\n  private proxy;\n\n  constructor(proxy) {\n    this.proxy = proxy;\n  };\n\n  processData(data: number, callback: ProcessDataCallback): void {\n    let option = new rpc.MessageOption();\n    let dataSequence = rpc.MessageSequence.create();\n    let replySequence = rpc.MessageSequence.create();\n    try {\n      dataSequence.writeInt(data);\n      this.proxy.sendMessageRequest(IdlServiceExtProxy.COMMAND_PROCESS_DATA, dataSequence, replySequence, option).then(function (result) {\n        if (result.errCode === 0) {\n          let errCodeVar = result.reply.readInt();\n          if (errCodeVar !== 0) {\n            let returnValueVar = undefined;\n            callback(errCodeVar, returnValueVar);\n            return;\n          }\n          let returnValueVar = result.reply.readInt();\n          callback(errCodeVar, returnValueVar);\n        } else {\n          hilog.info(DOMAIN_NUMBER, TAG, 'sendMessageRequest failed, errCode: ' + result.errCode);\n        }\n      });\n    } finally {\n      dataSequence.reclaim();\n      replySequence.reclaim();\n    };\n  };\n\n  insertDataToMap(key: string, val: number, callback: InsertDataToMapCallback): void {\n    let option = new rpc.MessageOption();\n    let dataSequence = rpc.MessageSequence.create();\n    let replySequence = rpc.MessageSequence.create();\n    try {\n      dataSequence.writeString(key);\n      dataSequence.writeInt(val);\n      this.proxy.sendMessageRequest(IdlServiceExtProxy.COMMAND_INSERT_DATA_TO_MAP, dataSequence, replySequence, option).then(function (result) {\n        if (result.errCode === 0) {\n          let errCodeVar = result.reply.readInt();\n          callback(errCodeVar);\n        } else {\n          hilog.info(DOMAIN_NUMBER, TAG, 'sendMessageRequest failed, errCode: ' + result.errCode);\n        }\n      });\n    } finally {\n      dataSequence.reclaim();\n      replySequence.reclaim();\n    };\n  };\n};\n\n", "llm_cg": {"IdlServiceExtProxy.processData(number, ProcessDataCallback)": ["rpc.MessageOption.%AM0$constructor()", "rpc.MessageSequence.%AM1$create()", "rpc.MessageSequence.%AM2$create()", "rpc.MessageSequence.%AM3$writeInt(number)", "IdlServiceExtProxy.proxy.%AM4$sendMessageRequest(number, rpc.MessageSequence, rpc.MessageSequence, rpc.MessageOption)", "rpc.MessageSequence.%AM5$reclaim()", "rpc.MessageSequence.%AM6$reclaim()"], "IdlServiceExtProxy.insertDataToMap(string, number, InsertDataToMapCallback)": ["rpc.MessageOption.%AM7$constructor()", "rpc.MessageSequence.%AM8$create()", "rpc.MessageSequence.%AM9$create()", "rpc.MessageSequence.%AM10$writeString(string)", "rpc.MessageSequence.%AM11$writeInt(number)", "IdlServiceExtProxy.proxy.%AM12$sendMessageRequest(number, rpc.MessageSequence, rpc.MessageSequence, rpc.MessageOption)", "rpc.MessageSequence.%AM13$reclaim()", "rpc.MessageSequence.%AM14$reclaim()"]}, "static_cg": {"@test/108.ts: IdlServiceExtProxy.processData(number, ProcessDataCallback)": ["@test/108.ts: IdlServiceExtProxy.%AM0$processData([callback], unknown)"], "@test/108.ts: IdlServiceExtProxy.insertDataToMap(string, number, InsertDataToMapCallback)": ["@test/108.ts: IdlServiceExtProxy.%AM1$insertDataToMap([callback], unknown)"]}}
{"source_code": "/*\n * Copyright (c) 2023 Huawei Device Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { ProcessDataCallback } from './i_idl_service_ext';\nimport type { InsertDataToMapCallback } from './i_idl_service_ext';\nimport type IIdlServiceExt from './i_idl_service_ext';\nimport hilog from '@ohos.hilog';\nimport rpc from '@ohos.rpc';\n\nconst TAG: string = '[IdlServiceExtStub]';\nconst DOMAIN_NUMBER: number = 0xFF00;\n\nexport default class IdlServiceExtStub extends rpc.RemoteObject implements IIdlServiceExt {\n  constructor(des: string) {\n    super(des);\n  };\n\n  async onRemoteMessageRequest(code: number, data: rpc.MessageSequence, reply: rpc.MessageSequence, option: rpc.MessageOption): Promise<boolean> {\n    hilog.info(DOMAIN_NUMBER, TAG, 'onRemoteMessageRequest called, code = ' + code);\n    switch (code) {\n      case IdlServiceExtStub.COMMAND_PROCESS_DATA: {\n        let dataVar = data.readInt();\n        let promise = new Promise<void>((resolve, reject) => {\n          this.processData(dataVar, (errCode, returnValue) => {\n            reply.writeInt(errCode);\n            if (errCode === 0) {\n              reply.writeInt(returnValue);\n            }\n            resolve();\n          });\n        });\n        await promise;\n        return true;\n      };\n      case IdlServiceExtStub.COMMAND_INSERT_DATA_TO_MAP: {\n        let keyVar = data.readString();\n        let valVar = data.readInt();\n        let promise = new Promise<void>((resolve, reject) => {\n          this.insertDataToMap(keyVar, valVar, (errCode) => {\n            reply.writeInt(errCode);\n            resolve();\n          });\n        });\n        await promise;\n        return true;\n      };\n      default: {\n        hilog.info(DOMAIN_NUMBER, TAG, 'invalid request code' + code);\n        break;\n      }\n    }\n    return false;\n  }\n\n  processData(data: number, callback: ProcessDataCallback): void {\n  };\n\n  insertDataToMap(key: string, val: number, callback: InsertDataToMapCallback): void {\n  };\n\n  static readonly COMMAND_PROCESS_DATA = 1;\n  static readonly COMMAND_INSERT_DATA_TO_MAP = 2;\n};", "llm_cg": {"IdlServiceExtStub.onRemoteMessageRequest(number, rpc.MessageSequence, rpc.MessageSequence, rpc.MessageOption)": ["IdlServiceExtStub.processData(number, ProcessDataCallback)", "IdlServiceExtStub.insertDataToMap(string, number, InsertDataToMapCallback)"]}, "static_cg": {"@test/109.ts: IdlServiceExtStub.onRemoteMessageRequest(number, rpc.MessageSequence, rpc.MessageSequence, rpc.MessageOption)": ["@test/109.ts: IdlServiceExtStub.%AM0$onRemoteMessageRequest([dataVar], unknown, unknown)", "@test/109.ts: IdlServiceExtStub.%AM2$onRemoteMessageRequest([keyVar, valVar], unknown, unknown)"], "@test/109.ts: IdlServiceExtStub.%AM0$onRemoteMessageRequest([dataVar], unknown, unknown)": ["@test/109.ts: IdlServiceExtStub.%AM1$%AM0$onRemoteMessageRequest(unknown, unknown)", "@test/109.ts: IdlServiceExtStub.processData(number, ProcessDataCallback)"], "@test/109.ts: IdlServiceExtStub.%AM2$onRemoteMessageRequest([keyVar, valVar], unknown, unknown)": ["@test/109.ts: IdlServiceExtStub.%AM3$%AM2$onRemoteMessageRequest(unknown)", "@test/109.ts: IdlServiceExtStub.insertDataToMap(string, number, InsertDataToMapCallback)"]}}
{"source_code": "/*\n * Copyright (c) 2023 Huawei Device Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport abilityAccessCtrl from '@ohos.abilityAccessCtrl';\nimport bundleManager from '@ohos.bundle.bundleManager';\nimport IdlServiceExtStub from './idl_service_ext_stub';\nimport hilog from '@ohos.hilog';\nimport rpc from '@ohos.rpc';\nimport type { BusinessError } from '@ohos.base';\nimport type { InsertDataToMapCallback } from './i_idl_service_ext';\nimport type { ProcessDataCallback } from './i_idl_service_ext';\n\nconst ERR_OK = 0;\nconst TAG: string = '[IdlServiceExtImpl]';\nconst DOMAIN_NUMBER: number = 0xFF00;\nconst ERR_DENY = -1;\n\n// 开发者需要在这个类型里对接口进行实现\nexport default class ServiceExtImpl extends IdlServiceExtStub {\n  processData(data: number, callback: ProcessDataCallback): void {\n    // 开发者自行实现业务逻辑\n    hilog.info(DOMAIN_NUMBER, TAG, `processData: ${data}`);\n\n    let callerUid = rpc.IPCSkeleton.getCallingUid();\n    bundleManager.getBundleNameByUid(callerUid).then((callerBundleName) => {\n      hilog.info(DOMAIN_NUMBER, TAG, 'getBundleNameByUid: ' + callerBundleName);\n      // 对客户端包名进行识别\n      if (callerBundleName !== 'com.samples.stagemodelabilitydevelop') { // 识别不通过\n        hilog.info(DOMAIN_NUMBER, TAG, 'The caller bundle is not in trustlist, reject');\n        return;\n      }\n      // 识别通过，执行正常业务逻辑\n    }).catch((err: BusinessError) => {\n      hilog.info(DOMAIN_NUMBER, TAG, 'getBundleNameByUid failed: ' + err.message);\n    });\n\n    let callerTokenId = rpc.IPCSkeleton.getCallingTokenId();\n    let accessManger = abilityAccessCtrl.createAtManager();\n    // 所校验的具体权限由开发者自行选择，此处ohos.permission.GET_BUNDLE_INFO_PRIVILEGED只作为示例\n    let grantStatus = accessManger.verifyAccessTokenSync(callerTokenId, 'ohos.permission.GET_BUNDLE_INFO_PRIVILEGED');\n    if (grantStatus === abilityAccessCtrl.GrantStatus.PERMISSION_DENIED) {\n      hilog.info(DOMAIN_NUMBER, TAG, 'PERMISSION_DENIED');\n      callback(ERR_DENY, data); // 鉴权失败，返回错误\n      return;\n    }\n    hilog.info(DOMAIN_NUMBER, TAG, 'verify access token success.');\n    callback(ERR_OK, data + 1); // 鉴权通过，执行正常业务逻辑\n  };\n\n  insertDataToMap(key: string, val: number, callback: InsertDataToMapCallback): void {\n    // 开发者自行实现业务逻辑\n    hilog.info(DOMAIN_NUMBER, TAG, `insertDataToMap, key: ${key}  val: ${val}`);\n    callback(ERR_OK);\n  };\n};", "llm_cg": {"ServiceExtImpl.processData(number, ProcessDataCallback)": ["rpc.IPCSkeleton.getCallingUid()", "bundleManager.getBundleNameByUid(number)", "rpc.IPCSkeleton.getCallingTokenId()", "abilityAccessCtrl.createAtManager()", "abilityAccessCtrl.AtManager.verifyAccessTokenSync(number, string)"], "ServiceExtImpl.insertDataToMap(string, number, InsertDataToMapCallback)": []}, "static_cg": {"@test/110.ts: ServiceExtImpl.processData(number, ProcessDataCallback)": ["@test/110.ts: ServiceExtImpl.%AM1$processData(unknown)", "@test/110.ts: ServiceExtImpl.%AM0$processData(BusinessError)"]}}
{"source_code": "/*\n * Copyright (c) 2023 Huawei Device Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport default interface IIdlServiceExt {\n  processData(data: number, callback: ProcessDataCallback): void;\n  insertDataToMap(key: string, val: number, callback: InsertDataToMapCallback): void;\n}\n\nexport type ProcessDataCallback = (errCode: number, returnValue: number) => void;\n\nexport type InsertDataToMapCallback = (errCode: number) => void;\n", "llm_cg": {"IIdlServiceExt.processData(number, ProcessDataCallback)": [], "IIdlServiceExt.insertDataToMap(string, number, InsertDataToMapCallback)": []}, "static_cg": {}}
{"source_code": "/*\n * Copyright (c) 2023 Huawei Device Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport AbilityStage from '@ohos.app.ability.AbilityStage';\nimport type AbilityConstant from '@ohos.app.ability.AbilityConstant';\nimport hilog from '@ohos.hilog';\nimport type Want from '@ohos.app.ability.Want';\nimport type { Configuration } from '@ohos.app.ability.Configuration';\n\nconst TAG: string = '[MyAbilityStage]';\nconst DOMAIN_NUMBER: number = 0xFF00;\n\nlet systemLanguage: string | undefined; // 系统当前语言\n\nexport default class MyAbilityStage extends AbilityStage {\n  onNewWant(want: Want, launchParam: AbilityConstant.LaunchParam): void {\n    hilog.info(DOMAIN_NUMBER, TAG, `onNewWant, want: ${want.abilityName}`);\n    hilog.info(DOMAIN_NUMBER, TAG, `onNewWant, launchParam: ${JSON.stringify(launchParam)}`);\n  }\n  onCreate(): void {\n    // 应用的HAP在首次加载的时，为该Module初始化操作\n    systemLanguage = this.context.config.language; // Module首次加载时，获取系统当前语言\n    hilog.info(DOMAIN_NUMBER, TAG, `systemLanguage is ${systemLanguage}`);\n    let abilityStageContext = this.context;\n  }\n  onAcceptWant(want: Want): string {\n    // 仅specified模式下触发\n    hilog.info(DOMAIN_NUMBER, TAG, 'Succeeded in starting SpecifiedAbility');\n    // 在被调用方的AbilityStage中，针对启动模式为specified的UIAbility返回一个UIAbility实例对应的一个Key值\n    // 当前示例指的是module1 Module的SpecifiedAbility\n    if (want.abilityName === 'SpecifiedFirstAbility' || want.abilityName === 'SpecifiedSecondAbility') {\n      // 返回的字符串Key标识为自定义拼接的字符串内容\n      if (want.parameters) {\n        return `SpecifiedAbilityInstance_${want.parameters.instanceKey}`;\n      }\n    }\n    return 'MyAbilityStage';\n  }\n  onMemoryLevel(level: AbilityConstant.MemoryLevel): void {\n    // 根据系统可用内存的变化情况，释放不必要的内存\n  }\n  onConfigurationUpdate(newConfig: Configuration): void {\n    hilog.info(DOMAIN_NUMBER, TAG, `onConfigurationUpdate, language: ${newConfig.language}`);\n    hilog.info(DOMAIN_NUMBER, TAG, `onConfigurationUpdated systemLanguage is ${systemLanguage}, newConfig: ${JSON.stringify(newConfig)}`);\n\n    if (systemLanguage !== newConfig.language) {\n      hilog.info(DOMAIN_NUMBER, TAG, `systemLanguage from ${systemLanguage} changed to ${newConfig.language}`);\n      systemLanguage = newConfig.language; // 将变化之后的系统语言保存，作为下一次变化前的系统语言\n    }\n  }\n};\n", "llm_cg": {"MyAbilityStage.onNewWant(Want, AbilityConstant.LaunchParam)": [], "MyAbilityStage.onCreate()": [], "MyAbilityStage.onAcceptWant(Want)": [], "MyAbilityStage.onMemoryLevel(AbilityConstant.MemoryLevel)": [], "MyAbilityStage.onConfigurationUpdate(Configuration)": []}, "static_cg": {}}
{"source_code": "/*\n * Copyright (c) 2023 Huawei Device Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport hilog from '@ohos.hilog';\n\nclass Logger {\n  private domain: number;\n  private prefix: string;\n  private format: string = '%{public}s, %{public}s';\n\n  constructor(prefix: string) {\n    this.prefix = prefix;\n    this.domain = 0xFF00;\n  }\n\n  /**\n   * debug\n   * @param args\n   */\n  debug(...args: string[]): void {\n    hilog.debug(this.domain, this.prefix, this.format, args);\n  }\n\n  /**\n   * info\n   * @param args\n   */\n  info(...args: string[]): void {\n    hilog.info(this.domain, this.prefix, this.format, args);\n  }\n\n  /**\n   * warn\n   * @param args\n   */\n  warn(...args: string[]): void {\n    hilog.warn(this.domain, this.prefix, this.format, args);\n  }\n\n  /**\n   * error\n   * @param args\n   */\n  error(...args: string[]): void {\n    hilog.error(this.domain, this.prefix, this.format, args);\n  }\n}\n\nexport default new Logger('[stageuiabilitydevelop]');", "llm_cg": {"Logger.debug(...args: string[])": [], "Logger.info(...args: string[])": [], "Logger.warn(...args: string[])": [], "Logger.error(...args: string[])": []}, "static_cg": {"@test/113.ts: %dflt.[static]%dflt()": ["@test/113.ts: Logger.constructor(string)"]}}
{"source_code": "/*\n * Copyright (c) 2023 Huawei Device Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport UIAbility from '@ohos.app.ability.UIAbility';\nimport type window from '@ohos.window';\n\nexport default class FuncAbilityB extends UIAbility {\n  onWindowStageCreate(windowStage: window.WindowStage): void {\n    // 设置UI加载\n    windowStage.loadContent('pages/page_funcability/Page_FuncAbilityB', (err, data) => {\n    });\n  }\n};\n", "llm_cg": {"FuncAbilityB.onWindowStageCreate(window.WindowStage)": ["window.WindowStage.loadContent(string, function)"]}, "static_cg": {"@test/114.ts: FuncAbilityB.onWindowStageCreate(window.WindowStage)": ["@test/114.ts: FuncAbilityB.%AM0$onWindowStageCreate(unknown, unknown)"]}}
{"source_code": "/*\n * Copyright (c) 2023 Huawei Device Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type AbilityConstant from '@ohos.app.ability.AbilityConstant';\nimport UIAbility from '@ohos.app.ability.UIAbility';\nimport type window from '@ohos.window';\nimport type Want from '@ohos.app.ability.Want';\n\nexport default class FuncAbilityA extends UIAbility {\n\n  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {\n    // 接收调用方UIAbility传过来的参数\n    let funcAbilityWant = want;\n    let info = funcAbilityWant?.parameters?.info;\n  }\n\n  onWindowStageCreate(windowStage: window.WindowStage): void {\n    // 设置UI加载\n    windowStage.loadContent('pages/page_funcability/Page_FuncAbilityA', (err, data) => {\n    });\n  }\n};\n", "llm_cg": {"FuncAbilityA.onCreate(Want, AbilityConstant.LaunchParam)": [], "FuncAbilityA.onWindowStageCreate(window.WindowStage)": ["window.WindowStage.loadContent(string, (err: Error, data: any) => void)"]}, "static_cg": {"@test/115.ts: FuncAbilityA.onWindowStageCreate(window.WindowStage)": ["@test/115.ts: FuncAbilityA.%AM0$onWindowStageCreate(unknown, unknown)"]}}
{"source_code": "/*\n * Copyright (c) 2023 Huawei Device Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport UIAbility from '@ohos.app.ability.UIAbility';\nimport type window from '@ohos.window';\n\nexport default class SpecifiedSecondAbility extends UIAbility {\n\n  onWindowStageCreate(windowStage: window.WindowStage): void {\n    // 设置UI加载\n    windowStage.loadContent('pages/page_startupability/Page_Specified_Second', (err, data) => {\n    });\n  }\n};", "llm_cg": {"SpecifiedSecondAbility.onWindowStageCreate(window.WindowStage)": ["window.WindowStage.loadContent(string, function)"]}, "static_cg": {"@test/116.ts: SpecifiedSecondAbility.onWindowStageCreate(window.WindowStage)": ["@test/116.ts: SpecifiedSecondAbility.%AM0$onWindowStageCreate(unknown, unknown)"]}}
{"source_code": "/*\n * Copyright (c) 2023 Huawei Device Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport hilog from '@ohos.hilog';\nimport UIAbility from '@ohos.app.ability.UIAbility';\nimport type window from '@ohos.window';\n\nconst TAG: string = '[MultitonAbility]';\nconst DOMAIN_NUMBER: number = 0xFF00;\n\nexport default class MultitonAbility extends UIAbility {\n  onCreate(): void {\n    hilog.info(DOMAIN_NUMBER, TAG, '%{public}s', 'Ability onCreate');\n  }\n\n  onWindowStageCreate(windowStage: window.WindowStage): void {\n    // Main window is created, set main page for this ability\n    hilog.info(DOMAIN_NUMBER, TAG, '%{public}s', 'Ability onWindowStageCreate');\n    windowStage.loadContent('pages/page_startupability/Page_Multiton', (err, data) => {\n      if (err.code) {\n        hilog.error(DOMAIN_NUMBER, TAG, 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');\n        return;\n      }\n      hilog.info(DOMAIN_NUMBER, TAG, 'Succeeded in loading the content. Data: %{public}s', JSON.stringify(data) ?? '');\n    });\n  }\n};\n", "llm_cg": {"MultitonAbility.onCreate()": [], "MultitonAbility.onWindowStageCreate(window.WindowStage)": ["window.WindowStage.loadContent(string, function)"]}, "static_cg": {"@test/117.ts: MultitonAbility.onWindowStageCreate(window.WindowStage)": ["@test/117.ts: MultitonAbility.%AM0$onWindowStageCreate(unknown, unknown)"]}}
{"source_code": "/*\n * Copyright (c) 2023 Huawei Device Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport UIAbility from '@ohos.app.ability.UIAbility';\nimport type window from '@ohos.window';\n\nexport default class SpecifiedFirstAbility extends UIAbility {\n\n  onWindowStageCreate(windowStage: window.WindowStage): void {\n    // 设置UI加载\n    windowStage.loadContent('pages/page_startupability/Page_Specified_First', (err, data) => {\n    });\n  }\n};", "llm_cg": {"SpecifiedFirstAbility.onWindowStageCreate(window.WindowStage)": ["window.WindowStage.loadContent(string, function)"]}, "static_cg": {"@test/118.ts: SpecifiedFirstAbility.onWindowStageCreate(window.WindowStage)": ["@test/118.ts: SpecifiedFirstAbility.%AM0$onWindowStageCreate(unknown, unknown)"]}}
{"source_code": "/*\n * Copyright (c) 2023 Huawei Device Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport hilog from '@ohos.hilog';\nimport UIAbility from '@ohos.app.ability.UIAbility';\nimport type window from '@ohos.window';\n\nconst TAG: string = '[SingletonAbility]';\nconst DOMAIN_NUMBER: number = 0xFF00;\n\nexport default class SingletonAbility extends UIAbility {\n  onCreate(): void {\n    hilog.info(DOMAIN_NUMBER, TAG, '%{public}s', 'Ability onCreate');\n  }\n\n  onWindowStageCreate(windowStage: window.WindowStage): void {\n    // Main window is created, set main page for this ability\n    hilog.info(DOMAIN_NUMBER, TAG, '%{public}s', 'Ability onWindowStageCreate');\n    windowStage.loadContent('pages/page_startupability/Page_Singleton', (err, data) => {\n      if (err.code) {\n        hilog.error(DOMAIN_NUMBER, TAG, 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');\n        return;\n      }\n      hilog.info(DOMAIN_NUMBER, TAG, 'Succeeded in loading the content. Data: %{public}s', JSON.stringify(data) ?? '');\n    });\n  }\n};\n", "llm_cg": {"SingletonAbility.onCreate()": [], "SingletonAbility.onWindowStageCreate(window.WindowStage)": ["window.WindowStage.loadContent(string, function)"]}, "static_cg": {"@test/119.ts: SingletonAbility.onWindowStageCreate(window.WindowStage)": ["@test/119.ts: SingletonAbility.%AM0$onWindowStageCreate(unknown, unknown)"]}}
{"source_code": "/*\n * Copyright (c) 2023-2024 Huawei Device Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport AbilityConstant from '@ohos.app.ability.AbilityConstant';\nimport hilog from '@ohos.hilog';\nimport UIAbility from '@ohos.app.ability.UIAbility';\nimport type Want from '@ohos.app.ability.Want';\nimport wantConstant from '@ohos.app.ability.wantConstant';\nimport type window from '@ohos.window';\nimport type { Context, PermissionRequestResult, Permissions } from '@ohos.abilityAccessCtrl';\nimport abilityAccessCtrl from '@ohos.abilityAccessCtrl';\nimport type { BusinessError } from '@ohos.base';\n\nconst permissions: Array<Permissions> = ['ohos.permission.DISTRIBUTED_DATASYNC'];\nconst TAG: string = '[MigrationAbility]';\nconst DOMAIN_NUMBER: number = 0xFF00;\n\nexport default class MigrationAbility extends UIAbility {\n  storage: LocalStorage = new LocalStorage();\n\n  // 对端恢复\n  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {\n    hilog.info(DOMAIN_NUMBER, TAG, '%{public}s', 'Ability onCreate');\n\n    // 获取分布式数据\n    if (launchParam.launchReason === AbilityConstant.LaunchReason.CONTINUATION) {\n      // 将want保存的数据取出恢复\n      let continueInput = '';\n      if (want.parameters !== undefined) {\n        continueInput = JSON.stringify(want.parameters.data);\n        hilog.info(DOMAIN_NUMBER, TAG, `continue input ${continueInput}`);\n      }\n      // 将数据显示当前页面\n      this.context.restoreWindowStage(this.storage);\n    }\n    // 调用原因为迁移时，设置状态为可迁移，应对冷启动情况\n    this.context.setMissionContinueState(AbilityConstant.ContinueState.ACTIVE, (result) => {\n      hilog.info(DOMAIN_NUMBER, TAG, `setMissionContinueState ACTIVE result: ${JSON.stringify(result)}`);\n    });\n  }\n\n  onWindowStageCreate(windowStage: window.WindowStage): void {\n    // Main window is created, set main page for this ability\n    hilog.info(DOMAIN_NUMBER, TAG, '%{public}s', 'Ability onWindowStageCreate');\n\n    windowStage.loadContent('pages/page_migrationability/Page_MigrationAbilityFirst', (err, data) => {\n      if (err.code) {\n        hilog.error(DOMAIN_NUMBER, TAG, 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');\n        return;\n      }\n      hilog.info(DOMAIN_NUMBER, TAG, 'Succeeded in loading the content. Data: %{public}s', JSON.stringify(data) ?? '');\n    });\n    // Main window is created, set main page for this ability\n    let context: Context = this.context;\n    let atManager: abilityAccessCtrl.AtManager = abilityAccessCtrl.createAtManager();\n    // requestPermissionsFromUser会判断权限的授权状态来决定是否唤起弹窗\n    atManager.requestPermissionsFromUser(context, permissions).then((data: PermissionRequestResult) => {\n      let grantStatus: Array<number> = data.authResults;\n      let length: number = grantStatus.length;\n      for (let i = 0; i < length; i++) {\n        if (grantStatus[i] === 0) {\n          // 用户授权，可以继续访问目标操作\n        } else {\n          // 用户拒绝授权，提示用户必须授权才能访问当前页面的功能，并引导用户到系统设置中打开相应的权限\n          return;\n        }\n      }\n      // 授权成功\n    }).catch((err: BusinessError) => {\n      hilog.info(DOMAIN_NUMBER, TAG, `Failed to request permissions from user. Code is ${err.code}, message is ${err.message}`);\n    });\n  }\n\n  // 源端保存\n  onContinue(wantParam: Record<string, Object>): AbilityConstant.OnContinueResult {\n    let version = wantParam.version;\n    let targetDevice = wantParam.targetDevice;\n    hilog.info(DOMAIN_NUMBER, TAG, `onContinue version = ${version}, targetDevice: ${targetDevice}`); // 准备迁移数据\n\n    // 获取源端版本号\n    let versionSrc: number = -1; // 请填充具体获取版本号的代码\n\n    // 兼容性校验\n    if (version !== versionSrc) {\n      // 在兼容性校验不通过时返回MISMATCH\n      return AbilityConstant.OnContinueResult.MISMATCH;\n    }\n\n    // 将要迁移的数据保存在wantParam的自定义字段（例如data）中\n    const continueInput = '迁移的数据';\n    wantParam['data'] = continueInput;\n\n    //设置不迁移页面栈&迁移后源端不退出\n    wantParam[wantConstant.Params.SUPPORT_CONTINUE_PAGE_STACK_KEY] = false;\n    wantParam[wantConstant.Params.SUPPORT_CONTINUE_SOURCE_EXIT_KEY] = false;\n\n    return AbilityConstant.OnContinueResult.AGREE;\n  }\n\n  onNewWant(want: Want, launchParam: AbilityConstant.LaunchParam): void {\n    hilog.info(DOMAIN_NUMBER, TAG, 'onNewWant');\n\n    if (launchParam.launchReason === AbilityConstant.LaunchReason.CONTINUATION) {\n      // get user data from want params\n      let continueInput = '';\n      if (want.parameters !== undefined) {\n        continueInput = JSON.stringify(want.parameters.data);\n        hilog.info(DOMAIN_NUMBER, TAG, `continue input ${JSON.stringify(continueInput)}`);\n      }\n      this.context.restoreWindowStage(this.storage);\n    }\n\n    // 调用原因为迁移时，设置状态为可迁移，应对热启动情况\n    if (launchParam.launchReason === AbilityConstant.LaunchReason.CONTINUATION) {\n      this.context.setMissionContinueState(AbilityConstant.ContinueState.ACTIVE, (result) => {\n        hilog.info(DOMAIN_NUMBER, TAG, `setMissionContinueState ACTIVE result: ${JSON.stringify(result)}`);\n      });\n    }\n  }\n\n  onWindowStageRestore(windowStage: window.WindowStage): void {\n    // 若不需要自动迁移页面栈信息，则需要在此处设置应用迁移后进入的页面\n    windowStage.loadContent('pages/page_migrationability/Page_MigrationAbilityThird', (err, data) => {\n      if (err.code) {\n        hilog.error(DOMAIN_NUMBER, TAG, 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');\n        return;\n      }\n    });\n  }\n};\n", "llm_cg": {"MigrationAbility.onCreate(Want, AbilityConstant.LaunchParam)": ["MigrationAbility.context.restoreWindowStage(LocalStorage)", "MigrationAbility.context.setMissionContinueState(AbilityConstant.ContinueState, Function)"], "MigrationAbility.onWindowStageCreate(window.WindowStage)": ["window.WindowStage.loadContent(String, Function)", "abilityAccessCtrl.AtManager.requestPermissionsFromUser(Context, Array<Permissions>)"], "MigrationAbility.onContinue(Record<string, Object>)": [], "MigrationAbility.onNewWant(Want, AbilityConstant.LaunchParam)": ["MigrationAbility.context.restoreWindowStage(LocalStorage)", "MigrationAbility.context.setMissionContinueState(AbilityConstant.ContinueState, Function)"], "MigrationAbility.onWindowStageRestore(window.WindowStage)": ["window.WindowStage.loadContent(String, Function)"]}, "static_cg": {"@test/120.ts: MigrationAbility.onCreate(Want, AbilityConstant.LaunchParam)": ["@test/120.ts: MigrationAbility.%AM0$onCreate(unknown)"], "@test/120.ts: MigrationAbility.onWindowStageCreate(window.WindowStage)": ["@test/120.ts: MigrationAbility.%AM1$onWindowStageCreate(unknown, unknown)", "@test/120.ts: MigrationAbility.%AM3$onWindowStageCreate(PermissionRequestResult)", "@test/120.ts: MigrationAbility.%AM2$onWindowStageCreate(BusinessError)"], "@test/120.ts: MigrationAbility.onNewWant(Want, AbilityConstant.LaunchParam)": ["@test/120.ts: MigrationAbility.%AM4$onNewWant(unknown)"], "@test/120.ts: MigrationAbility.onWindowStageRestore(window.WindowStage)": ["@test/120.ts: MigrationAbility.%AM5$onWindowStageRestore(unknown, unknown)"]}}
{"source_code": "/*\n * Copyright (c) 2023 Huawei Device Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { BusinessError } from '@ohos.base';\nimport hilog from '@ohos.hilog';\nimport ServiceExtensionAbility from '@ohos.app.ability.ServiceExtensionAbility';\nimport ServiceExtImpl from '../IdlServiceExt/idl_service_ext_impl';\nimport type Want from '@ohos.app.ability.Want';\nimport type rpc from '@ohos.rpc';\n\nconst TAG: string = '[ServiceExtAbility]';\nconst DOMAIN_NUMBER: number = 0xFF00;\n\nexport default class ServiceExtAbility extends ServiceExtensionAbility {\n  serviceExtImpl: ServiceExtImpl = new ServiceExtImpl('ExtImpl');\n\n  onCreate(want: Want): void {\n    let serviceExtensionContext = this.context;\n    hilog.info(DOMAIN_NUMBER, TAG, `onCreate, want: ${want.abilityName}`);\n  };\n\n  onRequest(want: Want, startId: number): void {\n    hilog.info(DOMAIN_NUMBER, TAG, `onRequest, want: ${want.abilityName}`);\n    if (want.parameters.key === 'ConnectFaPageAbility') {\n      let wantFA: Want = {\n        bundleName: 'com.samples.famodelabilitydevelop',\n        abilityName: 'com.samples.famodelabilitydevelop.MainAbility',\n      };\n      this.context.startAbility(wantFA).then(() => {\n        hilog.info(DOMAIN_NUMBER, TAG, 'Start Ability successfully.');\n      }).catch((error: BusinessError) => {\n        hilog.info(DOMAIN_NUMBER, TAG, `Ability failed: ${JSON.stringify(error)}`);\n      });\n    }\n  };\n\n  onConnect(want: Want): rpc.RemoteObject {\n    hilog.info(DOMAIN_NUMBER, TAG, `onConnect, want: ${want.abilityName}`);\n    // 返回ServiceExtImpl对象，客户端获取后便可以与ServiceExtensionAbility进行通信\n    return this.serviceExtImpl as rpc.RemoteObject;\n  };\n\n  onDisconnect(want: Want): void {\n    hilog.info(DOMAIN_NUMBER, TAG, `onDisconnect, want: ${want.abilityName}`);\n  };\n\n  onDestroy(): void {\n    hilog.info(DOMAIN_NUMBER, TAG, 'onDestroy');\n  };\n};", "llm_cg": {"ServiceExtAbility.onCreate(Want)": [], "ServiceExtAbility.onRequest(Want, number)": ["ServiceExtAbility.context.startAbility(Want)"], "ServiceExtAbility.onConnect(Want)": [], "ServiceExtAbility.onDisconnect(Want)": [], "ServiceExtAbility.onDestroy()": []}, "static_cg": {"@test/121.ts: ServiceExtAbility.onRequest(Want, number)": ["@test/121.ts: ServiceExtAbility.%AM1$onRequest()", "@test/121.ts: ServiceExtAbility.%AM0$onRequest(BusinessError)"]}}
{"source_code": "/*\n * Copyright (c) 2023 Huawei Device Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type AbilityConstant from '@ohos.app.ability.AbilityConstant';\nimport hilog from '@ohos.hilog';\nimport UIAbility from '@ohos.app.ability.UIAbility';\nimport type window from '@ohos.window';\nimport type Want from '@ohos.app.ability.Want';\nimport type { Context } from '@ohos.abilityAccessCtrl';\n\nconst TAG: string = '[EventAbility]';\nconst DOMAIN_NUMBER: number = 0xFF00;\n\nexport default class EventAbility extends UIAbility {\n  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {\n    // 获取UIAbility实例的上下文\n    let context = this.context;\n    // 获取eventHub\n    let eventhub = this.context.eventHub;\n    // 执行订阅操作\n    eventhub.on('event1', this.eventFunc);\n    eventhub.on('event1', (data: string) => {\n      // 触发事件，完成相应的业务操作\n    });\n    hilog.info(DOMAIN_NUMBER, TAG, '%{public}s', 'Ability onCreate');\n  }\n\n  onWindowStageCreate(windowStage: window.WindowStage): void {\n    // Main window is created, set main page for this ability\n    hilog.info(DOMAIN_NUMBER, TAG, '%{public}s', 'Ability onWindowStageCreate');\n\n    windowStage.loadContent('pages/Page_EventHub', (err, data) => {\n      if (err.code) {\n        hilog.error(DOMAIN_NUMBER, TAG, 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');\n        return;\n      }\n      hilog.info(DOMAIN_NUMBER, TAG, 'Succeeded in loading the content. Data: %{public}s', JSON.stringify(data) ?? '');\n    });\n  }\n\n  eventFunc(argOne: Context, argTwo: Context): void {\n    hilog.info(DOMAIN_NUMBER, TAG, '1. ' + `${argOne}, ${argTwo}`);\n    return;\n  }\n};\n", "llm_cg": {"EventAbility.onCreate(Want, AbilityConstant.LaunchParam)": ["EventAbility.eventFunc(Context, Context)"], "EventAbility.onWindowStageCreate(window.WindowStage)": []}, "static_cg": {"@test/122.ts: EventAbility.onCreate(Want, AbilityConstant.LaunchParam)": ["@test/122.ts: EventAbility.eventFunc(Context, Context)", "@test/122.ts: EventAbility.%AM0$onCreate(string)"], "@test/122.ts: EventAbility.onWindowStageCreate(window.WindowStage)": ["@test/122.ts: EventAbility.%AM1$onWindowStageCreate(unknown, unknown)"]}}
{"source_code": "/*\n * Copyright (c) 2023 Huawei Device Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type AbilityConstant from '@ohos.app.ability.AbilityConstant';\nimport hilog from '@ohos.hilog';\nimport UIAbility from '@ohos.app.ability.UIAbility';\nimport type Want from '@ohos.app.ability.Want';\nimport type window from '@ohos.window';\nimport abilityAccessCtrl from '@ohos.abilityAccessCtrl';\nimport type { Context } from '@ohos.abilityAccessCtrl';\nimport type { PermissionRequestResult } from '@ohos.abilityAccessCtrl';\nimport type { Permissions } from '@ohos.abilityAccessCtrl';\nimport type { BusinessError } from '@ohos.base';\n\nconst permissions: Array<Permissions> = ['ohos.permission.GET_BUNDLE_INFO_PRIVILEGED'];\nconst TAG: string = '[ContextAbility]';\nconst DOMAIN_NUMBER: number = 0xFF00;\n\nexport default class ContextAbility extends UIAbility {\n\n  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {\n    hilog.info(DOMAIN_NUMBER, TAG, '%{public}s', 'Ability onCreate');\n  }\n\n  onWindowStageCreate(windowStage: window.WindowStage): void {\n    windowStage.loadContent('pages/page_contextability/Page_ContextAbility', (err, data) => {\n      if (err.code) {\n        hilog.error(DOMAIN_NUMBER, TAG, 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');\n        return;\n      }\n      hilog.info(DOMAIN_NUMBER, TAG, 'Succeeded in loading the content. Data: %{public}s', JSON.stringify(data) ?? '');\n    });\n\n    // Main window is created, set main page for this ability\n    let context: Context = this.context;\n    let atManager: abilityAccessCtrl.AtManager = abilityAccessCtrl.createAtManager();\n    // requestPermissionsFromUser会判断权限的授权状态来决定是否唤起弹窗\n    atManager.requestPermissionsFromUser(context, permissions).then((data: PermissionRequestResult) => {\n      let grantStatus: Array<number> = data.authResults;\n      let length: number = grantStatus.length;\n      for (let i = 0; i < length; i++) {\n        if (grantStatus[i] === 0) {\n          // 用户授权，可以继续访问目标操作\n        } else {\n          // 用户拒绝授权，提示用户必须授权才能访问当前页面的功能，并引导用户到系统设置中打开相应的权限\n          return;\n        }\n      }\n      // 授权成功\n    }).catch((err: BusinessError) => {\n      hilog.error(DOMAIN_NUMBER, TAG, `Failed to request permissions from user. Code is ${err.code}, message is ${err.message}`);\n    });\n  }\n};\n", "llm_cg": {"ContextAbility.onCreate(Want, AbilityConstant.LaunchParam)": [], "ContextAbility.onWindowStageCreate(window.WindowStage)": ["window.WindowStage.loadContent(string, (err: BusinessError, data: any) => void)", "abilityAccessCtrl.AtManager.requestPermissionsFromUser(Context, Array<Permissions>)"]}, "static_cg": {"@test/123.ts: ContextAbility.onWindowStageCreate(window.WindowStage)": ["@test/123.ts: ContextAbility.%AM0$onWindowStageCreate(unknown, unknown)", "@test/123.ts: ContextAbility.%AM2$onWindowStageCreate(PermissionRequestResult)", "@test/123.ts: ContextAbility.%AM1$onWindowStageCreate(BusinessError)"]}}
{"source_code": "import hilog from '@ohos.hilog';\nimport AbilityStage from \"@ohos.application.AbilityStage\"\n\nexport default class MyAbilityStage extends AbilityStage {\n    onCreate() {\n        hilog.isLoggable(0x0000, 'testTag', hilog.LogLevel.INFO);\n        hilog.info(0x0000, 'testTag', '%{public}s', 'AbilityStage onCreate');\n    }\n}", "llm_cg": {"MyAbilityStage.onCreate()": ["hilog.isLoggable(0x0000, 'testTag', hilog.LogLevel.INFO)", "hilog.info(0x0000, 'testTag', '%{public}s', 'AbilityStage onCreate')"]}, "static_cg": {}}
{"source_code": "import hilog from '@ohos.hilog';\nimport Ability from '@ohos.application.Ability'\nimport Window from '@ohos.window'\n\nexport default class MainAbility extends Ability {\n    onCreate(want, launchParam) {\n        hilog.isLoggable(0x0000, 'testTag', hilog.LogLevel.INFO);\n        hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onCreate');\n        hilog.info(0x0000, 'testTag', '%{public}s', 'want param:' + JSON.stringify(want) ?? '');\n        hilog.info(0x0000, 'testTag', '%{public}s', 'launchParam:' + JSON.stringify(launchParam) ?? '');\n    }\n\n    onDestroy() {\n        hilog.isLoggable(0x0000, 'testTag', hilog.LogLevel.INFO);\n        hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onDestroy');\n    }\n\n    onWindowStageCreate(windowStage: Window.WindowStage) {\n        // Main window is created, set main page for this ability\n        hilog.isLoggable(0x0000, 'testTag', hilog.LogLevel.INFO);\n        hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageCreate');\n\n        windowStage.loadContent('pages/index', (err, data) => {\n            if (err.code) {\n                hilog.isLoggable(0x0000, 'testTag', hilog.LogLevel.ERROR);\n                hilog.error(0x0000, 'testTag', 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');\n                return;\n            }\n            hilog.isLoggable(0x0000, 'testTag', hilog.LogLevel.INFO);\n            hilog.info(0x0000, 'testTag', 'Succeeded in loading the content. Data: %{public}s', JSON.stringify(data) ?? '');\n        });\n    }\n\n    onWindowStageDestroy() {\n        // Main window is destroyed, release UI related resources\n        hilog.isLoggable(0x0000, 'testTag', hilog.LogLevel.INFO);\n        hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageDestroy');\n    }\n\n    onForeground() {\n        // Ability has brought to foreground\n        hilog.isLoggable(0x0000, 'testTag', hilog.LogLevel.INFO);\n        hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onForeground');\n    }\n\n    onBackground() {\n        // Ability has back to background\n        hilog.isLoggable(0x0000, 'testTag', hilog.LogLevel.INFO);\n        hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onBackground');\n    }\n}\n", "llm_cg": {"MainAbility.onCreate(want, launchParam)": [], "MainAbility.onDestroy()": [], "MainAbility.onWindowStageCreate(windowStage: Window.WindowStage)": ["Window.WindowStage.loadContent('pages/index', (err, data))"], "MainAbility.onWindowStageDestroy()": [], "MainAbility.onForeground()": [], "MainAbility.onBackground()": []}, "static_cg": {"@test/125.ts: MainAbility.onWindowStageCreate(Window.WindowStage)": ["@test/125.ts: MainAbility.%AM0$onWindowStageCreate(unknown, unknown)"]}}
{"source_code": "/*\n * Copyright (c) 2022 Huawei Device Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport hilog from '@ohos.hilog'\n\nclass Logger {\n  private domain: number\n  private prefix: string\n  private format: string = \"%{public}s, %{public}s\"\n\n  constructor(prefix: string) {\n    this.prefix = prefix\n    this.domain = 0xFF00\n  }\n\n  debug(...args: any[]) {\n    hilog.debug(this.domain, this.prefix, this.format, args)\n  }\n\n  info(...args: any[]) {\n    hilog.info(this.domain, this.prefix, this.format, args)\n  }\n\n  warn(...args: any[]) {\n    hilog.warn(this.domain, this.prefix, this.format, args)\n  }\n\n  error(...args: any[]) {\n    hilog.error(this.domain, this.prefix, this.format, args)\n  }\n}\n\nexport default new Logger('[eTSAdaptiveCapabilities]')", "llm_cg": {"Logger.debug(...args: any[])": [], "Logger.info(...args: any[])": [], "Logger.warn(...args: any[])": [], "Logger.error(...args: any[])": []}, "static_cg": {"@test/126.ts: %dflt.[static]%dflt()": ["@test/126.ts: Logger.constructor(string)"]}}
{"source_code": "/*\n * Copyright (c) 2022-2023 Huawei Device Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport AbilityStage from '@ohos.app.ability.AbilityStage'\nimport Logger from '../model/Logger'\n\nexport default class MyAbilityStage extends AbilityStage {\n  onCreate() {\n    Logger.info('[Sample_AdaptiveCapabilities]', 'MyAbilityStage onCreate')\n  }\n}", "llm_cg": {"MyAbilityStage.onCreate()": ["Logger.info(string, string)"]}, "static_cg": {}}
{"source_code": "/*\n * Copyright (c) 2022-2023 Huawei Device Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport UIAbility from '@ohos.app.ability.UIAbility'\nimport Logger from '../model/Logger'\nimport window from '@ohos.window'\n\nexport default class MainAbility extends UIAbility {\n  onCreate(want, launchParam) {\n    Logger.info('[Sample_AdaptiveCapabilities]', 'MainAbility onCreate')\n  }\n\n  onDestroy() {\n    Logger.info('[Sample_AdaptiveCapabilities]', 'MainAbility onDestroy')\n  }\n\n  onWindowStageCreate(windowStage) {\n    // Main window is created, set main page for this ability\n    Logger.info('[Sample_AdaptiveCapabilities]', 'onWindowStageCreate')\n    windowStage.setUIContent(this.context, \"pages/Index\", null)\n    window.getTopWindow(this.context)\n      .then(windowObj => {\n        AppStorage.SetOrCreate('windowObj', windowObj)\n      })\n  }\n\n  onWindowStageDestroy() {\n    // Main window is destroyed, release UI related resources\n    Logger.info('[Sample_AdaptiveCapabilities]', 'onWindowStageDestroy')\n  }\n\n  onForeground() {\n    // Ability has brought to foreground\n    Logger.info('[Sample_AdaptiveCapabilities]', 'onForeground')\n  }\n\n  onBackground() {\n    // Ability has back to background\n    Logger.info('[Sample_AdaptiveCapabilities]', 'onBackground')\n  }\n}\n", "llm_cg": {"MainAbility.onCreate(want, launchParam)": ["Logger.info('[Sample_AdaptiveCapabilities]', 'MainAbility onCreate')"], "MainAbility.onDestroy()": ["Logger.info('[Sample_AdaptiveCapabilities]', 'MainAbility onDestroy')"], "MainAbility.onWindowStageCreate(windowStage)": ["Logger.info('[Sample_AdaptiveCapabilities]', 'onWindowStageCreate')", "windowStage.setUIContent(this.context, \"pages/Index\", null)", "window.getTopWindow(this.context).then(windowObj => { AppStorage.SetOrCreate('windowObj', windowObj) })"], "MainAbility.onWindowStageDestroy()": ["Logger.info('[Sample_AdaptiveCapabilities]', 'onWindowStageDestroy')"], "MainAbility.onForeground()": ["Logger.info('[Sample_AdaptiveCapabilities]', 'onForeground')"], "MainAbility.onBackground()": ["Logger.info('[Sample_AdaptiveCapabilities]', 'onBackground')"]}, "static_cg": {"@test/128.ts: MainAbility.onWindowStageCreate(unknown)": ["@test/128.ts: MainAbility.%AM0$onWindowStageCreate(unknown)"]}}
{"source_code": "import { HttpStatus } from '../enums/http-status.enum';\nimport { HttpException, HttpExceptionOptions } from './http.exception';\nexport class BadRequestException extends HttpException {\n  constructor(\n    objectOrError?: string | object | any,\n    descriptionOrOptions: string | HttpExceptionOptions = 'Bad Request',\n  ) {\n    const { description, httpExceptionOptions } =\n      HttpException.extractDescriptionAndOptionsFrom(descriptionOrOptions);\n    super(\n      HttpException.createBody(\n        objectOrError,\n        description,\n        HttpStatus.BAD_REQUEST,\n      ),\n      HttpStatus.BAD_REQUEST,\n      httpExceptionOptions,\n    );\n  }\n}", "llm_cg": {"BadRequestException.constructor(string | object | any, string | HttpExceptionOptions)": ["HttpException.extractDescriptionAndOptionsFrom(string | HttpExceptionOptions)", "HttpException.createBody(string | object | any, string, HttpStatus)", "HttpException.constructor(string | object | any, HttpStatus, HttpExceptionOptions)"]}, "static_cg": {}}
{"source_code": "import { ConfigPlugin, withProjectBuildGradle } from '@expo/config-plugins';\nimport fs from 'fs';\nimport path from 'path';\nimport semver from 'semver';\n// Because regexp //g is stateful, to use it multiple times, we should create a new one.\nfunction createAgpRegExp() {\n  return /^(\\s*classpath[(\\s][\"']com\\.android\\.tools\\.build:gradle:)(\\d+\\.\\d+\\.\\d+)([\"'][)\\s]\\s*)$/gm;\n}\nexport async function shouldUpdateAgpVersionAsync(projectRoot: string, targetVersion: string) {\n  const gradlePath = path.join(projectRoot, 'android', 'build.gradle');\n  const content = await fs.promises.readFile(gradlePath, 'utf-8');\n  const matchResult = createAgpRegExp().exec(content);\n  if (!matchResult) {\n    console.warn(\n      'Unrecognized `android/build.gradle` content, will skip the process to update AGP version.'\n    );\n    return false;\n  }\n  const version = matchResult[2];\n  if (!version) {\n    console.warn(\n      'Unrecognized `android/build.gradle` content, will skip the process to update AGP version.'\n    );\n    return false;\n  }\n  return semver.lt(toSemVer(version), toSemVer(targetVersion));\n}\nexport const withAndroidGradlePluginVersion: ConfigPlugin<{ androidAgpVersion: string }> = (\n  config,\n  prop\n) => {\n  return withProjectBuildGradle(config, (config) => {\n    if (config.modResults.language !== 'groovy') {\n      throw new Error('Cannot setup kotlin because the build.gradle is not groovy');\n    }\n    const matchResult = createAgpRegExp().exec(config.modResults.contents);\n    if (matchResult) {\n      const version = matchResult[2];\n      if (version && semver.lt(toSemVer(version), toSemVer(prop.androidAgpVersion))) {\n        config.modResults.contents = config.modResults.contents.replace(\n          createAgpRegExp(),\n          (match, prefix, versionPart, suffix) => {\n            return `${prefix}${prop.androidAgpVersion}${suffix}`;\n          }\n        );\n      }\n    }\n    return config;\n  });\n};\nfunction toSemVer(version: string): semver.SemVer {\n  return semver.coerce(version) ?? new semver.SemVer('0.0.0');\n}", "llm_cg": {"shouldUpdateAgpVersionAsync(projectRoot: string, targetVersion: string)": ["%AM0$createAgpRegExp()", "%AM0$toSemVer(version)", "%AM0$toSemVer(targetVersion)"], "withAndroidGradlePluginVersion(config, prop)": ["withProjectBuildGradle(config, %AM1$anonymous(config))", "%AM0$createAgpRegExp()", "%AM0$toSemVer(version)", "%AM0$toSemVer(prop.androidAgpVersion)"], "%AM1$anonymous(config)": ["%AM0$createAgpRegExp()", "%AM0$toSemVer(version)", "%AM0$toSemVer(prop.androidAgpVersion)"], "toSemVer(version: string)": []}, "static_cg": {"@test/130.ts: %dflt.shouldUpdateAgpVersionAsync(string, string)": ["@test/130.ts: %dflt.createAgpRegExp()", "@test/130.ts: %dflt.toSemVer(string)"], "@test/130.ts: %dflt.%AM1$%AM0(unknown)": ["@test/130.ts: %dflt.createAgpRegExp()", "@test/130.ts: %dflt.toSemVer(string)", "@test/130.ts: %dflt.%AM2$%AM1$%AM0(unknown, unknown, unknown, unknown)"], "@test/130.ts: %dflt.%AM0(unknown, unknown)": ["@test/130.ts: %dflt.%AM1$%AM0(unknown)"]}}
{"source_code": "import {REMOTION_BUCKET_PREFIX} from '@remotion/serverless/client';\nimport {\n\tLAMBDA_INSIGHTS_PREFIX,\n\tLOG_GROUP_PREFIX,\n\tRENDER_FN_PREFIX,\n} from '../../shared/constants';\nexport const rolePermissions: {\n\tactions: string[];\n\tresource: string[];\n}[] = [\n\t{\n\t\tactions: ['s3:ListAllMyBuckets'],\n\t\tresource: ['*'],\n\t},\n\t{\n\t\tactions: [\n\t\t\t's3:CreateBucket',\n\t\t\t's3:ListBucket',\n\t\t\t's3:PutBucketAcl',\n\t\t\t's3:GetObject',\n\t\t\t's3:DeleteObject',\n\t\t\t's3:PutObjectAcl',\n\t\t\t's3:PutObject',\n\t\t\t's3:GetBucketLocation',\n\t\t],\n\t\tresource: [`arn:aws:s3:::${REMOTION_BUCKET_PREFIX}*`],\n\t},\n\t{\n\t\tactions: ['lambda:InvokeFunction'],\n\t\tresource: [`arn:aws:lambda:*:*:function:${RENDER_FN_PREFIX}*`],\n\t},\n\t{\n\t\tactions: ['logs:CreateLogGroup'],\n\t\tresource: [`arn:aws:logs:*:*:log-group:${LAMBDA_INSIGHTS_PREFIX}`],\n\t},\n\t{\n\t\tactions: ['logs:CreateLogStream', 'logs:PutLogEvents'],\n\t\tresource: [\n\t\t\t`arn:aws:logs:*:*:log-group:${LOG_GROUP_PREFIX}${RENDER_FN_PREFIX}*`,\n\t\t\t`arn:aws:logs:*:*:log-group:${LAMBDA_INSIGHTS_PREFIX}:*`,\n\t\t],\n\t},\n];", "llm_cg": {}, "static_cg": {}}
{"source_code": "// In this file is a mock implementation of the Google Sheets API.  It is used\n// to test the Google Sheets integration, and it keeps track of a single\n// spreadsheet with many sheets. It aims to be a faithful recreation of the\n// Google Sheets API, but it is not a perfect recreation. Some fields are\n// missing if they aren't relevant to our use of the API. It's possible that\n// this will cause problems for future feature development, but the original\n// development of these tests involved hitting Google's APIs directly and\n// examining the responses. If we couldn't find a good example of something in\n// use, it wasn't included.\nimport { Datasource } from \"@budibase/types\"\nimport nock from \"nock\"\nimport { GoogleSheetsConfig } from \"../../googlesheets\"\nimport type {\n  SpreadsheetProperties,\n  ExtendedValue,\n  WorksheetDimension,\n  WorksheetDimensionProperties,\n  WorksheetProperties,\n  CellData,\n  CellBorder,\n  CellFormat,\n  CellPadding,\n  Color,\n  GridRange,\n  DataSourceSheetProperties,\n} from \"google-spreadsheet/src/lib/types/sheets-types\"\nconst BLACK: Color = { red: 0, green: 0, blue: 0 }\nconst WHITE: Color = { red: 1, green: 1, blue: 1 }\nconst NO_PADDING: CellPadding = { top: 0, right: 0, bottom: 0, left: 0 }\nconst DEFAULT_BORDER: CellBorder = {\n  style: \"SOLID\",\n  width: 1,\n  color: BLACK,\n  colorStyle: { rgbColor: BLACK },\n}\nconst DEFAULT_CELL_FORMAT: CellFormat = {\n  hyperlinkDisplayType: \"PLAIN_TEXT\",\n  horizontalAlignment: \"LEFT\",\n  verticalAlignment: \"BOTTOM\",\n  wrapStrategy: \"OVERFLOW_CELL\",\n  textDirection: \"LEFT_TO_RIGHT\",\n  textRotation: { angle: 0, vertical: false },\n  padding: NO_PADDING,\n  backgroundColorStyle: { rgbColor: BLACK },\n  borders: {\n    top: DEFAULT_BORDER,\n    bottom: DEFAULT_BORDER,\n    left: DEFAULT_BORDER,\n    right: DEFAULT_BORDER,\n  },\n  numberFormat: {\n    type: \"NUMBER\",\n    pattern: \"General\",\n  },\n  backgroundColor: WHITE,\n  textFormat: {\n    foregroundColor: BLACK,\n    fontFamily: \"Arial\",\n    fontSize: 10,\n    bold: false,\n    italic: false,\n    strikethrough: false,\n    underline: false,\n  },\n}\n// https://protobuf.dev/reference/protobuf/google.protobuf/#value\ntype Value = string | number | boolean | null\ninterface Range {\n  row: number\n  column: number\n}\n// https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets.values#ValueRange\ninterface ValueRange {\n  range: string\n  majorDimension: WorksheetDimension\n  values: Value[][]\n}\n// https://developers.google.com/sheets/api/reference/rest/v4/UpdateValuesResponse\ninterface UpdateValuesResponse {\n  spreadsheetId: string\n  updatedRange: string\n  updatedRows: number\n  updatedColumns: number\n  updatedCells: number\n  updatedData: ValueRange\n}\n// https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/request#AddSheetRequest\ninterface AddSheetRequest {\n  properties: Partial<WorksheetProperties>\n}\n// https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/response#AddSheetResponse\ninterface AddSheetResponse {\n  properties: WorksheetProperties\n}\ninterface DeleteRangeRequest {\n  range: GridRange\n  shiftDimension: WorksheetDimension\n}\n// https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/request#DeleteSheetRequest\ninterface DeleteSheetRequest {\n  sheetId: number\n}\n// https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/request\ninterface BatchUpdateRequest {\n  requests: {\n    addSheet?: AddSheetRequest\n    deleteRange?: DeleteRangeRequest\n    deleteSheet?: DeleteSheetRequest\n  }[]\n  includeSpreadsheetInResponse: boolean\n  responseRanges: string[]\n  responseIncludeGridData: boolean\n}\n// https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/response\ninterface BatchUpdateResponse {\n  spreadsheetId: string\n  replies: {\n    addSheet?: AddSheetResponse\n  }[]\n  updatedSpreadsheet: Spreadsheet\n}\n// https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/sheets#RowData\ninterface RowData {\n  values: CellData[]\n}\n// https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/sheets#GridData\ninterface GridData {\n  startRow: number\n  startColumn: number\n  rowData: RowData[]\n  rowMetadata: WorksheetDimensionProperties[]\n  columnMetadata: WorksheetDimensionProperties[]\n}\n// https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/sheets#Sheet\ninterface Sheet {\n  properties: WorksheetProperties\n  data: GridData[]\n}\n// https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets#Spreadsheet\ninterface Spreadsheet {\n  properties: SpreadsheetProperties\n  spreadsheetId: string\n  sheets: Sheet[]\n}\n// https://developers.google.com/sheets/api/reference/rest/v4/ValueInputOption\ntype ValueInputOption =\n  | \"USER_ENTERED\"\n  | \"RAW\"\n  | \"INPUT_VALUE_OPTION_UNSPECIFIED\"\n// https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets.values/append#InsertDataOption\ntype InsertDataOption = \"OVERWRITE\" | \"INSERT_ROWS\"\n// https://developers.google.com/sheets/api/reference/rest/v4/ValueRenderOption\ntype ValueRenderOption = \"FORMATTED_VALUE\" | \"UNFORMATTED_VALUE\" | \"FORMULA\"\n// https://developers.google.com/sheets/api/reference/rest/v4/DateTimeRenderOption\ntype DateTimeRenderOption = \"SERIAL_NUMBER\" | \"FORMATTED_STRING\"\n// https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets.values/append#query-parameters\ninterface AppendParams {\n  valueInputOption?: ValueInputOption\n  insertDataOption?: InsertDataOption\n  includeValuesInResponse?: boolean\n  responseValueRenderOption?: ValueRenderOption\n  responseDateTimeRenderOption?: DateTimeRenderOption\n}\n// https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets.values/batchGet#query-parameters\ninterface BatchGetParams {\n  ranges: string[]\n  majorDimension?: WorksheetDimension\n  valueRenderOption?: ValueRenderOption\n  dateTimeRenderOption?: DateTimeRenderOption\n}\n// https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets.values/batchGet#response-body\ninterface BatchGetResponse {\n  spreadsheetId: string\n  valueRanges: ValueRange[]\n}\ninterface AppendRequest {\n  range: string\n  params: AppendParams\n  body: ValueRange\n}\n// https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets.values/append#response-body\ninterface AppendResponse {\n  spreadsheetId: string\n  tableRange: string\n  updates: UpdateValuesResponse\n}\nexport class GoogleSheetsMock {\n  private config: GoogleSheetsConfig\n  private spreadsheet: Spreadsheet\n  static forDatasource(datasource: Datasource): GoogleSheetsMock {\n    return new GoogleSheetsMock(datasource.config as GoogleSheetsConfig)\n  }\n  private constructor(config: GoogleSheetsConfig) {\n    this.config = config\n    this.spreadsheet = {\n      properties: {\n        title: \"Test Spreadsheet\",\n        locale: \"en_US\",\n        autoRecalc: \"ON_CHANGE\",\n        timeZone: \"America/New_York\",\n        defaultFormat: {},\n        iterativeCalculationSettings: {},\n        spreadsheetTheme: {},\n      },\n      spreadsheetId: config.spreadsheetId,\n      sheets: [],\n    }\n    this.mockAuth()\n    this.mockAPI()\n  }\n  public cell(cell: string): Value | undefined {\n    const cellData = this.cellData(cell)\n    if (!cellData) {\n      return undefined\n    }\n    return this.cellValue(cellData)\n  }\n  public set(cell: string, value: Value): void {\n    const cellData = this.cellData(cell)\n    if (!cellData) {\n      throw new Error(`Cell ${cell} not found`)\n    }\n    cellData.userEnteredValue = this.createValue(value)\n  }\n  public sheet(name: string | number): Sheet | undefined {\n    if (typeof name === \"number\") {\n      return this.getSheetById(name)\n    }\n    return this.getSheetByName(name)\n  }\n  public createSheet(opts: Partial<WorksheetProperties>): Sheet {\n    const properties = this.defaultWorksheetProperties(opts)\n    if (this.getSheetByName(properties.title)) {\n      throw new Error(`Sheet ${properties.title} already exists`)\n    }\n    const resp = this.handleAddSheet({ properties })\n    return this.getSheetById(resp.properties.sheetId)!\n  }\n  private route(\n    method: \"get\" | \"put\" | \"post\",\n    path: string | RegExp,\n    handler: (uri: string, request: nock.Body) => nock.Body\n  ): nock.Scope {\n    const headers = { reqheaders: { authorization: \"Bearer test\" } }\n    const scope = nock(\"https://sheets.googleapis.com/\", headers)\n    return scope[method](path).reply(200, handler).persist()\n  }\n  private get(\n    path: string | RegExp,\n    handler: (uri: string, request: nock.Body) => nock.Body\n  ): nock.Scope {\n    return this.route(\"get\", path, handler)\n  }\n  private put(\n    path: string | RegExp,\n    handler: (uri: string, request: nock.Body) => nock.Body\n  ): nock.Scope {\n    return this.route(\"put\", path, handler)\n  }\n  private post(\n    path: string | RegExp,\n    handler: (uri: string, request: nock.Body) => nock.Body\n  ): nock.Scope {\n    return this.route(\"post\", path, handler)\n  }\n  private mockAuth() {\n    nock(\"https://www.googleapis.com/\")\n      .post(\"/oauth2/v4/token\")\n      .reply(200, {\n        grant_type: \"client_credentials\",\n        client_id: \"your-client-id\",\n        client_secret: \"your-client-secret\",\n      })\n      .persist()\n    nock(\"https://oauth2.googleapis.com/\")\n      .post(\"/token\", {\n        client_id: \"test\",\n        client_secret: \"test\",\n        grant_type: \"refresh_token\",\n        refresh_token: \"refreshToken\",\n      })\n      .reply(200, {\n        access_token: \"test\",\n        expires_in: 3600,\n        token_type: \"Bearer\",\n        scopes: \"https://www.googleapis.com/auth/spreadsheets\",\n      })\n      .persist()\n  }\n  private mockAPI() {\n    const spreadsheetId = this.config.spreadsheetId\n    this.get(`/v4/spreadsheets/${spreadsheetId}/`, () =>\n      this.handleGetSpreadsheet()\n    )\n    // https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets.values/batchUpdate\n    this.post(\n      `/v4/spreadsheets/${spreadsheetId}/:batchUpdate`,\n      (_uri, request) => this.handleBatchUpdate(request as BatchUpdateRequest)\n    )\n    // https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets.values/update\n    this.put(\n      new RegExp(`/v4/spreadsheets/${spreadsheetId}/values/.*`),\n      (_uri, request) => this.handleValueUpdate(request as ValueRange)\n    )\n    // https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets.values/batchGet\n    this.get(\n      new RegExp(`/v4/spreadsheets/${spreadsheetId}/values:batchGet.*`),\n      uri => {\n        const url = new URL(uri, \"https://sheets.googleapis.com/\")\n        const params: BatchGetParams = {\n          ranges: url.searchParams.getAll(\"ranges\"),\n          majorDimension:\n            (url.searchParams.get(\"majorDimension\") as WorksheetDimension) ||\n            \"ROWS\",\n          valueRenderOption:\n            (url.searchParams.get(\"valueRenderOption\") as ValueRenderOption) ||\n            undefined,\n          dateTimeRenderOption:\n            (url.searchParams.get(\n              \"dateTimeRenderOption\"\n            ) as DateTimeRenderOption) || undefined,\n        }\n        return this.handleBatchGet(params as unknown as BatchGetParams)\n      }\n    )\n    // https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets.values/get\n    this.get(new RegExp(`/v4/spreadsheets/${spreadsheetId}/values/.*`), uri => {\n      const range = uri.split(\"/\").pop()\n      if (!range) {\n        throw new Error(\"No range provided\")\n      }\n      return this.getValueRange(decodeURIComponent(range))\n    })\n    // https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets.values/append\n    this.post(\n      new RegExp(`/v4/spreadsheets/${spreadsheetId}/values/.*:append`),\n      (_uri, request) => {\n        const url = new URL(_uri, \"https://sheets.googleapis.com/\")\n        const params: Record<string, any> = Object.fromEntries(\n          url.searchParams.entries()\n        )\n        if (params.includeValuesInResponse === \"true\") {\n          params.includeValuesInResponse = true\n        } else {\n          params.includeValuesInResponse = false\n        }\n        let range = url.pathname.split(\"/\").pop()\n        if (!range) {\n          throw new Error(\"No range provided\")\n        }\n        if (range.endsWith(\":append\")) {\n          range = range.slice(0, -7)\n        }\n        range = decodeURIComponent(range)\n        return this.handleValueAppend({\n          range,\n          params,\n          body: request as ValueRange,\n        })\n      }\n    )\n  }\n  private handleValueAppend(request: AppendRequest): AppendResponse {\n    const { range, params, body } = request\n    const { sheetId, endRowIndex } = this.parseA1Notation(range)\n    const sheet = this.getSheetById(sheetId)\n    if (!sheet) {\n      throw new Error(`Sheet ${sheetId} not found`)\n    }\n    const newRows = body.values.map(v => this.valuesToRowData(v))\n    const toDelete =\n      params.insertDataOption === \"INSERT_ROWS\" ? newRows.length : 0\n    sheet.data[0].rowData.splice(endRowIndex + 1, toDelete, ...newRows)\n    sheet.data[0].rowMetadata.splice(endRowIndex + 1, toDelete, {\n      hiddenByUser: false,\n      hiddenByFilter: false,\n      pixelSize: 100,\n      developerMetadata: [],\n    })\n    // It's important to give back a correct updated range because the API\n    // library we use makes use of it to assign the correct row IDs to rows.\n    const updatedRange = this.createA1({\n      sheetId,\n      startRowIndex: endRowIndex + 1,\n      startColumnIndex: 0,\n      endRowIndex: endRowIndex + newRows.length,\n      endColumnIndex: 0,\n    })\n    sheet.properties.gridProperties.rowCount = sheet.data[0].rowData.length\n    return {\n      spreadsheetId: this.spreadsheet.spreadsheetId,\n      tableRange: range,\n      updates: {\n        spreadsheetId: this.spreadsheet.spreadsheetId,\n        updatedRange,\n        updatedRows: body.values.length,\n        updatedColumns: body.values[0].length,\n        updatedCells: body.values.length * body.values[0].length,\n        updatedData: body,\n      },\n    }\n  }\n  private handleBatchGet(params: BatchGetParams): BatchGetResponse {\n    const { ranges, majorDimension } = params\n    if (majorDimension && majorDimension !== \"ROWS\") {\n      throw new Error(\"Only row-major updates are supported\")\n    }\n    return {\n      spreadsheetId: this.spreadsheet.spreadsheetId,\n      valueRanges: ranges.map(range => this.getValueRange(range)),\n    }\n  }\n  private handleBatchUpdate(\n    batchUpdateRequest: BatchUpdateRequest\n  ): BatchUpdateResponse {\n    const response: BatchUpdateResponse = {\n      spreadsheetId: this.spreadsheet.spreadsheetId,\n      replies: [],\n      updatedSpreadsheet: this.spreadsheet,\n    }\n    for (const request of batchUpdateRequest.requests) {\n      if (request.addSheet) {\n        response.replies.push({\n          addSheet: this.handleAddSheet(request.addSheet),\n        })\n      }\n      if (request.deleteRange) {\n        this.handleDeleteRange(request.deleteRange)\n        response.replies.push({})\n      }\n      if (request.deleteSheet) {\n        this.handleDeleteSheet(request.deleteSheet)\n        response.replies.push({})\n      }\n    }\n    return response\n  }\n  private defaultWorksheetProperties(\n    opts: Partial<WorksheetProperties>\n  ): WorksheetProperties {\n    return {\n      index: this.spreadsheet.sheets.length,\n      hidden: false,\n      rightToLeft: false,\n      tabColor: BLACK,\n      tabColorStyle: { rgbColor: BLACK },\n      sheetType: \"GRID\",\n      title: \"Sheet\",\n      sheetId: this.spreadsheet.sheets.length,\n      gridProperties: {\n        rowCount: 100,\n        columnCount: 26,\n      },\n      dataSourceSheetProperties: {} as DataSourceSheetProperties,\n      ...opts,\n    }\n  }\n  private handleAddSheet(request: AddSheetRequest): AddSheetResponse {\n    const properties = this.defaultWorksheetProperties(request.properties)\n    this.spreadsheet.sheets.push({\n      properties,\n      data: [\n        this.createEmptyGrid(\n          properties.gridProperties.rowCount,\n          properties.gridProperties.columnCount\n        ),\n      ],\n    })\n    return { properties }\n  }\n  private handleDeleteRange(request: DeleteRangeRequest) {\n    const { range, shiftDimension } = request\n    if (shiftDimension !== \"ROWS\") {\n      throw new Error(\"Only row-based deletes are supported\")\n    }\n    this.iterateRange(range, cell => {\n      cell.userEnteredValue = this.createValue(null)\n    })\n  }\n  private handleDeleteSheet(request: DeleteSheetRequest) {\n    const { sheetId } = request\n    this.spreadsheet.sheets.splice(sheetId, 1)\n  }\n  private handleGetSpreadsheet(): Spreadsheet {\n    return this.spreadsheet\n  }\n  private handleValueUpdate(valueRange: ValueRange): UpdateValuesResponse {\n    this.iterateValueRange(valueRange, (cell, value) => {\n      cell.userEnteredValue = this.createValue(value)\n    })\n    const response: UpdateValuesResponse = {\n      spreadsheetId: this.spreadsheet.spreadsheetId,\n      updatedRange: valueRange.range,\n      updatedRows: valueRange.values.length,\n      updatedColumns: valueRange.values[0].length,\n      updatedCells: valueRange.values.length * valueRange.values[0].length,\n      updatedData: valueRange,\n    }\n    return response\n  }\n  private iterateRange(range: GridRange, cb: (cell: CellData) => void) {\n    const {\n      sheetId,\n      startRowIndex,\n      endRowIndex,\n      startColumnIndex,\n      endColumnIndex,\n    } = this.ensureGridRange(range)\n    for (let row = startRowIndex; row <= endRowIndex; row++) {\n      for (let col = startColumnIndex; col <= endColumnIndex; col++) {\n        const cell = this.getCellNumericIndexes(sheetId, row, col)\n        if (!cell) {\n          throw new Error(\"Cell not found\")\n        }\n        cb(cell)\n      }\n    }\n  }\n  private iterateValueRange(\n    valueRange: ValueRange,\n    cb: (cell: CellData, value: Value) => void\n  ) {\n    if (valueRange.majorDimension !== \"ROWS\") {\n      throw new Error(\"Only row-major updates are supported\")\n    }\n    const {\n      sheetId,\n      startColumnIndex,\n      startRowIndex,\n      endColumnIndex,\n      endRowIndex,\n    } = this.parseA1Notation(valueRange.range)\n    for (let row = startRowIndex; row <= endRowIndex; row++) {\n      for (let col = startColumnIndex; col <= endColumnIndex; col++) {\n        const cell = this.getCellNumericIndexes(sheetId, row, col)\n        if (!cell) {\n          throw new Error(\"Cell not found\")\n        }\n        const value =\n          valueRange.values[row - startRowIndex][col - startColumnIndex]\n        cb(cell, value)\n      }\n    }\n  }\n  private getValueRange(range: string): ValueRange {\n    const {\n      sheetId,\n      startRowIndex,\n      endRowIndex,\n      startColumnIndex,\n      endColumnIndex,\n    } = this.parseA1Notation(range)\n    const valueRange: ValueRange = {\n      range,\n      majorDimension: \"ROWS\",\n      values: [],\n    }\n    for (let row = startRowIndex; row <= endRowIndex; row++) {\n      const values: Value[] = []\n      for (let col = startColumnIndex; col <= endColumnIndex; col++) {\n        const cell = this.getCellNumericIndexes(sheetId, row, col)\n        if (!cell) {\n          throw new Error(\"Cell not found\")\n        }\n        values.push(this.cellValue(cell))\n      }\n      valueRange.values.push(values)\n    }\n    return this.trimValueRange(valueRange)\n  }\n  // When Google Sheets returns a value range, it will trim the data down to the\n  // smallest possible size. It does all of the following:\n  //\n  // 1. Converts cells in non-empty rows up to the first value to empty strings.\n  // 2. Removes all cells after the last non-empty cell in a row.\n  // 3. Removes all rows after the last non-empty row.\n  // 4. Rows that are before the first non-empty row that are empty are replaced with [].\n  //\n  // We replicate this behaviour here.\n  private trimValueRange(valueRange: ValueRange): ValueRange {\n    for (const row of valueRange.values) {\n      if (row.every(v => v == null)) {\n        row.splice(0, row.length)\n        continue\n      }\n      for (let i = row.length - 1; i >= 0; i--) {\n        const cell = row[i]\n        if (cell == null) {\n          row.pop()\n        } else {\n          break\n        }\n      }\n      for (let i = 0; i < row.length; i++) {\n        const cell = row[i]\n        if (cell == null) {\n          row[i] = \"\"\n        } else {\n          break\n        }\n      }\n    }\n    for (let i = valueRange.values.length - 1; i >= 0; i--) {\n      const row = valueRange.values[i]\n      if (row.length === 0) {\n        valueRange.values.pop()\n      } else {\n        break\n      }\n    }\n    return valueRange\n  }\n  private valuesToRowData(values: Value[]): RowData {\n    return {\n      values: values.map(v => {\n        return this.createCellData(v)\n      }),\n    }\n  }\n  private unwrapValue(from: ExtendedValue): Value {\n    if (\"stringValue\" in from) {\n      return from.stringValue\n    } else if (\"numberValue\" in from) {\n      return from.numberValue\n    } else if (\"boolValue\" in from) {\n      return from.boolValue\n    } else if (\"formulaValue\" in from) {\n      return from.formulaValue\n    } else {\n      return null\n    }\n  }\n  private cellValue(from: CellData): Value {\n    return this.unwrapValue(from.userEnteredValue)\n  }\n  private createValue(from: Value): ExtendedValue {\n    if (from == null) {\n      return {} as ExtendedValue\n    } else if (typeof from === \"string\") {\n      return {\n        stringValue: from,\n      }\n    } else if (typeof from === \"number\") {\n      return {\n        numberValue: from,\n      }\n    } else if (typeof from === \"boolean\") {\n      return {\n        boolValue: from,\n      }\n    } else {\n      throw new Error(\"Unsupported value type\")\n    }\n  }\n  private createCellData(value: Value): CellData {\n    return {\n      userEnteredValue: this.createValue(value),\n      effectiveValue: this.createValue(value),\n      formattedValue: value?.toString() || \"\",\n      userEnteredFormat: DEFAULT_CELL_FORMAT,\n      effectiveFormat: DEFAULT_CELL_FORMAT,\n    }\n  }\n  private createEmptyGrid(numRows: number, numCols: number): GridData {\n    const rowData: RowData[] = []\n    for (let row = 0; row < numRows; row++) {\n      const cells: CellData[] = []\n      for (let col = 0; col < numCols; col++) {\n        cells.push(this.createCellData(null))\n      }\n      rowData.push({ values: cells })\n    }\n    const rowMetadata: WorksheetDimensionProperties[] = []\n    for (let row = 0; row < numRows; row++) {\n      rowMetadata.push({\n        hiddenByFilter: false,\n        hiddenByUser: false,\n        pixelSize: 100,\n        developerMetadata: [],\n      })\n    }\n    const columnMetadata: WorksheetDimensionProperties[] = []\n    for (let col = 0; col < numCols; col++) {\n      columnMetadata.push({\n        hiddenByFilter: false,\n        hiddenByUser: false,\n        pixelSize: 100,\n        developerMetadata: [],\n      })\n    }\n    return {\n      startRow: 0,\n      startColumn: 0,\n      rowData,\n      rowMetadata,\n      columnMetadata,\n    }\n  }\n  private cellData(cell: string): CellData | undefined {\n    const { sheetId, startColumnIndex, startRowIndex } =\n      this.parseA1Notation(cell)\n    return this.getCellNumericIndexes(sheetId, startRowIndex, startColumnIndex)\n  }\n  private getCellNumericIndexes(\n    sheet: Sheet | number,\n    row: number,\n    column: number\n  ): CellData | undefined {\n    if (typeof sheet === \"number\") {\n      const foundSheet = this.getSheetById(sheet)\n      if (!foundSheet) {\n        return undefined\n      }\n      sheet = foundSheet\n    }\n    const data = sheet.data[0]\n    const rowData = data.rowData[row]\n    if (!rowData) {\n      return undefined\n    }\n    const cell = rowData.values[column]\n    if (!cell) {\n      return undefined\n    }\n    return cell\n  }\n  // https://developers.google.com/sheets/api/guides/concepts#cell\n  //\n  // Examples from\n  //   https://code.luasoftware.com/tutorials/google-sheets-api/google-sheets-api-range-parameter-a1-notation\n  //\n  //   \"Sheet1!A1\"     -> First cell on Row 1 Col 1\n  //   \"Sheet1!A1:C1\"  -> Col 1-3 (A, B, C) on Row 1 = A1, B1, C1\n  //   \"A1\"            -> First visible sheet (if sheet name is ommitted)\n  //   \"'My Sheet'!A1\" -> If sheet name which contain space or start with a bracket.\n  //   \"Sheet1\"        -> All cells in Sheet1.\n  //   \"Sheet1!A:A\"    -> All cells on Col 1.\n  //   \"Sheet1!A:B\"    -> All cells on Col 1 and 2.\n  //   \"Sheet1!1:1\"    -> All cells on Row 1.\n  //   \"Sheet1!1:2\"    -> All cells on Row 1 and 2.\n  //\n  // How that translates to our code below, omitting the `sheet` property:\n  //\n  //   \"Sheet1!A1\"     -> { topLeft: { row: 0, column: 0 }, bottomRight: { row: 0, column: 0 } }\n  //   \"Sheet1!A1:C1\"  -> { topLeft: { row: 0, column: 0 }, bottomRight: { row: 0, column: 2 } }\n  //   \"A1\"            -> { topLeft: { row: 0, column: 0 }, bottomRight: { row: 0, column: 0 } }\n  //   \"Sheet1\"        -> { topLeft: { row: 0, column: 0 }, bottomRight: { row: 100, column: 25 } }\n  //                    -> This is because we default to having a 100x26 grid.\n  //   \"Sheet1!A:A\"    -> { topLeft: { row: 0, column: 0 }, bottomRight: { row: 99, column: 0 } }\n  //   \"Sheet1!A:B\"    -> { topLeft: { row: 0, column: 0 }, bottomRight: { row: 99, column: 1 } }\n  //   \"Sheet1!1:1\"    -> { topLeft: { row: 0, column: 0 }, bottomRight: { row: 0, column: 25 } }\n  //   \"Sheet1!1:2\"    -> { topLeft: { row: 0, column: 0 }, bottomRight: { row: 1, column: 25 } }\n  private parseA1Notation(range: string): Required<GridRange> {\n    let sheet: Sheet\n    let rest: string\n    if (!range.includes(\"!\")) {\n      sheet = this.spreadsheet.sheets[0]\n      rest = range\n    } else {\n      let sheetName = range.split(\"!\")[0]\n      if (sheetName.startsWith(\"'\") && sheetName.endsWith(\"'\")) {\n        sheetName = sheetName.slice(1, -1)\n      }\n      const foundSheet = this.getSheetByName(sheetName)\n      if (!foundSheet) {\n        throw new Error(`Sheet ${sheetName} not found`)\n      }\n      sheet = foundSheet\n      rest = range.split(\"!\")[1]\n    }\n    const [topLeft, bottomRight] = rest.split(\":\")\n    const parsedTopLeft = topLeft ? this.parseCell(topLeft) : undefined\n    let parsedBottomRight = bottomRight\n      ? this.parseCell(bottomRight)\n      : undefined\n    if (!parsedTopLeft && !parsedBottomRight) {\n      throw new Error(\"No range provided\")\n    }\n    if (!parsedTopLeft) {\n      throw new Error(\"No top left cell provided\")\n    }\n    if (!parsedBottomRight) {\n      parsedBottomRight = parsedTopLeft\n    }\n    return this.ensureGridRange({\n      sheetId: sheet.properties.sheetId,\n      startRowIndex: parsedTopLeft.row,\n      endRowIndex: parsedBottomRight.row,\n      startColumnIndex: parsedTopLeft.column,\n      endColumnIndex: parsedBottomRight.column,\n    })\n  }\n  private ensureGridRange(range: GridRange): Required<GridRange> {\n    const sheet = this.getSheetById(range.sheetId)\n    if (!sheet) {\n      throw new Error(`Sheet ${range.sheetId} not found`)\n    }\n    return {\n      sheetId: range.sheetId,\n      startRowIndex: range.startRowIndex ?? 0,\n      endRowIndex:\n        range.endRowIndex ?? sheet.properties.gridProperties.rowCount - 1,\n      startColumnIndex: range.startColumnIndex ?? 0,\n      endColumnIndex:\n        range.endColumnIndex ?? sheet.properties.gridProperties.columnCount - 1,\n    }\n  }\n  private createA1(range: Required<GridRange>) {\n    const {\n      sheetId,\n      startColumnIndex,\n      startRowIndex,\n      endColumnIndex,\n      endRowIndex,\n    } = range\n    const sheet = this.getSheetById(sheetId)\n    if (!sheet) {\n      throw new Error(`Sheet ${range.sheetId} not found`)\n    }\n    let title = sheet.properties.title\n    if (title.includes(\" \")) {\n      title = `'${title}'`\n    }\n    const topLeftLetter = this.numberToLetter(startColumnIndex)\n    const bottomRightLetter = this.numberToLetter(endColumnIndex)\n    const topLeftRow = startRowIndex + 1\n    const bottomRightRow = endRowIndex + 1\n    return `${title}!${topLeftLetter}${topLeftRow}:${bottomRightLetter}${bottomRightRow}`\n  }\n  private parseCell(cell: string): Partial<Range> {\n    const firstChar = cell.slice(0, 1)\n    if (this.isInteger(firstChar)) {\n      return { row: parseInt(cell) - 1 }\n    }\n    const column = this.letterToNumber(firstChar)\n    if (cell.length === 1) {\n      return { column }\n    }\n    const number = cell.slice(1)\n    return { row: parseInt(number) - 1, column }\n  }\n  private isInteger(value: string): boolean {\n    return !isNaN(parseInt(value))\n  }\n  private letterToNumber(letter: string): number {\n    return letter.charCodeAt(0) - 65\n  }\n  private numberToLetter(number: number): string {\n    return String.fromCharCode(number + 65)\n  }\n  private getSheetByName(name: string): Sheet | undefined {\n    return this.spreadsheet.sheets.find(\n      sheet => sheet.properties.title === name\n    )\n  }\n  private getSheetById(id: number): Sheet | undefined {\n    return this.spreadsheet.sheets.find(\n      sheet => sheet.properties.sheetId === id\n    )\n  }\n}", "llm_cg": {"GoogleSheetsMock.forDatasource(datasource: Datasource)": ["GoogleSheetsMock.%AM0$<constructor>(config: GoogleSheetsConfig)"], "GoogleSheetsMock.cell(cell: string)": ["GoogleSheetsMock.%AM0$cellData(cell: string)", "GoogleSheetsMock.%AM0$cellValue(from: CellData)"], "GoogleSheetsMock.set(cell: string, value: Value)": ["GoogleSheetsMock.%AM0$cellData(cell: string)", "GoogleSheetsMock.%AM0$createValue(from: Value)"], "GoogleSheetsMock.sheet(name: string | number)": ["GoogleSheetsMock.%AM0$getSheetById(id: number)", "GoogleSheetsMock.%AM0$getSheetByName(name: string)"], "GoogleSheetsMock.createSheet(opts: Partial<WorksheetProperties>): Sheet": ["GoogleSheetsMock.%AM0$defaultWorksheetProperties(opts: Partial<WorksheetProperties>)", "GoogleSheetsMock.%AM0$getSheetByName(name: string)", "GoogleSheetsMock.%AM0$handleAddSheet(request: AddSheetRequest)", "GoogleSheetsMock.%AM0$getSheetById(id: number)"], "GoogleSheetsMock.get(path: string | RegExp, handler: (uri: string, request: nock.Body) => nock.Body): nock.Scope": ["GoogleSheetsMock.%AM0$route(method: \"get\" | \"put\" | \"post\", path: string | RegExp, handler: (uri: string, request: nock.Body) => nock.Body)"], "GoogleSheetsMock.put(path: string | RegExp, handler: (uri: string, request: nock.Body) => nock.Body): nock.Scope": ["GoogleSheetsMock.%AM0$route(method: \"get\" | \"put\" | \"post\", path: string | RegExp, handler: (uri: string, request: nock.Body) => nock.Body)"], "GoogleSheetsMock.post(path: string | RegExp, handler: (uri: string, request: nock.Body) => nock.Body): nock.Scope": ["GoogleSheetsMock.%AM0$route(method: \"get\" | \"put\" | \"post\", path: string | RegExp, handler: (uri: string, request: nock.Body) => nock.Body)"], "GoogleSheetsMock.mockAuth()": [], "GoogleSheetsMock.mockAPI()": ["GoogleSheetsMock.%AM0$get(path: string | RegExp, handler: (uri: string, request: nock.Body) => nock.Body)", "GoogleSheetsMock.%AM0$post(path: string | RegExp, handler: (uri: string, request: nock.Body) => nock.Body)", "GoogleSheetsMock.%AM0$put(path: string | RegExp, handler: (uri: string, request: nock.Body) => nock.Body)"], "GoogleSheetsMock.handleValueAppend(request: AppendRequest): AppendResponse": ["GoogleSheetsMock.%AM0$parseA1Notation(range: string)", "GoogleSheetsMock.%AM0$valuesToRowData(values: Value[])", "GoogleSheetsMock.%AM0$createA1(range: Required<GridRange>)"], "GoogleSheetsMock.handleBatchGet(params: BatchGetParams): BatchGetResponse": ["GoogleSheetsMock.%AM0$getValueRange(range: string)"], "GoogleSheetsMock.handleBatchUpdate(batchUpdateRequest: BatchUpdateRequest): BatchUpdateResponse": ["GoogleSheetsMock.%AM0$handleAddSheet(request: AddSheetRequest)", "GoogleSheetsMock.%AM0$handleDeleteRange(request: DeleteRangeRequest)", "GoogleSheetsMock.%AM0$handleDeleteSheet(request: DeleteSheetRequest)"], "GoogleSheetsMock.defaultWorksheetProperties(opts: Partial<WorksheetProperties>): WorksheetProperties": [], "GoogleSheetsMock.handleAddSheet(request: AddSheetRequest): AddSheetResponse": ["GoogleSheetsMock.%AM0$defaultWorksheetProperties(opts: Partial<WorksheetProperties>)", "GoogleSheetsMock.%AM0$createEmptyGrid(numRows: number, numCols: number)"], "GoogleSheetsMock.handleDeleteRange(request: DeleteRangeRequest)": ["GoogleSheetsMock.%AM0$iterateRange(range: GridRange, cb: (cell: CellData) => void)", "GoogleSheetsMock.%AM0$createValue(from: Value)"], "GoogleSheetsMock.handleDeleteSheet(request: DeleteSheetRequest)": [], "GoogleSheetsMock.handleGetSpreadsheet(): Spreadsheet": [], "GoogleSheetsMock.handleValueUpdate(valueRange: ValueRange): UpdateValuesResponse": ["GoogleSheetsMock.%AM0$iterateValueRange(valueRange: ValueRange, cb: (cell: CellData, value: Value) => void)", "GoogleSheetsMock.%AM0$createValue(from: Value)"], "GoogleSheetsMock.iterateRange(range: GridRange, cb: (cell: CellData) => void)": ["GoogleSheetsMock.%AM0$ensureGridRange(range: GridRange)", "GoogleSheetsMock.%AM0$getCellNumericIndexes(sheet: Sheet | number, row: number, column: number)"], "GoogleSheetsMock.iterateValueRange(valueRange: ValueRange, cb: (cell: CellData, value: Value) => void)": ["GoogleSheetsMock.%AM0$parseA1Notation(range: string)", "GoogleSheetsMock.%AM0$getCellNumericIndexes(sheet: Sheet | number, row: number, column: number)"], "GoogleSheetsMock.getValueRange(range: string): ValueRange": ["GoogleSheetsMock.%AM0$parseA1Notation(range: string)", "GoogleSheetsMock.%AM0$getCellNumericIndexes(sheet: Sheet | number, row: number, column: number)", "GoogleSheetsMock.%AM0$cellValue(from: CellData)", "GoogleSheetsMock.%AM0$trimValueRange(valueRange: ValueRange)"], "GoogleSheetsMock.trimValueRange(valueRange: ValueRange): ValueRange": [], "GoogleSheetsMock.valuesToRowData(values: Value[]): RowData": ["GoogleSheetsMock.%AM0$createCellData(value: Value)"], "GoogleSheetsMock.unwrapValue(from: ExtendedValue): Value": [], "GoogleSheetsMock.cellValue(from: CellData): Value": ["GoogleSheetsMock.%AM0$unwrapValue(from: ExtendedValue)"], "GoogleSheetsMock.createValue(from: Value): ExtendedValue": [], "GoogleSheetsMock.createCellData(value: Value): CellData": ["GoogleSheetsMock.%AM0$createValue(from: Value)"], "GoogleSheetsMock.createEmptyGrid(numRows: number, numCols: number): GridData": ["GoogleSheetsMock.%AM0$createCellData(value: Value)"], "GoogleSheetsMock.cellData(cell: string): CellData | undefined": ["GoogleSheetsMock.%AM0$parseA1Notation(range: string)", "GoogleSheetsMock.%AM0$getCellNumericIndexes(sheet: Sheet | number, row: number, column: number)"], "GoogleSheetsMock.getCellNumericIndexes(sheet: Sheet | number, row: number, column: number): CellData | undefined": ["GoogleSheetsMock.%AM0$getSheetById(id: number)"], "GoogleSheetsMock.parseA1Notation(range: string): Required<GridRange>": ["GoogleSheetsMock.%AM0$getSheetByName(name: string)", "GoogleSheetsMock.%AM0$ensureGridRange(range: GridRange)"], "GoogleSheetsMock.ensureGridRange(range: GridRange): Required<GridRange>": ["GoogleSheetsMock.%AM0$getSheetById(id: number)"], "GoogleSheetsMock.createA1(range: Required<GridRange>)": ["GoogleSheetsMock.%AM0$getSheetById(id: number)", "GoogleSheetsMock.%AM0$numberToLetter(number: number)"], "GoogleSheetsMock.parseCell(cell: string): Partial<Range>": ["GoogleSheetsMock.%AM0$letterToNumber(letter: string)"], "GoogleSheetsMock.letterToNumber(letter: string): number": [], "GoogleSheetsMock.numberToLetter(number: number): string": [], "GoogleSheetsMock.getSheetByName(name: string): Sheet | undefined": [], "GoogleSheetsMock.getSheetById(id: number): Sheet | undefined": []}, "static_cg": {"@test/132.ts: GoogleSheetsMock.constructor(GoogleSheetsConfig)": ["@test/132.ts: GoogleSheetsMock.mockAuth()", "@test/132.ts: GoogleSheetsMock.mockAPI()"], "@test/132.ts: GoogleSheetsMock.cell(string)": ["@test/132.ts: GoogleSheetsMock.cellData(string)", "@test/132.ts: GoogleSheetsMock.cellValue(CellData)"], "@test/132.ts: GoogleSheetsMock.set(string, Value)": ["@test/132.ts: GoogleSheetsMock.cellData(string)", "@test/132.ts: GoogleSheetsMock.createValue(Value)"], "@test/132.ts: GoogleSheetsMock.sheet(string|number)": ["@test/132.ts: GoogleSheetsMock.getSheetById(number)", "@test/132.ts: GoogleSheetsMock.getSheetByName(string)"], "@test/132.ts: GoogleSheetsMock.createSheet(Partial<WorksheetProperties>)": ["@test/132.ts: GoogleSheetsMock.defaultWorksheetProperties(Partial<WorksheetProperties>)", "@test/132.ts: GoogleSheetsMock.getSheetByName(string)", "@test/132.ts: GoogleSheetsMock.handleAddSheet(@test/132.ts: AddSheetRequest)", "@test/132.ts: GoogleSheetsMock.getSheetById(number)"], "@test/132.ts: GoogleSheetsMock.route(string|string|string, string|RegExp, @test/132.ts: GoogleSheetsMock.%AM0(string, nock.Body))": ["@test/132.ts: GoogleSheetsMock.%AM0(string, nock.Body)"], "@test/132.ts: GoogleSheetsMock.get(string|RegExp, @test/132.ts: GoogleSheetsMock.%AM1(string, nock.Body))": ["@test/132.ts: GoogleSheetsMock.%AM1(string, nock.Body)", "@test/132.ts: GoogleSheetsMock.route(string|string|string, string|RegExp, @test/132.ts: GoogleSheetsMock.%AM0(string, nock.Body))"], "@test/132.ts: GoogleSheetsMock.put(string|RegExp, @test/132.ts: GoogleSheetsMock.%AM2(string, nock.Body))": ["@test/132.ts: GoogleSheetsMock.%AM2(string, nock.Body)", "@test/132.ts: GoogleSheetsMock.route(string|string|string, string|RegExp, @test/132.ts: GoogleSheetsMock.%AM0(string, nock.Body))"], "@test/132.ts: GoogleSheetsMock.post(string|RegExp, @test/132.ts: GoogleSheetsMock.%AM3(string, nock.Body))": ["@test/132.ts: GoogleSheetsMock.%AM3(string, nock.Body)", "@test/132.ts: GoogleSheetsMock.route(string|string|string, string|RegExp, @test/132.ts: GoogleSheetsMock.%AM0(string, nock.Body))"], "@test/132.ts: GoogleSheetsMock.mockAPI()": ["@test/132.ts: GoogleSheetsMock.%AM6$mockAPI()", "@test/132.ts: GoogleSheetsMock.get(string|RegExp, @test/132.ts: GoogleSheetsMock.%AM1(string, nock.Body))", "@test/132.ts: GoogleSheetsMock.%AM7$mockAPI(string, nock.Body)", "@test/132.ts: GoogleSheetsMock.post(string|RegExp, @test/132.ts: GoogleSheetsMock.%AM3(string, nock.Body))", "@test/132.ts: GoogleSheetsMock.%AM8$mockAPI(string, nock.Body)", "@test/132.ts: GoogleSheetsMock.put(string|RegExp, @test/132.ts: GoogleSheetsMock.%AM2(string, nock.Body))", "@test/132.ts: GoogleSheetsMock.%AM9$mockAPI(string)", "@test/132.ts: GoogleSheetsMock.%AM10$mockAPI(string)", "@test/132.ts: GoogleSheetsMock.%AM11$mockAPI(string, nock.Body)"], "@test/132.ts: GoogleSheetsMock.handleValueAppend(@test/132.ts: AppendRequest)": ["@test/132.ts: GoogleSheetsMock.parseA1Notation(string)", "@test/132.ts: GoogleSheetsMock.getSheetById(number)", "@test/132.ts: GoogleSheetsMock.%AM12$handleValueAppend(unknown)", "@test/132.ts: GoogleSheetsMock.createA1(Required<GridRange>)"], "@test/132.ts: GoogleSheetsMock.handleBatchUpdate(@test/132.ts: BatchUpdateRequest)": ["@test/132.ts: GoogleSheetsMock.handleDeleteRange(@test/132.ts: DeleteRangeRequest)", "@test/132.ts: GoogleSheetsMock.handleDeleteSheet(@test/132.ts: DeleteSheetRequest)"], "@test/132.ts: GoogleSheetsMock.handleAddSheet(@test/132.ts: AddSheetRequest)": ["@test/132.ts: GoogleSheetsMock.defaultWorksheetProperties(Partial<WorksheetProperties>)"], "@test/132.ts: GoogleSheetsMock.handleDeleteRange(@test/132.ts: DeleteRangeRequest)": ["@test/132.ts: GoogleSheetsMock.%AM13$handleDeleteRange(CellData)", "@test/132.ts: GoogleSheetsMock.iterateRange(GridRange, @test/132.ts: GoogleSheetsMock.%AM4(CellData))"], "@test/132.ts: GoogleSheetsMock.handleValueUpdate(@test/132.ts: ValueRange)": ["@test/132.ts: GoogleSheetsMock.%AM14$handleValueUpdate(CellData, Value)", "@test/132.ts: GoogleSheetsMock.iterateValueRange(@test/132.ts: ValueRange, @test/132.ts: GoogleSheetsMock.%AM5(CellData, Value))"], "@test/132.ts: GoogleSheetsMock.iterateRange(GridRange, @test/132.ts: GoogleSheetsMock.%AM4(CellData))": ["@test/132.ts: GoogleSheetsMock.ensureGridRange(GridRange)", "@test/132.ts: GoogleSheetsMock.getCellNumericIndexes(@test/132.ts: Sheet|number, number, number)"], "@test/132.ts: GoogleSheetsMock.iterateValueRange(@test/132.ts: ValueRange, @test/132.ts: GoogleSheetsMock.%AM5(CellData, Value))": ["@test/132.ts: GoogleSheetsMock.parseA1Notation(string)", "@test/132.ts: GoogleSheetsMock.getCellNumericIndexes(@test/132.ts: Sheet|number, number, number)"], "@test/132.ts: GoogleSheetsMock.getValueRange(string)": ["@test/132.ts: GoogleSheetsMock.parseA1Notation(string)", "@test/132.ts: GoogleSheetsMock.getCellNumericIndexes(@test/132.ts: Sheet|number, number, number)", "@test/132.ts: GoogleSheetsMock.cellValue(CellData)", "@test/132.ts: GoogleSheetsMock.trimValueRange(@test/132.ts: ValueRange)"], "@test/132.ts: GoogleSheetsMock.trimValueRange(@test/132.ts: ValueRange)": ["@test/132.ts: GoogleSheetsMock.%AM15$trimValueRange(unknown)"], "@test/132.ts: GoogleSheetsMock.cellValue(CellData)": ["@test/132.ts: GoogleSheetsMock.unwrapValue(ExtendedValue)"], "@test/132.ts: GoogleSheetsMock.createEmptyGrid(number, number)": ["@test/132.ts: GoogleSheetsMock.createCellData(Value)"], "@test/132.ts: GoogleSheetsMock.cellData(string)": ["@test/132.ts: GoogleSheetsMock.parseA1Notation(string)", "@test/132.ts: GoogleSheetsMock.getCellNumericIndexes(@test/132.ts: Sheet|number, number, number)"], "@test/132.ts: GoogleSheetsMock.getCellNumericIndexes(@test/132.ts: Sheet|number, number, number)": ["@test/132.ts: GoogleSheetsMock.getSheetById(number)"], "@test/132.ts: GoogleSheetsMock.parseA1Notation(string)": ["@test/132.ts: GoogleSheetsMock.getSheetByName(string)", "@test/132.ts: GoogleSheetsMock.ensureGridRange(GridRange)", "@test/132.ts: GoogleSheetsMock.parseCell(string)"], "@test/132.ts: GoogleSheetsMock.ensureGridRange(GridRange)": ["@test/132.ts: GoogleSheetsMock.getSheetById(number)"], "@test/132.ts: GoogleSheetsMock.createA1(Required<GridRange>)": ["@test/132.ts: GoogleSheetsMock.getSheetById(number)", "@test/132.ts: GoogleSheetsMock.numberToLetter(number)"], "@test/132.ts: GoogleSheetsMock.parseCell(string)": ["@test/132.ts: GoogleSheetsMock.isInteger(string)", "@test/132.ts: GoogleSheetsMock.letterToNumber(string)"], "@test/132.ts: GoogleSheetsMock.getSheetByName(string)": ["@test/132.ts: GoogleSheetsMock.%AM16$getSheetByName([name], unknown)"], "@test/132.ts: GoogleSheetsMock.getSheetById(number)": ["@test/132.ts: GoogleSheetsMock.%AM17$getSheetById([id], unknown)"], "@test/132.ts: GoogleSheetsMock.%AM6$mockAPI()": ["@test/132.ts: GoogleSheetsMock.handleGetSpreadsheet()"], "@test/132.ts: GoogleSheetsMock.%AM7$mockAPI(string, nock.Body)": ["@test/132.ts: GoogleSheetsMock.handleBatchUpdate(@test/132.ts: BatchUpdateRequest)"], "@test/132.ts: GoogleSheetsMock.%AM8$mockAPI(string, nock.Body)": ["@test/132.ts: GoogleSheetsMock.handleValueUpdate(@test/132.ts: ValueRange)"], "@test/132.ts: GoogleSheetsMock.%AM9$mockAPI(string)": ["@test/132.ts: GoogleSheetsMock.handleBatchGet(@test/132.ts: BatchGetParams)"], "@test/132.ts: GoogleSheetsMock.%AM10$mockAPI(string)": ["@test/132.ts: GoogleSheetsMock.getValueRange(string)"], "@test/132.ts: GoogleSheetsMock.%AM11$mockAPI(string, nock.Body)": ["@test/132.ts: GoogleSheetsMock.handleValueAppend(@test/132.ts: AppendRequest)"], "@test/132.ts: GoogleSheetsMock.%AM12$handleValueAppend(unknown)": ["@test/132.ts: GoogleSheetsMock.valuesToRowData(Value[])"], "@test/132.ts: GoogleSheetsMock.%AM13$handleDeleteRange(CellData)": ["@test/132.ts: GoogleSheetsMock.createValue(Value)"], "@test/132.ts: GoogleSheetsMock.%AM14$handleValueUpdate(CellData, Value)": ["@test/132.ts: GoogleSheetsMock.createValue(Value)"], "@test/132.ts: GoogleSheetsMock.[static]forDatasource(Datasource)": ["@test/132.ts: GoogleSheetsMock.constructor(GoogleSheetsConfig)"], "@test/132.ts: %AC$GoogleSheetsMock$handleBatchGet$30.%instInit()": ["@test/132.ts: %AC$GoogleSheetsMock$handleBatchGet$30.%AM0$%instInit(unknown)"], "@test/132.ts: %AC$GoogleSheetsMock$valuesToRowData$43.%instInit()": ["@test/132.ts: %AC$GoogleSheetsMock$valuesToRowData$43.%AM0$%instInit(unknown)"]}}
{"source_code": "import { BaseException, JsonObject, normalize, virtualFs } from '@angular-devkit/core';\nimport { NodeJsSyncHost } from '@angular-devkit/core/node';\nimport { existsSync, statSync } from 'fs';\nimport { dirname, isAbsolute, join, resolve } from 'path';\nimport { Observable, isObservable, lastValueFrom, from as observableFrom, throwError } from 'rxjs';\nimport { Url } from 'url';\nimport {\n  HostCreateTree,\n  RuleFactory,\n  Source,\n  TaskExecutor,\n  TaskExecutorFactory,\n  UnregisteredTaskException,\n} from '../src';\nimport {\n  FileSystemCollectionDesc,\n  FileSystemEngineHost,\n  FileSystemSchematicContext,\n  FileSystemSchematicDesc,\n  FileSystemSchematicDescription,\n} from './description';\nimport { readJsonFile } from './file-system-utility';\nexport declare type OptionTransform<T extends object | null, R extends object> = (\n  schematic: FileSystemSchematicDescription,\n  options: T,\n  context?: FileSystemSchematicContext,\n) => Observable<R> | PromiseLike<R> | R;\nexport declare type ContextTransform = (\n  context: FileSystemSchematicContext,\n) => FileSystemSchematicContext;\nexport class CollectionCannotBeResolvedException extends BaseException {\n  constructor(name: string) {\n    super(`Collection ${JSON.stringify(name)} cannot be resolved.`);\n  }\n}\nexport class InvalidCollectionJsonException extends BaseException {\n  constructor(_name: string, path: string, jsonException?: Error) {\n    let msg = `Collection JSON at path ${JSON.stringify(path)} is invalid.`;\n    if (jsonException) {\n      msg = `${msg} ${jsonException.message}`;\n    }\n    super(msg);\n  }\n}\nexport class SchematicMissingFactoryException extends BaseException {\n  constructor(name: string) {\n    super(`Schematic ${JSON.stringify(name)} is missing a factory.`);\n  }\n}\nexport class FactoryCannotBeResolvedException extends BaseException {\n  constructor(name: string) {\n    super(`Schematic ${JSON.stringify(name)} cannot resolve the factory.`);\n  }\n}\nexport class CollectionMissingSchematicsMapException extends BaseException {\n  constructor(name: string) {\n    super(`Collection \"${name}\" does not have a schematics map.`);\n  }\n}\nexport class CollectionMissingFieldsException extends BaseException {\n  constructor(name: string) {\n    super(`Collection \"${name}\" is missing fields.`);\n  }\n}\nexport class SchematicMissingFieldsException extends BaseException {\n  constructor(name: string) {\n    super(`Schematic \"${name}\" is missing fields.`);\n  }\n}\nexport class SchematicMissingDescriptionException extends BaseException {\n  constructor(name: string) {\n    super(`Schematics \"${name}\" does not have a description.`);\n  }\n}\nexport class SchematicNameCollisionException extends BaseException {\n  constructor(name: string) {\n    super(\n      `Schematics/alias ${JSON.stringify(name)} collides with another alias or schematic` +\n        ' name.',\n    );\n  }\n}\nexport abstract class FileSystemEngineHostBase implements FileSystemEngineHost {\n  protected abstract _resolveCollectionPath(name: string, requester?: string): string;\n  protected abstract _resolveReferenceString(\n    name: string,\n    parentPath: string,\n    collectionDescription: FileSystemCollectionDesc,\n  ): { ref: RuleFactory<{}>; path: string } | null;\n  protected abstract _transformCollectionDescription(\n    name: string,\n    desc: Partial<FileSystemCollectionDesc>,\n  ): FileSystemCollectionDesc;\n  protected abstract _transformSchematicDescription(\n    name: string,\n    collection: FileSystemCollectionDesc,\n    desc: Partial<FileSystemSchematicDesc>,\n  ): FileSystemSchematicDesc;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private _transforms: OptionTransform<any, any>[] = [];\n  private _contextTransforms: ContextTransform[] = [];\n  private _taskFactories = new Map<string, () => Observable<TaskExecutor>>();\n  listSchematicNames(collection: FileSystemCollectionDesc, includeHidden?: boolean) {\n    const schematics: string[] = [];\n    for (const key of Object.keys(collection.schematics)) {\n      const schematic = collection.schematics[key];\n      if ((schematic.hidden && !includeHidden) || schematic.private) {\n        continue;\n      }\n      // If extends is present without a factory it is an alias, do not return it\n      //   unless it is from another collection.\n      if (!schematic.extends || schematic.factory) {\n        schematics.push(key);\n      } else if (schematic.extends && schematic.extends.indexOf(':') !== -1) {\n        schematics.push(key);\n      }\n    }\n    return schematics;\n  }\n  registerOptionsTransform<T extends object | null, R extends object>(t: OptionTransform<T, R>) {\n    this._transforms.push(t);\n  }\n  registerContextTransform(t: ContextTransform) {\n    this._contextTransforms.push(t);\n  }\n  createCollectionDescription(\n    name: string,\n    requester?: FileSystemCollectionDesc,\n  ): FileSystemCollectionDesc {\n    const path = this._resolveCollectionPath(name, requester?.path);\n    const jsonValue = readJsonFile(path);\n    if (!jsonValue || typeof jsonValue != 'object' || Array.isArray(jsonValue)) {\n      throw new InvalidCollectionJsonException(name, path);\n    }\n    // normalize extends property to an array\n    if (typeof jsonValue['extends'] === 'string') {\n      jsonValue['extends'] = [jsonValue['extends']];\n    }\n    const description = this._transformCollectionDescription(name, {\n      ...jsonValue,\n      path,\n    });\n    if (!description || !description.name) {\n      throw new InvalidCollectionJsonException(name, path);\n    }\n    // Validate aliases.\n    const allNames = Object.keys(description.schematics);\n    for (const schematicName of Object.keys(description.schematics)) {\n      const aliases = description.schematics[schematicName].aliases || [];\n      for (const alias of aliases) {\n        if (allNames.indexOf(alias) != -1) {\n          throw new SchematicNameCollisionException(alias);\n        }\n      }\n      allNames.push(...aliases);\n    }\n    return description;\n  }\n  createSchematicDescription(\n    name: string,\n    collection: FileSystemCollectionDesc,\n  ): FileSystemSchematicDesc | null {\n    // Resolve aliases first.\n    for (const schematicName of Object.keys(collection.schematics)) {\n      const schematicDescription = collection.schematics[schematicName];\n      if (schematicDescription.aliases && schematicDescription.aliases.indexOf(name) != -1) {\n        name = schematicName;\n        break;\n      }\n    }\n    if (!(name in collection.schematics)) {\n      return null;\n    }\n    const collectionPath = dirname(collection.path);\n    const partialDesc: Partial<FileSystemSchematicDesc> | null = collection.schematics[name];\n    if (!partialDesc) {\n      return null;\n    }\n    if (partialDesc.extends) {\n      const index = partialDesc.extends.indexOf(':');\n      const collectionName = index !== -1 ? partialDesc.extends.slice(0, index) : null;\n      const schematicName =\n        index === -1 ? partialDesc.extends : partialDesc.extends.slice(index + 1);\n      if (collectionName !== null) {\n        const extendCollection = this.createCollectionDescription(collectionName);\n        return this.createSchematicDescription(schematicName, extendCollection);\n      } else {\n        return this.createSchematicDescription(schematicName, collection);\n      }\n    }\n    // Use any on this ref as we don't have the OptionT here, but we don't need it (we only need\n    // the path).\n    if (!partialDesc.factory) {\n      throw new SchematicMissingFactoryException(name);\n    }\n    const resolvedRef = this._resolveReferenceString(\n      partialDesc.factory,\n      collectionPath,\n      collection,\n    );\n    if (!resolvedRef) {\n      throw new FactoryCannotBeResolvedException(name);\n    }\n    let schema = partialDesc.schema;\n    let schemaJson: JsonObject | undefined = undefined;\n    if (schema) {\n      if (!isAbsolute(schema)) {\n        schema = join(collectionPath, schema);\n      }\n      schemaJson = readJsonFile(schema) as JsonObject;\n    }\n    // The schematic path is used to resolve URLs.\n    // We should be able to just do `dirname(resolvedRef.path)` but for compatibility with\n    // Bazel under Windows this directory needs to be resolved from the collection instead.\n    // This is needed because on Bazel under Windows the data files (such as the collection or\n    // url files) are not in the same place as the compiled JS.\n    const maybePath = join(collectionPath, partialDesc.factory);\n    const path =\n      existsSync(maybePath) && statSync(maybePath).isDirectory() ? maybePath : dirname(maybePath);\n    return this._transformSchematicDescription(name, collection, {\n      ...partialDesc,\n      schema,\n      schemaJson,\n      name,\n      path,\n      factoryFn: resolvedRef.ref,\n      collection,\n    });\n  }\n  createSourceFromUrl(url: Url): Source | null {\n    switch (url.protocol) {\n      case null:\n      case 'file:':\n        return (context) => {\n          // Check if context has necessary FileSystemSchematicContext path property\n          const fileDescription = context.schematic.description as { path?: string };\n          if (fileDescription.path === undefined) {\n            throw new Error(\n              'Unsupported schematic context. Expected a FileSystemSchematicContext.',\n            );\n          }\n          // Resolve all file:///a/b/c/d from the schematic's own path, and not the current\n          // path.\n          const root = normalize(resolve(fileDescription.path, url.path || ''));\n          return new HostCreateTree(new virtualFs.ScopedHost(new NodeJsSyncHost(), root));\n        };\n    }\n    return null;\n  }\n  transformOptions<OptionT extends object, ResultT extends object>(\n    schematic: FileSystemSchematicDesc,\n    options: OptionT,\n    context?: FileSystemSchematicContext,\n  ): Observable<ResultT> {\n    const transform = async () => {\n      let transformedOptions = options;\n      for (const transformer of this._transforms) {\n        const transformerResult = transformer(schematic, transformedOptions, context);\n        transformedOptions = await (isObservable(transformerResult)\n          ? lastValueFrom(transformerResult)\n          : transformerResult);\n      }\n      return transformedOptions;\n    };\n    return observableFrom(transform()) as unknown as Observable<ResultT>;\n  }\n  transformContext(context: FileSystemSchematicContext): FileSystemSchematicContext {\n    return this._contextTransforms.reduce((acc, curr) => curr(acc), context);\n  }\n  getSchematicRuleFactory<OptionT extends object>(\n    schematic: FileSystemSchematicDesc,\n    _collection: FileSystemCollectionDesc,\n  ): RuleFactory<OptionT> {\n    return schematic.factoryFn;\n  }\n  registerTaskExecutor<T>(factory: TaskExecutorFactory<T>, options?: T): void {\n    this._taskFactories.set(factory.name, () => observableFrom(factory.create(options)));\n  }\n  createTaskExecutor(name: string): Observable<TaskExecutor> {\n    const factory = this._taskFactories.get(name);\n    if (factory) {\n      return factory();\n    }\n    return throwError(new UnregisteredTaskException(name));\n  }\n  hasTaskExecutor(name: string): boolean {\n    return this._taskFactories.has(name);\n  }\n}", "llm_cg": {"FileSystemEngineHostBase.listSchematicNames(FileSystemEngineHostBase.collection, boolean)": [], "FileSystemEngineHostBase.registerOptionsTransform(%AMX$t)": [], "FileSystemEngineHostBase.registerContextTransform(%AMX$t)": [], "FileSystemEngineHostBase.createCollectionDescription(string, FileSystemEngineHostBase.collection)": ["FileSystemEngineHostBase.%AM0$_resolveCollectionPath(string, unknown)", "readJsonFile(string)", "FileSystemEngineHostBase.%AM1$_transformCollectionDescription(string, {} | {path}, unknown)", "FileSystemEngineHostBase.%AM2$InvalidCollectionJsonException(string, string)", "FileSystemEngineHostBase.%AM3$SchematicNameCollisionException(string)"], "FileSystemEngineHostBase.createSchematicDescription(string, FileSystemEngineHostBase.collection)": ["FileSystemEngineHostBase.createCollectionDescription(string)", "FileSystemEngineHostBase.%AM2$SchematicMissingFactoryException(string)", "FileSystemEngineHostBase.%AM3$FactoryCannotBeResolvedException(string)", "FileSystemEngineHostBase.%AM1$_resolveReferenceString(string, string, FileSystemEngineHostBase.collection, {})", "readJsonFile(string)", "FileSystemEngineHostBase.%AM0$_transformSchematicDescription(string, FileSystemEngineHostBase.collection, {} | {path, factory, {JSON}})"], "FileSystemEngineHostBase.createSourceFromUrl(Url)": ["normalize(string)", "resolve(string, string)", "FileSystemEngineHostBase.%AM4$HostCreateTree(%AM5$virtualFs.ScopedHost(new NodeJsSyncHost(), string))"], "FileSystemEngineHostBase.transformOptions(FileSystemEngineHostBase.schematic, object, FileSystemEngineHostBase.context)": ["FileSystemEngineHostBase.%AM0$lastValueFrom(result)", "observableFrom(Promise<result>)"], "FileSystemEngineHostBase.transformContext(FileSystemEngineHostBase.context)": [], "FileSystemEngineHostBase.getSchematicRuleFactory(FileSystemEngineHostBase.schematic, FileSystemEngineHostBase.collection)": [], "FileSystemEngineHostBase.registerTaskExecutor(TaskExecutorFactory, unknown)": ["observableFrom(Promise<factory.create(unknown))>"], "FileSystemEngineHostBase.createTaskExecutor(string)": [], "FileSystemEngineHostBase.hasTaskExecutor(string)": []}, "static_cg": {"@test/133.ts: FileSystemEngineHostBase.createCollectionDescription(string, FileSystemCollectionDesc)": ["@test/133.ts: InvalidCollectionJsonException.constructor(string, string, Error)", "@test/133.ts: SchematicNameCollisionException.constructor(string)"], "@test/133.ts: FileSystemEngineHostBase.createSchematicDescription(string, FileSystemCollectionDesc)": ["@test/133.ts: SchematicMissingFactoryException.constructor(string)", "@test/133.ts: FactoryCannotBeResolvedException.constructor(string)"], "@test/133.ts: FileSystemEngineHostBase.transformContext(FileSystemSchematicContext)": ["@test/133.ts: FileSystemEngineHostBase.%AM3$transformContext(unknown, unknown)"], "@test/133.ts: FileSystemEngineHostBase.registerTaskExecutor(TaskExecutorFactory<T>, T)": ["@test/133.ts: FileSystemEngineHostBase.%AM4$registerTaskExecutor([options, factory])"]}}
{"source_code": "import {DOCUMENT} from '@angular/common';\nimport {Component, destroyPlatform, inject} from '@angular/core';\nimport {bootstrapApplication} from '@angular/platform-browser';\nimport {withBody} from '@angular/private/testing';\nimport {\n  Event,\n  NavigationEnd,\n  provideRouter,\n  Router,\n  withDisabledInitialNavigation,\n  withViewTransitions,\n} from '@angular/router';\ndescribe('view transitions', () => {\n  if (isNode) {\n    it('are not available in node environment', () => {});\n    return;\n  }\n  beforeEach(destroyPlatform);\n  afterEach(destroyPlatform);\n  @Component({\n    selector: 'test-app',\n    standalone: true,\n    template: ``,\n  })\n  class App {}\n  beforeEach(withBody('<test-app></test-app>', () => {}));\n  it('should skip initial transition', async () => {\n    const appRef = await bootstrapApplication(App, {\n      providers: [\n        provideRouter(\n          [{path: '**', component: App}],\n          withDisabledInitialNavigation(),\n          withViewTransitions({skipInitialTransition: true}),\n        ),\n      ],\n    });\n    const doc = appRef.injector.get(DOCUMENT);\n    if (!doc.startViewTransition) {\n      return;\n    }\n    const viewTransitionSpy = spyOn(doc, 'startViewTransition').and.callThrough();\n    await appRef.injector.get(Router).navigateByUrl('/a');\n    expect(viewTransitionSpy).not.toHaveBeenCalled();\n    await appRef.injector.get(Router).navigateByUrl('/b');\n    expect(viewTransitionSpy).toHaveBeenCalled();\n  });\n  it('should have the correct event order when using view transitions', async () => {\n    @Component({\n      selector: 'component-b',\n      template: `b`,\n      standalone: true,\n    })\n    class ComponentB {}\n    const res = await bootstrapApplication(App, {\n      providers: [provideRouter([{path: 'b', component: ComponentB}], withViewTransitions())],\n    });\n    const router = res.injector.get(Router);\n    const eventLog = [] as Event[];\n    router.events.subscribe((e) => {\n      eventLog.push(e);\n    });\n    await router.navigateByUrl('/b');\n    expect(eventLog[eventLog.length - 1]).toBeInstanceOf(NavigationEnd);\n  });\n  describe('onViewTransitionCreated option', () => {\n    it('should not create a view transition if only the fragment changes', async () => {\n      @Component({\n        selector: 'test-app',\n        standalone: true,\n        template: `{{checks}}`,\n      })\n      class App {\n        checks = 0;\n        ngDoCheck() {\n          this.checks++;\n        }\n      }\n      const transitionSpy = jasmine.createSpy();\n      const appRef = await bootstrapApplication(App, {\n        providers: [\n          provideRouter(\n            [{path: '**', component: App}],\n            withDisabledInitialNavigation(),\n            withViewTransitions({onViewTransitionCreated: transitionSpy}),\n          ),\n        ],\n      });\n      const doc = appRef.injector.get(DOCUMENT);\n      if (!doc.startViewTransition) {\n        return;\n      }\n      await appRef.injector.get(Router).navigateByUrl('/a');\n      expect(transitionSpy).toHaveBeenCalled();\n    });\n  });\n});", "llm_cg": {"Anonymous_it_should_skip_initial_transition_AsyncFunction()": ["Anonymous_beforeEach_withBody_AsyncFunction()", "bootstrapApplication(Anonymous_Class_id0,unknown).then", "Anonymous_it_should_skip_initial_transition_AsyncFunction.maybe", "await.bootstrapApplication(Anonymous_Class_id0,unknown_injector.get(DOCUMENT)", "appRef.injector.get(Router).navigateByUrl('/a')", "expect(spyOn(doc,'startViewTransition')_not.toHaveBeenCalled())", "appRef.injector.get(Router).navigateByUrl('/b')", "expect(spyOn(doc,'startViewTransition')).toHaveBeenCalled()"], "Anonymous_it_should_have_the_correct_event_order_when_using_view_transitions_AsyncFunction()": ["Anonymous_beforeEach_withBody_AsyncFunction()", "ComponentB", "bootstrapApplication(Anonymous_Class_id0,unknown).then", "const router.res.injector.get(Router)", "router.events.subscribe(Anonymous_Function())", "await.router.navigateByUrl('/b')", "expect(eventLog[eventLog.length-1]).toBeInstanceOf(NavigationEnd)"], "Anonymous_it_should_not_create_a_view_transition_if_only_the_fragment_changes_AsyncFunction()": ["Anonymous_Class_id1()", "bootstrapApplication(Anonymous_Class_id1,unknown).then", "await.bootstrapApplication(Anonymous_Class_id1_injector.get(DOCUMENT)", "appRef.injector.get(Router).navigateByUrl('/a')", "expect(jasmine.createSpy()).toHaveBeenCalled()"]}, "static_cg": {"@test/134.ts: %dflt.[static]%dflt()": ["@test/134.ts: %dflt.%AM0()"], "@test/134.ts: %dflt.%AM4$%AM0()": ["@test/134.ts: %dflt.%AM5$%AM4$%AM0(unknown)"], "@test/134.ts: %dflt.%AM6$%AM0()": ["@test/134.ts: %dflt.%AM7$%AM6$%AM0()"], "@test/134.ts: %dflt.%AM0()": ["@test/134.ts: %dflt.%AM1$%AM0()", "@test/134.ts: %dflt.%AM2$%AM0()", "@test/134.ts: %dflt.%AM3$%AM0()", "@test/134.ts: %dflt.%AM4$%AM0()", "@test/134.ts: %dflt.%AM6$%AM0()"]}}
{"source_code": "import { e2e } from '../utils';\nconst PAGE_UNDER_TEST = 'kVi2Gex7z/test-variable-output';\nconst DASHBOARD_NAME = 'Test variable output';\nfunction fillInCustomVariable(name: string, label: string, value: string) {\n  e2e.pages.Dashboard.Settings.Variables.Edit.General.generalTypeSelectV2().within(() => {\n    cy.get('input').type('Custom{enter}');\n  });\n  e2e.pages.Dashboard.Settings.Variables.Edit.General.generalNameInputV2().clear().type(name).blur();\n  e2e.pages.Dashboard.Settings.Variables.Edit.General.generalLabelInputV2().type(label).blur();\n  e2e.pages.Dashboard.Settings.Variables.Edit.CustomVariable.customValueInput().type(value).blur();\n}\nfunction assertPreviewValues(expectedValues: string[]) {\n  for (const expected of expectedValues) {\n    const index = expectedValues.indexOf(expected);\n    e2e.pages.Dashboard.Settings.Variables.Edit.General.previewOfValuesOption().eq(index).should('have.text', expected);\n  }\n}\ndescribe('Variables - Custom', () => {\n  beforeEach(() => {\n    e2e.flows.login(Cypress.env('USERNAME'), Cypress.env('PASSWORD'));\n  });\n  it('can add a custom template variable', () => {\n    e2e.flows.openDashboard({ uid: `${PAGE_UNDER_TEST}?orgId=1&editview=templating` });\n    cy.contains(DASHBOARD_NAME).should('be.visible');\n    // Create a new \"Custom\" variable\n    e2e.components.CallToActionCard.buttonV2('Add variable').click();\n    fillInCustomVariable('VariableUnderTest', 'Variable under test', 'one,two,three');\n    assertPreviewValues(['one', 'two', 'three']);\n    // Navigate back to the homepage and change the selected variable value\n    e2e.pages.Dashboard.Settings.Variables.Edit.General.submitButton().click();\n    e2e.pages.Dashboard.Settings.Actions.close().click();\n    e2e.pages.Dashboard.SubMenu.submenuItemValueDropDownValueLinkTexts('one').click();\n    e2e.pages.Dashboard.SubMenu.submenuItemValueDropDownOptionTexts('two').click();\n    // Assert it was rendered\n    cy.get('.markdown-html').should('include.text', 'VariableUnderTest: two');\n  });\n  it('can add a custom template variable with labels', () => {\n    e2e.flows.openDashboard({ uid: `${PAGE_UNDER_TEST}?orgId=1&editview=templating` });\n    cy.contains(DASHBOARD_NAME).should('be.visible');\n    // Create a new \"Custom\" variable\n    e2e.components.CallToActionCard.buttonV2('Add variable').click();\n    e2e.pages.Dashboard.Settings.Variables.Edit.General.generalTypeSelectV2().within(() => {\n      cy.get('input').type('Custom{enter}');\n    });\n    // Set its name, label, and content\n    fillInCustomVariable('VariableUnderTest', 'Variable under test', 'One : 1,Two : 2, Three : 3');\n    assertPreviewValues(['One', 'Two', 'Three']);\n    // Navigate back to the homepage and change the selected variable value\n    e2e.pages.Dashboard.Settings.Variables.Edit.General.submitButton().click();\n    e2e.pages.Dashboard.Settings.Actions.close().click();\n    e2e.pages.Dashboard.SubMenu.submenuItemValueDropDownValueLinkTexts('One').click();\n    e2e.pages.Dashboard.SubMenu.submenuItemValueDropDownOptionTexts('Two').click();\n    // Assert it was rendered\n    cy.get('.markdown-html').should('include.text', 'VariableUnderTest: 2');\n  });\n});", "llm_cg": {"fillInCustomVariable(name: string, label: string, value: string)": [], "assertPreviewValues(expectedValues: string[])": [], "%AM0$beforeEach()": ["e2e.flows.login(username: string, password: string)"], "%AM1$it()": ["e2e.flows.openDashboard(params: object)", "%AM0$fillInCustomVariable(name: string, label: string, value: string)", "%AM0$assertPreviewValues(expectedValues: string[])", "e2e.components.CallToActionCard.buttonV2(label: string).click()", "e2e.pages.Dashboard.Settings.Variables.Edit.General.submitButton().click()", "e2e.pages.Dashboard.Settings.Actions.close().click()", "e2e.pages.Dashboard.SubMenu.submenuItemValueDropDownValueLinkTexts(label: string).click()", "e2e.pages.Dashboard.SubMenu.submenuItemValueDropDownOptionTexts(label: string).click()"], "%AM2$it()": ["e2e.flows.openDashboard(params: object)", "%AM0$fillInCustomVariable(name: string, label: string, value: string)", "%AM0$assertPreviewValues(expectedValues: string[])", "e2e.components.CallToActionCard.buttonV2(label: string).click()", "e2e.pages.Dashboard.Settings.Variables.Edit.General.generalTypeSelectV2().within(callback: function).cy.get(selector: string).type(text: string)", "e2e.pages.Dashboard.Settings.Variables.Edit.General.submitButton().click()", "e2e.pages.Dashboard.Settings.Actions.close().click()", "e2e.pages.Dashboard.SubMenu.submenuItemValueDropDownValueLinkTexts(label: string).click()", "e2e.pages.Dashboard.SubMenu.submenuItemValueDropDownOptionTexts(label: string).click()"], "%AM0$_describe()": ["%AM0$beforeEach()", "%AM1$it()", "%AM2$it()"]}, "static_cg": {"@test/135.ts: %dflt.[static]%dflt()": ["@test/135.ts: %dflt.%AM0()"], "@test/135.ts: %dflt.fillInCustomVariable(string, string, string)": ["@test/135.ts: %dflt.%AM5$fillInCustomVariable()"], "@test/135.ts: %dflt.%AM2$%AM0()": ["@test/135.ts: %dflt.fillInCustomVariable(string, string, string)", "@test/135.ts: %dflt.assertPreviewValues(string[])"], "@test/135.ts: %dflt.%AM3$%AM0()": ["@test/135.ts: %dflt.%AM4$%AM3$%AM0()", "@test/135.ts: %dflt.fillInCustomVariable(string, string, string)", "@test/135.ts: %dflt.assertPreviewValues(string[])"], "@test/135.ts: %dflt.%AM0()": ["@test/135.ts: %dflt.%AM1$%AM0()", "@test/135.ts: %dflt.%AM2$%AM0()", "@test/135.ts: %dflt.%AM3$%AM0()"]}}
{"source_code": "import type { NormalizedWebpackExecutorOptions } from '../../webpack/schema';\nexport function buildServePath(\n  browserOptions: NormalizedWebpackExecutorOptions\n) {\n  let servePath =\n    _findDefaultServePath(browserOptions.baseHref, browserOptions.deployUrl) ||\n    '/';\n  if (servePath.endsWith('/')) {\n    servePath = servePath.slice(0, -1);\n  }\n  if (!servePath.startsWith('/')) {\n    servePath = `/${servePath}`;\n  }\n  return servePath;\n}\nexport function _findDefaultServePath(\n  baseHref?: string,\n  deployUrl?: string\n): string | null {\n  if (!baseHref && !deployUrl) {\n    return '';\n  }\n  if (\n    /^(\\w+:)?\\/\\//.test(baseHref || '') ||\n    /^(\\w+:)?\\/\\//.test(deployUrl || '')\n  ) {\n    // If baseHref or deployUrl is absolute, unsupported by nx serve\n    return null;\n  }\n  // normalize baseHref\n  // for nx serve the starting base is always `/` so a relative\n  // and root relative value are identical\n  const baseHrefParts = (baseHref || '')\n    .split('/')\n    .filter((part) => part !== '');\n  if (baseHref && !baseHref.endsWith('/')) {\n    baseHrefParts.pop();\n  }\n  const normalizedBaseHref =\n    baseHrefParts.length === 0 ? '/' : `/${baseHrefParts.join('/')}/`;\n  if (deployUrl && deployUrl[0] === '/') {\n    if (baseHref && baseHref[0] === '/' && normalizedBaseHref !== deployUrl) {\n      // If baseHref and deployUrl are root relative and not equivalent, unsupported by nx serve\n      return null;\n    }\n    return deployUrl;\n  }\n  // Join together baseHref and deployUrl\n  return `${normalizedBaseHref}${deployUrl || ''}`;\n}", "llm_cg": {"buildServePath(NormalizedWebpackExecutorOptions)": ["buildServePath.%AM0$_findDefaultServePath(string, string)"]}, "static_cg": {"@test/136.ts: %dflt.buildServePath(NormalizedWebpackExecutorOptions)": ["@test/136.ts: %dflt._findDefaultServePath(string, string)"], "@test/136.ts: %dflt._findDefaultServePath(string, string)": ["@test/136.ts: %dflt.%AM0$_findDefaultServePath(unknown)"]}}
{"source_code": "import { createDirectory } from '@nx/workspace/src/utilities/fileutils';\nimport { names, ExecutorContext } from '@nx/devkit';\nimport { dirname, join, resolve as pathResolve } from 'path';\nimport { ChildProcess, fork } from 'child_process';\nimport { ReactNativeBundleOptions } from './schema';\nexport interface ReactNativeBundleOutput {\n  success: boolean;\n}\nexport default async function* bundleExecutor(\n  options: ReactNativeBundleOptions,\n  context: ExecutorContext\n): AsyncGenerator<ReactNativeBundleOutput> {\n  const projectRoot =\n    context.projectsConfigurations.projects[context.projectName].root;\n  options.bundleOutput = join(context.root, options.bundleOutput);\n  createDirectory(dirname(options.bundleOutput));\n  await runCliBuild(context.root, projectRoot, options);\n  yield { success: true };\n}\nfunction runCliBuild(\n  workspaceRoot: string,\n  projectRoot: string,\n  options: ReactNativeBundleOptions\n): Promise<ChildProcess> {\n  return new Promise<ChildProcess>((resolve, reject) => {\n    const cliOptions = createBundleOptions(options);\n    const childProcess = fork(\n      require.resolve('react-native/cli.js'),\n      ['bundle', ...cliOptions],\n      {\n        stdio: 'inherit',\n        cwd: pathResolve(workspaceRoot, projectRoot),\n        env: process.env,\n      }\n    );\n    const processExitListener = (signal?: number | NodeJS.Signals) => () => {\n      childProcess.kill(signal);\n      process.exit();\n    };\n    process.once('exit', (signal) => childProcess.kill(signal));\n    process.once('SIGTERM', processExitListener);\n    process.once('SIGINT', processExitListener);\n    process.once('SIGQUIT', processExitListener);\n    childProcess.on('error', (err) => {\n      reject(err);\n    });\n    childProcess.on('exit', (code) => {\n      if (code === 0) {\n        resolve(childProcess);\n      } else {\n        reject(code);\n      }\n    });\n  });\n}\nfunction createBundleOptions(options: ReactNativeBundleOptions) {\n  return Object.keys(options).reduce((acc, _k) => {\n    const v = options[_k];\n    const k = names(_k).fileName;\n    if (v === undefined) return acc;\n    acc.push(`--${k}`, v);\n    return acc;\n  }, []);\n}", "llm_cg": {"bundleExecutor(options.ExecutorContext)": ["bundleExecutor.%AM0$join(string, string)", "bundleExecutor.%AM0$dirname(string)", "bundleExecutor.%AM1$createDirectory(string)", "bundleExecutor.%AM0$runCliBuild(string, string, options)", "bundleExecutor.%AM0$yield({ success: boolean })"], "bundleExecutor.%AM0$runCliBuild(string, string, options)": ["bundleExecutor.%AM1$createBundleOptions(options)", "bundleExecutor.%AM1$fork(string, string[], { stdio: string, cwd: string, env: process.env })", "bundleExecutor.%AM0$process.once('exit', (signal) => childProcess.kill(signal))", "bundleExecutor.%AM0$process.once('SIGTERM', () => childProcess.kill(signal); process.exit())", "bundleExecutor.%AM0$process.once('SIGINT', () => childProcess.kill(signal); process.exit())", "bundleExecutor.%AM0$process.once('SIGQUIT', () => childProcess.kill(signal); process.exit())", "bundleExecutor.%AM0$childProcess.on('error', (err) => reject(err))", "bundleExecutor.%AM0$childProcess.on('exit', (code) => { if (code === 0) { resolve(childProcess); } else { reject(code); } })"], "bundleExecutor.%AM1$createBundleOptions(options)": ["bundleExecutor.%AM1$names(string)"]}, "static_cg": {"@test/137.ts: %dflt.bundleExecutor(ReactNativeBundleOptions, ExecutorContext)": ["@test/137.ts: %dflt.runCliBuild(string, string, ReactNativeBundleOptions)"], "@test/137.ts: %dflt.runCliBuild(string, string, ReactNativeBundleOptions)": ["@test/137.ts: %dflt.%AM0$runCliBuild([options], unknown, unknown)"], "@test/137.ts: %dflt.createBundleOptions(ReactNativeBundleOptions)": ["@test/137.ts: %dflt.%AM6$createBundleOptions([options], unknown, unknown)"], "@test/137.ts: %dflt.%AM0$runCliBuild([options], unknown, unknown)": ["@test/137.ts: %dflt.createBundleOptions(ReactNativeBundleOptions)", "@test/137.ts: %dflt.%AM3$%AM0$runCliBuild(unknown)", "@test/137.ts: %dflt.%AM1$%AM0$runCliBuild(number|NodeJS.Signals)", "@test/137.ts: %dflt.%AM4$%AM0$runCliBuild(unknown)", "@test/137.ts: %dflt.%AM5$%AM0$runCliBuild(unknown)"]}}
{"source_code": "import {FocusMonitor} from '@angular/cdk/a11y';\nimport {DOCUMENT} from '@angular/common';\nimport {DestroyRef, ElementRef, Injectable, inject, signal} from '@angular/core';\nimport {takeUntilDestroyed} from '@angular/core/rxjs-interop';\nimport {fromEvent, combineLatest} from 'rxjs';\nimport {map, filter, finalize} from 'rxjs/operators';\ninterface ResizingData {\n  isProgress: boolean;\n  initialContentContainerWidthInPercentage: number;\n  initialDividerPosition: number;\n  initialEditorContainerWidthInPercentage: number;\n}\ninterface MouseEventAndEditor {\n  event: MouseEvent;\n  editor: ElementRef<HTMLDivElement>;\n}\nconst MIN_WIDTH_OF_CONTENT_IN_PX = 300;\nconst MAX_WIDTH_OF_CONTENT_IN_PX = 800;\n@Injectable()\nexport class SplitResizerHandler {\n  private readonly destroyRef = inject(DestroyRef);\n  private readonly document = inject(DOCUMENT);\n  private readonly focusMonitor = inject(FocusMonitor);\n  private container!: ElementRef<any>;\n  private content!: ElementRef<HTMLDivElement>;\n  private editor: ElementRef<HTMLDivElement> | undefined;\n  private resizer!: ElementRef<HTMLDivElement>;\n  private readonly resizeData = signal<ResizingData>({\n    initialContentContainerWidthInPercentage: 0,\n    initialDividerPosition: 0,\n    initialEditorContainerWidthInPercentage: 0,\n    isProgress: false,\n  });\n  init(\n    container: ElementRef<unknown>,\n    content: ElementRef<HTMLDivElement>,\n    resizer: ElementRef<HTMLDivElement>,\n    editor?: ElementRef<HTMLDivElement>,\n  ): void {\n    this.container = container;\n    this.content = content;\n    this.resizer = resizer;\n    this.editor = editor;\n    this.listenToResizeStart();\n    this.listenToResize();\n    this.listenToResizeEnd();\n    this.resizeContainersUsingKeyArrows();\n  }\n  private listenToResizeStart(): void {\n    fromEvent<MouseEvent>(this.resizer.nativeElement, 'mousedown')\n      .pipe(\n        map((event) => ({editor: this.editor, event})),\n        filter(\n          (eventAndEditor): eventAndEditor is MouseEventAndEditor =>\n            !!eventAndEditor.editor?.nativeElement,\n        ),\n        takeUntilDestroyed(this.destroyRef),\n      )\n      .subscribe(({event}) => {\n        const contentWidthInPercentage = this.getCurrentContainerWidth(this.content.nativeElement);\n        const editorWidthInPercentage = this.getCurrentContainerWidth(this.editor!.nativeElement);\n        this.content.nativeElement.style.minWidth = `${MIN_WIDTH_OF_CONTENT_IN_PX}px`;\n        this.resizeData.update((data) => {\n          data.initialDividerPosition = event.pageX;\n          data.isProgress = true;\n          data.initialContentContainerWidthInPercentage = contentWidthInPercentage;\n          data.initialEditorContainerWidthInPercentage = editorWidthInPercentage;\n          return {...data};\n        });\n      });\n  }\n  private listenToResize(): void {\n    fromEvent<MouseEvent>(this.document, 'mousemove')\n      .pipe(\n        map((event) => ({editor: this.editor, event})),\n        filter(\n          (eventAndEditor): eventAndEditor is MouseEventAndEditor =>\n            !!eventAndEditor.editor?.nativeElement,\n        ),\n        takeUntilDestroyed(this.destroyRef),\n      )\n      .subscribe(({event}) => {\n        if (this.resizeData().isProgress) {\n          const newDividerPosition = event.pageX;\n          const containerWidth = this.getParentContainerWidth();\n          const shift =\n            ((newDividerPosition - this.resizeData().initialDividerPosition) / containerWidth) *\n            100;\n          const newContentWidthInPercentage =\n            this.resizeData().initialContentContainerWidthInPercentage + shift;\n          const newEditorWidthInPercentage =\n            this.resizeData().initialEditorContainerWidthInPercentage - shift;\n          this.setWidthOfTheContainers(newContentWidthInPercentage, newEditorWidthInPercentage);\n        }\n      });\n  }\n  private listenToResizeEnd(): void {\n    fromEvent(this.document, 'mouseup')\n      .pipe(takeUntilDestroyed(this.destroyRef))\n      .subscribe(() => {\n        if (this.resizeData().isProgress) {\n          this.content.nativeElement.style.minWidth = `${MIN_WIDTH_OF_CONTENT_IN_PX}px`;\n          this.resizeData.update((data) => {\n            data.isProgress = false;\n            data.initialDividerPosition = 0;\n            data.initialContentContainerWidthInPercentage = 0;\n            data.initialEditorContainerWidthInPercentage = 0;\n            return {...data};\n          });\n        }\n      });\n  }\n  // When resizer bar is focused, resize containers when user presses key arrows.\n  private resizeContainersUsingKeyArrows(): void {\n    combineLatest([\n      this.focusMonitor.monitor(this.resizer),\n      fromEvent<KeyboardEvent>(this.document, 'keydown'),\n    ])\n      .pipe(\n        filter(\n          ([origin, keyEvent]) =>\n            !!origin && (keyEvent.key === 'ArrowLeft' || keyEvent.key === 'ArrowRight'),\n        ),\n        takeUntilDestroyed(this.destroyRef),\n        finalize(() => this.focusMonitor.stopMonitoring(this.resizer)),\n      )\n      .subscribe(([_, keyEvent]) => {\n        const shift = keyEvent.key === 'ArrowLeft' ? -1 : 1;\n        const contentWidth = this.getCurrentContainerWidth(this.content.nativeElement);\n        const editorWidth = this.getCurrentContainerWidth(this.editor!.nativeElement);\n        this.setWidthOfTheContainers(contentWidth + shift, editorWidth - shift);\n      });\n  }\n  private setWidthOfTheContainers(\n    newContentWidthInPercentage: number,\n    newEditorWidthInPercentage: number,\n  ) {\n    const containerWidth = this.container.nativeElement.offsetWidth;\n    const newContentWidthInPx = (containerWidth * newContentWidthInPercentage) / 100;\n    if (\n      newContentWidthInPx > MIN_WIDTH_OF_CONTENT_IN_PX &&\n      newContentWidthInPx < MAX_WIDTH_OF_CONTENT_IN_PX &&\n      this.editor\n    ) {\n      this.content.nativeElement.style.width = `${newContentWidthInPercentage}%`;\n      this.editor.nativeElement.style.width = `${newEditorWidthInPercentage}%`;\n    }\n  }\n  private getCurrentContainerWidth(element: HTMLDivElement): number {\n    const savedWidth = Number(element.style.width.replace('%', ''));\n    return savedWidth > 0\n      ? savedWidth\n      : (element.offsetWidth / this.getParentContainerWidth()) * 100;\n  }\n  private getParentContainerWidth(): number {\n    return (\n      this.resizer.nativeElement.offsetWidth +\n      this.content.nativeElement.offsetWidth +\n      this.editor!.nativeElement.offsetWidth\n    );\n  }\n}", "llm_cg": {"SplitResizerHandler.init(ElementRef<unknown>, ElementRef<HTMLDivElement>, ElementRef<HTMLDivElement>, ElementRef<HTMLDivElement>)": ["SplitResizerHandler.listenToResizeStart()", "SplitResizerHandler.listenToResize()", "SplitResizerHandler.listenToResizeEnd()", "SplitResizerHandler.resizeContainersUsingKeyArrows()"], "SplitResizerHandler.listenToResizeStart()": ["SplitResizerHandler.getCurrentContainerWidth(HTMLDivElement)", "ResizingData.update(function)"], "SplitResizerHandler.listenToResize()": ["ResizingData.isProgress()", "SplitResizerHandler.getParentContainerWidth()", "SplitResizerHandler.setWidthOfTheContainers(number, number)"], "SplitResizerHandler.listenToResizeEnd()": ["ResizingData.isProgress()", "ResizingData.update(function)"], "SplitResizerHandler.resizeContainersUsingKeyArrows()": ["SplitResizerHandler.getCurrentContainerWidth(HTMLDivElement)", "SplitResizerHandler.getCurrentContainerWidth(HTMLDivElement)", "SplitResizerHandler.setWidthOfTheContainers(number, number)"], "SplitResizerHandler.setWidthOfTheContainers(number, number)": [], "SplitResizerHandler.getCurrentContainerWidth(HTMLDivElement)": ["SplitResizerHandler.getParentContainerWidth()"], "SplitResizerHandler.getParentContainerWidth()": []}, "static_cg": {"@test/138.ts: SplitResizerHandler.init(ElementRef<UnknownKeyword>, ElementRef<HTMLDivElement>, ElementRef<HTMLDivElement>, ElementRef<HTMLDivElement>)": ["@test/138.ts: SplitResizerHandler.listenToResizeStart()", "@test/138.ts: SplitResizerHandler.listenToResize()", "@test/138.ts: SplitResizerHandler.listenToResizeEnd()", "@test/138.ts: SplitResizerHandler.resizeContainersUsingKeyArrows()"], "@test/138.ts: SplitResizerHandler.listenToResizeStart()": ["@test/138.ts: SplitResizerHandler.%AM2$listenToResizeStart(unknown)", "@test/138.ts: SplitResizerHandler.%AM3$listenToResizeStart(unknown)", "@test/138.ts: SplitResizerHandler.%AM0$listenToResizeStart(unknown)"], "@test/138.ts: SplitResizerHandler.listenToResize()": ["@test/138.ts: SplitResizerHandler.%AM5$listenToResize(unknown)", "@test/138.ts: SplitResizerHandler.%AM6$listenToResize(unknown)", "@test/138.ts: SplitResizerHandler.%AM4$listenToResize(unknown)"], "@test/138.ts: SplitResizerHandler.listenToResizeEnd()": ["@test/138.ts: SplitResizerHandler.%AM7$listenToResizeEnd()"], "@test/138.ts: SplitResizerHandler.resizeContainersUsingKeyArrows()": ["@test/138.ts: SplitResizerHandler.%AM10$resizeContainersUsingKeyArrows(unknown)", "@test/138.ts: SplitResizerHandler.%AM11$resizeContainersUsingKeyArrows()", "@test/138.ts: SplitResizerHandler.%AM9$resizeContainersUsingKeyArrows(unknown)"], "@test/138.ts: SplitResizerHandler.getCurrentContainerWidth(HTMLDivElement)": ["@test/138.ts: SplitResizerHandler.getParentContainerWidth()"], "@test/138.ts: SplitResizerHandler.%AM0$listenToResizeStart(unknown)": ["@test/138.ts: SplitResizerHandler.getCurrentContainerWidth(HTMLDivElement)", "@test/138.ts: SplitResizerHandler.%AM1$%AM0$listenToResizeStart(unknown)"], "@test/138.ts: SplitResizerHandler.%AM4$listenToResize(unknown)": ["@test/138.ts: SplitResizerHandler.getParentContainerWidth()", "@test/138.ts: SplitResizerHandler.setWidthOfTheContainers(number, number)"], "@test/138.ts: SplitResizerHandler.%AM7$listenToResizeEnd()": ["@test/138.ts: SplitResizerHandler.%AM8$%AM7$listenToResizeEnd(unknown)"], "@test/138.ts: SplitResizerHandler.%AM9$resizeContainersUsingKeyArrows(unknown)": ["@test/138.ts: SplitResizerHandler.getCurrentContainerWidth(HTMLDivElement)", "@test/138.ts: SplitResizerHandler.setWidthOfTheContainers(number, number)"]}}
{"source_code": "import {FocusMonitor} from '@angular/cdk/a11y';\nimport {Direction, Directionality} from '@angular/cdk/bidi';\nimport {ESCAPE} from '@angular/cdk/keycodes';\nimport {CdkScrollable, OverlayContainer, OverlayModule} from '@angular/cdk/overlay';\nimport {Platform} from '@angular/cdk/platform';\nimport {\n  createFakeEvent,\n  createKeyboardEvent,\n  createMouseEvent,\n  dispatchEvent,\n  dispatchFakeEvent,\n  dispatchKeyboardEvent,\n  dispatchMouseEvent,\n  patchElementFocus,\n} from '@angular/cdk/testing/private';\nimport {\n  ChangeDetectionStrategy,\n  Component,\n  DebugElement,\n  ElementRef,\n  ViewChild,\n} from '@angular/core';\nimport {\n  ComponentFixture,\n  TestBed,\n  fakeAsync,\n  flush,\n  inject,\n  tick,\n  waitForAsync,\n} from '@angular/core/testing';\nimport {By} from '@angular/platform-browser';\nimport {NoopAnimationsModule} from '@angular/platform-browser/animations';\nimport {Subject} from 'rxjs';\nimport {\n  MAT_TOOLTIP_DEFAULT_OPTIONS,\n  MatTooltip,\n  MatTooltipModule,\n  SCROLL_THROTTLE_MS,\n  TooltipPosition,\n  TooltipTouchGestures,\n} from './index';\nconst initialTooltipMessage = 'initial tooltip message';\ndescribe('MatTooltip', () => {\n  let overlayContainerElement: HTMLElement;\n  let dir: {value: Direction; change: Subject<Direction>};\n  let platform: Platform;\n  let focusMonitor: FocusMonitor;\n  beforeEach(waitForAsync(() => {\n    TestBed.configureTestingModule({\n      imports: [\n        MatTooltipModule,\n        OverlayModule,\n        BasicTooltipDemo,\n        ScrollableTooltipDemo,\n        OnPushTooltipDemo,\n        DynamicTooltipsDemo,\n        TooltipOnTextFields,\n        TooltipOnDraggableElement,\n        DataBoundAriaLabelTooltip,\n      ],\n      providers: [\n        {\n          provide: Directionality,\n          useFactory: () => {\n            return (dir = {value: 'ltr', change: new Subject()});\n          },\n        },\n      ],\n    });\n    inject(\n      [OverlayContainer, FocusMonitor, Platform],\n      (oc: OverlayContainer, fm: FocusMonitor, pl: Platform) => {\n        overlayContainerElement = oc.getContainerElement();\n        focusMonitor = fm;\n        platform = pl;\n      },\n    )();\n  }));\n  describe('basic usage', () => {\n    let fixture: ComponentFixture<BasicTooltipDemo>;\n    let buttonDebugElement: DebugElement;\n    let buttonElement: HTMLButtonElement;\n    let tooltipDirective: MatTooltip;\n    beforeEach(fakeAsync(() => {\n      fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      tick();\n      buttonDebugElement = fixture.debugElement.query(By.css('button'))!;\n      buttonElement = buttonDebugElement.nativeElement;\n      tooltipDirective = buttonDebugElement.injector.get<MatTooltip>(MatTooltip);\n    }));\n    it('should show and hide the tooltip', fakeAsync(() => {\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.show();\n      tick(0); // Tick for the show delay (default is 0)\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      fixture.detectChanges();\n      // Wait until animation has finished\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      // Make sure tooltip is shown to the user and animation has finished.\n      const tooltipElement = overlayContainerElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;\n      expect(tooltipElement instanceof HTMLElement).toBe(true);\n      expect(tooltipElement.classList).toContain('mat-mdc-tooltip-show');\n      expect(overlayContainerElement.textContent).toContain(initialTooltipMessage);\n      // After hide is called, a timeout delay is created that will to hide the tooltip.\n      const tooltipDelay = 1000;\n      tooltipDirective.hide(tooltipDelay);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      // After the tooltip delay elapses, expect that the tooltip is not visible.\n      tick(tooltipDelay);\n      fixture.detectChanges();\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      // On animation complete, should expect that the tooltip has been detached.\n      finishCurrentTooltipAnimation(overlayContainerElement, false);\n      assertTooltipInstance(tooltipDirective, false);\n      flush();\n    }));\n    it('should be able to re-open a tooltip if it was closed by detaching the overlay', fakeAsync(() => {\n      tooltipDirective.show();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      tooltipDirective._overlayRef!.detach();\n      tick(0);\n      fixture.detectChanges();\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.show();\n      tick(0);\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      flush();\n    }));\n    it('should show with delay', fakeAsync(() => {\n      assertTooltipInstance(tooltipDirective, false);\n      const tooltipDelay = 1000;\n      tooltipDirective.show(tooltipDelay);\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      fixture.detectChanges();\n      expect(overlayContainerElement.textContent).toContain('');\n      tick(tooltipDelay);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      expect(overlayContainerElement.textContent).toContain(initialTooltipMessage);\n    }));\n    it('should be able to override the default show and hide delays', fakeAsync(() => {\n      TestBed.resetTestingModule().configureTestingModule({\n        imports: [MatTooltipModule, OverlayModule, BasicTooltipDemo],\n        providers: [\n          {\n            provide: MAT_TOOLTIP_DEFAULT_OPTIONS,\n            useValue: {showDelay: 1337, hideDelay: 7331},\n          },\n        ],\n      });\n      fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      tooltipDirective = fixture.debugElement\n        .query(By.css('button'))!\n        .injector.get<MatTooltip>(MatTooltip);\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick();\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      tick(1337);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      tooltipDirective.hide();\n      fixture.detectChanges();\n      tick();\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      tick(7331);\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      flush();\n    }));\n    it('should be able to override the default position', fakeAsync(() => {\n      TestBed.resetTestingModule().configureTestingModule({\n        imports: [MatTooltipModule, OverlayModule],\n        declarations: [TooltipDemoWithoutPositionBinding],\n        providers: [\n          {\n            provide: MAT_TOOLTIP_DEFAULT_OPTIONS,\n            useValue: {position: 'right'},\n          },\n        ],\n      });\n      const newFixture = TestBed.createComponent(TooltipDemoWithoutPositionBinding);\n      newFixture.detectChanges();\n      tooltipDirective = newFixture.debugElement\n        .query(By.css('button'))!\n        .injector.get<MatTooltip>(MatTooltip);\n      tooltipDirective.show();\n      newFixture.detectChanges();\n      tick();\n      expect(tooltipDirective.position).toBe('right');\n      expect(tooltipDirective._getOverlayPosition().main.overlayX).toBe('start');\n      expect(tooltipDirective._getOverlayPosition().fallback.overlayX).toBe('end');\n    }));\n    it('should be able to define a default (global) tooltip class', fakeAsync(() => {\n      TestBed.resetTestingModule().configureTestingModule({\n        declarations: [TooltipDemoWithoutTooltipClassBinding],\n        imports: [MatTooltipModule, OverlayModule],\n        providers: [\n          {\n            provide: MAT_TOOLTIP_DEFAULT_OPTIONS,\n            useValue: {tooltipClass: 'my-default-tooltip-class'},\n          },\n        ],\n      });\n      const fixture = TestBed.createComponent(TooltipDemoWithoutTooltipClassBinding);\n      fixture.detectChanges();\n      tooltipDirective = fixture.componentInstance.tooltip;\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick();\n      const overlayRef = tooltipDirective._overlayRef!;\n      const tooltipElement = overlayRef.overlayElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;\n      expect(tooltipDirective.tooltipClass).toBe('my-default-tooltip-class');\n      expect(tooltipElement.classList).toContain('my-default-tooltip-class');\n    }));\n    it('should be able to provide tooltip class over the custom default one', fakeAsync(() => {\n      TestBed.resetTestingModule().configureTestingModule({\n        declarations: [TooltipDemoWithTooltipClassBinding],\n        imports: [MatTooltipModule, OverlayModule],\n        providers: [\n          {\n            provide: MAT_TOOLTIP_DEFAULT_OPTIONS,\n            useValue: {tooltipClass: 'my-default-tooltip-class'},\n          },\n        ],\n      });\n      const fixture = TestBed.createComponent(TooltipDemoWithTooltipClassBinding);\n      fixture.detectChanges();\n      tooltipDirective = fixture.componentInstance.tooltip;\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick();\n      const overlayRef = tooltipDirective._overlayRef!;\n      const tooltipElement = overlayRef.overlayElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;\n      expect(tooltipDirective.tooltipClass).not.toBe('my-default-tooltip-class');\n      expect(tooltipElement.classList).not.toContain('my-default-tooltip-class');\n      expect(tooltipElement.classList).toContain('fixed-tooltip-class');\n    }));\n    it('should position on the bottom-left by default', fakeAsync(() => {\n      // We don't bind mouse events on mobile devices.\n      if (platform.IOS || platform.ANDROID) {\n        return;\n      }\n      TestBed.resetTestingModule().configureTestingModule({\n        imports: [MatTooltipModule, OverlayModule],\n        declarations: [WideTooltipDemo],\n      });\n      const wideFixture = TestBed.createComponent(WideTooltipDemo);\n      wideFixture.detectChanges();\n      tooltipDirective = wideFixture.debugElement\n        .query(By.css('button'))!\n        .injector.get<MatTooltip>(MatTooltip);\n      const button: HTMLButtonElement = wideFixture.nativeElement.querySelector('button');\n      const triggerRect = button.getBoundingClientRect();\n      dispatchMouseEvent(button, 'mouseenter', triggerRect.right - 100, triggerRect.top + 100);\n      wideFixture.detectChanges();\n      tick();\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      expect(tooltipDirective._overlayRef!.overlayElement.offsetLeft).toBeLessThan(\n        triggerRect.right - 250,\n      );\n      expect(tooltipDirective._overlayRef!.overlayElement.offsetTop).toBeGreaterThanOrEqual(\n        triggerRect.bottom,\n      );\n    }));\n    it('should be able to override the default positionAtOrigin', async () => {\n      // We don't bind mouse events on mobile devices.\n      if (platform.IOS || platform.ANDROID) {\n        return;\n      }\n      TestBed.resetTestingModule().configureTestingModule({\n        imports: [MatTooltipModule, OverlayModule],\n        declarations: [WideTooltipDemo],\n        providers: [\n          {\n            provide: MAT_TOOLTIP_DEFAULT_OPTIONS,\n            useValue: {positionAtOrigin: true},\n          },\n        ],\n      });\n      const wideFixture = TestBed.createComponent(WideTooltipDemo);\n      wideFixture.detectChanges();\n      tooltipDirective = wideFixture.debugElement\n        .query(By.css('button'))!\n        .injector.get<MatTooltip>(MatTooltip);\n      const button: HTMLButtonElement = wideFixture.nativeElement.querySelector('button');\n      const triggerRect = button.getBoundingClientRect();\n      dispatchMouseEvent(button, 'mouseenter', triggerRect.right - 100, triggerRect.top + 100);\n      wideFixture.detectChanges();\n      await new Promise<void>(resolve => setTimeout(resolve));\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      const actualOffsetLeft = tooltipDirective._overlayRef!.overlayElement.offsetLeft;\n      const expectedOffsetLeft = triggerRect.right - 100 - 20;\n      expect(actualOffsetLeft).toBeLessThanOrEqual(expectedOffsetLeft + 1);\n      expect(actualOffsetLeft).toBeGreaterThanOrEqual(expectedOffsetLeft - 1);\n      expect(tooltipDirective._overlayRef!.overlayElement.offsetTop).toBe(triggerRect.top + 100);\n    });\n    it('should be able to disable tooltip interactivity', fakeAsync(() => {\n      TestBed.resetTestingModule().configureTestingModule({\n        imports: [MatTooltipModule, OverlayModule, NoopAnimationsModule],\n        declarations: [TooltipDemoWithoutPositionBinding],\n        providers: [\n          {\n            provide: MAT_TOOLTIP_DEFAULT_OPTIONS,\n            useValue: {disableTooltipInteractivity: true},\n          },\n        ],\n      });\n      const newFixture = TestBed.createComponent(TooltipDemoWithoutPositionBinding);\n      newFixture.detectChanges();\n      tooltipDirective = newFixture.debugElement\n        .query(By.css('button'))!\n        .injector.get<MatTooltip>(MatTooltip);\n      tooltipDirective.show();\n      newFixture.detectChanges();\n      tick();\n      expect(tooltipDirective._overlayRef?.overlayElement.classList).toContain(\n        'mat-mdc-tooltip-panel-non-interactive',\n      );\n    }));\n    it('should set a css class on the overlay panel element', fakeAsync(() => {\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick(0);\n      const overlayRef = tooltipDirective._overlayRef;\n      expect(!!overlayRef).toBeTruthy();\n      expect(overlayRef!.overlayElement.classList)\n        .withContext('Expected the overlay panel element to have the tooltip panel class set.')\n        .toContain('mat-mdc-tooltip-panel');\n    }));\n    it('should not show if disabled', fakeAsync(() => {\n      // Test that disabling the tooltip will not set the tooltip visible\n      tooltipDirective.disabled = true;\n      fixture.changeDetectorRef.markForCheck();\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      // Test to make sure setting disabled to false will show the tooltip\n      // Sanity check to make sure everything was correct before (detectChanges, tick)\n      tooltipDirective.disabled = false;\n      fixture.changeDetectorRef.markForCheck();\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n    }));\n    it('should hide if disabled while visible', fakeAsync(() => {\n      // Display the tooltip with a timeout before hiding.\n      tooltipDirective.hideDelay = 1000;\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      // Set tooltip to be disabled and verify that the tooltip hides.\n      tooltipDirective.disabled = true;\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n    }));\n    it('should hide if the message is cleared while the tooltip is open', fakeAsync(() => {\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      fixture.componentInstance.message = '';\n      fixture.changeDetectorRef.markForCheck();\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n    }));\n    it('should not show if hide is called before delay finishes', waitForAsync(() => {\n      assertTooltipInstance(tooltipDirective, false);\n      const tooltipDelay = 1000;\n      tooltipDirective.show(tooltipDelay);\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      fixture.detectChanges();\n      expect(overlayContainerElement.textContent).toContain('');\n      tooltipDirective.hide();\n      fixture.whenStable().then(() => {\n        expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      });\n    }));\n    it('should not show tooltip if message is not present or empty', () => {\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.message = undefined;\n      fixture.detectChanges();\n      tooltipDirective.show();\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.message = null;\n      fixture.detectChanges();\n      tooltipDirective.show();\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.message = '';\n      fixture.detectChanges();\n      tooltipDirective.show();\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.message = '   ';\n      fixture.detectChanges();\n      tooltipDirective.show();\n      assertTooltipInstance(tooltipDirective, false);\n    });\n    it('should not follow through with hide if show is called after', fakeAsync(() => {\n      tooltipDirective.show();\n      tick(0); // Tick for the show delay (default is 0)\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      // After hide called, a timeout delay is created that will to hide the tooltip.\n      const tooltipDelay = 1000;\n      tooltipDirective.hide(tooltipDelay);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      // Before delay time has passed, call show which should cancel intent to hide tooltip.\n      tooltipDirective.show();\n      tick(tooltipDelay);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n    }));\n    it('should be able to update the tooltip position while open', fakeAsync(() => {\n      tooltipDirective.position = 'below';\n      tooltipDirective.show();\n      tick();\n      assertTooltipInstance(tooltipDirective, true);\n      spyOn(tooltipDirective._overlayRef!, 'updatePosition').and.callThrough();\n      tooltipDirective.position = 'above';\n      fixture.detectChanges();\n      tick();\n      assertTooltipInstance(tooltipDirective, true);\n      expect(tooltipDirective._overlayRef!.updatePosition).toHaveBeenCalled();\n    }));\n    it('should update the tooltip position when the directionality changes', fakeAsync(() => {\n      tooltipDirective.position = 'right';\n      tooltipDirective.show();\n      tick();\n      assertTooltipInstance(tooltipDirective, true);\n      const spy = spyOn(tooltipDirective as any, '_updatePosition').and.callThrough();\n      dir.change.next('rtl');\n      assertTooltipInstance(tooltipDirective, true);\n      expect(spy).toHaveBeenCalled();\n    }));\n    it('should not throw when updating the position for a closed tooltip', fakeAsync(() => {\n      tooltipDirective.position = 'left';\n      tooltipDirective.show(0);\n      fixture.detectChanges();\n      tick();\n      tooltipDirective.hide(0);\n      fixture.detectChanges();\n      tick();\n      finishCurrentTooltipAnimation(overlayContainerElement, false);\n      expect(() => {\n        tooltipDirective.position = 'right';\n        fixture.detectChanges();\n        tick();\n      }).not.toThrow();\n    }));\n    it('should be able to modify the tooltip message', fakeAsync(() => {\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.show();\n      tick(0); // Tick for the show delay (default is 0)\n      expect(tooltipDirective._tooltipInstance!.isVisible()).toBe(true);\n      fixture.detectChanges();\n      expect(overlayContainerElement.textContent).toContain(initialTooltipMessage);\n      const newMessage = 'new tooltip message';\n      tooltipDirective.message = newMessage;\n      fixture.detectChanges();\n      expect(overlayContainerElement.textContent).toContain(newMessage);\n    }));\n    it('should allow extra classes to be set on the tooltip', fakeAsync(() => {\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.show();\n      tick(0); // Tick for the show delay (default is 0)\n      fixture.detectChanges();\n      // Make sure classes aren't prematurely added\n      let tooltipElement = overlayContainerElement.querySelector('.mat-mdc-tooltip') as HTMLElement;\n      expect(tooltipElement.classList).not.toContain(\n        'custom-one',\n        'Expected to not have the class before enabling matTooltipClass',\n      );\n      expect(tooltipElement.classList).not.toContain(\n        'custom-two',\n        'Expected to not have the class before enabling matTooltipClass',\n      );\n      // Enable the classes via ngClass syntax\n      fixture.componentInstance.showTooltipClass = true;\n      fixture.changeDetectorRef.markForCheck();\n      fixture.detectChanges();\n      // Make sure classes are correctly added\n      tooltipElement = overlayContainerElement.querySelector('.mat-mdc-tooltip') as HTMLElement;\n      expect(tooltipElement.classList)\n        .withContext('Expected to have the class after enabling matTooltipClass')\n        .toContain('custom-one');\n      expect(tooltipElement.classList)\n        .withContext('Expected to have the class after enabling matTooltipClass')\n        .toContain('custom-two');\n    }));\n    it('should be removed after parent destroyed', fakeAsync(() => {\n      tooltipDirective.show();\n      tick(0); // Tick for the show delay (default is 0)\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      fixture.destroy();\n      expect(overlayContainerElement.childNodes.length).toBe(0);\n      expect(overlayContainerElement.textContent).toBe('');\n      flush();\n    }));\n    it('should have an aria-describedby element with the tooltip message', fakeAsync(() => {\n      const dynamicTooltipsDemoFixture = TestBed.createComponent(DynamicTooltipsDemo);\n      const dynamicTooltipsComponent = dynamicTooltipsDemoFixture.componentInstance;\n      dynamicTooltipsComponent.tooltips = ['Tooltip One', 'Tooltip Two'];\n      dynamicTooltipsDemoFixture.detectChanges();\n      tick();\n      const buttons = dynamicTooltipsDemoFixture.nativeElement.querySelectorAll('button');\n      const firstButtonAria = buttons[0].getAttribute('aria-describedby');\n      expect(document.querySelector(`#${firstButtonAria}`)!.textContent).toBe('Tooltip One');\n      const secondButtonAria = buttons[1].getAttribute('aria-describedby');\n      expect(document.querySelector(`#${secondButtonAria}`)!.textContent).toBe('Tooltip Two');\n    }));\n    it('should not add an ARIA description for elements that have the same text as a data-bound aria-label', fakeAsync(() => {\n      const ariaLabelFixture = TestBed.createComponent(DataBoundAriaLabelTooltip);\n      ariaLabelFixture.detectChanges();\n      tick();\n      const button = ariaLabelFixture.nativeElement.querySelector('button');\n      expect(button.getAttribute('aria-describedby')).toBeFalsy();\n    }));\n    it('should toggle aria-describedby depending on whether the tooltip is disabled', fakeAsync(() => {\n      expect(buttonElement.getAttribute('aria-describedby')).toBeTruthy();\n      fixture.componentInstance.tooltipDisabled = true;\n      fixture.changeDetectorRef.markForCheck();\n      fixture.detectChanges();\n      tick();\n      expect(buttonElement.hasAttribute('aria-describedby')).toBe(false);\n      fixture.componentInstance.tooltipDisabled = false;\n      fixture.changeDetectorRef.markForCheck();\n      fixture.detectChanges();\n      tick();\n      expect(buttonElement.getAttribute('aria-describedby')).toBeTruthy();\n    }));\n    it('should not try to dispose the tooltip when destroyed and done hiding', fakeAsync(() => {\n      tooltipDirective.show();\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      const tooltipDelay = 1000;\n      tooltipDirective.hide();\n      tick(tooltipDelay); // Change the tooltip state to hidden and trigger animation start\n      fixture.componentInstance.showButton = false;\n      fixture.changeDetectorRef.markForCheck();\n      fixture.detectChanges();\n    }));\n    it('should complete the afterHidden stream when tooltip is destroyed', fakeAsync(() => {\n      tooltipDirective.show();\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      const spy = jasmine.createSpy('complete spy');\n      const subscription = tooltipDirective\n        ._tooltipInstance!.afterHidden()\n        .subscribe({complete: spy});\n      tooltipDirective.hide(0);\n      tick(0);\n      fixture.detectChanges();\n      expect(spy).toHaveBeenCalled();\n      subscription.unsubscribe();\n    }));\n    it('should consistently position before and after overlay origin in ltr and rtl dir', () => {\n      tooltipDirective.position = 'left';\n      const leftOrigin = tooltipDirective._getOrigin().main;\n      tooltipDirective.position = 'right';\n      const rightOrigin = tooltipDirective._getOrigin().main;\n      // Test expectations in LTR\n      tooltipDirective.position = 'before';\n      expect(tooltipDirective._getOrigin().main).toEqual(leftOrigin);\n      tooltipDirective.position = 'after';\n      expect(tooltipDirective._getOrigin().main).toEqual(rightOrigin);\n      // Test expectations in RTL\n      dir.value = 'rtl';\n      tooltipDirective.position = 'before';\n      expect(tooltipDirective._getOrigin().main).toEqual(leftOrigin);\n      tooltipDirective.position = 'after';\n      expect(tooltipDirective._getOrigin().main).toEqual(rightOrigin);\n    });\n    it('should consistently position before and after overlay position in ltr and rtl dir', () => {\n      tooltipDirective.position = 'left';\n      const leftOverlayPosition = tooltipDirective._getOverlayPosition().main;\n      tooltipDirective.position = 'right';\n      const rightOverlayPosition = tooltipDirective._getOverlayPosition().main;\n      // Test expectations in LTR\n      tooltipDirective.position = 'before';\n      expect(tooltipDirective._getOverlayPosition().main).toEqual(leftOverlayPosition);\n      tooltipDirective.position = 'after';\n      expect(tooltipDirective._getOverlayPosition().main).toEqual(rightOverlayPosition);\n      // Test expectations in RTL\n      dir.value = 'rtl';\n      tooltipDirective.position = 'before';\n      expect(tooltipDirective._getOverlayPosition().main).toEqual(leftOverlayPosition);\n      tooltipDirective.position = 'after';\n      expect(tooltipDirective._getOverlayPosition().main).toEqual(rightOverlayPosition);\n    });\n    it('should throw when trying to assign an invalid position', () => {\n      expect(() => {\n        fixture.componentInstance.position = 'everywhere';\n        fixture.changeDetectorRef.markForCheck();\n        fixture.detectChanges();\n        tooltipDirective.show();\n      }).toThrowError('Tooltip position \"everywhere\" is invalid.');\n    });\n    it('should pass the layout direction to the tooltip', fakeAsync(() => {\n      dir.value = 'rtl';\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      const tooltipWrapper = overlayContainerElement.querySelector(\n        '.cdk-overlay-connected-position-bounding-box',\n      )!;\n      expect(tooltipWrapper).withContext('Expected tooltip to be shown.').toBeTruthy();\n      expect(tooltipWrapper.getAttribute('dir'))\n        .withContext('Expected tooltip to be in RTL mode.')\n        .toBe('rtl');\n    }));\n    it('should keep the overlay direction in sync with the trigger direction', fakeAsync(() => {\n      dir.value = 'rtl';\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      let tooltipWrapper = overlayContainerElement.querySelector(\n        '.cdk-overlay-connected-position-bounding-box',\n      )!;\n      expect(tooltipWrapper.getAttribute('dir'))\n        .withContext('Expected tooltip to be in RTL.')\n        .toBe('rtl');\n      tooltipDirective.hide(0);\n      tick(0);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, false);\n      dir.value = 'ltr';\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      tooltipWrapper = overlayContainerElement.querySelector(\n        '.cdk-overlay-connected-position-bounding-box',\n      )!;\n      expect(tooltipWrapper.getAttribute('dir'))\n        .withContext('Expected tooltip to be in LTR.')\n        .toBe('ltr');\n      flush();\n    }));\n    it('should be able to set the tooltip message as a number', fakeAsync(() => {\n      fixture.componentInstance.message = 100;\n      fixture.changeDetectorRef.markForCheck();\n      fixture.detectChanges();\n      expect(tooltipDirective.message).toBe('100');\n    }));\n    it('should hide when clicking away', fakeAsync(() => {\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      expect(overlayContainerElement.textContent).toContain(initialTooltipMessage);\n      document.body.click();\n      tick(0);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, false);\n      fixture.detectChanges();\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      expect(overlayContainerElement.textContent).toBe('');\n    }));\n    it('should hide when clicking away with an auxilliary button', fakeAsync(() => {\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      expect(overlayContainerElement.textContent).toContain(initialTooltipMessage);\n      dispatchFakeEvent(document.body, 'auxclick');\n      tick(0);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, false);\n      fixture.detectChanges();\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      expect(overlayContainerElement.textContent).toBe('');\n    }));\n    it('should not hide immediately if a click fires while animating', fakeAsync(() => {\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      document.body.click();\n      fixture.detectChanges();\n      tick(500);\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      expect(overlayContainerElement.textContent).toContain(initialTooltipMessage);\n      flush();\n    }));\n    it('should hide when pressing escape', fakeAsync(() => {\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      tick(500);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      expect(overlayContainerElement.textContent).toContain(initialTooltipMessage);\n      dispatchKeyboardEvent(document.body, 'keydown', ESCAPE);\n      tick(0);\n      fixture.detectChanges();\n      tick(500);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, false);\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      expect(overlayContainerElement.textContent).toBe('');\n      flush();\n    }));\n    it('should not throw when pressing ESCAPE', fakeAsync(() => {\n      expect(() => {\n        dispatchKeyboardEvent(document.body, 'keydown', ESCAPE);\n        fixture.detectChanges();\n      }).not.toThrow();\n      // Flush due to the additional tick that is necessary for the FocusMonitor.\n      flush();\n    }));\n    it('should preventDefault when pressing ESCAPE', fakeAsync(() => {\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      const event = dispatchKeyboardEvent(document.body, 'keydown', ESCAPE);\n      fixture.detectChanges();\n      flush();\n      expect(event.defaultPrevented).toBe(true);\n    }));\n    it('should not preventDefault when pressing ESCAPE with a modifier', fakeAsync(() => {\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      const event = createKeyboardEvent('keydown', ESCAPE, undefined, {alt: true});\n      dispatchEvent(document.body, event);\n      fixture.detectChanges();\n      flush();\n      expect(event.defaultPrevented).toBe(false);\n    }));\n    it('should not show the tooltip on programmatic focus', fakeAsync(() => {\n      patchElementFocus(buttonElement);\n      assertTooltipInstance(tooltipDirective, false);\n      focusMonitor.focusVia(buttonElement, 'program');\n      tick(0);\n      fixture.detectChanges();\n      tick(500);\n      expect(overlayContainerElement.querySelector('.mat-mdc-tooltip')).toBeNull();\n    }));\n    it('should not show the tooltip on mouse focus', fakeAsync(() => {\n      patchElementFocus(buttonElement);\n      assertTooltipInstance(tooltipDirective, false);\n      focusMonitor.focusVia(buttonElement, 'mouse');\n      tick(0);\n      fixture.detectChanges();\n      tick(500);\n      expect(overlayContainerElement.querySelector('.mat-mdc-tooltip')).toBeNull();\n    }));\n    it('should not show the tooltip on touch focus', fakeAsync(() => {\n      patchElementFocus(buttonElement);\n      assertTooltipInstance(tooltipDirective, false);\n      focusMonitor.focusVia(buttonElement, 'touch');\n      tick(0);\n      fixture.detectChanges();\n      tick(500);\n      expect(overlayContainerElement.querySelector('.mat-mdc-tooltip')).toBeNull();\n    }));\n    it('should not hide the tooltip when calling `show` twice in a row', fakeAsync(() => {\n      tooltipDirective.show();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      const overlayRef = tooltipDirective._overlayRef!;\n      spyOn(overlayRef, 'detach').and.callThrough();\n      tooltipDirective.show();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      expect(overlayRef.detach).not.toHaveBeenCalled();\n      flush();\n    }));\n    it('should set a class on the overlay panel that reflects the position', fakeAsync(() => {\n      // Move the element so that the primary position is always used.\n      buttonElement.style.position = 'fixed';\n      buttonElement.style.top = buttonElement.style.left = '200px';\n      fixture.componentInstance.message = 'hi';\n      fixture.changeDetectorRef.markForCheck();\n      fixture.detectChanges();\n      setPositionAndShow('below');\n      const classList = tooltipDirective._overlayRef!.overlayElement.classList;\n      expect(classList).toContain('mat-mdc-tooltip-panel-below');\n      setPositionAndShow('above');\n      expect(classList).not.toContain('mat-mdc-tooltip-panel-below');\n      expect(classList).toContain('mat-mdc-tooltip-panel-above');\n      setPositionAndShow('left');\n      expect(classList).not.toContain('mat-mdc-tooltip-panel-above');\n      expect(classList).toContain('mat-mdc-tooltip-panel-left');\n      setPositionAndShow('right');\n      expect(classList).not.toContain('mat-mdc-tooltip-panel-left');\n      expect(classList).toContain('mat-mdc-tooltip-panel-right');\n      function setPositionAndShow(position: TooltipPosition) {\n        tooltipDirective.hide(0);\n        fixture.detectChanges();\n        tick(0);\n        tooltipDirective.position = position;\n        tooltipDirective.show(0);\n        fixture.detectChanges();\n        tick(0);\n        fixture.detectChanges();\n        tick(500);\n      }\n    }));\n    it('should account for RTL when setting the tooltip position class', fakeAsync(() => {\n      // Move the element so that the primary position is always used.\n      buttonElement.style.position = 'fixed';\n      buttonElement.style.top = buttonElement.style.left = '200px';\n      fixture.componentInstance.message = 'hi';\n      fixture.changeDetectorRef.markForCheck();\n      fixture.detectChanges();\n      dir.value = 'ltr';\n      tooltipDirective.position = 'after';\n      fixture.changeDetectorRef.markForCheck();\n      tooltipDirective.show(0);\n      fixture.detectChanges();\n      tick(0);\n      fixture.detectChanges();\n      tick(500);\n      const classList = tooltipDirective._overlayRef!.overlayElement.classList;\n      expect(classList).not.toContain('mat-mdc-tooltip-panel-after');\n      expect(classList).not.toContain('mat-mdc-tooltip-panel-before');\n      expect(classList).not.toContain('mat-mdc-tooltip-panel-left');\n      expect(classList).toContain('mat-mdc-tooltip-panel-right');\n      tooltipDirective.hide(0);\n      fixture.detectChanges();\n      tick(0);\n      dir.value = 'rtl';\n      tooltipDirective.show(0);\n      fixture.detectChanges();\n      tick(0);\n      fixture.detectChanges();\n      tick(500);\n      expect(classList).not.toContain('mat-mdc-tooltip-panel-after');\n      expect(classList).not.toContain('mat-mdc-tooltip-panel-before');\n      expect(classList).not.toContain('mat-mdc-tooltip-panel-right');\n      expect(classList).toContain('mat-mdc-tooltip-panel-left');\n    }));\n    it('should clear the show timeout on destroy', fakeAsync(() => {\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.show(1000);\n      fixture.detectChanges();\n      // Note that we aren't asserting anything, but `fakeAsync` will\n      // throw if we have any timers by the end of the test.\n      fixture.destroy();\n      flush();\n    }));\n    it('should clear the hide timeout on destroy', fakeAsync(() => {\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      tick(500);\n      tooltipDirective.hide(1000);\n      fixture.detectChanges();\n      // Note that we aren't asserting anything, but `fakeAsync` will\n      // throw if we have any timers by the end of the test.\n      fixture.destroy();\n      flush();\n    }));\n    it('should set the multiline class on tooltips with messages that overflow', fakeAsync(() => {\n      fixture.componentInstance.message =\n        'This is a very long message that should cause the' +\n        'tooltip message body to overflow onto a new line.';\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick();\n      // Need to detect changes again to wait for the multiline class to be applied.\n      fixture.detectChanges();\n      const tooltipElement = overlayContainerElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;\n      expect(tooltipElement.classList).toContain('mdc-tooltip--multiline');\n      expect(tooltipDirective._tooltipInstance?._isMultiline).toBeTrue();\n    }));\n    it('should hide on mouseleave on the trigger', fakeAsync(() => {\n      // We don't bind mouse events on mobile devices.\n      if (platform.IOS || platform.ANDROID) {\n        return;\n      }\n      dispatchMouseEvent(fixture.componentInstance.button.nativeElement, 'mouseenter');\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      dispatchMouseEvent(fixture.componentInstance.button.nativeElement, 'mouseleave');\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n    }));\n    it('should not hide on mouseleave if the pointer goes from the trigger to the tooltip', fakeAsync(() => {\n      // We don't bind mouse events on mobile devices.\n      if (platform.IOS || platform.ANDROID) {\n        return;\n      }\n      dispatchMouseEvent(fixture.componentInstance.button.nativeElement, 'mouseenter');\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      const tooltipElement = overlayContainerElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;\n      const event = createMouseEvent('mouseleave');\n      Object.defineProperty(event, 'relatedTarget', {value: tooltipElement});\n      dispatchEvent(fixture.componentInstance.button.nativeElement, event);\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n    }));\n    it('should hide on mouseleave on the tooltip', fakeAsync(() => {\n      // We don't bind mouse events on mobile devices.\n      if (platform.IOS || platform.ANDROID) {\n        return;\n      }\n      dispatchMouseEvent(fixture.componentInstance.button.nativeElement, 'mouseenter');\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      const tooltipElement = overlayContainerElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;\n      dispatchMouseEvent(tooltipElement, 'mouseleave');\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n    }));\n    it('should not hide on mouseleave if the pointer goes from the tooltip to the trigger', fakeAsync(() => {\n      // We don't bind mouse events on mobile devices.\n      if (platform.IOS || platform.ANDROID) {\n        return;\n      }\n      dispatchMouseEvent(fixture.componentInstance.button.nativeElement, 'mouseenter');\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      const tooltipElement = overlayContainerElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;\n      const event = createMouseEvent('mouseleave');\n      Object.defineProperty(event, 'relatedTarget', {\n        value: fixture.componentInstance.button.nativeElement,\n      });\n      dispatchEvent(tooltipElement, event);\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n    }));\n  });\n  describe('fallback positions', () => {\n    let fixture: ComponentFixture<BasicTooltipDemo>;\n    let tooltip: MatTooltip;\n    beforeEach(() => {\n      fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      tooltip = fixture.debugElement.query(By.css('button'))!.injector.get<MatTooltip>(MatTooltip);\n    });\n    it('should set a fallback origin position by inverting the main origin position', () => {\n      tooltip.position = 'left';\n      expect(tooltip._getOrigin().main.originX).toBe('start');\n      expect(tooltip._getOrigin().fallback.originX).toBe('end');\n      tooltip.position = 'right';\n      expect(tooltip._getOrigin().main.originX).toBe('end');\n      expect(tooltip._getOrigin().fallback.originX).toBe('start');\n      tooltip.position = 'above';\n      expect(tooltip._getOrigin().main.originY).toBe('top');\n      expect(tooltip._getOrigin().fallback.originY).toBe('bottom');\n      tooltip.position = 'below';\n      expect(tooltip._getOrigin().main.originY).toBe('bottom');\n      expect(tooltip._getOrigin().fallback.originY).toBe('top');\n    });\n    it('should set a fallback overlay position by inverting the main overlay position', () => {\n      tooltip.position = 'left';\n      expect(tooltip._getOverlayPosition().main.overlayX).toBe('end');\n      expect(tooltip._getOverlayPosition().fallback.overlayX).toBe('start');\n      tooltip.position = 'right';\n      expect(tooltip._getOverlayPosition().main.overlayX).toBe('start');\n      expect(tooltip._getOverlayPosition().fallback.overlayX).toBe('end');\n      tooltip.position = 'above';\n      expect(tooltip._getOverlayPosition().main.overlayY).toBe('bottom');\n      expect(tooltip._getOverlayPosition().fallback.overlayY).toBe('top');\n      tooltip.position = 'below';\n      expect(tooltip._getOverlayPosition().main.overlayY).toBe('top');\n      expect(tooltip._getOverlayPosition().fallback.overlayY).toBe('bottom');\n    });\n  });\n  describe('scrollable usage', () => {\n    let fixture: ComponentFixture<ScrollableTooltipDemo>;\n    let buttonDebugElement: DebugElement;\n    let tooltipDirective: MatTooltip;\n    beforeEach(() => {\n      fixture = TestBed.createComponent(ScrollableTooltipDemo);\n      fixture.detectChanges();\n      buttonDebugElement = fixture.debugElement.query(By.css('button'))!;\n      tooltipDirective = buttonDebugElement.injector.get<MatTooltip>(MatTooltip);\n    });\n    it('should hide tooltip if clipped after changing positions', fakeAsync(() => {\n      assertTooltipInstance(tooltipDirective, false);\n      // Show the tooltip and tick for the show delay (default is 0)\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick(0);\n      // Expect that the tooltip is displayed\n      // Expect that the tooltip is displayed\n      expect(tooltipDirective._isTooltipVisible())\n        .withContext('Expected tooltip to be initially visible')\n        .toBe(true);\n      // Scroll the page but tick just before the default throttle should update.\n      fixture.componentInstance.scrollDown();\n      tick(SCROLL_THROTTLE_MS - 1);\n      expect(tooltipDirective._isTooltipVisible())\n        .withContext('Expected tooltip to be visible when scrolling, before throttle limit')\n        .toBe(true);\n      // Finish ticking to the throttle's limit and check that the scroll event notified the\n      // tooltip and it was hidden.\n      tick(100);\n      fixture.detectChanges();\n      expect(tooltipDirective._isTooltipVisible())\n        .withContext('Expected tooltip hidden when scrolled out of view, after throttle limit')\n        .toBe(false);\n    }));\n  });\n  describe('with OnPush', () => {\n    let fixture: ComponentFixture<OnPushTooltipDemo>;\n    let buttonDebugElement: DebugElement;\n    let buttonElement: HTMLButtonElement;\n    let tooltipDirective: MatTooltip;\n    beforeEach(() => {\n      fixture = TestBed.createComponent(OnPushTooltipDemo);\n      fixture.detectChanges();\n      buttonDebugElement = fixture.debugElement.query(By.css('button'))!;\n      buttonElement = <HTMLButtonElement>buttonDebugElement.nativeElement;\n      tooltipDirective = buttonDebugElement.injector.get<MatTooltip>(MatTooltip);\n    });\n    it('should show and hide the tooltip', fakeAsync(() => {\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.show();\n      tick(0); // Tick for the show delay (default is 0)\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      fixture.detectChanges();\n      // wait until animation has finished\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      // Make sure tooltip is shown to the user and animation has finished\n      const tooltipElement = overlayContainerElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;\n      expect(tooltipElement instanceof HTMLElement).toBe(true);\n      expect(tooltipElement.classList).toContain('mat-mdc-tooltip-show');\n      // After hide called, a timeout delay is created that will to hide the tooltip.\n      const tooltipDelay = 1000;\n      tooltipDirective.hide(tooltipDelay);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      // After the tooltip delay elapses, expect that the tooltip is not visible.\n      tick(tooltipDelay);\n      fixture.detectChanges();\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      // On animation complete, should expect that the tooltip has been detached.\n      finishCurrentTooltipAnimation(overlayContainerElement, false);\n      assertTooltipInstance(tooltipDirective, false);\n      flush();\n    }));\n    it('should have rendered the tooltip text on init', fakeAsync(() => {\n      // We don't bind mouse events on mobile devices.\n      if (platform.IOS || platform.ANDROID) {\n        return;\n      }\n      dispatchFakeEvent(buttonElement, 'mouseenter');\n      fixture.detectChanges();\n      tick(0);\n      const tooltipElement = overlayContainerElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;\n      expect(tooltipElement.textContent).toContain('initial tooltip message');\n    }));\n  });\n  describe('touch gestures', () => {\n    beforeEach(() => {\n      platform.ANDROID = true;\n    });\n    it('should have a delay when showing on touchstart', fakeAsync(() => {\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      const button: HTMLButtonElement = fixture.nativeElement.querySelector('button');\n      dispatchFakeEvent(button, 'touchstart');\n      fixture.detectChanges();\n      tick(250); // Halfway through the delay.\n      assertTooltipInstance(fixture.componentInstance.tooltip, false);\n      tick(500); // Finish the delay.\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true); // Finish the animation.\n      assertTooltipInstance(fixture.componentInstance.tooltip, true);\n      flush();\n    }));\n    it('should be able to disable opening on touch', fakeAsync(() => {\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.componentInstance.touchGestures = 'off';\n      fixture.detectChanges();\n      const button: HTMLButtonElement = fixture.nativeElement.querySelector('button');\n      dispatchFakeEvent(button, 'touchstart');\n      fixture.detectChanges();\n      tick(500); // Finish the delay.\n      fixture.detectChanges();\n      tick(500); // Finish the animation.\n      assertTooltipInstance(fixture.componentInstance.tooltip, false);\n    }));\n    it('should not prevent the default action on touchstart', () => {\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      const button: HTMLButtonElement = fixture.nativeElement.querySelector('button');\n      const event = dispatchFakeEvent(button, 'touchstart');\n      fixture.detectChanges();\n      expect(event.defaultPrevented).toBe(false);\n    });\n    it('should close on touchend with a delay', fakeAsync(() => {\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      const button: HTMLButtonElement = fixture.nativeElement.querySelector('button');\n      dispatchFakeEvent(button, 'touchstart');\n      fixture.detectChanges();\n      tick(500); // Finish the open delay.\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true); // Finish the animation.\n      assertTooltipInstance(fixture.componentInstance.tooltip, true);\n      dispatchFakeEvent(button, 'touchend');\n      fixture.detectChanges();\n      tick(1000); // 2/3 through the delay\n      assertTooltipInstance(fixture.componentInstance.tooltip, true);\n      tick(500); // Finish the delay.\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, false); // Finish the exit animation.\n      assertTooltipInstance(fixture.componentInstance.tooltip, false);\n      flush();\n    }));\n    it('should close on touchcancel with a delay', fakeAsync(() => {\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      const button: HTMLButtonElement = fixture.nativeElement.querySelector('button');\n      dispatchFakeEvent(button, 'touchstart');\n      fixture.detectChanges();\n      tick(500); // Finish the open delay.\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true); // Finish the animation.\n      assertTooltipInstance(fixture.componentInstance.tooltip, true);\n      dispatchFakeEvent(button, 'touchcancel');\n      fixture.detectChanges();\n      tick(1000); // 2/3 through the delay\n      assertTooltipInstance(fixture.componentInstance.tooltip, true);\n      tick(500); // Finish the delay.\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, false); // Finish the exit animation.\n      assertTooltipInstance(fixture.componentInstance.tooltip, false);\n      flush();\n    }));\n    it('should disable native touch interactions', () => {\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      const styles = fixture.nativeElement.querySelector('button').style;\n      expect(styles.touchAction || (styles as any).webkitUserDrag).toBe('none');\n    });\n    it('should allow native touch interactions if touch gestures are turned off', () => {\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.componentInstance.touchGestures = 'off';\n      fixture.detectChanges();\n      const styles = fixture.nativeElement.querySelector('button').style;\n      expect(styles.touchAction || (styles as any).webkitUserDrag).toBeFalsy();\n    });\n    it('should allow text selection on inputs when gestures are set to auto', () => {\n      const fixture = TestBed.createComponent(TooltipOnTextFields);\n      fixture.detectChanges();\n      const inputStyle = fixture.componentInstance.input.nativeElement.style;\n      const textareaStyle = fixture.componentInstance.textarea.nativeElement.style;\n      expect(inputStyle.userSelect).toBeFalsy();\n      expect(inputStyle.webkitUserSelect).toBeFalsy();\n      expect((inputStyle as any).msUserSelect).toBeFalsy();\n      expect((inputStyle as any).MozUserSelect).toBeFalsy();\n      expect(textareaStyle.userSelect).toBeFalsy();\n      expect(textareaStyle.webkitUserSelect).toBeFalsy();\n      expect((textareaStyle as any).msUserSelect).toBeFalsy();\n      expect((textareaStyle as any).MozUserSelect).toBeFalsy();\n    });\n    it('should disable text selection on inputs when gestures are set to on', () => {\n      const fixture = TestBed.createComponent(TooltipOnTextFields);\n      fixture.componentInstance.touchGestures = 'on';\n      fixture.detectChanges();\n      const inputStyle = fixture.componentInstance.input.nativeElement.style;\n      const inputUserSelect =\n        inputStyle.userSelect ||\n        inputStyle.webkitUserSelect ||\n        (inputStyle as any).msUserSelect ||\n        (inputStyle as any).MozUserSelect;\n      const textareaStyle = fixture.componentInstance.textarea.nativeElement.style;\n      const textareaUserSelect =\n        textareaStyle.userSelect ||\n        textareaStyle.webkitUserSelect ||\n        (textareaStyle as any).msUserSelect ||\n        (textareaStyle as any).MozUserSelect;\n      expect(inputUserSelect).toBe('none');\n      expect(textareaUserSelect).toBe('none');\n    });\n    it('should allow native dragging on draggable elements when gestures are set to auto', () => {\n      const fixture = TestBed.createComponent(TooltipOnDraggableElement);\n      fixture.detectChanges();\n      expect(fixture.componentInstance.button.nativeElement.style.webkitUserDrag).toBeFalsy();\n    });\n    it('should disable native dragging on draggable elements when gestures are set to on', () => {\n      const fixture = TestBed.createComponent(TooltipOnDraggableElement);\n      fixture.componentInstance.touchGestures = 'on';\n      fixture.detectChanges();\n      const styles = fixture.componentInstance.button.nativeElement.style;\n      if ('webkitUserDrag' in styles) {\n        expect(styles.webkitUserDrag).toBe('none');\n      }\n    });\n    it('should not open on `mouseenter` on iOS', () => {\n      platform.IOS = true;\n      platform.ANDROID = false;\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      dispatchMouseEvent(fixture.componentInstance.button.nativeElement, 'mouseenter');\n      fixture.detectChanges();\n      assertTooltipInstance(fixture.componentInstance.tooltip, false);\n    });\n    it('should not open on `mouseenter` on Android', () => {\n      platform.ANDROID = true;\n      platform.IOS = false;\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      dispatchMouseEvent(fixture.componentInstance.button.nativeElement, 'mouseenter');\n      fixture.detectChanges();\n      assertTooltipInstance(fixture.componentInstance.tooltip, false);\n    });\n  });\n  describe('mouse wheel handling', () => {\n    it('should close when a wheel event causes the cursor to leave the trigger', fakeAsync(() => {\n      // We don't bind wheel events on mobile devices.\n      if (platform.IOS || platform.ANDROID) {\n        return;\n      }\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      const button: HTMLButtonElement = fixture.nativeElement.querySelector('button');\n      dispatchFakeEvent(button, 'mouseenter');\n      fixture.detectChanges();\n      tick(500); // Finish the open delay.\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      assertTooltipInstance(fixture.componentInstance.tooltip, true);\n      // Simulate the pointer at the bottom/right of the page.\n      const wheelEvent = createFakeEvent('wheel');\n      Object.defineProperties(wheelEvent, {\n        clientX: {get: () => window.innerWidth},\n        clientY: {get: () => window.innerHeight},\n      });\n      dispatchEvent(button, wheelEvent);\n      fixture.detectChanges();\n      tick(1500); // Finish the delay.\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, false);\n      assertTooltipInstance(fixture.componentInstance.tooltip, false);\n      flush();\n    }));\n    it('should not close if the cursor is over the trigger after a wheel event', fakeAsync(() => {\n      // We don't bind wheel events on mobile devices.\n      if (platform.IOS || platform.ANDROID) {\n        return;\n      }\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      const button: HTMLButtonElement = fixture.nativeElement.querySelector('button');\n      dispatchFakeEvent(button, 'mouseenter');\n      fixture.detectChanges();\n      tick(500); // Finish the open delay.\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      assertTooltipInstance(fixture.componentInstance.tooltip, true);\n      // Simulate the pointer over the trigger.\n      const triggerRect = button.getBoundingClientRect();\n      const wheelEvent = createFakeEvent('wheel');\n      Object.defineProperties(wheelEvent, {\n        clientX: {get: () => triggerRect.left + 1},\n        clientY: {get: () => triggerRect.top + 1},\n      });\n      dispatchEvent(button, wheelEvent);\n      fixture.detectChanges();\n      tick(1500); // Finish the delay.\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, false);\n      assertTooltipInstance(fixture.componentInstance.tooltip, true);\n      flush();\n    }));\n  });\n});\n@Component({\n  selector: 'app',\n  template: `\n    @if (showButton) {\n      <button #button\n        [matTooltip]=\"message\"\n        [matTooltipPosition]=\"position\"\n        [matTooltipClass]=\"{'custom-one': showTooltipClass, 'custom-two': showTooltipClass}\"\n        [matTooltipTouchGestures]=\"touchGestures\"\n        [matTooltipDisabled]=\"tooltipDisabled\">Button</button>\n    }`,\n  standalone: true,\n  imports: [MatTooltipModule, OverlayModule],\n})\nclass BasicTooltipDemo {\n  position = 'below';\n  message: any = initialTooltipMessage;\n  showButton = true;\n  showTooltipClass = false;\n  tooltipDisabled = false;\n  touchGestures: TooltipTouchGestures = 'auto';\n  @ViewChild(MatTooltip) tooltip: MatTooltip;\n  @ViewChild('button') button: ElementRef<HTMLButtonElement>;\n}\n@Component({\n  selector: 'app',\n  template: `\n    <div cdkScrollable style=\"padding: 100px; margin: 300px;\n                               height: 200px; width: 200px; overflow: auto;\">\n      @if (showButton) {\n        <button style=\"margin-bottom: 600px\"\n              [matTooltip]=\"message\"\n              [matTooltipPosition]=\"position\">Button</button>\n      }\n    </div>`,\n  standalone: true,\n  imports: [MatTooltipModule, OverlayModule],\n})\nclass ScrollableTooltipDemo {\n  position: string = 'below';\n  message: string = initialTooltipMessage;\n  showButton: boolean = true;\n  @ViewChild(CdkScrollable) scrollingContainer: CdkScrollable;\n  scrollDown() {\n    const scrollingContainerEl = this.scrollingContainer.getElementRef().nativeElement;\n    scrollingContainerEl.scrollTop = 250;\n    // Emit a scroll event from the scrolling element in our component.\n    // This event should be picked up by the scrollable directive and notify.\n    // The notification should be picked up by the service.\n    dispatchFakeEvent(scrollingContainerEl, 'scroll');\n  }\n}\n@Component({\n  selector: 'app',\n  template: `\n    <button [matTooltip]=\"message\"\n            [matTooltipPosition]=\"position\">\n      Button\n    </button>`,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  standalone: true,\n  imports: [MatTooltipModule, OverlayModule],\n})\nclass OnPushTooltipDemo {\n  position: string = 'below';\n  message: string = initialTooltipMessage;\n}\n@Component({\n  selector: 'app',\n  template: `\n    @for (tooltip of tooltips; track tooltip) {\n      <button [matTooltip]=\"tooltip\">Button {{tooltip}}</button>\n    }\n  `,\n  standalone: true,\n  imports: [MatTooltipModule, OverlayModule],\n})\nclass DynamicTooltipsDemo {\n  tooltips: string[] = [];\n}\n@Component({\n  template: `<button [matTooltip]=\"message\" [attr.aria-label]=\"message\">Click me</button>`,\n  standalone: true,\n  imports: [MatTooltipModule, OverlayModule],\n})\nclass DataBoundAriaLabelTooltip {\n  message = 'Hello there';\n}\n@Component({\n  template: `\n    <input\n      #input\n      matTooltip=\"Something\"\n      [matTooltipTouchGestures]=\"touchGestures\">\n    <textarea\n      #textarea\n      matTooltip=\"Another thing\"\n      [matTooltipTouchGestures]=\"touchGestures\"></textarea>\n  `,\n  standalone: true,\n  imports: [MatTooltipModule, OverlayModule],\n})\nclass TooltipOnTextFields {\n  @ViewChild('input') input: ElementRef<HTMLInputElement>;\n  @ViewChild('textarea') textarea: ElementRef<HTMLTextAreaElement>;\n  touchGestures: TooltipTouchGestures = 'auto';\n}\n@Component({\n  template: `\n    <button\n      #button\n      draggable=\"true\"\n      matTooltip=\"Drag me\"\n      [matTooltipTouchGestures]=\"touchGestures\"></button>\n  `,\n  standalone: true,\n  imports: [MatTooltipModule, OverlayModule],\n})\nclass TooltipOnDraggableElement {\n  @ViewChild('button') button: ElementRef;\n  touchGestures: TooltipTouchGestures = 'auto';\n}\n@Component({\n  selector: 'app',\n  template: `<button #button [matTooltip]=\"message\">Button</button>`,\n  standalone: false,\n})\nclass TooltipDemoWithoutPositionBinding {\n  message: any = initialTooltipMessage;\n  @ViewChild(MatTooltip) tooltip: MatTooltip;\n  @ViewChild('button') button: ElementRef<HTMLButtonElement>;\n}\n@Component({\n  selector: 'app',\n  template: `<button #button [matTooltip]=\"message\">Button</button>`,\n  standalone: false,\n})\nclass TooltipDemoWithoutTooltipClassBinding {\n  message = initialTooltipMessage;\n  @ViewChild(MatTooltip) tooltip: MatTooltip;\n  @ViewChild('button') button: ElementRef<HTMLButtonElement>;\n}\n@Component({\n  selector: 'app',\n  template: `\n    <button #button matTooltipClass=\"fixed-tooltip-class\" [matTooltip]=\"message\">Button</button>\n  `,\n  standalone: false,\n})\nclass TooltipDemoWithTooltipClassBinding {\n  message: any = initialTooltipMessage;\n  @ViewChild(MatTooltip) tooltip: MatTooltip;\n  @ViewChild('button') button: ElementRef<HTMLButtonElement>;\n}\n@Component({\n  selector: 'app',\n  styles: `button { width: 500px; height: 500px; }`,\n  template: `<button #button [matTooltip]=\"message\">Button</button>`,\n  standalone: false,\n})\nclass WideTooltipDemo {\n  message = 'Test';\n  @ViewChild(MatTooltip) tooltip: MatTooltip;\n  @ViewChild('button') button: ElementRef<HTMLButtonElement>;\n}\nfunction assertTooltipInstance(tooltip: MatTooltip, shouldExist: boolean): void {\n  // Note that we have to cast this to a boolean, because Jasmine will go into an infinite loop\n  // if it tries to stringify the `_tooltipInstance` when an assertion fails. The infinite loop\n  // happens due to the `_tooltipInstance` having a circular structure.\n  expect(!!tooltip._tooltipInstance).toBe(shouldExist);\n}\nfunction finishCurrentTooltipAnimation(overlayContainer: HTMLElement, isVisible: boolean) {\n  const tooltip = overlayContainer.querySelector('.mat-mdc-tooltip')!;\n  const event = createFakeEvent('animationend');\n  Object.defineProperty(event, 'animationName', {\n    get: () => `mat-mdc-tooltip-${isVisible ? 'show' : 'hide'}`,\n  });\n  dispatchEvent(tooltip, event);\n}", "llm_cg": {"AnonymousClass.%AM0$Injectable(providers)": ["AnonymousClass.%AM1$Directionality(unknown)"], "AnonymousClass.%AM2$beforeEach(waitForAsync)": ["AnonymousClass.%AM3$configureTestingModule(imports,providers)", "AnonymousClass.%AM0$inject(OverlayContainer,FocusMonitor,Platform)"], "AnonymousClass.%AM4$beforeEach(fakeAsync)": ["AnonymousClass.%AM5$createComponent(BasicTooltipDemo)", "AnonymousClass.%AM5$detectChanges()", "AnonymousClass.%AM6$tick()", "AnonymousClass.%AM7$query(By.css('button'))", "AnonymousClass.%AM8$inject(MatTooltip)"], "AnonymousClass.%AM9$it(fakeAsync)": ["AnonymousClass.%AM10$assertTooltipInstance(MatTooltip, shouldExist)", "AnonymousClass.%AM11$MatTooltip.show()", "AnonymousClass.%AM6$tick()", "AnonymousClass.%AM11$_isTooltipVisible()", "AnonymousClass.%AM5$detectChanges()", "AnonymousClass.%AM12$finishCurrentTooltipAnimation(overlayContainerElement, true)", "AnonymousClass.%AM13$querySelector('.mat-mdc-tooltip')", "AnonymousClass.%AM11$hide(tooltipDelay)", "AnonymousClass.%AM11$_isTooltipVisible()", "AnonymousClass.%AM6$tick(tooltipDelay)", "AnonymousClass.%AM14$assertTooltipInstance(MatTooltip, shouldExist)", "AnonymousClass.%AM6$flush()"], "AnonymousClass.%AM15$lifecycleTest(fakeAsync)": ["AnonymousClass.%AM20$MatTooltip.show()", "AnonymousClass.%AM6$tick()", "AnonymousClass.%AM5$detectChanges()", "AnonymousClass.%AM19$finishCurrentTooltipAnimation(overlayContainerElement, true)", "AnonymousClass.%AM20$MatTooltip._overlayRef.attach()", "AnonymousClass.%AM6$tick()", "AnonymousClass.%AM5$detectChanges()", "AnonymousClass.%AM10$assertTooltipInstance(MatTooltip, shouldExist)", "AnonymousClass.%AM20$show()", "AnonymousClass.%AM6$tick()", "AnonymousClass.%AM19$finishCurrentTooltipAnimation(overlayContainerElement, true)", "AnonymousClass.%AM10$assertTooltipInstance(MatTooltip, shouldExist)"], "BasicTooltipDemo.%AM16$component(TestBed)": ["BasicTooltipDemo.%AM18$TestSetupTestBed()", "BasicTooltipDemo.%AM12$TestBed.detectChanges()", "BasicTooltipDemo.%AM21$waitForAsync(TestBed)", "BasicTooltipDemo.%AM3$configureTestingModule(imports,providers)", "BasicTooltipDemo.%AM0$providers(Directionality, OverlayContainer, FocusMonitor, Platform)", "BasicTooltipDemo.%AM4$fakeAsync(beforeEach)", "BasicTooltipDemo.%AM7$query", "BasicTooltipDemo.%AM10$assertTooltipInstance(MatTooltip, true)"], "ScrollableTooltipDemo.%AM0$listeners(CdkScrollable)": ["ScrollableTooltipDemo.%AM1$scroll()"], "static.%AM1$Test(classStatic)": [], "dynamic.%AM1$Test(TestMethods)": ["dynamic.%AM7$query", "dynamic.%AM18$TestMethods.detectChanges(createComponent)"], "fake.%AM0$expectations(fakeAsync)": ["fake.%AM5$detection(ngx)", "fake.%AM7$querySelector(element, .containsClass)", "fake.%AM15$lifecycleTest(mockText)"], "Method.%AM19$onAnimation(animation)": {"show": "Method.%AM20$animate(handler)"}}, "static_cg": {"@test/139.ts: %dflt.[static]%dflt()": ["@test/139.ts: %dflt.%AM0()"], "@test/139.ts: %dflt.%AM1$%AM0()": ["@test/139.ts: %dflt.%AM2$%AM1$%AM0(OverlayContainer, FocusMonitor, Platform)"], "@test/139.ts: %dflt.%AM5$%AM3$%AM0()": ["@test/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)", "@test/139.ts: %dflt.finishCurrentTooltipAnimation(HTMLElement, boolean)"], "@test/139.ts: %dflt.%AM6$%AM3$%AM0()": ["@test/139.ts: %dflt.finishCurrentTooltipAnimation(HTMLElement, boolean)", "@test/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)"], "@test/139.ts: %dflt.%AM7$%AM3$%AM0()": ["@test/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)"], "@test/139.ts: %dflt.%AM13$%AM3$%AM0()": ["@test/139.ts: %dflt.%AM14$%AM13$%AM3$%AM0(unknown)"], "@test/139.ts: %dflt.%AM20$%AM3$%AM0()": ["@test/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)", "@test/139.ts: %dflt.%AM21$%AM20$%AM3$%AM0()"], "@test/139.ts: %dflt.%AM22$%AM3$%AM0()": ["@test/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)"], "@test/139.ts: %dflt.%AM24$%AM3$%AM0()": ["@test/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)"], "@test/139.ts: %dflt.%AM25$%AM3$%AM0()": ["@test/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)"], "@test/139.ts: %dflt.%AM26$%AM3$%AM0()": ["@test/139.ts: %dflt.finishCurrentTooltipAnimation(HTMLElement, boolean)", "@test/139.ts: %dflt.%AM27$%AM26$%AM3$%AM0()"], "@test/139.ts: %dflt.%AM28$%AM3$%AM0()": ["@test/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)"], "@test/139.ts: %dflt.%AM29$%AM3$%AM0()": ["@test/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)"], "@test/139.ts: %dflt.%AM34$%AM3$%AM0()": ["@test/139.ts: %dflt.finishCurrentTooltipAnimation(HTMLElement, boolean)"], "@test/139.ts: %dflt.%AM35$%AM3$%AM0()": ["@test/139.ts: %dflt.finishCurrentTooltipAnimation(HTMLElement, boolean)"], "@test/139.ts: %dflt.%AM38$%AM3$%AM0()": ["@test/139.ts: %dflt.%AM39$%AM38$%AM3$%AM0()"], "@test/139.ts: %dflt.%AM41$%AM3$%AM0()": ["@test/139.ts: %dflt.finishCurrentTooltipAnimation(HTMLElement, boolean)"], "@test/139.ts: %dflt.%AM43$%AM3$%AM0()": ["@test/139.ts: %dflt.finishCurrentTooltipAnimation(HTMLElement, boolean)"], "@test/139.ts: %dflt.%AM44$%AM3$%AM0()": ["@test/139.ts: %dflt.finishCurrentTooltipAnimation(HTMLElement, boolean)"], "@test/139.ts: %dflt.%AM45$%AM3$%AM0()": ["@test/139.ts: %dflt.finishCurrentTooltipAnimation(HTMLElement, boolean)"], "@test/139.ts: %dflt.%AM46$%AM3$%AM0()": ["@test/139.ts: %dflt.finishCurrentTooltipAnimation(HTMLElement, boolean)"], "@test/139.ts: %dflt.%AM47$%AM3$%AM0()": ["@test/139.ts: %dflt.%AM48$%AM47$%AM3$%AM0()"], "@test/139.ts: %dflt.%AM51$%AM3$%AM0()": ["@test/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)"], "@test/139.ts: %dflt.%AM52$%AM3$%AM0()": ["@test/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)"], "@test/139.ts: %dflt.%AM53$%AM3$%AM0()": ["@test/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)"], "@test/139.ts: %dflt.%AM54$%AM3$%AM0()": ["@test/139.ts: %dflt.finishCurrentTooltipAnimation(HTMLElement, boolean)"], "@test/139.ts: %dflt.%AM57$%AM3$%AM0()": ["@test/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)"], "@test/139.ts: %dflt.%AM58$%AM3$%AM0()": ["@test/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)"], "@test/139.ts: %dflt.%AM3$%AM0()": ["@test/139.ts: %dflt.%AM4$%AM3$%AM0()", "@test/139.ts: %dflt.%AM5$%AM3$%AM0()", "@test/139.ts: %dflt.%AM6$%AM3$%AM0()", "@test/139.ts: %dflt.%AM7$%AM3$%AM0()", "@test/139.ts: %dflt.%AM8$%AM3$%AM0()", "@test/139.ts: %dflt.%AM9$%AM3$%AM0()", "@test/139.ts: %dflt.%AM10$%AM3$%AM0()", "@test/139.ts: %dflt.%AM11$%AM3$%AM0()", "@test/139.ts: %dflt.%AM12$%AM3$%AM0()", "@test/139.ts: %dflt.%AM13$%AM3$%AM0()", "@test/139.ts: %dflt.%AM15$%AM3$%AM0()", "@test/139.ts: %dflt.%AM16$%AM3$%AM0()", "@test/139.ts: %dflt.%AM17$%AM3$%AM0()", "@test/139.ts: %dflt.%AM18$%AM3$%AM0()", "@test/139.ts: %dflt.%AM19$%AM3$%AM0()", "@test/139.ts: %dflt.%AM20$%AM3$%AM0()", "@test/139.ts: %dflt.%AM22$%AM3$%AM0()", "@test/139.ts: %dflt.%AM23$%AM3$%AM0()", "@test/139.ts: %dflt.%AM24$%AM3$%AM0()", "@test/139.ts: %dflt.%AM25$%AM3$%AM0()", "@test/139.ts: %dflt.%AM26$%AM3$%AM0()", "@test/139.ts: %dflt.%AM28$%AM3$%AM0()", "@test/139.ts: %dflt.%AM29$%AM3$%AM0()", "@test/139.ts: %dflt.%AM30$%AM3$%AM0()", "@test/139.ts: %dflt.%AM31$%AM3$%AM0()", "@test/139.ts: %dflt.%AM32$%AM3$%AM0()", "@test/139.ts: %dflt.%AM33$%AM3$%AM0()", "@test/139.ts: %dflt.%AM34$%AM3$%AM0()", "@test/139.ts: %dflt.%AM35$%AM3$%AM0()", "@test/139.ts: %dflt.%AM36$%AM3$%AM0()", "@test/139.ts: %dflt.%AM37$%AM3$%AM0()", "@test/139.ts: %dflt.%AM38$%AM3$%AM0()", "@test/139.ts: %dflt.%AM40$%AM3$%AM0()", "@test/139.ts: %dflt.%AM41$%AM3$%AM0()", "@test/139.ts: %dflt.%AM42$%AM3$%AM0()", "@test/139.ts: %dflt.%AM43$%AM3$%AM0()", "@test/139.ts: %dflt.%AM44$%AM3$%AM0()", "@test/139.ts: %dflt.%AM45$%AM3$%AM0()", "@test/139.ts: %dflt.%AM46$%AM3$%AM0()", "@test/139.ts: %dflt.%AM47$%AM3$%AM0()", "@test/139.ts: %dflt.%AM49$%AM3$%AM0()", "@test/139.ts: %dflt.%AM50$%AM3$%AM0()", "@test/139.ts: %dflt.%AM51$%AM3$%AM0()", "@test/139.ts: %dflt.%AM52$%AM3$%AM0()", "@test/139.ts: %dflt.%AM53$%AM3$%AM0()", "@test/139.ts: %dflt.%AM54$%AM3$%AM0()", "@test/139.ts: %dflt.%AM55$%AM3$%AM0()", "@test/139.ts: %dflt.%AM56$%AM3$%AM0()", "@test/139.ts: %dflt.%AM57$%AM3$%AM0()", "@test/139.ts: %dflt.%AM58$%AM3$%AM0()", "@test/139.ts: %dflt.%AM59$%AM3$%AM0()", "@test/139.ts: %dflt.%AM60$%AM3$%AM0()", "@test/139.ts: %dflt.%AM61$%AM3$%AM0()", "@test/139.ts: %dflt.%AM62$%AM3$%AM0()", "@test/139.ts: %dflt.%AM63$%AM3$%AM0()"], "@test/139.ts: %dflt.%AM64$%AM0()": ["@test/139.ts: %dflt.%AM65$%AM64$%AM0()", "@test/139.ts: %dflt.%AM66$%AM64$%AM0()", "@test/139.ts: %dflt.%AM67$%AM64$%AM0()"], "@test/139.ts: %dflt.%AM70$%AM68$%AM0()": ["@test/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)"], "@test/139.ts: %dflt.%AM68$%AM0()": ["@test/139.ts: %dflt.%AM69$%AM68$%AM0()", "@test/139.ts: %dflt.%AM70$%AM68$%AM0()"], "@test/139.ts: %dflt.%AM73$%AM71$%AM0()": ["@test/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)", "@test/139.ts: %dflt.finishCurrentTooltipAnimation(HTMLElement, boolean)"], "@test/139.ts: %dflt.%AM71$%AM0()": ["@test/139.ts: %dflt.%AM72$%AM71$%AM0()", "@test/139.ts: %dflt.%AM73$%AM71$%AM0()", "@test/139.ts: %dflt.%AM74$%AM71$%AM0()"], "@test/139.ts: %dflt.%AM77$%AM75$%AM0()": ["@test/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)", "@test/139.ts: %dflt.finishCurrentTooltipAnimation(HTMLElement, boolean)"], "@test/139.ts: %dflt.%AM78$%AM75$%AM0()": ["@test/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)"], "@test/139.ts: %dflt.%AM80$%AM75$%AM0()": ["@test/139.ts: %dflt.finishCurrentTooltipAnimation(HTMLElement, boolean)", "@test/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)"], "@test/139.ts: %dflt.%AM81$%AM75$%AM0()": ["@test/139.ts: %dflt.finishCurrentTooltipAnimation(HTMLElement, boolean)", "@test/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)"], "@test/139.ts: %dflt.%AM88$%AM75$%AM0()": ["@test/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)"], "@test/139.ts: %dflt.%AM89$%AM75$%AM0()": ["@test/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)"], "@test/139.ts: %dflt.%AM75$%AM0()": ["@test/139.ts: %dflt.%AM76$%AM75$%AM0()", "@test/139.ts: %dflt.%AM77$%AM75$%AM0()", "@test/139.ts: %dflt.%AM78$%AM75$%AM0()", "@test/139.ts: %dflt.%AM79$%AM75$%AM0()", "@test/139.ts: %dflt.%AM80$%AM75$%AM0()", "@test/139.ts: %dflt.%AM81$%AM75$%AM0()", "@test/139.ts: %dflt.%AM82$%AM75$%AM0()", "@test/139.ts: %dflt.%AM83$%AM75$%AM0()", "@test/139.ts: %dflt.%AM84$%AM75$%AM0()", "@test/139.ts: %dflt.%AM85$%AM75$%AM0()", "@test/139.ts: %dflt.%AM86$%AM75$%AM0()", "@test/139.ts: %dflt.%AM87$%AM75$%AM0()", "@test/139.ts: %dflt.%AM88$%AM75$%AM0()", "@test/139.ts: %dflt.%AM89$%AM75$%AM0()"], "@test/139.ts: %dflt.%AM91$%AM90$%AM0()": ["@test/139.ts: %dflt.finishCurrentTooltipAnimation(HTMLElement, boolean)", "@test/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)"], "@test/139.ts: %dflt.%AM92$%AM90$%AM0()": ["@test/139.ts: %dflt.finishCurrentTooltipAnimation(HTMLElement, boolean)", "@test/139.ts: %dflt.assertTooltipInstance(MatTooltip, boolean)"], "@test/139.ts: %dflt.%AM90$%AM0()": ["@test/139.ts: %dflt.%AM91$%AM90$%AM0()", "@test/139.ts: %dflt.%AM92$%AM90$%AM0()"], "@test/139.ts: %dflt.%AM0()": ["@test/139.ts: %dflt.%AM1$%AM0()", "@test/139.ts: %dflt.%AM3$%AM0()", "@test/139.ts: %dflt.%AM64$%AM0()", "@test/139.ts: %dflt.%AM68$%AM0()", "@test/139.ts: %dflt.%AM71$%AM0()", "@test/139.ts: %dflt.%AM75$%AM0()", "@test/139.ts: %dflt.%AM90$%AM0()"]}}
{"source_code": "import { without } from 'lodash';\nimport { FormattedLine, Span, JSONLogs, TIMESTAMP_LENGTH } from './types';\nimport {\n  formatCaller,\n  formatKeyValuePair,\n  formatLevel,\n  formatMessage,\n  formatStackTrace,\n  formatTime,\n} from './formatters';\nfunction removeKnownKeys(keys: string[]) {\n  return without(keys, 'time', 'level', 'caller', 'message', 'stack_trace');\n}\nexport function formatJSONLine(\n  rawText: string,\n  withTimestamps?: boolean\n): FormattedLine[] {\n  const spans: Span[] = [];\n  const lines: FormattedLine[] = [];\n  let line = '';\n  const text = withTimestamps ? rawText.substring(TIMESTAMP_LENGTH) : rawText;\n  const json: JSONLogs = JSON.parse(text);\n  const { time, level, caller, message, stack_trace: stackTrace } = json;\n  const keys = removeKnownKeys(Object.keys(json));\n  if (withTimestamps) {\n    const timestamp = rawText.substring(0, TIMESTAMP_LENGTH);\n    spans.push({ text: timestamp });\n    line += `${timestamp} `;\n  }\n  line += formatTime(time, spans, line);\n  line += formatLevel(level, spans, line);\n  line += formatCaller(caller, spans, line);\n  line += formatMessage(message, spans, line, !!keys.length);\n  keys.forEach((key, idx) => {\n    line += formatKeyValuePair(\n      key,\n      json[key],\n      spans,\n      line,\n      idx === keys.length - 1\n    );\n  });\n  lines.push({ line, spans });\n  formatStackTrace(stackTrace, lines);\n  return lines;\n}", "llm_cg": {"formatJSONLine(rawText: string, withTimestamps?: boolean)": ["removeKnownKeys(string[])", "formatTime(unknown, unknown, unknown)", "formatLevel(unknown, unknown, unknown)", "formatCaller(unknown, unknown, unknown)", "formatMessage(unknown, unknown, unknown, unknown)", "formatKeyValuePair(unknown, unknown, unknown, unknown, unknown)", "formatStackTrace(unknown, unknown)"]}, "static_cg": {"@test/140.ts: %dflt.formatJSONLine(string, boolean)": ["@test/140.ts: %dflt.%AM0$formatJSONLine([line, json, spans, keys], unknown, unknown)", "@test/140.ts: %dflt.removeKnownKeys(string[])"]}}
{"source_code": "import {DataSource} from '@angular/cdk/collections';\nimport {Component} from '@angular/core';\nimport {CdkTableModule} from '@angular/cdk/table';\nimport {BehaviorSubject, Observable} from 'rxjs';\nexport interface PeriodicElement {\n  name: string;\n  position: number;\n  weight: number;\n  symbol: string;\n}\nconst ELEMENT_DATA: PeriodicElement[] = [\n  {position: 1, name: 'Hydrogen', weight: 1.0079, symbol: 'H'},\n  {position: 2, name: 'Helium', weight: 4.0026, symbol: 'He'},\n  {position: 3, name: 'Lithium', weight: 6.941, symbol: 'Li'},\n  {position: 4, name: 'Beryllium', weight: 9.0122, symbol: 'Be'},\n  {position: 5, name: 'Boron', weight: 10.811, symbol: 'B'},\n  {position: 6, name: 'Carbon', weight: 12.0107, symbol: 'C'},\n  {position: 7, name: 'Nitrogen', weight: 14.0067, symbol: 'N'},\n  {position: 8, name: 'Oxygen', weight: 15.9994, symbol: 'O'},\n  {position: 9, name: 'Fluorine', weight: 18.9984, symbol: 'F'},\n  {position: 10, name: 'Neon', weight: 20.1797, symbol: 'Ne'},\n];\n@Component({\n  selector: 'cdk-table-basic-example',\n  styleUrl: 'cdk-table-basic-example.css',\n  templateUrl: 'cdk-table-basic-example.html',\n  imports: [CdkTableModule],\n})\nexport class CdkTableBasicExample {\n  displayedColumns: string[] = ['position', 'name', 'weight', 'symbol'];\n  dataSource = new ExampleDataSource();\n}\nexport class ExampleDataSource extends DataSource<PeriodicElement> {\n  data = new BehaviorSubject<PeriodicElement[]>(ELEMENT_DATA);\n  connect(): Observable<PeriodicElement[]> {\n    return this.data;\n  }\n  disconnect() {}\n}", "llm_cg": {"CdkTableBasicExample.constructor()": ["ExampleDataSource.constructor()"], "ExampleDataSource.connect()": []}, "static_cg": {}}
{"source_code": "import { formatDate } from 'lib/date';\nimport { formatLongNumber } from 'lib/format';\nexport function renderNumberLabels(label: string) {\n  return +label > 1000 ? formatLongNumber(+label) : label;\n}\nexport function renderDateLabels(unit: string, locale: string) {\n  return (label: string, index: number, values: any[]) => {\n    const d = new Date(values[index].value);\n    switch (unit) {\n      case 'minute':\n        return formatDate(d, 'h:mm', locale);\n      case 'hour':\n        return formatDate(d, 'p', locale);\n      case 'day':\n        return formatDate(d, 'MMM d', locale);\n      case 'month':\n        return formatDate(d, 'MMM', locale);\n      case 'year':\n        return formatDate(d, 'YYY', locale);\n      default:\n        return label;\n    }\n  };\n}", "llm_cg": {"renderNumberLabels(label: string)": ["formatLongNumber(label: number)"], "renderDateLabels(unit: string, locale: string)": ["%AM0$anonymous(label: string, index: number, values: any[])"], "%AM0$anonymous(label: string, index: number, values: any[])": ["%AM1$anonymous(unit: string, locale: string, d: Date, label: string)"], "%AM1$anonymous(unit: string, locale: string, d: Date, label: string)": ["formatDate(date: Date, format: string, locale: string)"]}, "static_cg": {}}
{"source_code": "import BoundingRect from 'zrender/src/core/BoundingRect';\nimport * as vec2 from 'zrender/src/core/vector';\nimport * as polygonContain from 'zrender/src/contain/polygon';\nimport { GeoJSON, GeoProjection, GeoSVGGraphicRoot } from './geoTypes';\nimport * as matrix from 'zrender/src/core/matrix';\nimport Element from 'zrender/src/Element';\nimport { each } from 'zrender/src/core/util';\nconst TMP_TRANSFORM = [] as number[];\nfunction transformPoints(points: number[][], transform: matrix.MatrixArray) {\n    for (let p = 0; p < points.length; p++) {\n        vec2.applyTransform(points[p], points[p], transform);\n    }\n}\nfunction updateBBoxFromPoints(\n    points: ArrayLike<number>[],\n    min: vec2.VectorArray,\n    max: vec2.VectorArray,\n    projection: GeoProjection\n) {\n    for (let i = 0; i < points.length; i++) {\n        let p = points[i];\n        if (projection) {\n            // projection may return null point.\n            p = projection.project(p as number[]);\n        }\n        if (p && isFinite(p[0]) && isFinite(p[1])) {\n            vec2.min(min, min, p as vec2.VectorArray);\n            vec2.max(max, max, p as vec2.VectorArray);\n        }\n    }\n}\nfunction centroid(points: number[][]) {\n    let signedArea = 0;\n    let cx = 0;\n    let cy = 0;\n    const len = points.length;\n    let x0 = points[len - 1][0];\n    let y0 = points[len - 1][1];\n    // Polygon should been closed.\n    for (let i = 0; i < len; i++) {\n        const x1 = points[i][0];\n        const y1 = points[i][1];\n        const a = x0 * y1 - x1 * y0;\n        signedArea += a;\n        cx += (x0 + x1) * a;\n        cy += (y0 + y1) * a;\n        x0 = x1;\n        y0 = y1;\n    }\n    return signedArea\n        ? [cx / signedArea / 3, cy / signedArea / 3, signedArea]\n        : [points[0][0] || 0, points[0][1] || 0];\n}\nexport abstract class Region {\n    readonly name: string;\n    readonly type: 'geoJSON' | 'geoSVG';\n    protected _center: number[];\n    protected _rect: BoundingRect;\n    constructor(\n        name: string\n    ) {\n        this.name = name;\n    }\n    setCenter(center: number[]) {\n        this._center = center;\n    }\n    getCenter() {\n        let center = this._center;\n        if (!center) {\n            // In most cases there are no need to calculate this center.\n            // So calculate only when called.\n            center = this._center = this.calcCenter();\n        }\n        return center;\n    }\n    abstract calcCenter(): number[];\n}\nexport class GeoJSONPolygonGeometry {\n    readonly type = 'polygon';\n    exterior: number[][];\n    interiors?: number[][][];\n    constructor(exterior: number[][], interiors: number[][][]) {\n        this.exterior = exterior;\n        this.interiors = interiors;\n    }\n}\nexport class GeoJSONLineStringGeometry {\n    readonly type = 'linestring';\n    points: number[][][];\n    constructor(points: number[][][]) {\n        this.points = points;\n    }\n}\nexport class GeoJSONRegion extends Region {\n    readonly type = 'geoJSON';\n    readonly geometries: (GeoJSONPolygonGeometry | GeoJSONLineStringGeometry)[];\n    // Injected outside.\n    properties: GeoJSON['features'][0]['properties'];\n    constructor(\n        name: string,\n        geometries: GeoJSONRegion['geometries'],\n        cp: GeoJSON['features'][0]['properties']['cp']\n    ) {\n        super(name);\n        this.geometries = geometries;\n        this._center = cp && [cp[0], cp[1]];\n    }\n    calcCenter() {\n        const geometries = this.geometries;\n        let largestGeo: GeoJSONPolygonGeometry;\n        let largestGeoSize = 0;\n        for (let i = 0; i < geometries.length; i++) {\n            const geo = geometries[i] as GeoJSONPolygonGeometry;\n            const exterior = geo.exterior;\n            // Simple trick to use points count instead of polygon area as region size.\n            // Ignore linestring\n            const size = exterior && exterior.length;\n            if (size > largestGeoSize) {\n                largestGeo = geo;\n                largestGeoSize = size;\n            }\n        }\n        if (largestGeo) {\n            return centroid(largestGeo.exterior);\n        }\n        // from bounding rect by default.\n        const rect = this.getBoundingRect();\n        return [\n            rect.x + rect.width / 2,\n            rect.y + rect.height / 2\n        ];\n    }\n    getBoundingRect(projection?: GeoProjection): BoundingRect {\n        let rect = this._rect;\n        // Always recalculate if using projection.\n        if (rect && !projection) {\n            return rect;\n        }\n        const min = [Infinity, Infinity];\n        const max = [-Infinity, -Infinity];\n        const geometries = this.geometries;\n        each(geometries, geo => {\n            if (geo.type === 'polygon') {\n                // Doesn't consider hole\n                updateBBoxFromPoints(geo.exterior, min, max, projection);\n            }\n            else {\n                each(geo.points, (points) => {\n                    updateBBoxFromPoints(points, min, max, projection);\n                });\n            }\n        });\n        // Normalie invalid bounding.\n        if (!(isFinite(min[0]) && isFinite(min[1]) && isFinite(max[0]) && isFinite(max[1]))) {\n            min[0] = min[1] = max[0] = max[1] = 0;\n        }\n        rect = new BoundingRect(\n            min[0], min[1], max[0] - min[0], max[1] - min[1]\n        );\n        if (!projection) {\n            this._rect = rect;\n        }\n        return rect;\n    }\n    contain(coord: number[]): boolean {\n        const rect = this.getBoundingRect();\n        const geometries = this.geometries;\n        if (!rect.contain(coord[0], coord[1])) {\n            return false;\n        }\n        loopGeo: for (let i = 0, len = geometries.length; i < len; i++) {\n            const geo = geometries[i];\n            // Only support polygon.\n            if (geo.type !== 'polygon') {\n                continue;\n            }\n            const exterior = geo.exterior;\n            const interiors = geo.interiors;\n            if (polygonContain.contain(exterior, coord[0], coord[1])) {\n                // Not in the region if point is in the hole.\n                for (let k = 0; k < (interiors ? interiors.length : 0); k++) {\n                    if (polygonContain.contain(interiors[k], coord[0], coord[1])) {\n                        continue loopGeo;\n                    }\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    transformTo(x: number, y: number, width: number, height: number): void {\n        let rect = this.getBoundingRect();\n        const aspect = rect.width / rect.height;\n        if (!width) {\n            width = aspect * height;\n        }\n        else if (!height) {\n            height = width / aspect;\n        }\n        const target = new BoundingRect(x, y, width, height);\n        const transform = rect.calculateTransform(target);\n        const geometries = this.geometries;\n        for (let i = 0; i < geometries.length; i++) {\n            const geo = geometries[i];\n            if (geo.type === 'polygon') {\n                transformPoints(geo.exterior, transform);\n                each(geo.interiors, interior => {\n                    transformPoints(interior, transform);\n                });\n            }\n            else {\n                each(geo.points, points => {\n                    transformPoints(points, transform);\n                });\n            }\n        }\n        rect = this._rect;\n        rect.copy(target);\n        // Update center\n        this._center = [\n            rect.x + rect.width / 2,\n            rect.y + rect.height / 2\n        ];\n    }\n    cloneShallow(name: string): GeoJSONRegion {\n        name == null && (name = this.name);\n        const newRegion = new GeoJSONRegion(name, this.geometries, this._center);\n        newRegion._rect = this._rect;\n        newRegion.transformTo = null; // Simply avoid to be called.\n        return newRegion;\n    }\n}\nexport class GeoSVGRegion extends Region {\n    readonly type = 'geoSVG';\n    // Can only be used to calculate, but not be modified.\n    // Because this el may not belong to this view,\n    // but been displaying on some other view.\n    private _elOnlyForCalculate: Element;\n    constructor(\n        name: string,\n        elOnlyForCalculate: Element\n    ) {\n        super(name);\n        this._elOnlyForCalculate = elOnlyForCalculate;\n    }\n    calcCenter(): number[] {\n        const el = this._elOnlyForCalculate;\n        const rect = el.getBoundingRect();\n        const center = [\n            rect.x + rect.width / 2,\n            rect.y + rect.height / 2\n        ];\n        const mat = matrix.identity(TMP_TRANSFORM);\n        let target = el;\n        while (target && !(target as GeoSVGGraphicRoot).isGeoSVGGraphicRoot) {\n            matrix.mul(mat, target.getLocalTransform(), mat);\n            target = target.parent;\n        }\n        matrix.invert(mat, mat);\n        vec2.applyTransform(center, center, mat);\n        return center;\n    }\n}", "llm_cg": {"GeoJSONRegion.GeoJSONRegion(string,(GeoJSONPolygonGeometry|GeoJSONLineStringGeometry)[],GeoJSON['features'][0]['properties']['cp'])": ["Region.%AM0$Region(string)"], "GeoJSONRegion.getCenter()": ["GeoJSONRegion.%AM1$getCenter()"], "GeoJSONRegion.calcCenter()": ["GeoJSONRegion.getBoundingRect()", "GeoJSONRegion.%AM2$calcCenter()"], "GeoJSONRegion.getBoundingRect(GeoProjection?)": ["updateBBoxFromPoints(ArrayLike<number>[],vec2.VectorArray,vec2.VectorArray,GeoProjection)", "BoundingRect.%AM3$BoundingRect(number,number,number,number)", "GeoJSONRegion.%AM4$getBoundingRect(unknown)"], "GeoJSONRegion.contain(number[])": ["GeoJSONRegion.getBoundingRect()"], "GeoJSONRegion.transformTo(number,number,number,number)": ["GeoJSONRegion.getBoundingRect()", "transformPoints(unknown, matrix.MatrixArray)"], "GeoJSONRegion.cloneShallow(string)": ["GeoJSONRegion.%AM5$cloneShallow(string)"], "GeoSVGRegion.GeoSVGRegion(string, Element)": ["Region.%AM6$Region(string)"], "GeoSVGRegion.calcCenter()": ["Element.getBoundingRect()", "matrix.identity(matrix.MatrixArray)", "matrix.mul(matrix.MatrixArray, matrix.MatrixArray, matrix.MatrixArray)", "matrix.invert(matrix.MatrixArray, matrix.MatrixArray)", "vec2.applyTransform(vec2.VectorArray, vec2.VectorArray, matrix.MatrixArray)"]}, "static_cg": {"@test/143.ts: Region.getCenter()": ["@test/143.ts: GeoJSONRegion.calcCenter()"], "@test/143.ts: GeoJSONRegion.calcCenter()": ["@test/143.ts: %dflt.centroid(number[][])", "@test/143.ts: GeoJSONRegion.getBoundingRect(GeoProjection)"], "@test/143.ts: GeoJSONRegion.getBoundingRect(GeoProjection)": ["@test/143.ts: GeoJSONRegion.%AM0$getBoundingRect([min, max, projection], unknown)"], "@test/143.ts: GeoJSONRegion.contain(number[])": ["@test/143.ts: GeoJSONRegion.getBoundingRect(GeoProjection)"], "@test/143.ts: GeoJSONRegion.transformTo(number, number, number, number)": ["@test/143.ts: GeoJSONRegion.getBoundingRect(GeoProjection)", "@test/143.ts: %dflt.transformPoints(number[][], matrix.MatrixArray)", "@test/143.ts: GeoJSONRegion.%AM2$transformTo([transform], unknown)", "@test/143.ts: GeoJSONRegion.%AM3$transformTo([transform], unknown)"], "@test/143.ts: GeoJSONRegion.cloneShallow(string)": ["@test/143.ts: GeoJSONRegion.constructor(string, IndexedAccessType, IndexedAccessType)"], "@test/143.ts: GeoJSONRegion.%AM1$%AM0$getBoundingRect(unknown)": ["@test/143.ts: %dflt.updateBBoxFromPoints(ArrayLike<number>[], vec2.VectorArray, vec2.VectorArray, GeoProjection)"], "@test/143.ts: GeoJSONRegion.%AM0$getBoundingRect([min, max, projection], unknown)": ["@test/143.ts: %dflt.updateBBoxFromPoints(ArrayLike<number>[], vec2.VectorArray, vec2.VectorArray, GeoProjection)", "@test/143.ts: GeoJSONRegion.%AM1$%AM0$getBoundingRect(unknown)"], "@test/143.ts: GeoJSONRegion.%AM2$transformTo([transform], unknown)": ["@test/143.ts: %dflt.transformPoints(number[][], matrix.MatrixArray)"], "@test/143.ts: GeoJSONRegion.%AM3$transformTo([transform], unknown)": ["@test/143.ts: %dflt.transformPoints(number[][], matrix.MatrixArray)"]}}
{"source_code": "import { connect } from 'react-redux';\nimport { translate } from '../../../base/i18n/functions';\nimport { IconDotsHorizontal } from '../../../base/icons/svg';\nimport AbstractButton, { IProps as AbstractButtonProps } from '../../../base/toolbox/components/AbstractButton';\ninterface IProps extends AbstractButtonProps {\n    isOpen: boolean;\n    onKeyDown: Function;\n}\nclass OverflowToggleButton extends AbstractButton<IProps> {\n    accessibilityLabel = 'toolbar.accessibilityLabel.moreActions';\n    toggledAccessibilityLabel = 'toolbar.accessibilityLabel.closeMoreActions';\n    icon = IconDotsHorizontal;\n    label = 'toolbar.moreActions';\n    toggledLabel = 'toolbar.moreActions';\n    tooltip = 'toolbar.moreActions';\n    _isToggled() {\n        return this.props.isOpen;\n    }\n    _onKeyDown() {\n        this.props.onKeyDown();\n    }\n}\nexport default connect()(translate(OverflowToggleButton));", "llm_cg": {"OverflowToggleButton._isToggled()": [], "OverflowToggleButton._onKeyDown()": []}, "static_cg": {}}
{"source_code": "// @strict: true\n// @noEmit: true\n// @lib: esnext\nlet cond: boolean;\nasync function len(s: string) {\n    return s.length;\n}\nasync function f1() {\n    let x: string | number | boolean;\n    x = \"\";\n    while (cond) {\n        x = await len(x);\n        x;\n    }\n    x;\n}\nasync function f2() {\n    let x: string | number | boolean;\n    x = \"\";\n    while (cond) {\n        x;\n        x = await len(x);\n    }\n    x;\n}\ndeclare function foo(x: string): Promise<number>;\ndeclare function foo(x: number): Promise<string>;\nasync function g1() {\n    let x: string | number | boolean;\n    x = \"\";\n    while (cond) {\n        x = await foo(x);\n        x;\n    }\n    x;\n}\nasync function g2() {\n    let x: string | number | boolean;\n    x = \"\";\n    while (cond) {\n        x;\n        x = await foo(x);\n    }\n    x;\n}\nasync function asNumber(x: string | number): Promise<number> {\n    return +x;\n}\nasync function h1() {\n    let x: string | number | boolean;\n    x = \"0\";\n    while (cond) {\n        x = +x + 1;\n        x;\n    }\n}\nasync function h2() {\n    let x: string | number | boolean;\n    x = \"0\";\n    while (cond) {\n        x = await asNumber(x) + 1;\n        x;\n    }\n}\nasync function h3() {\n    let x: string | number | boolean;\n    x = \"0\";\n    while (cond) {\n        let y = await asNumber(x);\n        x = y + 1;\n        x;\n    }\n}\nasync function h4() {\n    let x: string | number | boolean;\n    x = \"0\";\n    while (cond) {\n        x;\n        let y = await asNumber(x);\n        x = y + 1;\n        x;\n    }\n}\n// repro #51115\nasync function get_things(_: number | undefined) {\n    return [0];\n}\nasync function foobar() {\n    let before: number | undefined = undefined;\n    for (let i = 0; i < 2; i++) {\n        const results = await get_things(before);\n        before = results[0];\n    }\n}\n// repro #43047#issuecomment-821453073\ndeclare function foox(x: string | undefined): Promise<string>\nasync () => {\n  let bar: string | undefined = undefined;\n  do {\n    const baz = await foox(bar);\n    bar = baz\n  } while (bar)\n}\n// repro #43047#issuecomment-874221939\ndeclare function myQuery(input: { lastId: number | undefined }): Promise<{ entities: number[] }>;\nasync function myFunc(): Promise<void> {\n  let lastId: number | undefined = undefined;\n  while (true) {\n    const { entities } = await myQuery({\n        lastId,\n    });\n    lastId = entities[entities.length - 1];\n  }\n}", "llm_cg": {"f1()": ["%AM0$len(string)"], "f2()": ["%AM0$len(string)"], "g1()": ["%AM0$foo(string | number)"], "g2()": ["%AM0$foo(string | number)"], "h2()": ["%AM0$asNumber(string | number)"], "h3()": ["%AM0$asNumber(string | number)"], "h4()": ["%AM0$asNumber(string | number)"], "foobar()": ["%AM0$get_things(number | undefined)"], "%AMX$(string | undefined)": ["%AM0$foox(string | undefined)"], "myFunc()": ["%AM0$myQuery({ lastId: number | undefined })"]}, "static_cg": {"@test/145.ts: %dflt.f1()": ["@test/145.ts: %dflt.len(string)"], "@test/145.ts: %dflt.f2()": ["@test/145.ts: %dflt.len(string)"], "@test/145.ts: %dflt.g1()": ["@test/145.ts: %dflt.foo(string)"], "@test/145.ts: %dflt.g2()": ["@test/145.ts: %dflt.foo(string)"], "@test/145.ts: %dflt.h2()": ["@test/145.ts: %dflt.asNumber(string|number)"], "@test/145.ts: %dflt.h3()": ["@test/145.ts: %dflt.asNumber(string|number)"], "@test/145.ts: %dflt.h4()": ["@test/145.ts: %dflt.asNumber(string|number)"], "@test/145.ts: %dflt.foobar()": ["@test/145.ts: %dflt.get_things(number|undefined)"], "@test/145.ts: %dflt.myFunc()": ["@test/145.ts: %dflt.myQuery(@test/145.ts: %AC$0)"], "@test/145.ts: %dflt.%AM0()": ["@test/145.ts: %dflt.foox(string|undefined)"]}}
{"source_code": "import { Test } from '@nestjs/testing';\nimport { expect } from 'chai';\nimport { Controller, Injectable, Module } from '@nestjs/common';\nclass B {}\n@Injectable()\nclass A {\n  constructor(b: B) {}\n}\n@Injectable()\nclass BImpl {\n  constructor(a: A) {}\n}\n@Controller()\nclass AppController {\n  constructor(a: A) {}\n}\n@Module({\n  imports: [],\n  controllers: [AppController],\n  providers: [A, { provide: B, useClass: BImpl }],\n})\nexport class AppModule {}\ndescribe('Circular custom providers', () => {\n  it('should throw an exception (useClass + regular provider)', async () => {\n    try {\n      const builder = Test.createTestingModule({\n        imports: [AppModule],\n      });\n      await builder.compile();\n      expect(true).to.be.eql(false);\n    } catch (err) {\n      expect(err.message).to.be.eql(\n        'A circular dependency has been detected inside \"A\". Please, make sure that each side of a bidirectional relationships are decorated with \"forwardRef()\". Note that circular relationships between custom providers (e.g., factories) are not supported since functions cannot be called more than once.',\n      );\n    }\n  });\n  it('should throw an exception (2 factories)', async () => {\n    try {\n      const builder = Test.createTestingModule({\n        providers: [\n          { provide: 'ABC', useFactory: () => ({}), inject: ['DEF'] },\n          { provide: 'DEF', useFactory: () => ({}), inject: ['ABC'] },\n        ],\n      });\n      await builder.compile();\n      expect(true).to.be.eql(false);\n    } catch (err) {\n      expect(err.message).to.be.eql(\n        'A circular dependency has been detected inside \"ABC\". Please, make sure that each side of a bidirectional relationships are decorated with \"forwardRef()\". Note that circular relationships between custom providers (e.g., factories) are not supported since functions cannot be called more than once.',\n      );\n    }\n  });\n});", "llm_cg": {"A.constructor(B)": [], "BImpl.constructor(A)": [], "AppController.constructor(A)": [], "Anonymous.%AM0$it(unknown)": ["Anonymous.%AM1$try(unknown)"], "Anonymous.%AM1$try(unknown)": ["Test.createTestingModule(AppModule)", "AM0$compile()", "expect(true).to.be.eql(false)", "Anonymous.%AM2$catch(unknown)"], "Anonymous.%AM2$catch(unknown)": ["expect(err.message).to.be.eql(unknown)"], "Anonymous.%AM3$it(unknown)": ["Anonymous.%AM4$try(unknown)"], "Anonymous.%AM4$try(unknown)": ["Test.createTestingModule(unknown)", "AM1$compile()", "expect(true).to.be.eql(false)", "Anonymous.%AM5$catch(unknown)"], "Anonymous.%AM5$catch(unknown)": ["expect(err.message).to.be.eql(unknown)"], "describe.%(aA2$test(Circular custom providers)": ["Anonymous.%AM6$it(unknown)", "Anonymous.%AM7$it(unknown)"], "Anonymous.%AM6$it(unknown)": [], "Anonymous.%AM7$it(unknown)": []}, "static_cg": {"@test/146.ts: %dflt.[static]%dflt()": ["@test/146.ts: %dflt.%AM0()"], "@test/146.ts: %dflt.%AM0()": ["@test/146.ts: %dflt.%AM1$%AM0()", "@test/146.ts: %dflt.%AM2$%AM0()"]}}
{"source_code": "import {DragDropModule} from '@angular/cdk/drag-drop';\nimport {Component, NgModule} from '@angular/core';\n@Component({\n  standalone: false,\n  template: `\n    <div cdkDropListGroup>\n      <div cdkDropList>\n        <div cdkDrag>\n          <span cdkDragHandle>handle</span>\n          <ng-template cdkDragPlaceholder>Placeholder</ng-template>\n          <ng-template cdkDragPreview>Preview</ng-template>\n        </div>\n      </div>\n    </div>\n  `,\n})\nexport class TestComponent {}\n@NgModule({\n  imports: [DragDropModule],\n  declarations: [TestComponent],\n  bootstrap: [TestComponent],\n})\nexport class AppModule {}", "llm_cg": {}, "static_cg": {}}
{"source_code": "import { Platform, UnavailabilityError, uuid } from 'expo-modules-core';\nimport NotificationScheduler from './NotificationScheduler';\nimport {\n  NativeCalendarTriggerInput,\n  NativeDailyTriggerInput,\n  NativeDateTriggerInput,\n  NativeNotificationTriggerInput,\n  NativeTimeIntervalTriggerInput,\n  NativeWeeklyTriggerInput,\n  NativeMonthlyTriggerInput,\n  NativeYearlyTriggerInput,\n} from './NotificationScheduler.types';\nimport {\n  NotificationRequestInput,\n  NotificationTriggerInput,\n  SchedulableTriggerInputTypes,\n} from './Notifications.types';\nexport default async function scheduleNotificationAsync(\n  request: NotificationRequestInput\n): Promise<string> {\n  if (!NotificationScheduler.scheduleNotificationAsync) {\n    throw new UnavailabilityError('Notifications', 'scheduleNotificationAsync');\n  }\n  return await NotificationScheduler.scheduleNotificationAsync(\n    request.identifier ?? uuid.v4(),\n    request.content,\n    parseTrigger(request.trigger)\n  );\n}\ntype ValidTriggerDateComponents = 'month' | 'day' | 'weekday' | 'hour' | 'minute';\nexport function parseTrigger(\n  userFacingTrigger: NotificationTriggerInput\n): NativeNotificationTriggerInput {\n  if (userFacingTrigger === null) {\n    return null;\n  }\n  if (userFacingTrigger === undefined) {\n    throw new TypeError(\n      'Encountered an `undefined` notification trigger. If you want to trigger the notification immediately, pass in an explicit `null` value.'\n    );\n  }\n  const dateTrigger = parseDateTrigger(userFacingTrigger);\n  if (dateTrigger) {\n    return dateTrigger;\n  }\n  const calendarTrigger = parseCalendarTrigger(userFacingTrigger);\n  if (calendarTrigger) {\n    return calendarTrigger;\n  }\n  const dailyTrigger = parseDailyTrigger(userFacingTrigger);\n  if (dailyTrigger) {\n    return dailyTrigger;\n  }\n  const weeklyTrigger = parseWeeklyTrigger(userFacingTrigger);\n  if (weeklyTrigger) {\n    return weeklyTrigger;\n  }\n  const monthlyTrigger = parseMonthlyTrigger(userFacingTrigger);\n  if (monthlyTrigger) {\n    return monthlyTrigger;\n  }\n  const yearlyTrigger = parseYearlyTrigger(userFacingTrigger);\n  if (yearlyTrigger) {\n    return yearlyTrigger;\n  }\n  const timeIntervalTrigger = parseTimeIntervalTrigger(userFacingTrigger);\n  if (timeIntervalTrigger) {\n    return timeIntervalTrigger;\n  }\n  return Platform.select({\n    default: null, // There's no notion of channels on platforms other than Android.\n    android: {\n      type: 'channel',\n      channelId:\n        typeof userFacingTrigger === 'object' &&\n        userFacingTrigger !== null &&\n        !(userFacingTrigger instanceof Date)\n          ? userFacingTrigger?.channelId\n          : undefined,\n    },\n  });\n}\nfunction parseCalendarTrigger(\n  trigger: NotificationTriggerInput\n): NativeCalendarTriggerInput | undefined {\n  if (\n    trigger !== null &&\n    typeof trigger === 'object' &&\n    'type' in trigger &&\n    trigger.type === SchedulableTriggerInputTypes.CALENDAR\n  ) {\n    const { repeats, ...calendarTrigger } = trigger;\n    return { type: 'calendar', value: calendarTrigger, repeats };\n  }\n  return undefined;\n}\nfunction parseDateTrigger(trigger: NotificationTriggerInput): NativeDateTriggerInput | undefined {\n  if (trigger instanceof Date || typeof trigger === 'number') {\n    return { type: 'date', timestamp: toTimestamp(trigger) };\n  } else if (\n    typeof trigger === 'object' &&\n    trigger !== null &&\n    'type' in trigger &&\n    trigger.type === SchedulableTriggerInputTypes.DATE &&\n    'date' in trigger &&\n    trigger.date instanceof Date\n  ) {\n    const result: NativeDateTriggerInput = {\n      type: 'date',\n      timestamp: toTimestamp(trigger.date),\n    };\n    if (trigger.channelId) {\n      result.channelId = trigger.channelId;\n    }\n    return result;\n  } else {\n    return undefined;\n  }\n}\nfunction toTimestamp(date: number | Date) {\n  if (date instanceof Date) {\n    return date.getTime();\n  }\n  return date;\n}\nfunction parseDailyTrigger(trigger: NotificationTriggerInput): NativeDailyTriggerInput | undefined {\n  if (\n    trigger !== null &&\n    typeof trigger === 'object' &&\n    'type' in trigger &&\n    trigger.type === SchedulableTriggerInputTypes.DAILY\n  ) {\n    validateDateComponentsInTrigger(trigger, ['hour', 'minute']);\n    const result: NativeDailyTriggerInput = {\n      type: 'daily',\n      hour: trigger.hour ?? placeholderDateComponentValue,\n      minute: trigger.minute ?? placeholderDateComponentValue,\n    };\n    if (trigger.channelId) {\n      result.channelId = trigger.channelId;\n    }\n    return result;\n  }\n  return undefined;\n}\nfunction parseWeeklyTrigger(\n  trigger: NotificationTriggerInput\n): NativeWeeklyTriggerInput | undefined {\n  if (\n    trigger !== null &&\n    typeof trigger === 'object' &&\n    'type' in trigger &&\n    trigger.type === SchedulableTriggerInputTypes.WEEKLY\n  ) {\n    validateDateComponentsInTrigger(trigger, ['weekday', 'hour', 'minute']);\n    const result: NativeWeeklyTriggerInput = {\n      type: 'weekly',\n      weekday: trigger.weekday ?? placeholderDateComponentValue,\n      hour: trigger.hour ?? placeholderDateComponentValue,\n      minute: trigger.minute ?? placeholderDateComponentValue,\n    };\n    if (trigger.channelId) {\n      result.channelId = trigger.channelId;\n    }\n    return result;\n  }\n  return undefined;\n}\nfunction parseMonthlyTrigger(\n  trigger: NotificationTriggerInput\n): NativeMonthlyTriggerInput | undefined {\n  if (\n    trigger !== null &&\n    typeof trigger === 'object' &&\n    'type' in trigger &&\n    trigger.type === SchedulableTriggerInputTypes.MONTHLY\n  ) {\n    validateDateComponentsInTrigger(trigger, ['day', 'hour', 'minute']);\n    const result: NativeMonthlyTriggerInput = {\n      type: 'monthly',\n      day: trigger.day ?? placeholderDateComponentValue,\n      hour: trigger.hour ?? placeholderDateComponentValue,\n      minute: trigger.minute ?? placeholderDateComponentValue,\n    };\n    if (trigger.channelId) {\n      result.channelId = trigger.channelId;\n    }\n    return result;\n  }\n  return undefined;\n}\nfunction parseYearlyTrigger(\n  trigger: NotificationTriggerInput\n): NativeYearlyTriggerInput | undefined {\n  if (\n    trigger !== null &&\n    typeof trigger === 'object' &&\n    'type' in trigger &&\n    trigger.type === SchedulableTriggerInputTypes.YEARLY\n  ) {\n    validateDateComponentsInTrigger(trigger, ['month', 'day', 'hour', 'minute']);\n    const result: NativeYearlyTriggerInput = {\n      type: 'yearly',\n      month: trigger.month ?? placeholderDateComponentValue,\n      day: trigger.day ?? placeholderDateComponentValue,\n      hour: trigger.hour ?? placeholderDateComponentValue,\n      minute: trigger.minute ?? placeholderDateComponentValue,\n    };\n    if (trigger.channelId) {\n      result.channelId = trigger.channelId;\n    }\n    return result;\n  }\n  return undefined;\n}\nfunction parseTimeIntervalTrigger(\n  trigger: NotificationTriggerInput\n): NativeTimeIntervalTriggerInput | undefined {\n  if (\n    trigger !== null &&\n    typeof trigger === 'object' &&\n    'type' in trigger &&\n    trigger.type === SchedulableTriggerInputTypes.TIME_INTERVAL &&\n    'seconds' in trigger &&\n    typeof trigger.seconds === 'number'\n  ) {\n    const result: NativeTimeIntervalTriggerInput = {\n      type: 'timeInterval',\n      seconds: trigger.seconds,\n      repeats: trigger.repeats ?? false,\n    };\n    if (trigger.channelId) {\n      result.channelId = trigger.channelId;\n    }\n    return result;\n  }\n  return undefined;\n}\n// Needed only to satisfy Typescript types for validated date components\nconst placeholderDateComponentValue = -9999;\nfunction validateDateComponentsInTrigger(\n  trigger: NonNullable<NotificationTriggerInput>,\n  components: readonly ValidTriggerDateComponents[]\n) {\n  const anyTriggerType = trigger as any;\n  components.forEach((component) => {\n    if (!(component in anyTriggerType)) {\n      throw new TypeError(`The ${component} parameter needs to be present`);\n    }\n    if (typeof anyTriggerType[component] !== 'number') {\n      throw new TypeError(`The ${component} parameter should be a number`);\n    }\n    switch (component) {\n      case 'month': {\n        const { month } = anyTriggerType;\n        if (month < 0 || month > 11) {\n          throw new RangeError(`The month parameter needs to be between 0 and 11. Found: ${month}`);\n        }\n        break;\n      }\n      case 'day': {\n        const day = anyTriggerType.day;\n        const month =\n          anyTriggerType.month !== undefined ? anyTriggerType.month : new Date().getMonth();\n        const daysInGivenMonth = daysInMonth(month);\n        if (day < 1 || day > daysInGivenMonth) {\n          throw new RangeError(\n            `The day parameter for month ${month} must be between 1 and ${daysInGivenMonth}. Found: ${day}`\n          );\n        }\n        break;\n      }\n      case 'weekday': {\n        const { weekday } = anyTriggerType;\n        if (weekday < 1 || weekday > 7) {\n          throw new RangeError(\n            `The weekday parameter needs to be between 1 and 7. Found: ${weekday}`\n          );\n        }\n        break;\n      }\n      case 'hour': {\n        const { hour } = anyTriggerType;\n        if (hour < 0 || hour > 23) {\n          throw new RangeError(`The hour parameter needs to be between 0 and 23. Found: ${hour}`);\n        }\n        break;\n      }\n      case 'minute': {\n        const { minute } = anyTriggerType;\n        if (minute < 0 || minute > 59) {\n          throw new RangeError(\n            `The minute parameter needs to be between 0 and 59. Found: ${minute}`\n          );\n        }\n        break;\n      }\n    }\n  });\n}\nfunction daysInMonth(month: number = 0, year?: number) {\n  return new Date(year ?? 2000, month + 1, 0).getDate();\n}", "llm_cg": {"scheduleNotificationAsync(request)": ["NotificationScheduler.%AMX$scheduleNotificationAsync(string, unknown, unknown)", "uuid.%AMX$v4()", "parseTrigger(userFacingTrigger)"], "parseTrigger(userFacingTrigger)": ["parseDateTrigger(trigger)", "parseCalendarTrigger(trigger)", "parseDailyTrigger(trigger)", "parseWeeklyTrigger(trigger)", "parseMonthlyTrigger(trigger)", "parseYearlyTrigger(trigger)", "parseTimeIntervalTrigger(trigger)"], "parseDateTrigger(trigger)": ["toTimestamp(date)"], "parseDailyTrigger(trigger)": ["%AMX$validateDateComponentsInTrigger(trigger, components)"], "parseWeeklyTrigger(trigger)": ["%AMX$validateDateComponentsInTrigger(trigger, components)"], "parseMonthlyTrigger(trigger)": ["%AMX$validateDateComponentsInTrigger(trigger, components)"], "parseYearlyTrigger(trigger)": ["%AMX$validateDateComponentsInTrigger(trigger, components)"], "validateDateComponentsInTrigger(trigger, components)": ["%AMX$daysInMonth(month)"]}, "static_cg": {"@test/148.ts: %dflt.scheduleNotificationAsync(NotificationRequestInput)": ["@test/148.ts: %dflt.parseTrigger(NotificationTriggerInput)"], "@test/148.ts: %dflt.parseTrigger(NotificationTriggerInput)": ["@test/148.ts: %dflt.parseDateTrigger(NotificationTriggerInput)", "@test/148.ts: %dflt.parseCalendarTrigger(NotificationTriggerInput)", "@test/148.ts: %dflt.parseDailyTrigger(NotificationTriggerInput)", "@test/148.ts: %dflt.parseWeeklyTrigger(NotificationTriggerInput)", "@test/148.ts: %dflt.parseMonthlyTrigger(NotificationTriggerInput)", "@test/148.ts: %dflt.parseYearlyTrigger(NotificationTriggerInput)", "@test/148.ts: %dflt.parseTimeIntervalTrigger(NotificationTriggerInput)"], "@test/148.ts: %dflt.parseDailyTrigger(NotificationTriggerInput)": ["@test/148.ts: %dflt.validateDateComponentsInTrigger(NonNullable<NotificationTriggerInput>, TypeOperator)"], "@test/148.ts: %dflt.parseWeeklyTrigger(NotificationTriggerInput)": ["@test/148.ts: %dflt.validateDateComponentsInTrigger(NonNullable<NotificationTriggerInput>, TypeOperator)"], "@test/148.ts: %dflt.parseMonthlyTrigger(NotificationTriggerInput)": ["@test/148.ts: %dflt.validateDateComponentsInTrigger(NonNullable<NotificationTriggerInput>, TypeOperator)"], "@test/148.ts: %dflt.parseYearlyTrigger(NotificationTriggerInput)": ["@test/148.ts: %dflt.validateDateComponentsInTrigger(NonNullable<NotificationTriggerInput>, TypeOperator)"], "@test/148.ts: %dflt.validateDateComponentsInTrigger(NonNullable<NotificationTriggerInput>, TypeOperator)": ["@test/148.ts: %dflt.%AM0$validateDateComponentsInTrigger([anyTriggerType], unknown)"], "@test/148.ts: %dflt.%AM0$validateDateComponentsInTrigger([anyTriggerType], unknown)": ["@test/148.ts: %dflt.daysInMonth(number, number)"], "@test/148.ts: %AC$%dflt$parseDateTrigger$3.%instInit()": ["@test/148.ts: %dflt.toTimestamp(number|Date)"], "@test/148.ts: %AC$%dflt$parseDateTrigger$4.%instInit()": ["@test/148.ts: %dflt.toTimestamp(number|Date)"]}}
{"source_code": "// Utilities\nimport { clamp } from '@/util/helpers'\n// Types\nimport type { RGB, XYZ } from '../colorUtils'\n// For converting XYZ to sRGB\nconst srgbForwardMatrix = [\n  [3.2406, -1.5372, -0.4986],\n  [-0.9689, 1.8758, 0.0415],\n  [0.0557, -0.2040, 1.0570],\n]\n// Forward gamma adjust\nconst srgbForwardTransform = (C: number): number => (\n  C <= 0.0031308\n    ? C * 12.92\n    : 1.055 * C ** (1 / 2.4) - 0.055\n)\n// For converting sRGB to XYZ\nconst srgbReverseMatrix = [\n  [0.4124, 0.3576, 0.1805],\n  [0.2126, 0.7152, 0.0722],\n  [0.0193, 0.1192, 0.9505],\n]\n// Reverse gamma adjust\nconst srgbReverseTransform = (C: number): number => (\n  C <= 0.04045\n    ? C / 12.92\n    : ((C + 0.055) / 1.055) ** 2.4\n)\nexport function fromXYZ (xyz: XYZ): RGB {\n  const rgb = Array(3)\n  const transform = srgbForwardTransform\n  const matrix = srgbForwardMatrix\n  // Matrix transform, then gamma adjustment\n  for (let i = 0; i < 3; ++i) {\n    // Rescale back to [0, 255]\n    rgb[i] = Math.round(clamp(transform(\n      matrix[i][0] * xyz[0] +\n      matrix[i][1] * xyz[1] +\n      matrix[i][2] * xyz[2]\n    )) * 255)\n  }\n  return {\n    r: rgb[0],\n    g: rgb[1],\n    b: rgb[2],\n  }\n}\nexport function toXYZ ({ r, g, b }: RGB): XYZ {\n  const xyz: XYZ = [0, 0, 0]\n  const transform = srgbReverseTransform\n  const matrix = srgbReverseMatrix\n  // Rescale from [0, 255] to [0, 1] then adjust sRGB gamma to linear RGB\n  r = transform(r / 255)\n  g = transform(g / 255)\n  b = transform(b / 255)\n  // Matrix color space transform\n  for (let i = 0; i < 3; ++i) {\n    xyz[i] = matrix[i][0] * r + matrix[i][1] * g + matrix[i][2] * b\n  }\n  return xyz\n}", "llm_cg": {"%AM0$fromXYZ(XYZ)": ["%AM0$srgbForwardTransform(number)", "%AM0$clamp(number)"], "%AM0$toXYZ(RGB)": ["%AM0$srgbReverseTransform(number)"]}, "static_cg": {}}
{"source_code": "import { Mark, mergeAttributes } from '@tiptap/core'\nimport type { StyleParseRule } from '@tiptap/pm/model'\nexport interface SubscriptExtensionOptions {\n  HTMLAttributes: Object,\n}\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    subscript: {\n      setSubscript: () => ReturnType,\n      toggleSubscript: () => ReturnType,\n      unsetSubscript: () => ReturnType,\n    }\n  }\n}\nexport const Subscript = Mark.create<SubscriptExtensionOptions>({\n  name: 'subscript',\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    }\n  },\n  parseHTML() {\n    return [\n      {\n        tag: 'sub',\n      },\n      {\n        style: 'vertical-align',\n        getAttrs(value) {\n          // Don’t match this rule if the vertical align isn’t sub.\n          if (value !== 'sub') {\n            return false\n          }\n          // If it falls through we’ll match, and this mark will be applied.\n          return null\n        },\n      } as StyleParseRule,\n    ]\n  },\n  renderHTML({ HTMLAttributes }) {\n    return ['sub', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n  addCommands() {\n    return {\n      setSubscript: () => ({ commands }) => {\n        return commands.setMark(this.name)\n      },\n      toggleSubscript: () => ({ commands }) => {\n        return commands.toggleMark(this.name)\n      },\n      unsetSubscript: () => ({ commands }) => {\n        return commands.unsetMark(this.name)\n      },\n    }\n  },\n  addKeyboardShortcuts() {\n    return {\n      'Mod-,': () => this.editor.commands.toggleSubscript(),\n    }\n  },\n})", "llm_cg": {"Subscript.%AMX$renderHTML({ HTMLAttributes })": ["mergeAttributes(Subscript.options.HTMLAttributes, HTMLAttributes)"], "Subscript.%AMX$setSubscript()": ["commands.setMark(Subscript.name)"], "Subscript.%AMX$toggleSubscript()": ["commands.toggleMark(Subscript.name)"], "Subscript.%AMX$unsetSubscript()": ["commands.unsetMark(Subscript.name)"], "Subscript.%AMX$addKeyboardShortcuts()": ["Subscript.editor.commands.toggleSubscript()"]}, "static_cg": {}}
{"source_code": "import { SmsProviderIdEnum } from '@novu/shared';\nimport {\n  ChannelTypeEnum,\n  ISendMessageSuccessResponse,\n  ISMSEventBody,\n  ISmsOptions,\n  ISmsProvider,\n  SmsEventStatusEnum,\n} from '@novu/stateless';\nimport { Client as PlivoClient } from 'plivo';\nimport { BaseProvider, CasingEnum } from '../../../base.provider';\nimport { WithPassthrough } from '../../../utils/types';\nexport class PlivoSmsProvider extends BaseProvider implements ISmsProvider {\n  id = SmsProviderIdEnum.Plivo;\n  channelType = ChannelTypeEnum.SMS as ChannelTypeEnum.SMS;\n  protected casing = CasingEnum.CAMEL_CASE;\n  private plivoClient: PlivoClient;\n  constructor(\n    private config: {\n      accountSid?: string;\n      authToken?: string;\n      from?: string;\n    },\n  ) {\n    super();\n    this.plivoClient = new PlivoClient(config.accountSid, config.authToken);\n  }\n  async sendMessage(\n    options: ISmsOptions,\n    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {},\n  ): Promise<ISendMessageSuccessResponse> {\n    const transformedData = this.transform(bridgeProviderData, {\n      src: options.from || this.config.from,\n      dst: options.to,\n      text: options.content,\n    });\n    const plivoResponse = await this.plivoClient.messages.create(\n      transformedData.body.src,\n      transformedData.body.dst,\n      transformedData.body.text as string,\n      transformedData.body.optionalParams as object,\n      transformedData.body.powerpackUUID as string,\n    );\n    return {\n      ids: plivoResponse.messageUuid,\n      date: new Date().toISOString(),\n    };\n  }\n  getMessageId(body: any | any[]): string[] {\n    if (Array.isArray(body)) {\n      return body.map((item) => item.messageUuid);\n    }\n    return [body.messageUuid];\n  }\n  parseEventBody(\n    body: any | any[],\n    identifier: string,\n  ): ISMSEventBody | undefined {\n    if (Array.isArray(body)) {\n      // eslint-disable-next-line no-param-reassign\n      body = body.find((item) => item.messageUuid === identifier);\n    }\n    if (!body) {\n      return undefined;\n    }\n    const status = this.getStatus(body.status);\n    if (status === undefined) {\n      return undefined;\n    }\n    return {\n      status,\n      date: new Date().toISOString(),\n      externalId: body.messageUuid,\n      attempts: body.attempt ? parseInt(body.attempt, 10) : 1,\n      response: body.response ?? '',\n      row: body,\n    };\n  }\n  private getStatus(event: string): SmsEventStatusEnum | undefined {\n    switch (event) {\n      case 'queued':\n        return SmsEventStatusEnum.QUEUED;\n      case 'sent':\n        return SmsEventStatusEnum.SENT;\n      case 'failed':\n        return SmsEventStatusEnum.FAILED;\n      case 'undelivered':\n        return SmsEventStatusEnum.UNDELIVERED;\n      case 'delivered':\n        return SmsEventStatusEnum.DELIVERED;\n      case 'rejected':\n        return SmsEventStatusEnum.REJECTED;\n      default:\n        return undefined;\n    }\n  }\n}", "llm_cg": {"PlivoSmsProvider.constructor({ accountSid?: string; authToken?: string; from?: string })": ["PlivoClient.%AM0$constructor(unknown, unknown)"], "PlivoSmsProvider.sendMessage(ISmsOptions, WithPassthrough<Record<string, unknown>>)": ["PlivoSmsProvider.%AM1$transform(unknown, unknown)", "PlivoClient.%AM0$messages.create(unknown, unknown, string, object, string)"], "PlivoSmsProvider.getMessageId(any | any[])": [], "PlivoSmsProvider.parseEventBody(any | any[], string)": ["PlivoSmsProvider.%AM2$getStatus(unknown)"], "PlivoSmsProvider.%AM2$getStatus(event: string)": []}, "static_cg": {"@test/151.ts: PlivoSmsProvider.getMessageId(any|any[])": ["@test/151.ts: PlivoSmsProvider.%AM0$getMessageId(unknown)"], "@test/151.ts: PlivoSmsProvider.parseEventBody(any|any[], string)": ["@test/151.ts: PlivoSmsProvider.%AM1$parseEventBody([identifier], unknown)", "@test/151.ts: PlivoSmsProvider.getStatus(string)"]}}
{"source_code": "interface __darwin_mcontext32 {\n\t__es: __darwin_i386_exception_state;\n\t__ss: __darwin_i386_thread_state;\n\t__fs: __darwin_i386_float_state;\n}\ndeclare var __darwin_mcontext32: interop.StructType<__darwin_mcontext32>;\ninterface __darwin_mcontext64 {\n\t__es: __darwin_x86_exception_state64;\n\t__ss: __darwin_x86_thread_state64;\n\t__fs: __darwin_x86_float_state64;\n}\ndeclare var __darwin_mcontext64: interop.StructType<__darwin_mcontext64>;\ninterface __darwin_mcontext64_full {\n\t__es: __darwin_x86_exception_state64;\n\t__ss: __darwin_x86_thread_full_state64;\n\t__fs: __darwin_x86_float_state64;\n}\ndeclare var __darwin_mcontext64_full: interop.StructType<__darwin_mcontext64_full>;\ninterface __darwin_mcontext_avx32 {\n\t__es: __darwin_i386_exception_state;\n\t__ss: __darwin_i386_thread_state;\n\t__fs: __darwin_i386_avx_state;\n}\ndeclare var __darwin_mcontext_avx32: interop.StructType<__darwin_mcontext_avx32>;\ninterface __darwin_mcontext_avx512_32 {\n\t__es: __darwin_i386_exception_state;\n\t__ss: __darwin_i386_thread_state;\n\t__fs: __darwin_i386_avx512_state;\n}\ndeclare var __darwin_mcontext_avx512_32: interop.StructType<__darwin_mcontext_avx512_32>;\ninterface __darwin_mcontext_avx512_64 {\n\t__es: __darwin_x86_exception_state64;\n\t__ss: __darwin_x86_thread_state64;\n\t__fs: __darwin_x86_avx512_state64;\n}\ndeclare var __darwin_mcontext_avx512_64: interop.StructType<__darwin_mcontext_avx512_64>;\ninterface __darwin_mcontext_avx512_64_full {\n\t__es: __darwin_x86_exception_state64;\n\t__ss: __darwin_x86_thread_full_state64;\n\t__fs: __darwin_x86_avx512_state64;\n}\ndeclare var __darwin_mcontext_avx512_64_full: interop.StructType<__darwin_mcontext_avx512_64_full>;\ninterface __darwin_mcontext_avx64 {\n\t__es: __darwin_x86_exception_state64;\n\t__ss: __darwin_x86_thread_state64;\n\t__fs: __darwin_x86_avx_state64;\n}\ndeclare var __darwin_mcontext_avx64: interop.StructType<__darwin_mcontext_avx64>;\ninterface __darwin_mcontext_avx64_full {\n\t__es: __darwin_x86_exception_state64;\n\t__ss: __darwin_x86_thread_full_state64;\n\t__fs: __darwin_x86_avx_state64;\n}\ndeclare var __darwin_mcontext_avx64_full: interop.StructType<__darwin_mcontext_avx64_full>;\ninterface __darwin_sigaltstack {\n\tss_sp: interop.Pointer | interop.Reference<any>;\n\tss_size: number;\n\tss_flags: number;\n}\ndeclare var __darwin_sigaltstack: interop.StructType<__darwin_sigaltstack>;\ninterface __darwin_ucontext {\n\tuc_onstack: number;\n\tuc_sigmask: number;\n\tuc_stack: __darwin_sigaltstack;\n\tuc_link: interop.Pointer | interop.Reference<__darwin_ucontext>;\n\tuc_mcsize: number;\n\tuc_mcontext: interop.Pointer | interop.Reference<__darwin_mcontext64>;\n}\ndeclare var __darwin_ucontext: interop.StructType<__darwin_ucontext>;\ndeclare function bsd_signal(p1: number, p2: interop.FunctionReference<(p1: number) => void>): interop.FunctionReference<(p1: number) => void>;\ndeclare function kill(p1: number, p2: number): number;\ndeclare function killpg(p1: number, p2: number): number;\ndeclare function psignal(p1: number, p2: string | interop.Pointer | interop.Reference<any>): void;\ndeclare function pthread_kill(p1: interop.Pointer | interop.Reference<_opaque_pthread_t>, p2: number): number;\ndeclare function pthread_sigmask(p1: number, p2: interop.Pointer | interop.Reference<number>, p3: interop.Pointer | interop.Reference<number>): number;\ndeclare function raise(p1: number): number;\ndeclare function sigaddset(p1: interop.Pointer | interop.Reference<number>, p2: number): number;\ndeclare function sigaltstack(p1: interop.Pointer | interop.Reference<__darwin_sigaltstack>, p2: interop.Pointer | interop.Reference<__darwin_sigaltstack>): number;\ndeclare function sigblock(p1: number): number;\ndeclare function sigdelset(p1: interop.Pointer | interop.Reference<number>, p2: number): number;\ndeclare function sigemptyset(p1: interop.Pointer | interop.Reference<number>): number;\ndeclare function sigfillset(p1: interop.Pointer | interop.Reference<number>): number;\ndeclare function sighold(p1: number): number;\ndeclare function sigignore(p1: number): number;\ndeclare function siginterrupt(p1: number, p2: number): number;\ndeclare function sigismember(p1: interop.Pointer | interop.Reference<number>, p2: number): number;\ndeclare function signal(p1: number, p2: interop.FunctionReference<(p1: number) => void>): interop.FunctionReference<(p1: number) => void>;\ndeclare function sigpause(p1: number): number;\ndeclare function sigpending(p1: interop.Pointer | interop.Reference<number>): number;\ndeclare function sigprocmask(p1: number, p2: interop.Pointer | interop.Reference<number>, p3: interop.Pointer | interop.Reference<number>): number;\ndeclare function sigrelse(p1: number): number;\ndeclare function sigset(p1: number, p2: interop.FunctionReference<(p1: number) => void>): interop.FunctionReference<(p1: number) => void>;\ndeclare function sigsetmask(p1: number): number;\ninterface sigstack {\n\tss_sp: interop.Pointer | interop.Reference<any>;\n\tss_onstack: number;\n}\ndeclare var sigstack: interop.StructType<sigstack>;\ndeclare function sigsuspend(p1: interop.Pointer | interop.Reference<number>): number;\ndeclare function sigvec(p1: number, p2: interop.Pointer | interop.Reference<sigvecStruct>, p3: interop.Pointer | interop.Reference<sigvecStruct>): number;\ninterface sigvecStruct {\n\tsv_handler: interop.FunctionReference<(p1: number) => void>;\n\tsv_mask: number;\n\tsv_flags: number;\n}\ndeclare var sigvecStruct: interop.StructType<sigvecStruct>;\ndeclare function sigwait(p1: interop.Pointer | interop.Reference<number>, p2: interop.Pointer | interop.Reference<number>): number;\ndeclare var sys_siglist: interop.Reference<interop.Pointer | interop.Reference<any>>;\ndeclare var sys_signame: interop.Reference<interop.Pointer | interop.Reference<any>>;", "llm_cg": {}, "static_cg": {}}
{"source_code": "import { remoteQueryObjectToString } from \"../remote-query-object-to-string\"\nconst remoteQueryObject = {\n  fields: [\n    \"id\",\n    \"title\",\n    \"subtitle\",\n    \"status\",\n    \"external_id\",\n    \"description\",\n    \"handle\",\n    \"is_giftcard\",\n    \"discountable\",\n    \"thumbnail\",\n    \"collection_id\",\n    \"type_id\",\n    \"weight\",\n    \"length\",\n    \"height\",\n    \"width\",\n    \"hs_code\",\n    \"origin_country\",\n    \"mid_code\",\n    \"material\",\n    \"created_at\",\n    \"updated_at\",\n    \"deleted_at\",\n    \"metadata\",\n  ],\n  images: {\n    fields: [\"id\", \"created_at\", \"updated_at\", \"deleted_at\", \"url\", \"metadata\"],\n  },\n  tags: {\n    fields: [\"id\", \"created_at\", \"updated_at\", \"deleted_at\", \"value\"],\n  },\n  type: {\n    fields: [\"id\", \"created_at\", \"updated_at\", \"deleted_at\", \"value\"],\n  },\n  collection: {\n    fields: [\"title\", \"handle\", \"id\", \"created_at\", \"updated_at\", \"deleted_at\"],\n  },\n  options: {\n    fields: [\n      \"id\",\n      \"created_at\",\n      \"updated_at\",\n      \"deleted_at\",\n      \"title\",\n      \"product_id\",\n      \"metadata\",\n    ],\n    values: {\n      fields: [\n        \"id\",\n        \"created_at\",\n        \"updated_at\",\n        \"deleted_at\",\n        \"value\",\n        \"option_id\",\n        \"variant_id\",\n        \"metadata\",\n      ],\n    },\n  },\n  variants: {\n    fields: [\n      \"id\",\n      \"created_at\",\n      \"updated_at\",\n      \"deleted_at\",\n      \"title\",\n      \"product_id\",\n      \"sku\",\n      \"barcode\",\n      \"ean\",\n      \"upc\",\n      \"variant_rank\",\n      \"allow_backorder\",\n      \"manage_inventory\",\n      \"hs_code\",\n      \"origin_country\",\n      \"mid_code\",\n      \"material\",\n      \"weight\",\n      \"length\",\n      \"height\",\n      \"width\",\n      \"metadata\",\n    ],\n    options: {\n      fields: [\n        \"id\",\n        \"created_at\",\n        \"updated_at\",\n        \"deleted_at\",\n        \"value\",\n        \"option_id\",\n        \"variant_id\",\n        \"metadata\",\n      ],\n    },\n  },\n  profile: {\n    fields: [\"id\", \"created_at\", \"updated_at\", \"deleted_at\", \"name\", \"type\"],\n  },\n}\ndescribe(\"remoteQueryObjectToString\", function () {\n  it(\"should return a string array of fields/relations\", function () {\n    const output = remoteQueryObjectToString(remoteQueryObject)\n    expect(output).toEqual([\n      \"id\",\n      \"title\",\n      \"subtitle\",\n      \"status\",\n      \"external_id\",\n      \"description\",\n      \"handle\",\n      \"is_giftcard\",\n      \"discountable\",\n      \"thumbnail\",\n      \"collection_id\",\n      \"type_id\",\n      \"weight\",\n      \"length\",\n      \"height\",\n      \"width\",\n      \"hs_code\",\n      \"origin_country\",\n      \"mid_code\",\n      \"material\",\n      \"created_at\",\n      \"updated_at\",\n      \"deleted_at\",\n      \"metadata\",\n      \"images.id\",\n      \"images.created_at\",\n      \"images.updated_at\",\n      \"images.deleted_at\",\n      \"images.url\",\n      \"images.metadata\",\n      \"tags.id\",\n      \"tags.created_at\",\n      \"tags.updated_at\",\n      \"tags.deleted_at\",\n      \"tags.value\",\n      \"type.id\",\n      \"type.created_at\",\n      \"type.updated_at\",\n      \"type.deleted_at\",\n      \"type.value\",\n      \"collection.title\",\n      \"collection.handle\",\n      \"collection.id\",\n      \"collection.created_at\",\n      \"collection.updated_at\",\n      \"collection.deleted_at\",\n      \"options.id\",\n      \"options.created_at\",\n      \"options.updated_at\",\n      \"options.deleted_at\",\n      \"options.title\",\n      \"options.product_id\",\n      \"options.metadata\",\n      \"options.values.id\",\n      \"options.values.created_at\",\n      \"options.values.updated_at\",\n      \"options.values.deleted_at\",\n      \"options.values.value\",\n      \"options.values.option_id\",\n      \"options.values.variant_id\",\n      \"options.values.metadata\",\n      \"variants.id\",\n      \"variants.created_at\",\n      \"variants.updated_at\",\n      \"variants.deleted_at\",\n      \"variants.title\",\n      \"variants.product_id\",\n      \"variants.sku\",\n      \"variants.barcode\",\n      \"variants.ean\",\n      \"variants.upc\",\n      \"variants.variant_rank\",\n      \"variants.allow_backorder\",\n      \"variants.manage_inventory\",\n      \"variants.hs_code\",\n      \"variants.origin_country\",\n      \"variants.mid_code\",\n      \"variants.material\",\n      \"variants.weight\",\n      \"variants.length\",\n      \"variants.height\",\n      \"variants.width\",\n      \"variants.metadata\",\n      \"variants.options.id\",\n      \"variants.options.created_at\",\n      \"variants.options.updated_at\",\n      \"variants.options.deleted_at\",\n      \"variants.options.value\",\n      \"variants.options.option_id\",\n      \"variants.options.variant_id\",\n      \"variants.options.metadata\",\n      \"profile.id\",\n      \"profile.created_at\",\n      \"profile.updated_at\",\n      \"profile.deleted_at\",\n      \"profile.name\",\n      \"profile.type\",\n    ])\n  })\n})", "llm_cg": {"describe.%AM0$(unknown)": ["%AM0$it(unknown)"], "%AM0$it(unknown)": ["remoteQueryObjectToString(remoteQueryObject)"]}, "static_cg": {"@test/153.ts: %dflt.[static]%dflt()": ["@test/153.ts: %dflt.%AM0()"], "@test/153.ts: %dflt.%AM0()": ["@test/153.ts: %dflt.%AM1$%AM0()"]}}
{"source_code": "import { MetaTable, MetaTableOldV2, orderedMetaTables } from '~/utils/globals';\nconst up = async (knex) => {\n  await knex.schema.createTable(MetaTableOldV2.PROJECT, (table) => {\n    table.string('id', 128).primary();\n    table.string('title');\n    table.string('prefix');\n    table.string('status');\n    table.text('description');\n    table.text('meta');\n    table.string('color');\n    table.string('uuid');\n    table.string('password');\n    table.string('roles');\n    table.boolean('deleted').defaultTo(false);\n    table.boolean('is_meta');\n    table.float('order');\n    table.timestamps(true, true);\n  });\n  await knex.schema.createTable(MetaTableOldV2.BASES, (table) => {\n    table.string('id', 20).primary().notNullable();\n    // todo: foreign key\n    // table.string('project_id', 128);\n    table.string('project_id', 128);\n    table.foreign('project_id').references(`${MetaTableOldV2.PROJECT}.id`);\n    table.string('alias');\n    table.text('config');\n    table.text('meta');\n    table.boolean('is_meta');\n    table.string('type');\n    table.string('inflection_column');\n    table.string('inflection_table');\n    // todo: type\n    // table.text('ssl');\n    table.timestamps(true, true);\n  });\n  await knex.schema.createTable(MetaTable.MODELS, (table) => {\n    table.string('id', 20).primary().notNullable();\n    table.string('base_id', 20);\n    table.foreign('base_id').references(`${MetaTableOldV2.BASES}.id`);\n    table.string('project_id', 128);\n    table.foreign('project_id').references(`${MetaTableOldV2.PROJECT}.id`);\n    table.string('table_name');\n    table.string('title');\n    table.string('type').defaultTo('table');\n    table.text('meta', 'mediumtext');\n    table.text('schema', 'text');\n    table.boolean('enabled').defaultTo(true);\n    table.boolean('mm').defaultTo(false);\n    table.string('tags');\n    table.boolean('pinned');\n    table.boolean('deleted');\n    table.float('order');\n    table.timestamps(true, true);\n  });\n  await knex.schema.createTable(MetaTable.COLUMNS, (table) => {\n    table.string('id', 20).primary().notNullable();\n    table.string('base_id', 20);\n    // table.foreign('base_id').references(`${MetaTableOldV2.BASES}.id`);\n    table.string('project_id', 128);\n    // table.foreign('project_id').references(`${MetaTableOldV2.PROJECT}.id`);\n    table.string('fk_model_id', 20);\n    table.foreign('fk_model_id').references(`${MetaTable.MODELS}.id`);\n    table.string('title');\n    table.string('column_name');\n    // todo: decide type\n    table.string('uidt');\n    table.string('dt');\n    table.string('np');\n    table.string('ns');\n    table.string('clen');\n    table.string('cop');\n    table.boolean('pk');\n    table.boolean('pv');\n    table.boolean('rqd');\n    table.boolean('un');\n    table.string('ct');\n    table.boolean('ai');\n    table.boolean('unique');\n    table.string('cdf');\n    table.string('cc');\n    table.string('csn');\n    table.string('dtx');\n    table.string('dtxp');\n    table.string('dtxs');\n    table.boolean('au');\n    // todo: normalise\n    table.text('validate');\n    //todo: virtual, real, etc\n    table.boolean('virtual');\n    table.boolean('deleted');\n    table.boolean('system').defaultTo(false);\n    table.float('order');\n    table.timestamps(true, true);\n  });\n  // await knex.schema.createTable(MetaTable.COLUMN_VALIDATIONS, table => {\n  //   table\n  //     .string('id', 20)\n  //     .primary()\n  //     .notNullable();\n  // })\n  await knex.schema.createTable(MetaTable.COL_RELATIONS, (table) => {\n    table.string('id', 20).primary().notNullable();\n    table.string('ref_db_alias');\n    table.string('type');\n    table.boolean('virtual');\n    table.string('db_type');\n    table.string('fk_column_id', 20);\n    table.foreign('fk_column_id').references(`${MetaTable.COLUMNS}.id`);\n    table.string('fk_related_model_id', 20);\n    table.foreign('fk_related_model_id').references(`${MetaTable.MODELS}.id`);\n    // fk_rel_column_id\n    // fk_rel_ref_column_id\n    table.string('fk_child_column_id', 20);\n    table.foreign('fk_child_column_id').references(`${MetaTable.COLUMNS}.id`);\n    table.string('fk_parent_column_id', 20);\n    table.foreign('fk_parent_column_id').references(`${MetaTable.COLUMNS}.id`);\n    table.string('fk_mm_model_id', 20);\n    table.foreign('fk_mm_model_id').references(`${MetaTable.MODELS}.id`);\n    table.string('fk_mm_child_column_id', 20);\n    table\n      .foreign('fk_mm_child_column_id')\n      .references(`${MetaTable.COLUMNS}.id`);\n    table.string('fk_mm_parent_column_id', 20);\n    table\n      .foreign('fk_mm_parent_column_id')\n      .references(`${MetaTable.COLUMNS}.id`);\n    table.string('ur');\n    table.string('dr');\n    table.string('fk_index_name');\n    table.boolean('deleted');\n    table.timestamps(true, true);\n  });\n  await knex.schema.createTable(MetaTable.COL_SELECT_OPTIONS, (table) => {\n    table.string('id', 20).primary().notNullable();\n    table.string('fk_column_id', 20);\n    table.foreign('fk_column_id').references(`${MetaTable.COLUMNS}.id`);\n    table.string('title');\n    table.string('color');\n    table.float('order');\n    table.timestamps(true, true);\n  });\n  await knex.schema.createTable(MetaTable.COL_LOOKUP, (table) => {\n    table.string('id', 20).primary().notNullable();\n    table.string('fk_column_id', 20);\n    table.foreign('fk_column_id').references(`${MetaTable.COLUMNS}.id`);\n    // todo: refer relation column\n    // table.string('fk_child_column_id',20);\n    // table.foreign('fk_child_column_id').references(`${MetaTable.COLUMNS}.id`);\n    // table.string('fk_parent_column_id',20);\n    // table.foreign('fk_parent_column_id').references(`${MetaTable.COLUMNS}.id`);\n    table.string('fk_relation_column_id', 20);\n    table\n      .foreign('fk_relation_column_id')\n      .references(`${MetaTable.COLUMNS}.id`);\n    table.string('fk_lookup_column_id', 20);\n    table.foreign('fk_lookup_column_id').references(`${MetaTable.COLUMNS}.id`);\n    table.boolean('deleted');\n    table.timestamps(true, true);\n  });\n  await knex.schema.createTable(MetaTable.COL_ROLLUP, (table) => {\n    table.string('id', 20).primary().notNullable();\n    table.string('fk_column_id', 20);\n    table.foreign('fk_column_id').references(`${MetaTable.COLUMNS}.id`);\n    table.string('fk_relation_column_id', 20);\n    table\n      .foreign('fk_relation_column_id')\n      .references(`${MetaTable.COLUMNS}.id`);\n    table.string('fk_rollup_column_id', 20);\n    table.foreign('fk_rollup_column_id').references(`${MetaTable.COLUMNS}.id`);\n    table.string('rollup_function');\n    table.boolean('deleted');\n    table.timestamps(true, true);\n  });\n  await knex.schema.createTable(MetaTable.COL_FORMULA, (table) => {\n    table.string('id', 20).primary().notNullable();\n    table.string('fk_column_id', 20);\n    table.foreign('fk_column_id').references(`${MetaTable.COLUMNS}.id`);\n    table.text('formula').notNullable();\n    table.text('formula_raw');\n    table.text('error');\n    table.boolean('deleted');\n    table.float('order');\n    table.timestamps(true, true);\n  });\n  await knex.schema.createTable(MetaTable.VIEWS, (table) => {\n    table.string('id', 20).primary().notNullable();\n    table.string('base_id', 20);\n    // table.foreign('base_id').references(`${MetaTableOldV2.BASES}.id`);\n    table.string('project_id', 128);\n    // table.foreign('project_id').references(`${MetaTableOldV2.PROJECT}.id`);\n    table.string('fk_model_id', 20);\n    table.foreign('fk_model_id').references(`${MetaTable.MODELS}.id`);\n    table.string('title');\n    table.integer('type');\n    table.boolean('is_default');\n    table.boolean('show_system_fields');\n    table.string('lock_type').defaultTo('collaborative');\n    table.string('uuid');\n    table.string('password');\n    // todo:  type\n    table.boolean('show');\n    table.float('order');\n    table.timestamps(true, true);\n  });\n  await knex.schema.createTable(MetaTable.HOOKS, (table) => {\n    table.string('id', 20).primary().notNullable();\n    table.string('base_id', 20);\n    // table.foreign('base_id').references(`${MetaTableOldV2.BASES}.id`);\n    table.string('project_id', 128);\n    // table.foreign('project_id').references(`${MetaTableOldV2.PROJECT}.id`);\n    table.string('fk_model_id', 20);\n    table.foreign('fk_model_id').references(`${MetaTable.MODELS}.id`);\n    table.string('title');\n    table.string('description', 255);\n    table.string('env').defaultTo('all');\n    table.string('type');\n    table.string('event');\n    table.string('operation');\n    table.boolean('async').defaultTo(false);\n    table.boolean('payload').defaultTo(true);\n    table.text('url', 'text');\n    table.text('headers', 'text');\n    // todo: normalise\n    table.boolean('condition').defaultTo(false);\n    table.text('notification', 'text');\n    table.integer('retries').defaultTo(0);\n    table.integer('retry_interval').defaultTo(60000);\n    table.integer('timeout').defaultTo(60000);\n    table.boolean('active').defaultTo(true);\n    table.timestamps(true, true);\n  });\n  await knex.schema.createTable(MetaTable.HOOK_LOGS, (table) => {\n    table.string('id', 20).primary().notNullable();\n    table.string('base_id', 20);\n    // table.foreign('base_id').references(`${MetaTableOldV2.BASES}.id`);\n    table.string('project_id', 128);\n    // table.foreign('project_id').references(`${MetaTableOldV2.PROJECT}.id`);\n    table.string('fk_hook_id', 20);\n    // table.foreign('fk_hook_id').references(`${MetaTable.HOOKS}.id`);\n    table.string('type');\n    table.string('event');\n    table.string('operation');\n    table.boolean('test_call').defaultTo(true);\n    table.boolean('payload').defaultTo(true);\n    table.text('conditions');\n    table.text('notification', 'text');\n    table.string('error_code');\n    table.string('error_message');\n    table.text('error', 'text');\n    table.integer('execution_time');\n    table.string('response');\n    table.string('triggered_by');\n    table.timestamps(true, true);\n  });\n  await knex.schema.createTable(MetaTable.FILTER_EXP, (table) => {\n    table.string('id', 20).primary().notNullable();\n    table.string('base_id', 20);\n    // table.foreign('base_id').references(`${MetaTableOldV2.BASES}.id`);\n    table.string('project_id', 128);\n    // table.foreign('project_id').references(`${MetaTableOldV2.PROJECT}.id`);\n    table.string('fk_view_id', 20);\n    table.foreign('fk_view_id').references(`${MetaTable.VIEWS}.id`);\n    table.string('fk_hook_id', 20);\n    table.foreign('fk_hook_id').references(`${MetaTable.HOOKS}.id`);\n    table.string('fk_column_id', 20);\n    table.foreign('fk_column_id').references(`${MetaTable.COLUMNS}.id`);\n    table.string('fk_parent_id', 20);\n    table.foreign('fk_parent_id').references(`${MetaTable.FILTER_EXP}.id`);\n    table.string('logical_op');\n    table.string('comparison_op');\n    table.string('value');\n    table.boolean('is_group');\n    table.float('order');\n    table.timestamps(true, true);\n  });\n  // await knex.schema.createTable(MetaTable.HOOK_FILTER_EXP, table => {\n  //   table\n  //     .string('id', 20)\n  //     .primary()\n  //     .notNullable();\n  //\n  //   table.string('base_id', 20);\n  //   // table.foreign('base_id').references(`${MetaTableOldV2.BASES}.id`);\n  //   table.string('project_id', 128);\n  //   // table.foreign('project_id').references(`${MetaTableOldV2.PROJECT}.id`);\n  //\n  //   table.string('fk_hook_id', 20);\n  //   table.foreign('fk_hook_id').references(`${MetaTable.HOOKS}.id`);\n  //   table.string('fk_column_id', 20);\n  //   table.foreign('fk_column_id').references(`${MetaTable.COLUMNS}.id`);\n  //\n  //   table.string('fk_parent_id', 20);\n  //   table.foreign('fk_parent_id').references(`${MetaTable.HOOK_FILTER_EXP}.id`);\n  //\n  //   table.string('logical_op');\n  //   table.string('comparison_op');\n  //   table.string('value');\n  //   table.boolean('is_group');\n  //\n  //   table.float('order');\n  //   table.timestamps(true, true);\n  // });\n  await knex.schema.createTable(MetaTable.SORT, (table) => {\n    table.string('id', 20).primary().notNullable();\n    table.string('base_id', 20);\n    // table.foreign('base_id').references(`${MetaTableOldV2.BASES}.id`);\n    table.string('project_id', 128);\n    // table.foreign('project_id').references(`${MetaTableOldV2.PROJECT}.id`);\n    table.string('fk_view_id', 20);\n    table.foreign('fk_view_id').references(`${MetaTable.VIEWS}.id`);\n    table.string('fk_column_id', 20);\n    table.foreign('fk_column_id').references(`${MetaTable.COLUMNS}.id`);\n    table.string('direction').defaultTo(false);\n    table.float('order');\n    table.timestamps(true, true);\n  });\n  await knex.schema.createTable(MetaTable.SHARED_VIEWS, (table) => {\n    table.string('id', 20).primary().notNullable();\n    table.string('fk_view_id', 20);\n    table.foreign('fk_view_id').references(`${MetaTable.VIEWS}.id`);\n    table.text('meta', 'mediumtext');\n    // todo:\n    table.text('query_params', 'mediumtext');\n    table.string('view_id');\n    table.boolean('show_all_fields');\n    table.boolean('allow_copy');\n    table.string('password');\n    table.boolean('deleted');\n    table.float('order');\n    table.timestamps(true, true);\n  });\n  await knex.schema.createTable(MetaTable.FORM_VIEW, (table) => {\n    // table\n    //   .string('id', 20)\n    //   .primary()\n    //   .notNullable();\n    table.string('base_id', 20);\n    // table.foreign('base_id').references(`${MetaTableOldV2.BASES}.id`);\n    table.string('project_id', 128);\n    // table.foreign('project_id').references(`${MetaTableOldV2.PROJECT}.id`);\n    table.string('fk_view_id', 20).primary();\n    table.foreign('fk_view_id').references(`${MetaTable.VIEWS}.id`);\n    table.string('heading');\n    table.string('subheading');\n    table.string('success_msg');\n    table.string('redirect_url');\n    table.string('redirect_after_secs');\n    table.string('email');\n    table.boolean('submit_another_form');\n    table.boolean('show_blank_form');\n    table.string('uuid');\n    table.string('banner_image_url');\n    table.string('logo_url');\n    table.timestamps(true, true);\n  });\n  await knex.schema.createTable(MetaTable.FORM_VIEW_COLUMNS, (table) => {\n    table.string('id', 20).primary().notNullable();\n    table.string('base_id', 20);\n    // table.foreign('base_id').references(`${MetaTableOldV2.BASES}.id`);\n    table.string('project_id', 128);\n    // table.foreign('project_id').references(`${MetaTableOldV2.PROJECT}.id`);\n    table.string('fk_view_id', 20);\n    table.foreign('fk_view_id').references(`${MetaTable.FORM_VIEW}.fk_view_id`);\n    table.string('fk_column_id', 20);\n    table.foreign('fk_column_id').references(`${MetaTable.COLUMNS}.id`);\n    // todo: type\n    table.string('uuid');\n    table.string('label');\n    table.string('help');\n    table.string('description');\n    table.boolean('required');\n    table.boolean('show');\n    table.float('order');\n    // todo : condition\n    table.timestamps(true, true);\n  });\n  await knex.schema.createTable(MetaTable.GALLERY_VIEW, (table) => {\n    // table\n    //   .string('id', 20)\n    //   .primary()\n    //   .notNullable();\n    table.string('base_id', 20);\n    // table.foreign('base_id').references(`${MetaTableOldV2.BASES}.id`);\n    table.string('project_id', 128);\n    // table.foreign('project_id').references(`${MetaTableOldV2.PROJECT}.id`);\n    table.string('fk_view_id', 20).primary();\n    table.foreign('fk_view_id').references(`${MetaTable.VIEWS}.id`);\n    // todo:  type\n    table.boolean('next_enabled');\n    table.boolean('prev_enabled');\n    table.integer('cover_image_idx');\n    table.string('fk_cover_image_col_id', 20);\n    table\n      .foreign('fk_cover_image_col_id')\n      .references(`${MetaTable.COLUMNS}.id`);\n    table.string('cover_image');\n    table.string('restrict_types');\n    table.string('restrict_size');\n    table.string('restrict_number');\n    table.boolean('public');\n    table.string('dimensions');\n    table.string('responsive_columns');\n    // todo : condition\n    table.timestamps(true, true);\n  });\n  await knex.schema.createTable(MetaTable.GALLERY_VIEW_COLUMNS, (table) => {\n    table.string('id', 20).primary().notNullable();\n    table.string('base_id', 20);\n    // table.foreign('base_id').references(`${MetaTableOldV2.BASES}.id`);\n    table.string('project_id', 128);\n    // table.foreign('project_id').references(`${MetaTableOldV2.PROJECT}.id`);\n    table.string('fk_view_id', 20);\n    table\n      .foreign('fk_view_id')\n      .references(`${MetaTable.GALLERY_VIEW}.fk_view_id`);\n    table.string('fk_column_id', 20);\n    table.foreign('fk_column_id').references(`${MetaTable.COLUMNS}.id`);\n    table.string('uuid');\n    // todo:  type\n    table.string('label');\n    table.string('help');\n    table.boolean('show');\n    table.float('order');\n    table.timestamps(true, true);\n  });\n  await knex.schema.createTable(MetaTable.GRID_VIEW, (table) => {\n    table.string('fk_view_id', 20).primary();\n    table.foreign('fk_view_id').references(`${MetaTable.VIEWS}.id`);\n    table.string('base_id', 20);\n    // table.foreign('base_id').references(`${MetaTableOldV2.BASES}.id`);\n    table.string('project_id', 128);\n    // table.foreign('project_id').references(`${MetaTableOldV2.PROJECT}.id`);\n    table.string('uuid');\n    table.timestamps(true, true);\n  });\n  await knex.schema.createTable(MetaTable.GRID_VIEW_COLUMNS, (table) => {\n    table.string('id', 20).primary().notNullable();\n    table.string('fk_view_id', 20);\n    table.foreign('fk_view_id').references(`${MetaTable.GRID_VIEW}.fk_view_id`);\n    table.string('fk_column_id', 20);\n    table.foreign('fk_column_id').references(`${MetaTable.COLUMNS}.id`);\n    table.string('base_id', 20);\n    // table.foreign('base_id').references(`${MetaTableOldV2.BASES}.id`);\n    table.string('project_id', 128);\n    // table.foreign('project_id').references(`${MetaTableOldV2.PROJECT}.id`);\n    table.string('uuid');\n    // todo:  type\n    table.string('label');\n    table.string('help');\n    table.string('width').defaultTo('200px');\n    table.boolean('show');\n    table.float('order');\n    table.timestamps(true, true);\n  });\n  await knex.schema.createTable(MetaTable.KANBAN_VIEW, (table) => {\n    table.string('fk_view_id', 20).primary();\n    table.foreign('fk_view_id').references(`${MetaTable.VIEWS}.id`);\n    table.string('base_id', 20);\n    // table.foreign('base_id').references(`${MetaTableOldV2.BASES}.id`);\n    table.string('project_id', 128);\n    // table.foreign('project_id').references(`${MetaTableOldV2.PROJECT}.id`);\n    table.boolean('show');\n    table.float('order');\n    table.string('uuid');\n    table.string('title');\n    // todo:  type\n    table.boolean('public');\n    table.string('password');\n    table.boolean('show_all_fields');\n    table.timestamps(true, true);\n  });\n  await knex.schema.createTable(MetaTable.KANBAN_VIEW_COLUMNS, (table) => {\n    table.string('id', 20).primary().notNullable();\n    table.string('base_id', 20);\n    // table.foreign('base_id').references(`${MetaTableOldV2.BASES}.id`);\n    table.string('project_id', 128);\n    // table.foreign('project_id').references(`${MetaTableOldV2.PROJECT}.id`);\n    table.string('fk_view_id', 20);\n    table\n      .foreign('fk_view_id')\n      .references(`${MetaTable.KANBAN_VIEW}.fk_view_id`);\n    table.string('fk_column_id', 20);\n    table.foreign('fk_column_id').references(`${MetaTable.COLUMNS}.id`);\n    table.string('uuid');\n    // todo:  type\n    table.string('label');\n    table.string('help');\n    table.boolean('show');\n    table.float('order');\n    table.timestamps(true, true);\n  });\n  await knex.schema.createTable(MetaTable.USERS, (table) => {\n    table.string('id', 20).primary().notNullable();\n    table.string('email');\n    table.string('password', 255);\n    table.string('salt', 255);\n    table.string('firstname');\n    table.string('lastname');\n    table.string('username');\n    table.string('refresh_token', 255);\n    table.string('invite_token', 255);\n    table.string('invite_token_expires', 255);\n    table.timestamp('reset_password_expires');\n    table.string('reset_password_token', 255);\n    table.string('email_verification_token', 255);\n    table.boolean('email_verified');\n    table.string('roles', 255).defaultTo('editor');\n    table.timestamps(true, true);\n  });\n  await knex.schema.createTable(MetaTableOldV2.PROJECT_USERS, (table) => {\n    table.string('project_id', 128);\n    table.foreign('project_id').references(`${MetaTableOldV2.PROJECT}.id`);\n    table.string('fk_user_id', 20);\n    table.foreign('fk_user_id').references(`${MetaTable.USERS}.id`);\n    table.text('roles');\n    table.boolean('starred');\n    table.boolean('pinned');\n    table.string('group');\n    table.string('color');\n    table.float('order');\n    table.float('hidden');\n    table.timestamp('opened_date');\n    table.timestamps(true, true);\n  });\n  await knex.schema.createTable(MetaTable.ORGS_OLD, (table) => {\n    table.string('id', 20).primary().notNullable();\n    table.string('title');\n    table.timestamps(true, true);\n  });\n  await knex.schema.createTable(MetaTable.TEAMS, (table) => {\n    table.string('id', 20).primary().notNullable();\n    table.string('title');\n    table.string('org_id', 20);\n    table.foreign('org_id').references(`${MetaTable.ORGS_OLD}.id`);\n    table.timestamps(true, true);\n  });\n  await knex.schema.createTable(MetaTable.TEAM_USERS, (table) => {\n    table.string('org_id', 20);\n    table.foreign('org_id').references(`${MetaTable.ORGS_OLD}.id`);\n    table.string('user_id', 20);\n    table.foreign('user_id').references(`${MetaTable.USERS}.id`);\n    table.timestamps(true, true);\n  });\n  await knex.schema.createTable(MetaTable.AUDIT, (table) => {\n    table.string('id', 20).primary().notNullable();\n    table.string('user');\n    table.string('ip');\n    table.string('base_id', 20);\n    table.foreign('base_id').references(`${MetaTableOldV2.BASES}.id`);\n    table.string('project_id', 128);\n    table.foreign('project_id').references(`${MetaTableOldV2.PROJECT}.id`);\n    table.string('fk_model_id', 20);\n    table.foreign('fk_model_id').references(`${MetaTable.MODELS}.id`);\n    table.string('row_id').index();\n    table.string('op_type');\n    table.string('op_sub_type');\n    table.string('status');\n    table.text('description');\n    table.text('details');\n    table.timestamps(true, true);\n  });\n  await knex.schema.createTable(MetaTable.PLUGIN, (table) => {\n    table.string('id', 20).primary().notNullable();\n    table.string('title', 45);\n    table.text('description');\n    table.boolean('active').defaultTo(false);\n    table.float('rating');\n    table.string('version');\n    table.string('docs');\n    table.string('status').defaultTo('install');\n    table.string('status_details');\n    table.string('logo');\n    table.string('icon');\n    table.string('tags');\n    table.string('category');\n    table.text('input_schema');\n    table.text('input');\n    table.string('creator');\n    table.string('creator_website');\n    table.string('price');\n    table.timestamps(true, true);\n  });\n  await knex.schema.createTable(MetaTable.MODEL_ROLE_VISIBILITY, (table) => {\n    table.string('id', 20).primary().notNullable();\n    table.string('base_id', 20);\n    // table.foreign('base_id').references(`${MetaTableOldV2.BASES}.id`);\n    table.string('project_id', 128);\n    // table.foreign('project_id').references(`${MetaTableOldV2.PROJECT}.id`);\n    // table.string('fk_model_id', 20);\n    // table.foreign('fk_model_id').references(`${MetaTable.MODELS}.id`);\n    table.string('fk_view_id', 20);\n    table.foreign('fk_view_id').references(`${MetaTable.VIEWS}.id`);\n    table.string('role', 45);\n    table.boolean('disabled').defaultTo(true);\n    table.timestamps(true, true);\n  });\n  // await knex('nc_plugins').insert([\n  //   googleAuth,\n  //   ses,\n  //   cache\n  //   // ee,\n  //   // brand,\n  // ]);\n};\nconst down = async (knex) => {\n  for (const tableName of orderedMetaTables) {\n    await knex.schema.dropTable(tableName);\n  }\n};\nexport { up, down };", "llm_cg": {"up(knex)": ["%AM0$(knex.schema.createTable(tableName, tableFunction))", "%AM1$(knex.schema.dropTable(tableName))"], "down(knex)": ["%AM1$(knex.schema.dropTable(tableName))"]}, "static_cg": {"@test/154.ts: %dflt.%AM0(unknown)": ["@test/154.ts: %dflt.%AM1$%AM0(unknown)", "@test/154.ts: %dflt.%AM2$%AM0(unknown)", "@test/154.ts: %dflt.%AM3$%AM0(unknown)", "@test/154.ts: %dflt.%AM4$%AM0(unknown)", "@test/154.ts: %dflt.%AM5$%AM0(unknown)", "@test/154.ts: %dflt.%AM6$%AM0(unknown)", "@test/154.ts: %dflt.%AM7$%AM0(unknown)", "@test/154.ts: %dflt.%AM8$%AM0(unknown)", "@test/154.ts: %dflt.%AM9$%AM0(unknown)", "@test/154.ts: %dflt.%AM10$%AM0(unknown)", "@test/154.ts: %dflt.%AM11$%AM0(unknown)", "@test/154.ts: %dflt.%AM12$%AM0(unknown)", "@test/154.ts: %dflt.%AM13$%AM0(unknown)", "@test/154.ts: %dflt.%AM14$%AM0(unknown)", "@test/154.ts: %dflt.%AM15$%AM0(unknown)", "@test/154.ts: %dflt.%AM16$%AM0(unknown)", "@test/154.ts: %dflt.%AM17$%AM0(unknown)", "@test/154.ts: %dflt.%AM18$%AM0(unknown)", "@test/154.ts: %dflt.%AM19$%AM0(unknown)", "@test/154.ts: %dflt.%AM20$%AM0(unknown)", "@test/154.ts: %dflt.%AM21$%AM0(unknown)", "@test/154.ts: %dflt.%AM22$%AM0(unknown)", "@test/154.ts: %dflt.%AM23$%AM0(unknown)", "@test/154.ts: %dflt.%AM24$%AM0(unknown)", "@test/154.ts: %dflt.%AM25$%AM0(unknown)", "@test/154.ts: %dflt.%AM26$%AM0(unknown)", "@test/154.ts: %dflt.%AM27$%AM0(unknown)", "@test/154.ts: %dflt.%AM28$%AM0(unknown)", "@test/154.ts: %dflt.%AM29$%AM0(unknown)", "@test/154.ts: %dflt.%AM30$%AM0(unknown)", "@test/154.ts: %dflt.%AM31$%AM0(unknown)"]}}
{"source_code": "// @module: commonjs\n// @filename: map.ts\nimport { Observable } from \"./observable\"\n(<any>Observable.prototype).map = function() { }\ndeclare module \"./observable\" {\n    interface Observable<T> {\n        map<U>(proj: (e:T) => U): Observable<U>\n    }\n    namespace Observable {\n        let someAnotherValue: string;\n    }\n}\n// @filename: observable.ts\nexport declare class Observable<T> {\n    filter(pred: (e:T) => boolean): Observable<T>;\n}\nexport namespace Observable {\n    export let someValue: number;\n}\n// @filename: main.ts\nimport { Observable } from \"./observable\"\nimport \"./map\";\nlet x: Observable<number>;\nlet y = x.map(x => x + 1);\nlet z1 = Observable.someValue.toFixed();\nlet z2 = Observable.someAnotherValue.toLowerCase();", "llm_cg": {"main:':createAnonymous('{main.ts}')": ["Observable.prototype.map(unknown)", "Observable.someValue(unknown)", "Observable.someAnotherValue(unknown)"], "Observable.prototype.map(unknown)": [], "Observable.filter((e:T) => boolean)": []}, "static_cg": {"@test/155.ts: %dflt.[static]%dflt()": ["@test/155.ts: %dflt.%AM1(unknown)"]}}
{"source_code": "import type { FlowGraphContext } from \"../../../flowGraphContext\";\nimport type { FlowGraphDataConnection } from \"../../../flowGraphDataConnection\";\nimport { RichTypeNumber } from \"../../../flowGraphRichTypes\";\nimport type { FlowGraphSignalConnection } from \"../../../flowGraphSignalConnection\";\nimport { FlowGraphExecutionBlockWithOutSignal } from \"../../../flowGraphExecutionBlockWithOutSignal\";\nimport type { IFlowGraphBlockConfiguration } from \"../../../flowGraphBlock\";\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\nexport class FlowGraphThrottleBlock extends FlowGraphExecutionBlockWithOutSignal {\n    public readonly duration: FlowGraphDataConnection<number>;\n    public readonly reset: FlowGraphSignalConnection;\n    public readonly timeRemaining: FlowGraphDataConnection<number>;\n    constructor(config?: IFlowGraphBlockConfiguration) {\n        super(config);\n        this.reset = this._registerSignalInput(\"reset\");\n        this.duration = this.registerDataInput(\"duration\", RichTypeNumber);\n        this.timeRemaining = this.registerDataOutput(\"timeRemaining\", RichTypeNumber);\n    }\n    public _execute(context: FlowGraphContext, callingSignal: FlowGraphSignalConnection): void {\n        const lastExecutedTime = context._getExecutionVariable(this, \"lastExecutedTime\");\n        const durationValue = this.duration.getValue(context);\n        const currentTime = Date.now();\n        if (callingSignal === this.reset || lastExecutedTime === undefined || currentTime - lastExecutedTime > durationValue) {\n            //activate the output flow\n            this.timeRemaining.setValue(0, context);\n            this.out._activateSignal(context);\n            context._setExecutionVariable(this, \"lastExecutedTime\", currentTime);\n        } else {\n            //activate the output flow after the remaining time\n            const remaining = durationValue - (currentTime - lastExecutedTime);\n            this.timeRemaining.setValue(remaining, context);\n        }\n    }\n    public override getClassName(): string {\n        return \"FGThrottleBlock\";\n    }\n}\nRegisterClass(\"FGThrottleBlock\", FlowGraphThrottleBlock);", "llm_cg": {"FlowGraphThrottleBlock.constructor(config?)": ["FlowGraphThrottleBlock.%AM0$super(unknown)", "FlowGraphThrottleBlock.%AM0$_registerSignalInput(string)", "FlowGraphThrottleBlock.%AM0$registerDataInput(string, unknown)", "FlowGraphThrottleBlock.%AM0$registerDataOutput(string, unknown)"], "FlowGraphThrottleBlock._execute(context.FlowGraphContext, callingSignal.FlowGraphSignalConnection)": ["FlowGraphContext.%AM0$_getExecutionVariable(unknown, string)", "FlowGraphThrottleBlock.%AM0$duration.getValue(context)", "FlowGraphThrottleBlock.%AM0$reset", "FlowGraphThrottleBlock.%AM0$timeRemaining.setValue(number, context)", "FlowGraphThrottleBlock.%AM0$out._activateSignal(context)", "FlowGraphContext.%AM0$_setExecutionVariable(unknown, string, unknown)"], "FlowGraphThrottleBlock.getClassName()": []}, "static_cg": {}}
{"source_code": "//@target: ES6\ninterface T1 {\n    __t1: string;\n}\ninterface T2 {\n    __t2: string;\n}\ninterface T3 {\n    __t3: string;\n}\nfunction f1(): Promise<T1> {\n    return Promise.resolve({ __t1: \"foo_t1\" });\n}\nfunction f2(x: T1): T2 {\n    return { __t2: x.__t1 + \":foo_21\" };\n}\nvar x3 = f1()\n    .then(f2, (e: Error) => {\n    throw e;\n})\n    .then((x: T2) => {\n    return { __t3: x.__t2 + \"bar\" };\n});", "llm_cg": {"anonymous.onFulfilled(x.T1)": ["anonymous.f2(T1)"], "anonymous.onSecondFulfilled(x.T2)": []}, "static_cg": {"@test/157.ts: %dflt.[static]%dflt()": ["@test/157.ts: %dflt.f1()", "@test/157.ts: %dflt.%AM1(Error)", "@test/157.ts: %dflt.%AM0(@test/157.ts: T2)"]}}
{"source_code": "import { BaseCallbackHandler } from '@langchain/core/callbacks/base';\nimport { Run } from '@langchain/core/tracers/base';\nimport { ConsoleCallbackHandler } from '@langchain/core/tracers/console';\nimport { LLMTracingDriver } from 'src/engine/core-modules/llm-tracing/drivers/interfaces/llm-tracing-driver.interface';\nclass WithMetadataConsoleCallbackHandler extends ConsoleCallbackHandler {\n  private metadata: Record<string, unknown>;\n  constructor(metadata: Record<string, unknown>) {\n    super();\n    this.metadata = metadata;\n  }\n  onChainStart(run: Run) {\n    console.log(`Chain metadata: ${JSON.stringify(this.metadata)}`);\n    super.onChainStart(run);\n  }\n}\nexport class ConsoleDriver implements LLMTracingDriver {\n  getCallbackHandler(metadata: Record<string, unknown>): BaseCallbackHandler {\n    return new WithMetadataConsoleCallbackHandler(metadata);\n  }\n}", "llm_cg": {"WithMetadataConsoleCallbackHandler.constructor(metadata.Record<string, unknown>)": [], "WithMetadataConsoleCallbackHandler.onChainStart(run.Run)": [], "ConsoleDriver.getCallbackHandler(metadata.Record<string, unknown>)": ["WithMetadataConsoleCallbackHandler.constructor(metadata.Record<string, unknown>)"]}, "static_cg": {"@test/158.ts: ConsoleDriver.getCallbackHandler(Record<string,UnknownKeyword>)": ["@test/158.ts: WithMetadataConsoleCallbackHandler.constructor(Record<string,UnknownKeyword>)"]}}
{"source_code": "import { ValidationError } from \"@lerna/core\";\nimport { FetchConfig, getFetchConfig } from \"./fetch-config\";\nimport { getProfileData } from \"./get-profile-data\";\nexport function getTwoFactorAuthRequired(options: Partial<FetchConfig> = {}): Promise<boolean> {\n  const opts = getFetchConfig(options, {\n    // don't wait forever for third-party failures to be dealt with\n    fetchRetries: 0,\n  });\n  opts.log.info(\"\", \"Checking two-factor auth mode\");\n  return getProfileData(opts).then(success, failure);\n  function success(result) {\n    opts.log.silly(\"2FA\", result.tfa);\n    if (result.tfa.pending) {\n      // if 2FA is pending, it is disabled\n      return false;\n    }\n    return result.tfa.mode === \"auth-and-writes\";\n  }\n  function failure(err) {\n    // pass if registry does not support profile endpoint\n    if (err.code === \"E500\" || err.code === \"E404\") {\n      // most likely a private registry (npm Enterprise, verdaccio, etc)\n      opts.log.warn(\n        \"EREGISTRY\",\n        `Registry \"${opts.registry}\" does not support 'npm profile get', skipping two-factor auth check...`\n      );\n      // don't log redundant errors\n      return false;\n    }\n    // Log the error cleanly to stderr\n    opts.log.pause();\n    console.error(err.message); // eslint-disable-line no-console\n    opts.log.resume();\n    throw new ValidationError(\"ETWOFACTOR\", \"Unable to obtain two-factor auth mode\");\n  }\n}", "llm_cg": {"getTwoFactorAuthRequired(options.Partial<FetchConfig>= {})": ["getFetchConfig(options.Partial<FetchConfig>, unknown)", "getProfileData(opts).then(success, failure)"], "success(result)": [], "failure(err)": []}, "static_cg": {}}
{"source_code": "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\nimport { RegisterClass } from \"../../../Misc/typeStore\";\nimport type { Scene } from \"../../../scene\";\nimport type { InputBlock } from \"./Input/inputBlock\";\nimport type { AbstractMesh } from \"../../../Meshes/abstractMesh\";\nimport type { NodeMaterial, NodeMaterialDefines } from \"../nodeMaterial\";\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"core/Decorators/nodeDecorator\";\nexport class TransformBlock extends NodeMaterialBlock {\n    public complementW = 1;\n    public complementZ = 0;\n    @editableInPropertyPage(\"Transform as direction\", PropertyTypeForEdition.Boolean, undefined, { embedded: true })\n    public get transformAsDirection() {\n        return this.complementW === 0;\n    }\n    public set transformAsDirection(value: boolean) {\n        this.complementW = value ? 0 : 1;\n    }\n    public constructor(name: string) {\n        super(name, NodeMaterialBlockTargets.Neutral);\n        this.target = NodeMaterialBlockTargets.Vertex;\n        this.registerInput(\"vector\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\n        this.registerInput(\"transform\", NodeMaterialBlockConnectionPointTypes.Matrix);\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Vector4);\n        this.registerOutput(\"xyz\", NodeMaterialBlockConnectionPointTypes.Vector3);\n        this._inputs[0].onConnectionObservable.add((other) => {\n            if (other.ownerBlock.isInput) {\n                const otherAsInput = other.ownerBlock as InputBlock;\n                if (otherAsInput.name === \"normal\" || otherAsInput.name === \"tangent\") {\n                    this.complementW = 0;\n                }\n            }\n        });\n    }\n    public override getClassName() {\n        return \"TransformBlock\";\n    }\n    public get vector(): NodeMaterialConnectionPoint {\n        return this._inputs[0];\n    }\n    public get output(): NodeMaterialConnectionPoint {\n        return this._outputs[0];\n    }\n    public get xyz(): NodeMaterialConnectionPoint {\n        return this._outputs[1];\n    }\n    public get transform(): NodeMaterialConnectionPoint {\n        return this._inputs[1];\n    }\n    protected override _buildBlock(state: NodeMaterialBuildState) {\n        super._buildBlock(state);\n        const vector = this.vector;\n        const transform = this.transform;\n        const vec4 = state._getShaderType(NodeMaterialBlockConnectionPointTypes.Vector4);\n        const vec3 = state._getShaderType(NodeMaterialBlockConnectionPointTypes.Vector3);\n        if (vector.connectedPoint) {\n            // None uniform scaling case.\n            if (this.complementW === 0 || this.transformAsDirection) {\n                const comments = `//${this.name}`;\n                state._emitFunctionFromInclude(\"helperFunctions\", comments);\n                state.sharedData.blocksWithDefines.push(this);\n                const transformName = state._getFreeVariableName(`${transform.associatedVariableName}_NUS`);\n                if (state.shaderLanguage === ShaderLanguage.WGSL) {\n                    state.compilationString += `var ${transformName}: mat3x3f = mat3x3f(${transform.associatedVariableName}[0].xyz, ${transform.associatedVariableName}[1].xyz, ${transform.associatedVariableName}[2].xyz);\\n`;\n                } else {\n                    state.compilationString += `mat3 ${transformName} = mat3(${transform.associatedVariableName});\\n`;\n                }\n                state.compilationString += `#ifdef NONUNIFORMSCALING\\n`;\n                state.compilationString += `${transformName} = transposeMat3(inverseMat3(${transformName}));\\n`;\n                state.compilationString += `#endif\\n`;\n                switch (vector.connectedPoint.type) {\n                    case NodeMaterialBlockConnectionPointTypes.Vector2:\n                        state.compilationString +=\n                            state._declareOutput(this.output) +\n                            ` = ${vec4}(${transformName} * ${vec3}(${vector.associatedVariableName}, ${this._writeFloat(this.complementZ)}), ${this._writeFloat(this.complementW)});\\n`;\n                        break;\n                    case NodeMaterialBlockConnectionPointTypes.Vector3:\n                    case NodeMaterialBlockConnectionPointTypes.Color3:\n                        state.compilationString +=\n                            state._declareOutput(this.output) + ` = ${vec4}(${transformName} * ${vector.associatedVariableName}, ${this._writeFloat(this.complementW)});\\n`;\n                        break;\n                    default:\n                        state.compilationString +=\n                            state._declareOutput(this.output) + ` = ${vec4}(${transformName} * ${vector.associatedVariableName}.xyz, ${this._writeFloat(this.complementW)});\\n`;\n                        break;\n                }\n            } else {\n                const transformName = transform.associatedVariableName;\n                switch (vector.connectedPoint.type) {\n                    case NodeMaterialBlockConnectionPointTypes.Vector2:\n                        state.compilationString +=\n                            state._declareOutput(this.output) +\n                            ` = ${transformName} * ${vec4}(${vector.associatedVariableName}, ${this._writeFloat(this.complementZ)}, ${this._writeFloat(this.complementW)});\\n`;\n                        break;\n                    case NodeMaterialBlockConnectionPointTypes.Vector3:\n                    case NodeMaterialBlockConnectionPointTypes.Color3:\n                        state.compilationString +=\n                            state._declareOutput(this.output) + ` = ${transformName} * ${vec4}(${vector.associatedVariableName}, ${this._writeFloat(this.complementW)});\\n`;\n                        break;\n                    default:\n                        state.compilationString += state._declareOutput(this.output) + ` = ${transformName} * ${vector.associatedVariableName};\\n`;\n                        break;\n                }\n            }\n            if (this.xyz.hasEndpoints) {\n                state.compilationString += state._declareOutput(this.xyz) + ` = ${this.output.associatedVariableName}.xyz;\\n`;\n            }\n        }\n        return this;\n    }\n    public override prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\n        // Do nothing\n        if (mesh.nonUniformScaling) {\n            defines.setValue(\"NONUNIFORMSCALING\", true);\n        }\n    }\n    public override serialize(): any {\n        const serializationObject = super.serialize();\n        serializationObject.complementZ = this.complementZ;\n        serializationObject.complementW = this.complementW;\n        return serializationObject;\n    }\n    public override _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\n        super._deserialize(serializationObject, scene, rootUrl);\n        this.complementZ = serializationObject.complementZ !== undefined ? serializationObject.complementZ : 0.0;\n        this.complementW = serializationObject.complementW !== undefined ? serializationObject.complementW : 1.0;\n    }\n    protected override _dumpPropertiesCode() {\n        let codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.complementZ = ${this.complementZ};\\n`;\n        codeString += `${this._codeVariableName}.complementW = ${this.complementW};\\n`;\n        return codeString;\n    }\n}\nRegisterClass(\"BABYLON.TransformBlock\", TransformBlock);", "llm_cg": {"TransformBlock.%AM0$constructor(string)": ["NodeMaterialBlock.constructor(string, NodeMaterialBlockTargets)", "TransformBlock.registerInput(string, NodeMaterialBlockConnectionPointTypes)", "TransformBlock.registerInput(string, NodeMaterialBlockConnectionPointTypes)", "TransformBlock.registerOutput(string, NodeMaterialBlockConnectionPointTypes)", "TransformBlock.registerOutput(string, NodeMaterialBlockConnectionPointTypes)", "InputBlock.isInput()", "TransformBlock.complementW(0)"], "TransformBlock.getClassName()": [], "TransformBlock.vector()": [], "TransformBlock.output()": [], "TransformBlock.xyz()": [], "TransformBlock.transform()": [], "TransformBlock._buildBlock(NodeMaterialBuildState)": ["NodeMaterialBlock._buildBlock(NodeMaterialBuildState)", "NodeMaterialBuildState._getShaderType(NodeMaterialBlockConnectionPointTypes)", "NodeMaterialBuildState._getShaderType(NodeMaterialBlockConnectionPointTypes)", "NodeMaterialBuildState._emitFunctionFromInclude(string, string)", "Array.push(NodeMaterialBlock)", "NodeMaterialBuildState._getFreeVariableName(string)", "NodeMaterialBuildState._declareOutput(NodeMaterialConnectionPoint)", "NodeMaterialBuildState._declareOutput(NodeMaterialConnectionPoint)", "NodeMaterialBuildState._declareOutput(NodeMaterialConnectionPoint)"], "TransformBlock.prepareDefines(AbstractMesh, NodeMaterial, NodeMaterialDefines)": ["NodeMaterialDefines.setValue(string, boolean)"], "TransformBlock.serialize()": ["NodeMaterialBlock.serialize()"], "TransformBlock._deserialize(any, Scene, string)": ["NodeMaterialBlock._deserialize(any, Scene, string)"], "TransformBlock._dumpPropertiesCode()": ["NodeMaterialBlock._dumpPropertiesCode()"]}, "static_cg": {"@test/160.ts: TransformBlock.constructor(string)": ["@test/160.ts: TransformBlock.%AM0$constructor(unknown)"]}}
{"source_code": "import { useMemo } from 'react';\nimport type { InternalDescriptionsItemType } from '..';\nimport { devUseWarning } from '../../_util/warning';\n// Calculate the sum of span in a row\nfunction getCalcRows(\n  rowItems: InternalDescriptionsItemType[],\n  mergedColumn: number,\n): [rows: InternalDescriptionsItemType[][], exceed: boolean] {\n  let rows: InternalDescriptionsItemType[][] = [];\n  let tmpRow: InternalDescriptionsItemType[] = [];\n  let exceed = false;\n  let count = 0;\n  rowItems\n    .filter((n) => n)\n    .forEach((rowItem) => {\n      const { filled, ...restItem } = rowItem;\n      if (filled) {\n        tmpRow.push(restItem);\n        rows.push(tmpRow);\n        // reset\n        tmpRow = [];\n        count = 0;\n        return;\n      }\n      const restSpan = mergedColumn - count;\n      count += rowItem.span || 1;\n      if (count >= mergedColumn) {\n        if (count > mergedColumn) {\n          exceed = true;\n          tmpRow.push({ ...restItem, span: restSpan });\n        } else {\n          tmpRow.push(restItem);\n        }\n        rows.push(tmpRow);\n        // reset\n        tmpRow = [];\n        count = 0;\n      } else {\n        tmpRow.push(restItem);\n      }\n    });\n  if (tmpRow.length > 0) {\n    rows.push(tmpRow);\n  }\n  rows = rows.map((rows) => {\n    const count = rows.reduce((acc, item) => acc + (item.span || 1), 0);\n    if (count < mergedColumn) {\n      // If the span of the last element in the current row is less than the column, then add its span to the remaining columns\n      const last = rows[rows.length - 1];\n      last.span = mergedColumn - count + 1;\n      return rows;\n    }\n    return rows;\n  });\n  return [rows, exceed];\n}\nconst useRow = (mergedColumn: number, items: InternalDescriptionsItemType[]) => {\n  const [rows, exceed] = useMemo(() => getCalcRows(items, mergedColumn), [items, mergedColumn]);\n  if (process.env.NODE_ENV !== 'production') {\n    const warning = devUseWarning('Descriptions');\n    warning(!exceed, 'usage', 'Sum of column `span` in a line not match `column` of Descriptions.');\n  }\n  return rows;\n};\nexport default useRow;", "llm_cg": {"useRow(mergedColumn:number, items:InternalDescriptionsItemType[])": ["%AM0$useMemo(() => getCalcRows(items, mergedColumn), [items, mergedColumn])", "%AM0$devUseWarning('Descriptions')", "getCalcRows(items:InternalDescriptionsItemType[], mergedColumn:number)"], "getCalcRows(rowItems:InternalDescriptionsItemType[], mergedColumn:number)": []}, "static_cg": {"@test/161.ts: %dflt.getCalcRows(InternalDescriptionsItemType[], number)": ["@test/161.ts: %dflt.%AM3$getCalcRows(unknown)", "@test/161.ts: %dflt.%AM2$getCalcRows([tmpRow, rows, count, mergedColumn, exceed], unknown)", "@test/161.ts: %dflt.%AM4$getCalcRows([mergedColumn], unknown)"], "@test/161.ts: %dflt.%AM1$%AM0()": ["@test/161.ts: %dflt.getCalcRows(InternalDescriptionsItemType[], number)"], "@test/161.ts: %dflt.%AM0(number, InternalDescriptionsItemType[])": ["@test/161.ts: %dflt.%AM1$%AM0()"], "@test/161.ts: %dflt.%AM4$getCalcRows([mergedColumn], unknown)": ["@test/161.ts: %dflt.%AM5$%AM4$getCalcRows(unknown, unknown)"]}}
{"source_code": "import {\n  joinPathFragments,\n  readJson,\n  updateJson,\n  type ProjectConfiguration,\n  type Tree,\n} from '@nx/devkit';\nexport function updateAppEditorTsConfigExcludedFiles(\n  tree: Tree,\n  projectConfig: ProjectConfiguration\n) {\n  if (projectConfig.projectType !== 'application') {\n    return;\n  }\n  const editorTsConfigPath = joinPathFragments(\n    projectConfig.root,\n    'tsconfig.editor.json'\n  );\n  const appTsConfigPath = joinPathFragments(\n    projectConfig.root,\n    'tsconfig.app.json'\n  );\n  if (!tree.exists(editorTsConfigPath) || !tree.exists(appTsConfigPath)) {\n    return;\n  }\n  const appTsConfig = readJson(tree, appTsConfigPath);\n  updateJson(tree, editorTsConfigPath, (json) => {\n    const exclude = [...(json.exclude ?? []), ...(appTsConfig.exclude ?? [])];\n    if (exclude.length) {\n      json.exclude = Array.from(new Set(exclude));\n    }\n    return json;\n  });\n}", "llm_cg": {"updateAppEditorTsConfigExcludedFiles(tree.Tree, projectConfig.ProjectConfiguration)": ["%AM0$joinPathFragments(string, string)", "%AM0$joinPathFragments(string, string)", "tree.exists(string)", "tree.exists(string)", "readJson(tree.Tree, string)", "updateJson(tree.Tree, string, function)"]}, "static_cg": {"@test/162.ts: %dflt.updateAppEditorTsConfigExcludedFiles(Tree, ProjectConfiguration)": ["@test/162.ts: %dflt.%AM0$updateAppEditorTsConfigExcludedFiles(unknown)"]}}
{"source_code": "import { Event } from '../../../../base/common/event.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { isWeb } from '../../../../base/common/platform.js';\nimport { isEqual } from '../../../../base/common/resources.js';\nimport { IUserDataProfilesService } from '../../../../platform/userDataProfile/common/userDataProfile.js';\nimport { IUserDataAutoSyncService } from '../../../../platform/userDataSync/common/userDataSync.js';\nimport { IWorkbenchContribution } from '../../../common/contributions.js';\nimport { EditorInput } from '../../../common/editor/editorInput.js';\nimport { IViewsService } from '../../../services/views/common/viewsService.js';\nimport { VIEWLET_ID } from '../../extensions/common/extensions.js';\nimport { IEditorService } from '../../../services/editor/common/editorService.js';\nimport { IHostService } from '../../../services/host/browser/host.js';\nimport { KeybindingsEditorInput } from '../../../services/preferences/browser/keybindingsEditorInput.js';\nimport { SettingsEditor2Input } from '../../../services/preferences/common/preferencesEditorInput.js';\nexport class UserDataSyncTrigger extends Disposable implements IWorkbenchContribution {\n\tconstructor(\n\t\t@IEditorService editorService: IEditorService,\n\t\t@IUserDataProfilesService private readonly userDataProfilesService: IUserDataProfilesService,\n\t\t@IViewsService viewsService: IViewsService,\n\t\t@IUserDataAutoSyncService userDataAutoSyncService: IUserDataAutoSyncService,\n\t\t@IHostService hostService: IHostService,\n\t) {\n\t\tsuper();\n\t\tconst event = Event.filter(\n\t\t\tEvent.any<string | undefined>(\n\t\t\t\tEvent.map(editorService.onDidActiveEditorChange, () => this.getUserDataEditorInputSource(editorService.activeEditor)),\n\t\t\t\tEvent.map(Event.filter(viewsService.onDidChangeViewContainerVisibility, e => e.id === VIEWLET_ID && e.visible), e => e.id)\n\t\t\t), source => source !== undefined);\n\t\tif (isWeb) {\n\t\t\tthis._register(Event.debounce<string, string[]>(\n\t\t\t\tEvent.any<string>(\n\t\t\t\t\tEvent.map(hostService.onDidChangeFocus, () => 'windowFocus'),\n\t\t\t\t\tEvent.map(event, source => source!),\n\t\t\t\t), (last, source) => last ? [...last, source] : [source], 1000)\n\t\t\t\t(sources => userDataAutoSyncService.triggerSync(sources, true, false)));\n\t\t} else {\n\t\t\tthis._register(event(source => userDataAutoSyncService.triggerSync([source!], true, false)));\n\t\t}\n\t}\n\tprivate getUserDataEditorInputSource(editorInput: EditorInput | undefined): string | undefined {\n\t\tif (!editorInput) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (editorInput instanceof SettingsEditor2Input) {\n\t\t\treturn 'settingsEditor';\n\t\t}\n\t\tif (editorInput instanceof KeybindingsEditorInput) {\n\t\t\treturn 'keybindingsEditor';\n\t\t}\n\t\tconst resource = editorInput.resource;\n\t\tif (isEqual(resource, this.userDataProfilesService.defaultProfile.settingsResource)) {\n\t\t\treturn 'settingsEditor';\n\t\t}\n\t\tif (isEqual(resource, this.userDataProfilesService.defaultProfile.keybindingsResource)) {\n\t\t\treturn 'keybindingsEditor';\n\t\t}\n\t\treturn undefined;\n\t}\n}", "llm_cg": {"UserDataSyncTrigger.constructor(editorService: IEditorService, userDataProfilesService: IUserDataProfilesService, viewsService: IViewsService, userDataAutoSyncService: IUserDataAutoSyncService, hostService: IHostService)": ["UserDataSyncTrigger.getUserDataEditorInputSource(EditorInput | undefined)", "UserDataAutoSyncService.triggerSync(string[], true, false)"], "UserDataSyncTrigger.getUserDataEditorInputSource(EditorInput | undefined)": ["isEqual(resource: unknown, settingsResource: unknown)", "isEqual(resource: unknown, keybindingsResource: unknown)"]}, "static_cg": {"@test/163.ts: UserDataSyncTrigger.constructor(IEditorService, IUserDataProfilesService, IViewsService, IUserDataAutoSyncService, IHostService)": ["@test/163.ts: UserDataSyncTrigger.%AM0$constructor([editorService])", "@test/163.ts: UserDataSyncTrigger.%AM1$constructor(unknown)", "@test/163.ts: UserDataSyncTrigger.%AM2$constructor(unknown)", "@test/163.ts: UserDataSyncTrigger.%AM3$constructor(unknown)", "@test/163.ts: UserDataSyncTrigger.%AM5$constructor()", "@test/163.ts: UserDataSyncTrigger.%AM6$constructor(unknown)", "@test/163.ts: UserDataSyncTrigger.%AM7$constructor(unknown, unknown)", "@test/163.ts: UserDataSyncTrigger.%AM4$constructor([userDataAutoSyncService], unknown)", "@test/163.ts: UserDataSyncTrigger.%AM8$constructor([userDataAutoSyncService], unknown)"], "@test/163.ts: UserDataSyncTrigger.%AM0$constructor([editorService])": ["@test/163.ts: UserDataSyncTrigger.getUserDataEditorInputSource(EditorInput|undefined)"]}}
{"source_code": "import type { IFederationServer, RocketChatRecordDeleted } from '@rocket.chat/core-typings';\nimport type { IFederationServersModel } from '@rocket.chat/model-typings';\nimport { Users } from '@rocket.chat/models';\nimport type { Collection, Db, IndexDescription, UpdateResult } from 'mongodb';\nimport { BaseRaw } from './BaseRaw';\nexport class FederationServersRaw extends BaseRaw<IFederationServer> implements IFederationServersModel {\n\tconstructor(db: Db, trash?: Collection<RocketChatRecordDeleted<IFederationServer>>) {\n\t\tsuper(db, 'federation_servers', trash);\n\t}\n\tprotected modelIndexes(): IndexDescription[] {\n\t\treturn [{ key: { domain: 1 } }];\n\t}\n\tsaveDomain(domain: string): Promise<UpdateResult> {\n\t\treturn this.updateOne(\n\t\t\t{ domain },\n\t\t\t{\n\t\t\t\t$setOnInsert: {\n\t\t\t\t\tdomain,\n\t\t\t\t},\n\t\t\t},\n\t\t\t{ upsert: true },\n\t\t);\n\t}\n\tasync refreshServers(): Promise<void> {\n\t\t// TODO remove model dependency - this logs should be inside a function/service and not in a model\n\t\tconst domains = await Users.getDistinctFederationDomains();\n\t\tfor await (const domain of domains) {\n\t\t\tawait this.saveDomain(domain);\n\t\t}\n\t\tawait this.deleteMany({ domain: { $nin: domains } });\n\t}\n}", "llm_cg": {"FederationServersRaw.saveDomain(string)": [], "FederationServersRaw.refreshServers()": ["Users.%AM0$getDistinctFederationDomains()", "FederationServersRaw.saveDomain(string)", "FederationServersRaw.deleteMany(object)"]}, "static_cg": {"@test/164.ts: FederationServersRaw.refreshServers()": ["@test/164.ts: FederationServersRaw.saveDomain(string)"]}}
{"source_code": "import type {VariantProps} from \"tailwind-variants\";\nimport {tv} from \"../utils/tv\";\nimport {colorVariants} from \"../utils\";\nconst snippet = tv({\n  slots: {\n    base: \"inline-flex items-center justify-between h-fit rounded-large gap-2\",\n    pre: \"bg-transparent text-inherit font-mono font-normal inline-block whitespace-nowrap\",\n    content: \"flex flex-col\",\n    symbol: \"select-none\",\n    copyButton: [\n      \"group\",\n      \"relative\",\n      \"z-10\",\n      \"text-large\",\n      \"text-inherit\",\n      \"data-[hover=true]:bg-transparent\",\n    ],\n    copyIcon: [\n      \"absolute text-inherit opacity-100 scale-100 group-data-[copied=true]:opacity-0 group-data-[copied=true]:scale-50\",\n    ],\n    checkIcon: [\n      \"absolute text-inherit opacity-0 scale-50 group-data-[copied=true]:opacity-100 group-data-[copied=true]:scale-100\",\n    ],\n  },\n  variants: {\n    variant: {\n      flat: \"\",\n      solid: \"\",\n      bordered: \"border-medium bg-transparent\",\n      shadow: \"\",\n    },\n    color: {\n      default: {},\n      primary: {},\n      secondary: {},\n      success: {},\n      warning: {},\n      danger: {},\n    },\n    size: {\n      sm: {\n        base: \"px-1.5 py-0.5 text-tiny rounded-small\",\n      },\n      md: {\n        base: \"px-3 py-1.5 text-small rounded-medium\",\n      },\n      lg: {\n        base: \"px-4 py-2 text-medium rounded-large\",\n      },\n    },\n    radius: {\n      none: {\n        base: \"rounded-none\",\n      },\n      sm: {\n        base: \"rounded-small\",\n      },\n      md: {\n        base: \"rounded-medium\",\n      },\n      lg: {\n        base: \"rounded-large\",\n      },\n    },\n    fullWidth: {\n      true: {\n        base: \"w-full\",\n      },\n    },\n    disableAnimation: {\n      true: {},\n      false: {\n        copyIcon: \"transition-transform-opacity\",\n        checkIcon: \"transition-transform-opacity\",\n      },\n    },\n  },\n  defaultVariants: {\n    color: \"default\",\n    variant: \"flat\",\n    size: \"md\",\n    fullWidth: false,\n  },\n  compoundVariants: [\n    // solid - shadow / color\n    {\n      variant: [\"solid\", \"shadow\"],\n      color: \"default\",\n      class: {\n        copyButton: \"data-[focus-visible]:outline-default-foreground\",\n      },\n    },\n    {\n      variant: [\"solid\", \"shadow\"],\n      color: \"primary\",\n      class: {\n        copyButton: \"data-[focus-visible]:outline-primary-foreground\",\n      },\n    },\n    {\n      variant: [\"solid\", \"shadow\"],\n      color: \"secondary\",\n      class: {\n        copyButton: \"data-[focus-visible]:outline-secondary-foreground\",\n      },\n    },\n    {\n      variant: [\"solid\", \"shadow\"],\n      color: \"success\",\n      class: {\n        copyButton: \"data-[focus-visible]:outline-success-foreground\",\n      },\n    },\n    {\n      variant: [\"solid\", \"shadow\"],\n      color: \"warning\",\n      class: {\n        copyButton: \"data-[focus-visible]:outline-warning-foreground\",\n      },\n    },\n    {\n      variant: [\"solid\", \"shadow\"],\n      color: \"danger\",\n      class: {\n        copyButton: \"data-[focus-visible]:outline-danger-foreground\",\n      },\n    },\n    // flat / color\n    {\n      variant: \"flat\",\n      color: \"default\",\n      class: {\n        base: colorVariants.flat.default,\n      },\n    },\n    {\n      variant: \"flat\",\n      color: \"primary\",\n      class: {\n        base: colorVariants.flat.primary,\n      },\n    },\n    {\n      variant: \"flat\",\n      color: \"secondary\",\n      class: {\n        base: colorVariants.flat.secondary,\n      },\n    },\n    {\n      variant: \"flat\",\n      color: \"success\",\n      class: {\n        base: colorVariants.flat.success,\n      },\n    },\n    {\n      variant: \"flat\",\n      color: \"warning\",\n      class: {\n        base: colorVariants.flat.warning,\n      },\n    },\n    {\n      variant: \"flat\",\n      color: \"danger\",\n      class: {\n        base: colorVariants.flat.danger,\n      },\n    },\n    // solid / color\n    {\n      variant: \"solid\",\n      color: \"default\",\n      class: {\n        base: colorVariants.solid.default,\n      },\n    },\n    {\n      variant: \"solid\",\n      color: \"primary\",\n      class: {\n        base: colorVariants.solid.primary,\n      },\n    },\n    {\n      variant: \"solid\",\n      color: \"secondary\",\n      class: {\n        base: colorVariants.solid.secondary,\n      },\n    },\n    {\n      variant: \"solid\",\n      color: \"success\",\n      class: {\n        base: colorVariants.solid.success,\n      },\n    },\n    {\n      variant: \"solid\",\n      color: \"warning\",\n      class: {\n        base: colorVariants.solid.warning,\n      },\n    },\n    {\n      variant: \"solid\",\n      color: \"danger\",\n      class: {\n        base: colorVariants.solid.danger,\n      },\n    },\n    // shadow / color\n    {\n      variant: \"shadow\",\n      color: \"default\",\n      class: {\n        base: colorVariants.shadow.default,\n      },\n    },\n    {\n      variant: \"shadow\",\n      color: \"primary\",\n      class: {\n        base: colorVariants.shadow.primary,\n      },\n    },\n    {\n      variant: \"shadow\",\n      color: \"secondary\",\n      class: {\n        base: colorVariants.shadow.secondary,\n      },\n    },\n    {\n      variant: \"shadow\",\n      color: \"success\",\n      class: {\n        base: colorVariants.shadow.success,\n      },\n    },\n    {\n      variant: \"shadow\",\n      color: \"warning\",\n      class: {\n        base: colorVariants.shadow.warning,\n      },\n    },\n    {\n      variant: \"shadow\",\n      color: \"danger\",\n      class: {\n        base: colorVariants.shadow.danger,\n      },\n    },\n    // bordered / color\n    {\n      variant: \"bordered\",\n      color: \"default\",\n      class: {\n        base: colorVariants.bordered.default,\n      },\n    },\n    {\n      variant: \"bordered\",\n      color: \"primary\",\n      class: {\n        base: colorVariants.bordered.primary,\n      },\n    },\n    {\n      variant: \"bordered\",\n      color: \"secondary\",\n      class: {\n        base: colorVariants.bordered.secondary,\n      },\n    },\n    {\n      variant: \"bordered\",\n      color: \"success\",\n      class: {\n        base: colorVariants.bordered.success,\n      },\n    },\n    {\n      variant: \"bordered\",\n      color: \"warning\",\n      class: {\n        base: colorVariants.bordered.warning,\n      },\n    },\n    {\n      variant: \"bordered\",\n      color: \"danger\",\n      class: {\n        base: colorVariants.bordered.danger,\n      },\n    },\n  ],\n});\nexport type SnippetVariantProps = VariantProps<typeof snippet>;\nexport type SnippetSlots = keyof ReturnType<typeof snippet>;\nexport {snippet};", "llm_cg": {"snippet.%AMX$colorVariants.flat.default()": [], "snippet.%AMX$colorVariants.flat.primary()": [], "snippet.%AMX$colorVariants.flat.secondary()": [], "snippet.%AMX$colorVariants.flat.success()": [], "snippet.%AMX$colorVariants.flat.warning()": [], "snippet.%AMX$colorVariants.flat.danger()": [], "snippet.%AMX$colorVariants.solid.default()": [], "snippet.%AMX$colorVariants.solid.primary()": [], "snippet.%AMX$colorVariants.solid.secondary()": [], "snippet.%AMX$colorVariants.solid.success()": [], "snippet.%AMX$colorVariants.solid.warning()": [], "snippet.%AMX$colorVariants.solid.danger()": [], "snippet.%AMX$colorVariants.shadow.default()": [], "snippet.%AMX$colorVariants.shadow.primary()": [], "snippet.%AMX$colorVariants.shadow.secondary()": [], "snippet.%AMX$colorVariants.shadow.success()": [], "snippet.%AMX$colorVariants.shadow.warning()": [], "snippet.%AMX$colorVariants.shadow.danger()": [], "snippet.%AMX$colorVariants.bordered.default()": [], "snippet.%AMX$colorVariants.bordered.primary()": [], "snippet.%AMX$colorVariants.bordered.secondary()": [], "snippet.%AMX$colorVariants.bordered.success()": [], "snippet.%AMX$colorVariants.bordered.warning()": [], "snippet.%AMX$colorVariants.bordered.danger()": []}, "static_cg": {}}
{"source_code": "import { Config, Disposable, Project } from \"../index\";\nexport class GitRepository {\n    // Construction\n    static open(path: string, options?: { refreshOnWindowFocus?: boolean | undefined }): GitRepository;\n    constructor(\n        path: string,\n        options?: {\n            refreshOnWindowFocus?: boolean | undefined;\n            config?: Config | undefined;\n            project?: Project | undefined;\n        },\n    );\n    // Lifecycle\n    destroy(): void;\n    isDestroyed(): boolean;\n    // Event Subscription\n    onDidDestroy(callback: () => void): Disposable;\n    onDidChangeStatus(callback: (event: RepoStatusChangedEvent) => void): Disposable;\n    onDidChangeStatuses(callback: () => void): Disposable;\n    // Repository Details\n    getType(): \"git\";\n    getPath(): string;\n    getWorkingDirectory(): string;\n    isProjectAtRoot(): boolean;\n    relativize(): string;\n    hasBranch(branch: string): boolean;\n    getShortHead(path?: string): string;\n    isSubmodule(path: string): boolean;\n    getAheadBehindCount(reference: string, path?: string): { ahead: number; behind: number };\n    getCachedUpstreamAheadBehindCount(path?: string): { ahead: number; behind: number };\n    getConfigValue(key: string, path?: string): string;\n    getOriginURL(path?: string): string;\n    getUpstreamBranch(path?: string): string | null;\n    getReferences(path?: string): { heads: string[]; remotes: string[]; tags: string[] };\n    getReferenceTarget(reference: string, path?: string): string;\n    // Reading Status\n    isPathModified(path: string): boolean;\n    isPathNew(path: string): boolean;\n    isPathIgnored(path: string): boolean;\n    getDirectoryStatus(path: string): number;\n    getPathStatus(path: string): number;\n    getCachedPathStatus(path: string): number | null;\n    isStatusModified(status: number): boolean;\n    isStatusNew(status: number): boolean;\n    // Retrieving Diffs\n    getDiffStats(path: string): { added: number; deleted: number };\n    getLineDiffs(\n        path: string,\n        text: string,\n    ): Array<{ oldStart: number; newStart: number; oldLines: number; newLines: number }>;\n    // Checking Out\n    checkoutHead(path: string): boolean;\n    checkoutReference(reference: string, create: boolean): boolean;\n}\nexport interface RepoStatusChangedEvent {\n    path: string;\n    pathStatus: number;\n}", "llm_cg": {"GitRepository.destroy()": [], "GitRepository.isDestroyed()": [], "GitRepository.onDidDestroy(callback: () => void)": [], "GitRepository.onDidChangeStatus(callback: (event: RepoStatusChangedEvent) => void)": [], "GitRepository.onDidChangeStatuses(callback: () => void)": [], "GitRepository.getType()": [], "GitRepository.getPath()": [], "GitRepository.getWorkingDirectory()": [], "GitRepository.isProjectAtRoot()": [], "GitRepository.relativize()": [], "GitRepository.hasBranch(branch: string)": [], "GitRepository.getShortHead(path?: string)": [], "GitRepository.isSubmodule(path: string)": [], "GitRepository.getAheadBehindCount(reference: string, path?: string)": [], "GitRepository.getCachedUpstreamAheadBehindCount(path?: string)": [], "GitRepository.getConfigValue(key: string, path?: string)": [], "GitRepository.getOriginURL(path?: string)": [], "GitRepository.getUpstreamBranch(path?: string)": [], "GitRepository.getReferences(path?: string)": [], "GitRepository.getReferenceTarget(reference: string, path?: string)": [], "GitRepository.isPathModified(path: string)": [], "GitRepository.isPathNew(path: string)": [], "GitRepository.isPathIgnored(path: string)": [], "GitRepository.getDirectoryStatus(path: string)": [], "GitRepository.getPathStatus(path: string)": [], "GitRepository.getCachedPathStatus(path: string)": [], "GitRepository.isStatusModified(status: number)": [], "GitRepository.isStatusNew(status: number)": [], "GitRepository.getDiffStats(path: string)": [], "GitRepository.getLineDiffs(path: string, text: string)": [], "GitRepository.checkoutHead(path: string)": [], "GitRepository.checkoutReference(reference: string, create: boolean)": []}, "static_cg": {}}
{"source_code": "// 3.8.4 Assignment Compatibility\ninterface Applicable {\n    apply(blah: any); // also works for 'apply'\n}\nvar x: Applicable;\n// Should fail\nx = '';\nx = [''];\nx = 4;\nx = {};\n// Should work\nfunction f() { };\nx = f;\nfunction fn(c: Applicable) { }\n// Should Fail\nfn('');\nfn(['']);\nfn(4);\nfn({});\n// Should work\nfn(a => { });", "llm_cg": {"": []}, "static_cg": {"@test/167.ts: %dflt.[static]%dflt()": ["@test/167.ts: %dflt.fn(@test/167.ts: Applicable)", "@test/167.ts: %dflt.%AM0(unknown)"]}}
{"source_code": "import { logger } from '@storybook/core/node-logger';\nimport getDefaultBrowser from '@aw-web-design/x-default-browser';\nimport betterOpn from 'better-opn';\n// betterOpn alias used because also loading open\nimport open from 'open';\nimport { dedent } from 'ts-dedent';\nexport function openInBrowser(address: string) {\n  const browserEnvVar = process.env.BROWSER;\n  const userBrowserIsChrome =\n    browserEnvVar === 'chrome' ||\n    browserEnvVar === 'chromium' ||\n    browserEnvVar === 'brave' ||\n    browserEnvVar === 'com.brave.browser';\n  const openOptions = browserEnvVar ? { app: { name: browserEnvVar } } : {};\n  getDefaultBrowser(async (err: any, res: any) => {\n    try {\n      if (\n        res &&\n        (res.isChrome ||\n          res.isChromium ||\n          res.identity === 'com.brave.browser' ||\n          userBrowserIsChrome)\n      ) {\n        // We use betterOpn for Chrome because it is better at handling which chrome tab\n        // or window the preview loads in.\n        await betterOpn(address);\n      } else {\n        await open(address, openOptions);\n      }\n    } catch (error) {\n      logger.error(dedent`\n        Could not open ${address} inside a browser. If you're running this command inside a\n        docker container or on a CI, you need to pass the '--ci' flag to prevent opening a\n        browser by default.\n      `);\n    }\n  });\n}", "llm_cg": {"openInBrowser(address: string)": ["getDefaultBrowser(%AMX$anonymousFunction(error, result))"], "%AMX$anonymousFunction(error, result)": ["betterOpn(address)", "open(address, openOptions)"]}, "static_cg": {"@test/168.ts: %dflt.openInBrowser(string)": ["@test/168.ts: %dflt.%AM0$openInBrowser([userBrowserIsChrome, address, openOptions], any, any)"]}}
{"source_code": "import { Route } from '@/types';\nimport cache from '@/utils/cache';\nimport { getProviderList } from './utils';\nimport InvalidParameterError from '@/errors/types/invalid-parameter';\nexport const route: Route = {\n    path: '/news/providers/:region/list',\n    categories: ['new-media', 'popular'],\n    example: '/yahoo/news/providers/tw/list',\n    parameters: { region: '地区, 同路由\"新闻来源\"中的支持地区, 即 hk 或 tw' },\n    features: {\n        requireConfig: false,\n        requirePuppeteer: false,\n        antiCrawler: false,\n        supportBT: false,\n        supportPodcast: false,\n        supportScihub: false,\n    },\n    radar: [\n        {\n            source: ['hk.news.yahoo.com/'],\n        },\n        {\n            source: ['tw.news.yahoo.com/'],\n        },\n    ],\n    name: '新聞來源列表',\n    maintainers: ['TonyRL', 'williamgateszhao'],\n    handler,\n};\nasync function handler(ctx) {\n    const region = ctx.req.param('region');\n    if (!['hk', 'tw'].includes(region)) {\n        throw new InvalidParameterError(`Unknown region: ${region}`);\n    }\n    const providerList = await getProviderList(region, cache.tryGet);\n    const items = providerList.map((provider) => ({\n        ...provider,\n        description: provider.key,\n    }));\n    return {\n        title: 'Yahoo 新聞 - 新聞來源列表',\n        link: `https://${region}.news.yahoo.com`,\n        image: 'https://s.yimg.com/cv/apiv2/social/images/yahoo_default_logo-1200x1200.png',\n        item: items,\n    };\n}", "llm_cg": {"handler(ctx)": ["ctx.req.param(unknown)", "InvalidParameterError.%AMX$constructor(string)", "getProviderList(string, function)", "providerList.map(function)"], "providerList.%AMX$map(function)": []}, "static_cg": {"@test/169.ts: %dflt.handler(unknown)": ["@test/169.ts: %dflt.%AM0$handler(unknown)"]}}
{"source_code": "import type { Completion, TernCompletionResult } from \"./CodemirrorTernService\";\nexport const getCompletionsForKeyword = (\n  completion: Completion<TernCompletionResult>,\n  cursorHorizontalPos: number,\n) => {\n  const keywordName = completion.text;\n  // indentation needs to be positive number\n  const indentation = cursorHorizontalPos < 0 ? 0 : cursorHorizontalPos;\n  const indentationSpace = \" \".repeat(indentation);\n  const completions = [];\n  switch (keywordName) {\n    // loops\n    case \"for\":\n      completions.push({\n        ...completion,\n        name: \"for-loop\",\n        text: `for(let i=0;i < array.length;i++){\\n${indentationSpace}\\tconst element = array[i];\\n${indentationSpace}}`,\n        render: (element: HTMLElement) => {\n          element.setAttribute(\"keyword\", \"For Loop\");\n          element.innerHTML = completion.text;\n        },\n      });\n      completions.push({\n        ...completion,\n        name: \"for-in-loop\",\n        text: `for(const key in object) {\\n${indentationSpace}}`,\n        render: (element: HTMLElement) => {\n          element.setAttribute(\"keyword\", \"For-in Loop\");\n          element.innerHTML = \"forin\";\n        },\n      });\n      completions.push({\n        ...completion,\n        name: \"for-of-loop\",\n        text: `for(const iterator of object){\\n${indentationSpace}}`,\n        render: (element: HTMLElement) => {\n          element.setAttribute(\"keyword\", \"For-of Loop\");\n          element.innerHTML = \"forof\";\n        },\n      });\n      break;\n    case \"while\":\n      completions.push({\n        ...completion,\n        name: \"while-loop\",\n        text: `while(condition){\\n${indentationSpace}}`,\n        render: (element: HTMLElement) => {\n          element.setAttribute(\"keyword\", \"While Statement\");\n          element.innerHTML = completion.text;\n        },\n      });\n      break;\n    case \"do\":\n      completions.push({\n        ...completion,\n        name: \"do-while-statement\",\n        text: `do{\\n\\n${indentationSpace}} while (condition);`,\n        render: (element: HTMLElement) => {\n          element.setAttribute(\"keyword\", \"do-While Statement\");\n          element.innerHTML = completion.text;\n        },\n      });\n      break;\n    // conditional statement\n    case \"if\":\n      completions.push({\n        ...completion,\n        name: \"if-statement\",\n        text: `if(condition){\\n\\n${indentationSpace}}`,\n        render: (element: HTMLElement) => {\n          element.setAttribute(\"keyword\", \"if Statement\");\n          element.innerHTML = completion.text;\n        },\n      });\n      break;\n    case \"switch\":\n      completions.push({\n        ...completion,\n        name: \"switch-statement\",\n        text: `switch(key){\\n${indentationSpace}\\tcase value:\\n${indentationSpace}\\t\\tbreak;\\n${indentationSpace}\\tdefault:\\n${indentationSpace}\\t\\tbreak;\\n${indentationSpace}}`,\n        render: (element: HTMLElement) => {\n          element.setAttribute(\"keyword\", \"Switch Statement\");\n          element.innerHTML = completion.text;\n        },\n      });\n      break;\n    case \"function\":\n      completions.push({\n        ...completion,\n        name: \"function-statement\",\n        text: `function name(params){\\n\\n${indentationSpace}}`,\n        render: (element: HTMLElement) => {\n          element.setAttribute(\"keyword\", \"Function Statement\");\n          element.innerHTML = completion.text;\n        },\n      });\n      break;\n    case \"try\":\n      completions.push({\n        ...completion,\n        name: \"try-catch\",\n        text: `try{\\n\\n${indentationSpace}}catch(error){\\n\\n${indentationSpace}}`,\n        render: (element: HTMLElement) => {\n          element.setAttribute(\"keyword\", \"Try-catch Statement\");\n          element.innerHTML = \"try-catch\";\n        },\n      });\n      break;\n    case \"throw\":\n      completions.push({\n        ...completion,\n        name: \"throw-exception\",\n        text: `throw new Error(\"\");`,\n        render: (element: HTMLElement) => {\n          element.setAttribute(\"keyword\", \"Throw Exception\");\n          element.innerHTML = completion.text;\n        },\n      });\n      break;\n    case \"new\":\n      completions.push({\n        ...completion,\n        name: \"new-statement\",\n        text: `const name = new type(arguments);`,\n        render: (element: HTMLElement) => {\n          element.setAttribute(\"keyword\", \"new Statement\");\n          element.innerHTML = completion.text;\n        },\n      });\n      break;\n    case \"async\":\n      completions.push(\n        {\n          ...completion,\n          name: \"async-function\",\n          text: `async function() {\\n\\n${indentationSpace}}`,\n          render: (element: HTMLElement) => {\n            element.setAttribute(\"keyword\", \"async Function Statement\");\n            element.innerHTML = completion.text;\n          },\n        },\n        {\n          ...completion,\n          name: \"async-arrow-function\",\n          text: `async () => {\\n\\n${indentationSpace}}`,\n          render: (element: HTMLElement) => {\n            element.setAttribute(\"keyword\", \"async Arrow Function Statement\");\n            element.innerHTML = completion.text;\n          },\n        },\n      );\n      break;\n  }\n  return completions;\n};", "llm_cg": {"getCompletionsForKeyword(completion, cursorHorizontalPos)": ["%AMX$render(element)", "%AMX$render(element)", "%AMX$render(element)", "%AMX$render(element)", "%AMX$render(element)", "%AMX$render(element)", "%AMX$render(element)", "%AMX$render(element)", "%AMX$render(element)", "%AMX$render(element)", "%AMX$render(element)", "%AMX$render(element)"]}, "static_cg": {}}
{"source_code": "import {Component, signal} from '@angular/core';\nimport {ComponentFixture, TestBed} from '@angular/core/testing';\nimport {HarnessLoader} from '@angular/cdk/testing';\nimport {DateAdapter, provideNativeDateAdapter} from '@angular/material/core';\nimport {TestbedHarnessEnvironment} from '@angular/cdk/testing/testbed';\nimport {NoopAnimationsModule} from '@angular/platform-browser/animations';\nimport {MatTimepicker, MatTimepickerInput, MatTimepickerToggle} from '@angular/material/timepicker';\nimport {MatTimepickerToggleHarness} from './timepicker-toggle-harness';\ndescribe('MatTimepickerToggleHarness', () => {\n  let fixture: ComponentFixture<TimepickerHarnessTest>;\n  let loader: HarnessLoader;\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      providers: [provideNativeDateAdapter()],\n      imports: [NoopAnimationsModule, TimepickerHarnessTest],\n    });\n    const adapter = TestBed.inject(DateAdapter);\n    adapter.setLocale('en-US');\n    fixture = TestBed.createComponent(TimepickerHarnessTest);\n    fixture.detectChanges();\n    loader = TestbedHarnessEnvironment.documentRootLoader(fixture);\n  });\n  it('should be able to load timepicker toggle harnesses', async () => {\n    const harnesses = await loader.getAllHarnesses(MatTimepickerToggleHarness);\n    expect(harnesses.length).toBe(2);\n  });\n  it('should get the open state of a timepicker toggle', async () => {\n    const toggle = await loader.getHarness(MatTimepickerToggleHarness.with({selector: '#one'}));\n    expect(await toggle.isTimepickerOpen()).toBe(false);\n    await toggle.openTimepicker();\n    expect(await toggle.isTimepickerOpen()).toBe(true);\n  });\n  it('should get the disabled state of a toggle', async () => {\n    const toggle = await loader.getHarness(MatTimepickerToggleHarness.with({selector: '#one'}));\n    expect(await toggle.isDisabled()).toBe(false);\n    fixture.componentInstance.disabled.set(true);\n    expect(await toggle.isDisabled()).toBe(true);\n  });\n});\n@Component({\n  template: `\n    <input [matTimepicker]=\"onePicker\">\n    <mat-timepicker #onePicker/>\n    <mat-timepicker-toggle id=\"one\" [for]=\"onePicker\" [disabled]=\"disabled()\"/>\n    <input [matTimepicker]=\"twoPicker\">\n    <mat-timepicker #twoPicker/>\n    <mat-timepicker-toggle id=\"two\" [for]=\"twoPicker\" [disabled]=\"disabled()\"/>\n  `,\n  standalone: true,\n  imports: [MatTimepickerInput, MatTimepicker, MatTimepickerToggle],\n})\nclass TimepickerHarnessTest {\n  disabled = signal(false);\n}", "llm_cg": {"describe('MatTimepickerToggleHarness')(unknown)": ["beforeEach(() => { })(unknown)", "it('should be able to load timepicker toggle harnesses', async () => { })(unknown)", "it('should get the open state of a timepicker toggle', async () => { })(unknown)", "it('should get the disabled state of a toggle', async () => { })(unknown)"], "beforeEach(() => { })(unknown)": ["TestBed.configureTestingModule({ providers: [provideNativeDateAdapter()], imports: [NoopAnimationsModule, TimepickerHarnessTest] })(unknown)", "TestBed.inject(DateAdapter)(unknown)", "adapter.setLocale('en-US')(unknown)", "TestBed.createComponent(TimepickerHarnessTest)(unknown)", "fixture.detectChanges()(unknown)", "TestbedHarnessEnvironment.documentRootLoader(fixture)(unknown)"], "it('should be able to load timepicker toggle harnesses', async () => { })(unknown)": ["loader.getAllHarnesses(MatTimepickerToggleHarness)(unknown)", "expect(harnesses.length).toBe(2)(unknown)"], "it('should get the open state of a timepicker toggle', async () => { })(unknown)": ["loader.getHarness(MatTimepickerToggleHarness.with({ selector: '#one' }))(unknown)", "toggle.isTimepickerOpen()(unknown)", "toggle.openTimepicker()(unknown)", "toggle.isTimepickerOpen()(unknown)"], "it('should get the disabled state of a toggle', async () => { })(unknown)": ["loader.getHarness(MatTimepickerToggleHarness.with({ selector: '#one' }))(unknown)", "toggle.isDisabled()(unknown)", "fixture.componentInstance.disabled.set(true)(unknown)", "toggle.isDisabled()(unknown)"]}, "static_cg": {"@test/171.ts: %dflt.[static]%dflt()": ["@test/171.ts: %dflt.%AM0()"], "@test/171.ts: %dflt.%AM0()": ["@test/171.ts: %dflt.%AM1$%AM0()", "@test/171.ts: %dflt.%AM2$%AM0()", "@test/171.ts: %dflt.%AM3$%AM0()", "@test/171.ts: %dflt.%AM4$%AM0()"]}}
{"source_code": "import { Route } from '@/types';\nimport cache from '@/utils/cache';\nimport got from '@/utils/got';\nimport { load } from 'cheerio';\nexport const route: Route = {\n    path: '/database_month',\n    categories: ['programming'],\n    example: '/aliyun/database_month',\n    parameters: {},\n    features: {\n        requireConfig: false,\n        requirePuppeteer: false,\n        antiCrawler: false,\n        supportBT: false,\n        supportPodcast: false,\n        supportScihub: false,\n    },\n    radar: [\n        {\n            source: ['mysql.taobao.org/monthly', 'mysql.taobao.org/'],\n        },\n    ],\n    name: '数据库内核月报',\n    maintainers: ['junbaor'],\n    handler,\n    url: 'mysql.taobao.org/monthly',\n};\nasync function handler() {\n    const url = 'http://mysql.taobao.org/monthly/';\n    const response = await got({ method: 'get', url });\n    const $ = load(response.data);\n    const list = $(\"ul[class='posts'] > li\")\n        .map((i, e) => {\n            const element = $(e);\n            const title = element.find('a').text().trim();\n            const link = `http://mysql.taobao.org${element.find('a').attr('href').trim()}/`;\n            return {\n                title,\n                description: '',\n                link,\n            };\n        })\n        .get();\n    const result = await Promise.all(\n        list.map((item) => {\n            const link = item.link;\n            return cache.tryGet(link, async () => {\n                const itemReponse = await got(link);\n                const itemElement = load(itemReponse.data);\n                item.description = itemElement('.content').html();\n                return item;\n            });\n        })\n    );\n    return {\n        title: $('title').text(),\n        link: url,\n        item: result.reverse(),\n    };\n}", "llm_cg": {"handler()": ["%AM0$handlerNested()"], "%AM0$handlerNested()": ["cache.tryGet(unknown, unknown)"]}, "static_cg": {"@test/172.ts: %dflt.handler()": ["@test/172.ts: %dflt.%AM0$handler([$], unknown, unknown)", "@test/172.ts: %dflt.%AM1$handler(unknown)"], "@test/172.ts: %dflt.%AM1$handler(unknown)": ["@test/172.ts: %dflt.%AM2$%AM1$handler()"]}}
{"source_code": "'use strict'\nimport { Range, SemanticTokens, SemanticTokensLegend } from \"vscode-languageserver-types\"\nfunction isStringArray(value: any): value is string[] {\n  return Array.isArray(value) && (value as any[]).every(elem => typeof elem === 'string')\n}\nfunction isStrArrayOrUndefined(arg: any): arg is string[] | undefined {\n  return ((typeof arg === 'undefined') || isStringArray(arg))\n}\nexport class SemanticTokensBuilder {\n  private _prevLine: number\n  private _prevChar: number\n  private _dataIsSortedAndDeltaEncoded: boolean\n  private _data: number[]\n  private _dataLen: number\n  private _tokenTypeStrToInt: Map<string, number>\n  private _tokenModifierStrToInt: Map<string, number>\n  private _hasLegend: boolean\n  constructor(legend?: SemanticTokensLegend) {\n    this._prevLine = 0\n    this._prevChar = 0\n    this._dataIsSortedAndDeltaEncoded = true\n    this._data = []\n    this._dataLen = 0\n    this._tokenTypeStrToInt = new Map<string, number>()\n    this._tokenModifierStrToInt = new Map<string, number>()\n    this._hasLegend = false\n    if (legend) {\n      this._hasLegend = true\n      for (let i = 0, len = legend.tokenTypes.length; i < len; i++) {\n        this._tokenTypeStrToInt.set(legend.tokenTypes[i], i)\n      }\n      for (let i = 0, len = legend.tokenModifiers.length; i < len; i++) {\n        this._tokenModifierStrToInt.set(legend.tokenModifiers[i], i)\n      }\n    }\n  }\n  public push(line: number, char: number, length: number, tokenType: number, tokenModifiers?: number): void\n  public push(range: Range, tokenType: string, tokenModifiers?: string[]): void\n  public push(arg0: any, arg1: any, arg2: any, arg3?: any, arg4?: any): void {\n    if (typeof arg0 === 'number' && typeof arg1 === 'number' && typeof arg2 === 'number' && typeof arg3 === 'number' && (typeof arg4 === 'number' || typeof arg4 === 'undefined')) {\n      if (typeof arg4 === 'undefined') {\n        arg4 = 0\n      }\n      // 1st overload\n      return this._pushEncoded(arg0, arg1, arg2, arg3, arg4)\n    }\n    if (Range.is(arg0) && typeof arg1 === 'string' && isStrArrayOrUndefined(arg2)) {\n      // 2nd overload\n      return this._push(arg0, arg1, arg2)\n    }\n    throw new Error('Illegal argument')\n  }\n  private _push(range: Range, tokenType: string, tokenModifiers?: string[]): void {\n    if (!this._hasLegend) {\n      throw new Error('Legend must be provided in constructor')\n    }\n    if (range.start.line !== range.end.line) {\n      throw new Error('`range` cannot span multiple lines')\n    }\n    if (!this._tokenTypeStrToInt.has(tokenType)) {\n      throw new Error('`tokenType` is not in the provided legend')\n    }\n    const line = range.start.line\n    const char = range.start.character\n    const length = range.end.character - range.start.character\n    const nTokenType = this._tokenTypeStrToInt.get(tokenType)!\n    let nTokenModifiers = 0\n    if (tokenModifiers) {\n      for (const tokenModifier of tokenModifiers) {\n        if (!this._tokenModifierStrToInt.has(tokenModifier)) {\n          throw new Error('`tokenModifier` is not in the provided legend')\n        }\n        const nTokenModifier = this._tokenModifierStrToInt.get(tokenModifier)!\n        nTokenModifiers |= (1 << nTokenModifier) >>> 0\n      }\n    }\n    this._pushEncoded(line, char, length, nTokenType, nTokenModifiers)\n  }\n  private _pushEncoded(line: number, char: number, length: number, tokenType: number, tokenModifiers: number): void {\n    if (this._dataIsSortedAndDeltaEncoded && (line < this._prevLine || (line === this._prevLine && char < this._prevChar))) {\n      // push calls were ordered and are no longer ordered\n      this._dataIsSortedAndDeltaEncoded = false\n      // Remove delta encoding from data\n      const tokenCount = (this._data.length / 5) | 0\n      let prevLine = 0\n      let prevChar = 0\n      for (let i = 0; i < tokenCount; i++) {\n        let line = this._data[5 * i]\n        let char = this._data[5 * i + 1]\n        if (line === 0) {\n          // on the same line as previous token\n          line = prevLine\n          char += prevChar\n        } else {\n          // on a different line than previous token\n          line += prevLine\n        }\n        this._data[5 * i] = line\n        this._data[5 * i + 1] = char\n        prevLine = line\n        prevChar = char\n      }\n    }\n    let pushLine = line\n    let pushChar = char\n    if (this._dataIsSortedAndDeltaEncoded && this._dataLen > 0) {\n      pushLine -= this._prevLine\n      if (pushLine === 0) {\n        pushChar -= this._prevChar\n      }\n    }\n    this._data[this._dataLen++] = pushLine\n    this._data[this._dataLen++] = pushChar\n    this._data[this._dataLen++] = length\n    this._data[this._dataLen++] = tokenType\n    this._data[this._dataLen++] = tokenModifiers\n    this._prevLine = line\n    this._prevChar = char\n  }\n  private static _sortAndDeltaEncode(data: number[]): number[] {\n    let pos: number[] = []\n    const tokenCount = (data.length / 5) | 0\n    for (let i = 0; i < tokenCount; i++) {\n      pos[i] = i\n    }\n    pos.sort((a, b) => {\n      const aLine = data[5 * a]\n      const bLine = data[5 * b]\n      if (aLine === bLine) {\n        const aChar = data[5 * a + 1]\n        const bChar = data[5 * b + 1]\n        return aChar - bChar\n      }\n      return aLine - bLine\n    })\n    const result = new Array<number>(data.length)\n    let prevLine = 0\n    let prevChar = 0\n    for (let i = 0; i < tokenCount; i++) {\n      const srcOffset = 5 * pos[i]\n      const line = data[srcOffset + 0]\n      const char = data[srcOffset + 1]\n      const length = data[srcOffset + 2]\n      const tokenType = data[srcOffset + 3]\n      const tokenModifiers = data[srcOffset + 4]\n      const pushLine = line - prevLine\n      const pushChar = (pushLine === 0 ? char - prevChar : char)\n      const dstOffset = 5 * i\n      result[dstOffset + 0] = pushLine\n      result[dstOffset + 1] = pushChar\n      result[dstOffset + 2] = length\n      result[dstOffset + 3] = tokenType\n      result[dstOffset + 4] = tokenModifiers\n      prevLine = line\n      prevChar = char\n    }\n    return result\n  }\n  public build(resultId?: string): SemanticTokens {\n    if (!this._dataIsSortedAndDeltaEncoded) {\n      return { data: SemanticTokensBuilder._sortAndDeltaEncode(this._data), resultId }\n    }\n    return { data: this._data, resultId }\n  }\n}", "llm_cg": {"SemanticTokensBuilder.constructor([SemanticTokensLegend]?)": [], "SemanticTokensBuilder.push(number, number, number, number, number?)": ["SemanticTokensBuilder.%AM0$_pushEncoded(number, number, number, number, number)"], "SemanticTokensBuilder.push(Range, string, string[]?)": ["SemanticTokensBuilder.%AM0$_push(Range, string, string[]?)"], "SemanticTokensBuilder.push(unknown, unknown, unknown, unknown?, unknown?)": ["SemanticTokensBuilder.push(number, number, number, number, number?)", "SemanticTokensBuilder.push(Range, string, string[]?)"], "SemanticTokensBuilder.%AM0$_push(Range, string, string[]?)": ["SemanticTokensBuilder.%AM0$_pushEncoded(number, number, number, number, number)"], "SemanticTokensBuilder.build(string?)": ["SemanticTokensBuilder.%AM1$_sortAndDeltaEncode(number[])"]}, "static_cg": {"@test/173.ts: %dflt.isStringArray(any)": ["@test/173.ts: %dflt.%AM0$isStringArray(unknown)"], "@test/173.ts: %dflt.isStrArrayOrUndefined(any)": ["@test/173.ts: %dflt.isStringArray(any)"], "@test/173.ts: SemanticTokensBuilder.push(any, any, any, any, any)": ["@test/173.ts: SemanticTokensBuilder._pushEncoded(number, number, number, number, number)", "@test/173.ts: %dflt.isStrArrayOrUndefined(any)", "@test/173.ts: SemanticTokensBuilder._push(Range, string, string[])"], "@test/173.ts: SemanticTokensBuilder._push(Range, string, string[])": ["@test/173.ts: SemanticTokensBuilder._pushEncoded(number, number, number, number, number)"], "@test/173.ts: SemanticTokensBuilder.[static]_sortAndDeltaEncode(number[])": ["@test/173.ts: SemanticTokensBuilder.%AM0$_sortAndDeltaEncode([data], unknown, unknown)"], "@test/173.ts: %AC$SemanticTokensBuilder$build$0.%instInit()": ["@test/173.ts: SemanticTokensBuilder.[static]_sortAndDeltaEncode(number[])"]}}
{"source_code": "import { colors } from 'playwright-core/lib/utilsBundle';\nimport type { ExpectMatcherState } from '../../types/test';\nimport type { Locator } from 'playwright-core';\nimport type { StackFrame } from '@protocol/channels';\nimport { stringifyStackFrames } from 'playwright-core/lib/utils';\nexport const kNoElementsFoundError = '<element(s) not found>';\nexport function matcherHint(state: ExpectMatcherState, locator: Locator | undefined, matcherName: string, expression: any, actual: any, matcherOptions: any, timeout?: number) {\n  let header = state.utils.matcherHint(matcherName, expression, actual, matcherOptions).replace(/ \\/\\/ deep equality/, '') + '\\n\\n';\n  if (timeout)\n    header = colors.red(`Timed out ${timeout}ms waiting for `) + header;\n  if (locator)\n    header += `Locator: ${String(locator)}\\n`;\n  return header;\n}\nexport type MatcherResult<E, A> = {\n  name: string;\n  expected?: E;\n  message: () => string;\n  pass: boolean;\n  actual?: A;\n  log?: string[];\n  timeout?: number;\n  suggestedRebaseline?: string;\n};\nexport type MatcherResultProperty = Omit<MatcherResult<unknown, unknown>, 'message'> & {\n  message: string;\n};\ntype JestError = Error & {\n  matcherResult: MatcherResultProperty;\n};\nexport class ExpectError extends Error {\n  matcherResult: MatcherResultProperty;\n  constructor(jestError: JestError, customMessage: string, stackFrames: StackFrame[]) {\n    super('');\n    // Copy to erase the JestMatcherError constructor name from the console.log(error).\n    this.name = jestError.name;\n    this.message = jestError.message;\n    this.matcherResult = jestError.matcherResult;\n    if (customMessage)\n      this.message = customMessage + '\\n\\n' + this.message;\n    this.stack = this.name + ': ' + this.message + '\\n' + stringifyStackFrames(stackFrames).join('\\n');\n  }\n}\nexport function isJestError(e: unknown): e is JestError {\n  return e instanceof Error && 'matcherResult' in e;\n}", "llm_cg": {"ExpectError.constructor(JestError, string, StackFrame[])": ["ExpectError.%AM0$stringifyStackFrames(StackFrame[])"]}, "static_cg": {}}
{"source_code": "import { UnavailabilityError } from 'expo-modules-core';\nimport { ParsedURL, SendIntentExtras, URLListener } from './Linking.types';\nexport function addEventListener(type: 'url', handler: URLListener) {\n  return { remove() {} };\n}\nexport async function parseInitialURLAsync(): Promise<ParsedURL> {\n  return {\n    scheme: null,\n    hostname: null,\n    path: null,\n    queryParams: null,\n  };\n}\nexport async function sendIntent(action: string, extras?: SendIntentExtras[]): Promise<void> {\n  throw new UnavailabilityError('Linking', 'sendIntent');\n}\nexport async function openSettings(): Promise<void> {\n  throw new UnavailabilityError('Linking', 'openSettings');\n}\nexport async function getInitialURL(): Promise<string | null> {\n  return '';\n}\nexport function getLinkingURL() {\n  return '';\n}\nexport async function openURL(url: string): Promise<true> {\n  return true;\n}\nexport async function canOpenURL() {\n  return true;\n}\nexport function useURL(): string | null {\n  return null;\n}\nexport function useLinkingURL() {\n  return null;\n}\nexport * from './Linking.types';\nexport function collectManifestSchemes() {\n  return [];\n}\nexport function hasConstantsManifest() {\n  return false;\n}\nexport function hasCustomScheme() {\n  return false;\n}\nexport function resolveScheme() {\n  return '';\n}\nexport { parse, createURL } from './createURL';", "llm_cg": {"addEventListener(unknown, unknown)": [], "parseInitialURLAsync()": [], "sendIntent(unknown, unknown)": [], "openSettings()": [], "getInitialURL()": [], "getLinkingURL()": [], "openURL(unknown)": [], "canOpenURL()": [], "useURL()": [], "useLinkingURL()": [], "collectManifestSchemes()": [], "hasConstantsManifest()": [], "hasCustomScheme()": [], "resolveScheme()": []}, "static_cg": {}}
{"source_code": "import { LinkIcon } from '@blocksuite/icons/rc';\nimport type { WorkspaceService } from '@toeverything/infra';\nimport { Entity, LiveData } from '@toeverything/infra';\nimport { resolveLinkToDoc } from '../../navigation';\nimport { isLink } from '../../navigation/utils';\nimport type { QuickSearchSession } from '../providers/quick-search-provider';\nimport type { QuickSearchItem } from '../types/item';\ntype ExternalLinkPayload = {\n  url: string;\n};\nexport class ExternalLinksQuickSearchSession\n  extends Entity\n  implements QuickSearchSession<'external-link', ExternalLinkPayload>\n{\n  constructor(private readonly workspaceService: WorkspaceService) {\n    super();\n  }\n  query$ = new LiveData('');\n  items$ = LiveData.computed(get => {\n    const query = get(this.query$).trim();\n    if (!query) return [];\n    if (!isLink(query)) return [];\n    const resolvedDoc = resolveLinkToDoc(query);\n    if (\n      resolvedDoc &&\n      resolvedDoc.workspaceId === this.workspaceService.workspace.id\n    ) {\n      // is doc url\n      return [];\n    }\n    return [\n      {\n        id: 'external-link:' + query,\n        source: 'external-link',\n        icon: LinkIcon,\n        label: {\n          i18nKey: 'com.affine.cmdk.affine.insert-link',\n        },\n        payload: { url: query },\n      } as QuickSearchItem<'external-link', ExternalLinkPayload>,\n    ];\n  });\n  query(query: string) {\n    this.query$.next(query);\n  }\n}", "llm_cg": {"ExternalLinksQuickSearchSession.query(string)": ["LiveData.next(string)"], "ExternalLinksQuickSearchSession.%AMX$computed(function)": ["LiveData.get(any)", "%AMX$trim()", "isLink(string)", "resolveLinkToDoc(string)", "Object.keys(Entity, $workspaceService)"], "LiveData.computed(function)": ["ExternalLinksQuickSearchSession.%AMX$computed(function)"], "String.trim()": [], "Object.keys(Entity, $workspaceService)": []}, "static_cg": {"@test/176.ts: ExternalLinksQuickSearchSession.%instInit()": ["@test/176.ts: ExternalLinksQuickSearchSession.%AM0$%instInit(unknown)"]}}
{"source_code": "// ==ORIGINAL==\nnamespace A {\n    let y = 1;\n    class C {\n        b() {}\n        a() {\n            let z = 1;\n            let a1 = { x: 1 };\n            y = 10;\n            z = 42;\n            this.b();\n            return a1.x + 10;\n        }\n    }\n}\n// ==SCOPE::Extract to inner function in method 'a'==\nnamespace A {\n    let y = 1;\n    class C {\n        b() {}\n        a() {\n            let z = 1;\n            return newFunction();\n            function newFunction() {\n                let a1 = { x: 1 };\n                y = 10;\n                z = 42;\n                this.b();\n                return a1.x + 10;\n            }\n        }\n    }\n}\n// ==SCOPE::Extract to method in class 'C'==\nnamespace A {\n    let y = 1;\n    class C {\n        b() {}\n        a() {\n            let z = 1;\n            let __return;\n            ({ __return, z } = this.newMethod(z));\n            return __return;\n        }\n        private newMethod(z: number) {\n            let a1 = { x: 1 };\n            y = 10;\n            z = 42;\n            this.b();\n            return { __return: a1.x + 10, z };\n        }\n    }\n}", "llm_cg": {"A.C.a()": ["A.C.newMethod(number)"], "A.C.newMethod(number)": ["A.C.b()"]}, "static_cg": {"@test/177.ts: A.C.a()": ["@test/177.ts: A.C.newMethod(number)"], "@test/177.ts: A.C.newMethod(number)": ["@test/177.ts: A.C.b()"]}}
{"source_code": "import { Point } from '../maths/point/Point';\nimport { FederatedEvent } from './FederatedEvent';\nimport type { PointData } from '../maths/point/PointData';\nimport type { Container } from '../scene/container/Container';\nimport type { PixiTouch } from './FederatedEvent';\nexport class FederatedMouseEvent extends FederatedEvent<\nMouseEvent | PointerEvent | PixiTouch\n> implements MouseEvent\n{\n    public altKey: boolean;\n    public button: number;\n    public buttons: number;\n    public ctrlKey: boolean;\n    public metaKey: boolean;\n    public relatedTarget: EventTarget;\n    public shiftKey: boolean;\n    public client: Point = new Point();\n    public get clientX(): number { return this.client.x; }\n    public get clientY(): number { return this.client.y; }\n    get x(): number { return this.clientX; }\n    get y(): number { return this.clientY; }\n    public detail: number;\n    public movement: Point = new Point();\n    get movementX(): number { return this.movement.x; }\n    get movementY(): number { return this.movement.y; }\n    public offset: Point = new Point();\n    get offsetX(): number { return this.offset.x; }\n    get offsetY(): number { return this.offset.y; }\n    public global: Point = new Point();\n    get globalX(): number { return this.global.x; }\n    get globalY(): number { return this.global.y; }\n    public screen: Point = new Point();\n    get screenX(): number { return this.screen.x; }\n    get screenY(): number { return this.screen.y; }\n    public getLocalPosition<P extends PointData = Point>(container: Container, point?: P, globalPos?: PointData): P\n    {\n        return container.worldTransform.applyInverse<P>(globalPos || this.global, point);\n    }\n    public getModifierState(key: string): boolean\n    {\n        return 'getModifierState' in this.nativeEvent && this.nativeEvent.getModifierState(key);\n    }\n    // eslint-disable-next-line max-params\n    public initMouseEvent(\n        _typeArg: string,\n        _canBubbleArg: boolean,\n        _cancelableArg: boolean,\n        _viewArg: Window,\n        _detailArg: number,\n        _screenXArg: number,\n        _screenYArg: number,\n        _clientXArg: number,\n        _clientYArg: number,\n        _ctrlKeyArg: boolean,\n        _altKeyArg: boolean,\n        _shiftKeyArg: boolean,\n        _metaKeyArg: boolean,\n        _buttonArg: number,\n        _relatedTargetArg: EventTarget\n    ): void\n    {\n        throw new Error('Method not implemented.');\n    }\n}", "llm_cg": {"FederatedMouseEvent.%AM0$getLocalPosition(Container, Point?, PointData?)": ["Container.%AM0$worldTransform.applyInverse(PointData, Point?)"], "FederatedMouseEvent.getLocalPosition(Container, Point?, PointData?)": ["FederatedMouseEvent.%AM0$getLocalPosition(Container, Point?, PointData?)"], "FederatedMouseEvent.getModifierState(string)": [], "FederatedMouseEvent.initMouseEvent(string, boolean, boolean, Window, number, number, number, number, number, boolean, boolean, boolean, boolean, number, EventTarget)": []}, "static_cg": {}}
{"source_code": "import { DebugLogger } from '@affine/debug';\nimport { DEFAULT_WORKSPACE_NAME } from '@affine/env/constant';\nimport { WorkspaceFlavour } from '@affine/env/workspace';\nimport onboardingUrl from '@affine/templates/onboarding.zip';\nimport { ZipTransformer } from '@blocksuite/affine/blocks';\nimport type { WorkspacesService } from '@toeverything/infra';\nimport { DocsService } from '@toeverything/infra';\nexport async function buildShowcaseWorkspace(\n  workspacesService: WorkspacesService,\n  flavour: WorkspaceFlavour,\n  workspaceName: string\n) {\n  const meta = await workspacesService.create(flavour, async docCollection => {\n    docCollection.meta.initialize();\n    docCollection.meta.setName(workspaceName);\n    const blob = await (await fetch(onboardingUrl)).blob();\n    await ZipTransformer.importDocs(docCollection, blob);\n  });\n  const { workspace, dispose } = workspacesService.open({ metadata: meta });\n  await workspace.engine.waitForRootDocReady();\n  const docsService = workspace.scope.get(DocsService);\n  // should jump to \"Write, Draw, Plan all at Once.\" in edgeless by default\n  const defaultDoc = docsService.list.docs$.value.find(p =>\n    p.title$.value.startsWith('Write, Draw, Plan all at Once.')\n  );\n  if (defaultDoc) {\n    defaultDoc.setPrimaryMode('edgeless');\n  }\n  dispose();\n  return { meta, defaultDocId: defaultDoc?.id };\n}\nconst logger = new DebugLogger('createFirstAppData');\nexport async function createFirstAppData(workspacesService: WorkspacesService) {\n  if (localStorage.getItem('is-first-open') !== null) {\n    return;\n  }\n  localStorage.setItem('is-first-open', 'false');\n  const { meta, defaultDocId } = await buildShowcaseWorkspace(\n    workspacesService,\n    WorkspaceFlavour.LOCAL,\n    DEFAULT_WORKSPACE_NAME\n  );\n  logger.info('create first workspace', defaultDocId);\n  return { meta, defaultPageId: defaultDocId };\n}", "llm_cg": {"buildShowcaseWorkspace(workspacesService: WorkspacesService, flavour: WorkspaceFlavour, workspaceName: string)": ["workspacesService.%AM0$create(flavour, async docCollection => { docCollection.meta.initialize(); docCollection.meta.setName(workspaceName); const blob = await (await fetch(onboardingUrl)).blob(); await ZipTransformer.importDocs(docCollection, blob); })", "workspacesService.%AM0$open({ metadata: meta })", "workspace.engine.waitForRootDocReady()", "workspace.scope.get(DocsService)", "docsService.list.docs$.value.find(p => p.title$.value.startsWith('Write, Draw, Plan all at Once.'))", "defaultDoc.setPrimaryMode('edgeless')"], "createFirstAppData(workspacesService: WorkspacesService)": ["localStorage.getItem('is-first-open')", "localStorage.setItem('is-first-open', 'false')", "buildShowcaseWorkspace(workspacesService, WorkspaceFlavour.LOCAL, DEFAULT_WORKSPACE_NAME)", "logger.info('create first workspace', defaultDocId)"]}, "static_cg": {"@test/179.ts: %dflt.buildShowcaseWorkspace(WorkspacesService, WorkspaceFlavour, string)": ["@test/179.ts: %dflt.%AM0$buildShowcaseWorkspace([workspaceName], unknown)", "@test/179.ts: %dflt.%AM1$buildShowcaseWorkspace(unknown)"], "@test/179.ts: %dflt.createFirstAppData(WorkspacesService)": ["@test/179.ts: %dflt.buildShowcaseWorkspace(WorkspacesService, WorkspaceFlavour, string)"]}}
{"source_code": "import { DebugLogger } from '@affine/debug';\nimport {\n  type DBSchema,\n  type IDBPDatabase,\n  type IDBPTransaction,\n  openDB,\n  type StoreNames,\n} from 'idb';\nimport {\n  type AggregateOptions,\n  type AggregateResult,\n  Document,\n  type Query,\n  type Schema,\n  type SearchOptions,\n  type SearchResult,\n} from '../../';\nimport { highlighter } from './highlighter';\nimport {\n  BooleanInvertedIndex,\n  FullTextInvertedIndex,\n  IntegerInvertedIndex,\n  type InvertedIndex,\n  StringInvertedIndex,\n} from './inverted-index';\nimport { Match } from './match';\nconst logger = new DebugLogger('indexeddb');\nexport interface IndexDB extends DBSchema {\n  kvMetadata: {\n    key: string;\n    value: {\n      key: string;\n      value: any;\n    };\n  };\n  records: {\n    key: number;\n    value: {\n      id: string;\n      data: Map<string, string[]>;\n    };\n    indexes: { id: string };\n  };\n  invertedIndex: {\n    key: number;\n    value: {\n      nid: number;\n      pos?: {\n        i: number ;\n        l: number ;\n        rs: [number, number][] ;\n      };\n      key: ArrayBuffer;\n    };\n    indexes: { key: ArrayBuffer; nid: number };\n  };\n}\nexport type DataStructRWTransaction = IDBPTransaction<\n  IndexDB,\n  ArrayLike<StoreNames<IndexDB>>,\n  'readwrite'\n>;\nexport type DataStructROTransaction = IDBPTransaction<\n  IndexDB,\n  ArrayLike<StoreNames<IndexDB>>,\n  'readonly' | 'readwrite'\n>;\nexport class DataStruct {\n  private initializePromise: Promise<void> | null = null;\n  database: IDBPDatabase<IndexDB> = null as any;\n  invertedIndex = new Map<string, InvertedIndex>();\n  constructor(\n    readonly databaseName: string,\n    readonly schema: Schema\n  ) {\n    for (const [key, type] of Object.entries(schema)) {\n      const typeInfo = typeof type === 'string' ? { type } : type;\n      if (typeInfo.index === false) {\n        // If index is false, we don't need to create an inverted index for this field.\n        continue;\n      }\n      if (typeInfo.type === 'String') {\n        this.invertedIndex.set(key, new StringInvertedIndex(key));\n      } else if (typeInfo.type === 'Integer') {\n        this.invertedIndex.set(key, new IntegerInvertedIndex(key));\n      } else if (typeInfo.type === 'FullText') {\n        this.invertedIndex.set(key, new FullTextInvertedIndex(key));\n      } else if (type === 'Boolean') {\n        this.invertedIndex.set(key, new BooleanInvertedIndex(key));\n      } else {\n        throw new Error(`Field type '${type}' not supported`);\n      }\n    }\n  }\n  private async insert(trx: DataStructRWTransaction, document: Document) {\n    const exists = await trx\n      .objectStore('records')\n      .index('id')\n      .get(document.id);\n    if (exists) {\n      throw new Error('Document already exists');\n    }\n    const dataMap = new Map();\n    for (const [key, values] of document.fields) {\n      const type = this.schema[key as string];\n      if (!type) {\n        continue;\n      }\n      const typeInfo = typeof type === 'string' ? { type } : type;\n      if (typeInfo.store !== false) {\n        // If store is false, the field will not be stored\n        dataMap.set(key, values);\n      }\n    }\n    const nid = await trx.objectStore('records').add({\n      id: document.id,\n      data: dataMap,\n    });\n    for (const [key, values] of document.fields) {\n      const iidx = this.invertedIndex.get(key as string);\n      if (!iidx) {\n        continue;\n      }\n      await iidx.insert(trx, nid, values);\n    }\n  }\n  private async delete(trx: DataStructRWTransaction, id: string) {\n    const nid = await trx.objectStore('records').index('id').getKey(id);\n    if (nid) {\n      await trx.objectStore('records').delete(nid);\n    }\n    const indexIds = await trx\n      .objectStore('invertedIndex')\n      .index('nid')\n      .getAllKeys(nid);\n    for (const indexId of indexIds) {\n      await trx.objectStore('invertedIndex').delete(indexId);\n    }\n  }\n  async batchWrite(\n    trx: DataStructRWTransaction,\n    deletes: string[],\n    inserts: Document[]\n  ) {\n    const startTime = performance.now();\n    try {\n      for (const del of deletes) {\n        await this.delete(trx, del);\n      }\n      for (const inst of inserts) {\n        await this.insert(trx, inst);\n      }\n    } finally {\n      const endTime = performance.now();\n      if (BUILD_CONFIG.debug) {\n        performance.measure(\n          `[IndexedDB Indexer] Batch Write (${this.databaseName})`,\n          {\n            start: startTime,\n            end: endTime,\n          }\n        );\n      }\n      logger.debug(\n        `[indexer ${this.databaseName}] batchWrite`,\n        endTime - startTime,\n        'ms'\n      );\n    }\n  }\n  async matchAll(trx: DataStructROTransaction): Promise<Match> {\n    const allNids = await trx.objectStore('records').getAllKeys();\n    const match = new Match();\n    for (const nid of allNids) {\n      match.addScore(nid, 1);\n    }\n    return match;\n  }\n  private async queryRaw(\n    trx: DataStructROTransaction,\n    query: Query<any>\n  ): Promise<Match> {\n    if (query.type === 'match') {\n      const iidx = this.invertedIndex.get(query.field as string);\n      if (!iidx) {\n        return new Match();\n      }\n      return await iidx.match(trx, query.match);\n    } else if (query.type === 'boolean') {\n      const weights = [];\n      for (const q of query.queries) {\n        weights.push(await this.queryRaw(trx, q));\n      }\n      if (query.occur === 'must') {\n        return weights.reduce((acc, w) => acc.and(w));\n      } else if (query.occur === 'must_not') {\n        const total = weights.reduce((acc, w) => acc.and(w));\n        return (await this.matchAll(trx)).exclude(total);\n      } else if (query.occur === 'should') {\n        return weights.reduce((acc, w) => acc.or(w));\n      }\n    } else if (query.type === 'all') {\n      return await this.matchAll(trx);\n    } else if (query.type === 'boost') {\n      return (await this.queryRaw(trx, query.query)).boost(query.boost);\n    } else if (query.type === 'exists') {\n      const iidx = this.invertedIndex.get(query.field as string);\n      if (!iidx) {\n        return new Match();\n      }\n      return await iidx.all(trx);\n    }\n    throw new Error(`Query type '${query.type}' not supported`);\n  }\n  async clear(trx: DataStructRWTransaction) {\n    await trx.objectStore('records').clear();\n    await trx.objectStore('invertedIndex').clear();\n    await trx.objectStore('kvMetadata').clear();\n  }\n  async search(\n    trx: DataStructROTransaction,\n    query: Query<any>,\n    options: SearchOptions<any>\n  ): Promise<SearchResult<any, any>> {\n    const startTime = performance.now();\n    try {\n      const pagination = {\n        skip: options.pagination?.skip ?? 0,\n        limit: options.pagination?.limit ?? 100,\n      };\n      const match = await this.queryRaw(trx, query);\n      const nids = match\n        .toArray()\n        .slice(pagination.skip, pagination.skip + pagination.limit);\n      const nodes = [];\n      for (const nid of nids) {\n        const record = await trx.objectStore('records').get(nid);\n        if (!record) {\n          continue;\n        }\n        nodes.push(this.resultNode(record, options, match, nid));\n      }\n      return {\n        pagination: {\n          count: match.size(),\n          hasMore: match.size() > pagination.limit + pagination.skip,\n          limit: pagination.limit,\n          skip: pagination.skip,\n        },\n        nodes: nodes,\n      };\n    } finally {\n      const endTime = performance.now();\n      if (BUILD_CONFIG.debug) {\n        performance.measure(\n          `[IndexedDB Indexer] Search (${this.databaseName})`,\n          {\n            detail: { query, options },\n            start: startTime,\n            end: endTime,\n          }\n        );\n      }\n      logger.debug(\n        `[indexer ${this.databaseName}] search`,\n        endTime - startTime,\n        'ms',\n        query\n      );\n    }\n  }\n  async aggregate(\n    trx: DataStructROTransaction,\n    query: Query<any>,\n    field: string,\n    options: AggregateOptions<any>\n  ): Promise<AggregateResult<any, any>> {\n    const startTime = performance.now();\n    try {\n      const pagination = {\n        skip: options.pagination?.skip ?? 0,\n        limit: options.pagination?.limit ?? 100,\n      };\n      const hitPagination = options.hits\n        ? {\n            skip: options.hits.pagination?.skip ?? 0,\n            limit: options.hits.pagination?.limit ?? 3,\n          }\n        : {\n            skip: 0,\n            limit: 0,\n          };\n      const match = await this.queryRaw(trx, query);\n      const nids = match.toArray();\n      const buckets: {\n        key: string;\n        nids: number[];\n        hits: SearchResult<any, any>['nodes'];\n      }[] = [];\n      for (const nid of nids) {\n        const record = await trx.objectStore('records').get(nid);\n        if (!record) {\n          continue;\n        }\n        const values = record.data.get(field);\n        for (const value of values ?? []) {\n          let bucket;\n          let bucketIndex = buckets.findIndex(b => b.key === value);\n          if (bucketIndex === -1) {\n            bucket = { key: value, nids: [], hits: [] };\n            buckets.push(bucket);\n            bucketIndex = buckets.length - 1;\n          } else {\n            bucket = buckets[bucketIndex];\n          }\n          if (\n            bucketIndex >= pagination.skip &&\n            bucketIndex < pagination.skip + pagination.limit\n          ) {\n            bucket.nids.push(nid);\n            if (\n              bucket.nids.length - 1 >= hitPagination.skip &&\n              bucket.nids.length - 1 < hitPagination.skip + hitPagination.limit\n            ) {\n              bucket.hits.push(\n                this.resultNode(record, options.hits ?? {}, match, nid)\n              );\n            }\n          }\n        }\n      }\n      return {\n        buckets: buckets\n          .slice(pagination.skip, pagination.skip + pagination.limit)\n          .map(bucket => {\n            const result = {\n              key: bucket.key,\n              score: match.getScore(bucket.nids[0]),\n              count: bucket.nids.length,\n            } as AggregateResult<any, any>['buckets'][number];\n            if (options.hits) {\n              (result as any).hits = {\n                pagination: {\n                  count: bucket.nids.length,\n                  hasMore:\n                    bucket.nids.length >\n                    hitPagination.limit + hitPagination.skip,\n                  limit: hitPagination.limit,\n                  skip: hitPagination.skip,\n                },\n                nodes: bucket.hits,\n              } as SearchResult<any, any>;\n            }\n            return result;\n          }),\n        pagination: {\n          count: buckets.length,\n          hasMore: buckets.length > pagination.limit + pagination.skip,\n          limit: pagination.limit,\n          skip: pagination.skip,\n        },\n      };\n    } finally {\n      const endTime = performance.now();\n      if (BUILD_CONFIG.debug) {\n        performance.measure(\n          `[IndexedDB Indexer] Aggregate (${this.databaseName})`,\n          {\n            detail: { query, field, options },\n            start: startTime,\n            end: endTime,\n          }\n        );\n      }\n      logger.debug(\n        `[indexer ${this.databaseName}] aggregate`,\n        endTime - startTime,\n        'ms'\n      );\n    }\n  }\n  async getAll(\n    trx: DataStructROTransaction,\n    ids?: string[]\n  ): Promise<Document[]> {\n    const docs = [];\n    if (ids) {\n      for (const id of ids) {\n        const record = await trx.objectStore('records').index('id').get(id);\n        if (record) {\n          docs.push(Document.from(record.id, record.data));\n        }\n      }\n    } else {\n      const records = await trx.objectStore('records').getAll();\n      for (const record of records) {\n        docs.push(Document.from(record.id, record.data));\n      }\n    }\n    return docs;\n  }\n  async has(trx: DataStructROTransaction, id: string): Promise<boolean> {\n    const nid = await trx.objectStore('records').index('id').getKey(id);\n    return nid !== undefined;\n  }\n  async readonly() {\n    await this.ensureInitialized();\n    return this.database.transaction(\n      ['records', 'invertedIndex', 'kvMetadata'],\n      'readonly',\n      {\n        durability: 'relaxed',\n      }\n    );\n  }\n  async readwrite() {\n    await this.ensureInitialized();\n    return this.database.transaction(\n      ['records', 'invertedIndex', 'kvMetadata'],\n      'readwrite',\n      {\n        durability: 'relaxed',\n      }\n    );\n  }\n  private async ensureInitialized() {\n    if (this.database) {\n      return;\n    }\n    this.initializePromise ??= this.initialize();\n    await this.initializePromise;\n  }\n  private async initialize() {\n    this.database = await openDB<IndexDB>(this.databaseName, 1, {\n      upgrade(database) {\n        database.createObjectStore('kvMetadata', {\n          keyPath: 'key',\n        });\n        const recordsStore = database.createObjectStore('records', {\n          autoIncrement: true,\n        });\n        recordsStore.createIndex('id', 'id', {\n          unique: true,\n        });\n        const invertedIndexStore = database.createObjectStore('invertedIndex', {\n          autoIncrement: true,\n        });\n        invertedIndexStore.createIndex('key', 'key', { unique: false });\n        invertedIndexStore.createIndex('nid', 'nid', { unique: false });\n      },\n    });\n  }\n  private resultNode(\n    record: { id: string; data: Map<string, string[]> },\n    options: SearchOptions<any>,\n    match?: Match,\n    nid?: number\n  ): SearchResult<any, any>['nodes'][number] {\n    const node = {\n      id: record.id,\n      score: match && nid ? match.getScore(nid) : 1,\n    } as any;\n    if (options.fields) {\n      const fields = {} as Record<string, string | string[]>;\n      for (const field of options.fields as string[]) {\n        fields[field] = record.data.get(field) ?? [''];\n        if (fields[field].length === 1) {\n          fields[field] = fields[field][0];\n        }\n      }\n      node.fields = fields;\n    }\n    if (match && nid && options.highlights) {\n      const highlights = {} as Record<string, string[]>;\n      for (const { field, before, end } of options.highlights) {\n        const highlightValues = match.getHighlighters(nid, field);\n        if (highlightValues) {\n          const rawValues = record.data.get(field) ?? [];\n          highlights[field] = Array.from(highlightValues)\n            .map(([index, ranges]) => {\n              const raw = rawValues[index];\n              if (raw) {\n                return (\n                  highlighter(raw, before, end, ranges, {\n                    maxPrefix: 20,\n                    maxLength: 50,\n                  }) ?? ''\n                );\n              }\n              return '';\n            })\n            .filter(Boolean);\n        }\n      }\n      node.highlights = highlights;\n    }\n    return node;\n  }\n}", "llm_cg": {"DataStruct.constructor(string, Schema)": ["DataStruct.%AM0$constructor(undefined)"], "DataStruct.insert(DataStructRWTransaction, Document)": [], "DataStruct.delete(DataStructRWTransaction, string)": [], "DataStruct.batchWrite(DataStructRWTransaction, string[], Document[])": ["DataStruct.delete(DataStructRWTransaction, string)", "DataStruct.insert(DataStructRWTransaction, Document)"], "DataStruct.matchAll(DataStructROTransaction)": ["Match.%AM0$constructor()"], "DataStruct.queryRaw(DataStructROTransaction, Query<any>)": ["DataStruct.queryRaw(DataStructROTransaction, Query<any>)", "DataStruct.matchAll(DataStructROTransaction)", "Match.%AM0$constructor()"], "DataStruct.clear(DataStructRWTransaction)": [], "DataStruct.search(DataStructROTransaction, Query<any>, SearchOptions<any>)": ["DataStruct.queryRaw(DataStructROTransaction, Query<any>)", "DataStruct.resultNode(undefined, undefined, undefined, undefined)"], "DataStruct.aggregate(DataStructROTransaction, Query<any>, string, AggregateOptions<any>)": ["DataStruct.queryRaw(DataStructROTransaction, Query<any>)", "DataStruct.resultNode(undefined, undefined, undefined, undefined)"], "DataStruct.getAll(DataStructROTransaction, string[])": [], "DataStruct.has(DataStructROTransaction, string)": [], "DataStruct.readonly()": ["DataStruct.ensureInitialized()"], "DataStruct.readwrite()": ["DataStruct.ensureInitialized()"], "DataStruct.ensureInitialized()": ["DataStruct.initialize()"], "DataStruct.initialize()": ["openDB<IndexDB>"], "DataStruct.resultNode(undefined, undefined, undefined, undefined)": []}, "static_cg": {"@test/180.ts: DataStruct.batchWrite(DataStructRWTransaction, string[], Document[])": ["@test/180.ts: DataStruct.delete(DataStructRWTransaction, string)", "@test/180.ts: DataStruct.insert(DataStructRWTransaction, Document)"], "@test/180.ts: DataStruct.queryRaw(DataStructROTransaction, Query<any>)": ["@test/180.ts: DataStruct.queryRaw(DataStructROTransaction, Query<any>)", "@test/180.ts: DataStruct.%AM0$queryRaw(unknown, unknown)", "@test/180.ts: DataStruct.%AM1$queryRaw(unknown, unknown)", "@test/180.ts: DataStruct.matchAll(DataStructROTransaction)", "@test/180.ts: DataStruct.%AM2$queryRaw(unknown, unknown)"], "@test/180.ts: DataStruct.search(DataStructROTransaction, Query<any>, SearchOptions<any>)": ["@test/180.ts: DataStruct.queryRaw(DataStructROTransaction, Query<any>)", "@test/180.ts: DataStruct.resultNode(@test/180.ts: %AC$9, SearchOptions<any>, Match, number)"], "@test/180.ts: DataStruct.aggregate(DataStructROTransaction, Query<any>, string, AggregateOptions<any>)": ["@test/180.ts: DataStruct.%AM3$aggregate([value], unknown)", "@test/180.ts: DataStruct.resultNode(@test/180.ts: %AC$9, SearchOptions<any>, Match, number)", "@test/180.ts: DataStruct.queryRaw(DataStructROTransaction, Query<any>)"], "@test/180.ts: DataStruct.readonly()": ["@test/180.ts: DataStruct.ensureInitialized()"], "@test/180.ts: DataStruct.readwrite()": ["@test/180.ts: DataStruct.ensureInitialized()"], "@test/180.ts: DataStruct.ensureInitialized()": ["@test/180.ts: DataStruct.initialize()"], "@test/180.ts: DataStruct.resultNode(@test/180.ts: %AC$9, SearchOptions<any>, Match, number)": ["@test/180.ts: DataStruct.%AM4$resultNode([rawValues, before, end], unknown)"], "@test/180.ts: %AC$DataStruct$aggregate$25.%instInit()": ["@test/180.ts: %AC$DataStruct$aggregate$25.%AM0$%instInit(unknown)"]}}
{"source_code": "import {QueryList, ViewChild, ViewChildren, Component} from '@angular/core';\nimport {CdkMenu} from './menu';\nimport {CdkMenuBar} from './menu-bar';\nimport {ComponentFixture, TestBed, waitForAsync} from '@angular/core/testing';\nimport {CdkMenuTrigger} from './menu-trigger';\nimport {MenuStack} from './menu-stack';\nimport {CdkMenuModule} from './menu-module';\ndescribe('MenuStack', () => {\n  let fixture: ComponentFixture<MultiMenuWithSubmenu>;\n  let menuStack: MenuStack;\n  let triggers: CdkMenuTrigger[];\n  let menus: CdkMenu[];\n  function getElementsForTesting() {\n    fixture.detectChanges();\n    triggers = fixture.componentInstance.triggers.toArray();\n    menus = fixture.componentInstance.menus.toArray();\n    menuStack = fixture.componentInstance.menuBar.menuStack;\n  }\n  beforeEach(waitForAsync(() => {\n    TestBed.configureTestingModule({\n      imports: [CdkMenuModule, MultiMenuWithSubmenu],\n    });\n  }));\n  beforeEach(() => {\n    fixture = TestBed.createComponent(MultiMenuWithSubmenu);\n    fixture.detectChanges();\n    getElementsForTesting();\n  });\n  function openAllMenus() {\n    triggers[0].open();\n    getElementsForTesting();\n    triggers[1].open();\n    getElementsForTesting();\n    triggers[2].open();\n    getElementsForTesting();\n  }\n  it(\n    'should fill the menu stack with the latest menu at the end of the stack and oldest at' +\n      ' the start of the stack',\n    () => {\n      openAllMenus();\n      expect(menus.length).toBe(3);\n      const spy = jasmine.createSpy('menu stack closed spy');\n      menuStack.closed.subscribe(spy);\n      menuStack.closeAll();\n      expect(spy).toHaveBeenCalledTimes(3);\n      const callArgs = spy.calls.all().map((v: jasmine.CallInfo<jasmine.Func>) => v.args[0].item);\n      expect(callArgs).toEqual(menus.reverse());\n      expect(menuStack.isEmpty()).toBeTrue();\n    },\n  );\n  it('should close triggering menu and all menus below it', () => {\n    openAllMenus();\n    expect(menus.length).toBe(3);\n    triggers[1].toggle();\n    getElementsForTesting();\n    expect(menus.length).toBe(1);\n    expect(menuStack.length()).withContext('menu stack should only have the single menu').toBe(1);\n    expect(menuStack.peek()).toEqual(menus[0]);\n  });\n});\n@Component({\n  template: `\n    <div>\n      <div cdkMenuBar id=\"menu_bar\">\n        <button cdkMenuItem [cdkMenuTriggerFor]=\"file\">File</button>\n      </div>\n      <ng-template #file>\n        <div cdkMenu id=\"file_menu\">\n          <button cdkMenuItem [cdkMenuTriggerFor]=\"share\">Share</button>\n        </div>\n      </ng-template>\n      <ng-template #share>\n        <div cdkMenu id=\"share_menu\">\n          <button cdkMenuItem [cdkMenuTriggerFor]=\"chat\">Chat</button>\n        </div>\n      </ng-template>\n      <ng-template #chat>\n        <div cdkMenu id=\"chat_menu\">\n          <button cdkMenuItem>GVC</button>\n        </div>\n      </ng-template>\n    </div>\n  `,\n  standalone: true,\n  imports: [CdkMenuModule],\n})\nclass MultiMenuWithSubmenu {\n  @ViewChild(CdkMenuBar) menuBar: CdkMenuBar;\n  @ViewChildren(CdkMenuTrigger) triggers: QueryList<CdkMenuTrigger>;\n  @ViewChildren(CdkMenu) menus: QueryList<CdkMenu>;\n}", "llm_cg": {"MenuStack.%AMX$openAllMenus()": ["CdkMenuTrigger.open()", "MenuStack.%AMX$getElementsForTesting()", "CdkMenuTrigger.open()", "MenuStack.%AMX$getElementsForTesting()", "CdkMenuTrigger.open()", "MenuStack.%AMX$getElementsForTesting()"], "MenuStack.it(unknown)": ["MenuStack.%AMX$openAllMenus()", "CdkMenuTrigger.toggle()", "MenuStack.%AMX$getElementsForTesting()", "MenuStack.length()", "MenuStack.peek()"], "MenuStack.%AMX$getElementsForTesting()": ["MultiMenuWithSubmenu.%AMX$triggers.toArray()", "MultiMenuWithSubmenu.%AMX$menus.toArray()"]}, "static_cg": {"@test/181.ts: %dflt.[static]%dflt()": ["@test/181.ts: %dflt.%AM0()"], "@test/181.ts: %dflt.%AM3$%AM0()": ["@test/181.ts: %dflt.%AM4$%AM3$%AM0(jasmine.CallInfo<jasmine.Func>)"], "@test/181.ts: %dflt.%AM0()": ["@test/181.ts: %dflt.%AM1$%AM0()", "@test/181.ts: %dflt.%AM2$%AM0()", "@test/181.ts: %dflt.%AM3$%AM0()", "@test/181.ts: %dflt.%AM5$%AM0()"]}}
{"source_code": "import type { WalletUnlocked } from '@fuel-ts/account';\nimport { ContractFactory } from '@fuel-ts/contract';\nimport type { DeployContractOptions } from '@fuel-ts/contract';\nimport { Contract } from '@fuel-ts/program';\nimport { Src14OwnedProxy, Src14OwnedProxyFactory } from '@fuel-ts/recipes';\nimport { existsSync, readFileSync } from 'fs';\nimport {\n  getABIPath,\n  getBinaryPath,\n  getClosestForcTomlDir,\n  getContractCamelCase,\n  getContractName,\n  getStorageSlotsPath,\n  readForcToml,\n  setForcTomlProxyAddress,\n  type ForcToml,\n} from '../../config/forcUtils';\nimport type { FuelsConfig, DeployedContract } from '../../types';\nimport { debug, log } from '../../utils/logger';\nimport { createWallet } from './createWallet';\nimport { getDeployConfig } from './getDeployConfig';\nexport async function deployContract(\n  wallet: WalletUnlocked,\n  binaryPath: string,\n  abiPath: string,\n  storageSlotsPath: string,\n  deployConfig: DeployContractOptions,\n  contractPath: string,\n  tomlContents: ForcToml\n) {\n  debug(`Deploying contract for ABI: ${abiPath}`);\n  if (existsSync(storageSlotsPath)) {\n    const storageSlots = JSON.parse(readFileSync(storageSlotsPath, 'utf-8'));\n    // eslint-disable-next-line no-param-reassign\n    deployConfig.storageSlots = storageSlots;\n  }\n  const targetBytecode = readFileSync(binaryPath);\n  const targetAbi = JSON.parse(readFileSync(abiPath, 'utf-8'));\n  const targetStorageSlots = deployConfig.storageSlots ?? [];\n  const proxyBytecode = Src14OwnedProxyFactory.bytecode;\n  const proxyAbi = Src14OwnedProxy.abi;\n  const proxyStorageSlots = Src14OwnedProxy.storageSlots ?? [];\n  const isProxyEnabled = tomlContents?.proxy?.enabled;\n  const proxyAddress = tomlContents?.proxy?.address;\n  if (!isProxyEnabled) {\n    // a. Deploy the target contract\n    const contractFactory = new ContractFactory(targetBytecode, targetAbi, wallet);\n    const { waitForResult } = await contractFactory.deploy(deployConfig);\n    const { contract } = await waitForResult();\n    return contract.id.toB256();\n  }\n  if (proxyAddress) {\n    // a. Deploy the target contract\n    const targetContractFactory = new ContractFactory(targetBytecode, targetAbi, wallet);\n    const { waitForResult: waitForTarget } = await targetContractFactory.deploy(deployConfig);\n    const { contract: targetContract } = await waitForTarget();\n    // b. Update proxy contract with the new target contract ID\n    const proxyContract = new Contract(proxyAddress, proxyAbi, wallet);\n    const { waitForResult: waitForProxyUpdate } = await proxyContract.functions\n      .set_proxy_target({ bits: targetContract.id.toB256() })\n      .call();\n    await waitForProxyUpdate();\n    return proxyAddress;\n  }\n  // a. Deploy the target contract\n  const targetContractFactory = new ContractFactory(targetBytecode, targetAbi, wallet);\n  const { waitForResult: waitForTarget } = await targetContractFactory.deploy(deployConfig);\n  const { contract: targetContract } = await waitForTarget();\n  // b. Deploy the SR-C14 Compliant / Proxy Contract\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const { storageSlots, stateRoot, ...commonDeployConfig } = deployConfig;\n  const mergedStorageSlots = targetStorageSlots.concat(proxyStorageSlots);\n  const proxyDeployConfig: DeployContractOptions = {\n    ...commonDeployConfig,\n    storageSlots: mergedStorageSlots,\n    configurableConstants: {\n      INITIAL_TARGET: { bits: targetContract.id.toB256() },\n      INITIAL_OWNER: { Initialized: { Address: { bits: wallet.address.toB256() } } },\n    },\n  };\n  const proxyFactory = new ContractFactory(proxyBytecode, proxyAbi, wallet);\n  const { waitForResult: waitForProxy } = await proxyFactory.deploy(proxyDeployConfig);\n  const { contract: proxyContract } = await waitForProxy();\n  // c. Initialize the proxy contract\n  const { waitForResult: waitForProxyInit } = await proxyContract.functions\n    .initialize_proxy()\n    .call();\n  await waitForProxyInit();\n  const proxyContractId = proxyContract.id.toB256();\n  // d. Write the address of the proxy contract to user's Forc.Toml file\n  setForcTomlProxyAddress(contractPath, proxyContractId);\n  return proxyContractId;\n}\nexport async function deployContracts(config: FuelsConfig) {\n  const contracts: DeployedContract[] = [];\n  const wallet = await createWallet(config.providerUrl, config.privateKey);\n  log(`Deploying contracts to: ${wallet.provider.url}`);\n  const contractsLen = config.contracts.length;\n  for (let i = 0; i < contractsLen; i++) {\n    const contractPath = config.contracts[i];\n    const forcTomlPath = getClosestForcTomlDir(contractPath);\n    const binaryPath = getBinaryPath(contractPath, config);\n    const abiPath = getABIPath(contractPath, config);\n    const storageSlotsPath = getStorageSlotsPath(contractPath, config);\n    const projectName = getContractName(contractPath);\n    const contractName = getContractCamelCase(contractPath);\n    const tomlContents = readForcToml(forcTomlPath);\n    const deployConfig = await getDeployConfig(config.deployConfig, {\n      contracts: Array.from(contracts),\n      contractName,\n      contractPath,\n    });\n    const contractId = await deployContract(\n      wallet,\n      binaryPath,\n      abiPath,\n      storageSlotsPath,\n      deployConfig,\n      contractPath,\n      tomlContents\n    );\n    debug(`Contract deployed: ${projectName} - ${contractId}`);\n    contracts.push({\n      name: contractName,\n      contractId,\n    });\n  }\n  return contracts;\n}", "llm_cg": {"deployContract(wallet: WalletUnlocked, binaryPath: string, abiPath: string, storageSlotsPath: string, deployConfig: DeployContractOptions, contractPath: string, tomlContents: ForcToml)": ["ContractFactory.deploy(unknown)", "DeployContractOptions.deployConfig(unknown)", "Contract.waitForResult(unknown)", "ContractFactory.deploy(unknown)", "Contract.waitForResult(unknown)", "Contract.functions.set_proxy_target(unknown)", "ContractFactory.deploy(unknown)", "Contract.waitForResult(unknown)", "Contract.functions.initialize_proxy(unknown)", "setForcTomlProxyAddress(contractPath: string, proxyContractId: string)"], "deployContracts(config: FuelsConfig)": ["createWallet(config.providerUrl: string, config.privateKey: string)", "getClosestForcTomlDir(contractPath: string)", "getBinaryPath(contractPath: string, config: FuelsConfig)", "getABIPath(contractPath: string, config: FuelsConfig)", "getStorageSlotsPath(contractPath: string, config: FuelsConfig)", "getContractName(contractPath: string)", "getContractCamelCase(contractPath: string)", "readForcToml(forcTomlPath: string)", "getDeployConfig(config.deployConfig: unknown, { contracts: DeployedContract[], contractName: string, contractPath: string })", "deployContract(wallet: WalletUnlocked, binaryPath: string, abiPath: string, storageSlotsPath: string, deployConfig: DeployContractOptions, contractPath: string, tomlContents: ForcToml)"]}, "static_cg": {"@test/182.ts: %dflt.deployContracts(FuelsConfig)": ["@test/182.ts: %dflt.deployContract(WalletUnlocked, string, string, string, DeployContractOptions, string, ForcToml)"]}}
{"source_code": "import { isTeamsUpdateProps } from '@rocket.chat/rest-typings';\nimport { assert } from 'chai';\ndescribe('TeamsUpdateMemberProps (definition/rest/v1)', () => {\n\tdescribe('isTeamsUpdateProps', () => {\n\t\tit('should be a function', () => {\n\t\t\tassert.isFunction(isTeamsUpdateProps);\n\t\t});\n\t\tit('should return false when provided anything that is not an TeamsUpdateProps', () => {\n\t\t\tassert.isFalse(isTeamsUpdateProps(undefined));\n\t\t\tassert.isFalse(isTeamsUpdateProps(null));\n\t\t\tassert.isFalse(isTeamsUpdateProps(''));\n\t\t\tassert.isFalse(isTeamsUpdateProps(123));\n\t\t\tassert.isFalse(isTeamsUpdateProps({}));\n\t\t\tassert.isFalse(isTeamsUpdateProps([]));\n\t\t\tassert.isFalse(isTeamsUpdateProps(new Date()));\n\t\t\tassert.isFalse(isTeamsUpdateProps(new Error()));\n\t\t});\n\t\tit('should return false when only teamName is provided to TeamsUpdateProps', () => {\n\t\t\tassert.isFalse(\n\t\t\t\tisTeamsUpdateProps({\n\t\t\t\t\tteamName: 'teamName',\n\t\t\t\t}),\n\t\t\t);\n\t\t});\n\t\tit('should return false when only teamId is provided to TeamsUpdateProps', () => {\n\t\t\tassert.isFalse(\n\t\t\t\tisTeamsUpdateProps({\n\t\t\t\t\tteamId: 'teamId',\n\t\t\t\t}),\n\t\t\t);\n\t\t});\n\t\tit('should return false when teamName and data are provided to TeamsUpdateProps but data is an empty object', () => {\n\t\t\tassert.isFalse(\n\t\t\t\tisTeamsUpdateProps({\n\t\t\t\t\tteamName: 'teamName',\n\t\t\t\t\tdata: {},\n\t\t\t\t}),\n\t\t\t);\n\t\t});\n\t\tit('should return false when teamId and data are provided to TeamsUpdateProps but data is an empty object', () => {\n\t\t\tassert.isFalse(\n\t\t\t\tisTeamsUpdateProps({\n\t\t\t\t\tteamId: 'teamId',\n\t\t\t\t\tdata: {},\n\t\t\t\t}),\n\t\t\t);\n\t\t});\n\t\tit('should return false when teamName and data are provided to TeamsUpdateProps but data is not an object', () => {\n\t\t\tassert.isFalse(\n\t\t\t\tisTeamsUpdateProps({\n\t\t\t\t\tteamName: 'teamName',\n\t\t\t\t\tdata: 'data',\n\t\t\t\t}),\n\t\t\t);\n\t\t});\n\t\tit('should return false when teamId and data are provided to TeamsUpdateProps but data is not an object', () => {\n\t\t\tassert.isFalse(\n\t\t\t\tisTeamsUpdateProps({\n\t\t\t\t\tteamId: 'teamId',\n\t\t\t\t\tdata: 'data',\n\t\t\t\t}),\n\t\t\t);\n\t\t});\n\t\tit('should return true when teamName and data.name are provided to TeamsUpdateProps', () => {\n\t\t\tassert.isTrue(\n\t\t\t\tisTeamsUpdateProps({\n\t\t\t\t\tteamName: 'teamName',\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tname: 'name',\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t);\n\t\t});\n\t\tit('should return true when teamId and data.name are provided to TeamsUpdateProps', () => {\n\t\t\tassert.isTrue(\n\t\t\t\tisTeamsUpdateProps({\n\t\t\t\t\tteamId: 'teamId',\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tname: 'name',\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t);\n\t\t});\n\t\tit('should return true when teamName and data.type are provided to TeamsUpdateProps', () => {\n\t\t\tassert.isTrue(\n\t\t\t\tisTeamsUpdateProps({\n\t\t\t\t\tteamName: 'teamName',\n\t\t\t\t\tdata: {\n\t\t\t\t\t\ttype: 0,\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t);\n\t\t});\n\t\tit('should return true when teamId and data.type are provided to TeamsUpdateProps', () => {\n\t\t\tassert.isTrue(\n\t\t\t\tisTeamsUpdateProps({\n\t\t\t\t\tteamId: 'teamId',\n\t\t\t\t\tdata: {\n\t\t\t\t\t\ttype: 0,\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t);\n\t\t});\n\t\tit('should return true when teamName and data.name and data.type are provided to TeamsUpdateProps', () => {\n\t\t\tassert.isTrue(\n\t\t\t\tisTeamsUpdateProps({\n\t\t\t\t\tteamName: 'teamName',\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tname: 'name',\n\t\t\t\t\t\ttype: 0,\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t);\n\t\t});\n\t\tit('should return true when teamId and data.name and data.type are provided to TeamsUpdateProps', () => {\n\t\t\tassert.isTrue(\n\t\t\t\tisTeamsUpdateProps({\n\t\t\t\t\tteamId: 'teamId',\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tname: 'name',\n\t\t\t\t\t\ttype: 0,\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t);\n\t\t});\n\t\tit('should return false when teamName, data.name, data.type are some more extra data  are provided to TeamsUpdateProps', () => {\n\t\t\tassert.isFalse(\n\t\t\t\tisTeamsUpdateProps({\n\t\t\t\t\tteamName: 'teamName',\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tname: 'name',\n\t\t\t\t\t\ttype: 0,\n\t\t\t\t\t\textra: 'extra',\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t);\n\t\t});\n\t\tit('should return false when teamId, data.name, data.type are some more extra data  are provided to TeamsUpdateProps', () => {\n\t\t\tassert.isFalse(\n\t\t\t\tisTeamsUpdateProps({\n\t\t\t\t\tteamId: 'teamId',\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tname: 'name',\n\t\t\t\t\t\ttype: 0,\n\t\t\t\t\t\textra: 'extra',\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t);\n\t\t});\n\t\tit('should return false when teamName, data.name, data.type are some more extra parameter are provided to TeamsUpdateProps', () => {\n\t\t\tassert.isFalse(\n\t\t\t\tisTeamsUpdateProps({\n\t\t\t\t\tteamName: 'teamName',\n\t\t\t\t\textra: 'extra',\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tname: 'name',\n\t\t\t\t\t\ttype: 0,\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t);\n\t\t});\n\t\tit('should return false when teamId, data.name, data.type are some more extra parameter are provided to TeamsUpdateProps', () => {\n\t\t\tassert.isFalse(\n\t\t\t\tisTeamsUpdateProps({\n\t\t\t\t\tteamId: 'teamId',\n\t\t\t\t\textra: 'extra',\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tname: 'name',\n\t\t\t\t\t\ttype: 0,\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t);\n\t\t});\n\t});\n});", "llm_cg": {"isTeamsUpdateProps(undefined)": [], "isTeamsUpdateProps(null)": [], "isTeamsUpdateProps('')": [], "isTeamsUpdateProps(123)": [], "isTeamsUpdateProps({})": [], "isTeamsUpdateProps([])": [], "isTeamsUpdateProps(new Date())": [], "isTeamsUpdateProps(new Error())": [], "isTeamsUpdateProps({ teamName: 'teamName' })": [], "isTeamsUpdateProps({ teamId: 'teamId' })": [], "isTeamsUpdateProps({ teamName: 'teamName', data: {} })": [], "isTeamsUpdateProps({ teamId: 'teamId', data: {} })": [], "isTeamsUpdateProps({ teamName: 'teamName', data: 'data' })": [], "isTeamsUpdateProps({ teamId: 'teamId', data: 'data' })": [], "isTeamsUpdateProps({ teamName: 'teamName', data: { name: 'name' } })": [], "isTeamsUpdateProps({ teamId: 'teamId', data: { name: 'name' } })": [], "isTeamsUpdateProps({ teamName: 'teamName', data: { type: 0 } })": [], "isTeamsUpdateProps({ teamId: 'teamId', data: { type: 0 } })": [], "isTeamsUpdateProps({ teamName: 'teamName', data: { name: 'name', type: 0 } })": [], "isTeamsUpdateProps({ teamId: 'teamId', data: { name: 'name', type: 0 } })": [], "isTeamsUpdateProps({ teamName: 'teamName', data: { name: 'name', type: 0, extra: 'extra' } })": [], "isTeamsUpdateProps({ teamId: 'teamId', data: { name: 'name', type: 0, extra: 'extra' } })": [], "isTeamsUpdateProps({ teamName: 'teamName', extra: 'extra', data: { name: 'name', type: 0 } })": [], "isTeamsUpdateProps({ teamId: 'teamId', extra: 'extra', data: { name: 'name', type: 0 } })": []}, "static_cg": {"@test/183.ts: %dflt.[static]%dflt()": ["@test/183.ts: %dflt.%AM0()"], "@test/183.ts: %dflt.%AM1$%AM0()": ["@test/183.ts: %dflt.%AM2$%AM1$%AM0()", "@test/183.ts: %dflt.%AM3$%AM1$%AM0()", "@test/183.ts: %dflt.%AM4$%AM1$%AM0()", "@test/183.ts: %dflt.%AM5$%AM1$%AM0()", "@test/183.ts: %dflt.%AM6$%AM1$%AM0()", "@test/183.ts: %dflt.%AM7$%AM1$%AM0()", "@test/183.ts: %dflt.%AM8$%AM1$%AM0()", "@test/183.ts: %dflt.%AM9$%AM1$%AM0()", "@test/183.ts: %dflt.%AM10$%AM1$%AM0()", "@test/183.ts: %dflt.%AM11$%AM1$%AM0()", "@test/183.ts: %dflt.%AM12$%AM1$%AM0()", "@test/183.ts: %dflt.%AM13$%AM1$%AM0()", "@test/183.ts: %dflt.%AM14$%AM1$%AM0()", "@test/183.ts: %dflt.%AM15$%AM1$%AM0()", "@test/183.ts: %dflt.%AM16$%AM1$%AM0()", "@test/183.ts: %dflt.%AM17$%AM1$%AM0()", "@test/183.ts: %dflt.%AM18$%AM1$%AM0()", "@test/183.ts: %dflt.%AM19$%AM1$%AM0()"], "@test/183.ts: %dflt.%AM0()": ["@test/183.ts: %dflt.%AM1$%AM0()"]}}
{"source_code": "import fs from \"fs\";\nimport path from \"path\";\nimport { ComponentResourceOptions, Output, all } from \"@pulumi/pulumi\";\nimport {\n  SsrSiteArgs,\n  createKvStorage,\n  createRouter,\n  prepare,\n  validatePlan,\n} from \"./ssr-site.js\";\nimport { Component } from \"../component.js\";\nimport { Hint } from \"../hint.js\";\nimport { Link } from \"../link.js\";\nimport { Kv } from \"./kv.js\";\nimport { buildApp } from \"../base/base-ssr-site.js\";\nimport { Worker } from \"./worker.js\";\nimport { Plugin } from \"esbuild\";\nimport { pathToRegexp } from \"../../util/path-to-regex.js\";\nexport interface RemixArgs extends SsrSiteArgs {\n  assets?: SsrSiteArgs[\"assets\"];\n  buildCommand?: SsrSiteArgs[\"buildCommand\"];\n  domain?: SsrSiteArgs[\"domain\"];\n  environment?: SsrSiteArgs[\"environment\"];\n  link?: SsrSiteArgs[\"link\"];\n  path?: SsrSiteArgs[\"path\"];\n}\nexport class Remix extends Component implements Link.Linkable {\n  private assets: Kv;\n  private router: Output<Worker>;\n  private server: Output<Worker>;\n  constructor(\n    name: string,\n    args: RemixArgs = {},\n    opts: ComponentResourceOptions = {},\n  ) {\n    super(__pulumiType, name, args, opts);\n    const parent = this;\n    const { sitePath } = prepare(args);\n    const isUsingVite = checkIsUsingVite();\n    const storage = createKvStorage(parent, name, args);\n    const outputPath = $dev ? sitePath : buildApp(parent, name, args, sitePath);\n    const { buildMeta } = loadBuildOutput();\n    const plan = buildPlan();\n    const { router, server } = createRouter(\n      parent,\n      name,\n      args,\n      outputPath,\n      storage,\n      plan,\n    );\n    this.assets = storage;\n    this.router = router;\n    this.server = server;\n    if (!$dev) {\n      Hint.register(this.urn, this.url as Output<string>);\n    }\n    this.registerOutputs({\n      _metadata: {\n        mode: $dev ? \"placeholder\" : \"deployed\",\n        path: sitePath,\n        url: this.url,\n      },\n    });\n    function checkIsUsingVite() {\n      return sitePath.apply(\n        (sitePath) =>\n          fs.existsSync(path.join(sitePath, \"vite.config.ts\")) ||\n          fs.existsSync(path.join(sitePath, \"vite.config.js\")),\n      );\n    }\n    function loadBuildOutput() {\n      return {\n        buildMeta: $dev ? loadBuildMetadataPlaceholder() : loadBuildMetadata(),\n      };\n    }\n    function loadBuildMetadata() {\n      return all([outputPath, isUsingVite]).apply(\n        ([outputPath, isUsingVite]) => {\n          // The path for all files that need to be in the \"/\" directory (static assets)\n          // is different when using Vite. These will be located in the \"build/client\"\n          // path of the output. It will be the \"public\" folder when using remix config.\n          const assetsPath = isUsingVite\n            ? path.join(\"build\", \"client\")\n            : \"public\";\n          const assetsVersionedSubDir = isUsingVite ? undefined : \"build\";\n          return {\n            assetsPath,\n            assetsVersionedSubDir,\n            // create 1 behaviour for each top level asset file/folder\n            staticRoutes: fs\n              .readdirSync(path.join(outputPath, assetsPath), {\n                withFileTypes: true,\n              })\n              .map((item) =>\n                item.isDirectory() ? `${item.name}/(.*)` : item.name,\n              ),\n          };\n        },\n      );\n    }\n    function loadBuildMetadataPlaceholder() {\n      return {\n        assetsPath: \"placeholder\",\n        assetsVersionedSubDir: undefined,\n        staticRoutes: [],\n      };\n    }\n    function buildPlan() {\n      return all([isUsingVite, outputPath, buildMeta]).apply(\n        ([isUsingVite, outputPath, buildMeta]) => {\n          return validatePlan({\n            server: createServerLambdaBundle(isUsingVite, outputPath),\n            assets: {\n              copy: [\n                {\n                  from: buildMeta.assetsPath,\n                  to: \"\",\n                  cached: true,\n                  versionedSubDir: buildMeta.assetsVersionedSubDir,\n                },\n              ],\n            },\n            routes: [\n              {\n                regex: pathToRegexp(buildMeta.staticRoutes).source,\n                origin: \"assets\" as const,\n              },\n              {\n                regex: pathToRegexp(\"(.*)\").source,\n                origin: \"server\" as const,\n              },\n            ],\n          });\n        },\n      );\n    }\n    function createServerLambdaBundle(\n      isUsingVite: boolean,\n      outputPath: string,\n    ) {\n      // Create a Lambda@Edge handler for the Remix server bundle.\n      //\n      // Note: Remix does perform their own internal ESBuild process, but it\n      // doesn't bundle 3rd party dependencies by default. In the interest of\n      // keeping deployments seamless for users we will create a server bundle\n      // with all dependencies included. We will still need to consider how to\n      // address any need for external dependencies, although I think we should\n      // possibly consider this at a later date.\n      // In this path we are assuming that the Remix build only outputs the\n      // \"core server build\". We can safely assume this as we have guarded the\n      // remix.config.js to ensure it matches our expectations for the build\n      // configuration.\n      // We need to ensure that the \"core server build\" is wrapped with an\n      // appropriate Lambda@Edge handler. We will utilise an internal asset\n      // template to create this wrapper within the \"core server build\" output\n      // directory.\n      // Ensure build directory exists\n      const buildPath = path.join(outputPath, \"build\");\n      fs.mkdirSync(buildPath, { recursive: true });\n      // Copy the server lambda handler and pre-append the build injection based\n      // on the config file used.\n      const content = [\n        // When using Vite config, the output build will be \"server/index.js\"\n        // and when using Remix config it will be `server.js`.\n        //isUsingVite\n        //  ? `import * as remixServerBuild from \"./server/index.js\";`\n        //  : `import * as remixServerBuild from \"./index.js\";`,\n        //`import { createRequestHandler } from \"@remix-run/cloudflare\";`,\n        //`import * as remixServerBuild from \"./server\";`,\n        //`import { createRequestHandler } from \"@remix-run/cloudflare\";`,\n        //`export default {`,\n        //`  async fetch(request) {`,\n        //`    const requestHandler = createRequestHandler(remixServerBuild);`,\n        //`    return await requestHandler(request);`,\n        //`  },`,\n        //`};`,\n        `import { createRequestHandler } from \"@remix-run/cloudflare\";`,\n        `import * as build from \"./server/index.js\";`,\n        `export default {`,\n        `  async fetch(request) {`,\n        `    console.log(\"fetch\");`,\n        `    console.log(\"build\", build);`,\n        `    console.log(\"build mode\", build.mode);`,\n        `    const handleRequest = createRequestHandler(build);`,\n        `    console.log(\"handleRequest\", handleRequest);`,\n        `    return await handleRequest(request);`,\n        `  },`,\n        `};`,\n      ].join(\"\\n\");\n      fs.writeFileSync(path.join(buildPath, \"server.ts\"), content);\n      const nodeBuiltInModulesPlugin: Plugin = {\n        name: \"node:built-in:modules\",\n        setup(build) {\n          build.onResolve({ filter: /^(util|stream)$/ }, ({ kind, path }) => {\n            // this plugin converts `require(\"node:*\")` calls, those are the only ones that\n            // need updating (esm imports to \"node:*\" are totally valid), so here we tag with the\n            // node-buffer namespace only imports that are require calls\n            return kind === \"require-call\"\n              ? { path, namespace: \"node-built-in-modules\" }\n              : undefined;\n          });\n          // we convert the imports we tagged with the node-built-in-modules namespace so that instead of `require(\"node:*\")`\n          // they import from `export * from \"node:*\";`\n          build.onLoad(\n            { filter: /.*/, namespace: \"node-built-in-modules\" },\n            ({ path }) => {\n              return {\n                contents: `export * from 'node:${path}'`,\n                loader: \"js\",\n              };\n            },\n          );\n        },\n      };\n      return {\n        handler: path.join(buildPath, \"server.ts\"),\n        build: {\n          esbuild: {\n            define: {\n              process: JSON.stringify({\n                env: {\n                  //NODE_ENV: \"production\",\n                  NODE_ENV: \"development\",\n                },\n              }),\n            },\n            plugins: [nodeBuiltInModulesPlugin],\n          },\n        },\n      };\n    }\n  }\n  public get url() {\n    return this.router.url;\n  }\n  public get nodes() {\n    return {\n      server: this.server,\n      assets: this.assets,\n    };\n  }\n  public getSSTLink() {\n    return {\n      properties: {\n        url: this.url,\n      },\n    };\n  }\n}\nconst __pulumiType = \"sst:cloudflare:Remix\";\n// @ts-expect-error\nRemix.__pulumiType = __pulumiType;", "llm_cg": {"Remix.constructor(string, RemixArgs, ComponentResourceOptions)": ["Remix.%AM0$checkIsUsingVite()", "Remix.%AM0$loadBuildOutput()", "Remix.%AM0$buildPlan()", "prepare(RemixArgs)", "createKvStorage(Remix, string, RemixArgs)", "buildApp(Remix, string, RemixArgs, string)", "createRouter(Remix, string, RemixArgs, string, Kv, unknown)", "Hint.register(unknown, Output<string>)", "Remix.registerOutputs(unknown)"], "Remix.%AM0$checkIsUsingVite()": ["path.join(string, string)", "fs.existsSync(string)"], "Remix.%AM0$loadBuildOutput()": ["Remix.%AM1$loadBuildMetadataPlaceholder()", "Remix.%AM1$loadBuildMetadata()"], "Remix.%AM1$loadBuildMetadata()": ["Remix.%AM2$loadBuildMetadata().apply(unknown)"], "Remix.%AM2$loadBuildMetadata().apply(unknown)": ["path.join(string, string)", "fs.readdirSync(string, unknown)"], "Remix.%AM1$loadBuildMetadataPlaceholder()": [], "Remix.%AM0$buildPlan()": ["Remix.%AM3$buildPlan().apply(unknown)", "validatePlan(unknown)"], "Remix.%AM3$buildPlan().apply(unknown)": ["Remix.%AM4$createServerLambdaBundle(boolean, string)", "pathToRegexp(unknown)"], "Remix.%AM4$createServerLambdaBundle(boolean, string)": ["fs.writeFileSync(string, string)", "path.join(string, string)", "fs.mkdirSync(string, unknown)"], "Remix.registerOutputs(unknown)": []}, "static_cg": {"@test/184.ts: Remix.constructor(string, @test/184.ts: RemixArgs, ComponentResourceOptions)": ["@test/184.ts: Remix.%checkIsUsingVite$constructor([sitePath])", "@test/184.ts: Remix.%buildPlan$constructor([isUsingVite, outputPath, buildMeta])"], "@test/184.ts: Remix.%checkIsUsingVite$constructor([sitePath])": ["@test/184.ts: Remix.%AM0$%checkIsUsingVite$constructor(unknown)"], "@test/184.ts: Remix.%loadBuildMetadata$constructor([outputPath, isUsingVite])": ["@test/184.ts: Remix.%AM1$%loadBuildMetadata$constructor(unknown)"], "@test/184.ts: Remix.%buildPlan$constructor([isUsingVite, outputPath, buildMeta])": ["@test/184.ts: Remix.%AM2$%buildPlan$constructor(unknown)"], "@test/184.ts: %AC$Remix$%AM1$%loadBuildMetadata$constructor$3.%instInit()": ["@test/184.ts: %AC$Remix$%AM1$%loadBuildMetadata$constructor$3.%AM0$%instInit(unknown)"], "@test/184.ts: %AC$Remix$%createServerLambdaBundle$constructor$12.setup(unknown)": ["@test/184.ts: %AC$Remix$%createServerLambdaBundle$constructor$12.%AM0$setup(unknown)", "@test/184.ts: %AC$Remix$%createServerLambdaBundle$constructor$12.%AM1$setup(unknown)"]}}
{"source_code": "import type { Nullable } from \"core/types\";\nimport { serializeAsTexture, serialize, expandToProperty, serializeAsColor3 } from \"core/Misc/decorators\";\nimport { SerializationHelper } from \"core/Misc/decorators.serialization\";\nimport type { Matrix } from \"core/Maths/math.vector\";\nimport { Color3 } from \"core/Maths/math.color\";\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\nimport type { IEffectCreationOptions } from \"core/Materials/effect\";\nimport { MaterialDefines } from \"core/Materials/materialDefines\";\nimport { PushMaterial } from \"core/Materials/pushMaterial\";\nimport { MaterialFlags } from \"core/Materials/materialFlags\";\nimport { VertexBuffer } from \"core/Buffers/buffer\";\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\nimport type { SubMesh } from \"core/Meshes/subMesh\";\nimport type { Mesh } from \"core/Meshes/mesh\";\nimport { Scene } from \"core/scene\";\nimport { RegisterClass } from \"core/Misc/typeStore\";\nimport \"./normal.fragment\";\nimport \"./normal.vertex\";\nimport { EffectFallbacks } from \"core/Materials/effectFallbacks\";\nimport { addClipPlaneUniforms, bindClipPlane } from \"core/Materials/clipPlaneMaterialHelper\";\nimport {\n    BindBonesParameters,\n    BindFogParameters,\n    BindLights,\n    BindLogDepth,\n    HandleFallbacksForShadows,\n    PrepareAttributesForBones,\n    PrepareAttributesForInstances,\n    PrepareDefinesForAttributes,\n    PrepareDefinesForFrameBoundValues,\n    PrepareDefinesForLights,\n    PrepareDefinesForMisc,\n    PrepareUniformsAndSamplersList,\n} from \"core/Materials/materialHelper.functions\";\nclass NormalMaterialDefines extends MaterialDefines {\n    public DIFFUSE = false;\n    public CLIPPLANE = false;\n    public CLIPPLANE2 = false;\n    public CLIPPLANE3 = false;\n    public CLIPPLANE4 = false;\n    public CLIPPLANE5 = false;\n    public CLIPPLANE6 = false;\n    public ALPHATEST = false;\n    public DEPTHPREPASS = false;\n    public POINTSIZE = false;\n    public FOG = false;\n    public LIGHT0 = false;\n    public LIGHT1 = false;\n    public LIGHT2 = false;\n    public LIGHT3 = false;\n    public SPOTLIGHT0 = false;\n    public SPOTLIGHT1 = false;\n    public SPOTLIGHT2 = false;\n    public SPOTLIGHT3 = false;\n    public HEMILIGHT0 = false;\n    public HEMILIGHT1 = false;\n    public HEMILIGHT2 = false;\n    public HEMILIGHT3 = false;\n    public DIRLIGHT0 = false;\n    public DIRLIGHT1 = false;\n    public DIRLIGHT2 = false;\n    public DIRLIGHT3 = false;\n    public POINTLIGHT0 = false;\n    public POINTLIGHT1 = false;\n    public POINTLIGHT2 = false;\n    public POINTLIGHT3 = false;\n    public SHADOW0 = false;\n    public SHADOW1 = false;\n    public SHADOW2 = false;\n    public SHADOW3 = false;\n    public SHADOWS = false;\n    public SHADOWESM0 = false;\n    public SHADOWESM1 = false;\n    public SHADOWESM2 = false;\n    public SHADOWESM3 = false;\n    public SHADOWPOISSON0 = false;\n    public SHADOWPOISSON1 = false;\n    public SHADOWPOISSON2 = false;\n    public SHADOWPOISSON3 = false;\n    public SHADOWPCF0 = false;\n    public SHADOWPCF1 = false;\n    public SHADOWPCF2 = false;\n    public SHADOWPCF3 = false;\n    public SHADOWPCSS0 = false;\n    public SHADOWPCSS1 = false;\n    public SHADOWPCSS2 = false;\n    public SHADOWPCSS3 = false;\n    public NORMAL = false;\n    public UV1 = false;\n    public UV2 = false;\n    public NUM_BONE_INFLUENCERS = 0;\n    public BonesPerMesh = 0;\n    public INSTANCES = false;\n    public LIGHTING = false;\n    public IMAGEPROCESSINGPOSTPROCESS = false;\n    public SKIPFINALCOLORCLAMP = false;\n    public LOGARITHMICDEPTH = false;\n    constructor() {\n        super();\n        this.rebuild();\n    }\n}\nexport class NormalMaterial extends PushMaterial {\n    @serializeAsTexture(\"diffuseTexture\")\n    private _diffuseTexture: BaseTexture;\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    public diffuseTexture: BaseTexture;\n    @serializeAsColor3()\n    public diffuseColor = new Color3(1, 1, 1);\n    @serialize(\"disableLighting\")\n    private _disableLighting = false;\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\n    public disableLighting: boolean;\n    @serialize(\"maxSimultaneousLights\")\n    private _maxSimultaneousLights = 4;\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\n    public maxSimultaneousLights: number;\n    constructor(name: string, scene?: Scene) {\n        super(name, scene);\n    }\n    public override needAlphaBlending(): boolean {\n        return this.alpha < 1.0;\n    }\n    public override needAlphaBlendingForMesh(mesh: AbstractMesh): boolean {\n        return this.needAlphaBlending() || mesh.visibility < 1.0;\n    }\n    public override needAlphaTesting(): boolean {\n        return false;\n    }\n    public override getAlphaTestTexture(): Nullable<BaseTexture> {\n        return null;\n    }\n    // Methods\n    public override isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\n        const drawWrapper = subMesh._drawWrapper;\n        if (this.isFrozen) {\n            if (drawWrapper.effect && drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {\n                return true;\n            }\n        }\n        if (!subMesh.materialDefines) {\n            subMesh.materialDefines = new NormalMaterialDefines();\n        }\n        const defines = <NormalMaterialDefines>subMesh.materialDefines;\n        const scene = this.getScene();\n        if (this._isReadyForSubMesh(subMesh)) {\n            return true;\n        }\n        const engine = scene.getEngine();\n        // Textures\n        if (defines._areTexturesDirty) {\n            defines._needUVs = false;\n            if (scene.texturesEnabled) {\n                if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\n                    if (!this._diffuseTexture.isReady()) {\n                        return false;\n                    } else {\n                        defines._needUVs = true;\n                        defines.DIFFUSE = true;\n                    }\n                }\n            }\n        }\n        // Misc.\n        PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);\n        // Lights\n        defines._needNormals = true;\n        PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights, this._disableLighting);\n        // Values that need to be evaluated on every frame\n        PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false);\n        defines.LIGHTING = !this._disableLighting;\n        // Attribs\n        PrepareDefinesForAttributes(mesh, defines, true, true);\n        // Get correct effect\n        if (defines.isDirty) {\n            defines.markAsProcessed();\n            scene.resetCachedMaterial();\n            // Fallbacks\n            const fallbacks = new EffectFallbacks();\n            if (defines.FOG) {\n                fallbacks.addFallback(1, \"FOG\");\n            }\n            HandleFallbacksForShadows(defines, fallbacks);\n            if (defines.NUM_BONE_INFLUENCERS > 0) {\n                fallbacks.addCPUSkinningFallback(0, mesh);\n            }\n            defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;\n            //Attributes\n            const attribs = [VertexBuffer.PositionKind];\n            if (defines.NORMAL) {\n                attribs.push(VertexBuffer.NormalKind);\n            }\n            if (defines.UV1) {\n                attribs.push(VertexBuffer.UVKind);\n            }\n            if (defines.UV2) {\n                attribs.push(VertexBuffer.UV2Kind);\n            }\n            PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\n            PrepareAttributesForInstances(attribs, defines);\n            const shaderName = \"normal\";\n            const join = defines.toString();\n            const uniforms = [\n                \"world\",\n                \"view\",\n                \"viewProjection\",\n                \"vEyePosition\",\n                \"vLightsType\",\n                \"vDiffuseColor\",\n                \"vFogInfos\",\n                \"vFogColor\",\n                \"pointSize\",\n                \"vDiffuseInfos\",\n                \"mBones\",\n                \"diffuseMatrix\",\n                \"logarithmicDepthConstant\",\n            ];\n            const samplers = [\"diffuseSampler\"];\n            const uniformBuffers: string[] = [];\n            addClipPlaneUniforms(uniforms);\n            PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\n                uniformsNames: uniforms,\n                uniformBuffersNames: uniformBuffers,\n                samplers: samplers,\n                defines: defines,\n                maxSimultaneousLights: 4,\n            });\n            subMesh.setEffect(\n                scene.getEngine().createEffect(\n                    shaderName,\n                    <IEffectCreationOptions>{\n                        attributes: attribs,\n                        uniformsNames: uniforms,\n                        uniformBuffersNames: uniformBuffers,\n                        samplers: samplers,\n                        defines: join,\n                        fallbacks: fallbacks,\n                        onCompiled: this.onCompiled,\n                        onError: this.onError,\n                        indexParameters: { maxSimultaneousLights: 4 },\n                    },\n                    engine\n                ),\n                defines,\n                this._materialContext\n            );\n        }\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\n            return false;\n        }\n        defines._renderId = scene.getRenderId();\n        drawWrapper._wasPreviouslyReady = true;\n        drawWrapper._wasPreviouslyUsingInstances = !!useInstances;\n        return true;\n    }\n    public override bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\n        const scene = this.getScene();\n        const defines = <NormalMaterialDefines>subMesh.materialDefines;\n        if (!defines) {\n            return;\n        }\n        const effect = subMesh.effect;\n        if (!effect) {\n            return;\n        }\n        this._activeEffect = effect;\n        // Matrices\n        this.bindOnlyWorldMatrix(world);\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\n        // Bones\n        BindBonesParameters(mesh, this._activeEffect);\n        if (this._mustRebind(scene, effect, subMesh)) {\n            // Textures\n            if (this.diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\n                this._activeEffect.setTexture(\"diffuseSampler\", this.diffuseTexture);\n                this._activeEffect.setFloat2(\"vDiffuseInfos\", this.diffuseTexture.coordinatesIndex, this.diffuseTexture.level);\n                this._activeEffect.setMatrix(\"diffuseMatrix\", this.diffuseTexture.getTextureMatrix());\n            }\n            // Clip plane\n            bindClipPlane(effect, this, scene);\n            // Point size\n            if (this.pointsCloud) {\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\n            }\n            // Log. depth\n            if (this._useLogarithmicDepth) {\n                BindLogDepth(defines, effect, scene);\n            }\n            scene.bindEyePosition(effect);\n        }\n        this._activeEffect.setColor4(\"vDiffuseColor\", this.diffuseColor, this.alpha * mesh.visibility);\n        // Lights\n        if (scene.lightsEnabled && !this.disableLighting) {\n            BindLights(scene, mesh, this._activeEffect, defines);\n        }\n        // View\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\n        }\n        // Fog\n        BindFogParameters(scene, mesh, this._activeEffect);\n        this._afterBind(mesh, this._activeEffect, subMesh);\n    }\n    public override getAnimatables(): IAnimatable[] {\n        const results = [];\n        if (this.diffuseTexture && this.diffuseTexture.animations && this.diffuseTexture.animations.length > 0) {\n            results.push(this.diffuseTexture);\n        }\n        return results;\n    }\n    public override getActiveTextures(): BaseTexture[] {\n        const activeTextures = super.getActiveTextures();\n        if (this._diffuseTexture) {\n            activeTextures.push(this._diffuseTexture);\n        }\n        return activeTextures;\n    }\n    public override hasTexture(texture: BaseTexture): boolean {\n        if (super.hasTexture(texture)) {\n            return true;\n        }\n        if (this.diffuseTexture === texture) {\n            return true;\n        }\n        return false;\n    }\n    public override dispose(forceDisposeEffect?: boolean): void {\n        if (this.diffuseTexture) {\n            this.diffuseTexture.dispose();\n        }\n        super.dispose(forceDisposeEffect);\n    }\n    public override clone(name: string): NormalMaterial {\n        return SerializationHelper.Clone(() => new NormalMaterial(name, this.getScene()), this);\n    }\n    public override serialize(): any {\n        const serializationObject = super.serialize();\n        serializationObject.customType = \"BABYLON.NormalMaterial\";\n        return serializationObject;\n    }\n    public override getClassName(): string {\n        return \"NormalMaterial\";\n    }\n    // Statics\n    public static override Parse(source: any, scene: Scene, rootUrl: string): NormalMaterial {\n        return SerializationHelper.Parse(() => new NormalMaterial(source.name, scene), source, scene, rootUrl);\n    }\n}\nRegisterClass(\"BABYLON.NormalMaterial\", NormalMaterial);", "llm_cg": {"NormalMaterial.needAlphaBlending()": [], "NormalMaterial.needAlphaBlendingForMesh(mesh: AbstractMesh)": ["NormalMaterial.needAlphaBlending()"], "NormalMaterial.needAlphaTesting()": [], "NormalMaterial.getAlphaTestTexture()": [], "NormalMaterial.isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances: boolean)": ["NormalMaterial.getScene()", "%AMX$NormalMaterialDefines()", "NormalMaterial._isReadyForSubMesh(subMesh: SubMesh)", "NormalMaterial.getScene()", "PrepareDefinesForMisc()", "PrepareDefinesForLights()", "PrepareDefinesForFrameBoundValues()", "PrepareDefinesForAttributes()", "%AMX$EffectFallbacks()", "HandleFallbacksForShadows()", "PrepareAttributesForBones()", "PrepareAttributesForInstances()", "addClipPlaneUniforms()", "PrepareUniformsAndSamplersList()", "NormalMaterial.onCompiled()", "NormalMaterial.onError()", "Scene.getEngine()", "Scene.resetCachedMaterial()", "SubMesh.setEffect(effect: Effect, defines: any, materialContext: any)", "Engine.createEffect(shaderName: string, options: IEffectCreationOptions, engine: Engine)"], "NormalMaterial.bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh)": ["NormalMaterial.getScene()", "NormalMaterial.bindOnlyWorldMatrix(world: Matrix)", "BindBonesParameters()", "NormalMaterial._mustRebind(scene: Scene, effect: Effect, subMesh: SubMesh)", "Effect.setTexture(name: string, texture: BaseTexture)", "Effect.setFloat2(name: string, x: number, y: number)", "Effect.setMatrix(name: string, matrix: Matrix)", "bindClipPlane(effect: Effect, material: Material, scene: Scene)", "Effect.setFloat(name: string, x: number)", "BindLogDepth()", "Scene.bindEyePosition(effect: Effect)", "Effect.setColor4(name: string, color: Color3, alpha: number)", "BindLights()", "Effect.setMatrix(name: string, matrix: Matrix)", "BindFogParameters()", "Material._afterBind(mesh: Mesh, effect: Effect, subMesh: SubMesh)"], "NormalMaterial.getAnimatables()": [], "NormalMaterial.getActiveTextures()": ["PushMaterial.getActiveTextures()"], "NormalMaterial.hasTexture(texture: BaseTexture)": ["PushMaterial.hasTexture(texture: BaseTexture)"], "NormalMaterial.dispose(forceDisposeEffect: boolean)": ["PushMaterial.dispose(forceDisposeEffect: boolean)", "BaseTexture.dispose()"], "NormalMaterial.clone(name: string)": ["SerializationHelper.Clone()", "%AMX$NormalMaterial(name: string, scene?: Scene)"], "NormalMaterial.serialize()": ["PushMaterial.serialize()"], "NormalMaterial.getClassName()": [], "NormalMaterial.Parse(source: any, scene: Scene, rootUrl: string)": ["SerializationHelper.Parse()", "%AMX$NormalMaterial(name: string, scene?: Scene)"]}, "static_cg": {"@test/185.ts: NormalMaterial.needAlphaBlendingForMesh(AbstractMesh)": ["@test/185.ts: NormalMaterial.needAlphaBlending()"], "@test/185.ts: NormalMaterial.isReadyForSubMesh(AbstractMesh, SubMesh, boolean)": ["@test/185.ts: NormalMaterialDefines.constructor()"], "@test/185.ts: NormalMaterial.clone(string)": ["@test/185.ts: NormalMaterial.%AM0$clone([name])"], "@test/185.ts: NormalMaterial.%AM0$clone([name])": ["@test/185.ts: NormalMaterial.constructor(string, Scene)"], "@test/185.ts: NormalMaterial.%AM1$Parse([source, scene])": ["@test/185.ts: NormalMaterial.constructor(string, Scene)"], "@test/185.ts: NormalMaterial.[static]Parse(any, Scene, string)": ["@test/185.ts: NormalMaterial.%AM1$Parse([source, scene])"]}}
{"source_code": "import { Datum } from \".\";\nimport LatLonEllipsoidal, { Dms } from \"./latlon-ellipsoidal-datum\";\ntype Hemisphere = \"N\" | \"S\";\ndeclare class Utm {\n    zone: number;\n    hemisphere: Hemisphere;\n    easting: number;\n    northing: number;\n    datum: Datum;\n    convergence: number | null;\n    scale: number | null;\n    constructor(\n        zone: number,\n        hemisphere: Hemisphere,\n        easting: number,\n        northing: number,\n        datum?: Datum,\n        convergence?: number,\n        scale?: number,\n    );\n    static parse(utmCoord: string, datum?: Datum): Utm;\n    toLatLon(): LatLon_Utm;\n    toString(digits?: number): string;\n}\ndeclare class LatLon_Utm extends LatLonEllipsoidal {\n    toUtm(zoneOverride?: number): Utm;\n}\nexport { Dms, LatLon_Utm as LatLon, Utm as default };", "llm_cg": {"Utm.parse(string, Datum)": [], "Utm.toLatLon()": [], "Utm.toString(number)": [], "LatLon_Utm.toUtm(number)": []}, "static_cg": {}}
{"source_code": "import axios from 'axios';\nimport { Novu } from '../novu';\nconst mockConfig = {\n  apiKey: '1234',\n};\njest.mock('axios');\ndescribe('test use of novus node package - InboundParse class', () => {\n  const mockedAxios = axios as jest.Mocked<typeof axios>;\n  let novu: Novu;\n  beforeEach(() => {\n    mockedAxios.create.mockReturnThis();\n    novu = new Novu(mockConfig.apiKey);\n  });\n  test('should get inbound parse correctly', async () => {\n    mockedAxios.get.mockResolvedValue({});\n    await novu.inboundParse.getMxStatus();\n    expect(mockedAxios.get).toHaveBeenCalled();\n    expect(mockedAxios.get).toHaveBeenCalledWith('/inbound-parse/mx/status');\n  });\n});", "llm_cg": {"TestSuite.describe(string)": ["AnonymousClass.beforeEach()", "AnonymousClass.test(string, function)"], "AnonymousClass.beforeEach()": ["AnonymousClass.%AMX$mockReturnThis()", "Novu.constructor(string)"], "AnonymousClass.test(string, function)": ["AnonymousClass.%AMX$mockResolvedValue(object)", "NovuInboundParse.getMxStatus()"]}, "static_cg": {"@test/187.ts: %dflt.[static]%dflt()": ["@test/187.ts: %dflt.%AM0()"], "@test/187.ts: %dflt.%AM0()": ["@test/187.ts: %dflt.%AM1$%AM0()", "@test/187.ts: %dflt.%AM2$%AM0()"]}}
{"source_code": "import type { Quiz } from '../../types'\nimport type { SupportedLocale } from '../../locales'\nimport { defaultLocale, t } from '../../locales'\nimport { toCommentBlock } from './toCommentBlock'\nimport { toInfoHeader } from './toInfoHeader'\nimport { toLinks } from './toLinks'\nimport { toDivider } from './toDivider'\nimport { toFooter } from './toFooter'\nexport function formatToCode(quiz: Quiz, locale: SupportedLocale) {\n  return `${toCommentBlock(\n    toInfoHeader(quiz, locale)\n    + (quiz.readme[locale] || quiz.readme[defaultLocale])\n    + toLinks(quiz, locale),\n  )\n  + toDivider(t(locale, 'divider.code-start'))\n  }\\n${\n    (quiz.template || '').trim()\n  }\\n${\n    toDivider(t(locale, 'divider.test-cases'))\n  }${\n    (quiz.tests || '').trim()\n  }\\n${\n    toDivider(t(locale, 'divider.further-steps'))\n  }${toCommentBlock(toFooter(quiz, locale))}`\n}", "llm_cg": {"formatToCode(quiz: Quiz, locale: SupportedLocale)": ["%AM0$toCommentBlock(string)", "%AM0$toInfoHeader(quiz: Quiz, locale: SupportedLocale)", "%AM0$toLinks(quiz: Quiz, locale: SupportedLocale)", "%AM0$toDivider(string)", "%AM0$t(locale: SupportedLocale, string)", "%AM0$toFooter(quiz: Quiz, locale: SupportedLocale)"]}, "static_cg": {}}
{"source_code": "import axios, {\n  json2formData,\n  parseAxiosError,\n} from '@/portainer/services/axios';\nimport { EdgeGroup } from '@/react/edge/edge-groups/types';\nimport { EnvironmentId } from '@/react/portainer/environments/types';\nimport { EdgeJob } from '../../types';\nimport { buildUrl } from '../build-url';\nexport type FileUploadPayload = {\n  Name: string;\n  CronExpression: string;\n  Recurring: boolean;\n  EdgeGroups: Array<EdgeGroup['Id']>;\n  Endpoints: Array<EnvironmentId>;\n  File: File;\n};\nexport async function createJobFromFile(payload: FileUploadPayload) {\n  try {\n    const { data } = await axios.post<EdgeJob>(\n      buildUrl({ action: 'create/file' }),\n      json2formData(payload),\n      {\n        headers: {\n          'Content-Type': 'multipart/form-data',\n        },\n      }\n    );\n    return data;\n  } catch (e) {\n    throw parseAxiosError(e as Error);\n  }\n}", "llm_cg": {"createJobFromFile(FileUploadPayload)": ["axios.post<EdgeJob>(unknown, unknown, unknown)", "buildUrl({ action: 'create/file' })", "json2formData(FileUploadPayload)", "parseAxiosError(Error)"]}, "static_cg": {}}
{"source_code": "import { json, workspaces } from '@angular-devkit/core';\nimport { readFileSync } from 'node:fs';\nimport { createRequire } from 'node:module';\nimport * as path from 'node:path';\nimport { pathToFileURL } from 'node:url';\nimport { deserialize, serialize } from 'node:v8';\nimport { BuilderInfo } from '../src';\nimport { Schema as BuilderSchema } from '../src/builders-schema';\nimport { Target } from '../src/input-schema';\nimport { ArchitectHost, Builder, BuilderSymbol } from '../src/internal';\n// TODO_ESM: Update to use import.meta.url\nconst localRequire = createRequire(__filename);\nexport type NodeModulesBuilderInfo = BuilderInfo & {\n  import: string;\n};\nfunction clone(obj: unknown): unknown {\n  try {\n    return deserialize(serialize(obj));\n  } catch {\n    return JSON.parse(JSON.stringify(obj)) as unknown;\n  }\n}\nexport interface WorkspaceHost {\n  getBuilderName(project: string, target: string): Promise<string>;\n  getMetadata(project: string): Promise<json.JsonObject>;\n  getOptions(project: string, target: string, configuration?: string): Promise<json.JsonObject>;\n  hasTarget(project: string, target: string): Promise<boolean>;\n  getDefaultConfigurationName(project: string, target: string): Promise<string | undefined>;\n}\nfunction findProjectTarget(\n  workspace: workspaces.WorkspaceDefinition,\n  project: string,\n  target: string,\n): workspaces.TargetDefinition {\n  const projectDefinition = workspace.projects.get(project);\n  if (!projectDefinition) {\n    throw new Error(`Project \"${project}\" does not exist.`);\n  }\n  const targetDefinition = projectDefinition.targets.get(target);\n  if (!targetDefinition) {\n    throw new Error('Project target does not exist.');\n  }\n  return targetDefinition;\n}\nexport class WorkspaceNodeModulesArchitectHost implements ArchitectHost<NodeModulesBuilderInfo> {\n  private workspaceHost: WorkspaceHost;\n  constructor(workspaceHost: WorkspaceHost, _root: string);\n  constructor(workspace: workspaces.WorkspaceDefinition, _root: string);\n  constructor(\n    workspaceOrHost: workspaces.WorkspaceDefinition | WorkspaceHost,\n    protected _root: string,\n  ) {\n    if ('getBuilderName' in workspaceOrHost) {\n      this.workspaceHost = workspaceOrHost;\n    } else {\n      this.workspaceHost = {\n        async getBuilderName(project, target) {\n          const targetDefinition = findProjectTarget(workspaceOrHost, project, target);\n          return targetDefinition.builder;\n        },\n        async getOptions(project, target, configuration) {\n          const targetDefinition = findProjectTarget(workspaceOrHost, project, target);\n          if (configuration === undefined) {\n            return (targetDefinition.options ?? {}) as json.JsonObject;\n          }\n          if (!targetDefinition.configurations?.[configuration]) {\n            throw new Error(`Configuration '${configuration}' is not set in the workspace.`);\n          }\n          return (targetDefinition.configurations?.[configuration] ?? {}) as json.JsonObject;\n        },\n        async getMetadata(project) {\n          const projectDefinition = workspaceOrHost.projects.get(project);\n          if (!projectDefinition) {\n            throw new Error(`Project \"${project}\" does not exist.`);\n          }\n          return {\n            root: projectDefinition.root,\n            sourceRoot: projectDefinition.sourceRoot,\n            prefix: projectDefinition.prefix,\n            ...(clone(workspaceOrHost.extensions) as {}),\n            ...(clone(projectDefinition.extensions) as {}),\n          } as unknown as json.JsonObject;\n        },\n        async hasTarget(project, target) {\n          return !!workspaceOrHost.projects.get(project)?.targets.has(target);\n        },\n        async getDefaultConfigurationName(project, target) {\n          return workspaceOrHost.projects.get(project)?.targets.get(target)?.defaultConfiguration;\n        },\n      };\n    }\n  }\n  async getBuilderNameForTarget(target: Target) {\n    return this.workspaceHost.getBuilderName(target.project, target.target);\n  }\n  resolveBuilder(\n    builderStr: string,\n    basePath = this._root,\n    seenBuilders?: Set<string>,\n  ): Promise<NodeModulesBuilderInfo> {\n    if (seenBuilders?.has(builderStr)) {\n      throw new Error(\n        'Circular builder alias references detected: ' + [...seenBuilders, builderStr],\n      );\n    }\n    const [packageName, builderName] = builderStr.split(':', 2);\n    if (!builderName) {\n      throw new Error('No builder name specified.');\n    }\n    // Resolve and load the builders manifest from the package's `builders` field, if present\n    const packageJsonPath = localRequire.resolve(packageName + '/package.json', {\n      paths: [basePath],\n    });\n    const packageJson = JSON.parse(readFileSync(packageJsonPath, 'utf-8')) as { builders?: string };\n    const buildersManifestRawPath = packageJson['builders'];\n    if (!buildersManifestRawPath) {\n      throw new Error(`Package ${JSON.stringify(packageName)} has no builders defined.`);\n    }\n    let buildersManifestPath = path.normalize(buildersManifestRawPath);\n    if (path.isAbsolute(buildersManifestRawPath) || buildersManifestRawPath.startsWith('..')) {\n      throw new Error(\n        `Package \"${packageName}\" has an invalid builders manifest path: \"${buildersManifestRawPath}\"`,\n      );\n    }\n    buildersManifestPath = path.join(path.dirname(packageJsonPath), buildersManifestPath);\n    const buildersManifest = JSON.parse(\n      readFileSync(buildersManifestPath, 'utf-8'),\n    ) as BuilderSchema;\n    const buildersManifestDirectory = path.dirname(buildersManifestPath);\n    // Attempt to locate an entry for the specified builder by name\n    const builder = buildersManifest.builders?.[builderName];\n    if (!builder) {\n      throw new Error(`Cannot find builder ${JSON.stringify(builderStr)}.`);\n    }\n    // Resolve alias reference if entry is a string\n    if (typeof builder === 'string') {\n      return this.resolveBuilder(\n        builder,\n        path.dirname(packageJsonPath),\n        (seenBuilders ?? new Set()).add(builderStr),\n      );\n    }\n    // Determine builder implementation path (relative within package only)\n    const implementationPath = builder.implementation && path.normalize(builder.implementation);\n    if (!implementationPath) {\n      throw new Error('Could not find the implementation for builder ' + builderStr);\n    }\n    if (path.isAbsolute(implementationPath) || implementationPath.startsWith('..')) {\n      throw new Error(\n        `Package \"${packageName}\" has an invalid builder implementation path: \"${builderName}\" --> \"${builder.implementation}\"`,\n      );\n    }\n    // Determine builder option schema path (relative within package only)\n    const schemaPath = builder.schema && path.normalize(builder.schema);\n    if (!schemaPath) {\n      throw new Error('Could not find the schema for builder ' + builderStr);\n    }\n    if (path.isAbsolute(schemaPath) || schemaPath.startsWith('..')) {\n      throw new Error(\n        `Package \"${packageName}\" has an invalid builder implementation path: \"${builderName}\" --> \"${builder.schema}\"`,\n      );\n    }\n    const schemaText = readFileSync(path.join(buildersManifestDirectory, schemaPath), 'utf-8');\n    return Promise.resolve({\n      name: builderStr,\n      builderName,\n      description: builder['description'],\n      optionSchema: JSON.parse(schemaText) as json.schema.JsonSchema,\n      import: path.join(buildersManifestDirectory, implementationPath),\n    });\n  }\n  async getCurrentDirectory() {\n    return process.cwd();\n  }\n  async getWorkspaceRoot() {\n    return this._root;\n  }\n  async getOptionsForTarget(target: Target): Promise<json.JsonObject | null> {\n    if (!(await this.workspaceHost.hasTarget(target.project, target.target))) {\n      return null;\n    }\n    let options = await this.workspaceHost.getOptions(target.project, target.target);\n    const targetConfiguration =\n      target.configuration ||\n      (await this.workspaceHost.getDefaultConfigurationName(target.project, target.target));\n    if (targetConfiguration) {\n      const configurations = targetConfiguration.split(',').map((c) => c.trim());\n      for (const configuration of configurations) {\n        options = {\n          ...options,\n          ...(await this.workspaceHost.getOptions(target.project, target.target, configuration)),\n        };\n      }\n    }\n    return clone(options) as json.JsonObject;\n  }\n  async getProjectMetadata(target: Target | string): Promise<json.JsonObject | null> {\n    const projectName = typeof target === 'string' ? target : target.project;\n    const metadata = this.workspaceHost.getMetadata(projectName);\n    return metadata;\n  }\n  async loadBuilder(info: NodeModulesBuilderInfo): Promise<Builder> {\n    const builder = await getBuilder(info.import);\n    if (builder[BuilderSymbol]) {\n      return builder;\n    }\n    // Default handling code is for old builders that incorrectly export `default` with non-ESM module\n    if (builder?.default[BuilderSymbol]) {\n      return builder.default;\n    }\n    throw new Error('Builder is not a builder');\n  }\n}\nlet load: (<T>(modulePath: string | URL) => Promise<T>) | undefined;\nexport function loadEsmModule<T>(modulePath: string | URL): Promise<T> {\n  load ??= new Function('modulePath', `return import(modulePath);`) as Exclude<\n    typeof load,\n    undefined\n  >;\n  return load(modulePath);\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nasync function getBuilder(builderPath: string): Promise<any> {\n  switch (path.extname(builderPath)) {\n    case '.mjs':\n      // Load the ESM configuration file using the TypeScript dynamic import workaround.\n      // Once TypeScript provides support for keeping the dynamic import this workaround can be\n      // changed to a direct dynamic import.\n      return (await loadEsmModule<{ default: unknown }>(pathToFileURL(builderPath))).default;\n    case '.cjs':\n      return localRequire(builderPath);\n    default:\n      // The file could be either CommonJS or ESM.\n      // CommonJS is tried first then ESM if loading fails.\n      try {\n        return localRequire(builderPath);\n      } catch (e) {\n        if ((e as NodeJS.ErrnoException).code === 'ERR_REQUIRE_ESM') {\n          // Load the ESM configuration file using the TypeScript dynamic import workaround.\n          // Once TypeScript provides support for keeping the dynamic import this workaround can be\n          // changed to a direct dynamic import.\n          return (await loadEsmModule<{ default: unknown }>(pathToFileURL(builderPath))).default;\n        }\n        throw e;\n      }\n  }\n}", "llm_cg": {"clone(obj: unknown)": [], "findProjectTarget(workspace.WorkspaceDefinition, project: string, target: string)": [], "WorkspaceNodeModulesArchitectHost.constructor(workspaceOrHost: workspaces.WorkspaceDefinition | WorkspaceHost, _root: string)": ["WorkspaceNodeModulesArchitectHost.%AM0$getBuilderName(project: string, target: string)", "WorkspaceNodeModulesArchitectHost.%AM0$getOptions(project: string, target: string, configuration?: string)", "WorkspaceNodeModulesArchitectHost.%AM0$getMetadata(project: string)", "WorkspaceNodeModulesArchitectHost.%AM0$hasTarget(project: string, target: string)", "WorkspaceNodeModulesArchitectHost.%AM0$getDefaultConfigurationName(project: string, target: string)"], "WorkspaceNodeModulesArchitectHost.getBuilderNameForTarget(target: Target)": ["WorkspaceNodeModulesArchitectHost.%AM0$getBuilderName(project: string, target: string)"], "WorkspaceNodeModulesArchitectHost.resolveBuilder(builderStr: string, basePath: string, seenBuilders?: Set<string>)": ["WorkspaceNodeModulesArchitectHost.resolveBuilder(builder: string, basePath: string, seenBuilders?: Set<string>)"], "WorkspaceNodeModulesArchitectHost.getOptionsForTarget(target: Target)": ["WorkspaceNodeModulesArchitectHost.%AM0$getOptions(project: string, target: string, configuration?: string)", "WorkspaceNodeModulesArchitectHost.%AM0$hasTarget(project: string, target: string)", "WorkspaceNodeModulesArchitectHost.%AM0$getDefaultConfigurationName(project: string, target: string)"], "WorkspaceNodeModulesArchitectHost.getProjectMetadata(target: Target | string)": ["WorkspaceNodeModulesArchitectHost.%AM0$getMetadata(project: string)"], "WorkspaceNodeModulesArchitectHost.loadBuilder(info: NodeModulesBuilderInfo)": ["getBuilder(builderPath: string)"], "loadEsmModule<T>(modulePath: string | URL)": [], "getBuilder(builderPath: string)": ["loadEsmModule<{ default: unknown }>(modulePath: string | URL)"], "WorkspaceNodeModulesArchitectHost.%AM0$getBuilderName(project: string, target: string)": ["findProjectTarget(workspace: workspaces.WorkspaceDefinition, project: string, target: string)"], "WorkspaceNodeModulesArchitectHost.%AM0$getOptions(project: string, target: string, configuration?: string)": ["findProjectTarget(workspace: workspaces.WorkspaceDefinition, project: string, target: string)"], "WorkspaceNodeModulesArchitectHost.%AM0$getMetadata(project: string)": ["findProjectTarget(workspace: workspaces.WorkspaceDefinition, project: string, target: string)", "clone(obj: unknown)"], "WorkspaceNodeModulesArchitectHost.%AM0$hasTarget(project: string, target: string)": ["findProjectTarget(workspace: workspaces.WorkspaceDefinition, project: string, target: string)"], "WorkspaceNodeModulesArchitectHost.%AM0$getDefaultConfigurationName(project: string, target: string)": ["findProjectTarget(workspace: workspaces.WorkspaceDefinition, project: string, target: string)"]}, "static_cg": {"@test/190.ts: %dflt.getBuilder(string)": ["@test/190.ts: %dflt.loadEsmModule(string|URL)"], "@test/190.ts: WorkspaceNodeModulesArchitectHost.getBuilderNameForTarget(Target)": ["@test/190.ts: WorkspaceHost.getBuilderName(string, string)"], "@test/190.ts: WorkspaceNodeModulesArchitectHost.resolveBuilder(string, unknown, Set<string>)": ["@test/190.ts: WorkspaceNodeModulesArchitectHost.resolveBuilder(string, unknown, Set<string>)"], "@test/190.ts: WorkspaceNodeModulesArchitectHost.getOptionsForTarget(Target)": ["@test/190.ts: WorkspaceHost.hasTarget(string, string)", "@test/190.ts: WorkspaceHost.getOptions(string, string, string)", "@test/190.ts: WorkspaceHost.getDefaultConfigurationName(string, string)", "@test/190.ts: WorkspaceNodeModulesArchitectHost.%AM0$getOptionsForTarget(unknown)", "@test/190.ts: %dflt.clone(UnknownKeyword)"], "@test/190.ts: WorkspaceNodeModulesArchitectHost.getProjectMetadata(Target|string)": ["@test/190.ts: WorkspaceHost.getMetadata(string)"], "@test/190.ts: WorkspaceNodeModulesArchitectHost.loadBuilder(NodeModulesBuilderInfo)": ["@test/190.ts: %dflt.getBuilder(string)"], "@test/190.ts: %AC$WorkspaceNodeModulesArchitectHost$constructor$2.getBuilderName(unknown, unknown)": ["@test/190.ts: %dflt.findProjectTarget(workspaces.WorkspaceDefinition, string, string)"], "@test/190.ts: %AC$WorkspaceNodeModulesArchitectHost$constructor$2.getOptions(unknown, unknown, unknown)": ["@test/190.ts: %dflt.findProjectTarget(workspaces.WorkspaceDefinition, string, string)"]}}
{"source_code": "import { BedrockEmbeddings } from '@langchain/aws';\nimport {\n\tNodeConnectionType,\n\ttype INodeType,\n\ttype INodeTypeDescription,\n\ttype ISupplyDataFunctions,\n\ttype SupplyData,\n} from 'n8n-workflow';\nimport { logWrapper } from '../../../utils/logWrapper';\nimport { getConnectionHintNoticeField } from '../../../utils/sharedFields';\nexport class EmbeddingsAwsBedrock implements INodeType {\n\tdescription: INodeTypeDescription = {\n\t\tdisplayName: 'Embeddings AWS Bedrock',\n\t\tname: 'embeddingsAwsBedrock',\n\t\ticon: 'file:bedrock.svg',\n\t\tcredentials: [\n\t\t\t{\n\t\t\t\tname: 'aws',\n\t\t\t\trequired: true,\n\t\t\t},\n\t\t],\n\t\tgroup: ['transform'],\n\t\tversion: 1,\n\t\tdescription: 'Use Embeddings AWS Bedrock',\n\t\tdefaults: {\n\t\t\tname: 'Embeddings AWS Bedrock',\n\t\t},\n\t\tcodex: {\n\t\t\tcategories: ['AI'],\n\t\t\tsubcategories: {\n\t\t\t\tAI: ['Embeddings'],\n\t\t\t},\n\t\t\tresources: {\n\t\t\t\tprimaryDocumentation: [\n\t\t\t\t\t{\n\t\t\t\t\t\turl: 'https://docs.n8n.io/integrations/builtin/cluster-nodes/sub-nodes/n8n-nodes-langchain.embeddingsawsbedrock/',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t},\n\t\t// eslint-disable-next-line n8n-nodes-base/node-class-description-inputs-wrong-regular-node\n\t\tinputs: [],\n\t\t// eslint-disable-next-line n8n-nodes-base/node-class-description-outputs-wrong\n\t\toutputs: [NodeConnectionType.AiEmbedding],\n\t\toutputNames: ['Embeddings'],\n\t\trequestDefaults: {\n\t\t\tignoreHttpStatusErrors: true,\n\t\t\tbaseURL: '=https://bedrock.{{$credentials?.region ?? \"eu-central-1\"}}.amazonaws.com',\n\t\t},\n\t\tproperties: [\n\t\t\tgetConnectionHintNoticeField([NodeConnectionType.AiVectorStore]),\n\t\t\t{\n\t\t\t\tdisplayName: 'Model',\n\t\t\t\tname: 'model',\n\t\t\t\ttype: 'options',\n\t\t\t\tdescription:\n\t\t\t\t\t'The model which will generate the completion. <a href=\"https://docs.aws.amazon.com/bedrock/latest/userguide/foundation-models.html\">Learn more</a>.',\n\t\t\t\ttypeOptions: {\n\t\t\t\t\tloadOptions: {\n\t\t\t\t\t\trouting: {\n\t\t\t\t\t\t\trequest: {\n\t\t\t\t\t\t\t\tmethod: 'GET',\n\t\t\t\t\t\t\t\turl: '/foundation-models?byInferenceType=ON_DEMAND&byOutputModality=EMBEDDING',\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toutput: {\n\t\t\t\t\t\t\t\tpostReceive: [\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\ttype: 'rootProperty',\n\t\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\t\tproperty: 'modelSummaries',\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\ttype: 'setKeyValue',\n\t\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\t\tname: '={{$responseItem.modelName}}',\n\t\t\t\t\t\t\t\t\t\t\tdescription: '={{$responseItem.modelArn}}',\n\t\t\t\t\t\t\t\t\t\t\tvalue: '={{$responseItem.modelId}}',\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\ttype: 'sort',\n\t\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\t\tkey: 'name',\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\trouting: {\n\t\t\t\t\tsend: {\n\t\t\t\t\t\ttype: 'body',\n\t\t\t\t\t\tproperty: 'model',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: '',\n\t\t\t},\n\t\t],\n\t};\n\tasync supplyData(this: ISupplyDataFunctions, itemIndex: number): Promise<SupplyData> {\n\t\tconst credentials = await this.getCredentials('aws');\n\t\tconst modelName = this.getNodeParameter('model', itemIndex) as string;\n\t\tconst embeddings = new BedrockEmbeddings({\n\t\t\tregion: credentials.region as string,\n\t\t\tmodel: modelName,\n\t\t\tmaxRetries: 3,\n\t\t\tcredentials: {\n\t\t\t\tsecretAccessKey: credentials.secretAccessKey as string,\n\t\t\t\taccessKeyId: credentials.accessKeyId as string,\n\t\t\t\tsessionToken: credentials.sessionToken as string,\n\t\t\t},\n\t\t});\n\t\treturn {\n\t\t\tresponse: logWrapper(embeddings, this),\n\t\t};\n\t}\n}", "llm_cg": {"EmbeddingsAwsBedrock.supplyData(this: ISupplyDataFunctions, itemIndex: number)": ["EmbeddingsAwsBedrock.%AM1$getCredentials(unknown)", "EmbeddingsAwsBedrock.%AM2$getNodeParameter(unknown, unknown)", "BedrockEmbeddings.constructor(unknown)", "EmbeddingsAwsBedrock.%AM3$logWrapper(unknown, unknown)"]}, "static_cg": {}}
{"source_code": "import {\n  DeepPartial,\n  DeleteResult,\n  EntityManager,\n  EntitySchema,\n  EntityTarget,\n  FindManyOptions,\n  FindOneOptions,\n  FindOptionsWhere,\n  InsertResult,\n  ObjectId,\n  ObjectLiteral,\n  QueryRunner,\n  RemoveOptions,\n  Repository,\n  SaveOptions,\n  UpdateResult,\n} from 'typeorm';\nimport { PickKeysByType } from 'typeorm/common/PickKeysByType';\nimport { QueryDeepPartialEntity } from 'typeorm/query-builder/QueryPartialEntity';\nimport { UpsertOptions } from 'typeorm/repository/UpsertOptions';\nimport { WorkspaceInternalContext } from 'src/engine/twenty-orm/interfaces/workspace-internal-context.interface';\nimport { ObjectMetadataItemWithFieldMaps } from 'src/engine/metadata-modules/types/object-metadata-item-with-field-maps';\nimport { getObjectMetadataMapItemByNameSingular } from 'src/engine/metadata-modules/utils/get-object-metadata-map-item-by-name-singular.util';\nimport { WorkspaceEntitiesStorage } from 'src/engine/twenty-orm/storage/workspace-entities.storage';\nimport { formatData } from 'src/engine/twenty-orm/utils/format-data.util';\nimport { formatResult } from 'src/engine/twenty-orm/utils/format-result.util';\nexport class WorkspaceRepository<\n  Entity extends ObjectLiteral,\n> extends Repository<Entity> {\n  private readonly internalContext: WorkspaceInternalContext;\n  constructor(\n    internalContext: WorkspaceInternalContext,\n    target: EntityTarget<Entity>,\n    manager: EntityManager,\n    queryRunner?: QueryRunner,\n  ) {\n    super(target, manager, queryRunner);\n    this.internalContext = internalContext;\n  }\n  override async find(\n    options?: FindManyOptions<Entity>,\n    entityManager?: EntityManager,\n  ): Promise<Entity[]> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions(options);\n    const result = await manager.find(this.target, computedOptions);\n    const formattedResult = await this.formatResult(result);\n    return formattedResult;\n  }\n  override async findBy(\n    where: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    entityManager?: EntityManager,\n  ): Promise<Entity[]> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions({ where });\n    const result = await manager.findBy(this.target, computedOptions.where);\n    const formattedResult = await this.formatResult(result);\n    return formattedResult;\n  }\n  override async findAndCount(\n    options?: FindManyOptions<Entity>,\n    entityManager?: EntityManager,\n  ): Promise<[Entity[], number]> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions(options);\n    const result = await manager.findAndCount(this.target, computedOptions);\n    const formattedResult = await this.formatResult(result);\n    return formattedResult;\n  }\n  override async findAndCountBy(\n    where: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    entityManager?: EntityManager,\n  ): Promise<[Entity[], number]> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions({ where });\n    const result = await manager.findAndCountBy(\n      this.target,\n      computedOptions.where,\n    );\n    const formattedResult = await this.formatResult(result);\n    return formattedResult;\n  }\n  override async findOne(\n    options: FindOneOptions<Entity>,\n    entityManager?: EntityManager,\n  ): Promise<Entity | null> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions(options);\n    const result = await manager.findOne(this.target, computedOptions);\n    const formattedResult = await this.formatResult(result);\n    return formattedResult;\n  }\n  override async findOneBy(\n    where: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    entityManager?: EntityManager,\n  ): Promise<Entity | null> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions({ where });\n    const result = await manager.findOneBy(this.target, computedOptions.where);\n    const formattedResult = await this.formatResult(result);\n    return formattedResult;\n  }\n  override async findOneOrFail(\n    options: FindOneOptions<Entity>,\n    entityManager?: EntityManager,\n  ): Promise<Entity> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions(options);\n    const result = await manager.findOneOrFail(this.target, computedOptions);\n    const formattedResult = await this.formatResult(result);\n    return formattedResult;\n  }\n  override async findOneByOrFail(\n    where: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    entityManager?: EntityManager,\n  ): Promise<Entity> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions({ where });\n    const result = await manager.findOneByOrFail(\n      this.target,\n      computedOptions.where,\n    );\n    const formattedResult = await this.formatResult(result);\n    return formattedResult;\n  }\n  override save<T extends DeepPartial<Entity>>(\n    entities: T[],\n    options: SaveOptions & { reload: false },\n    entityManager?: EntityManager,\n  ): Promise<T[]>;\n  override save<T extends DeepPartial<Entity>>(\n    entities: T[],\n    options?: SaveOptions,\n    entityManager?: EntityManager,\n  ): Promise<(T & Entity)[]>;\n  override save<T extends DeepPartial<Entity>>(\n    entity: T,\n    options: SaveOptions & { reload: false },\n    entityManager?: EntityManager,\n  ): Promise<T>;\n  override save<T extends DeepPartial<Entity>>(\n    entity: T,\n    options?: SaveOptions,\n    entityManager?: EntityManager,\n  ): Promise<T & Entity>;\n  override async save<T extends DeepPartial<Entity>>(\n    entityOrEntities: T | T[],\n    options?: SaveOptions,\n    entityManager?: EntityManager,\n  ): Promise<T | T[]> {\n    const manager = entityManager || this.manager;\n    const formattedEntityOrEntities = await this.formatData(entityOrEntities);\n    let result: T | T[];\n    // Needed becasuse save method has multiple signature, otherwise we will need to do a type assertion\n    if (Array.isArray(formattedEntityOrEntities)) {\n      result = await manager.save(\n        this.target,\n        formattedEntityOrEntities,\n        options,\n      );\n    } else {\n      result = await manager.save(\n        this.target,\n        formattedEntityOrEntities,\n        options,\n      );\n    }\n    const formattedResult = await this.formatResult(result);\n    return formattedResult;\n  }\n  override remove(\n    entities: Entity[],\n    options?: RemoveOptions,\n    entityManager?: EntityManager,\n  ): Promise<Entity[]>;\n  override remove(\n    entity: Entity,\n    options?: RemoveOptions,\n    entityManager?: EntityManager,\n  ): Promise<Entity>;\n  override async remove(\n    entityOrEntities: Entity | Entity[],\n    options?: RemoveOptions,\n    entityManager?: EntityManager,\n  ): Promise<Entity | Entity[]> {\n    const manager = entityManager || this.manager;\n    const formattedEntityOrEntities = await this.formatData(entityOrEntities);\n    const result = await manager.remove(\n      this.target,\n      formattedEntityOrEntities,\n      options,\n    );\n    const formattedResult = await this.formatResult(result);\n    return formattedResult;\n  }\n  override async delete(\n    criteria:\n      | string\n      | string[]\n      | number\n      | number[]\n      | Date\n      | Date[]\n      | ObjectId\n      | ObjectId[]\n      | FindOptionsWhere<Entity>,\n    entityManager?: EntityManager,\n  ): Promise<DeleteResult> {\n    const manager = entityManager || this.manager;\n    if (typeof criteria === 'object' && 'where' in criteria) {\n      criteria = await this.transformOptions(criteria);\n    }\n    return manager.delete(this.target, criteria);\n  }\n  override softRemove<T extends DeepPartial<Entity>>(\n    entities: T[],\n    options: SaveOptions & { reload: false },\n    entityManager?: EntityManager,\n  ): Promise<T[]>;\n  override softRemove<T extends DeepPartial<Entity>>(\n    entities: T[],\n    options?: SaveOptions,\n    entityManager?: EntityManager,\n  ): Promise<(T & Entity)[]>;\n  override softRemove<T extends DeepPartial<Entity>>(\n    entity: T,\n    options: SaveOptions & { reload: false },\n    entityManager?: EntityManager,\n  ): Promise<T>;\n  override softRemove<T extends DeepPartial<Entity>>(\n    entity: T,\n    options?: SaveOptions,\n    entityManager?: EntityManager,\n  ): Promise<T & Entity>;\n  override async softRemove<T extends DeepPartial<Entity>>(\n    entityOrEntities: T | T[],\n    options?: SaveOptions,\n    entityManager?: EntityManager,\n  ): Promise<T | T[]> {\n    const manager = entityManager || this.manager;\n    const formattedEntityOrEntities = await this.formatData(entityOrEntities);\n    let result: T | T[];\n    // Needed becasuse save method has multiple signature, otherwise we will need to do a type assertion\n    if (Array.isArray(formattedEntityOrEntities)) {\n      result = await manager.softRemove(\n        this.target,\n        formattedEntityOrEntities,\n        options,\n      );\n    } else {\n      result = await manager.softRemove(\n        this.target,\n        formattedEntityOrEntities,\n        options,\n      );\n    }\n    const formattedResult = await this.formatResult(result);\n    return formattedResult;\n  }\n  override async softDelete(\n    criteria:\n      | string\n      | string[]\n      | number\n      | number[]\n      | Date\n      | Date[]\n      | ObjectId\n      | ObjectId[]\n      | FindOptionsWhere<Entity>,\n    entityManager?: EntityManager,\n  ): Promise<UpdateResult> {\n    const manager = entityManager || this.manager;\n    if (typeof criteria === 'object' && 'where' in criteria) {\n      criteria = await this.transformOptions(criteria);\n    }\n    return manager.softDelete(this.target, criteria);\n  }\n  override recover<T extends DeepPartial<Entity>>(\n    entities: T[],\n    options: SaveOptions & { reload: false },\n    entityManager?: EntityManager,\n  ): Promise<T[]>;\n  override recover<T extends DeepPartial<Entity>>(\n    entities: T[],\n    options?: SaveOptions,\n    entityManager?: EntityManager,\n  ): Promise<(T & Entity)[]>;\n  override recover<T extends DeepPartial<Entity>>(\n    entity: T,\n    options: SaveOptions & { reload: false },\n    entityManager?: EntityManager,\n  ): Promise<T>;\n  override recover<T extends DeepPartial<Entity>>(\n    entity: T,\n    options?: SaveOptions,\n    entityManager?: EntityManager,\n  ): Promise<T & Entity>;\n  override async recover<T extends DeepPartial<Entity>>(\n    entityOrEntities: T | T[],\n    options?: SaveOptions,\n    entityManager?: EntityManager,\n  ): Promise<T | T[]> {\n    const manager = entityManager || this.manager;\n    const formattedEntityOrEntities = await this.formatData(entityOrEntities);\n    let result: T | T[];\n    // Needed becasuse save method has multiple signature, otherwise we will need to do a type assertion\n    if (Array.isArray(formattedEntityOrEntities)) {\n      result = await manager.recover(\n        this.target,\n        formattedEntityOrEntities,\n        options,\n      );\n    } else {\n      result = await manager.recover(\n        this.target,\n        formattedEntityOrEntities,\n        options,\n      );\n    }\n    const formattedResult = await this.formatResult(result);\n    return formattedResult;\n  }\n  override async restore(\n    criteria:\n      | string\n      | string[]\n      | number\n      | number[]\n      | Date\n      | Date[]\n      | ObjectId\n      | ObjectId[]\n      | FindOptionsWhere<Entity>,\n    entityManager?: EntityManager,\n  ): Promise<UpdateResult> {\n    const manager = entityManager || this.manager;\n    if (typeof criteria === 'object' && 'where' in criteria) {\n      criteria = await this.transformOptions(criteria);\n    }\n    return manager.restore(this.target, criteria);\n  }\n  override async insert(\n    entity: QueryDeepPartialEntity<Entity> | QueryDeepPartialEntity<Entity>[],\n    entityManager?: EntityManager,\n  ): Promise<InsertResult> {\n    const manager = entityManager || this.manager;\n    const formatedEntity = await this.formatData(entity);\n    const result = await manager.insert(this.target, formatedEntity);\n    const formattedResult = await this.formatResult(result.generatedMaps);\n    return {\n      raw: result.raw,\n      generatedMaps: formattedResult,\n      identifiers: result.identifiers,\n    };\n  }\n  override async update(\n    criteria:\n      | string\n      | string[]\n      | number\n      | number[]\n      | Date\n      | Date[]\n      | ObjectId\n      | ObjectId[]\n      | FindOptionsWhere<Entity>,\n    partialEntity: QueryDeepPartialEntity<Entity>,\n    entityManager?: EntityManager,\n  ): Promise<UpdateResult> {\n    const manager = entityManager || this.manager;\n    if (typeof criteria === 'object' && 'where' in criteria) {\n      criteria = await this.transformOptions(criteria);\n    }\n    return manager.update(this.target, criteria, partialEntity);\n  }\n  override async upsert(\n    entityOrEntities:\n      | QueryDeepPartialEntity<Entity>\n      | QueryDeepPartialEntity<Entity>[],\n    conflictPathsOrOptions: string[] | UpsertOptions<Entity>,\n    entityManager?: EntityManager,\n  ): Promise<InsertResult> {\n    const manager = entityManager || this.manager;\n    const formattedEntityOrEntities = await this.formatData(entityOrEntities);\n    const result = await manager.upsert(\n      this.target,\n      formattedEntityOrEntities,\n      conflictPathsOrOptions,\n    );\n    const formattedResult = await this.formatResult(result.generatedMaps);\n    return {\n      raw: result.raw,\n      generatedMaps: formattedResult,\n      identifiers: result.identifiers,\n    };\n  }\n  override async exists(\n    options?: FindManyOptions<Entity>,\n    entityManager?: EntityManager,\n  ): Promise<boolean> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions(options);\n    return manager.exists(this.target, computedOptions);\n  }\n  override async existsBy(\n    where: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    entityManager?: EntityManager,\n  ): Promise<boolean> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions({ where });\n    return manager.existsBy(this.target, computedOptions.where);\n  }\n  override async count(\n    options?: FindManyOptions<Entity>,\n    entityManager?: EntityManager,\n  ): Promise<number> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions(options);\n    return manager.count(this.target, computedOptions);\n  }\n  override async countBy(\n    where: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    entityManager?: EntityManager,\n  ): Promise<number> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions({ where });\n    return manager.countBy(this.target, computedOptions.where);\n  }\n  override async sum(\n    columnName: PickKeysByType<Entity, number>,\n    where?: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    entityManager?: EntityManager,\n  ): Promise<number | null> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions({ where });\n    return manager.sum(this.target, columnName, computedOptions.where);\n  }\n  override async average(\n    columnName: PickKeysByType<Entity, number>,\n    where?: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    entityManager?: EntityManager,\n  ): Promise<number | null> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions({ where });\n    return manager.average(this.target, columnName, computedOptions.where);\n  }\n  override async minimum(\n    columnName: PickKeysByType<Entity, number>,\n    where?: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    entityManager?: EntityManager,\n  ): Promise<number | null> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions({ where });\n    return manager.minimum(this.target, columnName, computedOptions.where);\n  }\n  override async maximum(\n    columnName: PickKeysByType<Entity, number>,\n    where?: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    entityManager?: EntityManager,\n  ): Promise<number | null> {\n    const manager = entityManager || this.manager;\n    const computedOptions = await this.transformOptions({ where });\n    return manager.maximum(this.target, columnName, computedOptions.where);\n  }\n  override async increment(\n    conditions: FindOptionsWhere<Entity>,\n    propertyPath: string,\n    value: number | string,\n    entityManager?: EntityManager,\n  ): Promise<UpdateResult> {\n    const manager = entityManager || this.manager;\n    const computedConditions = await this.transformOptions({\n      where: conditions,\n    });\n    return manager.increment(\n      this.target,\n      computedConditions.where,\n      propertyPath,\n      value,\n    );\n  }\n  override async decrement(\n    conditions: FindOptionsWhere<Entity>,\n    propertyPath: string,\n    value: number | string,\n    entityManager?: EntityManager,\n  ): Promise<UpdateResult> {\n    const manager = entityManager || this.manager;\n    const computedConditions = await this.transformOptions({\n      where: conditions,\n    });\n    return manager.decrement(\n      this.target,\n      computedConditions.where,\n      propertyPath,\n      value,\n    );\n  }\n  private async getObjectMetadataFromTarget() {\n    const objectMetadataName =\n      typeof this.target === 'string'\n        ? this.target\n        : WorkspaceEntitiesStorage.getObjectMetadataName(\n            this.internalContext.workspaceId,\n            this.target as EntitySchema,\n          );\n    if (!objectMetadataName) {\n      throw new Error('Object metadata name is missing');\n    }\n    const objectMetadata = getObjectMetadataMapItemByNameSingular(\n      this.internalContext.objectMetadataMaps,\n      objectMetadataName,\n    );\n    if (!objectMetadata) {\n      throw new Error(\n        `Object metadata for object \"${objectMetadataName}\" is missing ` +\n          `in workspace \"${this.internalContext.workspaceId}\" ` +\n          `with object metadata collection length: ${\n            Object.keys(\n              this.internalContext.objectMetadataMaps.idByNameSingular,\n            ).length\n          }`,\n      );\n    }\n    return objectMetadata;\n  }\n  private async transformOptions<\n    T extends FindManyOptions<Entity> | FindOneOptions<Entity> | undefined,\n  >(options: T): Promise<T> {\n    if (!options) {\n      return options;\n    }\n    const transformedOptions = { ...options };\n    transformedOptions.where = await this.formatData(options.where);\n    return transformedOptions;\n  }\n  private async formatData<T>(data: T): Promise<T> {\n    const objectMetadata = await this.getObjectMetadataFromTarget();\n    return formatData(data, objectMetadata) as T;\n  }\n  async formatResult<T>(\n    data: T,\n    objectMetadata?: ObjectMetadataItemWithFieldMaps,\n  ): Promise<T> {\n    objectMetadata ??= await this.getObjectMetadataFromTarget();\n    const objectMetadataMaps = this.internalContext.objectMetadataMaps;\n    return formatResult(data, objectMetadata, objectMetadataMaps) as T;\n  }\n}", "llm_cg": {"WorkspaceRepository.find(FindManyOptions<unknown>, EntityManager)": ["WorkspaceRepository.%AMX$transformOptions(unknown)", "WorkspaceRepository.%AMX$formatResult(unknown)"], "WorkspaceRepository.findBy(FindOptionsWhere<unknown>, EntityManager)": ["WorkspaceRepository.%AMX$transformOptions(unknown)", "WorkspaceRepository.%AMX$formatResult(unknown)"], "WorkspaceRepository.findAndCount(FindManyOptions<unknown>, EntityManager)": ["WorkspaceRepository.%AMX$transformOptions(unknown)", "WorkspaceRepository.%AMX$formatResult(unknown)"], "WorkspaceRepository.findAndCountBy(FindOptionsWhere<unknown>, EntityManager)": ["WorkspaceRepository.%AMX$transformOptions(unknown)", "WorkspaceRepository.%AMX$formatResult(unknown)"], "WorkspaceRepository.findOne(FindOneOptions<unknown>, EntityManager)": ["WorkspaceRepository.%AMX$transformOptions(unknown)", "WorkspaceRepository.%AMX$formatResult(unknown)"], "WorkspaceRepository.findOneBy(FindOptionsWhere<unknown>, EntityManager)": ["WorkspaceRepository.%AMX$transformOptions(unknown)", "WorkspaceRepository.%AMX$formatResult(unknown)"], "WorkspaceRepository.findOneOrFail(FindOneOptions<unknown>, EntityManager)": ["WorkspaceRepository.%AMX$transformOptions(unknown)", "WorkspaceRepository.%AMX$formatResult(unknown)"], "WorkspaceRepository.findOneByOrFail(FindOptionsWhere<unknown>, EntityManager)": ["WorkspaceRepository.%AMX$transformOptions(unknown)", "WorkspaceRepository.%AMX$formatResult(unknown)"], "WorkspaceRepository.save(DeepPartial<unknown>, SaveOptions, EntityManager)": ["WorkspaceRepository.%AMX$formatData(unknown)", "WorkspaceRepository.%AMX$formatResult(unknown)"], "WorkspaceRepository.remove(Entity[], RemoveOptions, EntityManager)": ["WorkspaceRepository.%AMX$formatData(unknown)", "WorkspaceRepository.%AMX$formatResult(unknown)"], "WorkspaceRepository.delete(string | string[] | number | number[] | Date | Date[] | ObjectId | ObjectId[] | FindOptionsWhere<unknown>, EntityManager)": ["WorkspaceRepository.%AMX$transformOptions(unknown)"], "WorkspaceRepository.softRemove(DeepPartial<unknown>, SaveOptions, EntityManager)": ["WorkspaceRepository.%AMX$formatData(unknown)", "WorkspaceRepository.%AMX$formatResult(unknown)"], "WorkspaceRepository.softDelete(string | string[] | number | number[] | Date | Date[] | ObjectId | ObjectId[] | FindOptionsWhere<unknown>, EntityManager)": ["WorkspaceRepository.%AMX$transformOptions(unknown)"], "WorkspaceRepository.recover(DeepPartial<unknown>, SaveOptions, EntityManager)": ["WorkspaceRepository.%AMX$formatData(unknown)", "WorkspaceRepository.%AMX$formatResult(unknown)"], "WorkspaceRepository.restore(string | string[] | number | number[] | Date | Date[] | ObjectId | ObjectId[] | FindOptionsWhere<unknown>, EntityManager)": ["WorkspaceRepository.%AMX$transformOptions(unknown)"], "WorkspaceRepository.insert(QueryDeepPartialEntity<unknown> | QueryDeepPartialEntity<unknown>[], EntityManager)": ["WorkspaceRepository.%AMX$formatData(unknown)", "WorkspaceRepository.%AMX$formatResult(unknown)"], "WorkspaceRepository.upsert(QueryDeepPartialEntity<unknown> | QueryDeepPartialEntity<unknown>[], string[] | UpsertOptions<unknown>, EntityManager)": ["WorkspaceRepository.%AMX$formatData(unknown)", "WorkspaceRepository.%AMX$formatResult(unknown)"], "WorkspaceRepository.exists(FindManyOptions<unknown>, EntityManager)": ["WorkspaceRepository.%AMX$transformOptions(unknown)"], "WorkspaceRepository.existsBy(FindOptionsWhere<unknown> | FindOptionsWhere<unknown>[], EntityManager)": ["WorkspaceRepository.%AMX$transformOptions(unknown)"], "WorkspaceRepository.count(FindManyOptions<unknown>, EntityManager)": ["WorkspaceRepository.%AMX$transformOptions(unknown)"], "WorkspaceRepository.countBy(FindOptionsWhere<unknown> | FindOptionsWhere<unknown>[], EntityManager)": ["WorkspaceRepository.%AMX$transformOptions(unknown)"], "WorkspaceRepository.sum(PickKeysByType<unknown, number>, FindOptionsWhere<unknown> | FindOptionsWhere<unknown>[], EntityManager)": ["WorkspaceRepository.%AMX$transformOptions(unknown)"], "WorkspaceRepository.average(PickKeysByType<unknown, number>, FindOptionsWhere<unknown> | FindOptionsWhere<unknown>[], EntityManager)": ["WorkspaceRepository.%AMX$transformOptions(unknown)"], "WorkspaceRepository.minimum(PickKeysByType<unknown, number>, FindOptionsWhere<unknown> | FindOptionsWhere<unknown>[], EntityManager)": ["WorkspaceRepository.%AMX$transformOptions(unknown)"], "WorkspaceRepository.maximum(PickKeysByType<unknown, number>, FindOptionsWhere<unknown> | FindOptionsWhere<unknown>[], EntityManager)": ["WorkspaceRepository.%AMX$transformOptions(unknown)"], "WorkspaceRepository.increment(FindOptionsWhere<unknown>, string, number | string, EntityManager)": ["WorkspaceRepository.%AMX$transformOptions(unknown)"], "WorkspaceRepository.decrement(FindOptionsWhere<unknown>, string, number | string, EntityManager)": ["WorkspaceRepository.%AMX$transformOptions(unknown)"], "WorkspaceRepository.%AMX$getObjectMetadataFromTarget()": ["WorkspaceEntitiesStorage.getObjectMetadataName(unknown, unknown)", "WorkspaceRepository.%AMX$%AMX$getObjectMetadataMapItemByNameSingular(unknown, unknown)"], "WorkspaceRepository.%AMX$transformOptions(T)": ["WorkspaceRepository.%AMX$formatData(unknown)"], "WorkspaceRepository.%AMX$formatData(T)": ["WorkspaceRepository.%AMX$getObjectMetadataFromTarget()", "formatData(unknown, unknown)"], "WorkspaceRepository.%AMX$formatResult(T)": ["WorkspaceRepository.%AMX$getObjectMetadataFromTarget()", "formatResult(unknown, unknown, unknown)"]}, "static_cg": {"@test/192.ts: WorkspaceRepository.find(FindManyOptions<Entity extends ObjectLiteral>, EntityManager)": ["@test/192.ts: WorkspaceRepository.transformOptions(T extends FindManyOptions<Entity>|FindOneOptions<Entity>|undefined)", "@test/192.ts: WorkspaceRepository.formatResult(T, ObjectMetadataItemWithFieldMaps)"], "@test/192.ts: WorkspaceRepository.findBy(FindOptionsWhere<Entity extends ObjectLiteral>|FindOptionsWhere<Entity>[], EntityManager)": ["@test/192.ts: WorkspaceRepository.transformOptions(T extends FindManyOptions<Entity>|FindOneOptions<Entity>|undefined)", "@test/192.ts: WorkspaceRepository.formatResult(T, ObjectMetadataItemWithFieldMaps)"], "@test/192.ts: WorkspaceRepository.findAndCount(FindManyOptions<Entity extends ObjectLiteral>, EntityManager)": ["@test/192.ts: WorkspaceRepository.transformOptions(T extends FindManyOptions<Entity>|FindOneOptions<Entity>|undefined)", "@test/192.ts: WorkspaceRepository.formatResult(T, ObjectMetadataItemWithFieldMaps)"], "@test/192.ts: WorkspaceRepository.findAndCountBy(FindOptionsWhere<Entity extends ObjectLiteral>|FindOptionsWhere<Entity>[], EntityManager)": ["@test/192.ts: WorkspaceRepository.transformOptions(T extends FindManyOptions<Entity>|FindOneOptions<Entity>|undefined)", "@test/192.ts: WorkspaceRepository.formatResult(T, ObjectMetadataItemWithFieldMaps)"], "@test/192.ts: WorkspaceRepository.findOne(FindOneOptions<Entity extends ObjectLiteral>, EntityManager)": ["@test/192.ts: WorkspaceRepository.transformOptions(T extends FindManyOptions<Entity>|FindOneOptions<Entity>|undefined)", "@test/192.ts: WorkspaceRepository.formatResult(T, ObjectMetadataItemWithFieldMaps)"], "@test/192.ts: WorkspaceRepository.findOneBy(FindOptionsWhere<Entity extends ObjectLiteral>|FindOptionsWhere<Entity>[], EntityManager)": ["@test/192.ts: WorkspaceRepository.transformOptions(T extends FindManyOptions<Entity>|FindOneOptions<Entity>|undefined)", "@test/192.ts: WorkspaceRepository.formatResult(T, ObjectMetadataItemWithFieldMaps)"], "@test/192.ts: WorkspaceRepository.findOneOrFail(FindOneOptions<Entity extends ObjectLiteral>, EntityManager)": ["@test/192.ts: WorkspaceRepository.transformOptions(T extends FindManyOptions<Entity>|FindOneOptions<Entity>|undefined)", "@test/192.ts: WorkspaceRepository.formatResult(T, ObjectMetadataItemWithFieldMaps)"], "@test/192.ts: WorkspaceRepository.findOneByOrFail(FindOptionsWhere<Entity extends ObjectLiteral>|FindOptionsWhere<Entity>[], EntityManager)": ["@test/192.ts: WorkspaceRepository.transformOptions(T extends FindManyOptions<Entity>|FindOneOptions<Entity>|undefined)", "@test/192.ts: WorkspaceRepository.formatResult(T, ObjectMetadataItemWithFieldMaps)"], "@test/192.ts: WorkspaceRepository.save(T extends DeepPartial<Entity>|T[], SaveOptions, EntityManager)": ["@test/192.ts: WorkspaceRepository.formatData(T)", "@test/192.ts: WorkspaceRepository.formatResult(T, ObjectMetadataItemWithFieldMaps)"], "@test/192.ts: WorkspaceRepository.remove(Entity extends ObjectLiteral|Entity[], RemoveOptions, EntityManager)": ["@test/192.ts: WorkspaceRepository.formatData(T)", "@test/192.ts: WorkspaceRepository.formatResult(T, ObjectMetadataItemWithFieldMaps)"], "@test/192.ts: WorkspaceRepository.delete(string|string[]|number|number[]|Date|Date[]|ObjectId|ObjectId[]|FindOptionsWhere<Entity extends ObjectLiteral>, EntityManager)": ["@test/192.ts: WorkspaceRepository.transformOptions(T extends FindManyOptions<Entity>|FindOneOptions<Entity>|undefined)"], "@test/192.ts: WorkspaceRepository.softRemove(T extends DeepPartial<Entity>|T[], SaveOptions, EntityManager)": ["@test/192.ts: WorkspaceRepository.formatData(T)", "@test/192.ts: WorkspaceRepository.formatResult(T, ObjectMetadataItemWithFieldMaps)"], "@test/192.ts: WorkspaceRepository.softDelete(string|string[]|number|number[]|Date|Date[]|ObjectId|ObjectId[]|FindOptionsWhere<Entity extends ObjectLiteral>, EntityManager)": ["@test/192.ts: WorkspaceRepository.transformOptions(T extends FindManyOptions<Entity>|FindOneOptions<Entity>|undefined)"], "@test/192.ts: WorkspaceRepository.recover(T extends DeepPartial<Entity>|T[], SaveOptions, EntityManager)": ["@test/192.ts: WorkspaceRepository.formatData(T)", "@test/192.ts: WorkspaceRepository.formatResult(T, ObjectMetadataItemWithFieldMaps)"], "@test/192.ts: WorkspaceRepository.restore(string|string[]|number|number[]|Date|Date[]|ObjectId|ObjectId[]|FindOptionsWhere<Entity extends ObjectLiteral>, EntityManager)": ["@test/192.ts: WorkspaceRepository.transformOptions(T extends FindManyOptions<Entity>|FindOneOptions<Entity>|undefined)"], "@test/192.ts: WorkspaceRepository.insert(QueryDeepPartialEntity<Entity extends ObjectLiteral>|QueryDeepPartialEntity<Entity>[], EntityManager)": ["@test/192.ts: WorkspaceRepository.formatData(T)", "@test/192.ts: WorkspaceRepository.formatResult(T, ObjectMetadataItemWithFieldMaps)"], "@test/192.ts: WorkspaceRepository.update(string|string[]|number|number[]|Date|Date[]|ObjectId|ObjectId[]|FindOptionsWhere<Entity extends ObjectLiteral>, QueryDeepPartialEntity<Entity extends ObjectLiteral>, EntityManager)": ["@test/192.ts: WorkspaceRepository.transformOptions(T extends FindManyOptions<Entity>|FindOneOptions<Entity>|undefined)"], "@test/192.ts: WorkspaceRepository.upsert(QueryDeepPartialEntity<Entity extends ObjectLiteral>|QueryDeepPartialEntity<Entity>[], string[]|UpsertOptions<Entity extends ObjectLiteral>, EntityManager)": ["@test/192.ts: WorkspaceRepository.formatData(T)", "@test/192.ts: WorkspaceRepository.formatResult(T, ObjectMetadataItemWithFieldMaps)"], "@test/192.ts: WorkspaceRepository.exists(FindManyOptions<Entity extends ObjectLiteral>, EntityManager)": ["@test/192.ts: WorkspaceRepository.transformOptions(T extends FindManyOptions<Entity>|FindOneOptions<Entity>|undefined)"], "@test/192.ts: WorkspaceRepository.existsBy(FindOptionsWhere<Entity extends ObjectLiteral>|FindOptionsWhere<Entity>[], EntityManager)": ["@test/192.ts: WorkspaceRepository.transformOptions(T extends FindManyOptions<Entity>|FindOneOptions<Entity>|undefined)"], "@test/192.ts: WorkspaceRepository.count(FindManyOptions<Entity extends ObjectLiteral>, EntityManager)": ["@test/192.ts: WorkspaceRepository.transformOptions(T extends FindManyOptions<Entity>|FindOneOptions<Entity>|undefined)"], "@test/192.ts: WorkspaceRepository.countBy(FindOptionsWhere<Entity extends ObjectLiteral>|FindOptionsWhere<Entity>[], EntityManager)": ["@test/192.ts: WorkspaceRepository.transformOptions(T extends FindManyOptions<Entity>|FindOneOptions<Entity>|undefined)"], "@test/192.ts: WorkspaceRepository.sum(PickKeysByType<Entity extends ObjectLiteral,number>, FindOptionsWhere<Entity extends ObjectLiteral>|FindOptionsWhere<Entity>[], EntityManager)": ["@test/192.ts: WorkspaceRepository.transformOptions(T extends FindManyOptions<Entity>|FindOneOptions<Entity>|undefined)"], "@test/192.ts: WorkspaceRepository.average(PickKeysByType<Entity extends ObjectLiteral,number>, FindOptionsWhere<Entity extends ObjectLiteral>|FindOptionsWhere<Entity>[], EntityManager)": ["@test/192.ts: WorkspaceRepository.transformOptions(T extends FindManyOptions<Entity>|FindOneOptions<Entity>|undefined)"], "@test/192.ts: WorkspaceRepository.minimum(PickKeysByType<Entity extends ObjectLiteral,number>, FindOptionsWhere<Entity extends ObjectLiteral>|FindOptionsWhere<Entity>[], EntityManager)": ["@test/192.ts: WorkspaceRepository.transformOptions(T extends FindManyOptions<Entity>|FindOneOptions<Entity>|undefined)"], "@test/192.ts: WorkspaceRepository.maximum(PickKeysByType<Entity extends ObjectLiteral,number>, FindOptionsWhere<Entity extends ObjectLiteral>|FindOptionsWhere<Entity>[], EntityManager)": ["@test/192.ts: WorkspaceRepository.transformOptions(T extends FindManyOptions<Entity>|FindOneOptions<Entity>|undefined)"], "@test/192.ts: WorkspaceRepository.increment(FindOptionsWhere<Entity extends ObjectLiteral>, string, number|string, EntityManager)": ["@test/192.ts: WorkspaceRepository.transformOptions(T extends FindManyOptions<Entity>|FindOneOptions<Entity>|undefined)"], "@test/192.ts: WorkspaceRepository.decrement(FindOptionsWhere<Entity extends ObjectLiteral>, string, number|string, EntityManager)": ["@test/192.ts: WorkspaceRepository.transformOptions(T extends FindManyOptions<Entity>|FindOneOptions<Entity>|undefined)"], "@test/192.ts: WorkspaceRepository.transformOptions(T extends FindManyOptions<Entity>|FindOneOptions<Entity>|undefined)": ["@test/192.ts: WorkspaceRepository.formatData(T)"], "@test/192.ts: WorkspaceRepository.formatData(T)": ["@test/192.ts: WorkspaceRepository.getObjectMetadataFromTarget()"], "@test/192.ts: WorkspaceRepository.formatResult(T, ObjectMetadataItemWithFieldMaps)": ["@test/192.ts: WorkspaceRepository.getObjectMetadataFromTarget()"]}}
{"source_code": "import type {JSHandle} from './JSHandle';\nexport interface ConsoleMessageLocation {\n\turl?: string;\n\tlineNumber?: number;\n\tcolumnNumber?: number;\n}\nexport type ConsoleMessageType =\n\t| 'log'\n\t| 'debug'\n\t| 'info'\n\t| 'error'\n\t| 'warning'\n\t| 'dir'\n\t| 'dirxml'\n\t| 'table'\n\t| 'trace'\n\t| 'clear'\n\t| 'startGroup'\n\t| 'startGroupCollapsed'\n\t| 'endGroup'\n\t| 'assert'\n\t| 'profile'\n\t| 'profileEnd'\n\t| 'count'\n\t| 'timeEnd'\n\t| 'verbose';\nexport class ConsoleMessage {\n\ttype: ConsoleMessageType;\n\ttext: string;\n\targs: JSHandle[];\n\tpreviewString: string;\n\t#stackTraceLocations: ConsoleMessageLocation[];\n\tconstructor({\n\t\ttype,\n\t\ttext,\n\t\targs,\n\t\tstackTraceLocations,\n\t\tpreviewString,\n\t}: {\n\t\ttype: ConsoleMessageType;\n\t\ttext: string;\n\t\targs: JSHandle[];\n\t\tstackTraceLocations: ConsoleMessageLocation[];\n\t\tpreviewString: string;\n\t}) {\n\t\tthis.type = type;\n\t\tthis.text = text;\n\t\tthis.args = args;\n\t\tthis.previewString = previewString;\n\t\tthis.#stackTraceLocations = stackTraceLocations;\n\t}\n\tlocation(): ConsoleMessageLocation {\n\t\treturn this.#stackTraceLocations[0] ?? {};\n\t}\n\tstackTrace(): ConsoleMessageLocation[] {\n\t\treturn this.#stackTraceLocations;\n\t}\n}", "llm_cg": {"ConsoleMessage.constructor({ type, text, args, stackTraceLocations, previewString })": [], "ConsoleMessage.location()": [], "ConsoleMessage.stackTrace()": []}, "static_cg": {}}
{"source_code": "import { RoomType } from '@rocket.chat/apps-engine/definition/rooms';\nimport { expect } from 'chai';\nimport proxyquire from 'proxyquire';\nimport sinon from 'sinon';\nimport { EVENT_ORIGIN } from '../../../../../../../server/services/federation/domain/IFederationBridge';\nconst { FederationRoomServiceReceiver } = proxyquire\n\t.noCallThru()\n\t.load('../../../../../../../server/services/federation/application/room/receiver/RoomServiceReceiver', {\n\t\tmongodb: {\n\t\t\t'ObjectId': class ObjectId {\n\t\t\t\ttoHexString(): string {\n\t\t\t\t\treturn 'hexString';\n\t\t\t\t}\n\t\t\t},\n\t\t\t'@global': true,\n\t\t},\n\t});\nconst { FederatedUser } = proxyquire.noCallThru().load('../../../../../../../server/services/federation/domain/FederatedUser', {\n\tmongodb: {\n\t\t'ObjectId': class ObjectId {\n\t\t\ttoHexString(): string {\n\t\t\t\treturn 'hexString';\n\t\t\t}\n\t\t},\n\t\t'@global': true,\n\t},\n});\nconst { DirectMessageFederatedRoom, FederatedRoom } = proxyquire\n\t.noCallThru()\n\t.load('../../../../../../../server/services/federation/domain/FederatedRoom', {\n\t\tmongodb: {\n\t\t\t'ObjectId': class ObjectId {\n\t\t\t\ttoHexString(): string {\n\t\t\t\t\treturn 'hexString';\n\t\t\t\t}\n\t\t\t},\n\t\t\t'@global': true,\n\t\t},\n\t});\ndescribe('Federation - Application - FederationRoomServiceReceiver', () => {\n\tlet service: typeof FederationRoomServiceReceiver;\n\tconst roomAdapter = {\n\t\tgetFederatedRoomByExternalId: sinon.stub(),\n\t\tcreateFederatedRoom: sinon.stub(),\n\t\tcreateFederatedRoomForDirectMessage: sinon.stub(),\n\t\tremoveDirectMessageRoom: sinon.stub(),\n\t\tremoveUserFromRoom: sinon.stub(),\n\t\taddUserToRoom: sinon.stub(),\n\t\tisUserAlreadyJoined: sinon.stub(),\n\t\tgetInternalRoomById: sinon.stub(),\n\t\tupdateFederatedRoomByInternalRoomId: sinon.stub(),\n\t\tupdateRoomType: sinon.stub(),\n\t\tupdateRoomName: sinon.stub(),\n\t\tupdateRoomTopic: sinon.stub(),\n\t\tapplyRoomRolesToUser: sinon.stub(),\n\t\tupdateDisplayRoomName: sinon.stub(),\n\t\taddUsersToRoomWhenJoinExternalPublicRoom: sinon.stub(),\n\t};\n\tconst userAdapter = {\n\t\tgetFederatedUserByExternalId: sinon.stub(),\n\t\tcreateFederatedUser: sinon.stub(),\n\t\tupdateFederationAvatar: sinon.stub(),\n\t\tsetAvatar: sinon.stub(),\n\t\tgetInternalUserByUsername: sinon.stub(),\n\t\tupdateRealName: sinon.stub(),\n\t\tgetFederatedUsersByExternalIds: sinon.stub(),\n\t};\n\tconst messageAdapter = {\n\t\tsendMessage: sinon.stub(),\n\t\tsendFileMessage: sinon.stub(),\n\t\tdeleteMessage: sinon.stub(),\n\t\tgetMessageByFederationId: sinon.stub(),\n\t\teditMessage: sinon.stub(),\n\t\tfindOneByFederationIdOnReactions: sinon.stub(),\n\t\tunreactToMessage: sinon.stub(),\n\t\tsendQuoteMessage: sinon.stub(),\n\t\tsendQuoteFileMessage: sinon.stub(),\n\t\teditQuotedMessage: sinon.stub(),\n\t\tgetMessageToEditWhenReplyAndQuote: sinon.stub(),\n\t\tsendThreadQuoteMessage: sinon.stub(),\n\t\tsendThreadMessage: sinon.stub(),\n\t\tsendThreadFileMessage: sinon.stub(),\n\t\tsendThreadQuoteFileMessage: sinon.stub(),\n\t};\n\tconst settingsAdapter = {\n\t\tgetHomeServerDomain: sinon.stub().returns('localDomain'),\n\t};\n\tconst notificationsAdapter = {\n\t\tsubscribeToUserTypingEventsOnFederatedRoomId: sinon.stub(),\n\t\tbroadcastUserTypingOnRoom: sinon.stub(),\n\t};\n\tconst fileAdapter = {\n\t\tuploadFile: sinon.stub(),\n\t};\n\tconst queueInstance = {\n\t\taddToQueue: sinon.stub(),\n\t};\n\tconst bridge = {\n\t\tgetUserProfileInformation: sinon.stub().resolves({}),\n\t\textractHomeserverOrigin: sinon.stub().returns('localDomain'),\n\t\tjoinRoom: sinon.stub(),\n\t\tconvertMatrixUrlToHttp: sinon.stub().returns('toHttpUrl'),\n\t\tgetReadStreamForFileFromUrl: sinon.stub(),\n\t\tgetRoomHistoricalJoinEvents: sinon.stub(),\n\t\tgetRoomData: sinon.stub(),\n\t};\n\tbeforeEach(() => {\n\t\tservice = new FederationRoomServiceReceiver(\n\t\t\troomAdapter as any,\n\t\t\tuserAdapter as any,\n\t\t\tmessageAdapter as any,\n\t\t\tfileAdapter as any,\n\t\t\tsettingsAdapter as any,\n\t\t\tnotificationsAdapter as any,\n\t\t\tqueueInstance as any,\n\t\t\tbridge as any,\n\t\t);\n\t});\n\tafterEach(() => {\n\t\troomAdapter.getFederatedRoomByExternalId.reset();\n\t\troomAdapter.createFederatedRoom.reset();\n\t\troomAdapter.createFederatedRoomForDirectMessage.reset();\n\t\troomAdapter.removeDirectMessageRoom.reset();\n\t\troomAdapter.updateRoomType.reset();\n\t\troomAdapter.updateRoomName.reset();\n\t\troomAdapter.updateFederatedRoomByInternalRoomId.reset();\n\t\troomAdapter.updateRoomTopic.reset();\n\t\troomAdapter.removeUserFromRoom.reset();\n\t\troomAdapter.isUserAlreadyJoined.reset();\n\t\troomAdapter.addUsersToRoomWhenJoinExternalPublicRoom.reset();\n\t\troomAdapter.getInternalRoomById.reset();\n\t\troomAdapter.addUserToRoom.reset();\n\t\troomAdapter.applyRoomRolesToUser.reset();\n\t\troomAdapter.updateDisplayRoomName.reset();\n\t\tuserAdapter.getFederatedUserByExternalId.reset();\n\t\tuserAdapter.createFederatedUser.reset();\n\t\tuserAdapter.updateFederationAvatar.reset();\n\t\tuserAdapter.setAvatar.reset();\n\t\tuserAdapter.getInternalUserByUsername.reset();\n\t\tuserAdapter.updateRealName.reset();\n\t\tuserAdapter.getFederatedUsersByExternalIds.reset();\n\t\tmessageAdapter.sendMessage.reset();\n\t\tmessageAdapter.sendFileMessage.reset();\n\t\tmessageAdapter.deleteMessage.reset();\n\t\tmessageAdapter.getMessageByFederationId.reset();\n\t\tmessageAdapter.editMessage.reset();\n\t\tmessageAdapter.unreactToMessage.reset();\n\t\tmessageAdapter.findOneByFederationIdOnReactions.reset();\n\t\tmessageAdapter.sendQuoteFileMessage.reset();\n\t\tmessageAdapter.sendQuoteMessage.reset();\n\t\tmessageAdapter.sendThreadQuoteMessage.reset();\n\t\tmessageAdapter.sendThreadMessage.reset();\n\t\tmessageAdapter.sendThreadFileMessage.reset();\n\t\tmessageAdapter.sendThreadQuoteFileMessage.reset();\n\t\tbridge.extractHomeserverOrigin.reset();\n\t\tbridge.joinRoom.reset();\n\t\tbridge.getUserProfileInformation.reset();\n\t\tbridge.getReadStreamForFileFromUrl.reset();\n\t\tbridge.getRoomData.reset();\n\t\tbridge.getRoomHistoricalJoinEvents.reset();\n\t\tfileAdapter.uploadFile.reset();\n\t\tqueueInstance.addToQueue.reset();\n\t});\n\tdescribe('#onCreateRoom()', () => {\n\t\tit('should NOT create users nor room if the room already exists', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves({} as any);\n\t\t\tawait service.onCreateRoom({} as any);\n\t\t\texpect(roomAdapter.createFederatedRoom.called).to.be.false;\n\t\t\texpect(userAdapter.createFederatedUser.called).to.be.false;\n\t\t});\n\t\tit('should NOT create users nor room if the room was created internally and programatically even if the room does not exists', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(undefined);\n\t\t\tawait service.onCreateRoom({ wasInternallyProgramaticallyCreated: true } as any);\n\t\t\texpect(roomAdapter.createFederatedRoom.called).to.be.false;\n\t\t\texpect(userAdapter.createFederatedUser.called).to.be.false;\n\t\t});\n\t\tit('should NOT update the room if it was created internally and programatically but it is not a DM message and dont create the room', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(undefined);\n\t\t\troomAdapter.getInternalRoomById.resolves({ t: 'c' });\n\t\t\tawait service.onCreateRoom({ wasInternallyProgramaticallyCreated: true } as any);\n\t\t\texpect(roomAdapter.updateFederatedRoomByInternalRoomId.called).to.be.false;\n\t\t\texpect(roomAdapter.createFederatedRoom.called).to.be.false;\n\t\t\texpect(userAdapter.createFederatedUser.called).to.be.false;\n\t\t});\n\t\tit('should NOT update the room if it was created internally and programatically but it does not exists and dont create the room', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(undefined);\n\t\t\troomAdapter.getInternalRoomById.resolves(undefined);\n\t\t\tawait service.onCreateRoom({ wasInternallyProgramaticallyCreated: true } as any);\n\t\t\texpect(roomAdapter.updateFederatedRoomByInternalRoomId.called).to.be.false;\n\t\t\texpect(roomAdapter.createFederatedRoom.called).to.be.false;\n\t\t\texpect(userAdapter.createFederatedUser.called).to.be.false;\n\t\t});\n\t\tit('should update the room if it was created internally and programatically but it is a DM message but it should NOT create a new DM Room(this is necessary due to a race condition on matrix events)', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(undefined);\n\t\t\troomAdapter.getInternalRoomById.resolves({ t: 'd' });\n\t\t\tawait service.onCreateRoom({\n\t\t\t\twasInternallyProgramaticallyCreated: true,\n\t\t\t\tinternalRoomId: 'internalRoomId',\n\t\t\t\texternalRoomId: 'externalRoomId',\n\t\t\t} as any);\n\t\t\texpect(roomAdapter.updateFederatedRoomByInternalRoomId.calledWith('internalRoomId', 'externalRoomId')).to.be.true;\n\t\t\texpect(roomAdapter.createFederatedRoom.called).to.be.false;\n\t\t\texpect(userAdapter.createFederatedUser.called).to.be.false;\n\t\t});\n\t});\n\tdescribe('#onChangeRoomMembership()', () => {\n\t\tconst user = FederatedUser.createInstance('externalInviterId', {\n\t\t\tname: 'normalizedInviterId',\n\t\t\tusername: 'normalizedInviterId',\n\t\t\texistsOnlyOnProxyServer: false,\n\t\t});\n\t\tconst room = FederatedRoom.createInstance('externalRoomId', 'normalizedRoomId', user, RoomType.CHANNEL, 'externalRoomName');\n\t\tit('should NOT process the method if the room already exists AND event origin is equal to LOCAL', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(user);\n\t\t\tawait service.onChangeRoomMembership({ externalRoomId: 'externalRoomId', eventOrigin: EVENT_ORIGIN.LOCAL } as any);\n\t\t\texpect(userAdapter.createFederatedUser.called).to.be.false;\n\t\t});\n\t\tit('should NOT process the method if the room already exists AND event origin is equal to REMOTE', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(user);\n\t\t\tawait service.onChangeRoomMembership({ externalRoomId: 'externalRoomId', eventOrigin: EVENT_ORIGIN.REMOTE } as any);\n\t\t\texpect(userAdapter.createFederatedUser.called).to.be.false;\n\t\t});\n\t\tit('should NOT process the method logic if the event was generated on the proxy home server, it is NOT a join event (user joining himself), but the room does not exists yet', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(undefined);\n\t\t\tuserAdapter.getFederatedUserByExternalId.onFirstCall().resolves(undefined);\n\t\t\tawait service.onChangeRoomMembership({\n\t\t\t\texternalRoomId: 'externalRoomId',\n\t\t\t\texternalInviterId: 'externalInviterId',\n\t\t\t\texternalInviteeId: 'externalInviteeId',\n\t\t\t\teventOrigin: EVENT_ORIGIN.LOCAL,\n\t\t\t} as any);\n\t\t\texpect(userAdapter.createFederatedUser.called).to.be.false;\n\t\t});\n\t\tit('should NOT create the inviter if it already exists', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(user);\n\t\t\tawait service.onChangeRoomMembership({ externalRoomId: 'externalRoomId', eventOrigin: EVENT_ORIGIN.LOCAL } as any);\n\t\t\texpect(userAdapter.createFederatedUser.called).to.be.false;\n\t\t});\n\t\tit('should create the inviter if it does not exists', async () => {\n\t\t\tconst inviter = FederatedUser.createInstance('externalInviterId', {\n\t\t\t\tname: 'inviterUsernameOnly',\n\t\t\t\tusername: 'inviterUsernameOnly',\n\t\t\t\texistsOnlyOnProxyServer: true,\n\t\t\t});\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\tuserAdapter.getFederatedUserByExternalId.onFirstCall().resolves(undefined);\n\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(user);\n\t\t\tbridge.extractHomeserverOrigin.returns('localDomain');\n\t\t\tawait service.onChangeRoomMembership({\n\t\t\t\texternalRoomId: 'externalRoomId',\n\t\t\t\teventOrigin: EVENT_ORIGIN.LOCAL,\n\t\t\t\texternalInviterId: 'externalInviterId',\n\t\t\t\tnormalizedInviterId: 'normalizedInviterId',\n\t\t\t\tinviterUsernameOnly: 'inviterUsernameOnly',\n\t\t\t} as any);\n\t\t\texpect(userAdapter.createFederatedUser.calledWith(inviter)).to.be.true;\n\t\t});\n\t\tit('should NOT create the invitee if it already exists', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(user);\n\t\t\tawait service.onChangeRoomMembership({ externalRoomId: 'externalRoomId', eventOrigin: EVENT_ORIGIN.LOCAL } as any);\n\t\t\texpect(userAdapter.createFederatedUser.called).to.be.false;\n\t\t});\n\t\tit('should create the invitee if it does not exists', async () => {\n\t\t\tconst invitee = FederatedUser.createInstance('externalInviteeId', {\n\t\t\t\tname: 'normalizedInviteeId',\n\t\t\t\tusername: 'normalizedInviteeId',\n\t\t\t\texistsOnlyOnProxyServer: false,\n\t\t\t});\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(invitee);\n\t\t\tuserAdapter.getFederatedUserByExternalId.onSecondCall().resolves(undefined);\n\t\t\tbridge.extractHomeserverOrigin.onCall(1).returns('externalDomain');\n\t\t\tawait service.onChangeRoomMembership({\n\t\t\t\texternalRoomId: 'externalRoomId',\n\t\t\t\teventOrigin: EVENT_ORIGIN.LOCAL,\n\t\t\t\texternalInviteeId: 'externalInviteeId',\n\t\t\t\tnormalizedInviteeId: 'normalizedInviteeId',\n\t\t\t} as any);\n\t\t\texpect(userAdapter.createFederatedUser.calledWith(invitee)).to.be.true;\n\t\t});\n\t\tit('should throw an error if the invitee user does not exists at all', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(undefined);\n\t\t\tawait expect(\n\t\t\t\tservice.onChangeRoomMembership({\n\t\t\t\t\texternalRoomId: 'externalRoomId',\n\t\t\t\t\teventOrigin: EVENT_ORIGIN.LOCAL,\n\t\t\t\t\texternalInviteeId: 'externalInviteeId',\n\t\t\t\t\tnormalizedInviteeId: 'normalizedInviteeId',\n\t\t\t\t} as any),\n\t\t\t).to.be.rejectedWith('Invitee or inviter user not found');\n\t\t});\n\t\tit('should throw an error if the inviter user does not exists at all', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(undefined);\n\t\t\tawait expect(\n\t\t\t\tservice.onChangeRoomMembership({\n\t\t\t\t\texternalRoomId: 'externalRoomId',\n\t\t\t\t\teventOrigin: EVENT_ORIGIN.LOCAL,\n\t\t\t\t\texternalInviteeId: 'externalInviteeId',\n\t\t\t\t\tnormalizedInviteeId: 'normalizedInviteeId',\n\t\t\t\t} as any),\n\t\t\t).to.be.rejectedWith('Invitee or inviter user not found');\n\t\t});\n\t\tit('should NOT create the room if it does not exists yet AND the event origin is REMOTE but there is no room type on the event', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.onCall(0).resolves(undefined);\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(user);\n\t\t\tawait service.onChangeRoomMembership({\n\t\t\t\texternalRoomId: 'externalRoomId',\n\t\t\t\tnormalizedRoomId: 'normalizedRoomId',\n\t\t\t\teventOrigin: EVENT_ORIGIN.REMOTE,\n\t\t\t\troomType: undefined,\n\t\t\t\texternalInviteeId: 'externalInviteeId',\n\t\t\t\tnormalizedInviteeId: 'normalizedInviteeId',\n\t\t\t} as any);\n\t\t\texpect(roomAdapter.createFederatedRoom.called).to.be.false;\n\t\t});\n\t\tit('should create a room for DM if the room type is equal a direct message and it is handling regular events (m.room.member)(not using the property extracted from the invite_room_state)', async () => {\n\t\t\tconst inviter = user;\n\t\t\tconst invitee = FederatedUser.createInstance('externalInviteeId', {\n\t\t\t\tname: 'normalizedInviteeId',\n\t\t\t\tusername: 'normalizedInviteeId',\n\t\t\t\texistsOnlyOnProxyServer: false,\n\t\t\t});\n\t\t\troomAdapter.getFederatedRoomByExternalId.onCall(0).resolves(undefined);\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\tuserAdapter.getFederatedUserByExternalId.onCall(0).resolves(inviter);\n\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(invitee);\n\t\t\tbridge.extractHomeserverOrigin.returns('localDomain');\n\t\t\tawait service.onChangeRoomMembership({\n\t\t\t\texternalRoomId: 'externalRoomId',\n\t\t\t\tnormalizedRoomId: 'normalizedRoomId',\n\t\t\t\teventOrigin: EVENT_ORIGIN.REMOTE,\n\t\t\t\troomType: RoomType.DIRECT_MESSAGE,\n\t\t\t\texternalInviteeId: 'externalInviteeId',\n\t\t\t\tnormalizedInviteeId: 'normalizedInviteeId',\n\t\t\t} as any);\n\t\t\tconst createdRoom = DirectMessageFederatedRoom.createInstance('externalRoomId', inviter, [inviter, invitee]);\n\t\t\texpect(roomAdapter.createFederatedRoomForDirectMessage.calledWith(createdRoom)).to.be.true;\n\t\t\texpect(roomAdapter.createFederatedRoom.called).to.be.false;\n\t\t\texpect(bridge.joinRoom.calledOnceWith('externalRoomId', 'externalInviteeId')).to.be.true;\n\t\t});\n\t\tit('should create a room for DM if the room type is equal a direct message and it is handling regular events (m.room.member)(not using the property extracted from the invite_room_state), but not automatically join the invitee if he/she is not from the proxy homeserver', async () => {\n\t\t\tconst inviter = user;\n\t\t\tconst invitee = FederatedUser.createInstance('externalInviteeId', {\n\t\t\t\tname: 'normalizedInviteeId',\n\t\t\t\tusername: 'normalizedInviteeId',\n\t\t\t\texistsOnlyOnProxyServer: false,\n\t\t\t});\n\t\t\troomAdapter.getFederatedRoomByExternalId.onCall(0).resolves(undefined);\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\tuserAdapter.getFederatedUserByExternalId.onCall(0).resolves(inviter);\n\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(invitee);\n\t\t\tbridge.extractHomeserverOrigin.returns('externalDomain');\n\t\t\tawait service.onChangeRoomMembership({\n\t\t\t\texternalRoomId: 'externalRoomId',\n\t\t\t\tnormalizedRoomId: 'normalizedRoomId',\n\t\t\t\teventOrigin: EVENT_ORIGIN.REMOTE,\n\t\t\t\troomType: RoomType.DIRECT_MESSAGE,\n\t\t\t\texternalInviteeId: 'externalInviteeId',\n\t\t\t\tnormalizedInviteeId: 'normalizedInviteeId',\n\t\t\t} as any);\n\t\t\tconst createdRoom = DirectMessageFederatedRoom.createInstance('externalRoomId', inviter, [inviter, invitee]);\n\t\t\texpect(roomAdapter.createFederatedRoomForDirectMessage.calledWith(createdRoom)).to.be.true;\n\t\t\texpect(roomAdapter.createFederatedRoom.called).to.be.false;\n\t\t\texpect(bridge.joinRoom.called).to.be.false;\n\t\t});\n\t\tit('should create a room for DM if the room type is equal a direct message handling the property extracted from the invite_room_state', async () => {\n\t\t\tconst inviter = user;\n\t\t\tconst invitee = FederatedUser.createInstance('externalInviteeId', {\n\t\t\t\tname: 'normalizedInviteeId',\n\t\t\t\tusername: 'normalizedInviteeId',\n\t\t\t\texistsOnlyOnProxyServer: false,\n\t\t\t});\n\t\t\troomAdapter.getFederatedRoomByExternalId.onCall(0).resolves(undefined);\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\tuserAdapter.getFederatedUserByExternalId.onCall(0).resolves(inviter);\n\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(invitee);\n\t\t\tbridge.extractHomeserverOrigin.returns('localDomain');\n\t\t\tawait service.onChangeRoomMembership({\n\t\t\t\texternalRoomId: 'externalRoomId',\n\t\t\t\tnormalizedRoomId: 'normalizedRoomId',\n\t\t\t\teventOrigin: EVENT_ORIGIN.REMOTE,\n\t\t\t\troomType: RoomType.DIRECT_MESSAGE,\n\t\t\t\texternalInviteeId: 'externalInviteeId',\n\t\t\t\tnormalizedInviteeId: 'normalizedInviteeId',\n\t\t\t\tallInviteesExternalIdsWhenDM: [\n\t\t\t\t\t{\n\t\t\t\t\t\texternalInviteeId: 'externalInviteeId',\n\t\t\t\t\t\tnormalizedInviteeId: 'normalizedInviteeId',\n\t\t\t\t\t\tinviteeUsernameOnly: 'inviteeUsernameOnly',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t} as any);\n\t\t\tconst createdRoom = DirectMessageFederatedRoom.createInstance('externalRoomId', inviter, [inviter, invitee]);\n\t\t\texpect(roomAdapter.createFederatedRoomForDirectMessage.calledWith(createdRoom)).to.be.true;\n\t\t\texpect(roomAdapter.createFederatedRoom.called).to.be.false;\n\t\t\texpect(bridge.joinRoom.calledOnceWith('externalRoomId', 'externalInviteeId')).to.be.true;\n\t\t});\n\t\tit('should create a room for DM if the room type is equal a direct message handling the property extracted from the invite_room_state, but not automatically join the user if he/she is not from the proxy homeserver', async () => {\n\t\t\tconst inviter = user;\n\t\t\tconst invitee = FederatedUser.createInstance('externalInviteeId', {\n\t\t\t\tname: 'normalizedInviteeId',\n\t\t\t\tusername: 'normalizedInviteeId',\n\t\t\t\texistsOnlyOnProxyServer: false,\n\t\t\t});\n\t\t\troomAdapter.getFederatedRoomByExternalId.onCall(0).resolves(undefined);\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\tuserAdapter.getFederatedUserByExternalId.onCall(0).resolves(inviter);\n\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(invitee);\n\t\t\tbridge.extractHomeserverOrigin.returns('externalDomain');\n\t\t\tawait service.onChangeRoomMembership({\n\t\t\t\texternalRoomId: 'externalRoomId',\n\t\t\t\tnormalizedRoomId: 'normalizedRoomId',\n\t\t\t\teventOrigin: EVENT_ORIGIN.REMOTE,\n\t\t\t\troomType: RoomType.DIRECT_MESSAGE,\n\t\t\t\texternalInviteeId: 'externalInviteeId',\n\t\t\t\tnormalizedInviteeId: 'normalizedInviteeId',\n\t\t\t\tallInviteesExternalIdsWhenDM: [\n\t\t\t\t\t{\n\t\t\t\t\t\texternalInviteeId: 'externalInviteeId',\n\t\t\t\t\t\tnormalizedInviteeId: 'normalizedInviteeId',\n\t\t\t\t\t\tinviteeUsernameOnly: 'inviteeUsernameOnly',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t} as any);\n\t\t\tconst createdRoom = DirectMessageFederatedRoom.createInstance('externalRoomId', inviter, [inviter, invitee]);\n\t\t\texpect(roomAdapter.createFederatedRoomForDirectMessage.calledWith(createdRoom)).to.be.true;\n\t\t\texpect(roomAdapter.createFederatedRoom.called).to.be.false;\n\t\t\texpect(bridge.joinRoom.called).to.be.false;\n\t\t});\n\t\tit('should create a room (not DM) if the room type is NOT equal a direct message AND to add the historical room events to the processing queue when they exists', async () => {\n\t\t\tconst invitee = FederatedUser.createInstance('externalInviteeId', {\n\t\t\t\tname: 'normalizedInviteeId',\n\t\t\t\tusername: 'normalizedInviteeId',\n\t\t\t\texistsOnlyOnProxyServer: false,\n\t\t\t});\n\t\t\troomAdapter.getFederatedRoomByExternalId.onCall(0).resolves(undefined);\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(invitee);\n\t\t\tbridge.getRoomHistoricalJoinEvents.resolves(['event1', 'event2']);\n\t\t\tawait service.onChangeRoomMembership({\n\t\t\t\texternalRoomId: 'externalRoomId',\n\t\t\t\tnormalizedRoomId: 'normalizedRoomId',\n\t\t\t\teventOrigin: EVENT_ORIGIN.REMOTE,\n\t\t\t\troomType: RoomType.CHANNEL,\n\t\t\t\texternalInviteeId: 'externalInviteeId',\n\t\t\t\tnormalizedInviteeId: 'normalizedInviteeId',\n\t\t\t\texternalRoomName: 'externalRoomName',\n\t\t\t} as any);\n\t\t\tconst createdRoom = FederatedRoom.createInstance('externalRoomId', 'normalizedRoomId', invitee, RoomType.CHANNEL);\n\t\t\texpect(roomAdapter.createFederatedRoom.calledWith(createdRoom)).to.be.true;\n\t\t\texpect(roomAdapter.createFederatedRoomForDirectMessage.called).to.be.false;\n\t\t\texpect(bridge.joinRoom.calledWith('externalRoomId', 'externalInviteeId')).to.be.true;\n\t\t\t['event1', 'event2'].forEach((event) => expect(queueInstance.addToQueue.calledWith(event)).to.be.true);\n\t\t});\n\t\tit('should create a room (not DM) if the room type is NOT equal a direct message AND NOT to add the historical room events to the processing queue when they exists', async () => {\n\t\t\tconst invitee = FederatedUser.createInstance('externalInviteeId', {\n\t\t\t\tname: 'normalizedInviteeId',\n\t\t\t\tusername: 'normalizedInviteeId',\n\t\t\t\texistsOnlyOnProxyServer: false,\n\t\t\t});\n\t\t\troomAdapter.getFederatedRoomByExternalId.onCall(0).resolves(undefined);\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(invitee);\n\t\t\tbridge.getRoomHistoricalJoinEvents.resolves([]);\n\t\t\tawait service.onChangeRoomMembership({\n\t\t\t\texternalRoomId: 'externalRoomId',\n\t\t\t\tnormalizedRoomId: 'normalizedRoomId',\n\t\t\t\teventOrigin: EVENT_ORIGIN.REMOTE,\n\t\t\t\troomType: RoomType.CHANNEL,\n\t\t\t\texternalInviteeId: 'externalInviteeId',\n\t\t\t\tnormalizedInviteeId: 'normalizedInviteeId',\n\t\t\t\texternalRoomName: 'externalRoomName',\n\t\t\t} as any);\n\t\t\tconst createdRoom = FederatedRoom.createInstance('externalRoomId', 'normalizedRoomId', invitee, RoomType.CHANNEL);\n\t\t\texpect(roomAdapter.createFederatedRoom.calledWith(createdRoom)).to.be.true;\n\t\t\texpect(roomAdapter.createFederatedRoomForDirectMessage.called).to.be.false;\n\t\t\texpect(bridge.joinRoom.calledWith('externalRoomId', 'externalInviteeId')).to.be.true;\n\t\t\texpect(queueInstance.addToQueue.called).to.be.false;\n\t\t});\n\t\tit('should call the update name function if the name is inside the received input', async () => {\n\t\t\tconst invitee = FederatedUser.createInstance('externalInviteeId', {\n\t\t\t\tname: 'normalizedInviteeId',\n\t\t\t\tusername: 'normalizedInviteeId',\n\t\t\t\texistsOnlyOnProxyServer: false,\n\t\t\t});\n\t\t\troomAdapter.getFederatedRoomByExternalId.onCall(0).resolves(undefined);\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(invitee);\n\t\t\tbridge.getRoomHistoricalJoinEvents.resolves([]);\n\t\t\tconst spy = sinon.spy(service, 'onChangeRoomName');\n\t\t\tawait service.onChangeRoomMembership({\n\t\t\t\texternalRoomId: 'externalRoomId',\n\t\t\t\tnormalizedRoomId: 'normalizedRoomId',\n\t\t\t\teventOrigin: EVENT_ORIGIN.REMOTE,\n\t\t\t\troomType: RoomType.CHANNEL,\n\t\t\t\texternalInviteeId: 'externalInviteeId',\n\t\t\t\tnormalizedInviteeId: 'normalizedInviteeId',\n\t\t\t\texternalRoomName: 'externalRoomName',\n\t\t\t\texternalEventId: 'externalEventId',\n\t\t\t\texternalInviterId: 'externalInviterId',\n\t\t\t} as any);\n\t\t\texpect(\n\t\t\t\tspy.calledWith({\n\t\t\t\t\texternalRoomId: 'externalRoomId',\n\t\t\t\t\tnormalizedRoomName: 'externalRoomName',\n\t\t\t\t\texternalEventId: 'externalEventId',\n\t\t\t\t\texternalSenderId: 'externalInviterId',\n\t\t\t\t\tnormalizedRoomId: 'normalizedRoomId',\n\t\t\t\t}),\n\t\t\t).to.be.true;\n\t\t});\n\t\tit('should NOT create the room if it already exists yet AND the event origin is REMOTE', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(user);\n\t\t\tawait service.onChangeRoomMembership({\n\t\t\t\texternalRoomId: 'externalRoomId',\n\t\t\t\tnormalizedRoomId: 'normalizedRoomId',\n\t\t\t\teventOrigin: EVENT_ORIGIN.REMOTE,\n\t\t\t\troomType: RoomType.CHANNEL,\n\t\t\t\texternalInviteeId: 'externalInviteeId',\n\t\t\t\tnormalizedInviteeId: 'normalizedInviteeId',\n\t\t\t} as any);\n\t\t\texpect(roomAdapter.createFederatedRoom.called).to.be.false;\n\t\t\texpect(roomAdapter.createFederatedRoomForDirectMessage.called).to.be.false;\n\t\t\texpect(bridge.joinRoom.called).to.be.false;\n\t\t});\n\t\tit('should remove the user from room if its a LEAVE event and the user is in the room already', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\troomAdapter.isUserAlreadyJoined.resolves(true);\n\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(user);\n\t\t\tawait service.onChangeRoomMembership({\n\t\t\t\texternalRoomId: 'externalRoomId',\n\t\t\t\tnormalizedRoomId: 'normalizedRoomId',\n\t\t\t\teventOrigin: EVENT_ORIGIN.LOCAL,\n\t\t\t\troomType: RoomType.CHANNEL,\n\t\t\t\texternalInviteeId: 'externalInviteeId',\n\t\t\t\tleave: true,\n\t\t\t\tnormalizedInviteeId: 'normalizedInviteeId',\n\t\t\t} as any);\n\t\t\texpect(roomAdapter.removeUserFromRoom.calledWith(room, user, user)).to.be.true;\n\t\t\texpect(roomAdapter.addUserToRoom.called).to.be.false;\n\t\t});\n\t\tit('should NOT remove the user from room if its a LEAVE event and the user is NOT in the room anymore', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\troomAdapter.isUserAlreadyJoined.resolves(false);\n\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(user);\n\t\t\tawait service.onChangeRoomMembership({\n\t\t\t\texternalRoomId: 'externalRoomId',\n\t\t\t\tnormalizedRoomId: 'normalizedRoomId',\n\t\t\t\teventOrigin: EVENT_ORIGIN.LOCAL,\n\t\t\t\troomType: RoomType.CHANNEL,\n\t\t\t\texternalInviteeId: 'externalInviteeId',\n\t\t\t\tleave: true,\n\t\t\t\tnormalizedInviteeId: 'normalizedInviteeId',\n\t\t\t} as any);\n\t\t\texpect(roomAdapter.removeUserFromRoom.called).to.be.false;\n\t\t\texpect(roomAdapter.addUserToRoom.called).to.be.false;\n\t\t});\n\t\tit('should NOT remove and recreate the DM room if the user is already part of the room (in case of being a multiple DM, Matrix send events for each user at a time, which requires us to remove and recreate the DM room)', async () => {\n\t\t\tconst dmRoom = DirectMessageFederatedRoom.createWithInternalReference(\n\t\t\t\t'externalRoomId',\n\t\t\t\t{ usernames: [user.getUsername() as string] } as any,\n\t\t\t\t[user, user],\n\t\t\t);\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(dmRoom);\n\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(user);\n\t\t\tawait service.onChangeRoomMembership({\n\t\t\t\texternalRoomId: 'externalRoomId',\n\t\t\t\tnormalizedRoomId: 'normalizedRoomId',\n\t\t\t\teventOrigin: EVENT_ORIGIN.REMOTE,\n\t\t\t\troomType: RoomType.DIRECT_MESSAGE,\n\t\t\t\texternalInviteeId: 'externalInviteeId',\n\t\t\t\tnormalizedInviteeId: 'normalizedInviteeId',\n\t\t\t} as any);\n\t\t\texpect(roomAdapter.removeDirectMessageRoom.called).to.be.false;\n\t\t\texpect(roomAdapter.createFederatedRoomForDirectMessage.called).to.be.false;\n\t\t});\n\t\tit('should remove and recreate the DM room if the user is part of the room yet (in case of being a multiple DM, Matrix send events for each user at a time, which requires us to remove and recreate the DM room)', async () => {\n\t\t\tconst dmRoom = DirectMessageFederatedRoom.createWithInternalReference('externalRoomId', { usernames: [] } as any, [user, user]);\n\t\t\tconst invitee = FederatedUser.createInstance('externalInviteeId', {\n\t\t\t\tname: 'normalizedInviteeId',\n\t\t\t\tusername: 'normalizedInviteeId',\n\t\t\t\texistsOnlyOnProxyServer: false,\n\t\t\t});\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(dmRoom);\n\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(user);\n\t\t\tuserAdapter.getFederatedUserByExternalId.onCall(1).resolves(invitee);\n\t\t\tawait service.onChangeRoomMembership({\n\t\t\t\texternalRoomId: 'externalRoomId',\n\t\t\t\tnormalizedRoomId: 'normalizedRoomId',\n\t\t\t\teventOrigin: EVENT_ORIGIN.REMOTE,\n\t\t\t\troomType: RoomType.DIRECT_MESSAGE,\n\t\t\t\texternalInviteeId: 'externalInviteeId',\n\t\t\t\tnormalizedInviteeId: 'normalizedInviteeId',\n\t\t\t} as any);\n\t\t\tconst createdRoom = DirectMessageFederatedRoom.createInstance('externalRoomId', user, [user, user, invitee]);\n\t\t\texpect(roomAdapter.removeDirectMessageRoom.calledWith(dmRoom)).to.be.true;\n\t\t\texpect(roomAdapter.createFederatedRoomForDirectMessage.calledWith(createdRoom)).to.be.true;\n\t\t\texpect(roomAdapter.addUserToRoom.called).to.be.false;\n\t\t});\n\t\tit('should NOT add the user to the room if its NOT a LEAVE event but the user is already in the room', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\troomAdapter.isUserAlreadyJoined.resolves(true);\n\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(user);\n\t\t\tawait service.onChangeRoomMembership({\n\t\t\t\texternalRoomId: 'externalRoomId',\n\t\t\t\tnormalizedRoomId: 'normalizedRoomId',\n\t\t\t\teventOrigin: EVENT_ORIGIN.LOCAL,\n\t\t\t\troomType: RoomType.CHANNEL,\n\t\t\t\texternalInviteeId: 'externalInviteeId',\n\t\t\t\tleave: false,\n\t\t\t\tnormalizedInviteeId: 'normalizedInviteeId',\n\t\t\t} as any);\n\t\t\texpect(roomAdapter.removeUserFromRoom.called).to.be.false;\n\t\t\texpect(roomAdapter.removeDirectMessageRoom.called).to.be.false;\n\t\t\texpect(roomAdapter.createFederatedRoomForDirectMessage.called).to.be.false;\n\t\t\texpect(bridge.joinRoom.called).to.be.false;\n\t\t\texpect(roomAdapter.addUserToRoom.called).to.be.false;\n\t\t});\n\t\tit('should add the user into the room if its NOT a LEAVE event providing the inviter when the user is NOT joining by himself', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(user);\n\t\t\tawait service.onChangeRoomMembership({\n\t\t\t\texternalRoomId: 'externalRoomId',\n\t\t\t\tnormalizedRoomId: 'normalizedRoomId',\n\t\t\t\teventOrigin: EVENT_ORIGIN.REMOTE,\n\t\t\t\troomType: RoomType.CHANNEL,\n\t\t\t\texternalInviteeId: 'externalInviteeId',\n\t\t\t\tleave: false,\n\t\t\t\tnormalizedInviteeId: 'normalizedInviteeId',\n\t\t\t} as any);\n\t\t\texpect(roomAdapter.removeUserFromRoom.called).to.be.false;\n\t\t\texpect(roomAdapter.removeDirectMessageRoom.called).to.be.false;\n\t\t\texpect(roomAdapter.createFederatedRoomForDirectMessage.called).to.be.false;\n\t\t\texpect(bridge.joinRoom.called).to.be.false;\n\t\t\texpect(roomAdapter.addUserToRoom.calledWith(room, user, user)).to.be.true;\n\t\t});\n\t\tit('should join the room using the bridge if its NOT a leave event AND the invitee is from the proxy home server', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(user);\n\t\t\tbridge.extractHomeserverOrigin.returns('localDomain');\n\t\t\tawait service.onChangeRoomMembership({\n\t\t\t\texternalRoomId: 'externalRoomId',\n\t\t\t\tnormalizedRoomId: 'normalizedRoomId',\n\t\t\t\teventOrigin: EVENT_ORIGIN.LOCAL,\n\t\t\t\troomType: RoomType.CHANNEL,\n\t\t\t\texternalInviteeId: 'externalInviteeId',\n\t\t\t\tleave: false,\n\t\t\t\tnormalizedInviteeId: 'normalizedInviteeId',\n\t\t\t} as any);\n\t\t\texpect(roomAdapter.addUserToRoom.calledWith(room, user, user)).to.be.true;\n\t\t\texpect(bridge.joinRoom.calledWith('externalRoomId', 'externalInviteeId')).to.be.true;\n\t\t});\n\t\tit('should NOT join the room using the bridge if its NOT a leave event AND the invitee is NOT from the proxy home server', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(user);\n\t\t\tbridge.extractHomeserverOrigin.returns('externalDomain');\n\t\t\tawait service.onChangeRoomMembership({\n\t\t\t\texternalRoomId: 'externalRoomId',\n\t\t\t\tnormalizedRoomId: 'normalizedRoomId',\n\t\t\t\teventOrigin: EVENT_ORIGIN.LOCAL,\n\t\t\t\troomType: RoomType.CHANNEL,\n\t\t\t\texternalInviteeId: 'externalInviteeId',\n\t\t\t\tleave: false,\n\t\t\t\tnormalizedInviteeId: 'normalizedInviteeId',\n\t\t\t} as any);\n\t\t\texpect(roomAdapter.addUserToRoom.calledWith(room, user, user)).to.be.true;\n\t\t\texpect(bridge.joinRoom.called).to.be.false;\n\t\t});\n\t\tit('should add the user into the room if its NOT a LEAVE event NOT providing the inviter when the user is joining by himself', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(user);\n\t\t\tawait service.onChangeRoomMembership({\n\t\t\t\texternalRoomId: 'externalRoomId',\n\t\t\t\tnormalizedRoomId: 'normalizedRoomId',\n\t\t\t\teventOrigin: EVENT_ORIGIN.REMOTE,\n\t\t\t\troomType: RoomType.CHANNEL,\n\t\t\t\texternalInviteeId: 'externalInviteeId',\n\t\t\t\texternalInviterId: 'externalInviteeId',\n\t\t\t\tleave: false,\n\t\t\t\tnormalizedInviteeId: 'normalizedInviteeId',\n\t\t\t} as any);\n\t\t\texpect(roomAdapter.removeUserFromRoom.called).to.be.false;\n\t\t\texpect(roomAdapter.removeDirectMessageRoom.called).to.be.false;\n\t\t\texpect(roomAdapter.createFederatedRoomForDirectMessage.called).to.be.false;\n\t\t\texpect(bridge.joinRoom.called).to.be.false;\n\t\t\texpect(roomAdapter.addUserToRoom.calledWith(room, user)).to.be.true;\n\t\t});\n\t\tdescribe('Handling users auto-joining', () => {\n\t\t\tit('should subscribe to the typings events if the room already exists', async () => {\n\t\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(user);\n\t\t\t\tawait service.onChangeRoomMembership({\n\t\t\t\t\texternalRoomId: 'externalRoomId',\n\t\t\t\t\tnormalizedRoomId: 'normalizedRoomId',\n\t\t\t\t\teventOrigin: EVENT_ORIGIN.LOCAL,\n\t\t\t\t\troomType: RoomType.CHANNEL,\n\t\t\t\t\texternalInviteeId: 'externalInviteeId',\n\t\t\t\t\texternalInviterId: 'externalInviteeId',\n\t\t\t\t\tleave: false,\n\t\t\t\t\tnormalizedInviteeId: 'normalizedInviteeId',\n\t\t\t\t} as any);\n\t\t\t\texpect(notificationsAdapter.subscribeToUserTypingEventsOnFederatedRoomId.called).to.be.true;\n\t\t\t});\n\t\t\tit('should NOT add the user to the room if the user is already a room member', async () => {\n\t\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(user);\n\t\t\t\troomAdapter.isUserAlreadyJoined.resolves(true);\n\t\t\t\tawait service.onChangeRoomMembership({\n\t\t\t\t\texternalRoomId: 'externalRoomId',\n\t\t\t\t\tnormalizedRoomId: 'normalizedRoomId',\n\t\t\t\t\teventOrigin: EVENT_ORIGIN.LOCAL,\n\t\t\t\t\troomType: RoomType.CHANNEL,\n\t\t\t\t\texternalInviteeId: 'externalInviteeId',\n\t\t\t\t\texternalInviterId: 'externalInviteeId',\n\t\t\t\t\tleave: false,\n\t\t\t\t\tnormalizedInviteeId: 'normalizedInviteeId',\n\t\t\t\t} as any);\n\t\t\t\texpect(roomAdapter.addUserToRoom.called).to.be.false;\n\t\t\t});\n\t\t\tit('should add the user to the room if the user is NOT a room member yet', async () => {\n\t\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(user);\n\t\t\t\troomAdapter.isUserAlreadyJoined.resolves(false);\n\t\t\t\tawait service.onChangeRoomMembership({\n\t\t\t\t\texternalRoomId: 'externalRoomId',\n\t\t\t\t\tnormalizedRoomId: 'normalizedRoomId',\n\t\t\t\t\teventOrigin: EVENT_ORIGIN.LOCAL,\n\t\t\t\t\troomType: RoomType.CHANNEL,\n\t\t\t\t\texternalInviteeId: 'externalInviteeId',\n\t\t\t\t\texternalInviterId: 'externalInviteeId',\n\t\t\t\t\tleave: false,\n\t\t\t\t\tnormalizedInviteeId: 'normalizedInviteeId',\n\t\t\t\t} as any);\n\t\t\t\texpect(roomAdapter.addUserToRoom.calledWith(room, user)).to.be.true;\n\t\t\t});\n\t\t\tit('should NOT create the room if it was not possible to retrieve the information from the room from the bridge', async () => {\n\t\t\t\troomAdapter.getFederatedRoomByExternalId.onCall(0).resolves(room);\n\t\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(undefined);\n\t\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(user);\n\t\t\t\troomAdapter.isUserAlreadyJoined.resolves(false);\n\t\t\t\tbridge.getRoomData.resolves(undefined);\n\t\t\t\tawait service.onChangeRoomMembership({\n\t\t\t\t\texternalRoomId: 'externalRoomId',\n\t\t\t\t\tnormalizedRoomId: 'normalizedRoomId',\n\t\t\t\t\teventOrigin: EVENT_ORIGIN.LOCAL,\n\t\t\t\t\troomType: RoomType.CHANNEL,\n\t\t\t\t\texternalInviteeId: 'externalInviteeId',\n\t\t\t\t\texternalInviterId: 'externalInviteeId',\n\t\t\t\t\tleave: false,\n\t\t\t\t\tnormalizedInviteeId: 'normalizedInviteeId',\n\t\t\t\t} as any);\n\t\t\t\texpect(roomAdapter.createFederatedRoom.called).to.be.false;\n\t\t\t});\n\t\t\tit('should NOT create the room if it there is already a room creation process already running', async () => {\n\t\t\t\troomAdapter.getFederatedRoomByExternalId.onCall(0).resolves(room);\n\t\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(undefined);\n\t\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(user);\n\t\t\t\troomAdapter.isUserAlreadyJoined.resolves(false);\n\t\t\t\tbridge.getRoomData.resolves({ creator: {} });\n\t\t\t\tawait service.onChangeRoomMembership({\n\t\t\t\t\texternalRoomId: 'externalRoomId',\n\t\t\t\t\tnormalizedRoomId: 'normalizedRoomId',\n\t\t\t\t\teventOrigin: EVENT_ORIGIN.LOCAL,\n\t\t\t\t\troomType: RoomType.CHANNEL,\n\t\t\t\t\texternalInviteeId: 'externalInviteeId',\n\t\t\t\t\texternalInviterId: 'externalInviteeId',\n\t\t\t\t\tleave: false,\n\t\t\t\t\tnormalizedInviteeId: 'normalizedInviteeId',\n\t\t\t\t} as any);\n\t\t\t\texpect(roomAdapter.createFederatedRoom.called).to.be.false;\n\t\t\t});\n\t\t\tit('should create the creator user only if it does not exists yet and use the provided username if its from the same homeserver', async () => {\n\t\t\t\tconst spy = sinon.spy(service, 'createFederatedUserInternallyOnly');\n\t\t\t\troomAdapter.getFederatedRoomByExternalId.onCall(0).resolves(room);\n\t\t\t\tuserAdapter.getFederatedUserByExternalId.onCall(0).resolves(user);\n\t\t\t\tuserAdapter.getFederatedUserByExternalId.onCall(1).resolves(user);\n\t\t\t\tuserAdapter.getFederatedUserByExternalId.onCall(2).resolves(undefined);\n\t\t\t\tuserAdapter.getFederatedUserByExternalId.onCall(3).resolves(undefined);\n\t\t\t\tbridge.getRoomData.resolves({ creator: { id: 'creatorId', username: 'creatorUsername' } });\n\t\t\t\tbridge.extractHomeserverOrigin.returns('localDomain');\n\t\t\t\tawait service.onChangeRoomMembership({\n\t\t\t\t\texternalRoomId: 'externalRoomId',\n\t\t\t\t\tnormalizedRoomId: 'normalizedRoomId',\n\t\t\t\t\teventOrigin: EVENT_ORIGIN.LOCAL,\n\t\t\t\t\troomType: RoomType.CHANNEL,\n\t\t\t\t\texternalInviteeId: 'externalInviteeId',\n\t\t\t\t\texternalInviterId: 'externalInviteeId',\n\t\t\t\t\tleave: false,\n\t\t\t\t\tnormalizedInviteeId: 'normalizedInviteeId',\n\t\t\t\t} as any);\n\t\t\t\tconst existsOnlyOnProxyServer = true;\n\t\t\t\texpect(spy.calledWith('creatorId', 'creatorUsername', existsOnlyOnProxyServer)).to.be.true;\n\t\t\t});\n\t\t\tit('should create the creator user if it does not exists yet and use the external id as username if its not from the same homeserver', async () => {\n\t\t\t\tconst spy = sinon.spy(service, 'createFederatedUserInternallyOnly');\n\t\t\t\troomAdapter.getFederatedRoomByExternalId.onCall(0).resolves(room);\n\t\t\t\tuserAdapter.getFederatedUserByExternalId.onCall(0).resolves(user);\n\t\t\t\tuserAdapter.getFederatedUserByExternalId.onCall(1).resolves(user);\n\t\t\t\tuserAdapter.getFederatedUserByExternalId.onCall(2).resolves(undefined);\n\t\t\t\tuserAdapter.getFederatedUserByExternalId.onCall(3).resolves(undefined);\n\t\t\t\tbridge.getRoomData.resolves({ creator: { id: '@creatorId:externalserver.com', username: 'creatorUsername' } });\n\t\t\t\tbridge.extractHomeserverOrigin.returns('externalDomain');\n\t\t\t\tawait service.onChangeRoomMembership({\n\t\t\t\t\texternalRoomId: 'externalRoomId',\n\t\t\t\t\tnormalizedRoomId: 'normalizedRoomId',\n\t\t\t\t\teventOrigin: EVENT_ORIGIN.LOCAL,\n\t\t\t\t\troomType: RoomType.CHANNEL,\n\t\t\t\t\texternalInviteeId: 'externalInviteeId',\n\t\t\t\t\texternalInviterId: 'externalInviteeId',\n\t\t\t\t\tleave: false,\n\t\t\t\t\tnormalizedInviteeId: 'normalizedInviteeId',\n\t\t\t\t} as any);\n\t\t\t\tconst existsOnlyOnProxyServer = false;\n\t\t\t\texpect(spy.calledWith('@creatorId:externalserver.com', 'creatorId:externalserver.com', existsOnlyOnProxyServer)).to.be.true;\n\t\t\t});\n\t\t\tit('should NOT create the room if the creator does not exists nor was created successfully previously', async () => {\n\t\t\t\tsinon.stub(service, 'createFederatedUserAndReturnIt').resolves();\n\t\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(undefined);\n\t\t\t\tuserAdapter.getFederatedUserByExternalId.onCall(0).resolves(user);\n\t\t\t\tuserAdapter.getFederatedUserByExternalId.onCall(1).resolves(user);\n\t\t\t\tuserAdapter.getFederatedUserByExternalId.onCall(2).resolves(undefined);\n\t\t\t\tbridge.getRoomData.resolves({ creator: { id: '@creatorId:externalserver.com', username: 'creatorUsername' } });\n\t\t\t\tbridge.extractHomeserverOrigin.returns('externalDomain');\n\t\t\t\tawait service.onChangeRoomMembership({\n\t\t\t\t\texternalRoomId: 'externalRoomId',\n\t\t\t\t\tnormalizedRoomId: 'normalizedRoomId',\n\t\t\t\t\teventOrigin: EVENT_ORIGIN.LOCAL,\n\t\t\t\t\troomType: RoomType.CHANNEL,\n\t\t\t\t\texternalInviteeId: 'externalInviteeId',\n\t\t\t\t\texternalInviterId: 'externalInviteeId',\n\t\t\t\t\tleave: false,\n\t\t\t\t\tnormalizedInviteeId: 'normalizedInviteeId',\n\t\t\t\t} as any);\n\t\t\t\texpect(roomAdapter.createFederatedRoom.called).to.be.false;\n\t\t\t});\n\t\t\tit('should create the room using the external room name if its original from the same homeserver', async () => {\n\t\t\t\tsinon.stub(service, 'createFederatedUserAndReturnIt').resolves();\n\t\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(undefined);\n\t\t\t\tuserAdapter.getFederatedUserByExternalId.onCall(0).resolves(user);\n\t\t\t\tuserAdapter.getFederatedUserByExternalId.onCall(1).resolves(user);\n\t\t\t\tuserAdapter.getFederatedUserByExternalId.onCall(2).resolves(undefined);\n\t\t\t\tuserAdapter.getFederatedUserByExternalId.onCall(3).resolves(user);\n\t\t\t\tbridge.getRoomData.resolves({ name: 'roomName', creator: { id: '@creatorId:externalserver.com', username: 'creatorUsername' } });\n\t\t\t\tbridge.extractHomeserverOrigin.returns('localDomain');\n\t\t\t\tawait service.onChangeRoomMembership({\n\t\t\t\t\texternalRoomId: 'externalRoomId',\n\t\t\t\t\tnormalizedRoomId: 'normalizedRoomId',\n\t\t\t\t\teventOrigin: EVENT_ORIGIN.LOCAL,\n\t\t\t\t\troomType: RoomType.CHANNEL,\n\t\t\t\t\texternalInviteeId: 'externalInviteeId',\n\t\t\t\t\texternalInviterId: 'externalInviteeId',\n\t\t\t\t\tleave: false,\n\t\t\t\t\tnormalizedInviteeId: 'normalizedInviteeId',\n\t\t\t\t} as any);\n\t\t\t\texpect(\n\t\t\t\t\troomAdapter.createFederatedRoom.calledWith(\n\t\t\t\t\t\tFederatedRoom.createInstance('externalRoomId', 'normalizedRoomId', user, RoomType.CHANNEL, 'roomName'),\n\t\t\t\t\t),\n\t\t\t\t).to.be.true;\n\t\t\t});\n\t\t\tit('should create the room using nothing if its not original from the same homeserver', async () => {\n\t\t\t\tsinon.stub(service, 'createFederatedUserAndReturnIt').resolves();\n\t\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(undefined);\n\t\t\t\tuserAdapter.getFederatedUserByExternalId.onCall(0).resolves(user);\n\t\t\t\tuserAdapter.getFederatedUserByExternalId.onCall(1).resolves(user);\n\t\t\t\tuserAdapter.getFederatedUserByExternalId.onCall(2).resolves(undefined);\n\t\t\t\tuserAdapter.getFederatedUserByExternalId.onCall(3).resolves(user);\n\t\t\t\tbridge.getRoomData.resolves({ name: 'roomName', creator: { id: '@creatorId:externalserver.com', username: 'creatorUsername' } });\n\t\t\t\tbridge.extractHomeserverOrigin.returns('externalDomain');\n\t\t\t\tawait service.onChangeRoomMembership({\n\t\t\t\t\texternalRoomId: 'externalRoomId',\n\t\t\t\t\tnormalizedRoomId: 'normalizedRoomId',\n\t\t\t\t\teventOrigin: EVENT_ORIGIN.LOCAL,\n\t\t\t\t\troomType: RoomType.CHANNEL,\n\t\t\t\t\texternalInviteeId: 'externalInviteeId',\n\t\t\t\t\texternalInviterId: 'externalInviteeId',\n\t\t\t\t\tleave: false,\n\t\t\t\t\tnormalizedInviteeId: 'normalizedInviteeId',\n\t\t\t\t} as any);\n\t\t\t\texpect(\n\t\t\t\t\troomAdapter.createFederatedRoom.calledWith(\n\t\t\t\t\t\tFederatedRoom.createInstance('externalRoomId', 'normalizedRoomId', user, RoomType.CHANNEL, undefined),\n\t\t\t\t\t),\n\t\t\t\t).to.be.true;\n\t\t\t});\n\t\t\tit('should dispatch a room name event if its not from the same homeserver and it was possible to retrieve the name from the bridge query', async () => {\n\t\t\t\tconst spy = sinon.spy(service, 'onChangeRoomName');\n\t\t\t\tsinon.stub(service, 'createFederatedUserAndReturnIt').resolves();\n\t\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(undefined);\n\t\t\t\tuserAdapter.getFederatedUserByExternalId.onCall(0).resolves(user);\n\t\t\t\tuserAdapter.getFederatedUserByExternalId.onCall(1).resolves(user);\n\t\t\t\tuserAdapter.getFederatedUserByExternalId.onCall(2).resolves(undefined);\n\t\t\t\tuserAdapter.getFederatedUserByExternalId.onCall(3).resolves(user);\n\t\t\t\troomAdapter.createFederatedRoom.resolves();\n\t\t\t\tbridge.getRoomData.resolves({ name: 'roomName', creator: { id: '@creatorId:externalserver.com', username: 'creatorUsername' } });\n\t\t\t\tbridge.extractHomeserverOrigin.returns('externalDomain');\n\t\t\t\tawait service.onChangeRoomMembership({\n\t\t\t\t\texternalRoomId: 'externalRoomId',\n\t\t\t\t\tnormalizedRoomId: 'normalizedRoomId',\n\t\t\t\t\teventOrigin: EVENT_ORIGIN.LOCAL,\n\t\t\t\t\troomType: RoomType.CHANNEL,\n\t\t\t\t\texternalInviteeId: 'externalInviteeId',\n\t\t\t\t\texternalInviterId: 'externalInviteeId',\n\t\t\t\t\tleave: false,\n\t\t\t\t\tnormalizedInviteeId: 'normalizedInviteeId',\n\t\t\t\t} as any);\n\t\t\t\texpect(\n\t\t\t\t\tspy.calledWith({\n\t\t\t\t\t\texternalRoomId: 'externalRoomId',\n\t\t\t\t\t\tnormalizedRoomName: 'roomName',\n\t\t\t\t\t\texternalEventId: '',\n\t\t\t\t\t\texternalSenderId: user.getExternalId(),\n\t\t\t\t\t\tnormalizedRoomId: 'normalizedRoomId',\n\t\t\t\t\t}),\n\t\t\t\t).to.be.true;\n\t\t\t});\n\t\t\tit('should create federated users for each member of the room excluding the one joining and the creator, and add them to the room ', async () => {\n\t\t\t\tconst stub = sinon.stub(service, 'createFederatedUserAndReturnIt');\n\t\t\t\troomAdapter.getFederatedRoomByExternalId.onCall(0).resolves(undefined);\n\t\t\t\troomAdapter.getFederatedRoomByExternalId.onCall(1).resolves(undefined);\n\t\t\t\troomAdapter.getFederatedRoomByExternalId.onCall(2).resolves(room);\n\t\t\t\tuserAdapter.getFederatedUserByExternalId.onCall(0).resolves(user);\n\t\t\t\tuserAdapter.getFederatedUserByExternalId.onCall(1).resolves(user);\n\t\t\t\tuserAdapter.getFederatedUserByExternalId.onCall(2).resolves(undefined);\n\t\t\t\tuserAdapter.getFederatedUserByExternalId.onCall(3).resolves(user);\n\t\t\t\tstub.resolves(user);\n\t\t\t\troomAdapter.createFederatedRoom.resolves({});\n\t\t\t\tbridge.getRoomData.resolves({\n\t\t\t\t\tjoinedMembers: ['user1', '@creatorId:externalserver.com', user.getExternalId(), 'user2'],\n\t\t\t\t\tcreator: { id: '@creatorId:externalserver.com', username: 'creatorUsername' },\n\t\t\t\t});\n\t\t\t\tbridge.extractHomeserverOrigin.returns('localDomain');\n\t\t\t\tawait service.onChangeRoomMembership({\n\t\t\t\t\texternalRoomId: 'externalRoomId',\n\t\t\t\t\tnormalizedRoomId: 'normalizedRoomId',\n\t\t\t\t\teventOrigin: EVENT_ORIGIN.LOCAL,\n\t\t\t\t\troomType: RoomType.CHANNEL,\n\t\t\t\t\texternalInviteeId: 'externalInviteeId',\n\t\t\t\t\texternalInviterId: 'externalInviteeId',\n\t\t\t\t\tleave: false,\n\t\t\t\t\tnormalizedInviteeId: 'normalizedInviteeId',\n\t\t\t\t} as any);\n\t\t\t\texpect(stub.callCount).to.be.equal(3);\n\t\t\t\texpect(stub.getCall(1).calledWith('user1')).to.be.true;\n\t\t\t\texpect(stub.getCall(2).calledWith('user2')).to.be.true;\n\t\t\t\texpect(roomAdapter.addUsersToRoomWhenJoinExternalPublicRoom.calledWith([user, user])).to.be.true;\n\t\t\t});\n\t\t\tit('should add the user to the room and subscribe to typings events if everything was done correctly', async () => {\n\t\t\t\tsinon.stub(service, 'createFederatedUserAndReturnIt').resolves(user);\n\t\t\t\troomAdapter.getFederatedRoomByExternalId.onCall(0).resolves(undefined);\n\t\t\t\troomAdapter.getFederatedRoomByExternalId.onCall(1).resolves(undefined);\n\t\t\t\troomAdapter.getFederatedRoomByExternalId.onCall(2).resolves(room);\n\t\t\t\tuserAdapter.getFederatedUserByExternalId.onCall(0).resolves(user);\n\t\t\t\tuserAdapter.getFederatedUserByExternalId.onCall(1).resolves(user);\n\t\t\t\tuserAdapter.getFederatedUserByExternalId.onCall(2).resolves(undefined);\n\t\t\t\tuserAdapter.getFederatedUserByExternalId.onCall(3).resolves(user);\n\t\t\t\troomAdapter.createFederatedRoom.resolves({});\n\t\t\t\tbridge.getRoomData.resolves({\n\t\t\t\t\tjoinedMembers: ['user1', '@creatorId:externalserver.com', user.getExternalId(), 'user2'],\n\t\t\t\t\tcreator: { id: '@creatorId:externalserver.com', username: 'creatorUsername' },\n\t\t\t\t});\n\t\t\t\tbridge.extractHomeserverOrigin.returns('localDomain');\n\t\t\t\tawait service.onChangeRoomMembership({\n\t\t\t\t\texternalRoomId: 'externalRoomId',\n\t\t\t\t\tnormalizedRoomId: 'normalizedRoomId',\n\t\t\t\t\teventOrigin: EVENT_ORIGIN.LOCAL,\n\t\t\t\t\troomType: RoomType.CHANNEL,\n\t\t\t\t\texternalInviteeId: 'externalInviteeId',\n\t\t\t\t\texternalInviterId: 'externalInviteeId',\n\t\t\t\t\tleave: false,\n\t\t\t\t\tnormalizedInviteeId: 'normalizedInviteeId',\n\t\t\t\t} as any);\n\t\t\t\texpect(notificationsAdapter.subscribeToUserTypingEventsOnFederatedRoomId.called).to.be.true;\n\t\t\t\texpect(roomAdapter.addUserToRoom.calledWith(room, user)).to.be.true;\n\t\t\t});\n\t\t});\n\t\tdescribe('User profile changed event', () => {\n\t\t\tit('should NOT call the function to update the user avatar if the event does not include an avatarUrl property', async () => {\n\t\t\t\tconst spy = sinon.spy(service, 'updateUserAvatarInternally');\n\t\t\t\tawait service.onChangeRoomMembership({\n\t\t\t\t\texternalRoomId: 'externalRoomId',\n\t\t\t\t\tnormalizedRoomId: 'normalizedRoomId',\n\t\t\t\t\teventOrigin: EVENT_ORIGIN.LOCAL,\n\t\t\t\t\troomType: RoomType.CHANNEL,\n\t\t\t\t\texternalInviteeId: 'externalInviteeId',\n\t\t\t\t\tleave: false,\n\t\t\t\t\tnormalizedInviteeId: 'normalizedInviteeId',\n\t\t\t\t} as any);\n\t\t\t\texpect(spy.called).to.be.false;\n\t\t\t});\n\t\t\tconst eventForUserProfileChanges = {\n\t\t\t\texternalRoomId: 'externalRoomId',\n\t\t\t\tnormalizedRoomId: 'normalizedRoomId',\n\t\t\t\teventOrigin: EVENT_ORIGIN.LOCAL,\n\t\t\t\troomType: RoomType.CHANNEL,\n\t\t\t\texternalInviteeId: 'externalInviteeId',\n\t\t\t\tleave: false,\n\t\t\t\tnormalizedInviteeId: 'normalizedInviteeId',\n\t\t\t\tuserProfile: {\n\t\t\t\t\tavatarUrl: 'avatarUrl',\n\t\t\t\t\tdisplayName: 'displayName',\n\t\t\t\t},\n\t\t\t} as any;\n\t\t\tit('should NOT call the function to update the avatar internally if the user does not exists', async () => {\n\t\t\t\tconst spy = sinon.spy(service, 'updateUserAvatarInternally');\n\t\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(undefined);\n\t\t\t\tawait service.onChangeRoomMembership(eventForUserProfileChanges);\n\t\t\t\texpect(spy.called).to.be.false;\n\t\t\t});\n\t\t\tit('should NOT update the avatar nor the display name if both does not exists', async () => {\n\t\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(user);\n\t\t\t\tawait service.onChangeRoomMembership({ ...eventForUserProfileChanges, userProfile: {} });\n\t\t\t\texpect(userAdapter.setAvatar.called).to.be.false;\n\t\t\t\texpect(userAdapter.updateFederationAvatar.called).to.be.false;\n\t\t\t\texpect(userAdapter.updateRealName.called).to.be.false;\n\t\t\t});\n\t\t\tit('should NOT update the avatar url nor the display name if the user is from the local home server', async () => {\n\t\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(\n\t\t\t\t\tFederatedUser.createInstance('externalInviterId', {\n\t\t\t\t\t\tname: 'normalizedInviterId',\n\t\t\t\t\t\tusername: 'normalizedInviterId',\n\t\t\t\t\t\texistsOnlyOnProxyServer: true,\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t\tawait service.onChangeRoomMembership(eventForUserProfileChanges);\n\t\t\t\texpect(userAdapter.setAvatar.called).to.be.false;\n\t\t\t\texpect(userAdapter.updateFederationAvatar.called).to.be.false;\n\t\t\t\texpect(userAdapter.updateRealName.called).to.be.false;\n\t\t\t});\n\t\t\tit('should NOT update the avatar url if the url received in the event is equal to the one already used', async () => {\n\t\t\t\tconst existsOnlyOnProxyServer = false;\n\t\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(\n\t\t\t\t\tFederatedUser.createWithInternalReference('externalInviterId', existsOnlyOnProxyServer, {\n\t\t\t\t\t\tfederation: {\n\t\t\t\t\t\t\tavatarUrl: 'avatarUrl',\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t\tawait service.onChangeRoomMembership({ ...eventForUserProfileChanges, userProfile: { avatarUrl: 'avatarUrl' } });\n\t\t\t\texpect(userAdapter.setAvatar.called).to.be.false;\n\t\t\t\texpect(userAdapter.updateFederationAvatar.called).to.be.false;\n\t\t\t});\n\t\t\tit('should call the functions to update the avatar internally correctly', async () => {\n\t\t\t\tconst existsOnlyOnProxyServer = false;\n\t\t\t\tconst userAvatar = FederatedUser.createWithInternalReference('externalInviterId', existsOnlyOnProxyServer, {\n\t\t\t\t\tfederation: {\n\t\t\t\t\t\tavatarUrl: 'currentAvatarUrl',\n\t\t\t\t\t},\n\t\t\t\t\t_id: 'userId',\n\t\t\t\t});\n\t\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(userAvatar);\n\t\t\t\tawait service.onChangeRoomMembership(eventForUserProfileChanges);\n\t\t\t\texpect(userAdapter.setAvatar.calledWith(userAvatar, 'toHttpUrl')).to.be.true;\n\t\t\t\texpect(userAdapter.updateFederationAvatar.calledWith(userAvatar.getInternalId(), 'avatarUrl')).to.be.true;\n\t\t\t});\n\t\t\tit('should NOT update the display name if the name received in the event is equal to the one already used', async () => {\n\t\t\t\tconst existsOnlyOnProxyServer = false;\n\t\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(\n\t\t\t\t\tFederatedUser.createWithInternalReference('externalInviterId', existsOnlyOnProxyServer, {\n\t\t\t\t\t\tname: 'displayName',\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t\tawait service.onChangeRoomMembership({ ...eventForUserProfileChanges, userProfile: { displayName: 'displayName' } });\n\t\t\t\texpect(userAdapter.setAvatar.called).to.be.false;\n\t\t\t\texpect(userAdapter.updateFederationAvatar.called).to.be.false;\n\t\t\t\texpect(userAdapter.updateRealName.called).to.be.false;\n\t\t\t});\n\t\t\tit('should call the functions to update the display name internally correctly', async () => {\n\t\t\t\tconst existsOnlyOnProxyServer = false;\n\t\t\t\tconst user = FederatedUser.createWithInternalReference('externalInviterId', existsOnlyOnProxyServer, {\n\t\t\t\t\t_id: 'userId',\n\t\t\t\t\tname: 'currentName',\n\t\t\t\t});\n\t\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(user);\n\t\t\t\tawait service.onChangeRoomMembership({ ...eventForUserProfileChanges, userProfile: { displayName: 'displayName' } });\n\t\t\t\texpect(userAdapter.setAvatar.called).to.be.false;\n\t\t\t\texpect(userAdapter.updateFederationAvatar.called).to.be.false;\n\t\t\t\texpect(userAdapter.updateRealName.calledWith(user.getInternalReference(), 'displayName')).to.be.true;\n\t\t\t});\n\t\t});\n\t});\n\tdescribe('#onExternalFileMessageReceived()', () => {\n\t\tconst user = FederatedUser.createInstance('externalInviterId', {\n\t\t\tname: 'normalizedInviterId',\n\t\t\tusername: 'normalizedInviterId',\n\t\t\texistsOnlyOnProxyServer: false,\n\t\t});\n\t\tconst room = FederatedRoom.createInstance('externalRoomId', 'normalizedRoomId', user, RoomType.CHANNEL, 'externalRoomName');\n\t\tit('should NOT send a message if the room does not exists', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(undefined);\n\t\t\tawait service.onExternalFileMessageReceived({\n\t\t\t\tmessageText: 'text',\n\t\t\t} as any);\n\t\t\texpect(messageAdapter.sendFileMessage.called).to.be.false;\n\t\t});\n\t\tit('should NOT send a message if the sender does not exists', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves({} as any);\n\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(undefined);\n\t\t\tawait service.onExternalFileMessageReceived({\n\t\t\t\tmessageText: 'text',\n\t\t\t} as any);\n\t\t\texpect(messageAdapter.sendFileMessage.called).to.be.false;\n\t\t});\n\t\tit('should send a message if the room and the sender already exists', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(user);\n\t\t\tbridge.getReadStreamForFileFromUrl.resolves();\n\t\t\tconst files = [{ id: 'fileId', name: 'filename' }];\n\t\t\tconst attachments = ['attachment', 'attachment2'];\n\t\t\tfileAdapter.uploadFile.resolves({ files, attachments } as any);\n\t\t\tawait service.onExternalFileMessageReceived({\n\t\t\t\tmessageBody: {\n\t\t\t\t\tfilename: 'filename',\n\t\t\t\t\tsize: 12,\n\t\t\t\t\tmimetype: 'mimetype',\n\t\t\t\t\turl: 'url',\n\t\t\t\t},\n\t\t\t} as any);\n\t\t\texpect(messageAdapter.sendFileMessage.calledWith(user, room, files, attachments)).to.be.true;\n\t\t});\n\t\tdescribe('Quoting messages', () => {\n\t\t\tit('should NOT send a quote message if its necessary to quote but the message to quote does not exists', async () => {\n\t\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(user);\n\t\t\t\tmessageAdapter.getMessageByFederationId.resolves(undefined);\n\t\t\t\tfileAdapter.uploadFile.resolves({} as any);\n\t\t\t\tawait service.onExternalFileMessageReceived({\n\t\t\t\t\tmessageBody: {\n\t\t\t\t\t\tfilename: 'filename',\n\t\t\t\t\t\tsize: 12,\n\t\t\t\t\t\tmimetype: 'mimetype',\n\t\t\t\t\t\turl: 'url',\n\t\t\t\t\t},\n\t\t\t\t\treplyToEventId: 'replyToEventId',\n\t\t\t\t} as any);\n\t\t\t\texpect(messageAdapter.sendQuoteFileMessage.called).to.be.false;\n\t\t\t\texpect(messageAdapter.sendFileMessage.called).to.be.false;\n\t\t\t});\n\t\t\tit('should send a quote message if its necessary to quote and the message to quote exists', async () => {\n\t\t\t\tconst messageToReplyTo = { federation: { eventId: 'eventId' } } as any;\n\t\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(user);\n\t\t\t\tmessageAdapter.getMessageByFederationId.onFirstCall().resolves(undefined);\n\t\t\t\tmessageAdapter.getMessageByFederationId.onSecondCall().resolves(messageToReplyTo);\n\t\t\t\tconst files = [{ id: 'fileId', name: 'filename' }];\n\t\t\t\tconst attachments = ['attachment', 'attachment2'];\n\t\t\t\tfileAdapter.uploadFile.resolves({ files, attachments } as any);\n\t\t\t\tawait service.onExternalFileMessageReceived({\n\t\t\t\t\tmessageBody: {\n\t\t\t\t\t\tfilename: 'filename',\n\t\t\t\t\t\tsize: 12,\n\t\t\t\t\t\tmimetype: 'mimetype',\n\t\t\t\t\t\turl: 'url',\n\t\t\t\t\t},\n\t\t\t\t\treplyToEventId: 'replyToEventId',\n\t\t\t\t\texternalEventId: 'externalEventId',\n\t\t\t\t} as any);\n\t\t\t\texpect(\n\t\t\t\t\tmessageAdapter.sendQuoteFileMessage.calledWith(\n\t\t\t\t\t\tuser,\n\t\t\t\t\t\troom,\n\t\t\t\t\t\tfiles,\n\t\t\t\t\t\tattachments,\n\t\t\t\t\t\t'externalEventId',\n\t\t\t\t\t\tmessageToReplyTo,\n\t\t\t\t\t\t'localDomain',\n\t\t\t\t\t),\n\t\t\t\t).to.be.true;\n\t\t\t\texpect(messageAdapter.sendFileMessage.called).to.be.false;\n\t\t\t});\n\t\t});\n\t});\n\tdescribe('#onExternalMessageReceived()', () => {\n\t\tit('should NOT send a message if the room does not exists', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(undefined);\n\t\t\tawait service.onExternalMessageReceived({\n\t\t\t\tmessageText: 'text',\n\t\t\t} as any);\n\t\t\texpect(messageAdapter.sendMessage.called).to.be.false;\n\t\t});\n\t\tit('should NOT send a message if the sender does not exists', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves({} as any);\n\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(undefined);\n\t\t\tawait service.onExternalMessageReceived({\n\t\t\t\tmessageText: 'text',\n\t\t\t} as any);\n\t\t\texpect(messageAdapter.sendMessage.called).to.be.false;\n\t\t});\n\t\tit('should NOT send a message if the message was already be sent through federation and is just a reply back event', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves({} as any);\n\t\t\tuserAdapter.getFederatedUserByExternalId.resolves({} as any);\n\t\t\tmessageAdapter.getMessageByFederationId.resolves({} as any);\n\t\t\tawait service.onExternalMessageReceived({\n\t\t\t\tmessageText: 'text',\n\t\t\t} as any);\n\t\t\texpect(messageAdapter.sendMessage.called).to.be.false;\n\t\t});\n\t\tit('should send a message if the room, the sender already exists and the message does not exists, because it was sent originally from Matrix', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves({} as any);\n\t\t\tuserAdapter.getFederatedUserByExternalId.resolves({} as any);\n\t\t\tmessageAdapter.getMessageByFederationId.resolves(undefined);\n\t\t\tawait service.onExternalMessageReceived({\n\t\t\t\tmessageText: 'text',\n\t\t\t\trawMessage: 'rawMessage',\n\t\t\t\texternalFormattedText: 'externalFormattedText',\n\t\t\t\texternalEventId: 'externalEventId',\n\t\t\t} as any);\n\t\t\texpect(messageAdapter.sendMessage.calledWith({}, {}, 'rawMessage', 'externalFormattedText', 'externalEventId', 'localDomain')).to.be\n\t\t\t\t.true;\n\t\t\texpect(messageAdapter.sendQuoteMessage.called).to.be.false;\n\t\t});\n\t\tdescribe('Quoting messages', () => {\n\t\t\tit('should NOT send a quote message if its necessary to quote but the message to quote does not exists', async () => {\n\t\t\t\troomAdapter.getFederatedRoomByExternalId.resolves({} as any);\n\t\t\t\tuserAdapter.getFederatedUserByExternalId.resolves({} as any);\n\t\t\t\tmessageAdapter.getMessageByFederationId.resolves(undefined);\n\t\t\t\tawait service.onExternalMessageReceived({\n\t\t\t\t\tmessageText: 'text',\n\t\t\t\t\treplyToEventId: 'replyToEventId',\n\t\t\t\t} as any);\n\t\t\t\texpect(messageAdapter.sendQuoteMessage.called).to.be.false;\n\t\t\t\texpect(messageAdapter.sendMessage.called).to.be.false;\n\t\t\t});\n\t\t\tit('should send a quote message if its necessary to quote and the message to quote exists', async () => {\n\t\t\t\troomAdapter.getFederatedRoomByExternalId.resolves({} as any);\n\t\t\t\tuserAdapter.getFederatedUserByExternalId.resolves({} as any);\n\t\t\t\tmessageAdapter.getMessageByFederationId.onFirstCall().resolves(undefined);\n\t\t\t\tmessageAdapter.getMessageByFederationId.onSecondCall().resolves({} as any);\n\t\t\t\tawait service.onExternalMessageReceived({\n\t\t\t\t\tmessageText: 'text',\n\t\t\t\t\texternalEventId: 'externalEventId',\n\t\t\t\t\treplyToEventId: 'replyToEventId',\n\t\t\t\t\trawMessage: 'rawMessage',\n\t\t\t\t\texternalFormattedText: 'externalFormattedText',\n\t\t\t\t} as any);\n\t\t\t\texpect(\n\t\t\t\t\tmessageAdapter.sendQuoteMessage.calledWith({}, {}, 'externalFormattedText', 'rawMessage', 'externalEventId', {}, 'localDomain'),\n\t\t\t\t).to.be.true;\n\t\t\t\texpect(messageAdapter.sendMessage.called).to.be.false;\n\t\t\t});\n\t\t});\n\t});\n\tdescribe('#onChangeJoinRules()', () => {\n\t\tconst user = FederatedUser.createInstance('externalInviterId', {\n\t\t\tname: 'normalizedInviterId',\n\t\t\tusername: 'normalizedInviterId',\n\t\t\texistsOnlyOnProxyServer: false,\n\t\t});\n\t\tconst room = FederatedRoom.createInstance('externalRoomId', 'normalizedRoomId', user, RoomType.CHANNEL, 'externalRoomName');\n\t\tit('should NOT change the room type if the room does not exists', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(undefined);\n\t\t\tawait service.onChangeJoinRules({\n\t\t\t\troomType: RoomType.CHANNEL,\n\t\t\t} as any);\n\t\t\texpect(roomAdapter.updateRoomType.called).to.be.false;\n\t\t});\n\t\tit('should NOT change the room type if it exists and is a direct message', async () => {\n\t\t\tconst dmRoom = DirectMessageFederatedRoom.createInstance('externalRoomId', user, [user, user]);\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(dmRoom);\n\t\t\tawait service.onChangeJoinRules({\n\t\t\t\troomType: RoomType.CHANNEL,\n\t\t\t} as any);\n\t\t\texpect(roomAdapter.updateRoomType.called).to.be.false;\n\t\t});\n\t\tit('should change the room type if it exists and is NOT a direct message', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\tawait service.onChangeJoinRules({\n\t\t\t\troomType: RoomType.PRIVATE_GROUP,\n\t\t\t} as any);\n\t\t\troom.changeRoomType(RoomType.PRIVATE_GROUP);\n\t\t\texpect(roomAdapter.updateRoomType.calledWith(room)).to.be.true;\n\t\t});\n\t});\n\tdescribe('#onChangeRoomName()', () => {\n\t\tconst user = FederatedUser.createInstance('externalInviterId', {\n\t\t\tname: 'normalizedInviterId',\n\t\t\tusername: 'normalizedInviterId',\n\t\t\texistsOnlyOnProxyServer: false,\n\t\t});\n\t\tconst room = FederatedRoom.createInstance('externalRoomId', 'normalizedRoomId', user, RoomType.CHANNEL, 'externalRoomName');\n\t\tit('should NOT change the room name if the room does not exists', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(undefined);\n\t\t\tawait service.onChangeRoomName({\n\t\t\t\tnormalizedRoomName: 'normalizedRoomName',\n\t\t\t} as any);\n\t\t\texpect(roomAdapter.updateRoomName.called).to.be.false;\n\t\t\texpect(roomAdapter.updateDisplayRoomName.called).to.be.false;\n\t\t});\n\t\tit('should NOT change the room name if the user does not exists', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(undefined);\n\t\t\tawait service.onChangeRoomName({\n\t\t\t\tnormalizedRoomName: 'normalizedRoomName',\n\t\t\t} as any);\n\t\t\texpect(roomAdapter.updateRoomName.called).to.be.false;\n\t\t\texpect(roomAdapter.updateDisplayRoomName.called).to.be.false;\n\t\t});\n\t\tit('should NOT change the room name if the room is an internal room', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(user);\n\t\t\tbridge.extractHomeserverOrigin.returns('localDomain');\n\t\t\tawait service.onChangeRoomName({\n\t\t\t\texternalRoomId: '!externalRoomId:localDomain',\n\t\t\t\tnormalizedRoomName: 'normalizedRoomName',\n\t\t\t} as any);\n\t\t\texpect(roomAdapter.updateRoomName.called).to.be.false;\n\t\t});\n\t\tit('should change the room name if the room is NOT an internal room', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(user);\n\t\t\tbridge.extractHomeserverOrigin.returns('externalDomain');\n\t\t\tawait service.onChangeRoomName({\n\t\t\t\texternalRoomId: '!externalRoomId:externalDomain',\n\t\t\t\tnormalizedRoomName: 'normalizedRoomName',\n\t\t\t} as any);\n\t\t\troom.changeRoomName('!externalRoomId:externalDomain');\n\t\t\texpect(roomAdapter.updateRoomName.calledWith(room)).to.be.true;\n\t\t});\n\t\tit('should NOT change the room fname if it exists and is a direct message', async () => {\n\t\t\tconst dmRoom = DirectMessageFederatedRoom.createInstance('externalRoomId', user, [user, user]);\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(dmRoom);\n\t\t\tawait service.onChangeRoomName({\n\t\t\t\tnormalizedRoomName: 'normalizedRoomName',\n\t\t\t} as any);\n\t\t\texpect(roomAdapter.updateDisplayRoomName.called).to.be.false;\n\t\t});\n\t\tit('should change the room fname if it exists and is NOT a direct message', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(user);\n\t\t\tawait service.onChangeRoomName({\n\t\t\t\tnormalizedRoomName: 'normalizedRoomName2',\n\t\t\t} as any);\n\t\t\troom.changeDisplayRoomName('normalizedRoomName2');\n\t\t\texpect(roomAdapter.updateDisplayRoomName.calledWith(room, user)).to.be.true;\n\t\t});\n\t});\n\tdescribe('#onChangeRoomTopic()', () => {\n\t\tconst user = FederatedUser.createInstance('externalInviterId', {\n\t\t\tname: 'normalizedInviterId',\n\t\t\tusername: 'normalizedInviterId',\n\t\t\texistsOnlyOnProxyServer: false,\n\t\t});\n\t\tconst room = FederatedRoom.createInstance('externalRoomId', 'normalizedRoomId', user, RoomType.CHANNEL, 'externalRoomName');\n\t\tit('should NOT change the room topic if the room does not exists', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(undefined);\n\t\t\tawait service.onChangeRoomTopic({\n\t\t\t\troomTopic: 'roomTopic',\n\t\t\t} as any);\n\t\t\texpect(roomAdapter.updateRoomTopic.called).to.be.false;\n\t\t});\n\t\tit('should NOT change the room topic if it exists and is a direct message', async () => {\n\t\t\tconst dmRoom = DirectMessageFederatedRoom.createInstance('externalRoomId', user, [user, user]);\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(dmRoom);\n\t\t\tawait service.onChangeRoomTopic({\n\t\t\t\troomTopic: 'roomTopic',\n\t\t\t} as any);\n\t\t\texpect(roomAdapter.updateRoomTopic.called).to.be.false;\n\t\t});\n\t\tit('should change the room topic if it exists and is NOT a direct message', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(user);\n\t\t\tawait service.onChangeRoomTopic({\n\t\t\t\troomTopic: 'roomTopic',\n\t\t\t} as any);\n\t\t\troom.changeRoomTopic('roomTopic');\n\t\t\texpect(roomAdapter.updateRoomTopic.calledWith(room, user)).to.be.true;\n\t\t});\n\t});\n\tdescribe('#onRedactEvent()', () => {\n\t\tconst user = FederatedUser.createInstance('externalInviterId', {\n\t\t\tname: 'normalizedInviterId',\n\t\t\tusername: 'normalizedInviterId',\n\t\t\texistsOnlyOnProxyServer: false,\n\t\t});\n\t\tconst room = FederatedRoom.createInstance('externalRoomId', 'normalizedRoomId', user, RoomType.CHANNEL, 'externalRoomName');\n\t\tit('should NOT delete the message if the room does not exists', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(undefined);\n\t\t\tawait service.onRedactEvent({\n\t\t\t\tredactsEvent: 'redactsEvent',\n\t\t\t} as any);\n\t\t\texpect(messageAdapter.deleteMessage.called).to.be.false;\n\t\t\texpect(messageAdapter.unreactToMessage.called).to.be.false;\n\t\t});\n\t\tit('should NOT delete the message if the sender does not exists', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(undefined);\n\t\t\tawait service.onRedactEvent({\n\t\t\t\tredactsEvent: 'redactsEvent',\n\t\t\t} as any);\n\t\t\texpect(messageAdapter.deleteMessage.called).to.be.false;\n\t\t\texpect(messageAdapter.unreactToMessage.called).to.be.false;\n\t\t});\n\t\tit('should NOT delete the message if the message does not exists', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(user);\n\t\t\tmessageAdapter.getMessageByFederationId.resolves(undefined);\n\t\t\tawait service.onRedactEvent({\n\t\t\t\tredactsEvent: 'redactsEvent',\n\t\t\t} as any);\n\t\t\texpect(messageAdapter.deleteMessage.called).to.be.false;\n\t\t\texpect(messageAdapter.unreactToMessage.called).to.be.false;\n\t\t});\n\t\tit('should delete the message if its a raw text redact handler', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(user);\n\t\t\tmessageAdapter.getMessageByFederationId.resolves({ msg: 'msg' });\n\t\t\tmessageAdapter.findOneByFederationIdOnReactions.resolves(undefined);\n\t\t\tawait service.onRedactEvent({\n\t\t\t\tredactsEvent: 'redactsEvent',\n\t\t\t} as any);\n\t\t\texpect(messageAdapter.deleteMessage.calledWith({ msg: 'msg' }, user)).to.be.true;\n\t\t\texpect(messageAdapter.unreactToMessage.called).to.be.false;\n\t\t});\n\t\tit('should NOT unreact if the message was not reacted before by the user', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(user);\n\t\t\tmessageAdapter.getMessageByFederationId.resolves(undefined);\n\t\t\tmessageAdapter.findOneByFederationIdOnReactions.resolves({\n\t\t\t\tmsg: 'msg',\n\t\t\t\treactions: {\n\t\t\t\t\treaction: {\n\t\t\t\t\t\tfederationReactionEventIds: {},\n\t\t\t\t\t\tusernames: [],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t});\n\t\t\tawait service.onRedactEvent({\n\t\t\t\tredactsEvent: 'redactsEvent',\n\t\t\t} as any);\n\t\t\texpect(messageAdapter.deleteMessage.called).to.be.false;\n\t\t\texpect(messageAdapter.unreactToMessage.called).to.be.false;\n\t\t});\n\t\tit('should unreact if the message was reacted before by the user', async () => {\n\t\t\tconst message = {\n\t\t\t\tmsg: 'msg',\n\t\t\t\treactions: {\n\t\t\t\t\treaction: {\n\t\t\t\t\t\tfederationReactionEventIds: {\n\t\t\t\t\t\t\tredactsEvent: user.getUsername(),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tusernames: [user.getUsername()],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t};\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(user);\n\t\t\tmessageAdapter.getMessageByFederationId.resolves(undefined);\n\t\t\tmessageAdapter.findOneByFederationIdOnReactions.resolves(message);\n\t\t\tawait service.onRedactEvent({\n\t\t\t\tredactsEvent: 'redactsEvent',\n\t\t\t} as any);\n\t\t\texpect(messageAdapter.deleteMessage.called).to.be.false;\n\t\t\texpect(messageAdapter.unreactToMessage.calledWith(user, message, 'reaction', 'redactsEvent')).to.be.true;\n\t\t});\n\t});\n\tdescribe('#onExternalMessageEditedReceived()', () => {\n\t\tconst user = FederatedUser.createInstance('externalInviterId', {\n\t\t\tname: 'normalizedInviterId',\n\t\t\tusername: 'normalizedInviterId',\n\t\t\texistsOnlyOnProxyServer: false,\n\t\t});\n\t\tconst room = FederatedRoom.createInstance('externalRoomId', 'normalizedRoomId', user, RoomType.CHANNEL, 'externalRoomName');\n\t\tit('should NOT update the message if the room does not exists', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(undefined);\n\t\t\tawait service.onExternalMessageEditedReceived({\n\t\t\t\teditsEvent: 'editsEvent',\n\t\t\t} as any);\n\t\t\texpect(messageAdapter.editMessage.called).to.be.false;\n\t\t});\n\t\tit('should NOT update the message if the sender does not exists', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(undefined);\n\t\t\tawait service.onExternalMessageEditedReceived({\n\t\t\t\teditsEvent: 'editsEvent',\n\t\t\t} as any);\n\t\t\texpect(messageAdapter.editMessage.called).to.be.false;\n\t\t});\n\t\tit('should NOT update the message if the message does not exists', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(user);\n\t\t\tmessageAdapter.getMessageByFederationId.resolves(undefined);\n\t\t\tawait service.onExternalMessageEditedReceived({\n\t\t\t\teditsEvent: 'editsEvent',\n\t\t\t} as any);\n\t\t\texpect(messageAdapter.editMessage.called).to.be.false;\n\t\t});\n\t\tit('should NOT update the message if the content of the message is equal of the oldest one', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(user);\n\t\t\tmessageAdapter.getMessageByFederationId.resolves({ msg: 'newRawMessage' });\n\t\t\tawait service.onExternalMessageEditedReceived({\n\t\t\t\teditsEvent: 'editsEvent',\n\t\t\t\tnewRawMessage: 'newRawMessage',\n\t\t\t} as any);\n\t\t\texpect(messageAdapter.editMessage.called).to.be.false;\n\t\t});\n\t\tit('should update the message', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(user);\n\t\t\tmessageAdapter.getMessageByFederationId.resolves({ msg: 'differentOne' });\n\t\t\tawait service.onExternalMessageEditedReceived({\n\t\t\t\teditsEvent: 'editsEvent',\n\t\t\t\tnewMessageText: 'newMessageText',\n\t\t\t\tnewRawMessage: 'newRawMessage',\n\t\t\t\tnewExternalFormattedText: 'newExternalFormattedText',\n\t\t\t} as any);\n\t\t\texpect(\n\t\t\t\tmessageAdapter.editMessage.calledWith(user, 'newRawMessage', 'newExternalFormattedText', { msg: 'differentOne' }, 'localDomain'),\n\t\t\t).to.be.true;\n\t\t});\n\t\tdescribe('Editing quoted messages', () => {\n\t\t\tit('should NOT edit the quoted message if the event was generated locally (the message edited was on local server only)', async () => {\n\t\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(user);\n\t\t\t\tmessageAdapter.getMessageByFederationId.resolves({ msg: 'differentOne', attachments: [{ message_link: 'link' }] });\n\t\t\t\tbridge.extractHomeserverOrigin.returns('localDomain');\n\t\t\t\tawait service.onExternalMessageEditedReceived({\n\t\t\t\t\teditsEvent: 'editsEvent',\n\t\t\t\t\tnewMessageText: 'newMessageText',\n\t\t\t\t\tnewRawMessage: 'newRawMessage',\n\t\t\t\t\tnewExternalFormattedText: 'newExternalFormattedText',\n\t\t\t\t\texternalSenderId: 'externalSenderId:localDomain',\n\t\t\t\t} as any);\n\t\t\t\texpect(messageAdapter.editMessage.called).to.be.false;\n\t\t\t\texpect(messageAdapter.editQuotedMessage.called).to.be.false;\n\t\t\t});\n\t\t\tit('should NOT edit the quoted message if the event was remotely generated but the message content is the same as the current one (the message is already up to date)', async () => {\n\t\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(user);\n\t\t\t\tmessageAdapter.getMessageByFederationId.resolves({\n\t\t\t\t\tmsg: 'internalFormattedMessageToBeEdited',\n\t\t\t\t\tattachments: [{ message_link: 'link' }],\n\t\t\t\t});\n\t\t\t\tbridge.extractHomeserverOrigin.returns('externalDomain');\n\t\t\t\tmessageAdapter.getMessageToEditWhenReplyAndQuote.resolves('internalFormattedMessageToBeEdited');\n\t\t\t\tawait service.onExternalMessageEditedReceived({\n\t\t\t\t\teditsEvent: 'editsEvent',\n\t\t\t\t\tnewMessageText: 'newMessageText',\n\t\t\t\t\tnewRawMessage: 'newRawMessage',\n\t\t\t\t\tnewExternalFormattedText: 'newExternalFormattedText',\n\t\t\t\t\texternalSenderId: 'externalSenderId:externalDomain',\n\t\t\t\t} as any);\n\t\t\t\texpect(messageAdapter.editMessage.called).to.be.false;\n\t\t\t\texpect(messageAdapter.editQuotedMessage.called).to.be.false;\n\t\t\t});\n\t\t\tit('should edit the quoted message if the event was remotely the message content is outdated', async () => {\n\t\t\t\tconst message = {\n\t\t\t\t\tmsg: 'differentOne',\n\t\t\t\t\tattachments: [{ message_link: 'link' }],\n\t\t\t\t};\n\t\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(user);\n\t\t\t\tmessageAdapter.getMessageByFederationId.resolves(message);\n\t\t\t\tbridge.extractHomeserverOrigin.returns('externalDomain');\n\t\t\t\tmessageAdapter.getMessageToEditWhenReplyAndQuote.resolves('internalFormattedMessageToBeEdited');\n\t\t\t\tawait service.onExternalMessageEditedReceived({\n\t\t\t\t\teditsEvent: 'editsEvent',\n\t\t\t\t\tnewMessageText: 'newMessageText',\n\t\t\t\t\tnewRawMessage: 'newRawMessage',\n\t\t\t\t\tnewExternalFormattedText: 'newExternalFormattedText',\n\t\t\t\t\texternalSenderId: 'externalSenderId:externalDomain',\n\t\t\t\t} as any);\n\t\t\t\texpect(messageAdapter.editMessage.called).to.be.false;\n\t\t\t\texpect(messageAdapter.editQuotedMessage.calledWith(user, 'newRawMessage', 'newExternalFormattedText', message, 'localDomain')).to.be\n\t\t\t\t\t.true;\n\t\t\t});\n\t\t});\n\t});\n\tdescribe('#onChangeRoomPowerLevels()', () => {\n\t\tconst user = FederatedUser.createInstance('externalUserId', {\n\t\t\tname: 'normalizedInviterId',\n\t\t\tusername: 'normalizedInviterId',\n\t\t\texistsOnlyOnProxyServer: false,\n\t\t});\n\t\tconst room = FederatedRoom.createInstance('externalRoomId', 'normalizedRoomId', user, RoomType.CHANNEL, 'externalRoomName');\n\t\tit('should NOT update the room roles if the room does not exists', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(undefined);\n\t\t\tawait service.onChangeRoomPowerLevels({\n\t\t\t\texternalRoomId: 'externalRoomId',\n\t\t\t\texternalSenderId: 'externalSenderId',\n\t\t\t\trolesChangesToApply: [],\n\t\t\t} as any);\n\t\t\texpect(roomAdapter.applyRoomRolesToUser.called).to.be.false;\n\t\t});\n\t\tit('should NOT update the room roles if the user does not exists', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(undefined);\n\t\t\tawait service.onChangeRoomPowerLevels({\n\t\t\t\texternalRoomId: 'externalRoomId',\n\t\t\t\texternalSenderId: 'externalSenderId',\n\t\t\t\trolesChangesToApply: [],\n\t\t\t} as any);\n\t\t\texpect(roomAdapter.applyRoomRolesToUser.called).to.be.false;\n\t\t});\n\t\tit('should NOT update the room roles if there is no target users', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(user);\n\t\t\tuserAdapter.getFederatedUsersByExternalIds.resolves([]);\n\t\t\tawait service.onChangeRoomPowerLevels({\n\t\t\t\texternalRoomId: 'externalRoomId',\n\t\t\t\texternalSenderId: 'externalSenderId',\n\t\t\t\trolesChangesToApply: [],\n\t\t\t} as any);\n\t\t\texpect(roomAdapter.applyRoomRolesToUser.called).to.be.false;\n\t\t});\n\t\tit('should update the room roles adding one role to be added', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(user);\n\t\t\tuserAdapter.getFederatedUsersByExternalIds.resolves([user]);\n\t\t\tawait service.onChangeRoomPowerLevels({\n\t\t\t\texternalRoomId: 'externalRoomId',\n\t\t\t\texternalSenderId: 'externalSenderId',\n\t\t\t\troleChangesToApply: {\n\t\t\t\t\texternalUserId: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taction: 'add',\n\t\t\t\t\t\t\trole: 'owner',\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t},\n\t\t\t} as any);\n\t\t\texpect(\n\t\t\t\troomAdapter.applyRoomRolesToUser.calledWith({\n\t\t\t\t\tfederatedRoom: room,\n\t\t\t\t\ttargetFederatedUser: user,\n\t\t\t\t\tfromUser: user,\n\t\t\t\t\trolesToAdd: ['owner'],\n\t\t\t\t\trolesToRemove: [],\n\t\t\t\t\tnotifyChannel: true,\n\t\t\t\t}),\n\t\t\t).to.be.true;\n\t\t});\n\t\tit('should update the room roles adding one role to be removed', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(user);\n\t\t\tuserAdapter.getFederatedUsersByExternalIds.resolves([user]);\n\t\t\tawait service.onChangeRoomPowerLevels({\n\t\t\t\texternalRoomId: 'externalRoomId',\n\t\t\t\texternalSenderId: 'externalSenderId',\n\t\t\t\troleChangesToApply: {\n\t\t\t\t\texternalUserId: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taction: 'remove',\n\t\t\t\t\t\t\trole: 'owner',\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t},\n\t\t\t} as any);\n\t\t\texpect(\n\t\t\t\troomAdapter.applyRoomRolesToUser.calledWith({\n\t\t\t\t\tfederatedRoom: room,\n\t\t\t\t\ttargetFederatedUser: user,\n\t\t\t\t\tfromUser: user,\n\t\t\t\t\trolesToAdd: [],\n\t\t\t\t\trolesToRemove: ['owner'],\n\t\t\t\t\tnotifyChannel: true,\n\t\t\t\t}),\n\t\t\t).to.be.true;\n\t\t});\n\t});\n\tdescribe('#onExternalThreadedMessageReceived()', () => {\n\t\tit('should NOT send a message if the thread root event id does not exist', async () => {\n\t\t\tawait service.onExternalThreadedMessageReceived({\n\t\t\t\trawMessage: 'text',\n\t\t\t} as any);\n\t\t\texpect(messageAdapter.sendThreadMessage.called).to.be.false;\n\t\t\texpect(messageAdapter.sendThreadQuoteMessage.called).to.be.false;\n\t\t});\n\t\tit('should NOT send a message if the internal thread parent message does not exist', async () => {\n\t\t\tmessageAdapter.getMessageByFederationId.resolves(undefined);\n\t\t\tawait service.onExternalThreadedMessageReceived({\n\t\t\t\trawMessage: 'text',\n\t\t\t\tthread: { rootEventId: 'rootEventId' },\n\t\t\t} as any);\n\t\t\texpect(messageAdapter.sendThreadMessage.called).to.be.false;\n\t\t\texpect(messageAdapter.sendThreadQuoteMessage.called).to.be.false;\n\t\t});\n\t\tit('should NOT send a message if the room does not exists', async () => {\n\t\t\tmessageAdapter.getMessageByFederationId.resolves({});\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(undefined);\n\t\t\tawait service.onExternalThreadedMessageReceived({\n\t\t\t\trawMessage: 'text',\n\t\t\t\tthread: { rootEventId: 'rootEventId' },\n\t\t\t} as any);\n\t\t\texpect(messageAdapter.sendThreadQuoteMessage.called).to.be.false;\n\t\t\texpect(messageAdapter.sendThreadMessage.called).to.be.false;\n\t\t});\n\t\tit('should NOT send a message if the sender does not exists', async () => {\n\t\t\tmessageAdapter.getMessageByFederationId.resolves({});\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves({} as any);\n\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(undefined);\n\t\t\tawait service.onExternalThreadedMessageReceived({\n\t\t\t\trawMessage: 'text',\n\t\t\t\tthread: { rootEventId: 'rootEventId' },\n\t\t\t} as any);\n\t\t\texpect(messageAdapter.sendThreadQuoteMessage.called).to.be.false;\n\t\t\texpect(messageAdapter.sendThreadMessage.called).to.be.false;\n\t\t});\n\t\tit('should NOT send a message if the message was already be sent through federation and is just a reply back event', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves({} as any);\n\t\t\tuserAdapter.getFederatedUserByExternalId.resolves({} as any);\n\t\t\tmessageAdapter.getMessageByFederationId.resolves({} as any);\n\t\t\tawait service.onExternalThreadedMessageReceived({\n\t\t\t\tmessageText: 'text',\n\t\t\t\tthread: { rootEventId: 'rootEventId' },\n\t\t\t} as any);\n\t\t\texpect(messageAdapter.sendThreadQuoteMessage.called).to.be.false;\n\t\t\texpect(messageAdapter.sendThreadMessage.called).to.be.false;\n\t\t});\n\t\tit('should send a message if the room, the sender already exists and the message does not exists, because it was sent originally from Matrix', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves({} as any);\n\t\t\tuserAdapter.getFederatedUserByExternalId.resolves({} as any);\n\t\t\tmessageAdapter.getMessageByFederationId.onFirstCall().resolves({ _id: 'messageThreadId' });\n\t\t\troomAdapter.getFederatedRoomByExternalId.onSecondCall().resolves(undefined);\n\t\t\tawait service.onExternalThreadedMessageReceived({\n\t\t\t\tmessageText: 'text',\n\t\t\t\trawMessage: 'rawMessage',\n\t\t\t\texternalFormattedText: 'externalFormattedText',\n\t\t\t\texternalEventId: 'externalEventId',\n\t\t\t\tthread: { rootEventId: 'rootEventId' },\n\t\t\t} as any);\n\t\t\texpect(\n\t\t\t\tmessageAdapter.sendThreadMessage.calledWith(\n\t\t\t\t\t{},\n\t\t\t\t\t{},\n\t\t\t\t\t'rawMessage',\n\t\t\t\t\t'externalEventId',\n\t\t\t\t\t'messageThreadId',\n\t\t\t\t\t'externalFormattedText',\n\t\t\t\t\t'localDomain',\n\t\t\t\t),\n\t\t\t).to.be.true;\n\t\t\texpect(messageAdapter.sendThreadQuoteMessage.called).to.be.false;\n\t\t});\n\t\tdescribe('Quoting messages', () => {\n\t\t\tit('should NOT send a quote message if its necessary to quote but the message to quote does not exists', async () => {\n\t\t\t\tmessageAdapter.getMessageByFederationId.onFirstCall().resolves({ _id: 'messageThreadId' });\n\t\t\t\troomAdapter.getFederatedRoomByExternalId.onSecondCall().resolves(undefined);\n\t\t\t\troomAdapter.getFederatedRoomByExternalId.onThirdCall().resolves(undefined);\n\t\t\t\troomAdapter.getFederatedRoomByExternalId.resolves({} as any);\n\t\t\t\tuserAdapter.getFederatedUserByExternalId.resolves({} as any);\n\t\t\t\tmessageAdapter.getMessageByFederationId.resolves(undefined);\n\t\t\t\tawait service.onExternalThreadedMessageReceived({\n\t\t\t\t\tmessageText: 'text',\n\t\t\t\t\treplyToEventId: 'replyToEventId',\n\t\t\t\t\tthread: { rootEventId: 'rootEventId' },\n\t\t\t\t} as any);\n\t\t\t\texpect(messageAdapter.sendThreadQuoteMessage.called).to.be.false;\n\t\t\t\texpect(messageAdapter.sendThreadMessage.called).to.be.false;\n\t\t\t});\n\t\t\tit('should send a quote message if its necessary to quote and the message to quote exists', async () => {\n\t\t\t\tmessageAdapter.getMessageByFederationId.onFirstCall().resolves({ _id: 'messageThreadId' });\n\t\t\t\troomAdapter.getFederatedRoomByExternalId.resolves({} as any);\n\t\t\t\tuserAdapter.getFederatedUserByExternalId.resolves({} as any);\n\t\t\t\tmessageAdapter.getMessageByFederationId.onSecondCall().resolves(undefined);\n\t\t\t\tmessageAdapter.getMessageByFederationId.onThirdCall().resolves({} as any);\n\t\t\t\tawait service.onExternalThreadedMessageReceived({\n\t\t\t\t\tmessageText: 'text',\n\t\t\t\t\texternalEventId: 'externalEventId',\n\t\t\t\t\treplyToEventId: 'replyToEventId',\n\t\t\t\t\trawMessage: 'rawMessage',\n\t\t\t\t\texternalFormattedText: 'externalFormattedText',\n\t\t\t\t\tthread: { rootEventId: 'rootEventId' },\n\t\t\t\t} as any);\n\t\t\t\texpect(\n\t\t\t\t\tmessageAdapter.sendThreadQuoteMessage.calledWith(\n\t\t\t\t\t\t{},\n\t\t\t\t\t\t{},\n\t\t\t\t\t\t'rawMessage',\n\t\t\t\t\t\t'externalEventId',\n\t\t\t\t\t\t{},\n\t\t\t\t\t\t'localDomain',\n\t\t\t\t\t\t'messageThreadId',\n\t\t\t\t\t\t'externalFormattedText',\n\t\t\t\t\t),\n\t\t\t\t).to.be.true;\n\t\t\t\texpect(messageAdapter.sendThreadMessage.called).to.be.false;\n\t\t\t});\n\t\t});\n\t});\n\tdescribe('#onExternalThreadedFileMessageReceived()', () => {\n\t\tconst user = FederatedUser.createInstance('externalInviterId', {\n\t\t\tname: 'normalizedInviterId',\n\t\t\tusername: 'normalizedInviterId',\n\t\t\texistsOnlyOnProxyServer: false,\n\t\t});\n\t\tconst room = FederatedRoom.createInstance('externalRoomId', 'normalizedRoomId', user, RoomType.CHANNEL, 'externalRoomName');\n\t\tit('should NOT send a message if the thread root event id does not exist', async () => {\n\t\t\tawait service.onExternalThreadedFileMessageReceived({\n\t\t\t\trawMessage: 'text',\n\t\t\t} as any);\n\t\t\texpect(messageAdapter.sendThreadQuoteFileMessage.called).to.be.false;\n\t\t\texpect(messageAdapter.sendThreadFileMessage.called).to.be.false;\n\t\t});\n\t\tit('should NOT send a message if the internal thread parent message does not exist', async () => {\n\t\t\tmessageAdapter.getMessageByFederationId.resolves(undefined);\n\t\t\tawait service.onExternalThreadedFileMessageReceived({\n\t\t\t\trawMessage: 'text',\n\t\t\t\tthread: { rootEventId: 'rootEventId' },\n\t\t\t} as any);\n\t\t\texpect(messageAdapter.sendThreadQuoteFileMessage.called).to.be.false;\n\t\t\texpect(messageAdapter.sendThreadFileMessage.called).to.be.false;\n\t\t});\n\t\tit('should NOT send a message if the room does not exists', async () => {\n\t\t\tmessageAdapter.getMessageByFederationId.resolves({});\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(undefined);\n\t\t\tawait service.onExternalThreadedFileMessageReceived({\n\t\t\t\trawMessage: 'text',\n\t\t\t\tthread: { rootEventId: 'rootEventId' },\n\t\t\t} as any);\n\t\t\texpect(messageAdapter.sendThreadQuoteFileMessage.called).to.be.false;\n\t\t\texpect(messageAdapter.sendThreadFileMessage.called).to.be.false;\n\t\t});\n\t\tit('should NOT send a message if the sender does not exists', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves({} as any);\n\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(undefined);\n\t\t\tmessageAdapter.getMessageByFederationId.resolves({});\n\t\t\tawait service.onExternalThreadedFileMessageReceived({\n\t\t\t\trawMessage: 'text',\n\t\t\t\tthread: { rootEventId: 'rootEventId' },\n\t\t\t} as any);\n\t\t\texpect(messageAdapter.sendThreadQuoteFileMessage.called).to.be.false;\n\t\t\texpect(messageAdapter.sendThreadFileMessage.called).to.be.false;\n\t\t});\n\t\tit('should send a message if the room and the sender already exists', async () => {\n\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(user);\n\t\t\tbridge.getReadStreamForFileFromUrl.resolves();\n\t\t\tconst files = [{ id: 'fileId', name: 'filename' }];\n\t\t\tconst attachments = ['attachment', 'attachment2'];\n\t\t\tfileAdapter.uploadFile.resolves({ files, attachments } as any);\n\t\t\tmessageAdapter.getMessageByFederationId.onFirstCall().resolves({ _id: 'messageThreadId' });\n\t\t\tmessageAdapter.getMessageByFederationId.onSecondCall().resolves(undefined);\n\t\t\tawait service.onExternalThreadedFileMessageReceived({\n\t\t\t\tthread: { rootEventId: 'rootEventId' },\n\t\t\t\texternalEventId: 'externalEventId',\n\t\t\t\tmessageBody: {\n\t\t\t\t\tfilename: 'filename',\n\t\t\t\t\tsize: 12,\n\t\t\t\t\tmimetype: 'mimetype',\n\t\t\t\t\turl: 'url',\n\t\t\t\t},\n\t\t\t} as any);\n\t\t\texpect(messageAdapter.sendThreadFileMessage.calledWith(user, room, files, attachments, 'externalEventId', 'messageThreadId')).to.be\n\t\t\t\t.true;\n\t\t\texpect(messageAdapter.sendThreadQuoteFileMessage.called).to.be.false;\n\t\t});\n\t\tdescribe('Quoting messages', () => {\n\t\t\tit('should NOT send a quote message if its necessary to quote but the message to quote does not exists', async () => {\n\t\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(user);\n\t\t\t\tmessageAdapter.getMessageByFederationId.resolves(undefined);\n\t\t\t\tfileAdapter.uploadFile.resolves({} as any);\n\t\t\t\tmessageAdapter.getMessageByFederationId.onFirstCall().resolves({ _id: 'messageThreadId' });\n\t\t\t\tmessageAdapter.getMessageByFederationId.onSecondCall().resolves(undefined);\n\t\t\t\tmessageAdapter.getMessageByFederationId.onThirdCall().resolves(undefined);\n\t\t\t\tawait service.onExternalThreadedFileMessageReceived({\n\t\t\t\t\tthread: { rootEventId: 'rootEventId' },\n\t\t\t\t\texternalEventId: 'externalEventId',\n\t\t\t\t\treplyToEventId: 'replyToEventId',\n\t\t\t\t\tmessageBody: {\n\t\t\t\t\t\tfilename: 'filename',\n\t\t\t\t\t\tsize: 12,\n\t\t\t\t\t\tmimetype: 'mimetype',\n\t\t\t\t\t\turl: 'url',\n\t\t\t\t\t},\n\t\t\t\t} as any);\n\t\t\t\texpect(messageAdapter.sendThreadQuoteFileMessage.called).to.be.false;\n\t\t\t\texpect(messageAdapter.sendThreadFileMessage.called).to.be.false;\n\t\t\t});\n\t\t\tit('should send a quote message if its necessary to quote and the message to quote exists', async () => {\n\t\t\t\tconst messageToReplyTo = { federation: { eventId: 'eventId' } } as any;\n\t\t\t\troomAdapter.getFederatedRoomByExternalId.resolves(room);\n\t\t\t\tuserAdapter.getFederatedUserByExternalId.resolves(user);\n\t\t\t\tmessageAdapter.getMessageByFederationId.onFirstCall().resolves({ _id: 'messageThreadId' });\n\t\t\t\tmessageAdapter.getMessageByFederationId.onSecondCall().resolves(undefined);\n\t\t\t\tmessageAdapter.getMessageByFederationId.onThirdCall().resolves(messageToReplyTo);\n\t\t\t\tconst files = [{ id: 'fileId', name: 'filename' }];\n\t\t\t\tconst attachments = ['attachment', 'attachment2'];\n\t\t\t\tfileAdapter.uploadFile.resolves({ files, attachments } as any);\n\t\t\t\tawait service.onExternalThreadedFileMessageReceived({\n\t\t\t\t\tthread: { rootEventId: 'rootEventId' },\n\t\t\t\t\texternalEventId: 'externalEventId',\n\t\t\t\t\treplyToEventId: 'replyToEventId',\n\t\t\t\t\tmessageBody: {\n\t\t\t\t\t\tfilename: 'filename',\n\t\t\t\t\t\tsize: 12,\n\t\t\t\t\t\tmimetype: 'mimetype',\n\t\t\t\t\t\turl: 'url',\n\t\t\t\t\t},\n\t\t\t\t} as any);\n\t\t\t\texpect(\n\t\t\t\t\tmessageAdapter.sendThreadQuoteFileMessage.calledWith(\n\t\t\t\t\t\tuser,\n\t\t\t\t\t\troom,\n\t\t\t\t\t\tfiles,\n\t\t\t\t\t\tattachments,\n\t\t\t\t\t\t'externalEventId',\n\t\t\t\t\t\tmessageToReplyTo,\n\t\t\t\t\t\t'localDomain',\n\t\t\t\t\t\t'messageThreadId',\n\t\t\t\t\t),\n\t\t\t\t).to.be.true;\n\t\t\t\texpect(messageAdapter.sendThreadFileMessage.called).to.be.false;\n\t\t\t});\n\t\t});\n\t});\n});", "llm_cg": {"FederationRoomServiceReceiver.onCreateRoom(any)": ["roomAdapter.getFederatedRoomByExternalId(any)", "FederatedRoomServiceReceiver.onChangeRoomMembership(any)"], "FederationRoomServiceReceiver.onChangeRoomMembership(any)": ["roomAdapter.getFederatedRoomByExternalId(any)", "userAdapter.getFederatedUserByExternalId(any)", "FederatedUser.createInstance(any, any)", "FederatedRoom.createInstance(any, any, any, any, any)", "roomAdapter.createFederatedRoom(any)", "bridge.joinRoom(any, any)", "roomAdapter.updateFederatedRoomByInternalRoomId(any, any)", "roomAdapter.createFederatedRoomForDirectMessage(any)", "FederatedUser.createWithInternalReference(any, any, any)", "roomAdapter.removeDirectMessageRoom(any)", "roomAdapter.removeUserFromRoom(any, any, any)", "roomAdapter.addUserToRoom(any, any)", "roomAdapter.addUsersToRoomWhenJoinExternalPublicRoom(any)", "roomAdapter.isUserAlreadyJoined(any, any)", "service.createFederatedUserInternallyOnly(any, any, any)", "service.createFederatedUserAndReturnIt(any)", "bridge.getRoomData(any)", "bridge.extractHomeserverOrigin(any)", "roomAdapter.createFederatedRoom(any)", "service.onChangeRoomName(any)"], "FederationRoomServiceReceiver.onExternalFileMessageReceived(any)": ["roomAdapter.getFederatedRoomByExternalId(any)", "userAdapter.getFederatedUserByExternalId(any)", "bridge.getReadStreamForFileFromUrl(any)", "fileAdapter.uploadFile(any, any, any, any)", "messageAdapter.sendFileMessage(any, any, any, any)"], "FederationRoomServiceReceiver.onExternalMessageReceived(any)": ["roomAdapter.getFederatedRoomByExternalId(any)", "userAdapter.getFederatedUserByExternalId(any)", "messageAdapter.getMessageByFederationId(any)", "messageAdapter.sendMessage(any, any, any, any, any, any)", "messageAdapter.sendQuoteMessage(any, any, any, any, any, any, any)"], "FederationRoomServiceReceiver.onChangeJoinRules(any)": ["roomAdapter.getFederatedRoomByExternalId(any)", "roomAdapter.updateRoomType(any)"], "FederationRoomServiceReceiver.onChangeRoomName(any)": ["roomAdapter.getFederatedRoomByExternalId(any)", "userAdapter.getFederatedUserByExternalId(any)", "bridge.extractHomeserverOrigin(any)", "roomAdapter.updateRoomName(any)", "roomAdapter.updateDisplayRoomName(any, any)"], "FederationRoomServiceReceiver.onChangeRoomTopic(any)": ["roomAdapter.getFederatedRoomByExternalId(any)", "roomAdapter.updateRoomTopic(any, any)"], "FederationRoomServiceReceiver.onRedactEvent(any)": ["roomAdapter.getFederatedRoomByExternalId(any)", "userAdapter.getFederatedUserByExternalId(any)", "messageAdapter.getMessageByFederationId(any)", "messageAdapter.deleteMessage(any, any)", "messageAdapter.unreactToMessage(any, any, any, any)", "messageAdapter.findOneByFederationIdOnReactions(any)"], "FederationRoomServiceReceiver.onExternalMessageEditedReceived(any)": ["roomAdapter.getFederatedRoomByExternalId(any)", "userAdapter.getFederatedUserByExternalId(any)", "messageAdapter.getMessageByFederationId(any)", "bridge.extractHomeserverOrigin(any)", "messageAdapter.getMessageToEditWhenReplyAndQuote(any, any)", "messageAdapter.editMessage(any, any, any, any, any)", "messageAdapter.editQuotedMessage(any, any, any, any, any)"], "FederationRoomServiceReceiver.onChangeRoomPowerLevels(any)": ["roomAdapter.getFederatedRoomByExternalId(any)", "userAdapter.getFederatedUserByExternalId(any)", "userAdapter.getFederatedUsersByExternalIds(any)", "roomAdapter.applyRoomRolesToUser(any)"], "FederationRoomServiceReceiver.onExternalThreadedMessageReceived(any)": ["messageAdapter.getMessageByFederationId(any)", "roomAdapter.getFederatedRoomByExternalId(any)", "userAdapter.getFederatedUserByExternalId(any)", "messageAdapter.sendThreadMessage(any, any, any, any, any, any, any)", "messageAdapter.sendThreadQuoteMessage(any, any, any, any, any, any, any, any)"], "FederationRoomServiceReceiver.onExternalThreadedFileMessageReceived(any)": ["messageAdapter.getMessageByFederationId(any)", "roomAdapter.getFederatedRoomByExternalId(any)", "userAdapter.getFederatedUserByExternalId(any)", "bridge.getReadStreamForFileFromUrl(any)", "fileAdapter.uploadFile(any, any, any, any)", "messageAdapter.sendThreadFileMessage(any, any, any, any, any, any)", "messageAdapter.sendThreadQuoteFileMessage(any, any, any, any, any, any, any, any)"]}, "static_cg": {"@test/194.ts: %dflt.[static]%dflt()": ["@test/194.ts: %dflt.%AM0()"], "@test/194.ts: %dflt.%AM3$%AM0()": ["@test/194.ts: %dflt.%AM4$%AM3$%AM0()", "@test/194.ts: %dflt.%AM5$%AM3$%AM0()", "@test/194.ts: %dflt.%AM6$%AM3$%AM0()", "@test/194.ts: %dflt.%AM7$%AM3$%AM0()", "@test/194.ts: %dflt.%AM8$%AM3$%AM0()"], "@test/194.ts: %dflt.%AM24$%AM9$%AM0()": ["@test/194.ts: %dflt.%AM25$%AM24$%AM9$%AM0(unknown)"], "@test/194.ts: %dflt.%AM38$%AM9$%AM0()": ["@test/194.ts: %dflt.%AM39$%AM38$%AM9$%AM0()", "@test/194.ts: %dflt.%AM40$%AM38$%AM9$%AM0()", "@test/194.ts: %dflt.%AM41$%AM38$%AM9$%AM0()", "@test/194.ts: %dflt.%AM42$%AM38$%AM9$%AM0()", "@test/194.ts: %dflt.%AM43$%AM38$%AM9$%AM0()", "@test/194.ts: %dflt.%AM44$%AM38$%AM9$%AM0()", "@test/194.ts: %dflt.%AM45$%AM38$%AM9$%AM0()", "@test/194.ts: %dflt.%AM46$%AM38$%AM9$%AM0()", "@test/194.ts: %dflt.%AM47$%AM38$%AM9$%AM0()", "@test/194.ts: %dflt.%AM48$%AM38$%AM9$%AM0()", "@test/194.ts: %dflt.%AM49$%AM38$%AM9$%AM0()", "@test/194.ts: %dflt.%AM50$%AM38$%AM9$%AM0()", "@test/194.ts: %dflt.%AM51$%AM38$%AM9$%AM0()"], "@test/194.ts: %dflt.%AM52$%AM9$%AM0()": ["@test/194.ts: %dflt.%AM53$%AM52$%AM9$%AM0()", "@test/194.ts: %dflt.%AM54$%AM52$%AM9$%AM0()", "@test/194.ts: %dflt.%AM55$%AM52$%AM9$%AM0()", "@test/194.ts: %dflt.%AM56$%AM52$%AM9$%AM0()", "@test/194.ts: %dflt.%AM57$%AM52$%AM9$%AM0()", "@test/194.ts: %dflt.%AM58$%AM52$%AM9$%AM0()", "@test/194.ts: %dflt.%AM59$%AM52$%AM9$%AM0()", "@test/194.ts: %dflt.%AM60$%AM52$%AM9$%AM0()"], "@test/194.ts: %dflt.%AM9$%AM0()": ["@test/194.ts: %dflt.%AM10$%AM9$%AM0()", "@test/194.ts: %dflt.%AM11$%AM9$%AM0()", "@test/194.ts: %dflt.%AM12$%AM9$%AM0()", "@test/194.ts: %dflt.%AM13$%AM9$%AM0()", "@test/194.ts: %dflt.%AM14$%AM9$%AM0()", "@test/194.ts: %dflt.%AM15$%AM9$%AM0()", "@test/194.ts: %dflt.%AM16$%AM9$%AM0()", "@test/194.ts: %dflt.%AM17$%AM9$%AM0()", "@test/194.ts: %dflt.%AM18$%AM9$%AM0()", "@test/194.ts: %dflt.%AM19$%AM9$%AM0()", "@test/194.ts: %dflt.%AM20$%AM9$%AM0()", "@test/194.ts: %dflt.%AM21$%AM9$%AM0()", "@test/194.ts: %dflt.%AM22$%AM9$%AM0()", "@test/194.ts: %dflt.%AM23$%AM9$%AM0()", "@test/194.ts: %dflt.%AM24$%AM9$%AM0()", "@test/194.ts: %dflt.%AM26$%AM9$%AM0()", "@test/194.ts: %dflt.%AM27$%AM9$%AM0()", "@test/194.ts: %dflt.%AM28$%AM9$%AM0()", "@test/194.ts: %dflt.%AM29$%AM9$%AM0()", "@test/194.ts: %dflt.%AM30$%AM9$%AM0()", "@test/194.ts: %dflt.%AM31$%AM9$%AM0()", "@test/194.ts: %dflt.%AM32$%AM9$%AM0()", "@test/194.ts: %dflt.%AM33$%AM9$%AM0()", "@test/194.ts: %dflt.%AM34$%AM9$%AM0()", "@test/194.ts: %dflt.%AM35$%AM9$%AM0()", "@test/194.ts: %dflt.%AM36$%AM9$%AM0()", "@test/194.ts: %dflt.%AM37$%AM9$%AM0()", "@test/194.ts: %dflt.%AM38$%AM9$%AM0()", "@test/194.ts: %dflt.%AM52$%AM9$%AM0()"], "@test/194.ts: %dflt.%AM65$%AM61$%AM0()": ["@test/194.ts: %dflt.%AM66$%AM65$%AM61$%AM0()", "@test/194.ts: %dflt.%AM67$%AM65$%AM61$%AM0()"], "@test/194.ts: %dflt.%AM61$%AM0()": ["@test/194.ts: %dflt.%AM62$%AM61$%AM0()", "@test/194.ts: %dflt.%AM63$%AM61$%AM0()", "@test/194.ts: %dflt.%AM64$%AM61$%AM0()", "@test/194.ts: %dflt.%AM65$%AM61$%AM0()"], "@test/194.ts: %dflt.%AM73$%AM68$%AM0()": ["@test/194.ts: %dflt.%AM74$%AM73$%AM68$%AM0()", "@test/194.ts: %dflt.%AM75$%AM73$%AM68$%AM0()"], "@test/194.ts: %dflt.%AM68$%AM0()": ["@test/194.ts: %dflt.%AM69$%AM68$%AM0()", "@test/194.ts: %dflt.%AM70$%AM68$%AM0()", "@test/194.ts: %dflt.%AM71$%AM68$%AM0()", "@test/194.ts: %dflt.%AM72$%AM68$%AM0()", "@test/194.ts: %dflt.%AM73$%AM68$%AM0()"], "@test/194.ts: %dflt.%AM76$%AM0()": ["@test/194.ts: %dflt.%AM77$%AM76$%AM0()", "@test/194.ts: %dflt.%AM78$%AM76$%AM0()", "@test/194.ts: %dflt.%AM79$%AM76$%AM0()"], "@test/194.ts: %dflt.%AM80$%AM0()": ["@test/194.ts: %dflt.%AM81$%AM80$%AM0()", "@test/194.ts: %dflt.%AM82$%AM80$%AM0()", "@test/194.ts: %dflt.%AM83$%AM80$%AM0()", "@test/194.ts: %dflt.%AM84$%AM80$%AM0()", "@test/194.ts: %dflt.%AM85$%AM80$%AM0()", "@test/194.ts: %dflt.%AM86$%AM80$%AM0()"], "@test/194.ts: %dflt.%AM87$%AM0()": ["@test/194.ts: %dflt.%AM88$%AM87$%AM0()", "@test/194.ts: %dflt.%AM89$%AM87$%AM0()", "@test/194.ts: %dflt.%AM90$%AM87$%AM0()"], "@test/194.ts: %dflt.%AM91$%AM0()": ["@test/194.ts: %dflt.%AM92$%AM91$%AM0()", "@test/194.ts: %dflt.%AM93$%AM91$%AM0()", "@test/194.ts: %dflt.%AM94$%AM91$%AM0()", "@test/194.ts: %dflt.%AM95$%AM91$%AM0()", "@test/194.ts: %dflt.%AM96$%AM91$%AM0()", "@test/194.ts: %dflt.%AM97$%AM91$%AM0()"], "@test/194.ts: %dflt.%AM104$%AM98$%AM0()": ["@test/194.ts: %dflt.%AM105$%AM104$%AM98$%AM0()", "@test/194.ts: %dflt.%AM106$%AM104$%AM98$%AM0()", "@test/194.ts: %dflt.%AM107$%AM104$%AM98$%AM0()"], "@test/194.ts: %dflt.%AM98$%AM0()": ["@test/194.ts: %dflt.%AM99$%AM98$%AM0()", "@test/194.ts: %dflt.%AM100$%AM98$%AM0()", "@test/194.ts: %dflt.%AM101$%AM98$%AM0()", "@test/194.ts: %dflt.%AM102$%AM98$%AM0()", "@test/194.ts: %dflt.%AM103$%AM98$%AM0()", "@test/194.ts: %dflt.%AM104$%AM98$%AM0()"], "@test/194.ts: %dflt.%AM108$%AM0()": ["@test/194.ts: %dflt.%AM109$%AM108$%AM0()", "@test/194.ts: %dflt.%AM110$%AM108$%AM0()", "@test/194.ts: %dflt.%AM111$%AM108$%AM0()", "@test/194.ts: %dflt.%AM112$%AM108$%AM0()", "@test/194.ts: %dflt.%AM113$%AM108$%AM0()"], "@test/194.ts: %dflt.%AM121$%AM114$%AM0()": ["@test/194.ts: %dflt.%AM122$%AM121$%AM114$%AM0()", "@test/194.ts: %dflt.%AM123$%AM121$%AM114$%AM0()"], "@test/194.ts: %dflt.%AM114$%AM0()": ["@test/194.ts: %dflt.%AM115$%AM114$%AM0()", "@test/194.ts: %dflt.%AM116$%AM114$%AM0()", "@test/194.ts: %dflt.%AM117$%AM114$%AM0()", "@test/194.ts: %dflt.%AM118$%AM114$%AM0()", "@test/194.ts: %dflt.%AM119$%AM114$%AM0()", "@test/194.ts: %dflt.%AM120$%AM114$%AM0()", "@test/194.ts: %dflt.%AM121$%AM114$%AM0()"], "@test/194.ts: %dflt.%AM130$%AM124$%AM0()": ["@test/194.ts: %dflt.%AM131$%AM130$%AM124$%AM0()", "@test/194.ts: %dflt.%AM132$%AM130$%AM124$%AM0()"], "@test/194.ts: %dflt.%AM124$%AM0()": ["@test/194.ts: %dflt.%AM125$%AM124$%AM0()", "@test/194.ts: %dflt.%AM126$%AM124$%AM0()", "@test/194.ts: %dflt.%AM127$%AM124$%AM0()", "@test/194.ts: %dflt.%AM128$%AM124$%AM0()", "@test/194.ts: %dflt.%AM129$%AM124$%AM0()", "@test/194.ts: %dflt.%AM130$%AM124$%AM0()"], "@test/194.ts: %dflt.%AM0()": ["@test/194.ts: %dflt.%AM1$%AM0()", "@test/194.ts: %dflt.%AM2$%AM0()", "@test/194.ts: %dflt.%AM3$%AM0()", "@test/194.ts: %dflt.%AM9$%AM0()", "@test/194.ts: %dflt.%AM61$%AM0()", "@test/194.ts: %dflt.%AM68$%AM0()", "@test/194.ts: %dflt.%AM76$%AM0()", "@test/194.ts: %dflt.%AM80$%AM0()", "@test/194.ts: %dflt.%AM87$%AM0()", "@test/194.ts: %dflt.%AM91$%AM0()", "@test/194.ts: %dflt.%AM98$%AM0()", "@test/194.ts: %dflt.%AM108$%AM0()", "@test/194.ts: %dflt.%AM114$%AM0()", "@test/194.ts: %dflt.%AM124$%AM0()"]}}
{"source_code": "import { BadRequestException, NotFoundException, Scope } from '@nestjs/common';\nimport { WorkspaceQueryHookInstance } from 'src/engine/api/graphql/workspace-query-runner/workspace-query-hook/interfaces/workspace-query-hook.interface';\nimport { FindManyResolverArgs } from 'src/engine/api/graphql/workspace-resolver-builder/interfaces/workspace-resolvers-builder.interface';\nimport { WorkspaceQueryHook } from 'src/engine/api/graphql/workspace-query-runner/workspace-query-hook/decorators/workspace-query-hook.decorator';\nimport { TwentyORMManager } from 'src/engine/twenty-orm/twenty-orm.manager';\nimport { CanAccessCalendarEventService } from 'src/modules/calendar/common/query-hooks/calendar-event/services/can-access-calendar-event.service';\nimport { CalendarChannelEventAssociationWorkspaceEntity } from 'src/modules/calendar/common/standard-objects/calendar-channel-event-association.workspace-entity';\nimport { AuthContext } from 'src/engine/core-modules/auth/types/auth-context.type';\n@WorkspaceQueryHook({\n  key: `calendarEvent.findMany`,\n  scope: Scope.REQUEST,\n})\nexport class CalendarEventFindManyPreQueryHook\n  implements WorkspaceQueryHookInstance\n{\n  constructor(\n    private readonly twentyORMManager: TwentyORMManager,\n    private readonly canAccessCalendarEventService: CanAccessCalendarEventService,\n  ) {}\n  async execute(\n    authContext: AuthContext,\n    objectName: string,\n    payload: FindManyResolverArgs,\n  ): Promise<FindManyResolverArgs> {\n    if (!payload?.filter?.id?.eq) {\n      throw new BadRequestException('id filter is required');\n    }\n    if (!authContext.user?.id) {\n      throw new BadRequestException('User id is required');\n    }\n    const calendarChannelEventAssociationRepository =\n      await this.twentyORMManager.getRepository<CalendarChannelEventAssociationWorkspaceEntity>(\n        'calendarChannelEventAssociation',\n      );\n    const calendarChannelCalendarEventAssociations =\n      await calendarChannelEventAssociationRepository.find({\n        where: {\n          calendarEventId: payload?.filter?.id?.eq,\n        },\n        relations: ['calendarChannel.connectedAccount'],\n      });\n    if (calendarChannelCalendarEventAssociations.length === 0) {\n      throw new NotFoundException();\n    }\n    await this.canAccessCalendarEventService.canAccessCalendarEvent(\n      authContext.user.id,\n      authContext.workspace.id,\n      calendarChannelCalendarEventAssociations,\n    );\n    return payload;\n  }\n}", "llm_cg": {"CalendarEventFindManyPreQueryHook.execute(AuthContext, string, FindManyResolverArgs)": ["CalendarEventFindManyPreQueryHook.%AM0$getRepository(unknown)", "CalendarEventFindManyPreQueryHook.%AM1$find(unknown)", "CanAccessCalendarEventService.canAccessCalendarEvent(string, string, unknown[])"]}, "static_cg": {}}
{"source_code": "class C {\n    public x;\n    public a = '';\n    public b: string = '';\n    public c() { return '' }\n    public d = () => '';\n    public static e;\n    public static f() { return '' }\n    public static g = () => '';\n}\n// all of these are valid\nvar c = new C();\nvar r1: string = c.x;\nvar r2: string = c.a;\nvar r3: string = c.b;\nvar r4: string = c.c();\nvar r5: string = c.d();\nvar r6: string = C.e;\nvar r7: string = C.f();\nvar r8: string = C.g();", "llm_cg": {"C.c()": [], "C.d()": [], "C.f()": [], "C.g()": [], "%AM0$c.c()": [], "%AM0$c.d()": ["C.d()"], "MainCode.%AM1$x()": [], "MainCode.%AM1$a()": [], "MainCode.%AM1$b()": [], "MainCode.%AM1$r1()": ["MainCode.%AM1$x()"], "MainCode.%AM1$r2()": ["MainCode.%AM1$a()"], "MainCode.%AM1$r3()": ["MainCode.%AM1$b()"], "MainCode.%AM1$r4()": ["%AM0$c.c()"], "MainCode.%AM1$r5()": ["%AM0$c.d()"], "MainCode.%AM1$r6()": [], "MainCode.%AM1$r7()": ["C.f()"], "MainCode.%AM1$r8()": ["C.g()"]}, "static_cg": {"@test/196.ts: %dflt.[static]%dflt()": ["@test/196.ts: C.c()", "@test/196.ts: C.[static]f()"]}}
{"source_code": "import {CommonModule} from '@angular/common';\nimport {\n  ChangeDetectorRef,\n  Component,\n  Directive,\n  EmbeddedViewRef,\n  Injectable,\n  Injector,\n  Input,\n  TemplateRef,\n  ViewChild,\n  ViewContainerRef,\n  ViewRef,\n} from '@angular/core';\nimport {TestBed} from '@angular/core/testing';\nimport {By} from '@angular/platform-browser';\ndescribe('view insertion', () => {\n  describe('of a simple template', () => {\n    it('should insert into an empty container, at the front, in the middle, and at the end', () => {\n      let _counter = 0;\n      @Component({\n        selector: 'increment-comp',\n        template: `<span>created{{counter}}</span>`,\n        standalone: false,\n      })\n      class IncrementComp {\n        counter = _counter++;\n      }\n      @Component({\n        template: `\n              <ng-template #simple><increment-comp></increment-comp></ng-template>\n              <div #container></div>\n            `,\n        standalone: false,\n      })\n      class App {\n        @ViewChild('container', {read: ViewContainerRef, static: true})\n        container: ViewContainerRef = null!;\n        @ViewChild('simple', {read: TemplateRef, static: true}) simple: TemplateRef<any> = null!;\n        view0: EmbeddedViewRef<any> = null!;\n        view1: EmbeddedViewRef<any> = null!;\n        view2: EmbeddedViewRef<any> = null!;\n        view3: EmbeddedViewRef<any> = null!;\n        constructor(public changeDetector: ChangeDetectorRef) {}\n        ngAfterViewInit() {\n          // insert at the front\n          this.view1 = this.container.createEmbeddedView(this.simple); // \"created0\"\n          // insert at the front again\n          this.view0 = this.container.createEmbeddedView(this.simple, {}, 0); // \"created1\"\n          // insert at the end\n          this.view3 = this.container.createEmbeddedView(this.simple); // \"created2\"\n          // insert in the middle\n          this.view2 = this.container.createEmbeddedView(this.simple, {}, 2); // \"created3\"\n          // We need to run change detection here to avoid\n          // ExpressionChangedAfterItHasBeenCheckedError because of the value updating in\n          // increment-comp\n          this.changeDetector.detectChanges();\n        }\n      }\n      TestBed.configureTestingModule({\n        declarations: [App, IncrementComp],\n      });\n      const fixture = TestBed.createComponent(App);\n      fixture.detectChanges();\n      const app = fixture.componentInstance;\n      expect(app.container.indexOf(app.view0)).toBe(0);\n      expect(app.container.indexOf(app.view1)).toBe(1);\n      expect(app.container.indexOf(app.view2)).toBe(2);\n      expect(app.container.indexOf(app.view3)).toBe(3);\n      // The text in each component differs based on *when* it was created.\n      expect(fixture.nativeElement.textContent).toBe('created1created0created3created2');\n    });\n  });\n  describe('of an empty template', () => {\n    it('should insert into an empty container, at the front, in the middle, and at the end', () => {\n      @Component({\n        template: `\n              <ng-template #empty></ng-template>\n              <div #container></div>\n            `,\n        standalone: false,\n      })\n      class App {\n        @ViewChild('container', {read: ViewContainerRef}) container: ViewContainerRef = null!;\n        @ViewChild('empty', {read: TemplateRef}) empty: TemplateRef<any> = null!;\n        view0: EmbeddedViewRef<any> = null!;\n        view1: EmbeddedViewRef<any> = null!;\n        view2: EmbeddedViewRef<any> = null!;\n        view3: EmbeddedViewRef<any> = null!;\n        ngAfterViewInit() {\n          // insert at the front\n          this.view1 = this.container.createEmbeddedView(this.empty);\n          // insert at the front again\n          this.view0 = this.container.createEmbeddedView(this.empty, {}, 0);\n          // insert at the end\n          this.view3 = this.container.createEmbeddedView(this.empty);\n          // insert in the middle\n          this.view2 = this.container.createEmbeddedView(this.empty, {}, 2);\n        }\n      }\n      TestBed.configureTestingModule({\n        declarations: [App],\n      });\n      const fixture = TestBed.createComponent(App);\n      fixture.detectChanges();\n      const app = fixture.componentInstance;\n      expect(app.container.indexOf(app.view0)).toBe(0);\n      expect(app.container.indexOf(app.view1)).toBe(1);\n      expect(app.container.indexOf(app.view2)).toBe(2);\n      expect(app.container.indexOf(app.view3)).toBe(3);\n    });\n  });\n  describe('of an ng-content projection', () => {\n    it('should insert into an empty container, at the front, in the middle, and at the end', () => {\n      @Component({\n        selector: 'comp',\n        template: `\n                  <ng-template #projection><ng-content></ng-content></ng-template>\n                  <div #container></div>\n                `,\n        standalone: false,\n      })\n      class Comp {\n        @ViewChild('container', {read: ViewContainerRef}) container: ViewContainerRef = null!;\n        @ViewChild('projection', {read: TemplateRef}) projection: TemplateRef<any> = null!;\n        view0: EmbeddedViewRef<any> = null!;\n        view1: EmbeddedViewRef<any> = null!;\n        view2: EmbeddedViewRef<any> = null!;\n        view3: EmbeddedViewRef<any> = null!;\n        ngAfterViewInit() {\n          // insert at the front\n          this.view1 = this.container.createEmbeddedView(this.projection);\n          // insert at the front again\n          this.view0 = this.container.createEmbeddedView(this.projection, {}, 0);\n          // insert at the end\n          this.view3 = this.container.createEmbeddedView(this.projection);\n          // insert in the middle\n          this.view2 = this.container.createEmbeddedView(this.projection, {}, 2);\n        }\n      }\n      @Component({\n        template: `\n          <comp>test</comp>\n        `,\n        standalone: false,\n      })\n      class App {}\n      TestBed.configureTestingModule({\n        declarations: [App, Comp],\n      });\n      const fixture = TestBed.createComponent(App);\n      fixture.detectChanges();\n      const comp = fixture.debugElement.query(By.directive(Comp)).injector.get(Comp);\n      expect(comp.container.indexOf(comp.view0)).toBe(0);\n      expect(comp.container.indexOf(comp.view1)).toBe(1);\n      expect(comp.container.indexOf(comp.view2)).toBe(2);\n      expect(comp.container.indexOf(comp.view3)).toBe(3);\n      // Both ViewEngine and Ivy only honor one of the inserted ng-content components, even though\n      // all are inserted.\n      expect(fixture.nativeElement.textContent).toBe('test');\n    });\n  });\n  describe('of another container like ngIf', () => {\n    it('should insert into an empty container, at the front, in the middle, and at the end', () => {\n      @Component({\n        template: `\n                  <ng-template #subContainer><div class=\"dynamic\" *ngIf=\"true\">test</div></ng-template>\n                  <div #container></div>\n                `,\n        standalone: false,\n      })\n      class App {\n        @ViewChild('container', {read: ViewContainerRef}) container: ViewContainerRef = null!;\n        @ViewChild('subContainer', {read: TemplateRef}) subContainer: TemplateRef<any> = null!;\n        view0: EmbeddedViewRef<any> = null!;\n        view1: EmbeddedViewRef<any> = null!;\n        view2: EmbeddedViewRef<any> = null!;\n        view3: EmbeddedViewRef<any> = null!;\n        constructor(public changeDetectorRef: ChangeDetectorRef) {}\n        ngAfterViewInit() {\n          // insert at the front\n          this.view1 = this.container.createEmbeddedView(this.subContainer, null, 0);\n          // insert at the front again\n          this.view0 = this.container.createEmbeddedView(this.subContainer, null, 0);\n          // insert at the end\n          this.view3 = this.container.createEmbeddedView(this.subContainer, null, 2);\n          // insert in the middle\n          this.view2 = this.container.createEmbeddedView(this.subContainer, null, 2);\n          // We need to run change detection here to avoid\n          // ExpressionChangedAfterItHasBeenCheckedError because of the value getting passed to ngIf\n          // in the template.\n          this.changeDetectorRef.detectChanges();\n        }\n      }\n      TestBed.configureTestingModule({\n        declarations: [App],\n        imports: [CommonModule],\n      });\n      const fixture = TestBed.createComponent(App);\n      fixture.detectChanges();\n      const app = fixture.componentInstance;\n      expect(app.container.indexOf(app.view0)).toBe(0);\n      expect(app.container.indexOf(app.view1)).toBe(1);\n      expect(app.container.indexOf(app.view2)).toBe(2);\n      expect(app.container.indexOf(app.view3)).toBe(3);\n      expect(fixture.debugElement.queryAll(By.css('div.dynamic')).length).toBe(4);\n    });\n  });\n  describe('before another view', () => {\n    @Directive({\n      selector: '[viewInserting]',\n      exportAs: 'vi',\n      standalone: false,\n    })\n    class ViewInsertingDir {\n      constructor(private _vcRef: ViewContainerRef) {}\n      insert(beforeView: ViewRef, insertTpl: TemplateRef<{}>) {\n        this._vcRef.insert(beforeView, 0);\n        this._vcRef.createEmbeddedView(insertTpl, {}, 0);\n      }\n    }\n    describe('before embedded view', () => {\n      @Component({\n        selector: 'test-cmpt',\n        template: '',\n        standalone: false,\n      })\n      class TestCmpt {\n        @ViewChild('before', {static: true}) beforeTpl!: TemplateRef<{}>;\n        @ViewChild('insert', {static: true}) insertTpl!: TemplateRef<{}>;\n        @ViewChild('vi', {static: true}) viewInsertingDir!: ViewInsertingDir;\n        minutes = 10;\n        insert() {\n          const beforeView = this.beforeTpl.createEmbeddedView({});\n          // change-detect the \"before view\" to create all child views\n          beforeView.detectChanges();\n          this.viewInsertingDir.insert(beforeView, this.insertTpl);\n        }\n      }\n      beforeEach(() => {\n        TestBed.configureTestingModule({\n          declarations: [TestCmpt, ViewInsertingDir],\n          imports: [CommonModule],\n        });\n      });\n      function createAndInsertViews(beforeTpl: string): any {\n        TestBed.overrideTemplate(\n          TestCmpt,\n          `\n          <ng-template #insert>insert</ng-template>\n          <ng-template #before>${beforeTpl}</ng-template>\n          <div><ng-template #vi=\"vi\" viewInserting></ng-template></div>\n        `,\n        );\n        const fixture = TestBed.createComponent(TestCmpt);\n        fixture.detectChanges();\n        fixture.componentInstance.insert();\n        fixture.detectChanges();\n        return fixture.nativeElement;\n      }\n      it('should insert before a view with the text node as the first root node', () => {\n        expect(createAndInsertViews('|before').textContent).toBe('insert|before');\n      });\n      it('should insert before a view with the element as the first root node', () => {\n        expect(createAndInsertViews('<span>|before</span>').textContent).toBe('insert|before');\n      });\n      it('should insert before a view with the ng-container as the first root node', () => {\n        expect(\n          createAndInsertViews(`\n          <ng-container>\n            <ng-container>|before</ng-container>\n          </ng-container>\n        `).textContent,\n        ).toBe('insert|before');\n      });\n      it('should insert before a view with the empty ng-container as the first root node', () => {\n        expect(createAndInsertViews(`<ng-container></ng-container>|before`).textContent).toBe(\n          'insert|before',\n        );\n      });\n      it('should insert before a view with ICU container inside a ng-container as the first root node', () => {\n        expect(\n          createAndInsertViews(\n            `<ng-container i18n>{minutes, plural, =0 {just now} =1 {one minute ago} other {|before}}</ng-container>`,\n          ).textContent,\n        ).toBe('insert|before');\n      });\n      it('should insert before a view with a container as the first root node', () => {\n        expect(\n          createAndInsertViews(`<ng-template [ngIf]=\"true\">|before</ng-template>`).textContent,\n        ).toBe('insert|before');\n      });\n      it('should insert before a view with an empty container as the first root node', () => {\n        expect(\n          createAndInsertViews(`<ng-template [ngIf]=\"true\"></ng-template>|before`).textContent,\n        ).toBe('insert|before');\n      });\n      it('should insert before a view with a ng-container where ViewContainerRef is injected', () => {\n        expect(\n          createAndInsertViews(`\n          <ng-container [ngTemplateOutlet]=\"after\">|before</ng-container>\n          <ng-template #after>|after</ng-template>\n        `).textContent,\n        ).toBe('insert|before|after');\n      });\n      it('should insert before a view with an element where ViewContainerRef is injected', () => {\n        expect(\n          createAndInsertViews(`\n          <div [ngTemplateOutlet]=\"after\">|before</div>\n          <ng-template #after>|after</ng-template>\n        `).textContent,\n        ).toBe('insert|before|after');\n      });\n      it('should insert before a view with an empty projection as the first root node', () => {\n        expect(createAndInsertViews(`<ng-content></ng-content>|before`).textContent).toBe(\n          'insert|before',\n        );\n      });\n      it('should insert before a view with complex node structure', () => {\n        expect(\n          createAndInsertViews(`\n          <ng-template [ngIf]=\"true\">\n            <ng-container>\n              <ng-container>\n                <ng-template [ngIf]=\"true\">|before</ng-template>\n              </ng-container>\n            </ng-container>\n          </ng-template>\n        `).textContent,\n        ).toBe('insert|before');\n      });\n      it('should insert before a ng-container with a ViewContainerRef on it', () => {\n        @Component({\n          selector: 'app-root',\n          template: `\n            <div>start|</div>\n            <ng-container [ngTemplateOutlet]=\"insertTpl ? tpl : null\"></ng-container>\n            <ng-container [ngTemplateOutlet]=\"tpl\"></ng-container>\n            <div>|end</div>\n            <ng-template #tpl>test</ng-template>\n          `,\n          standalone: false,\n        })\n        class AppComponent {\n          insertTpl = false;\n        }\n        TestBed.configureTestingModule({\n          declarations: [AppComponent],\n          imports: [CommonModule],\n        });\n        const fixture = TestBed.createComponent(AppComponent);\n        fixture.detectChanges();\n        expect(fixture.nativeElement.textContent).toBe('start|test|end');\n        fixture.componentInstance.insertTpl = true;\n        fixture.detectChanges();\n        expect(fixture.nativeElement.textContent).toBe('start|testtest|end');\n      });\n    });\n    describe('before embedded view with projection', () => {\n      @Component({\n        selector: 'with-content',\n        template: `\n          <ng-template #insert>insert</ng-template>\n          <ng-template #before><ng-content></ng-content></ng-template>\n          <div><ng-template #vi=\"vi\" viewInserting></ng-template></div>\n        `,\n        standalone: false,\n      })\n      class WithContentCmpt {\n        @ViewChild('insert', {static: true}) insertTpl!: TemplateRef<{}>;\n        @ViewChild('before', {static: true}) beforeTpl!: TemplateRef<{}>;\n        @ViewChild('vi', {static: true}) viewInsertingDir!: ViewInsertingDir;\n        insert() {\n          const beforeView = this.beforeTpl.createEmbeddedView({});\n          // change-detect the \"before view\" to create all child views\n          beforeView.detectChanges();\n          this.viewInsertingDir.insert(beforeView, this.insertTpl);\n        }\n      }\n      @Component({\n        selector: 'test-cmpt',\n        template: '',\n        standalone: false,\n      })\n      class TestCmpt {\n        @ViewChild('wc', {static: true}) withContentCmpt!: WithContentCmpt;\n      }\n      beforeEach(() => {\n        TestBed.configureTestingModule({\n          declarations: [ViewInsertingDir, WithContentCmpt, TestCmpt],\n          imports: [CommonModule],\n        });\n      });\n      it('should insert before a view with projected text nodes', () => {\n        TestBed.overrideTemplate(TestCmpt, `<with-content #wc>|before</with-content>`);\n        const fixture = TestBed.createComponent(TestCmpt);\n        fixture.detectChanges();\n        fixture.componentInstance.withContentCmpt.insert();\n        fixture.detectChanges();\n        expect(fixture.nativeElement.textContent).toBe('insert|before');\n      });\n      it('should insert before a view with projected container', () => {\n        TestBed.overrideTemplate(\n          TestCmpt,\n          `<with-content #wc><ng-template [ngIf]=\"true\">|before</ng-template></with-content>`,\n        );\n        const fixture = TestBed.createComponent(TestCmpt);\n        fixture.detectChanges();\n        fixture.componentInstance.withContentCmpt.insert();\n        fixture.detectChanges();\n        expect(fixture.nativeElement.textContent).toBe('insert|before');\n      });\n    });\n    describe('before component view', () => {\n      @Directive({\n        selector: '[viewInserting]',\n        exportAs: 'vi',\n        standalone: false,\n      })\n      class ViewInsertingDir {\n        constructor(private _vcRef: ViewContainerRef) {}\n        insert(beforeView: ViewRef, insertTpl: TemplateRef<{}>) {\n          this._vcRef.insert(beforeView, 0);\n          this._vcRef.createEmbeddedView(insertTpl, {}, 0);\n        }\n      }\n      @Component({\n        selector: 'dynamic-cmpt',\n        template: '|before',\n        standalone: false,\n      })\n      class DynamicComponent {}\n      it('should insert in front a dynamic component view', () => {\n        @Component({\n          selector: 'test-cmpt',\n          template: `\n                <ng-template #insert>insert</ng-template>\n                <div><ng-template #vi=\"vi\" viewInserting></ng-template></div>\n              `,\n          standalone: false,\n        })\n        class TestCmpt {\n          @ViewChild('insert', {static: true}) insertTpl!: TemplateRef<{}>;\n          @ViewChild('vi', {static: true}) viewInsertingDir!: ViewInsertingDir;\n          constructor(\n            private _vcr: ViewContainerRef,\n            private _injector: Injector,\n          ) {}\n          insert() {\n            // create a dynamic component view to act as an \"insert before\" view\n            const beforeView = this._vcr.createComponent(DynamicComponent, {\n              injector: this._injector,\n            }).hostView;\n            // change-detect the \"before view\" to create all child views\n            beforeView.detectChanges();\n            this.viewInsertingDir.insert(beforeView, this.insertTpl);\n          }\n        }\n        TestBed.configureTestingModule({\n          declarations: [TestCmpt, ViewInsertingDir, DynamicComponent],\n        });\n        const fixture = TestBed.createComponent(TestCmpt);\n        fixture.detectChanges();\n        fixture.componentInstance.insert();\n        fixture.detectChanges();\n        expect(fixture.nativeElement.textContent).toBe('insert|before');\n      });\n    });\n  });\n  describe('non-regression', () => {\n    // https://github.com/angular/angular/issues/31971\n    it('should insert component views into ViewContainerRef injected by querying <ng-container>', () => {\n      @Component({\n        selector: 'dynamic-cmpt',\n        template: 'dynamic',\n        standalone: false,\n      })\n      class DynamicComponent {}\n      @Component({\n        selector: 'app-root',\n        template: `\n            <div>start|</div>\n            <ng-container #container></ng-container>\n            <div>|end</div>\n            <div (click)=\"click()\" >|click</div>\n        `,\n        standalone: false,\n      })\n      class AppComponent {\n        @ViewChild('container', {read: ViewContainerRef, static: true}) vcr!: ViewContainerRef;\n        click() {\n          this.vcr.createComponent(DynamicComponent);\n        }\n      }\n      TestBed.configureTestingModule({\n        declarations: [AppComponent, DynamicComponent],\n      });\n      const fixture = TestBed.createComponent(AppComponent);\n      fixture.detectChanges();\n      expect(fixture.nativeElement.textContent).toBe('start||end|click');\n      fixture.componentInstance.click();\n      fixture.detectChanges();\n      expect(fixture.nativeElement.textContent).toBe('start|dynamic|end|click');\n    });\n    // https://github.com/angular/angular/issues/33679\n    it('should insert embedded views into ViewContainerRef injected by querying <ng-container>', () => {\n      @Component({\n        selector: 'app-root',\n        template: `\n        <div>container start|</div>\n        <ng-container #container></ng-container>\n        <div>|container end</div>\n        <ng-template #template >test</ng-template>\n        <div (click)=\"click()\" >|click</div>\n        `,\n        standalone: false,\n      })\n      class AppComponent {\n        @ViewChild('container', {read: ViewContainerRef, static: true}) vcr!: ViewContainerRef;\n        @ViewChild('template', {read: TemplateRef, static: true}) template!: TemplateRef<any>;\n        click() {\n          this.vcr.createEmbeddedView(this.template, undefined, 0);\n        }\n      }\n      TestBed.configureTestingModule({\n        declarations: [AppComponent],\n      });\n      const fixture = TestBed.createComponent(AppComponent);\n      fixture.detectChanges();\n      expect(fixture.nativeElement.textContent).toBe('container start||container end|click');\n      fixture.componentInstance.click();\n      fixture.detectChanges();\n      expect(fixture.nativeElement.textContent).toBe('container start|test|container end|click');\n    });\n    it('should properly insert before views in a ViewContainerRef injected on ng-container', () => {\n      @Component({\n        selector: 'app-root',\n        template: `\n          <ng-template #parameterListItem let-parameter=\"parameter\">\n            {{parameter}}\n          </ng-template>\n          <ng-container *ngFor=\"let parameter of items;\"\n            [ngTemplateOutlet]=\"parameterListItem\"\n            [ngTemplateOutletContext]=\"{parameter:parameter}\">\n          </ng-container>\n        `,\n        standalone: false,\n      })\n      class AppComponent {\n        items = [1];\n      }\n      TestBed.configureTestingModule({\n        declarations: [AppComponent],\n        imports: [CommonModule],\n      });\n      const fixture = TestBed.createComponent(AppComponent);\n      fixture.detectChanges();\n      expect(fixture.nativeElement.textContent.trim()).toContain('1');\n      fixture.componentInstance.items = [2, 1];\n      fixture.detectChanges();\n      expect(fixture.nativeElement.textContent.trim()).toContain('2  1');\n    });\n  });\n  describe('create mode error handling', () => {\n    it('should consistently report errors raised a directive constructor', () => {\n      @Directive({\n        selector: '[failInConstructorAlways]',\n        standalone: false,\n      })\n      class FailInConstructorAlways {\n        constructor() {\n          throw new Error('Error in a constructor');\n        }\n      }\n      @Component({\n        template: `<div failInConstructorAlways></div>`,\n        standalone: false,\n      })\n      class TestCmpt {}\n      TestBed.configureTestingModule({\n        declarations: [TestCmpt, FailInConstructorAlways],\n      });\n      expect(() => {\n        TestBed.createComponent(TestCmpt);\n      }).toThrowError('Error in a constructor');\n      expect(() => {\n        TestBed.createComponent(TestCmpt);\n      }).toThrowError('Error in a constructor');\n    });\n    it('should render even if a directive constructor throws in the first create pass', () => {\n      let firstRun = true;\n      @Directive({\n        selector: '[failInConstructorOnce]',\n        standalone: false,\n      })\n      class FailInConstructorOnce {\n        constructor() {\n          if (firstRun) {\n            firstRun = false;\n            throw new Error('Error in a constructor');\n          }\n        }\n      }\n      @Component({\n        template: `<div failInConstructorOnce>OK</div>`,\n        standalone: false,\n      })\n      class TestCmpt {}\n      TestBed.configureTestingModule({\n        declarations: [TestCmpt, FailInConstructorOnce],\n      });\n      expect(() => {\n        TestBed.createComponent(TestCmpt);\n      }).toThrowError('Error in a constructor');\n      const fixture = TestBed.createComponent(TestCmpt);\n      expect(fixture.nativeElement.textContent).toContain('OK');\n    });\n    it('should consistently report errors raised a directive input setter', () => {\n      @Directive({\n        selector: '[failInInputAlways]',\n        standalone: false,\n      })\n      class FailInInputAlways {\n        @Input()\n        set failInInputAlways(_: string) {\n          throw new Error('Error in an input');\n        }\n      }\n      @Component({\n        template: `<div failInInputAlways=\"static\"></div>`,\n        standalone: false,\n      })\n      class TestCmpt {}\n      TestBed.configureTestingModule({\n        declarations: [TestCmpt, FailInInputAlways],\n      });\n      expect(() => {\n        TestBed.createComponent(TestCmpt);\n      }).toThrowError('Error in an input');\n      expect(() => {\n        TestBed.createComponent(TestCmpt);\n      }).toThrowError('Error in an input');\n    });\n    it('should consistently report errors raised a static query setter', () => {\n      @Directive({\n        selector: '[someDir]',\n        standalone: false,\n      })\n      class SomeDirective {}\n      @Component({\n        template: `<div someDir></div>`,\n        standalone: false,\n      })\n      class TestCmpt {\n        @ViewChild(SomeDirective, {static: true})\n        set directive(_: SomeDirective) {\n          throw new Error('Error in static query setter');\n        }\n      }\n      TestBed.configureTestingModule({\n        declarations: [TestCmpt, SomeDirective],\n      });\n      expect(() => {\n        TestBed.createComponent(TestCmpt);\n      }).toThrowError('Error in static query setter');\n      expect(() => {\n        TestBed.createComponent(TestCmpt);\n      }).toThrowError('Error in static query setter');\n    });\n    it('should match a static query, even if its setter throws in the first create pass', () => {\n      let hasThrown = false;\n      @Directive({\n        selector: '[someDir]',\n        standalone: false,\n      })\n      class SomeDirective {}\n      @Component({\n        template: `<div someDir></div>`,\n        standalone: false,\n      })\n      class TestCmpt {\n        @ViewChild(SomeDirective, {static: true})\n        get directive() {\n          return this._directive;\n        }\n        set directive(directiveInstance: SomeDirective) {\n          if (!hasThrown) {\n            hasThrown = true;\n            throw new Error('Error in static query setter');\n          }\n          this._directive = directiveInstance;\n        }\n        private _directive!: SomeDirective;\n      }\n      TestBed.configureTestingModule({\n        declarations: [TestCmpt, SomeDirective],\n      });\n      expect(() => {\n        TestBed.createComponent(TestCmpt);\n      }).toThrowError('Error in static query setter');\n      const fixture = TestBed.createComponent(TestCmpt);\n      expect(fixture.componentInstance.directive).toBeInstanceOf(SomeDirective);\n    });\n    it('should render a recursive component if it throws during the first creation pass', () => {\n      let hasThrown = false;\n      @Component({\n        selector: 'test',\n        template: `<ng-content></ng-content>OK`,\n        standalone: false,\n      })\n      class TestCmpt {\n        constructor() {\n          if (!hasThrown) {\n            hasThrown = true;\n            throw new Error('Error in a constructor');\n          }\n        }\n      }\n      @Component({\n        template: `<test><test><test></test></test></test>`,\n        standalone: false,\n      })\n      class App {}\n      TestBed.configureTestingModule({\n        declarations: [App, TestCmpt],\n      });\n      expect(() => {\n        TestBed.createComponent(App);\n      }).toThrowError('Error in a constructor');\n      const fixture = TestBed.createComponent(App);\n      expect(fixture.nativeElement.textContent).toContain('OKOKOK');\n    });\n    it('should continue detecting changes if a directive throws in its constructor', () => {\n      let firstRun = true;\n      @Directive({\n        selector: '[failInConstructorOnce]',\n        standalone: false,\n      })\n      class FailInConstructorOnce {\n        constructor() {\n          if (firstRun) {\n            firstRun = false;\n            throw new Error('Error in a constructor');\n          }\n        }\n      }\n      @Component({\n        template: `<div failInConstructorOnce>{{value}}</div>`,\n        standalone: false,\n      })\n      class TestCmpt {\n        value = 0;\n      }\n      TestBed.configureTestingModule({\n        declarations: [TestCmpt, FailInConstructorOnce],\n      });\n      expect(() => {\n        TestBed.createComponent(TestCmpt);\n      }).toThrowError('Error in a constructor');\n      const fixture = TestBed.createComponent(TestCmpt);\n      fixture.detectChanges();\n      expect(fixture.nativeElement.textContent).toContain('0');\n      fixture.componentInstance.value = 1;\n      fixture.detectChanges();\n      expect(fixture.nativeElement.textContent).toContain('1');\n      fixture.componentInstance.value = 2;\n      fixture.detectChanges();\n      expect(fixture.nativeElement.textContent).toContain('2');\n    });\n    it('should consistently report errors raised by createEmbeddedView', () => {\n      // Intentionally hasn't been added to `providers` so that it throws a DI error.\n      @Injectable()\n      class DoesNotExist {}\n      @Directive({\n        selector: 'dir',\n        standalone: false,\n      })\n      class Dir {\n        constructor(willCauseError: DoesNotExist) {}\n      }\n      @Component({\n        template: `\n          <ng-template #broken>\n            <dir></dir>\n          </ng-template>\n        `,\n        standalone: false,\n      })\n      class App {\n        @ViewChild('broken') template!: TemplateRef<unknown>;\n        constructor(private _viewContainerRef: ViewContainerRef) {}\n        insertTemplate() {\n          this._viewContainerRef.createEmbeddedView(this.template);\n        }\n      }\n      TestBed.configureTestingModule({declarations: [App, Dir]});\n      const fixture = TestBed.createComponent(App);\n      const tryRender = () => {\n        fixture.componentInstance.insertTemplate();\n        fixture.detectChanges();\n      };\n      fixture.detectChanges();\n      // We try to render the same template twice to ensure that we get consistent error messages.\n      expect(tryRender).toThrowError(/No provider for DoesNotExist/);\n      expect(tryRender).toThrowError(/No provider for DoesNotExist/);\n    });\n  });\n});", "llm_cg": {"App.ngAfterViewInit()": ["ViewContainerRef.createEmbeddedView(TemplateRef)", "ViewContainerRef.createEmbeddedView(TemplateRef, {}, 0)", "ViewContainerRef.createEmbeddedView(TemplateRef, {}, 2)", "ChangeDetectorRef.detectChanges()"], "App.constructor(ChangeDetectorRef)": [], "ViewInsertingDir.insert(ViewRef, TemplateRef)": ["ViewContainerRef.insert(ViewRef, 0)", "ViewContainerRef.createEmbeddedView(TemplateRef, {}, 0)"], "Comp.ngAfterViewInit()": ["ViewContainerRef.createEmbeddedView(TemplateRef)", "ViewContainerRef.createEmbeddedView(TemplateRef, {}, 0)", "ViewContainerRef.createEmbeddedView(TemplateRef, {}, 2)"], "Component.ngAfterViewInit()": [], "TestCmpt.insert()": ["TemplateRef.createEmbeddedView({})", "ViewRef.detectChanges()", "ViewInsertingDir.insert(ViewRef, TemplateRef)"], "AppComponent.click()": ["ViewContainerRef.createComponent(DynamicComponent)"], "App.click()": [], "Test.createEmbeddedView()": ["ViewInsertingDir.insert(ViewRef, TemplateRef)"], "TestCmpt.ngAfterViewInit()": [], "Test.click()": [], "App.insert()": ["IncrementComp.constructor(ChangeDetectorRef)", "ViewContainerRef.createEmbeddedView(TemplateRef)", "ViewContainerRef.createEmbeddedView(TemplateRef, {}, 0)", "ViewContainerRef.createEmbeddedView(TemplateRef)", "ViewContainerRef.createEmbeddedView(TemplateRef, {}, 2)"], "Test.insert()": ["ViewContainerRef.createComponent(DynamicComponent)"]}, "static_cg": {"@test/197.ts: %dflt.[static]%dflt()": ["@test/197.ts: %dflt.%AM0()"], "@test/197.ts: %dflt.%AM1$%AM0()": ["@test/197.ts: %dflt.%AM2$%AM1$%AM0()"], "@test/197.ts: %dflt.%AM3$%AM0()": ["@test/197.ts: %dflt.%AM4$%AM3$%AM0()"], "@test/197.ts: %dflt.%AM5$%AM0()": ["@test/197.ts: %dflt.%AM6$%AM5$%AM0()"], "@test/197.ts: %dflt.%AM7$%AM0()": ["@test/197.ts: %dflt.%AM8$%AM7$%AM0()"], "@test/197.ts: %dflt.%AM10$%AM9$%AM0()": ["@test/197.ts: %dflt.%AM11$%AM10$%AM9$%AM0()", "@test/197.ts: %dflt.%AM12$%AM10$%AM9$%AM0()", "@test/197.ts: %dflt.%AM13$%AM10$%AM9$%AM0()", "@test/197.ts: %dflt.%AM14$%AM10$%AM9$%AM0()", "@test/197.ts: %dflt.%AM15$%AM10$%AM9$%AM0()", "@test/197.ts: %dflt.%AM16$%AM10$%AM9$%AM0()", "@test/197.ts: %dflt.%AM17$%AM10$%AM9$%AM0()", "@test/197.ts: %dflt.%AM18$%AM10$%AM9$%AM0()", "@test/197.ts: %dflt.%AM19$%AM10$%AM9$%AM0()", "@test/197.ts: %dflt.%AM20$%AM10$%AM9$%AM0()", "@test/197.ts: %dflt.%AM21$%AM10$%AM9$%AM0()", "@test/197.ts: %dflt.%AM22$%AM10$%AM9$%AM0()", "@test/197.ts: %dflt.%AM23$%AM10$%AM9$%AM0()"], "@test/197.ts: %dflt.%AM24$%AM9$%AM0()": ["@test/197.ts: %dflt.%AM25$%AM24$%AM9$%AM0()", "@test/197.ts: %dflt.%AM26$%AM24$%AM9$%AM0()", "@test/197.ts: %dflt.%AM27$%AM24$%AM9$%AM0()"], "@test/197.ts: %dflt.%AM28$%AM9$%AM0()": ["@test/197.ts: %dflt.%AM29$%AM28$%AM9$%AM0()"], "@test/197.ts: %dflt.%AM9$%AM0()": ["@test/197.ts: %dflt.%AM10$%AM9$%AM0()", "@test/197.ts: %dflt.%AM24$%AM9$%AM0()", "@test/197.ts: %dflt.%AM28$%AM9$%AM0()"], "@test/197.ts: %dflt.%AM30$%AM0()": ["@test/197.ts: %dflt.%AM31$%AM30$%AM0()", "@test/197.ts: %dflt.%AM32$%AM30$%AM0()", "@test/197.ts: %dflt.%AM33$%AM30$%AM0()"], "@test/197.ts: %dflt.%AM35$%AM34$%AM0()": ["@test/197.ts: %dflt.%AM36$%AM35$%AM34$%AM0()", "@test/197.ts: %dflt.%AM37$%AM35$%AM34$%AM0()"], "@test/197.ts: %dflt.%AM38$%AM34$%AM0()": ["@test/197.ts: %dflt.%AM39$%AM38$%AM34$%AM0()"], "@test/197.ts: %dflt.%AM40$%AM34$%AM0()": ["@test/197.ts: %dflt.%AM41$%AM40$%AM34$%AM0()", "@test/197.ts: %dflt.%AM42$%AM40$%AM34$%AM0()"], "@test/197.ts: %dflt.%AM43$%AM34$%AM0()": ["@test/197.ts: %dflt.%AM44$%AM43$%AM34$%AM0()", "@test/197.ts: %dflt.%AM45$%AM43$%AM34$%AM0()"], "@test/197.ts: %dflt.%AM46$%AM34$%AM0()": ["@test/197.ts: %dflt.%AM47$%AM46$%AM34$%AM0()"], "@test/197.ts: %dflt.%AM48$%AM34$%AM0()": ["@test/197.ts: %dflt.%AM49$%AM48$%AM34$%AM0()"], "@test/197.ts: %dflt.%AM50$%AM34$%AM0()": ["@test/197.ts: %dflt.%AM51$%AM50$%AM34$%AM0()"], "@test/197.ts: %dflt.%AM52$%AM34$%AM0()": ["@test/197.ts: %dflt.%AM53$%AM52$%AM34$%AM0()"], "@test/197.ts: %dflt.%AM34$%AM0()": ["@test/197.ts: %dflt.%AM35$%AM34$%AM0()", "@test/197.ts: %dflt.%AM38$%AM34$%AM0()", "@test/197.ts: %dflt.%AM40$%AM34$%AM0()", "@test/197.ts: %dflt.%AM43$%AM34$%AM0()", "@test/197.ts: %dflt.%AM46$%AM34$%AM0()", "@test/197.ts: %dflt.%AM48$%AM34$%AM0()", "@test/197.ts: %dflt.%AM50$%AM34$%AM0()", "@test/197.ts: %dflt.%AM52$%AM34$%AM0()"], "@test/197.ts: %dflt.%AM0()": ["@test/197.ts: %dflt.%AM1$%AM0()", "@test/197.ts: %dflt.%AM3$%AM0()", "@test/197.ts: %dflt.%AM5$%AM0()", "@test/197.ts: %dflt.%AM7$%AM0()", "@test/197.ts: %dflt.%AM9$%AM0()", "@test/197.ts: %dflt.%AM30$%AM0()", "@test/197.ts: %dflt.%AM34$%AM0()"]}}
{"source_code": "import { IntegrationRepository } from '@novu/dal';\nimport { ChannelTypeEnum, InAppProviderIdEnum } from '@novu/shared';\nimport { UserSession } from '@novu/testing';\nimport { expect } from 'chai';\nimport { CacheInMemoryProviderService, CacheService, createHash } from '@novu/application-generic';\nconst integrationRepository = new IntegrationRepository();\nconst mockSubscriberId = '12345';\ndescribe('Session - /inbox/session (POST)', async () => {\n  let session: UserSession;\n  let cacheService: CacheService;\n  before(async () => {\n    const cacheInMemoryProviderService = new CacheInMemoryProviderService();\n    cacheService = new CacheService(cacheInMemoryProviderService);\n    await cacheService.initialize();\n  });\n  beforeEach(async () => {\n    session = new UserSession();\n    await session.initialize();\n    await setIntegrationConfig(\n      {\n        _environmentId: session.environment._id,\n        _organizationId: session.environment._organizationId,\n      },\n      cacheService\n    );\n  });\n  const initializeSession = async ({\n    applicationIdentifier,\n    subscriberId,\n    subscriberHash,\n  }: {\n    applicationIdentifier: string;\n    subscriberId: string;\n    subscriberHash?: string;\n  }) => {\n    return await session.testAgent.post('/v1/inbox/session').send({\n      applicationIdentifier,\n      subscriberId,\n      subscriberHash,\n    });\n  };\n  it('should initialize session', async function () {\n    await setIntegrationConfig(\n      {\n        _environmentId: session.environment._id,\n        _organizationId: session.environment._organizationId,\n        hmac: false,\n      },\n      cacheService\n    );\n    const { body, status } = await initializeSession({\n      applicationIdentifier: session.environment.identifier,\n      subscriberId: mockSubscriberId,\n    });\n    expect(status).to.equal(201);\n    expect(body.data.token).to.be.ok;\n    expect(body.data.totalUnreadCount).to.equal(0);\n  });\n  it('should initialize session with HMAC', async function () {\n    const secretKey = session.environment.apiKeys[0].key;\n    const subscriberHash = createHash(secretKey, mockSubscriberId);\n    const { body, status } = await initializeSession({\n      applicationIdentifier: session.environment.identifier,\n      subscriberId: mockSubscriberId,\n      subscriberHash,\n    });\n    expect(status).to.equal(201);\n    expect(body.data.token).to.be.ok;\n    expect(body.data.totalUnreadCount).to.equal(0);\n  });\n  it('should throw an error when invalid applicationIdentifier provided', async function () {\n    const { body, status } = await initializeSession({\n      applicationIdentifier: 'some-not-existing-id',\n      subscriberId: mockSubscriberId,\n    });\n    expect(status).to.equal(400);\n    expect(body.message).to.contain('Please provide a valid application identifier');\n  });\n  it('should throw an error when no active integrations', async function () {\n    await setIntegrationConfig(\n      {\n        _environmentId: session.environment._id,\n        _organizationId: session.environment._organizationId,\n        active: false,\n      },\n      cacheService\n    );\n    const { body, status } = await initializeSession({\n      applicationIdentifier: session.environment.identifier,\n      subscriberId: mockSubscriberId,\n    });\n    expect(status).to.equal(404);\n    expect(body.message).to.contain('The active in-app integration could not be found');\n  });\n  it('should throw an error when invalid subscriberHash provided', async function () {\n    const invalidSecretKey = 'invalid-secret-key';\n    const subscriberHash = createHash(invalidSecretKey, mockSubscriberId);\n    const { body, status } = await initializeSession({\n      applicationIdentifier: session.environment.identifier,\n      subscriberId: session.subscriberId,\n      subscriberHash,\n    });\n    expect(status).to.equal(400);\n    expect(body.message).to.contain('Please provide a valid HMAC hash');\n  });\n});\nasync function setIntegrationConfig(\n  {\n    _environmentId,\n    _organizationId,\n    hmac = true,\n    active = true,\n  }: { _environmentId: string; _organizationId: string; active?: boolean; hmac?: boolean },\n  cacheService: CacheService\n) {\n  await cacheService.delByPattern('*');\n  await integrationRepository.update(\n    {\n      _environmentId,\n      _organizationId,\n      providerId: InAppProviderIdEnum.Novu,\n      channel: ChannelTypeEnum.IN_APP,\n      active: true,\n    },\n    {\n      $set: {\n        'credentials.hmac': hmac,\n        active,\n      },\n    }\n  );\n}", "llm_cg": {"%AMX$before(async () =>)": ["CacheInMemoryProviderService.%AMX$CacheInMemoryProviderService()", "CacheService.%AMX$CacheService(CacheInMemoryProviderService)", "CacheService.initialize()"], "%AMX$beforeEach(async () =>)": ["UserSession.%AMX$UserSession()", "UserSession.initialize()", "setIntegrationConfig({ _environmentId: string, _organizationId: string; active?: boolean; hmac?: boolean }, CacheService)"], "%AMX$it(should initialize session, async function ()": ["setIntegrationConfig({ _environmentId: string, _organizationId: string; hmac: boolean }, CacheService)", "%AMX$initializeSession({ applicationIdentifier: string, subscriberId: string })"], "%AMX$it(should initialize session with HMAC, async function ()": ["session.environment.apiKeys[]", "createHash(string, string)", "%AMX$initializeSession({ applicationIdentifier: string, subscriberId: string; subscriberHash?: string })"], "%AMX$it(should throw an error when invalid applicationIdentifier provided, async function ()": ["%AMX$initializeSession({ applicationIdentifier: string, subscriberId: string })"], "%AMX$it(should throw an error when no active integrations, async function ()": ["setIntegrationConfig({ _environmentId: string, _organizationId: string; active: boolean }, CacheService)", "%AMX$initializeSession({ applicationIdentifier: string, subscriberId: string })"], "%AMX$it(should throw an error when invalid subscriberHash provided, async function ()": ["createHash(string, string)", "%AMX$initializeSession({ applicationIdentifier: string, subscriberId: string; subscriberHash?: string })"], "initializeSession({ applicationIdentifier: string, subscriberId: string, subscriberHash?: string })": ["session.testAgent.post('/v1/inbox/session').send({ applicationIdentifier: string, subscriberId: string, subscriberHash?: string })"], "setIntegrationConfig({ _environmentId: string, _organizationId: string; active?: boolean; hmac?: boolean }, CacheService)": ["CacheService.delByPattern('*')", "IntegrationRepository.update({ _environmentId: string, _organizationId: string; providerId: InAppProviderIdEnum, channel: ChannelTypeEnum, active: boolean }, { $set: { 'credentials.hmac': boolean, active: boolean } })"]}, "static_cg": {"@test/198.ts: %dflt.[static]%dflt()": ["@test/198.ts: %dflt.%AM0()"], "@test/198.ts: %dflt.%AM2$%AM0()": ["@test/198.ts: %dflt.setIntegrationConfig(@test/198.ts: %AC$0, CacheService)"], "@test/198.ts: %dflt.%AM4$%AM0()": ["@test/198.ts: %dflt.setIntegrationConfig(@test/198.ts: %AC$0, CacheService)"], "@test/198.ts: %dflt.%AM7$%AM0()": ["@test/198.ts: %dflt.setIntegrationConfig(@test/198.ts: %AC$0, CacheService)"], "@test/198.ts: %dflt.%AM0()": ["@test/198.ts: %dflt.%AM1$%AM0()", "@test/198.ts: %dflt.%AM2$%AM0()", "@test/198.ts: %dflt.%AM4$%AM0()", "@test/198.ts: %dflt.%AM5$%AM0()", "@test/198.ts: %dflt.%AM6$%AM0()", "@test/198.ts: %dflt.%AM7$%AM0()", "@test/198.ts: %dflt.%AM8$%AM0()"]}}
{"source_code": "import type { MigrationContext, ReversibleMigration } from '@/databases/types';\nexport class DeleteExecutionsWithWorkflows1673268682475 implements ReversibleMigration {\n\ttransaction = false as const;\n\tasync up({ queryRunner, tablePrefix }: MigrationContext) {\n\t\tconst workflowIds = (await queryRunner.query(`\n\t\t\tSELECT id FROM \"${tablePrefix}workflow_entity\"\n\t\t`)) as Array<{ id: number }>;\n\t\tawait queryRunner.query(\n\t\t\t`DELETE FROM \"${tablePrefix}execution_entity\"\n\t\t\t WHERE \"workflowId\" IS NOT NULL\n\t\t\t ${\n\t\t\t\t\tworkflowIds.length\n\t\t\t\t\t\t? `AND \"workflowId\" NOT IN (${workflowIds.map(({ id }) => id).join()})`\n\t\t\t\t\t\t: ''\n\t\t\t\t}`,\n\t\t);\n\t\tawait queryRunner.query(`DROP TABLE IF EXISTS \"${tablePrefix}temporary_execution_entity\"`);\n\t\tawait queryRunner.query(\n\t\t\t`CREATE TABLE \"${tablePrefix}temporary_execution_entity\" (\n\t\t\t\t\"id\" integer PRIMARY KEY AUTOINCREMENT NOT NULL,\n\t\t\t\t\"workflowId\" int,\n\t\t\t\t\"finished\" boolean NOT NULL,\n\t\t\t\t\"mode\" varchar NOT NULL,\n\t\t\t\t\"retryOf\" varchar,\n\t\t\t\t\"retrySuccessId\" varchar,\n\t\t\t\t\"startedAt\" datetime NOT NULL,\n\t\t\t\t\"stoppedAt\" datetime,\n\t\t\t\t\"waitTill\" datetime,\n\t\t\t\t\"workflowData\" text NOT NULL,\n\t\t\t\t\"data\" text NOT NULL,\n\t\t\t\tFOREIGN KEY(\"workflowId\") REFERENCES \"${tablePrefix}workflow_entity\" (\"id\") ON DELETE CASCADE\n\t\t\t)`,\n\t\t);\n\t\tconst columns =\n\t\t\t'\"id\", \"workflowId\", \"finished\", \"mode\", \"retryOf\", \"retrySuccessId\", \"startedAt\", \"stoppedAt\", \"waitTill\", \"workflowData\", \"data\"';\n\t\tawait queryRunner.query(\n\t\t\t`INSERT INTO \"${tablePrefix}temporary_execution_entity\"(${columns}) SELECT ${columns} FROM \"${tablePrefix}execution_entity\"`,\n\t\t);\n\t\tawait queryRunner.query(`DROP TABLE \"${tablePrefix}execution_entity\"`);\n\t\tawait queryRunner.query(\n\t\t\t`ALTER TABLE \"${tablePrefix}temporary_execution_entity\" RENAME TO \"${tablePrefix}execution_entity\"`,\n\t\t);\n\t\tawait queryRunner.query(\n\t\t\t`CREATE INDEX \"IDX_${tablePrefix}cefb067df2402f6aed0638a6c1\" ON \"${tablePrefix}execution_entity\" (\"stoppedAt\")`,\n\t\t);\n\t\tawait queryRunner.query(\n\t\t\t`CREATE INDEX \"IDX_${tablePrefix}ca4a71b47f28ac6ea88293a8e2\" ON \"${tablePrefix}execution_entity\" (\"waitTill\")`,\n\t\t);\n\t}\n\tasync down({ queryRunner, tablePrefix }: MigrationContext) {\n\t\tawait queryRunner.query(`DROP TABLE IF EXISTS \"${tablePrefix}temporary_execution_entity\"`);\n\t\tawait queryRunner.query(\n\t\t\t`CREATE TABLE \"${tablePrefix}temporary_execution_entity\" (\n\t\t\t\t\"id\" integer PRIMARY KEY AUTOINCREMENT NOT NULL,\n\t\t\t\t\"workflowId\" varchar,\n\t\t\t\t\"finished\" boolean NOT NULL,\n\t\t\t\t\"mode\" varchar NOT NULL,\n\t\t\t\t\"retryOf\" varchar,\n\t\t\t\t\"retrySuccessId\" varchar,\n\t\t\t\t\"startedAt\" datetime NOT NULL,\n\t\t\t\t\"stoppedAt\" datetime,\n\t\t\t\t\"waitTill\" datetime,\n\t\t\t\t\"workflowData\" text NOT NULL,\n\t\t\t\t\"data\" text NOT NULL\n\t\t\t)`,\n\t\t);\n\t\tconst columns =\n\t\t\t'\"id\", \"workflowId\", \"finished\", \"mode\", \"retryOf\", \"retrySuccessId\", \"startedAt\", \"stoppedAt\", \"waitTill\", \"workflowData\", \"data\"';\n\t\tawait queryRunner.query(\n\t\t\t`INSERT INTO \"${tablePrefix}temporary_execution_entity\"(${columns}) SELECT ${columns} FROM \"${tablePrefix}execution_entity\"`,\n\t\t);\n\t\tawait queryRunner.query(`DROP TABLE \"${tablePrefix}execution_entity\"`);\n\t\tawait queryRunner.query(\n\t\t\t`ALTER TABLE \"${tablePrefix}temporary_execution_entity\" RENAME TO \"${tablePrefix}execution_entity\"`,\n\t\t);\n\t\tawait queryRunner.query(\n\t\t\t`CREATE INDEX \"IDX_${tablePrefix}cefb067df2402f6aed0638a6c1\" ON \"${tablePrefix}execution_entity\" (\"stoppedAt\")`,\n\t\t);\n\t\tawait queryRunner.query(\n\t\t\t`CREATE INDEX \"IDX_${tablePrefix}ca4a71b47f28ac6ea88293a8e2\" ON \"${tablePrefix}execution_entity\" (\"waitTill\")`,\n\t\t);\n\t}\n}", "llm_cg": {"DeleteExecutionsWithWorkflows1673268682475.up(MigrationContext)": [], "DeleteExecutionsWithWorkflows1673268682475.down(MigrationContext)": []}, "static_cg": {"@test/199.ts: DeleteExecutionsWithWorkflows1673268682475.up(MigrationContext)": ["@test/199.ts: DeleteExecutionsWithWorkflows1673268682475.%AM0$up(unknown)"]}}
