{
  "name": "example_script",
  "type": "CFG",
  "start_line": 1,
  "end_line": 263,
  "functions": [
    {
      "name": "transformPoints",
      "type": "function",
      "start_line": 9,
      "end_line": 13,
      "functions": [],
      "classes": [],
      "simplified_code": "function transformPoints(points: number[][], transform: matrix.MatrixArray) {\n    for (let p = 0; p < points.length; p++) {\n        vec2.applyTransform(points[p], points[p], transform);\n    }\n}",
      "blocks": [
        {
          "id": 1,
          "label": "function transformPoints(points: number[][], transform: matrix.MatrixArray) {",
          "successors": [
            {
              "id": 2,
              "label": "    for (let p = 0; p < points.length; p++) {",
              "successors": [
                {
                  "id": 3,
                  "label": "        vec2.applyTransform(points[p], points[p], transform);",
                  "successors": [
                    {
                      "id": 4,
                      "label": "    }",
                      "successors": [
                        {
                          "id": 5,
                          "label": "}",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "updateBBoxFromPoints",
      "type": "function",
      "start_line": 14,
      "end_line": 31,
      "functions": [],
      "classes": [],
      "simplified_code": "function updateBBoxFromPoints(\n    points: ArrayLike<number>[],\n    min: vec2.VectorArray,\n    max: vec2.VectorArray,\n    projection: GeoProjection\n) {\n    for (let i = 0; i < points.length; i++) {\n        let p = points[i];\n        if (projection) {\n            // projection may return null point.\n            p = projection.project(p as number[]);\n        }\n        if (p && isFinite(p[0]) && isFinite(p[1])) {\n            vec2.min(min, min, p as vec2.VectorArray);\n            vec2.max(max, max, p as vec2.VectorArray);\n        }\n    }\n}",
      "blocks": [
        {
          "id": 1,
          "label": "function updateBBoxFromPoints(\n    points: ArrayLike<number>[],\n    min: vec2.VectorArray,\n    max: vec2.VectorArray,\n    projection: GeoProjection\n) {",
          "successors": [
            {
              "id": 2,
              "label": "for (let i = 0; i < points.length; i++) {",
              "successors": [
                {
                  "id": 3,
                  "label": "let p = points[i];",
                  "successors": [
                    {
                      "id": 4,
                      "label": "if (projection) {",
                      "successors": [
                        {
                          "id": 5,
                          "label": "// projection may return null point.\np = projection.project(p as number[]);",
                          "successors": [
                            {
                              "id": 6,
                              "label": "if (p && isFinite(p[0]) && isFinite(p[1])) {",
                              "successors": [
                                {
                                  "id": 7,
                                  "label": "vec2.min(min, min, p as vec2.VectorArray);\nvec2.max(max, max, p as vec2.VectorArray);",
                                  "successors": [
                                    {
                                      "id": 8,
                                      "label": "",
                                      "successors": [
                                        {
                                          "id": 9,
                                          "label": "// }",
                                          "successors": []
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "centroid",
      "type": "function",
      "start_line": 32,
      "end_line": 53,
      "functions": [],
      "classes": [],
      "simplified_code": "function centroid(points: number[][]) {\n    let signedArea = 0;\n    let cx = 0;\n    let cy = 0;\n    const len = points.length;\n    let x0 = points[len - 1][0];\n    let y0 = points[len - 1][1];\n    // Polygon should been closed.\n    for (let i = 0; i < len; i++) {\n        const x1 = points[i][0];\n        const y1 = points[i][1];\n        const a = x0 * y1 - x1 * y0;\n        signedArea += a;\n        cx += (x0 + x1) * a;\n        cy += (y0 + y1) * a;\n        x0 = x1;\n        y0 = y1;\n    }\n    return signedArea\n        ? [cx / signedArea / 3, cy / signedArea / 3, signedArea]\n        : [points[0][0] || 0, points[0][1] || 0];\n}",
      "blocks": [
        {
          "id": 1,
          "label": "function centroid(points: number[][]) {\n    let signedArea = 0;\n    let cx = 0;\n    let cy = 0;\n    const len = points.length;\n    let x0 = points[len - 1][0];\n    let y0 = points[len - 1][1];",
          "successors": [
            {
              "id": 2,
              "label": "for (let i = 0; i < len; i++) {\n    const x1 = points[i][0];\n    const y1 = points[i][1];\n    const a = x0 * y1 - x1 * y0;\n    signedArea += a;\n    cx += (x0 + x1) * a;\n    cy += (y0 + y1) * a;\n  x0 = x1;\n  y0 = y1;",
              "successors": [
                {
                  "id": 3,
                  "label": "i++;",
                  "successors": [
                    {
                      "id": 2,
                      "label": "for (let i = 0; i < len; i++) {\n    const x1 = points[i][0];\n    const y1 = points[i][1];\n    const a = x0 * y1 - x1 * y0;\n    signedArea += a;\n    cx += (x0 + x1) * a;\n    cy += (y0 + y1) * a;\n  x0 = x1;\n  y0 = y1;",
                      "successors": []
                    }
                  ]
                }
              ]
            },
            {
              "id": 4,
              "label": "}",
              "successors": [
                {
                  "id": 5,
                  "label": "return signedArea\n      ? [cx / signedArea / 3, cy / signedArea / 3, signedArea]\n      : [points[0][0] || 0, points[0][1] || 0];",
                  "successors": []
                }
              ]
            }
          ]
        }
      ]
    }
  ],
  "classes": [
    {
      "name": "Region",
      "type": "class",
      "start_line": 54,
      "end_line": 77,
      "functions": [
        {
          "name": "constructor",
          "type": "function",
          "start_line": 59,
          "end_line": 63,
          "functions": [],
          "classes": [],
          "simplified_code": "    constructor(\n        name: string\n    ) {\n        this.name = name;\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "constructor(\n    name: string\n) {",
              "successors": [
                {
                  "id": 2,
                  "label": "    this.name = name;",
                  "successors": [
                    {
                      "id": 3,
                      "label": "}",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "setCenter",
          "type": "function",
          "start_line": 64,
          "end_line": 66,
          "functions": [],
          "classes": [],
          "simplified_code": "    setCenter(center: number[]) {\n        this._center = center;\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "setCenter(center: number[]) {",
              "successors": [
                {
                  "id": 2,
                  "label": "    this._center = center;",
                  "successors": [
                    {
                      "id": 3,
                      "label": "}",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "getCenter",
          "type": "function",
          "start_line": 67,
          "end_line": 75,
          "functions": [],
          "classes": [],
          "simplified_code": "    getCenter() {\n        let center = this._center;\n        if (!center) {\n            // In most cases there are no need to calculate this center.\n            // So calculate only when called.\n            center = this._center = this.calcCenter();\n        }\n        return center;\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "getCenter() {",
              "successors": [
                {
                  "id": 2,
                  "label": "let center = this._center;",
                  "successors": [
                    {
                      "id": 3,
                      "label": "if (!center) {",
                      "successors": [
                        {
                          "id": 4,
                          "label": "// In most cases there are no need to calculate this center.\n// So calculate only when called.",
                          "successors": [
                            {
                              "id": 5,
                              "label": "center = this._center = this.calcCenter();",
                              "successors": [
                                {
                                  "id": 6,
                                  "label": "}",
                                  "successors": [
                                    {
                                      "id": 7,
                                      "label": "return center;",
                                      "successors": [
                                        {
                                          "id": 8,
                                          "label": "}",
                                          "successors": []
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "calcCenter",
          "type": "function",
          "start_line": 76,
          "end_line": 76,
          "functions": [],
          "classes": [],
          "simplified_code": "    abstract calcCenter(): number[];",
          "blocks": [
            {
              "id": 1,
              "label": "abstract calcCenter(): number[];",
              "successors": []
            }
          ]
        }
      ],
      "classes": [],
      "simplified_code": "export abstract class Region {\n    readonly name: string;\n    readonly type: 'geoJSON' | 'geoSVG';\n    protected _center: number[];\n    protected _rect: BoundingRect;\n    }\n    }\n    }\n    abstract calcCenter(): number[];\n}",
      "blocks": [
        {
          "id": 1,
          "label": "export abstract class Region {",
          "successors": [
            {
              "id": 2,
              "label": "    readonly name: string;\n    readonly type: 'geoJSON' | 'geoSVG';\n    protected _center: number[];\n    protected _rect: BoundingRect;",
              "successors": [
                {
                  "id": 3,
                  "label": "    abstract calcCenter(): number[];",
                  "successors": []
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "GeoJSONPolygonGeometry",
      "type": "class",
      "start_line": 78,
      "end_line": 86,
      "functions": [
        {
          "name": "constructor",
          "type": "function",
          "start_line": 82,
          "end_line": 85,
          "functions": [],
          "classes": [],
          "simplified_code": "    constructor(exterior: number[][], interiors: number[][][]) {\n        this.exterior = exterior;\n        this.interiors = interiors;\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "constructor(exterior: number[][], interiors: number[][][]) {",
              "successors": [
                {
                  "id": 2,
                  "label": "    this.exterior = exterior;",
                  "successors": [
                    {
                      "id": 3,
                      "label": "    this.interiors = interiors;",
                      "successors": [
                        {
                          "id": 4,
                          "label": "}",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "classes": [],
      "simplified_code": "export class GeoJSONPolygonGeometry {\n    readonly type = 'polygon';\n    exterior: number[][];\n    interiors?: number[][][];\n    }\n}",
      "blocks": [
        {
          "id": 1,
          "label": "export class GeoJSONPolygonGeometry {",
          "successors": [
            {
              "id": 2,
              "label": "    readonly type = 'polygon';",
              "successors": [
                {
                  "id": 3,
                  "label": "    exterior: number[][];",
                  "successors": [
                    {
                      "id": 4,
                      "label": "    interiors?: number[][][];",
                      "successors": [
                        {
                          "id": 5,
                          "label": "}",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "GeoJSONLineStringGeometry",
      "type": "class",
      "start_line": 87,
      "end_line": 93,
      "functions": [
        {
          "name": "constructor",
          "type": "function",
          "start_line": 90,
          "end_line": 92,
          "functions": [],
          "classes": [],
          "simplified_code": "    constructor(points: number[][][]) {\n        this.points = points;\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "constructor(points: number[][][]) {",
              "successors": [
                {
                  "id": 2,
                  "label": "    this.points = points;",
                  "successors": [
                    {
                      "id": 3,
                      "label": "}",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "classes": [],
      "simplified_code": "export class GeoJSONLineStringGeometry {\n    readonly type = 'linestring';\n    points: number[][][];\n    }\n}",
      "blocks": [
        {
          "id": 1,
          "label": "export class GeoJSONLineStringGeometry {",
          "successors": [
            {
              "id": 2,
              "label": "readonly type = 'linestring';",
              "successors": [
                {
                  "id": 3,
                  "label": "points: number[][][];",
                  "successors": [
                    {
                      "id": 4,
                      "label": "}",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "GeoJSONRegion",
      "type": "class",
      "start_line": 94,
      "end_line": 232,
      "functions": [
        {
          "name": "constructor",
          "type": "function",
          "start_line": 99,
          "end_line": 107,
          "functions": [],
          "classes": [],
          "simplified_code": "    constructor(\n        name: string,\n        geometries: GeoJSONRegion['geometries'],\n        cp: GeoJSON['features'][0]['properties']['cp']\n    ) {\n        super(name);\n        this.geometries = geometries;\n        this._center = cp && [cp[0], cp[1]];\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "constructor(\n    name: string,\n    geometries: GeoJSONRegion['geometries'],\n    cp: GeoJSON['features'][0]['properties']['cp']\n) {",
              "successors": [
                {
                  "id": 2,
                  "label": "    super(name);",
                  "successors": [
                    {
                      "id": 3,
                      "label": "    this.geometries = geometries;",
                      "successors": [
                        {
                          "id": 4,
                          "label": "    this._center = cp && [cp[0], cp[1]];",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "calcCenter",
          "type": "function",
          "start_line": 108,
          "end_line": 132,
          "functions": [],
          "classes": [],
          "simplified_code": "    calcCenter() {\n        const geometries = this.geometries;\n        let largestGeo: GeoJSONPolygonGeometry;\n        let largestGeoSize = 0;\n        for (let i = 0; i < geometries.length; i++) {\n            const geo = geometries[i] as GeoJSONPolygonGeometry;\n            const exterior = geo.exterior;\n            // Simple trick to use points count instead of polygon area as region size.\n            // Ignore linestring\n            const size = exterior && exterior.length;\n            if (size > largestGeoSize) {\n                largestGeo = geo;\n                largestGeoSize = size;\n            }\n        }\n        if (largestGeo) {\n            return centroid(largestGeo.exterior);\n        }\n        // from bounding rect by default.\n        const rect = this.getBoundingRect();\n        return [\n            rect.x + rect.width / 2,\n            rect.y + rect.height / 2\n        ];\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "calcCenter() {\n    const geometries = this.geometries;\n    let largestGeo: GeoJSONPolygonGeometry;\n    let largestGeoSize = 0;",
              "successors": [
                {
                  "id": 2,
                  "label": "for (let i = 0; i < geometries.length; i++) {\n    const geo = geometries[i] as GeoJSONPolygonGeometry;\n    const exterior = geo.exterior;\n    // Simple trick to use points count instead of polygon area as region size.\n    // Ignore linestring\n    const size = exterior && exterior.length;",
                  "successors": [
                    {
                      "id": 3,
                      "label": "if (size > largestGeoSize) {\n    largestGeo = geo;\n    largestGeoSize = size;\n}",
                      "successors": [
                        {
                          "id": 2,
                          "label": "for (let i = 0; i < geometries.length; i++) {\n    const geo = geometries[i] as GeoJSONPolygonGeometry;\n    const exterior = geo.exterior;\n    // Simple trick to use points count instead of polygon area as region size.\n    // Ignore linestring\n    const size = exterior && exterior.length;",
                          "successors": []
                        },
                        {
                          "id": 5,
                          "label": "if (largestGeo) {\n    return centroid(largestGeo.exterior);\n}",
                          "successors": [
                            {
                              "id": 6,
                              "label": "// from bounding rect by default.\nconst rect = this.getBoundingRect();\nreturn [\n    rect.x + rect.width / 2,\n    rect.y + rect.height / 2\n];\n}",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "getBoundingRect",
          "type": "function",
          "start_line": 133,
          "end_line": 163,
          "functions": [],
          "classes": [],
          "simplified_code": "    getBoundingRect(projection?: GeoProjection): BoundingRect {\n        let rect = this._rect;\n        // Always recalculate if using projection.\n        if (rect && !projection) {\n            return rect;\n        }\n        const min = [Infinity, Infinity];\n        const max = [-Infinity, -Infinity];\n        const geometries = this.geometries;\n        each(geometries, geo => {\n            if (geo.type === 'polygon') {\n                // Doesn't consider hole\n                updateBBoxFromPoints(geo.exterior, min, max, projection);\n            }\n            else {\n                each(geo.points, (points) => {\n                    updateBBoxFromPoints(points, min, max, projection);\n                });\n            }\n        });\n        // Normalie invalid bounding.\n        if (!(isFinite(min[0]) && isFinite(min[1]) && isFinite(max[0]) && isFinite(max[1]))) {\n            min[0] = min[1] = max[0] = max[1] = 0;\n        }\n        rect = new BoundingRect(\n            min[0], min[1], max[0] - min[0], max[1] - min[1]\n        );\n        if (!projection) {\n            this._rect = rect;\n        }\n        return rect;",
          "blocks": [
            {
              "id": 1,
              "label": "getBoundingRect(projection?: GeoProjection): BoundingRect {",
              "successors": [
                {
                  "id": 2,
                  "label": "    let rect = this._rect;",
                  "successors": [
                    {
                      "id": 3,
                      "label": "if (rect && !projection) {",
                      "successors": [
                        {
                          "id": 4,
                          "label": "    return rect;",
                          "successors": []
                        },
                        {
                          "id": 5,
                          "label": "const min = [Infinity, Infinity];\nconst max = [-Infinity, -Infinity];\nconst geometries = this.geometries;",
                          "successors": [
                            {
                              "id": 6,
                              "label": "each(geometries, geo => {",
                              "successors": [
                                {
                                  "id": 7,
                                  "label": "if (geo.type === 'polygon') {",
                                  "successors": [
                                    {
                                      "id": 8,
                                      "label": "    updateBBoxFromPoints(geo.exterior, min, max, projection);",
                                      "successors": [
                                        {
                                          "id": 10,
                                          "label": "each(geo.points, (points) => {\n    updateBBoxFromPoints(points, min, max, projection);\n});",
                                          "successors": []
                                        },
                                        {
                                          "id": 9,
                                          "label": "} else {",
                                          "successors": []
                                        }
                                      ]
                                    },
                                    {
                                      "id": 9,
                                      "label": "} else {",
                                      "successors": [
                                        {
                                          "id": 10,
                                          "label": "each(geo.points, (points) => {\n    updateBBoxFromPoints(points, min, max, projection);\n});",
                                          "successors": []
                                        }
                                      ]
                                    }
                                  ]
                                },
                                {
                                  "id": 11,
                                  "label": "});",
                                  "successors": [
                                    {
                                      "id": 12,
                                      "label": "if (!(isFinite(min[0]) && isFinite(min[1]) && isFinite(max[0]) && isFinite(max[1]))) {",
                                      "successors": [
                                        {
                                          "id": 13,
                                          "label": "    min[0] = min[1] = max[0] = max[1] = 0;",
                                          "successors": [
                                            {
                                              "id": 15,
                                              "label": "rect = new BoundingRect(\n    min[0], min[1], max[0] - min[0], max[1] - min[1]\n);",
                                              "successors": [
                                                {
                                                  "id": 16,
                                                  "label": "if (!projection) {",
                                                  "successors": [
                                                    {
                                                      "id": 17,
                                                      "label": "    this._rect = rect;",
                                                      "successors": []
                                                    },
                                                    {
                                                      "id": 18,
                                                      "label": "}",
                                                      "successors": [
                                                        {
                                                          "id": 19,
                                                          "label": "return rect;",
                                                          "successors": []
                                                        }
                                                      ]
                                                    }
                                                  ]
                                                },
                                                {
                                                  "id": 18,
                                                  "label": "}",
                                                  "successors": [
                                                    {
                                                      "id": 19,
                                                      "label": "return rect;",
                                                      "successors": []
                                                    }
                                                  ]
                                                }
                                              ]
                                            }
                                          ]
                                        },
                                        {
                                          "id": 15,
                                          "label": "rect = new BoundingRect(\n    min[0], min[1], max[0] - min[0], max[1] - min[1]\n);",
                                          "successors": [
                                            {
                                              "id": 16,
                                              "label": "if (!projection) {",
                                              "successors": [
                                                {
                                                  "id": 17,
                                                  "label": "    this._rect = rect;",
                                                  "successors": []
                                                },
                                                {
                                                  "id": 18,
                                                  "label": "}",
                                                  "successors": [
                                                    {
                                                      "id": 19,
                                                      "label": "return rect;",
                                                      "successors": []
                                                    }
                                                  ]
                                                }
                                              ]
                                            },
                                            {
                                              "id": 18,
                                              "label": "}",
                                              "successors": [
                                                {
                                                  "id": 19,
                                                  "label": "return rect;",
                                                  "successors": []
                                                }
                                              ]
                                            }
                                          ]
                                        }
                                      ]
                                    },
                                    {
                                      "id": 15,
                                      "label": "rect = new BoundingRect(\n    min[0], min[1], max[0] - min[0], max[1] - min[1]\n);",
                                      "successors": [
                                        {
                                          "id": 16,
                                          "label": "if (!projection) {",
                                          "successors": [
                                            {
                                              "id": 17,
                                              "label": "    this._rect = rect;",
                                              "successors": []
                                            },
                                            {
                                              "id": 18,
                                              "label": "}",
                                              "successors": [
                                                {
                                                  "id": 19,
                                                  "label": "return rect;",
                                                  "successors": []
                                                }
                                              ]
                                            }
                                          ]
                                        },
                                        {
                                          "id": 18,
                                          "label": "}",
                                          "successors": [
                                            {
                                              "id": 19,
                                              "label": "return rect;",
                                              "successors": []
                                            }
                                          ]
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            },
                            {
                              "id": 12,
                              "label": "if (!(isFinite(min[0]) && isFinite(min[1]) && isFinite(max[0]) && isFinite(max[1]))) {",
                              "successors": [
                                {
                                  "id": 13,
                                  "label": "    min[0] = min[1] = max[0] = max[1] = 0;",
                                  "successors": [
                                    {
                                      "id": 15,
                                      "label": "rect = new BoundingRect(\n    min[0], min[1], max[0] - min[0], max[1] - min[1]\n);",
                                      "successors": [
                                        {
                                          "id": 16,
                                          "label": "if (!projection) {",
                                          "successors": [
                                            {
                                              "id": 17,
                                              "label": "    this._rect = rect;",
                                              "successors": []
                                            },
                                            {
                                              "id": 18,
                                              "label": "}",
                                              "successors": [
                                                {
                                                  "id": 19,
                                                  "label": "return rect;",
                                                  "successors": []
                                                }
                                              ]
                                            }
                                          ]
                                        },
                                        {
                                          "id": 18,
                                          "label": "}",
                                          "successors": [
                                            {
                                              "id": 19,
                                              "label": "return rect;",
                                              "successors": []
                                            }
                                          ]
                                        }
                                      ]
                                    }
                                  ]
                                },
                                {
                                  "id": 15,
                                  "label": "rect = new BoundingRect(\n    min[0], min[1], max[0] - min[0], max[1] - min[1]\n);",
                                  "successors": [
                                    {
                                      "id": 16,
                                      "label": "if (!projection) {",
                                      "successors": [
                                        {
                                          "id": 17,
                                          "label": "    this._rect = rect;",
                                          "successors": []
                                        },
                                        {
                                          "id": 18,
                                          "label": "}",
                                          "successors": [
                                            {
                                              "id": 19,
                                              "label": "return rect;",
                                              "successors": []
                                            }
                                          ]
                                        }
                                      ]
                                    },
                                    {
                                      "id": 18,
                                      "label": "}",
                                      "successors": [
                                        {
                                          "id": 19,
                                          "label": "return rect;",
                                          "successors": []
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            },
                            {
                              "id": 15,
                              "label": "rect = new BoundingRect(\n    min[0], min[1], max[0] - min[0], max[1] - min[1]\n);",
                              "successors": [
                                {
                                  "id": 16,
                                  "label": "if (!projection) {",
                                  "successors": [
                                    {
                                      "id": 17,
                                      "label": "    this._rect = rect;",
                                      "successors": []
                                    },
                                    {
                                      "id": 18,
                                      "label": "}",
                                      "successors": [
                                        {
                                          "id": 19,
                                          "label": "return rect;",
                                          "successors": []
                                        }
                                      ]
                                    }
                                  ]
                                },
                                {
                                  "id": 18,
                                  "label": "}",
                                  "successors": [
                                    {
                                      "id": 19,
                                      "label": "return rect;",
                                      "successors": []
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        },
                        {
                          "id": 15,
                          "label": "rect = new BoundingRect(\n    min[0], min[1], max[0] - min[0], max[1] - min[1]\n);",
                          "successors": [
                            {
                              "id": 16,
                              "label": "if (!projection) {",
                              "successors": [
                                {
                                  "id": 17,
                                  "label": "    this._rect = rect;",
                                  "successors": []
                                },
                                {
                                  "id": 18,
                                  "label": "}",
                                  "successors": [
                                    {
                                      "id": 19,
                                      "label": "return rect;",
                                      "successors": []
                                    }
                                  ]
                                }
                              ]
                            },
                            {
                              "id": 18,
                              "label": "}",
                              "successors": [
                                {
                                  "id": 19,
                                  "label": "return rect;",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "id": 4,
                      "label": "    return rect;",
                      "successors": []
                    }
                  ]
                },
                {
                  "id": 18,
                  "label": "}",
                  "successors": [
                    {
                      "id": 19,
                      "label": "return rect;",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "contain",
          "type": "function",
          "start_line": 165,
          "end_line": 189,
          "functions": [],
          "classes": [],
          "simplified_code": "    contain(coord: number[]): boolean {\n        const rect = this.getBoundingRect();\n        const geometries = this.geometries;\n        if (!rect.contain(coord[0], coord[1])) {\n            return false;\n        }\n        loopGeo: for (let i = 0, len = geometries.length; i < len; i++) {\n            const geo = geometries[i];\n            // Only support polygon.\n            if (geo.type !== 'polygon') {\n                continue;\n            }\n            const exterior = geo.exterior;\n            const interiors = geo.interiors;\n            if (polygonContain.contain(exterior, coord[0], coord[1])) {\n                // Not in the region if point is in the hole.\n                for (let k = 0; k < (interiors ? interiors.length : 0); k++) {\n                    if (polygonContain.contain(interiors[k], coord[0], coord[1])) {\n                        continue loopGeo;\n                    }\n                }\n                return true;\n            }\n        }\n        return false;",
          "blocks": [
            {
              "id": 1,
              "label": "contain(coord: number[]): boolean {",
              "successors": [
                {
                  "id": 2,
                  "label": "const rect = this.getBoundingRect();\nconst geometries = this.geometries;",
                  "successors": [
                    {
                      "id": 3,
                      "label": "if (!rect.contain(coord[0], coord[1])) {",
                      "successors": [
                        {
                          "id": 4,
                          "label": "return false;",
                          "successors": []
                        },
                        {
                          "id": 5,
                          "label": "}",
                          "successors": [
                            {
                              "id": 6,
                              "label": "loopGeo: for (let i = 0, len = geometries.length; i < len; i++) {",
                              "successors": [
                                {
                                  "id": 7,
                                  "label": "const geo = geometries[i];\n// Only support polygon.\nif (geo.type !== 'polygon') {\ncontinue;\n}",
                                  "successors": [
                                    {
                                      "id": 8,
                                      "label": "const exterior = geo.exterior;\nconst interiors = geo.interiors;",
                                      "successors": [
                                        {
                                          "id": 9,
                                          "label": "if (polygonContain.contain(exterior, coord[0], coord[1])) {",
                                          "successors": [
                                            {
                                              "id": 10,
                                              "label": "for (let k = 0; k < (interiors ? interiors.length : 0); k++) {",
                                              "successors": [
                                                {
                                                  "id": 11,
                                                  "label": "if (polygonContain.contain(interiors[k], coord[0], coord[1])) {",
                                                  "successors": [
                                                    {
                                                      "id": 12,
                                                      "label": "continue loopGeo;",
                                                      "successors": []
                                                    }
                                                  ]
                                                }
                                              ]
                                            },
                                            {
                                              "id": 13,
                                              "label": "}\nreturn true;",
                                              "successors": []
                                            }
                                          ]
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            },
                            {
                              "id": 14,
                              "label": "}",
                              "successors": [
                                {
                                  "id": 15,
                                  "label": "return false;\n}",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "transformTo",
          "type": "function",
          "start_line": 191,
          "end_line": 224,
          "functions": [],
          "classes": [],
          "simplified_code": "    transformTo(x: number, y: number, width: number, height: number): void {\n        let rect = this.getBoundingRect();\n        const aspect = rect.width / rect.height;\n        if (!width) {\n            width = aspect * height;\n        }\n        else if (!height) {\n            height = width / aspect;\n        }\n        const target = new BoundingRect(x, y, width, height);\n        const transform = rect.calculateTransform(target);\n        const geometries = this.geometries;\n        for (let i = 0; i < geometries.length; i++) {\n            const geo = geometries[i];\n            if (geo.type === 'polygon') {\n                transformPoints(geo.exterior, transform);\n                each(geo.interiors, interior => {\n                    transformPoints(interior, transform);\n                });\n            }\n            else {\n                each(geo.points, points => {\n                    transformPoints(points, transform);\n                });\n            }\n        }\n        rect = this._rect;\n        rect.copy(target);\n        // Update center\n        this._center = [\n            rect.x + rect.width / 2,\n            rect.y + rect.height / 2\n        ];\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "let rect = this.getBoundingRect();",
              "successors": [
                {
                  "id": 2,
                  "label": "const aspect = rect.width / rect.height;",
                  "successors": [
                    {
                      "id": 3,
                      "label": "if (!width) {",
                      "successors": [
                        {
                          "id": 4,
                          "label": "width = aspect * height;",
                          "successors": [
                            {
                              "id": 9,
                              "label": "const target = new BoundingRect(x, y, width, height);",
                              "successors": [
                                {
                                  "id": 10,
                                  "label": "const transform = rect.calculateTransform(target);",
                                  "successors": [
                                    {
                                      "id": 11,
                                      "label": "const geometries = this.geometries;",
                                      "successors": [
                                        {
                                          "id": 12,
                                          "label": "for (let i = 0; i < geometries.length; i++) {",
                                          "successors": [
                                            {
                                              "id": 13,
                                              "label": "const geo = geometries[i];",
                                              "successors": [
                                                {
                                                  "id": 14,
                                                  "label": "if (geo.type === 'polygon') {",
                                                  "successors": [
                                                    {
                                                      "id": 15,
                                                      "label": "transformPoints(geo.exterior, transform);",
                                                      "successors": [
                                                        {
                                                          "id": 16,
                                                          "label": "each(geo.interiors, interior => {",
                                                          "successors": [
                                                            {
                                                              "id": 17,
                                                              "label": "transformPoints(interior, transform);",
                                                              "successors": []
                                                            }
                                                          ]
                                                        }
                                                      ]
                                                    }
                                                  ]
                                                },
                                                {
                                                  "id": 18,
                                                  "label": "else {",
                                                  "successors": [
                                                    {
                                                      "id": 19,
                                                      "label": "each(geo.points, points => {",
                                                      "successors": [
                                                        {
                                                          "id": 20,
                                                          "label": "transformPoints(points, transform);",
                                                          "successors": []
                                                        }
                                                      ]
                                                    }
                                                  ]
                                                }
                                              ]
                                            }
                                          ]
                                        },
                                        {
                                          "id": 21,
                                          "label": "rect = this._rect;",
                                          "successors": [
                                            {
                                              "id": 22,
                                              "label": "rect.copy(target);",
                                              "successors": [
                                                {
                                                  "id": 23,
                                                  "label": "this._center = [",
                                                  "successors": [
                                                    {
                                                      "id": 24,
                                                      "label": "rect.x + rect.width / 2,",
                                                      "successors": [
                                                        {
                                                          "id": 25,
                                                          "label": "rect.y + rect.height / 2",
                                                          "successors": []
                                                        }
                                                      ]
                                                    }
                                                  ]
                                                }
                                              ]
                                            }
                                          ]
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        },
                        {
                          "id": 5,
                          "label": "else if (!height) {",
                          "successors": [
                            {
                              "id": 6,
                              "label": "height = width / aspect;",
                              "successors": [
                                {
                                  "id": 9,
                                  "label": "const target = new BoundingRect(x, y, width, height);",
                                  "successors": [
                                    {
                                      "id": 10,
                                      "label": "const transform = rect.calculateTransform(target);",
                                      "successors": [
                                        {
                                          "id": 11,
                                          "label": "const geometries = this.geometries;",
                                          "successors": [
                                            {
                                              "id": 12,
                                              "label": "for (let i = 0; i < geometries.length; i++) {",
                                              "successors": [
                                                {
                                                  "id": 13,
                                                  "label": "const geo = geometries[i];",
                                                  "successors": [
                                                    {
                                                      "id": 14,
                                                      "label": "if (geo.type === 'polygon') {",
                                                      "successors": [
                                                        {
                                                          "id": 15,
                                                          "label": "transformPoints(geo.exterior, transform);",
                                                          "successors": [
                                                            {
                                                              "id": 16,
                                                              "label": "each(geo.interiors, interior => {",
                                                              "successors": [
                                                                {
                                                                  "id": 17,
                                                                  "label": "transformPoints(interior, transform);",
                                                                  "successors": []
                                                                }
                                                              ]
                                                            }
                                                          ]
                                                        }
                                                      ]
                                                    },
                                                    {
                                                      "id": 18,
                                                      "label": "else {",
                                                      "successors": [
                                                        {
                                                          "id": 19,
                                                          "label": "each(geo.points, points => {",
                                                          "successors": [
                                                            {
                                                              "id": 20,
                                                              "label": "transformPoints(points, transform);",
                                                              "successors": []
                                                            }
                                                          ]
                                                        }
                                                      ]
                                                    }
                                                  ]
                                                }
                                              ]
                                            },
                                            {
                                              "id": 21,
                                              "label": "rect = this._rect;",
                                              "successors": [
                                                {
                                                  "id": 22,
                                                  "label": "rect.copy(target);",
                                                  "successors": [
                                                    {
                                                      "id": 23,
                                                      "label": "this._center = [",
                                                      "successors": [
                                                        {
                                                          "id": 24,
                                                          "label": "rect.x + rect.width / 2,",
                                                          "successors": [
                                                            {
                                                              "id": 25,
                                                              "label": "rect.y + rect.height / 2",
                                                              "successors": []
                                                            }
                                                          ]
                                                        }
                                                      ]
                                                    }
                                                  ]
                                                }
                                              ]
                                            }
                                          ]
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "cloneShallow",
          "type": "function",
          "start_line": 225,
          "end_line": 230,
          "functions": [],
          "classes": [],
          "simplified_code": "    cloneShallow(name: string): GeoJSONRegion {\n        name == null && (name = this.name);\n        const newRegion = new GeoJSONRegion(name, this.geometries, this._center);\n        newRegion._rect = this._rect;\n        newRegion.transformTo = null; // Simply avoid to be called.\n        return newRegion;",
          "blocks": [
            {
              "id": 1,
              "label": "name == null && (name = this.name);",
              "successors": [
                {
                  "id": 2,
                  "label": "const newRegion = new GeoJSONRegion(name, this.geometries, this._center);",
                  "successors": [
                    {
                      "id": 3,
                      "label": "newRegion._rect = this._rect;",
                      "successors": [
                        {
                          "id": 4,
                          "label": "newRegion.transformTo = null;",
                          "successors": [
                            {
                              "id": 5,
                              "label": "return newRegion;",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "classes": [],
      "simplified_code": "export class GeoJSONRegion extends Region {\n    readonly type = 'geoJSON';\n    readonly geometries: (GeoJSONPolygonGeometry | GeoJSONLineStringGeometry)[];\n    // Injected outside.\n    properties: GeoJSON['features'][0]['properties'];\n    }\n    }\n        return rect;\n    }\n        return false;\n    }\n    }\n        return newRegion;\n    }\n}",
      "blocks": [
        {
          "id": 1,
          "label": "export class GeoJSONRegion extends Region {",
          "successors": [
            {
              "id": 2,
              "label": "readonly type = 'geoJSON';",
              "successors": []
            },
            {
              "id": 3,
              "label": "readonly geometries: (GeoJSONPolygonGeometry | GeoJSONLineStringGeometry)[];",
              "successors": []
            },
            {
              "id": 4,
              "label": "properties: GeoJSON['features'][0]['properties'];",
              "successors": []
            }
          ]
        }
      ]
    },
    {
      "name": "GeoSVGRegion",
      "type": "class",
      "start_line": 233,
      "end_line": 263,
      "functions": [
        {
          "name": "constructor",
          "type": "function",
          "start_line": 239,
          "end_line": 244,
          "functions": [],
          "classes": [],
          "simplified_code": "    constructor(\n        name: string,\n        elOnlyForCalculate: Element\n    ) {\n        super(name);\n        this._elOnlyForCalculate = elOnlyForCalculate;",
          "blocks": [
            {
              "id": 1,
              "label": "constructor(\n    name: string,\n    elOnlyForCalculate: Element\n) {",
              "successors": [
                {
                  "id": 2,
                  "label": "    super(name);",
                  "successors": [
                    {
                      "id": 3,
                      "label": "    this._elOnlyForCalculate = elOnlyForCalculate;",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "calcCenter",
          "type": "function",
          "start_line": 246,
          "end_line": 261,
          "functions": [],
          "classes": [],
          "simplified_code": "    calcCenter(): number[] {\n        const el = this._elOnlyForCalculate;\n        const rect = el.getBoundingRect();\n        const center = [\n            rect.x + rect.width / 2,\n            rect.y + rect.height / 2\n        ];\n        const mat = matrix.identity(TMP_TRANSFORM);\n        let target = el;\n        while (target && !(target as GeoSVGGraphicRoot).isGeoSVGGraphicRoot) {\n            matrix.mul(mat, target.getLocalTransform(), mat);\n            target = target.parent;\n        }\n        matrix.invert(mat, mat);\n        vec2.applyTransform(center, center, mat);\n        return center;",
          "blocks": [
            {
              "id": 1,
              "label": "const el = this._elOnlyForCalculate;\nconst rect = el.getBoundingRect();\nconst center = [\n    rect.x + rect.width / 2,\n    rect.y + rect.height / 2\n];\nconst mat = matrix.identity(TMP_TRANSFORM);\nlet target = el;",
              "successors": [
                {
                  "id": 2,
                  "label": "while (target && !(target as GeoSVGGraphicRoot).isGeoSVGGraphicRoot) {",
                  "successors": [
                    {
                      "id": 3,
                      "label": "    matrix.mul(mat, target.getLocalTransform(), mat);\n    target = target.parent;",
                      "successors": [
                        {
                          "id": 2,
                          "label": "while (target && !(target as GeoSVGGraphicRoot).isGeoSVGGraphicRoot) {",
                          "successors": []
                        }
                      ]
                    }
                  ]
                },
                {
                  "id": 4,
                  "label": "matrix.invert(mat, mat);\nvec2.applyTransform(center, center, mat);\nreturn center;",
                  "successors": []
                }
              ]
            }
          ]
        }
      ],
      "classes": [],
      "simplified_code": "export class GeoSVGRegion extends Region {\n    readonly type = 'geoSVG';\n    // Can only be used to calculate, but not be modified.\n    // Because this el may not belong to this view,\n    // but been displaying on some other view.\n    private _elOnlyForCalculate: Element;\n        this._elOnlyForCalculate = elOnlyForCalculate;\n    }\n        return center;\n    }\n}",
      "blocks": [
        {
          "id": 1,
          "label": "export class GeoSVGRegion extends Region {",
          "successors": [
            {
              "id": 2,
              "label": "    readonly type = 'geoSVG';",
              "successors": [
                {
                  "id": 3,
                  "label": "    private _elOnlyForCalculate: Element;",
                  "successors": [
                    {
                      "id": 4,
                      "label": "    this._elOnlyForCalculate = elOnlyForCalculate;",
                      "successors": [
                        {
                          "id": 5,
                          "label": "}",
                          "successors": [
                            {
                              "id": 6,
                              "label": "return center;",
                              "successors": [
                                {
                                  "id": 7,
                                  "label": "}",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    }
  ],
  "simplified_code": "import BoundingRect from 'zrender/src/core/BoundingRect';\nimport * as vec2 from 'zrender/src/core/vector';\nimport * as polygonContain from 'zrender/src/contain/polygon';\nimport { GeoJSON, GeoProjection, GeoSVGGraphicRoot } from './geoTypes';\nimport * as matrix from 'zrender/src/core/matrix';\nimport Element from 'zrender/src/Element';\nimport { each } from 'zrender/src/core/util';\nconst TMP_TRANSFORM = [] as number[];\n}\n}\n}\n}\n}\n}\n}\n}",
  "blocks": [
    {
      "id": 1,
      "label": "import BoundingRect from 'zrender/src/core/BoundingRect';",
      "successors": [
        {
          "id": 2,
          "label": "import * as vec2 from 'zrender/src/core/vector';",
          "successors": [
            {
              "id": 3,
              "label": "import * as polygonContain from 'zrender/src/contain/polygon';",
              "successors": [
                {
                  "id": 4,
                  "label": "import { GeoJSON, GeoProjection, GeoSVGGraphicRoot } from './geoTypes';",
                  "successors": [
                    {
                      "id": 5,
                      "label": "import * as matrix from 'zrender/src/core/matrix';",
                      "successors": [
                        {
                          "id": 6,
                          "label": "import Element from 'zrender/src/Element';",
                          "successors": [
                            {
                              "id": 7,
                              "label": "import { each } from 'zrender/src/core/util';",
                              "successors": [
                                {
                                  "id": 8,
                                  "label": "const TMP_TRANSFORM = [] as number[];",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    }
  ]
}