{
  "name": "example_script",
  "type": "CFG",
  "start_line": 1,
  "end_line": 289,
  "functions": [],
  "classes": [
    {
      "name": "CollectionCannotBeResolvedException",
      "type": "class",
      "start_line": 31,
      "end_line": 35,
      "functions": [
        {
          "name": "constructor",
          "type": "function",
          "start_line": 32,
          "end_line": 34,
          "functions": [],
          "classes": [],
          "simplified_code": "  constructor(name: string) {\n    super(`Collection ${JSON.stringify(name)} cannot be resolved.`);\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "constructor(name: string) {",
              "successors": [
                {
                  "id": 2,
                  "label": "    super(`Collection ${JSON.stringify(name)} cannot be resolved.`);",
                  "successors": [
                    {
                      "id": 3,
                      "label": "}",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "simplified_code": "export class CollectionCannotBeResolvedException extends BaseException {\n  }\n}",
      "blocks": [
        {
          "id": 1,
          "label": "export class CollectionCannotBeResolvedException extends BaseException {",
          "successors": []
        }
      ]
    },
    {
      "name": "InvalidCollectionJsonException",
      "type": "class",
      "start_line": 36,
      "end_line": 44,
      "functions": [
        {
          "name": "constructor",
          "type": "function",
          "start_line": 37,
          "end_line": 43,
          "functions": [],
          "classes": [],
          "simplified_code": "  constructor(_name: string, path: string, jsonException?: Error) {\n    let msg = `Collection JSON at path ${JSON.stringify(path)} is invalid.`;\n    if (jsonException) {\n      msg = `${msg} ${jsonException.message}`;\n    }\n    super(msg);\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "constructor(_name: string, path: string, jsonException?: Error) {",
              "successors": [
                {
                  "id": 2,
                  "label": "let msg = `Collection JSON at path ${JSON.stringify(path)} is invalid.`;",
                  "successors": [
                    {
                      "id": 3,
                      "label": "if (jsonException) {",
                      "successors": [
                        {
                          "id": 4,
                          "label": "msg = `${msg} ${jsonException.message}`;",
                          "successors": []
                        },
                        {
                          "id": 5,
                          "label": "}",
                          "successors": [
                            {
                              "id": 6,
                              "label": "super(msg);",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "simplified_code": "export class InvalidCollectionJsonException extends BaseException {\n  }\n}",
      "blocks": [
        {
          "id": 1,
          "label": "export class InvalidCollectionJsonException extends BaseException {",
          "successors": [
            {
              "id": 2,
              "label": "}",
              "successors": []
            }
          ]
        }
      ]
    },
    {
      "name": "SchematicMissingFactoryException",
      "type": "class",
      "start_line": 45,
      "end_line": 49,
      "functions": [
        {
          "name": "constructor",
          "type": "function",
          "start_line": 46,
          "end_line": 48,
          "functions": [],
          "classes": [],
          "simplified_code": "  constructor(name: string) {\n    super(`Schematic ${JSON.stringify(name)} is missing a factory.`);\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "constructor(name: string) {",
              "successors": [
                {
                  "id": 2,
                  "label": "    super(`Schematic ${JSON.stringify(name)} is missing a factory.`);",
                  "successors": []
                }
              ]
            }
          ]
        }
      ],
      "simplified_code": "export class SchematicMissingFactoryException extends BaseException {\n  }\n}",
      "blocks": [
        {
          "id": 1,
          "label": "export class SchematicMissingFactoryException extends BaseException {\n}",
          "successors": []
        }
      ]
    },
    {
      "name": "FactoryCannotBeResolvedException",
      "type": "class",
      "start_line": 50,
      "end_line": 54,
      "functions": [
        {
          "name": "constructor",
          "type": "function",
          "start_line": 51,
          "end_line": 53,
          "functions": [],
          "classes": [],
          "simplified_code": "  constructor(name: string) {\n    super(`Schematic ${JSON.stringify(name)} cannot resolve the factory.`);\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "constructor(name: string) {",
              "successors": [
                {
                  "id": 2,
                  "label": "super(`Schematic ${JSON.stringify(name)} cannot resolve the factory.`);",
                  "successors": [
                    {
                      "id": 3,
                      "label": "}",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "simplified_code": "export class FactoryCannotBeResolvedException extends BaseException {\n  }\n}",
      "blocks": [
        {
          "id": 1,
          "label": "export class FactoryCannotBeResolvedException extends BaseException {",
          "successors": [
            {
              "id": 2,
              "label": "}",
              "successors": []
            }
          ]
        }
      ]
    },
    {
      "name": "CollectionMissingSchematicsMapException",
      "type": "class",
      "start_line": 55,
      "end_line": 59,
      "functions": [
        {
          "name": "constructor",
          "type": "function",
          "start_line": 56,
          "end_line": 58,
          "functions": [],
          "classes": [],
          "simplified_code": "  constructor(name: string) {\n    super(`Collection \"${name}\" does not have a schematics map.`);\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "constructor(name: string) {",
              "successors": [
                {
                  "id": 2,
                  "label": "super(`Collection \"${name}\" does not have a schematics map.`);",
                  "successors": [
                    {
                      "id": 3,
                      "label": "}",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "simplified_code": "export class CollectionMissingSchematicsMapException extends BaseException {\n  }\n}",
      "blocks": [
        {
          "id": 1,
          "label": "export class CollectionMissingSchematicsMapException extends BaseException {",
          "successors": [
            {
              "id": 2,
              "label": "",
              "successors": []
            }
          ]
        }
      ]
    },
    {
      "name": "CollectionMissingFieldsException",
      "type": "class",
      "start_line": 60,
      "end_line": 64,
      "functions": [
        {
          "name": "constructor",
          "type": "function",
          "start_line": 61,
          "end_line": 63,
          "functions": [],
          "classes": [],
          "simplified_code": "  constructor(name: string) {\n    super(`Collection \"${name}\" is missing fields.`);\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "constructor(name: string) {",
              "successors": [
                {
                  "id": 2,
                  "label": "  super(`Collection \"${name}\" is missing fields.`);",
                  "successors": [
                    {
                      "id": 3,
                      "label": "}",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "simplified_code": "export class CollectionMissingFieldsException extends BaseException {\n  }\n}",
      "blocks": [
        {
          "id": 1,
          "label": "export class CollectionMissingFieldsException extends BaseException {",
          "successors": [
            {
              "id": 2,
              "label": "}",
              "successors": []
            }
          ]
        }
      ]
    },
    {
      "name": "SchematicMissingFieldsException",
      "type": "class",
      "start_line": 65,
      "end_line": 69,
      "functions": [
        {
          "name": "constructor",
          "type": "function",
          "start_line": 66,
          "end_line": 68,
          "functions": [],
          "classes": [],
          "simplified_code": "  constructor(name: string) {\n    super(`Schematic \"${name}\" is missing fields.`);\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "constructor(name: string) {",
              "successors": [
                {
                  "id": 2,
                  "label": "    super(`Schematic \"${name}\" is missing fields.`);",
                  "successors": []
                }
              ]
            }
          ]
        }
      ],
      "simplified_code": "export class SchematicMissingFieldsException extends BaseException {\n  }\n}",
      "blocks": [
        {
          "id": 1,
          "label": "export class SchematicMissingFieldsException extends BaseException {",
          "successors": [
            {
              "id": 2,
              "label": "}",
              "successors": []
            }
          ]
        }
      ]
    },
    {
      "name": "SchematicMissingDescriptionException",
      "type": "class",
      "start_line": 70,
      "end_line": 74,
      "functions": [
        {
          "name": "constructor",
          "type": "function",
          "start_line": 71,
          "end_line": 73,
          "functions": [],
          "classes": [],
          "simplified_code": "  constructor(name: string) {\n    super(`Schematics \"${name}\" does not have a description.`);\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "constructor(name: string) {",
              "successors": [
                {
                  "id": 2,
                  "label": "super(`Schematics \"${name}\" does not have a description.`);",
                  "successors": []
                }
              ]
            }
          ]
        }
      ],
      "simplified_code": "export class SchematicMissingDescriptionException extends BaseException {\n  }\n}",
      "blocks": [
        {
          "id": 1,
          "label": "export class SchematicMissingDescriptionException extends BaseException {",
          "successors": [
            {
              "id": 2,
              "label": "}",
              "successors": []
            }
          ]
        }
      ]
    },
    {
      "name": "SchematicNameCollisionException",
      "type": "class",
      "start_line": 75,
      "end_line": 82,
      "functions": [
        {
          "name": "constructor",
          "type": "function",
          "start_line": 76,
          "end_line": 81,
          "functions": [],
          "classes": [],
          "simplified_code": "  constructor(name: string) {\n    super(\n      `Schematics/alias ${JSON.stringify(name)} collides with another alias or schematic` +\n        ' name.',\n    );\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "constructor(name: string) {",
              "successors": [
                {
                  "id": 2,
                  "label": "super(`Schematics/alias ${JSON.stringify(name)} collides with another alias or schematic` + ' name.',);",
                  "successors": [
                    {
                      "id": 3,
                      "label": "}",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "simplified_code": "export class SchematicNameCollisionException extends BaseException {\n  }\n}",
      "blocks": [
        {
          "id": 1,
          "label": "export class SchematicNameCollisionException extends BaseException {",
          "successors": [
            {
              "id": 2,
              "label": "}",
              "successors": []
            }
          ]
        }
      ]
    },
    {
      "name": "FileSystemEngineHostBase",
      "type": "class",
      "start_line": 83,
      "end_line": 289,
      "functions": [
        {
          "name": "_resolveCollectionPath",
          "type": "function",
          "start_line": 84,
          "end_line": 84,
          "functions": [],
          "classes": [],
          "simplified_code": "  protected abstract _resolveCollectionPath(name: string, requester?: string): string;",
          "blocks": [
            {
              "id": 1,
              "label": "protected abstract _resolveCollectionPath(name: string, requester?: string): string;",
              "successors": []
            }
          ]
        },
        {
          "name": "_resolveReferenceString",
          "type": "function",
          "start_line": 85,
          "end_line": 89,
          "functions": [],
          "classes": [],
          "simplified_code": "  protected abstract _resolveReferenceString(\n    name: string,\n    parentPath: string,\n    collectionDescription: FileSystemCollectionDesc,\n  ): { ref: RuleFactory<{}>; path: string } | null;",
          "blocks": [
            {
              "id": 1,
              "label": "protected abstract _resolveReferenceString(\n    name: string,\n    parentPath: string,\n    collectionDescription: FileSystemCollectionDesc,\n  ): { ref: RuleFactory<{}>; path: string } | null;",
              "successors": []
            }
          ]
        },
        {
          "name": "_transformCollectionDescription",
          "type": "function",
          "start_line": 90,
          "end_line": 93,
          "functions": [],
          "classes": [],
          "simplified_code": "  protected abstract _transformCollectionDescription(\n    name: string,\n    desc: Partial<FileSystemCollectionDesc>,\n  ): FileSystemCollectionDesc;",
          "blocks": [
            {
              "id": 1,
              "label": "protected abstract _transformCollectionDescription(name: string, desc: Partial<FileSystemCollectionDesc>): FileSystemCollectionDesc;",
              "successors": []
            }
          ]
        },
        {
          "name": "_transformSchematicDescription",
          "type": "function",
          "start_line": 94,
          "end_line": 98,
          "functions": [],
          "classes": [],
          "simplified_code": "  protected abstract _transformSchematicDescription(\n    name: string,\n    collection: FileSystemCollectionDesc,\n    desc: Partial<FileSystemSchematicDesc>,\n  ): FileSystemSchematicDesc;",
          "blocks": [
            {
              "id": 1,
              "label": "protected abstract _transformSchematicDescription(\n  name: string,\n  collection: FileSystemCollectionDesc,\n  desc: Partial<FileSystemSchematicDesc>,\n): FileSystemSchematicDesc;",
              "successors": []
            }
          ]
        },
        {
          "name": "listSchematicNames",
          "type": "function",
          "start_line": 103,
          "end_line": 119,
          "functions": [],
          "classes": [],
          "simplified_code": "  listSchematicNames(collection: FileSystemCollectionDesc, includeHidden?: boolean) {\n    const schematics: string[] = [];\n    for (const key of Object.keys(collection.schematics)) {\n      const schematic = collection.schematics[key];\n      if ((schematic.hidden && !includeHidden) || schematic.private) {\n        continue;\n      }\n      // If extends is present without a factory it is an alias, do not return it\n      //   unless it is from another collection.\n      if (!schematic.extends || schematic.factory) {\n        schematics.push(key);\n      } else if (schematic.extends && schematic.extends.indexOf(':') !== -1) {\n        schematics.push(key);\n      }\n    }\n    return schematics;\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "listSchematicNames(collection: FileSystemCollectionDesc, includeHidden?: boolean) {",
              "successors": [
                {
                  "id": 2,
                  "label": "const schematics: string[] = [];",
                  "successors": [
                    {
                      "id": 3,
                      "label": "for (const key of Object.keys(collection.schematics)) {",
                      "successors": [
                        {
                          "id": 4,
                          "label": "const schematic = collection.schematics[key];",
                          "successors": [
                            {
                              "id": 5,
                              "label": "if ((schematic.hidden && !includeHidden) || schematic.private) {",
                              "successors": [
                                {
                                  "id": 6,
                                  "label": "continue;",
                                  "successors": [
                                    {
                                      "id": 12,
                                      "label": "}",
                                      "successors": [
                                        {
                                          "id": 3,
                                          "label": "for (const key of Object.keys(collection.schematics)) {",
                                          "successors": []
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            },
                            {
                              "id": 7,
                              "label": "if (!schematic.extends || schematic.factory) {",
                              "successors": [
                                {
                                  "id": 8,
                                  "label": "schematics.push(key);",
                                  "successors": [
                                    {
                                      "id": 12,
                                      "label": "}",
                                      "successors": [
                                        {
                                          "id": 3,
                                          "label": "for (const key of Object.keys(collection.schematics)) {",
                                          "successors": []
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            },
                            {
                              "id": 9,
                              "label": "else if (schematic.extends && schematic.extends.indexOf(':') !== -1) {",
                              "successors": [
                                {
                                  "id": 10,
                                  "label": "schematics.push(key);",
                                  "successors": [
                                    {
                                      "id": 12,
                                      "label": "}",
                                      "successors": [
                                        {
                                          "id": 3,
                                          "label": "for (const key of Object.keys(collection.schematics)) {",
                                          "successors": []
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        },
                        {
                          "id": 12,
                          "label": "}",
                          "successors": [
                            {
                              "id": 13,
                              "label": "return schematics;",
                              "successors": [
                                {
                                  "id": 14,
                                  "label": "}",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "registerOptionsTransform",
          "type": "function",
          "start_line": 120,
          "end_line": 122,
          "functions": [],
          "classes": [],
          "simplified_code": "  registerOptionsTransform<T extends object | null, R extends object>(t: OptionTransform<T, R>) {\n    this._transforms.push(t);\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "registerOptionsTransform<T extends object | null, R extends object>(t: OptionTransform<T, R>) {",
              "successors": [
                {
                  "id": 2,
                  "label": "    this._transforms.push(t);",
                  "successors": [
                    {
                      "id": 3,
                      "label": "}",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "registerContextTransform",
          "type": "function",
          "start_line": 123,
          "end_line": 125,
          "functions": [],
          "classes": [],
          "simplified_code": "  registerContextTransform(t: ContextTransform) {\n    this._contextTransforms.push(t);\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "registerContextTransform(t: ContextTransform) {",
              "successors": [
                {
                  "id": 2,
                  "label": "this._contextTransforms.push(t);",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "createCollectionDescription",
          "type": "function",
          "start_line": 126,
          "end_line": 157,
          "functions": [],
          "classes": [],
          "simplified_code": "  createCollectionDescription(\n    name: string,\n    requester?: FileSystemCollectionDesc,\n  ): FileSystemCollectionDesc {\n    const path = this._resolveCollectionPath(name, requester?.path);\n    const jsonValue = readJsonFile(path);\n    if (!jsonValue || typeof jsonValue != 'object' || Array.isArray(jsonValue)) {\n      throw new InvalidCollectionJsonException(name, path);\n    }\n    // normalize extends property to an array\n    if (typeof jsonValue['extends'] === 'string') {\n      jsonValue['extends'] = [jsonValue['extends']];\n    }\n    const description = this._transformCollectionDescription(name, {\n      ...jsonValue,\n      path,\n    });\n    if (!description || !description.name) {\n      throw new InvalidCollectionJsonException(name, path);\n    }\n    // Validate aliases.\n    const allNames = Object.keys(description.schematics);\n    for (const schematicName of Object.keys(description.schematics)) {\n      const aliases = description.schematics[schematicName].aliases || [];\n      for (const alias of aliases) {\n        if (allNames.indexOf(alias) != -1) {\n          throw new SchematicNameCollisionException(alias);\n        }\n      }\n      allNames.push(...aliases);\n    }\n    return description;",
          "blocks": [
            {
              "id": 1,
              "label": "createCollectionDescription(\n  name: string,\n  requester?: FileSystemCollectionDesc,\n): FileSystemCollectionDesc {\n  const path = this._resolveCollectionPath(name, requester?.path);\n  const jsonValue = readJsonFile(path);",
              "successors": [
                {
                  "id": 2,
                  "label": "if (!jsonValue || typeof jsonValue != 'object' || Array.isArray(jsonValue)) {\n  throw new InvalidCollectionJsonException(name, path);\n}",
                  "successors": [
                    {
                      "id": 3,
                      "label": "if (typeof jsonValue['extends'] === 'string') {\n  jsonValue['extends'] = [jsonValue['extends']];\n}",
                      "successors": [
                        {
                          "id": 4,
                          "label": "const description = this._transformCollectionDescription(name, { ...jsonValue, path, });",
                          "successors": [
                            {
                              "id": 5,
                              "label": "if (!description || !description.name) {\n  throw new InvalidCollectionJsonException(name, path);\n}",
                              "successors": [
                                {
                                  "id": 6,
                                  "label": "const allNames = Object.keys(description.schematics);\nfor (const schematicName of Object.keys(description.schematics)) {\n  const aliases = description.schematics[schematicName].aliases || [];\n  for (const alias of aliases) {\n    if (allNames.indexOf(alias) != -1) {\n      throw new SchematicNameCollisionException(alias);\n    }\n  }\n  allNames.push(...aliases);\n}",
                                  "successors": [
                                    {
                                      "id": 7,
                                      "label": "return description;",
                                      "successors": []
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "createSchematicDescription",
          "type": "function",
          "start_line": 159,
          "end_line": 228,
          "functions": [],
          "classes": [],
          "simplified_code": "  createSchematicDescription(\n    name: string,\n    collection: FileSystemCollectionDesc,\n  ): FileSystemSchematicDesc | null {\n    // Resolve aliases first.\n    for (const schematicName of Object.keys(collection.schematics)) {\n      const schematicDescription = collection.schematics[schematicName];\n      if (schematicDescription.aliases && schematicDescription.aliases.indexOf(name) != -1) {\n        name = schematicName;\n        break;\n      }\n    }\n    if (!(name in collection.schematics)) {\n      return null;\n    }\n    const collectionPath = dirname(collection.path);\n    const partialDesc: Partial<FileSystemSchematicDesc> | null = collection.schematics[name];\n    if (!partialDesc) {\n      return null;\n    }\n    if (partialDesc.extends) {\n      const index = partialDesc.extends.indexOf(':');\n      const collectionName = index !== -1 ? partialDesc.extends.slice(0, index) : null;\n      const schematicName =\n        index === -1 ? partialDesc.extends : partialDesc.extends.slice(index + 1);\n      if (collectionName !== null) {\n        const extendCollection = this.createCollectionDescription(collectionName);\n        return this.createSchematicDescription(schematicName, extendCollection);\n      } else {\n        return this.createSchematicDescription(schematicName, collection);\n      }\n    }\n    // Use any on this ref as we don't have the OptionT here, but we don't need it (we only need\n    // the path).\n    if (!partialDesc.factory) {\n      throw new SchematicMissingFactoryException(name);\n    }\n    const resolvedRef = this._resolveReferenceString(\n      partialDesc.factory,\n      collectionPath,\n      collection,\n    );\n    if (!resolvedRef) {\n      throw new FactoryCannotBeResolvedException(name);\n    }\n    let schema = partialDesc.schema;\n    let schemaJson: JsonObject | undefined = undefined;\n    if (schema) {\n      if (!isAbsolute(schema)) {\n        schema = join(collectionPath, schema);\n      }\n      schemaJson = readJsonFile(schema) as JsonObject;\n    }\n    // The schematic path is used to resolve URLs.\n    // We should be able to just do `dirname(resolvedRef.path)` but for compatibility with\n    // Bazel under Windows this directory needs to be resolved from the collection instead.\n    // This is needed because on Bazel under Windows the data files (such as the collection or\n    // url files) are not in the same place as the compiled JS.\n    const maybePath = join(collectionPath, partialDesc.factory);\n    const path =\n      existsSync(maybePath) && statSync(maybePath).isDirectory() ? maybePath : dirname(maybePath);\n    return this._transformSchematicDescription(name, collection, {\n      ...partialDesc,\n      schema,\n      schemaJson,\n      name,\n      path,\n      factoryFn: resolvedRef.ref,\n      collection,\n    });",
          "blocks": [
            {
              "id": 1,
              "label": "createSchematicDescription(\n  name: string,\n  collection: FileSystemCollectionDesc,\n) {",
              "successors": [
                {
                  "id": 2,
                  "label": "// Resolve aliases first.\nfor (const schematicName of Object.keys(collection.schematics)) {",
                  "successors": [
                    {
                      "id": 3,
                      "label": "const schematicDescription = collection.schematics[schematicName];\nif (schematicDescription.aliases && schematicDescription.aliases.indexOf(name) != -1) {",
                      "successors": [
                        {
                          "id": 4,
                          "label": "name = schematicName;\nbreak;",
                          "successors": [
                            {
                              "id": 5,
                              "label": "}\n}",
                              "successors": [
                                {
                                  "id": 6,
                                  "label": "if (!(name in collection.schematics)) {",
                                  "successors": [
                                    {
                                      "id": 7,
                                      "label": "return null;",
                                      "successors": [
                                        {
                                          "id": 8,
                                          "label": "}\nconst collectionPath = dirname(collection.path);\nconst partialDesc: Partial<FileSystemSchematicDesc> | null = collection.schematics[name];\nif (!partialDesc) {",
                                          "successors": [
                                            {
                                              "id": 9,
                                              "label": "return null;",
                                              "successors": [
                                                {
                                                  "id": 10,
                                                  "label": "}\nif (partialDesc.extends) {",
                                                  "successors": [
                                                    {
                                                      "id": 11,
                                                      "label": "const index = partialDesc.extends.indexOf(':');\nconst collectionName = index !== -1 ? partialDesc.extends.slice(0, index) : null;\nconst schematicName = index === -1 ? partialDesc.extends : partialDesc.extends.slice(index + 1);\nif (collectionName !== null) {",
                                                      "successors": [
                                                        {
                                                          "id": 12,
                                                          "label": "const extendCollection = this.createCollectionDescription(collectionName);\nreturn this.createSchematicDescription(schematicName, extendCollection);",
                                                          "successors": [
                                                            {
                                                              "id": 13,
                                                              "label": "} else {",
                                                              "successors": [
                                                                {
                                                                  "id": 14,
                                                                  "label": "return this.createSchematicDescription(schematicName, collection);",
                                                                  "successors": [
                                                                    {
                                                                      "id": 15,
                                                                      "label": "}\n}\n// Use any on this ref as we don't have the OptionT here, but we don't need it (we only need\n// the path).\nif (!partialDesc.factory) {",
                                                                      "successors": [
                                                                        {
                                                                          "id": 16,
                                                                          "label": "throw new SchematicMissingFactoryException(name);",
                                                                          "successors": [
                                                                            {
                                                                              "id": 17,
                                                                              "label": "}\nconst resolvedRef = this._resolveReferenceString(\n  partialDesc.factory,\n  collectionPath,\n  collection,\n);\nif (!resolvedRef) {",
                                                                              "successors": [
                                                                                {
                                                                                  "id": 18,
                                                                                  "label": "throw new FactoryCannotBeResolvedException(name);",
                                                                                  "successors": [
                                                                                    {
                                                                                      "id": 19,
                                                                                      "label": "}\nlet schema = partialDesc.schema;\nlet schemaJson: JsonObject | undefined = undefined;\nif (schema) {",
                                                                                      "successors": [
                                                                                        {
                                                                                          "id": 20,
                                                                                          "label": "if (!isAbsolute(schema)) {\n  schema = join(collectionPath, schema);\n}",
                                                                                          "successors": [
                                                                                            {
                                                                                              "id": 21,
                                                                                              "label": "schemaJson = readJsonFile(schema) as JsonObject;\n}\n// The schematic path is used to resolve URLs.\n// We should be able to just do `dirname(resolvedRef.path)` but for compatibility with\n// Bazel under Windows this directory needs to be resolved from the collection instead.\n// This is needed because on Bazel under Windows the data files (such as the collection or\n// url files) are not in the same place as the compiled JS.\nconst maybePath = join(collectionPath, partialDesc.factory);\nconst path = existsSync(maybePath) && statSync(maybePath).isDirectory() ? maybePath : dirname(maybePath);\nreturn this._transformSchematicDescription(name, collection, {",
                                                                                              "successors": [
                                                                                                {
                                                                                                  "id": 22,
                                                                                                  "label": "...partialDesc,\nschema,\nschemaJson,\nname,\npath,\nfactoryFn: resolvedRef.ref,\ncollection,\n});",
                                                                                                  "successors": []
                                                                                                }
                                                                                              ]
                                                                                            }
                                                                                          ]
                                                                                        }
                                                                                      ]
                                                                                    }
                                                                                  ]
                                                                                }
                                                                              ]
                                                                            }
                                                                          ]
                                                                        }
                                                                      ]
                                                                    }
                                                                  ]
                                                                }
                                                              ]
                                                            }
                                                          ]
                                                        }
                                                      ]
                                                    }
                                                  ]
                                                }
                                              ]
                                            }
                                          ]
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "createSourceFromUrl",
          "type": "function",
          "start_line": 230,
          "end_line": 249,
          "functions": [],
          "classes": [],
          "simplified_code": "  createSourceFromUrl(url: Url): Source | null {\n    switch (url.protocol) {\n      case null:\n      case 'file:':\n        return (context) => {\n          // Check if context has necessary FileSystemSchematicContext path property\n          const fileDescription = context.schematic.description as { path?: string };\n          if (fileDescription.path === undefined) {\n            throw new Error(\n              'Unsupported schematic context. Expected a FileSystemSchematicContext.',\n            );\n          }\n          // Resolve all file:///a/b/c/d from the schematic's own path, and not the current\n          // path.\n          const root = normalize(resolve(fileDescription.path, url.path || ''));\n          return new HostCreateTree(new virtualFs.ScopedHost(new NodeJsSyncHost(), root));\n        };\n    }\n    return null;\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "createSourceFromUrl(url: Url): Source | null {",
              "successors": [
                {
                  "id": 2,
                  "label": "switch (url.protocol) {",
                  "successors": [
                    {
                      "id": 3,
                      "label": "case null:",
                      "successors": [
                        {
                          "id": 4,
                          "label": "case 'file:':",
                          "successors": [
                            {
                              "id": 5,
                              "label": "return (context) => {",
                              "successors": [
                                {
                                  "id": 6,
                                  "label": "const fileDescription = context.schematic.description as { path?: string };",
                                  "successors": [
                                    {
                                      "id": 7,
                                      "label": "if (fileDescription.path === undefined) {",
                                      "successors": [
                                        {
                                          "id": 8,
                                          "label": "throw new Error(\n\"Unsupported schematic context. Expected a FileSystemSchematicContext.\",\n);",
                                          "successors": []
                                        }
                                      ]
                                    },
                                    {
                                      "id": 9,
                                      "label": "const root = normalize(resolve(fileDescription.path, url.path || ''));",
                                      "successors": [
                                        {
                                          "id": 10,
                                          "label": "return new HostCreateTree(new virtualFs.ScopedHost(new NodeJsSyncHost(), root));",
                                          "successors": []
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "id": 11,
                      "label": "}",
                      "successors": [
                        {
                          "id": 12,
                          "label": "return null;",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "transformOptions",
          "type": "function",
          "start_line": 250,
          "end_line": 266,
          "functions": [],
          "classes": [],
          "simplified_code": "  transformOptions<OptionT extends object, ResultT extends object>(\n    schematic: FileSystemSchematicDesc,\n    options: OptionT,\n    context?: FileSystemSchematicContext,\n  ): Observable<ResultT> {\n    const transform = async () => {\n      let transformedOptions = options;\n      for (const transformer of this._transforms) {\n        const transformerResult = transformer(schematic, transformedOptions, context);\n        transformedOptions = await (isObservable(transformerResult)\n          ? lastValueFrom(transformerResult)\n          : transformerResult);\n      }\n      return transformedOptions;\n    };\n    return observableFrom(transform()) as unknown as Observable<ResultT>;\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "transformOptions<OptionT extends object, ResultT extends object>(schematic: FileSystemSchematicDesc, options: OptionT, context?: FileSystemSchematicContext,): Observable<ResultT> {",
              "successors": [
                {
                  "id": 2,
                  "label": "const transform = async () => {",
                  "successors": [
                    {
                      "id": 3,
                      "label": "let transformedOptions = options;",
                      "successors": [
                        {
                          "id": 4,
                          "label": "for (const transformer of this._transforms) {",
                          "successors": [
                            {
                              "id": 5,
                              "label": "const transformerResult = transformer(schematic, transformedOptions, context);",
                              "successors": [
                                {
                                  "id": 6,
                                  "label": "transformedOptions = await (isObservable(transformerResult) ? lastValueFrom(transformerResult) : transformerResult);",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        },
                        {
                          "id": 7,
                          "label": "}",
                          "successors": [
                            {
                              "id": 8,
                              "label": "return transformedOptions;",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "id": 9,
                      "label": "};",
                      "successors": [
                        {
                          "id": 10,
                          "label": "return observableFrom(transform()) as unknown as Observable<ResultT>;",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "id": 11,
              "label": "}",
              "successors": []
            }
          ]
        },
        {
          "name": "transformContext",
          "type": "function",
          "start_line": 267,
          "end_line": 269,
          "functions": [],
          "classes": [],
          "simplified_code": "  transformContext(context: FileSystemSchematicContext): FileSystemSchematicContext {\n    return this._contextTransforms.reduce((acc, curr) => curr(acc), context);\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "transformContext(context: FileSystemSchematicContext): FileSystemSchematicContext {",
              "successors": [
                {
                  "id": 2,
                  "label": "  return this._contextTransforms.reduce((acc, curr) => curr(acc), context);",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "getSchematicRuleFactory",
          "type": "function",
          "start_line": 270,
          "end_line": 274,
          "functions": [],
          "classes": [],
          "simplified_code": "  getSchematicRuleFactory<OptionT extends object>(\n    schematic: FileSystemSchematicDesc,\n    _collection: FileSystemCollectionDesc,\n  ): RuleFactory<OptionT> {\n    return schematic.factoryFn;",
          "blocks": [
            {
              "id": 1,
              "label": "getSchematicRuleFactory<OptionT extends object>(schematic: FileSystemSchematicDesc, _collection: FileSystemCollectionDesc): RuleFactory<OptionT> {",
              "successors": [
                {
                  "id": 2,
                  "label": "return schematic.factoryFn;",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "registerTaskExecutor",
          "type": "function",
          "start_line": 276,
          "end_line": 278,
          "functions": [],
          "classes": [],
          "simplified_code": "  registerTaskExecutor<T>(factory: TaskExecutorFactory<T>, options?: T): void {\n    this._taskFactories.set(factory.name, () => observableFrom(factory.create(options)));\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "registerTaskExecutor<T>(factory: TaskExecutorFactory<T>, options?: T): void {",
              "successors": [
                {
                  "id": 2,
                  "label": "    this._taskFactories.set(factory.name, () => observableFrom(factory.create(options)));",
                  "successors": [
                    {
                      "id": 3,
                      "label": "}",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "createTaskExecutor",
          "type": "function",
          "start_line": 279,
          "end_line": 285,
          "functions": [],
          "classes": [],
          "simplified_code": "  createTaskExecutor(name: string): Observable<TaskExecutor> {\n    const factory = this._taskFactories.get(name);\n    if (factory) {\n      return factory();\n    }\n    return throwError(new UnregisteredTaskException(name));\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "createTaskExecutor(name: string): Observable<TaskExecutor> {",
              "successors": [
                {
                  "id": 2,
                  "label": "const factory = this._taskFactories.get(name);",
                  "successors": [
                    {
                      "id": 3,
                      "label": "if (factory) {",
                      "successors": [
                        {
                          "id": 4,
                          "label": "return factory();",
                          "successors": []
                        }
                      ]
                    },
                    {
                      "id": 5,
                      "label": "return throwError(new UnregisteredTaskException(name));",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "hasTaskExecutor",
          "type": "function",
          "start_line": 286,
          "end_line": 288,
          "functions": [],
          "classes": [],
          "simplified_code": "  hasTaskExecutor(name: string): boolean {\n    return this._taskFactories.has(name);\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "function hasTaskExecutor(name: string): boolean {",
              "successors": [
                {
                  "id": 2,
                  "label": "    return this._taskFactories.has(name);",
                  "successors": []
                }
              ]
            }
          ]
        }
      ],
      "simplified_code": "export abstract class FileSystemEngineHostBase implements FileSystemEngineHost {\n  protected abstract _resolveCollectionPath(name: string, requester?: string): string;\n  ): { ref: RuleFactory<{}>; path: string } | null;\n  ): FileSystemCollectionDesc;\n  ): FileSystemSchematicDesc;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private _transforms: OptionTransform<any, any>[] = [];\n  private _contextTransforms: ContextTransform[] = [];\n  private _taskFactories = new Map<string, () => Observable<TaskExecutor>>();\n  }\n  }\n  }\n    return description;\n  }\n    });\n  }\n  }\n  }\n  }\n    return schematic.factoryFn;\n  }\n  }\n  }\n  }\n}",
      "blocks": [
        {
          "id": 1,
          "label": "export abstract class FileSystemEngineHostBase implements FileSystemEngineHost {",
          "successors": [
            {
              "id": 2,
              "label": "  protected abstract _resolveCollectionPath(name: string, requester?: string): string;",
              "successors": [
                {
                  "id": 3,
                  "label": "  private _transforms: OptionTransform<any, any>[] = [];",
                  "successors": [
                    {
                      "id": 4,
                      "label": "  private _contextTransforms: ContextTransform[] = [];",
                      "successors": [
                        {
                          "id": 5,
                          "label": "  private _taskFactories = new Map<string, () => Observable<TaskExecutor>>();",
                          "successors": [
                            {
                              "id": 6,
                              "label": "",
                              "successors": [
                                {
                                  "id": 7,
                                  "label": "}",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    }
  ],
  "simplified_code": "import { BaseException, JsonObject, normalize, virtualFs } from '@angular-devkit/core';\nimport { NodeJsSyncHost } from '@angular-devkit/core/node';\nimport { existsSync, statSync } from 'fs';\nimport { dirname, isAbsolute, join, resolve } from 'path';\nimport { Observable, isObservable, lastValueFrom, from as observableFrom, throwError } from 'rxjs';\nimport { Url } from 'url';\nimport {\n  HostCreateTree,\n  RuleFactory,\n  Source,\n  TaskExecutor,\n  TaskExecutorFactory,\n  UnregisteredTaskException,\n} from '../src';\nimport {\n  FileSystemCollectionDesc,\n  FileSystemEngineHost,\n  FileSystemSchematicContext,\n  FileSystemSchematicDesc,\n  FileSystemSchematicDescription,\n} from './description';\nimport { readJsonFile } from './file-system-utility';\nexport declare type OptionTransform<T extends object | null, R extends object> = (\n  schematic: FileSystemSchematicDescription,\n  options: T,\n  context?: FileSystemSchematicContext,\n) => Observable<R> | PromiseLike<R> | R;\nexport declare type ContextTransform = (\n  context: FileSystemSchematicContext,\n) => FileSystemSchematicContext;\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}",
  "blocks": [
    {
      "id": 1,
      "label": "import { BaseException, JsonObject, normalize, virtualFs } from '@angular-devkit/core';",
      "successors": [
        {
          "id": 2,
          "label": "import { NodeJsSyncHost } from '@angular-devkit/core/node';",
          "successors": [
            {
              "id": 3,
              "label": "import { existsSync, statSync } from 'fs';",
              "successors": [
                {
                  "id": 4,
                  "label": "import { dirname, isAbsolute, join, resolve } from 'path';",
                  "successors": [
                    {
                      "id": 5,
                      "label": "import { Observable, isObservable, lastValueFrom, from as observableFrom, throwError } from 'rxjs';",
                      "successors": [
                        {
                          "id": 6,
                          "label": "import { Url } from 'url';",
                          "successors": [
                            {
                              "id": 7,
                              "label": "import { HostCreateTree, RuleFactory, Source, TaskExecutor, TaskExecutorFactory, UnregisteredTaskException, } from '../src';",
                              "successors": [
                                {
                                  "id": 8,
                                  "label": "import { FileSystemCollectionDesc, FileSystemEngineHost, FileSystemSchematicContext, FileSystemSchematicDesc, FileSystemSchematicDescription, } from './description';",
                                  "successors": [
                                    {
                                      "id": 9,
                                      "label": "import { readJsonFile } from './file-system-utility';",
                                      "successors": [
                                        {
                                          "id": 10,
                                          "label": "export declare type OptionTransform<T extends object | null, R extends object> = (schematic: FileSystemSchematicDescription, options: T, context?: FileSystemSchematicContext, ) => Observable<R> | PromiseLike<R> | R;",
                                          "successors": [
                                            {
                                              "id": 11,
                                              "label": "export declare type ContextTransform = ( context: FileSystemSchematicContext, ) => FileSystemSchematicContext;",
                                              "successors": [
                                                {
                                                  "id": 12,
                                                  "label": "",
                                                  "successors": []
                                                }
                                              ]
                                            }
                                          ]
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    }
  ]
}