{
  "name": "example_script",
  "type": "CFG",
  "start_line": 1,
  "end_line": 247,
  "functions": [
    {
      "name": "clone",
      "type": "function",
      "start_line": 16,
      "end_line": 22,
      "functions": [],
      "classes": [],
      "simplified_code": "function clone(obj: unknown): unknown {\n  try {\n    return deserialize(serialize(obj));\n  } catch {\n    return JSON.parse(JSON.stringify(obj)) as unknown;\n  }\n}",
      "blocks": [
        {
          "id": 1,
          "label": "function clone(obj: unknown): unknown {",
          "successors": [
            {
              "id": 2,
              "label": "try {\nreturn deserialize(serialize(obj));",
              "successors": []
            },
            {
              "id": 4,
              "label": "} catch {\nreturn JSON.parse(JSON.stringify(obj)) as unknown;",
              "successors": []
            },
            {
              "id": 6,
              "label": "}",
              "successors": []
            }
          ]
        }
      ]
    },
    {
      "name": "findProjectTarget",
      "type": "function",
      "start_line": 30,
      "end_line": 44,
      "functions": [],
      "classes": [],
      "simplified_code": "function findProjectTarget(\n  workspace: workspaces.WorkspaceDefinition,\n  project: string,\n  target: string,\n): workspaces.TargetDefinition {\n  const projectDefinition = workspace.projects.get(project);\n  if (!projectDefinition) {\n    throw new Error(`Project \"${project}\" does not exist.`);\n  }\n  const targetDefinition = projectDefinition.targets.get(target);\n  if (!targetDefinition) {\n    throw new Error('Project target does not exist.');\n  }\n  return targetDefinition;\n}",
      "blocks": [
        {
          "id": 1,
          "label": "function findProjectTarget(\n  workspace: workspaces.WorkspaceDefinition,\n  project: string,\n  target: string,\n): workspaces.TargetDefinition {\n  const projectDefinition = workspace.projects.get(project);\nif (!projectDefinition) {",
          "successors": [
            {
              "id": 3,
              "label": "throw new Error(`Project \"${project}\" does not exist.`);\n}",
              "successors": [
                {
                  "id": 4,
                  "label": "const targetDefinition = projectDefinition.targets.get(target);\nif (!targetDefinition) {",
                  "successors": [
                    {
                      "id": 6,
                      "label": "throw new Error('Project target does not exist.');",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "loadEsmModule",
      "type": "function",
      "start_line": 215,
      "end_line": 221,
      "functions": [],
      "classes": [],
      "simplified_code": "export function loadEsmModule<T>(modulePath: string | URL): Promise<T> {\n  load ??= new Function('modulePath', `return import(modulePath);`) as Exclude<\n    typeof load,\n    undefined\n  >;\n  return load(modulePath);\n}",
      "blocks": [
        {
          "id": 1,
          "label": "export function loadEsmModule<T>(modulePath: string | URL): Promise<T> {\n  load ??= new Function('modulePath', `return import(modulePath);`) as Exclude<\n    typeof load,\n    undefined\n  >;",
          "successors": [
            {
              "id": 3,
              "label": "  return load(modulePath);",
              "successors": []
            }
          ]
        }
      ]
    },
    {
      "name": "getBuilder",
      "type": "function",
      "start_line": 223,
      "end_line": 247,
      "functions": [],
      "classes": [],
      "simplified_code": "async function getBuilder(builderPath: string): Promise<any> {\n  switch (path.extname(builderPath)) {\n    case '.mjs':\n      // Load the ESM configuration file using the TypeScript dynamic import workaround.\n      // Once TypeScript provides support for keeping the dynamic import this workaround can be\n      // changed to a direct dynamic import.\n      return (await loadEsmModule<{ default: unknown }>(pathToFileURL(builderPath))).default;\n    case '.cjs':\n      return localRequire(builderPath);\n    default:\n      // The file could be either CommonJS or ESM.\n      // CommonJS is tried first then ESM if loading fails.\n      try {\n        return localRequire(builderPath);\n      } catch (e) {\n        if ((e as NodeJS.ErrnoException).code === 'ERR_REQUIRE_ESM') {\n          // Load the ESM configuration file using the TypeScript dynamic import workaround.\n          // Once TypeScript provides support for keeping the dynamic import this workaround can be\n          // changed to a direct dynamic import.\n          return (await loadEsmModule<{ default: unknown }>(pathToFileURL(builderPath))).default;\n        }\n        throw e;\n      }\n  }\n}",
      "blocks": [
        {
          "id": 1,
          "label": "async function getBuilder(builderPath: string): Promise<any> {\nswitch (path.extname(builderPath)) {",
          "successors": [
            {
              "id": 3,
              "label": "case '.mjs':\nreturn (await loadEsmModule<{ default: unknown }>(pathToFileURL(builderPath))).default;",
              "successors": [
                {
                  "id": 11,
                  "label": "}",
                  "successors": []
                }
              ]
            },
            {
              "id": 5,
              "label": "case '.cjs':\nreturn localRequire(builderPath);",
              "successors": [
                {
                  "id": 11,
                  "label": "}",
                  "successors": []
                }
              ]
            },
            {
              "id": 7,
              "label": "default:\ntry {",
              "successors": [
                {
                  "id": 9,
                  "label": "return localRequire(builderPath);",
                  "successors": []
                },
                {
                  "id": 10,
                  "label": "} catch (e) {\nif ((e as NodeJS.ErrnoException).code === 'ERR_REQUIRE_ESM') {",
                  "successors": []
                }
              ]
            }
          ]
        }
      ]
    }
  ],
  "classes": [
    {
      "name": "WorkspaceNodeModulesArchitectHost",
      "type": "class",
      "start_line": 45,
      "end_line": 213,
      "functions": [
        {
          "name": "constructor",
          "type": "function",
          "start_line": 47,
          "end_line": 92,
          "functions": [],
          "classes": [],
          "simplified_code": "  constructor(workspaceHost: WorkspaceHost, _root: string);\n  constructor(workspace: workspaces.WorkspaceDefinition, _root: string);\n  constructor(\n    workspaceOrHost: workspaces.WorkspaceDefinition | WorkspaceHost,\n    protected _root: string,\n  ) {\n    if ('getBuilderName' in workspaceOrHost) {\n      this.workspaceHost = workspaceOrHost;\n    } else {\n      this.workspaceHost = {\n        async getBuilderName(project, target) {\n          const targetDefinition = findProjectTarget(workspaceOrHost, project, target);\n          return targetDefinition.builder;\n        },\n        async getOptions(project, target, configuration) {\n          const targetDefinition = findProjectTarget(workspaceOrHost, project, target);\n          if (configuration === undefined) {\n            return (targetDefinition.options ?? {}) as json.JsonObject;\n          }\n          if (!targetDefinition.configurations?.[configuration]) {\n            throw new Error(`Configuration '${configuration}' is not set in the workspace.`);\n          }\n          return (targetDefinition.configurations?.[configuration] ?? {}) as json.JsonObject;\n        },\n        async getMetadata(project) {\n          const projectDefinition = workspaceOrHost.projects.get(project);\n          if (!projectDefinition) {\n            throw new Error(`Project \"${project}\" does not exist.`);\n          }\n          return {\n            root: projectDefinition.root,\n            sourceRoot: projectDefinition.sourceRoot,\n            prefix: projectDefinition.prefix,\n            ...(clone(workspaceOrHost.extensions) as {}),\n            ...(clone(projectDefinition.extensions) as {}),\n          } as unknown as json.JsonObject;\n        },\n        async hasTarget(project, target) {\n          return !!workspaceOrHost.projects.get(project)?.targets.has(target);\n        },\n        async getDefaultConfigurationName(project, target) {\n          return workspaceOrHost.projects.get(project)?.targets.get(target)?.defaultConfiguration;\n        },\n      };\n    }\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "constructor(workspaceHost: WorkspaceHost, _root: string);\nconstructor(workspace: workspaces.WorkspaceDefinition, _root: string);\nconstructor(\n  workspaceOrHost: workspaces.WorkspaceDefinition | WorkspaceHost,\n  protected _root: string,\n) {\nif ('getBuilderName' in workspaceOrHost) {",
              "successors": [
                {
                  "id": 3,
                  "label": "this.workspaceHost = workspaceOrHost;\n}",
                  "successors": []
                },
                {
                  "id": 5,
                  "label": "} else {\nthis.workspaceHost = {",
                  "successors": [
                    {
                      "id": 7,
                      "label": "async getBuilderName(project, target) {\nconst targetDefinition = findProjectTarget(workspaceOrHost, project, target);\nreturn targetDefinition.builder;",
                      "successors": [
                        {
                          "id": 9,
                          "label": "},",
                          "successors": []
                        }
                      ]
                    },
                    {
                      "id": 10,
                      "label": "async getOptions(project, target, configuration) {",
                      "successors": [
                        {
                          "id": 11,
                          "label": "const targetDefinition = findProjectTarget(workspaceOrHost, project, target);\nif (configuration === undefined) {\nreturn (targetDefinition.options ?? {}) as json.JsonObject;",
                          "successors": [
                            {
                              "id": 13,
                              "label": "} }",
                              "successors": []
                            }
                          ]
                        },
                        {
                          "id": 14,
                          "label": "if (!targetDefinition.configurations?.[configuration]) {",
                          "successors": [
                            {
                              "id": 15,
                              "label": "throw new Error(`Configuration '${configuration}' is not set in the workspace.`);\n}",
                              "successors": []
                            },
                            {
                              "id": 17,
                              "label": "return (targetDefinition.configurations?.[configuration] ?? {}) as json.JsonObject; \n},",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "id": 19,
                      "label": "async getMetadata(project) {\nconst projectDefinition = workspaceOrHost.projects.get(project);\nif (!projectDefinition) {",
                      "successors": [
                        {
                          "id": 21,
                          "label": "throw new Error(`Project \"${project}\" does not exist.`);\n},",
                          "successors": []
                        },
                        {
                          "id": 23,
                          "label": "return {\n  root: projectDefinition.root,\n  sourceRoot: projectDefinition.sourceRoot,\n  prefix: projectDefinition.prefix,\n  ...(clone(workspaceOrHost.extensions) as {}),\n  ...(clone(projectDefinition.extensions) as {}),\n} as unknown as json.JsonObject;\n},",
                          "successors": []
                        }
                      ]
                    },
                    {
                      "id": 25,
                      "label": "async hasTarget(project, target) {\nreturn !!workspaceOrHost.projects.get(project)?.targets.has(target); ",
                      "successors": [
                        {
                          "id": 27,
                          "label": "},",
                          "successors": []
                        }
                      ]
                    },
                    {
                      "id": 28,
                      "label": "async getDefaultConfigurationName(project, target) {\nreturn workspaceOrHost.projects.get(project)?.targets.get(target)?.defaultConfiguration;",
                      "successors": [
                        {
                          "id": 30,
                          "label": "},",
                          "successors": []
                        }
                      ]
                    },
                    {
                      "id": 31,
                      "label": "};\n}",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "getBuilderNameForTarget",
          "type": "function",
          "start_line": 93,
          "end_line": 95,
          "functions": [],
          "classes": [],
          "simplified_code": "  async getBuilderNameForTarget(target: Target) {\n    return this.workspaceHost.getBuilderName(target.project, target.target);\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "async getBuilderNameForTarget(target: Target) {\n  return this.workspaceHost.getBuilderName(target.project, target.target);",
              "successors": [
                {
                  "id": 3,
                  "label": "}",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "resolveBuilder",
          "type": "function",
          "start_line": 96,
          "end_line": 171,
          "functions": [],
          "classes": [],
          "simplified_code": "  resolveBuilder(\n    builderStr: string,\n    basePath = this._root,\n    seenBuilders?: Set<string>,\n  ): Promise<NodeModulesBuilderInfo> {\n    if (seenBuilders?.has(builderStr)) {\n      throw new Error(\n        'Circular builder alias references detected: ' + [...seenBuilders, builderStr],\n      );\n    }\n    const [packageName, builderName] = builderStr.split(':', 2);\n    if (!builderName) {\n      throw new Error('No builder name specified.');\n    }\n    // Resolve and load the builders manifest from the package's `builders` field, if present\n    const packageJsonPath = localRequire.resolve(packageName + '/package.json', {\n      paths: [basePath],\n    });\n    const packageJson = JSON.parse(readFileSync(packageJsonPath, 'utf-8')) as { builders?: string };\n    const buildersManifestRawPath = packageJson['builders'];\n    if (!buildersManifestRawPath) {\n      throw new Error(`Package ${JSON.stringify(packageName)} has no builders defined.`);\n    }\n    let buildersManifestPath = path.normalize(buildersManifestRawPath);\n    if (path.isAbsolute(buildersManifestRawPath) || buildersManifestRawPath.startsWith('..')) {\n      throw new Error(\n        `Package \"${packageName}\" has an invalid builders manifest path: \"${buildersManifestRawPath}\"`,\n      );\n    }\n    buildersManifestPath = path.join(path.dirname(packageJsonPath), buildersManifestPath);\n    const buildersManifest = JSON.parse(\n      readFileSync(buildersManifestPath, 'utf-8'),\n    ) as BuilderSchema;\n    const buildersManifestDirectory = path.dirname(buildersManifestPath);\n    // Attempt to locate an entry for the specified builder by name\n    const builder = buildersManifest.builders?.[builderName];\n    if (!builder) {\n      throw new Error(`Cannot find builder ${JSON.stringify(builderStr)}.`);\n    }\n    // Resolve alias reference if entry is a string\n    if (typeof builder === 'string') {\n      return this.resolveBuilder(\n        builder,\n        path.dirname(packageJsonPath),\n        (seenBuilders ?? new Set()).add(builderStr),\n      );\n    }\n    // Determine builder implementation path (relative within package only)\n    const implementationPath = builder.implementation && path.normalize(builder.implementation);\n    if (!implementationPath) {\n      throw new Error('Could not find the implementation for builder ' + builderStr);\n    }\n    if (path.isAbsolute(implementationPath) || implementationPath.startsWith('..')) {\n      throw new Error(\n        `Package \"${packageName}\" has an invalid builder implementation path: \"${builderName}\" --> \"${builder.implementation}\"`,\n      );\n    }\n    // Determine builder option schema path (relative within package only)\n    const schemaPath = builder.schema && path.normalize(builder.schema);\n    if (!schemaPath) {\n      throw new Error('Could not find the schema for builder ' + builderStr);\n    }\n    if (path.isAbsolute(schemaPath) || schemaPath.startsWith('..')) {\n      throw new Error(\n        `Package \"${packageName}\" has an invalid builder implementation path: \"${builderName}\" --> \"${builder.schema}\"`,\n      );\n    }\n    const schemaText = readFileSync(path.join(buildersManifestDirectory, schemaPath), 'utf-8');\n    return Promise.resolve({\n      name: builderStr,\n      builderName,\n      description: builder['description'],\n      optionSchema: JSON.parse(schemaText) as json.schema.JsonSchema,\n      import: path.join(buildersManifestDirectory, implementationPath),\n    });\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "resolveBuilder(builderStr: string, basePath = this._root, seenBuilders?: Set<string>): Promise<NodeModulesBuilderInfo> {\nif (seenBuilders?.has(builderStr)) {",
              "successors": [
                {
                  "id": 3,
                  "label": "throw new Error('Circular builder alias references detected: ' + [...seenBuilders, builderStr]);",
                  "successors": []
                },
                {
                  "id": 4,
                  "label": "}\nconst [packageName, builderName] = builderStr.split(':', 2);",
                  "successors": [
                    {
                      "id": 6,
                      "label": "if (!builderName) {",
                      "successors": [
                        {
                          "id": 7,
                          "label": "throw new Error('No builder name specified.');",
                          "successors": []
                        },
                        {
                          "id": 8,
                          "label": "}\nconst packageJsonPath = localRequire.resolve(packageName + '/package.json', { paths: [basePath] });",
                          "successors": [
                            {
                              "id": 10,
                              "label": "const packageJson = JSON.parse(readFileSync(packageJsonPath, 'utf-8')) as { builders?: string };\nconst buildersManifestRawPath = packageJson['builders'];",
                              "successors": [
                                {
                                  "id": 12,
                                  "label": "if (!buildersManifestRawPath) {",
                                  "successors": [
                                    {
                                      "id": 13,
                                      "label": "throw new Error(`Package ${JSON.stringify(packageName)} has no builders defined.`);",
                                      "successors": []
                                    },
                                    {
                                      "id": 14,
                                      "label": "}\nlet buildersManifestPath = path.normalize(buildersManifestRawPath);",
                                      "successors": [
                                        {
                                          "id": 16,
                                          "label": "if (path.isAbsolute(buildersManifestRawPath) || buildersManifestRawPath.startsWith('..')) {",
                                          "successors": [
                                            {
                                              "id": 17,
                                              "label": "throw new Error(`Package \"${packageName}\" has an invalid builders manifest path: \"${buildersManifestRawPath}\"`);",
                                              "successors": []
                                            },
                                            {
                                              "id": 18,
                                              "label": "}\nbuildersManifestPath = path.join(path.dirname(packageJsonPath), buildersManifestPath);",
                                              "successors": [
                                                {
                                                  "id": 20,
                                                  "label": "const buildersManifest = JSON.parse(readFileSync(buildersManifestPath, 'utf-8')) as BuilderSchema;\nconst buildersManifestDirectory = path.dirname(buildersManifestPath);",
                                                  "successors": [
                                                    {
                                                      "id": 22,
                                                      "label": "const builder = buildersManifest.builders?.[builderName];\nif (!builder) {",
                                                      "successors": [
                                                        {
                                                          "id": 24,
                                                          "label": "throw new Error(`Cannot find builder ${JSON.stringify(builderStr)}.`);",
                                                          "successors": []
                                                        },
                                                        {
                                                          "id": 25,
                                                          "label": "}\nif (typeof builder === 'string') {",
                                                          "successors": [
                                                            {
                                                              "id": 27,
                                                              "label": "return this.resolveBuilder(builder, path.dirname(packageJsonPath), (seenBuilders ?? new Set()).add(builderStr));",
                                                              "successors": []
                                                            },
                                                            {
                                                              "id": 28,
                                                              "label": "}\nconst implementationPath = builder.implementation && path.normalize(builder.implementation);",
                                                              "successors": [
                                                                {
                                                                  "id": 30,
                                                                  "label": "if (!implementationPath) {",
                                                                  "successors": [
                                                                    {
                                                                      "id": 31,
                                                                      "label": "throw new Error('Could not find the implementation for builder ' + builderStr);",
                                                                      "successors": []
                                                                    },
                                                                    {
                                                                      "id": 32,
                                                                      "label": "}\nif (path.isAbsolute(implementationPath) || implementationPath.startsWith('..')) {",
                                                                      "successors": [
                                                                        {
                                                                          "id": 34,
                                                                          "label": "throw new Error(`Package \"${packageName}\" has an invalid builder implementation path: \"${builderName}\" --> \"${builder.implementation}\"`);",
                                                                          "successors": []
                                                                        },
                                                                        {
                                                                          "id": 35,
                                                                          "label": "}\nconst schemaPath = builder.schema && path.normalize(builder.schema);",
                                                                          "successors": [
                                                                            {
                                                                              "id": 37,
                                                                              "label": "if (!schemaPath) {",
                                                                              "successors": [
                                                                                {
                                                                                  "id": 38,
                                                                                  "label": "throw new Error('Could not find the schema for builder ' + builderStr);",
                                                                                  "successors": []
                                                                                },
                                                                                {
                                                                                  "id": 39,
                                                                                  "label": "if (path.isAbsolute(schemaPath) || schemaPath.startsWith('..')) {",
                                                                                  "successors": [
                                                                                    {
                                                                                      "id": 40,
                                                                                      "label": "throw new Error(`Package \"${packageName}\" has an invalid builder implementation path: \"${builderName}\" --> \"${builder.schema}\"`);",
                                                                                      "successors": []
                                                                                    },
                                                                                    {
                                                                                      "id": 41,
                                                                                      "label": "}\nconst schemaText = readFileSync(path.join(buildersManifestDirectory, schemaPath), 'utf-8');",
                                                                                      "successors": [
                                                                                        {
                                                                                          "id": 43,
                                                                                          "label": "return Promise.resolve({ name: builderStr, builderName, description: builder['description'], optionSchema: JSON.parse(schemaText) as json.schema.JsonSchema, import: path.join(buildersManifestDirectory, implementationPath), });",
                                                                                          "successors": []
                                                                                        },
                                                                                        {
                                                                                          "id": 44,
                                                                                          "label": "}",
                                                                                          "successors": []
                                                                                        }
                                                                                      ]
                                                                                    }
                                                                                  ]
                                                                                }
                                                                              ]
                                                                            }
                                                                          ]
                                                                        }
                                                                      ]
                                                                    }
                                                                  ]
                                                                }
                                                              ]
                                                            }
                                                          ]
                                                        }
                                                      ]
                                                    }
                                                  ]
                                                }
                                              ]
                                            }
                                          ]
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "getCurrentDirectory",
          "type": "function",
          "start_line": 172,
          "end_line": 174,
          "functions": [],
          "classes": [],
          "simplified_code": "  async getCurrentDirectory() {\n    return process.cwd();\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "async getCurrentDirectory() {\n    return process.cwd();",
              "successors": []
            }
          ]
        },
        {
          "name": "getWorkspaceRoot",
          "type": "function",
          "start_line": 175,
          "end_line": 177,
          "functions": [],
          "classes": [],
          "simplified_code": "  async getWorkspaceRoot() {\n    return this._root;\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "async getWorkspaceRoot() {\n    return this._root;",
              "successors": [
                {
                  "id": 3,
                  "label": "}",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "getOptionsForTarget",
          "type": "function",
          "start_line": 178,
          "end_line": 195,
          "functions": [],
          "classes": [],
          "simplified_code": "  async getOptionsForTarget(target: Target): Promise<json.JsonObject | null> {\n    if (!(await this.workspaceHost.hasTarget(target.project, target.target))) {\n      return null;\n    }\n    let options = await this.workspaceHost.getOptions(target.project, target.target);\n    const targetConfiguration =\n      target.configuration ||\n      (await this.workspaceHost.getDefaultConfigurationName(target.project, target.target));\n    if (targetConfiguration) {\n      const configurations = targetConfiguration.split(',').map((c) => c.trim());\n      for (const configuration of configurations) {\n        options = {\n          ...options,\n          ...(await this.workspaceHost.getOptions(target.project, target.target, configuration)),\n        };\n      }\n    }\n    return clone(options) as json.JsonObject;",
          "blocks": [
            {
              "id": 1,
              "label": "async getOptionsForTarget(target: Target): Promise<json.JsonObject | null> {",
              "successors": [
                {
                  "id": 2,
                  "label": "if (!(await this.workspaceHost.hasTarget(target.project, target.target))) {\nreturn null;",
                  "successors": []
                },
                {
                  "id": 4,
                  "label": "let options = await this.workspaceHost.getOptions(target.project, target.target);\nconst targetConfiguration = target.configuration || (await this.workspaceHost.getDefaultConfigurationName(target.project, target.target));",
                  "successors": [
                    {
                      "id": 6,
                      "label": "if (targetConfiguration) {\nconst configurations = targetConfiguration.split(',').map((c) => c.trim());",
                      "successors": [
                        {
                          "id": 8,
                          "label": "for (const configuration of configurations) {",
                          "successors": [
                            {
                              "id": 9,
                              "label": "options = { ...options, ...(await this.workspaceHost.getOptions(target.project, target.target, configuration)) };",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "id": 10,
                      "label": "}\nreturn clone(options) as json.JsonObject;",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "getProjectMetadata",
          "type": "function",
          "start_line": 197,
          "end_line": 200,
          "functions": [],
          "classes": [],
          "simplified_code": "  async getProjectMetadata(target: Target | string): Promise<json.JsonObject | null> {\n    const projectName = typeof target === 'string' ? target : target.project;\n    const metadata = this.workspaceHost.getMetadata(projectName);\n    return metadata;",
          "blocks": [
            {
              "id": 1,
              "label": "async getProjectMetadata(target: Target | string): Promise<json.JsonObject | null> {\nconst projectName = typeof target === 'string' ? target : target.project;",
              "successors": [
                {
                  "id": 3,
                  "label": "const metadata = this.workspaceHost.getMetadata(projectName);\nreturn metadata;",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "loadBuilder",
          "type": "function",
          "start_line": 202,
          "end_line": 212,
          "functions": [],
          "classes": [],
          "simplified_code": "  async loadBuilder(info: NodeModulesBuilderInfo): Promise<Builder> {\n    const builder = await getBuilder(info.import);\n    if (builder[BuilderSymbol]) {\n      return builder;\n    }\n    // Default handling code is for old builders that incorrectly export `default` with non-ESM module\n    if (builder?.default[BuilderSymbol]) {\n      return builder.default;\n    }\n    throw new Error('Builder is not a builder');\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "async loadBuilder(info: NodeModulesBuilderInfo): Promise<Builder> {\nconst builder = await getBuilder(info.import);",
              "successors": [
                {
                  "id": 3,
                  "label": "if (builder[BuilderSymbol]) {",
                  "successors": [
                    {
                      "id": 4,
                      "label": "return builder;",
                      "successors": []
                    },
                    {
                      "id": 5,
                      "label": "}\nif (builder?.default[BuilderSymbol]) {",
                      "successors": [
                        {
                          "id": 7,
                          "label": "return builder.default;",
                          "successors": []
                        },
                        {
                          "id": 8,
                          "label": "}",
                          "successors": [
                            {
                              "id": 9,
                              "label": "throw new Error('Builder is not a builder');",
                              "successors": []
                            },
                            {
                              "id": 10,
                              "label": "}",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "classes": [],
      "simplified_code": "export class WorkspaceNodeModulesArchitectHost implements ArchitectHost<NodeModulesBuilderInfo> {\n  private workspaceHost: WorkspaceHost;\n  }\n  }\n  }\n  }\n  }\n    return clone(options) as json.JsonObject;\n  }\n    return metadata;\n  }\n  }\n}",
      "blocks": [
        {
          "id": 1,
          "label": "export class WorkspaceNodeModulesArchitectHost implements ArchitectHost<NodeModulesBuilderInfo> {\nprivate workspaceHost: WorkspaceHost;",
          "successors": [
            {
              "id": 3,
              "label": "return clone(options) as json.JsonObject;\nreturn metadata;",
              "successors": []
            }
          ]
        }
      ]
    }
  ],
  "simplified_code": "import { json, workspaces } from '@angular-devkit/core';\nimport { readFileSync } from 'node:fs';\nimport { createRequire } from 'node:module';\nimport * as path from 'node:path';\nimport { pathToFileURL } from 'node:url';\nimport { deserialize, serialize } from 'node:v8';\nimport { BuilderInfo } from '../src';\nimport { Schema as BuilderSchema } from '../src/builders-schema';\nimport { Target } from '../src/input-schema';\nimport { ArchitectHost, Builder, BuilderSymbol } from '../src/internal';\n// TODO_ESM: Update to use import.meta.url\nconst localRequire = createRequire(__filename);\nexport type NodeModulesBuilderInfo = BuilderInfo & {\n  import: string;\n};\n}\nexport interface WorkspaceHost {\n  getBuilderName(project: string, target: string): Promise<string>;\n  getMetadata(project: string): Promise<json.JsonObject>;\n  getOptions(project: string, target: string, configuration?: string): Promise<json.JsonObject>;\n  hasTarget(project: string, target: string): Promise<boolean>;\n  getDefaultConfigurationName(project: string, target: string): Promise<string | undefined>;\n}\n}\n}\nlet load: (<T>(modulePath: string | URL) => Promise<T>) | undefined;\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n}",
  "blocks": [
    {
      "id": 1,
      "label": "import { json, workspaces } from '@angular-devkit/core';\nimport { readFileSync } from 'node:fs';",
      "successors": [
        {
          "id": 3,
          "label": "import { createRequire } from 'node:module';\nimport * as path from 'node:path';",
          "successors": [
            {
              "id": 5,
              "label": "import { pathToFileURL } from 'node:url';\nimport { deserialize, serialize } from 'node:v8';",
              "successors": [
                {
                  "id": 7,
                  "label": "import { BuilderInfo } from '../src';\nimport { Schema as BuilderSchema } from '../src/builders-schema';",
                  "successors": [
                    {
                      "id": 9,
                      "label": "import { Target } from '../src/input-schema';\nimport { ArchitectHost, Builder, BuilderSymbol } from '../src/internal';",
                      "successors": [
                        {
                          "id": 11,
                          "label": "const localRequire = createRequire(__filename);\nexport type NodeModulesBuilderInfo = BuilderInfo & {\n  import: string;\n};",
                          "successors": [
                            {
                              "id": 13,
                              "label": "export interface WorkspaceHost {\n  getBuilderName(project: string, target: string): Promise<string>;\n  getMetadata(project: string): Promise<json.JsonObject>;\n  getOptions(project: string, target: string, configuration?: string): Promise<json.JsonObject>;\n  hasTarget(project: string, target: string): Promise<boolean>;\n  getDefaultConfigurationName(project: string, target: string): Promise<string | undefined>;\n}\nlet load: (<T>(modulePath: string | URL) => Promise<T>) | undefined;",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    }
  ]
}