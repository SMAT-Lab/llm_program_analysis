{
  "name": "example_script",
  "type": "CFG",
  "start_line": 1,
  "end_line": 677,
  "functions": [],
  "classes": [
    {
      "name": "EventPipeline",
      "type": "class",
      "start_line": 36,
      "end_line": 677,
      "functions": [
        {
          "name": "constructor",
          "type": "function",
          "start_line": 109,
          "end_line": 117,
          "functions": [],
          "classes": [],
          "simplified_code": "  constructor(broadCastParam: Broadcast, item: UserFileDataItem, timeStamp: string, updateMatrix: Function) {\n    this.broadCast = broadCastParam;\n    this.item = item;\n    this.timeStamp = timeStamp;\n    this.updateMatrix = updateMatrix;\n    this.width = this.item.imgWidth === 0 ? MediaConstants.DEFAULT_SIZE : this.item.imgWidth;\n    this.height = this.item.imgHeight === 0 ? MediaConstants.DEFAULT_SIZE : this.item.imgHeight;\n    this.evaluateScales();\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "constructor(broadCastParam: Broadcast, item: UserFileDataItem, timeStamp: string, updateMatrix: Function) {\n    this.broadCast = broadCastParam;",
              "successors": [
                {
                  "id": 3,
                  "label": "    this.item = item;\n    this.timeStamp = timeStamp;",
                  "successors": [
                    {
                      "id": 5,
                      "label": "    this.updateMatrix = updateMatrix;\n    this.width = this.item.imgWidth === 0 ? MediaConstants.DEFAULT_SIZE : this.item.imgWidth;",
                      "successors": [
                        {
                          "id": 7,
                          "label": "    this.height = this.item.imgHeight === 0 ? MediaConstants.DEFAULT_SIZE : this.item.imgHeight;\n    this.evaluateScales();",
                          "successors": []
                        },
                        {
                          "id": 9,
                          "label": "}",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "onDataChanged",
          "type": "function",
          "start_line": 119,
          "end_line": 124,
          "functions": [],
          "classes": [],
          "simplified_code": "  onDataChanged(item: UserFileDataItem): void {\n    this.item = item;\n    this.width = this.item.imgWidth === 0 ? MediaConstants.DEFAULT_SIZE : this.item.imgWidth;\n    this.height = this.item.imgHeight === 0 ? MediaConstants.DEFAULT_SIZE : this.item.imgHeight;\n    this.evaluateScales();\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "onDataChanged(item: UserFileDataItem): void {\n    this.item = item;",
              "successors": [
                {
                  "id": 3,
                  "label": "    this.width = this.item.imgWidth === 0 ? MediaConstants.DEFAULT_SIZE : this.item.imgWidth;\n    this.height = this.item.imgHeight === 0 ? MediaConstants.DEFAULT_SIZE : this.item.imgHeight;",
                  "successors": [
                    {
                      "id": 5,
                      "label": "    this.evaluateScales();\n}",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "setDefaultScale",
          "type": "function",
          "start_line": 126,
          "end_line": 129,
          "functions": [],
          "classes": [],
          "simplified_code": "  setDefaultScale(scale): void {\n    this.defaultScale = scale;\n    this.lastScale = scale;\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "setDefaultScale(scale): void {\n    this.defaultScale = scale;",
              "successors": [
                {
                  "id": 3,
                  "label": "    this.lastScale = scale;\n}",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "onComponentSizeChanged",
          "type": "function",
          "start_line": 131,
          "end_line": 133,
          "functions": [],
          "classes": [],
          "simplified_code": "  onComponentSizeChanged(): void {\n    this.evaluateScales();\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "onComponentSizeChanged(): void {\n    this.evaluateScales();",
              "successors": []
            }
          ]
        },
        {
          "name": "onTouch",
          "type": "function",
          "start_line": 135,
          "end_line": 150,
          "functions": [],
          "classes": [],
          "simplified_code": "  onTouch(event: TouchEvent): void {\n    Log.debug(TAG, 'onTouch trigger: ' + event.type + ', ' + this.isInAnimation + ', ' + this.isExiting);\n    if (this.isInAnimation || this.isExiting) {\n      return;\n    }\n    if (event.type === TouchType.Down || event.type === TouchType.Up) {\n      this.emitDirectionChange();\n    }\n\n    if (event.type === TouchType.Up) {\n      this.lastOffset = this.evaluateOffset();\n      this.lastScale = this.lastScale * this.scale;\n      this.scale = 1;\n      this.offset = [0, 0];\n    }\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "onTouch(event: TouchEvent): void {\nLog.debug(TAG, 'onTouch trigger: ' + event.type + ', ' + this.isInAnimation + ', ' + this.isExiting);",
              "successors": [
                {
                  "id": 3,
                  "label": "if (this.isInAnimation || this.isExiting) {\nreturn;",
                  "successors": []
                },
                {
                  "id": 5,
                  "label": "if (event.type === TouchType.Down || event.type === TouchType.Up) {\nthis.emitDirectionChange();",
                  "successors": []
                },
                {
                  "id": 7,
                  "label": "if (event.type === TouchType.Up) {\nthis.lastOffset = this.evaluateOffset();\nthis.lastScale = this.lastScale * this.scale;\nthis.scale = 1;\nthis.offset = [0, 0];",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "emitDirectionChange",
          "type": "function",
          "start_line": 152,
          "end_line": 188,
          "functions": [],
          "classes": [],
          "simplified_code": "  private emitDirectionChange(): void {\n\n    /**\n     * reachLeft reachRight scale>1，only five possible situations（when scale<=1,reachLeft、reachRight is true）：\n     * T T T：Vertical\n     * T T F：Vertical（initial state）\n     * T F T：Vertical | Left\n     * F T T：Vertical | Right\n     * F F T：All\n     */\n    let direction;\n    let scale = this.lastScale * this.scale;\n    let isEnlarged = Number(scale.toFixed(Constants.RESERVED_DIGITS)) > Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS));\n    if (!this.hasReachLeft && !this.hasReachRight && isEnlarged) {\n      direction = PanDirection.All;\n    } else if (!this.hasReachLeft && this.hasReachRight && isEnlarged) {\n      direction = (PanDirection.Vertical as number) | (PanDirection.Right as number);\n    } else if (this.hasReachLeft && !this.hasReachRight && isEnlarged) {\n      direction = (PanDirection.Vertical as number) | (PanDirection.Left as number);\n    } else {\n      direction = PanDirection.Vertical;\n    }\n\n    Log.info(TAG, 'emitDirectionChange reaches: ' + this.hasReachLeft + ', ' + this.hasReachRight + ', ' + this.hasReachTop + ', ' + this.hasReachBottom +\n    ', scale ' + scale + ', direction: ' + direction);\n    if (this.isExiting) {\n      return;\n    }\n\n    if (direction === (PanDirection.Vertical as number) || direction === ((PanDirection.Vertical as number) | (PanDirection.Left as number)) ||\n    direction === ((PanDirection.Vertical as number) | (PanDirection.Right as number))) {\n      this.broadCast.emit(Constants.SET_DISABLE_SWIPE, [false]);\n    } else {\n      this.broadCast.emit(Constants.SET_DISABLE_SWIPE, [true]);\n    }\n    this.broadCast.emit(Constants.DIRECTION_CHANGE + this.item.uri + this.timeStamp, [direction]);\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "private emitDirectionChange(): void {",
              "successors": [
                {
                  "id": 2,
                  "label": "let direction;\nlet scale = this.lastScale * this.scale;\nlet isEnlarged = Number(scale.toFixed(Constants.RESERVED_DIGITS)) > Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS));\nif (!this.hasReachLeft && !this.hasReachRight && isEnlarged) {",
                  "successors": [
                    {
                      "id": 4,
                      "label": "direction = PanDirection.All;\nLog.info(TAG, 'emitDirectionChange reaches: ' + this.hasReachLeft + ', ' + this.hasReachRight + ', ' + this.hasReachTop + ', ' + this.hasReachBottom + ', scale ' + scale + ', direction: ' + direction);",
                      "successors": [
                        {
                          "id": 14,
                          "label": "if (this.isExiting) {\nreturn;",
                          "successors": []
                        },
                        {
                          "id": 16,
                          "label": "if (direction === (PanDirection.Vertical as number) || direction === ((PanDirection.Vertical as number) | (PanDirection.Left as number)) || direction === ((PanDirection.Vertical as number) | (PanDirection.Right as number))) {\nthis.broadCast.emit(Constants.SET_DISABLE_SWIPE, [false]);",
                          "successors": [
                            {
                              "id": 19,
                              "label": "this.broadCast.emit(Constants.DIRECTION_CHANGE + this.item.uri + this.timeStamp, [direction]);",
                              "successors": []
                            }
                          ]
                        },
                        {
                          "id": 18,
                          "label": "this.broadCast.emit(Constants.SET_DISABLE_SWIPE, [true]);\nthis.broadCast.emit(Constants.DIRECTION_CHANGE + this.item.uri + this.timeStamp, [direction]);",
                          "successors": []
                        }
                      ]
                    }
                  ]
                },
                {
                  "id": 5,
                  "label": "else if (!this.hasReachLeft && this.hasReachRight && isEnlarged) {\ndirection = (PanDirection.Vertical as number) | (PanDirection.Right as number);",
                  "successors": [
                    {
                      "id": 13,
                      "label": "Log.info(TAG, 'emitDirectionChange reaches: ' + this.hasReachLeft + ', ' + this.hasReachRight + ', ' + this.hasReachTop + ', ' + this.hasReachBottom + ', scale ' + scale + ', direction: ' + direction);",
                      "successors": [
                        {
                          "id": 14,
                          "label": "if (this.isExiting) {\nreturn;",
                          "successors": []
                        },
                        {
                          "id": 16,
                          "label": "if (direction === (PanDirection.Vertical as number) || direction === ((PanDirection.Vertical as number) | (PanDirection.Left as number)) || direction === ((PanDirection.Vertical as number) | (PanDirection.Right as number))) {\nthis.broadCast.emit(Constants.SET_DISABLE_SWIPE, [false]);",
                          "successors": [
                            {
                              "id": 19,
                              "label": "this.broadCast.emit(Constants.DIRECTION_CHANGE + this.item.uri + this.timeStamp, [direction]);",
                              "successors": []
                            }
                          ]
                        },
                        {
                          "id": 18,
                          "label": "this.broadCast.emit(Constants.SET_DISABLE_SWIPE, [true]);\nthis.broadCast.emit(Constants.DIRECTION_CHANGE + this.item.uri + this.timeStamp, [direction]);",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "evaluateOffset",
          "type": "function",
          "start_line": 190,
          "end_line": 198,
          "functions": [],
          "classes": [],
          "simplified_code": "  private evaluateOffset(): number[] {\n    Log.info(TAG, 'evaluateOffset lastOffset: ' + this.lastOffset + ', offset: ' + this.offset);\n    let centerX = (this.center[0] - Constants.CENTER_DEFAULT) * this.componentWidth * (this.defaultScale - this.scale) * this.lastScale;\n    let centerY = (this.center[1] - Constants.CENTER_DEFAULT) * this.componentHeight * (this.defaultScale - this.scale) * this.lastScale;\n    let offsetX = this.lastOffset[0] + this.offset[0] + centerX;\n    let offsetY = this.lastOffset[1] + this.offset[1] + centerY;\n    Log.debug(TAG, 'evaluateOffset offsetX: ' + offsetX + ', offsetY: ' + offsetY);\n    return [offsetX, offsetY];\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "Log.info(TAG, 'evaluateOffset lastOffset: ' + this.lastOffset + ', offset: ' + this.offset);\nlet centerX = (this.center[0] - Constants.CENTER_DEFAULT) * this.componentWidth * (this.defaultScale - this.scale) * this.lastScale;",
              "successors": [
                {
                  "id": 3,
                  "label": "let centerY = (this.center[1] - Constants.CENTER_DEFAULT) * this.componentHeight * (this.defaultScale - this.scale) * this.lastScale;\nlet offsetX = this.lastOffset[0] + this.offset[0] + centerX;",
                  "successors": [
                    {
                      "id": 5,
                      "label": "let offsetY = this.lastOffset[1] + this.offset[1] + centerY;\nLog.debug(TAG, 'evaluateOffset offsetX: ' + offsetX + ', offsetY: ' + offsetY);",
                      "successors": [
                        {
                          "id": 7,
                          "label": "return [offsetX, offsetY];",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "emitTouchEvent",
          "type": "function",
          "start_line": 200,
          "end_line": 238,
          "functions": [],
          "classes": [],
          "simplified_code": "  private emitTouchEvent(): void {\n    let offset: number[];\n    let scale = this.lastScale * this.scale;\n    if (Number(scale.toFixed(Constants.RESERVED_DIGITS)) > Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) {\n      let limits = this.evaluateOffsetRange(scale);\n      offset = this.evaluateOffset();\n      // the offset in the X direction is always limited for non shrinking scenes\n      offset[0] = MathUtils.clamp(offset[0], limits[0], limits[1]);\n      if (Number(scale.toFixed(Constants.RESERVED_DIGITS)) > Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) {\n        // cannot pull down to return, limit y\n        offset[1] = MathUtils.clamp(offset[1], limits[2], limits[3]);\n      } else {\n        // can pull down to return to the scene, and only limit y to drag upward, limit the lower bound\n        offset[1] = Math.max(limits[2], offset[1]);\n      }\n    } else {\n      // When zooming in, adjust the zoom center to the display center point\n      offset = [0, 0];\n    }\n    let moveX = offset[0];\n    let moveY = offset[1];\n    Log.debug(TAG, 'emitTouchEvent moveX: ' + moveX + ', moveY: ' + moveY);\n    let scaleOption: Matrix4.ScaleOption = {\n      x: scale,\n      y: scale,\n    };\n    let translateOption: Matrix4.TranslateOption = {\n      x: moveX,\n      y: moveY\n    };\n    let matrix = Matrix4.identity()\n      .scale(scaleOption)\n      .translate(translateOption)\n      .copy();\n    Log.debug(TAG, 'emitTouchEvent lastOffset: ' + this.lastOffset + ', offset: ' + this.offset +\n    ',center: ' + this.center + ', scale: ' + this.lastScale + ', ' + this.scale);\n    this.updateMatrix(matrix);\n    this.evaluateBounds();\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "let offset: number[];\nlet scale = this.lastScale * this.scale;",
              "successors": [
                {
                  "id": 2,
                  "label": "if (Number(scale.toFixed(Constants.RESERVED_DIGITS)) > Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) {\nlet limits = this.evaluateOffsetRange(scale);\noffset = this.evaluateOffset();\noffset[0] = MathUtils.clamp(offset[0], limits[0], limits[1]);",
                  "successors": [
                    {
                      "id": 4,
                      "label": "if (Number(scale.toFixed(Constants.RESERVED_DIGITS)) > Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) {\noffset[1] = MathUtils.clamp(offset[1], limits[2], limits[3]);",
                      "successors": [
                        {
                          "id": 9,
                          "label": "let moveX = offset[0];\nlet moveY = offset[1];\nLog.debug(TAG, 'emitTouchEvent moveX: ' + moveX + ', moveY: ' + moveY);\nlet scaleOption: Matrix4.ScaleOption = {\n  x: scale,\n  y: scale,\n};\nlet translateOption: Matrix4.TranslateOption = {\n  x: moveX,\n  y: moveY\n};\nlet matrix = Matrix4.identity()\n  .scale(scaleOption)\n  .translate(translateOption)\n  .copy();\nLog.debug(TAG, 'emitTouchEvent lastOffset: ' + this.lastOffset + ', offset: ' + this.offset + ',center: ' + this.center + ', scale: ' + this.lastScale + ', ' + this.scale);\nthis.updateMatrix(matrix);\nthis.evaluateBounds();",
                          "successors": []
                        }
                      ]
                    },
                    {
                      "id": 6,
                      "label": "else {\noffset[1] = Math.max(limits[2], offset[1]);",
                      "successors": [
                        {
                          "id": 9,
                          "label": "let moveX = offset[0];\nlet moveY = offset[1];\nLog.debug(TAG, 'emitTouchEvent moveX: ' + moveX + ', moveY: ' + moveY);\nlet scaleOption: Matrix4.ScaleOption = {\n  x: scale,\n  y: scale,\n};\nlet translateOption: Matrix4.TranslateOption = {\n  x: moveX,\n  y: moveY\n};\nlet matrix = Matrix4.identity()\n  .scale(scaleOption)\n  .translate(translateOption)\n  .copy();\nLog.debug(TAG, 'emitTouchEvent lastOffset: ' + this.lastOffset + ', offset: ' + this.offset + ',center: ' + this.center + ', scale: ' + this.lastScale + ', ' + this.scale);\nthis.updateMatrix(matrix);\nthis.evaluateBounds();",
                          "successors": []
                        }
                      ]
                    }
                  ]
                },
                {
                  "id": 8,
                  "label": "else {\noffset = [0, 0];\nlet moveX = offset[0];\nlet moveY = offset[1];\nLog.debug(TAG, 'emitTouchEvent moveX: ' + moveX + ', moveY: ' + moveY);\nlet scaleOption: Matrix4.ScaleOption = {\n  x: scale,\n  y: scale,\n};\nlet translateOption: Matrix4.TranslateOption = {\n  x: moveX,\n  y: moveY\n};\nlet matrix = Matrix4.identity()\n  .scale(scaleOption)\n  .translate(translateOption)\n  .copy();\nLog.debug(TAG, 'emitTouchEvent lastOffset: ' + this.lastOffset + ', offset: ' + this.offset + ',center: ' + this.center + ', scale: ' + this.lastScale + ', ' + this.scale);\nthis.updateMatrix(matrix);\nthis.evaluateBounds();",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "evaluateScales",
          "type": "function",
          "start_line": 240,
          "end_line": 273,
          "functions": [],
          "classes": [],
          "simplified_code": "  private evaluateScales(): void {\n    if (this.width * this.componentHeight < this.componentWidth * this.height) {\n      // The aspect ratio is less than the display aspect ratio of the control\n      // the height of the control is equal to the height of the picture\n      this.maxScale = this.height / this.componentHeight;\n      // Double click the enlarged scale to ensure that the left and right boundaries are filled\n      this.doubleTapScale = this.componentWidth * this.height / this.width / this.componentHeight;\n      // leftMost = (1 - dspW / compW) / 2 = (1 - compH * imgW / imgH / compW) / 2\n      this.leftMost = (1 - this.componentHeight * this.width / this.height / this.componentWidth) / Constants.NUMBER_2;\n      this.topMost = 0.0;\n    } else if (this.width * this.componentHeight === this.componentWidth * this.height) {\n      // The aspect ratio is equal to the display aspect ratio of the control\n      this.doubleTapScale = Constants.SAME_RATIO_SCALE_FACTOR;\n      this.maxScale = this.doubleTapScale * Constants.MAX_SCALE_EXTRA_FACTOR;\n      this.leftMost = 0;\n      this.topMost = 0;\n    } else {\n      // The aspect ratio is greater than the display aspect ratio of the control\n      // the width of the control is equal to the width of the picture\n      this.maxScale = this.width / this.componentWidth;\n      // Double click the enlarged scale to ensure that the top and bottom fill the boundary\n      this.doubleTapScale = this.componentHeight * this.width / this.height / this.componentWidth;\n      this.leftMost = 0.0;\n      this.topMost = (1 - this.componentWidth * this.height / this.width / this.componentHeight) / Constants.NUMBER_2;\n    }\n\n    this.maxScale = Math.max(this.maxScale, Constants.COMPONENT_SCALE_CEIL);\n    if (this.doubleTapScale > this.maxScale) {\n      this.maxScale = this.doubleTapScale * Constants.MAX_SCALE_EXTRA_FACTOR;\n    }\n    Log.debug(TAG, 'evaluateScales: ' + this.width + '*' + this.height + ' &' +\n    this.componentWidth + '*' + this.componentHeight +\n    ',max: ' + this.maxScale + ', most: [' + this.leftMost + ',' + this.topMost + '], double: ' + this.doubleTapScale);\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "private evaluateScales(): void {",
              "successors": [
                {
                  "id": 2,
                  "label": "if (this.width * this.componentHeight < this.componentWidth * this.height) {\n    this.maxScale = this.height / this.componentHeight;\n    this.doubleTapScale = this.componentWidth * this.height / this.width / this.componentHeight;\n    this.leftMost = (1 - this.componentHeight * this.width / this.height / this.componentWidth) / Constants.NUMBER_2;\n    this.topMost = 0.0;",
                  "successors": [
                    {
                      "id": 10,
                      "label": "this.maxScale = Math.max(this.maxScale, Constants.COMPONENT_SCALE_CEIL);\nif (this.doubleTapScale > this.maxScale) {",
                      "successors": [
                        {
                          "id": 12,
                          "label": "    this.maxScale = this.doubleTapScale * Constants.MAX_SCALE_EXTRA_FACTOR;\nLog.debug(TAG, 'evaluateScales: ' + this.width + '*' + this.height + ' &' +\nthis.componentWidth + '*' + this.componentHeight +\n',max: ' + this.maxScale + ', most: [' + this.leftMost + ',' + this.topMost + '], double: ' + this.doubleTapScale);",
                          "successors": []
                        }
                      ]
                    }
                  ]
                },
                {
                  "id": 4,
                  "label": "else if (this.width * this.componentHeight === this.componentWidth * this.height) {\n    this.doubleTapScale = Constants.SAME_RATIO_SCALE_FACTOR;\n    this.maxScale = this.doubleTapScale * Constants.MAX_SCALE_EXTRA_FACTOR;\n    this.leftMost = 0;\n    this.topMost = 0;",
                  "successors": [
                    {
                      "id": 10,
                      "label": "this.maxScale = Math.max(this.maxScale, Constants.COMPONENT_SCALE_CEIL);\nif (this.doubleTapScale > this.maxScale) {",
                      "successors": [
                        {
                          "id": 12,
                          "label": "    this.maxScale = this.doubleTapScale * Constants.MAX_SCALE_EXTRA_FACTOR;\nLog.debug(TAG, 'evaluateScales: ' + this.width + '*' + this.height + ' &' +\nthis.componentWidth + '*' + this.componentHeight +\n',max: ' + this.maxScale + ', most: [' + this.leftMost + ',' + this.topMost + '], double: ' + this.doubleTapScale);",
                          "successors": []
                        }
                      ]
                    }
                  ]
                },
                {
                  "id": 6,
                  "label": "else {\n    this.maxScale = this.width / this.componentWidth;\n    this.doubleTapScale = this.componentHeight * this.width / this.height / this.componentWidth;\n    this.leftMost = 0.0;\n    this.topMost = (1 - this.componentWidth * this.height / this.width / this.componentHeight) / Constants.NUMBER_2;",
                  "successors": [
                    {
                      "id": 10,
                      "label": "this.maxScale = Math.max(this.maxScale, Constants.COMPONENT_SCALE_CEIL);\nif (this.doubleTapScale > this.maxScale) {",
                      "successors": [
                        {
                          "id": 12,
                          "label": "    this.maxScale = this.doubleTapScale * Constants.MAX_SCALE_EXTRA_FACTOR;\nLog.debug(TAG, 'evaluateScales: ' + this.width + '*' + this.height + ' &' +\nthis.componentWidth + '*' + this.componentHeight +\n',max: ' + this.maxScale + ', most: [' + this.leftMost + ',' + this.topMost + '], double: ' + this.doubleTapScale);",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "evaluateCompBounds",
          "type": "function",
          "start_line": 275,
          "end_line": 283,
          "functions": [],
          "classes": [],
          "simplified_code": "  private evaluateCompBounds(): number[] {\n    let scale = this.lastScale * this.scale;\n    let offset = this.evaluateOffset();\n    let result: number[] = [\n      offset[0] - this.componentWidth * (Number(scale.toFixed(Constants.RESERVED_DIGITS)) - Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) / Constants.NUMBER_2,\n      offset[1] - this.componentHeight * (Number(scale.toFixed(Constants.RESERVED_DIGITS)) - Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) / Constants.NUMBER_2\n    ];\n    Log.debug(TAG, 'evaluateCompBounds: ' + result);\n    return result;",
          "blocks": [
            {
              "id": 1,
              "label": "let scale = this.lastScale * this.scale;\nlet offset = this.evaluateOffset();",
              "successors": [
                {
                  "id": 3,
                  "label": "let result: number[] = [\n  offset[0] - this.componentWidth * (Number(scale.toFixed(Constants.RESERVED_DIGITS)) - Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) / Constants.NUMBER_2,\n  offset[1] - this.componentHeight * (Number(scale.toFixed(Constants.RESERVED_DIGITS)) - Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) / Constants.NUMBER_2\n];\nLog.debug(TAG, 'evaluateCompBounds: ' + result);",
                  "successors": [
                    {
                      "id": 5,
                      "label": "return result;",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "evaluateImgDisplaySize",
          "type": "function",
          "start_line": 286,
          "end_line": 296,
          "functions": [],
          "classes": [],
          "simplified_code": "  private evaluateImgDisplaySize(): number[] {\n    let screenScale = 1;\n    let widthScale = this.componentWidth / this.item.imgWidth;\n    let heightScale = this.componentHeight / this.item.imgHeight;\n    screenScale = widthScale > heightScale ? heightScale : widthScale;\n    let scale = this.lastScale * this.scale * screenScale;\n    let imgDisplayWidth = 0;\n    let imgDisplayHeight = 0;\n    imgDisplayWidth = this.width * scale;\n    imgDisplayHeight = this.height * scale;\n    return [imgDisplayWidth, imgDisplayHeight];",
          "blocks": [
            {
              "id": 1,
              "label": "private evaluateImgDisplaySize(): number[] {\nlet screenScale = 1;\nlet widthScale = this.componentWidth / this.item.imgWidth;\nlet heightScale = this.componentHeight / this.item.imgHeight;\nscreenScale = widthScale > heightScale ? heightScale : widthScale;",
              "successors": [
                {
                  "id": 3,
                  "label": "let scale = this.lastScale * this.scale * screenScale;\nlet imgDisplayWidth = 0;\nlet imgDisplayHeight = 0;\nimgDisplayWidth = this.width * scale;\nimgDisplayHeight = this.height * scale;\nreturn [imgDisplayWidth, imgDisplayHeight];\n}",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "evaluateImgDisplayBounds",
          "type": "function",
          "start_line": 299,
          "end_line": 321,
          "functions": [],
          "classes": [],
          "simplified_code": "  private evaluateImgDisplayBounds(): number[] {\n    // For the left boundary of the component,\n    // the offset caused by amplification is - compw * (scale-1) / 2,\n    // plus the offset of the gesture to obtain the left boundary of the control.\n    // The same is true for the upper boundary\n    let scale = this.lastScale * this.scale;\n    let leftTop = this.evaluateCompBounds();\n    let imgDisplaySize: number[] = this.evaluateImgDisplaySize();\n    let imgDisplayWidth = imgDisplaySize[0];\n    let imgDisplayHeight = imgDisplaySize[1];\n    let imgLeftBound = 0;\n    let imgTopBound = 0;\n    if (this.width / this.height > this.componentWidth / this.componentHeight) {\n      imgLeftBound = leftTop[0];\n      imgTopBound = leftTop[1] + (this.componentHeight * scale - imgDisplayHeight) / Constants.NUMBER_2;\n    } else {\n      // Control width minus the picture width, divided by 2,\n      // you can get the distance from the left of the picture to the left of the control.\n      // Plus offsetX is the left boundary of the picture currently displayed\n      imgLeftBound = (this.componentWidth * scale - imgDisplayWidth) / Constants.NUMBER_2 + leftTop[0];\n      imgTopBound = leftTop[1];\n    }\n    return [imgLeftBound, imgTopBound];",
          "blocks": [
            {
              "id": 1,
              "label": "let scale = this.lastScale * this.scale;\nlet leftTop = this.evaluateCompBounds();\nlet imgDisplaySize: number[] = this.evaluateImgDisplaySize();\nlet imgDisplayWidth = imgDisplaySize[0];\nlet imgDisplayHeight = imgDisplaySize[1];\nlet imgLeftBound = 0;\nlet imgTopBound = 0;\nif (this.width / this.height > this.componentWidth / this.componentHeight) {",
              "successors": [
                {
                  "id": 3,
                  "label": "    imgLeftBound = leftTop[0];\n    imgTopBound = leftTop[1] + (this.componentHeight * scale - imgDisplayHeight) / Constants.NUMBER_2;\nreturn [imgLeftBound, imgTopBound];",
                  "successors": []
                },
                {
                  "id": 4,
                  "label": "    imgLeftBound = (this.componentWidth * scale - imgDisplayWidth) / Constants.NUMBER_2 + leftTop[0];\n    imgTopBound = leftTop[1];\nreturn [imgLeftBound, imgTopBound];",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "evaluateBounds",
          "type": "function",
          "start_line": 325,
          "end_line": 333,
          "functions": [],
          "classes": [],
          "simplified_code": "  private evaluateBounds(): void {\n    let imgDisplaySize: number[] = this.evaluateImgDisplaySize();\n    let imgDisplayWidth = imgDisplaySize[0];\n\n    let imgDisplayBounds = this.evaluateImgDisplayBounds();\n    let imgLeftBound = imgDisplayBounds[0];\n    this.hasReachLeft = imgLeftBound > -1;\n    this.hasReachRight = imgLeftBound + imgDisplayWidth < this.componentWidth + 1;\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "let imgDisplaySize: number[] = this.evaluateImgDisplaySize();\nlet imgDisplayWidth = imgDisplaySize[0];\nlet imgDisplayBounds = this.evaluateImgDisplayBounds();\nlet imgLeftBound = imgDisplayBounds[0];",
              "successors": [
                {
                  "id": 3,
                  "label": "this.hasReachLeft = imgLeftBound > -1;\nthis.hasReachRight = imgLeftBound + imgDisplayWidth < this.componentWidth + 1;",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "evaluateOffsetRange",
          "type": "function",
          "start_line": 341,
          "end_line": 353,
          "functions": [],
          "classes": [],
          "simplified_code": "  private evaluateOffsetRange(scale: number): number[] {\n    let result: number[] = [0, 0, 0, 0];\n    let screenScale = 1;\n    let widthScale = this.componentWidth / this.item.imgWidth;\n    let heightScale = this.componentHeight / this.item.imgHeight;\n    screenScale = widthScale > heightScale ? heightScale : widthScale;\n    let left = (screenScale * scale * this.width - this.componentWidth) / Constants.NUMBER_2;\n    let top = (screenScale * scale * this.height - this.componentHeight) / Constants.NUMBER_2;\n    top = Math.max(top, 0);\n    left = Math.max(left, 0);\n    result = [-left, left, -top, top];\n    Log.debug(TAG, 'evaluateOffsetRange scale: ' + scale + ', defaultScale: ' + this.defaultScale + ', result: ' + result);\n    return result;",
          "blocks": [
            {
              "id": 1,
              "label": "private evaluateOffsetRange(scale: number): number[] {\nlet result: number[] = [0, 0, 0, 0];",
              "successors": [
                {
                  "id": 3,
                  "label": "let screenScale = 1;\nlet widthScale = this.componentWidth / this.item.imgWidth;",
                  "successors": [
                    {
                      "id": 5,
                      "label": "let heightScale = this.componentHeight / this.item.imgHeight;\nscreenScale = widthScale > heightScale ? heightScale : widthScale;",
                      "successors": [
                        {
                          "id": 7,
                          "label": "let left = (screenScale * scale * this.width - this.componentWidth) / Constants.NUMBER_2;\nlet top = (screenScale * scale * this.height - this.componentHeight) / Constants.NUMBER_2;",
                          "successors": [
                            {
                              "id": 9,
                              "label": "top = Math.max(top, 0);\nleft = Math.max(left, 0);",
                              "successors": [
                                {
                                  "id": 11,
                                  "label": "result = [-left, left, -top, top];\nLog.debug(TAG, 'evaluateOffsetRange scale: ' + scale + ', defaultScale: ' + this.defaultScale + ', result: ' + result);",
                                  "successors": [
                                    {
                                      "id": 13,
                                      "label": "return result;",
                                      "successors": []
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "emitPullDownToBackEvent",
          "type": "function",
          "start_line": 356,
          "end_line": 364,
          "functions": [],
          "classes": [],
          "simplified_code": "  private emitPullDownToBackEvent(): void {\n    Log.debug(TAG, 'emitPullDownToBackEvent');\n    if (this.isExiting) {\n      Log.info(TAG, 'emitPullDownToBack isExiting: ' + this.isExiting);\n      return;\n    }\n    this.broadCast.emit(Constants.PULL_DOWN_END, []);\n    this.isExiting = true;\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "private emitPullDownToBackEvent(): void {\n  Log.debug(TAG, 'emitPullDownToBackEvent');\nif (this.isExiting) {",
              "successors": [
                {
                  "id": 3,
                  "label": "  Log.info(TAG, 'emitPullDownToBack isExiting: ' + this.isExiting);\n  return;",
                  "successors": []
                },
                {
                  "id": 4,
                  "label": "}\nthis.broadCast.emit(Constants.PULL_DOWN_END, []);\nthis.isExiting = true;",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "emitPullDownCancelEvent",
          "type": "function",
          "start_line": 366,
          "end_line": 369,
          "functions": [],
          "classes": [],
          "simplified_code": "  private emitPullDownCancelEvent(): void {\n    Log.debug(TAG, 'emitPullDownCancelEvent');\n    this.broadCast.emit(Constants.PULL_DOWN_CANCEL, []);\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "private emitPullDownCancelEvent(): void {\n  Log.debug(TAG, 'emitPullDownCancelEvent');\n  this.broadCast.emit(Constants.PULL_DOWN_CANCEL, []);\n}",
              "successors": []
            }
          ]
        },
        {
          "name": "onMoveStart",
          "type": "function",
          "start_line": 371,
          "end_line": 387,
          "functions": [],
          "classes": [],
          "simplified_code": "  onMoveStart(offsetX: number, offsetY: number): void {\n    if (this.isInAnimation || this.isExiting) {\n      return;\n    }\n    // Reset offset at the beginning of dragging to prevent jumping\n    this.offset = [0, 0];\n    this.evaluateBounds();\n    let scale = this.lastScale * this.scale;\n    if (Number(scale.toFixed(Constants.RESERVED_DIGITS)) > Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) {\n      // Hide bars with zoom drag\n      this.broadCast.emit(Constants.HIDE_BARS, []);\n    }\n    if (scale.toFixed(Constants.RESERVED_DIGITS) === this.defaultScale.toFixed(Constants.RESERVED_DIGITS) && offsetY > 0) {\n      // Drop down return to hide details first\n      this.broadCast.emit(Constants.PULL_DOWN_START, []);\n    }\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "onMoveStart(offsetX: number, offsetY: number): void {",
              "successors": [
                {
                  "id": 2,
                  "label": "if (this.isInAnimation || this.isExiting) {\nreturn;",
                  "successors": []
                },
                {
                  "id": 4,
                  "label": "this.offset = [0, 0];\nthis.evaluateBounds();",
                  "successors": [
                    {
                      "id": 6,
                      "label": "let scale = this.lastScale * this.scale;",
                      "successors": [
                        {
                          "id": 7,
                          "label": "if (Number(scale.toFixed(Constants.RESERVED_DIGITS)) > Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) {\nthis.broadCast.emit(Constants.HIDE_BARS, []);",
                          "successors": []
                        },
                        {
                          "id": 9,
                          "label": "if (scale.toFixed(Constants.RESERVED_DIGITS) === this.defaultScale.toFixed(Constants.RESERVED_DIGITS) && offsetY > 0) {\nthis.broadCast.emit(Constants.PULL_DOWN_START, []);",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "onMove",
          "type": "function",
          "start_line": 395,
          "end_line": 424,
          "functions": [],
          "classes": [],
          "simplified_code": "  onMove(offsetX: number, offsetY: number): void {\n    if (this.isInAnimation || this.isExiting) {\n      return;\n    }\n    let scale = this.lastScale * this.scale;\n    let limits = this.evaluateOffsetRange(scale);\n    let measureX = this.lastOffset[0] + (this.center[0] - Constants.CENTER_DEFAULT) * this.componentWidth\n    * (this.defaultScale - this.scale) * this.lastScale;\n    let measureY = this.lastOffset[1] + (this.center[1] - Constants.CENTER_DEFAULT) * this.componentHeight\n    * (this.defaultScale - this.scale) * this.lastScale;\n    let moveX = offsetX;\n    let moveY = offsetY;\n    let offX = measureX + moveX;\n    let offY = measureY + moveY;\n    if (Number(scale.toFixed(Constants.RESERVED_DIGITS)) > Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) {\n      // The offset in the X direction is always limited for non shrinking scenes\n      offX = MathUtils.clamp(offX, limits[0], limits[1]);\n      if (Number(scale.toFixed(Constants.RESERVED_DIGITS)) > Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) {\n        // cannot drop down to return to the scene, limit y\n        offY = MathUtils.clamp(offY, limits[Constants.NUMBER_2], limits[Constants.NUMBER_3]);\n      } else {\n        // pull down to return to the scene, and only limit y to drag upward, that is, limit the lower bound\n        offY = Math.max(limits[Constants.NUMBER_2], offY);\n      }\n    }\n    let tmpX = offX - measureX;\n    let tmpY = offY - measureY;\n    this.offset = [tmpX, tmpY];\n    this.emitTouchEvent();\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "onMove(offsetX: number, offsetY: number): void {",
              "successors": [
                {
                  "id": 2,
                  "label": "if (this.isInAnimation || this.isExiting) {\nreturn;",
                  "successors": []
                },
                {
                  "id": 4,
                  "label": "let scale = this.lastScale * this.scale;\nlet limits = this.evaluateOffsetRange(scale);\nlet measureX = this.lastOffset[0] + (this.center[0] - Constants.CENTER_DEFAULT) * this.componentWidth * (this.defaultScale - this.scale) * this.lastScale;\nlet measureY = this.lastOffset[1] + (this.center[1] - Constants.CENTER_DEFAULT) * this.componentHeight * (this.defaultScale - this.scale) * this.lastScale;\nlet moveX = offsetX;\nlet moveY = offsetY;\nlet offX = measureX + moveX;\nlet offY = measureY + moveY;",
                  "successors": [
                    {
                      "id": 5,
                      "label": "if (Number(scale.toFixed(Constants.RESERVED_DIGITS)) > Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) {\noffX = MathUtils.clamp(offX, limits[0], limits[1]);",
                      "successors": [
                        {
                          "id": 7,
                          "label": "if (Number(scale.toFixed(Constants.RESERVED_DIGITS)) > Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) {\noffY = MathUtils.clamp(offY, limits[Constants.NUMBER_2], limits[Constants.NUMBER_3]);",
                          "successors": []
                        },
                        {
                          "id": 9,
                          "label": "else {\noffY = Math.max(limits[Constants.NUMBER_2], offY);",
                          "successors": []
                        }
                      ]
                    },
                    {
                      "id": 11,
                      "label": "let tmpX = offX - measureX;\nlet tmpY = offY - measureY;\nthis.offset = [tmpX, tmpY];\nthis.emitTouchEvent();\n}",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "onMoveEnd",
          "type": "function",
          "start_line": 426,
          "end_line": 445,
          "functions": [],
          "classes": [],
          "simplified_code": "  onMoveEnd(offsetX, offsetY): void {\n    if (this.isInAnimation || this.isExiting) {\n      return;\n    }\n    let scale = this.lastScale * this.scale;\n    Log.debug(TAG, 'onMoveEnd: scale is ' + scale + ' offsetY is ' + offsetY);\n    if (scale.toFixed(Constants.RESERVED_DIGITS) === this.defaultScale.toFixed(Constants.RESERVED_DIGITS) && offsetY > Constants.PULL_DOWN_THRESHOLD) {\n      this.emitPullDownToBackEvent();\n    } else if (scale.toFixed(Constants.RESERVED_DIGITS) === this.defaultScale.toFixed(Constants.RESERVED_DIGITS)) {\n      // The reset animation is triggered when the threshold is not reached\n      let scaleOption: Matrix4.ScaleOption = {\n        x: this.defaultScale,\n        y: this.defaultScale\n      };\n      this.startAnimation(Matrix4.identity().scale(scaleOption).copy() as Matrix4TransitWithMatrix4x4);\n      this.emitPullDownCancelEvent();\n    } else {\n      this.emitDirectionChange();\n    }\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "onMoveEnd(offsetX, offsetY): void {",
              "successors": [
                {
                  "id": 2,
                  "label": "if (this.isInAnimation || this.isExiting) {\nreturn;",
                  "successors": []
                },
                {
                  "id": 4,
                  "label": "let scale = this.lastScale * this.scale;\nLog.debug(TAG, 'onMoveEnd: scale is ' + scale + ' offsetY is ' + offsetY);",
                  "successors": [
                    {
                      "id": 6,
                      "label": "if (scale.toFixed(Constants.RESERVED_DIGITS) === this.defaultScale.toFixed(Constants.RESERVED_DIGITS) && offsetY > Constants.PULL_DOWN_THRESHOLD) {\nthis.emitPullDownToBackEvent();",
                      "successors": []
                    },
                    {
                      "id": 8,
                      "label": "else if (scale.toFixed(Constants.RESERVED_DIGITS) === this.defaultScale.toFixed(Constants.RESERVED_DIGITS)) {\nlet scaleOption: Matrix4.ScaleOption = { x: this.defaultScale, y: this.defaultScale };",
                      "successors": [
                        {
                          "id": 10,
                          "label": "this.startAnimation(Matrix4.identity().scale(scaleOption).copy() as Matrix4TransitWithMatrix4x4);\nthis.emitPullDownCancelEvent();",
                          "successors": []
                        }
                      ]
                    },
                    {
                      "id": 12,
                      "label": "else {\nthis.emitDirectionChange();",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "onScaleStart",
          "type": "function",
          "start_line": 447,
          "end_line": 457,
          "functions": [],
          "classes": [],
          "simplified_code": "  onScaleStart(scale: number, centerX: number, centerY: number): void {\n    Log.info(TAG, 'onScaleStart: ' + this.isInAnimation + ', ' + this.isExiting);\n    if (this.isInAnimation || this.isExiting) {\n      return;\n    }\n    this.scale = 1;\n    this.evaluateBounds();\n    // Adjust action bar status\n    this.broadCast.emit(Constants.HIDE_BARS, []);\n    this.center = this.evaluateCenter(centerX, centerY);\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "Log.info(TAG, 'onScaleStart: ' + this.isInAnimation + ', ' + this.isExiting);\nif (this.isInAnimation || this.isExiting) {",
              "successors": [
                {
                  "id": 3,
                  "label": "return;",
                  "successors": []
                },
                {
                  "id": 4,
                  "label": "}\nthis.scale = 1;\nthis.evaluateBounds();\n// Adjust action bar status\nthis.broadCast.emit(Constants.HIDE_BARS, []);\nthis.center = this.evaluateCenter(centerX, centerY);",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "evaluateCenter",
          "type": "function",
          "start_line": 466,
          "end_line": 503,
          "functions": [],
          "classes": [],
          "simplified_code": "  private evaluateCenter(centerX: number, centerY: number): number[] {\n    // Calculate the coordinates of the upper left corner of the control relative to\n    // the upper left corner of the current display\n    let scale = this.lastScale * this.scale;\n    let leftTop = this.evaluateCompBounds();\n\n    // Get the touch coordinates relative to the control\n    let cxRelativeToComp = MathUtils.clamp((centerX - leftTop[0])\n    / (this.componentWidth * scale), this.leftMost, 1 - this.leftMost);\n    let cyRelativeToComp = MathUtils.clamp((centerY - leftTop[1])\n    / (this.componentHeight * scale), this.topMost, 1 - this.topMost);\n\n    let imgDisplaySize: number[] = this.evaluateImgDisplaySize();\n    let imgDisplayWidth = imgDisplaySize[0];\n    let imgDisplayHeight = imgDisplaySize[1];\n\n    let imgDisplayBounds = this.evaluateImgDisplayBounds();\n    let imgLeftBound = imgDisplayBounds[0];\n    let imgTopBound = imgDisplayBounds[1];\n\n    // When the touch center point is outside the picture display area, take the midpoint\n    if (this.width / this.height > this.componentWidth / this.componentHeight) {\n      if (centerY < imgTopBound || centerY > imgTopBound + imgDisplayHeight) {\n        cyRelativeToComp = Constants.CENTER_DEFAULT;\n      }\n    } else {\n      if (centerX < imgLeftBound || centerX > imgLeftBound + imgDisplayWidth) {\n        cxRelativeToComp = Constants.CENTER_DEFAULT;\n      }\n    }\n\n    // Calculate the percentage of the center point of the touch\n    let center: number[] = [cxRelativeToComp, cyRelativeToComp];\n    Log.debug(TAG, 'evaluateCenter center: ' + center + ', ' + centerX + ',' + centerY +\n    ',size: ' + imgDisplaySize + ', bounds: ' + imgDisplayBounds + ', leftTop: ' + leftTop +\n    ',compSize: ' + this.componentWidth * scale + ',' + this.componentHeight * scale);\n    return center;\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "private evaluateCenter(centerX: number, centerY: number): number[] {\nlet scale = this.lastScale * this.scale;\nlet leftTop = this.evaluateCompBounds();",
              "successors": [
                {
                  "id": 3,
                  "label": "let cxRelativeToComp = MathUtils.clamp((centerX - leftTop[0]) / (this.componentWidth * scale), this.leftMost, 1 - this.leftMost);\nlet cyRelativeToComp = MathUtils.clamp((centerY - leftTop[1]) / (this.componentHeight * scale), this.topMost, 1 - this.topMost);\nlet imgDisplaySize: number[] = this.evaluateImgDisplaySize();\nlet imgDisplayWidth = imgDisplaySize[0];\nlet imgDisplayHeight = imgDisplaySize[1];",
                  "successors": [
                    {
                      "id": 5,
                      "label": "let imgDisplayBounds = this.evaluateImgDisplayBounds();\nlet imgLeftBound = imgDisplayBounds[0];\nlet imgTopBound = imgDisplayBounds[1];",
                      "successors": [
                        {
                          "id": 6,
                          "label": "if (this.width / this.height > this.componentWidth / this.componentHeight) {\nif (centerY < imgTopBound || centerY > imgTopBound + imgDisplayHeight) {",
                          "successors": [
                            {
                              "id": 8,
                              "label": "cyRelativeToComp = Constants.CENTER_DEFAULT;\nlet center: number[] = [cxRelativeToComp, cyRelativeToComp];\nLog.debug(TAG, 'evaluateCenter center: ' + center + ', ' + centerX + ',' + centerY + ',size: ' + imgDisplaySize + ', bounds: ' + imgDisplayBounds + ', leftTop: ' + leftTop + ',compSize: ' + this.componentWidth * scale + ',' + this.componentHeight * scale);\nreturn center;\n}",
                              "successors": []
                            }
                          ]
                        },
                        {
                          "id": 9,
                          "label": "} else {\nif (centerX < imgLeftBound || centerX > imgLeftBound + imgDisplayWidth) {",
                          "successors": [
                            {
                              "id": 8,
                              "label": "cxRelativeToComp = Constants.CENTER_DEFAULT;\nlet center: number[] = [cxRelativeToComp, cyRelativeToComp];\nLog.debug(TAG, 'evaluateCenter center: ' + center + ', ' + centerX + ',' + centerY + ',size: ' + imgDisplaySize + ', bounds: ' + imgDisplayBounds + ', leftTop: ' + leftTop + ',compSize: ' + this.componentWidth * scale + ',' + this.componentHeight * scale);\nreturn center;\n}",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "onScale",
          "type": "function",
          "start_line": 505,
          "end_line": 519,
          "functions": [],
          "classes": [],
          "simplified_code": "  onScale(scale: number): void {\n    Log.debug(TAG, 'onScale: ' + this.isInAnimation + ', ' + this.isExiting + ', scale: ' + scale);\n    if (this.isInAnimation || this.isExiting) {\n      return;\n    }\n    this.evaluateBounds();\n    this.scale = scale;\n    if (this.lastScale * scale <= Constants.COMPONENT_SCALE_FLOOR) {\n      this.scale = Constants.COMPONENT_SCALE_FLOOR / this.lastScale;\n    }\n    if (this.lastScale * scale >= this.maxScale * Constants.OVER_SCALE_EXTRA_FACTOR) {\n      this.scale = this.maxScale * Constants.OVER_SCALE_EXTRA_FACTOR / this.lastScale;\n    }\n    this.emitTouchEvent();\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "Log.debug(TAG, 'onScale: ' + this.isInAnimation + ', ' + this.isExiting + ', scale: ' + scale);",
              "successors": [
                {
                  "id": 2,
                  "label": "if (this.isInAnimation || this.isExiting) {\n    return;",
                  "successors": []
                },
                {
                  "id": 4,
                  "label": "this.evaluateBounds();\nthis.scale = scale;",
                  "successors": [
                    {
                      "id": 6,
                      "label": "if (this.lastScale * scale <= Constants.COMPONENT_SCALE_FLOOR) {\n    this.scale = Constants.COMPONENT_SCALE_FLOOR / this.lastScale;",
                      "successors": []
                    },
                    {
                      "id": 8,
                      "label": "if (this.lastScale * scale >= this.maxScale * Constants.OVER_SCALE_EXTRA_FACTOR) {\n    this.scale = this.maxScale * Constants.OVER_SCALE_EXTRA_FACTOR / this.lastScale;",
                      "successors": []
                    },
                    {
                      "id": 10,
                      "label": "this.emitTouchEvent();",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "onScaleEnd",
          "type": "function",
          "start_line": 521,
          "end_line": 545,
          "functions": [],
          "classes": [],
          "simplified_code": "  onScaleEnd(): void {\n    Log.info(TAG, 'onScaleEnd: ' + this.isInAnimation + ', ' + this.isExiting);\n    if (this.isInAnimation || this.isExiting) {\n      return;\n    }\n    this.evaluateBounds();\n    let scale = this.lastScale * this.scale;\n    if (Number(scale.toFixed(Constants.RESERVED_DIGITS)) >= Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS)) && scale <= this.maxScale) {\n      Log.info(TAG, 'does not need to do animation: ' + scale);\n      this.emitDirectionChange();\n      return;\n    }\n    let animationEndMatrix: Matrix4.Matrix4Transit = null;\n    if (Number(scale.toFixed(Constants.RESERVED_DIGITS)) <= Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) {\n      // Zoom out too small to trigger the restored animation\n      let scaleOption: Matrix4.ScaleOption = {\n        x: this.defaultScale,\n        y: this.defaultScale\n      };\n      animationEndMatrix = Matrix4.identity().scale(scaleOption).copy();\n    } else {\n      // Do the animation of retracting maxScale when zooming in\n      animationEndMatrix = this.evaluateAnimeMatrix(this.maxScale, this.center);\n    }\n    this.startAnimation(animationEndMatrix as Matrix4TransitWithMatrix4x4);",
          "blocks": [
            {
              "id": 1,
              "label": "Log.info(TAG, 'onScaleEnd: ' + this.isInAnimation + ', ' + this.isExiting);",
              "successors": [
                {
                  "id": 2,
                  "label": "if (this.isInAnimation || this.isExiting) {\nreturn;",
                  "successors": []
                },
                {
                  "id": 4,
                  "label": "this.evaluateBounds();\nlet scale = this.lastScale * this.scale;",
                  "successors": [
                    {
                      "id": 6,
                      "label": "if (Number(scale.toFixed(Constants.RESERVED_DIGITS)) >= Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS)) && scale <= this.maxScale) {\nLog.info(TAG, 'does not need to do animation: ' + scale);",
                      "successors": [
                        {
                          "id": 8,
                          "label": "this.emitDirectionChange();\nreturn;",
                          "successors": []
                        }
                      ]
                    },
                    {
                      "id": 10,
                      "label": "let animationEndMatrix: Matrix4.Matrix4Transit = null;",
                      "successors": [
                        {
                          "id": 11,
                          "label": "if (Number(scale.toFixed(Constants.RESERVED_DIGITS)) <= Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) {\n// Zoom out too small to trigger the restored animation\nlet scaleOption: Matrix4.ScaleOption = {\n  x: this.defaultScale,\n  y: this.defaultScale\n};\nanimationEndMatrix = Matrix4.identity().scale(scaleOption).copy();",
                          "successors": []
                        },
                        {
                          "id": 13,
                          "label": "// Do the animation of retracting maxScale when zooming in\nanimationEndMatrix = this.evaluateAnimeMatrix(this.maxScale, this.center);",
                          "successors": []
                        }
                      ]
                    },
                    {
                      "id": 14,
                      "label": "this.startAnimation(animationEndMatrix as Matrix4TransitWithMatrix4x4);",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "evaluateAnimeMatrix",
          "type": "function",
          "start_line": 548,
          "end_line": 585,
          "functions": [],
          "classes": [],
          "simplified_code": "  private evaluateAnimeMatrix(scale: number, center: number[]): Matrix4.Matrix4Transit {\n    let offset: number[] = [\n      this.lastOffset[0] + this.offset[0] + (center[0] - Constants.CENTER_DEFAULT) * this.componentWidth\n      * (this.defaultScale - scale / this.lastScale) * this.lastScale,\n      this.lastOffset[1] + this.offset[1] + (center[1] - Constants.CENTER_DEFAULT) * this.componentHeight\n      * (this.defaultScale - scale / this.lastScale) * this.lastScale\n    ];\n    if (Number(scale.toFixed(Constants.RESERVED_DIGITS)) > Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) {\n      let limits = this.evaluateOffsetRange(scale);\n      // The offset in the X direction is always limited for non shrinking scenes\n      offset[0] = MathUtils.clamp(offset[0], limits[0], limits[1]);\n      if (Number(scale.toFixed(Constants.RESERVED_DIGITS)) > Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) {\n        // Cannot drop down to return to the scene, limit y\n        offset[1] = MathUtils.clamp(offset[1], limits[Constants.NUMBER_2], limits[Constants.NUMBER_3]);\n      } else {\n        // You can pull down to return to the scene, and only limit y to drag upward,\n        // that is, limit the lower bound\n        offset[1] = Math.max(limits[Constants.NUMBER_2], offset[1]);\n      }\n    } else {\n      // When zooming in, adjust the zoom center to the display center point\n      offset = [0, 0];\n    }\n    let scaleOption: Matrix4.ScaleOption = {\n      x: scale,\n      y: scale,\n    };\n    let translateOption: Matrix4.TranslateOption = {\n      x: offset[0],\n      y: offset[1]\n    };\n    let animationEndMatrix = Matrix4.identity()\n      .copy()\n      .scale(scaleOption)\n      .translate(translateOption)\n      .copy();\n    Log.debug(TAG, 'evaluateAnimeMatrix scale:' + scale + ', center:' + center);\n    return animationEndMatrix;",
          "blocks": [
            {
              "id": 1,
              "label": "let offset: number[] = [this.lastOffset[0] + this.offset[0] + (center[0] - Constants.CENTER_DEFAULT) * this.componentWidth * (this.defaultScale - scale / this.lastScale) * this.lastScale, this.lastOffset[1] + this.offset[1] + (center[1] - Constants.CENTER_DEFAULT) * this.componentHeight * (this.defaultScale - scale / this.lastScale) * this.lastScale];",
              "successors": [
                {
                  "id": 2,
                  "label": "if (Number(scale.toFixed(Constants.RESERVED_DIGITS)) > Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) {\nlet limits = this.evaluateOffsetRange(scale); offset[0] = MathUtils.clamp(offset[0], limits[0], limits[1]);",
                  "successors": [
                    {
                      "id": 4,
                      "label": "if (Number(scale.toFixed(Constants.RESERVED_DIGITS)) > Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) {",
                      "successors": [
                        {
                          "id": 5,
                          "label": "offset[1] = MathUtils.clamp(offset[1], limits[Constants.NUMBER_2], limits[Constants.NUMBER_3]);",
                          "successors": []
                        },
                        {
                          "id": 6,
                          "label": "offset[1] = Math.max(limits[Constants.NUMBER_2], offset[1]);",
                          "successors": []
                        }
                      ]
                    }
                  ]
                },
                {
                  "id": 7,
                  "label": "offset = [0, 0];",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "onDoubleTap",
          "type": "function",
          "start_line": 596,
          "end_line": 628,
          "functions": [],
          "classes": [],
          "simplified_code": "  onDoubleTap(centerX: number, centerY: number): void {\n    if (this.isInAnimation || this.isExiting) {\n      Log.debug(TAG, 'onDoubleTap not avaliable: ' + this.isInAnimation + ', ' + this.isExiting);\n      return;\n    }\n    // Adjust action bar status\n    this.broadCast.emit(Constants.HIDE_BARS, []);\n    let matrix: Matrix4TransitWithMatrix4x4;\n    Log.debug(TAG, 'onDoubleTap lastScale: ' + this.lastScale + ', scale: ' + this.scale + ', defaultScale: ' + this.defaultScale);\n    if (Number(this.lastScale.toFixed(Constants.RESERVED_DIGITS)) * this.scale > Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS))) {\n      // Scale to original state when scale is greater than 1\n      let scaleOption: Matrix4.ScaleOption = {\n        x: this.defaultScale,\n        y: this.defaultScale\n      };\n      matrix = Matrix4.identity().scale(scaleOption).copy() as Matrix4TransitWithMatrix4x4;\n    } else {\n      // The zoom in status calculates the zoom in center according to the click position\n      let center = this.evaluateCenter(centerX, centerY);\n      // When the picture aspect ratio is less than the control aspect ratio,\n      // centerX is set to 0.5,\n      // whereas centerY is set to 0.5 to ensure that\n      // the short side is close to the side after double clicking and enlarging\n      if (this.width / this.height < this.componentWidth / this.componentHeight) {\n        center = [Constants.CENTER_DEFAULT, center[1]];\n      } else {\n        center = [center[0], Constants.CENTER_DEFAULT];\n      }\n      matrix = this.evaluateAnimeMatrix(this.doubleTapScale * this.defaultScale, center) as Matrix4TransitWithMatrix4x4;\n    }\n    Log.debug(TAG, 'onDoubleTap matrix: ' + matrix.matrix4x4);\n    this.startAnimation(matrix);\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "if (this.isInAnimation || this.isExiting)",
              "successors": [
                {
                  "id": 2,
                  "label": "Log.debug(TAG, 'onDoubleTap not avaliable: ' + this.isInAnimation + ', ' + this.isExiting);\nreturn;",
                  "successors": []
                },
                {
                  "id": 3,
                  "label": "// Adjust action bar status\nthis.broadCast.emit(Constants.HIDE_BARS, []);\nlet matrix: Matrix4TransitWithMatrix4x4;\nLog.debug(TAG, 'onDoubleTap lastScale: ' + this.lastScale + ', scale: ' + this.scale + ', defaultScale: ' + this.defaultScale);\nif (Number(this.lastScale.toFixed(Constants.RESERVED_DIGITS)) * this.scale > Number(this.defaultScale.toFixed(Constants.RESERVED_DIGITS)))",
                  "successors": [
                    {
                      "id": 5,
                      "label": "// Scale to original state when scale is greater than 1\nlet scaleOption: Matrix4.ScaleOption = {\n  x: this.defaultScale,\n  y: this.defaultScale\n};\nmatrix = Matrix4.identity().scale(scaleOption).copy() as Matrix4TransitWithMatrix4x4;\nLog.debug(TAG, 'onDoubleTap matrix: ' + matrix.matrix4x4);\nthis.startAnimation(matrix);",
                      "successors": []
                    },
                    {
                      "id": 6,
                      "label": "// The zoom in status calculates the zoom in center according to the click position\nlet center = this.evaluateCenter(centerX, centerY);\n// When the picture aspect ratio is less than the control aspect ratio,\n// centerX is set to 0.5,\n// whereas centerY is set to 0.5 to ensure that\n// the short side is close to the side after double clicking and enlarging\nif (this.width / this.height < this.componentWidth / this.componentHeight) {\n  center = [Constants.CENTER_DEFAULT, center[1]];\n} else {\n  center = [center[0], Constants.CENTER_DEFAULT];\n}\nmatrix = this.evaluateAnimeMatrix(this.doubleTapScale * this.defaultScale, center) as Matrix4TransitWithMatrix4x4;\nLog.debug(TAG, 'onDoubleTap matrix: ' + matrix.matrix4x4);\nthis.startAnimation(matrix);",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "reset",
          "type": "function",
          "start_line": 630,
          "end_line": 642,
          "functions": [],
          "classes": [],
          "simplified_code": "  reset(): void {\n    this.lastOffset = [0, 0];\n    this.offset = [0, 0];\n    this.lastScale = 1.0;\n    this.scale = 1;\n    this.hasReachLeft = true;\n    this.hasReachRight = true;\n    this.hasReachTop = true;\n    this.hasReachBottom = true;\n    this.isInAnimation = false;\n    this.isExiting = false;\n    this.emitDirectionChange();\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "reset(): void {\nthis.lastOffset = [0, 0];\nthis.offset = [0, 0];\nthis.lastScale = 1.0;\nthis.scale = 1;\nthis.hasReachLeft = true;\nthis.hasReachRight = true;\nthis.hasReachTop = true;\nthis.hasReachBottom = true;\nthis.isInAnimation = false;\nthis.isExiting = false;\nthis.emitDirectionChange();",
              "successors": []
            }
          ]
        },
        {
          "name": "onDisAppear",
          "type": "function",
          "start_line": 644,
          "end_line": 646,
          "functions": [],
          "classes": [],
          "simplified_code": "  onDisAppear(): void {\n    Log.info(TAG, 'onDisAppear');\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "onDisAppear(): void {\n    Log.info(TAG, 'onDisAppear');",
              "successors": []
            }
          ]
        },
        {
          "name": "startAnimation",
          "type": "function",
          "start_line": 648,
          "end_line": 656,
          "functions": [],
          "classes": [],
          "simplified_code": "  private startAnimation(animationEndMatrix: Matrix4TransitWithMatrix4x4): void {\n    this.isInAnimation = true;\n    let animationOption: AnimationOption = {\n      duration: Constants.OVER_SCALE_ANIME_DURATION,\n      curve: Curve.Ease\n    };\n    Log.debug(TAG, 'animationEndMatrix: ' + animationEndMatrix.matrix4x4);\n    this.broadCast.emit(Constants.ANIMATION_EVENT + this.item.uri + this.timeStamp, [animationOption, animationEndMatrix]);\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "private startAnimation(animationEndMatrix: Matrix4TransitWithMatrix4x4): void {\n    this.isInAnimation = true;",
              "successors": [
                {
                  "id": 3,
                  "label": "    let animationOption: AnimationOption = {\n      duration: Constants.OVER_SCALE_ANIME_DURATION,",
                  "successors": [
                    {
                      "id": 5,
                      "label": "      curve: Curve.Ease\n    };",
                      "successors": [
                        {
                          "id": 7,
                          "label": "    Log.debug(TAG, 'animationEndMatrix: ' + animationEndMatrix.matrix4x4);\n    this.broadCast.emit(Constants.ANIMATION_EVENT + this.item.uri + this.timeStamp, [animationOption, animationEndMatrix]);",
                          "successors": [
                            {
                              "id": 9,
                              "label": "}",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "onAnimationEnd",
          "type": "function",
          "start_line": 665,
          "end_line": 675,
          "functions": [],
          "classes": [],
          "simplified_code": "  onAnimationEnd(animationEndMatrix: Matrix4TransitWithMatrix4x4): void {\n    if (animationEndMatrix != null) {\n      Log.info(TAG, 'onAnimationEnd: ' + animationEndMatrix.matrix4x4);\n      this.lastScale = animationEndMatrix.matrix4x4[0];\n      this.scale = 1;\n      this.lastOffset = [animationEndMatrix.matrix4x4[Constants.NUMBER_12], animationEndMatrix.matrix4x4[Constants.NUMBER_13]];\n      this.offset = [0, 0];\n      this.evaluateBounds();\n      this.isInAnimation = false;\n      this.emitDirectionChange();\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "onAnimationEnd(animationEndMatrix: Matrix4TransitWithMatrix4x4): void {\nif (animationEndMatrix != null) {",
              "successors": [
                {
                  "id": 3,
                  "label": "Log.info(TAG, 'onAnimationEnd: ' + animationEndMatrix.matrix4x4);\nthis.lastScale = animationEndMatrix.matrix4x4[0];\nthis.scale = 1;\nthis.lastOffset = [animationEndMatrix.matrix4x4[Constants.NUMBER_12], animationEndMatrix.matrix4x4[Constants.NUMBER_13]];\nthis.offset = [0, 0];\nthis.evaluateBounds();\nthis.isInAnimation = false;\nthis.emitDirectionChange();",
                  "successors": []
                }
              ]
            }
          ]
        }
      ],
      "classes": [],
      "simplified_code": "export class EventPipeline {\n\n  // last offset\n  private lastOffset: number[] = [0, 0];\n\n  // offset\n  private offset: number[] = [0, 0];\n\n  // default scale\n  private defaultScale = 1.0;\n\n  // last scale\n  private lastScale = 1.0;\n\n  // scale\n  private scale = 1.0;\n\n  // the zoom center point is a percentage position relative to the control, not an absolute position\n  private center: number[] = [Constants.CENTER_DEFAULT, Constants.CENTER_DEFAULT];\n\n  // leftmost zoom Center，(1 - leftMost)is rightmost zoom Center\n  private leftMost = 0.0;\n\n  // top zoom center，(1 - topMost)is bottom zoom center\n  private topMost = 0.0;\n\n  // double tap scale\n  private doubleTapScale = 1.0;\n\n  // max scale\n  private maxScale = 1.0;\n\n  // has reached the far left\n  private hasReachLeft = true;\n\n  // has reached the far right\n  private hasReachRight = true;\n\n  // has reached the far top\n  private hasReachTop = true;\n\n  // has reached the far bottom\n  private hasReachBottom = true;\n\n  // Broadcast\n  private broadCast: Broadcast;\n\n  // item\n  private item: UserFileDataItem;\n\n  // timeStamp\n  private timeStamp: string;\n\n  // width\n  private width: number;\n\n  // height\n  private height: number;\n\n  // Large display control width\n  private componentWidth: number = vp2px(screenManager.getWinWidth());\n\n  // Large display control height\n  private componentHeight = vp2px(screenManager.getWinHeight());\n\n  // is now in animation\n  private isInAnimation = false;\n\n  // pull down to return flag to prevent multiple triggers\n  private isExiting = false;\n\n  private updateMatrix: Function;\n\n  }\n\n  }\n\n  }\n\n  }\n\n  }\n\n  }\n\n  }\n\n  }\n\n  }\n\n    return result;\n  }\n\n    return [imgDisplayWidth, imgDisplayHeight];\n  }\n\n    return [imgLeftBound, imgTopBound];\n  }\n\n  // Calculate picture display boundary\n  }\n\n  /**\n   * Calculate the upper and lower bounds of offset in X and Y directions under the current scale\n   *\n   * @param scale The display magnification of the current control, usually this.lastScale * this.scale\n   * @returns 0&1 X-direction offset lower & upper bound, 2&3 Y-direction offset lower & upper bound\n   */\n    return result;\n  }\n\n  }\n\n  }\n\n  }\n\n  /**\n   * Each callback returns the displacement relative to the start point of the gesture\n   *\n   * @param offsetX offsetX\n   * @param offsetY offsetY\n   */\n  }\n\n  }\n\n  }\n\n  /**\n   * Calculates the percentage position of the current zoom center relative to the control\n   *\n   * @param centerX The absolute position of the touch point on the screen\n   * @param centerY The absolute position of the touch point on the screen\n   * @returns The percentage position of the current zoom center relative to the control\n   */\n  }\n\n  }\n\n    this.startAnimation(animationEndMatrix as Matrix4TransitWithMatrix4x4);\n  }\n\n    return animationEndMatrix;\n  }\n\n  /**\n   * Double click to trigger zoom.\n   * If the current scale is less than or equal to 1, zoom to doubleTapScale;\n   * If the current scale is greater than 1, scale to 1;\n   *\n   * @param centerX the location of double click\n   * @param centerY the location of double click\n   */\n  }\n\n  }\n\n  }\n\n  }\n\n  /**\n   * At the end of the animation,\n   * refresh the current parameter values according to the end transformation matrix to ensure continuity and\n   * prevent jumping during the next gesture operation\n   *\n   * @param animationEndMatrix Transformation matrix at end\n   */\n    }\n  }\n}",
      "blocks": [
        {
          "id": 1,
          "label": "export class EventPipeline {\n// last offset\nprivate lastOffset: number[] = [0, 0];\n\n// offset\nprivate offset: number[] = [0, 0];\n\n// default scale\nprivate defaultScale = 1.0;\n\n// last scale\nprivate lastScale = 1.0;\n\n// scale\nprivate scale = 1.0;\n\n// the zoom center point is a percentage position relative to the control, not an absolute position\nprivate center: number[] = [Constants.CENTER_DEFAULT, Constants.CENTER_DEFAULT];\n\n// leftmost zoom Center，(1 - leftMost)is rightmost zoom Center\nprivate leftMost = 0.0;\n\n// top zoom center，(1 - topMost)is bottom zoom center\nprivate topMost = 0.0;\n\n// double tap scale\nprivate doubleTapScale = 1.0;\n\n// max scale\nprivate maxScale = 1.0;\n\n// has reached the far left\nprivate hasReachLeft = true;\n\n// has reached the far right\nprivate hasReachRight = true;\n\n// has reached the far top\nprivate hasReachTop = true;\n\n// has reached the far bottom\nprivate hasReachBottom = true;\n\n// Broadcast\nprivate broadCast: Broadcast;\n\n// item\nprivate item: UserFileDataItem;\n\n// timeStamp\nprivate timeStamp: string;\n\n// width\nprivate width: number;\n\n// height\nprivate height: number;\n\n// Large display control width\nprivate componentWidth: number = vp2px(screenManager.getWinWidth());\n\n// Large display control height\nprivate componentHeight = vp2px(screenManager.getWinHeight());\n\n// is now in animation\nprivate isInAnimation = false;\n\n// pull down to return flag to prevent multiple triggers\nprivate isExiting = false;\n\nprivate updateMatrix: Function;",
          "successors": []
        }
      ]
    }
  ],
  "simplified_code": "/*\n * Copyright (c) 2023 Shenzhen Kaihong Digital Industry Development Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Matrix4 from '@ohos.matrix4';\nimport { UserFileDataItem } from '../base/UserFileDataItem';\nimport { Log } from '../utils/Log';\nimport { Broadcast } from './Broadcast';\nimport { MathUtils } from '../utils/MathUtils';\nimport { Constants } from '../constants/BrowserConstants';\nimport { screenManager } from './ScreenManager';\nimport { MediaConstants } from '../constants/MediaConstants';\n\nconst TAG = 'EventPipeline'\n\nexport interface Matrix4TransitWithMatrix4x4 extends Matrix4.Matrix4Transit {\n  matrix4x4: number[];\n}\n\nexport interface AnimationOption {\n  duration: number,\n  curve: Curve\n}\n\n}",
  "blocks": [
    {
      "id": 1,
      "label": "import Matrix4 from '@ohos.matrix4';\nimport { UserFileDataItem } from '../base/UserFileDataItem';",
      "successors": [
        {
          "id": 3,
          "label": "import { Log } from '../utils/Log';\nimport { Broadcast } from './Broadcast';",
          "successors": [
            {
              "id": 5,
              "label": "import { MathUtils } from '../utils/MathUtils';\nimport { Constants } from '../constants/BrowserConstants';",
              "successors": [
                {
                  "id": 7,
                  "label": "import { screenManager } from './ScreenManager';\nimport { MediaConstants } from '../constants/MediaConstants';",
                  "successors": [
                    {
                      "id": 9,
                      "label": "const TAG = 'EventPipeline'\nexport interface Matrix4TransitWithMatrix4x4 extends Matrix4.Matrix4Transit {\n  matrix4x4: number[];\n}",
                      "successors": [
                        {
                          "id": 11,
                          "label": "export interface AnimationOption {\n  duration: number,\n  curve: Curve\n}",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    }
  ]
}