{
  "name": "example_script",
  "type": "CFG",
  "start_line": 1,
  "end_line": 1482,
  "functions": [
    {
      "name": "beforeEach",
      "type": "function",
      "start_line": 49,
      "end_line": 79,
      "functions": [],
      "classes": [],
      "simplified_code": "  beforeEach(waitForAsync(() => {\n    TestBed.configureTestingModule({\n      imports: [\n        MatTooltipModule,\n        OverlayModule,\n        BasicTooltipDemo,\n        ScrollableTooltipDemo,\n        OnPushTooltipDemo,\n        DynamicTooltipsDemo,\n        TooltipOnTextFields,\n        TooltipOnDraggableElement,\n        DataBoundAriaLabelTooltip,\n      ],\n      providers: [\n        {\n          provide: Directionality,\n          useFactory: () => {\n            return (dir = {value: 'ltr', change: new Subject()});\n          },\n        },\n      ],\n    });\n    inject(\n      [OverlayContainer, FocusMonitor, Platform],\n      (oc: OverlayContainer, fm: FocusMonitor, pl: Platform) => {\n        overlayContainerElement = oc.getContainerElement();\n        focusMonitor = fm;\n        platform = pl;\n      },\n    )();\n  }));",
      "blocks": [
        {
          "id": 1,
          "label": "beforeEach(waitForAsync(() => {\nTestBed.configureTestingModule({",
          "successors": [
            {
              "id": 3,
              "label": "imports: [\n        MatTooltipModule,\n        OverlayModule,\n        BasicTooltipDemo,\n        ScrollableTooltipDemo,\n        OnPushTooltipDemo,\n        DynamicTooltipsDemo,\n        TooltipOnTextFields,\n        TooltipOnDraggableElement,\n        DataBoundAriaLabelTooltip,\n      ],\nproviders: [\n        {\n          provide: Directionality,\n          useFactory: () => {",
              "successors": [
                {
                  "id": 5,
                  "label": "return (dir = {value: 'ltr', change: new Subject()});\n},\n        },\n      ],\n    });",
                  "successors": [
                    {
                      "id": 7,
                      "label": "inject(\n      [OverlayContainer, FocusMonitor, Platform],\n      (oc: OverlayContainer, fm: FocusMonitor, pl: Platform) => {\noverlayContainerElement = oc.getContainerElement();\n        focusMonitor = fm;\n        platform = pl;",
                      "successors": [
                        {
                          "id": 9,
                          "label": "},\n    )();\n  }));",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "it",
      "type": "function",
      "start_line": 93,
      "end_line": 120,
      "functions": [],
      "classes": [],
      "simplified_code": "    it('should show and hide the tooltip', fakeAsync(() => {\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.show();\n      tick(0); // Tick for the show delay (default is 0)\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      fixture.detectChanges();\n      // Wait until animation has finished\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      // Make sure tooltip is shown to the user and animation has finished.\n      const tooltipElement = overlayContainerElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;\n      expect(tooltipElement instanceof HTMLElement).toBe(true);\n      expect(tooltipElement.classList).toContain('mat-mdc-tooltip-show');\n      expect(overlayContainerElement.textContent).toContain(initialTooltipMessage);\n      // After hide is called, a timeout delay is created that will to hide the tooltip.\n      const tooltipDelay = 1000;\n      tooltipDirective.hide(tooltipDelay);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      // After the tooltip delay elapses, expect that the tooltip is not visible.\n      tick(tooltipDelay);\n      fixture.detectChanges();\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      // On animation complete, should expect that the tooltip has been detached.\n      finishCurrentTooltipAnimation(overlayContainerElement, false);\n      assertTooltipInstance(tooltipDirective, false);\n      flush();\n    }));",
      "blocks": [
        {
          "id": 1,
          "label": "it('should show and hide the tooltip', fakeAsync(() => {\nassertTooltipInstance(tooltipDirective, false);",
          "successors": [
            {
              "id": 3,
              "label": "tooltipDirective.show();\ntick(0); // Tick for the show delay (default is 0)",
              "successors": [
                {
                  "id": 5,
                  "label": "expect(tooltipDirective._isTooltipVisible()).toBe(true);\nfixture.detectChanges();",
                  "successors": [
                    {
                      "id": 7,
                      "label": "// Wait until animation has finished\nfinishCurrentTooltipAnimation(overlayContainerElement, true);\n// Make sure tooltip is shown to the user and animation has finished.\nconst tooltipElement = overlayContainerElement.querySelector(\n  '.mat-mdc-tooltip',\n) as HTMLElement;",
                      "successors": [
                        {
                          "id": 9,
                          "label": "expect(tooltipElement instanceof HTMLElement).toBe(true);\nexpect(tooltipElement.classList).toContain('mat-mdc-tooltip-show');",
                          "successors": [
                            {
                              "id": 11,
                              "label": "expect(overlayContainerElement.textContent).toContain(initialTooltipMessage);\n// After hide is called, a timeout delay is created that will to hide the tooltip.\nconst tooltipDelay = 1000;\ntooltipDirective.hide(tooltipDelay);",
                              "successors": [
                                {
                                  "id": 13,
                                  "label": "expect(tooltipDirective._isTooltipVisible()).toBe(true);\n// After the tooltip delay elapses, expect that the tooltip is not visible.\ntick(tooltipDelay);",
                                  "successors": [
                                    {
                                      "id": 15,
                                      "label": "fixture.detectChanges();\nexpect(tooltipDirective._isTooltipVisible()).toBe(false);",
                                      "successors": [
                                        {
                                          "id": 17,
                                          "label": "// On animation complete, should expect that the tooltip has been detached.\nfinishCurrentTooltipAnimation(overlayContainerElement, false);\nassertTooltipInstance(tooltipDirective, false);",
                                          "successors": [
                                            {
                                              "id": 19,
                                              "label": "flush();",
                                              "successors": []
                                            }
                                          ]
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "it",
      "type": "function",
      "start_line": 121,
      "end_line": 137,
      "functions": [],
      "classes": [],
      "simplified_code": "    it('should be able to re-open a tooltip if it was closed by detaching the overlay', fakeAsync(() => {\n      tooltipDirective.show();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      tooltipDirective._overlayRef!.detach();\n      tick(0);\n      fixture.detectChanges();\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.show();\n      tick(0);\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      flush();\n    }));",
      "blocks": [
        {
          "id": 1,
          "label": "it('should be able to re-open a tooltip if it was closed by detaching the overlay', fakeAsync(() => {\ntooltipDirective.show();",
          "successors": [
            {
              "id": 3,
              "label": "tick(0);\nexpect(tooltipDirective._isTooltipVisible()).toBe(true);",
              "successors": [
                {
                  "id": 5,
                  "label": "fixture.detectChanges();\nfinishCurrentTooltipAnimation(overlayContainerElement, true);",
                  "successors": [
                    {
                      "id": 7,
                      "label": "tooltipDirective._overlayRef!.detach();\ntick(0);",
                      "successors": [
                        {
                          "id": 9,
                          "label": "fixture.detectChanges();\nexpect(tooltipDirective._isTooltipVisible()).toBe(false);",
                          "successors": [
                            {
                              "id": 11,
                              "label": "assertTooltipInstance(tooltipDirective, false);\ntooltipDirective.show();",
                              "successors": [
                                {
                                  "id": 13,
                                  "label": "tick(0);\nfinishCurrentTooltipAnimation(overlayContainerElement, true);",
                                  "successors": [
                                    {
                                      "id": 15,
                                      "label": "expect(tooltipDirective._isTooltipVisible()).toBe(true);\nflush();",
                                      "successors": []
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "it",
      "type": "function",
      "start_line": 138,
      "end_line": 147,
      "functions": [],
      "classes": [],
      "simplified_code": "    it('should show with delay', fakeAsync(() => {\n      assertTooltipInstance(tooltipDirective, false);\n      const tooltipDelay = 1000;\n      tooltipDirective.show(tooltipDelay);\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      fixture.detectChanges();\n      expect(overlayContainerElement.textContent).toContain('');\n      tick(tooltipDelay);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      expect(overlayContainerElement.textContent).toContain(initialTooltipMessage);",
      "blocks": [
        {
          "id": 1,
          "label": "it('should show with delay', fakeAsync(() => {\n    assertTooltipInstance(tooltipDirective, false);",
          "successors": [
            {
              "id": 3,
              "label": "    const tooltipDelay = 1000;\n    tooltipDirective.show(tooltipDelay);",
              "successors": [
                {
                  "id": 5,
                  "label": "    expect(tooltipDirective._isTooltipVisible()).toBe(false);\n    fixture.detectChanges();",
                  "successors": [
                    {
                      "id": 7,
                      "label": "    expect(overlayContainerElement.textContent).toContain('');\n    tick(tooltipDelay);",
                      "successors": [
                        {
                          "id": 9,
                          "label": "    expect(tooltipDirective._isTooltipVisible()).toBe(true);\n    expect(overlayContainerElement.textContent).toContain(initialTooltipMessage);",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "it",
      "type": "function",
      "start_line": 149,
      "end_line": 176,
      "functions": [],
      "classes": [],
      "simplified_code": "    it('should be able to override the default show and hide delays', fakeAsync(() => {\n      TestBed.resetTestingModule().configureTestingModule({\n        imports: [MatTooltipModule, OverlayModule, BasicTooltipDemo],\n        providers: [\n          {\n            provide: MAT_TOOLTIP_DEFAULT_OPTIONS,\n            useValue: {showDelay: 1337, hideDelay: 7331},\n          },\n        ],\n      });\n      fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      tooltipDirective = fixture.debugElement\n        .query(By.css('button'))!\n        .injector.get<MatTooltip>(MatTooltip);\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick();\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      tick(1337);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      tooltipDirective.hide();\n      fixture.detectChanges();\n      tick();\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      tick(7331);\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      flush();",
      "blocks": [
        {
          "id": 1,
          "label": "it('should be able to override the default show and hide delays', fakeAsync(() => {\nTestBed.resetTestingModule().configureTestingModule({\n  imports: [MatTooltipModule, OverlayModule, BasicTooltipDemo],\n  providers: [\n    { provide: MAT_TOOLTIP_DEFAULT_OPTIONS, useValue: {showDelay: 1337, hideDelay: 7331} }\n  ]\n});",
          "successors": [
            {
              "id": 3,
              "label": "fixture = TestBed.createComponent(BasicTooltipDemo);\nfixture.detectChanges();\ntooltipDirective = fixture.debugElement.query(By.css('button'))!.injector.get<MatTooltip>(MatTooltip);",
              "successors": [
                {
                  "id": 5,
                  "label": "tooltipDirective.show();\nfixture.detectChanges();\ntick();\nexpect(tooltipDirective._isTooltipVisible()).toBe(false);",
                  "successors": [
                    {
                      "id": 7,
                      "label": "tick(1337);\nexpect(tooltipDirective._isTooltipVisible()).toBe(true);",
                      "successors": [
                        {
                          "id": 9,
                          "label": "tooltipDirective.hide();\nfixture.detectChanges();\ntick();\nexpect(tooltipDirective._isTooltipVisible()).toBe(true);",
                          "successors": [
                            {
                              "id": 11,
                              "label": "tick(7331);\nexpect(tooltipDirective._isTooltipVisible()).toBe(false);",
                              "successors": [
                                {
                                  "id": 13,
                                  "label": "flush();",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "it",
      "type": "function",
      "start_line": 178,
      "end_line": 200,
      "functions": [],
      "classes": [],
      "simplified_code": "    it('should be able to override the default position', fakeAsync(() => {\n      TestBed.resetTestingModule().configureTestingModule({\n        imports: [MatTooltipModule, OverlayModule],\n        declarations: [TooltipDemoWithoutPositionBinding],\n        providers: [\n          {\n            provide: MAT_TOOLTIP_DEFAULT_OPTIONS,\n            useValue: {position: 'right'},\n          },\n        ],\n      });\n      const newFixture = TestBed.createComponent(TooltipDemoWithoutPositionBinding);\n      newFixture.detectChanges();\n      tooltipDirective = newFixture.debugElement\n        .query(By.css('button'))!\n        .injector.get<MatTooltip>(MatTooltip);\n      tooltipDirective.show();\n      newFixture.detectChanges();\n      tick();\n      expect(tooltipDirective.position).toBe('right');\n      expect(tooltipDirective._getOverlayPosition().main.overlayX).toBe('start');\n      expect(tooltipDirective._getOverlayPosition().fallback.overlayX).toBe('end');\n    }));",
      "blocks": [
        {
          "id": 1,
          "label": "it('should be able to override the default position', fakeAsync(() => {\n  TestBed.resetTestingModule().configureTestingModule({\n    imports: [MatTooltipModule, OverlayModule],\n    declarations: [TooltipDemoWithoutPositionBinding],\n    providers: [\n      {\n        provide: MAT_TOOLTIP_DEFAULT_OPTIONS,\n        useValue: {position: 'right'},\n      },\n    ],\n  });",
          "successors": [
            {
              "id": 3,
              "label": "  const newFixture = TestBed.createComponent(TooltipDemoWithoutPositionBinding);\n  newFixture.detectChanges();\n  tooltipDirective = newFixture.debugElement\n    .query(By.css('button'))!\n    .injector.get<MatTooltip>(MatTooltip);\n  tooltipDirective.show();\n  newFixture.detectChanges();\n  tick();",
              "successors": [
                {
                  "id": 5,
                  "label": "  expect(tooltipDirective.position).toBe('right');\n  expect(tooltipDirective._getOverlayPosition().main.overlayX).toBe('start');",
                  "successors": [
                    {
                      "id": 7,
                      "label": "  expect(tooltipDirective._getOverlayPosition().fallback.overlayX).toBe('end');\n}));",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "it",
      "type": "function",
      "start_line": 201,
      "end_line": 224,
      "functions": [],
      "classes": [],
      "simplified_code": "    it('should be able to define a default (global) tooltip class', fakeAsync(() => {\n      TestBed.resetTestingModule().configureTestingModule({\n        declarations: [TooltipDemoWithoutTooltipClassBinding],\n        imports: [MatTooltipModule, OverlayModule],\n        providers: [\n          {\n            provide: MAT_TOOLTIP_DEFAULT_OPTIONS,\n            useValue: {tooltipClass: 'my-default-tooltip-class'},\n          },\n        ],\n      });\n      const fixture = TestBed.createComponent(TooltipDemoWithoutTooltipClassBinding);\n      fixture.detectChanges();\n      tooltipDirective = fixture.componentInstance.tooltip;\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick();\n      const overlayRef = tooltipDirective._overlayRef!;\n      const tooltipElement = overlayRef.overlayElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;\n      expect(tooltipDirective.tooltipClass).toBe('my-default-tooltip-class');\n      expect(tooltipElement.classList).toContain('my-default-tooltip-class');\n    }));",
      "blocks": [
        {
          "id": 1,
          "label": "it('should be able to define a default (global) tooltip class', fakeAsync(() => {\n    TestBed.resetTestingModule().configureTestingModule({",
          "successors": [
            {
              "id": 3,
              "label": "        declarations: [TooltipDemoWithoutTooltipClassBinding],\n        imports: [MatTooltipModule, OverlayModule],",
              "successors": [
                {
                  "id": 5,
                  "label": "        providers: [\n            {",
                  "successors": [
                    {
                      "id": 7,
                      "label": "                provide: MAT_TOOLTIP_DEFAULT_OPTIONS,\n                useValue: {tooltipClass: 'my-default-tooltip-class'},",
                      "successors": [
                        {
                          "id": 9,
                          "label": "            },\n        ],",
                          "successors": [
                            {
                              "id": 11,
                              "label": "    });\n    const fixture = TestBed.createComponent(TooltipDemoWithoutTooltipClassBinding);",
                              "successors": [
                                {
                                  "id": 13,
                                  "label": "    fixture.detectChanges();\n    tooltipDirective = fixture.componentInstance.tooltip;",
                                  "successors": [
                                    {
                                      "id": 15,
                                      "label": "    tooltipDirective.show();\n    fixture.detectChanges();",
                                      "successors": [
                                        {
                                          "id": 17,
                                          "label": "    tick();\n    const overlayRef = tooltipDirective._overlayRef!;",
                                          "successors": [
                                            {
                                              "id": 19,
                                              "label": "    const tooltipElement = overlayRef.overlayElement.querySelector('.mat-mdc-tooltip') as HTMLElement;\n    expect(tooltipDirective.tooltipClass).toBe('my-default-tooltip-class');",
                                              "successors": [
                                                {
                                                  "id": 21,
                                                  "label": "    expect(tooltipElement.classList).toContain('my-default-tooltip-class');\n}))",
                                                  "successors": []
                                                }
                                              ]
                                            }
                                          ]
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "it",
      "type": "function",
      "start_line": 225,
      "end_line": 249,
      "functions": [],
      "classes": [],
      "simplified_code": "    it('should be able to provide tooltip class over the custom default one', fakeAsync(() => {\n      TestBed.resetTestingModule().configureTestingModule({\n        declarations: [TooltipDemoWithTooltipClassBinding],\n        imports: [MatTooltipModule, OverlayModule],\n        providers: [\n          {\n            provide: MAT_TOOLTIP_DEFAULT_OPTIONS,\n            useValue: {tooltipClass: 'my-default-tooltip-class'},\n          },\n        ],\n      });\n      const fixture = TestBed.createComponent(TooltipDemoWithTooltipClassBinding);\n      fixture.detectChanges();\n      tooltipDirective = fixture.componentInstance.tooltip;\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick();\n      const overlayRef = tooltipDirective._overlayRef!;\n      const tooltipElement = overlayRef.overlayElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;\n      expect(tooltipDirective.tooltipClass).not.toBe('my-default-tooltip-class');\n      expect(tooltipElement.classList).not.toContain('my-default-tooltip-class');\n      expect(tooltipElement.classList).toContain('fixed-tooltip-class');\n    }));",
      "blocks": [
        {
          "id": 1,
          "label": "it('should be able to provide tooltip class over the custom default one', fakeAsync(() => {\nTestBed.resetTestingModule().configureTestingModule({\n        declarations: [TooltipDemoWithTooltipClassBinding],\n        imports: [MatTooltipModule, OverlayModule],\n        providers: [\n          {\n            provide: MAT_TOOLTIP_DEFAULT_OPTIONS,\n            useValue: {tooltipClass: 'my-default-tooltip-class'},\n          },\n        ],\n      });",
          "successors": [
            {
              "id": 3,
              "label": "const fixture = TestBed.createComponent(TooltipDemoWithTooltipClassBinding);\n      fixture.detectChanges();\n      tooltipDirective = fixture.componentInstance.tooltip;\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick();\nconst overlayRef = tooltipDirective._overlayRef!;\n      const tooltipElement = overlayRef.overlayElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;",
              "successors": [
                {
                  "id": 5,
                  "label": "expect(tooltipDirective.tooltipClass).not.toBe('my-default-tooltip-class');\n      expect(tooltipElement.classList).not.toContain('my-default-tooltip-class');\n      expect(tooltipElement.classList).toContain('fixed-tooltip-class');\n}))",
                  "successors": []
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "it",
      "type": "function",
      "start_line": 250,
      "end_line": 276,
      "functions": [],
      "classes": [],
      "simplified_code": "    it('should position on the bottom-left by default', fakeAsync(() => {\n      // We don't bind mouse events on mobile devices.\n      if (platform.IOS || platform.ANDROID) {\n        return;\n      }\n      TestBed.resetTestingModule().configureTestingModule({\n        imports: [MatTooltipModule, OverlayModule],\n        declarations: [WideTooltipDemo],\n      });\n      const wideFixture = TestBed.createComponent(WideTooltipDemo);\n      wideFixture.detectChanges();\n      tooltipDirective = wideFixture.debugElement\n        .query(By.css('button'))!\n        .injector.get<MatTooltip>(MatTooltip);\n      const button: HTMLButtonElement = wideFixture.nativeElement.querySelector('button');\n      const triggerRect = button.getBoundingClientRect();\n      dispatchMouseEvent(button, 'mouseenter', triggerRect.right - 100, triggerRect.top + 100);\n      wideFixture.detectChanges();\n      tick();\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      expect(tooltipDirective._overlayRef!.overlayElement.offsetLeft).toBeLessThan(\n        triggerRect.right - 250,\n      );\n      expect(tooltipDirective._overlayRef!.overlayElement.offsetTop).toBeGreaterThanOrEqual(\n        triggerRect.bottom,\n      );\n    }));",
      "blocks": [
        {
          "id": 1,
          "label": "it('should position on the bottom-left by default', fakeAsync(() => {",
          "successors": [
            {
              "id": 2,
              "label": "  if (platform.IOS || platform.ANDROID) {\n    return;",
              "successors": []
            },
            {
              "id": 4,
              "label": "  TestBed.resetTestingModule().configureTestingModule({\n    imports: [MatTooltipModule, OverlayModule],",
              "successors": [
                {
                  "id": 6,
                  "label": "    declarations: [WideTooltipDemo],\n  });",
                  "successors": [
                    {
                      "id": 8,
                      "label": "  const wideFixture = TestBed.createComponent(WideTooltipDemo);\n  wideFixture.detectChanges();",
                      "successors": [
                        {
                          "id": 10,
                          "label": "  tooltipDirective = wideFixture.debugElement.query(By.css('button'))!.injector.get<MatTooltip>(MatTooltip);\n  const button: HTMLButtonElement = wideFixture.nativeElement.querySelector('button');",
                          "successors": [
                            {
                              "id": 12,
                              "label": "  const triggerRect = button.getBoundingClientRect();\n  dispatchMouseEvent(button, 'mouseenter', triggerRect.right - 100, triggerRect.top + 100);",
                              "successors": [
                                {
                                  "id": 14,
                                  "label": "  wideFixture.detectChanges();\n  tick();",
                                  "successors": [
                                    {
                                      "id": 16,
                                      "label": "  expect(tooltipDirective._isTooltipVisible()).toBe(true);\n  expect(tooltipDirective._overlayRef!.overlayElement.offsetLeft).toBeLessThan(triggerRect.right - 250,);",
                                      "successors": [
                                        {
                                          "id": 18,
                                          "label": "  expect(tooltipDirective._overlayRef!.overlayElement.offsetTop).toBeGreaterThanOrEqual(triggerRect.bottom,);\n});",
                                          "successors": []
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "it",
      "type": "function",
      "start_line": 277,
      "end_line": 308,
      "functions": [],
      "classes": [],
      "simplified_code": "    it('should be able to override the default positionAtOrigin', async () => {\n      // We don't bind mouse events on mobile devices.\n      if (platform.IOS || platform.ANDROID) {\n        return;\n      }\n      TestBed.resetTestingModule().configureTestingModule({\n        imports: [MatTooltipModule, OverlayModule],\n        declarations: [WideTooltipDemo],\n        providers: [\n          {\n            provide: MAT_TOOLTIP_DEFAULT_OPTIONS,\n            useValue: {positionAtOrigin: true},\n          },\n        ],\n      });\n      const wideFixture = TestBed.createComponent(WideTooltipDemo);\n      wideFixture.detectChanges();\n      tooltipDirective = wideFixture.debugElement\n        .query(By.css('button'))!\n        .injector.get<MatTooltip>(MatTooltip);\n      const button: HTMLButtonElement = wideFixture.nativeElement.querySelector('button');\n      const triggerRect = button.getBoundingClientRect();\n      dispatchMouseEvent(button, 'mouseenter', triggerRect.right - 100, triggerRect.top + 100);\n      wideFixture.detectChanges();\n      await new Promise<void>(resolve => setTimeout(resolve));\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      const actualOffsetLeft = tooltipDirective._overlayRef!.overlayElement.offsetLeft;\n      const expectedOffsetLeft = triggerRect.right - 100 - 20;\n      expect(actualOffsetLeft).toBeLessThanOrEqual(expectedOffsetLeft + 1);\n      expect(actualOffsetLeft).toBeGreaterThanOrEqual(expectedOffsetLeft - 1);\n      expect(tooltipDirective._overlayRef!.overlayElement.offsetTop).toBe(triggerRect.top + 100);\n    });",
      "blocks": [
        {
          "id": 1,
          "label": "it('should be able to override the default positionAtOrigin', async () => {\nif (platform.IOS || platform.ANDROID) {\n  return;\n}",
          "successors": [
            {
              "id": 3,
              "label": "TestBed.resetTestingModule().configureTestingModule({\n  imports: [MatTooltipModule, OverlayModule],\n  declarations: [WideTooltipDemo],\n  providers: [\n    {\n      provide: MAT_TOOLTIP_DEFAULT_OPTIONS,\n      useValue: {positionAtOrigin: true},\n    },\n  ],\n});\nconst wideFixture = TestBed.createComponent(WideTooltipDemo);\nwideFixture.detectChanges();",
              "successors": [
                {
                  "id": 5,
                  "label": "tooltipDirective = wideFixture.debugElement\n  .query(By.css('button'))!\n  .injector.get<MatTooltip>(MatTooltip);\nconst button: HTMLButtonElement = wideFixture.nativeElement.querySelector('button');\nconst triggerRect = button.getBoundingClientRect();",
                  "successors": [
                    {
                      "id": 7,
                      "label": "dispatchMouseEvent(button, 'mouseenter', triggerRect.right - 100, triggerRect.top + 100);\nwideFixture.detectChanges();\nawait new Promise<void>(resolve => setTimeout(resolve));",
                      "successors": [
                        {
                          "id": 9,
                          "label": "expect(tooltipDirective._isTooltipVisible()).toBe(true);\nconst actualOffsetLeft = tooltipDirective._overlayRef!.overlayElement.offsetLeft;\nconst expectedOffsetLeft = triggerRect.right - 100 - 20;",
                          "successors": [
                            {
                              "id": 11,
                              "label": "expect(actualOffsetLeft).toBeLessThanOrEqual(expectedOffsetLeft + 1);\nexpect(actualOffsetLeft).toBeGreaterThanOrEqual(expectedOffsetLeft - 1);\nexpect(tooltipDirective._overlayRef!.overlayElement.offsetTop).toBe(triggerRect.top + 100);",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "id": 13,
              "label": "}",
              "successors": []
            }
          ]
        }
      ]
    },
    {
      "name": "it",
      "type": "function",
      "start_line": 309,
      "end_line": 331,
      "functions": [],
      "classes": [],
      "simplified_code": "    it('should be able to disable tooltip interactivity', fakeAsync(() => {\n      TestBed.resetTestingModule().configureTestingModule({\n        imports: [MatTooltipModule, OverlayModule, NoopAnimationsModule],\n        declarations: [TooltipDemoWithoutPositionBinding],\n        providers: [\n          {\n            provide: MAT_TOOLTIP_DEFAULT_OPTIONS,\n            useValue: {disableTooltipInteractivity: true},\n          },\n        ],\n      });\n      const newFixture = TestBed.createComponent(TooltipDemoWithoutPositionBinding);\n      newFixture.detectChanges();\n      tooltipDirective = newFixture.debugElement\n        .query(By.css('button'))!\n        .injector.get<MatTooltip>(MatTooltip);\n      tooltipDirective.show();\n      newFixture.detectChanges();\n      tick();\n      expect(tooltipDirective._overlayRef?.overlayElement.classList).toContain(\n        'mat-mdc-tooltip-panel-non-interactive',\n      );\n    }));",
      "blocks": [
        {
          "id": 1,
          "label": "it('should be able to disable tooltip interactivity', fakeAsync(() => {\n  TestBed.resetTestingModule().configureTestingModule({",
          "successors": [
            {
              "id": 3,
              "label": "    imports: [MatTooltipModule, OverlayModule, NoopAnimationsModule],\n    declarations: [TooltipDemoWithoutPositionBinding],",
              "successors": [
                {
                  "id": 5,
                  "label": "    providers: [\n      {",
                  "successors": [
                    {
                      "id": 7,
                      "label": "        provide: MAT_TOOLTIP_DEFAULT_OPTIONS,\n        useValue: {disableTooltipInteractivity: true},",
                      "successors": [
                        {
                          "id": 9,
                          "label": "      },\n    ],",
                          "successors": [
                            {
                              "id": 11,
                              "label": "  });\n  const newFixture = TestBed.createComponent(TooltipDemoWithoutPositionBinding);",
                              "successors": [
                                {
                                  "id": 13,
                                  "label": "  newFixture.detectChanges();\n  tooltipDirective = newFixture.debugElement",
                                  "successors": [
                                    {
                                      "id": 15,
                                      "label": "    .query(By.css('button'))!\n    .injector.get<MatTooltip>(MatTooltip);",
                                      "successors": [
                                        {
                                          "id": 17,
                                          "label": "  tooltipDirective.show();\n  newFixture.detectChanges();",
                                          "successors": [
                                            {
                                              "id": 19,
                                              "label": "  tick();\n  expect(tooltipDirective._overlayRef?.overlayElement.classList).toContain('mat-mdc-tooltip-panel-non-interactive',);",
                                              "successors": [
                                                {
                                                  "id": 21,
                                                  "label": "}))",
                                                  "successors": []
                                                }
                                              ]
                                            }
                                          ]
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "it",
      "type": "function",
      "start_line": 332,
      "end_line": 341,
      "functions": [],
      "classes": [],
      "simplified_code": "    it('should set a css class on the overlay panel element', fakeAsync(() => {\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick(0);\n      const overlayRef = tooltipDirective._overlayRef;\n      expect(!!overlayRef).toBeTruthy();\n      expect(overlayRef!.overlayElement.classList)\n        .withContext('Expected the overlay panel element to have the tooltip panel class set.')\n        .toContain('mat-mdc-tooltip-panel');\n    }));",
      "blocks": [
        {
          "id": 1,
          "label": "it('should set a css class on the overlay panel element', fakeAsync(() => {\n  tooltipDirective.show();\n  fixture.detectChanges();\n  tick(0);\n  const overlayRef = tooltipDirective._overlayRef;\n  expect(!!overlayRef).toBeTruthy();\n  expect(overlayRef!.overlayElement.classList)\n    .withContext('Expected the overlay panel element to have the tooltip panel class set.')\n    .toContain('mat-mdc-tooltip-panel');",
          "successors": [
            {
              "id": 3,
              "label": "}));",
              "successors": []
            }
          ]
        }
      ]
    },
    {
      "name": "it",
      "type": "function",
      "start_line": 342,
      "end_line": 357,
      "functions": [],
      "classes": [],
      "simplified_code": "    it('should not show if disabled', fakeAsync(() => {\n      // Test that disabling the tooltip will not set the tooltip visible\n      tooltipDirective.disabled = true;\n      fixture.changeDetectorRef.markForCheck();\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      // Test to make sure setting disabled to false will show the tooltip\n      // Sanity check to make sure everything was correct before (detectChanges, tick)\n      tooltipDirective.disabled = false;\n      fixture.changeDetectorRef.markForCheck();\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);",
      "blocks": [
        {
          "id": 1,
          "label": "it('should not show if disabled', fakeAsync(() => {\n  tooltipDirective.disabled = true;",
          "successors": [
            {
              "id": 3,
              "label": "  fixture.changeDetectorRef.markForCheck();\n  tooltipDirective.show();",
              "successors": [
                {
                  "id": 5,
                  "label": "  fixture.detectChanges();\n  tick(0);",
                  "successors": [
                    {
                      "id": 7,
                      "label": "  expect(tooltipDirective._isTooltipVisible()).toBe(false);\n  tooltipDirective.disabled = false;",
                      "successors": [
                        {
                          "id": 9,
                          "label": "  fixture.changeDetectorRef.markForCheck();\n  tooltipDirective.show();",
                          "successors": [
                            {
                              "id": 11,
                              "label": "  fixture.detectChanges();\n  tick(0);",
                              "successors": [
                                {
                                  "id": 13,
                                  "label": "  expect(tooltipDirective._isTooltipVisible()).toBe(true);",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "it",
      "type": "function",
      "start_line": 359,
      "end_line": 370,
      "functions": [],
      "classes": [],
      "simplified_code": "    it('should hide if disabled while visible', fakeAsync(() => {\n      // Display the tooltip with a timeout before hiding.\n      tooltipDirective.hideDelay = 1000;\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      // Set tooltip to be disabled and verify that the tooltip hides.\n      tooltipDirective.disabled = true;\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n    }));",
      "blocks": [
        {
          "id": 1,
          "label": "it('should hide if disabled while visible', fakeAsync(() => {\n// Display the tooltip with a timeout before hiding.",
          "successors": [
            {
              "id": 3,
              "label": "tooltipDirective.hideDelay = 1000;\ntooltipDirective.show();",
              "successors": [
                {
                  "id": 5,
                  "label": "fixture.detectChanges();\ntick(0);",
                  "successors": [
                    {
                      "id": 7,
                      "label": "expect(tooltipDirective._isTooltipVisible()).toBe(true);\n// Set tooltip to be disabled and verify that the tooltip hides.",
                      "successors": [
                        {
                          "id": 9,
                          "label": "tooltipDirective.disabled = true;\ntick(0);",
                          "successors": [
                            {
                              "id": 11,
                              "label": "expect(tooltipDirective._isTooltipVisible()).toBe(false);\n}))",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "it",
      "type": "function",
      "start_line": 371,
      "end_line": 381,
      "functions": [],
      "classes": [],
      "simplified_code": "    it('should hide if the message is cleared while the tooltip is open', fakeAsync(() => {\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      fixture.componentInstance.message = '';\n      fixture.changeDetectorRef.markForCheck();\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n    }));",
      "blocks": [
        {
          "id": 1,
          "label": "it('should hide if the message is cleared while the tooltip is open', fakeAsync(() =>\n    tooltipDirective.show();\n    fixture.detectChanges();\n    tick(0);\n    expect(tooltipDirective._isTooltipVisible()).toBe(true);\n    fixture.componentInstance.message = '';\n    fixture.changeDetectorRef.markForCheck();\n    fixture.detectChanges();\n    tick(0);\n    expect(tooltipDirective._isTooltipVisible()).toBe(false);",
          "successors": [
            {
              "id": 3,
              "label": "}));",
              "successors": []
            }
          ]
        }
      ]
    },
    {
      "name": "it",
      "type": "function",
      "start_line": 382,
      "end_line": 393,
      "functions": [],
      "classes": [],
      "simplified_code": "    it('should not show if hide is called before delay finishes', waitForAsync(() => {\n      assertTooltipInstance(tooltipDirective, false);\n      const tooltipDelay = 1000;\n      tooltipDirective.show(tooltipDelay);\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      fixture.detectChanges();\n      expect(overlayContainerElement.textContent).toContain('');\n      tooltipDirective.hide();\n      fixture.whenStable().then(() => {\n        expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      });\n    }));",
      "blocks": [
        {
          "id": 1,
          "label": "it('should not show if hide is called before delay finishes', waitForAsync(() => {\n  assertTooltipInstance(tooltipDirective, false);\n  const tooltipDelay = 1000;\n  tooltipDirective.show(tooltipDelay);\n  expect(tooltipDirective._isTooltipVisible()).toBe(false);\n  fixture.detectChanges();\n  expect(overlayContainerElement.textContent).toContain('');\n  tooltipDirective.hide();",
          "successors": [
            {
              "id": 3,
              "label": "  fixture.whenStable().then(() => {\n    expect(tooltipDirective._isTooltipVisible()).toBe(false);",
              "successors": []
            }
          ]
        }
      ]
    },
    {
      "name": "it",
      "type": "function",
      "start_line": 394,
      "end_line": 412,
      "functions": [],
      "classes": [],
      "simplified_code": "    it('should not show tooltip if message is not present or empty', () => {\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.message = undefined;\n      fixture.detectChanges();\n      tooltipDirective.show();\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.message = null;\n      fixture.detectChanges();\n      tooltipDirective.show();\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.message = '';\n      fixture.detectChanges();\n      tooltipDirective.show();\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.message = '   ';\n      fixture.detectChanges();\n      tooltipDirective.show();\n      assertTooltipInstance(tooltipDirective, false);\n    });",
      "blocks": [
        {
          "id": 1,
          "label": "it('should not show tooltip if message is not present or empty', () => {\nassertTooltipInstance(tooltipDirective, false);",
          "successors": [
            {
              "id": 3,
              "label": "tooltipDirective.message = undefined;\nfixture.detectChanges();",
              "successors": [
                {
                  "id": 5,
                  "label": "tooltipDirective.show();\nassertTooltipInstance(tooltipDirective, false);",
                  "successors": [
                    {
                      "id": 7,
                      "label": "tooltipDirective.message = null;\nfixture.detectChanges();",
                      "successors": [
                        {
                          "id": 9,
                          "label": "tooltipDirective.show();\nassertTooltipInstance(tooltipDirective, false);",
                          "successors": [
                            {
                              "id": 11,
                              "label": "tooltipDirective.message = '';\nfixture.detectChanges();",
                              "successors": [
                                {
                                  "id": 13,
                                  "label": "tooltipDirective.show();\nassertTooltipInstance(tooltipDirective, false);",
                                  "successors": [
                                    {
                                      "id": 15,
                                      "label": "tooltipDirective.message = '   ';\nfixture.detectChanges();",
                                      "successors": [
                                        {
                                          "id": 17,
                                          "label": "tooltipDirective.show();\nassertTooltipInstance(tooltipDirective, false);",
                                          "successors": [
                                            {
                                              "id": 19,
                                              "label": "});",
                                              "successors": []
                                            }
                                          ]
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "it",
      "type": "function",
      "start_line": 413,
      "end_line": 425,
      "functions": [],
      "classes": [],
      "simplified_code": "    it('should not follow through with hide if show is called after', fakeAsync(() => {\n      tooltipDirective.show();\n      tick(0); // Tick for the show delay (default is 0)\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      // After hide called, a timeout delay is created that will to hide the tooltip.\n      const tooltipDelay = 1000;\n      tooltipDirective.hide(tooltipDelay);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      // Before delay time has passed, call show which should cancel intent to hide tooltip.\n      tooltipDirective.show();\n      tick(tooltipDelay);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n    }));",
      "blocks": [
        {
          "id": 1,
          "label": "it('should not follow through with hide if show is called after', fakeAsync(() => {\ntooltipDirective.show();",
          "successors": [
            {
              "id": 3,
              "label": "tick(0);\nexpect(tooltipDirective._isTooltipVisible()).toBe(true);",
              "successors": [
                {
                  "id": 5,
                  "label": "const tooltipDelay = 1000;\ntooltipDirective.hide(tooltipDelay);",
                  "successors": [
                    {
                      "id": 7,
                      "label": "expect(tooltipDirective._isTooltipVisible()).toBe(true);\ntooltipDirective.show();",
                      "successors": [
                        {
                          "id": 9,
                          "label": "tick(tooltipDelay);\nexpect(tooltipDirective._isTooltipVisible()).toBe(true);",
                          "successors": [
                            {
                              "id": 11,
                              "label": "}))",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "it",
      "type": "function",
      "start_line": 426,
      "end_line": 437,
      "functions": [],
      "classes": [],
      "simplified_code": "    it('should be able to update the tooltip position while open', fakeAsync(() => {\n      tooltipDirective.position = 'below';\n      tooltipDirective.show();\n      tick();\n      assertTooltipInstance(tooltipDirective, true);\n      spyOn(tooltipDirective._overlayRef!, 'updatePosition').and.callThrough();\n      tooltipDirective.position = 'above';\n      fixture.detectChanges();\n      tick();\n      assertTooltipInstance(tooltipDirective, true);\n      expect(tooltipDirective._overlayRef!.updatePosition).toHaveBeenCalled();\n    }));",
      "blocks": [
        {
          "id": 1,
          "label": "it('should be able to update the tooltip position while open', fakeAsync(() => {\ntooltipDirective.position = 'below';\ntooltipDirective.show();",
          "successors": [
            {
              "id": 3,
              "label": "tick();\nassertTooltipInstance(tooltipDirective, true);",
              "successors": [
                {
                  "id": 5,
                  "label": "spyOn(tooltipDirective._overlayRef!, 'updatePosition').and.callThrough();\ntooltipDirective.position = 'above';",
                  "successors": [
                    {
                      "id": 7,
                      "label": "fixture.detectChanges();\ntick();",
                      "successors": [
                        {
                          "id": 9,
                          "label": "assertTooltipInstance(tooltipDirective, true);\nexpect(tooltipDirective._overlayRef!.updatePosition).toHaveBeenCalled();",
                          "successors": [
                            {
                              "id": 11,
                              "label": "}));",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "it",
      "type": "function",
      "start_line": 438,
      "end_line": 447,
      "functions": [],
      "classes": [],
      "simplified_code": "    it('should update the tooltip position when the directionality changes', fakeAsync(() => {\n      tooltipDirective.position = 'right';\n      tooltipDirective.show();\n      tick();\n      assertTooltipInstance(tooltipDirective, true);\n      const spy = spyOn(tooltipDirective as any, '_updatePosition').and.callThrough();\n      dir.change.next('rtl');\n      assertTooltipInstance(tooltipDirective, true);\n      expect(spy).toHaveBeenCalled();\n    }));",
      "blocks": [
        {
          "id": 1,
          "label": "it('should update the tooltip position when the directionality changes', fakeAsync(() => {\ntooltipDirective.position = 'right';\ntooltipDirective.show();\ntick();\nassertTooltipInstance(tooltipDirective, true);\nconst spy = spyOn(tooltipDirective as any, '_updatePosition').and.callThrough();\ndir.change.next('rtl');\nassertTooltipInstance(tooltipDirective, true);\nexpect(spy).toHaveBeenCalled();",
          "successors": [
            {
              "id": 3,
              "label": "}));",
              "successors": []
            }
          ]
        }
      ]
    },
    {
      "name": "it",
      "type": "function",
      "start_line": 448,
      "end_line": 462,
      "functions": [],
      "classes": [],
      "simplified_code": "    it('should not throw when updating the position for a closed tooltip', fakeAsync(() => {\n      tooltipDirective.position = 'left';\n      tooltipDirective.show(0);\n      fixture.detectChanges();\n      tick();\n      tooltipDirective.hide(0);\n      fixture.detectChanges();\n      tick();\n      finishCurrentTooltipAnimation(overlayContainerElement, false);\n      expect(() => {\n        tooltipDirective.position = 'right';\n        fixture.detectChanges();\n        tick();\n      }).not.toThrow();\n    }));",
      "blocks": [
        {
          "id": 1,
          "label": "it('should not throw when updating the position for a closed tooltip', fakeAsync(() => {\ntooltipDirective.position = 'left';\ntooltipDirective.show(0);\nfixture.detectChanges();\ntick();\ntooltipDirective.hide(0);\nfixture.detectChanges();\ntick();\nfinishCurrentTooltipAnimation(overlayContainerElement, false);",
          "successors": [
            {
              "id": 3,
              "label": "expect(() => {\ntooltipDirective.position = 'right';\nfixture.detectChanges();\ntick();",
              "successors": [
                {
                  "id": 5,
                  "label": "}).not.toThrow();\n}));",
                  "successors": []
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "it",
      "type": "function",
      "start_line": 463,
      "end_line": 474,
      "functions": [],
      "classes": [],
      "simplified_code": "    it('should be able to modify the tooltip message', fakeAsync(() => {\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.show();\n      tick(0); // Tick for the show delay (default is 0)\n      expect(tooltipDirective._tooltipInstance!.isVisible()).toBe(true);\n      fixture.detectChanges();\n      expect(overlayContainerElement.textContent).toContain(initialTooltipMessage);\n      const newMessage = 'new tooltip message';\n      tooltipDirective.message = newMessage;\n      fixture.detectChanges();\n      expect(overlayContainerElement.textContent).toContain(newMessage);\n    }));",
      "blocks": [
        {
          "id": 1,
          "label": "it('should be able to modify the tooltip message', fakeAsync(() => {\n    assertTooltipInstance(tooltipDirective, false);",
          "successors": [
            {
              "id": 3,
              "label": "    tooltipDirective.show();\n    tick(0);",
              "successors": [
                {
                  "id": 5,
                  "label": "    expect(tooltipDirective._tooltipInstance!.isVisible()).toBe(true);\n    fixture.detectChanges();",
                  "successors": [
                    {
                      "id": 7,
                      "label": "    expect(overlayContainerElement.textContent).toContain(initialTooltipMessage);\n    const newMessage = 'new tooltip message';",
                      "successors": [
                        {
                          "id": 9,
                          "label": "    tooltipDirective.message = newMessage;\n    fixture.detectChanges();",
                          "successors": [
                            {
                              "id": 11,
                              "label": "    expect(overlayContainerElement.textContent).toContain(newMessage);\n}))",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "it",
      "type": "function",
      "start_line": 475,
      "end_line": 502,
      "functions": [],
      "classes": [],
      "simplified_code": "    it('should allow extra classes to be set on the tooltip', fakeAsync(() => {\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.show();\n      tick(0); // Tick for the show delay (default is 0)\n      fixture.detectChanges();\n      // Make sure classes aren't prematurely added\n      let tooltipElement = overlayContainerElement.querySelector('.mat-mdc-tooltip') as HTMLElement;\n      expect(tooltipElement.classList).not.toContain(\n        'custom-one',\n        'Expected to not have the class before enabling matTooltipClass',\n      );\n      expect(tooltipElement.classList).not.toContain(\n        'custom-two',\n        'Expected to not have the class before enabling matTooltipClass',\n      );\n      // Enable the classes via ngClass syntax\n      fixture.componentInstance.showTooltipClass = true;\n      fixture.changeDetectorRef.markForCheck();\n      fixture.detectChanges();\n      // Make sure classes are correctly added\n      tooltipElement = overlayContainerElement.querySelector('.mat-mdc-tooltip') as HTMLElement;\n      expect(tooltipElement.classList)\n        .withContext('Expected to have the class after enabling matTooltipClass')\n        .toContain('custom-one');\n      expect(tooltipElement.classList)\n        .withContext('Expected to have the class after enabling matTooltipClass')\n        .toContain('custom-two');\n    }));",
      "blocks": [
        {
          "id": 1,
          "label": "it('should allow extra classes to be set on the tooltip', fakeAsync(() => {\n    assertTooltipInstance(tooltipDirective, false);",
          "successors": [
            {
              "id": 3,
              "label": "    tooltipDirective.show();\n    tick(0);",
              "successors": [
                {
                  "id": 5,
                  "label": "    fixture.detectChanges();\n    let tooltipElement = overlayContainerElement.querySelector('.mat-mdc-tooltip') as HTMLElement;",
                  "successors": [
                    {
                      "id": 7,
                      "label": "    expect(tooltipElement.classList).not.toContain('custom-one', 'Expected to not have the class before enabling matTooltipClass');\n    expect(tooltipElement.classList).not.toContain('custom-two', 'Expected to not have the class before enabling matTooltipClass');",
                      "successors": [
                        {
                          "id": 9,
                          "label": "    fixture.componentInstance.showTooltipClass = true;\n    fixture.changeDetectorRef.markForCheck();",
                          "successors": [
                            {
                              "id": 11,
                              "label": "    fixture.detectChanges();\n    tooltipElement = overlayContainerElement.querySelector('.mat-mdc-tooltip') as HTMLElement;",
                              "successors": [
                                {
                                  "id": 13,
                                  "label": "    expect(tooltipElement.classList).withContext('Expected to have the class after enabling matTooltipClass').toContain('custom-one');\n    expect(tooltipElement.classList).withContext('Expected to have the class after enabling matTooltipClass').toContain('custom-two');",
                                  "successors": [
                                    {
                                      "id": 15,
                                      "label": "}));",
                                      "successors": []
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "it",
      "type": "function",
      "start_line": 503,
      "end_line": 511,
      "functions": [],
      "classes": [],
      "simplified_code": "    it('should be removed after parent destroyed', fakeAsync(() => {\n      tooltipDirective.show();\n      tick(0); // Tick for the show delay (default is 0)\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      fixture.destroy();\n      expect(overlayContainerElement.childNodes.length).toBe(0);\n      expect(overlayContainerElement.textContent).toBe('');\n      flush();\n    }));",
      "blocks": [
        {
          "id": 1,
          "label": "it('should be removed after parent destroyed', fakeAsync(() => {\n  tooltipDirective.show();",
          "successors": [
            {
              "id": 3,
              "label": "  tick(0); // Tick for the show delay (default is 0)\n  expect(tooltipDirective._isTooltipVisible()).toBe(true);",
              "successors": [
                {
                  "id": 5,
                  "label": "  fixture.destroy();\n  expect(overlayContainerElement.childNodes.length).toBe(0);",
                  "successors": [
                    {
                      "id": 7,
                      "label": "  expect(overlayContainerElement.textContent).toBe('');\n  flush();",
                      "successors": [
                        {
                          "id": 9,
                          "label": "}));",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "it",
      "type": "function",
      "start_line": 512,
      "end_line": 523,
      "functions": [],
      "classes": [],
      "simplified_code": "    it('should have an aria-describedby element with the tooltip message', fakeAsync(() => {\n      const dynamicTooltipsDemoFixture = TestBed.createComponent(DynamicTooltipsDemo);\n      const dynamicTooltipsComponent = dynamicTooltipsDemoFixture.componentInstance;\n      dynamicTooltipsComponent.tooltips = ['Tooltip One', 'Tooltip Two'];\n      dynamicTooltipsDemoFixture.detectChanges();\n      tick();\n      const buttons = dynamicTooltipsDemoFixture.nativeElement.querySelectorAll('button');\n      const firstButtonAria = buttons[0].getAttribute('aria-describedby');\n      expect(document.querySelector(`#${firstButtonAria}`)!.textContent).toBe('Tooltip One');\n      const secondButtonAria = buttons[1].getAttribute('aria-describedby');\n      expect(document.querySelector(`#${secondButtonAria}`)!.textContent).toBe('Tooltip Two');\n    }));",
      "blocks": [
        {
          "id": 1,
          "label": "it('should have an aria-describedby element with the tooltip message', fakeAsync(() => {\n    const dynamicTooltipsDemoFixture = TestBed.createComponent(DynamicTooltipsDemo);",
          "successors": [
            {
              "id": 3,
              "label": "    const dynamicTooltipsComponent = dynamicTooltipsDemoFixture.componentInstance;\n    dynamicTooltipsComponent.tooltips = ['Tooltip One', 'Tooltip Two'];",
              "successors": [
                {
                  "id": 5,
                  "label": "    dynamicTooltipsDemoFixture.detectChanges();\n    tick();",
                  "successors": [
                    {
                      "id": 7,
                      "label": "    const buttons = dynamicTooltipsDemoFixture.nativeElement.querySelectorAll('button');\n    const firstButtonAria = buttons[0].getAttribute('aria-describedby');",
                      "successors": [
                        {
                          "id": 9,
                          "label": "    expect(document.querySelector(`#${firstButtonAria}`)!.textContent).toBe('Tooltip One');\n    const secondButtonAria = buttons[1].getAttribute('aria-describedby');",
                          "successors": [
                            {
                              "id": 11,
                              "label": "    expect(document.querySelector(`#${secondButtonAria}`)!.textContent).toBe('Tooltip Two');\n  }));",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "it",
      "type": "function",
      "start_line": 524,
      "end_line": 530,
      "functions": [],
      "classes": [],
      "simplified_code": "    it('should not add an ARIA description for elements that have the same text as a data-bound aria-label', fakeAsync(() => {\n      const ariaLabelFixture = TestBed.createComponent(DataBoundAriaLabelTooltip);\n      ariaLabelFixture.detectChanges();\n      tick();\n      const button = ariaLabelFixture.nativeElement.querySelector('button');\n      expect(button.getAttribute('aria-describedby')).toBeFalsy();\n    }));",
      "blocks": [
        {
          "id": 1,
          "label": "it('should not add an ARIA description for elements that have the same text as a data-bound aria-label', fakeAsync(() => {\nconst ariaLabelFixture = TestBed.createComponent(DataBoundAriaLabelTooltip);",
          "successors": [
            {
              "id": 3,
              "label": "ariaLabelFixture.detectChanges();\ntick();",
              "successors": [
                {
                  "id": 5,
                  "label": "const button = ariaLabelFixture.nativeElement.querySelector('button');\nexpect(button.getAttribute('aria-describedby')).toBeFalsy();",
                  "successors": [
                    {
                      "id": 7,
                      "label": "}));",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "it",
      "type": "function",
      "start_line": 531,
      "end_line": 542,
      "functions": [],
      "classes": [],
      "simplified_code": "    it('should toggle aria-describedby depending on whether the tooltip is disabled', fakeAsync(() => {\n      expect(buttonElement.getAttribute('aria-describedby')).toBeTruthy();\n      fixture.componentInstance.tooltipDisabled = true;\n      fixture.changeDetectorRef.markForCheck();\n      fixture.detectChanges();\n      tick();\n      expect(buttonElement.hasAttribute('aria-describedby')).toBe(false);\n      fixture.componentInstance.tooltipDisabled = false;\n      fixture.changeDetectorRef.markForCheck();\n      fixture.detectChanges();\n      tick();\n      expect(buttonElement.getAttribute('aria-describedby')).toBeTruthy();",
      "blocks": [
        {
          "id": 1,
          "label": "it('should toggle aria-describedby depending on whether the tooltip is disabled', fakeAsync(() => {\nexpect(buttonElement.getAttribute('aria-describedby')).toBeTruthy();",
          "successors": [
            {
              "id": 3,
              "label": "fixture.componentInstance.tooltipDisabled = true;\nfixture.changeDetectorRef.markForCheck();",
              "successors": [
                {
                  "id": 5,
                  "label": "fixture.detectChanges();\ntick();",
                  "successors": [
                    {
                      "id": 7,
                      "label": "expect(buttonElement.hasAttribute('aria-describedby')).toBe(false);\nfixture.componentInstance.tooltipDisabled = false;",
                      "successors": [
                        {
                          "id": 9,
                          "label": "fixture.changeDetectorRef.markForCheck();\nfixture.detectChanges();",
                          "successors": [
                            {
                              "id": 11,
                              "label": "tick();\nexpect(buttonElement.getAttribute('aria-describedby')).toBeTruthy();",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "it",
      "type": "function",
      "start_line": 544,
      "end_line": 554,
      "functions": [],
      "classes": [],
      "simplified_code": "    it('should not try to dispose the tooltip when destroyed and done hiding', fakeAsync(() => {\n      tooltipDirective.show();\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      const tooltipDelay = 1000;\n      tooltipDirective.hide();\n      tick(tooltipDelay); // Change the tooltip state to hidden and trigger animation start\n      fixture.componentInstance.showButton = false;\n      fixture.changeDetectorRef.markForCheck();\n      fixture.detectChanges();\n    }));",
      "blocks": [
        {
          "id": 1,
          "label": "it('should not try to dispose the tooltip when destroyed and done hiding', fakeAsync(() => {\n  tooltipDirective.show();\n  fixture.detectChanges();\n  finishCurrentTooltipAnimation(overlayContainerElement, true);\n  const tooltipDelay = 1000;\n  tooltipDirective.hide();\n  tick(tooltipDelay);",
          "successors": [
            {
              "id": 3,
              "label": "  fixture.componentInstance.showButton = false;\n  fixture.changeDetectorRef.markForCheck();\n  fixture.detectChanges();",
              "successors": []
            }
          ]
        }
      ]
    },
    {
      "name": "it",
      "type": "function",
      "start_line": 555,
      "end_line": 568,
      "functions": [],
      "classes": [],
      "simplified_code": "    it('should complete the afterHidden stream when tooltip is destroyed', fakeAsync(() => {\n      tooltipDirective.show();\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      const spy = jasmine.createSpy('complete spy');\n      const subscription = tooltipDirective\n        ._tooltipInstance!.afterHidden()\n        .subscribe({complete: spy});\n      tooltipDirective.hide(0);\n      tick(0);\n      fixture.detectChanges();\n      expect(spy).toHaveBeenCalled();\n      subscription.unsubscribe();\n    }));",
      "blocks": [
        {
          "id": 1,
          "label": "it('should complete the afterHidden stream when tooltip is destroyed', fakeAsync(() => {\ntooltipDirective.show();",
          "successors": [
            {
              "id": 3,
              "label": "fixture.detectChanges();\nfinishCurrentTooltipAnimation(overlayContainerElement, true);",
              "successors": [
                {
                  "id": 5,
                  "label": "const spy = jasmine.createSpy('complete spy');\nconst subscription = tooltipDirective\n  ._tooltipInstance!.afterHidden()\n  .subscribe({complete: spy});",
                  "successors": [
                    {
                      "id": 7,
                      "label": "tooltipDirective.hide(0);\ntick(0);",
                      "successors": [
                        {
                          "id": 9,
                          "label": "fixture.detectChanges();\nexpect(spy).toHaveBeenCalled();",
                          "successors": [
                            {
                              "id": 11,
                              "label": "subscription.unsubscribe();\n}));",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "it",
      "type": "function",
      "start_line": 569,
      "end_line": 585,
      "functions": [],
      "classes": [],
      "simplified_code": "    it('should consistently position before and after overlay origin in ltr and rtl dir', () => {\n      tooltipDirective.position = 'left';\n      const leftOrigin = tooltipDirective._getOrigin().main;\n      tooltipDirective.position = 'right';\n      const rightOrigin = tooltipDirective._getOrigin().main;\n      // Test expectations in LTR\n      tooltipDirective.position = 'before';\n      expect(tooltipDirective._getOrigin().main).toEqual(leftOrigin);\n      tooltipDirective.position = 'after';\n      expect(tooltipDirective._getOrigin().main).toEqual(rightOrigin);\n      // Test expectations in RTL\n      dir.value = 'rtl';\n      tooltipDirective.position = 'before';\n      expect(tooltipDirective._getOrigin().main).toEqual(leftOrigin);\n      tooltipDirective.position = 'after';\n      expect(tooltipDirective._getOrigin().main).toEqual(rightOrigin);\n    });",
      "blocks": [
        {
          "id": 1,
          "label": "it('should consistently position before and after overlay origin in ltr and rtl dir', () => {\ntooltipDirective.position = 'left';",
          "successors": [
            {
              "id": 3,
              "label": "const leftOrigin = tooltipDirective._getOrigin().main;\ntooltipDirective.position = 'right';",
              "successors": [
                {
                  "id": 5,
                  "label": "const rightOrigin = tooltipDirective._getOrigin().main;\n// Test expectations in LTR",
                  "successors": [
                    {
                      "id": 7,
                      "label": "tooltipDirective.position = 'before';\nexpect(tooltipDirective._getOrigin().main).toEqual(leftOrigin);",
                      "successors": [
                        {
                          "id": 9,
                          "label": "tooltipDirective.position = 'after';\nexpect(tooltipDirective._getOrigin().main).toEqual(rightOrigin);",
                          "successors": [
                            {
                              "id": 11,
                              "label": "// Test expectations in RTL\ndir.value = 'rtl';",
                              "successors": [
                                {
                                  "id": 13,
                                  "label": "tooltipDirective.position = 'before';\nexpect(tooltipDirective._getOrigin().main).toEqual(leftOrigin);",
                                  "successors": [
                                    {
                                      "id": 15,
                                      "label": "tooltipDirective.position = 'after';\nexpect(tooltipDirective._getOrigin().main).toEqual(rightOrigin);",
                                      "successors": []
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "it",
      "type": "function",
      "start_line": 586,
      "end_line": 602,
      "functions": [],
      "classes": [],
      "simplified_code": "    it('should consistently position before and after overlay position in ltr and rtl dir', () => {\n      tooltipDirective.position = 'left';\n      const leftOverlayPosition = tooltipDirective._getOverlayPosition().main;\n      tooltipDirective.position = 'right';\n      const rightOverlayPosition = tooltipDirective._getOverlayPosition().main;\n      // Test expectations in LTR\n      tooltipDirective.position = 'before';\n      expect(tooltipDirective._getOverlayPosition().main).toEqual(leftOverlayPosition);\n      tooltipDirective.position = 'after';\n      expect(tooltipDirective._getOverlayPosition().main).toEqual(rightOverlayPosition);\n      // Test expectations in RTL\n      dir.value = 'rtl';\n      tooltipDirective.position = 'before';\n      expect(tooltipDirective._getOverlayPosition().main).toEqual(leftOverlayPosition);\n      tooltipDirective.position = 'after';\n      expect(tooltipDirective._getOverlayPosition().main).toEqual(rightOverlayPosition);\n    });",
      "blocks": [
        {
          "id": 1,
          "label": "it('should consistently position before and after overlay position in ltr and rtl dir', () => {\ntooltipDirective.position = 'left';",
          "successors": [
            {
              "id": 3,
              "label": "const leftOverlayPosition = tooltipDirective._getOverlayPosition().main;\ntooltipDirective.position = 'right';",
              "successors": [
                {
                  "id": 5,
                  "label": "const rightOverlayPosition = tooltipDirective._getOverlayPosition().main;\n// Test expectations in LTR",
                  "successors": [
                    {
                      "id": 7,
                      "label": "tooltipDirective.position = 'before';\nexpect(tooltipDirective._getOverlayPosition().main).toEqual(leftOverlayPosition);",
                      "successors": [
                        {
                          "id": 9,
                          "label": "tooltipDirective.position = 'after';\nexpect(tooltipDirective._getOverlayPosition().main).toEqual(rightOverlayPosition);",
                          "successors": [
                            {
                              "id": 11,
                              "label": "// Test expectations in RTL\ndir.value = 'rtl';",
                              "successors": [
                                {
                                  "id": 13,
                                  "label": "tooltipDirective.position = 'before';\nexpect(tooltipDirective._getOverlayPosition().main).toEqual(leftOverlayPosition);",
                                  "successors": [
                                    {
                                      "id": 15,
                                      "label": "tooltipDirective.position = 'after';\nexpect(tooltipDirective._getOverlayPosition().main).toEqual(rightOverlayPosition);",
                                      "successors": []
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "it",
      "type": "function",
      "start_line": 603,
      "end_line": 610,
      "functions": [],
      "classes": [],
      "simplified_code": "    it('should throw when trying to assign an invalid position', () => {\n      expect(() => {\n        fixture.componentInstance.position = 'everywhere';\n        fixture.changeDetectorRef.markForCheck();\n        fixture.detectChanges();\n        tooltipDirective.show();\n      }).toThrowError('Tooltip position \"everywhere\" is invalid.');\n    });",
      "blocks": [
        {
          "id": 1,
          "label": "it('should throw when trying to assign an invalid position', () => {",
          "successors": [
            {
              "id": 2,
              "label": "expect(() => {\nfixture.componentInstance.position = 'everywhere';\nfixture.changeDetectorRef.markForCheck();\nfixture.detectChanges();\ntooltipDirective.show();",
              "successors": [
                {
                  "id": 4,
                  "label": "}).toThrowError('Tooltip position \"everywhere\" is invalid.');",
                  "successors": []
                }
              ]
            },
            {
              "id": 5,
              "label": "});",
              "successors": []
            }
          ]
        }
      ]
    },
    {
      "name": "it",
      "type": "function",
      "start_line": 611,
      "end_line": 622,
      "functions": [],
      "classes": [],
      "simplified_code": "    it('should pass the layout direction to the tooltip', fakeAsync(() => {\n      dir.value = 'rtl';\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      const tooltipWrapper = overlayContainerElement.querySelector(\n        '.cdk-overlay-connected-position-bounding-box',\n      )!;\n      expect(tooltipWrapper).withContext('Expected tooltip to be shown.').toBeTruthy();\n      expect(tooltipWrapper.getAttribute('dir'))\n        .withContext('Expected tooltip to be in RTL mode.')\n        .toBe('rtl');",
      "blocks": [
        {
          "id": 1,
          "label": "it('should pass the layout direction to the tooltip', fakeAsync(() => {\ndir.value = 'rtl';",
          "successors": [
            {
              "id": 3,
              "label": "tooltipDirective.show();\ntick(0);",
              "successors": [
                {
                  "id": 5,
                  "label": "fixture.detectChanges();\nconst tooltipWrapper = overlayContainerElement.querySelector('.cdk-overlay-connected-position-bounding-box')!;",
                  "successors": [
                    {
                      "id": 7,
                      "label": "expect(tooltipWrapper).withContext('Expected tooltip to be shown.').toBeTruthy();\nexpect(tooltipWrapper.getAttribute('dir'))\n    .withContext('Expected tooltip to be in RTL mode.')\n    .toBe('rtl');",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "it",
      "type": "function",
      "start_line": 624,
      "end_line": 651,
      "functions": [],
      "classes": [],
      "simplified_code": "    it('should keep the overlay direction in sync with the trigger direction', fakeAsync(() => {\n      dir.value = 'rtl';\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      let tooltipWrapper = overlayContainerElement.querySelector(\n        '.cdk-overlay-connected-position-bounding-box',\n      )!;\n      expect(tooltipWrapper.getAttribute('dir'))\n        .withContext('Expected tooltip to be in RTL.')\n        .toBe('rtl');\n      tooltipDirective.hide(0);\n      tick(0);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, false);\n      dir.value = 'ltr';\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      tooltipWrapper = overlayContainerElement.querySelector(\n        '.cdk-overlay-connected-position-bounding-box',\n      )!;\n      expect(tooltipWrapper.getAttribute('dir'))\n        .withContext('Expected tooltip to be in LTR.')\n        .toBe('ltr');\n      flush();",
      "blocks": [
        {
          "id": 1,
          "label": "it('should keep the overlay direction in sync with the trigger direction', fakeAsync(() => {\n  dir.value = 'rtl';\n  tooltipDirective.show();\n  tick(0);\n  fixture.detectChanges();\n  finishCurrentTooltipAnimation(overlayContainerElement, true);\n  let tooltipWrapper = overlayContainerElement.querySelector(\n    '.cdk-overlay-connected-position-bounding-box',\n  )!;\n  expect(tooltipWrapper.getAttribute('dir'))\n    .withContext('Expected tooltip to be in RTL.')\n    .toBe('rtl');\n  tooltipDirective.hide(0);\n  tick(0);\n  fixture.detectChanges();\n  finishCurrentTooltipAnimation(overlayContainerElement, false);\n  dir.value = 'ltr';\n  tooltipDirective.show();\n  tick(0);\n  fixture.detectChanges();\n  finishCurrentTooltipAnimation(overlayContainerElement, true);\n  tooltipWrapper = overlayContainerElement.querySelector(\n    '.cdk-overlay-connected-position-bounding-box',\n  )!;\n  expect(tooltipWrapper.getAttribute('dir'))\n    .withContext('Expected tooltip to be in LTR.')\n    .toBe('ltr');\n  flush();",
          "successors": []
        }
      ]
    },
    {
      "name": "it",
      "type": "function",
      "start_line": 653,
      "end_line": 658,
      "functions": [],
      "classes": [],
      "simplified_code": "    it('should be able to set the tooltip message as a number', fakeAsync(() => {\n      fixture.componentInstance.message = 100;\n      fixture.changeDetectorRef.markForCheck();\n      fixture.detectChanges();\n      expect(tooltipDirective.message).toBe('100');\n    }));",
      "blocks": [
        {
          "id": 1,
          "label": "it('should be able to set the tooltip message as a number', fakeAsync(() => {\n    fixture.componentInstance.message = 100;",
          "successors": [
            {
              "id": 3,
              "label": "    fixture.changeDetectorRef.markForCheck();\n    fixture.detectChanges();",
              "successors": [
                {
                  "id": 5,
                  "label": "    expect(tooltipDirective.message).toBe('100');\n}));",
                  "successors": []
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "it",
      "type": "function",
      "start_line": 659,
      "end_line": 673,
      "functions": [],
      "classes": [],
      "simplified_code": "    it('should hide when clicking away', fakeAsync(() => {\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      expect(overlayContainerElement.textContent).toContain(initialTooltipMessage);\n      document.body.click();\n      tick(0);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, false);\n      fixture.detectChanges();\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      expect(overlayContainerElement.textContent).toBe('');\n    }));",
      "blocks": [
        {
          "id": 1,
          "label": "it('should hide when clicking away', fakeAsync(() => {\n  tooltipDirective.show();",
          "successors": [
            {
              "id": 3,
              "label": "  tick(0);\n  fixture.detectChanges();",
              "successors": [
                {
                  "id": 5,
                  "label": "  finishCurrentTooltipAnimation(overlayContainerElement, true);\n  expect(tooltipDirective._isTooltipVisible()).toBe(true);",
                  "successors": [
                    {
                      "id": 7,
                      "label": "  expect(overlayContainerElement.textContent).toContain(initialTooltipMessage);\n  document.body.click();",
                      "successors": [
                        {
                          "id": 9,
                          "label": "  tick(0);\n  fixture.detectChanges();",
                          "successors": [
                            {
                              "id": 11,
                              "label": "  finishCurrentTooltipAnimation(overlayContainerElement, false);\n  fixture.detectChanges();",
                              "successors": [
                                {
                                  "id": 13,
                                  "label": "  expect(tooltipDirective._isTooltipVisible()).toBe(false);\n  expect(overlayContainerElement.textContent).toBe('');",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "it",
      "type": "function",
      "start_line": 674,
      "end_line": 688,
      "functions": [],
      "classes": [],
      "simplified_code": "    it('should hide when clicking away with an auxilliary button', fakeAsync(() => {\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      expect(overlayContainerElement.textContent).toContain(initialTooltipMessage);\n      dispatchFakeEvent(document.body, 'auxclick');\n      tick(0);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, false);\n      fixture.detectChanges();\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      expect(overlayContainerElement.textContent).toBe('');\n    }));",
      "blocks": [
        {
          "id": 1,
          "label": "it('should hide when clicking away with an auxilliary button', fakeAsync(() => {\ntooltipDirective.show();",
          "successors": [
            {
              "id": 3,
              "label": "tick(0);\nfixture.detectChanges();",
              "successors": [
                {
                  "id": 5,
                  "label": "finishCurrentTooltipAnimation(overlayContainerElement, true);\nexpect(tooltipDirective._isTooltipVisible()).toBe(true);",
                  "successors": [
                    {
                      "id": 7,
                      "label": "expect(overlayContainerElement.textContent).toContain(initialTooltipMessage);\ndispatchFakeEvent(document.body, 'auxclick');",
                      "successors": [
                        {
                          "id": 9,
                          "label": "tick(0);\nfixture.detectChanges();",
                          "successors": [
                            {
                              "id": 11,
                              "label": "finishCurrentTooltipAnimation(overlayContainerElement, false);\nfixture.detectChanges();",
                              "successors": [
                                {
                                  "id": 13,
                                  "label": "expect(tooltipDirective._isTooltipVisible()).toBe(false);\nexpect(overlayContainerElement.textContent).toBe('');",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "it",
      "type": "function",
      "start_line": 689,
      "end_line": 699,
      "functions": [],
      "classes": [],
      "simplified_code": "    it('should not hide immediately if a click fires while animating', fakeAsync(() => {\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      document.body.click();\n      fixture.detectChanges();\n      tick(500);\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      expect(overlayContainerElement.textContent).toContain(initialTooltipMessage);\n      flush();\n    }));",
      "blocks": [
        {
          "id": 1,
          "label": "it('should not hide immediately if a click fires while animating', fakeAsync(() => {\ntooltipDirective.show();",
          "successors": [
            {
              "id": 3,
              "label": "tick(0);\nfixture.detectChanges();",
              "successors": [
                {
                  "id": 5,
                  "label": "document.body.click();\nfixture.detectChanges();",
                  "successors": [
                    {
                      "id": 7,
                      "label": "tick(500);\nfinishCurrentTooltipAnimation(overlayContainerElement, true);",
                      "successors": [
                        {
                          "id": 9,
                          "label": "expect(overlayContainerElement.textContent).toContain(initialTooltipMessage);\nflush();",
                          "successors": [
                            {
                              "id": 11,
                              "label": "});",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "it",
      "type": "function",
      "start_line": 700,
      "end_line": 716,
      "functions": [],
      "classes": [],
      "simplified_code": "    it('should hide when pressing escape', fakeAsync(() => {\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      tick(500);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      expect(overlayContainerElement.textContent).toContain(initialTooltipMessage);\n      dispatchKeyboardEvent(document.body, 'keydown', ESCAPE);\n      tick(0);\n      fixture.detectChanges();\n      tick(500);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, false);\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      expect(overlayContainerElement.textContent).toBe('');\n      flush();\n    }));",
      "blocks": [
        {
          "id": 1,
          "label": "it('should hide when pressing escape', fakeAsync(() => {\ntooltipDirective.show();",
          "successors": [
            {
              "id": 3,
              "label": "tick(0);\nfixture.detectChanges();",
              "successors": [
                {
                  "id": 5,
                  "label": "tick(500);\nexpect(tooltipDirective._isTooltipVisible()).toBe(true);",
                  "successors": [
                    {
                      "id": 7,
                      "label": "expect(overlayContainerElement.textContent).toContain(initialTooltipMessage);\ndispatchKeyboardEvent(document.body, 'keydown', ESCAPE);",
                      "successors": [
                        {
                          "id": 9,
                          "label": "tick(0);\nfixture.detectChanges();",
                          "successors": [
                            {
                              "id": 11,
                              "label": "tick(500);\nfixture.detectChanges();",
                              "successors": [
                                {
                                  "id": 13,
                                  "label": "finishCurrentTooltipAnimation(overlayContainerElement, false);\nexpect(tooltipDirective._isTooltipVisible()).toBe(false);",
                                  "successors": [
                                    {
                                      "id": 15,
                                      "label": "expect(overlayContainerElement.textContent).toBe('');\nflush();",
                                      "successors": []
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "it",
      "type": "function",
      "start_line": 717,
      "end_line": 724,
      "functions": [],
      "classes": [],
      "simplified_code": "    it('should not throw when pressing ESCAPE', fakeAsync(() => {\n      expect(() => {\n        dispatchKeyboardEvent(document.body, 'keydown', ESCAPE);\n        fixture.detectChanges();\n      }).not.toThrow();\n      // Flush due to the additional tick that is necessary for the FocusMonitor.\n      flush();\n    }));",
      "blocks": [
        {
          "id": 1,
          "label": "it('should not throw when pressing ESCAPE', fakeAsync(() => {\nexpect(() => {",
          "successors": [
            {
              "id": 3,
              "label": "dispatchKeyboardEvent(document.body, 'keydown', ESCAPE);\nfixture.detectChanges();",
              "successors": [
                {
                  "id": 5,
                  "label": "}).not.toThrow();\nflush();",
                  "successors": [
                    {
                      "id": 7,
                      "label": "}));",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "it",
      "type": "function",
      "start_line": 725,
      "end_line": 733,
      "functions": [],
      "classes": [],
      "simplified_code": "    it('should preventDefault when pressing ESCAPE', fakeAsync(() => {\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      const event = dispatchKeyboardEvent(document.body, 'keydown', ESCAPE);\n      fixture.detectChanges();\n      flush();\n      expect(event.defaultPrevented).toBe(true);\n    }));",
      "blocks": [
        {
          "id": 1,
          "label": "it('should preventDefault when pressing ESCAPE', fakeAsync(() => {\ntooltipDirective.show();",
          "successors": [
            {
              "id": 3,
              "label": "tick(0);\nfixture.detectChanges();",
              "successors": [
                {
                  "id": 5,
                  "label": "const event = dispatchKeyboardEvent(document.body, 'keydown', ESCAPE);\nfixture.detectChanges();",
                  "successors": [
                    {
                      "id": 7,
                      "label": "flush();\nexpect(event.defaultPrevented).toBe(true);",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "it",
      "type": "function",
      "start_line": 734,
      "end_line": 743,
      "functions": [],
      "classes": [],
      "simplified_code": "    it('should not preventDefault when pressing ESCAPE with a modifier', fakeAsync(() => {\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      const event = createKeyboardEvent('keydown', ESCAPE, undefined, {alt: true});\n      dispatchEvent(document.body, event);\n      fixture.detectChanges();\n      flush();\n      expect(event.defaultPrevented).toBe(false);\n    }));",
      "blocks": [
        {
          "id": 1,
          "label": "it('should not preventDefault when pressing ESCAPE with a modifier', fakeAsync(() => {\ntooltipDirective.show();",
          "successors": [
            {
              "id": 3,
              "label": "tick(0);\nfixture.detectChanges();",
              "successors": [
                {
                  "id": 5,
                  "label": "const event = createKeyboardEvent('keydown', ESCAPE, undefined, {alt: true});\ndispatchEvent(document.body, event);",
                  "successors": [
                    {
                      "id": 7,
                      "label": "fixture.detectChanges();\nflush();",
                      "successors": [
                        {
                          "id": 9,
                          "label": "expect(event.defaultPrevented).toBe(false);\n}));",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "it",
      "type": "function",
      "start_line": 744,
      "end_line": 752,
      "functions": [],
      "classes": [],
      "simplified_code": "    it('should not show the tooltip on programmatic focus', fakeAsync(() => {\n      patchElementFocus(buttonElement);\n      assertTooltipInstance(tooltipDirective, false);\n      focusMonitor.focusVia(buttonElement, 'program');\n      tick(0);\n      fixture.detectChanges();\n      tick(500);\n      expect(overlayContainerElement.querySelector('.mat-mdc-tooltip')).toBeNull();\n    }));",
      "blocks": [
        {
          "id": 1,
          "label": "it('should not show the tooltip on programmatic focus', fakeAsync(() => {\n  patchElementFocus(buttonElement);",
          "successors": [
            {
              "id": 3,
              "label": "  assertTooltipInstance(tooltipDirective, false);\n  focusMonitor.focusVia(buttonElement, 'program');",
              "successors": [
                {
                  "id": 5,
                  "label": "  tick(0);\n  fixture.detectChanges();",
                  "successors": [
                    {
                      "id": 7,
                      "label": "  tick(500);\n  expect(overlayContainerElement.querySelector('.mat-mdc-tooltip')).toBeNull();",
                      "successors": [
                        {
                          "id": 9,
                          "label": "}));",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "it",
      "type": "function",
      "start_line": 753,
      "end_line": 760,
      "functions": [],
      "classes": [],
      "simplified_code": "    it('should not show the tooltip on mouse focus', fakeAsync(() => {\n      patchElementFocus(buttonElement);\n      assertTooltipInstance(tooltipDirective, false);\n      focusMonitor.focusVia(buttonElement, 'mouse');\n      tick(0);\n      fixture.detectChanges();\n      tick(500);\n      expect(overlayContainerElement.querySelector('.mat-mdc-tooltip')).toBeNull();",
      "blocks": [
        {
          "id": 1,
          "label": "it('should not show the tooltip on mouse focus', fakeAsync(() => {\n    patchElementFocus(buttonElement);",
          "successors": [
            {
              "id": 3,
              "label": "    assertTooltipInstance(tooltipDirective, false);\n    focusMonitor.focusVia(buttonElement, 'mouse');",
              "successors": [
                {
                  "id": 5,
                  "label": "    tick(0);\n    fixture.detectChanges();",
                  "successors": [
                    {
                      "id": 7,
                      "label": "    tick(500);\n    expect(overlayContainerElement.querySelector('.mat-mdc-tooltip')).toBeNull();",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "it",
      "type": "function",
      "start_line": 762,
      "end_line": 770,
      "functions": [],
      "classes": [],
      "simplified_code": "    it('should not show the tooltip on touch focus', fakeAsync(() => {\n      patchElementFocus(buttonElement);\n      assertTooltipInstance(tooltipDirective, false);\n      focusMonitor.focusVia(buttonElement, 'touch');\n      tick(0);\n      fixture.detectChanges();\n      tick(500);\n      expect(overlayContainerElement.querySelector('.mat-mdc-tooltip')).toBeNull();\n    }));",
      "blocks": [
        {
          "id": 1,
          "label": "it('should not show the tooltip on touch focus', fakeAsync(() => {\n    patchElementFocus(buttonElement);",
          "successors": [
            {
              "id": 3,
              "label": "    assertTooltipInstance(tooltipDirective, false);\n    focusMonitor.focusVia(buttonElement, 'touch');",
              "successors": [
                {
                  "id": 5,
                  "label": "    tick(0);\n    fixture.detectChanges();",
                  "successors": [
                    {
                      "id": 7,
                      "label": "    tick(500);\n    expect(overlayContainerElement.querySelector('.mat-mdc-tooltip')).toBeNull();",
                      "successors": [
                        {
                          "id": 9,
                          "label": "}))",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "it",
      "type": "function",
      "start_line": 771,
      "end_line": 786,
      "functions": [],
      "classes": [],
      "simplified_code": "    it('should not hide the tooltip when calling `show` twice in a row', fakeAsync(() => {\n      tooltipDirective.show();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      const overlayRef = tooltipDirective._overlayRef!;\n      spyOn(overlayRef, 'detach').and.callThrough();\n      tooltipDirective.show();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      expect(overlayRef.detach).not.toHaveBeenCalled();\n      flush();\n    }));",
      "blocks": [
        {
          "id": 1,
          "label": "it('should not hide the tooltip when calling `show` twice in a row', fakeAsync(() => {\ntooltipDirective.show();",
          "successors": [
            {
              "id": 3,
              "label": "tick(0);\nexpect(tooltipDirective._isTooltipVisible()).toBe(true);",
              "successors": [
                {
                  "id": 5,
                  "label": "fixture.detectChanges();\nfinishCurrentTooltipAnimation(overlayContainerElement, true);",
                  "successors": [
                    {
                      "id": 7,
                      "label": "const overlayRef = tooltipDirective._overlayRef!;\nspyOn(overlayRef, 'detach').and.callThrough();",
                      "successors": [
                        {
                          "id": 9,
                          "label": "tooltipDirective.show();\ntick(0);",
                          "successors": [
                            {
                              "id": 11,
                              "label": "expect(tooltipDirective._isTooltipVisible()).toBe(true);\nfixture.detectChanges();",
                              "successors": [
                                {
                                  "id": 13,
                                  "label": "finishCurrentTooltipAnimation(overlayContainerElement, true);\nexpect(overlayRef.detach).not.toHaveBeenCalled();",
                                  "successors": [
                                    {
                                      "id": 15,
                                      "label": "flush();",
                                      "successors": []
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "it",
      "type": "function",
      "start_line": 787,
      "end_line": 817,
      "functions": [],
      "classes": [],
      "simplified_code": "    it('should set a class on the overlay panel that reflects the position', fakeAsync(() => {\n      // Move the element so that the primary position is always used.\n      buttonElement.style.position = 'fixed';\n      buttonElement.style.top = buttonElement.style.left = '200px';\n      fixture.componentInstance.message = 'hi';\n      fixture.changeDetectorRef.markForCheck();\n      fixture.detectChanges();\n      setPositionAndShow('below');\n      const classList = tooltipDirective._overlayRef!.overlayElement.classList;\n      expect(classList).toContain('mat-mdc-tooltip-panel-below');\n      setPositionAndShow('above');\n      expect(classList).not.toContain('mat-mdc-tooltip-panel-below');\n      expect(classList).toContain('mat-mdc-tooltip-panel-above');\n      setPositionAndShow('left');\n      expect(classList).not.toContain('mat-mdc-tooltip-panel-above');\n      expect(classList).toContain('mat-mdc-tooltip-panel-left');\n      setPositionAndShow('right');\n      expect(classList).not.toContain('mat-mdc-tooltip-panel-left');\n      expect(classList).toContain('mat-mdc-tooltip-panel-right');\n      function setPositionAndShow(position: TooltipPosition) {\n        tooltipDirective.hide(0);\n        fixture.detectChanges();\n        tick(0);\n        tooltipDirective.position = position;\n        tooltipDirective.show(0);\n        fixture.detectChanges();\n        tick(0);\n        fixture.detectChanges();\n        tick(500);\n      }\n    }));",
      "blocks": [
        {
          "id": 1,
          "label": "it('should set a class on the overlay panel that reflects the position', fakeAsync(() => {\nbuttonElement.style.position = 'fixed';",
          "successors": [
            {
              "id": 3,
              "label": "buttonElement.style.top = buttonElement.style.left = '200px';\nfixture.componentInstance.message = 'hi';",
              "successors": [
                {
                  "id": 5,
                  "label": "fixture.changeDetectorRef.markForCheck();\nfixture.detectChanges();",
                  "successors": [
                    {
                      "id": 7,
                      "label": "setPositionAndShow('below');\nconst classList = tooltipDirective._overlayRef!.overlayElement.classList;",
                      "successors": [
                        {
                          "id": 9,
                          "label": "expect(classList).toContain('mat-mdc-tooltip-panel-below');\nsetPositionAndShow('above');",
                          "successors": [
                            {
                              "id": 11,
                              "label": "expect(classList).not.toContain('mat-mdc-tooltip-panel-below');\nexpect(classList).toContain('mat-mdc-tooltip-panel-above');",
                              "successors": [
                                {
                                  "id": 13,
                                  "label": "setPositionAndShow('left');\nexpect(classList).not.toContain('mat-mdc-tooltip-panel-above');",
                                  "successors": [
                                    {
                                      "id": 15,
                                      "label": "expect(classList).toContain('mat-mdc-tooltip-panel-left');\nsetPositionAndShow('right');",
                                      "successors": [
                                        {
                                          "id": 17,
                                          "label": "expect(classList).not.toContain('mat-mdc-tooltip-panel-left');\nexpect(classList).toContain('mat-mdc-tooltip-panel-right');",
                                          "successors": []
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "id": 19,
              "label": "function setPositionAndShow(position: TooltipPosition) {\ntooltipDirective.hide(0);",
              "successors": [
                {
                  "id": 21,
                  "label": "fixture.detectChanges();\ntick(0);",
                  "successors": [
                    {
                      "id": 23,
                      "label": "tooltipDirective.position = position;\ntooltipDirective.show(0);",
                      "successors": [
                        {
                          "id": 25,
                          "label": "fixture.detectChanges();\ntick(0);",
                          "successors": [
                            {
                              "id": 27,
                              "label": "fixture.detectChanges();\ntick(500);",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "it",
      "type": "function",
      "start_line": 818,
      "end_line": 851,
      "functions": [],
      "classes": [],
      "simplified_code": "    it('should account for RTL when setting the tooltip position class', fakeAsync(() => {\n      // Move the element so that the primary position is always used.\n      buttonElement.style.position = 'fixed';\n      buttonElement.style.top = buttonElement.style.left = '200px';\n      fixture.componentInstance.message = 'hi';\n      fixture.changeDetectorRef.markForCheck();\n      fixture.detectChanges();\n      dir.value = 'ltr';\n      tooltipDirective.position = 'after';\n      fixture.changeDetectorRef.markForCheck();\n      tooltipDirective.show(0);\n      fixture.detectChanges();\n      tick(0);\n      fixture.detectChanges();\n      tick(500);\n      const classList = tooltipDirective._overlayRef!.overlayElement.classList;\n      expect(classList).not.toContain('mat-mdc-tooltip-panel-after');\n      expect(classList).not.toContain('mat-mdc-tooltip-panel-before');\n      expect(classList).not.toContain('mat-mdc-tooltip-panel-left');\n      expect(classList).toContain('mat-mdc-tooltip-panel-right');\n      tooltipDirective.hide(0);\n      fixture.detectChanges();\n      tick(0);\n      dir.value = 'rtl';\n      tooltipDirective.show(0);\n      fixture.detectChanges();\n      tick(0);\n      fixture.detectChanges();\n      tick(500);\n      expect(classList).not.toContain('mat-mdc-tooltip-panel-after');\n      expect(classList).not.toContain('mat-mdc-tooltip-panel-before');\n      expect(classList).not.toContain('mat-mdc-tooltip-panel-right');\n      expect(classList).toContain('mat-mdc-tooltip-panel-left');\n    }));",
      "blocks": [
        {
          "id": 1,
          "label": "it('should account for RTL when setting the tooltip position class', fakeAsync(() => {",
          "successors": [
            {
              "id": 2,
              "label": "// Move the element so that the primary position is always used.\nbuttonElement.style.position = 'fixed';\nbuttonElement.style.top = buttonElement.style.left = '200px';\nfixture.componentInstance.message = 'hi';\nfixture.changeDetectorRef.markForCheck();\nfixture.detectChanges();\ndir.value = 'ltr';\ntooltipDirective.position = 'after';\nfixture.changeDetectorRef.markForCheck();\ntooltipDirective.show(0);\nfixture.detectChanges();\ntick(0);\nfixture.detectChanges();\ntick(500);\nconst classList = tooltipDirective._overlayRef!.overlayElement.classList;\nexpect(classList).not.toContain('mat-mdc-tooltip-panel-after');\nexpect(classList).not.toContain('mat-mdc-tooltip-panel-before');\nexpect(classList).not.toContain('mat-mdc-tooltip-panel-left');\nexpect(classList).toContain('mat-mdc-tooltip-panel-right');\ntooltipDirective.hide(0);\nfixture.detectChanges();\ntick(0);\ndir.value = 'rtl';\ntooltipDirective.show(0);\nfixture.detectChanges();\ntick(0);\nfixture.detectChanges();\ntick(500);\nexpect(classList).not.toContain('mat-mdc-tooltip-panel-after');\nexpect(classList).not.toContain('mat-mdc-tooltip-panel-before');\nexpect(classList).not.toContain('mat-mdc-tooltip-panel-right');\nexpect(classList).toContain('mat-mdc-tooltip-panel-left');\n}))",
              "successors": []
            },
            {
              "id": 4,
              "label": "",
              "successors": []
            }
          ]
        }
      ]
    },
    {
      "name": "it",
      "type": "function",
      "start_line": 852,
      "end_line": 860,
      "functions": [],
      "classes": [],
      "simplified_code": "    it('should clear the show timeout on destroy', fakeAsync(() => {\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.show(1000);\n      fixture.detectChanges();\n      // Note that we aren't asserting anything, but `fakeAsync` will\n      // throw if we have any timers by the end of the test.\n      fixture.destroy();\n      flush();\n    }));",
      "blocks": [
        {
          "id": 1,
          "label": "it('should clear the show timeout on destroy', fakeAsync(() => {\n    assertTooltipInstance(tooltipDirective, false);",
          "successors": [
            {
              "id": 3,
              "label": "    tooltipDirective.show(1000);\n    fixture.detectChanges();",
              "successors": [
                {
                  "id": 5,
                  "label": "    fixture.destroy();\n    flush();",
                  "successors": [
                    {
                      "id": 7,
                      "label": "}));",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "it",
      "type": "function",
      "start_line": 861,
      "end_line": 873,
      "functions": [],
      "classes": [],
      "simplified_code": "    it('should clear the hide timeout on destroy', fakeAsync(() => {\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.show();\n      tick(0);\n      fixture.detectChanges();\n      tick(500);\n      tooltipDirective.hide(1000);\n      fixture.detectChanges();\n      // Note that we aren't asserting anything, but `fakeAsync` will\n      // throw if we have any timers by the end of the test.\n      fixture.destroy();\n      flush();\n    }));",
      "blocks": [
        {
          "id": 1,
          "label": "it('should clear the hide timeout on destroy', fakeAsync(() => {\nassertTooltipInstance(tooltipDirective, false);",
          "successors": [
            {
              "id": 3,
              "label": "tooltipDirective.show();\ntick(0);",
              "successors": [
                {
                  "id": 5,
                  "label": "fixture.detectChanges();\ntick(500);",
                  "successors": [
                    {
                      "id": 7,
                      "label": "tooltipDirective.hide(1000);\nfixture.detectChanges();",
                      "successors": [
                        {
                          "id": 9,
                          "label": "fixture.destroy();\nflush();",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "it",
      "type": "function",
      "start_line": 874,
      "end_line": 888,
      "functions": [],
      "classes": [],
      "simplified_code": "    it('should set the multiline class on tooltips with messages that overflow', fakeAsync(() => {\n      fixture.componentInstance.message =\n        'This is a very long message that should cause the' +\n        'tooltip message body to overflow onto a new line.';\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick();\n      // Need to detect changes again to wait for the multiline class to be applied.\n      fixture.detectChanges();\n      const tooltipElement = overlayContainerElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;\n      expect(tooltipElement.classList).toContain('mdc-tooltip--multiline');\n      expect(tooltipDirective._tooltipInstance?._isMultiline).toBeTrue();\n    }));",
      "blocks": [
        {
          "id": 1,
          "label": "it('should set the multiline class on tooltips with messages that overflow', fakeAsync(() => {\nfixture.componentInstance.message =\n  'This is a very long message that should cause the' +\n  'tooltip message body to overflow onto a new line.';",
          "successors": [
            {
              "id": 3,
              "label": "tooltipDirective.show();\nfixture.detectChanges();",
              "successors": [
                {
                  "id": 5,
                  "label": "tick();\n// Need to detect changes again to wait for the multiline class to be applied.\nfixture.detectChanges();",
                  "successors": [
                    {
                      "id": 7,
                      "label": "const tooltipElement = overlayContainerElement.querySelector(\n  '.mat-mdc-tooltip',\n) as HTMLElement;\nexpect(tooltipElement.classList).toContain('mdc-tooltip--multiline');",
                      "successors": [
                        {
                          "id": 9,
                          "label": "expect(tooltipDirective._tooltipInstance?._isMultiline).toBeTrue();\n}));",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "it",
      "type": "function",
      "start_line": 889,
      "end_line": 902,
      "functions": [],
      "classes": [],
      "simplified_code": "    it('should hide on mouseleave on the trigger', fakeAsync(() => {\n      // We don't bind mouse events on mobile devices.\n      if (platform.IOS || platform.ANDROID) {\n        return;\n      }\n      dispatchMouseEvent(fixture.componentInstance.button.nativeElement, 'mouseenter');\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      dispatchMouseEvent(fixture.componentInstance.button.nativeElement, 'mouseleave');\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n    }));",
      "blocks": [
        {
          "id": 1,
          "label": "it('should hide on mouseleave on the trigger', fakeAsync(() => {\nif (platform.IOS || platform.ANDROID) {",
          "successors": [
            {
              "id": 3,
              "label": "return;",
              "successors": []
            },
            {
              "id": 4,
              "label": "} else {\ndispatchMouseEvent(fixture.componentInstance.button.nativeElement, 'mouseenter');",
              "successors": [
                {
                  "id": 6,
                  "label": "fixture.detectChanges();\ntick(0);",
                  "successors": [
                    {
                      "id": 8,
                      "label": "expect(tooltipDirective._isTooltipVisible()).toBe(true);\ndispatchMouseEvent(fixture.componentInstance.button.nativeElement, 'mouseleave');",
                      "successors": [
                        {
                          "id": 10,
                          "label": "fixture.detectChanges();\ntick(0);",
                          "successors": [
                            {
                              "id": 12,
                              "label": "expect(tooltipDirective._isTooltipVisible()).toBe(false);",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "it",
      "type": "function",
      "start_line": 903,
      "end_line": 921,
      "functions": [],
      "classes": [],
      "simplified_code": "    it('should not hide on mouseleave if the pointer goes from the trigger to the tooltip', fakeAsync(() => {\n      // We don't bind mouse events on mobile devices.\n      if (platform.IOS || platform.ANDROID) {\n        return;\n      }\n      dispatchMouseEvent(fixture.componentInstance.button.nativeElement, 'mouseenter');\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      const tooltipElement = overlayContainerElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;\n      const event = createMouseEvent('mouseleave');\n      Object.defineProperty(event, 'relatedTarget', {value: tooltipElement});\n      dispatchEvent(fixture.componentInstance.button.nativeElement, event);\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n    }));",
      "blocks": [
        {
          "id": 1,
          "label": "it('should not hide on mouseleave if the pointer goes from the trigger to the tooltip', fakeAsync(() => {\nif (platform.IOS || platform.ANDROID) {",
          "successors": [
            {
              "id": 3,
              "label": "return;",
              "successors": []
            },
            {
              "id": 4,
              "label": "}\ndispatchMouseEvent(fixture.componentInstance.button.nativeElement, 'mouseenter');",
              "successors": [
                {
                  "id": 6,
                  "label": "fixture.detectChanges();\ntick(0);",
                  "successors": [
                    {
                      "id": 8,
                      "label": "expect(tooltipDirective._isTooltipVisible()).toBe(true);\nconst tooltipElement = overlayContainerElement.querySelector(\n  '.mat-mdc-tooltip',\n) as HTMLElement;",
                      "successors": [
                        {
                          "id": 10,
                          "label": "const event = createMouseEvent('mouseleave');\nObject.defineProperty(event, 'relatedTarget', {value: tooltipElement});",
                          "successors": [
                            {
                              "id": 12,
                              "label": "dispatchEvent(fixture.componentInstance.button.nativeElement, event);\nfixture.detectChanges();",
                              "successors": [
                                {
                                  "id": 14,
                                  "label": "tick(0);\nexpect(tooltipDirective._isTooltipVisible()).toBe(true);",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "it",
      "type": "function",
      "start_line": 922,
      "end_line": 938,
      "functions": [],
      "classes": [],
      "simplified_code": "    it('should hide on mouseleave on the tooltip', fakeAsync(() => {\n      // We don't bind mouse events on mobile devices.\n      if (platform.IOS || platform.ANDROID) {\n        return;\n      }\n      dispatchMouseEvent(fixture.componentInstance.button.nativeElement, 'mouseenter');\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      const tooltipElement = overlayContainerElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;\n      dispatchMouseEvent(tooltipElement, 'mouseleave');\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n    }));",
      "blocks": [
        {
          "id": 1,
          "label": "it('should hide on mouseleave on the tooltip', fakeAsync(() => {\nif (platform.IOS || platform.ANDROID) {",
          "successors": [
            {
              "id": 3,
              "label": "return;",
              "successors": []
            },
            {
              "id": 4,
              "label": "}\ndispatchMouseEvent(fixture.componentInstance.button.nativeElement, 'mouseenter');\nfixture.detectChanges();\ntick(0);\nexpect(tooltipDirective._isTooltipVisible()).toBe(true);",
              "successors": [
                {
                  "id": 6,
                  "label": "const tooltipElement = overlayContainerElement.querySelector(\n    '.mat-mdc-tooltip',\n  ) as HTMLElement;\ndispatchMouseEvent(tooltipElement, 'mouseleave');\nfixture.detectChanges();\ntick(0);\nexpect(tooltipDirective._isTooltipVisible()).toBe(false);\n}));",
                  "successors": []
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "it",
      "type": "function",
      "start_line": 939,
      "end_line": 958,
      "functions": [],
      "classes": [],
      "simplified_code": "    it('should not hide on mouseleave if the pointer goes from the tooltip to the trigger', fakeAsync(() => {\n      // We don't bind mouse events on mobile devices.\n      if (platform.IOS || platform.ANDROID) {\n        return;\n      }\n      dispatchMouseEvent(fixture.componentInstance.button.nativeElement, 'mouseenter');\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      const tooltipElement = overlayContainerElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;\n      const event = createMouseEvent('mouseleave');\n      Object.defineProperty(event, 'relatedTarget', {\n        value: fixture.componentInstance.button.nativeElement,\n      });\n      dispatchEvent(tooltipElement, event);\n      fixture.detectChanges();\n      tick(0);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);",
      "blocks": [
        {
          "id": 1,
          "label": "it('should not hide on mouseleave if the pointer goes from the tooltip to the trigger', fakeAsync(() => {",
          "successors": [
            {
              "id": 2,
              "label": "if (platform.IOS || platform.ANDROID) {\nreturn;",
              "successors": []
            },
            {
              "id": 4,
              "label": "dispatchMouseEvent(fixture.componentInstance.button.nativeElement, 'mouseenter');\nfixture.detectChanges();",
              "successors": [
                {
                  "id": 6,
                  "label": "tick(0);\nexpect(tooltipDirective._isTooltipVisible()).toBe(true);",
                  "successors": [
                    {
                      "id": 8,
                      "label": "const tooltipElement = overlayContainerElement.querySelector('.mat-mdc-tooltip') as HTMLElement;\nconst event = createMouseEvent('mouseleave');",
                      "successors": [
                        {
                          "id": 10,
                          "label": "Object.defineProperty(event, 'relatedTarget', { value: fixture.componentInstance.button.nativeElement });\ndispatchEvent(tooltipElement, event);",
                          "successors": [
                            {
                              "id": 12,
                              "label": "fixture.detectChanges();\ntick(0);",
                              "successors": [
                                {
                                  "id": 14,
                                  "label": "expect(tooltipDirective._isTooltipVisible()).toBe(true);",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    }
  ],
  "classes": [
    {
      "name": "BasicTooltipDemo",
      "type": "class",
      "start_line": 1318,
      "end_line": 1327,
      "functions": [
        {
          "name": "",
          "type": "constructor",
          "start_line": 1318,
          "end_line": 1327,
          "functions": [],
          "classes": [],
          "simplified_code": "class BasicTooltipDemo {\n  position = 'below';\n  message: any = initialTooltipMessage;\n  showButton = true;\n  showTooltipClass = false;\n  tooltipDisabled = false;\n  touchGestures: TooltipTouchGestures = 'auto';\n  @ViewChild(MatTooltip) tooltip: MatTooltip;\n  @ViewChild('button') button: ElementRef<HTMLButtonElement>;\n}",
          "blocks": [
            {
              "id": 1,
              "label": "class BasicTooltipDemo {\n  position = 'below';",
              "successors": [
                {
                  "id": 3,
                  "label": "  message: any = initialTooltipMessage;\n  showButton = true;",
                  "successors": [
                    {
                      "id": 5,
                      "label": "  showTooltipClass = false;\n  tooltipDisabled = false;",
                      "successors": [
                        {
                          "id": 7,
                          "label": "  touchGestures: TooltipTouchGestures = 'auto';\n  @ViewChild(MatTooltip) tooltip: MatTooltip;",
                          "successors": [
                            {
                              "id": 9,
                              "label": "  @ViewChild('button') button: ElementRef<HTMLButtonElement>;\n}",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "simplified_code": "}",
      "blocks": [
        {
          "id": 1,
          "label": "while True:",
          "successors": [
            {
              "id": 2,
              "label": "    try:",
              "successors": [
                {
                  "id": 3,
                  "label": "        x = int(input(\"Please enter a number: \"))\n    break",
                  "successors": []
                },
                {
                  "id": 4,
                  "label": "    except ValueError:\n        print(\"Oops! That was no valid number. Try again...\")",
                  "successors": [
                    {
                      "id": 1,
                      "label": "while True:",
                      "successors": [
                        {
                          "id": 2,
                          "label": "    try:",
                          "successors": [
                            {
                              "id": 3,
                              "label": "        x = int(input(\"Please enter a number: \"))\n    break",
                              "successors": []
                            },
                            {
                              "id": 4,
                              "label": "    except ValueError:\n        print(\"Oops! That was no valid number. Try again...\")",
                              "successors": [
                                {
                                  "id": 1,
                                  "label": "while True:",
                                  "successors": [
                                    {
                                      "id": 2,
                                      "label": "    try:",
                                      "successors": [
                                        {
                                          "id": 3,
                                          "label": "        x = int(input(\"Please enter a number: \"))\n    break",
                                          "successors": []
                                        },
                                        {
                                          "id": 4,
                                          "label": "    except ValueError:\n        print(\"Oops! That was no valid number. Try again...\")",
                                          "successors": [
                                            {
                                              "id": 1,
                                              "label": "while True:",
                                              "successors": [
                                                {
                                                  "id": 2,
                                                  "label": "    try:",
                                                  "successors": [
                                                    {
                                                      "id": 3,
                                                      "label": "        x = int(input(\"Please enter a number: \"))\n    break",
                                                      "successors": []
                                                    },
                                                    {
                                                      "id": 4,
                                                      "label": "    except ValueError:\n        print(\"Oops! That was no valid number. Try again...\")",
                                                      "successors": []
                                                    }
                                                  ]
                                                }
                                              ]
                                            }
                                          ]
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "ScrollableTooltipDemo",
      "type": "class",
      "start_line": 1342,
      "end_line": 1355,
      "functions": [
        {
          "name": "scrollDown",
          "type": "function",
          "start_line": 1347,
          "end_line": 1355,
          "functions": [],
          "classes": [],
          "simplified_code": "  scrollDown() {\n    const scrollingContainerEl = this.scrollingContainer.getElementRef().nativeElement;\n    scrollingContainerEl.scrollTop = 250;\n    // Emit a scroll event from the scrolling element in our component.\n    // This event should be picked up by the scrollable directive and notify.\n    // The notification should be picked up by the service.\n    dispatchFakeEvent(scrollingContainerEl, 'scroll');\n  }\n}",
          "blocks": [
            {
              "id": 1,
              "label": "scrollDown() {\nconst scrollingContainerEl = this.scrollingContainer.getElementRef().nativeElement;",
              "successors": [
                {
                  "id": 3,
                  "label": "scrollingContainerEl.scrollTop = 250;\ndispatchFakeEvent(scrollingContainerEl, 'scroll');",
                  "successors": [
                    {
                      "id": 5,
                      "label": "}",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "simplified_code": "class ScrollableTooltipDemo {\n  position: string = 'below';\n  message: string = initialTooltipMessage;\n  showButton: boolean = true;\n  @ViewChild(CdkScrollable) scrollingContainer: CdkScrollable;\n}",
      "blocks": [
        {
          "id": 1,
          "label": "class ScrollableTooltipDemo {\nposition: string = 'below';",
          "successors": [
            {
              "id": 3,
              "label": "message: string = initialTooltipMessage;\nshowButton: boolean = true;",
              "successors": [
                {
                  "id": 5,
                  "label": "@ViewChild(CdkScrollable) scrollingContainer: CdkScrollable;",
                  "successors": []
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "OnPushTooltipDemo",
      "type": "class",
      "start_line": 1367,
      "end_line": 1370,
      "functions": [
        {
          "name": "",
          "type": "constructor",
          "start_line": 1367,
          "end_line": 1370,
          "functions": [],
          "classes": [],
          "simplified_code": "class OnPushTooltipDemo {\n  position: string = 'below';\n  message: string = initialTooltipMessage;\n}",
          "blocks": [
            {
              "id": 1,
              "label": "class OnPushTooltipDemo {",
              "successors": [
                {
                  "id": 2,
                  "label": "position: string = 'below';",
                  "successors": []
                },
                {
                  "id": 3,
                  "label": "message: string = initialTooltipMessage;",
                  "successors": []
                }
              ]
            }
          ]
        }
      ],
      "simplified_code": "}",
      "blocks": [
        {
          "id": 1,
          "label": "if a > 2:",
          "successors": [
            {
              "id": 2,
              "label": "    print(a)\nprint(\"done\")",
              "successors": []
            },
            {
              "id": 3,
              "label": "    print(1)\nprint(\"done\")",
              "successors": []
            }
          ]
        }
      ]
    },
    {
      "name": "DynamicTooltipsDemo",
      "type": "class",
      "start_line": 1381,
      "end_line": 1383,
      "functions": [
        {
          "name": "",
          "type": "constructor",
          "start_line": 1381,
          "end_line": 1383,
          "functions": [],
          "classes": [],
          "simplified_code": "class DynamicTooltipsDemo {\n  tooltips: string[] = [];\n}",
          "blocks": [
            {
              "id": 1,
              "label": "class DynamicTooltipsDemo {\ntooltips: string[] = [];",
              "successors": [
                {
                  "id": 3,
                  "label": "}",
                  "successors": []
                }
              ]
            }
          ]
        }
      ],
      "simplified_code": "}",
      "blocks": [
        {
          "id": 1,
          "label": "if a > 2:",
          "successors": [
            {
              "id": 2,
              "label": "    print(a)\nprint(\"done\")",
              "successors": []
            },
            {
              "id": 3,
              "label": "    print(1)\nprint(\"done\")",
              "successors": []
            }
          ]
        }
      ]
    },
    {
      "name": "DataBoundAriaLabelTooltip",
      "type": "class",
      "start_line": 1389,
      "end_line": 1391,
      "functions": [
        {
          "name": "",
          "type": "constructor",
          "start_line": 1389,
          "end_line": 1391,
          "functions": [],
          "classes": [],
          "simplified_code": "class DataBoundAriaLabelTooltip {\n  message = 'Hello there';\n}",
          "blocks": [
            {
              "id": 1,
              "label": "class DataBoundAriaLabelTooltip {\n  message = 'Hello there';",
              "successors": []
            }
          ]
        }
      ],
      "simplified_code": "}",
      "blocks": [
        {
          "id": 1,
          "label": "if a > 2:",
          "successors": [
            {
              "id": 2,
              "label": "    print(a)\nprint(\"done\")",
              "successors": []
            },
            {
              "id": 3,
              "label": "    print(1)\nprint(\"done\")",
              "successors": []
            }
          ]
        }
      ]
    },
    {
      "name": "TooltipOnTextFields",
      "type": "class",
      "start_line": 1406,
      "end_line": 1410,
      "functions": [
        {
          "name": "",
          "type": "constructor",
          "start_line": 1406,
          "end_line": 1410,
          "functions": [],
          "classes": [],
          "simplified_code": "class TooltipOnTextFields {\n  @ViewChild('input') input: ElementRef<HTMLInputElement>;\n  @ViewChild('textarea') textarea: ElementRef<HTMLTextAreaElement>;\n  touchGestures: TooltipTouchGestures = 'auto';\n}",
          "blocks": [
            {
              "id": 1,
              "label": "class TooltipOnTextFields {\n@ViewChild('input') input: ElementRef<HTMLInputElement>;",
              "successors": [
                {
                  "id": 3,
                  "label": "@ViewChild('textarea') textarea: ElementRef<HTMLTextAreaElement>;\ntouchGestures: TooltipTouchGestures = 'auto';",
                  "successors": [
                    {
                      "id": 5,
                      "label": "",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "simplified_code": "}",
      "blocks": []
    },
    {
      "name": "TooltipOnDraggableElement",
      "type": "class",
      "start_line": 1422,
      "end_line": 1424,
      "functions": [
        {
          "name": "",
          "type": "constructor",
          "start_line": 1422,
          "end_line": 1424,
          "functions": [],
          "classes": [],
          "simplified_code": "class TooltipOnDraggableElement {\n  @ViewChild('button') button: ElementRef;\n  touchGestures: TooltipTouchGestures = 'auto';",
          "blocks": [
            {
              "id": 1,
              "label": "class TooltipOnDraggableElement {\n  @ViewChild('button') button: ElementRef;\n  touchGestures: TooltipTouchGestures = 'auto';",
              "successors": []
            }
          ]
        }
      ],
      "simplified_code": "  touchGestures: TooltipTouchGestures = 'auto';",
      "blocks": [
        {
          "id": 1,
          "label": "touchGestures: TooltipTouchGestures = 'auto';",
          "successors": []
        }
      ]
    },
    {
      "name": "TooltipDemoWithoutPositionBinding",
      "type": "class",
      "start_line": 1431,
      "end_line": 1434,
      "functions": [
        {
          "name": "",
          "type": "constructor",
          "start_line": 1431,
          "end_line": 1434,
          "functions": [],
          "classes": [],
          "simplified_code": "class TooltipDemoWithoutPositionBinding {\n  message: any = initialTooltipMessage;\n  @ViewChild(MatTooltip) tooltip: MatTooltip;\n  @ViewChild('button') button: ElementRef<HTMLButtonElement>;",
          "blocks": [
            {
              "id": 1,
              "label": "class TooltipDemoWithoutPositionBinding {\n  message: any = initialTooltipMessage;",
              "successors": [
                {
                  "id": 3,
                  "label": "@ViewChild(MatTooltip) tooltip: MatTooltip;\n@ViewChild('button') button: ElementRef<HTMLButtonElement>;",
                  "successors": []
                }
              ]
            }
          ]
        }
      ],
      "simplified_code": "  @ViewChild('button') button: ElementRef<HTMLButtonElement>;",
      "blocks": [
        {
          "id": 1,
          "label": "@ViewChild('button') button: ElementRef<HTMLButtonElement>;",
          "successors": []
        }
      ]
    },
    {
      "name": "TooltipDemoWithoutTooltipClassBinding",
      "type": "class",
      "start_line": 1441,
      "end_line": 1444,
      "functions": [
        {
          "name": "",
          "type": "constructor",
          "start_line": 1441,
          "end_line": 1444,
          "functions": [],
          "classes": [],
          "simplified_code": "class TooltipDemoWithoutTooltipClassBinding {\n  message = initialTooltipMessage;\n  @ViewChild(MatTooltip) tooltip: MatTooltip;\n  @ViewChild('button') button: ElementRef<HTMLButtonElement>;",
          "blocks": [
            {
              "id": 1,
              "label": "class TooltipDemoWithoutTooltipClassBinding {\n  message = initialTooltipMessage;",
              "successors": [
                {
                  "id": 3,
                  "label": "@ViewChild(MatTooltip) tooltip: MatTooltip;\n@ViewChild('button') button: ElementRef<HTMLButtonElement>;",
                  "successors": []
                }
              ]
            }
          ]
        }
      ],
      "simplified_code": "  @ViewChild('button') button: ElementRef<HTMLButtonElement>;",
      "blocks": []
    },
    {
      "name": "TooltipDemoWithTooltipClassBinding",
      "type": "class",
      "start_line": 1453,
      "end_line": 1456,
      "functions": [
        {
          "name": "",
          "type": "constructor",
          "start_line": 1453,
          "end_line": 1456,
          "functions": [],
          "classes": [],
          "simplified_code": "class TooltipDemoWithTooltipClassBinding {\n  message: any = initialTooltipMessage;\n  @ViewChild(MatTooltip) tooltip: MatTooltip;\n  @ViewChild('button') button: ElementRef<HTMLButtonElement>;",
          "blocks": [
            {
              "id": 1,
              "label": "message: any = initialTooltipMessage;",
              "successors": []
            }
          ]
        }
      ],
      "simplified_code": "  @ViewChild('button') button: ElementRef<HTMLButtonElement>;",
      "blocks": [
        {
          "id": 1,
          "label": "@ViewChild('button') button: ElementRef<HTMLButtonElement>;",
          "successors": []
        }
      ]
    },
    {
      "name": "WideTooltipDemo",
      "type": "class",
      "start_line": 1464,
      "end_line": 1467,
      "functions": [
        {
          "name": "",
          "type": "constructor",
          "start_line": 1464,
          "end_line": 1467,
          "functions": [],
          "classes": [],
          "simplified_code": "class WideTooltipDemo {\n  message = 'Test';\n  @ViewChild(MatTooltip) tooltip: MatTooltip;\n  @ViewChild('button') button: ElementRef<HTMLButtonElement>;",
          "blocks": [
            {
              "id": 1,
              "label": "class WideTooltipDemo {\n  message = 'Test';",
              "successors": [
                {
                  "id": 3,
                  "label": "@ViewChild(MatTooltip) tooltip: MatTooltip;\n@ViewChild('button') button: ElementRef<HTMLButtonElement>;",
                  "successors": [
                    {
                      "id": 5,
                      "label": "}",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "simplified_code": "  @ViewChild('button') button: ElementRef<HTMLButtonElement>;",
      "blocks": [
        {
          "id": 1,
          "label": "@ViewChild('button') button: ElementRef<HTMLButtonElement>;",
          "successors": []
        }
      ]
    },
    {
      "name": "assertTooltipInstance",
      "type": "class",
      "start_line": 1469,
      "end_line": 1473,
      "functions": [
        {
          "name": "",
          "type": "constructor",
          "start_line": 1469,
          "end_line": 1473,
          "functions": [],
          "classes": [],
          "simplified_code": "function assertTooltipInstance(tooltip: MatTooltip, shouldExist: boolean): void {\n  // Note that we have to cast this to a boolean, because Jasmine will go into an infinite loop\n  // if it tries to stringify the `_tooltipInstance` when an assertion fails. The infinite loop\n  // happens due to the `_tooltipInstance` having a circular structure.\n  expect(!!tooltip._tooltipInstance).toBe(shouldExist);",
          "blocks": [
            {
              "id": 1,
              "label": "function assertTooltipInstance(tooltip: MatTooltip, shouldExist: boolean): void {\n// Note that we have to cast this to a boolean, because Jasmine will go into an infinite loop\n  // if it tries to stringify the `_tooltipInstance` when an assertion fails. The infinite loop\n  // happens due to the `_tooltipInstance` having a circular structure.",
              "successors": [
                {
                  "id": 3,
                  "label": "expect(!!tooltip._tooltipInstance).toBe(shouldExist);",
                  "successors": []
                }
              ]
            }
          ]
        }
      ],
      "simplified_code": "  expect(!!tooltip._tooltipInstance).toBe(shouldExist);",
      "blocks": [
        {
          "id": 1,
          "label": "expect(!!tooltip._tooltipInstance).toBe(shouldExist);",
          "successors": []
        }
      ]
    },
    {
      "name": "finishCurrentTooltipAnimation",
      "type": "class",
      "start_line": 1475,
      "end_line": 1482,
      "functions": [
        {
          "name": "",
          "type": "constructor",
          "start_line": 1475,
          "end_line": 1482,
          "functions": [],
          "classes": [],
          "simplified_code": "function finishCurrentTooltipAnimation(overlayContainer: HTMLElement, isVisible: boolean) {\n  const tooltip = overlayContainer.querySelector('.mat-mdc-tooltip')!;\n  const event = createFakeEvent('animationend');\n  Object.defineProperty(event, 'animationName', {\n    get: () => `mat-mdc-tooltip-${isVisible ? 'show' : 'hide'}`,\n  });\n  dispatchEvent(tooltip, event);\n}",
          "blocks": [
            {
              "id": 1,
              "label": "function finishCurrentTooltipAnimation(overlayContainer: HTMLElement, isVisible: boolean) {\n  const tooltip = overlayContainer.querySelector('.mat-mdc-tooltip')!;",
              "successors": [
                {
                  "id": 3,
                  "label": "  const event = createFakeEvent('animationend');\n  Object.defineProperty(event, 'animationName', {",
                  "successors": [
                    {
                      "id": 5,
                      "label": "    get: () => `mat-mdc-tooltip-${isVisible ? 'show' : 'hide'}`,\n  });",
                      "successors": [
                        {
                          "id": 7,
                          "label": "  dispatchEvent(tooltip, event);\n}",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "simplified_code": "}",
      "blocks": []
    }
  ],
  "simplified_code": "import {FocusMonitor} from '@angular/cdk/a11y';\nimport {Direction, Directionality} from '@angular/cdk/bidi';\nimport {ESCAPE} from '@angular/cdk/keycodes';\nimport {CdkScrollable, OverlayContainer, OverlayModule} from '@angular/cdk/overlay';\nimport {Platform} from '@angular/cdk/platform';\nimport {\n  createFakeEvent,\n  createKeyboardEvent,\n  createMouseEvent,\n  dispatchEvent,\n  dispatchFakeEvent,\n  dispatchKeyboardEvent,\n  dispatchMouseEvent,\n  patchElementFocus,\n} from '@angular/cdk/testing/private';\nimport {\n  ChangeDetectionStrategy,\n  Component,\n  DebugElement,\n  ElementRef,\n  ViewChild,\n} from '@angular/core';\nimport {\n  ComponentFixture,\n  TestBed,\n  fakeAsync,\n  flush,\n  inject,\n  tick,\n  waitForAsync,\n} from '@angular/core/testing';\nimport {By} from '@angular/platform-browser';\nimport {NoopAnimationsModule} from '@angular/platform-browser/animations';\nimport {Subject} from 'rxjs';\nimport {\n  MAT_TOOLTIP_DEFAULT_OPTIONS,\n  MatTooltip,\n  MatTooltipModule,\n  SCROLL_THROTTLE_MS,\n  TooltipPosition,\n  TooltipTouchGestures,\n} from './index';\nconst initialTooltipMessage = 'initial tooltip message';\ndescribe('MatTooltip', () => {\n  let overlayContainerElement: HTMLElement;\n  let dir: {value: Direction; change: Subject<Direction>};\n  let platform: Platform;\n  let focusMonitor: FocusMonitor;\n  }));\n  describe('basic usage', () => {\n    let fixture: ComponentFixture<BasicTooltipDemo>;\n    let buttonDebugElement: DebugElement;\n    let buttonElement: HTMLButtonElement;\n    let tooltipDirective: MatTooltip;\n    beforeEach(fakeAsync(() => {\n      fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      tick();\n      buttonDebugElement = fixture.debugElement.query(By.css('button'))!;\n      buttonElement = buttonDebugElement.nativeElement;\n      tooltipDirective = buttonDebugElement.injector.get<MatTooltip>(MatTooltip);\n    }));\n    }));\n    }));\n      expect(overlayContainerElement.textContent).toContain(initialTooltipMessage);\n    }));\n      flush();\n    }));\n    }));\n    }));\n    }));\n    }));\n    });\n    }));\n    }));\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n    }));\n    }));\n    }));\n    }));\n    });\n    }));\n    }));\n    }));\n    }));\n    }));\n    }));\n    }));\n    }));\n    }));\n      expect(buttonElement.getAttribute('aria-describedby')).toBeTruthy();\n    }));\n    }));\n    }));\n    });\n    });\n    });\n        .toBe('rtl');\n    }));\n      flush();\n    }));\n    }));\n    }));\n    }));\n    }));\n    }));\n    }));\n    }));\n    }));\n    }));\n      expect(overlayContainerElement.querySelector('.mat-mdc-tooltip')).toBeNull();\n    }));\n    }));\n    }));\n    }));\n    }));\n    }));\n    }));\n    }));\n    }));\n    }));\n    }));\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n    }));\n  });\n  describe('fallback positions', () => {\n    let fixture: ComponentFixture<BasicTooltipDemo>;\n    let tooltip: MatTooltip;\n    beforeEach(() => {\n      fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      tooltip = fixture.debugElement.query(By.css('button'))!.injector.get<MatTooltip>(MatTooltip);\n    });\n    it('should set a fallback origin position by inverting the main origin position', () => {\n      tooltip.position = 'left';\n      expect(tooltip._getOrigin().main.originX).toBe('start');\n      expect(tooltip._getOrigin().fallback.originX).toBe('end');\n      tooltip.position = 'right';\n      expect(tooltip._getOrigin().main.originX).toBe('end');\n      expect(tooltip._getOrigin().fallback.originX).toBe('start');\n      tooltip.position = 'above';\n      expect(tooltip._getOrigin().main.originY).toBe('top');\n      expect(tooltip._getOrigin().fallback.originY).toBe('bottom');\n      tooltip.position = 'below';\n      expect(tooltip._getOrigin().main.originY).toBe('bottom');\n      expect(tooltip._getOrigin().fallback.originY).toBe('top');\n    });\n    it('should set a fallback overlay position by inverting the main overlay position', () => {\n      tooltip.position = 'left';\n      expect(tooltip._getOverlayPosition().main.overlayX).toBe('end');\n      expect(tooltip._getOverlayPosition().fallback.overlayX).toBe('start');\n      tooltip.position = 'right';\n      expect(tooltip._getOverlayPosition().main.overlayX).toBe('start');\n      expect(tooltip._getOverlayPosition().fallback.overlayX).toBe('end');\n      tooltip.position = 'above';\n      expect(tooltip._getOverlayPosition().main.overlayY).toBe('bottom');\n      expect(tooltip._getOverlayPosition().fallback.overlayY).toBe('top');\n      tooltip.position = 'below';\n      expect(tooltip._getOverlayPosition().main.overlayY).toBe('top');\n      expect(tooltip._getOverlayPosition().fallback.overlayY).toBe('bottom');\n    });\n  });\n  describe('scrollable usage', () => {\n    let fixture: ComponentFixture<ScrollableTooltipDemo>;\n    let buttonDebugElement: DebugElement;\n    let tooltipDirective: MatTooltip;\n    beforeEach(() => {\n      fixture = TestBed.createComponent(ScrollableTooltipDemo);\n      fixture.detectChanges();\n      buttonDebugElement = fixture.debugElement.query(By.css('button'))!;\n      tooltipDirective = buttonDebugElement.injector.get<MatTooltip>(MatTooltip);\n    });\n    it('should hide tooltip if clipped after changing positions', fakeAsync(() => {\n      assertTooltipInstance(tooltipDirective, false);\n      // Show the tooltip and tick for the show delay (default is 0)\n      tooltipDirective.show();\n      fixture.detectChanges();\n      tick(0);\n      // Expect that the tooltip is displayed\n      // Expect that the tooltip is displayed\n      expect(tooltipDirective._isTooltipVisible())\n        .withContext('Expected tooltip to be initially visible')\n        .toBe(true);\n      // Scroll the page but tick just before the default throttle should update.\n      fixture.componentInstance.scrollDown();\n      tick(SCROLL_THROTTLE_MS - 1);\n      expect(tooltipDirective._isTooltipVisible())\n        .withContext('Expected tooltip to be visible when scrolling, before throttle limit')\n        .toBe(true);\n      // Finish ticking to the throttle's limit and check that the scroll event notified the\n      // tooltip and it was hidden.\n      tick(100);\n      fixture.detectChanges();\n      expect(tooltipDirective._isTooltipVisible())\n        .withContext('Expected tooltip hidden when scrolled out of view, after throttle limit')\n        .toBe(false);\n    }));\n  });\n  describe('with OnPush', () => {\n    let fixture: ComponentFixture<OnPushTooltipDemo>;\n    let buttonDebugElement: DebugElement;\n    let buttonElement: HTMLButtonElement;\n    let tooltipDirective: MatTooltip;\n    beforeEach(() => {\n      fixture = TestBed.createComponent(OnPushTooltipDemo);\n      fixture.detectChanges();\n      buttonDebugElement = fixture.debugElement.query(By.css('button'))!;\n      buttonElement = <HTMLButtonElement>buttonDebugElement.nativeElement;\n      tooltipDirective = buttonDebugElement.injector.get<MatTooltip>(MatTooltip);\n    });\n    it('should show and hide the tooltip', fakeAsync(() => {\n      assertTooltipInstance(tooltipDirective, false);\n      tooltipDirective.show();\n      tick(0); // Tick for the show delay (default is 0)\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      fixture.detectChanges();\n      // wait until animation has finished\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      // Make sure tooltip is shown to the user and animation has finished\n      const tooltipElement = overlayContainerElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;\n      expect(tooltipElement instanceof HTMLElement).toBe(true);\n      expect(tooltipElement.classList).toContain('mat-mdc-tooltip-show');\n      // After hide called, a timeout delay is created that will to hide the tooltip.\n      const tooltipDelay = 1000;\n      tooltipDirective.hide(tooltipDelay);\n      expect(tooltipDirective._isTooltipVisible()).toBe(true);\n      // After the tooltip delay elapses, expect that the tooltip is not visible.\n      tick(tooltipDelay);\n      fixture.detectChanges();\n      expect(tooltipDirective._isTooltipVisible()).toBe(false);\n      // On animation complete, should expect that the tooltip has been detached.\n      finishCurrentTooltipAnimation(overlayContainerElement, false);\n      assertTooltipInstance(tooltipDirective, false);\n      flush();\n    }));\n    it('should have rendered the tooltip text on init', fakeAsync(() => {\n      // We don't bind mouse events on mobile devices.\n      if (platform.IOS || platform.ANDROID) {\n        return;\n      }\n      dispatchFakeEvent(buttonElement, 'mouseenter');\n      fixture.detectChanges();\n      tick(0);\n      const tooltipElement = overlayContainerElement.querySelector(\n        '.mat-mdc-tooltip',\n      ) as HTMLElement;\n      expect(tooltipElement.textContent).toContain('initial tooltip message');\n    }));\n  });\n  describe('touch gestures', () => {\n    beforeEach(() => {\n      platform.ANDROID = true;\n    });\n    it('should have a delay when showing on touchstart', fakeAsync(() => {\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      const button: HTMLButtonElement = fixture.nativeElement.querySelector('button');\n      dispatchFakeEvent(button, 'touchstart');\n      fixture.detectChanges();\n      tick(250); // Halfway through the delay.\n      assertTooltipInstance(fixture.componentInstance.tooltip, false);\n      tick(500); // Finish the delay.\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true); // Finish the animation.\n      assertTooltipInstance(fixture.componentInstance.tooltip, true);\n      flush();\n    }));\n    it('should be able to disable opening on touch', fakeAsync(() => {\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.componentInstance.touchGestures = 'off';\n      fixture.detectChanges();\n      const button: HTMLButtonElement = fixture.nativeElement.querySelector('button');\n      dispatchFakeEvent(button, 'touchstart');\n      fixture.detectChanges();\n      tick(500); // Finish the delay.\n      fixture.detectChanges();\n      tick(500); // Finish the animation.\n      assertTooltipInstance(fixture.componentInstance.tooltip, false);\n    }));\n    it('should not prevent the default action on touchstart', () => {\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      const button: HTMLButtonElement = fixture.nativeElement.querySelector('button');\n      const event = dispatchFakeEvent(button, 'touchstart');\n      fixture.detectChanges();\n      expect(event.defaultPrevented).toBe(false);\n    });\n    it('should close on touchend with a delay', fakeAsync(() => {\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      const button: HTMLButtonElement = fixture.nativeElement.querySelector('button');\n      dispatchFakeEvent(button, 'touchstart');\n      fixture.detectChanges();\n      tick(500); // Finish the open delay.\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true); // Finish the animation.\n      assertTooltipInstance(fixture.componentInstance.tooltip, true);\n      dispatchFakeEvent(button, 'touchend');\n      fixture.detectChanges();\n      tick(1000); // 2/3 through the delay\n      assertTooltipInstance(fixture.componentInstance.tooltip, true);\n      tick(500); // Finish the delay.\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, false); // Finish the exit animation.\n      assertTooltipInstance(fixture.componentInstance.tooltip, false);\n      flush();\n    }));\n    it('should close on touchcancel with a delay', fakeAsync(() => {\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      const button: HTMLButtonElement = fixture.nativeElement.querySelector('button');\n      dispatchFakeEvent(button, 'touchstart');\n      fixture.detectChanges();\n      tick(500); // Finish the open delay.\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true); // Finish the animation.\n      assertTooltipInstance(fixture.componentInstance.tooltip, true);\n      dispatchFakeEvent(button, 'touchcancel');\n      fixture.detectChanges();\n      tick(1000); // 2/3 through the delay\n      assertTooltipInstance(fixture.componentInstance.tooltip, true);\n      tick(500); // Finish the delay.\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, false); // Finish the exit animation.\n      assertTooltipInstance(fixture.componentInstance.tooltip, false);\n      flush();\n    }));\n    it('should disable native touch interactions', () => {\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      const styles = fixture.nativeElement.querySelector('button').style;\n      expect(styles.touchAction || (styles as any).webkitUserDrag).toBe('none');\n    });\n    it('should allow native touch interactions if touch gestures are turned off', () => {\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.componentInstance.touchGestures = 'off';\n      fixture.detectChanges();\n      const styles = fixture.nativeElement.querySelector('button').style;\n      expect(styles.touchAction || (styles as any).webkitUserDrag).toBeFalsy();\n    });\n    it('should allow text selection on inputs when gestures are set to auto', () => {\n      const fixture = TestBed.createComponent(TooltipOnTextFields);\n      fixture.detectChanges();\n      const inputStyle = fixture.componentInstance.input.nativeElement.style;\n      const textareaStyle = fixture.componentInstance.textarea.nativeElement.style;\n      expect(inputStyle.userSelect).toBeFalsy();\n      expect(inputStyle.webkitUserSelect).toBeFalsy();\n      expect((inputStyle as any).msUserSelect).toBeFalsy();\n      expect((inputStyle as any).MozUserSelect).toBeFalsy();\n      expect(textareaStyle.userSelect).toBeFalsy();\n      expect(textareaStyle.webkitUserSelect).toBeFalsy();\n      expect((textareaStyle as any).msUserSelect).toBeFalsy();\n      expect((textareaStyle as any).MozUserSelect).toBeFalsy();\n    });\n    it('should disable text selection on inputs when gestures are set to on', () => {\n      const fixture = TestBed.createComponent(TooltipOnTextFields);\n      fixture.componentInstance.touchGestures = 'on';\n      fixture.detectChanges();\n      const inputStyle = fixture.componentInstance.input.nativeElement.style;\n      const inputUserSelect =\n        inputStyle.userSelect ||\n        inputStyle.webkitUserSelect ||\n        (inputStyle as any).msUserSelect ||\n        (inputStyle as any).MozUserSelect;\n      const textareaStyle = fixture.componentInstance.textarea.nativeElement.style;\n      const textareaUserSelect =\n        textareaStyle.userSelect ||\n        textareaStyle.webkitUserSelect ||\n        (textareaStyle as any).msUserSelect ||\n        (textareaStyle as any).MozUserSelect;\n      expect(inputUserSelect).toBe('none');\n      expect(textareaUserSelect).toBe('none');\n    });\n    it('should allow native dragging on draggable elements when gestures are set to auto', () => {\n      const fixture = TestBed.createComponent(TooltipOnDraggableElement);\n      fixture.detectChanges();\n      expect(fixture.componentInstance.button.nativeElement.style.webkitUserDrag).toBeFalsy();\n    });\n    it('should disable native dragging on draggable elements when gestures are set to on', () => {\n      const fixture = TestBed.createComponent(TooltipOnDraggableElement);\n      fixture.componentInstance.touchGestures = 'on';\n      fixture.detectChanges();\n      const styles = fixture.componentInstance.button.nativeElement.style;\n      if ('webkitUserDrag' in styles) {\n        expect(styles.webkitUserDrag).toBe('none');\n      }\n    });\n    it('should not open on `mouseenter` on iOS', () => {\n      platform.IOS = true;\n      platform.ANDROID = false;\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      dispatchMouseEvent(fixture.componentInstance.button.nativeElement, 'mouseenter');\n      fixture.detectChanges();\n      assertTooltipInstance(fixture.componentInstance.tooltip, false);\n    });\n    it('should not open on `mouseenter` on Android', () => {\n      platform.ANDROID = true;\n      platform.IOS = false;\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      dispatchMouseEvent(fixture.componentInstance.button.nativeElement, 'mouseenter');\n      fixture.detectChanges();\n      assertTooltipInstance(fixture.componentInstance.tooltip, false);\n    });\n  });\n  describe('mouse wheel handling', () => {\n    it('should close when a wheel event causes the cursor to leave the trigger', fakeAsync(() => {\n      // We don't bind wheel events on mobile devices.\n      if (platform.IOS || platform.ANDROID) {\n        return;\n      }\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      const button: HTMLButtonElement = fixture.nativeElement.querySelector('button');\n      dispatchFakeEvent(button, 'mouseenter');\n      fixture.detectChanges();\n      tick(500); // Finish the open delay.\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      assertTooltipInstance(fixture.componentInstance.tooltip, true);\n      // Simulate the pointer at the bottom/right of the page.\n      const wheelEvent = createFakeEvent('wheel');\n      Object.defineProperties(wheelEvent, {\n        clientX: {get: () => window.innerWidth},\n        clientY: {get: () => window.innerHeight},\n      });\n      dispatchEvent(button, wheelEvent);\n      fixture.detectChanges();\n      tick(1500); // Finish the delay.\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, false);\n      assertTooltipInstance(fixture.componentInstance.tooltip, false);\n      flush();\n    }));\n    it('should not close if the cursor is over the trigger after a wheel event', fakeAsync(() => {\n      // We don't bind wheel events on mobile devices.\n      if (platform.IOS || platform.ANDROID) {\n        return;\n      }\n      const fixture = TestBed.createComponent(BasicTooltipDemo);\n      fixture.detectChanges();\n      const button: HTMLButtonElement = fixture.nativeElement.querySelector('button');\n      dispatchFakeEvent(button, 'mouseenter');\n      fixture.detectChanges();\n      tick(500); // Finish the open delay.\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, true);\n      assertTooltipInstance(fixture.componentInstance.tooltip, true);\n      // Simulate the pointer over the trigger.\n      const triggerRect = button.getBoundingClientRect();\n      const wheelEvent = createFakeEvent('wheel');\n      Object.defineProperties(wheelEvent, {\n        clientX: {get: () => triggerRect.left + 1},\n        clientY: {get: () => triggerRect.top + 1},\n      });\n      dispatchEvent(button, wheelEvent);\n      fixture.detectChanges();\n      tick(1500); // Finish the delay.\n      fixture.detectChanges();\n      finishCurrentTooltipAnimation(overlayContainerElement, false);\n      assertTooltipInstance(fixture.componentInstance.tooltip, true);\n      flush();\n    }));\n  });\n});\n@Component({\n  selector: 'app',\n  template: `\n    @if (showButton) {\n      <button #button\n        [matTooltip]=\"message\"\n        [matTooltipPosition]=\"position\"\n        [matTooltipClass]=\"{'custom-one': showTooltipClass, 'custom-two': showTooltipClass}\"\n        [matTooltipTouchGestures]=\"touchGestures\"\n        [matTooltipDisabled]=\"tooltipDisabled\">Button</button>\n    }`,\n  standalone: true,\n  imports: [MatTooltipModule, OverlayModule],\n})\n}\n@Component({\n  selector: 'app',\n  template: `\n    <div cdkScrollable style=\"padding: 100px; margin: 300px;\n                               height: 200px; width: 200px; overflow: auto;\">\n      @if (showButton) {\n        <button style=\"margin-bottom: 600px\"\n              [matTooltip]=\"message\"\n              [matTooltipPosition]=\"position\">Button</button>\n      }\n    </div>`,\n  standalone: true,\n  imports: [MatTooltipModule, OverlayModule],\n})\n}\n@Component({\n  selector: 'app',\n  template: `\n    <button [matTooltip]=\"message\"\n            [matTooltipPosition]=\"position\">\n      Button\n    </button>`,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  standalone: true,\n  imports: [MatTooltipModule, OverlayModule],\n})\n}\n@Component({\n  selector: 'app',\n  template: `\n    @for (tooltip of tooltips; track tooltip) {\n      <button [matTooltip]=\"tooltip\">Button {{tooltip}}</button>\n    }\n  `,\n  standalone: true,\n  imports: [MatTooltipModule, OverlayModule],\n})\n}\n@Component({\n  template: `<button [matTooltip]=\"message\" [attr.aria-label]=\"message\">Click me</button>`,\n  standalone: true,\n  imports: [MatTooltipModule, OverlayModule],\n})\n}\n@Component({\n  template: `\n    <input\n      #input\n      matTooltip=\"Something\"\n      [matTooltipTouchGestures]=\"touchGestures\">\n    <textarea\n      #textarea\n      matTooltip=\"Another thing\"\n      [matTooltipTouchGestures]=\"touchGestures\"></textarea>\n  `,\n  standalone: true,\n  imports: [MatTooltipModule, OverlayModule],\n})\n}\n@Component({\n  template: `\n    <button\n      #button\n      draggable=\"true\"\n      matTooltip=\"Drag me\"\n      [matTooltipTouchGestures]=\"touchGestures\"></button>\n  `,\n  standalone: true,\n  imports: [MatTooltipModule, OverlayModule],\n})\n  touchGestures: TooltipTouchGestures = 'auto';\n}\n@Component({\n  selector: 'app',\n  template: `<button #button [matTooltip]=\"message\">Button</button>`,\n  standalone: false,\n})\n  @ViewChild('button') button: ElementRef<HTMLButtonElement>;\n}\n@Component({\n  selector: 'app',\n  template: `<button #button [matTooltip]=\"message\">Button</button>`,\n  standalone: false,\n})\n  @ViewChild('button') button: ElementRef<HTMLButtonElement>;\n}\n@Component({\n  selector: 'app',\n  template: `\n    <button #button matTooltipClass=\"fixed-tooltip-class\" [matTooltip]=\"message\">Button</button>\n  `,\n  standalone: false,\n})\n  @ViewChild('button') button: ElementRef<HTMLButtonElement>;\n}\n@Component({\n  selector: 'app',\n  styles: `button { width: 500px; height: 500px; }`,\n  template: `<button #button [matTooltip]=\"message\">Button</button>`,\n  standalone: false,\n})\n  @ViewChild('button') button: ElementRef<HTMLButtonElement>;\n}\n  expect(!!tooltip._tooltipInstance).toBe(shouldExist);\n}\n}",
  "blocks": [
    {
      "id": 1,
      "label": "import {FocusMonitor} from '@angular/cdk/a11y'; import {Direction, Directionality} from '@angular/cdk/bidi'; import {ESCAPE} from '@angular/cdk/keycodes'; import {CdkScrollable, OverlayContainer, OverlayModule} from '@angular/cdk/overlay'; import {Platform} from '@angular/cdk/platform'; import { createFakeEvent, createKeyboardEvent, createMouseEvent, dispatchEvent, dispatchFakeEvent, dispatchKeyboardEvent, dispatchMouseEvent, patchElementFocus, } from '@angular/cdk/testing/private'; import { ChangeDetectionStrategy, Component, DebugElement, ElementRef, ViewChild, } from '@angular/core'; import { ComponentFixture, TestBed, fakeAsync, flush, inject, tick, waitForAsync, } from '@angular/core/testing'; import {By} from '@angular/platform-browser'; import {NoopAnimationsModule} from '@angular/platform-browser/animations'; import {Subject} from 'rxjs'; import { MAT_TOOLTIP_DEFAULT_OPTIONS, MatTooltip, MatTooltipModule, SCROLL_THROTTLE_MS, TooltipPosition, TooltipTouchGestures, } from './index'; const initialTooltipMessage = 'initial tooltip message';\ndescribe('MatTooltip', () => { let overlayContainerElement: HTMLElement; let dir: {value: Direction; change: Subject<Direction>}; let platform: Platform; let focusMonitor: FocusMonitor; });",
      "successors": [
        {
          "id": 3,
          "label": "describe('basic usage', () => { let fixture: ComponentFixture<BasicTooltipDemo>; let buttonDebugElement: DebugElement; let buttonElement: HTMLButtonElement; let tooltipDirective: MatTooltip; });\nbeforeEach(fakeAsync(() => { fixture = TestBed.createComponent(BasicTooltipDemo); fixture.detectChanges(); tick(); buttonDebugElement = fixture.debugElement.query(By.css('button'))!; buttonElement = buttonDebugElement.nativeElement; tooltipDirective = buttonDebugElement.injector.get<MatTooltip>(MatTooltip); }));",
          "successors": [
            {
              "id": 5,
              "label": "expect(overlayContainerElement.textContent).toContain(initialTooltipMessage);",
              "successors": []
            },
            {
              "id": 6,
              "label": "flush();",
              "successors": []
            },
            {
              "id": 7,
              "label": "expect(tooltipDirective._isTooltipVisible()).toBe(true);",
              "successors": []
            },
            {
              "id": 8,
              "label": "expect(buttonElement.getAttribute('aria-describedby')).toBeTruthy();",
              "successors": []
            },
            {
              "id": 9,
              "label": "expect(overlayContainerElement.querySelector('.mat-mdc-tooltip')).toBeNull();",
              "successors": []
            }
          ]
        },
        {
          "id": 10,
          "label": "describe('fallback positions', () => { let fixture: ComponentFixture<BasicTooltipDemo>; let tooltip: MatTooltip; });\nbeforeEach(() => { fixture = TestBed.createComponent(BasicTooltipDemo); fixture.detectChanges(); tooltip = fixture.debugElement.query(By.css('button'))!.injector.get<MatTooltip>(MatTooltip); });",
          "successors": [
            {
              "id": 12,
              "label": "it('should set a fallback origin position by inverting the main origin position', () => { tooltip.position = 'left'; expect(tooltip._getOrigin().main.originX).toBe('start'); expect(tooltip._getOrigin().fallback.originX).toBe('end'); tooltip.position = 'right'; expect(tooltip._getOrigin().main.originX).toBe('end'); expect(tooltip._getOrigin().fallback.originX).toBe('start'); tooltip.position = 'above'; expect(tooltip._getOrigin().main.originY).toBe('top'); expect(tooltip._getOrigin().fallback.originY).toBe('bottom'); tooltip.position = 'below'; expect(tooltip._getOrigin().main.originY).toBe('bottom'); expect(tooltip._getOrigin().fallback.originY).toBe('top'); });",
              "successors": []
            },
            {
              "id": 13,
              "label": "it('should set a fallback overlay position by inverting the main overlay position', () => { tooltip.position = 'left'; expect(tooltip._getOverlayPosition().main.overlayX).toBe('end'); expect(tooltip._getOverlayPosition().fallback.overlayX).toBe('start'); tooltip.position = 'right'; expect(tooltip._getOverlayPosition().main.overlayX).toBe('start'); expect(tooltip._getOverlayPosition().fallback.overlayX).toBe('end'); tooltip.position = 'above'; expect(tooltip._getOverlayPosition().main.overlayY).toBe('bottom'); expect(tooltip._getOverlayPosition().fallback.overlayY).toBe('top'); tooltip.position = 'below'; expect(tooltip._getOverlayPosition().main.overlayY).toBe('top'); expect(tooltip._getOverlayPosition().fallback.overlayY).toBe('bottom'); });",
              "successors": []
            }
          ]
        },
        {
          "id": 14,
          "label": "describe('scrollable usage', () => { let fixture: ComponentFixture<ScrollableTooltipDemo>; let buttonDebugElement: DebugElement; let tooltipDirective: MatTooltip; });\nbeforeEach(() => { fixture = TestBed.createComponent(ScrollableTooltipDemo); fixture.detectChanges(); buttonDebugElement = fixture.debugElement.query(By.css('button'))!; tooltipDirective = buttonDebugElement.injector.get<MatTooltip>(MatTooltip); });",
          "successors": [
            {
              "id": 16,
              "label": "it('should hide tooltip if clipped after changing positions', fakeAsync(() => { assertTooltipInstance(tooltipDirective, false); tooltipDirective.show(); fixture.detectChanges(); tick(0); expect(tooltipDirective._isTooltipVisible()).withContext('Expected tooltip to be initially visible').toBe(true); fixture.componentInstance.scrollDown(); tick(SCROLL_THROTTLE_MS - 1); expect(tooltipDirective._isTooltipVisible()).withContext('Expected tooltip to be visible when scrolling, before throttle limit').toBe(true); tick(100); fixture.detectChanges(); expect(tooltipDirective._isTooltipVisible()).withContext('Expected tooltip hidden when scrolled out of view, after throttle limit').toBe(false); }));",
              "successors": []
            }
          ]
        },
        {
          "id": 17,
          "label": "describe('with OnPush', () => { let fixture: ComponentFixture<OnPushTooltipDemo>; let buttonDebugElement: DebugElement; let buttonElement: HTMLButtonElement; let tooltipDirective: MatTooltip; });\nbeforeEach(() => { fixture = TestBed.createComponent(OnPushTooltipDemo); fixture.detectChanges(); buttonDebugElement = fixture.debugElement.query(By.css('button'))!; buttonElement = <HTMLButtonElement>buttonDebugElement.nativeElement; tooltipDirective = buttonDebugElement.injector.get<MatTooltip>(MatTooltip); });",
          "successors": [
            {
              "id": 19,
              "label": "it('should show and hide the tooltip', fakeAsync(() => { assertTooltipInstance(tooltipDirective, false); tooltipDirective.show(); tick(0); expect(tooltipDirective._isTooltipVisible()).toBe(true); fixture.detectChanges(); finishCurrentTooltipAnimation(overlayContainerElement, true); const tooltipElement = overlayContainerElement.querySelector('.mat-mdc-tooltip') as HTMLElement; expect(tooltipElement instanceof HTMLElement).toBe(true); expect(tooltipElement.classList).toContain('mat-mdc-tooltip-show'); const tooltipDelay = 1000; tooltipDirective.hide(tooltipDelay); expect(tooltipDirective._isTooltipVisible()).toBe(true); tick(tooltipDelay); fixture.detectChanges(); expect(tooltipDirective._isTooltipVisible()).toBe(false); finishCurrentTooltipAnimation(overlayContainerElement, false); assertTooltipInstance(tooltipDirective, false); flush(); }));",
              "successors": []
            },
            {
              "id": 20,
              "label": "it('should have rendered the tooltip text on init', fakeAsync(() => { dispatchFakeEvent(buttonElement, 'mouseenter'); fixture.detectChanges(); tick(0); const tooltipElement = overlayContainerElement.querySelector('.mat-mdc-tooltip') as HTMLElement; expect(tooltipElement.textContent).toContain('initial tooltip message'); }));",
              "successors": []
            }
          ]
        },
        {
          "id": 21,
          "label": "describe('touch gestures', () => { let platform = { ANDROID: true }; });",
          "successors": [
            {
              "id": 22,
              "label": "it('should have a delay when showing on touchstart', fakeAsync(() => { const fixture = TestBed.createComponent(BasicTooltipDemo); fixture.detectChanges(); const button: HTMLButtonElement = fixture.nativeElement.querySelector('button'); dispatchFakeEvent(button, 'touchstart'); fixture.detectChanges(); tick(250); assertTooltipInstance(fixture.componentInstance.tooltip, false); tick(500); fixture.detectChanges(); finishCurrentTooltipAnimation(overlayContainerElement, true); assertTooltipInstance(fixture.componentInstance.tooltip, true); flush(); }));",
              "successors": []
            },
            {
              "id": 23,
              "label": "it('should be able to disable opening on touch', fakeAsync(() => { const fixture = TestBed.createComponent(BasicTooltipDemo); fixture.componentInstance.touchGestures = 'off'; fixture.detectChanges(); const button: HTMLButtonElement = fixture.nativeElement.querySelector('button'); dispatchFakeEvent(button, 'touchstart'); fixture.detectChanges(); tick(500); fixture.detectChanges(); tick(500); assertTooltipInstance(fixture.componentInstance.tooltip, false); }));",
              "successors": []
            }
          ]
        },
        {
          "id": 24,
          "label": "describe('mouse wheel handling', () => { });",
          "successors": [
            {
              "id": 25,
              "label": "it('should close when a wheel event causes the cursor to leave the trigger', fakeAsync(() => { const fixture = TestBed.createComponent(BasicTooltipDemo); fixture.detectChanges(); const button: HTMLButtonElement = fixture.nativeElement.querySelector('button'); dispatchFakeEvent(button, 'mouseenter'); fixture.detectChanges(); tick(500); fixture.detectChanges(); finishCurrentTooltipAnimation(overlayContainerElement, true); assertTooltipInstance(fixture.componentInstance.tooltip, true); const wheelEvent = createFakeEvent('wheel'); Object.defineProperties(wheelEvent, { clientX: {get: () => window.innerWidth}, clientY: {get: () => window.innerHeight}, }); dispatchEvent(button, wheelEvent); fixture.detectChanges(); tick(1500); fixture.detectChanges(); finishCurrentTooltipAnimation(overlayContainerElement, false); assertTooltipInstance(fixture.componentInstance.tooltip, false); flush(); }));",
              "successors": []
            },
            {
              "id": 26,
              "label": "it('should not close if the cursor is over the trigger after a wheel event', fakeAsync(() => { const fixture = TestBed.createComponent(BasicTooltipDemo); fixture.detectChanges(); const button: HTMLButtonElement = fixture.nativeElement.querySelector('button'); dispatchFakeEvent(button, 'mouseenter'); fixture.detectChanges(); tick(500); fixture.detectChanges(); finishCurrentTooltipAnimation(overlayContainerElement, true); assertTooltipInstance(fixture.componentInstance.tooltip, true); const triggerRect = button.getBoundingClientRect(); const wheelEvent = createFakeEvent('wheel'); Object.defineProperties(wheelEvent, { clientX: {get: () => triggerRect.left + 1}, clientY: {get: () => triggerRect.top + 1}, }); dispatchEvent(button, wheelEvent); fixture.detectChanges(); tick(1500); fixture.detectChanges(); finishCurrentTooltipAnimation(overlayContainerElement, false); assertTooltipInstance(fixture.componentInstance.tooltip, true); flush(); }));",
              "successors": []
            }
          ]
        }
      ]
    }
  ]
}