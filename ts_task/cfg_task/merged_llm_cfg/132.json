{
  "name": "example_script",
  "type": "CFG",
  "start_line": 1,
  "end_line": 861,
  "functions": [],
  "classes": [
    {
      "name": "GoogleSheetsMock",
      "type": "class",
      "start_line": 187,
      "end_line": 861,
      "functions": [
        {
          "name": "forDatasource",
          "type": "function",
          "start_line": 190,
          "end_line": 192,
          "functions": [],
          "classes": [],
          "simplified_code": "  static forDatasource(datasource: Datasource): GoogleSheetsMock {\n    return new GoogleSheetsMock(datasource.config as GoogleSheetsConfig)\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "static forDatasource(datasource: Datasource): GoogleSheetsMock {\n    return new GoogleSheetsMock(datasource.config as GoogleSheetsConfig)",
              "successors": []
            }
          ]
        },
        {
          "name": "constructor",
          "type": "function",
          "start_line": 193,
          "end_line": 210,
          "functions": [],
          "classes": [],
          "simplified_code": "  private constructor(config: GoogleSheetsConfig) {\n    this.config = config\n    this.spreadsheet = {\n      properties: {\n        title: \"Test Spreadsheet\",\n        locale: \"en_US\",\n        autoRecalc: \"ON_CHANGE\",\n        timeZone: \"America/New_York\",\n        defaultFormat: {},\n        iterativeCalculationSettings: {},\n        spreadsheetTheme: {},\n      },\n      spreadsheetId: config.spreadsheetId,\n      sheets: [],\n    }\n    this.mockAuth()\n    this.mockAPI()\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "private constructor(config: GoogleSheetsConfig) {\nthis.config = config",
              "successors": [
                {
                  "id": 3,
                  "label": "this.spreadsheet = { properties: { title: \"Test Spreadsheet\", locale: \"en_US\", autoRecalc: \"ON_CHANGE\", timeZone: \"America/New_York\", defaultFormat: {}, iterativeCalculationSettings: {}, spreadsheetTheme: {}, }, spreadsheetId: config.spreadsheetId, sheets: [], }\nthis.mockAuth()",
                  "successors": [
                    {
                      "id": 5,
                      "label": "this.mockAPI()",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "cell",
          "type": "function",
          "start_line": 211,
          "end_line": 217,
          "functions": [],
          "classes": [],
          "simplified_code": "  public cell(cell: string): Value | undefined {\n    const cellData = this.cellData(cell)\n    if (!cellData) {\n      return undefined\n    }\n    return this.cellValue(cellData)\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "const cellData = this.cellData(cell)\nif (!cellData) {",
              "successors": [
                {
                  "id": 3,
                  "label": "  return undefined",
                  "successors": []
                },
                {
                  "id": 4,
                  "label": "}\nreturn this.cellValue(cellData)",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "set",
          "type": "function",
          "start_line": 218,
          "end_line": 224,
          "functions": [],
          "classes": [],
          "simplified_code": "  public set(cell: string, value: Value): void {\n    const cellData = this.cellData(cell)\n    if (!cellData) {\n      throw new Error(`Cell ${cell} not found`)\n    }\n    cellData.userEnteredValue = this.createValue(value)\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "public set(cell: string, value: Value): void {\nconst cellData = this.cellData(cell)",
              "successors": [
                {
                  "id": 3,
                  "label": "if (!cellData) {",
                  "successors": [
                    {
                      "id": 4,
                      "label": "throw new Error(`Cell ${cell} not found`)",
                      "successors": []
                    },
                    {
                      "id": 5,
                      "label": "}\ncellData.userEnteredValue = this.createValue(value)",
                      "successors": [
                        {
                          "id": 7,
                          "label": "}",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "sheet",
          "type": "function",
          "start_line": 225,
          "end_line": 230,
          "functions": [],
          "classes": [],
          "simplified_code": "  public sheet(name: string | number): Sheet | undefined {\n    if (typeof name === \"number\") {\n      return this.getSheetById(name)\n    }\n    return this.getSheetByName(name)\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "public sheet(name: string | number): Sheet | undefined {",
              "successors": [
                {
                  "id": 2,
                  "label": "if (typeof name === \"number\") {\nreturn this.getSheetById(name)",
                  "successors": []
                },
                {
                  "id": 4,
                  "label": "return this.getSheetByName(name)",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "createSheet",
          "type": "function",
          "start_line": 231,
          "end_line": 238,
          "functions": [],
          "classes": [],
          "simplified_code": "  public createSheet(opts: Partial<WorksheetProperties>): Sheet {\n    const properties = this.defaultWorksheetProperties(opts)\n    if (this.getSheetByName(properties.title)) {\n      throw new Error(`Sheet ${properties.title} already exists`)\n    }\n    const resp = this.handleAddSheet({ properties })\n    return this.getSheetById(resp.properties.sheetId)!\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "public createSheet(opts: Partial<WorksheetProperties>): Sheet {\nconst properties = this.defaultWorksheetProperties(opts)",
              "successors": [
                {
                  "id": 3,
                  "label": "if (this.getSheetByName(properties.title)) {",
                  "successors": [
                    {
                      "id": 4,
                      "label": "throw new Error(`Sheet ${properties.title} already exists`)",
                      "successors": []
                    },
                    {
                      "id": 5,
                      "label": "} else {\nconst resp = this.handleAddSheet({ properties })",
                      "successors": [
                        {
                          "id": 7,
                          "label": "return this.getSheetById(resp.properties.sheetId)!",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "route",
          "type": "function",
          "start_line": 239,
          "end_line": 247,
          "functions": [],
          "classes": [],
          "simplified_code": "  private route(\n    method: \"get\" | \"put\" | \"post\",\n    path: string | RegExp,\n    handler: (uri: string, request: nock.Body) => nock.Body\n  ): nock.Scope {\n    const headers = { reqheaders: { authorization: \"Bearer test\" } }\n    const scope = nock(\"https://sheets.googleapis.com/\", headers)\n    return scope[method](path).reply(200, handler).persist()\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "private route(\n    method: \"get\" | \"put\" | \"post\",\n    path: string | RegExp,\n    handler: (uri: string, request: nock.Body) => nock.Body\n  ): nock.Scope {\nconst headers = { reqheaders: { authorization: \"Bearer test\" } }",
              "successors": [
                {
                  "id": 3,
                  "label": "const scope = nock(\"https://sheets.googleapis.com/\", headers)\nreturn scope[method](path).reply(200, handler).persist()",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "get",
          "type": "function",
          "start_line": 248,
          "end_line": 253,
          "functions": [],
          "classes": [],
          "simplified_code": "  private get(\n    path: string | RegExp,\n    handler: (uri: string, request: nock.Body) => nock.Body\n  ): nock.Scope {\n    return this.route(\"get\", path, handler)\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "private get( path: string | RegExp, handler: (uri: string, request: nock.Body) => nock.Body ): nock.Scope {\n    return this.route(\"get\", path, handler)",
              "successors": [
                {
                  "id": 3,
                  "label": "}",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "put",
          "type": "function",
          "start_line": 254,
          "end_line": 259,
          "functions": [],
          "classes": [],
          "simplified_code": "  private put(\n    path: string | RegExp,\n    handler: (uri: string, request: nock.Body) => nock.Body\n  ): nock.Scope {\n    return this.route(\"put\", path, handler)\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "private put(\n  path: string | RegExp,\n  handler: (uri: string, request: nock.Body) => nock.Body\n): nock.Scope {\n  return this.route(\"put\", path, handler)\n}",
              "successors": []
            }
          ]
        },
        {
          "name": "post",
          "type": "function",
          "start_line": 260,
          "end_line": 265,
          "functions": [],
          "classes": [],
          "simplified_code": "  private post(\n    path: string | RegExp,\n    handler: (uri: string, request: nock.Body) => nock.Body\n  ): nock.Scope {\n    return this.route(\"post\", path, handler)\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "private post(\n  path: string | RegExp,\n  handler: (uri: string, request: nock.Body) => nock.Body\n): nock.Scope {\n  return this.route(\"post\", path, handler)",
              "successors": [
                {
                  "id": 3,
                  "label": "}",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "mockAuth",
          "type": "function",
          "start_line": 266,
          "end_line": 289,
          "functions": [],
          "classes": [],
          "simplified_code": "  private mockAuth() {\n    nock(\"https://www.googleapis.com/\")\n      .post(\"/oauth2/v4/token\")\n      .reply(200, {\n        grant_type: \"client_credentials\",\n        client_id: \"your-client-id\",\n        client_secret: \"your-client-secret\",\n      })\n      .persist()\n    nock(\"https://oauth2.googleapis.com/\")\n      .post(\"/token\", {\n        client_id: \"test\",\n        client_secret: \"test\",\n        grant_type: \"refresh_token\",\n        refresh_token: \"refreshToken\",\n      })\n      .reply(200, {\n        access_token: \"test\",\n        expires_in: 3600,\n        token_type: \"Bearer\",\n        scopes: \"https://www.googleapis.com/auth/spreadsheets\",\n      })\n      .persist()\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "private mockAuth() {\nnock(\"https://www.googleapis.com/\")",
              "successors": [
                {
                  "id": 3,
                  "label": ".post(\"/oauth2/v4/token\")\n.reply(200, {\n  grant_type: \"client_credentials\",\n  client_id: \"your-client-id\",\n  client_secret: \"your-client-secret\",\n})",
                  "successors": [
                    {
                      "id": 5,
                      "label": ".persist()\nnock(\"https://oauth2.googleapis.com/\")",
                      "successors": [
                        {
                          "id": 7,
                          "label": ".post(\"/token\", {\n  client_id: \"test\",\n  client_secret: \"test\",\n  grant_type: \"refresh_token\",\n  refresh_token: \"refreshToken\",\n})\n.reply(200, {\n  access_token: \"test\",\n  expires_in: 3600,\n  token_type: \"Bearer\",\n  scopes: \"https://www.googleapis.com/auth/spreadsheets\",\n})",
                          "successors": [
                            {
                              "id": 9,
                              "label": ".persist()\n",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "mockAPI",
          "type": "function",
          "start_line": 290,
          "end_line": 361,
          "functions": [],
          "classes": [],
          "simplified_code": "  private mockAPI() {\n    const spreadsheetId = this.config.spreadsheetId\n    this.get(`/v4/spreadsheets/${spreadsheetId}/`, () =>\n      this.handleGetSpreadsheet()\n    )\n    // https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets.values/batchUpdate\n    this.post(\n      `/v4/spreadsheets/${spreadsheetId}/:batchUpdate`,\n      (_uri, request) => this.handleBatchUpdate(request as BatchUpdateRequest)\n    )\n    // https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets.values/update\n    this.put(\n      new RegExp(`/v4/spreadsheets/${spreadsheetId}/values/.*`),\n      (_uri, request) => this.handleValueUpdate(request as ValueRange)\n    )\n    // https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets.values/batchGet\n    this.get(\n      new RegExp(`/v4/spreadsheets/${spreadsheetId}/values:batchGet.*`),\n      uri => {\n        const url = new URL(uri, \"https://sheets.googleapis.com/\")\n        const params: BatchGetParams = {\n          ranges: url.searchParams.getAll(\"ranges\"),\n          majorDimension:\n            (url.searchParams.get(\"majorDimension\") as WorksheetDimension) ||\n            \"ROWS\",\n          valueRenderOption:\n            (url.searchParams.get(\"valueRenderOption\") as ValueRenderOption) ||\n            undefined,\n          dateTimeRenderOption:\n            (url.searchParams.get(\n              \"dateTimeRenderOption\"\n            ) as DateTimeRenderOption) || undefined,\n        }\n        return this.handleBatchGet(params as unknown as BatchGetParams)\n      }\n    )\n    // https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets.values/get\n    this.get(new RegExp(`/v4/spreadsheets/${spreadsheetId}/values/.*`), uri => {\n      const range = uri.split(\"/\").pop()\n      if (!range) {\n        throw new Error(\"No range provided\")\n      }\n      return this.getValueRange(decodeURIComponent(range))\n    })\n    // https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets.values/append\n    this.post(\n      new RegExp(`/v4/spreadsheets/${spreadsheetId}/values/.*:append`),\n      (_uri, request) => {\n        const url = new URL(_uri, \"https://sheets.googleapis.com/\")\n        const params: Record<string, any> = Object.fromEntries(\n          url.searchParams.entries()\n        )\n        if (params.includeValuesInResponse === \"true\") {\n          params.includeValuesInResponse = true\n        } else {\n          params.includeValuesInResponse = false\n        }\n        let range = url.pathname.split(\"/\").pop()\n        if (!range) {\n          throw new Error(\"No range provided\")\n        }\n        if (range.endsWith(\":append\")) {\n          range = range.slice(0, -7)\n        }\n        range = decodeURIComponent(range)\n        return this.handleValueAppend({\n          range,\n          params,\n          body: request as ValueRange,\n        })\n      }\n    )",
          "blocks": [
            {
              "id": 1,
              "label": "const spreadsheetId = this.config.spreadsheetId\nthis.get(`/v4/spreadsheets/${spreadsheetId}/`, () => this.handleGetSpreadsheet())",
              "successors": [
                {
                  "id": 3,
                  "label": "this.post(`/v4/spreadsheets/${spreadsheetId}/:batchUpdate`, (_uri, request) => this.handleBatchUpdate(request as BatchUpdateRequest))\nthis.put(new RegExp(`/v4/spreadsheets/${spreadsheetId}/values/.*`), (_uri, request) => this.handleValueUpdate(request as ValueRange))",
                  "successors": [
                    {
                      "id": 5,
                      "label": "this.get(new RegExp(`/v4/spreadsheets/${spreadsheetId}/values:batchGet.*`), uri => { const url = new URL(uri, \"https://sheets.googleapis.com/\") const params: BatchGetParams = { ranges: url.searchParams.getAll(\"ranges\"), majorDimension: (url.searchParams.get(\"majorDimension\") as WorksheetDimension) || \"ROWS\", valueRenderOption: (url.searchParams.get(\"valueRenderOption\") as ValueRenderOption) || undefined, dateTimeRenderOption: (url.searchParams.get(\"dateTimeRenderOption\") as DateTimeRenderOption) || undefined, } return this.handleBatchGet(params as unknown as BatchGetParams) })\nthis.get(new RegExp(`/v4/spreadsheets/${spreadsheetId}/values/.*`), uri => { const range = uri.split(\"/\").pop() if (!range) { throw new Error(\"No range provided\") } return this.getValueRange(decodeURIComponent(range)) })",
                      "successors": [
                        {
                          "id": 7,
                          "label": "this.post(new RegExp(`/v4/spreadsheets/${spreadsheetId}/values/.*:append`), (_uri, request) => { const url = new URL(_uri, \"https://sheets.googleapis.com/\") const params: Record<string, any> = Object.fromEntries(url.searchParams.entries()) if (params.includeValuesInResponse === \"true\") { params.includeValuesInResponse = true } else { params.includeValuesInResponse = false } let range = url.pathname.split(\"/\").pop() if (!range) { throw new Error(\"No range provided\") } if (range.endsWith(\":append\")) { range = range.slice(0, -7) } range = decodeURIComponent(range) return this.handleValueAppend({ range, params, body: request as ValueRange, }) })",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "handleValueAppend",
          "type": "function",
          "start_line": 363,
          "end_line": 401,
          "functions": [],
          "classes": [],
          "simplified_code": "  private handleValueAppend(request: AppendRequest): AppendResponse {\n    const { range, params, body } = request\n    const { sheetId, endRowIndex } = this.parseA1Notation(range)\n    const sheet = this.getSheetById(sheetId)\n    if (!sheet) {\n      throw new Error(`Sheet ${sheetId} not found`)\n    }\n    const newRows = body.values.map(v => this.valuesToRowData(v))\n    const toDelete =\n      params.insertDataOption === \"INSERT_ROWS\" ? newRows.length : 0\n    sheet.data[0].rowData.splice(endRowIndex + 1, toDelete, ...newRows)\n    sheet.data[0].rowMetadata.splice(endRowIndex + 1, toDelete, {\n      hiddenByUser: false,\n      hiddenByFilter: false,\n      pixelSize: 100,\n      developerMetadata: [],\n    })\n    // It's important to give back a correct updated range because the API\n    // library we use makes use of it to assign the correct row IDs to rows.\n    const updatedRange = this.createA1({\n      sheetId,\n      startRowIndex: endRowIndex + 1,\n      startColumnIndex: 0,\n      endRowIndex: endRowIndex + newRows.length,\n      endColumnIndex: 0,\n    })\n    sheet.properties.gridProperties.rowCount = sheet.data[0].rowData.length\n    return {\n      spreadsheetId: this.spreadsheet.spreadsheetId,\n      tableRange: range,\n      updates: {\n        spreadsheetId: this.spreadsheet.spreadsheetId,\n        updatedRange,\n        updatedRows: body.values.length,\n        updatedColumns: body.values[0].length,\n        updatedCells: body.values.length * body.values[0].length,\n        updatedData: body,\n      },\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "private handleValueAppend(request: AppendRequest): AppendResponse {\nconst { range, params, body } = request",
              "successors": [
                {
                  "id": 3,
                  "label": "const { sheetId, endRowIndex } = this.parseA1Notation(range)\nconst sheet = this.getSheetById(sheetId)",
                  "successors": [
                    {
                      "id": 5,
                      "label": "if (!sheet) {\nthrow new Error(`Sheet ${sheetId} not found`)",
                      "successors": []
                    },
                    {
                      "id": 7,
                      "label": "} else {\nconst newRows = body.values.map(v => this.valuesToRowData(v))",
                      "successors": [
                        {
                          "id": 9,
                          "label": "const toDelete = params.insertDataOption === \"INSERT_ROWS\" ? newRows.length : 0\nsheet.data[0].rowData.splice(endRowIndex + 1, toDelete, ...newRows)",
                          "successors": [
                            {
                              "id": 11,
                              "label": "sheet.data[0].rowMetadata.splice(endRowIndex + 1, toDelete, { hiddenByUser: false, hiddenByFilter: false, pixelSize: 100, developerMetadata: [], })\nconst updatedRange = this.createA1({ sheetId, startRowIndex: endRowIndex + 1, startColumnIndex: 0, endRowIndex: endRowIndex + newRows.length, endColumnIndex: 0, })",
                              "successors": [
                                {
                                  "id": 13,
                                  "label": "sheet.properties.gridProperties.rowCount = sheet.data[0].rowData.length\nreturn { spreadsheetId: this.spreadsheet.spreadsheetId, tableRange: range, updates: { spreadsheetId: this.spreadsheet.spreadsheetId, updatedRange, updatedRows: body.values.length, updatedColumns: body.values[0].length, updatedCells: body.values.length * body.values[0].length, updatedData: body, }, }",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "handleBatchGet",
          "type": "function",
          "start_line": 403,
          "end_line": 412,
          "functions": [],
          "classes": [],
          "simplified_code": "  private handleBatchGet(params: BatchGetParams): BatchGetResponse {\n    const { ranges, majorDimension } = params\n    if (majorDimension && majorDimension !== \"ROWS\") {\n      throw new Error(\"Only row-major updates are supported\")\n    }\n    return {\n      spreadsheetId: this.spreadsheet.spreadsheetId,\n      valueRanges: ranges.map(range => this.getValueRange(range)),\n    }\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "private handleBatchGet(params: BatchGetParams): BatchGetResponse {\nconst { ranges, majorDimension } = params",
              "successors": [
                {
                  "id": 3,
                  "label": "if (majorDimension && majorDimension !== \"ROWS\") {",
                  "successors": [
                    {
                      "id": 4,
                      "label": "throw new Error(\"Only row-major updates are supported\")",
                      "successors": []
                    },
                    {
                      "id": 5,
                      "label": "}\nreturn {",
                      "successors": [
                        {
                          "id": 7,
                          "label": "spreadsheetId: this.spreadsheet.spreadsheetId,\nvalueRanges: ranges.map(range => this.getValueRange(range))",
                          "successors": [
                            {
                              "id": 9,
                              "label": "}\n}",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "handleBatchUpdate",
          "type": "function",
          "start_line": 413,
          "end_line": 437,
          "functions": [],
          "classes": [],
          "simplified_code": "  private handleBatchUpdate(\n    batchUpdateRequest: BatchUpdateRequest\n  ): BatchUpdateResponse {\n    const response: BatchUpdateResponse = {\n      spreadsheetId: this.spreadsheet.spreadsheetId,\n      replies: [],\n      updatedSpreadsheet: this.spreadsheet,\n    }\n    for (const request of batchUpdateRequest.requests) {\n      if (request.addSheet) {\n        response.replies.push({\n          addSheet: this.handleAddSheet(request.addSheet),\n        })\n      }\n      if (request.deleteRange) {\n        this.handleDeleteRange(request.deleteRange)\n        response.replies.push({})\n      }\n      if (request.deleteSheet) {\n        this.handleDeleteSheet(request.deleteSheet)\n        response.replies.push({})\n      }\n    }\n    return response\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "private handleBatchUpdate(\n    batchUpdateRequest: BatchUpdateRequest\n  ): BatchUpdateResponse {\n    const response: BatchUpdateResponse = {\n      spreadsheetId: this.spreadsheet.spreadsheetId,\n      replies: [],\n      updatedSpreadsheet: this.spreadsheet,\n    }",
              "successors": [
                {
                  "id": 2,
                  "label": "for (const request of batchUpdateRequest.requests) {",
                  "successors": [
                    {
                      "id": 3,
                      "label": "if (request.addSheet) {\n        response.replies.push({\n          addSheet: this.handleAddSheet(request.addSheet),\n        })\n      }\nif (request.deleteRange) {\n        this.handleDeleteRange(request.deleteRange)\n        response.replies.push({})\n      }",
                      "successors": [
                        {
                          "id": 5,
                          "label": "if (request.deleteSheet) {\n        this.handleDeleteSheet(request.deleteSheet)\n        response.replies.push({})\n      }\n} // End of loop block",
                          "successors": []
                        }
                      ]
                    }
                  ]
                },
                {
                  "id": 7,
                  "label": "return response\n  }",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "defaultWorksheetProperties",
          "type": "function",
          "start_line": 438,
          "end_line": 457,
          "functions": [],
          "classes": [],
          "simplified_code": "  private defaultWorksheetProperties(\n    opts: Partial<WorksheetProperties>\n  ): WorksheetProperties {\n    return {\n      index: this.spreadsheet.sheets.length,\n      hidden: false,\n      rightToLeft: false,\n      tabColor: BLACK,\n      tabColorStyle: { rgbColor: BLACK },\n      sheetType: \"GRID\",\n      title: \"Sheet\",\n      sheetId: this.spreadsheet.sheets.length,\n      gridProperties: {\n        rowCount: 100,\n        columnCount: 26,\n      },\n      dataSourceSheetProperties: {} as DataSourceSheetProperties,\n      ...opts,\n    }\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "private defaultWorksheetProperties(\nopts: Partial<WorksheetProperties>",
              "successors": [
                {
                  "id": 3,
                  "label": "): WorksheetProperties {\nreturn {",
                  "successors": [
                    {
                      "id": 5,
                      "label": "  index: this.spreadsheet.sheets.length,\n  hidden: false,",
                      "successors": [
                        {
                          "id": 7,
                          "label": "  rightToLeft: false,\n  tabColor: BLACK,",
                          "successors": [
                            {
                              "id": 9,
                              "label": "  tabColorStyle: { rgbColor: BLACK },\n  sheetType: \"GRID\",",
                              "successors": [
                                {
                                  "id": 11,
                                  "label": "  title: \"Sheet\",\n  sheetId: this.spreadsheet.sheets.length,",
                                  "successors": [
                                    {
                                      "id": 13,
                                      "label": "  gridProperties: {\n    rowCount: 100,",
                                      "successors": [
                                        {
                                          "id": 15,
                                          "label": "    columnCount: 26,\n  },",
                                          "successors": [
                                            {
                                              "id": 17,
                                              "label": "  dataSourceSheetProperties: {} as DataSourceSheetProperties,\n  ...opts,",
                                              "successors": [
                                                {
                                                  "id": 19,
                                                  "label": "}\n}",
                                                  "successors": []
                                                }
                                              ]
                                            }
                                          ]
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "handleAddSheet",
          "type": "function",
          "start_line": 458,
          "end_line": 470,
          "functions": [],
          "classes": [],
          "simplified_code": "  private handleAddSheet(request: AddSheetRequest): AddSheetResponse {\n    const properties = this.defaultWorksheetProperties(request.properties)\n    this.spreadsheet.sheets.push({\n      properties,\n      data: [\n        this.createEmptyGrid(\n          properties.gridProperties.rowCount,\n          properties.gridProperties.columnCount\n        ),\n      ],\n    })\n    return { properties }\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "private handleAddSheet(request: AddSheetRequest): AddSheetResponse {\nconst properties = this.defaultWorksheetProperties(request.properties)",
              "successors": [
                {
                  "id": 3,
                  "label": "this.spreadsheet.sheets.push({\nproperties,",
                  "successors": [
                    {
                      "id": 5,
                      "label": "data: [\nthis.createEmptyGrid(",
                      "successors": [
                        {
                          "id": 7,
                          "label": "properties.gridProperties.rowCount,\nproperties.gridProperties.columnCount",
                          "successors": [
                            {
                              "id": 9,
                              "label": ")\n]",
                              "successors": [
                                {
                                  "id": 11,
                                  "label": "})\nreturn { properties }",
                                  "successors": [
                                    {
                                      "id": 13,
                                      "label": "}",
                                      "successors": []
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "handleDeleteRange",
          "type": "function",
          "start_line": 471,
          "end_line": 479,
          "functions": [],
          "classes": [],
          "simplified_code": "  private handleDeleteRange(request: DeleteRangeRequest) {\n    const { range, shiftDimension } = request\n    if (shiftDimension !== \"ROWS\") {\n      throw new Error(\"Only row-based deletes are supported\")\n    }\n    this.iterateRange(range, cell => {\n      cell.userEnteredValue = this.createValue(null)\n    })\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "private handleDeleteRange(request: DeleteRangeRequest) {\nconst { range, shiftDimension } = request",
              "successors": [
                {
                  "id": 3,
                  "label": "if (shiftDimension !== \"ROWS\") {",
                  "successors": [
                    {
                      "id": 4,
                      "label": "throw new Error(\"Only row-based deletes are supported\")",
                      "successors": []
                    },
                    {
                      "id": 5,
                      "label": "}\nthis.iterateRange(range, cell => {",
                      "successors": [
                        {
                          "id": 7,
                          "label": "cell.userEnteredValue = this.createValue(null)\n})",
                          "successors": [
                            {
                              "id": 9,
                              "label": "}",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "handleDeleteSheet",
          "type": "function",
          "start_line": 480,
          "end_line": 483,
          "functions": [],
          "classes": [],
          "simplified_code": "  private handleDeleteSheet(request: DeleteSheetRequest) {\n    const { sheetId } = request\n    this.spreadsheet.sheets.splice(sheetId, 1)\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "private handleDeleteSheet(request: DeleteSheetRequest) {\n  const { sheetId } = request",
              "successors": [
                {
                  "id": 3,
                  "label": "  this.spreadsheet.sheets.splice(sheetId, 1)\n}",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "handleGetSpreadsheet",
          "type": "function",
          "start_line": 484,
          "end_line": 486,
          "functions": [],
          "classes": [],
          "simplified_code": "  private handleGetSpreadsheet(): Spreadsheet {\n    return this.spreadsheet\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "private handleGetSpreadsheet(): Spreadsheet {\n    return this.spreadsheet",
              "successors": []
            }
          ]
        },
        {
          "name": "handleValueUpdate",
          "type": "function",
          "start_line": 487,
          "end_line": 499,
          "functions": [],
          "classes": [],
          "simplified_code": "  private handleValueUpdate(valueRange: ValueRange): UpdateValuesResponse {\n    this.iterateValueRange(valueRange, (cell, value) => {\n      cell.userEnteredValue = this.createValue(value)\n    })\n    const response: UpdateValuesResponse = {\n      spreadsheetId: this.spreadsheet.spreadsheetId,\n      updatedRange: valueRange.range,\n      updatedRows: valueRange.values.length,\n      updatedColumns: valueRange.values[0].length,\n      updatedCells: valueRange.values.length * valueRange.values[0].length,\n      updatedData: valueRange,\n    }\n    return response",
          "blocks": [
            {
              "id": 1,
              "label": "private handleValueUpdate(valueRange: ValueRange): UpdateValuesResponse {\n    this.iterateValueRange(valueRange, (cell, value) => {",
              "successors": [
                {
                  "id": 3,
                  "label": "      cell.userEnteredValue = this.createValue(value)\n    })",
                  "successors": [
                    {
                      "id": 5,
                      "label": "    const response: UpdateValuesResponse = {\n      spreadsheetId: this.spreadsheet.spreadsheetId,",
                      "successors": [
                        {
                          "id": 7,
                          "label": "      updatedRange: valueRange.range,\n      updatedRows: valueRange.values.length,",
                          "successors": [
                            {
                              "id": 9,
                              "label": "      updatedColumns: valueRange.values[0].length,\n      updatedCells: valueRange.values.length * valueRange.values[0].length,",
                              "successors": [
                                {
                                  "id": 11,
                                  "label": "      updatedData: valueRange\n    }",
                                  "successors": [
                                    {
                                      "id": 13,
                                      "label": "    return response\n}",
                                      "successors": []
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "iterateRange",
          "type": "function",
          "start_line": 501,
          "end_line": 518,
          "functions": [],
          "classes": [],
          "simplified_code": "  private iterateRange(range: GridRange, cb: (cell: CellData) => void) {\n    const {\n      sheetId,\n      startRowIndex,\n      endRowIndex,\n      startColumnIndex,\n      endColumnIndex,\n    } = this.ensureGridRange(range)\n    for (let row = startRowIndex; row <= endRowIndex; row++) {\n      for (let col = startColumnIndex; col <= endColumnIndex; col++) {\n        const cell = this.getCellNumericIndexes(sheetId, row, col)\n        if (!cell) {\n          throw new Error(\"Cell not found\")\n        }\n        cb(cell)\n      }\n    }\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "const {\n  sheetId,\n  startRowIndex,\n  endRowIndex,\n  startColumnIndex,\n  endColumnIndex\n} = this.ensureGridRange(range)",
              "successors": [
                {
                  "id": 2,
                  "label": "for (let row = startRowIndex; row <= endRowIndex; row++)",
                  "successors": [
                    {
                      "id": 3,
                      "label": "for (let col = startColumnIndex; col <= endColumnIndex; col++)",
                      "successors": [
                        {
                          "id": 4,
                          "label": "const cell = this.getCellNumericIndexes(sheetId, row, col)\nif (!cell)",
                          "successors": [
                            {
                              "id": 6,
                              "label": "throw new Error(\"Cell not found\")",
                              "successors": []
                            },
                            {
                              "id": 7,
                              "label": "cb(cell)",
                              "successors": [
                                {
                                  "id": 3,
                                  "label": "for (let col = startColumnIndex; col <= endColumnIndex; col++)",
                                  "successors": []
                                },
                                {
                                  "id": 2,
                                  "label": "for (let row = startRowIndex; row <= endRowIndex; row++)",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "iterateValueRange",
          "type": "function",
          "start_line": 519,
          "end_line": 543,
          "functions": [],
          "classes": [],
          "simplified_code": "  private iterateValueRange(\n    valueRange: ValueRange,\n    cb: (cell: CellData, value: Value) => void\n  ) {\n    if (valueRange.majorDimension !== \"ROWS\") {\n      throw new Error(\"Only row-major updates are supported\")\n    }\n    const {\n      sheetId,\n      startColumnIndex,\n      startRowIndex,\n      endColumnIndex,\n      endRowIndex,\n    } = this.parseA1Notation(valueRange.range)\n    for (let row = startRowIndex; row <= endRowIndex; row++) {\n      for (let col = startColumnIndex; col <= endColumnIndex; col++) {\n        const cell = this.getCellNumericIndexes(sheetId, row, col)\n        if (!cell) {\n          throw new Error(\"Cell not found\")\n        }\n        const value =\n          valueRange.values[row - startRowIndex][col - startColumnIndex]\n        cb(cell, value)\n      }\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "private iterateValueRange(valueRange: ValueRange, cb: (cell: CellData, value: Value) => void) {",
              "successors": [
                {
                  "id": 2,
                  "label": "if (valueRange.majorDimension !== \"ROWS\") {\n  throw new Error(\"Only row-major updates are supported\")",
                  "successors": []
                },
                {
                  "id": 4,
                  "label": "const { sheetId, startColumnIndex, startRowIndex, endColumnIndex, endRowIndex } = this.parseA1Notation(valueRange.range)",
                  "successors": [
                    {
                      "id": 5,
                      "label": "for (let row = startRowIndex; row <= endRowIndex; row++) {",
                      "successors": [
                        {
                          "id": 6,
                          "label": "  for (let col = startColumnIndex; col <= endColumnIndex; col++) {",
                          "successors": [
                            {
                              "id": 7,
                              "label": "    const cell = this.getCellNumericIndexes(sheetId, row, col)",
                              "successors": [
                                {
                                  "id": 8,
                                  "label": "if (!cell) {\n  throw new Error(\"Cell not found\")",
                                  "successors": []
                                },
                                {
                                  "id": 10,
                                  "label": "const value = valueRange.values[row - startRowIndex][col - startColumnIndex]\ncb(cell, value)",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "getValueRange",
          "type": "function",
          "start_line": 545,
          "end_line": 570,
          "functions": [],
          "classes": [],
          "simplified_code": "  private getValueRange(range: string): ValueRange {\n    const {\n      sheetId,\n      startRowIndex,\n      endRowIndex,\n      startColumnIndex,\n      endColumnIndex,\n    } = this.parseA1Notation(range)\n    const valueRange: ValueRange = {\n      range,\n      majorDimension: \"ROWS\",\n      values: [],\n    }\n    for (let row = startRowIndex; row <= endRowIndex; row++) {\n      const values: Value[] = []\n      for (let col = startColumnIndex; col <= endColumnIndex; col++) {\n        const cell = this.getCellNumericIndexes(sheetId, row, col)\n        if (!cell) {\n          throw new Error(\"Cell not found\")\n        }\n        values.push(this.cellValue(cell))\n      }\n      valueRange.values.push(values)\n    }\n    return this.trimValueRange(valueRange)\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "private getValueRange(range: string): ValueRange {\nconst {\n  sheetId,\n  startRowIndex,\n  endRowIndex,\n  startColumnIndex,\n  endColumnIndex,\n} = this.parseA1Notation(range)",
              "successors": [
                {
                  "id": 3,
                  "label": "const valueRange: ValueRange = {\n  range,\n  majorDimension: \"ROWS\",\n  values: [],\n}",
                  "successors": [
                    {
                      "id": 4,
                      "label": "for (let row = startRowIndex; row <= endRowIndex; row++) {",
                      "successors": [
                        {
                          "id": 5,
                          "label": "const values: Value[] = []",
                          "successors": [
                            {
                              "id": 6,
                              "label": "for (let col = startColumnIndex; col <= endColumnIndex; col++) {",
                              "successors": [
                                {
                                  "id": 7,
                                  "label": "const cell = this.getCellNumericIndexes(sheetId, row, col)",
                                  "successors": [
                                    {
                                      "id": 8,
                                      "label": "if (!cell) {\nthrow new Error(\"Cell not found\")",
                                      "successors": []
                                    },
                                    {
                                      "id": 10,
                                      "label": "values.push(this.cellValue(cell))",
                                      "successors": [
                                        {
                                          "id": 6,
                                          "label": "for (let col = startColumnIndex; col <= endColumnIndex; col++)",
                                          "successors": []
                                        },
                                        {
                                          "id": 5,
                                          "label": "const values: Value[] = []",
                                          "successors": []
                                        }
                                      ]
                                    }
                                  ]
                                },
                                {
                                  "id": 11,
                                  "label": "valueRange.values.push(values)",
                                  "successors": [
                                    {
                                      "id": 4,
                                      "label": "for (let row = startRowIndex; row <= endRowIndex; row++)",
                                      "successors": []
                                    }
                                  ]
                                }
                              ]
                            },
                            {
                              "id": 12,
                              "label": "return this.trimValueRange(valueRange)",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "id": 13,
                      "label": "}",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "trimValueRange",
          "type": "function",
          "start_line": 580,
          "end_line": 612,
          "functions": [],
          "classes": [],
          "simplified_code": "  private trimValueRange(valueRange: ValueRange): ValueRange {\n    for (const row of valueRange.values) {\n      if (row.every(v => v == null)) {\n        row.splice(0, row.length)\n        continue\n      }\n      for (let i = row.length - 1; i >= 0; i--) {\n        const cell = row[i]\n        if (cell == null) {\n          row.pop()\n        } else {\n          break\n        }\n      }\n      for (let i = 0; i < row.length; i++) {\n        const cell = row[i]\n        if (cell == null) {\n          row[i] = \"\"\n        } else {\n          break\n        }\n      }\n    }\n    for (let i = valueRange.values.length - 1; i >= 0; i--) {\n      const row = valueRange.values[i]\n      if (row.length === 0) {\n        valueRange.values.pop()\n      } else {\n        break\n      }\n    }\n    return valueRange\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "private trimValueRange(valueRange: ValueRange): ValueRange {",
              "successors": [
                {
                  "id": 2,
                  "label": "for (const row of valueRange.values) {",
                  "successors": [
                    {
                      "id": 3,
                      "label": "if (row.every(v => v == null)) {",
                      "successors": [
                        {
                          "id": 4,
                          "label": "row.splice(0, row.length)\ncontinue",
                          "successors": []
                        },
                        {
                          "id": 6,
                          "label": "} else {",
                          "successors": [
                            {
                              "id": 7,
                              "label": "for (let i = row.length - 1; i >= 0; i--) {",
                              "successors": [
                                {
                                  "id": 8,
                                  "label": "const cell = row[i]",
                                  "successors": [
                                    {
                                      "id": 9,
                                      "label": "if (cell == null) {",
                                      "successors": [
                                        {
                                          "id": 10,
                                          "label": "row.pop()",
                                          "successors": []
                                        },
                                        {
                                          "id": 11,
                                          "label": "} else {\nbreak",
                                          "successors": []
                                        }
                                      ]
                                    },
                                    {
                                      "id": 13,
                                      "label": "}",
                                      "successors": []
                                    }
                                  ]
                                },
                                {
                                  "id": 14,
                                  "label": "}",
                                  "successors": []
                                },
                                {
                                  "id": 15,
                                  "label": "for (let i = 0; i < row.length; i++) {",
                                  "successors": [
                                    {
                                      "id": 16,
                                      "label": "const cell = row[i]",
                                      "successors": [
                                        {
                                          "id": 17,
                                          "label": "if (cell == null) {",
                                          "successors": [
                                            {
                                              "id": 18,
                                              "label": "row[i] = \"\"",
                                              "successors": []
                                            },
                                            {
                                              "id": 19,
                                              "label": "} else {\nbreak",
                                              "successors": []
                                            }
                                          ]
                                        },
                                        {
                                          "id": 21,
                                          "label": "}",
                                          "successors": []
                                        }
                                      ]
                                    },
                                    {
                                      "id": 22,
                                      "label": "}",
                                      "successors": []
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "id": 23,
                  "label": "} for (let i = valueRange.values.length - 1; i >= 0; i--) {\nconst row = valueRange.values[i]",
                  "successors": [
                    {
                      "id": 25,
                      "label": "if (row.length === 0) {",
                      "successors": [
                        {
                          "id": 26,
                          "label": "valueRange.values.pop()",
                          "successors": []
                        },
                        {
                          "id": 27,
                          "label": "} else {\nbreak",
                          "successors": []
                        }
                      ]
                    },
                    {
                      "id": 29,
                      "label": "}",
                      "successors": []
                    }
                  ]
                },
                {
                  "id": 30,
                  "label": "return valueRange",
                  "successors": []
                },
                {
                  "id": 31,
                  "label": "}",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "valuesToRowData",
          "type": "function",
          "start_line": 613,
          "end_line": 618,
          "functions": [],
          "classes": [],
          "simplified_code": "  private valuesToRowData(values: Value[]): RowData {\n    return {\n      values: values.map(v => {\n        return this.createCellData(v)\n      }),\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "private valuesToRowData(values: Value[]): RowData {\nreturn {",
              "successors": [
                {
                  "id": 3,
                  "label": "values: values.map(v => {\nreturn this.createCellData(v)",
                  "successors": [
                    {
                      "id": 5,
                      "label": "}),\n}",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "unwrapValue",
          "type": "function",
          "start_line": 620,
          "end_line": 631,
          "functions": [],
          "classes": [],
          "simplified_code": "  private unwrapValue(from: ExtendedValue): Value {\n    if (\"stringValue\" in from) {\n      return from.stringValue\n    } else if (\"numberValue\" in from) {\n      return from.numberValue\n    } else if (\"boolValue\" in from) {\n      return from.boolValue\n    } else if (\"formulaValue\" in from) {\n      return from.formulaValue\n    } else {\n      return null\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "private unwrapValue(from: ExtendedValue): Value {\nif (\"stringValue\" in from) {",
              "successors": [
                {
                  "id": 3,
                  "label": "return from.stringValue\n} else if (\"numberValue\" in from) {",
                  "successors": [
                    {
                      "id": 5,
                      "label": "return from.numberValue\n} else if (\"boolValue\" in from) {",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "cellValue",
          "type": "function",
          "start_line": 633,
          "end_line": 635,
          "functions": [],
          "classes": [],
          "simplified_code": "  private cellValue(from: CellData): Value {\n    return this.unwrapValue(from.userEnteredValue)\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "private cellValue(from: CellData): Value {\nreturn this.unwrapValue(from.userEnteredValue)",
              "successors": []
            }
          ]
        },
        {
          "name": "createValue",
          "type": "function",
          "start_line": 636,
          "end_line": 653,
          "functions": [],
          "classes": [],
          "simplified_code": "  private createValue(from: Value): ExtendedValue {\n    if (from == null) {\n      return {} as ExtendedValue\n    } else if (typeof from === \"string\") {\n      return {\n        stringValue: from,\n      }\n    } else if (typeof from === \"number\") {\n      return {\n        numberValue: from,\n      }\n    } else if (typeof from === \"boolean\") {\n      return {\n        boolValue: from,\n      }\n    } else {\n      throw new Error(\"Unsupported value type\")\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "private createValue(from: Value): ExtendedValue {\nif (from == null) {",
              "successors": [
                {
                  "id": 3,
                  "label": "return {} as ExtendedValue",
                  "successors": []
                },
                {
                  "id": 4,
                  "label": "} else if (typeof from === \"string\") {",
                  "successors": [
                    {
                      "id": 5,
                      "label": "return {\n  stringValue: from,\n}",
                      "successors": []
                    },
                    {
                      "id": 6,
                      "label": "} else if (typeof from === \"number\") {",
                      "successors": [
                        {
                          "id": 7,
                          "label": "return {\n  numberValue: from,\n}",
                          "successors": []
                        },
                        {
                          "id": 8,
                          "label": "} else if (typeof from === \"boolean\") {",
                          "successors": [
                            {
                              "id": 9,
                              "label": "return {\n  boolValue: from,\n}",
                              "successors": []
                            },
                            {
                              "id": 10,
                              "label": "} else {\nthrow new Error(\"Unsupported value type\")",
                              "successors": [
                                {
                                  "id": 12,
                                  "label": "}\n}",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "createCellData",
          "type": "function",
          "start_line": 655,
          "end_line": 662,
          "functions": [],
          "classes": [],
          "simplified_code": "  private createCellData(value: Value): CellData {\n    return {\n      userEnteredValue: this.createValue(value),\n      effectiveValue: this.createValue(value),\n      formattedValue: value?.toString() || \"\",\n      userEnteredFormat: DEFAULT_CELL_FORMAT,\n      effectiveFormat: DEFAULT_CELL_FORMAT,\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "private createCellData(value: Value): CellData {\n  return {",
              "successors": [
                {
                  "id": 3,
                  "label": "    userEnteredValue: this.createValue(value),",
                  "successors": []
                },
                {
                  "id": 4,
                  "label": "    effectiveValue: this.createValue(value),",
                  "successors": []
                },
                {
                  "id": 5,
                  "label": "    formattedValue: value?.toString() || \"\",",
                  "successors": []
                },
                {
                  "id": 6,
                  "label": "    userEnteredFormat: DEFAULT_CELL_FORMAT,",
                  "successors": []
                },
                {
                  "id": 7,
                  "label": "    effectiveFormat: DEFAULT_CELL_FORMAT,\n  };",
                  "successors": [
                    {
                      "id": 9,
                      "label": "}",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "createEmptyGrid",
          "type": "function",
          "start_line": 664,
          "end_line": 697,
          "functions": [],
          "classes": [],
          "simplified_code": "  private createEmptyGrid(numRows: number, numCols: number): GridData {\n    const rowData: RowData[] = []\n    for (let row = 0; row < numRows; row++) {\n      const cells: CellData[] = []\n      for (let col = 0; col < numCols; col++) {\n        cells.push(this.createCellData(null))\n      }\n      rowData.push({ values: cells })\n    }\n    const rowMetadata: WorksheetDimensionProperties[] = []\n    for (let row = 0; row < numRows; row++) {\n      rowMetadata.push({\n        hiddenByFilter: false,\n        hiddenByUser: false,\n        pixelSize: 100,\n        developerMetadata: [],\n      })\n    }\n    const columnMetadata: WorksheetDimensionProperties[] = []\n    for (let col = 0; col < numCols; col++) {\n      columnMetadata.push({\n        hiddenByFilter: false,\n        hiddenByUser: false,\n        pixelSize: 100,\n        developerMetadata: [],\n      })\n    }\n    return {\n      startRow: 0,\n      startColumn: 0,\n      rowData,\n      rowMetadata,\n      columnMetadata,\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "private createEmptyGrid(numRows: number, numCols: number): GridData {\nconst rowData: RowData[] = []",
              "successors": [
                {
                  "id": 3,
                  "label": "for (let row = 0; row < numRows; row++) {",
                  "successors": [
                    {
                      "id": 4,
                      "label": "const cells: CellData[] = []",
                      "successors": [
                        {
                          "id": 5,
                          "label": "for (let col = 0; col < numCols; col++) {",
                          "successors": [
                            {
                              "id": 6,
                              "label": "cells.push(this.createCellData(null))\n}",
                              "successors": [
                                {
                                  "id": 8,
                                  "label": "rowData.push({ values: cells })\n}",
                                  "successors": [
                                    {
                                      "id": 10,
                                      "label": "const rowMetadata: WorksheetDimensionProperties[] = []",
                                      "successors": [
                                        {
                                          "id": 11,
                                          "label": "for (let row = 0; row < numRows; row++) {",
                                          "successors": [
                                            {
                                              "id": 12,
                                              "label": "rowMetadata.push({\n  hiddenByFilter: false,\n  hiddenByUser: false,\n  pixelSize: 100,\n  developerMetadata: [],\n})\n}",
                                              "successors": [
                                                {
                                                  "id": 14,
                                                  "label": "const columnMetadata: WorksheetDimensionProperties[] = []",
                                                  "successors": [
                                                    {
                                                      "id": 15,
                                                      "label": "for (let col = 0; col < numCols; col++) {",
                                                      "successors": [
                                                        {
                                                          "id": 16,
                                                          "label": "columnMetadata.push({\n  hiddenByFilter: false,\n  hiddenByUser: false,\n  pixelSize: 100,\n  developerMetadata: [],\n})\n}",
                                                          "successors": [
                                                            {
                                                              "id": 18,
                                                              "label": "return {\n  startRow: 0,\n  startColumn: 0,\n  rowData,\n  rowMetadata,\n  columnMetadata,\n}\n}",
                                                              "successors": []
                                                            }
                                                          ]
                                                        }
                                                      ]
                                                    }
                                                  ]
                                                }
                                              ]
                                            }
                                          ]
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "cellData",
          "type": "function",
          "start_line": 699,
          "end_line": 703,
          "functions": [],
          "classes": [],
          "simplified_code": "  private cellData(cell: string): CellData | undefined {\n    const { sheetId, startColumnIndex, startRowIndex } =\n      this.parseA1Notation(cell)\n    return this.getCellNumericIndexes(sheetId, startRowIndex, startColumnIndex)\n  }",
          "blocks": [
            {
              "id": 1,
              "label": "private cellData(cell: string): CellData | undefined {\nconst { sheetId, startColumnIndex, startRowIndex } = this.parseA1Notation(cell)",
              "successors": [
                {
                  "id": 3,
                  "label": "return this.getCellNumericIndexes(sheetId, startRowIndex, startColumnIndex)\n}",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "getCellNumericIndexes",
          "type": "function",
          "start_line": 704,
          "end_line": 725,
          "functions": [],
          "classes": [],
          "simplified_code": "  private getCellNumericIndexes(\n    sheet: Sheet | number,\n    row: number,\n    column: number\n  ): CellData | undefined {\n    if (typeof sheet === \"number\") {\n      const foundSheet = this.getSheetById(sheet)\n      if (!foundSheet) {\n        return undefined\n      }\n      sheet = foundSheet\n    }\n    const data = sheet.data[0]\n    const rowData = data.rowData[row]\n    if (!rowData) {\n      return undefined\n    }\n    const cell = rowData.values[column]\n    if (!cell) {\n      return undefined\n    }\n    return cell",
          "blocks": [
            {
              "id": 1,
              "label": "if (typeof sheet === \"number\") {\n  const foundSheet = this.getSheetById(sheet)",
              "successors": [
                {
                  "id": 3,
                  "label": "  if (!foundSheet) {\n    return undefined",
                  "successors": []
                },
                {
                  "id": 5,
                  "label": "  sheet = foundSheet\n}",
                  "successors": [
                    {
                      "id": 7,
                      "label": "const data = sheet.data[0]\nconst rowData = data.rowData[row]",
                      "successors": [
                        {
                          "id": 9,
                          "label": "if (!rowData) {\n  return undefined",
                          "successors": []
                        },
                        {
                          "id": 11,
                          "label": "const cell = rowData.values[column]",
                          "successors": [
                            {
                              "id": 12,
                              "label": "if (!cell) {\n  return undefined",
                              "successors": []
                            },
                            {
                              "id": 14,
                              "label": "return cell",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "parseA1Notation",
          "type": "function",
          "start_line": 753,
          "end_line": 791,
          "functions": [],
          "classes": [],
          "simplified_code": "  private parseA1Notation(range: string): Required<GridRange> {\n    let sheet: Sheet\n    let rest: string\n    if (!range.includes(\"!\")) {\n      sheet = this.spreadsheet.sheets[0]\n      rest = range\n    } else {\n      let sheetName = range.split(\"!\")[0]\n      if (sheetName.startsWith(\"'\") && sheetName.endsWith(\"'\")) {\n        sheetName = sheetName.slice(1, -1)\n      }\n      const foundSheet = this.getSheetByName(sheetName)\n      if (!foundSheet) {\n        throw new Error(`Sheet ${sheetName} not found`)\n      }\n      sheet = foundSheet\n      rest = range.split(\"!\")[1]\n    }\n    const [topLeft, bottomRight] = rest.split(\":\")\n    const parsedTopLeft = topLeft ? this.parseCell(topLeft) : undefined\n    let parsedBottomRight = bottomRight\n      ? this.parseCell(bottomRight)\n      : undefined\n    if (!parsedTopLeft && !parsedBottomRight) {\n      throw new Error(\"No range provided\")\n    }\n    if (!parsedTopLeft) {\n      throw new Error(\"No top left cell provided\")\n    }\n    if (!parsedBottomRight) {\n      parsedBottomRight = parsedTopLeft\n    }\n    return this.ensureGridRange({\n      sheetId: sheet.properties.sheetId,\n      startRowIndex: parsedTopLeft.row,\n      endRowIndex: parsedBottomRight.row,\n      startColumnIndex: parsedTopLeft.column,\n      endColumnIndex: parsedBottomRight.column,\n    })",
          "blocks": [
            {
              "id": 1,
              "label": "private parseA1Notation(range: string): Required<GridRange> {\nlet sheet: Sheet\nlet rest: string",
              "successors": [
                {
                  "id": 3,
                  "label": "if (!range.includes(\"!\")) {",
                  "successors": [
                    {
                      "id": 4,
                      "label": "sheet = this.spreadsheet.sheets[0]\nrest = range\nconst [topLeft, bottomRight] = rest.split(\":\")",
                      "successors": []
                    },
                    {
                      "id": 5,
                      "label": "} else {\nlet sheetName = range.split(\"!\")[0]",
                      "successors": [
                        {
                          "id": 7,
                          "label": "if (sheetName.startsWith(\"'\") && sheetName.endsWith(\"'\")) {\nsheetName = sheetName.slice(1, -1)",
                          "successors": [
                            {
                              "id": 9,
                              "label": "}\nconst foundSheet = this.getSheetByName(sheetName)",
                              "successors": [
                                {
                                  "id": 11,
                                  "label": "if (!foundSheet) {",
                                  "successors": [
                                    {
                                      "id": 12,
                                      "label": "throw new Error(`Sheet ${sheetName} not found`)",
                                      "successors": []
                                    },
                                    {
                                      "id": 11,
                                      "label": "}\nsheet = foundSheet\nrest = range.split(\"!\")[1]",
                                      "successors": []
                                    }
                                  ]
                                },
                                {
                                  "id": 13,
                                  "label": "const [topLeft, bottomRight] = rest.split(\":\")",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "id": 15,
                  "label": "const parsedTopLeft = topLeft ? this.parseCell(topLeft) : undefined\nlet parsedBottomRight = bottomRight ? this.parseCell(bottomRight) : undefined\nif (!parsedTopLeft && !parsedBottomRight) {",
                  "successors": [
                    {
                      "id": 17,
                      "label": "throw new Error(\"No range provided\")",
                      "successors": []
                    },
                    {
                      "id": 16,
                      "label": "}",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "ensureGridRange",
          "type": "function",
          "start_line": 793,
          "end_line": 806,
          "functions": [],
          "classes": [],
          "simplified_code": "  private ensureGridRange(range: GridRange): Required<GridRange> {\n    const sheet = this.getSheetById(range.sheetId)\n    if (!sheet) {\n      throw new Error(`Sheet ${range.sheetId} not found`)\n    }\n    return {\n      sheetId: range.sheetId,\n      startRowIndex: range.startRowIndex ?? 0,\n      endRowIndex:\n        range.endRowIndex ?? sheet.properties.gridProperties.rowCount - 1,\n      startColumnIndex: range.startColumnIndex ?? 0,\n      endColumnIndex:\n        range.endColumnIndex ?? sheet.properties.gridProperties.columnCount - 1,\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "const sheet = this.getSheetById(range.sheetId)",
              "successors": [
                {
                  "id": 2,
                  "label": "if (!sheet) {\nthrow new Error(`Sheet ${range.sheetId} not found`)",
                  "successors": []
                },
                {
                  "id": 4,
                  "label": "}\nreturn {",
                  "successors": [
                    {
                      "id": 6,
                      "label": "sheetId: range.sheetId,\nstartRowIndex: range.startRowIndex ?? 0,",
                      "successors": [
                        {
                          "id": 8,
                          "label": "endRowIndex: range.endRowIndex ?? sheet.properties.gridProperties.rowCount - 1,\nstartColumnIndex: range.startColumnIndex ?? 0,",
                          "successors": [
                            {
                              "id": 10,
                              "label": "endColumnIndex: range.endColumnIndex ?? sheet.properties.gridProperties.columnCount - 1,\n}",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "createA1",
          "type": "function",
          "start_line": 808,
          "end_line": 828,
          "functions": [],
          "classes": [],
          "simplified_code": "  private createA1(range: Required<GridRange>) {\n    const {\n      sheetId,\n      startColumnIndex,\n      startRowIndex,\n      endColumnIndex,\n      endRowIndex,\n    } = range\n    const sheet = this.getSheetById(sheetId)\n    if (!sheet) {\n      throw new Error(`Sheet ${range.sheetId} not found`)\n    }\n    let title = sheet.properties.title\n    if (title.includes(\" \")) {\n      title = `'${title}'`\n    }\n    const topLeftLetter = this.numberToLetter(startColumnIndex)\n    const bottomRightLetter = this.numberToLetter(endColumnIndex)\n    const topLeftRow = startRowIndex + 1\n    const bottomRightRow = endRowIndex + 1\n    return `${title}!${topLeftLetter}${topLeftRow}:${bottomRightLetter}${bottomRightRow}`",
          "blocks": [
            {
              "id": 1,
              "label": "private createA1(range: Required<GridRange>) {\n    const {\n      sheetId,\n      startColumnIndex,\n      startRowIndex,\n      endColumnIndex,\n      endRowIndex,\n    } = range\nconst sheet = this.getSheetById(sheetId)",
              "successors": [
                {
                  "id": 3,
                  "label": "if (!sheet) {",
                  "successors": [
                    {
                      "id": 4,
                      "label": "  throw new Error(`Sheet ${range.sheetId} not found`)",
                      "successors": []
                    },
                    {
                      "id": 5,
                      "label": "}\nlet title = sheet.properties.title",
                      "successors": [
                        {
                          "id": 7,
                          "label": "if (title.includes(\" \")) {",
                          "successors": [
                            {
                              "id": 8,
                              "label": "  title = `'${title}'`",
                              "successors": []
                            },
                            {
                              "id": 9,
                              "label": "}\nconst topLeftLetter = this.numberToLetter(startColumnIndex)\nconst bottomRightLetter = this.numberToLetter(endColumnIndex)\nconst topLeftRow = startRowIndex + 1\nconst bottomRightRow = endRowIndex + 1",
                              "successors": [
                                {
                                  "id": 11,
                                  "label": "return `${title}!${topLeftLetter}${topLeftRow}:${bottomRightLetter}${bottomRightRow}`",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "parseCell",
          "type": "function",
          "start_line": 830,
          "end_line": 840,
          "functions": [],
          "classes": [],
          "simplified_code": "  private parseCell(cell: string): Partial<Range> {\n    const firstChar = cell.slice(0, 1)\n    if (this.isInteger(firstChar)) {\n      return { row: parseInt(cell) - 1 }\n    }\n    const column = this.letterToNumber(firstChar)\n    if (cell.length === 1) {\n      return { column }\n    }\n    const number = cell.slice(1)\n    return { row: parseInt(number) - 1, column }",
          "blocks": [
            {
              "id": 1,
              "label": "private parseCell(cell: string): Partial<Range> {\nconst firstChar = cell.slice(0, 1)",
              "successors": [
                {
                  "id": 3,
                  "label": "if (this.isInteger(firstChar)) {\nreturn { row: parseInt(cell) - 1 }",
                  "successors": [
                    {
                      "id": 9,
                      "label": "}\nconst column = this.letterToNumber(firstChar)\nif (cell.length === 1) {",
                      "successors": [
                        {
                          "id": 11,
                          "label": "return { column }\n}",
                          "successors": [
                            {
                              "id": 13,
                              "label": "const number = cell.slice(1)\nreturn { row: parseInt(number) - 1, column }\n}\n}",
                              "successors": []
                            }
                          ]
                        },
                        {
                          "id": 13,
                          "label": "const number = cell.slice(1)\nreturn { row: parseInt(number) - 1, column }\n}\n}",
                          "successors": []
                        }
                      ]
                    }
                  ]
                },
                {
                  "id": 10,
                  "label": "const column = this.letterToNumber(firstChar)\nif (cell.length === 1) {",
                  "successors": [
                    {
                      "id": 11,
                      "label": "return { column }\n}",
                      "successors": [
                        {
                          "id": 13,
                          "label": "const number = cell.slice(1)\nreturn { row: parseInt(number) - 1, column }\n}\n}",
                          "successors": []
                        }
                      ]
                    },
                    {
                      "id": 13,
                      "label": "const number = cell.slice(1)\nreturn { row: parseInt(number) - 1, column }\n}\n}",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "isInteger",
          "type": "function",
          "start_line": 842,
          "end_line": 843,
          "functions": [],
          "classes": [],
          "simplified_code": "  private isInteger(value: string): boolean {\n    return !isNaN(parseInt(value))",
          "blocks": [
            {
              "id": 1,
              "label": "private isInteger(value: string): boolean {\n  return !isNaN(parseInt(value))",
              "successors": []
            }
          ]
        },
        {
          "name": "letterToNumber",
          "type": "function",
          "start_line": 845,
          "end_line": 846,
          "functions": [],
          "classes": [],
          "simplified_code": "  private letterToNumber(letter: string): number {\n    return letter.charCodeAt(0) - 65",
          "blocks": [
            {
              "id": 1,
              "label": "private letterToNumber(letter: string): number {\n    return letter.charCodeAt(0) - 65",
              "successors": []
            }
          ]
        },
        {
          "name": "numberToLetter",
          "type": "function",
          "start_line": 848,
          "end_line": 849,
          "functions": [],
          "classes": [],
          "simplified_code": "  private numberToLetter(number: number): string {\n    return String.fromCharCode(number + 65)",
          "blocks": [
            {
              "id": 1,
              "label": "private numberToLetter(number: number): string {\n  return String.fromCharCode(number + 65)",
              "successors": []
            }
          ]
        },
        {
          "name": "getSheetByName",
          "type": "function",
          "start_line": 851,
          "end_line": 854,
          "functions": [],
          "classes": [],
          "simplified_code": "  private getSheetByName(name: string): Sheet | undefined {\n    return this.spreadsheet.sheets.find(\n      sheet => sheet.properties.title === name\n    )",
          "blocks": [
            {
              "id": 1,
              "label": "private getSheetByName(name: string): Sheet | undefined {\nreturn this.spreadsheet.sheets.find(sheet => sheet.properties.title === name)",
              "successors": []
            }
          ]
        },
        {
          "name": "getSheetById",
          "type": "function",
          "start_line": 856,
          "end_line": 859,
          "functions": [],
          "classes": [],
          "simplified_code": "  private getSheetById(id: number): Sheet | undefined {\n    return this.spreadsheet.sheets.find(\n      sheet => sheet.properties.sheetId === id\n    )",
          "blocks": [
            {
              "id": 1,
              "label": "private getSheetById(id: number): Sheet | undefined {\nreturn this.spreadsheet.sheets.find(",
              "successors": [
                {
                  "id": 3,
                  "label": "sheet => sheet.properties.sheetId === id",
                  "successors": []
                }
              ]
            }
          ]
        }
      ],
      "simplified_code": "export class GoogleSheetsMock {\n  private config: GoogleSheetsConfig\n  private spreadsheet: Spreadsheet\n  }\n  }\n  }\n  }\n  }\n  }\n  }\n  }\n  }\n  }\n  }\n    )\n  }\n    }\n  }\n  }\n  }\n  }\n  }\n  }\n  }\n  }\n    return response\n  }\n  }\n    }\n  }\n  }\n  // When Google Sheets returns a value range, it will trim the data down to the\n  // smallest possible size. It does all of the following:\n  //\n  // 1. Converts cells in non-empty rows up to the first value to empty strings.\n  // 2. Removes all cells after the last non-empty cell in a row.\n  // 3. Removes all rows after the last non-empty row.\n  // 4. Rows that are before the first non-empty row that are empty are replaced with [].\n  //\n  // We replicate this behaviour here.\n  }\n    }\n  }\n    }\n  }\n  }\n    }\n  }\n    }\n  }\n    }\n  }\n  }\n    return cell\n  }\n  // https://developers.google.com/sheets/api/guides/concepts#cell\n  //\n  // Examples from\n  //   https://code.luasoftware.com/tutorials/google-sheets-api/google-sheets-api-range-parameter-a1-notation\n  //\n  //   \"Sheet1!A1\"     -> First cell on Row 1 Col 1\n  //   \"Sheet1!A1:C1\"  -> Col 1-3 (A, B, C) on Row 1 = A1, B1, C1\n  //   \"A1\"            -> First visible sheet (if sheet name is ommitted)\n  //   \"'My Sheet'!A1\" -> If sheet name which contain space or start with a bracket.\n  //   \"Sheet1\"        -> All cells in Sheet1.\n  //   \"Sheet1!A:A\"    -> All cells on Col 1.\n  //   \"Sheet1!A:B\"    -> All cells on Col 1 and 2.\n  //   \"Sheet1!1:1\"    -> All cells on Row 1.\n  //   \"Sheet1!1:2\"    -> All cells on Row 1 and 2.\n  //\n  // How that translates to our code below, omitting the `sheet` property:\n  //\n  //   \"Sheet1!A1\"     -> { topLeft: { row: 0, column: 0 }, bottomRight: { row: 0, column: 0 } }\n  //   \"Sheet1!A1:C1\"  -> { topLeft: { row: 0, column: 0 }, bottomRight: { row: 0, column: 2 } }\n  //   \"A1\"            -> { topLeft: { row: 0, column: 0 }, bottomRight: { row: 0, column: 0 } }\n  //   \"Sheet1\"        -> { topLeft: { row: 0, column: 0 }, bottomRight: { row: 100, column: 25 } }\n  //                    -> This is because we default to having a 100x26 grid.\n  //   \"Sheet1!A:A\"    -> { topLeft: { row: 0, column: 0 }, bottomRight: { row: 99, column: 0 } }\n  //   \"Sheet1!A:B\"    -> { topLeft: { row: 0, column: 0 }, bottomRight: { row: 99, column: 1 } }\n  //   \"Sheet1!1:1\"    -> { topLeft: { row: 0, column: 0 }, bottomRight: { row: 0, column: 25 } }\n  //   \"Sheet1!1:2\"    -> { topLeft: { row: 0, column: 0 }, bottomRight: { row: 1, column: 25 } }\n    })\n  }\n    }\n  }\n    return `${title}!${topLeftLetter}${topLeftRow}:${bottomRightLetter}${bottomRightRow}`\n  }\n    return { row: parseInt(number) - 1, column }\n  }\n    return !isNaN(parseInt(value))\n  }\n    return letter.charCodeAt(0) - 65\n  }\n    return String.fromCharCode(number + 65)\n  }\n    )\n  }\n    )\n  }\n}",
      "blocks": [
        {
          "id": 1,
          "label": "export class GoogleSheetsMock {\n  private config: GoogleSheetsConfig\n  private spreadsheet: Spreadsheet",
          "successors": []
        }
      ]
    }
  ],
  "simplified_code": "// In this file is a mock implementation of the Google Sheets API.  It is used\n// to test the Google Sheets integration, and it keeps track of a single\n// spreadsheet with many sheets. It aims to be a faithful recreation of the\n// Google Sheets API, but it is not a perfect recreation. Some fields are\n// missing if they aren't relevant to our use of the API. It's possible that\n// this will cause problems for future feature development, but the original\n// development of these tests involved hitting Google's APIs directly and\n// examining the responses. If we couldn't find a good example of something in\n// use, it wasn't included.\nimport { Datasource } from \"@budibase/types\"\nimport nock from \"nock\"\nimport { GoogleSheetsConfig } from \"../../googlesheets\"\nimport type {\n  SpreadsheetProperties,\n  ExtendedValue,\n  WorksheetDimension,\n  WorksheetDimensionProperties,\n  WorksheetProperties,\n  CellData,\n  CellBorder,\n  CellFormat,\n  CellPadding,\n  Color,\n  GridRange,\n  DataSourceSheetProperties,\n} from \"google-spreadsheet/src/lib/types/sheets-types\"\nconst BLACK: Color = { red: 0, green: 0, blue: 0 }\nconst WHITE: Color = { red: 1, green: 1, blue: 1 }\nconst NO_PADDING: CellPadding = { top: 0, right: 0, bottom: 0, left: 0 }\nconst DEFAULT_BORDER: CellBorder = {\n  style: \"SOLID\",\n  width: 1,\n  color: BLACK,\n  colorStyle: { rgbColor: BLACK },\n}\nconst DEFAULT_CELL_FORMAT: CellFormat = {\n  hyperlinkDisplayType: \"PLAIN_TEXT\",\n  horizontalAlignment: \"LEFT\",\n  verticalAlignment: \"BOTTOM\",\n  wrapStrategy: \"OVERFLOW_CELL\",\n  textDirection: \"LEFT_TO_RIGHT\",\n  textRotation: { angle: 0, vertical: false },\n  padding: NO_PADDING,\n  backgroundColorStyle: { rgbColor: BLACK },\n  borders: {\n    top: DEFAULT_BORDER,\n    bottom: DEFAULT_BORDER,\n    left: DEFAULT_BORDER,\n    right: DEFAULT_BORDER,\n  },\n  numberFormat: {\n    type: \"NUMBER\",\n    pattern: \"General\",\n  },\n  backgroundColor: WHITE,\n  textFormat: {\n    foregroundColor: BLACK,\n    fontFamily: \"Arial\",\n    fontSize: 10,\n    bold: false,\n    italic: false,\n    strikethrough: false,\n    underline: false,\n  },\n}\n// https://protobuf.dev/reference/protobuf/google.protobuf/#value\ntype Value = string | number | boolean | null\ninterface Range {\n  row: number\n  column: number\n}\n// https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets.values#ValueRange\ninterface ValueRange {\n  range: string\n  majorDimension: WorksheetDimension\n  values: Value[][]\n}\n// https://developers.google.com/sheets/api/reference/rest/v4/UpdateValuesResponse\ninterface UpdateValuesResponse {\n  spreadsheetId: string\n  updatedRange: string\n  updatedRows: number\n  updatedColumns: number\n  updatedCells: number\n  updatedData: ValueRange\n}\n// https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/request#AddSheetRequest\ninterface AddSheetRequest {\n  properties: Partial<WorksheetProperties>\n}\n// https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/response#AddSheetResponse\ninterface AddSheetResponse {\n  properties: WorksheetProperties\n}\ninterface DeleteRangeRequest {\n  range: GridRange\n  shiftDimension: WorksheetDimension\n}\n// https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/request#DeleteSheetRequest\ninterface DeleteSheetRequest {\n  sheetId: number\n}\n// https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/request\ninterface BatchUpdateRequest {\n  requests: {\n    addSheet?: AddSheetRequest\n    deleteRange?: DeleteRangeRequest\n    deleteSheet?: DeleteSheetRequest\n  }[]\n  includeSpreadsheetInResponse: boolean\n  responseRanges: string[]\n  responseIncludeGridData: boolean\n}\n// https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/response\ninterface BatchUpdateResponse {\n  spreadsheetId: string\n  replies: {\n    addSheet?: AddSheetResponse\n  }[]\n  updatedSpreadsheet: Spreadsheet\n}\n// https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/sheets#RowData\ninterface RowData {\n  values: CellData[]\n}\n// https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/sheets#GridData\ninterface GridData {\n  startRow: number\n  startColumn: number\n  rowData: RowData[]\n  rowMetadata: WorksheetDimensionProperties[]\n  columnMetadata: WorksheetDimensionProperties[]\n}\n// https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/sheets#Sheet\ninterface Sheet {\n  properties: WorksheetProperties\n  data: GridData[]\n}\n// https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets#Spreadsheet\ninterface Spreadsheet {\n  properties: SpreadsheetProperties\n  spreadsheetId: string\n  sheets: Sheet[]\n}\n// https://developers.google.com/sheets/api/reference/rest/v4/ValueInputOption\ntype ValueInputOption =\n  | \"USER_ENTERED\"\n  | \"RAW\"\n  | \"INPUT_VALUE_OPTION_UNSPECIFIED\"\n// https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets.values/append#InsertDataOption\ntype InsertDataOption = \"OVERWRITE\" | \"INSERT_ROWS\"\n// https://developers.google.com/sheets/api/reference/rest/v4/ValueRenderOption\ntype ValueRenderOption = \"FORMATTED_VALUE\" | \"UNFORMATTED_VALUE\" | \"FORMULA\"\n// https://developers.google.com/sheets/api/reference/rest/v4/DateTimeRenderOption\ntype DateTimeRenderOption = \"SERIAL_NUMBER\" | \"FORMATTED_STRING\"\n// https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets.values/append#query-parameters\ninterface AppendParams {\n  valueInputOption?: ValueInputOption\n  insertDataOption?: InsertDataOption\n  includeValuesInResponse?: boolean\n  responseValueRenderOption?: ValueRenderOption\n  responseDateTimeRenderOption?: DateTimeRenderOption\n}\n// https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets.values/batchGet#query-parameters\ninterface BatchGetParams {\n  ranges: string[]\n  majorDimension?: WorksheetDimension\n  valueRenderOption?: ValueRenderOption\n  dateTimeRenderOption?: DateTimeRenderOption\n}\n// https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets.values/batchGet#response-body\ninterface BatchGetResponse {\n  spreadsheetId: string\n  valueRanges: ValueRange[]\n}\ninterface AppendRequest {\n  range: string\n  params: AppendParams\n  body: ValueRange\n}\n// https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets.values/append#response-body\ninterface AppendResponse {\n  spreadsheetId: string\n  tableRange: string\n  updates: UpdateValuesResponse\n}\n}",
  "blocks": [
    {
      "id": 1,
      "label": "import { Datasource } from \"@budibase/types\"\nimport nock from \"nock\"\nimport { GoogleSheetsConfig } from \"../../googlesheets\"\nimport type {\n  SpreadsheetProperties,\n  ExtendedValue,\n  WorksheetDimension,\n  WorksheetDimensionProperties,\n  WorksheetProperties,\n  CellData,\n  CellBorder,\n  CellFormat,\n  CellPadding,\n  Color,\n  GridRange,\n  DataSourceSheetProperties,\n} from \"google-spreadsheet/src/lib/types/sheets-types\"\nconst BLACK: Color = { red: 0, green: 0, blue: 0 }\nconst WHITE: Color = { red: 1, green: 1, blue: 1 }\nconst NO_PADDING: CellPadding = { top: 0, right: 0, bottom: 0, left: 0 }\nconst DEFAULT_BORDER: CellBorder = {\n  style: \"SOLID\",\n  width: 1,\n  color: BLACK,\n  colorStyle: { rgbColor: BLACK },\n}\nconst DEFAULT_CELL_FORMAT: CellFormat = {\n  hyperlinkDisplayType: \"PLAIN_TEXT\",\n  horizontalAlignment: \"LEFT\",\n  verticalAlignment: \"BOTTOM\",\n  wrapStrategy: \"OVERFLOW_CELL\",\n  textDirection: \"LEFT_TO_RIGHT\",\n  textRotation: { angle: 0, vertical: false },\n  padding: NO_PADDING,\n  backgroundColorStyle: { rgbColor: BLACK },\n  borders: {\n    top: DEFAULT_BORDER,\n    bottom: DEFAULT_BORDER,\n    left: DEFAULT_BORDER,\n    right: DEFAULT_BORDER,\n  },\n  numberFormat: {\n    type: \"NUMBER\",\n    pattern: \"General\",\n  },\n  backgroundColor: WHITE,\n  textFormat: {\n    foregroundColor: BLACK,\n    fontFamily: \"Arial\",\n    fontSize: 10,\n    bold: false,\n    italic: false,\n    strikethrough: false,\n    underline: false,\n  },\n}\n// https://protobuf.dev/reference/protobuf/google.protobuf/#value\ntype Value = string | number | boolean | null\ninterface Range {\n  row: number\n  column: number\n}\n// https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets.values#ValueRange\ninterface ValueRange {\n  range: string\n  majorDimension: WorksheetDimension\n  values: Value[][]\n}\n// https://developers.google.com/sheets/api/reference/rest/v4/UpdateValuesResponse\ninterface UpdateValuesResponse {\n  spreadsheetId: string\n  updatedRange: string\n  updatedRows: number\n  updatedColumns: number\n  updatedCells: number\n  updatedData: ValueRange\n}\n// https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/request#AddSheetRequest\ninterface AddSheetRequest {\n  properties: Partial<WorksheetProperties>\n}\n// https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/response#AddSheetResponse\ninterface AddSheetResponse {\n  properties: WorksheetProperties\n}\ninterface DeleteRangeRequest {\n  range: GridRange\n  shiftDimension: WorksheetDimension\n}\n// https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/request#DeleteSheetRequest\ninterface DeleteSheetRequest {\n  sheetId: number\n}\n// https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/request\ninterface BatchUpdateRequest {\n  requests: {\n    addSheet?: AddSheetRequest\n    deleteRange?: DeleteRangeRequest\n    deleteSheet?: DeleteSheetRequest\n  }[]\n  includeSpreadsheetInResponse: boolean\n  responseRanges: string[]\n  responseIncludeGridData: boolean\n}\n// https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/response\ninterface BatchUpdateResponse {\n  spreadsheetId: string\n  replies: {\n    addSheet?: AddSheetResponse\n  }[]\n  updatedSpreadsheet: Spreadsheet\n}\n// https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/sheets#RowData\ninterface RowData {\n  values: CellData[]\n}\n// https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/sheets#GridData\ninterface GridData {\n  startRow: number\n  startColumn: number\n  rowData: RowData[]\n  rowMetadata: WorksheetDimensionProperties[]\n  columnMetadata: WorksheetDimensionProperties[]\n}\n// https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/sheets#Sheet\ninterface Sheet {\n  properties: WorksheetProperties\n  data: GridData[]\n}\n// https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets#Spreadsheet\ninterface Spreadsheet {\n  properties: SpreadsheetProperties\n  spreadsheetId: string\n  sheets: Sheet[]\n}\n// https://developers.google.com/sheets/api/reference/rest/v4/ValueInputOption\ntype ValueInputOption =\n  | \"USER_ENTERED\"\n  | \"RAW\"\n  | \"INPUT_VALUE_OPTION_UNSPECIFIED\"\n// https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets.values/append#InsertDataOption\ntype InsertDataOption = \"OVERWRITE\" | \"INSERT_ROWS\"\n// https://developers.google.com/sheets/api/reference/rest/v4/ValueRenderOption\ntype ValueRenderOption = \"FORMATTED_VALUE\" | \"UNFORMATTED_VALUE\" | \"FORMULA\"\n// https://developers.google.com/sheets/api/reference/rest/v4/DateTimeRenderOption\ntype DateTimeRenderOption = \"SERIAL_NUMBER\" | \"FORMATTED_STRING\"\n// https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets.values/append#query-parameters\ninterface AppendParams {\n  valueInputOption?: ValueInputOption\n  insertDataOption?: InsertDataOption\n  includeValuesInResponse?: boolean\n  responseValueRenderOption?: ValueRenderOption\n  responseDateTimeRenderOption?: DateTimeRenderOption\n}\n// https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets.values/batchGet#query-parameters\ninterface BatchGetParams {\n  ranges: string[]\n  majorDimension?: WorksheetDimension\n  valueRenderOption?: ValueRenderOption\n  dateTimeRenderOption?: DateTimeRenderOption\n}\n// https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets.values/batchGet#response-body\ninterface BatchGetResponse {\n  spreadsheetId: string\n  valueRanges: ValueRange[]\n}\ninterface AppendRequest {\n  range: string\n  params: AppendParams\n  body: ValueRange\n}\n// https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets.values/append#response-body\ninterface AppendResponse {\n  spreadsheetId: string\n  tableRange: string\n  updates: UpdateValuesResponse\n}\n}\n}",
      "successors": []
    }
  ]
}