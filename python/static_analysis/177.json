{
  "nodes": [
    {
      "id": "n0",
      "type": "block",
      "statements": [
        "from contextlib import contextmanager",
        "from threading import Lock",
        "from typing import TYPE_CHECKING, Any",
        "from expiringdict import ExpiringDict",
        "TYPE_CHECKING"
      ],
      "code": "from contextlib import contextmanager\nfrom threading import Lock\nfrom typing import TYPE_CHECKING, Any\nfrom expiringdict import ExpiringDict\nTYPE_CHECKING"
    },
    {
      "id": "n1",
      "type": "block",
      "statements": [
        "from redis import Redis",
        "from redis.lock import Lock as RedisLock"
      ],
      "code": "from redis import Redis\nfrom redis.lock import Lock as RedisLock"
    },
    {
      "id": "n2",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n3",
      "type": "block",
      "statements": [
        "class RedisKeyedMutex:\n    \"\"\"\n    This class provides a mutex that can be locked and unlocked by a specific key,\n    using Redis as a distributed locking provider.\n    It uses an ExpiringDict to automatically clear the mutex after a specified timeout,\n    in case the key is not unlocked for a specified duration, to prevent memory leaks.\n    \"\"\"\n\n    def __init__(self, redis: 'Redis', timeout: int | None=60):\n        self.redis = redis\n        self.timeout = timeout\n        self.locks: dict[Any, 'RedisLock'] = ExpiringDict(max_len=6000, max_age_seconds=self.timeout)\n        self.locks_lock = Lock()\n\n    @contextmanager\n    def locked(self, key: Any):\n        lock = self.acquire(key)\n        try:\n            yield\n        finally:\n            if lock.locked():\n                lock.release()\n\n    def acquire(self, key: Any) -> 'RedisLock':\n        \"\"\"Acquires and returns a lock with the given key\"\"\"\n        with self.locks_lock:\n            if key not in self.locks:\n                self.locks[key] = self.redis.lock(str(key), self.timeout, thread_local=False)\n            lock = self.locks[key]\n        lock.acquire()\n        return lock\n\n    def release(self, key: Any):\n        if (lock := self.locks.get(key)) and lock.locked() and lock.owned():\n            lock.release()\n\n    def release_all_locks(self):\n        \"\"\"Call this on process termination to ensure all locks are released\"\"\"\n        self.locks_lock.acquire(blocking=False)\n        for lock in self.locks.values():\n            if lock.locked() and lock.owned():\n                lock.release()",
        "'\\n    This class provides a mutex that can be locked and unlocked by a specific key,\\n    using Redis as a distributed locking provider.\\n    It uses an ExpiringDict to automatically clear the mutex after a specified timeout,\\n    in case the key is not unlocked for a specified duration, to prevent memory leaks.\\n    '",
        "def __init__(self, redis: 'Redis', timeout: int | None=60):\n    self.redis = redis\n    self.timeout = timeout\n    self.locks: dict[Any, 'RedisLock'] = ExpiringDict(max_len=6000, max_age_seconds=self.timeout)\n    self.locks_lock = Lock()",
        "self.redis = redis",
        "self.timeout = timeout",
        "self.locks: dict[Any, 'RedisLock'] = ExpiringDict(max_len=6000, max_age_seconds=self.timeout)",
        "self.locks_lock = Lock()",
        "@contextmanager\ndef locked(self, key: Any):\n    lock = self.acquire(key)\n    try:\n        yield\n    finally:\n        if lock.locked():\n            lock.release()",
        "lock = self.acquire(key)",
        "try:\n    yield\nfinally:\n    if lock.locked():\n        lock.release()",
        "(yield)",
        "lock.locked()"
      ],
      "code": "class RedisKeyedMutex:\n    \"\"\"\n    This class provides a mutex that can be locked and unlocked by a specific key,\n    using Redis as a distributed locking provider.\n    It uses an ExpiringDict to automatically clear the mutex after a specified timeout,\n    in case the key is not unlocked for a specified duration, to prevent memory leaks.\n    \"\"\"\n\n    def __init__(self, redis: 'Redis', timeout: int | None=60):\n        self.redis = redis\n        self.timeout = timeout\n        self.locks: dict[Any, 'RedisLock'] = ExpiringDict(max_len=6000, max_age_seconds=self.timeout)\n        self.locks_lock = Lock()\n\n    @contextmanager\n    def locked(self, key: Any):\n        lock = self.acquire(key)\n        try:\n            yield\n        finally:\n            if lock.locked():\n                lock.release()\n\n    def acquire(self, key: Any) -> 'RedisLock':\n        \"\"\"Acquires and returns a lock with the given key\"\"\"\n        with self.locks_lock:\n            if key not in self.locks:\n                self.locks[key] = self.redis.lock(str(key), self.timeout, thread_local=False)\n            lock = self.locks[key]\n        lock.acquire()\n        return lock\n\n    def release(self, key: Any):\n        if (lock := self.locks.get(key)) and lock.locked() and lock.owned():\n            lock.release()\n\n    def release_all_locks(self):\n        \"\"\"Call this on process termination to ensure all locks are released\"\"\"\n        self.locks_lock.acquire(blocking=False)\n        for lock in self.locks.values():\n            if lock.locked() and lock.owned():\n                lock.release()\n'\\n    This class provides a mutex that can be locked and unlocked by a specific key,\\n    using Redis as a distributed locking provider.\\n    It uses an ExpiringDict to automatically clear the mutex after a specified timeout,\\n    in case the key is not unlocked for a specified duration, to prevent memory leaks.\\n    '\ndef __init__(self, redis: 'Redis', timeout: int | None=60):\n    self.redis = redis\n    self.timeout = timeout\n    self.locks: dict[Any, 'RedisLock'] = ExpiringDict(max_len=6000, max_age_seconds=self.timeout)\n    self.locks_lock = Lock()\nself.redis = redis\nself.timeout = timeout\nself.locks: dict[Any, 'RedisLock'] = ExpiringDict(max_len=6000, max_age_seconds=self.timeout)\nself.locks_lock = Lock()\n@contextmanager\ndef locked(self, key: Any):\n    lock = self.acquire(key)\n    try:\n        yield\n    finally:\n        if lock.locked():\n            lock.release()\nlock = self.acquire(key)\ntry:\n    yield\nfinally:\n    if lock.locked():\n        lock.release()\n(yield)\nlock.locked()"
    },
    {
      "id": "n4",
      "type": "block",
      "statements": [
        "lock.release()"
      ],
      "code": "lock.release()"
    },
    {
      "id": "n5",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n6",
      "type": "block",
      "statements": [
        "def acquire(self, key: Any) -> 'RedisLock':\n    \"\"\"Acquires and returns a lock with the given key\"\"\"\n    with self.locks_lock:\n        if key not in self.locks:\n            self.locks[key] = self.redis.lock(str(key), self.timeout, thread_local=False)\n        lock = self.locks[key]\n    lock.acquire()\n    return lock",
        "'Acquires and returns a lock with the given key'",
        "with self.locks_lock:\n    if key not in self.locks:\n        self.locks[key] = self.redis.lock(str(key), self.timeout, thread_local=False)\n    lock = self.locks[key]",
        "key NotIn self.locks"
      ],
      "code": "def acquire(self, key: Any) -> 'RedisLock':\n    \"\"\"Acquires and returns a lock with the given key\"\"\"\n    with self.locks_lock:\n        if key not in self.locks:\n            self.locks[key] = self.redis.lock(str(key), self.timeout, thread_local=False)\n        lock = self.locks[key]\n    lock.acquire()\n    return lock\n'Acquires and returns a lock with the given key'\nwith self.locks_lock:\n    if key not in self.locks:\n        self.locks[key] = self.redis.lock(str(key), self.timeout, thread_local=False)\n    lock = self.locks[key]\nkey NotIn self.locks"
    },
    {
      "id": "n7",
      "type": "block",
      "statements": [
        "self.locks[key] = self.redis.lock(str(key), self.timeout, thread_local=False)"
      ],
      "code": "self.locks[key] = self.redis.lock(str(key), self.timeout, thread_local=False)"
    },
    {
      "id": "n8",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n9",
      "type": "block",
      "statements": [
        "lock = self.locks[key]",
        "lock.acquire()",
        "return lock"
      ],
      "code": "lock = self.locks[key]\nlock.acquire()\nreturn lock"
    },
    {
      "id": "n10",
      "type": "block",
      "statements": [
        "def release(self, key: Any):\n    if (lock := self.locks.get(key)) and lock.locked() and lock.owned():\n        lock.release()",
        "(lock := self.locks.get(key)) and lock.locked() and lock.owned()"
      ],
      "code": "def release(self, key: Any):\n    if (lock := self.locks.get(key)) and lock.locked() and lock.owned():\n        lock.release()\n(lock := self.locks.get(key)) and lock.locked() and lock.owned()"
    },
    {
      "id": "n11",
      "type": "block",
      "statements": [
        "lock.release()"
      ],
      "code": "lock.release()"
    },
    {
      "id": "n12",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n13",
      "type": "block",
      "statements": [
        "def release_all_locks(self):\n    \"\"\"Call this on process termination to ensure all locks are released\"\"\"\n    self.locks_lock.acquire(blocking=False)\n    for lock in self.locks.values():\n        if lock.locked() and lock.owned():\n            lock.release()",
        "'Call this on process termination to ensure all locks are released'",
        "self.locks_lock.acquire()"
      ],
      "code": "def release_all_locks(self):\n    \"\"\"Call this on process termination to ensure all locks are released\"\"\"\n    self.locks_lock.acquire(blocking=False)\n    for lock in self.locks.values():\n        if lock.locked() and lock.owned():\n            lock.release()\n'Call this on process termination to ensure all locks are released'\nself.locks_lock.acquire()"
    },
    {
      "id": "n14",
      "type": "block",
      "statements": [
        "lock",
        "self.locks.values()"
      ],
      "code": "lock\nself.locks.values()"
    },
    {
      "id": "n15",
      "type": "block",
      "statements": [
        "lock.locked() and lock.owned()"
      ],
      "code": "lock.locked() and lock.owned()"
    },
    {
      "id": "n16",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n17",
      "type": "block",
      "statements": [
        "lock.release()"
      ],
      "code": "lock.release()"
    },
    {
      "id": "n18",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n19",
      "type": "block",
      "statements": [],
      "code": ""
    }
  ],
  "edges": [
    {
      "source": "n19",
      "target": "n14"
    },
    {
      "source": "n15",
      "target": "n18"
    },
    {
      "source": "n6",
      "target": "n7"
    },
    {
      "source": "n14",
      "target": "n15"
    },
    {
      "source": "n0",
      "target": "n1"
    },
    {
      "source": "n10",
      "target": "n11"
    },
    {
      "source": "n17",
      "target": "n19"
    },
    {
      "source": "n2",
      "target": "n3"
    },
    {
      "source": "n13",
      "target": "n14"
    },
    {
      "source": "n11",
      "target": "n13"
    },
    {
      "source": "n8",
      "target": "n9"
    },
    {
      "source": "n3",
      "target": "n4"
    },
    {
      "source": "n4",
      "target": "n6"
    },
    {
      "source": "n12",
      "target": "n13"
    },
    {
      "source": "n14",
      "target": "n16"
    },
    {
      "source": "n10",
      "target": "n12"
    },
    {
      "source": "n18",
      "target": "n19"
    },
    {
      "source": "n7",
      "target": "n9"
    },
    {
      "source": "n5",
      "target": "n6"
    },
    {
      "source": "n1",
      "target": "n3"
    },
    {
      "source": "n3",
      "target": "n5"
    },
    {
      "source": "n6",
      "target": "n8"
    },
    {
      "source": "n0",
      "target": "n2"
    },
    {
      "source": "n15",
      "target": "n17"
    }
  ]
}