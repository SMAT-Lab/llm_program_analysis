{
  "nodes": [
    {
      "id": "n0",
      "type": "block",
      "statements": [
        "'\\nIn this problem, we want to determine all possible combinations of k\\nnumbers out of 1 ... n. We use backtracking to solve this problem.\\n\\nTime complexity: O(C(n,k)) which is O(n choose k) = O((n!/(k! * (n - k)!))),\\n'",
        "from __future__ import annotations",
        "from itertools import combinations",
        "def combination_lists(n: int, k: int) -> list[list[int]]:\n    \"\"\"\n    >>> combination_lists(n=4, k=2)\n    [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n    \"\"\"\n    return [list(x) for x in combinations(range(1, n + 1), k)]",
        "'\\n    >>> combination_lists(n=4, k=2)\\n    [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\\n    '",
        "return [list(x) for x in combinations(range(1, n + 1), k)]"
      ],
      "code": "'\\nIn this problem, we want to determine all possible combinations of k\\nnumbers out of 1 ... n. We use backtracking to solve this problem.\\n\\nTime complexity: O(C(n,k)) which is O(n choose k) = O((n!/(k! * (n - k)!))),\\n'\nfrom __future__ import annotations\nfrom itertools import combinations\ndef combination_lists(n: int, k: int) -> list[list[int]]:\n    \"\"\"\n    >>> combination_lists(n=4, k=2)\n    [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n    \"\"\"\n    return [list(x) for x in combinations(range(1, n + 1), k)]\n'\\n    >>> combination_lists(n=4, k=2)\\n    [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\\n    '\nreturn [list(x) for x in combinations(range(1, n + 1), k)]"
    },
    {
      "id": "n1",
      "type": "block",
      "statements": [
        "def generate_all_combinations(n: int, k: int) -> list[list[int]]:\n    \"\"\"\n    >>> generate_all_combinations(n=4, k=2)\n    [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n    >>> generate_all_combinations(n=0, k=0)\n    [[]]\n    >>> generate_all_combinations(n=10, k=-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: k must not be negative\n    >>> generate_all_combinations(n=-1, k=10)\n    Traceback (most recent call last):\n        ...\n    ValueError: n must not be negative\n    >>> generate_all_combinations(n=5, k=4)\n    [[1, 2, 3, 4], [1, 2, 3, 5], [1, 2, 4, 5], [1, 3, 4, 5], [2, 3, 4, 5]]\n    >>> from itertools import combinations\n    >>> all(generate_all_combinations(n, k) == combination_lists(n, k)\n    ...     for n in range(1, 6) for k in range(1, 6))\n    True\n    \"\"\"\n    if k < 0:\n        raise ValueError('k must not be negative')\n    if n < 0:\n        raise ValueError('n must not be negative')\n    result: list[list[int]] = []\n    create_all_state(1, n, k, [], result)\n    return result",
        "'\\n    >>> generate_all_combinations(n=4, k=2)\\n    [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\\n    >>> generate_all_combinations(n=0, k=0)\\n    [[]]\\n    >>> generate_all_combinations(n=10, k=-1)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: k must not be negative\\n    >>> generate_all_combinations(n=-1, k=10)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: n must not be negative\\n    >>> generate_all_combinations(n=5, k=4)\\n    [[1, 2, 3, 4], [1, 2, 3, 5], [1, 2, 4, 5], [1, 3, 4, 5], [2, 3, 4, 5]]\\n    >>> from itertools import combinations\\n    >>> all(generate_all_combinations(n, k) == combination_lists(n, k)\\n    ...     for n in range(1, 6) for k in range(1, 6))\\n    True\\n    '",
        "k Lt 0"
      ],
      "code": "def generate_all_combinations(n: int, k: int) -> list[list[int]]:\n    \"\"\"\n    >>> generate_all_combinations(n=4, k=2)\n    [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n    >>> generate_all_combinations(n=0, k=0)\n    [[]]\n    >>> generate_all_combinations(n=10, k=-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: k must not be negative\n    >>> generate_all_combinations(n=-1, k=10)\n    Traceback (most recent call last):\n        ...\n    ValueError: n must not be negative\n    >>> generate_all_combinations(n=5, k=4)\n    [[1, 2, 3, 4], [1, 2, 3, 5], [1, 2, 4, 5], [1, 3, 4, 5], [2, 3, 4, 5]]\n    >>> from itertools import combinations\n    >>> all(generate_all_combinations(n, k) == combination_lists(n, k)\n    ...     for n in range(1, 6) for k in range(1, 6))\n    True\n    \"\"\"\n    if k < 0:\n        raise ValueError('k must not be negative')\n    if n < 0:\n        raise ValueError('n must not be negative')\n    result: list[list[int]] = []\n    create_all_state(1, n, k, [], result)\n    return result\n'\\n    >>> generate_all_combinations(n=4, k=2)\\n    [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\\n    >>> generate_all_combinations(n=0, k=0)\\n    [[]]\\n    >>> generate_all_combinations(n=10, k=-1)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: k must not be negative\\n    >>> generate_all_combinations(n=-1, k=10)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: n must not be negative\\n    >>> generate_all_combinations(n=5, k=4)\\n    [[1, 2, 3, 4], [1, 2, 3, 5], [1, 2, 4, 5], [1, 3, 4, 5], [2, 3, 4, 5]]\\n    >>> from itertools import combinations\\n    >>> all(generate_all_combinations(n, k) == combination_lists(n, k)\\n    ...     for n in range(1, 6) for k in range(1, 6))\\n    True\\n    '\nk Lt 0"
    },
    {
      "id": "n2",
      "type": "block",
      "statements": [
        "raise ValueError('k must not be negative')"
      ],
      "code": "raise ValueError('k must not be negative')"
    },
    {
      "id": "n3",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n4",
      "type": "block",
      "statements": [
        "n Lt 0"
      ],
      "code": "n Lt 0"
    },
    {
      "id": "n5",
      "type": "block",
      "statements": [
        "raise ValueError('n must not be negative')"
      ],
      "code": "raise ValueError('n must not be negative')"
    },
    {
      "id": "n6",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n7",
      "type": "block",
      "statements": [
        "result: list[list[int]] = []",
        "create_all_state(1, n, k, [], result)",
        "return result"
      ],
      "code": "result: list[list[int]] = []\ncreate_all_state(1, n, k, [], result)\nreturn result"
    },
    {
      "id": "n8",
      "type": "block",
      "statements": [
        "def create_all_state(increment: int, total_number: int, level: int, current_list: list[int], total_list: list[list[int]]) -> None:\n    if level == 0:\n        total_list.append(current_list[:])\n        return\n    for i in range(increment, total_number - level + 2):\n        current_list.append(i)\n        create_all_state(i + 1, total_number, level - 1, current_list, total_list)\n        current_list.pop()",
        "level Eq 0"
      ],
      "code": "def create_all_state(increment: int, total_number: int, level: int, current_list: list[int], total_list: list[list[int]]) -> None:\n    if level == 0:\n        total_list.append(current_list[:])\n        return\n    for i in range(increment, total_number - level + 2):\n        current_list.append(i)\n        create_all_state(i + 1, total_number, level - 1, current_list, total_list)\n        current_list.pop()\nlevel Eq 0"
    },
    {
      "id": "n9",
      "type": "block",
      "statements": [
        "total_list.append(current_list[:])",
        "return"
      ],
      "code": "total_list.append(current_list[:])\nreturn"
    },
    {
      "id": "n10",
      "type": "block",
      "statements": [],
      "code": "\n"
    },
    {
      "id": "n11",
      "type": "block",
      "statements": [
        "i",
        "range(increment, total_number Sub level Add 2)"
      ],
      "code": "i\nrange(increment, total_number Sub level Add 2)"
    },
    {
      "id": "n12",
      "type": "block",
      "statements": [
        "current_list.append(i)",
        "create_all_state(i Add 1, total_number, level Sub 1, current_list, total_list)",
        "current_list.pop()"
      ],
      "code": "current_list.append(i)\ncreate_all_state(i Add 1, total_number, level Sub 1, current_list, total_list)\ncurrent_list.pop()"
    },
    {
      "id": "n13",
      "type": "block",
      "statements": [
        "__name__ Eq '__main__'"
      ],
      "code": "__name__ Eq '__main__'"
    },
    {
      "id": "n14",
      "type": "block",
      "statements": [
        "from doctest import testmod",
        "testmod()",
        "print(generate_all_combinations())",
        "tests = ((n, k) for n in range(1, 5) for k in range(1, 5))"
      ],
      "code": "from doctest import testmod\ntestmod()\nprint(generate_all_combinations())\ntests = ((n, k) for n in range(1, 5) for k in range(1, 5))"
    },
    {
      "id": "n15",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n16",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n17",
      "type": "block",
      "statements": [
        "(n, k)",
        "tests"
      ],
      "code": "(n, k)\ntests"
    },
    {
      "id": "n18",
      "type": "block",
      "statements": [
        "print(n, k, generate_all_combinations(n, k) Eq combination_lists(n, k))"
      ],
      "code": "print(n, k, generate_all_combinations(n, k) Eq combination_lists(n, k))"
    },
    {
      "id": "n19",
      "type": "block",
      "statements": [
        "print('Benchmark:')",
        "from timeit import timeit"
      ],
      "code": "print('Benchmark:')\nfrom timeit import timeit"
    },
    {
      "id": "n20",
      "type": "block",
      "statements": [
        "func",
        "('combination_lists', 'generate_all_combinations')"
      ],
      "code": "func\n('combination_lists', 'generate_all_combinations')"
    },
    {
      "id": "n21",
      "type": "block",
      "statements": [
        "print(f\"{func:>25}(): {timeit(f'{func}(n=4, k = 2)', globals=globals())}\")"
      ],
      "code": "print(f\"{func:>25}(): {timeit(f'{func}(n=4, k = 2)', globals=globals())}\")"
    },
    {
      "id": "n22",
      "type": "block",
      "statements": [],
      "code": ""
    }
  ],
  "edges": [
    {
      "source": "n21",
      "target": "n20"
    },
    {
      "source": "n6",
      "target": "n7"
    },
    {
      "source": "n17",
      "target": "n18"
    },
    {
      "source": "n14",
      "target": "n17"
    },
    {
      "source": "n10",
      "target": "n11"
    },
    {
      "source": "n17",
      "target": "n19"
    },
    {
      "source": "n13",
      "target": "n14"
    },
    {
      "source": "n2",
      "target": "n4"
    },
    {
      "source": "n13",
      "target": "n15"
    },
    {
      "source": "n8",
      "target": "n9"
    },
    {
      "source": "n3",
      "target": "n4"
    },
    {
      "source": "n1",
      "target": "n2"
    },
    {
      "source": "n19",
      "target": "n20"
    },
    {
      "source": "n4",
      "target": "n5"
    },
    {
      "source": "n4",
      "target": "n6"
    },
    {
      "source": "n15",
      "target": "n16"
    },
    {
      "source": "n20",
      "target": "n21"
    },
    {
      "source": "n18",
      "target": "n17"
    },
    {
      "source": "n11",
      "target": "n12"
    },
    {
      "source": "n12",
      "target": "n11"
    },
    {
      "source": "n1",
      "target": "n3"
    },
    {
      "source": "n8",
      "target": "n10"
    },
    {
      "source": "n20",
      "target": "n22"
    },
    {
      "source": "n5",
      "target": "n7"
    },
    {
      "source": "n11",
      "target": "n13"
    },
    {
      "source": "n22",
      "target": "n16"
    }
  ]
}