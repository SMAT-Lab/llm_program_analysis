{
  "nodes": [
    {
      "id": "n0",
      "type": "block",
      "statements": [
        "import hashlib",
        "import hmac",
        "import logging",
        "import requests",
        "from fastapi import HTTPException, Request",
        "from strenum import StrEnum",
        "from backend.data import integrations",
        "from backend.data.model import Credentials",
        "from backend.integrations.providers import ProviderName",
        "from ._base import BaseWebhooksManager",
        "logger = logging.getLogger(__name__)",
        "class GithubWebhookType(StrEnum):\n    REPO = 'repo'",
        "REPO = 'repo'",
        "class GithubWebhooksManager(BaseWebhooksManager):\n    PROVIDER_NAME = ProviderName.GITHUB\n    WebhookType = GithubWebhookType\n    GITHUB_API_URL = 'https://api.github.com'\n    GITHUB_API_DEFAULT_HEADERS = {'Accept': 'application/vnd.github.v3+json'}\n\n    @classmethod\n    async def validate_payload(cls, webhook: integrations.Webhook, request: Request) -> tuple[dict, str]:\n        if not (event_type := request.headers.get('X-GitHub-Event')):\n            raise HTTPException(status_code=400, detail='X-GitHub-Event header is missing!')\n        if not (signature_header := request.headers.get('X-Hub-Signature-256')):\n            raise HTTPException(status_code=403, detail='X-Hub-Signature-256 header is missing!')\n        payload_body = await request.body()\n        hash_object = hmac.new(webhook.secret.encode('utf-8'), msg=payload_body, digestmod=hashlib.sha256)\n        expected_signature = 'sha256=' + hash_object.hexdigest()\n        if not hmac.compare_digest(expected_signature, signature_header):\n            raise HTTPException(status_code=403, detail=\"Request signatures didn't match!\")\n        payload = await request.json()\n        if (action := payload.get('action')):\n            event_type += f'.{action}'\n        return (payload, event_type)\n\n    async def trigger_ping(self, webhook: integrations.Webhook, credentials: Credentials | None) -> None:\n        if not credentials:\n            raise ValueError('Credentials are required but were not passed')\n        headers = {**self.GITHUB_API_DEFAULT_HEADERS, 'Authorization': credentials.bearer()}\n        (repo, github_hook_id) = (webhook.resource, webhook.provider_webhook_id)\n        ping_url = f'{self.GITHUB_API_URL}/repos/{repo}/hooks/{github_hook_id}/pings'\n        response = requests.post(ping_url, headers=headers)\n        if response.status_code != 204:\n            error_msg = extract_github_error_msg(response)\n            raise ValueError(f'Failed to ping GitHub webhook: {error_msg}')\n\n    async def _register_webhook(self, credentials: Credentials, webhook_type: GithubWebhookType, resource: str, events: list[str], ingress_url: str, secret: str) -> tuple[str, dict]:\n        if webhook_type == self.WebhookType.REPO and resource.count('/') > 1:\n            raise ValueError(\"Invalid repo format: expected 'owner/repo'\")\n        github_events = list({event.split('.')[0] for event in events})\n        headers = {**self.GITHUB_API_DEFAULT_HEADERS, 'Authorization': credentials.bearer()}\n        webhook_data = {'name': 'web', 'active': True, 'events': github_events, 'config': {'url': ingress_url, 'content_type': 'json', 'insecure_ssl': '0', 'secret': secret}}\n        response = requests.post(f'{self.GITHUB_API_URL}/repos/{resource}/hooks', headers=headers, json=webhook_data)\n        if response.status_code != 201:\n            error_msg = extract_github_error_msg(response)\n            if 'not found' in error_msg.lower():\n                error_msg = f\"{error_msg} (Make sure the GitHub account or API key has 'repo' or webhook create permissions to '{resource}')\"\n            raise ValueError(f'Failed to create GitHub webhook: {error_msg}')\n        webhook_id = response.json()['id']\n        config = response.json()['config']\n        return (str(webhook_id), config)\n\n    async def _deregister_webhook(self, webhook: integrations.Webhook, credentials: Credentials) -> None:\n        webhook_type = self.WebhookType(webhook.webhook_type)\n        if webhook.credentials_id != credentials.id:\n            raise ValueError(f'Webhook #{webhook.id} does not belong to credentials {credentials.id}')\n        headers = {**self.GITHUB_API_DEFAULT_HEADERS, 'Authorization': credentials.bearer()}\n        if webhook_type == self.WebhookType.REPO:\n            repo = webhook.resource\n            delete_url = f'{self.GITHUB_API_URL}/repos/{repo}/hooks/{webhook.provider_webhook_id}'\n        else:\n            raise NotImplementedError(f\"Unsupported webhook type '{webhook.webhook_type}'\")\n        response = requests.delete(delete_url, headers=headers)\n        if response.status_code not in [204, 404]:\n            error_msg = extract_github_error_msg(response)\n            raise ValueError(f'Failed to delete GitHub webhook: {error_msg}')",
        "PROVIDER_NAME = ProviderName.GITHUB",
        "WebhookType = GithubWebhookType",
        "GITHUB_API_URL = 'https://api.github.com'",
        "GITHUB_API_DEFAULT_HEADERS = {'Accept': 'application/vnd.github.v3+json'}",
        "@classmethod\nasync def validate_payload(cls, webhook: integrations.Webhook, request: Request) -> tuple[dict, str]:\n    if not (event_type := request.headers.get('X-GitHub-Event')):\n        raise HTTPException(status_code=400, detail='X-GitHub-Event header is missing!')\n    if not (signature_header := request.headers.get('X-Hub-Signature-256')):\n        raise HTTPException(status_code=403, detail='X-Hub-Signature-256 header is missing!')\n    payload_body = await request.body()\n    hash_object = hmac.new(webhook.secret.encode('utf-8'), msg=payload_body, digestmod=hashlib.sha256)\n    expected_signature = 'sha256=' + hash_object.hexdigest()\n    if not hmac.compare_digest(expected_signature, signature_header):\n        raise HTTPException(status_code=403, detail=\"Request signatures didn't match!\")\n    payload = await request.json()\n    if (action := payload.get('action')):\n        event_type += f'.{action}'\n    return (payload, event_type)",
        "not (event_type := request.headers.get('X-GitHub-Event'))"
      ],
      "code": "import hashlib\nimport hmac\nimport logging\nimport requests\nfrom fastapi import HTTPException, Request\nfrom strenum import StrEnum\nfrom backend.data import integrations\nfrom backend.data.model import Credentials\nfrom backend.integrations.providers import ProviderName\nfrom ._base import BaseWebhooksManager\nlogger = logging.getLogger(__name__)\nclass GithubWebhookType(StrEnum):\n    REPO = 'repo'\nREPO = 'repo'\nclass GithubWebhooksManager(BaseWebhooksManager):\n    PROVIDER_NAME = ProviderName.GITHUB\n    WebhookType = GithubWebhookType\n    GITHUB_API_URL = 'https://api.github.com'\n    GITHUB_API_DEFAULT_HEADERS = {'Accept': 'application/vnd.github.v3+json'}\n\n    @classmethod\n    async def validate_payload(cls, webhook: integrations.Webhook, request: Request) -> tuple[dict, str]:\n        if not (event_type := request.headers.get('X-GitHub-Event')):\n            raise HTTPException(status_code=400, detail='X-GitHub-Event header is missing!')\n        if not (signature_header := request.headers.get('X-Hub-Signature-256')):\n            raise HTTPException(status_code=403, detail='X-Hub-Signature-256 header is missing!')\n        payload_body = await request.body()\n        hash_object = hmac.new(webhook.secret.encode('utf-8'), msg=payload_body, digestmod=hashlib.sha256)\n        expected_signature = 'sha256=' + hash_object.hexdigest()\n        if not hmac.compare_digest(expected_signature, signature_header):\n            raise HTTPException(status_code=403, detail=\"Request signatures didn't match!\")\n        payload = await request.json()\n        if (action := payload.get('action')):\n            event_type += f'.{action}'\n        return (payload, event_type)\n\n    async def trigger_ping(self, webhook: integrations.Webhook, credentials: Credentials | None) -> None:\n        if not credentials:\n            raise ValueError('Credentials are required but were not passed')\n        headers = {**self.GITHUB_API_DEFAULT_HEADERS, 'Authorization': credentials.bearer()}\n        (repo, github_hook_id) = (webhook.resource, webhook.provider_webhook_id)\n        ping_url = f'{self.GITHUB_API_URL}/repos/{repo}/hooks/{github_hook_id}/pings'\n        response = requests.post(ping_url, headers=headers)\n        if response.status_code != 204:\n            error_msg = extract_github_error_msg(response)\n            raise ValueError(f'Failed to ping GitHub webhook: {error_msg}')\n\n    async def _register_webhook(self, credentials: Credentials, webhook_type: GithubWebhookType, resource: str, events: list[str], ingress_url: str, secret: str) -> tuple[str, dict]:\n        if webhook_type == self.WebhookType.REPO and resource.count('/') > 1:\n            raise ValueError(\"Invalid repo format: expected 'owner/repo'\")\n        github_events = list({event.split('.')[0] for event in events})\n        headers = {**self.GITHUB_API_DEFAULT_HEADERS, 'Authorization': credentials.bearer()}\n        webhook_data = {'name': 'web', 'active': True, 'events': github_events, 'config': {'url': ingress_url, 'content_type': 'json', 'insecure_ssl': '0', 'secret': secret}}\n        response = requests.post(f'{self.GITHUB_API_URL}/repos/{resource}/hooks', headers=headers, json=webhook_data)\n        if response.status_code != 201:\n            error_msg = extract_github_error_msg(response)\n            if 'not found' in error_msg.lower():\n                error_msg = f\"{error_msg} (Make sure the GitHub account or API key has 'repo' or webhook create permissions to '{resource}')\"\n            raise ValueError(f'Failed to create GitHub webhook: {error_msg}')\n        webhook_id = response.json()['id']\n        config = response.json()['config']\n        return (str(webhook_id), config)\n\n    async def _deregister_webhook(self, webhook: integrations.Webhook, credentials: Credentials) -> None:\n        webhook_type = self.WebhookType(webhook.webhook_type)\n        if webhook.credentials_id != credentials.id:\n            raise ValueError(f'Webhook #{webhook.id} does not belong to credentials {credentials.id}')\n        headers = {**self.GITHUB_API_DEFAULT_HEADERS, 'Authorization': credentials.bearer()}\n        if webhook_type == self.WebhookType.REPO:\n            repo = webhook.resource\n            delete_url = f'{self.GITHUB_API_URL}/repos/{repo}/hooks/{webhook.provider_webhook_id}'\n        else:\n            raise NotImplementedError(f\"Unsupported webhook type '{webhook.webhook_type}'\")\n        response = requests.delete(delete_url, headers=headers)\n        if response.status_code not in [204, 404]:\n            error_msg = extract_github_error_msg(response)\n            raise ValueError(f'Failed to delete GitHub webhook: {error_msg}')\nPROVIDER_NAME = ProviderName.GITHUB\nWebhookType = GithubWebhookType\nGITHUB_API_URL = 'https://api.github.com'\nGITHUB_API_DEFAULT_HEADERS = {'Accept': 'application/vnd.github.v3+json'}\n@classmethod\nasync def validate_payload(cls, webhook: integrations.Webhook, request: Request) -> tuple[dict, str]:\n    if not (event_type := request.headers.get('X-GitHub-Event')):\n        raise HTTPException(status_code=400, detail='X-GitHub-Event header is missing!')\n    if not (signature_header := request.headers.get('X-Hub-Signature-256')):\n        raise HTTPException(status_code=403, detail='X-Hub-Signature-256 header is missing!')\n    payload_body = await request.body()\n    hash_object = hmac.new(webhook.secret.encode('utf-8'), msg=payload_body, digestmod=hashlib.sha256)\n    expected_signature = 'sha256=' + hash_object.hexdigest()\n    if not hmac.compare_digest(expected_signature, signature_header):\n        raise HTTPException(status_code=403, detail=\"Request signatures didn't match!\")\n    payload = await request.json()\n    if (action := payload.get('action')):\n        event_type += f'.{action}'\n    return (payload, event_type)\nnot (event_type := request.headers.get('X-GitHub-Event'))"
    },
    {
      "id": "n1",
      "type": "block",
      "statements": [
        "raise HTTPException(status_code=400, detail='X-GitHub-Event header is missing!')"
      ],
      "code": "raise HTTPException(status_code=400, detail='X-GitHub-Event header is missing!')"
    },
    {
      "id": "n2",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n3",
      "type": "block",
      "statements": [
        "not (signature_header := request.headers.get('X-Hub-Signature-256'))"
      ],
      "code": "not (signature_header := request.headers.get('X-Hub-Signature-256'))"
    },
    {
      "id": "n4",
      "type": "block",
      "statements": [
        "raise HTTPException(status_code=403, detail='X-Hub-Signature-256 header is missing!')"
      ],
      "code": "raise HTTPException(status_code=403, detail='X-Hub-Signature-256 header is missing!')"
    },
    {
      "id": "n5",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n6",
      "type": "block",
      "statements": [
        "payload_body = await request.body()",
        "hash_object = hmac.new(webhook.secret.encode('utf-8'), msg=payload_body, digestmod=hashlib.sha256)",
        "expected_signature = 'sha256=' + hash_object.hexdigest()",
        "not hmac.compare_digest(expected_signature, signature_header)"
      ],
      "code": "payload_body = await request.body()\nhash_object = hmac.new(webhook.secret.encode('utf-8'), msg=payload_body, digestmod=hashlib.sha256)\nexpected_signature = 'sha256=' + hash_object.hexdigest()\nnot hmac.compare_digest(expected_signature, signature_header)"
    },
    {
      "id": "n7",
      "type": "block",
      "statements": [
        "raise HTTPException(status_code=403, detail=\"Request signatures didn't match!\")"
      ],
      "code": "raise HTTPException(status_code=403, detail=\"Request signatures didn't match!\")"
    },
    {
      "id": "n8",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n9",
      "type": "block",
      "statements": [
        "payload = await request.json()",
        "(action := payload.get('action'))"
      ],
      "code": "payload = await request.json()\n(action := payload.get('action'))"
    },
    {
      "id": "n10",
      "type": "block",
      "statements": [
        "event_type += f'.{action}'"
      ],
      "code": "event_type += f'.{action}'"
    },
    {
      "id": "n11",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n12",
      "type": "block",
      "statements": [
        "return (payload, event_type)"
      ],
      "code": "return (payload, event_type)"
    },
    {
      "id": "n13",
      "type": "block",
      "statements": [
        "async def trigger_ping(self, webhook: integrations.Webhook, credentials: Credentials | None) -> None:\n    if not credentials:\n        raise ValueError('Credentials are required but were not passed')\n    headers = {**self.GITHUB_API_DEFAULT_HEADERS, 'Authorization': credentials.bearer()}\n    (repo, github_hook_id) = (webhook.resource, webhook.provider_webhook_id)\n    ping_url = f'{self.GITHUB_API_URL}/repos/{repo}/hooks/{github_hook_id}/pings'\n    response = requests.post(ping_url, headers=headers)\n    if response.status_code != 204:\n        error_msg = extract_github_error_msg(response)\n        raise ValueError(f'Failed to ping GitHub webhook: {error_msg}')",
        "not credentials"
      ],
      "code": "async def trigger_ping(self, webhook: integrations.Webhook, credentials: Credentials | None) -> None:\n    if not credentials:\n        raise ValueError('Credentials are required but were not passed')\n    headers = {**self.GITHUB_API_DEFAULT_HEADERS, 'Authorization': credentials.bearer()}\n    (repo, github_hook_id) = (webhook.resource, webhook.provider_webhook_id)\n    ping_url = f'{self.GITHUB_API_URL}/repos/{repo}/hooks/{github_hook_id}/pings'\n    response = requests.post(ping_url, headers=headers)\n    if response.status_code != 204:\n        error_msg = extract_github_error_msg(response)\n        raise ValueError(f'Failed to ping GitHub webhook: {error_msg}')\nnot credentials"
    },
    {
      "id": "n14",
      "type": "block",
      "statements": [
        "raise ValueError('Credentials are required but were not passed')"
      ],
      "code": "raise ValueError('Credentials are required but were not passed')"
    },
    {
      "id": "n15",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n16",
      "type": "block",
      "statements": [
        "headers = {**self.GITHUB_API_DEFAULT_HEADERS, 'Authorization': credentials.bearer()}",
        "(repo, github_hook_id) = (webhook.resource, webhook.provider_webhook_id)",
        "ping_url = f'{self.GITHUB_API_URL}/repos/{repo}/hooks/{github_hook_id}/pings'",
        "response = requests.post(ping_url, headers=headers)",
        "response.status_code NotEq 204"
      ],
      "code": "headers = {**self.GITHUB_API_DEFAULT_HEADERS, 'Authorization': credentials.bearer()}\n(repo, github_hook_id) = (webhook.resource, webhook.provider_webhook_id)\nping_url = f'{self.GITHUB_API_URL}/repos/{repo}/hooks/{github_hook_id}/pings'\nresponse = requests.post(ping_url, headers=headers)\nresponse.status_code NotEq 204"
    },
    {
      "id": "n17",
      "type": "block",
      "statements": [
        "error_msg = extract_github_error_msg(response)",
        "raise ValueError(f'Failed to ping GitHub webhook: {error_msg}')"
      ],
      "code": "error_msg = extract_github_error_msg(response)\nraise ValueError(f'Failed to ping GitHub webhook: {error_msg}')"
    },
    {
      "id": "n18",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n19",
      "type": "block",
      "statements": [
        "async def _register_webhook(self, credentials: Credentials, webhook_type: GithubWebhookType, resource: str, events: list[str], ingress_url: str, secret: str) -> tuple[str, dict]:\n    if webhook_type == self.WebhookType.REPO and resource.count('/') > 1:\n        raise ValueError(\"Invalid repo format: expected 'owner/repo'\")\n    github_events = list({event.split('.')[0] for event in events})\n    headers = {**self.GITHUB_API_DEFAULT_HEADERS, 'Authorization': credentials.bearer()}\n    webhook_data = {'name': 'web', 'active': True, 'events': github_events, 'config': {'url': ingress_url, 'content_type': 'json', 'insecure_ssl': '0', 'secret': secret}}\n    response = requests.post(f'{self.GITHUB_API_URL}/repos/{resource}/hooks', headers=headers, json=webhook_data)\n    if response.status_code != 201:\n        error_msg = extract_github_error_msg(response)\n        if 'not found' in error_msg.lower():\n            error_msg = f\"{error_msg} (Make sure the GitHub account or API key has 'repo' or webhook create permissions to '{resource}')\"\n        raise ValueError(f'Failed to create GitHub webhook: {error_msg}')\n    webhook_id = response.json()['id']\n    config = response.json()['config']\n    return (str(webhook_id), config)",
        "webhook_type == self.WebhookType.REPO and resource.count('/') > 1"
      ],
      "code": "async def _register_webhook(self, credentials: Credentials, webhook_type: GithubWebhookType, resource: str, events: list[str], ingress_url: str, secret: str) -> tuple[str, dict]:\n    if webhook_type == self.WebhookType.REPO and resource.count('/') > 1:\n        raise ValueError(\"Invalid repo format: expected 'owner/repo'\")\n    github_events = list({event.split('.')[0] for event in events})\n    headers = {**self.GITHUB_API_DEFAULT_HEADERS, 'Authorization': credentials.bearer()}\n    webhook_data = {'name': 'web', 'active': True, 'events': github_events, 'config': {'url': ingress_url, 'content_type': 'json', 'insecure_ssl': '0', 'secret': secret}}\n    response = requests.post(f'{self.GITHUB_API_URL}/repos/{resource}/hooks', headers=headers, json=webhook_data)\n    if response.status_code != 201:\n        error_msg = extract_github_error_msg(response)\n        if 'not found' in error_msg.lower():\n            error_msg = f\"{error_msg} (Make sure the GitHub account or API key has 'repo' or webhook create permissions to '{resource}')\"\n        raise ValueError(f'Failed to create GitHub webhook: {error_msg}')\n    webhook_id = response.json()['id']\n    config = response.json()['config']\n    return (str(webhook_id), config)\nwebhook_type == self.WebhookType.REPO and resource.count('/') > 1"
    },
    {
      "id": "n20",
      "type": "block",
      "statements": [
        "raise ValueError(\"Invalid repo format: expected 'owner/repo'\")"
      ],
      "code": "raise ValueError(\"Invalid repo format: expected 'owner/repo'\")"
    },
    {
      "id": "n21",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n22",
      "type": "block",
      "statements": [
        "github_events = list({event.split('.')[0] for event in events})",
        "headers = {**self.GITHUB_API_DEFAULT_HEADERS, 'Authorization': credentials.bearer()}",
        "webhook_data = {'name': 'web', 'active': True, 'events': github_events, 'config': {'url': ingress_url, 'content_type': 'json', 'insecure_ssl': '0', 'secret': secret}}",
        "response = requests.post(f'{self.GITHUB_API_URL}/repos/{resource}/hooks', headers=headers, json=webhook_data)",
        "response.status_code NotEq 201"
      ],
      "code": "github_events = list({event.split('.')[0] for event in events})\nheaders = {**self.GITHUB_API_DEFAULT_HEADERS, 'Authorization': credentials.bearer()}\nwebhook_data = {'name': 'web', 'active': True, 'events': github_events, 'config': {'url': ingress_url, 'content_type': 'json', 'insecure_ssl': '0', 'secret': secret}}\nresponse = requests.post(f'{self.GITHUB_API_URL}/repos/{resource}/hooks', headers=headers, json=webhook_data)\nresponse.status_code NotEq 201"
    },
    {
      "id": "n23",
      "type": "block",
      "statements": [
        "error_msg = extract_github_error_msg(response)",
        "'not found' In error_msg.lower()"
      ],
      "code": "error_msg = extract_github_error_msg(response)\n'not found' In error_msg.lower()"
    },
    {
      "id": "n24",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n25",
      "type": "block",
      "statements": [
        "webhook_id = response.json()['id']",
        "config = response.json()['config']",
        "return (str(webhook_id), config)"
      ],
      "code": "webhook_id = response.json()['id']\nconfig = response.json()['config']\nreturn (str(webhook_id), config)"
    },
    {
      "id": "n26",
      "type": "block",
      "statements": [
        "error_msg = f\"{error_msg} (Make sure the GitHub account or API key has 'repo' or webhook create permissions to '{resource}')\""
      ],
      "code": "error_msg = f\"{error_msg} (Make sure the GitHub account or API key has 'repo' or webhook create permissions to '{resource}')\""
    },
    {
      "id": "n27",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n28",
      "type": "block",
      "statements": [
        "raise ValueError(f'Failed to create GitHub webhook: {error_msg}')"
      ],
      "code": "raise ValueError(f'Failed to create GitHub webhook: {error_msg}')"
    },
    {
      "id": "n29",
      "type": "block",
      "statements": [
        "async def _deregister_webhook(self, webhook: integrations.Webhook, credentials: Credentials) -> None:\n    webhook_type = self.WebhookType(webhook.webhook_type)\n    if webhook.credentials_id != credentials.id:\n        raise ValueError(f'Webhook #{webhook.id} does not belong to credentials {credentials.id}')\n    headers = {**self.GITHUB_API_DEFAULT_HEADERS, 'Authorization': credentials.bearer()}\n    if webhook_type == self.WebhookType.REPO:\n        repo = webhook.resource\n        delete_url = f'{self.GITHUB_API_URL}/repos/{repo}/hooks/{webhook.provider_webhook_id}'\n    else:\n        raise NotImplementedError(f\"Unsupported webhook type '{webhook.webhook_type}'\")\n    response = requests.delete(delete_url, headers=headers)\n    if response.status_code not in [204, 404]:\n        error_msg = extract_github_error_msg(response)\n        raise ValueError(f'Failed to delete GitHub webhook: {error_msg}')",
        "webhook_type = self.WebhookType(webhook.webhook_type)",
        "webhook.credentials_id NotEq credentials.id"
      ],
      "code": "async def _deregister_webhook(self, webhook: integrations.Webhook, credentials: Credentials) -> None:\n    webhook_type = self.WebhookType(webhook.webhook_type)\n    if webhook.credentials_id != credentials.id:\n        raise ValueError(f'Webhook #{webhook.id} does not belong to credentials {credentials.id}')\n    headers = {**self.GITHUB_API_DEFAULT_HEADERS, 'Authorization': credentials.bearer()}\n    if webhook_type == self.WebhookType.REPO:\n        repo = webhook.resource\n        delete_url = f'{self.GITHUB_API_URL}/repos/{repo}/hooks/{webhook.provider_webhook_id}'\n    else:\n        raise NotImplementedError(f\"Unsupported webhook type '{webhook.webhook_type}'\")\n    response = requests.delete(delete_url, headers=headers)\n    if response.status_code not in [204, 404]:\n        error_msg = extract_github_error_msg(response)\n        raise ValueError(f'Failed to delete GitHub webhook: {error_msg}')\nwebhook_type = self.WebhookType(webhook.webhook_type)\nwebhook.credentials_id NotEq credentials.id"
    },
    {
      "id": "n30",
      "type": "block",
      "statements": [
        "raise ValueError(f'Webhook #{webhook.id} does not belong to credentials {credentials.id}')"
      ],
      "code": "raise ValueError(f'Webhook #{webhook.id} does not belong to credentials {credentials.id}')"
    },
    {
      "id": "n31",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n32",
      "type": "block",
      "statements": [
        "headers = {**self.GITHUB_API_DEFAULT_HEADERS, 'Authorization': credentials.bearer()}",
        "webhook_type Eq self.WebhookType.REPO"
      ],
      "code": "headers = {**self.GITHUB_API_DEFAULT_HEADERS, 'Authorization': credentials.bearer()}\nwebhook_type Eq self.WebhookType.REPO"
    },
    {
      "id": "n33",
      "type": "block",
      "statements": [
        "repo = webhook.resource",
        "delete_url = f'{self.GITHUB_API_URL}/repos/{repo}/hooks/{webhook.provider_webhook_id}'"
      ],
      "code": "repo = webhook.resource\ndelete_url = f'{self.GITHUB_API_URL}/repos/{repo}/hooks/{webhook.provider_webhook_id}'"
    },
    {
      "id": "n34",
      "type": "block",
      "statements": [
        "raise NotImplementedError(f\"Unsupported webhook type '{webhook.webhook_type}'\")"
      ],
      "code": "raise NotImplementedError(f\"Unsupported webhook type '{webhook.webhook_type}'\")"
    },
    {
      "id": "n35",
      "type": "block",
      "statements": [
        "response = requests.delete(delete_url, headers=headers)",
        "response.status_code NotIn [204, 404]"
      ],
      "code": "response = requests.delete(delete_url, headers=headers)\nresponse.status_code NotIn [204, 404]"
    },
    {
      "id": "n36",
      "type": "block",
      "statements": [
        "error_msg = extract_github_error_msg(response)",
        "raise ValueError(f'Failed to delete GitHub webhook: {error_msg}')"
      ],
      "code": "error_msg = extract_github_error_msg(response)\nraise ValueError(f'Failed to delete GitHub webhook: {error_msg}')"
    },
    {
      "id": "n37",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n38",
      "type": "block",
      "statements": [
        "def extract_github_error_msg(response: requests.Response) -> str:\n    error_msgs = []\n    resp = response.json()\n    if resp.get('message'):\n        error_msgs.append(resp['message'])\n    if resp.get('errors'):\n        error_msgs.extend((f\"* {err.get('message', err)}\" for err in resp['errors']))\n    if resp.get('error'):\n        if isinstance(resp['error'], dict):\n            error_msgs.append(resp['error'].get('message', resp['error']))\n        else:\n            error_msgs.append(resp['error'])\n    return '\\n'.join(error_msgs)",
        "error_msgs = []",
        "resp = response.json()",
        "resp.get('message')"
      ],
      "code": "def extract_github_error_msg(response: requests.Response) -> str:\n    error_msgs = []\n    resp = response.json()\n    if resp.get('message'):\n        error_msgs.append(resp['message'])\n    if resp.get('errors'):\n        error_msgs.extend((f\"* {err.get('message', err)}\" for err in resp['errors']))\n    if resp.get('error'):\n        if isinstance(resp['error'], dict):\n            error_msgs.append(resp['error'].get('message', resp['error']))\n        else:\n            error_msgs.append(resp['error'])\n    return '\\n'.join(error_msgs)\nerror_msgs = []\nresp = response.json()\nresp.get('message')"
    },
    {
      "id": "n39",
      "type": "block",
      "statements": [
        "error_msgs.append(resp['message'])"
      ],
      "code": "error_msgs.append(resp['message'])"
    },
    {
      "id": "n40",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n41",
      "type": "block",
      "statements": [
        "resp.get('errors')"
      ],
      "code": "resp.get('errors')"
    },
    {
      "id": "n42",
      "type": "block",
      "statements": [
        "error_msgs.extend((f\"* {err.get('message', err)}\" for err in resp['errors']))"
      ],
      "code": "error_msgs.extend((f\"* {err.get('message', err)}\" for err in resp['errors']))"
    },
    {
      "id": "n43",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n44",
      "type": "block",
      "statements": [
        "resp.get('error')"
      ],
      "code": "resp.get('error')"
    },
    {
      "id": "n45",
      "type": "block",
      "statements": [
        "isinstance(resp['error'], dict)"
      ],
      "code": "isinstance(resp['error'], dict)"
    },
    {
      "id": "n46",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n47",
      "type": "block",
      "statements": [
        "return '\\n'.join(error_msgs)"
      ],
      "code": "return '\\n'.join(error_msgs)"
    },
    {
      "id": "n48",
      "type": "block",
      "statements": [
        "error_msgs.append(resp['error'].get('message', resp['error']))"
      ],
      "code": "error_msgs.append(resp['error'].get('message', resp['error']))"
    },
    {
      "id": "n49",
      "type": "block",
      "statements": [
        "error_msgs.append(resp['error'])"
      ],
      "code": "error_msgs.append(resp['error'])"
    },
    {
      "id": "n50",
      "type": "block",
      "statements": [],
      "code": ""
    }
  ],
  "edges": [
    {
      "source": "n38",
      "target": "n39"
    },
    {
      "source": "n6",
      "target": "n7"
    },
    {
      "source": "n0",
      "target": "n1"
    },
    {
      "source": "n21",
      "target": "n22"
    },
    {
      "source": "n44",
      "target": "n45"
    },
    {
      "source": "n35",
      "target": "n37"
    },
    {
      "source": "n34",
      "target": "n35"
    },
    {
      "source": "n22",
      "target": "n23"
    },
    {
      "source": "n17",
      "target": "n19"
    },
    {
      "source": "n2",
      "target": "n3"
    },
    {
      "source": "n19",
      "target": "n21"
    },
    {
      "source": "n13",
      "target": "n14"
    },
    {
      "source": "n40",
      "target": "n41"
    },
    {
      "source": "n35",
      "target": "n36"
    },
    {
      "source": "n16",
      "target": "n17"
    },
    {
      "source": "n13",
      "target": "n15"
    },
    {
      "source": "n16",
      "target": "n18"
    },
    {
      "source": "n8",
      "target": "n9"
    },
    {
      "source": "n3",
      "target": "n4"
    },
    {
      "source": "n33",
      "target": "n35"
    },
    {
      "source": "n19",
      "target": "n20"
    },
    {
      "source": "n4",
      "target": "n6"
    },
    {
      "source": "n41",
      "target": "n42"
    },
    {
      "source": "n43",
      "target": "n44"
    },
    {
      "source": "n24",
      "target": "n25"
    },
    {
      "source": "n45",
      "target": "n49"
    },
    {
      "source": "n23",
      "target": "n26"
    },
    {
      "source": "n15",
      "target": "n16"
    },
    {
      "source": "n29",
      "target": "n30"
    },
    {
      "source": "n9",
      "target": "n11"
    },
    {
      "source": "n44",
      "target": "n46"
    },
    {
      "source": "n23",
      "target": "n27"
    },
    {
      "source": "n49",
      "target": "n50"
    },
    {
      "source": "n46",
      "target": "n47"
    },
    {
      "source": "n32",
      "target": "n33"
    },
    {
      "source": "n14",
      "target": "n16"
    },
    {
      "source": "n41",
      "target": "n43"
    },
    {
      "source": "n36",
      "target": "n38"
    },
    {
      "source": "n9",
      "target": "n10"
    },
    {
      "source": "n48",
      "target": "n50"
    },
    {
      "source": "n50",
      "target": "n47"
    },
    {
      "source": "n31",
      "target": "n32"
    },
    {
      "source": "n10",
      "target": "n12"
    },
    {
      "source": "n11",
      "target": "n12"
    },
    {
      "source": "n18",
      "target": "n19"
    },
    {
      "source": "n45",
      "target": "n48"
    },
    {
      "source": "n7",
      "target": "n9"
    },
    {
      "source": "n37",
      "target": "n38"
    },
    {
      "source": "n5",
      "target": "n6"
    },
    {
      "source": "n29",
      "target": "n31"
    },
    {
      "source": "n38",
      "target": "n40"
    },
    {
      "source": "n42",
      "target": "n44"
    },
    {
      "source": "n26",
      "target": "n28"
    },
    {
      "source": "n1",
      "target": "n3"
    },
    {
      "source": "n28",
      "target": "n25"
    },
    {
      "source": "n27",
      "target": "n28"
    },
    {
      "source": "n3",
      "target": "n5"
    },
    {
      "source": "n20",
      "target": "n22"
    },
    {
      "source": "n22",
      "target": "n24"
    },
    {
      "source": "n32",
      "target": "n34"
    },
    {
      "source": "n6",
      "target": "n8"
    },
    {
      "source": "n39",
      "target": "n41"
    },
    {
      "source": "n0",
      "target": "n2"
    },
    {
      "source": "n30",
      "target": "n32"
    }
  ]
}