{
  "nodes": [
    {
      "id": "n0",
      "type": "block",
      "statements": [
        "import json",
        "from typing import Any, Type, TypeVar, overload",
        "import jsonschema",
        "from fastapi.encoders import jsonable_encoder",
        "from .type import type_match",
        "def to_dict(data) -> dict:\n    return jsonable_encoder(data)",
        "return jsonable_encoder(data)"
      ],
      "code": "import json\nfrom typing import Any, Type, TypeVar, overload\nimport jsonschema\nfrom fastapi.encoders import jsonable_encoder\nfrom .type import type_match\ndef to_dict(data) -> dict:\n    return jsonable_encoder(data)\nreturn jsonable_encoder(data)"
    },
    {
      "id": "n1",
      "type": "block",
      "statements": [
        "def dumps(data) -> str:\n    return json.dumps(jsonable_encoder(data))",
        "return json.dumps(jsonable_encoder(data))"
      ],
      "code": "def dumps(data) -> str:\n    return json.dumps(jsonable_encoder(data))\nreturn json.dumps(jsonable_encoder(data))"
    },
    {
      "id": "n2",
      "type": "block",
      "statements": [
        "T = TypeVar('T')",
        "@overload\ndef loads(data: str, *args, target_type: Type[T], **kwargs) -> T:\n    ...",
        "Ellipsis",
        "@overload\ndef loads(data: str, *args, **kwargs) -> Any:\n    ...",
        "Ellipsis",
        "def loads(data: str, *args, target_type: Type[T] | None=None, **kwargs) -> Any:\n    parsed = json.loads(data, *args, **kwargs)\n    if target_type:\n        return type_match(parsed, target_type)\n    return parsed",
        "parsed = json.loads(data, *args, **kwargs)",
        "target_type"
      ],
      "code": "T = TypeVar('T')\n@overload\ndef loads(data: str, *args, target_type: Type[T], **kwargs) -> T:\n    ...\nEllipsis\n@overload\ndef loads(data: str, *args, **kwargs) -> Any:\n    ...\nEllipsis\ndef loads(data: str, *args, target_type: Type[T] | None=None, **kwargs) -> Any:\n    parsed = json.loads(data, *args, **kwargs)\n    if target_type:\n        return type_match(parsed, target_type)\n    return parsed\nparsed = json.loads(data, *args, **kwargs)\ntarget_type"
    },
    {
      "id": "n3",
      "type": "block",
      "statements": [
        "return type_match(parsed, target_type)"
      ],
      "code": "return type_match(parsed, target_type)"
    },
    {
      "id": "n4",
      "type": "block",
      "statements": [],
      "code": "\nreturn parsed"
    },
    {
      "id": "n5",
      "type": "block",
      "statements": [
        "def validate_with_jsonschema(schema: dict[str, Any], data: dict[str, Any]) -> str | None:\n    \"\"\"\n    Validate the data against the schema.\n    Returns the validation error message if the data does not match the schema.\n    \"\"\"\n    try:\n        jsonschema.validate(data, schema)\n        return None\n    except jsonschema.ValidationError as e:\n        return str(e)",
        "'\\n    Validate the data against the schema.\\n    Returns the validation error message if the data does not match the schema.\\n    '",
        "try:\n    jsonschema.validate(data, schema)\n    return None\nexcept jsonschema.ValidationError as e:\n    return str(e)",
        "jsonschema.validate(data, schema)",
        "return None"
      ],
      "code": "def validate_with_jsonschema(schema: dict[str, Any], data: dict[str, Any]) -> str | None:\n    \"\"\"\n    Validate the data against the schema.\n    Returns the validation error message if the data does not match the schema.\n    \"\"\"\n    try:\n        jsonschema.validate(data, schema)\n        return None\n    except jsonschema.ValidationError as e:\n        return str(e)\n'\\n    Validate the data against the schema.\\n    Returns the validation error message if the data does not match the schema.\\n    '\ntry:\n    jsonschema.validate(data, schema)\n    return None\nexcept jsonschema.ValidationError as e:\n    return str(e)\njsonschema.validate(data, schema)\nreturn None"
    },
    {
      "id": "n6",
      "type": "block",
      "statements": [
        "return str(e)"
      ],
      "code": "return str(e)"
    }
  ],
  "edges": [
    {
      "source": "n2",
      "target": "n4"
    },
    {
      "source": "n2",
      "target": "n3"
    }
  ]
}