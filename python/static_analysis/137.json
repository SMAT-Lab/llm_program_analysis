{
  "nodes": [
    {
      "id": "n0",
      "type": "block",
      "statements": [
        "import logging",
        "import os",
        "import uuid",
        "import fastapi",
        "from google.cloud import storage",
        "import backend.server.v2.store.exceptions",
        "from backend.util.settings import Settings",
        "logger = logging.getLogger(__name__)",
        "ALLOWED_IMAGE_TYPES = {'image/jpeg', 'image/png', 'image/gif', 'image/webp'}",
        "ALLOWED_VIDEO_TYPES = {'video/mp4', 'video/webm'}",
        "MAX_FILE_SIZE = 50 * 1024 * 1024",
        "async def check_media_exists(user_id: str, filename: str) -> str | None:\n    \"\"\"\n    Check if a media file exists in storage for the given user.\n    Tries both images and videos directories.\n\n    Args:\n        user_id (str): ID of the user who uploaded the file\n        filename (str): Name of the file to check\n\n    Returns:\n        str | None: URL of the blob if it exists, None otherwise\n    \"\"\"\n    try:\n        settings = Settings()\n        storage_client = storage.Client()\n        bucket = storage_client.bucket(settings.config.media_gcs_bucket_name)\n        image_path = f'users/{user_id}/images/{filename}'\n        image_blob = bucket.blob(image_path)\n        if image_blob.exists():\n            return image_blob.public_url\n        video_path = f'users/{user_id}/videos/{filename}'\n        video_blob = bucket.blob(video_path)\n        if video_blob.exists():\n            return video_blob.public_url\n        return None\n    except Exception as e:\n        logger.error(f'Error checking if media file exists: {str(e)}')\n        return None",
        "'\\n    Check if a media file exists in storage for the given user.\\n    Tries both images and videos directories.\\n\\n    Args:\\n        user_id (str): ID of the user who uploaded the file\\n        filename (str): Name of the file to check\\n\\n    Returns:\\n        str | None: URL of the blob if it exists, None otherwise\\n    '",
        "try:\n    settings = Settings()\n    storage_client = storage.Client()\n    bucket = storage_client.bucket(settings.config.media_gcs_bucket_name)\n    image_path = f'users/{user_id}/images/{filename}'\n    image_blob = bucket.blob(image_path)\n    if image_blob.exists():\n        return image_blob.public_url\n    video_path = f'users/{user_id}/videos/{filename}'\n    video_blob = bucket.blob(video_path)\n    if video_blob.exists():\n        return video_blob.public_url\n    return None\nexcept Exception as e:\n    logger.error(f'Error checking if media file exists: {str(e)}')\n    return None",
        "settings = Settings()",
        "storage_client = storage.Client()",
        "bucket = storage_client.bucket(settings.config.media_gcs_bucket_name)",
        "image_path = f'users/{user_id}/images/{filename}'",
        "image_blob = bucket.blob(image_path)",
        "image_blob.exists()"
      ],
      "code": "import logging\nimport os\nimport uuid\nimport fastapi\nfrom google.cloud import storage\nimport backend.server.v2.store.exceptions\nfrom backend.util.settings import Settings\nlogger = logging.getLogger(__name__)\nALLOWED_IMAGE_TYPES = {'image/jpeg', 'image/png', 'image/gif', 'image/webp'}\nALLOWED_VIDEO_TYPES = {'video/mp4', 'video/webm'}\nMAX_FILE_SIZE = 50 * 1024 * 1024\nasync def check_media_exists(user_id: str, filename: str) -> str | None:\n    \"\"\"\n    Check if a media file exists in storage for the given user.\n    Tries both images and videos directories.\n\n    Args:\n        user_id (str): ID of the user who uploaded the file\n        filename (str): Name of the file to check\n\n    Returns:\n        str | None: URL of the blob if it exists, None otherwise\n    \"\"\"\n    try:\n        settings = Settings()\n        storage_client = storage.Client()\n        bucket = storage_client.bucket(settings.config.media_gcs_bucket_name)\n        image_path = f'users/{user_id}/images/{filename}'\n        image_blob = bucket.blob(image_path)\n        if image_blob.exists():\n            return image_blob.public_url\n        video_path = f'users/{user_id}/videos/{filename}'\n        video_blob = bucket.blob(video_path)\n        if video_blob.exists():\n            return video_blob.public_url\n        return None\n    except Exception as e:\n        logger.error(f'Error checking if media file exists: {str(e)}')\n        return None\n'\\n    Check if a media file exists in storage for the given user.\\n    Tries both images and videos directories.\\n\\n    Args:\\n        user_id (str): ID of the user who uploaded the file\\n        filename (str): Name of the file to check\\n\\n    Returns:\\n        str | None: URL of the blob if it exists, None otherwise\\n    '\ntry:\n    settings = Settings()\n    storage_client = storage.Client()\n    bucket = storage_client.bucket(settings.config.media_gcs_bucket_name)\n    image_path = f'users/{user_id}/images/{filename}'\n    image_blob = bucket.blob(image_path)\n    if image_blob.exists():\n        return image_blob.public_url\n    video_path = f'users/{user_id}/videos/{filename}'\n    video_blob = bucket.blob(video_path)\n    if video_blob.exists():\n        return video_blob.public_url\n    return None\nexcept Exception as e:\n    logger.error(f'Error checking if media file exists: {str(e)}')\n    return None\nsettings = Settings()\nstorage_client = storage.Client()\nbucket = storage_client.bucket(settings.config.media_gcs_bucket_name)\nimage_path = f'users/{user_id}/images/{filename}'\nimage_blob = bucket.blob(image_path)\nimage_blob.exists()"
    },
    {
      "id": "n1",
      "type": "block",
      "statements": [
        "return image_blob.public_url"
      ],
      "code": "return image_blob.public_url"
    },
    {
      "id": "n2",
      "type": "block",
      "statements": [],
      "code": "\nvideo_path = f'users/{user_id}/videos/{filename}'\nvideo_blob = bucket.blob(video_path)\nvideo_blob.exists()"
    },
    {
      "id": "n3",
      "type": "block",
      "statements": [
        "return video_blob.public_url"
      ],
      "code": "return video_blob.public_url"
    },
    {
      "id": "n4",
      "type": "block",
      "statements": [],
      "code": "\nreturn None"
    },
    {
      "id": "n5",
      "type": "block",
      "statements": [
        "logger.error(f'Error checking if media file exists: {str(e)}')",
        "return None"
      ],
      "code": "logger.error(f'Error checking if media file exists: {str(e)}')\nreturn None"
    },
    {
      "id": "n6",
      "type": "block",
      "statements": [
        "async def upload_media(user_id: str, file: fastapi.UploadFile, use_file_name: bool=False) -> str:\n    try:\n        content = await file.read(1024)\n        await file.seek(0)\n    except Exception as e:\n        logger.error(f'Error reading file content: {str(e)}')\n        raise backend.server.v2.store.exceptions.FileReadError('Failed to read file content') from e\n    if file.content_type in ALLOWED_IMAGE_TYPES:\n        if content.startswith(b'\\xff\\xd8\\xff'):\n            if file.content_type != 'image/jpeg':\n                raise backend.server.v2.store.exceptions.InvalidFileTypeError('File signature does not match content type')\n        elif content.startswith(b'\\x89PNG\\r\\n\\x1a\\n'):\n            if file.content_type != 'image/png':\n                raise backend.server.v2.store.exceptions.InvalidFileTypeError('File signature does not match content type')\n        elif content.startswith(b'GIF87a') or content.startswith(b'GIF89a'):\n            if file.content_type != 'image/gif':\n                raise backend.server.v2.store.exceptions.InvalidFileTypeError('File signature does not match content type')\n        elif content.startswith(b'RIFF') and content[8:12] == b'WEBP':\n            if file.content_type != 'image/webp':\n                raise backend.server.v2.store.exceptions.InvalidFileTypeError('File signature does not match content type')\n        else:\n            raise backend.server.v2.store.exceptions.InvalidFileTypeError('Invalid image file signature')\n    elif file.content_type in ALLOWED_VIDEO_TYPES:\n        if content.startswith(b'\\x00\\x00\\x00') and content[4:8] == b'ftyp':\n            if file.content_type != 'video/mp4':\n                raise backend.server.v2.store.exceptions.InvalidFileTypeError('File signature does not match content type')\n        elif content.startswith(b'\\x1aE\\xdf\\xa3'):\n            if file.content_type != 'video/webm':\n                raise backend.server.v2.store.exceptions.InvalidFileTypeError('File signature does not match content type')\n        else:\n            raise backend.server.v2.store.exceptions.InvalidFileTypeError('Invalid video file signature')\n    settings = Settings()\n    if not settings.config.media_gcs_bucket_name:\n        logger.error('Missing GCS bucket name setting')\n        raise backend.server.v2.store.exceptions.StorageConfigError('Missing storage bucket configuration')\n    try:\n        content_type = file.content_type\n        if content_type is None:\n            content_type = 'image/jpeg'\n        if content_type not in ALLOWED_IMAGE_TYPES and content_type not in ALLOWED_VIDEO_TYPES:\n            logger.warning(f'Invalid file type attempted: {content_type}')\n            raise backend.server.v2.store.exceptions.InvalidFileTypeError(f'File type not supported. Must be jpeg, png, gif, webp, mp4 or webm. Content type: {content_type}')\n        file_size = 0\n        chunk_size = 8192\n        try:\n            while (chunk := (await file.read(chunk_size))):\n                file_size += len(chunk)\n                if file_size > MAX_FILE_SIZE:\n                    logger.warning(f'File size too large: {file_size} bytes')\n                    raise backend.server.v2.store.exceptions.FileSizeTooLargeError('File too large. Maximum size is 50MB')\n        except backend.server.v2.store.exceptions.FileSizeTooLargeError:\n            raise\n        except Exception as e:\n            logger.error(f'Error reading file chunks: {str(e)}')\n            raise backend.server.v2.store.exceptions.FileReadError('Failed to read uploaded file') from e\n        await file.seek(0)\n        filename = file.filename or ''\n        file_ext = os.path.splitext(filename)[1].lower()\n        if use_file_name:\n            unique_filename = filename\n        else:\n            unique_filename = f'{uuid.uuid4()}{file_ext}'\n        media_type = 'images' if content_type in ALLOWED_IMAGE_TYPES else 'videos'\n        storage_path = f'users/{user_id}/{media_type}/{unique_filename}'\n        try:\n            storage_client = storage.Client()\n            bucket = storage_client.bucket(settings.config.media_gcs_bucket_name)\n            blob = bucket.blob(storage_path)\n            blob.content_type = content_type\n            file_bytes = await file.read()\n            blob.upload_from_string(file_bytes, content_type=content_type)\n            public_url = blob.public_url\n            logger.info(f'Successfully uploaded file to: {storage_path}')\n            return public_url\n        except Exception as e:\n            logger.error(f'GCS storage error: {str(e)}')\n            raise backend.server.v2.store.exceptions.StorageUploadError('Failed to upload file to storage') from e\n    except backend.server.v2.store.exceptions.MediaUploadError:\n        raise\n    except Exception as e:\n        logger.exception('Unexpected error in upload_media')\n        raise backend.server.v2.store.exceptions.MediaUploadError('Unexpected error during media upload') from e",
        "try:\n    content = await file.read(1024)\n    await file.seek(0)\nexcept Exception as e:\n    logger.error(f'Error reading file content: {str(e)}')\n    raise backend.server.v2.store.exceptions.FileReadError('Failed to read file content') from e",
        "content = await file.read(1024)",
        "await file.seek(0)",
        "logger.error(f'Error reading file content: {str(e)}')",
        "raise backend.server.v2.store.exceptions.FileReadError('Failed to read file content') from e",
        "file.content_type In ALLOWED_IMAGE_TYPES"
      ],
      "code": "async def upload_media(user_id: str, file: fastapi.UploadFile, use_file_name: bool=False) -> str:\n    try:\n        content = await file.read(1024)\n        await file.seek(0)\n    except Exception as e:\n        logger.error(f'Error reading file content: {str(e)}')\n        raise backend.server.v2.store.exceptions.FileReadError('Failed to read file content') from e\n    if file.content_type in ALLOWED_IMAGE_TYPES:\n        if content.startswith(b'\\xff\\xd8\\xff'):\n            if file.content_type != 'image/jpeg':\n                raise backend.server.v2.store.exceptions.InvalidFileTypeError('File signature does not match content type')\n        elif content.startswith(b'\\x89PNG\\r\\n\\x1a\\n'):\n            if file.content_type != 'image/png':\n                raise backend.server.v2.store.exceptions.InvalidFileTypeError('File signature does not match content type')\n        elif content.startswith(b'GIF87a') or content.startswith(b'GIF89a'):\n            if file.content_type != 'image/gif':\n                raise backend.server.v2.store.exceptions.InvalidFileTypeError('File signature does not match content type')\n        elif content.startswith(b'RIFF') and content[8:12] == b'WEBP':\n            if file.content_type != 'image/webp':\n                raise backend.server.v2.store.exceptions.InvalidFileTypeError('File signature does not match content type')\n        else:\n            raise backend.server.v2.store.exceptions.InvalidFileTypeError('Invalid image file signature')\n    elif file.content_type in ALLOWED_VIDEO_TYPES:\n        if content.startswith(b'\\x00\\x00\\x00') and content[4:8] == b'ftyp':\n            if file.content_type != 'video/mp4':\n                raise backend.server.v2.store.exceptions.InvalidFileTypeError('File signature does not match content type')\n        elif content.startswith(b'\\x1aE\\xdf\\xa3'):\n            if file.content_type != 'video/webm':\n                raise backend.server.v2.store.exceptions.InvalidFileTypeError('File signature does not match content type')\n        else:\n            raise backend.server.v2.store.exceptions.InvalidFileTypeError('Invalid video file signature')\n    settings = Settings()\n    if not settings.config.media_gcs_bucket_name:\n        logger.error('Missing GCS bucket name setting')\n        raise backend.server.v2.store.exceptions.StorageConfigError('Missing storage bucket configuration')\n    try:\n        content_type = file.content_type\n        if content_type is None:\n            content_type = 'image/jpeg'\n        if content_type not in ALLOWED_IMAGE_TYPES and content_type not in ALLOWED_VIDEO_TYPES:\n            logger.warning(f'Invalid file type attempted: {content_type}')\n            raise backend.server.v2.store.exceptions.InvalidFileTypeError(f'File type not supported. Must be jpeg, png, gif, webp, mp4 or webm. Content type: {content_type}')\n        file_size = 0\n        chunk_size = 8192\n        try:\n            while (chunk := (await file.read(chunk_size))):\n                file_size += len(chunk)\n                if file_size > MAX_FILE_SIZE:\n                    logger.warning(f'File size too large: {file_size} bytes')\n                    raise backend.server.v2.store.exceptions.FileSizeTooLargeError('File too large. Maximum size is 50MB')\n        except backend.server.v2.store.exceptions.FileSizeTooLargeError:\n            raise\n        except Exception as e:\n            logger.error(f'Error reading file chunks: {str(e)}')\n            raise backend.server.v2.store.exceptions.FileReadError('Failed to read uploaded file') from e\n        await file.seek(0)\n        filename = file.filename or ''\n        file_ext = os.path.splitext(filename)[1].lower()\n        if use_file_name:\n            unique_filename = filename\n        else:\n            unique_filename = f'{uuid.uuid4()}{file_ext}'\n        media_type = 'images' if content_type in ALLOWED_IMAGE_TYPES else 'videos'\n        storage_path = f'users/{user_id}/{media_type}/{unique_filename}'\n        try:\n            storage_client = storage.Client()\n            bucket = storage_client.bucket(settings.config.media_gcs_bucket_name)\n            blob = bucket.blob(storage_path)\n            blob.content_type = content_type\n            file_bytes = await file.read()\n            blob.upload_from_string(file_bytes, content_type=content_type)\n            public_url = blob.public_url\n            logger.info(f'Successfully uploaded file to: {storage_path}')\n            return public_url\n        except Exception as e:\n            logger.error(f'GCS storage error: {str(e)}')\n            raise backend.server.v2.store.exceptions.StorageUploadError('Failed to upload file to storage') from e\n    except backend.server.v2.store.exceptions.MediaUploadError:\n        raise\n    except Exception as e:\n        logger.exception('Unexpected error in upload_media')\n        raise backend.server.v2.store.exceptions.MediaUploadError('Unexpected error during media upload') from e\ntry:\n    content = await file.read(1024)\n    await file.seek(0)\nexcept Exception as e:\n    logger.error(f'Error reading file content: {str(e)}')\n    raise backend.server.v2.store.exceptions.FileReadError('Failed to read file content') from e\ncontent = await file.read(1024)\nawait file.seek(0)\nlogger.error(f'Error reading file content: {str(e)}')\nraise backend.server.v2.store.exceptions.FileReadError('Failed to read file content') from e\nfile.content_type In ALLOWED_IMAGE_TYPES"
    },
    {
      "id": "n7",
      "type": "block",
      "statements": [
        "content.startswith(b'\\xff\\xd8\\xff')"
      ],
      "code": "content.startswith(b'\\xff\\xd8\\xff')"
    },
    {
      "id": "n8",
      "type": "block",
      "statements": [
        "file.content_type In ALLOWED_VIDEO_TYPES"
      ],
      "code": "file.content_type In ALLOWED_VIDEO_TYPES"
    },
    {
      "id": "n9",
      "type": "block",
      "statements": [
        "settings = Settings()",
        "not settings.config.media_gcs_bucket_name"
      ],
      "code": "settings = Settings()\nnot settings.config.media_gcs_bucket_name"
    },
    {
      "id": "n10",
      "type": "block",
      "statements": [
        "file.content_type NotEq 'image/jpeg'"
      ],
      "code": "file.content_type NotEq 'image/jpeg'"
    },
    {
      "id": "n11",
      "type": "block",
      "statements": [
        "content.startswith(b'\\x89PNG\\r\\n\\x1a\\n')"
      ],
      "code": "content.startswith(b'\\x89PNG\\r\\n\\x1a\\n')"
    },
    {
      "id": "n12",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n13",
      "type": "block",
      "statements": [
        "raise backend.server.v2.store.exceptions.InvalidFileTypeError('File signature does not match content type')"
      ],
      "code": "raise backend.server.v2.store.exceptions.InvalidFileTypeError('File signature does not match content type')"
    },
    {
      "id": "n14",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n15",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n16",
      "type": "block",
      "statements": [
        "file.content_type NotEq 'image/png'"
      ],
      "code": "file.content_type NotEq 'image/png'"
    },
    {
      "id": "n17",
      "type": "block",
      "statements": [
        "content.startswith(b'GIF87a') or content.startswith(b'GIF89a')"
      ],
      "code": "content.startswith(b'GIF87a') or content.startswith(b'GIF89a')"
    },
    {
      "id": "n18",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n19",
      "type": "block",
      "statements": [
        "raise backend.server.v2.store.exceptions.InvalidFileTypeError('File signature does not match content type')"
      ],
      "code": "raise backend.server.v2.store.exceptions.InvalidFileTypeError('File signature does not match content type')"
    },
    {
      "id": "n20",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n21",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n22",
      "type": "block",
      "statements": [
        "file.content_type NotEq 'image/gif'"
      ],
      "code": "file.content_type NotEq 'image/gif'"
    },
    {
      "id": "n23",
      "type": "block",
      "statements": [
        "content.startswith(b'RIFF') and content[8:12] == b'WEBP'"
      ],
      "code": "content.startswith(b'RIFF') and content[8:12] == b'WEBP'"
    },
    {
      "id": "n24",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n25",
      "type": "block",
      "statements": [
        "raise backend.server.v2.store.exceptions.InvalidFileTypeError('File signature does not match content type')"
      ],
      "code": "raise backend.server.v2.store.exceptions.InvalidFileTypeError('File signature does not match content type')"
    },
    {
      "id": "n26",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n27",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n28",
      "type": "block",
      "statements": [
        "file.content_type NotEq 'image/webp'"
      ],
      "code": "file.content_type NotEq 'image/webp'"
    },
    {
      "id": "n29",
      "type": "block",
      "statements": [
        "raise backend.server.v2.store.exceptions.InvalidFileTypeError('Invalid image file signature')"
      ],
      "code": "raise backend.server.v2.store.exceptions.InvalidFileTypeError('Invalid image file signature')"
    },
    {
      "id": "n30",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n31",
      "type": "block",
      "statements": [
        "raise backend.server.v2.store.exceptions.InvalidFileTypeError('File signature does not match content type')"
      ],
      "code": "raise backend.server.v2.store.exceptions.InvalidFileTypeError('File signature does not match content type')"
    },
    {
      "id": "n32",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n33",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n34",
      "type": "block",
      "statements": [
        "content.startswith(b'\\x00\\x00\\x00') and content[4:8] == b'ftyp'"
      ],
      "code": "content.startswith(b'\\x00\\x00\\x00') and content[4:8] == b'ftyp'"
    },
    {
      "id": "n35",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n36",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n37",
      "type": "block",
      "statements": [
        "file.content_type NotEq 'video/mp4'"
      ],
      "code": "file.content_type NotEq 'video/mp4'"
    },
    {
      "id": "n38",
      "type": "block",
      "statements": [
        "content.startswith(b'\\x1aE\\xdf\\xa3')"
      ],
      "code": "content.startswith(b'\\x1aE\\xdf\\xa3')"
    },
    {
      "id": "n39",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n40",
      "type": "block",
      "statements": [
        "raise backend.server.v2.store.exceptions.InvalidFileTypeError('File signature does not match content type')"
      ],
      "code": "raise backend.server.v2.store.exceptions.InvalidFileTypeError('File signature does not match content type')"
    },
    {
      "id": "n41",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n42",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n43",
      "type": "block",
      "statements": [
        "file.content_type NotEq 'video/webm'"
      ],
      "code": "file.content_type NotEq 'video/webm'"
    },
    {
      "id": "n44",
      "type": "block",
      "statements": [
        "raise backend.server.v2.store.exceptions.InvalidFileTypeError('Invalid video file signature')"
      ],
      "code": "raise backend.server.v2.store.exceptions.InvalidFileTypeError('Invalid video file signature')"
    },
    {
      "id": "n45",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n46",
      "type": "block",
      "statements": [
        "raise backend.server.v2.store.exceptions.InvalidFileTypeError('File signature does not match content type')"
      ],
      "code": "raise backend.server.v2.store.exceptions.InvalidFileTypeError('File signature does not match content type')"
    },
    {
      "id": "n47",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n48",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n49",
      "type": "block",
      "statements": [
        "logger.error('Missing GCS bucket name setting')",
        "raise backend.server.v2.store.exceptions.StorageConfigError('Missing storage bucket configuration')"
      ],
      "code": "logger.error('Missing GCS bucket name setting')\nraise backend.server.v2.store.exceptions.StorageConfigError('Missing storage bucket configuration')"
    },
    {
      "id": "n50",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n51",
      "type": "block",
      "statements": [
        "try:\n    content_type = file.content_type\n    if content_type is None:\n        content_type = 'image/jpeg'\n    if content_type not in ALLOWED_IMAGE_TYPES and content_type not in ALLOWED_VIDEO_TYPES:\n        logger.warning(f'Invalid file type attempted: {content_type}')\n        raise backend.server.v2.store.exceptions.InvalidFileTypeError(f'File type not supported. Must be jpeg, png, gif, webp, mp4 or webm. Content type: {content_type}')\n    file_size = 0\n    chunk_size = 8192\n    try:\n        while (chunk := (await file.read(chunk_size))):\n            file_size += len(chunk)\n            if file_size > MAX_FILE_SIZE:\n                logger.warning(f'File size too large: {file_size} bytes')\n                raise backend.server.v2.store.exceptions.FileSizeTooLargeError('File too large. Maximum size is 50MB')\n    except backend.server.v2.store.exceptions.FileSizeTooLargeError:\n        raise\n    except Exception as e:\n        logger.error(f'Error reading file chunks: {str(e)}')\n        raise backend.server.v2.store.exceptions.FileReadError('Failed to read uploaded file') from e\n    await file.seek(0)\n    filename = file.filename or ''\n    file_ext = os.path.splitext(filename)[1].lower()\n    if use_file_name:\n        unique_filename = filename\n    else:\n        unique_filename = f'{uuid.uuid4()}{file_ext}'\n    media_type = 'images' if content_type in ALLOWED_IMAGE_TYPES else 'videos'\n    storage_path = f'users/{user_id}/{media_type}/{unique_filename}'\n    try:\n        storage_client = storage.Client()\n        bucket = storage_client.bucket(settings.config.media_gcs_bucket_name)\n        blob = bucket.blob(storage_path)\n        blob.content_type = content_type\n        file_bytes = await file.read()\n        blob.upload_from_string(file_bytes, content_type=content_type)\n        public_url = blob.public_url\n        logger.info(f'Successfully uploaded file to: {storage_path}')\n        return public_url\n    except Exception as e:\n        logger.error(f'GCS storage error: {str(e)}')\n        raise backend.server.v2.store.exceptions.StorageUploadError('Failed to upload file to storage') from e\nexcept backend.server.v2.store.exceptions.MediaUploadError:\n    raise\nexcept Exception as e:\n    logger.exception('Unexpected error in upload_media')\n    raise backend.server.v2.store.exceptions.MediaUploadError('Unexpected error during media upload') from e",
        "content_type = file.content_type",
        "content_type Is None"
      ],
      "code": "try:\n    content_type = file.content_type\n    if content_type is None:\n        content_type = 'image/jpeg'\n    if content_type not in ALLOWED_IMAGE_TYPES and content_type not in ALLOWED_VIDEO_TYPES:\n        logger.warning(f'Invalid file type attempted: {content_type}')\n        raise backend.server.v2.store.exceptions.InvalidFileTypeError(f'File type not supported. Must be jpeg, png, gif, webp, mp4 or webm. Content type: {content_type}')\n    file_size = 0\n    chunk_size = 8192\n    try:\n        while (chunk := (await file.read(chunk_size))):\n            file_size += len(chunk)\n            if file_size > MAX_FILE_SIZE:\n                logger.warning(f'File size too large: {file_size} bytes')\n                raise backend.server.v2.store.exceptions.FileSizeTooLargeError('File too large. Maximum size is 50MB')\n    except backend.server.v2.store.exceptions.FileSizeTooLargeError:\n        raise\n    except Exception as e:\n        logger.error(f'Error reading file chunks: {str(e)}')\n        raise backend.server.v2.store.exceptions.FileReadError('Failed to read uploaded file') from e\n    await file.seek(0)\n    filename = file.filename or ''\n    file_ext = os.path.splitext(filename)[1].lower()\n    if use_file_name:\n        unique_filename = filename\n    else:\n        unique_filename = f'{uuid.uuid4()}{file_ext}'\n    media_type = 'images' if content_type in ALLOWED_IMAGE_TYPES else 'videos'\n    storage_path = f'users/{user_id}/{media_type}/{unique_filename}'\n    try:\n        storage_client = storage.Client()\n        bucket = storage_client.bucket(settings.config.media_gcs_bucket_name)\n        blob = bucket.blob(storage_path)\n        blob.content_type = content_type\n        file_bytes = await file.read()\n        blob.upload_from_string(file_bytes, content_type=content_type)\n        public_url = blob.public_url\n        logger.info(f'Successfully uploaded file to: {storage_path}')\n        return public_url\n    except Exception as e:\n        logger.error(f'GCS storage error: {str(e)}')\n        raise backend.server.v2.store.exceptions.StorageUploadError('Failed to upload file to storage') from e\nexcept backend.server.v2.store.exceptions.MediaUploadError:\n    raise\nexcept Exception as e:\n    logger.exception('Unexpected error in upload_media')\n    raise backend.server.v2.store.exceptions.MediaUploadError('Unexpected error during media upload') from e\ncontent_type = file.content_type\ncontent_type Is None"
    },
    {
      "id": "n52",
      "type": "block",
      "statements": [
        "content_type = 'image/jpeg'"
      ],
      "code": "content_type = 'image/jpeg'"
    },
    {
      "id": "n53",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n54",
      "type": "block",
      "statements": [
        "content_type not in ALLOWED_IMAGE_TYPES and content_type not in ALLOWED_VIDEO_TYPES"
      ],
      "code": "content_type not in ALLOWED_IMAGE_TYPES and content_type not in ALLOWED_VIDEO_TYPES"
    },
    {
      "id": "n55",
      "type": "block",
      "statements": [
        "logger.warning(f'Invalid file type attempted: {content_type}')",
        "raise backend.server.v2.store.exceptions.InvalidFileTypeError(f'File type not supported. Must be jpeg, png, gif, webp, mp4 or webm. Content type: {content_type}')"
      ],
      "code": "logger.warning(f'Invalid file type attempted: {content_type}')\nraise backend.server.v2.store.exceptions.InvalidFileTypeError(f'File type not supported. Must be jpeg, png, gif, webp, mp4 or webm. Content type: {content_type}')"
    },
    {
      "id": "n56",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n57",
      "type": "block",
      "statements": [
        "file_size = 0",
        "chunk_size = 8192",
        "try:\n    while (chunk := (await file.read(chunk_size))):\n        file_size += len(chunk)\n        if file_size > MAX_FILE_SIZE:\n            logger.warning(f'File size too large: {file_size} bytes')\n            raise backend.server.v2.store.exceptions.FileSizeTooLargeError('File too large. Maximum size is 50MB')\nexcept backend.server.v2.store.exceptions.FileSizeTooLargeError:\n    raise\nexcept Exception as e:\n    logger.error(f'Error reading file chunks: {str(e)}')\n    raise backend.server.v2.store.exceptions.FileReadError('Failed to read uploaded file') from e"
      ],
      "code": "file_size = 0\nchunk_size = 8192\ntry:\n    while (chunk := (await file.read(chunk_size))):\n        file_size += len(chunk)\n        if file_size > MAX_FILE_SIZE:\n            logger.warning(f'File size too large: {file_size} bytes')\n            raise backend.server.v2.store.exceptions.FileSizeTooLargeError('File too large. Maximum size is 50MB')\nexcept backend.server.v2.store.exceptions.FileSizeTooLargeError:\n    raise\nexcept Exception as e:\n    logger.error(f'Error reading file chunks: {str(e)}')\n    raise backend.server.v2.store.exceptions.FileReadError('Failed to read uploaded file') from e"
    },
    {
      "id": "n58",
      "type": "block",
      "statements": [
        "(chunk := (await file.read(chunk_size)))"
      ],
      "code": "(chunk := (await file.read(chunk_size)))"
    },
    {
      "id": "n59",
      "type": "block",
      "statements": [
        "file_size += len(chunk)",
        "file_size Gt MAX_FILE_SIZE"
      ],
      "code": "file_size += len(chunk)\nfile_size Gt MAX_FILE_SIZE"
    },
    {
      "id": "n60",
      "type": "block",
      "statements": [
        "raise",
        "logger.error(f'Error reading file chunks: {str(e)}')",
        "raise backend.server.v2.store.exceptions.FileReadError('Failed to read uploaded file') from e",
        "await file.seek(0)",
        "filename = file.filename or ''",
        "file_ext = os.path.splitext(filename)[1].lower()",
        "use_file_name"
      ],
      "code": "raise\nlogger.error(f'Error reading file chunks: {str(e)}')\nraise backend.server.v2.store.exceptions.FileReadError('Failed to read uploaded file') from e\nawait file.seek(0)\nfilename = file.filename or ''\nfile_ext = os.path.splitext(filename)[1].lower()\nuse_file_name"
    },
    {
      "id": "n61",
      "type": "block",
      "statements": [
        "logger.warning(f'File size too large: {file_size} bytes')",
        "raise backend.server.v2.store.exceptions.FileSizeTooLargeError('File too large. Maximum size is 50MB')"
      ],
      "code": "logger.warning(f'File size too large: {file_size} bytes')\nraise backend.server.v2.store.exceptions.FileSizeTooLargeError('File too large. Maximum size is 50MB')"
    },
    {
      "id": "n62",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n63",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n64",
      "type": "block",
      "statements": [
        "unique_filename = filename"
      ],
      "code": "unique_filename = filename"
    },
    {
      "id": "n65",
      "type": "block",
      "statements": [
        "unique_filename = f'{uuid.uuid4()}{file_ext}'"
      ],
      "code": "unique_filename = f'{uuid.uuid4()}{file_ext}'"
    },
    {
      "id": "n66",
      "type": "block",
      "statements": [
        "media_type = 'images' if content_type in ALLOWED_IMAGE_TYPES else 'videos'",
        "storage_path = f'users/{user_id}/{media_type}/{unique_filename}'",
        "try:\n    storage_client = storage.Client()\n    bucket = storage_client.bucket(settings.config.media_gcs_bucket_name)\n    blob = bucket.blob(storage_path)\n    blob.content_type = content_type\n    file_bytes = await file.read()\n    blob.upload_from_string(file_bytes, content_type=content_type)\n    public_url = blob.public_url\n    logger.info(f'Successfully uploaded file to: {storage_path}')\n    return public_url\nexcept Exception as e:\n    logger.error(f'GCS storage error: {str(e)}')\n    raise backend.server.v2.store.exceptions.StorageUploadError('Failed to upload file to storage') from e",
        "storage_client = storage.Client()",
        "bucket = storage_client.bucket(settings.config.media_gcs_bucket_name)",
        "blob = bucket.blob(storage_path)",
        "blob.content_type = content_type",
        "file_bytes = await file.read()",
        "blob.upload_from_string(file_bytes)",
        "public_url = blob.public_url",
        "logger.info(f'Successfully uploaded file to: {storage_path}')",
        "return public_url"
      ],
      "code": "media_type = 'images' if content_type in ALLOWED_IMAGE_TYPES else 'videos'\nstorage_path = f'users/{user_id}/{media_type}/{unique_filename}'\ntry:\n    storage_client = storage.Client()\n    bucket = storage_client.bucket(settings.config.media_gcs_bucket_name)\n    blob = bucket.blob(storage_path)\n    blob.content_type = content_type\n    file_bytes = await file.read()\n    blob.upload_from_string(file_bytes, content_type=content_type)\n    public_url = blob.public_url\n    logger.info(f'Successfully uploaded file to: {storage_path}')\n    return public_url\nexcept Exception as e:\n    logger.error(f'GCS storage error: {str(e)}')\n    raise backend.server.v2.store.exceptions.StorageUploadError('Failed to upload file to storage') from e\nstorage_client = storage.Client()\nbucket = storage_client.bucket(settings.config.media_gcs_bucket_name)\nblob = bucket.blob(storage_path)\nblob.content_type = content_type\nfile_bytes = await file.read()\nblob.upload_from_string(file_bytes)\npublic_url = blob.public_url\nlogger.info(f'Successfully uploaded file to: {storage_path}')\nreturn public_url"
    },
    {
      "id": "n67",
      "type": "block",
      "statements": [
        "logger.error(f'GCS storage error: {str(e)}')",
        "raise backend.server.v2.store.exceptions.StorageUploadError('Failed to upload file to storage') from e",
        "raise",
        "logger.exception('Unexpected error in upload_media')",
        "raise backend.server.v2.store.exceptions.MediaUploadError('Unexpected error during media upload') from e"
      ],
      "code": "logger.error(f'GCS storage error: {str(e)}')\nraise backend.server.v2.store.exceptions.StorageUploadError('Failed to upload file to storage') from e\nraise\nlogger.exception('Unexpected error in upload_media')\nraise backend.server.v2.store.exceptions.MediaUploadError('Unexpected error during media upload') from e"
    }
  ],
  "edges": [
    {
      "source": "n23",
      "target": "n29"
    },
    {
      "source": "n34",
      "target": "n38"
    },
    {
      "source": "n0",
      "target": "n1"
    },
    {
      "source": "n14",
      "target": "n15"
    },
    {
      "source": "n18",
      "target": "n12"
    },
    {
      "source": "n50",
      "target": "n51"
    },
    {
      "source": "n26",
      "target": "n27"
    },
    {
      "source": "n43",
      "target": "n47"
    },
    {
      "source": "n35",
      "target": "n36"
    },
    {
      "source": "n2",
      "target": "n4"
    },
    {
      "source": "n31",
      "target": "n33"
    },
    {
      "source": "n37",
      "target": "n41"
    },
    {
      "source": "n45",
      "target": "n39"
    },
    {
      "source": "n51",
      "target": "n52"
    },
    {
      "source": "n20",
      "target": "n21"
    },
    {
      "source": "n22",
      "target": "n25"
    },
    {
      "source": "n59",
      "target": "n61"
    },
    {
      "source": "n17",
      "target": "n23"
    },
    {
      "source": "n21",
      "target": "n18"
    },
    {
      "source": "n59",
      "target": "n62"
    },
    {
      "source": "n6",
      "target": "n8"
    },
    {
      "source": "n41",
      "target": "n42"
    },
    {
      "source": "n65",
      "target": "n66"
    },
    {
      "source": "n63",
      "target": "n58"
    },
    {
      "source": "n23",
      "target": "n28"
    },
    {
      "source": "n7",
      "target": "n10"
    },
    {
      "source": "n8",
      "target": "n35"
    },
    {
      "source": "n43",
      "target": "n46"
    },
    {
      "source": "n2",
      "target": "n3"
    },
    {
      "source": "n19",
      "target": "n21"
    },
    {
      "source": "n17",
      "target": "n22"
    },
    {
      "source": "n16",
      "target": "n19"
    },
    {
      "source": "n9",
      "target": "n50"
    },
    {
      "source": "n58",
      "target": "n60"
    },
    {
      "source": "n28",
      "target": "n32"
    },
    {
      "source": "n29",
      "target": "n30"
    },
    {
      "source": "n58",
      "target": "n59"
    },
    {
      "source": "n9",
      "target": "n49"
    },
    {
      "source": "n48",
      "target": "n45"
    },
    {
      "source": "n33",
      "target": "n30"
    },
    {
      "source": "n28",
      "target": "n31"
    },
    {
      "source": "n10",
      "target": "n14"
    },
    {
      "source": "n27",
      "target": "n24"
    },
    {
      "source": "n22",
      "target": "n26"
    },
    {
      "source": "n60",
      "target": "n64"
    },
    {
      "source": "n44",
      "target": "n45"
    },
    {
      "source": "n53",
      "target": "n54"
    },
    {
      "source": "n34",
      "target": "n37"
    },
    {
      "source": "n37",
      "target": "n40"
    },
    {
      "source": "n47",
      "target": "n48"
    },
    {
      "source": "n30",
      "target": "n24"
    },
    {
      "source": "n51",
      "target": "n53"
    },
    {
      "source": "n11",
      "target": "n16"
    },
    {
      "source": "n46",
      "target": "n48"
    },
    {
      "source": "n62",
      "target": "n63"
    },
    {
      "source": "n54",
      "target": "n56"
    },
    {
      "source": "n57",
      "target": "n58"
    },
    {
      "source": "n39",
      "target": "n36"
    },
    {
      "source": "n64",
      "target": "n66"
    },
    {
      "source": "n40",
      "target": "n42"
    },
    {
      "source": "n36",
      "target": "n9"
    },
    {
      "source": "n0",
      "target": "n2"
    },
    {
      "source": "n54",
      "target": "n55"
    },
    {
      "source": "n6",
      "target": "n7"
    },
    {
      "source": "n38",
      "target": "n43"
    },
    {
      "source": "n7",
      "target": "n11"
    },
    {
      "source": "n61",
      "target": "n63"
    },
    {
      "source": "n11",
      "target": "n17"
    },
    {
      "source": "n24",
      "target": "n18"
    },
    {
      "source": "n13",
      "target": "n15"
    },
    {
      "source": "n42",
      "target": "n39"
    },
    {
      "source": "n12",
      "target": "n9"
    },
    {
      "source": "n38",
      "target": "n44"
    },
    {
      "source": "n15",
      "target": "n12"
    },
    {
      "source": "n55",
      "target": "n57"
    },
    {
      "source": "n16",
      "target": "n20"
    },
    {
      "source": "n32",
      "target": "n33"
    },
    {
      "source": "n49",
      "target": "n51"
    },
    {
      "source": "n8",
      "target": "n34"
    },
    {
      "source": "n52",
      "target": "n54"
    },
    {
      "source": "n25",
      "target": "n27"
    },
    {
      "source": "n60",
      "target": "n65"
    },
    {
      "source": "n10",
      "target": "n13"
    },
    {
      "source": "n56",
      "target": "n57"
    }
  ]
}