{
  "nodes": [
    {
      "id": "n0",
      "type": "block",
      "statements": [
        "import asyncio",
        "import json",
        "import logging",
        "from abc import ABC, abstractmethod",
        "from datetime import datetime",
        "from typing import Any, AsyncGenerator, Generator, Generic, Optional, TypeVar",
        "from pydantic import BaseModel",
        "from redis.asyncio.client import PubSub as AsyncPubSub",
        "from redis.client import PubSub",
        "from backend.data import redis",
        "logger = logging.getLogger(__name__)",
        "class DateTimeEncoder(json.JSONEncoder):\n\n    def default(self, o):\n        if isinstance(o, datetime):\n            return o.isoformat()\n        return super().default(o)",
        "def default(self, o):\n    if isinstance(o, datetime):\n        return o.isoformat()\n    return super().default(o)",
        "isinstance(o, datetime)"
      ],
      "code": "import asyncio\nimport json\nimport logging\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom typing import Any, AsyncGenerator, Generator, Generic, Optional, TypeVar\nfrom pydantic import BaseModel\nfrom redis.asyncio.client import PubSub as AsyncPubSub\nfrom redis.client import PubSub\nfrom backend.data import redis\nlogger = logging.getLogger(__name__)\nclass DateTimeEncoder(json.JSONEncoder):\n\n    def default(self, o):\n        if isinstance(o, datetime):\n            return o.isoformat()\n        return super().default(o)\ndef default(self, o):\n    if isinstance(o, datetime):\n        return o.isoformat()\n    return super().default(o)\nisinstance(o, datetime)"
    },
    {
      "id": "n1",
      "type": "block",
      "statements": [
        "return o.isoformat()"
      ],
      "code": "return o.isoformat()"
    },
    {
      "id": "n2",
      "type": "block",
      "statements": [],
      "code": "\nreturn super().default(o)"
    },
    {
      "id": "n3",
      "type": "block",
      "statements": [
        "M = TypeVar('M', bound=BaseModel)",
        "class BaseRedisEventBus(Generic[M], ABC):\n    Model: type[M]\n\n    @property\n    @abstractmethod\n    def event_bus_name(self) -> str:\n        pass\n\n    def _serialize_message(self, item: M, channel_key: str) -> tuple[str, str]:\n        message = json.dumps(item.model_dump(), cls=DateTimeEncoder)\n        channel_name = f'{self.event_bus_name}/{channel_key}'\n        logger.info(f'[{channel_name}] Publishing an event to Redis {message}')\n        return (message, channel_name)\n\n    def _deserialize_message(self, msg: Any, channel_key: str) -> M | None:\n        message_type = 'pmessage' if '*' in channel_key else 'message'\n        if msg['type'] != message_type:\n            return None\n        try:\n            data = json.loads(msg['data'])\n            logger.info(f'Consuming an event from Redis {data}')\n            return self.Model(**data)\n        except Exception as e:\n            logger.error(f'Failed to parse event result from Redis {msg} {e}')\n\n    def _get_pubsub_channel(self, connection: redis.Redis | redis.AsyncRedis, channel_key: str) -> tuple[PubSub | AsyncPubSub, str]:\n        full_channel_name = f'{self.event_bus_name}/{channel_key}'\n        pubsub = connection.pubsub()\n        return (pubsub, full_channel_name)",
        "Model: type[M]",
        "@property\n@abstractmethod\ndef event_bus_name(self) -> str:\n    pass",
        "pass",
        "def _serialize_message(self, item: M, channel_key: str) -> tuple[str, str]:\n    message = json.dumps(item.model_dump(), cls=DateTimeEncoder)\n    channel_name = f'{self.event_bus_name}/{channel_key}'\n    logger.info(f'[{channel_name}] Publishing an event to Redis {message}')\n    return (message, channel_name)",
        "message = json.dumps(item.model_dump(), cls=DateTimeEncoder)",
        "channel_name = f'{self.event_bus_name}/{channel_key}'",
        "logger.info(f'[{channel_name}] Publishing an event to Redis {message}')",
        "return (message, channel_name)"
      ],
      "code": "M = TypeVar('M', bound=BaseModel)\nclass BaseRedisEventBus(Generic[M], ABC):\n    Model: type[M]\n\n    @property\n    @abstractmethod\n    def event_bus_name(self) -> str:\n        pass\n\n    def _serialize_message(self, item: M, channel_key: str) -> tuple[str, str]:\n        message = json.dumps(item.model_dump(), cls=DateTimeEncoder)\n        channel_name = f'{self.event_bus_name}/{channel_key}'\n        logger.info(f'[{channel_name}] Publishing an event to Redis {message}')\n        return (message, channel_name)\n\n    def _deserialize_message(self, msg: Any, channel_key: str) -> M | None:\n        message_type = 'pmessage' if '*' in channel_key else 'message'\n        if msg['type'] != message_type:\n            return None\n        try:\n            data = json.loads(msg['data'])\n            logger.info(f'Consuming an event from Redis {data}')\n            return self.Model(**data)\n        except Exception as e:\n            logger.error(f'Failed to parse event result from Redis {msg} {e}')\n\n    def _get_pubsub_channel(self, connection: redis.Redis | redis.AsyncRedis, channel_key: str) -> tuple[PubSub | AsyncPubSub, str]:\n        full_channel_name = f'{self.event_bus_name}/{channel_key}'\n        pubsub = connection.pubsub()\n        return (pubsub, full_channel_name)\nModel: type[M]\n@property\n@abstractmethod\ndef event_bus_name(self) -> str:\n    pass\npass\ndef _serialize_message(self, item: M, channel_key: str) -> tuple[str, str]:\n    message = json.dumps(item.model_dump(), cls=DateTimeEncoder)\n    channel_name = f'{self.event_bus_name}/{channel_key}'\n    logger.info(f'[{channel_name}] Publishing an event to Redis {message}')\n    return (message, channel_name)\nmessage = json.dumps(item.model_dump(), cls=DateTimeEncoder)\nchannel_name = f'{self.event_bus_name}/{channel_key}'\nlogger.info(f'[{channel_name}] Publishing an event to Redis {message}')\nreturn (message, channel_name)"
    },
    {
      "id": "n4",
      "type": "block",
      "statements": [
        "def _deserialize_message(self, msg: Any, channel_key: str) -> M | None:\n    message_type = 'pmessage' if '*' in channel_key else 'message'\n    if msg['type'] != message_type:\n        return None\n    try:\n        data = json.loads(msg['data'])\n        logger.info(f'Consuming an event from Redis {data}')\n        return self.Model(**data)\n    except Exception as e:\n        logger.error(f'Failed to parse event result from Redis {msg} {e}')",
        "message_type = 'pmessage' if '*' in channel_key else 'message'",
        "msg['type'] NotEq message_type"
      ],
      "code": "def _deserialize_message(self, msg: Any, channel_key: str) -> M | None:\n    message_type = 'pmessage' if '*' in channel_key else 'message'\n    if msg['type'] != message_type:\n        return None\n    try:\n        data = json.loads(msg['data'])\n        logger.info(f'Consuming an event from Redis {data}')\n        return self.Model(**data)\n    except Exception as e:\n        logger.error(f'Failed to parse event result from Redis {msg} {e}')\nmessage_type = 'pmessage' if '*' in channel_key else 'message'\nmsg['type'] NotEq message_type"
    },
    {
      "id": "n5",
      "type": "block",
      "statements": [
        "return None"
      ],
      "code": "return None"
    },
    {
      "id": "n6",
      "type": "block",
      "statements": [],
      "code": "\ntry:\n    data = json.loads(msg['data'])\n    logger.info(f'Consuming an event from Redis {data}')\n    return self.Model(**data)\nexcept Exception as e:\n    logger.error(f'Failed to parse event result from Redis {msg} {e}')\ndata = json.loads(msg['data'])\nlogger.info(f'Consuming an event from Redis {data}')\nreturn self.Model(**data)"
    },
    {
      "id": "n7",
      "type": "block",
      "statements": [
        "logger.error(f'Failed to parse event result from Redis {msg} {e}')",
        "def _get_pubsub_channel(self, connection: redis.Redis | redis.AsyncRedis, channel_key: str) -> tuple[PubSub | AsyncPubSub, str]:\n    full_channel_name = f'{self.event_bus_name}/{channel_key}'\n    pubsub = connection.pubsub()\n    return (pubsub, full_channel_name)",
        "full_channel_name = f'{self.event_bus_name}/{channel_key}'",
        "pubsub = connection.pubsub()",
        "return (pubsub, full_channel_name)"
      ],
      "code": "logger.error(f'Failed to parse event result from Redis {msg} {e}')\ndef _get_pubsub_channel(self, connection: redis.Redis | redis.AsyncRedis, channel_key: str) -> tuple[PubSub | AsyncPubSub, str]:\n    full_channel_name = f'{self.event_bus_name}/{channel_key}'\n    pubsub = connection.pubsub()\n    return (pubsub, full_channel_name)\nfull_channel_name = f'{self.event_bus_name}/{channel_key}'\npubsub = connection.pubsub()\nreturn (pubsub, full_channel_name)"
    },
    {
      "id": "n8",
      "type": "block",
      "statements": [
        "class RedisEventBus(BaseRedisEventBus[M], ABC):\n    Model: type[M]\n\n    @property\n    def connection(self) -> redis.Redis:\n        return redis.get_redis()\n\n    def publish_event(self, event: M, channel_key: str):\n        (message, full_channel_name) = self._serialize_message(event, channel_key)\n        self.connection.publish(full_channel_name, message)\n\n    def listen_events(self, channel_key: str) -> Generator[M, None, None]:\n        (pubsub, full_channel_name) = self._get_pubsub_channel(self.connection, channel_key)\n        assert isinstance(pubsub, PubSub)\n        if '*' in channel_key:\n            pubsub.psubscribe(full_channel_name)\n        else:\n            pubsub.subscribe(full_channel_name)\n        for message in pubsub.listen():\n            if (event := self._deserialize_message(message, channel_key)):\n                yield event",
        "Model: type[M]",
        "@property\ndef connection(self) -> redis.Redis:\n    return redis.get_redis()",
        "return redis.get_redis()"
      ],
      "code": "class RedisEventBus(BaseRedisEventBus[M], ABC):\n    Model: type[M]\n\n    @property\n    def connection(self) -> redis.Redis:\n        return redis.get_redis()\n\n    def publish_event(self, event: M, channel_key: str):\n        (message, full_channel_name) = self._serialize_message(event, channel_key)\n        self.connection.publish(full_channel_name, message)\n\n    def listen_events(self, channel_key: str) -> Generator[M, None, None]:\n        (pubsub, full_channel_name) = self._get_pubsub_channel(self.connection, channel_key)\n        assert isinstance(pubsub, PubSub)\n        if '*' in channel_key:\n            pubsub.psubscribe(full_channel_name)\n        else:\n            pubsub.subscribe(full_channel_name)\n        for message in pubsub.listen():\n            if (event := self._deserialize_message(message, channel_key)):\n                yield event\nModel: type[M]\n@property\ndef connection(self) -> redis.Redis:\n    return redis.get_redis()\nreturn redis.get_redis()"
    },
    {
      "id": "n9",
      "type": "block",
      "statements": [
        "def publish_event(self, event: M, channel_key: str):\n    (message, full_channel_name) = self._serialize_message(event, channel_key)\n    self.connection.publish(full_channel_name, message)",
        "(message, full_channel_name) = self._serialize_message(event, channel_key)",
        "self.connection.publish(full_channel_name, message)",
        "def listen_events(self, channel_key: str) -> Generator[M, None, None]:\n    (pubsub, full_channel_name) = self._get_pubsub_channel(self.connection, channel_key)\n    assert isinstance(pubsub, PubSub)\n    if '*' in channel_key:\n        pubsub.psubscribe(full_channel_name)\n    else:\n        pubsub.subscribe(full_channel_name)\n    for message in pubsub.listen():\n        if (event := self._deserialize_message(message, channel_key)):\n            yield event",
        "(pubsub, full_channel_name) = self._get_pubsub_channel(self.connection, channel_key)",
        "assert isinstance(pubsub, PubSub)",
        "'*' In channel_key"
      ],
      "code": "def publish_event(self, event: M, channel_key: str):\n    (message, full_channel_name) = self._serialize_message(event, channel_key)\n    self.connection.publish(full_channel_name, message)\n(message, full_channel_name) = self._serialize_message(event, channel_key)\nself.connection.publish(full_channel_name, message)\ndef listen_events(self, channel_key: str) -> Generator[M, None, None]:\n    (pubsub, full_channel_name) = self._get_pubsub_channel(self.connection, channel_key)\n    assert isinstance(pubsub, PubSub)\n    if '*' in channel_key:\n        pubsub.psubscribe(full_channel_name)\n    else:\n        pubsub.subscribe(full_channel_name)\n    for message in pubsub.listen():\n        if (event := self._deserialize_message(message, channel_key)):\n            yield event\n(pubsub, full_channel_name) = self._get_pubsub_channel(self.connection, channel_key)\nassert isinstance(pubsub, PubSub)\n'*' In channel_key"
    },
    {
      "id": "n10",
      "type": "block",
      "statements": [
        "pubsub.psubscribe(full_channel_name)"
      ],
      "code": "pubsub.psubscribe(full_channel_name)"
    },
    {
      "id": "n11",
      "type": "block",
      "statements": [
        "pubsub.subscribe(full_channel_name)"
      ],
      "code": "pubsub.subscribe(full_channel_name)"
    },
    {
      "id": "n12",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n13",
      "type": "block",
      "statements": [
        "message",
        "pubsub.listen()"
      ],
      "code": "message\npubsub.listen()"
    },
    {
      "id": "n14",
      "type": "block",
      "statements": [
        "(event := self._deserialize_message(message, channel_key))"
      ],
      "code": "(event := self._deserialize_message(message, channel_key))"
    },
    {
      "id": "n15",
      "type": "block",
      "statements": [
        "class AsyncRedisEventBus(BaseRedisEventBus[M], ABC):\n    Model: type[M]\n\n    @property\n    async def connection(self) -> redis.AsyncRedis:\n        return await redis.get_redis_async()\n\n    async def publish_event(self, event: M, channel_key: str):\n        (message, full_channel_name) = self._serialize_message(event, channel_key)\n        connection = await self.connection\n        await connection.publish(full_channel_name, message)\n\n    async def listen_events(self, channel_key: str) -> AsyncGenerator[M, None]:\n        (pubsub, full_channel_name) = self._get_pubsub_channel(await self.connection, channel_key)\n        assert isinstance(pubsub, AsyncPubSub)\n        if '*' in channel_key:\n            await pubsub.psubscribe(full_channel_name)\n        else:\n            await pubsub.subscribe(full_channel_name)\n        async for message in pubsub.listen():\n            if (event := self._deserialize_message(message, channel_key)):\n                yield event\n\n    async def wait_for_event(self, channel_key: str, timeout: Optional[float]=None) -> M | None:\n        try:\n            return await asyncio.wait_for(anext(aiter(self.listen_events(channel_key))), timeout)\n        except TimeoutError:\n            return None",
        "Model: type[M]",
        "@property\nasync def connection(self) -> redis.AsyncRedis:\n    return await redis.get_redis_async()",
        "return await redis.get_redis_async()"
      ],
      "code": "class AsyncRedisEventBus(BaseRedisEventBus[M], ABC):\n    Model: type[M]\n\n    @property\n    async def connection(self) -> redis.AsyncRedis:\n        return await redis.get_redis_async()\n\n    async def publish_event(self, event: M, channel_key: str):\n        (message, full_channel_name) = self._serialize_message(event, channel_key)\n        connection = await self.connection\n        await connection.publish(full_channel_name, message)\n\n    async def listen_events(self, channel_key: str) -> AsyncGenerator[M, None]:\n        (pubsub, full_channel_name) = self._get_pubsub_channel(await self.connection, channel_key)\n        assert isinstance(pubsub, AsyncPubSub)\n        if '*' in channel_key:\n            await pubsub.psubscribe(full_channel_name)\n        else:\n            await pubsub.subscribe(full_channel_name)\n        async for message in pubsub.listen():\n            if (event := self._deserialize_message(message, channel_key)):\n                yield event\n\n    async def wait_for_event(self, channel_key: str, timeout: Optional[float]=None) -> M | None:\n        try:\n            return await asyncio.wait_for(anext(aiter(self.listen_events(channel_key))), timeout)\n        except TimeoutError:\n            return None\nModel: type[M]\n@property\nasync def connection(self) -> redis.AsyncRedis:\n    return await redis.get_redis_async()\nreturn await redis.get_redis_async()"
    },
    {
      "id": "n16",
      "type": "block",
      "statements": [
        "(yield event)"
      ],
      "code": "(yield event)"
    },
    {
      "id": "n17",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n18",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n19",
      "type": "block",
      "statements": [
        "async def publish_event(self, event: M, channel_key: str):\n    (message, full_channel_name) = self._serialize_message(event, channel_key)\n    connection = await self.connection\n    await connection.publish(full_channel_name, message)",
        "(message, full_channel_name) = self._serialize_message(event, channel_key)",
        "connection = await self.connection",
        "await connection.publish(full_channel_name, message)",
        "async def listen_events(self, channel_key: str) -> AsyncGenerator[M, None]:\n    (pubsub, full_channel_name) = self._get_pubsub_channel(await self.connection, channel_key)\n    assert isinstance(pubsub, AsyncPubSub)\n    if '*' in channel_key:\n        await pubsub.psubscribe(full_channel_name)\n    else:\n        await pubsub.subscribe(full_channel_name)\n    async for message in pubsub.listen():\n        if (event := self._deserialize_message(message, channel_key)):\n            yield event",
        "(pubsub, full_channel_name) = self._get_pubsub_channel(await self.connection, channel_key)",
        "assert isinstance(pubsub, AsyncPubSub)",
        "'*' In channel_key"
      ],
      "code": "async def publish_event(self, event: M, channel_key: str):\n    (message, full_channel_name) = self._serialize_message(event, channel_key)\n    connection = await self.connection\n    await connection.publish(full_channel_name, message)\n(message, full_channel_name) = self._serialize_message(event, channel_key)\nconnection = await self.connection\nawait connection.publish(full_channel_name, message)\nasync def listen_events(self, channel_key: str) -> AsyncGenerator[M, None]:\n    (pubsub, full_channel_name) = self._get_pubsub_channel(await self.connection, channel_key)\n    assert isinstance(pubsub, AsyncPubSub)\n    if '*' in channel_key:\n        await pubsub.psubscribe(full_channel_name)\n    else:\n        await pubsub.subscribe(full_channel_name)\n    async for message in pubsub.listen():\n        if (event := self._deserialize_message(message, channel_key)):\n            yield event\n(pubsub, full_channel_name) = self._get_pubsub_channel(await self.connection, channel_key)\nassert isinstance(pubsub, AsyncPubSub)\n'*' In channel_key"
    },
    {
      "id": "n20",
      "type": "block",
      "statements": [
        "await pubsub.psubscribe(full_channel_name)"
      ],
      "code": "await pubsub.psubscribe(full_channel_name)"
    },
    {
      "id": "n21",
      "type": "block",
      "statements": [
        "await pubsub.subscribe(full_channel_name)"
      ],
      "code": "await pubsub.subscribe(full_channel_name)"
    },
    {
      "id": "n22",
      "type": "block",
      "statements": [
        "async for message in pubsub.listen():\n    if (event := self._deserialize_message(message, channel_key)):\n        yield event",
        "(event := self._deserialize_message(message, channel_key))"
      ],
      "code": "async for message in pubsub.listen():\n    if (event := self._deserialize_message(message, channel_key)):\n        yield event\n(event := self._deserialize_message(message, channel_key))"
    },
    {
      "id": "n23",
      "type": "block",
      "statements": [
        "(yield event)"
      ],
      "code": "(yield event)"
    },
    {
      "id": "n24",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n25",
      "type": "block",
      "statements": [
        "async def wait_for_event(self, channel_key: str, timeout: Optional[float]=None) -> M | None:\n    try:\n        return await asyncio.wait_for(anext(aiter(self.listen_events(channel_key))), timeout)\n    except TimeoutError:\n        return None",
        "try:\n    return await asyncio.wait_for(anext(aiter(self.listen_events(channel_key))), timeout)\nexcept TimeoutError:\n    return None",
        "return await asyncio.wait_for(anext(aiter(self.listen_events(channel_key))), timeout)"
      ],
      "code": "async def wait_for_event(self, channel_key: str, timeout: Optional[float]=None) -> M | None:\n    try:\n        return await asyncio.wait_for(anext(aiter(self.listen_events(channel_key))), timeout)\n    except TimeoutError:\n        return None\ntry:\n    return await asyncio.wait_for(anext(aiter(self.listen_events(channel_key))), timeout)\nexcept TimeoutError:\n    return None\nreturn await asyncio.wait_for(anext(aiter(self.listen_events(channel_key))), timeout)"
    },
    {
      "id": "n26",
      "type": "block",
      "statements": [
        "return None"
      ],
      "code": "return None"
    }
  ],
  "edges": [
    {
      "source": "n0",
      "target": "n1"
    },
    {
      "source": "n17",
      "target": "n18"
    },
    {
      "source": "n14",
      "target": "n17"
    },
    {
      "source": "n23",
      "target": "n25"
    },
    {
      "source": "n21",
      "target": "n22"
    },
    {
      "source": "n22",
      "target": "n23"
    },
    {
      "source": "n13",
      "target": "n14"
    },
    {
      "source": "n19",
      "target": "n21"
    },
    {
      "source": "n13",
      "target": "n15"
    },
    {
      "source": "n16",
      "target": "n18"
    },
    {
      "source": "n18",
      "target": "n13"
    },
    {
      "source": "n19",
      "target": "n20"
    },
    {
      "source": "n4",
      "target": "n6"
    },
    {
      "source": "n4",
      "target": "n5"
    },
    {
      "source": "n12",
      "target": "n13"
    },
    {
      "source": "n24",
      "target": "n25"
    },
    {
      "source": "n9",
      "target": "n11"
    },
    {
      "source": "n14",
      "target": "n16"
    },
    {
      "source": "n9",
      "target": "n10"
    },
    {
      "source": "n10",
      "target": "n12"
    },
    {
      "source": "n11",
      "target": "n12"
    },
    {
      "source": "n22",
      "target": "n24"
    },
    {
      "source": "n20",
      "target": "n22"
    },
    {
      "source": "n0",
      "target": "n2"
    }
  ]
}