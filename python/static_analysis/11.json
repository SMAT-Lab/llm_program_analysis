{
  "nodes": [
    {
      "id": "n0",
      "type": "block",
      "statements": [
        "import functools",
        "import logging",
        "import os",
        "import time",
        "from typing import Callable, ParamSpec, Tuple, TypeVar",
        "from pydantic import BaseModel",
        "class TimingInfo(BaseModel):\n    cpu_time: float\n    wall_time: float",
        "cpu_time: float",
        "wall_time: float",
        "def _start_measurement() -> Tuple[float, float]:\n    return (time.time(), os.times()[0] + os.times()[1])",
        "return (time.time(), os.times()[0] + os.times()[1])"
      ],
      "code": "import functools\nimport logging\nimport os\nimport time\nfrom typing import Callable, ParamSpec, Tuple, TypeVar\nfrom pydantic import BaseModel\nclass TimingInfo(BaseModel):\n    cpu_time: float\n    wall_time: float\ncpu_time: float\nwall_time: float\ndef _start_measurement() -> Tuple[float, float]:\n    return (time.time(), os.times()[0] + os.times()[1])\nreturn (time.time(), os.times()[0] + os.times()[1])"
    },
    {
      "id": "n1",
      "type": "block",
      "statements": [
        "def _end_measurement(start_wall_time: float, start_cpu_time: float) -> Tuple[float, float]:\n    end_wall_time = time.time()\n    end_cpu_time = os.times()[0] + os.times()[1]\n    return (end_wall_time - start_wall_time, end_cpu_time - start_cpu_time)",
        "end_wall_time = time.time()",
        "end_cpu_time = os.times()[0] + os.times()[1]",
        "return (end_wall_time - start_wall_time, end_cpu_time - start_cpu_time)"
      ],
      "code": "def _end_measurement(start_wall_time: float, start_cpu_time: float) -> Tuple[float, float]:\n    end_wall_time = time.time()\n    end_cpu_time = os.times()[0] + os.times()[1]\n    return (end_wall_time - start_wall_time, end_cpu_time - start_cpu_time)\nend_wall_time = time.time()\nend_cpu_time = os.times()[0] + os.times()[1]\nreturn (end_wall_time - start_wall_time, end_cpu_time - start_cpu_time)"
    },
    {
      "id": "n2",
      "type": "block",
      "statements": [
        "P = ParamSpec('P')",
        "T = TypeVar('T')",
        "logger = logging.getLogger(__name__)",
        "def time_measured(func: Callable[P, T]) -> Callable[P, Tuple[TimingInfo, T]]:\n    \"\"\"\n    Decorator to measure the time taken by a function to execute.\n    \"\"\"\n\n    @functools.wraps(func)\n    def wrapper(*args: P.args, **kwargs: P.kwargs) -> Tuple[TimingInfo, T]:\n        (start_wall_time, start_cpu_time) = _start_measurement()\n        try:\n            result = func(*args, **kwargs)\n        finally:\n            (wall_duration, cpu_duration) = _end_measurement(start_wall_time, start_cpu_time)\n            timing_info = TimingInfo(cpu_time=cpu_duration, wall_time=wall_duration)\n        return (timing_info, result)\n    return wrapper",
        "'\\n    Decorator to measure the time taken by a function to execute.\\n    '",
        "@functools.wraps(func)\ndef wrapper(*args: P.args, **kwargs: P.kwargs) -> Tuple[TimingInfo, T]:\n    (start_wall_time, start_cpu_time) = _start_measurement()\n    try:\n        result = func(*args, **kwargs)\n    finally:\n        (wall_duration, cpu_duration) = _end_measurement(start_wall_time, start_cpu_time)\n        timing_info = TimingInfo(cpu_time=cpu_duration, wall_time=wall_duration)\n    return (timing_info, result)",
        "(start_wall_time, start_cpu_time) = _start_measurement()",
        "try:\n    result = func(*args, **kwargs)\nfinally:\n    (wall_duration, cpu_duration) = _end_measurement(start_wall_time, start_cpu_time)\n    timing_info = TimingInfo(cpu_time=cpu_duration, wall_time=wall_duration)",
        "result = func(*args, **kwargs)",
        "(wall_duration, cpu_duration) = _end_measurement(start_wall_time, start_cpu_time)",
        "timing_info = TimingInfo(cpu_time=cpu_duration, wall_time=wall_duration)",
        "return (timing_info, result)"
      ],
      "code": "P = ParamSpec('P')\nT = TypeVar('T')\nlogger = logging.getLogger(__name__)\ndef time_measured(func: Callable[P, T]) -> Callable[P, Tuple[TimingInfo, T]]:\n    \"\"\"\n    Decorator to measure the time taken by a function to execute.\n    \"\"\"\n\n    @functools.wraps(func)\n    def wrapper(*args: P.args, **kwargs: P.kwargs) -> Tuple[TimingInfo, T]:\n        (start_wall_time, start_cpu_time) = _start_measurement()\n        try:\n            result = func(*args, **kwargs)\n        finally:\n            (wall_duration, cpu_duration) = _end_measurement(start_wall_time, start_cpu_time)\n            timing_info = TimingInfo(cpu_time=cpu_duration, wall_time=wall_duration)\n        return (timing_info, result)\n    return wrapper\n'\\n    Decorator to measure the time taken by a function to execute.\\n    '\n@functools.wraps(func)\ndef wrapper(*args: P.args, **kwargs: P.kwargs) -> Tuple[TimingInfo, T]:\n    (start_wall_time, start_cpu_time) = _start_measurement()\n    try:\n        result = func(*args, **kwargs)\n    finally:\n        (wall_duration, cpu_duration) = _end_measurement(start_wall_time, start_cpu_time)\n        timing_info = TimingInfo(cpu_time=cpu_duration, wall_time=wall_duration)\n    return (timing_info, result)\n(start_wall_time, start_cpu_time) = _start_measurement()\ntry:\n    result = func(*args, **kwargs)\nfinally:\n    (wall_duration, cpu_duration) = _end_measurement(start_wall_time, start_cpu_time)\n    timing_info = TimingInfo(cpu_time=cpu_duration, wall_time=wall_duration)\nresult = func(*args, **kwargs)\n(wall_duration, cpu_duration) = _end_measurement(start_wall_time, start_cpu_time)\ntiming_info = TimingInfo(cpu_time=cpu_duration, wall_time=wall_duration)\nreturn (timing_info, result)"
    },
    {
      "id": "n3",
      "type": "block",
      "statements": [
        "return wrapper"
      ],
      "code": "return wrapper"
    },
    {
      "id": "n4",
      "type": "block",
      "statements": [
        "def error_logged(func: Callable[P, T]) -> Callable[P, T | None]:\n    \"\"\"\n    Decorator to suppress and log any exceptions raised by a function.\n    \"\"\"\n\n    @functools.wraps(func)\n    def wrapper(*args: P.args, **kwargs: P.kwargs) -> T | None:\n        try:\n            return func(*args, **kwargs)\n        except Exception as e:\n            logger.exception(f'Error when calling function {func.__name__} with arguments {args} {kwargs}: {e}')\n    return wrapper",
        "'\\n    Decorator to suppress and log any exceptions raised by a function.\\n    '",
        "@functools.wraps(func)\ndef wrapper(*args: P.args, **kwargs: P.kwargs) -> T | None:\n    try:\n        return func(*args, **kwargs)\n    except Exception as e:\n        logger.exception(f'Error when calling function {func.__name__} with arguments {args} {kwargs}: {e}')",
        "try:\n    return func(*args, **kwargs)\nexcept Exception as e:\n    logger.exception(f'Error when calling function {func.__name__} with arguments {args} {kwargs}: {e}')",
        "return func(*args, **kwargs)"
      ],
      "code": "def error_logged(func: Callable[P, T]) -> Callable[P, T | None]:\n    \"\"\"\n    Decorator to suppress and log any exceptions raised by a function.\n    \"\"\"\n\n    @functools.wraps(func)\n    def wrapper(*args: P.args, **kwargs: P.kwargs) -> T | None:\n        try:\n            return func(*args, **kwargs)\n        except Exception as e:\n            logger.exception(f'Error when calling function {func.__name__} with arguments {args} {kwargs}: {e}')\n    return wrapper\n'\\n    Decorator to suppress and log any exceptions raised by a function.\\n    '\n@functools.wraps(func)\ndef wrapper(*args: P.args, **kwargs: P.kwargs) -> T | None:\n    try:\n        return func(*args, **kwargs)\n    except Exception as e:\n        logger.exception(f'Error when calling function {func.__name__} with arguments {args} {kwargs}: {e}')\ntry:\n    return func(*args, **kwargs)\nexcept Exception as e:\n    logger.exception(f'Error when calling function {func.__name__} with arguments {args} {kwargs}: {e}')\nreturn func(*args, **kwargs)"
    },
    {
      "id": "n5",
      "type": "block",
      "statements": [
        "logger.exception(f'Error when calling function {func.__name__} with arguments {args} {kwargs}: {e}')",
        "return wrapper"
      ],
      "code": "logger.exception(f'Error when calling function {func.__name__} with arguments {args} {kwargs}: {e}')\nreturn wrapper"
    }
  ],
  "edges": []
}