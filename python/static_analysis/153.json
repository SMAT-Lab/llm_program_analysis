{
  "nodes": [
    {
      "id": "n0",
      "type": "block",
      "statements": [
        "from datetime import datetime, timezone",
        "from typing import Iterator",
        "import praw",
        "from pydantic import BaseModel, ConfigDict",
        "from backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema",
        "from backend.data.model import BlockSecret, SchemaField, SecretField",
        "from backend.util.mock import MockObject",
        "class RedditCredentials(BaseModel):\n    client_id: BlockSecret = SecretField(key='reddit_client_id')\n    client_secret: BlockSecret = SecretField(key='reddit_client_secret')\n    username: BlockSecret = SecretField(key='reddit_username')\n    password: BlockSecret = SecretField(key='reddit_password')\n    user_agent: str = 'AutoGPT:1.0 (by /u/autogpt)'\n    model_config = ConfigDict(title='Reddit Credentials')",
        "client_id: BlockSecret = SecretField(key='reddit_client_id')",
        "client_secret: BlockSecret = SecretField(key='reddit_client_secret')",
        "username: BlockSecret = SecretField(key='reddit_username')",
        "password: BlockSecret = SecretField(key='reddit_password')",
        "user_agent: str = 'AutoGPT:1.0 (by /u/autogpt)'",
        "model_config = ConfigDict(title='Reddit Credentials')",
        "class RedditPost(BaseModel):\n    id: str\n    subreddit: str\n    title: str\n    body: str",
        "id: str",
        "subreddit: str",
        "title: str",
        "body: str",
        "class RedditComment(BaseModel):\n    post_id: str\n    comment: str",
        "post_id: str",
        "comment: str",
        "def get_praw(creds: RedditCredentials) -> praw.Reddit:\n    client = praw.Reddit(client_id=creds.client_id.get_secret_value(), client_secret=creds.client_secret.get_secret_value(), username=creds.username.get_secret_value(), password=creds.password.get_secret_value(), user_agent=creds.user_agent)\n    me = client.user.me()\n    if not me:\n        raise ValueError('Invalid Reddit credentials.')\n    print(f'Logged in as Reddit user: {me.name}')\n    return client",
        "client = praw.Reddit(client_id=creds.client_id.get_secret_value(), client_secret=creds.client_secret.get_secret_value(), username=creds.username.get_secret_value(), password=creds.password.get_secret_value(), user_agent=creds.user_agent)",
        "me = client.user.me()",
        "not me"
      ],
      "code": "from datetime import datetime, timezone\nfrom typing import Iterator\nimport praw\nfrom pydantic import BaseModel, ConfigDict\nfrom backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema\nfrom backend.data.model import BlockSecret, SchemaField, SecretField\nfrom backend.util.mock import MockObject\nclass RedditCredentials(BaseModel):\n    client_id: BlockSecret = SecretField(key='reddit_client_id')\n    client_secret: BlockSecret = SecretField(key='reddit_client_secret')\n    username: BlockSecret = SecretField(key='reddit_username')\n    password: BlockSecret = SecretField(key='reddit_password')\n    user_agent: str = 'AutoGPT:1.0 (by /u/autogpt)'\n    model_config = ConfigDict(title='Reddit Credentials')\nclient_id: BlockSecret = SecretField(key='reddit_client_id')\nclient_secret: BlockSecret = SecretField(key='reddit_client_secret')\nusername: BlockSecret = SecretField(key='reddit_username')\npassword: BlockSecret = SecretField(key='reddit_password')\nuser_agent: str = 'AutoGPT:1.0 (by /u/autogpt)'\nmodel_config = ConfigDict(title='Reddit Credentials')\nclass RedditPost(BaseModel):\n    id: str\n    subreddit: str\n    title: str\n    body: str\nid: str\nsubreddit: str\ntitle: str\nbody: str\nclass RedditComment(BaseModel):\n    post_id: str\n    comment: str\npost_id: str\ncomment: str\ndef get_praw(creds: RedditCredentials) -> praw.Reddit:\n    client = praw.Reddit(client_id=creds.client_id.get_secret_value(), client_secret=creds.client_secret.get_secret_value(), username=creds.username.get_secret_value(), password=creds.password.get_secret_value(), user_agent=creds.user_agent)\n    me = client.user.me()\n    if not me:\n        raise ValueError('Invalid Reddit credentials.')\n    print(f'Logged in as Reddit user: {me.name}')\n    return client\nclient = praw.Reddit(client_id=creds.client_id.get_secret_value(), client_secret=creds.client_secret.get_secret_value(), username=creds.username.get_secret_value(), password=creds.password.get_secret_value(), user_agent=creds.user_agent)\nme = client.user.me()\nnot me"
    },
    {
      "id": "n1",
      "type": "block",
      "statements": [
        "raise ValueError('Invalid Reddit credentials.')"
      ],
      "code": "raise ValueError('Invalid Reddit credentials.')"
    },
    {
      "id": "n2",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n3",
      "type": "block",
      "statements": [
        "print(f'Logged in as Reddit user: {me.name}')",
        "return client"
      ],
      "code": "print(f'Logged in as Reddit user: {me.name}')\nreturn client"
    },
    {
      "id": "n4",
      "type": "block",
      "statements": [
        "class GetRedditPostsBlock(Block):\n\n    class Input(BlockSchema):\n        subreddit: str = SchemaField(description='Subreddit name')\n        creds: RedditCredentials = SchemaField(description='Reddit credentials', default=RedditCredentials())\n        last_minutes: int | None = SchemaField(description='Post time to stop minutes ago while fetching posts', default=None)\n        last_post: str | None = SchemaField(description='Post ID to stop when reached while fetching posts', default=None)\n        post_limit: int | None = SchemaField(description='Number of posts to fetch', default=10)\n\n    class Output(BlockSchema):\n        post: RedditPost = SchemaField(description='Reddit post')\n\n    def __init__(self):\n        super().__init__(disabled=True, id='c6731acb-4285-4ee1-bc9b-03d0766c370f', description='This block fetches Reddit posts from a defined subreddit name.', categories={BlockCategory.SOCIAL}, input_schema=GetRedditPostsBlock.Input, output_schema=GetRedditPostsBlock.Output, test_input={'creds': {'client_id': 'client_id', 'client_secret': 'client_secret', 'username': 'username', 'password': 'password', 'user_agent': 'user_agent'}, 'subreddit': 'subreddit', 'last_post': 'id3', 'post_limit': 2}, test_output=[('post', RedditPost(id='id1', subreddit='subreddit', title='title1', body='body1')), ('post', RedditPost(id='id2', subreddit='subreddit', title='title2', body='body2'))], test_mock={'get_posts': lambda _: [MockObject(id='id1', title='title1', selftext='body1'), MockObject(id='id2', title='title2', selftext='body2'), MockObject(id='id3', title='title2', selftext='body2')]})\n\n    @staticmethod\n    def get_posts(input_data: Input) -> Iterator[praw.reddit.Submission]:\n        client = get_praw(input_data.creds)\n        subreddit = client.subreddit(input_data.subreddit)\n        return subreddit.new(limit=input_data.post_limit or 10)\n\n    def run(self, input_data: Input, **kwargs) -> BlockOutput:\n        current_time = datetime.now(tz=timezone.utc)\n        for post in self.get_posts(input_data):\n            if input_data.last_minutes:\n                post_datetime = datetime.fromtimestamp(post.created_utc, tz=timezone.utc)\n                time_difference = current_time - post_datetime\n                if time_difference.total_seconds() / 60 > input_data.last_minutes:\n                    continue\n            if input_data.last_post and post.id == input_data.last_post:\n                break\n            yield ('post', RedditPost(id=post.id, subreddit=input_data.subreddit, title=post.title, body=post.selftext))",
        "class Input(BlockSchema):\n    subreddit: str = SchemaField(description='Subreddit name')\n    creds: RedditCredentials = SchemaField(description='Reddit credentials', default=RedditCredentials())\n    last_minutes: int | None = SchemaField(description='Post time to stop minutes ago while fetching posts', default=None)\n    last_post: str | None = SchemaField(description='Post ID to stop when reached while fetching posts', default=None)\n    post_limit: int | None = SchemaField(description='Number of posts to fetch', default=10)",
        "subreddit: str = SchemaField(description='Subreddit name')",
        "creds: RedditCredentials = SchemaField(description='Reddit credentials', default=RedditCredentials())",
        "last_minutes: int | None = SchemaField(description='Post time to stop minutes ago while fetching posts', default=None)",
        "last_post: str | None = SchemaField(description='Post ID to stop when reached while fetching posts', default=None)",
        "post_limit: int | None = SchemaField(description='Number of posts to fetch', default=10)",
        "class Output(BlockSchema):\n    post: RedditPost = SchemaField(description='Reddit post')",
        "post: RedditPost = SchemaField(description='Reddit post')",
        "def __init__(self):\n    super().__init__(disabled=True, id='c6731acb-4285-4ee1-bc9b-03d0766c370f', description='This block fetches Reddit posts from a defined subreddit name.', categories={BlockCategory.SOCIAL}, input_schema=GetRedditPostsBlock.Input, output_schema=GetRedditPostsBlock.Output, test_input={'creds': {'client_id': 'client_id', 'client_secret': 'client_secret', 'username': 'username', 'password': 'password', 'user_agent': 'user_agent'}, 'subreddit': 'subreddit', 'last_post': 'id3', 'post_limit': 2}, test_output=[('post', RedditPost(id='id1', subreddit='subreddit', title='title1', body='body1')), ('post', RedditPost(id='id2', subreddit='subreddit', title='title2', body='body2'))], test_mock={'get_posts': lambda _: [MockObject(id='id1', title='title1', selftext='body1'), MockObject(id='id2', title='title2', selftext='body2'), MockObject(id='id3', title='title2', selftext='body2')]})",
        "super().__init__()",
        "@staticmethod\ndef get_posts(input_data: Input) -> Iterator[praw.reddit.Submission]:\n    client = get_praw(input_data.creds)\n    subreddit = client.subreddit(input_data.subreddit)\n    return subreddit.new(limit=input_data.post_limit or 10)",
        "client = get_praw(input_data.creds)",
        "subreddit = client.subreddit(input_data.subreddit)",
        "return subreddit.new(limit=input_data.post_limit or 10)"
      ],
      "code": "class GetRedditPostsBlock(Block):\n\n    class Input(BlockSchema):\n        subreddit: str = SchemaField(description='Subreddit name')\n        creds: RedditCredentials = SchemaField(description='Reddit credentials', default=RedditCredentials())\n        last_minutes: int | None = SchemaField(description='Post time to stop minutes ago while fetching posts', default=None)\n        last_post: str | None = SchemaField(description='Post ID to stop when reached while fetching posts', default=None)\n        post_limit: int | None = SchemaField(description='Number of posts to fetch', default=10)\n\n    class Output(BlockSchema):\n        post: RedditPost = SchemaField(description='Reddit post')\n\n    def __init__(self):\n        super().__init__(disabled=True, id='c6731acb-4285-4ee1-bc9b-03d0766c370f', description='This block fetches Reddit posts from a defined subreddit name.', categories={BlockCategory.SOCIAL}, input_schema=GetRedditPostsBlock.Input, output_schema=GetRedditPostsBlock.Output, test_input={'creds': {'client_id': 'client_id', 'client_secret': 'client_secret', 'username': 'username', 'password': 'password', 'user_agent': 'user_agent'}, 'subreddit': 'subreddit', 'last_post': 'id3', 'post_limit': 2}, test_output=[('post', RedditPost(id='id1', subreddit='subreddit', title='title1', body='body1')), ('post', RedditPost(id='id2', subreddit='subreddit', title='title2', body='body2'))], test_mock={'get_posts': lambda _: [MockObject(id='id1', title='title1', selftext='body1'), MockObject(id='id2', title='title2', selftext='body2'), MockObject(id='id3', title='title2', selftext='body2')]})\n\n    @staticmethod\n    def get_posts(input_data: Input) -> Iterator[praw.reddit.Submission]:\n        client = get_praw(input_data.creds)\n        subreddit = client.subreddit(input_data.subreddit)\n        return subreddit.new(limit=input_data.post_limit or 10)\n\n    def run(self, input_data: Input, **kwargs) -> BlockOutput:\n        current_time = datetime.now(tz=timezone.utc)\n        for post in self.get_posts(input_data):\n            if input_data.last_minutes:\n                post_datetime = datetime.fromtimestamp(post.created_utc, tz=timezone.utc)\n                time_difference = current_time - post_datetime\n                if time_difference.total_seconds() / 60 > input_data.last_minutes:\n                    continue\n            if input_data.last_post and post.id == input_data.last_post:\n                break\n            yield ('post', RedditPost(id=post.id, subreddit=input_data.subreddit, title=post.title, body=post.selftext))\nclass Input(BlockSchema):\n    subreddit: str = SchemaField(description='Subreddit name')\n    creds: RedditCredentials = SchemaField(description='Reddit credentials', default=RedditCredentials())\n    last_minutes: int | None = SchemaField(description='Post time to stop minutes ago while fetching posts', default=None)\n    last_post: str | None = SchemaField(description='Post ID to stop when reached while fetching posts', default=None)\n    post_limit: int | None = SchemaField(description='Number of posts to fetch', default=10)\nsubreddit: str = SchemaField(description='Subreddit name')\ncreds: RedditCredentials = SchemaField(description='Reddit credentials', default=RedditCredentials())\nlast_minutes: int | None = SchemaField(description='Post time to stop minutes ago while fetching posts', default=None)\nlast_post: str | None = SchemaField(description='Post ID to stop when reached while fetching posts', default=None)\npost_limit: int | None = SchemaField(description='Number of posts to fetch', default=10)\nclass Output(BlockSchema):\n    post: RedditPost = SchemaField(description='Reddit post')\npost: RedditPost = SchemaField(description='Reddit post')\ndef __init__(self):\n    super().__init__(disabled=True, id='c6731acb-4285-4ee1-bc9b-03d0766c370f', description='This block fetches Reddit posts from a defined subreddit name.', categories={BlockCategory.SOCIAL}, input_schema=GetRedditPostsBlock.Input, output_schema=GetRedditPostsBlock.Output, test_input={'creds': {'client_id': 'client_id', 'client_secret': 'client_secret', 'username': 'username', 'password': 'password', 'user_agent': 'user_agent'}, 'subreddit': 'subreddit', 'last_post': 'id3', 'post_limit': 2}, test_output=[('post', RedditPost(id='id1', subreddit='subreddit', title='title1', body='body1')), ('post', RedditPost(id='id2', subreddit='subreddit', title='title2', body='body2'))], test_mock={'get_posts': lambda _: [MockObject(id='id1', title='title1', selftext='body1'), MockObject(id='id2', title='title2', selftext='body2'), MockObject(id='id3', title='title2', selftext='body2')]})\nsuper().__init__()\n@staticmethod\ndef get_posts(input_data: Input) -> Iterator[praw.reddit.Submission]:\n    client = get_praw(input_data.creds)\n    subreddit = client.subreddit(input_data.subreddit)\n    return subreddit.new(limit=input_data.post_limit or 10)\nclient = get_praw(input_data.creds)\nsubreddit = client.subreddit(input_data.subreddit)\nreturn subreddit.new(limit=input_data.post_limit or 10)"
    },
    {
      "id": "n5",
      "type": "block",
      "statements": [
        "def run(self, input_data: Input, **kwargs) -> BlockOutput:\n    current_time = datetime.now(tz=timezone.utc)\n    for post in self.get_posts(input_data):\n        if input_data.last_minutes:\n            post_datetime = datetime.fromtimestamp(post.created_utc, tz=timezone.utc)\n            time_difference = current_time - post_datetime\n            if time_difference.total_seconds() / 60 > input_data.last_minutes:\n                continue\n        if input_data.last_post and post.id == input_data.last_post:\n            break\n        yield ('post', RedditPost(id=post.id, subreddit=input_data.subreddit, title=post.title, body=post.selftext))",
        "current_time = datetime.now(tz=timezone.utc)"
      ],
      "code": "def run(self, input_data: Input, **kwargs) -> BlockOutput:\n    current_time = datetime.now(tz=timezone.utc)\n    for post in self.get_posts(input_data):\n        if input_data.last_minutes:\n            post_datetime = datetime.fromtimestamp(post.created_utc, tz=timezone.utc)\n            time_difference = current_time - post_datetime\n            if time_difference.total_seconds() / 60 > input_data.last_minutes:\n                continue\n        if input_data.last_post and post.id == input_data.last_post:\n            break\n        yield ('post', RedditPost(id=post.id, subreddit=input_data.subreddit, title=post.title, body=post.selftext))\ncurrent_time = datetime.now(tz=timezone.utc)"
    },
    {
      "id": "n6",
      "type": "block",
      "statements": [
        "post",
        "self.get_posts(input_data)"
      ],
      "code": "post\nself.get_posts(input_data)"
    },
    {
      "id": "n7",
      "type": "block",
      "statements": [
        "input_data.last_minutes"
      ],
      "code": "input_data.last_minutes"
    },
    {
      "id": "n8",
      "type": "block",
      "statements": [
        "class PostRedditCommentBlock(Block):\n\n    class Input(BlockSchema):\n        creds: RedditCredentials = SchemaField(description='Reddit credentials', default=RedditCredentials())\n        data: RedditComment = SchemaField(description='Reddit comment')\n\n    class Output(BlockSchema):\n        comment_id: str = SchemaField(description='Posted comment ID')\n\n    def __init__(self):\n        super().__init__(id='4a92261b-701e-4ffb-8970-675fd28e261f', description='This block posts a Reddit comment on a specified Reddit post.', categories={BlockCategory.SOCIAL}, input_schema=PostRedditCommentBlock.Input, output_schema=PostRedditCommentBlock.Output, test_input={'data': {'post_id': 'id', 'comment': 'comment'}}, test_output=[('comment_id', 'dummy_comment_id')], test_mock={'reply_post': lambda creds, comment: 'dummy_comment_id'})\n\n    @staticmethod\n    def reply_post(creds: RedditCredentials, comment: RedditComment) -> str:\n        client = get_praw(creds)\n        submission = client.submission(id=comment.post_id)\n        new_comment = submission.reply(comment.comment)\n        if not new_comment:\n            raise ValueError('Failed to post comment.')\n        return new_comment.id\n\n    def run(self, input_data: Input, **kwargs) -> BlockOutput:\n        yield ('comment_id', self.reply_post(input_data.creds, input_data.data))",
        "class Input(BlockSchema):\n    creds: RedditCredentials = SchemaField(description='Reddit credentials', default=RedditCredentials())\n    data: RedditComment = SchemaField(description='Reddit comment')",
        "creds: RedditCredentials = SchemaField(description='Reddit credentials', default=RedditCredentials())",
        "data: RedditComment = SchemaField(description='Reddit comment')",
        "class Output(BlockSchema):\n    comment_id: str = SchemaField(description='Posted comment ID')",
        "comment_id: str = SchemaField(description='Posted comment ID')",
        "def __init__(self):\n    super().__init__(id='4a92261b-701e-4ffb-8970-675fd28e261f', description='This block posts a Reddit comment on a specified Reddit post.', categories={BlockCategory.SOCIAL}, input_schema=PostRedditCommentBlock.Input, output_schema=PostRedditCommentBlock.Output, test_input={'data': {'post_id': 'id', 'comment': 'comment'}}, test_output=[('comment_id', 'dummy_comment_id')], test_mock={'reply_post': lambda creds, comment: 'dummy_comment_id'})",
        "super().__init__()",
        "@staticmethod\ndef reply_post(creds: RedditCredentials, comment: RedditComment) -> str:\n    client = get_praw(creds)\n    submission = client.submission(id=comment.post_id)\n    new_comment = submission.reply(comment.comment)\n    if not new_comment:\n        raise ValueError('Failed to post comment.')\n    return new_comment.id",
        "client = get_praw(creds)",
        "submission = client.submission(id=comment.post_id)",
        "new_comment = submission.reply(comment.comment)",
        "not new_comment"
      ],
      "code": "class PostRedditCommentBlock(Block):\n\n    class Input(BlockSchema):\n        creds: RedditCredentials = SchemaField(description='Reddit credentials', default=RedditCredentials())\n        data: RedditComment = SchemaField(description='Reddit comment')\n\n    class Output(BlockSchema):\n        comment_id: str = SchemaField(description='Posted comment ID')\n\n    def __init__(self):\n        super().__init__(id='4a92261b-701e-4ffb-8970-675fd28e261f', description='This block posts a Reddit comment on a specified Reddit post.', categories={BlockCategory.SOCIAL}, input_schema=PostRedditCommentBlock.Input, output_schema=PostRedditCommentBlock.Output, test_input={'data': {'post_id': 'id', 'comment': 'comment'}}, test_output=[('comment_id', 'dummy_comment_id')], test_mock={'reply_post': lambda creds, comment: 'dummy_comment_id'})\n\n    @staticmethod\n    def reply_post(creds: RedditCredentials, comment: RedditComment) -> str:\n        client = get_praw(creds)\n        submission = client.submission(id=comment.post_id)\n        new_comment = submission.reply(comment.comment)\n        if not new_comment:\n            raise ValueError('Failed to post comment.')\n        return new_comment.id\n\n    def run(self, input_data: Input, **kwargs) -> BlockOutput:\n        yield ('comment_id', self.reply_post(input_data.creds, input_data.data))\nclass Input(BlockSchema):\n    creds: RedditCredentials = SchemaField(description='Reddit credentials', default=RedditCredentials())\n    data: RedditComment = SchemaField(description='Reddit comment')\ncreds: RedditCredentials = SchemaField(description='Reddit credentials', default=RedditCredentials())\ndata: RedditComment = SchemaField(description='Reddit comment')\nclass Output(BlockSchema):\n    comment_id: str = SchemaField(description='Posted comment ID')\ncomment_id: str = SchemaField(description='Posted comment ID')\ndef __init__(self):\n    super().__init__(id='4a92261b-701e-4ffb-8970-675fd28e261f', description='This block posts a Reddit comment on a specified Reddit post.', categories={BlockCategory.SOCIAL}, input_schema=PostRedditCommentBlock.Input, output_schema=PostRedditCommentBlock.Output, test_input={'data': {'post_id': 'id', 'comment': 'comment'}}, test_output=[('comment_id', 'dummy_comment_id')], test_mock={'reply_post': lambda creds, comment: 'dummy_comment_id'})\nsuper().__init__()\n@staticmethod\ndef reply_post(creds: RedditCredentials, comment: RedditComment) -> str:\n    client = get_praw(creds)\n    submission = client.submission(id=comment.post_id)\n    new_comment = submission.reply(comment.comment)\n    if not new_comment:\n        raise ValueError('Failed to post comment.')\n    return new_comment.id\nclient = get_praw(creds)\nsubmission = client.submission(id=comment.post_id)\nnew_comment = submission.reply(comment.comment)\nnot new_comment"
    },
    {
      "id": "n9",
      "type": "block",
      "statements": [
        "post_datetime = datetime.fromtimestamp(post.created_utc, tz=timezone.utc)",
        "time_difference = current_time - post_datetime",
        "time_difference.total_seconds() Div 60 Gt input_data.last_minutes"
      ],
      "code": "post_datetime = datetime.fromtimestamp(post.created_utc, tz=timezone.utc)\ntime_difference = current_time - post_datetime\ntime_difference.total_seconds() Div 60 Gt input_data.last_minutes"
    },
    {
      "id": "n10",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n11",
      "type": "block",
      "statements": [
        "input_data.last_post and post.id == input_data.last_post"
      ],
      "code": "input_data.last_post and post.id == input_data.last_post"
    },
    {
      "id": "n12",
      "type": "block",
      "statements": [
        "continue"
      ],
      "code": "continue"
    },
    {
      "id": "n13",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n14",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n15",
      "type": "block",
      "statements": [
        "break"
      ],
      "code": "break"
    },
    {
      "id": "n16",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n17",
      "type": "block",
      "statements": [
        "(yield ('post', RedditPost(id=post.id, subreddit=input_data.subreddit, title=post.title, body=post.selftext)))"
      ],
      "code": "(yield ('post', RedditPost(id=post.id, subreddit=input_data.subreddit, title=post.title, body=post.selftext)))"
    },
    {
      "id": "n18",
      "type": "block",
      "statements": [
        "raise ValueError('Failed to post comment.')"
      ],
      "code": "raise ValueError('Failed to post comment.')"
    },
    {
      "id": "n19",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n20",
      "type": "block",
      "statements": [
        "return new_comment.id"
      ],
      "code": "return new_comment.id"
    },
    {
      "id": "n21",
      "type": "block",
      "statements": [
        "def run(self, input_data: Input, **kwargs) -> BlockOutput:\n    yield ('comment_id', self.reply_post(input_data.creds, input_data.data))",
        "(yield ('comment_id', self.reply_post(input_data.creds, input_data.data)))"
      ],
      "code": "def run(self, input_data: Input, **kwargs) -> BlockOutput:\n    yield ('comment_id', self.reply_post(input_data.creds, input_data.data))\n(yield ('comment_id', self.reply_post(input_data.creds, input_data.data)))"
    }
  ],
  "edges": [
    {
      "source": "n6",
      "target": "n7"
    },
    {
      "source": "n0",
      "target": "n1"
    },
    {
      "source": "n11",
      "target": "n15"
    },
    {
      "source": "n14",
      "target": "n11"
    },
    {
      "source": "n10",
      "target": "n11"
    },
    {
      "source": "n7",
      "target": "n10"
    },
    {
      "source": "n2",
      "target": "n3"
    },
    {
      "source": "n13",
      "target": "n14"
    },
    {
      "source": "n9",
      "target": "n13"
    },
    {
      "source": "n16",
      "target": "n17"
    },
    {
      "source": "n19",
      "target": "n20"
    },
    {
      "source": "n12",
      "target": "n14"
    },
    {
      "source": "n17",
      "target": "n6"
    },
    {
      "source": "n11",
      "target": "n16"
    },
    {
      "source": "n8",
      "target": "n18"
    },
    {
      "source": "n7",
      "target": "n9"
    },
    {
      "source": "n5",
      "target": "n6"
    },
    {
      "source": "n18",
      "target": "n20"
    },
    {
      "source": "n8",
      "target": "n19"
    },
    {
      "source": "n1",
      "target": "n3"
    },
    {
      "source": "n6",
      "target": "n8"
    },
    {
      "source": "n9",
      "target": "n12"
    },
    {
      "source": "n0",
      "target": "n2"
    },
    {
      "source": "n15",
      "target": "n17"
    }
  ]
}