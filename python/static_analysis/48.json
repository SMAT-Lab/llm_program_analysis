{
  "nodes": [
    {
      "id": "n0",
      "type": "block",
      "statements": [
        "def match_word_pattern(pattern: str, input_string: str) -> bool:\n    \"\"\"\n    Determine if a given pattern matches a string using backtracking.\n\n    pattern: The pattern to match.\n    input_string: The string to match against the pattern.\n    return: True if the pattern matches the string, False otherwise.\n\n    >>> match_word_pattern(\"aba\", \"GraphTreesGraph\")\n    True\n\n    >>> match_word_pattern(\"xyx\", \"PythonRubyPython\")\n    True\n\n    >>> match_word_pattern(\"GG\", \"PythonJavaPython\")\n    False\n    \"\"\"\n\n    def backtrack(pattern_index: int, str_index: int) -> bool:\n        \"\"\"\n        >>> backtrack(0, 0)\n        True\n\n        >>> backtrack(0, 1)\n        True\n\n        >>> backtrack(0, 4)\n        False\n        \"\"\"\n        if pattern_index == len(pattern) and str_index == len(input_string):\n            return True\n        if pattern_index == len(pattern) or str_index == len(input_string):\n            return False\n        char = pattern[pattern_index]\n        if char in pattern_map:\n            mapped_str = pattern_map[char]\n            if input_string.startswith(mapped_str, str_index):\n                return backtrack(pattern_index + 1, str_index + len(mapped_str))\n            else:\n                return False\n        for end in range(str_index + 1, len(input_string) + 1):\n            substr = input_string[str_index:end]\n            if substr in str_map:\n                continue\n            pattern_map[char] = substr\n            str_map[substr] = char\n            if backtrack(pattern_index + 1, end):\n                return True\n            del pattern_map[char]\n            del str_map[substr]\n        return False\n    pattern_map: dict[str, str] = {}\n    str_map: dict[str, str] = {}\n    return backtrack(0, 0)",
        "'\\n    Determine if a given pattern matches a string using backtracking.\\n\\n    pattern: The pattern to match.\\n    input_string: The string to match against the pattern.\\n    return: True if the pattern matches the string, False otherwise.\\n\\n    >>> match_word_pattern(\"aba\", \"GraphTreesGraph\")\\n    True\\n\\n    >>> match_word_pattern(\"xyx\", \"PythonRubyPython\")\\n    True\\n\\n    >>> match_word_pattern(\"GG\", \"PythonJavaPython\")\\n    False\\n    '",
        "def backtrack(pattern_index: int, str_index: int) -> bool:\n    \"\"\"\n        >>> backtrack(0, 0)\n        True\n\n        >>> backtrack(0, 1)\n        True\n\n        >>> backtrack(0, 4)\n        False\n        \"\"\"\n    if pattern_index == len(pattern) and str_index == len(input_string):\n        return True\n    if pattern_index == len(pattern) or str_index == len(input_string):\n        return False\n    char = pattern[pattern_index]\n    if char in pattern_map:\n        mapped_str = pattern_map[char]\n        if input_string.startswith(mapped_str, str_index):\n            return backtrack(pattern_index + 1, str_index + len(mapped_str))\n        else:\n            return False\n    for end in range(str_index + 1, len(input_string) + 1):\n        substr = input_string[str_index:end]\n        if substr in str_map:\n            continue\n        pattern_map[char] = substr\n        str_map[substr] = char\n        if backtrack(pattern_index + 1, end):\n            return True\n        del pattern_map[char]\n        del str_map[substr]\n    return False",
        "'\\n        >>> backtrack(0, 0)\\n        True\\n\\n        >>> backtrack(0, 1)\\n        True\\n\\n        >>> backtrack(0, 4)\\n        False\\n        '",
        "pattern_index == len(pattern) and str_index == len(input_string)"
      ],
      "code": "def match_word_pattern(pattern: str, input_string: str) -> bool:\n    \"\"\"\n    Determine if a given pattern matches a string using backtracking.\n\n    pattern: The pattern to match.\n    input_string: The string to match against the pattern.\n    return: True if the pattern matches the string, False otherwise.\n\n    >>> match_word_pattern(\"aba\", \"GraphTreesGraph\")\n    True\n\n    >>> match_word_pattern(\"xyx\", \"PythonRubyPython\")\n    True\n\n    >>> match_word_pattern(\"GG\", \"PythonJavaPython\")\n    False\n    \"\"\"\n\n    def backtrack(pattern_index: int, str_index: int) -> bool:\n        \"\"\"\n        >>> backtrack(0, 0)\n        True\n\n        >>> backtrack(0, 1)\n        True\n\n        >>> backtrack(0, 4)\n        False\n        \"\"\"\n        if pattern_index == len(pattern) and str_index == len(input_string):\n            return True\n        if pattern_index == len(pattern) or str_index == len(input_string):\n            return False\n        char = pattern[pattern_index]\n        if char in pattern_map:\n            mapped_str = pattern_map[char]\n            if input_string.startswith(mapped_str, str_index):\n                return backtrack(pattern_index + 1, str_index + len(mapped_str))\n            else:\n                return False\n        for end in range(str_index + 1, len(input_string) + 1):\n            substr = input_string[str_index:end]\n            if substr in str_map:\n                continue\n            pattern_map[char] = substr\n            str_map[substr] = char\n            if backtrack(pattern_index + 1, end):\n                return True\n            del pattern_map[char]\n            del str_map[substr]\n        return False\n    pattern_map: dict[str, str] = {}\n    str_map: dict[str, str] = {}\n    return backtrack(0, 0)\n'\\n    Determine if a given pattern matches a string using backtracking.\\n\\n    pattern: The pattern to match.\\n    input_string: The string to match against the pattern.\\n    return: True if the pattern matches the string, False otherwise.\\n\\n    >>> match_word_pattern(\"aba\", \"GraphTreesGraph\")\\n    True\\n\\n    >>> match_word_pattern(\"xyx\", \"PythonRubyPython\")\\n    True\\n\\n    >>> match_word_pattern(\"GG\", \"PythonJavaPython\")\\n    False\\n    '\ndef backtrack(pattern_index: int, str_index: int) -> bool:\n    \"\"\"\n        >>> backtrack(0, 0)\n        True\n\n        >>> backtrack(0, 1)\n        True\n\n        >>> backtrack(0, 4)\n        False\n        \"\"\"\n    if pattern_index == len(pattern) and str_index == len(input_string):\n        return True\n    if pattern_index == len(pattern) or str_index == len(input_string):\n        return False\n    char = pattern[pattern_index]\n    if char in pattern_map:\n        mapped_str = pattern_map[char]\n        if input_string.startswith(mapped_str, str_index):\n            return backtrack(pattern_index + 1, str_index + len(mapped_str))\n        else:\n            return False\n    for end in range(str_index + 1, len(input_string) + 1):\n        substr = input_string[str_index:end]\n        if substr in str_map:\n            continue\n        pattern_map[char] = substr\n        str_map[substr] = char\n        if backtrack(pattern_index + 1, end):\n            return True\n        del pattern_map[char]\n        del str_map[substr]\n    return False\n'\\n        >>> backtrack(0, 0)\\n        True\\n\\n        >>> backtrack(0, 1)\\n        True\\n\\n        >>> backtrack(0, 4)\\n        False\\n        '\npattern_index == len(pattern) and str_index == len(input_string)"
    },
    {
      "id": "n1",
      "type": "block",
      "statements": [
        "return True"
      ],
      "code": "return True"
    },
    {
      "id": "n2",
      "type": "block",
      "statements": [],
      "code": "\npattern_index == len(pattern) or str_index == len(input_string)"
    },
    {
      "id": "n3",
      "type": "block",
      "statements": [
        "return False"
      ],
      "code": "return False"
    },
    {
      "id": "n4",
      "type": "block",
      "statements": [],
      "code": "\nchar = pattern[pattern_index]\nchar In pattern_map"
    },
    {
      "id": "n5",
      "type": "block",
      "statements": [
        "mapped_str = pattern_map[char]",
        "input_string.startswith(mapped_str, str_index)"
      ],
      "code": "mapped_str = pattern_map[char]\ninput_string.startswith(mapped_str, str_index)"
    },
    {
      "id": "n6",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n7",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n8",
      "type": "block",
      "statements": [
        "return backtrack(pattern_index + 1, str_index + len(mapped_str))"
      ],
      "code": "return backtrack(pattern_index + 1, str_index + len(mapped_str))"
    },
    {
      "id": "n9",
      "type": "block",
      "statements": [
        "return False"
      ],
      "code": "return False"
    },
    {
      "id": "n10",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n11",
      "type": "block",
      "statements": [
        "end",
        "range(str_index Add 1, len(input_string) Add 1)"
      ],
      "code": "end\nrange(str_index Add 1, len(input_string) Add 1)"
    },
    {
      "id": "n12",
      "type": "block",
      "statements": [
        "substr = input_string[str_index:end]",
        "substr In str_map"
      ],
      "code": "substr = input_string[str_index:end]\nsubstr In str_map"
    },
    {
      "id": "n13",
      "type": "block",
      "statements": [
        "return False"
      ],
      "code": "return False"
    },
    {
      "id": "n14",
      "type": "block",
      "statements": [
        "continue"
      ],
      "code": "continue"
    },
    {
      "id": "n15",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n16",
      "type": "block",
      "statements": [
        "pattern_map[char] = substr",
        "str_map[substr] = char",
        "backtrack(pattern_index Add 1, end)"
      ],
      "code": "pattern_map[char] = substr\nstr_map[substr] = char\nbacktrack(pattern_index Add 1, end)"
    },
    {
      "id": "n17",
      "type": "block",
      "statements": [
        "return True"
      ],
      "code": "return True"
    },
    {
      "id": "n18",
      "type": "block",
      "statements": [],
      "code": "\ndel pattern_map[char]\ndel str_map[substr]"
    },
    {
      "id": "n19",
      "type": "block",
      "statements": [
        "pattern_map: dict[str, str] = {}",
        "str_map: dict[str, str] = {}",
        "return backtrack(0, 0)"
      ],
      "code": "pattern_map: dict[str, str] = {}\nstr_map: dict[str, str] = {}\nreturn backtrack(0, 0)"
    },
    {
      "id": "n20",
      "type": "block",
      "statements": [
        "__name__ Eq '__main__'"
      ],
      "code": "__name__ Eq '__main__'"
    },
    {
      "id": "n21",
      "type": "block",
      "statements": [
        "import doctest",
        "doctest.testmod()"
      ],
      "code": "import doctest\ndoctest.testmod()"
    },
    {
      "id": "n22",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n23",
      "type": "block",
      "statements": [],
      "code": ""
    }
  ],
  "edges": [
    {
      "source": "n6",
      "target": "n7"
    },
    {
      "source": "n5",
      "target": "n9"
    },
    {
      "source": "n0",
      "target": "n1"
    },
    {
      "source": "n7",
      "target": "n11"
    },
    {
      "source": "n22",
      "target": "n23"
    },
    {
      "source": "n2",
      "target": "n3"
    },
    {
      "source": "n2",
      "target": "n4"
    },
    {
      "source": "n16",
      "target": "n17"
    },
    {
      "source": "n16",
      "target": "n18"
    },
    {
      "source": "n4",
      "target": "n5"
    },
    {
      "source": "n4",
      "target": "n6"
    },
    {
      "source": "n21",
      "target": "n23"
    },
    {
      "source": "n15",
      "target": "n16"
    },
    {
      "source": "n12",
      "target": "n14"
    },
    {
      "source": "n20",
      "target": "n21"
    },
    {
      "source": "n14",
      "target": "n16"
    },
    {
      "source": "n12",
      "target": "n15"
    },
    {
      "source": "n18",
      "target": "n11"
    },
    {
      "source": "n11",
      "target": "n12"
    },
    {
      "source": "n10",
      "target": "n7"
    },
    {
      "source": "n5",
      "target": "n8"
    },
    {
      "source": "n20",
      "target": "n22"
    },
    {
      "source": "n11",
      "target": "n13"
    },
    {
      "source": "n0",
      "target": "n2"
    }
  ]
}