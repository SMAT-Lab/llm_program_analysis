{
  "nodes": [
    {
      "id": "n0",
      "type": "block",
      "statements": [
        "class Node(object):\n\n    def __init__(self, results):\n        self.results = results\n        self.next = next",
        "def __init__(self, results):\n    self.results = results\n    self.next = next",
        "self.results = results",
        "self.next = next",
        "class LinkedList(object):\n\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def move_to_front(self, node):\n        pass\n\n    def append_to_front(self, node):\n        pass\n\n    def remove_from_tail(self):\n        pass",
        "def __init__(self):\n    self.head = None\n    self.tail = None",
        "self.head = None",
        "self.tail = None",
        "def move_to_front(self, node):\n    pass",
        "pass",
        "def append_to_front(self, node):\n    pass",
        "pass",
        "def remove_from_tail(self):\n    pass",
        "pass",
        "class Cache(object):\n\n    def __init__(self, MAX_SIZE):\n        self.MAX_SIZE = MAX_SIZE\n        self.size = 0\n        self.lookup = {}\n        self.linked_list = LinkedList()\n\n    def get(self, query):\n        \"\"\"Get the stored query result from the cache.\n\n        Accessing a node updates its position to the front of the LRU list.\n        \"\"\"\n        node = self.lookup.get(query)\n        if node is None:\n            return None\n        self.linked_list.move_to_front(node)\n        return node.results\n\n    def set(self, results, query):\n        \"\"\"Set the result for the given query key in the cache.\n\n        When updating an entry, updates its position to the front of the LRU list.\n        If the entry is new and the cache is at capacity, removes the oldest entry\n        before the new entry is added.\n        \"\"\"\n        node = self.lookup.get(query)\n        if node is not None:\n            node.results = results\n            self.linked_list.move_to_front(node)\n        else:\n            if self.size == self.MAX_SIZE:\n                self.lookup.pop(self.linked_list.tail.query, None)\n                self.linked_list.remove_from_tail()\n            else:\n                self.size += 1\n            new_node = Node(results)\n            self.linked_list.append_to_front(new_node)\n            self.lookup[query] = new_node",
        "def __init__(self, MAX_SIZE):\n    self.MAX_SIZE = MAX_SIZE\n    self.size = 0\n    self.lookup = {}\n    self.linked_list = LinkedList()",
        "self.MAX_SIZE = MAX_SIZE",
        "self.size = 0",
        "self.lookup = {}",
        "self.linked_list = LinkedList()",
        "def get(self, query):\n    \"\"\"Get the stored query result from the cache.\n\n        Accessing a node updates its position to the front of the LRU list.\n        \"\"\"\n    node = self.lookup.get(query)\n    if node is None:\n        return None\n    self.linked_list.move_to_front(node)\n    return node.results",
        "'Get the stored query result from the cache.\\n\\n        Accessing a node updates its position to the front of the LRU list.\\n        '",
        "node = self.lookup.get(query)",
        "node Is None"
      ],
      "code": "class Node(object):\n\n    def __init__(self, results):\n        self.results = results\n        self.next = next\ndef __init__(self, results):\n    self.results = results\n    self.next = next\nself.results = results\nself.next = next\nclass LinkedList(object):\n\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def move_to_front(self, node):\n        pass\n\n    def append_to_front(self, node):\n        pass\n\n    def remove_from_tail(self):\n        pass\ndef __init__(self):\n    self.head = None\n    self.tail = None\nself.head = None\nself.tail = None\ndef move_to_front(self, node):\n    pass\npass\ndef append_to_front(self, node):\n    pass\npass\ndef remove_from_tail(self):\n    pass\npass\nclass Cache(object):\n\n    def __init__(self, MAX_SIZE):\n        self.MAX_SIZE = MAX_SIZE\n        self.size = 0\n        self.lookup = {}\n        self.linked_list = LinkedList()\n\n    def get(self, query):\n        \"\"\"Get the stored query result from the cache.\n\n        Accessing a node updates its position to the front of the LRU list.\n        \"\"\"\n        node = self.lookup.get(query)\n        if node is None:\n            return None\n        self.linked_list.move_to_front(node)\n        return node.results\n\n    def set(self, results, query):\n        \"\"\"Set the result for the given query key in the cache.\n\n        When updating an entry, updates its position to the front of the LRU list.\n        If the entry is new and the cache is at capacity, removes the oldest entry\n        before the new entry is added.\n        \"\"\"\n        node = self.lookup.get(query)\n        if node is not None:\n            node.results = results\n            self.linked_list.move_to_front(node)\n        else:\n            if self.size == self.MAX_SIZE:\n                self.lookup.pop(self.linked_list.tail.query, None)\n                self.linked_list.remove_from_tail()\n            else:\n                self.size += 1\n            new_node = Node(results)\n            self.linked_list.append_to_front(new_node)\n            self.lookup[query] = new_node\ndef __init__(self, MAX_SIZE):\n    self.MAX_SIZE = MAX_SIZE\n    self.size = 0\n    self.lookup = {}\n    self.linked_list = LinkedList()\nself.MAX_SIZE = MAX_SIZE\nself.size = 0\nself.lookup = {}\nself.linked_list = LinkedList()\ndef get(self, query):\n    \"\"\"Get the stored query result from the cache.\n\n        Accessing a node updates its position to the front of the LRU list.\n        \"\"\"\n    node = self.lookup.get(query)\n    if node is None:\n        return None\n    self.linked_list.move_to_front(node)\n    return node.results\n'Get the stored query result from the cache.\\n\\n        Accessing a node updates its position to the front of the LRU list.\\n        '\nnode = self.lookup.get(query)\nnode Is None"
    },
    {
      "id": "n1",
      "type": "block",
      "statements": [
        "return None"
      ],
      "code": "return None"
    },
    {
      "id": "n2",
      "type": "block",
      "statements": [],
      "code": "\nself.linked_list.move_to_front(node)\nreturn node.results"
    },
    {
      "id": "n3",
      "type": "block",
      "statements": [
        "def set(self, results, query):\n    \"\"\"Set the result for the given query key in the cache.\n\n        When updating an entry, updates its position to the front of the LRU list.\n        If the entry is new and the cache is at capacity, removes the oldest entry\n        before the new entry is added.\n        \"\"\"\n    node = self.lookup.get(query)\n    if node is not None:\n        node.results = results\n        self.linked_list.move_to_front(node)\n    else:\n        if self.size == self.MAX_SIZE:\n            self.lookup.pop(self.linked_list.tail.query, None)\n            self.linked_list.remove_from_tail()\n        else:\n            self.size += 1\n        new_node = Node(results)\n        self.linked_list.append_to_front(new_node)\n        self.lookup[query] = new_node",
        "'Set the result for the given query key in the cache.\\n\\n        When updating an entry, updates its position to the front of the LRU list.\\n        If the entry is new and the cache is at capacity, removes the oldest entry\\n        before the new entry is added.\\n        '",
        "node = self.lookup.get(query)",
        "node IsNot None"
      ],
      "code": "def set(self, results, query):\n    \"\"\"Set the result for the given query key in the cache.\n\n        When updating an entry, updates its position to the front of the LRU list.\n        If the entry is new and the cache is at capacity, removes the oldest entry\n        before the new entry is added.\n        \"\"\"\n    node = self.lookup.get(query)\n    if node is not None:\n        node.results = results\n        self.linked_list.move_to_front(node)\n    else:\n        if self.size == self.MAX_SIZE:\n            self.lookup.pop(self.linked_list.tail.query, None)\n            self.linked_list.remove_from_tail()\n        else:\n            self.size += 1\n        new_node = Node(results)\n        self.linked_list.append_to_front(new_node)\n        self.lookup[query] = new_node\n'Set the result for the given query key in the cache.\\n\\n        When updating an entry, updates its position to the front of the LRU list.\\n        If the entry is new and the cache is at capacity, removes the oldest entry\\n        before the new entry is added.\\n        '\nnode = self.lookup.get(query)\nnode IsNot None"
    },
    {
      "id": "n4",
      "type": "block",
      "statements": [
        "node.results = results",
        "self.linked_list.move_to_front(node)"
      ],
      "code": "node.results = results\nself.linked_list.move_to_front(node)"
    },
    {
      "id": "n5",
      "type": "block",
      "statements": [
        "self.size Eq self.MAX_SIZE"
      ],
      "code": "self.size Eq self.MAX_SIZE"
    },
    {
      "id": "n6",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n7",
      "type": "block",
      "statements": [
        "self.lookup.pop(self.linked_list.tail.query, None)",
        "self.linked_list.remove_from_tail()"
      ],
      "code": "self.lookup.pop(self.linked_list.tail.query, None)\nself.linked_list.remove_from_tail()"
    },
    {
      "id": "n8",
      "type": "block",
      "statements": [
        "self.size += 1"
      ],
      "code": "self.size += 1"
    },
    {
      "id": "n9",
      "type": "block",
      "statements": [
        "new_node = Node(results)",
        "self.linked_list.append_to_front(new_node)",
        "self.lookup[query] = new_node"
      ],
      "code": "new_node = Node(results)\nself.linked_list.append_to_front(new_node)\nself.lookup[query] = new_node"
    }
  ],
  "edges": [
    {
      "source": "n5",
      "target": "n8"
    },
    {
      "source": "n0",
      "target": "n1"
    },
    {
      "source": "n3",
      "target": "n4"
    },
    {
      "source": "n8",
      "target": "n9"
    },
    {
      "source": "n3",
      "target": "n5"
    },
    {
      "source": "n9",
      "target": "n6"
    },
    {
      "source": "n4",
      "target": "n6"
    },
    {
      "source": "n5",
      "target": "n7"
    },
    {
      "source": "n0",
      "target": "n2"
    },
    {
      "source": "n7",
      "target": "n9"
    }
  ]
}