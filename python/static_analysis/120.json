{
  "nodes": [
    {
      "id": "n0",
      "type": "block",
      "statements": [
        "import inspect",
        "from abc import ABC, abstractmethod",
        "from enum import Enum",
        "from typing import Any, ClassVar, Generator, Generic, Optional, Type, TypeVar, cast, get_origin",
        "import jsonref",
        "import jsonschema",
        "from prisma.models import AgentBlock",
        "from pydantic import BaseModel",
        "from backend.util import json",
        "from backend.util.settings import Config",
        "from .model import CREDENTIALS_FIELD_NAME, ContributorDetails, Credentials, CredentialsMetaInput",
        "app_config = Config()",
        "BlockData = tuple[str, Any]",
        "BlockInput = dict[str, Any]",
        "BlockOutput = Generator[BlockData, None, None]",
        "CompletedBlockOutput = dict[str, list[Any]]",
        "class BlockType(Enum):\n    STANDARD = 'Standard'\n    INPUT = 'Input'\n    OUTPUT = 'Output'\n    NOTE = 'Note'\n    WEBHOOK = 'Webhook'\n    WEBHOOK_MANUAL = 'Webhook (manual)'\n    AGENT = 'Agent'",
        "STANDARD = 'Standard'",
        "INPUT = 'Input'",
        "OUTPUT = 'Output'",
        "NOTE = 'Note'",
        "WEBHOOK = 'Webhook'",
        "WEBHOOK_MANUAL = 'Webhook (manual)'",
        "AGENT = 'Agent'",
        "class BlockCategory(Enum):\n    AI = 'Block that leverages AI to perform a task.'\n    SOCIAL = 'Block that interacts with social media platforms.'\n    TEXT = 'Block that processes text data.'\n    SEARCH = 'Block that searches or extracts information from the internet.'\n    BASIC = 'Block that performs basic operations.'\n    INPUT = 'Block that interacts with input of the graph.'\n    OUTPUT = 'Block that interacts with output of the graph.'\n    LOGIC = 'Programming logic to control the flow of your agent'\n    COMMUNICATION = 'Block that interacts with communication platforms.'\n    DEVELOPER_TOOLS = 'Developer tools such as GitHub blocks.'\n    DATA = 'Block that interacts with structured data.'\n    HARDWARE = 'Block that interacts with hardware.'\n    AGENT = 'Block that interacts with other agents.'\n    CRM = 'Block that interacts with CRM services.'\n\n    def dict(self) -> dict[str, str]:\n        return {'category': self.name, 'description': self.value}",
        "AI = 'Block that leverages AI to perform a task.'",
        "SOCIAL = 'Block that interacts with social media platforms.'",
        "TEXT = 'Block that processes text data.'",
        "SEARCH = 'Block that searches or extracts information from the internet.'",
        "BASIC = 'Block that performs basic operations.'",
        "INPUT = 'Block that interacts with input of the graph.'",
        "OUTPUT = 'Block that interacts with output of the graph.'",
        "LOGIC = 'Programming logic to control the flow of your agent'",
        "COMMUNICATION = 'Block that interacts with communication platforms.'",
        "DEVELOPER_TOOLS = 'Developer tools such as GitHub blocks.'",
        "DATA = 'Block that interacts with structured data.'",
        "HARDWARE = 'Block that interacts with hardware.'",
        "AGENT = 'Block that interacts with other agents.'",
        "CRM = 'Block that interacts with CRM services.'",
        "def dict(self) -> dict[str, str]:\n    return {'category': self.name, 'description': self.value}",
        "return {'category': self.name, 'description': self.value}"
      ],
      "code": "import inspect\nfrom abc import ABC, abstractmethod\nfrom enum import Enum\nfrom typing import Any, ClassVar, Generator, Generic, Optional, Type, TypeVar, cast, get_origin\nimport jsonref\nimport jsonschema\nfrom prisma.models import AgentBlock\nfrom pydantic import BaseModel\nfrom backend.util import json\nfrom backend.util.settings import Config\nfrom .model import CREDENTIALS_FIELD_NAME, ContributorDetails, Credentials, CredentialsMetaInput\napp_config = Config()\nBlockData = tuple[str, Any]\nBlockInput = dict[str, Any]\nBlockOutput = Generator[BlockData, None, None]\nCompletedBlockOutput = dict[str, list[Any]]\nclass BlockType(Enum):\n    STANDARD = 'Standard'\n    INPUT = 'Input'\n    OUTPUT = 'Output'\n    NOTE = 'Note'\n    WEBHOOK = 'Webhook'\n    WEBHOOK_MANUAL = 'Webhook (manual)'\n    AGENT = 'Agent'\nSTANDARD = 'Standard'\nINPUT = 'Input'\nOUTPUT = 'Output'\nNOTE = 'Note'\nWEBHOOK = 'Webhook'\nWEBHOOK_MANUAL = 'Webhook (manual)'\nAGENT = 'Agent'\nclass BlockCategory(Enum):\n    AI = 'Block that leverages AI to perform a task.'\n    SOCIAL = 'Block that interacts with social media platforms.'\n    TEXT = 'Block that processes text data.'\n    SEARCH = 'Block that searches or extracts information from the internet.'\n    BASIC = 'Block that performs basic operations.'\n    INPUT = 'Block that interacts with input of the graph.'\n    OUTPUT = 'Block that interacts with output of the graph.'\n    LOGIC = 'Programming logic to control the flow of your agent'\n    COMMUNICATION = 'Block that interacts with communication platforms.'\n    DEVELOPER_TOOLS = 'Developer tools such as GitHub blocks.'\n    DATA = 'Block that interacts with structured data.'\n    HARDWARE = 'Block that interacts with hardware.'\n    AGENT = 'Block that interacts with other agents.'\n    CRM = 'Block that interacts with CRM services.'\n\n    def dict(self) -> dict[str, str]:\n        return {'category': self.name, 'description': self.value}\nAI = 'Block that leverages AI to perform a task.'\nSOCIAL = 'Block that interacts with social media platforms.'\nTEXT = 'Block that processes text data.'\nSEARCH = 'Block that searches or extracts information from the internet.'\nBASIC = 'Block that performs basic operations.'\nINPUT = 'Block that interacts with input of the graph.'\nOUTPUT = 'Block that interacts with output of the graph.'\nLOGIC = 'Programming logic to control the flow of your agent'\nCOMMUNICATION = 'Block that interacts with communication platforms.'\nDEVELOPER_TOOLS = 'Developer tools such as GitHub blocks.'\nDATA = 'Block that interacts with structured data.'\nHARDWARE = 'Block that interacts with hardware.'\nAGENT = 'Block that interacts with other agents.'\nCRM = 'Block that interacts with CRM services.'\ndef dict(self) -> dict[str, str]:\n    return {'category': self.name, 'description': self.value}\nreturn {'category': self.name, 'description': self.value}"
    },
    {
      "id": "n1",
      "type": "block",
      "statements": [
        "class BlockSchema(BaseModel):\n    cached_jsonschema: ClassVar[dict[str, Any]]\n\n    @classmethod\n    def jsonschema(cls) -> dict[str, Any]:\n        if cls.cached_jsonschema:\n            return cls.cached_jsonschema\n        model = jsonref.replace_refs(cls.model_json_schema(), merge_props=True)\n\n        def ref_to_dict(obj):\n            if isinstance(obj, dict):\n                keys = {'allOf', 'anyOf', 'oneOf'}\n                one_key = next((k for k in keys if k in obj and len(obj[k]) == 1), None)\n                if one_key:\n                    obj.update(obj[one_key][0])\n                return {key: ref_to_dict(value) for (key, value) in obj.items() if not key.startswith('$') and key != one_key}\n            elif isinstance(obj, list):\n                return [ref_to_dict(item) for item in obj]\n            return obj\n        cls.cached_jsonschema = cast(dict[str, Any], ref_to_dict(model))\n        for field in cls.cached_jsonschema.get('properties', {}).values():\n            if isinstance(field, dict) and 'advanced' not in field:\n                field['advanced'] = True\n        return cls.cached_jsonschema\n\n    @classmethod\n    def validate_data(cls, data: BlockInput) -> str | None:\n        return json.validate_with_jsonschema(schema=cls.jsonschema(), data=data)\n\n    @classmethod\n    def validate_field(cls, field_name: str, data: BlockInput) -> str | None:\n        \"\"\"\n        Validate the data against a specific property (one of the input/output name).\n        Returns the validation error message if the data does not match the schema.\n        \"\"\"\n        model_schema = cls.jsonschema().get('properties', {})\n        if not model_schema:\n            return f'Invalid model schema {cls}'\n        property_schema = model_schema.get(field_name)\n        if not property_schema:\n            return f'Invalid property name {field_name}'\n        try:\n            jsonschema.validate(json.to_dict(data), property_schema)\n            return None\n        except jsonschema.ValidationError as e:\n            return str(e)\n\n    @classmethod\n    def get_fields(cls) -> set[str]:\n        return set(cls.model_fields.keys())\n\n    @classmethod\n    def get_required_fields(cls) -> set[str]:\n        return {field for (field, field_info) in cls.model_fields.items() if field_info.is_required()}\n\n    @classmethod\n    def __pydantic_init_subclass__(cls, **kwargs):\n        \"\"\"Validates the schema definition. Rules:\n        - Only one `CredentialsMetaInput` field may be present.\n          - This field MUST be called `credentials`.\n        - A field that is called `credentials` MUST be a `CredentialsMetaInput`.\n        \"\"\"\n        super().__pydantic_init_subclass__(**kwargs)\n        cls.cached_jsonschema = {}\n        credentials_fields = [field_name for (field_name, info) in cls.model_fields.items() if inspect.isclass(info.annotation) and issubclass(get_origin(info.annotation) or info.annotation, CredentialsMetaInput)]\n        if len(credentials_fields) > 1:\n            raise ValueError(f'{cls.__qualname__} can only have one CredentialsMetaInput field')\n        elif len(credentials_fields) == 1 and credentials_fields[0] != CREDENTIALS_FIELD_NAME:\n            raise ValueError(f\"CredentialsMetaInput field on {cls.__qualname__} must be named 'credentials'\")\n        elif len(credentials_fields) == 0 and CREDENTIALS_FIELD_NAME in cls.model_fields.keys():\n            raise TypeError(f\"Field 'credentials' on {cls.__qualname__} must be of type {CredentialsMetaInput.__name__}\")\n        if (credentials_field := cls.model_fields.get(CREDENTIALS_FIELD_NAME)):\n            credentials_input_type = cast(CredentialsMetaInput, credentials_field.annotation)\n            credentials_input_type.validate_credentials_field_schema(cls)",
        "cached_jsonschema: ClassVar[dict[str, Any]]",
        "@classmethod\ndef jsonschema(cls) -> dict[str, Any]:\n    if cls.cached_jsonschema:\n        return cls.cached_jsonschema\n    model = jsonref.replace_refs(cls.model_json_schema(), merge_props=True)\n\n    def ref_to_dict(obj):\n        if isinstance(obj, dict):\n            keys = {'allOf', 'anyOf', 'oneOf'}\n            one_key = next((k for k in keys if k in obj and len(obj[k]) == 1), None)\n            if one_key:\n                obj.update(obj[one_key][0])\n            return {key: ref_to_dict(value) for (key, value) in obj.items() if not key.startswith('$') and key != one_key}\n        elif isinstance(obj, list):\n            return [ref_to_dict(item) for item in obj]\n        return obj\n    cls.cached_jsonschema = cast(dict[str, Any], ref_to_dict(model))\n    for field in cls.cached_jsonschema.get('properties', {}).values():\n        if isinstance(field, dict) and 'advanced' not in field:\n            field['advanced'] = True\n    return cls.cached_jsonschema",
        "cls.cached_jsonschema"
      ],
      "code": "class BlockSchema(BaseModel):\n    cached_jsonschema: ClassVar[dict[str, Any]]\n\n    @classmethod\n    def jsonschema(cls) -> dict[str, Any]:\n        if cls.cached_jsonschema:\n            return cls.cached_jsonschema\n        model = jsonref.replace_refs(cls.model_json_schema(), merge_props=True)\n\n        def ref_to_dict(obj):\n            if isinstance(obj, dict):\n                keys = {'allOf', 'anyOf', 'oneOf'}\n                one_key = next((k for k in keys if k in obj and len(obj[k]) == 1), None)\n                if one_key:\n                    obj.update(obj[one_key][0])\n                return {key: ref_to_dict(value) for (key, value) in obj.items() if not key.startswith('$') and key != one_key}\n            elif isinstance(obj, list):\n                return [ref_to_dict(item) for item in obj]\n            return obj\n        cls.cached_jsonschema = cast(dict[str, Any], ref_to_dict(model))\n        for field in cls.cached_jsonschema.get('properties', {}).values():\n            if isinstance(field, dict) and 'advanced' not in field:\n                field['advanced'] = True\n        return cls.cached_jsonschema\n\n    @classmethod\n    def validate_data(cls, data: BlockInput) -> str | None:\n        return json.validate_with_jsonschema(schema=cls.jsonschema(), data=data)\n\n    @classmethod\n    def validate_field(cls, field_name: str, data: BlockInput) -> str | None:\n        \"\"\"\n        Validate the data against a specific property (one of the input/output name).\n        Returns the validation error message if the data does not match the schema.\n        \"\"\"\n        model_schema = cls.jsonschema().get('properties', {})\n        if not model_schema:\n            return f'Invalid model schema {cls}'\n        property_schema = model_schema.get(field_name)\n        if not property_schema:\n            return f'Invalid property name {field_name}'\n        try:\n            jsonschema.validate(json.to_dict(data), property_schema)\n            return None\n        except jsonschema.ValidationError as e:\n            return str(e)\n\n    @classmethod\n    def get_fields(cls) -> set[str]:\n        return set(cls.model_fields.keys())\n\n    @classmethod\n    def get_required_fields(cls) -> set[str]:\n        return {field for (field, field_info) in cls.model_fields.items() if field_info.is_required()}\n\n    @classmethod\n    def __pydantic_init_subclass__(cls, **kwargs):\n        \"\"\"Validates the schema definition. Rules:\n        - Only one `CredentialsMetaInput` field may be present.\n          - This field MUST be called `credentials`.\n        - A field that is called `credentials` MUST be a `CredentialsMetaInput`.\n        \"\"\"\n        super().__pydantic_init_subclass__(**kwargs)\n        cls.cached_jsonschema = {}\n        credentials_fields = [field_name for (field_name, info) in cls.model_fields.items() if inspect.isclass(info.annotation) and issubclass(get_origin(info.annotation) or info.annotation, CredentialsMetaInput)]\n        if len(credentials_fields) > 1:\n            raise ValueError(f'{cls.__qualname__} can only have one CredentialsMetaInput field')\n        elif len(credentials_fields) == 1 and credentials_fields[0] != CREDENTIALS_FIELD_NAME:\n            raise ValueError(f\"CredentialsMetaInput field on {cls.__qualname__} must be named 'credentials'\")\n        elif len(credentials_fields) == 0 and CREDENTIALS_FIELD_NAME in cls.model_fields.keys():\n            raise TypeError(f\"Field 'credentials' on {cls.__qualname__} must be of type {CredentialsMetaInput.__name__}\")\n        if (credentials_field := cls.model_fields.get(CREDENTIALS_FIELD_NAME)):\n            credentials_input_type = cast(CredentialsMetaInput, credentials_field.annotation)\n            credentials_input_type.validate_credentials_field_schema(cls)\ncached_jsonschema: ClassVar[dict[str, Any]]\n@classmethod\ndef jsonschema(cls) -> dict[str, Any]:\n    if cls.cached_jsonschema:\n        return cls.cached_jsonschema\n    model = jsonref.replace_refs(cls.model_json_schema(), merge_props=True)\n\n    def ref_to_dict(obj):\n        if isinstance(obj, dict):\n            keys = {'allOf', 'anyOf', 'oneOf'}\n            one_key = next((k for k in keys if k in obj and len(obj[k]) == 1), None)\n            if one_key:\n                obj.update(obj[one_key][0])\n            return {key: ref_to_dict(value) for (key, value) in obj.items() if not key.startswith('$') and key != one_key}\n        elif isinstance(obj, list):\n            return [ref_to_dict(item) for item in obj]\n        return obj\n    cls.cached_jsonschema = cast(dict[str, Any], ref_to_dict(model))\n    for field in cls.cached_jsonschema.get('properties', {}).values():\n        if isinstance(field, dict) and 'advanced' not in field:\n            field['advanced'] = True\n    return cls.cached_jsonschema\ncls.cached_jsonschema"
    },
    {
      "id": "n2",
      "type": "block",
      "statements": [
        "return cls.cached_jsonschema"
      ],
      "code": "return cls.cached_jsonschema"
    },
    {
      "id": "n3",
      "type": "block",
      "statements": [],
      "code": "\nmodel = jsonref.replace_refs(cls.model_json_schema(), merge_props=True)\ndef ref_to_dict(obj):\n    if isinstance(obj, dict):\n        keys = {'allOf', 'anyOf', 'oneOf'}\n        one_key = next((k for k in keys if k in obj and len(obj[k]) == 1), None)\n        if one_key:\n            obj.update(obj[one_key][0])\n        return {key: ref_to_dict(value) for (key, value) in obj.items() if not key.startswith('$') and key != one_key}\n    elif isinstance(obj, list):\n        return [ref_to_dict(item) for item in obj]\n    return obj\nisinstance(obj, dict)"
    },
    {
      "id": "n4",
      "type": "block",
      "statements": [
        "keys = {'allOf', 'anyOf', 'oneOf'}",
        "one_key = next((k for k in keys if k in obj and len(obj[k]) == 1), None)",
        "one_key"
      ],
      "code": "keys = {'allOf', 'anyOf', 'oneOf'}\none_key = next((k for k in keys if k in obj and len(obj[k]) == 1), None)\none_key"
    },
    {
      "id": "n5",
      "type": "block",
      "statements": [
        "isinstance(obj, list)"
      ],
      "code": "isinstance(obj, list)"
    },
    {
      "id": "n6",
      "type": "block",
      "statements": [
        "return obj"
      ],
      "code": "return obj"
    },
    {
      "id": "n7",
      "type": "block",
      "statements": [
        "obj.update(obj[one_key][0])"
      ],
      "code": "obj.update(obj[one_key][0])"
    },
    {
      "id": "n8",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n9",
      "type": "block",
      "statements": [
        "return {key: ref_to_dict(value) for (key, value) in obj.items() if not key.startswith('$') and key != one_key}"
      ],
      "code": "return {key: ref_to_dict(value) for (key, value) in obj.items() if not key.startswith('$') and key != one_key}"
    },
    {
      "id": "n10",
      "type": "block",
      "statements": [
        "return [ref_to_dict(item) for item in obj]"
      ],
      "code": "return [ref_to_dict(item) for item in obj]"
    },
    {
      "id": "n11",
      "type": "block",
      "statements": [],
      "code": "\n"
    },
    {
      "id": "n12",
      "type": "block",
      "statements": [
        "cls.cached_jsonschema = cast(dict[str, Any], ref_to_dict(model))"
      ],
      "code": "cls.cached_jsonschema = cast(dict[str, Any], ref_to_dict(model))"
    },
    {
      "id": "n13",
      "type": "block",
      "statements": [
        "field",
        "cls.cached_jsonschema.get('properties', {}).values()"
      ],
      "code": "field\ncls.cached_jsonschema.get('properties', {}).values()"
    },
    {
      "id": "n14",
      "type": "block",
      "statements": [
        "isinstance(field, dict) and 'advanced' not in field"
      ],
      "code": "isinstance(field, dict) and 'advanced' not in field"
    },
    {
      "id": "n15",
      "type": "block",
      "statements": [
        "return cls.cached_jsonschema"
      ],
      "code": "return cls.cached_jsonschema"
    },
    {
      "id": "n16",
      "type": "block",
      "statements": [
        "field['advanced'] = True"
      ],
      "code": "field['advanced'] = True"
    },
    {
      "id": "n17",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n18",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n19",
      "type": "block",
      "statements": [
        "@classmethod\ndef validate_data(cls, data: BlockInput) -> str | None:\n    return json.validate_with_jsonschema(schema=cls.jsonschema(), data=data)",
        "return json.validate_with_jsonschema(schema=cls.jsonschema(), data=data)"
      ],
      "code": "@classmethod\ndef validate_data(cls, data: BlockInput) -> str | None:\n    return json.validate_with_jsonschema(schema=cls.jsonschema(), data=data)\nreturn json.validate_with_jsonschema(schema=cls.jsonschema(), data=data)"
    },
    {
      "id": "n20",
      "type": "block",
      "statements": [
        "@classmethod\ndef validate_field(cls, field_name: str, data: BlockInput) -> str | None:\n    \"\"\"\n        Validate the data against a specific property (one of the input/output name).\n        Returns the validation error message if the data does not match the schema.\n        \"\"\"\n    model_schema = cls.jsonschema().get('properties', {})\n    if not model_schema:\n        return f'Invalid model schema {cls}'\n    property_schema = model_schema.get(field_name)\n    if not property_schema:\n        return f'Invalid property name {field_name}'\n    try:\n        jsonschema.validate(json.to_dict(data), property_schema)\n        return None\n    except jsonschema.ValidationError as e:\n        return str(e)",
        "'\\n        Validate the data against a specific property (one of the input/output name).\\n        Returns the validation error message if the data does not match the schema.\\n        '",
        "model_schema = cls.jsonschema().get('properties', {})",
        "not model_schema"
      ],
      "code": "@classmethod\ndef validate_field(cls, field_name: str, data: BlockInput) -> str | None:\n    \"\"\"\n        Validate the data against a specific property (one of the input/output name).\n        Returns the validation error message if the data does not match the schema.\n        \"\"\"\n    model_schema = cls.jsonschema().get('properties', {})\n    if not model_schema:\n        return f'Invalid model schema {cls}'\n    property_schema = model_schema.get(field_name)\n    if not property_schema:\n        return f'Invalid property name {field_name}'\n    try:\n        jsonschema.validate(json.to_dict(data), property_schema)\n        return None\n    except jsonschema.ValidationError as e:\n        return str(e)\n'\\n        Validate the data against a specific property (one of the input/output name).\\n        Returns the validation error message if the data does not match the schema.\\n        '\nmodel_schema = cls.jsonschema().get('properties', {})\nnot model_schema"
    },
    {
      "id": "n21",
      "type": "block",
      "statements": [
        "return f'Invalid model schema {cls}'"
      ],
      "code": "return f'Invalid model schema {cls}'"
    },
    {
      "id": "n22",
      "type": "block",
      "statements": [],
      "code": "\nproperty_schema = model_schema.get(field_name)\nnot property_schema"
    },
    {
      "id": "n23",
      "type": "block",
      "statements": [
        "return f'Invalid property name {field_name}'"
      ],
      "code": "return f'Invalid property name {field_name}'"
    },
    {
      "id": "n24",
      "type": "block",
      "statements": [],
      "code": "\ntry:\n    jsonschema.validate(json.to_dict(data), property_schema)\n    return None\nexcept jsonschema.ValidationError as e:\n    return str(e)\njsonschema.validate(json.to_dict(data), property_schema)\nreturn None"
    },
    {
      "id": "n25",
      "type": "block",
      "statements": [
        "return str(e)"
      ],
      "code": "return str(e)"
    },
    {
      "id": "n26",
      "type": "block",
      "statements": [
        "@classmethod\ndef get_fields(cls) -> set[str]:\n    return set(cls.model_fields.keys())",
        "return set(cls.model_fields.keys())"
      ],
      "code": "@classmethod\ndef get_fields(cls) -> set[str]:\n    return set(cls.model_fields.keys())\nreturn set(cls.model_fields.keys())"
    },
    {
      "id": "n27",
      "type": "block",
      "statements": [
        "@classmethod\ndef get_required_fields(cls) -> set[str]:\n    return {field for (field, field_info) in cls.model_fields.items() if field_info.is_required()}",
        "return {field for (field, field_info) in cls.model_fields.items() if field_info.is_required()}"
      ],
      "code": "@classmethod\ndef get_required_fields(cls) -> set[str]:\n    return {field for (field, field_info) in cls.model_fields.items() if field_info.is_required()}\nreturn {field for (field, field_info) in cls.model_fields.items() if field_info.is_required()}"
    },
    {
      "id": "n28",
      "type": "block",
      "statements": [
        "@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"Validates the schema definition. Rules:\n        - Only one `CredentialsMetaInput` field may be present.\n          - This field MUST be called `credentials`.\n        - A field that is called `credentials` MUST be a `CredentialsMetaInput`.\n        \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n    cls.cached_jsonschema = {}\n    credentials_fields = [field_name for (field_name, info) in cls.model_fields.items() if inspect.isclass(info.annotation) and issubclass(get_origin(info.annotation) or info.annotation, CredentialsMetaInput)]\n    if len(credentials_fields) > 1:\n        raise ValueError(f'{cls.__qualname__} can only have one CredentialsMetaInput field')\n    elif len(credentials_fields) == 1 and credentials_fields[0] != CREDENTIALS_FIELD_NAME:\n        raise ValueError(f\"CredentialsMetaInput field on {cls.__qualname__} must be named 'credentials'\")\n    elif len(credentials_fields) == 0 and CREDENTIALS_FIELD_NAME in cls.model_fields.keys():\n        raise TypeError(f\"Field 'credentials' on {cls.__qualname__} must be of type {CredentialsMetaInput.__name__}\")\n    if (credentials_field := cls.model_fields.get(CREDENTIALS_FIELD_NAME)):\n        credentials_input_type = cast(CredentialsMetaInput, credentials_field.annotation)\n        credentials_input_type.validate_credentials_field_schema(cls)",
        "'Validates the schema definition. Rules:\\n        - Only one `CredentialsMetaInput` field may be present.\\n          - This field MUST be called `credentials`.\\n        - A field that is called `credentials` MUST be a `CredentialsMetaInput`.\\n        '",
        "super().__pydantic_init_subclass__()",
        "cls.cached_jsonschema = {}",
        "credentials_fields = [field_name for (field_name, info) in cls.model_fields.items() if inspect.isclass(info.annotation) and issubclass(get_origin(info.annotation) or info.annotation, CredentialsMetaInput)]",
        "len(credentials_fields) Gt 1"
      ],
      "code": "@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"Validates the schema definition. Rules:\n        - Only one `CredentialsMetaInput` field may be present.\n          - This field MUST be called `credentials`.\n        - A field that is called `credentials` MUST be a `CredentialsMetaInput`.\n        \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n    cls.cached_jsonschema = {}\n    credentials_fields = [field_name for (field_name, info) in cls.model_fields.items() if inspect.isclass(info.annotation) and issubclass(get_origin(info.annotation) or info.annotation, CredentialsMetaInput)]\n    if len(credentials_fields) > 1:\n        raise ValueError(f'{cls.__qualname__} can only have one CredentialsMetaInput field')\n    elif len(credentials_fields) == 1 and credentials_fields[0] != CREDENTIALS_FIELD_NAME:\n        raise ValueError(f\"CredentialsMetaInput field on {cls.__qualname__} must be named 'credentials'\")\n    elif len(credentials_fields) == 0 and CREDENTIALS_FIELD_NAME in cls.model_fields.keys():\n        raise TypeError(f\"Field 'credentials' on {cls.__qualname__} must be of type {CredentialsMetaInput.__name__}\")\n    if (credentials_field := cls.model_fields.get(CREDENTIALS_FIELD_NAME)):\n        credentials_input_type = cast(CredentialsMetaInput, credentials_field.annotation)\n        credentials_input_type.validate_credentials_field_schema(cls)\n'Validates the schema definition. Rules:\\n        - Only one `CredentialsMetaInput` field may be present.\\n          - This field MUST be called `credentials`.\\n        - A field that is called `credentials` MUST be a `CredentialsMetaInput`.\\n        '\nsuper().__pydantic_init_subclass__()\ncls.cached_jsonschema = {}\ncredentials_fields = [field_name for (field_name, info) in cls.model_fields.items() if inspect.isclass(info.annotation) and issubclass(get_origin(info.annotation) or info.annotation, CredentialsMetaInput)]\nlen(credentials_fields) Gt 1"
    },
    {
      "id": "n29",
      "type": "block",
      "statements": [
        "raise ValueError(f'{cls.__qualname__} can only have one CredentialsMetaInput field')"
      ],
      "code": "raise ValueError(f'{cls.__qualname__} can only have one CredentialsMetaInput field')"
    },
    {
      "id": "n30",
      "type": "block",
      "statements": [
        "len(credentials_fields) == 1 and credentials_fields[0] != CREDENTIALS_FIELD_NAME"
      ],
      "code": "len(credentials_fields) == 1 and credentials_fields[0] != CREDENTIALS_FIELD_NAME"
    },
    {
      "id": "n31",
      "type": "block",
      "statements": [
        "(credentials_field := cls.model_fields.get(CREDENTIALS_FIELD_NAME))"
      ],
      "code": "(credentials_field := cls.model_fields.get(CREDENTIALS_FIELD_NAME))"
    },
    {
      "id": "n32",
      "type": "block",
      "statements": [
        "raise ValueError(f\"CredentialsMetaInput field on {cls.__qualname__} must be named 'credentials'\")"
      ],
      "code": "raise ValueError(f\"CredentialsMetaInput field on {cls.__qualname__} must be named 'credentials'\")"
    },
    {
      "id": "n33",
      "type": "block",
      "statements": [
        "len(credentials_fields) == 0 and CREDENTIALS_FIELD_NAME in cls.model_fields.keys()"
      ],
      "code": "len(credentials_fields) == 0 and CREDENTIALS_FIELD_NAME in cls.model_fields.keys()"
    },
    {
      "id": "n34",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n35",
      "type": "block",
      "statements": [
        "raise TypeError(f\"Field 'credentials' on {cls.__qualname__} must be of type {CredentialsMetaInput.__name__}\")"
      ],
      "code": "raise TypeError(f\"Field 'credentials' on {cls.__qualname__} must be of type {CredentialsMetaInput.__name__}\")"
    },
    {
      "id": "n36",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n37",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n38",
      "type": "block",
      "statements": [
        "credentials_input_type = cast(CredentialsMetaInput, credentials_field.annotation)",
        "credentials_input_type.validate_credentials_field_schema(cls)"
      ],
      "code": "credentials_input_type = cast(CredentialsMetaInput, credentials_field.annotation)\ncredentials_input_type.validate_credentials_field_schema(cls)"
    },
    {
      "id": "n39",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n40",
      "type": "block",
      "statements": [
        "BlockSchemaInputType = TypeVar('BlockSchemaInputType', bound=BlockSchema)",
        "BlockSchemaOutputType = TypeVar('BlockSchemaOutputType', bound=BlockSchema)",
        "class EmptySchema(BlockSchema):\n    pass",
        "pass",
        "class BlockManualWebhookConfig(BaseModel):\n    \"\"\"\n    Configuration model for webhook-triggered blocks on which\n    the user has to manually set up the webhook at the provider.\n    \"\"\"\n    provider: str\n    'The service provider that the webhook connects to'\n    webhook_type: str\n    '\\n    Identifier for the webhook type. E.g. GitHub has repo and organization level hooks.\\n\\n    Only for use in the corresponding `WebhooksManager`.\\n    '\n    event_filter_input: str = ''\n    \"\\n    Name of the block's event filter input.\\n    Leave empty if the corresponding webhook doesn't have distinct event/payload types.\\n    \"\n    event_format: str = '{event}'\n    '\\n    Template string for the event(s) that a block instance subscribes to.\\n    Applied individually to each event selected in the event filter input.\\n\\n    Example: `\"pull_request.{event}\"` -> `\"pull_request.opened\"`\\n    '",
        "'\\n    Configuration model for webhook-triggered blocks on which\\n    the user has to manually set up the webhook at the provider.\\n    '",
        "provider: str",
        "'The service provider that the webhook connects to'",
        "webhook_type: str",
        "'\\n    Identifier for the webhook type. E.g. GitHub has repo and organization level hooks.\\n\\n    Only for use in the corresponding `WebhooksManager`.\\n    '",
        "event_filter_input: str = ''",
        "\"\\n    Name of the block's event filter input.\\n    Leave empty if the corresponding webhook doesn't have distinct event/payload types.\\n    \"",
        "event_format: str = '{event}'",
        "'\\n    Template string for the event(s) that a block instance subscribes to.\\n    Applied individually to each event selected in the event filter input.\\n\\n    Example: `\"pull_request.{event}\"` -> `\"pull_request.opened\"`\\n    '",
        "class BlockWebhookConfig(BlockManualWebhookConfig):\n    \"\"\"\n    Configuration model for webhook-triggered blocks for which\n    the webhook can be automatically set up through the provider's API.\n    \"\"\"\n    resource_format: str\n    '\\n    Template string for the resource that a block instance subscribes to.\\n    Fields will be filled from the block\\'s inputs (except `payload`).\\n\\n    Example: `f\"{repo}/pull_requests\"` (note: not how it\\'s actually implemented)\\n\\n    Only for use in the corresponding `WebhooksManager`.\\n    '",
        "\"\\n    Configuration model for webhook-triggered blocks for which\\n    the webhook can be automatically set up through the provider's API.\\n    \"",
        "resource_format: str",
        "'\\n    Template string for the resource that a block instance subscribes to.\\n    Fields will be filled from the block\\'s inputs (except `payload`).\\n\\n    Example: `f\"{repo}/pull_requests\"` (note: not how it\\'s actually implemented)\\n\\n    Only for use in the corresponding `WebhooksManager`.\\n    '",
        "class Block(ABC, Generic[BlockSchemaInputType, BlockSchemaOutputType]):\n\n    def __init__(self, id: str='', description: str='', contributors: list[ContributorDetails]=[], categories: set[BlockCategory] | None=None, input_schema: Type[BlockSchemaInputType]=EmptySchema, output_schema: Type[BlockSchemaOutputType]=EmptySchema, test_input: BlockInput | list[BlockInput] | None=None, test_output: BlockData | list[BlockData] | None=None, test_mock: dict[str, Any] | None=None, test_credentials: Optional[Credentials]=None, disabled: bool=False, static_output: bool=False, block_type: BlockType=BlockType.STANDARD, webhook_config: Optional[BlockWebhookConfig | BlockManualWebhookConfig]=None):\n        \"\"\"\n        Initialize the block with the given schema.\n\n        Args:\n            id: The unique identifier for the block, this value will be persisted in the\n                DB. So it should be a unique and constant across the application run.\n                Use the UUID format for the ID.\n            description: The description of the block, explaining what the block does.\n            contributors: The list of contributors who contributed to the block.\n            input_schema: The schema, defined as a Pydantic model, for the input data.\n            output_schema: The schema, defined as a Pydantic model, for the output data.\n            test_input: The list or single sample input data for the block, for testing.\n            test_output: The list or single expected output if the test_input is run.\n            test_mock: function names on the block implementation to mock on test run.\n            disabled: If the block is disabled, it will not be available for execution.\n            static_output: Whether the output links of the block are static by default.\n        \"\"\"\n        self.id = id\n        self.input_schema = input_schema\n        self.output_schema = output_schema\n        self.test_input = test_input\n        self.test_output = test_output\n        self.test_mock = test_mock\n        self.test_credentials = test_credentials\n        self.description = description\n        self.categories = categories or set()\n        self.contributors = contributors or set()\n        self.disabled = disabled\n        self.static_output = static_output\n        self.block_type = block_type\n        self.webhook_config = webhook_config\n        self.execution_stats = {}\n        if self.webhook_config:\n            if isinstance(self.webhook_config, BlockWebhookConfig):\n                if CREDENTIALS_FIELD_NAME not in self.input_schema.model_fields:\n                    raise TypeError('credentials field is required on auto-setup webhook blocks')\n                self.block_type = BlockType.WEBHOOK\n            else:\n                self.block_type = BlockType.WEBHOOK_MANUAL\n            if self.webhook_config.event_filter_input:\n                event_filter_field = self.input_schema.model_fields[self.webhook_config.event_filter_input]\n                if not (isinstance(event_filter_field.annotation, type) and issubclass(event_filter_field.annotation, BaseModel) and all((field.annotation is bool for field in event_filter_field.annotation.model_fields.values()))):\n                    raise NotImplementedError(f'{self.name} has an invalid webhook event selector: field must be a BaseModel and all its fields must be boolean')\n            if 'payload' not in self.input_schema.model_fields:\n                raise TypeError(f\"{self.name} is webhook-triggered but has no 'payload' input\")\n            if not app_config.platform_base_url:\n                self.disabled = True\n\n    @classmethod\n    def create(cls: Type['Block']) -> 'Block':\n        return cls()\n\n    @abstractmethod\n    def run(self, input_data: BlockSchemaInputType, **kwargs) -> BlockOutput:\n        \"\"\"\n        Run the block with the given input data.\n        Args:\n            input_data: The input data with the structure of input_schema.\n        Returns:\n            A Generator that yields (output_name, output_data).\n            output_name: One of the output name defined in Block's output_schema.\n            output_data: The data for the output_name, matching the defined schema.\n        \"\"\"\n        pass\n\n    def run_once(self, input_data: BlockSchemaInputType, output: str, **kwargs) -> Any:\n        for (name, data) in self.run(input_data, **kwargs):\n            if name == output:\n                return data\n        raise ValueError(f'{self.name} did not produce any output for {output}')\n\n    def merge_stats(self, stats: dict[str, Any]) -> dict[str, Any]:\n        for (key, value) in stats.items():\n            if isinstance(value, dict):\n                self.execution_stats.setdefault(key, {}).update(value)\n            elif isinstance(value, (int, float)):\n                self.execution_stats.setdefault(key, 0)\n                self.execution_stats[key] += value\n            elif isinstance(value, list):\n                self.execution_stats.setdefault(key, [])\n                self.execution_stats[key].extend(value)\n            else:\n                self.execution_stats[key] = value\n        return self.execution_stats\n\n    @property\n    def name(self):\n        return self.__class__.__name__\n\n    def to_dict(self):\n        return {'id': self.id, 'name': self.name, 'inputSchema': self.input_schema.jsonschema(), 'outputSchema': self.output_schema.jsonschema(), 'description': self.description, 'categories': [category.dict() for category in self.categories], 'contributors': [contributor.model_dump() for contributor in self.contributors], 'staticOutput': self.static_output, 'uiType': self.block_type.value}\n\n    def execute(self, input_data: BlockInput, **kwargs) -> BlockOutput:\n        if (error := self.input_schema.validate_data(input_data)):\n            raise ValueError(f'Unable to execute block with invalid input data: {error}')\n        for (output_name, output_data) in self.run(self.input_schema(**input_data), **kwargs):\n            if output_name == 'error':\n                raise RuntimeError(output_data)\n            if self.block_type == BlockType.STANDARD and (error := self.output_schema.validate_field(output_name, output_data)):\n                raise ValueError(f'Block produced an invalid output data: {error}')\n            yield (output_name, output_data)",
        "def __init__(self, id: str='', description: str='', contributors: list[ContributorDetails]=[], categories: set[BlockCategory] | None=None, input_schema: Type[BlockSchemaInputType]=EmptySchema, output_schema: Type[BlockSchemaOutputType]=EmptySchema, test_input: BlockInput | list[BlockInput] | None=None, test_output: BlockData | list[BlockData] | None=None, test_mock: dict[str, Any] | None=None, test_credentials: Optional[Credentials]=None, disabled: bool=False, static_output: bool=False, block_type: BlockType=BlockType.STANDARD, webhook_config: Optional[BlockWebhookConfig | BlockManualWebhookConfig]=None):\n    \"\"\"\n        Initialize the block with the given schema.\n\n        Args:\n            id: The unique identifier for the block, this value will be persisted in the\n                DB. So it should be a unique and constant across the application run.\n                Use the UUID format for the ID.\n            description: The description of the block, explaining what the block does.\n            contributors: The list of contributors who contributed to the block.\n            input_schema: The schema, defined as a Pydantic model, for the input data.\n            output_schema: The schema, defined as a Pydantic model, for the output data.\n            test_input: The list or single sample input data for the block, for testing.\n            test_output: The list or single expected output if the test_input is run.\n            test_mock: function names on the block implementation to mock on test run.\n            disabled: If the block is disabled, it will not be available for execution.\n            static_output: Whether the output links of the block are static by default.\n        \"\"\"\n    self.id = id\n    self.input_schema = input_schema\n    self.output_schema = output_schema\n    self.test_input = test_input\n    self.test_output = test_output\n    self.test_mock = test_mock\n    self.test_credentials = test_credentials\n    self.description = description\n    self.categories = categories or set()\n    self.contributors = contributors or set()\n    self.disabled = disabled\n    self.static_output = static_output\n    self.block_type = block_type\n    self.webhook_config = webhook_config\n    self.execution_stats = {}\n    if self.webhook_config:\n        if isinstance(self.webhook_config, BlockWebhookConfig):\n            if CREDENTIALS_FIELD_NAME not in self.input_schema.model_fields:\n                raise TypeError('credentials field is required on auto-setup webhook blocks')\n            self.block_type = BlockType.WEBHOOK\n        else:\n            self.block_type = BlockType.WEBHOOK_MANUAL\n        if self.webhook_config.event_filter_input:\n            event_filter_field = self.input_schema.model_fields[self.webhook_config.event_filter_input]\n            if not (isinstance(event_filter_field.annotation, type) and issubclass(event_filter_field.annotation, BaseModel) and all((field.annotation is bool for field in event_filter_field.annotation.model_fields.values()))):\n                raise NotImplementedError(f'{self.name} has an invalid webhook event selector: field must be a BaseModel and all its fields must be boolean')\n        if 'payload' not in self.input_schema.model_fields:\n            raise TypeError(f\"{self.name} is webhook-triggered but has no 'payload' input\")\n        if not app_config.platform_base_url:\n            self.disabled = True",
        "'\\n        Initialize the block with the given schema.\\n\\n        Args:\\n            id: The unique identifier for the block, this value will be persisted in the\\n                DB. So it should be a unique and constant across the application run.\\n                Use the UUID format for the ID.\\n            description: The description of the block, explaining what the block does.\\n            contributors: The list of contributors who contributed to the block.\\n            input_schema: The schema, defined as a Pydantic model, for the input data.\\n            output_schema: The schema, defined as a Pydantic model, for the output data.\\n            test_input: The list or single sample input data for the block, for testing.\\n            test_output: The list or single expected output if the test_input is run.\\n            test_mock: function names on the block implementation to mock on test run.\\n            disabled: If the block is disabled, it will not be available for execution.\\n            static_output: Whether the output links of the block are static by default.\\n        '",
        "self.id = id",
        "self.input_schema = input_schema",
        "self.output_schema = output_schema",
        "self.test_input = test_input",
        "self.test_output = test_output",
        "self.test_mock = test_mock",
        "self.test_credentials = test_credentials",
        "self.description = description",
        "self.categories = categories or set()",
        "self.contributors = contributors or set()",
        "self.disabled = disabled",
        "self.static_output = static_output",
        "self.block_type = block_type",
        "self.webhook_config = webhook_config",
        "self.execution_stats = {}",
        "self.webhook_config"
      ],
      "code": "BlockSchemaInputType = TypeVar('BlockSchemaInputType', bound=BlockSchema)\nBlockSchemaOutputType = TypeVar('BlockSchemaOutputType', bound=BlockSchema)\nclass EmptySchema(BlockSchema):\n    pass\npass\nclass BlockManualWebhookConfig(BaseModel):\n    \"\"\"\n    Configuration model for webhook-triggered blocks on which\n    the user has to manually set up the webhook at the provider.\n    \"\"\"\n    provider: str\n    'The service provider that the webhook connects to'\n    webhook_type: str\n    '\\n    Identifier for the webhook type. E.g. GitHub has repo and organization level hooks.\\n\\n    Only for use in the corresponding `WebhooksManager`.\\n    '\n    event_filter_input: str = ''\n    \"\\n    Name of the block's event filter input.\\n    Leave empty if the corresponding webhook doesn't have distinct event/payload types.\\n    \"\n    event_format: str = '{event}'\n    '\\n    Template string for the event(s) that a block instance subscribes to.\\n    Applied individually to each event selected in the event filter input.\\n\\n    Example: `\"pull_request.{event}\"` -> `\"pull_request.opened\"`\\n    '\n'\\n    Configuration model for webhook-triggered blocks on which\\n    the user has to manually set up the webhook at the provider.\\n    '\nprovider: str\n'The service provider that the webhook connects to'\nwebhook_type: str\n'\\n    Identifier for the webhook type. E.g. GitHub has repo and organization level hooks.\\n\\n    Only for use in the corresponding `WebhooksManager`.\\n    '\nevent_filter_input: str = ''\n\"\\n    Name of the block's event filter input.\\n    Leave empty if the corresponding webhook doesn't have distinct event/payload types.\\n    \"\nevent_format: str = '{event}'\n'\\n    Template string for the event(s) that a block instance subscribes to.\\n    Applied individually to each event selected in the event filter input.\\n\\n    Example: `\"pull_request.{event}\"` -> `\"pull_request.opened\"`\\n    '\nclass BlockWebhookConfig(BlockManualWebhookConfig):\n    \"\"\"\n    Configuration model for webhook-triggered blocks for which\n    the webhook can be automatically set up through the provider's API.\n    \"\"\"\n    resource_format: str\n    '\\n    Template string for the resource that a block instance subscribes to.\\n    Fields will be filled from the block\\'s inputs (except `payload`).\\n\\n    Example: `f\"{repo}/pull_requests\"` (note: not how it\\'s actually implemented)\\n\\n    Only for use in the corresponding `WebhooksManager`.\\n    '\n\"\\n    Configuration model for webhook-triggered blocks for which\\n    the webhook can be automatically set up through the provider's API.\\n    \"\nresource_format: str\n'\\n    Template string for the resource that a block instance subscribes to.\\n    Fields will be filled from the block\\'s inputs (except `payload`).\\n\\n    Example: `f\"{repo}/pull_requests\"` (note: not how it\\'s actually implemented)\\n\\n    Only for use in the corresponding `WebhooksManager`.\\n    '\nclass Block(ABC, Generic[BlockSchemaInputType, BlockSchemaOutputType]):\n\n    def __init__(self, id: str='', description: str='', contributors: list[ContributorDetails]=[], categories: set[BlockCategory] | None=None, input_schema: Type[BlockSchemaInputType]=EmptySchema, output_schema: Type[BlockSchemaOutputType]=EmptySchema, test_input: BlockInput | list[BlockInput] | None=None, test_output: BlockData | list[BlockData] | None=None, test_mock: dict[str, Any] | None=None, test_credentials: Optional[Credentials]=None, disabled: bool=False, static_output: bool=False, block_type: BlockType=BlockType.STANDARD, webhook_config: Optional[BlockWebhookConfig | BlockManualWebhookConfig]=None):\n        \"\"\"\n        Initialize the block with the given schema.\n\n        Args:\n            id: The unique identifier for the block, this value will be persisted in the\n                DB. So it should be a unique and constant across the application run.\n                Use the UUID format for the ID.\n            description: The description of the block, explaining what the block does.\n            contributors: The list of contributors who contributed to the block.\n            input_schema: The schema, defined as a Pydantic model, for the input data.\n            output_schema: The schema, defined as a Pydantic model, for the output data.\n            test_input: The list or single sample input data for the block, for testing.\n            test_output: The list or single expected output if the test_input is run.\n            test_mock: function names on the block implementation to mock on test run.\n            disabled: If the block is disabled, it will not be available for execution.\n            static_output: Whether the output links of the block are static by default.\n        \"\"\"\n        self.id = id\n        self.input_schema = input_schema\n        self.output_schema = output_schema\n        self.test_input = test_input\n        self.test_output = test_output\n        self.test_mock = test_mock\n        self.test_credentials = test_credentials\n        self.description = description\n        self.categories = categories or set()\n        self.contributors = contributors or set()\n        self.disabled = disabled\n        self.static_output = static_output\n        self.block_type = block_type\n        self.webhook_config = webhook_config\n        self.execution_stats = {}\n        if self.webhook_config:\n            if isinstance(self.webhook_config, BlockWebhookConfig):\n                if CREDENTIALS_FIELD_NAME not in self.input_schema.model_fields:\n                    raise TypeError('credentials field is required on auto-setup webhook blocks')\n                self.block_type = BlockType.WEBHOOK\n            else:\n                self.block_type = BlockType.WEBHOOK_MANUAL\n            if self.webhook_config.event_filter_input:\n                event_filter_field = self.input_schema.model_fields[self.webhook_config.event_filter_input]\n                if not (isinstance(event_filter_field.annotation, type) and issubclass(event_filter_field.annotation, BaseModel) and all((field.annotation is bool for field in event_filter_field.annotation.model_fields.values()))):\n                    raise NotImplementedError(f'{self.name} has an invalid webhook event selector: field must be a BaseModel and all its fields must be boolean')\n            if 'payload' not in self.input_schema.model_fields:\n                raise TypeError(f\"{self.name} is webhook-triggered but has no 'payload' input\")\n            if not app_config.platform_base_url:\n                self.disabled = True\n\n    @classmethod\n    def create(cls: Type['Block']) -> 'Block':\n        return cls()\n\n    @abstractmethod\n    def run(self, input_data: BlockSchemaInputType, **kwargs) -> BlockOutput:\n        \"\"\"\n        Run the block with the given input data.\n        Args:\n            input_data: The input data with the structure of input_schema.\n        Returns:\n            A Generator that yields (output_name, output_data).\n            output_name: One of the output name defined in Block's output_schema.\n            output_data: The data for the output_name, matching the defined schema.\n        \"\"\"\n        pass\n\n    def run_once(self, input_data: BlockSchemaInputType, output: str, **kwargs) -> Any:\n        for (name, data) in self.run(input_data, **kwargs):\n            if name == output:\n                return data\n        raise ValueError(f'{self.name} did not produce any output for {output}')\n\n    def merge_stats(self, stats: dict[str, Any]) -> dict[str, Any]:\n        for (key, value) in stats.items():\n            if isinstance(value, dict):\n                self.execution_stats.setdefault(key, {}).update(value)\n            elif isinstance(value, (int, float)):\n                self.execution_stats.setdefault(key, 0)\n                self.execution_stats[key] += value\n            elif isinstance(value, list):\n                self.execution_stats.setdefault(key, [])\n                self.execution_stats[key].extend(value)\n            else:\n                self.execution_stats[key] = value\n        return self.execution_stats\n\n    @property\n    def name(self):\n        return self.__class__.__name__\n\n    def to_dict(self):\n        return {'id': self.id, 'name': self.name, 'inputSchema': self.input_schema.jsonschema(), 'outputSchema': self.output_schema.jsonschema(), 'description': self.description, 'categories': [category.dict() for category in self.categories], 'contributors': [contributor.model_dump() for contributor in self.contributors], 'staticOutput': self.static_output, 'uiType': self.block_type.value}\n\n    def execute(self, input_data: BlockInput, **kwargs) -> BlockOutput:\n        if (error := self.input_schema.validate_data(input_data)):\n            raise ValueError(f'Unable to execute block with invalid input data: {error}')\n        for (output_name, output_data) in self.run(self.input_schema(**input_data), **kwargs):\n            if output_name == 'error':\n                raise RuntimeError(output_data)\n            if self.block_type == BlockType.STANDARD and (error := self.output_schema.validate_field(output_name, output_data)):\n                raise ValueError(f'Block produced an invalid output data: {error}')\n            yield (output_name, output_data)\ndef __init__(self, id: str='', description: str='', contributors: list[ContributorDetails]=[], categories: set[BlockCategory] | None=None, input_schema: Type[BlockSchemaInputType]=EmptySchema, output_schema: Type[BlockSchemaOutputType]=EmptySchema, test_input: BlockInput | list[BlockInput] | None=None, test_output: BlockData | list[BlockData] | None=None, test_mock: dict[str, Any] | None=None, test_credentials: Optional[Credentials]=None, disabled: bool=False, static_output: bool=False, block_type: BlockType=BlockType.STANDARD, webhook_config: Optional[BlockWebhookConfig | BlockManualWebhookConfig]=None):\n    \"\"\"\n        Initialize the block with the given schema.\n\n        Args:\n            id: The unique identifier for the block, this value will be persisted in the\n                DB. So it should be a unique and constant across the application run.\n                Use the UUID format for the ID.\n            description: The description of the block, explaining what the block does.\n            contributors: The list of contributors who contributed to the block.\n            input_schema: The schema, defined as a Pydantic model, for the input data.\n            output_schema: The schema, defined as a Pydantic model, for the output data.\n            test_input: The list or single sample input data for the block, for testing.\n            test_output: The list or single expected output if the test_input is run.\n            test_mock: function names on the block implementation to mock on test run.\n            disabled: If the block is disabled, it will not be available for execution.\n            static_output: Whether the output links of the block are static by default.\n        \"\"\"\n    self.id = id\n    self.input_schema = input_schema\n    self.output_schema = output_schema\n    self.test_input = test_input\n    self.test_output = test_output\n    self.test_mock = test_mock\n    self.test_credentials = test_credentials\n    self.description = description\n    self.categories = categories or set()\n    self.contributors = contributors or set()\n    self.disabled = disabled\n    self.static_output = static_output\n    self.block_type = block_type\n    self.webhook_config = webhook_config\n    self.execution_stats = {}\n    if self.webhook_config:\n        if isinstance(self.webhook_config, BlockWebhookConfig):\n            if CREDENTIALS_FIELD_NAME not in self.input_schema.model_fields:\n                raise TypeError('credentials field is required on auto-setup webhook blocks')\n            self.block_type = BlockType.WEBHOOK\n        else:\n            self.block_type = BlockType.WEBHOOK_MANUAL\n        if self.webhook_config.event_filter_input:\n            event_filter_field = self.input_schema.model_fields[self.webhook_config.event_filter_input]\n            if not (isinstance(event_filter_field.annotation, type) and issubclass(event_filter_field.annotation, BaseModel) and all((field.annotation is bool for field in event_filter_field.annotation.model_fields.values()))):\n                raise NotImplementedError(f'{self.name} has an invalid webhook event selector: field must be a BaseModel and all its fields must be boolean')\n        if 'payload' not in self.input_schema.model_fields:\n            raise TypeError(f\"{self.name} is webhook-triggered but has no 'payload' input\")\n        if not app_config.platform_base_url:\n            self.disabled = True\n'\\n        Initialize the block with the given schema.\\n\\n        Args:\\n            id: The unique identifier for the block, this value will be persisted in the\\n                DB. So it should be a unique and constant across the application run.\\n                Use the UUID format for the ID.\\n            description: The description of the block, explaining what the block does.\\n            contributors: The list of contributors who contributed to the block.\\n            input_schema: The schema, defined as a Pydantic model, for the input data.\\n            output_schema: The schema, defined as a Pydantic model, for the output data.\\n            test_input: The list or single sample input data for the block, for testing.\\n            test_output: The list or single expected output if the test_input is run.\\n            test_mock: function names on the block implementation to mock on test run.\\n            disabled: If the block is disabled, it will not be available for execution.\\n            static_output: Whether the output links of the block are static by default.\\n        '\nself.id = id\nself.input_schema = input_schema\nself.output_schema = output_schema\nself.test_input = test_input\nself.test_output = test_output\nself.test_mock = test_mock\nself.test_credentials = test_credentials\nself.description = description\nself.categories = categories or set()\nself.contributors = contributors or set()\nself.disabled = disabled\nself.static_output = static_output\nself.block_type = block_type\nself.webhook_config = webhook_config\nself.execution_stats = {}\nself.webhook_config"
    },
    {
      "id": "n41",
      "type": "block",
      "statements": [
        "isinstance(self.webhook_config, BlockWebhookConfig)"
      ],
      "code": "isinstance(self.webhook_config, BlockWebhookConfig)"
    },
    {
      "id": "n42",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n43",
      "type": "block",
      "statements": [
        "@classmethod\ndef create(cls: Type['Block']) -> 'Block':\n    return cls()",
        "return cls()"
      ],
      "code": "@classmethod\ndef create(cls: Type['Block']) -> 'Block':\n    return cls()\nreturn cls()"
    },
    {
      "id": "n44",
      "type": "block",
      "statements": [
        "CREDENTIALS_FIELD_NAME NotIn self.input_schema.model_fields"
      ],
      "code": "CREDENTIALS_FIELD_NAME NotIn self.input_schema.model_fields"
    },
    {
      "id": "n45",
      "type": "block",
      "statements": [
        "self.block_type = BlockType.WEBHOOK_MANUAL"
      ],
      "code": "self.block_type = BlockType.WEBHOOK_MANUAL"
    },
    {
      "id": "n46",
      "type": "block",
      "statements": [
        "self.webhook_config.event_filter_input"
      ],
      "code": "self.webhook_config.event_filter_input"
    },
    {
      "id": "n47",
      "type": "block",
      "statements": [
        "raise TypeError('credentials field is required on auto-setup webhook blocks')"
      ],
      "code": "raise TypeError('credentials field is required on auto-setup webhook blocks')"
    },
    {
      "id": "n48",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n49",
      "type": "block",
      "statements": [
        "self.block_type = BlockType.WEBHOOK"
      ],
      "code": "self.block_type = BlockType.WEBHOOK"
    },
    {
      "id": "n50",
      "type": "block",
      "statements": [
        "event_filter_field = self.input_schema.model_fields[self.webhook_config.event_filter_input]",
        "not (isinstance(event_filter_field.annotation, type) and issubclass(event_filter_field.annotation, BaseModel) and all((field.annotation is bool for field in event_filter_field.annotation.model_fields.values())))"
      ],
      "code": "event_filter_field = self.input_schema.model_fields[self.webhook_config.event_filter_input]\nnot (isinstance(event_filter_field.annotation, type) and issubclass(event_filter_field.annotation, BaseModel) and all((field.annotation is bool for field in event_filter_field.annotation.model_fields.values())))"
    },
    {
      "id": "n51",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n52",
      "type": "block",
      "statements": [
        "'payload' NotIn self.input_schema.model_fields"
      ],
      "code": "'payload' NotIn self.input_schema.model_fields"
    },
    {
      "id": "n53",
      "type": "block",
      "statements": [
        "raise NotImplementedError(f'{self.name} has an invalid webhook event selector: field must be a BaseModel and all its fields must be boolean')"
      ],
      "code": "raise NotImplementedError(f'{self.name} has an invalid webhook event selector: field must be a BaseModel and all its fields must be boolean')"
    },
    {
      "id": "n54",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n55",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n56",
      "type": "block",
      "statements": [
        "raise TypeError(f\"{self.name} is webhook-triggered but has no 'payload' input\")"
      ],
      "code": "raise TypeError(f\"{self.name} is webhook-triggered but has no 'payload' input\")"
    },
    {
      "id": "n57",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n58",
      "type": "block",
      "statements": [
        "not app_config.platform_base_url"
      ],
      "code": "not app_config.platform_base_url"
    },
    {
      "id": "n59",
      "type": "block",
      "statements": [
        "self.disabled = True"
      ],
      "code": "self.disabled = True"
    },
    {
      "id": "n60",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n61",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n62",
      "type": "block",
      "statements": [
        "@abstractmethod\ndef run(self, input_data: BlockSchemaInputType, **kwargs) -> BlockOutput:\n    \"\"\"\n        Run the block with the given input data.\n        Args:\n            input_data: The input data with the structure of input_schema.\n        Returns:\n            A Generator that yields (output_name, output_data).\n            output_name: One of the output name defined in Block's output_schema.\n            output_data: The data for the output_name, matching the defined schema.\n        \"\"\"\n    pass",
        "\"\\n        Run the block with the given input data.\\n        Args:\\n            input_data: The input data with the structure of input_schema.\\n        Returns:\\n            A Generator that yields (output_name, output_data).\\n            output_name: One of the output name defined in Block's output_schema.\\n            output_data: The data for the output_name, matching the defined schema.\\n        \"",
        "pass",
        "def run_once(self, input_data: BlockSchemaInputType, output: str, **kwargs) -> Any:\n    for (name, data) in self.run(input_data, **kwargs):\n        if name == output:\n            return data\n    raise ValueError(f'{self.name} did not produce any output for {output}')"
      ],
      "code": "@abstractmethod\ndef run(self, input_data: BlockSchemaInputType, **kwargs) -> BlockOutput:\n    \"\"\"\n        Run the block with the given input data.\n        Args:\n            input_data: The input data with the structure of input_schema.\n        Returns:\n            A Generator that yields (output_name, output_data).\n            output_name: One of the output name defined in Block's output_schema.\n            output_data: The data for the output_name, matching the defined schema.\n        \"\"\"\n    pass\n\"\\n        Run the block with the given input data.\\n        Args:\\n            input_data: The input data with the structure of input_schema.\\n        Returns:\\n            A Generator that yields (output_name, output_data).\\n            output_name: One of the output name defined in Block's output_schema.\\n            output_data: The data for the output_name, matching the defined schema.\\n        \"\npass\ndef run_once(self, input_data: BlockSchemaInputType, output: str, **kwargs) -> Any:\n    for (name, data) in self.run(input_data, **kwargs):\n        if name == output:\n            return data\n    raise ValueError(f'{self.name} did not produce any output for {output}')"
    },
    {
      "id": "n63",
      "type": "block",
      "statements": [
        "(name, data)",
        "self.run(input_data)"
      ],
      "code": "(name, data)\nself.run(input_data)"
    },
    {
      "id": "n64",
      "type": "block",
      "statements": [
        "name Eq output"
      ],
      "code": "name Eq output"
    },
    {
      "id": "n65",
      "type": "block",
      "statements": [
        "raise ValueError(f'{self.name} did not produce any output for {output}')",
        "def merge_stats(self, stats: dict[str, Any]) -> dict[str, Any]:\n    for (key, value) in stats.items():\n        if isinstance(value, dict):\n            self.execution_stats.setdefault(key, {}).update(value)\n        elif isinstance(value, (int, float)):\n            self.execution_stats.setdefault(key, 0)\n            self.execution_stats[key] += value\n        elif isinstance(value, list):\n            self.execution_stats.setdefault(key, [])\n            self.execution_stats[key].extend(value)\n        else:\n            self.execution_stats[key] = value\n    return self.execution_stats"
      ],
      "code": "raise ValueError(f'{self.name} did not produce any output for {output}')\ndef merge_stats(self, stats: dict[str, Any]) -> dict[str, Any]:\n    for (key, value) in stats.items():\n        if isinstance(value, dict):\n            self.execution_stats.setdefault(key, {}).update(value)\n        elif isinstance(value, (int, float)):\n            self.execution_stats.setdefault(key, 0)\n            self.execution_stats[key] += value\n        elif isinstance(value, list):\n            self.execution_stats.setdefault(key, [])\n            self.execution_stats[key].extend(value)\n        else:\n            self.execution_stats[key] = value\n    return self.execution_stats"
    },
    {
      "id": "n66",
      "type": "block",
      "statements": [
        "return data"
      ],
      "code": "return data"
    },
    {
      "id": "n67",
      "type": "block",
      "statements": [],
      "code": "\n"
    },
    {
      "id": "n68",
      "type": "block",
      "statements": [
        "(key, value)",
        "stats.items()"
      ],
      "code": "(key, value)\nstats.items()"
    },
    {
      "id": "n69",
      "type": "block",
      "statements": [
        "isinstance(value, dict)"
      ],
      "code": "isinstance(value, dict)"
    },
    {
      "id": "n70",
      "type": "block",
      "statements": [
        "return self.execution_stats"
      ],
      "code": "return self.execution_stats"
    },
    {
      "id": "n71",
      "type": "block",
      "statements": [
        "self.execution_stats.setdefault(key, {}).update(value)"
      ],
      "code": "self.execution_stats.setdefault(key, {}).update(value)"
    },
    {
      "id": "n72",
      "type": "block",
      "statements": [
        "isinstance(value, (int, float))"
      ],
      "code": "isinstance(value, (int, float))"
    },
    {
      "id": "n73",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n74",
      "type": "block",
      "statements": [
        "self.execution_stats.setdefault(key, 0)",
        "self.execution_stats[key] += value"
      ],
      "code": "self.execution_stats.setdefault(key, 0)\nself.execution_stats[key] += value"
    },
    {
      "id": "n75",
      "type": "block",
      "statements": [
        "isinstance(value, list)"
      ],
      "code": "isinstance(value, list)"
    },
    {
      "id": "n76",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n77",
      "type": "block",
      "statements": [
        "self.execution_stats.setdefault(key, [])",
        "self.execution_stats[key].extend(value)"
      ],
      "code": "self.execution_stats.setdefault(key, [])\nself.execution_stats[key].extend(value)"
    },
    {
      "id": "n78",
      "type": "block",
      "statements": [
        "self.execution_stats[key] = value"
      ],
      "code": "self.execution_stats[key] = value"
    },
    {
      "id": "n79",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n80",
      "type": "block",
      "statements": [
        "@property\ndef name(self):\n    return self.__class__.__name__",
        "return self.__class__.__name__"
      ],
      "code": "@property\ndef name(self):\n    return self.__class__.__name__\nreturn self.__class__.__name__"
    },
    {
      "id": "n81",
      "type": "block",
      "statements": [
        "def to_dict(self):\n    return {'id': self.id, 'name': self.name, 'inputSchema': self.input_schema.jsonschema(), 'outputSchema': self.output_schema.jsonschema(), 'description': self.description, 'categories': [category.dict() for category in self.categories], 'contributors': [contributor.model_dump() for contributor in self.contributors], 'staticOutput': self.static_output, 'uiType': self.block_type.value}",
        "return {'id': self.id, 'name': self.name, 'inputSchema': self.input_schema.jsonschema(), 'outputSchema': self.output_schema.jsonschema(), 'description': self.description, 'categories': [category.dict() for category in self.categories], 'contributors': [contributor.model_dump() for contributor in self.contributors], 'staticOutput': self.static_output, 'uiType': self.block_type.value}"
      ],
      "code": "def to_dict(self):\n    return {'id': self.id, 'name': self.name, 'inputSchema': self.input_schema.jsonschema(), 'outputSchema': self.output_schema.jsonschema(), 'description': self.description, 'categories': [category.dict() for category in self.categories], 'contributors': [contributor.model_dump() for contributor in self.contributors], 'staticOutput': self.static_output, 'uiType': self.block_type.value}\nreturn {'id': self.id, 'name': self.name, 'inputSchema': self.input_schema.jsonschema(), 'outputSchema': self.output_schema.jsonschema(), 'description': self.description, 'categories': [category.dict() for category in self.categories], 'contributors': [contributor.model_dump() for contributor in self.contributors], 'staticOutput': self.static_output, 'uiType': self.block_type.value}"
    },
    {
      "id": "n82",
      "type": "block",
      "statements": [
        "def execute(self, input_data: BlockInput, **kwargs) -> BlockOutput:\n    if (error := self.input_schema.validate_data(input_data)):\n        raise ValueError(f'Unable to execute block with invalid input data: {error}')\n    for (output_name, output_data) in self.run(self.input_schema(**input_data), **kwargs):\n        if output_name == 'error':\n            raise RuntimeError(output_data)\n        if self.block_type == BlockType.STANDARD and (error := self.output_schema.validate_field(output_name, output_data)):\n            raise ValueError(f'Block produced an invalid output data: {error}')\n        yield (output_name, output_data)",
        "(error := self.input_schema.validate_data(input_data))"
      ],
      "code": "def execute(self, input_data: BlockInput, **kwargs) -> BlockOutput:\n    if (error := self.input_schema.validate_data(input_data)):\n        raise ValueError(f'Unable to execute block with invalid input data: {error}')\n    for (output_name, output_data) in self.run(self.input_schema(**input_data), **kwargs):\n        if output_name == 'error':\n            raise RuntimeError(output_data)\n        if self.block_type == BlockType.STANDARD and (error := self.output_schema.validate_field(output_name, output_data)):\n            raise ValueError(f'Block produced an invalid output data: {error}')\n        yield (output_name, output_data)\n(error := self.input_schema.validate_data(input_data))"
    },
    {
      "id": "n83",
      "type": "block",
      "statements": [
        "raise ValueError(f'Unable to execute block with invalid input data: {error}')"
      ],
      "code": "raise ValueError(f'Unable to execute block with invalid input data: {error}')"
    },
    {
      "id": "n84",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n85",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n86",
      "type": "block",
      "statements": [
        "(output_name, output_data)",
        "self.run(self.input_schema())"
      ],
      "code": "(output_name, output_data)\nself.run(self.input_schema())"
    },
    {
      "id": "n87",
      "type": "block",
      "statements": [
        "output_name Eq 'error'"
      ],
      "code": "output_name Eq 'error'"
    },
    {
      "id": "n88",
      "type": "block",
      "statements": [
        "def get_blocks() -> dict[str, Type[Block]]:\n    from backend.blocks import AVAILABLE_BLOCKS\n    return AVAILABLE_BLOCKS",
        "from backend.blocks import AVAILABLE_BLOCKS",
        "return AVAILABLE_BLOCKS"
      ],
      "code": "def get_blocks() -> dict[str, Type[Block]]:\n    from backend.blocks import AVAILABLE_BLOCKS\n    return AVAILABLE_BLOCKS\nfrom backend.blocks import AVAILABLE_BLOCKS\nreturn AVAILABLE_BLOCKS"
    },
    {
      "id": "n89",
      "type": "block",
      "statements": [
        "raise RuntimeError(output_data)"
      ],
      "code": "raise RuntimeError(output_data)"
    },
    {
      "id": "n90",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n91",
      "type": "block",
      "statements": [
        "self.block_type == BlockType.STANDARD and (error := self.output_schema.validate_field(output_name, output_data))"
      ],
      "code": "self.block_type == BlockType.STANDARD and (error := self.output_schema.validate_field(output_name, output_data))"
    },
    {
      "id": "n92",
      "type": "block",
      "statements": [
        "raise ValueError(f'Block produced an invalid output data: {error}')"
      ],
      "code": "raise ValueError(f'Block produced an invalid output data: {error}')"
    },
    {
      "id": "n93",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n94",
      "type": "block",
      "statements": [
        "(yield (output_name, output_data))"
      ],
      "code": "(yield (output_name, output_data))"
    },
    {
      "id": "n95",
      "type": "block",
      "statements": [
        "async def initialize_blocks() -> None:\n    for cls in get_blocks().values():\n        block = cls()\n        existing_block = await AgentBlock.prisma().find_first(where={'OR': [{'id': block.id}, {'name': block.name}]})\n        if not existing_block:\n            await AgentBlock.prisma().create(data={'id': block.id, 'name': block.name, 'inputSchema': json.dumps(block.input_schema.jsonschema()), 'outputSchema': json.dumps(block.output_schema.jsonschema())})\n            continue\n        input_schema = json.dumps(block.input_schema.jsonschema())\n        output_schema = json.dumps(block.output_schema.jsonschema())\n        if block.id != existing_block.id or block.name != existing_block.name or input_schema != existing_block.inputSchema or (output_schema != existing_block.outputSchema):\n            await AgentBlock.prisma().update(where={'id': existing_block.id}, data={'id': block.id, 'name': block.name, 'inputSchema': input_schema, 'outputSchema': output_schema})"
      ],
      "code": "async def initialize_blocks() -> None:\n    for cls in get_blocks().values():\n        block = cls()\n        existing_block = await AgentBlock.prisma().find_first(where={'OR': [{'id': block.id}, {'name': block.name}]})\n        if not existing_block:\n            await AgentBlock.prisma().create(data={'id': block.id, 'name': block.name, 'inputSchema': json.dumps(block.input_schema.jsonschema()), 'outputSchema': json.dumps(block.output_schema.jsonschema())})\n            continue\n        input_schema = json.dumps(block.input_schema.jsonschema())\n        output_schema = json.dumps(block.output_schema.jsonschema())\n        if block.id != existing_block.id or block.name != existing_block.name or input_schema != existing_block.inputSchema or (output_schema != existing_block.outputSchema):\n            await AgentBlock.prisma().update(where={'id': existing_block.id}, data={'id': block.id, 'name': block.name, 'inputSchema': input_schema, 'outputSchema': output_schema})"
    },
    {
      "id": "n96",
      "type": "block",
      "statements": [
        "cls",
        "get_blocks().values()"
      ],
      "code": "cls\nget_blocks().values()"
    },
    {
      "id": "n97",
      "type": "block",
      "statements": [
        "block = cls()",
        "existing_block = await AgentBlock.prisma().find_first(where={'OR': [{'id': block.id}, {'name': block.name}]})",
        "not existing_block"
      ],
      "code": "block = cls()\nexisting_block = await AgentBlock.prisma().find_first(where={'OR': [{'id': block.id}, {'name': block.name}]})\nnot existing_block"
    },
    {
      "id": "n98",
      "type": "block",
      "statements": [
        "def get_block(block_id: str) -> Block | None:\n    cls = get_blocks().get(block_id)\n    return cls() if cls else None",
        "cls = get_blocks().get(block_id)",
        "return cls() if cls else None"
      ],
      "code": "def get_block(block_id: str) -> Block | None:\n    cls = get_blocks().get(block_id)\n    return cls() if cls else None\ncls = get_blocks().get(block_id)\nreturn cls() if cls else None"
    },
    {
      "id": "n99",
      "type": "block",
      "statements": [
        "await AgentBlock.prisma().create(data={'id': block.id, 'name': block.name, 'inputSchema': json.dumps(block.input_schema.jsonschema()), 'outputSchema': json.dumps(block.output_schema.jsonschema())})",
        "continue"
      ],
      "code": "await AgentBlock.prisma().create(data={'id': block.id, 'name': block.name, 'inputSchema': json.dumps(block.input_schema.jsonschema()), 'outputSchema': json.dumps(block.output_schema.jsonschema())})\ncontinue"
    },
    {
      "id": "n100",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n101",
      "type": "block",
      "statements": [
        "input_schema = json.dumps(block.input_schema.jsonschema())",
        "output_schema = json.dumps(block.output_schema.jsonschema())",
        "block.id != existing_block.id or block.name != existing_block.name or input_schema != existing_block.inputSchema or (output_schema != existing_block.outputSchema)"
      ],
      "code": "input_schema = json.dumps(block.input_schema.jsonschema())\noutput_schema = json.dumps(block.output_schema.jsonschema())\nblock.id != existing_block.id or block.name != existing_block.name or input_schema != existing_block.inputSchema or (output_schema != existing_block.outputSchema)"
    },
    {
      "id": "n102",
      "type": "block",
      "statements": [
        "await AgentBlock.prisma().update(where={'id': existing_block.id}, data={'id': block.id, 'name': block.name, 'inputSchema': input_schema, 'outputSchema': output_schema})"
      ],
      "code": "await AgentBlock.prisma().update(where={'id': existing_block.id}, data={'id': block.id, 'name': block.name, 'inputSchema': input_schema, 'outputSchema': output_schema})"
    },
    {
      "id": "n103",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n104",
      "type": "block",
      "statements": [],
      "code": ""
    }
  ],
  "edges": [
    {
      "source": "n65",
      "target": "n68"
    },
    {
      "source": "n83",
      "target": "n85"
    },
    {
      "source": "n82",
      "target": "n84"
    },
    {
      "source": "n101",
      "target": "n103"
    },
    {
      "source": "n84",
      "target": "n85"
    },
    {
      "source": "n13",
      "target": "n14"
    },
    {
      "source": "n40",
      "target": "n41"
    },
    {
      "source": "n31",
      "target": "n38"
    },
    {
      "source": "n103",
      "target": "n104"
    },
    {
      "source": "n55",
      "target": "n52"
    },
    {
      "source": "n68",
      "target": "n69"
    },
    {
      "source": "n8",
      "target": "n9"
    },
    {
      "source": "n53",
      "target": "n55"
    },
    {
      "source": "n1",
      "target": "n2"
    },
    {
      "source": "n5",
      "target": "n11"
    },
    {
      "source": "n12",
      "target": "n13"
    },
    {
      "source": "n51",
      "target": "n52"
    },
    {
      "source": "n89",
      "target": "n91"
    },
    {
      "source": "n85",
      "target": "n86"
    },
    {
      "source": "n20",
      "target": "n21"
    },
    {
      "source": "n101",
      "target": "n102"
    },
    {
      "source": "n59",
      "target": "n61"
    },
    {
      "source": "n45",
      "target": "n46"
    },
    {
      "source": "n28",
      "target": "n29"
    },
    {
      "source": "n29",
      "target": "n31"
    },
    {
      "source": "n96",
      "target": "n98"
    },
    {
      "source": "n76",
      "target": "n73"
    },
    {
      "source": "n93",
      "target": "n94"
    },
    {
      "source": "n75",
      "target": "n77"
    },
    {
      "source": "n91",
      "target": "n92"
    },
    {
      "source": "n36",
      "target": "n37"
    },
    {
      "source": "n22",
      "target": "n24"
    },
    {
      "source": "n41",
      "target": "n44"
    },
    {
      "source": "n97",
      "target": "n99"
    },
    {
      "source": "n63",
      "target": "n64"
    },
    {
      "source": "n17",
      "target": "n18"
    },
    {
      "source": "n69",
      "target": "n72"
    },
    {
      "source": "n35",
      "target": "n37"
    },
    {
      "source": "n75",
      "target": "n78"
    },
    {
      "source": "n69",
      "target": "n71"
    },
    {
      "source": "n41",
      "target": "n45"
    },
    {
      "source": "n94",
      "target": "n86"
    },
    {
      "source": "n18",
      "target": "n13"
    },
    {
      "source": "n92",
      "target": "n94"
    },
    {
      "source": "n42",
      "target": "n43"
    },
    {
      "source": "n96",
      "target": "n97"
    },
    {
      "source": "n58",
      "target": "n60"
    },
    {
      "source": "n5",
      "target": "n10"
    },
    {
      "source": "n4",
      "target": "n7"
    },
    {
      "source": "n28",
      "target": "n30"
    },
    {
      "source": "n58",
      "target": "n59"
    },
    {
      "source": "n52",
      "target": "n56"
    },
    {
      "source": "n7",
      "target": "n9"
    },
    {
      "source": "n38",
      "target": "n40"
    },
    {
      "source": "n86",
      "target": "n87"
    },
    {
      "source": "n67",
      "target": "n63"
    },
    {
      "source": "n39",
      "target": "n40"
    },
    {
      "source": "n104",
      "target": "n96"
    },
    {
      "source": "n30",
      "target": "n32"
    },
    {
      "source": "n46",
      "target": "n50"
    },
    {
      "source": "n56",
      "target": "n58"
    },
    {
      "source": "n74",
      "target": "n76"
    },
    {
      "source": "n72",
      "target": "n75"
    },
    {
      "source": "n46",
      "target": "n51"
    },
    {
      "source": "n49",
      "target": "n46"
    },
    {
      "source": "n14",
      "target": "n17"
    },
    {
      "source": "n72",
      "target": "n74"
    },
    {
      "source": "n47",
      "target": "n49"
    },
    {
      "source": "n102",
      "target": "n104"
    },
    {
      "source": "n22",
      "target": "n23"
    },
    {
      "source": "n50",
      "target": "n54"
    },
    {
      "source": "n82",
      "target": "n83"
    },
    {
      "source": "n37",
      "target": "n34"
    },
    {
      "source": "n95",
      "target": "n96"
    },
    {
      "source": "n90",
      "target": "n91"
    },
    {
      "source": "n86",
      "target": "n88"
    },
    {
      "source": "n4",
      "target": "n8"
    },
    {
      "source": "n50",
      "target": "n53"
    },
    {
      "source": "n44",
      "target": "n47"
    },
    {
      "source": "n14",
      "target": "n16"
    },
    {
      "source": "n60",
      "target": "n61"
    },
    {
      "source": "n62",
      "target": "n63"
    },
    {
      "source": "n44",
      "target": "n48"
    },
    {
      "source": "n57",
      "target": "n58"
    },
    {
      "source": "n33",
      "target": "n36"
    },
    {
      "source": "n87",
      "target": "n89"
    },
    {
      "source": "n64",
      "target": "n66"
    },
    {
      "source": "n40",
      "target": "n42"
    },
    {
      "source": "n1",
      "target": "n3"
    },
    {
      "source": "n30",
      "target": "n33"
    },
    {
      "source": "n3",
      "target": "n5"
    },
    {
      "source": "n32",
      "target": "n34"
    },
    {
      "source": "n63",
      "target": "n65"
    },
    {
      "source": "n48",
      "target": "n49"
    },
    {
      "source": "n54",
      "target": "n55"
    },
    {
      "source": "n78",
      "target": "n79"
    },
    {
      "source": "n31",
      "target": "n39"
    },
    {
      "source": "n91",
      "target": "n93"
    },
    {
      "source": "n52",
      "target": "n57"
    },
    {
      "source": "n71",
      "target": "n73"
    },
    {
      "source": "n3",
      "target": "n4"
    },
    {
      "source": "n68",
      "target": "n70"
    },
    {
      "source": "n13",
      "target": "n15"
    },
    {
      "source": "n16",
      "target": "n18"
    },
    {
      "source": "n33",
      "target": "n35"
    },
    {
      "source": "n97",
      "target": "n100"
    },
    {
      "source": "n64",
      "target": "n67"
    },
    {
      "source": "n100",
      "target": "n101"
    },
    {
      "source": "n11",
      "target": "n6"
    },
    {
      "source": "n73",
      "target": "n68"
    },
    {
      "source": "n87",
      "target": "n90"
    },
    {
      "source": "n77",
      "target": "n79"
    },
    {
      "source": "n79",
      "target": "n76"
    },
    {
      "source": "n99",
      "target": "n101"
    },
    {
      "source": "n61",
      "target": "n43"
    },
    {
      "source": "n20",
      "target": "n22"
    },
    {
      "source": "n34",
      "target": "n31"
    }
  ]
}