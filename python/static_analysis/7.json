{
  "nodes": [
    {
      "id": "n0",
      "type": "block",
      "statements": [
        "from abc import ABC, abstractmethod",
        "from datetime import datetime, timezone",
        "from prisma import Json",
        "from prisma.enums import CreditTransactionType",
        "from prisma.errors import UniqueViolationError",
        "from prisma.models import CreditTransaction",
        "from backend.data.block import Block, BlockInput, get_block",
        "from backend.data.block_cost_config import BLOCK_COSTS",
        "from backend.data.cost import BlockCost, BlockCostType",
        "from backend.util.settings import Config",
        "config = Config()",
        "class UserCreditBase(ABC):\n\n    def __init__(self, num_user_credits_refill: int):\n        self.num_user_credits_refill = num_user_credits_refill\n\n    @abstractmethod\n    async def get_or_refill_credit(self, user_id: str) -> int:\n        \"\"\"\n        Get the current credit for the user and refill if no transaction has been made in the current cycle.\n\n        Returns:\n            int: The current credit for the user.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    async def spend_credits(self, user_id: str, user_credit: int, block_id: str, input_data: BlockInput, data_size: float, run_time: float) -> int:\n        \"\"\"\n        Spend the credits for the user based on the block usage.\n\n        Args:\n            user_id (str): The user ID.\n            user_credit (int): The current credit for the user.\n            block_id (str): The block ID.\n            input_data (BlockInput): The input data for the block.\n            data_size (float): The size of the data being processed.\n            run_time (float): The time taken to run the block.\n\n        Returns:\n            int: amount of credit spent\n        \"\"\"\n        pass\n\n    @abstractmethod\n    async def top_up_credits(self, user_id: str, amount: int):\n        \"\"\"\n        Top up the credits for the user.\n\n        Args:\n            user_id (str): The user ID.\n            amount (int): The amount to top up.\n        \"\"\"\n        pass",
        "def __init__(self, num_user_credits_refill: int):\n    self.num_user_credits_refill = num_user_credits_refill",
        "self.num_user_credits_refill = num_user_credits_refill",
        "@abstractmethod\nasync def get_or_refill_credit(self, user_id: str) -> int:\n    \"\"\"\n        Get the current credit for the user and refill if no transaction has been made in the current cycle.\n\n        Returns:\n            int: The current credit for the user.\n        \"\"\"\n    pass",
        "'\\n        Get the current credit for the user and refill if no transaction has been made in the current cycle.\\n\\n        Returns:\\n            int: The current credit for the user.\\n        '",
        "pass",
        "@abstractmethod\nasync def spend_credits(self, user_id: str, user_credit: int, block_id: str, input_data: BlockInput, data_size: float, run_time: float) -> int:\n    \"\"\"\n        Spend the credits for the user based on the block usage.\n\n        Args:\n            user_id (str): The user ID.\n            user_credit (int): The current credit for the user.\n            block_id (str): The block ID.\n            input_data (BlockInput): The input data for the block.\n            data_size (float): The size of the data being processed.\n            run_time (float): The time taken to run the block.\n\n        Returns:\n            int: amount of credit spent\n        \"\"\"\n    pass",
        "'\\n        Spend the credits for the user based on the block usage.\\n\\n        Args:\\n            user_id (str): The user ID.\\n            user_credit (int): The current credit for the user.\\n            block_id (str): The block ID.\\n            input_data (BlockInput): The input data for the block.\\n            data_size (float): The size of the data being processed.\\n            run_time (float): The time taken to run the block.\\n\\n        Returns:\\n            int: amount of credit spent\\n        '",
        "pass",
        "@abstractmethod\nasync def top_up_credits(self, user_id: str, amount: int):\n    \"\"\"\n        Top up the credits for the user.\n\n        Args:\n            user_id (str): The user ID.\n            amount (int): The amount to top up.\n        \"\"\"\n    pass",
        "'\\n        Top up the credits for the user.\\n\\n        Args:\\n            user_id (str): The user ID.\\n            amount (int): The amount to top up.\\n        '",
        "pass",
        "class UserCredit(UserCreditBase):\n\n    async def get_or_refill_credit(self, user_id: str) -> int:\n        cur_time = self.time_now()\n        cur_month = cur_time.replace(day=1, hour=0, minute=0, second=0, microsecond=0)\n        nxt_month = cur_month.replace(month=cur_month.month + 1) if cur_month.month < 12 else cur_month.replace(year=cur_month.year + 1, month=1)\n        user_credit = await CreditTransaction.prisma().group_by(by=['userId'], sum={'amount': True}, where={'userId': user_id, 'createdAt': {'gte': cur_month, 'lt': nxt_month}, 'isActive': True})\n        if user_credit:\n            credit_sum = user_credit[0].get('_sum') or {}\n            return credit_sum.get('amount', 0)\n        key = f'MONTHLY-CREDIT-TOP-UP-{cur_month}'\n        try:\n            await CreditTransaction.prisma().create(data={'amount': self.num_user_credits_refill, 'type': CreditTransactionType.TOP_UP, 'userId': user_id, 'transactionKey': key, 'createdAt': self.time_now()})\n        except UniqueViolationError:\n            pass\n        return self.num_user_credits_refill\n\n    @staticmethod\n    def time_now():\n        return datetime.now(timezone.utc)\n\n    def _block_usage_cost(self, block: Block, input_data: BlockInput, data_size: float, run_time: float) -> tuple[int, BlockInput]:\n        block_costs = BLOCK_COSTS.get(type(block))\n        if not block_costs:\n            return (0, {})\n        for block_cost in block_costs:\n            if not self._is_cost_filter_match(block_cost.cost_filter, input_data):\n                continue\n            if block_cost.cost_type == BlockCostType.RUN:\n                return (block_cost.cost_amount, block_cost.cost_filter)\n            if block_cost.cost_type == BlockCostType.SECOND:\n                return (int(run_time * block_cost.cost_amount), block_cost.cost_filter)\n            if block_cost.cost_type == BlockCostType.BYTE:\n                return (int(data_size * block_cost.cost_amount), block_cost.cost_filter)\n        return (0, {})\n\n    def _is_cost_filter_match(self, cost_filter: BlockInput, input_data: BlockInput) -> bool:\n        \"\"\"\n        Filter rules:\n          - If costFilter is an object, then check if costFilter is the subset of inputValues\n          - Otherwise, check if costFilter is equal to inputValues.\n          - Undefined, null, and empty string are considered as equal.\n        \"\"\"\n        if not isinstance(cost_filter, dict) or not isinstance(input_data, dict):\n            return cost_filter == input_data\n        return all((not input_data.get(k) and (not v) or (input_data.get(k) and self._is_cost_filter_match(v, input_data[k])) for (k, v) in cost_filter.items()))\n\n    async def spend_credits(self, user_id: str, user_credit: int, block_id: str, input_data: BlockInput, data_size: float, run_time: float, validate_balance: bool=True) -> int:\n        block = get_block(block_id)\n        if not block:\n            raise ValueError(f'Block not found: {block_id}')\n        (cost, matching_filter) = self._block_usage_cost(block=block, input_data=input_data, data_size=data_size, run_time=run_time)\n        if cost <= 0:\n            return 0\n        if validate_balance and user_credit < cost:\n            raise ValueError(f'Insufficient credit: {user_credit} < {cost}')\n        await CreditTransaction.prisma().create(data={'userId': user_id, 'amount': -cost, 'type': CreditTransactionType.USAGE, 'blockId': block.id, 'metadata': Json({'block': block.name, 'input': matching_filter}), 'createdAt': self.time_now()})\n        return cost\n\n    async def top_up_credits(self, user_id: str, amount: int):\n        await CreditTransaction.prisma().create(data={'userId': user_id, 'amount': amount, 'type': CreditTransactionType.TOP_UP, 'createdAt': self.time_now()})",
        "async def get_or_refill_credit(self, user_id: str) -> int:\n    cur_time = self.time_now()\n    cur_month = cur_time.replace(day=1, hour=0, minute=0, second=0, microsecond=0)\n    nxt_month = cur_month.replace(month=cur_month.month + 1) if cur_month.month < 12 else cur_month.replace(year=cur_month.year + 1, month=1)\n    user_credit = await CreditTransaction.prisma().group_by(by=['userId'], sum={'amount': True}, where={'userId': user_id, 'createdAt': {'gte': cur_month, 'lt': nxt_month}, 'isActive': True})\n    if user_credit:\n        credit_sum = user_credit[0].get('_sum') or {}\n        return credit_sum.get('amount', 0)\n    key = f'MONTHLY-CREDIT-TOP-UP-{cur_month}'\n    try:\n        await CreditTransaction.prisma().create(data={'amount': self.num_user_credits_refill, 'type': CreditTransactionType.TOP_UP, 'userId': user_id, 'transactionKey': key, 'createdAt': self.time_now()})\n    except UniqueViolationError:\n        pass\n    return self.num_user_credits_refill",
        "cur_time = self.time_now()",
        "cur_month = cur_time.replace(day=1, hour=0, minute=0, second=0, microsecond=0)",
        "nxt_month = cur_month.replace(month=cur_month.month + 1) if cur_month.month < 12 else cur_month.replace(year=cur_month.year + 1, month=1)",
        "user_credit = await CreditTransaction.prisma().group_by(by=['userId'], sum={'amount': True}, where={'userId': user_id, 'createdAt': {'gte': cur_month, 'lt': nxt_month}, 'isActive': True})",
        "user_credit"
      ],
      "code": "from abc import ABC, abstractmethod\nfrom datetime import datetime, timezone\nfrom prisma import Json\nfrom prisma.enums import CreditTransactionType\nfrom prisma.errors import UniqueViolationError\nfrom prisma.models import CreditTransaction\nfrom backend.data.block import Block, BlockInput, get_block\nfrom backend.data.block_cost_config import BLOCK_COSTS\nfrom backend.data.cost import BlockCost, BlockCostType\nfrom backend.util.settings import Config\nconfig = Config()\nclass UserCreditBase(ABC):\n\n    def __init__(self, num_user_credits_refill: int):\n        self.num_user_credits_refill = num_user_credits_refill\n\n    @abstractmethod\n    async def get_or_refill_credit(self, user_id: str) -> int:\n        \"\"\"\n        Get the current credit for the user and refill if no transaction has been made in the current cycle.\n\n        Returns:\n            int: The current credit for the user.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    async def spend_credits(self, user_id: str, user_credit: int, block_id: str, input_data: BlockInput, data_size: float, run_time: float) -> int:\n        \"\"\"\n        Spend the credits for the user based on the block usage.\n\n        Args:\n            user_id (str): The user ID.\n            user_credit (int): The current credit for the user.\n            block_id (str): The block ID.\n            input_data (BlockInput): The input data for the block.\n            data_size (float): The size of the data being processed.\n            run_time (float): The time taken to run the block.\n\n        Returns:\n            int: amount of credit spent\n        \"\"\"\n        pass\n\n    @abstractmethod\n    async def top_up_credits(self, user_id: str, amount: int):\n        \"\"\"\n        Top up the credits for the user.\n\n        Args:\n            user_id (str): The user ID.\n            amount (int): The amount to top up.\n        \"\"\"\n        pass\ndef __init__(self, num_user_credits_refill: int):\n    self.num_user_credits_refill = num_user_credits_refill\nself.num_user_credits_refill = num_user_credits_refill\n@abstractmethod\nasync def get_or_refill_credit(self, user_id: str) -> int:\n    \"\"\"\n        Get the current credit for the user and refill if no transaction has been made in the current cycle.\n\n        Returns:\n            int: The current credit for the user.\n        \"\"\"\n    pass\n'\\n        Get the current credit for the user and refill if no transaction has been made in the current cycle.\\n\\n        Returns:\\n            int: The current credit for the user.\\n        '\npass\n@abstractmethod\nasync def spend_credits(self, user_id: str, user_credit: int, block_id: str, input_data: BlockInput, data_size: float, run_time: float) -> int:\n    \"\"\"\n        Spend the credits for the user based on the block usage.\n\n        Args:\n            user_id (str): The user ID.\n            user_credit (int): The current credit for the user.\n            block_id (str): The block ID.\n            input_data (BlockInput): The input data for the block.\n            data_size (float): The size of the data being processed.\n            run_time (float): The time taken to run the block.\n\n        Returns:\n            int: amount of credit spent\n        \"\"\"\n    pass\n'\\n        Spend the credits for the user based on the block usage.\\n\\n        Args:\\n            user_id (str): The user ID.\\n            user_credit (int): The current credit for the user.\\n            block_id (str): The block ID.\\n            input_data (BlockInput): The input data for the block.\\n            data_size (float): The size of the data being processed.\\n            run_time (float): The time taken to run the block.\\n\\n        Returns:\\n            int: amount of credit spent\\n        '\npass\n@abstractmethod\nasync def top_up_credits(self, user_id: str, amount: int):\n    \"\"\"\n        Top up the credits for the user.\n\n        Args:\n            user_id (str): The user ID.\n            amount (int): The amount to top up.\n        \"\"\"\n    pass\n'\\n        Top up the credits for the user.\\n\\n        Args:\\n            user_id (str): The user ID.\\n            amount (int): The amount to top up.\\n        '\npass\nclass UserCredit(UserCreditBase):\n\n    async def get_or_refill_credit(self, user_id: str) -> int:\n        cur_time = self.time_now()\n        cur_month = cur_time.replace(day=1, hour=0, minute=0, second=0, microsecond=0)\n        nxt_month = cur_month.replace(month=cur_month.month + 1) if cur_month.month < 12 else cur_month.replace(year=cur_month.year + 1, month=1)\n        user_credit = await CreditTransaction.prisma().group_by(by=['userId'], sum={'amount': True}, where={'userId': user_id, 'createdAt': {'gte': cur_month, 'lt': nxt_month}, 'isActive': True})\n        if user_credit:\n            credit_sum = user_credit[0].get('_sum') or {}\n            return credit_sum.get('amount', 0)\n        key = f'MONTHLY-CREDIT-TOP-UP-{cur_month}'\n        try:\n            await CreditTransaction.prisma().create(data={'amount': self.num_user_credits_refill, 'type': CreditTransactionType.TOP_UP, 'userId': user_id, 'transactionKey': key, 'createdAt': self.time_now()})\n        except UniqueViolationError:\n            pass\n        return self.num_user_credits_refill\n\n    @staticmethod\n    def time_now():\n        return datetime.now(timezone.utc)\n\n    def _block_usage_cost(self, block: Block, input_data: BlockInput, data_size: float, run_time: float) -> tuple[int, BlockInput]:\n        block_costs = BLOCK_COSTS.get(type(block))\n        if not block_costs:\n            return (0, {})\n        for block_cost in block_costs:\n            if not self._is_cost_filter_match(block_cost.cost_filter, input_data):\n                continue\n            if block_cost.cost_type == BlockCostType.RUN:\n                return (block_cost.cost_amount, block_cost.cost_filter)\n            if block_cost.cost_type == BlockCostType.SECOND:\n                return (int(run_time * block_cost.cost_amount), block_cost.cost_filter)\n            if block_cost.cost_type == BlockCostType.BYTE:\n                return (int(data_size * block_cost.cost_amount), block_cost.cost_filter)\n        return (0, {})\n\n    def _is_cost_filter_match(self, cost_filter: BlockInput, input_data: BlockInput) -> bool:\n        \"\"\"\n        Filter rules:\n          - If costFilter is an object, then check if costFilter is the subset of inputValues\n          - Otherwise, check if costFilter is equal to inputValues.\n          - Undefined, null, and empty string are considered as equal.\n        \"\"\"\n        if not isinstance(cost_filter, dict) or not isinstance(input_data, dict):\n            return cost_filter == input_data\n        return all((not input_data.get(k) and (not v) or (input_data.get(k) and self._is_cost_filter_match(v, input_data[k])) for (k, v) in cost_filter.items()))\n\n    async def spend_credits(self, user_id: str, user_credit: int, block_id: str, input_data: BlockInput, data_size: float, run_time: float, validate_balance: bool=True) -> int:\n        block = get_block(block_id)\n        if not block:\n            raise ValueError(f'Block not found: {block_id}')\n        (cost, matching_filter) = self._block_usage_cost(block=block, input_data=input_data, data_size=data_size, run_time=run_time)\n        if cost <= 0:\n            return 0\n        if validate_balance and user_credit < cost:\n            raise ValueError(f'Insufficient credit: {user_credit} < {cost}')\n        await CreditTransaction.prisma().create(data={'userId': user_id, 'amount': -cost, 'type': CreditTransactionType.USAGE, 'blockId': block.id, 'metadata': Json({'block': block.name, 'input': matching_filter}), 'createdAt': self.time_now()})\n        return cost\n\n    async def top_up_credits(self, user_id: str, amount: int):\n        await CreditTransaction.prisma().create(data={'userId': user_id, 'amount': amount, 'type': CreditTransactionType.TOP_UP, 'createdAt': self.time_now()})\nasync def get_or_refill_credit(self, user_id: str) -> int:\n    cur_time = self.time_now()\n    cur_month = cur_time.replace(day=1, hour=0, minute=0, second=0, microsecond=0)\n    nxt_month = cur_month.replace(month=cur_month.month + 1) if cur_month.month < 12 else cur_month.replace(year=cur_month.year + 1, month=1)\n    user_credit = await CreditTransaction.prisma().group_by(by=['userId'], sum={'amount': True}, where={'userId': user_id, 'createdAt': {'gte': cur_month, 'lt': nxt_month}, 'isActive': True})\n    if user_credit:\n        credit_sum = user_credit[0].get('_sum') or {}\n        return credit_sum.get('amount', 0)\n    key = f'MONTHLY-CREDIT-TOP-UP-{cur_month}'\n    try:\n        await CreditTransaction.prisma().create(data={'amount': self.num_user_credits_refill, 'type': CreditTransactionType.TOP_UP, 'userId': user_id, 'transactionKey': key, 'createdAt': self.time_now()})\n    except UniqueViolationError:\n        pass\n    return self.num_user_credits_refill\ncur_time = self.time_now()\ncur_month = cur_time.replace(day=1, hour=0, minute=0, second=0, microsecond=0)\nnxt_month = cur_month.replace(month=cur_month.month + 1) if cur_month.month < 12 else cur_month.replace(year=cur_month.year + 1, month=1)\nuser_credit = await CreditTransaction.prisma().group_by(by=['userId'], sum={'amount': True}, where={'userId': user_id, 'createdAt': {'gte': cur_month, 'lt': nxt_month}, 'isActive': True})\nuser_credit"
    },
    {
      "id": "n1",
      "type": "block",
      "statements": [
        "credit_sum = user_credit[0].get('_sum') or {}",
        "return credit_sum.get('amount', 0)"
      ],
      "code": "credit_sum = user_credit[0].get('_sum') or {}\nreturn credit_sum.get('amount', 0)"
    },
    {
      "id": "n2",
      "type": "block",
      "statements": [],
      "code": "\nkey = f'MONTHLY-CREDIT-TOP-UP-{cur_month}'\ntry:\n    await CreditTransaction.prisma().create(data={'amount': self.num_user_credits_refill, 'type': CreditTransactionType.TOP_UP, 'userId': user_id, 'transactionKey': key, 'createdAt': self.time_now()})\nexcept UniqueViolationError:\n    pass\nawait CreditTransaction.prisma().create(data={'amount': self.num_user_credits_refill, 'type': CreditTransactionType.TOP_UP, 'userId': user_id, 'transactionKey': key, 'createdAt': self.time_now()})\npass\nreturn self.num_user_credits_refill"
    },
    {
      "id": "n3",
      "type": "block",
      "statements": [
        "@staticmethod\ndef time_now():\n    return datetime.now(timezone.utc)",
        "return datetime.now(timezone.utc)"
      ],
      "code": "@staticmethod\ndef time_now():\n    return datetime.now(timezone.utc)\nreturn datetime.now(timezone.utc)"
    },
    {
      "id": "n4",
      "type": "block",
      "statements": [
        "def _block_usage_cost(self, block: Block, input_data: BlockInput, data_size: float, run_time: float) -> tuple[int, BlockInput]:\n    block_costs = BLOCK_COSTS.get(type(block))\n    if not block_costs:\n        return (0, {})\n    for block_cost in block_costs:\n        if not self._is_cost_filter_match(block_cost.cost_filter, input_data):\n            continue\n        if block_cost.cost_type == BlockCostType.RUN:\n            return (block_cost.cost_amount, block_cost.cost_filter)\n        if block_cost.cost_type == BlockCostType.SECOND:\n            return (int(run_time * block_cost.cost_amount), block_cost.cost_filter)\n        if block_cost.cost_type == BlockCostType.BYTE:\n            return (int(data_size * block_cost.cost_amount), block_cost.cost_filter)\n    return (0, {})",
        "block_costs = BLOCK_COSTS.get(type(block))",
        "not block_costs"
      ],
      "code": "def _block_usage_cost(self, block: Block, input_data: BlockInput, data_size: float, run_time: float) -> tuple[int, BlockInput]:\n    block_costs = BLOCK_COSTS.get(type(block))\n    if not block_costs:\n        return (0, {})\n    for block_cost in block_costs:\n        if not self._is_cost_filter_match(block_cost.cost_filter, input_data):\n            continue\n        if block_cost.cost_type == BlockCostType.RUN:\n            return (block_cost.cost_amount, block_cost.cost_filter)\n        if block_cost.cost_type == BlockCostType.SECOND:\n            return (int(run_time * block_cost.cost_amount), block_cost.cost_filter)\n        if block_cost.cost_type == BlockCostType.BYTE:\n            return (int(data_size * block_cost.cost_amount), block_cost.cost_filter)\n    return (0, {})\nblock_costs = BLOCK_COSTS.get(type(block))\nnot block_costs"
    },
    {
      "id": "n5",
      "type": "block",
      "statements": [
        "return (0, {})"
      ],
      "code": "return (0, {})"
    },
    {
      "id": "n6",
      "type": "block",
      "statements": [],
      "code": "\n"
    },
    {
      "id": "n7",
      "type": "block",
      "statements": [
        "block_cost",
        "block_costs"
      ],
      "code": "block_cost\nblock_costs"
    },
    {
      "id": "n8",
      "type": "block",
      "statements": [
        "not self._is_cost_filter_match(block_cost.cost_filter, input_data)"
      ],
      "code": "not self._is_cost_filter_match(block_cost.cost_filter, input_data)"
    },
    {
      "id": "n9",
      "type": "block",
      "statements": [
        "return (0, {})"
      ],
      "code": "return (0, {})"
    },
    {
      "id": "n10",
      "type": "block",
      "statements": [
        "continue"
      ],
      "code": "continue"
    },
    {
      "id": "n11",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n12",
      "type": "block",
      "statements": [
        "block_cost.cost_type Eq BlockCostType.RUN"
      ],
      "code": "block_cost.cost_type Eq BlockCostType.RUN"
    },
    {
      "id": "n13",
      "type": "block",
      "statements": [
        "return (block_cost.cost_amount, block_cost.cost_filter)"
      ],
      "code": "return (block_cost.cost_amount, block_cost.cost_filter)"
    },
    {
      "id": "n14",
      "type": "block",
      "statements": [],
      "code": "\nblock_cost.cost_type Eq BlockCostType.SECOND"
    },
    {
      "id": "n15",
      "type": "block",
      "statements": [
        "return (int(run_time * block_cost.cost_amount), block_cost.cost_filter)"
      ],
      "code": "return (int(run_time * block_cost.cost_amount), block_cost.cost_filter)"
    },
    {
      "id": "n16",
      "type": "block",
      "statements": [],
      "code": "\nblock_cost.cost_type Eq BlockCostType.BYTE"
    },
    {
      "id": "n17",
      "type": "block",
      "statements": [
        "return (int(data_size * block_cost.cost_amount), block_cost.cost_filter)"
      ],
      "code": "return (int(data_size * block_cost.cost_amount), block_cost.cost_filter)"
    },
    {
      "id": "n18",
      "type": "block",
      "statements": [],
      "code": "\n"
    },
    {
      "id": "n19",
      "type": "block",
      "statements": [
        "def _is_cost_filter_match(self, cost_filter: BlockInput, input_data: BlockInput) -> bool:\n    \"\"\"\n        Filter rules:\n          - If costFilter is an object, then check if costFilter is the subset of inputValues\n          - Otherwise, check if costFilter is equal to inputValues.\n          - Undefined, null, and empty string are considered as equal.\n        \"\"\"\n    if not isinstance(cost_filter, dict) or not isinstance(input_data, dict):\n        return cost_filter == input_data\n    return all((not input_data.get(k) and (not v) or (input_data.get(k) and self._is_cost_filter_match(v, input_data[k])) for (k, v) in cost_filter.items()))",
        "'\\n        Filter rules:\\n          - If costFilter is an object, then check if costFilter is the subset of inputValues\\n          - Otherwise, check if costFilter is equal to inputValues.\\n          - Undefined, null, and empty string are considered as equal.\\n        '",
        "not isinstance(cost_filter, dict) or not isinstance(input_data, dict)"
      ],
      "code": "def _is_cost_filter_match(self, cost_filter: BlockInput, input_data: BlockInput) -> bool:\n    \"\"\"\n        Filter rules:\n          - If costFilter is an object, then check if costFilter is the subset of inputValues\n          - Otherwise, check if costFilter is equal to inputValues.\n          - Undefined, null, and empty string are considered as equal.\n        \"\"\"\n    if not isinstance(cost_filter, dict) or not isinstance(input_data, dict):\n        return cost_filter == input_data\n    return all((not input_data.get(k) and (not v) or (input_data.get(k) and self._is_cost_filter_match(v, input_data[k])) for (k, v) in cost_filter.items()))\n'\\n        Filter rules:\\n          - If costFilter is an object, then check if costFilter is the subset of inputValues\\n          - Otherwise, check if costFilter is equal to inputValues.\\n          - Undefined, null, and empty string are considered as equal.\\n        '\nnot isinstance(cost_filter, dict) or not isinstance(input_data, dict)"
    },
    {
      "id": "n20",
      "type": "block",
      "statements": [
        "return cost_filter == input_data"
      ],
      "code": "return cost_filter == input_data"
    },
    {
      "id": "n21",
      "type": "block",
      "statements": [],
      "code": "\nreturn all((not input_data.get(k) and (not v) or (input_data.get(k) and self._is_cost_filter_match(v, input_data[k])) for (k, v) in cost_filter.items()))"
    },
    {
      "id": "n22",
      "type": "block",
      "statements": [
        "async def spend_credits(self, user_id: str, user_credit: int, block_id: str, input_data: BlockInput, data_size: float, run_time: float, validate_balance: bool=True) -> int:\n    block = get_block(block_id)\n    if not block:\n        raise ValueError(f'Block not found: {block_id}')\n    (cost, matching_filter) = self._block_usage_cost(block=block, input_data=input_data, data_size=data_size, run_time=run_time)\n    if cost <= 0:\n        return 0\n    if validate_balance and user_credit < cost:\n        raise ValueError(f'Insufficient credit: {user_credit} < {cost}')\n    await CreditTransaction.prisma().create(data={'userId': user_id, 'amount': -cost, 'type': CreditTransactionType.USAGE, 'blockId': block.id, 'metadata': Json({'block': block.name, 'input': matching_filter}), 'createdAt': self.time_now()})\n    return cost",
        "block = get_block(block_id)",
        "not block"
      ],
      "code": "async def spend_credits(self, user_id: str, user_credit: int, block_id: str, input_data: BlockInput, data_size: float, run_time: float, validate_balance: bool=True) -> int:\n    block = get_block(block_id)\n    if not block:\n        raise ValueError(f'Block not found: {block_id}')\n    (cost, matching_filter) = self._block_usage_cost(block=block, input_data=input_data, data_size=data_size, run_time=run_time)\n    if cost <= 0:\n        return 0\n    if validate_balance and user_credit < cost:\n        raise ValueError(f'Insufficient credit: {user_credit} < {cost}')\n    await CreditTransaction.prisma().create(data={'userId': user_id, 'amount': -cost, 'type': CreditTransactionType.USAGE, 'blockId': block.id, 'metadata': Json({'block': block.name, 'input': matching_filter}), 'createdAt': self.time_now()})\n    return cost\nblock = get_block(block_id)\nnot block"
    },
    {
      "id": "n23",
      "type": "block",
      "statements": [
        "raise ValueError(f'Block not found: {block_id}')"
      ],
      "code": "raise ValueError(f'Block not found: {block_id}')"
    },
    {
      "id": "n24",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n25",
      "type": "block",
      "statements": [
        "(cost, matching_filter) = self._block_usage_cost(block=block, input_data=input_data, data_size=data_size, run_time=run_time)",
        "cost LtE 0"
      ],
      "code": "(cost, matching_filter) = self._block_usage_cost(block=block, input_data=input_data, data_size=data_size, run_time=run_time)\ncost LtE 0"
    },
    {
      "id": "n26",
      "type": "block",
      "statements": [
        "return 0"
      ],
      "code": "return 0"
    },
    {
      "id": "n27",
      "type": "block",
      "statements": [],
      "code": "\nvalidate_balance and user_credit < cost"
    },
    {
      "id": "n28",
      "type": "block",
      "statements": [
        "raise ValueError(f'Insufficient credit: {user_credit} < {cost}')"
      ],
      "code": "raise ValueError(f'Insufficient credit: {user_credit} < {cost}')"
    },
    {
      "id": "n29",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n30",
      "type": "block",
      "statements": [
        "await CreditTransaction.prisma().create(data={'userId': user_id, 'amount': -cost, 'type': CreditTransactionType.USAGE, 'blockId': block.id, 'metadata': Json({'block': block.name, 'input': matching_filter}), 'createdAt': self.time_now()})",
        "return cost"
      ],
      "code": "await CreditTransaction.prisma().create(data={'userId': user_id, 'amount': -cost, 'type': CreditTransactionType.USAGE, 'blockId': block.id, 'metadata': Json({'block': block.name, 'input': matching_filter}), 'createdAt': self.time_now()})\nreturn cost"
    },
    {
      "id": "n31",
      "type": "block",
      "statements": [
        "async def top_up_credits(self, user_id: str, amount: int):\n    await CreditTransaction.prisma().create(data={'userId': user_id, 'amount': amount, 'type': CreditTransactionType.TOP_UP, 'createdAt': self.time_now()})",
        "await CreditTransaction.prisma().create(data={'userId': user_id, 'amount': amount, 'type': CreditTransactionType.TOP_UP, 'createdAt': self.time_now()})",
        "class DisabledUserCredit(UserCreditBase):\n\n    async def get_or_refill_credit(self, *args, **kwargs) -> int:\n        return 0\n\n    async def spend_credits(self, *args, **kwargs) -> int:\n        return 0\n\n    async def top_up_credits(self, *args, **kwargs):\n        pass",
        "async def get_or_refill_credit(self, *args, **kwargs) -> int:\n    return 0",
        "return 0"
      ],
      "code": "async def top_up_credits(self, user_id: str, amount: int):\n    await CreditTransaction.prisma().create(data={'userId': user_id, 'amount': amount, 'type': CreditTransactionType.TOP_UP, 'createdAt': self.time_now()})\nawait CreditTransaction.prisma().create(data={'userId': user_id, 'amount': amount, 'type': CreditTransactionType.TOP_UP, 'createdAt': self.time_now()})\nclass DisabledUserCredit(UserCreditBase):\n\n    async def get_or_refill_credit(self, *args, **kwargs) -> int:\n        return 0\n\n    async def spend_credits(self, *args, **kwargs) -> int:\n        return 0\n\n    async def top_up_credits(self, *args, **kwargs):\n        pass\nasync def get_or_refill_credit(self, *args, **kwargs) -> int:\n    return 0\nreturn 0"
    },
    {
      "id": "n32",
      "type": "block",
      "statements": [
        "async def spend_credits(self, *args, **kwargs) -> int:\n    return 0",
        "return 0"
      ],
      "code": "async def spend_credits(self, *args, **kwargs) -> int:\n    return 0\nreturn 0"
    },
    {
      "id": "n33",
      "type": "block",
      "statements": [
        "async def top_up_credits(self, *args, **kwargs):\n    pass",
        "pass",
        "def get_user_credit_model() -> UserCreditBase:\n    if config.enable_credit.lower() == 'true':\n        return UserCredit(config.num_user_credits_refill)\n    else:\n        return DisabledUserCredit(0)",
        "config.enable_credit.lower() Eq 'true'"
      ],
      "code": "async def top_up_credits(self, *args, **kwargs):\n    pass\npass\ndef get_user_credit_model() -> UserCreditBase:\n    if config.enable_credit.lower() == 'true':\n        return UserCredit(config.num_user_credits_refill)\n    else:\n        return DisabledUserCredit(0)\nconfig.enable_credit.lower() Eq 'true'"
    },
    {
      "id": "n34",
      "type": "block",
      "statements": [
        "return UserCredit(config.num_user_credits_refill)"
      ],
      "code": "return UserCredit(config.num_user_credits_refill)"
    },
    {
      "id": "n35",
      "type": "block",
      "statements": [
        "return DisabledUserCredit(0)"
      ],
      "code": "return DisabledUserCredit(0)"
    },
    {
      "id": "n36",
      "type": "block",
      "statements": [
        "def get_block_costs() -> dict[str, list[BlockCost]]:\n    return {block().id: costs for (block, costs) in BLOCK_COSTS.items()}",
        "return {block().id: costs for (block, costs) in BLOCK_COSTS.items()}"
      ],
      "code": "def get_block_costs() -> dict[str, list[BlockCost]]:\n    return {block().id: costs for (block, costs) in BLOCK_COSTS.items()}\nreturn {block().id: costs for (block, costs) in BLOCK_COSTS.items()}"
    }
  ],
  "edges": [
    {
      "source": "n6",
      "target": "n7"
    },
    {
      "source": "n14",
      "target": "n15"
    },
    {
      "source": "n0",
      "target": "n1"
    },
    {
      "source": "n23",
      "target": "n25"
    },
    {
      "source": "n18",
      "target": "n7"
    },
    {
      "source": "n22",
      "target": "n23"
    },
    {
      "source": "n19",
      "target": "n21"
    },
    {
      "source": "n16",
      "target": "n17"
    },
    {
      "source": "n16",
      "target": "n18"
    },
    {
      "source": "n33",
      "target": "n35"
    },
    {
      "source": "n19",
      "target": "n20"
    },
    {
      "source": "n4",
      "target": "n6"
    },
    {
      "source": "n4",
      "target": "n5"
    },
    {
      "source": "n12",
      "target": "n13"
    },
    {
      "source": "n24",
      "target": "n25"
    },
    {
      "source": "n7",
      "target": "n8"
    },
    {
      "source": "n29",
      "target": "n30"
    },
    {
      "source": "n12",
      "target": "n14"
    },
    {
      "source": "n14",
      "target": "n16"
    },
    {
      "source": "n28",
      "target": "n30"
    },
    {
      "source": "n10",
      "target": "n12"
    },
    {
      "source": "n11",
      "target": "n12"
    },
    {
      "source": "n8",
      "target": "n11"
    },
    {
      "source": "n7",
      "target": "n9"
    },
    {
      "source": "n25",
      "target": "n26"
    },
    {
      "source": "n27",
      "target": "n29"
    },
    {
      "source": "n8",
      "target": "n10"
    },
    {
      "source": "n27",
      "target": "n28"
    },
    {
      "source": "n33",
      "target": "n34"
    },
    {
      "source": "n25",
      "target": "n27"
    },
    {
      "source": "n22",
      "target": "n24"
    },
    {
      "source": "n0",
      "target": "n2"
    }
  ]
}