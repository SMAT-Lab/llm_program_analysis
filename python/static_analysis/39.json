{
  "nodes": [
    {
      "id": "n0",
      "type": "block",
      "statements": [
        "import asyncio",
        "from typing import Literal",
        "import aiohttp",
        "import discord",
        "from pydantic import SecretStr",
        "from backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema",
        "from backend.data.model import APIKeyCredentials, CredentialsField, CredentialsMetaInput, SchemaField",
        "from backend.integrations.providers import ProviderName",
        "DiscordCredentials = CredentialsMetaInput[Literal[ProviderName.DISCORD], Literal['api_key']]",
        "def DiscordCredentialsField() -> DiscordCredentials:\n    return CredentialsField(description='Discord bot token')",
        "return CredentialsField(description='Discord bot token')"
      ],
      "code": "import asyncio\nfrom typing import Literal\nimport aiohttp\nimport discord\nfrom pydantic import SecretStr\nfrom backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema\nfrom backend.data.model import APIKeyCredentials, CredentialsField, CredentialsMetaInput, SchemaField\nfrom backend.integrations.providers import ProviderName\nDiscordCredentials = CredentialsMetaInput[Literal[ProviderName.DISCORD], Literal['api_key']]\ndef DiscordCredentialsField() -> DiscordCredentials:\n    return CredentialsField(description='Discord bot token')\nreturn CredentialsField(description='Discord bot token')"
    },
    {
      "id": "n1",
      "type": "block",
      "statements": [
        "TEST_CREDENTIALS = APIKeyCredentials(id='01234567-89ab-cdef-0123-456789abcdef', provider='discord', api_key=SecretStr('test_api_key'), title='Mock Discord API key', expires_at=None)",
        "TEST_CREDENTIALS_INPUT = {'provider': TEST_CREDENTIALS.provider, 'id': TEST_CREDENTIALS.id, 'type': TEST_CREDENTIALS.type, 'title': TEST_CREDENTIALS.type}",
        "class ReadDiscordMessagesBlock(Block):\n\n    class Input(BlockSchema):\n        credentials: DiscordCredentials = DiscordCredentialsField()\n\n    class Output(BlockSchema):\n        message_content: str = SchemaField(description='The content of the message received')\n        channel_name: str = SchemaField(description='The name of the channel the message was received from')\n        username: str = SchemaField(description='The username of the user who sent the message')\n\n    def __init__(self):\n        super().__init__(id='df06086a-d5ac-4abb-9996-2ad0acb2eff7', input_schema=ReadDiscordMessagesBlock.Input, output_schema=ReadDiscordMessagesBlock.Output, description='Reads messages from a Discord channel using a bot token.', categories={BlockCategory.SOCIAL}, test_input={'continuous_read': False, 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('message_content', 'Hello!\\n\\nFile from user: example.txt\\nContent: This is the content of the file.'), ('channel_name', 'general'), ('username', 'test_user')], test_mock={'run_bot': lambda token: asyncio.Future()})\n\n    async def run_bot(self, token: SecretStr):\n        intents = discord.Intents.default()\n        intents.message_content = True\n        client = discord.Client(intents=intents)\n        self.output_data = None\n        self.channel_name = None\n        self.username = None\n\n        @client.event\n        async def on_ready():\n            print(f'Logged in as {client.user}')\n\n        @client.event\n        async def on_message(message):\n            if message.author == client.user:\n                return\n            self.output_data = message.content\n            self.channel_name = message.channel.name\n            self.username = message.author.name\n            if message.attachments:\n                attachment = message.attachments[0]\n                if attachment.filename.endswith(('.txt', '.py')):\n                    async with aiohttp.ClientSession() as session:\n                        async with session.get(attachment.url) as response:\n                            file_content = await response.text()\n                            self.output_data += f'\\n\\nFile from user: {attachment.filename}\\nContent: {file_content}'\n            await client.close()\n        await client.start(token.get_secret_value())\n\n    def run(self, input_data: Input, *, credentials: APIKeyCredentials, **kwargs) -> BlockOutput:\n        while True:\n            for (output_name, output_value) in self.__run(input_data, credentials):\n                yield (output_name, output_value)\n            break\n\n    def __run(self, input_data: Input, credentials: APIKeyCredentials) -> BlockOutput:\n        try:\n            loop = asyncio.get_event_loop()\n            future = self.run_bot(credentials.api_key)\n            if isinstance(future, asyncio.Future):\n                future.set_result({'output_data': 'Hello!\\n\\nFile from user: example.txt\\nContent: This is the content of the file.', 'channel_name': 'general', 'username': 'test_user'})\n            result = loop.run_until_complete(future)\n            if isinstance(result, dict):\n                self.output_data = result.get('output_data')\n                self.channel_name = result.get('channel_name')\n                self.username = result.get('username')\n            if self.output_data is None or self.channel_name is None or self.username is None:\n                raise ValueError('No message, channel name, or username received.')\n            yield ('message_content', self.output_data)\n            yield ('channel_name', self.channel_name)\n            yield ('username', self.username)\n        except discord.errors.LoginFailure as login_err:\n            raise ValueError(f'Login error occurred: {login_err}')\n        except Exception as e:\n            raise ValueError(f'An error occurred: {e}')",
        "class Input(BlockSchema):\n    credentials: DiscordCredentials = DiscordCredentialsField()",
        "credentials: DiscordCredentials = DiscordCredentialsField()",
        "class Output(BlockSchema):\n    message_content: str = SchemaField(description='The content of the message received')\n    channel_name: str = SchemaField(description='The name of the channel the message was received from')\n    username: str = SchemaField(description='The username of the user who sent the message')",
        "message_content: str = SchemaField(description='The content of the message received')",
        "channel_name: str = SchemaField(description='The name of the channel the message was received from')",
        "username: str = SchemaField(description='The username of the user who sent the message')",
        "def __init__(self):\n    super().__init__(id='df06086a-d5ac-4abb-9996-2ad0acb2eff7', input_schema=ReadDiscordMessagesBlock.Input, output_schema=ReadDiscordMessagesBlock.Output, description='Reads messages from a Discord channel using a bot token.', categories={BlockCategory.SOCIAL}, test_input={'continuous_read': False, 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('message_content', 'Hello!\\n\\nFile from user: example.txt\\nContent: This is the content of the file.'), ('channel_name', 'general'), ('username', 'test_user')], test_mock={'run_bot': lambda token: asyncio.Future()})",
        "super().__init__()",
        "async def run_bot(self, token: SecretStr):\n    intents = discord.Intents.default()\n    intents.message_content = True\n    client = discord.Client(intents=intents)\n    self.output_data = None\n    self.channel_name = None\n    self.username = None\n\n    @client.event\n    async def on_ready():\n        print(f'Logged in as {client.user}')\n\n    @client.event\n    async def on_message(message):\n        if message.author == client.user:\n            return\n        self.output_data = message.content\n        self.channel_name = message.channel.name\n        self.username = message.author.name\n        if message.attachments:\n            attachment = message.attachments[0]\n            if attachment.filename.endswith(('.txt', '.py')):\n                async with aiohttp.ClientSession() as session:\n                    async with session.get(attachment.url) as response:\n                        file_content = await response.text()\n                        self.output_data += f'\\n\\nFile from user: {attachment.filename}\\nContent: {file_content}'\n        await client.close()\n    await client.start(token.get_secret_value())",
        "intents = discord.Intents.default()",
        "intents.message_content = True",
        "client = discord.Client(intents=intents)",
        "self.output_data = None",
        "self.channel_name = None",
        "self.username = None",
        "@client.event\nasync def on_ready():\n    print(f'Logged in as {client.user}')",
        "print(f'Logged in as {client.user}')",
        "@client.event\nasync def on_message(message):\n    if message.author == client.user:\n        return\n    self.output_data = message.content\n    self.channel_name = message.channel.name\n    self.username = message.author.name\n    if message.attachments:\n        attachment = message.attachments[0]\n        if attachment.filename.endswith(('.txt', '.py')):\n            async with aiohttp.ClientSession() as session:\n                async with session.get(attachment.url) as response:\n                    file_content = await response.text()\n                    self.output_data += f'\\n\\nFile from user: {attachment.filename}\\nContent: {file_content}'\n    await client.close()",
        "message.author Eq client.user"
      ],
      "code": "TEST_CREDENTIALS = APIKeyCredentials(id='01234567-89ab-cdef-0123-456789abcdef', provider='discord', api_key=SecretStr('test_api_key'), title='Mock Discord API key', expires_at=None)\nTEST_CREDENTIALS_INPUT = {'provider': TEST_CREDENTIALS.provider, 'id': TEST_CREDENTIALS.id, 'type': TEST_CREDENTIALS.type, 'title': TEST_CREDENTIALS.type}\nclass ReadDiscordMessagesBlock(Block):\n\n    class Input(BlockSchema):\n        credentials: DiscordCredentials = DiscordCredentialsField()\n\n    class Output(BlockSchema):\n        message_content: str = SchemaField(description='The content of the message received')\n        channel_name: str = SchemaField(description='The name of the channel the message was received from')\n        username: str = SchemaField(description='The username of the user who sent the message')\n\n    def __init__(self):\n        super().__init__(id='df06086a-d5ac-4abb-9996-2ad0acb2eff7', input_schema=ReadDiscordMessagesBlock.Input, output_schema=ReadDiscordMessagesBlock.Output, description='Reads messages from a Discord channel using a bot token.', categories={BlockCategory.SOCIAL}, test_input={'continuous_read': False, 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('message_content', 'Hello!\\n\\nFile from user: example.txt\\nContent: This is the content of the file.'), ('channel_name', 'general'), ('username', 'test_user')], test_mock={'run_bot': lambda token: asyncio.Future()})\n\n    async def run_bot(self, token: SecretStr):\n        intents = discord.Intents.default()\n        intents.message_content = True\n        client = discord.Client(intents=intents)\n        self.output_data = None\n        self.channel_name = None\n        self.username = None\n\n        @client.event\n        async def on_ready():\n            print(f'Logged in as {client.user}')\n\n        @client.event\n        async def on_message(message):\n            if message.author == client.user:\n                return\n            self.output_data = message.content\n            self.channel_name = message.channel.name\n            self.username = message.author.name\n            if message.attachments:\n                attachment = message.attachments[0]\n                if attachment.filename.endswith(('.txt', '.py')):\n                    async with aiohttp.ClientSession() as session:\n                        async with session.get(attachment.url) as response:\n                            file_content = await response.text()\n                            self.output_data += f'\\n\\nFile from user: {attachment.filename}\\nContent: {file_content}'\n            await client.close()\n        await client.start(token.get_secret_value())\n\n    def run(self, input_data: Input, *, credentials: APIKeyCredentials, **kwargs) -> BlockOutput:\n        while True:\n            for (output_name, output_value) in self.__run(input_data, credentials):\n                yield (output_name, output_value)\n            break\n\n    def __run(self, input_data: Input, credentials: APIKeyCredentials) -> BlockOutput:\n        try:\n            loop = asyncio.get_event_loop()\n            future = self.run_bot(credentials.api_key)\n            if isinstance(future, asyncio.Future):\n                future.set_result({'output_data': 'Hello!\\n\\nFile from user: example.txt\\nContent: This is the content of the file.', 'channel_name': 'general', 'username': 'test_user'})\n            result = loop.run_until_complete(future)\n            if isinstance(result, dict):\n                self.output_data = result.get('output_data')\n                self.channel_name = result.get('channel_name')\n                self.username = result.get('username')\n            if self.output_data is None or self.channel_name is None or self.username is None:\n                raise ValueError('No message, channel name, or username received.')\n            yield ('message_content', self.output_data)\n            yield ('channel_name', self.channel_name)\n            yield ('username', self.username)\n        except discord.errors.LoginFailure as login_err:\n            raise ValueError(f'Login error occurred: {login_err}')\n        except Exception as e:\n            raise ValueError(f'An error occurred: {e}')\nclass Input(BlockSchema):\n    credentials: DiscordCredentials = DiscordCredentialsField()\ncredentials: DiscordCredentials = DiscordCredentialsField()\nclass Output(BlockSchema):\n    message_content: str = SchemaField(description='The content of the message received')\n    channel_name: str = SchemaField(description='The name of the channel the message was received from')\n    username: str = SchemaField(description='The username of the user who sent the message')\nmessage_content: str = SchemaField(description='The content of the message received')\nchannel_name: str = SchemaField(description='The name of the channel the message was received from')\nusername: str = SchemaField(description='The username of the user who sent the message')\ndef __init__(self):\n    super().__init__(id='df06086a-d5ac-4abb-9996-2ad0acb2eff7', input_schema=ReadDiscordMessagesBlock.Input, output_schema=ReadDiscordMessagesBlock.Output, description='Reads messages from a Discord channel using a bot token.', categories={BlockCategory.SOCIAL}, test_input={'continuous_read': False, 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('message_content', 'Hello!\\n\\nFile from user: example.txt\\nContent: This is the content of the file.'), ('channel_name', 'general'), ('username', 'test_user')], test_mock={'run_bot': lambda token: asyncio.Future()})\nsuper().__init__()\nasync def run_bot(self, token: SecretStr):\n    intents = discord.Intents.default()\n    intents.message_content = True\n    client = discord.Client(intents=intents)\n    self.output_data = None\n    self.channel_name = None\n    self.username = None\n\n    @client.event\n    async def on_ready():\n        print(f'Logged in as {client.user}')\n\n    @client.event\n    async def on_message(message):\n        if message.author == client.user:\n            return\n        self.output_data = message.content\n        self.channel_name = message.channel.name\n        self.username = message.author.name\n        if message.attachments:\n            attachment = message.attachments[0]\n            if attachment.filename.endswith(('.txt', '.py')):\n                async with aiohttp.ClientSession() as session:\n                    async with session.get(attachment.url) as response:\n                        file_content = await response.text()\n                        self.output_data += f'\\n\\nFile from user: {attachment.filename}\\nContent: {file_content}'\n        await client.close()\n    await client.start(token.get_secret_value())\nintents = discord.Intents.default()\nintents.message_content = True\nclient = discord.Client(intents=intents)\nself.output_data = None\nself.channel_name = None\nself.username = None\n@client.event\nasync def on_ready():\n    print(f'Logged in as {client.user}')\nprint(f'Logged in as {client.user}')\n@client.event\nasync def on_message(message):\n    if message.author == client.user:\n        return\n    self.output_data = message.content\n    self.channel_name = message.channel.name\n    self.username = message.author.name\n    if message.attachments:\n        attachment = message.attachments[0]\n        if attachment.filename.endswith(('.txt', '.py')):\n            async with aiohttp.ClientSession() as session:\n                async with session.get(attachment.url) as response:\n                    file_content = await response.text()\n                    self.output_data += f'\\n\\nFile from user: {attachment.filename}\\nContent: {file_content}'\n    await client.close()\nmessage.author Eq client.user"
    },
    {
      "id": "n2",
      "type": "block",
      "statements": [
        "return"
      ],
      "code": "return"
    },
    {
      "id": "n3",
      "type": "block",
      "statements": [],
      "code": "\nself.output_data = message.content\nself.channel_name = message.channel.name\nself.username = message.author.name\nmessage.attachments"
    },
    {
      "id": "n4",
      "type": "block",
      "statements": [
        "attachment = message.attachments[0]",
        "attachment.filename.endswith(('.txt', '.py'))"
      ],
      "code": "attachment = message.attachments[0]\nattachment.filename.endswith(('.txt', '.py'))"
    },
    {
      "id": "n5",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n6",
      "type": "block",
      "statements": [
        "await client.close()",
        "await client.start(token.get_secret_value())",
        "def run(self, input_data: Input, *, credentials: APIKeyCredentials, **kwargs) -> BlockOutput:\n    while True:\n        for (output_name, output_value) in self.__run(input_data, credentials):\n            yield (output_name, output_value)\n        break"
      ],
      "code": "await client.close()\nawait client.start(token.get_secret_value())\ndef run(self, input_data: Input, *, credentials: APIKeyCredentials, **kwargs) -> BlockOutput:\n    while True:\n        for (output_name, output_value) in self.__run(input_data, credentials):\n            yield (output_name, output_value)\n        break"
    },
    {
      "id": "n7",
      "type": "block",
      "statements": [
        "async with aiohttp.ClientSession() as session:\n    async with session.get(attachment.url) as response:\n        file_content = await response.text()\n        self.output_data += f'\\n\\nFile from user: {attachment.filename}\\nContent: {file_content}'",
        "async with session.get(attachment.url) as response:\n    file_content = await response.text()\n    self.output_data += f'\\n\\nFile from user: {attachment.filename}\\nContent: {file_content}'",
        "file_content = await response.text()",
        "self.output_data += f'\\n\\nFile from user: {attachment.filename}\\nContent: {file_content}'"
      ],
      "code": "async with aiohttp.ClientSession() as session:\n    async with session.get(attachment.url) as response:\n        file_content = await response.text()\n        self.output_data += f'\\n\\nFile from user: {attachment.filename}\\nContent: {file_content}'\nasync with session.get(attachment.url) as response:\n    file_content = await response.text()\n    self.output_data += f'\\n\\nFile from user: {attachment.filename}\\nContent: {file_content}'\nfile_content = await response.text()\nself.output_data += f'\\n\\nFile from user: {attachment.filename}\\nContent: {file_content}'"
    },
    {
      "id": "n8",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n9",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n10",
      "type": "block",
      "statements": [
        "True"
      ],
      "code": "True"
    },
    {
      "id": "n11",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n12",
      "type": "block",
      "statements": [
        "def __run(self, input_data: Input, credentials: APIKeyCredentials) -> BlockOutput:\n    try:\n        loop = asyncio.get_event_loop()\n        future = self.run_bot(credentials.api_key)\n        if isinstance(future, asyncio.Future):\n            future.set_result({'output_data': 'Hello!\\n\\nFile from user: example.txt\\nContent: This is the content of the file.', 'channel_name': 'general', 'username': 'test_user'})\n        result = loop.run_until_complete(future)\n        if isinstance(result, dict):\n            self.output_data = result.get('output_data')\n            self.channel_name = result.get('channel_name')\n            self.username = result.get('username')\n        if self.output_data is None or self.channel_name is None or self.username is None:\n            raise ValueError('No message, channel name, or username received.')\n        yield ('message_content', self.output_data)\n        yield ('channel_name', self.channel_name)\n        yield ('username', self.username)\n    except discord.errors.LoginFailure as login_err:\n        raise ValueError(f'Login error occurred: {login_err}')\n    except Exception as e:\n        raise ValueError(f'An error occurred: {e}')",
        "try:\n    loop = asyncio.get_event_loop()\n    future = self.run_bot(credentials.api_key)\n    if isinstance(future, asyncio.Future):\n        future.set_result({'output_data': 'Hello!\\n\\nFile from user: example.txt\\nContent: This is the content of the file.', 'channel_name': 'general', 'username': 'test_user'})\n    result = loop.run_until_complete(future)\n    if isinstance(result, dict):\n        self.output_data = result.get('output_data')\n        self.channel_name = result.get('channel_name')\n        self.username = result.get('username')\n    if self.output_data is None or self.channel_name is None or self.username is None:\n        raise ValueError('No message, channel name, or username received.')\n    yield ('message_content', self.output_data)\n    yield ('channel_name', self.channel_name)\n    yield ('username', self.username)\nexcept discord.errors.LoginFailure as login_err:\n    raise ValueError(f'Login error occurred: {login_err}')\nexcept Exception as e:\n    raise ValueError(f'An error occurred: {e}')",
        "loop = asyncio.get_event_loop()",
        "future = self.run_bot(credentials.api_key)",
        "isinstance(future, asyncio.Future)"
      ],
      "code": "def __run(self, input_data: Input, credentials: APIKeyCredentials) -> BlockOutput:\n    try:\n        loop = asyncio.get_event_loop()\n        future = self.run_bot(credentials.api_key)\n        if isinstance(future, asyncio.Future):\n            future.set_result({'output_data': 'Hello!\\n\\nFile from user: example.txt\\nContent: This is the content of the file.', 'channel_name': 'general', 'username': 'test_user'})\n        result = loop.run_until_complete(future)\n        if isinstance(result, dict):\n            self.output_data = result.get('output_data')\n            self.channel_name = result.get('channel_name')\n            self.username = result.get('username')\n        if self.output_data is None or self.channel_name is None or self.username is None:\n            raise ValueError('No message, channel name, or username received.')\n        yield ('message_content', self.output_data)\n        yield ('channel_name', self.channel_name)\n        yield ('username', self.username)\n    except discord.errors.LoginFailure as login_err:\n        raise ValueError(f'Login error occurred: {login_err}')\n    except Exception as e:\n        raise ValueError(f'An error occurred: {e}')\ntry:\n    loop = asyncio.get_event_loop()\n    future = self.run_bot(credentials.api_key)\n    if isinstance(future, asyncio.Future):\n        future.set_result({'output_data': 'Hello!\\n\\nFile from user: example.txt\\nContent: This is the content of the file.', 'channel_name': 'general', 'username': 'test_user'})\n    result = loop.run_until_complete(future)\n    if isinstance(result, dict):\n        self.output_data = result.get('output_data')\n        self.channel_name = result.get('channel_name')\n        self.username = result.get('username')\n    if self.output_data is None or self.channel_name is None or self.username is None:\n        raise ValueError('No message, channel name, or username received.')\n    yield ('message_content', self.output_data)\n    yield ('channel_name', self.channel_name)\n    yield ('username', self.username)\nexcept discord.errors.LoginFailure as login_err:\n    raise ValueError(f'Login error occurred: {login_err}')\nexcept Exception as e:\n    raise ValueError(f'An error occurred: {e}')\nloop = asyncio.get_event_loop()\nfuture = self.run_bot(credentials.api_key)\nisinstance(future, asyncio.Future)"
    },
    {
      "id": "n13",
      "type": "block",
      "statements": [
        "(output_name, output_value)",
        "self.__run(input_data, credentials)"
      ],
      "code": "(output_name, output_value)\nself.__run(input_data, credentials)"
    },
    {
      "id": "n14",
      "type": "block",
      "statements": [
        "(yield (output_name, output_value))"
      ],
      "code": "(yield (output_name, output_value))"
    },
    {
      "id": "n15",
      "type": "block",
      "statements": [
        "break"
      ],
      "code": "break"
    },
    {
      "id": "n16",
      "type": "block",
      "statements": [
        "future.set_result({'output_data': 'Hello!\\n\\nFile from user: example.txt\\nContent: This is the content of the file.', 'channel_name': 'general', 'username': 'test_user'})"
      ],
      "code": "future.set_result({'output_data': 'Hello!\\n\\nFile from user: example.txt\\nContent: This is the content of the file.', 'channel_name': 'general', 'username': 'test_user'})"
    },
    {
      "id": "n17",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n18",
      "type": "block",
      "statements": [
        "result = loop.run_until_complete(future)",
        "isinstance(result, dict)"
      ],
      "code": "result = loop.run_until_complete(future)\nisinstance(result, dict)"
    },
    {
      "id": "n19",
      "type": "block",
      "statements": [
        "self.output_data = result.get('output_data')",
        "self.channel_name = result.get('channel_name')",
        "self.username = result.get('username')"
      ],
      "code": "self.output_data = result.get('output_data')\nself.channel_name = result.get('channel_name')\nself.username = result.get('username')"
    },
    {
      "id": "n20",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n21",
      "type": "block",
      "statements": [
        "self.output_data is None or self.channel_name is None or self.username is None"
      ],
      "code": "self.output_data is None or self.channel_name is None or self.username is None"
    },
    {
      "id": "n22",
      "type": "block",
      "statements": [
        "raise ValueError('No message, channel name, or username received.')"
      ],
      "code": "raise ValueError('No message, channel name, or username received.')"
    },
    {
      "id": "n23",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n24",
      "type": "block",
      "statements": [
        "(yield ('message_content', self.output_data))",
        "(yield ('channel_name', self.channel_name))",
        "(yield ('username', self.username))",
        "raise ValueError(f'Login error occurred: {login_err}')",
        "raise ValueError(f'An error occurred: {e}')",
        "class SendDiscordMessageBlock(Block):\n\n    class Input(BlockSchema):\n        credentials: DiscordCredentials = DiscordCredentialsField()\n        message_content: str = SchemaField(description='The content of the message received')\n        channel_name: str = SchemaField(description='The name of the channel the message was received from')\n\n    class Output(BlockSchema):\n        status: str = SchemaField(description=\"The status of the operation (e.g., 'Message sent', 'Error')\")\n\n    def __init__(self):\n        super().__init__(id='d0822ab5-9f8a-44a3-8971-531dd0178b6b', input_schema=SendDiscordMessageBlock.Input, output_schema=SendDiscordMessageBlock.Output, description='Sends a message to a Discord channel using a bot token.', categories={BlockCategory.SOCIAL}, test_input={'channel_name': 'general', 'message_content': 'Hello, Discord!', 'credentials': TEST_CREDENTIALS_INPUT}, test_output=[('status', 'Message sent')], test_mock={'send_message': lambda token, channel_name, message_content: asyncio.Future()}, test_credentials=TEST_CREDENTIALS)\n\n    async def send_message(self, token: str, channel_name: str, message_content: str):\n        intents = discord.Intents.default()\n        intents.guilds = True\n        client = discord.Client(intents=intents)\n\n        @client.event\n        async def on_ready():\n            print(f'Logged in as {client.user}')\n            for guild in client.guilds:\n                for channel in guild.text_channels:\n                    if channel.name == channel_name:\n                        for chunk in self.chunk_message(message_content):\n                            await channel.send(chunk)\n                        self.output_data = 'Message sent'\n                        await client.close()\n                        return\n            self.output_data = 'Channel not found'\n            await client.close()\n        await client.start(token)\n\n    def chunk_message(self, message: str, limit: int=2000) -> list:\n        \"\"\"Splits a message into chunks not exceeding the Discord limit.\"\"\"\n        return [message[i:i + limit] for i in range(0, len(message), limit)]\n\n    def run(self, input_data: Input, *, credentials: APIKeyCredentials, **kwargs) -> BlockOutput:\n        try:\n            loop = asyncio.get_event_loop()\n            future = self.send_message(credentials.api_key.get_secret_value(), input_data.channel_name, input_data.message_content)\n            if isinstance(future, asyncio.Future):\n                future.set_result('Message sent')\n            result = loop.run_until_complete(future)\n            if isinstance(result, str):\n                self.output_data = result\n            if self.output_data is None:\n                raise ValueError('No status message received.')\n            yield ('status', self.output_data)\n        except discord.errors.LoginFailure as login_err:\n            raise ValueError(f'Login error occurred: {login_err}')\n        except Exception as e:\n            raise ValueError(f'An error occurred: {e}')",
        "class Input(BlockSchema):\n    credentials: DiscordCredentials = DiscordCredentialsField()\n    message_content: str = SchemaField(description='The content of the message received')\n    channel_name: str = SchemaField(description='The name of the channel the message was received from')",
        "credentials: DiscordCredentials = DiscordCredentialsField()",
        "message_content: str = SchemaField(description='The content of the message received')",
        "channel_name: str = SchemaField(description='The name of the channel the message was received from')",
        "class Output(BlockSchema):\n    status: str = SchemaField(description=\"The status of the operation (e.g., 'Message sent', 'Error')\")",
        "status: str = SchemaField(description=\"The status of the operation (e.g., 'Message sent', 'Error')\")",
        "def __init__(self):\n    super().__init__(id='d0822ab5-9f8a-44a3-8971-531dd0178b6b', input_schema=SendDiscordMessageBlock.Input, output_schema=SendDiscordMessageBlock.Output, description='Sends a message to a Discord channel using a bot token.', categories={BlockCategory.SOCIAL}, test_input={'channel_name': 'general', 'message_content': 'Hello, Discord!', 'credentials': TEST_CREDENTIALS_INPUT}, test_output=[('status', 'Message sent')], test_mock={'send_message': lambda token, channel_name, message_content: asyncio.Future()}, test_credentials=TEST_CREDENTIALS)",
        "super().__init__()",
        "async def send_message(self, token: str, channel_name: str, message_content: str):\n    intents = discord.Intents.default()\n    intents.guilds = True\n    client = discord.Client(intents=intents)\n\n    @client.event\n    async def on_ready():\n        print(f'Logged in as {client.user}')\n        for guild in client.guilds:\n            for channel in guild.text_channels:\n                if channel.name == channel_name:\n                    for chunk in self.chunk_message(message_content):\n                        await channel.send(chunk)\n                    self.output_data = 'Message sent'\n                    await client.close()\n                    return\n        self.output_data = 'Channel not found'\n        await client.close()\n    await client.start(token)",
        "intents = discord.Intents.default()",
        "intents.guilds = True",
        "client = discord.Client(intents=intents)",
        "@client.event\nasync def on_ready():\n    print(f'Logged in as {client.user}')\n    for guild in client.guilds:\n        for channel in guild.text_channels:\n            if channel.name == channel_name:\n                for chunk in self.chunk_message(message_content):\n                    await channel.send(chunk)\n                self.output_data = 'Message sent'\n                await client.close()\n                return\n    self.output_data = 'Channel not found'\n    await client.close()",
        "print(f'Logged in as {client.user}')"
      ],
      "code": "(yield ('message_content', self.output_data))\n(yield ('channel_name', self.channel_name))\n(yield ('username', self.username))\nraise ValueError(f'Login error occurred: {login_err}')\nraise ValueError(f'An error occurred: {e}')\nclass SendDiscordMessageBlock(Block):\n\n    class Input(BlockSchema):\n        credentials: DiscordCredentials = DiscordCredentialsField()\n        message_content: str = SchemaField(description='The content of the message received')\n        channel_name: str = SchemaField(description='The name of the channel the message was received from')\n\n    class Output(BlockSchema):\n        status: str = SchemaField(description=\"The status of the operation (e.g., 'Message sent', 'Error')\")\n\n    def __init__(self):\n        super().__init__(id='d0822ab5-9f8a-44a3-8971-531dd0178b6b', input_schema=SendDiscordMessageBlock.Input, output_schema=SendDiscordMessageBlock.Output, description='Sends a message to a Discord channel using a bot token.', categories={BlockCategory.SOCIAL}, test_input={'channel_name': 'general', 'message_content': 'Hello, Discord!', 'credentials': TEST_CREDENTIALS_INPUT}, test_output=[('status', 'Message sent')], test_mock={'send_message': lambda token, channel_name, message_content: asyncio.Future()}, test_credentials=TEST_CREDENTIALS)\n\n    async def send_message(self, token: str, channel_name: str, message_content: str):\n        intents = discord.Intents.default()\n        intents.guilds = True\n        client = discord.Client(intents=intents)\n\n        @client.event\n        async def on_ready():\n            print(f'Logged in as {client.user}')\n            for guild in client.guilds:\n                for channel in guild.text_channels:\n                    if channel.name == channel_name:\n                        for chunk in self.chunk_message(message_content):\n                            await channel.send(chunk)\n                        self.output_data = 'Message sent'\n                        await client.close()\n                        return\n            self.output_data = 'Channel not found'\n            await client.close()\n        await client.start(token)\n\n    def chunk_message(self, message: str, limit: int=2000) -> list:\n        \"\"\"Splits a message into chunks not exceeding the Discord limit.\"\"\"\n        return [message[i:i + limit] for i in range(0, len(message), limit)]\n\n    def run(self, input_data: Input, *, credentials: APIKeyCredentials, **kwargs) -> BlockOutput:\n        try:\n            loop = asyncio.get_event_loop()\n            future = self.send_message(credentials.api_key.get_secret_value(), input_data.channel_name, input_data.message_content)\n            if isinstance(future, asyncio.Future):\n                future.set_result('Message sent')\n            result = loop.run_until_complete(future)\n            if isinstance(result, str):\n                self.output_data = result\n            if self.output_data is None:\n                raise ValueError('No status message received.')\n            yield ('status', self.output_data)\n        except discord.errors.LoginFailure as login_err:\n            raise ValueError(f'Login error occurred: {login_err}')\n        except Exception as e:\n            raise ValueError(f'An error occurred: {e}')\nclass Input(BlockSchema):\n    credentials: DiscordCredentials = DiscordCredentialsField()\n    message_content: str = SchemaField(description='The content of the message received')\n    channel_name: str = SchemaField(description='The name of the channel the message was received from')\ncredentials: DiscordCredentials = DiscordCredentialsField()\nmessage_content: str = SchemaField(description='The content of the message received')\nchannel_name: str = SchemaField(description='The name of the channel the message was received from')\nclass Output(BlockSchema):\n    status: str = SchemaField(description=\"The status of the operation (e.g., 'Message sent', 'Error')\")\nstatus: str = SchemaField(description=\"The status of the operation (e.g., 'Message sent', 'Error')\")\ndef __init__(self):\n    super().__init__(id='d0822ab5-9f8a-44a3-8971-531dd0178b6b', input_schema=SendDiscordMessageBlock.Input, output_schema=SendDiscordMessageBlock.Output, description='Sends a message to a Discord channel using a bot token.', categories={BlockCategory.SOCIAL}, test_input={'channel_name': 'general', 'message_content': 'Hello, Discord!', 'credentials': TEST_CREDENTIALS_INPUT}, test_output=[('status', 'Message sent')], test_mock={'send_message': lambda token, channel_name, message_content: asyncio.Future()}, test_credentials=TEST_CREDENTIALS)\nsuper().__init__()\nasync def send_message(self, token: str, channel_name: str, message_content: str):\n    intents = discord.Intents.default()\n    intents.guilds = True\n    client = discord.Client(intents=intents)\n\n    @client.event\n    async def on_ready():\n        print(f'Logged in as {client.user}')\n        for guild in client.guilds:\n            for channel in guild.text_channels:\n                if channel.name == channel_name:\n                    for chunk in self.chunk_message(message_content):\n                        await channel.send(chunk)\n                    self.output_data = 'Message sent'\n                    await client.close()\n                    return\n        self.output_data = 'Channel not found'\n        await client.close()\n    await client.start(token)\nintents = discord.Intents.default()\nintents.guilds = True\nclient = discord.Client(intents=intents)\n@client.event\nasync def on_ready():\n    print(f'Logged in as {client.user}')\n    for guild in client.guilds:\n        for channel in guild.text_channels:\n            if channel.name == channel_name:\n                for chunk in self.chunk_message(message_content):\n                    await channel.send(chunk)\n                self.output_data = 'Message sent'\n                await client.close()\n                return\n    self.output_data = 'Channel not found'\n    await client.close()\nprint(f'Logged in as {client.user}')"
    },
    {
      "id": "n25",
      "type": "block",
      "statements": [
        "guild",
        "client.guilds"
      ],
      "code": "guild\nclient.guilds"
    },
    {
      "id": "n26",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n27",
      "type": "block",
      "statements": [
        "self.output_data = 'Channel not found'",
        "await client.close()",
        "await client.start(token)",
        "def chunk_message(self, message: str, limit: int=2000) -> list:\n    \"\"\"Splits a message into chunks not exceeding the Discord limit.\"\"\"\n    return [message[i:i + limit] for i in range(0, len(message), limit)]",
        "'Splits a message into chunks not exceeding the Discord limit.'",
        "return [message[i:i + limit] for i in range(0, len(message), limit)]"
      ],
      "code": "self.output_data = 'Channel not found'\nawait client.close()\nawait client.start(token)\ndef chunk_message(self, message: str, limit: int=2000) -> list:\n    \"\"\"Splits a message into chunks not exceeding the Discord limit.\"\"\"\n    return [message[i:i + limit] for i in range(0, len(message), limit)]\n'Splits a message into chunks not exceeding the Discord limit.'\nreturn [message[i:i + limit] for i in range(0, len(message), limit)]"
    },
    {
      "id": "n28",
      "type": "block",
      "statements": [
        "channel",
        "guild.text_channels"
      ],
      "code": "channel\nguild.text_channels"
    },
    {
      "id": "n29",
      "type": "block",
      "statements": [
        "channel.name Eq channel_name"
      ],
      "code": "channel.name Eq channel_name"
    },
    {
      "id": "n30",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n31",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n32",
      "type": "block",
      "statements": [],
      "code": "\n"
    },
    {
      "id": "n33",
      "type": "block",
      "statements": [
        "chunk",
        "self.chunk_message(message_content)"
      ],
      "code": "chunk\nself.chunk_message(message_content)"
    },
    {
      "id": "n34",
      "type": "block",
      "statements": [
        "await channel.send(chunk)"
      ],
      "code": "await channel.send(chunk)"
    },
    {
      "id": "n35",
      "type": "block",
      "statements": [
        "self.output_data = 'Message sent'",
        "await client.close()",
        "return"
      ],
      "code": "self.output_data = 'Message sent'\nawait client.close()\nreturn"
    },
    {
      "id": "n36",
      "type": "block",
      "statements": [
        "def run(self, input_data: Input, *, credentials: APIKeyCredentials, **kwargs) -> BlockOutput:\n    try:\n        loop = asyncio.get_event_loop()\n        future = self.send_message(credentials.api_key.get_secret_value(), input_data.channel_name, input_data.message_content)\n        if isinstance(future, asyncio.Future):\n            future.set_result('Message sent')\n        result = loop.run_until_complete(future)\n        if isinstance(result, str):\n            self.output_data = result\n        if self.output_data is None:\n            raise ValueError('No status message received.')\n        yield ('status', self.output_data)\n    except discord.errors.LoginFailure as login_err:\n        raise ValueError(f'Login error occurred: {login_err}')\n    except Exception as e:\n        raise ValueError(f'An error occurred: {e}')",
        "try:\n    loop = asyncio.get_event_loop()\n    future = self.send_message(credentials.api_key.get_secret_value(), input_data.channel_name, input_data.message_content)\n    if isinstance(future, asyncio.Future):\n        future.set_result('Message sent')\n    result = loop.run_until_complete(future)\n    if isinstance(result, str):\n        self.output_data = result\n    if self.output_data is None:\n        raise ValueError('No status message received.')\n    yield ('status', self.output_data)\nexcept discord.errors.LoginFailure as login_err:\n    raise ValueError(f'Login error occurred: {login_err}')\nexcept Exception as e:\n    raise ValueError(f'An error occurred: {e}')",
        "loop = asyncio.get_event_loop()",
        "future = self.send_message(credentials.api_key.get_secret_value(), input_data.channel_name, input_data.message_content)",
        "isinstance(future, asyncio.Future)"
      ],
      "code": "def run(self, input_data: Input, *, credentials: APIKeyCredentials, **kwargs) -> BlockOutput:\n    try:\n        loop = asyncio.get_event_loop()\n        future = self.send_message(credentials.api_key.get_secret_value(), input_data.channel_name, input_data.message_content)\n        if isinstance(future, asyncio.Future):\n            future.set_result('Message sent')\n        result = loop.run_until_complete(future)\n        if isinstance(result, str):\n            self.output_data = result\n        if self.output_data is None:\n            raise ValueError('No status message received.')\n        yield ('status', self.output_data)\n    except discord.errors.LoginFailure as login_err:\n        raise ValueError(f'Login error occurred: {login_err}')\n    except Exception as e:\n        raise ValueError(f'An error occurred: {e}')\ntry:\n    loop = asyncio.get_event_loop()\n    future = self.send_message(credentials.api_key.get_secret_value(), input_data.channel_name, input_data.message_content)\n    if isinstance(future, asyncio.Future):\n        future.set_result('Message sent')\n    result = loop.run_until_complete(future)\n    if isinstance(result, str):\n        self.output_data = result\n    if self.output_data is None:\n        raise ValueError('No status message received.')\n    yield ('status', self.output_data)\nexcept discord.errors.LoginFailure as login_err:\n    raise ValueError(f'Login error occurred: {login_err}')\nexcept Exception as e:\n    raise ValueError(f'An error occurred: {e}')\nloop = asyncio.get_event_loop()\nfuture = self.send_message(credentials.api_key.get_secret_value(), input_data.channel_name, input_data.message_content)\nisinstance(future, asyncio.Future)"
    },
    {
      "id": "n37",
      "type": "block",
      "statements": [
        "future.set_result('Message sent')"
      ],
      "code": "future.set_result('Message sent')"
    },
    {
      "id": "n38",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n39",
      "type": "block",
      "statements": [
        "result = loop.run_until_complete(future)",
        "isinstance(result, str)"
      ],
      "code": "result = loop.run_until_complete(future)\nisinstance(result, str)"
    },
    {
      "id": "n40",
      "type": "block",
      "statements": [
        "self.output_data = result"
      ],
      "code": "self.output_data = result"
    },
    {
      "id": "n41",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n42",
      "type": "block",
      "statements": [
        "self.output_data Is None"
      ],
      "code": "self.output_data Is None"
    },
    {
      "id": "n43",
      "type": "block",
      "statements": [
        "raise ValueError('No status message received.')"
      ],
      "code": "raise ValueError('No status message received.')"
    },
    {
      "id": "n44",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n45",
      "type": "block",
      "statements": [
        "(yield ('status', self.output_data))",
        "raise ValueError(f'Login error occurred: {login_err}')",
        "raise ValueError(f'An error occurred: {e}')"
      ],
      "code": "(yield ('status', self.output_data))\nraise ValueError(f'Login error occurred: {login_err}')\nraise ValueError(f'An error occurred: {e}')"
    }
  ],
  "edges": [
    {
      "source": "n38",
      "target": "n39"
    },
    {
      "source": "n17",
      "target": "n18"
    },
    {
      "source": "n32",
      "target": "n28"
    },
    {
      "source": "n21",
      "target": "n22"
    },
    {
      "source": "n44",
      "target": "n45"
    },
    {
      "source": "n12",
      "target": "n16"
    },
    {
      "source": "n15",
      "target": "n10"
    },
    {
      "source": "n10",
      "target": "n11"
    },
    {
      "source": "n19",
      "target": "n21"
    },
    {
      "source": "n13",
      "target": "n14"
    },
    {
      "source": "n34",
      "target": "n33"
    },
    {
      "source": "n23",
      "target": "n24"
    },
    {
      "source": "n29",
      "target": "n32"
    },
    {
      "source": "n3",
      "target": "n4"
    },
    {
      "source": "n16",
      "target": "n18"
    },
    {
      "source": "n30",
      "target": "n25"
    },
    {
      "source": "n8",
      "target": "n9"
    },
    {
      "source": "n13",
      "target": "n15"
    },
    {
      "source": "n33",
      "target": "n35"
    },
    {
      "source": "n1",
      "target": "n2"
    },
    {
      "source": "n42",
      "target": "n43"
    },
    {
      "source": "n4",
      "target": "n8"
    },
    {
      "source": "n24",
      "target": "n25"
    },
    {
      "source": "n21",
      "target": "n23"
    },
    {
      "source": "n31",
      "target": "n33"
    },
    {
      "source": "n4",
      "target": "n7"
    },
    {
      "source": "n36",
      "target": "n38"
    },
    {
      "source": "n20",
      "target": "n21"
    },
    {
      "source": "n37",
      "target": "n39"
    },
    {
      "source": "n28",
      "target": "n30"
    },
    {
      "source": "n6",
      "target": "n10"
    },
    {
      "source": "n12",
      "target": "n17"
    },
    {
      "source": "n10",
      "target": "n12"
    },
    {
      "source": "n18",
      "target": "n19"
    },
    {
      "source": "n28",
      "target": "n29"
    },
    {
      "source": "n7",
      "target": "n9"
    },
    {
      "source": "n29",
      "target": "n31"
    },
    {
      "source": "n5",
      "target": "n6"
    },
    {
      "source": "n42",
      "target": "n44"
    },
    {
      "source": "n25",
      "target": "n26"
    },
    {
      "source": "n18",
      "target": "n20"
    },
    {
      "source": "n40",
      "target": "n42"
    },
    {
      "source": "n1",
      "target": "n3"
    },
    {
      "source": "n26",
      "target": "n28"
    },
    {
      "source": "n43",
      "target": "n45"
    },
    {
      "source": "n36",
      "target": "n37"
    },
    {
      "source": "n33",
      "target": "n34"
    },
    {
      "source": "n25",
      "target": "n27"
    },
    {
      "source": "n3",
      "target": "n5"
    },
    {
      "source": "n14",
      "target": "n13"
    },
    {
      "source": "n22",
      "target": "n24"
    },
    {
      "source": "n39",
      "target": "n40"
    },
    {
      "source": "n9",
      "target": "n6"
    },
    {
      "source": "n11",
      "target": "n13"
    },
    {
      "source": "n39",
      "target": "n41"
    },
    {
      "source": "n41",
      "target": "n42"
    }
  ]
}