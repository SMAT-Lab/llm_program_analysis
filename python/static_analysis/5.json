{
  "nodes": [
    {
      "id": "n0",
      "type": "block",
      "statements": [
        "'\\nThe sum-of-subsetsproblem states that a set of non-negative integers, and a\\nvalue M, determine all possible subsets of the given set whose summation sum\\nequal to given M.\\n\\nSummation of the chosen numbers must be equal to given number M and one number\\ncan be used only once.\\n'",
        "from __future__ import annotations",
        "def generate_sum_of_subsets_soln(nums: list[int], max_sum: int) -> list[list[int]]:\n    result: list[list[int]] = []\n    path: list[int] = []\n    num_index = 0\n    remaining_nums_sum = sum(nums)\n    create_state_space_tree(nums, max_sum, num_index, path, result, remaining_nums_sum)\n    return result",
        "result: list[list[int]] = []",
        "path: list[int] = []",
        "num_index = 0",
        "remaining_nums_sum = sum(nums)",
        "create_state_space_tree(nums, max_sum, num_index, path, result, remaining_nums_sum)",
        "return result"
      ],
      "code": "'\\nThe sum-of-subsetsproblem states that a set of non-negative integers, and a\\nvalue M, determine all possible subsets of the given set whose summation sum\\nequal to given M.\\n\\nSummation of the chosen numbers must be equal to given number M and one number\\ncan be used only once.\\n'\nfrom __future__ import annotations\ndef generate_sum_of_subsets_soln(nums: list[int], max_sum: int) -> list[list[int]]:\n    result: list[list[int]] = []\n    path: list[int] = []\n    num_index = 0\n    remaining_nums_sum = sum(nums)\n    create_state_space_tree(nums, max_sum, num_index, path, result, remaining_nums_sum)\n    return result\nresult: list[list[int]] = []\npath: list[int] = []\nnum_index = 0\nremaining_nums_sum = sum(nums)\ncreate_state_space_tree(nums, max_sum, num_index, path, result, remaining_nums_sum)\nreturn result"
    },
    {
      "id": "n1",
      "type": "block",
      "statements": [
        "def create_state_space_tree(nums: list[int], max_sum: int, num_index: int, path: list[int], result: list[list[int]], remaining_nums_sum: int) -> None:\n    \"\"\"\n    Creates a state space tree to iterate through each branch using DFS.\n    It terminates the branching of a node when any of the two conditions\n    given below satisfy.\n    This algorithm follows depth-fist-search and backtracks when the node is not\n    branchable.\n\n    \"\"\"\n    if sum(path) > max_sum or remaining_nums_sum + sum(path) < max_sum:\n        return\n    if sum(path) == max_sum:\n        result.append(path)\n        return\n    for index in range(num_index, len(nums)):\n        create_state_space_tree(nums, max_sum, index + 1, [*path, nums[index]], result, remaining_nums_sum - nums[index])",
        "'\\n    Creates a state space tree to iterate through each branch using DFS.\\n    It terminates the branching of a node when any of the two conditions\\n    given below satisfy.\\n    This algorithm follows depth-fist-search and backtracks when the node is not\\n    branchable.\\n\\n    '",
        "sum(path) > max_sum or remaining_nums_sum + sum(path) < max_sum"
      ],
      "code": "def create_state_space_tree(nums: list[int], max_sum: int, num_index: int, path: list[int], result: list[list[int]], remaining_nums_sum: int) -> None:\n    \"\"\"\n    Creates a state space tree to iterate through each branch using DFS.\n    It terminates the branching of a node when any of the two conditions\n    given below satisfy.\n    This algorithm follows depth-fist-search and backtracks when the node is not\n    branchable.\n\n    \"\"\"\n    if sum(path) > max_sum or remaining_nums_sum + sum(path) < max_sum:\n        return\n    if sum(path) == max_sum:\n        result.append(path)\n        return\n    for index in range(num_index, len(nums)):\n        create_state_space_tree(nums, max_sum, index + 1, [*path, nums[index]], result, remaining_nums_sum - nums[index])\n'\\n    Creates a state space tree to iterate through each branch using DFS.\\n    It terminates the branching of a node when any of the two conditions\\n    given below satisfy.\\n    This algorithm follows depth-fist-search and backtracks when the node is not\\n    branchable.\\n\\n    '\nsum(path) > max_sum or remaining_nums_sum + sum(path) < max_sum"
    },
    {
      "id": "n2",
      "type": "block",
      "statements": [
        "return"
      ],
      "code": "return"
    },
    {
      "id": "n3",
      "type": "block",
      "statements": [],
      "code": "\nsum(path) Eq max_sum"
    },
    {
      "id": "n4",
      "type": "block",
      "statements": [
        "result.append(path)",
        "return"
      ],
      "code": "result.append(path)\nreturn"
    },
    {
      "id": "n5",
      "type": "block",
      "statements": [],
      "code": "\n"
    },
    {
      "id": "n6",
      "type": "block",
      "statements": [
        "index",
        "range(num_index, len(nums))"
      ],
      "code": "index\nrange(num_index, len(nums))"
    },
    {
      "id": "n7",
      "type": "block",
      "statements": [
        "create_state_space_tree(nums, max_sum, index Add 1, [*path, nums[index]], result, remaining_nums_sum Sub nums[index])"
      ],
      "code": "create_state_space_tree(nums, max_sum, index Add 1, [*path, nums[index]], result, remaining_nums_sum Sub nums[index])"
    },
    {
      "id": "n8",
      "type": "block",
      "statements": [
        "'\\nremove the comment to take an input from the user\\n\\nprint(\"Enter the elements\")\\nnums = list(map(int, input().split()))\\nprint(\"Enter max_sum sum\")\\nmax_sum = int(input())\\n\\n'",
        "nums = [3, 34, 4, 12, 5, 2]",
        "max_sum = 9",
        "result = generate_sum_of_subsets_soln(nums, max_sum)",
        "print(*result)"
      ],
      "code": "'\\nremove the comment to take an input from the user\\n\\nprint(\"Enter the elements\")\\nnums = list(map(int, input().split()))\\nprint(\"Enter max_sum sum\")\\nmax_sum = int(input())\\n\\n'\nnums = [3, 34, 4, 12, 5, 2]\nmax_sum = 9\nresult = generate_sum_of_subsets_soln(nums, max_sum)\nprint(*result)"
    }
  ],
  "edges": [
    {
      "source": "n7",
      "target": "n6"
    },
    {
      "source": "n5",
      "target": "n6"
    },
    {
      "source": "n1",
      "target": "n3"
    },
    {
      "source": "n6",
      "target": "n7"
    },
    {
      "source": "n3",
      "target": "n4"
    },
    {
      "source": "n3",
      "target": "n5"
    },
    {
      "source": "n1",
      "target": "n2"
    },
    {
      "source": "n6",
      "target": "n8"
    }
  ]
}