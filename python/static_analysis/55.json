{
  "nodes": [
    {
      "id": "n0",
      "type": "block",
      "statements": [
        "import time",
        "from datetime import datetime, timedelta, timezone",
        "from typing import Any",
        "import feedparser",
        "import pydantic",
        "from backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema",
        "from backend.data.model import SchemaField",
        "class RSSEntry(pydantic.BaseModel):\n    title: str\n    link: str\n    description: str\n    pub_date: datetime\n    author: str\n    categories: list[str]",
        "title: str",
        "link: str",
        "description: str",
        "pub_date: datetime",
        "author: str",
        "categories: list[str]",
        "class ReadRSSFeedBlock(Block):\n\n    class Input(BlockSchema):\n        rss_url: str = SchemaField(description='The URL of the RSS feed to read', placeholder='https://example.com/rss')\n        time_period: int = SchemaField(description='The time period to check in minutes relative to the run block runtime, e.g. 60 would check for new entries in the last hour.', placeholder='1440', default=1440)\n        polling_rate: int = SchemaField(description='The number of seconds to wait between polling attempts.', placeholder='300')\n        run_continuously: bool = SchemaField(description='Whether to run the block continuously or just once.', default=True)\n\n    class Output(BlockSchema):\n        entry: RSSEntry = SchemaField(description='The RSS item')\n\n    def __init__(self):\n        super().__init__(id='5ebe6768-8e5d-41e3-9134-1c7bd89a8d52', input_schema=ReadRSSFeedBlock.Input, output_schema=ReadRSSFeedBlock.Output, description='Reads RSS feed entries from a given URL.', categories={BlockCategory.INPUT}, test_input={'rss_url': 'https://example.com/rss', 'time_period': 10000000, 'polling_rate': 1, 'run_continuously': False}, test_output=[('entry', RSSEntry(title='Example RSS Item', link='https://example.com/article', description='This is an example RSS item description.', pub_date=datetime(2023, 6, 23, 12, 30, 0, tzinfo=timezone.utc), author='John Doe', categories=['Technology', 'News']))], test_mock={'parse_feed': lambda *args, **kwargs: {'entries': [{'title': 'Example RSS Item', 'link': 'https://example.com/article', 'summary': 'This is an example RSS item description.', 'published_parsed': (2023, 6, 23, 12, 30, 0, 4, 174, 0), 'author': 'John Doe', 'tags': [{'term': 'Technology'}, {'term': 'News'}]}]}})\n\n    @staticmethod\n    def parse_feed(url: str) -> dict[str, Any]:\n        return feedparser.parse(url)\n\n    def run(self, input_data: Input, **kwargs) -> BlockOutput:\n        keep_going = True\n        start_time = datetime.now(timezone.utc) - timedelta(minutes=input_data.time_period)\n        while keep_going:\n            keep_going = input_data.run_continuously\n            feed = self.parse_feed(input_data.rss_url)\n            for entry in feed['entries']:\n                pub_date = datetime(*entry['published_parsed'][:6], tzinfo=timezone.utc)\n                if pub_date > start_time:\n                    yield ('entry', RSSEntry(title=entry['title'], link=entry['link'], description=entry.get('summary', ''), pub_date=pub_date, author=entry.get('author', ''), categories=[tag['term'] for tag in entry.get('tags', [])]))\n            time.sleep(input_data.polling_rate)",
        "class Input(BlockSchema):\n    rss_url: str = SchemaField(description='The URL of the RSS feed to read', placeholder='https://example.com/rss')\n    time_period: int = SchemaField(description='The time period to check in minutes relative to the run block runtime, e.g. 60 would check for new entries in the last hour.', placeholder='1440', default=1440)\n    polling_rate: int = SchemaField(description='The number of seconds to wait between polling attempts.', placeholder='300')\n    run_continuously: bool = SchemaField(description='Whether to run the block continuously or just once.', default=True)",
        "rss_url: str = SchemaField(description='The URL of the RSS feed to read', placeholder='https://example.com/rss')",
        "time_period: int = SchemaField(description='The time period to check in minutes relative to the run block runtime, e.g. 60 would check for new entries in the last hour.', placeholder='1440', default=1440)",
        "polling_rate: int = SchemaField(description='The number of seconds to wait between polling attempts.', placeholder='300')",
        "run_continuously: bool = SchemaField(description='Whether to run the block continuously or just once.', default=True)",
        "class Output(BlockSchema):\n    entry: RSSEntry = SchemaField(description='The RSS item')",
        "entry: RSSEntry = SchemaField(description='The RSS item')",
        "def __init__(self):\n    super().__init__(id='5ebe6768-8e5d-41e3-9134-1c7bd89a8d52', input_schema=ReadRSSFeedBlock.Input, output_schema=ReadRSSFeedBlock.Output, description='Reads RSS feed entries from a given URL.', categories={BlockCategory.INPUT}, test_input={'rss_url': 'https://example.com/rss', 'time_period': 10000000, 'polling_rate': 1, 'run_continuously': False}, test_output=[('entry', RSSEntry(title='Example RSS Item', link='https://example.com/article', description='This is an example RSS item description.', pub_date=datetime(2023, 6, 23, 12, 30, 0, tzinfo=timezone.utc), author='John Doe', categories=['Technology', 'News']))], test_mock={'parse_feed': lambda *args, **kwargs: {'entries': [{'title': 'Example RSS Item', 'link': 'https://example.com/article', 'summary': 'This is an example RSS item description.', 'published_parsed': (2023, 6, 23, 12, 30, 0, 4, 174, 0), 'author': 'John Doe', 'tags': [{'term': 'Technology'}, {'term': 'News'}]}]}})",
        "super().__init__()",
        "@staticmethod\ndef parse_feed(url: str) -> dict[str, Any]:\n    return feedparser.parse(url)",
        "return feedparser.parse(url)"
      ],
      "code": "import time\nfrom datetime import datetime, timedelta, timezone\nfrom typing import Any\nimport feedparser\nimport pydantic\nfrom backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema\nfrom backend.data.model import SchemaField\nclass RSSEntry(pydantic.BaseModel):\n    title: str\n    link: str\n    description: str\n    pub_date: datetime\n    author: str\n    categories: list[str]\ntitle: str\nlink: str\ndescription: str\npub_date: datetime\nauthor: str\ncategories: list[str]\nclass ReadRSSFeedBlock(Block):\n\n    class Input(BlockSchema):\n        rss_url: str = SchemaField(description='The URL of the RSS feed to read', placeholder='https://example.com/rss')\n        time_period: int = SchemaField(description='The time period to check in minutes relative to the run block runtime, e.g. 60 would check for new entries in the last hour.', placeholder='1440', default=1440)\n        polling_rate: int = SchemaField(description='The number of seconds to wait between polling attempts.', placeholder='300')\n        run_continuously: bool = SchemaField(description='Whether to run the block continuously or just once.', default=True)\n\n    class Output(BlockSchema):\n        entry: RSSEntry = SchemaField(description='The RSS item')\n\n    def __init__(self):\n        super().__init__(id='5ebe6768-8e5d-41e3-9134-1c7bd89a8d52', input_schema=ReadRSSFeedBlock.Input, output_schema=ReadRSSFeedBlock.Output, description='Reads RSS feed entries from a given URL.', categories={BlockCategory.INPUT}, test_input={'rss_url': 'https://example.com/rss', 'time_period': 10000000, 'polling_rate': 1, 'run_continuously': False}, test_output=[('entry', RSSEntry(title='Example RSS Item', link='https://example.com/article', description='This is an example RSS item description.', pub_date=datetime(2023, 6, 23, 12, 30, 0, tzinfo=timezone.utc), author='John Doe', categories=['Technology', 'News']))], test_mock={'parse_feed': lambda *args, **kwargs: {'entries': [{'title': 'Example RSS Item', 'link': 'https://example.com/article', 'summary': 'This is an example RSS item description.', 'published_parsed': (2023, 6, 23, 12, 30, 0, 4, 174, 0), 'author': 'John Doe', 'tags': [{'term': 'Technology'}, {'term': 'News'}]}]}})\n\n    @staticmethod\n    def parse_feed(url: str) -> dict[str, Any]:\n        return feedparser.parse(url)\n\n    def run(self, input_data: Input, **kwargs) -> BlockOutput:\n        keep_going = True\n        start_time = datetime.now(timezone.utc) - timedelta(minutes=input_data.time_period)\n        while keep_going:\n            keep_going = input_data.run_continuously\n            feed = self.parse_feed(input_data.rss_url)\n            for entry in feed['entries']:\n                pub_date = datetime(*entry['published_parsed'][:6], tzinfo=timezone.utc)\n                if pub_date > start_time:\n                    yield ('entry', RSSEntry(title=entry['title'], link=entry['link'], description=entry.get('summary', ''), pub_date=pub_date, author=entry.get('author', ''), categories=[tag['term'] for tag in entry.get('tags', [])]))\n            time.sleep(input_data.polling_rate)\nclass Input(BlockSchema):\n    rss_url: str = SchemaField(description='The URL of the RSS feed to read', placeholder='https://example.com/rss')\n    time_period: int = SchemaField(description='The time period to check in minutes relative to the run block runtime, e.g. 60 would check for new entries in the last hour.', placeholder='1440', default=1440)\n    polling_rate: int = SchemaField(description='The number of seconds to wait between polling attempts.', placeholder='300')\n    run_continuously: bool = SchemaField(description='Whether to run the block continuously or just once.', default=True)\nrss_url: str = SchemaField(description='The URL of the RSS feed to read', placeholder='https://example.com/rss')\ntime_period: int = SchemaField(description='The time period to check in minutes relative to the run block runtime, e.g. 60 would check for new entries in the last hour.', placeholder='1440', default=1440)\npolling_rate: int = SchemaField(description='The number of seconds to wait between polling attempts.', placeholder='300')\nrun_continuously: bool = SchemaField(description='Whether to run the block continuously or just once.', default=True)\nclass Output(BlockSchema):\n    entry: RSSEntry = SchemaField(description='The RSS item')\nentry: RSSEntry = SchemaField(description='The RSS item')\ndef __init__(self):\n    super().__init__(id='5ebe6768-8e5d-41e3-9134-1c7bd89a8d52', input_schema=ReadRSSFeedBlock.Input, output_schema=ReadRSSFeedBlock.Output, description='Reads RSS feed entries from a given URL.', categories={BlockCategory.INPUT}, test_input={'rss_url': 'https://example.com/rss', 'time_period': 10000000, 'polling_rate': 1, 'run_continuously': False}, test_output=[('entry', RSSEntry(title='Example RSS Item', link='https://example.com/article', description='This is an example RSS item description.', pub_date=datetime(2023, 6, 23, 12, 30, 0, tzinfo=timezone.utc), author='John Doe', categories=['Technology', 'News']))], test_mock={'parse_feed': lambda *args, **kwargs: {'entries': [{'title': 'Example RSS Item', 'link': 'https://example.com/article', 'summary': 'This is an example RSS item description.', 'published_parsed': (2023, 6, 23, 12, 30, 0, 4, 174, 0), 'author': 'John Doe', 'tags': [{'term': 'Technology'}, {'term': 'News'}]}]}})\nsuper().__init__()\n@staticmethod\ndef parse_feed(url: str) -> dict[str, Any]:\n    return feedparser.parse(url)\nreturn feedparser.parse(url)"
    },
    {
      "id": "n1",
      "type": "block",
      "statements": [
        "def run(self, input_data: Input, **kwargs) -> BlockOutput:\n    keep_going = True\n    start_time = datetime.now(timezone.utc) - timedelta(minutes=input_data.time_period)\n    while keep_going:\n        keep_going = input_data.run_continuously\n        feed = self.parse_feed(input_data.rss_url)\n        for entry in feed['entries']:\n            pub_date = datetime(*entry['published_parsed'][:6], tzinfo=timezone.utc)\n            if pub_date > start_time:\n                yield ('entry', RSSEntry(title=entry['title'], link=entry['link'], description=entry.get('summary', ''), pub_date=pub_date, author=entry.get('author', ''), categories=[tag['term'] for tag in entry.get('tags', [])]))\n        time.sleep(input_data.polling_rate)",
        "keep_going = True",
        "start_time = datetime.now(timezone.utc) - timedelta(minutes=input_data.time_period)"
      ],
      "code": "def run(self, input_data: Input, **kwargs) -> BlockOutput:\n    keep_going = True\n    start_time = datetime.now(timezone.utc) - timedelta(minutes=input_data.time_period)\n    while keep_going:\n        keep_going = input_data.run_continuously\n        feed = self.parse_feed(input_data.rss_url)\n        for entry in feed['entries']:\n            pub_date = datetime(*entry['published_parsed'][:6], tzinfo=timezone.utc)\n            if pub_date > start_time:\n                yield ('entry', RSSEntry(title=entry['title'], link=entry['link'], description=entry.get('summary', ''), pub_date=pub_date, author=entry.get('author', ''), categories=[tag['term'] for tag in entry.get('tags', [])]))\n        time.sleep(input_data.polling_rate)\nkeep_going = True\nstart_time = datetime.now(timezone.utc) - timedelta(minutes=input_data.time_period)"
    },
    {
      "id": "n2",
      "type": "block",
      "statements": [
        "keep_going"
      ],
      "code": "keep_going"
    },
    {
      "id": "n3",
      "type": "block",
      "statements": [
        "keep_going = input_data.run_continuously",
        "feed = self.parse_feed(input_data.rss_url)"
      ],
      "code": "keep_going = input_data.run_continuously\nfeed = self.parse_feed(input_data.rss_url)"
    },
    {
      "id": "n4",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n5",
      "type": "block",
      "statements": [
        "entry",
        "feed['entries']"
      ],
      "code": "entry\nfeed['entries']"
    },
    {
      "id": "n6",
      "type": "block",
      "statements": [
        "pub_date = datetime(*entry['published_parsed'][:6], tzinfo=timezone.utc)",
        "pub_date Gt start_time"
      ],
      "code": "pub_date = datetime(*entry['published_parsed'][:6], tzinfo=timezone.utc)\npub_date Gt start_time"
    },
    {
      "id": "n7",
      "type": "block",
      "statements": [
        "time.sleep(input_data.polling_rate)"
      ],
      "code": "time.sleep(input_data.polling_rate)"
    },
    {
      "id": "n8",
      "type": "block",
      "statements": [
        "(yield ('entry', RSSEntry(title=entry['title'], link=entry['link'], description=entry.get('summary', ''), pub_date=pub_date, author=entry.get('author', ''), categories=[tag['term'] for tag in entry.get('tags', [])])))"
      ],
      "code": "(yield ('entry', RSSEntry(title=entry['title'], link=entry['link'], description=entry.get('summary', ''), pub_date=pub_date, author=entry.get('author', ''), categories=[tag['term'] for tag in entry.get('tags', [])])))"
    },
    {
      "id": "n9",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n10",
      "type": "block",
      "statements": [],
      "code": ""
    }
  ],
  "edges": [
    {
      "source": "n5",
      "target": "n6"
    },
    {
      "source": "n7",
      "target": "n2"
    },
    {
      "source": "n8",
      "target": "n10"
    },
    {
      "source": "n2",
      "target": "n4"
    },
    {
      "source": "n10",
      "target": "n5"
    },
    {
      "source": "n3",
      "target": "n5"
    },
    {
      "source": "n9",
      "target": "n10"
    },
    {
      "source": "n1",
      "target": "n2"
    },
    {
      "source": "n5",
      "target": "n7"
    },
    {
      "source": "n6",
      "target": "n9"
    },
    {
      "source": "n6",
      "target": "n8"
    },
    {
      "source": "n2",
      "target": "n3"
    }
  ]
}