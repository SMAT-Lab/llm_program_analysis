{
  "nodes": [
    {
      "id": "n0",
      "type": "block",
      "statements": [
        "from functools import wraps",
        "from typing import Any, Callable, Concatenate, Coroutine, ParamSpec, TypeVar, cast",
        "from backend.data.credit import get_user_credit_model",
        "from backend.data.execution import ExecutionResult, RedisExecutionEventBus, create_graph_execution, get_execution_results, get_incomplete_executions, get_latest_execution, update_execution_status, update_graph_execution_stats, update_node_execution_stats, upsert_execution_input, upsert_execution_output",
        "from backend.data.graph import get_graph, get_node",
        "from backend.data.user import get_user_integrations, get_user_metadata, update_user_integrations, update_user_metadata",
        "from backend.util.service import AppService, expose, register_pydantic_serializers",
        "from backend.util.settings import Config",
        "P = ParamSpec('P')",
        "R = TypeVar('R')",
        "config = Config()",
        "class DatabaseManager(AppService):\n\n    def __init__(self):\n        super().__init__()\n        self.use_db = True\n        self.use_redis = True\n        self.event_queue = RedisExecutionEventBus()\n\n    @classmethod\n    def get_port(cls) -> int:\n        return config.database_api_port\n\n    @expose\n    def send_execution_update(self, execution_result: ExecutionResult):\n        self.event_queue.publish(execution_result)\n\n    @staticmethod\n    def exposed_run_and_wait(f: Callable[P, Coroutine[None, None, R]]) -> Callable[Concatenate[object, P], R]:\n\n        @expose\n        @wraps(f)\n        def wrapper(self, *args: P.args, **kwargs: P.kwargs) -> R:\n            coroutine = f(*args, **kwargs)\n            res = self.run_and_wait(coroutine)\n            return res\n        register_pydantic_serializers(f)\n        return wrapper\n    create_graph_execution = exposed_run_and_wait(create_graph_execution)\n    get_execution_results = exposed_run_and_wait(get_execution_results)\n    get_incomplete_executions = exposed_run_and_wait(get_incomplete_executions)\n    get_latest_execution = exposed_run_and_wait(get_latest_execution)\n    update_execution_status = exposed_run_and_wait(update_execution_status)\n    update_graph_execution_stats = exposed_run_and_wait(update_graph_execution_stats)\n    update_node_execution_stats = exposed_run_and_wait(update_node_execution_stats)\n    upsert_execution_input = exposed_run_and_wait(upsert_execution_input)\n    upsert_execution_output = exposed_run_and_wait(upsert_execution_output)\n    get_node = exposed_run_and_wait(get_node)\n    get_graph = exposed_run_and_wait(get_graph)\n    user_credit_model = get_user_credit_model()\n    get_or_refill_credit = cast(Callable[[Any, str], int], exposed_run_and_wait(user_credit_model.get_or_refill_credit))\n    spend_credits = cast(Callable[[Any, str, int, str, dict[str, str], float, float], int], exposed_run_and_wait(user_credit_model.spend_credits))\n    get_user_metadata = exposed_run_and_wait(get_user_metadata)\n    update_user_metadata = exposed_run_and_wait(update_user_metadata)\n    get_user_integrations = exposed_run_and_wait(get_user_integrations)\n    update_user_integrations = exposed_run_and_wait(update_user_integrations)",
        "def __init__(self):\n    super().__init__()\n    self.use_db = True\n    self.use_redis = True\n    self.event_queue = RedisExecutionEventBus()",
        "super().__init__()",
        "self.use_db = True",
        "self.use_redis = True",
        "self.event_queue = RedisExecutionEventBus()",
        "@classmethod\ndef get_port(cls) -> int:\n    return config.database_api_port",
        "return config.database_api_port"
      ],
      "code": "from functools import wraps\nfrom typing import Any, Callable, Concatenate, Coroutine, ParamSpec, TypeVar, cast\nfrom backend.data.credit import get_user_credit_model\nfrom backend.data.execution import ExecutionResult, RedisExecutionEventBus, create_graph_execution, get_execution_results, get_incomplete_executions, get_latest_execution, update_execution_status, update_graph_execution_stats, update_node_execution_stats, upsert_execution_input, upsert_execution_output\nfrom backend.data.graph import get_graph, get_node\nfrom backend.data.user import get_user_integrations, get_user_metadata, update_user_integrations, update_user_metadata\nfrom backend.util.service import AppService, expose, register_pydantic_serializers\nfrom backend.util.settings import Config\nP = ParamSpec('P')\nR = TypeVar('R')\nconfig = Config()\nclass DatabaseManager(AppService):\n\n    def __init__(self):\n        super().__init__()\n        self.use_db = True\n        self.use_redis = True\n        self.event_queue = RedisExecutionEventBus()\n\n    @classmethod\n    def get_port(cls) -> int:\n        return config.database_api_port\n\n    @expose\n    def send_execution_update(self, execution_result: ExecutionResult):\n        self.event_queue.publish(execution_result)\n\n    @staticmethod\n    def exposed_run_and_wait(f: Callable[P, Coroutine[None, None, R]]) -> Callable[Concatenate[object, P], R]:\n\n        @expose\n        @wraps(f)\n        def wrapper(self, *args: P.args, **kwargs: P.kwargs) -> R:\n            coroutine = f(*args, **kwargs)\n            res = self.run_and_wait(coroutine)\n            return res\n        register_pydantic_serializers(f)\n        return wrapper\n    create_graph_execution = exposed_run_and_wait(create_graph_execution)\n    get_execution_results = exposed_run_and_wait(get_execution_results)\n    get_incomplete_executions = exposed_run_and_wait(get_incomplete_executions)\n    get_latest_execution = exposed_run_and_wait(get_latest_execution)\n    update_execution_status = exposed_run_and_wait(update_execution_status)\n    update_graph_execution_stats = exposed_run_and_wait(update_graph_execution_stats)\n    update_node_execution_stats = exposed_run_and_wait(update_node_execution_stats)\n    upsert_execution_input = exposed_run_and_wait(upsert_execution_input)\n    upsert_execution_output = exposed_run_and_wait(upsert_execution_output)\n    get_node = exposed_run_and_wait(get_node)\n    get_graph = exposed_run_and_wait(get_graph)\n    user_credit_model = get_user_credit_model()\n    get_or_refill_credit = cast(Callable[[Any, str], int], exposed_run_and_wait(user_credit_model.get_or_refill_credit))\n    spend_credits = cast(Callable[[Any, str, int, str, dict[str, str], float, float], int], exposed_run_and_wait(user_credit_model.spend_credits))\n    get_user_metadata = exposed_run_and_wait(get_user_metadata)\n    update_user_metadata = exposed_run_and_wait(update_user_metadata)\n    get_user_integrations = exposed_run_and_wait(get_user_integrations)\n    update_user_integrations = exposed_run_and_wait(update_user_integrations)\ndef __init__(self):\n    super().__init__()\n    self.use_db = True\n    self.use_redis = True\n    self.event_queue = RedisExecutionEventBus()\nsuper().__init__()\nself.use_db = True\nself.use_redis = True\nself.event_queue = RedisExecutionEventBus()\n@classmethod\ndef get_port(cls) -> int:\n    return config.database_api_port\nreturn config.database_api_port"
    },
    {
      "id": "n1",
      "type": "block",
      "statements": [
        "@expose\ndef send_execution_update(self, execution_result: ExecutionResult):\n    self.event_queue.publish(execution_result)",
        "self.event_queue.publish(execution_result)",
        "@staticmethod\ndef exposed_run_and_wait(f: Callable[P, Coroutine[None, None, R]]) -> Callable[Concatenate[object, P], R]:\n\n    @expose\n    @wraps(f)\n    def wrapper(self, *args: P.args, **kwargs: P.kwargs) -> R:\n        coroutine = f(*args, **kwargs)\n        res = self.run_and_wait(coroutine)\n        return res\n    register_pydantic_serializers(f)\n    return wrapper",
        "@expose\n@wraps(f)\ndef wrapper(self, *args: P.args, **kwargs: P.kwargs) -> R:\n    coroutine = f(*args, **kwargs)\n    res = self.run_and_wait(coroutine)\n    return res",
        "coroutine = f(*args, **kwargs)",
        "res = self.run_and_wait(coroutine)",
        "return res"
      ],
      "code": "@expose\ndef send_execution_update(self, execution_result: ExecutionResult):\n    self.event_queue.publish(execution_result)\nself.event_queue.publish(execution_result)\n@staticmethod\ndef exposed_run_and_wait(f: Callable[P, Coroutine[None, None, R]]) -> Callable[Concatenate[object, P], R]:\n\n    @expose\n    @wraps(f)\n    def wrapper(self, *args: P.args, **kwargs: P.kwargs) -> R:\n        coroutine = f(*args, **kwargs)\n        res = self.run_and_wait(coroutine)\n        return res\n    register_pydantic_serializers(f)\n    return wrapper\n@expose\n@wraps(f)\ndef wrapper(self, *args: P.args, **kwargs: P.kwargs) -> R:\n    coroutine = f(*args, **kwargs)\n    res = self.run_and_wait(coroutine)\n    return res\ncoroutine = f(*args, **kwargs)\nres = self.run_and_wait(coroutine)\nreturn res"
    },
    {
      "id": "n2",
      "type": "block",
      "statements": [
        "register_pydantic_serializers(f)",
        "return wrapper"
      ],
      "code": "register_pydantic_serializers(f)\nreturn wrapper"
    },
    {
      "id": "n3",
      "type": "block",
      "statements": [
        "create_graph_execution = exposed_run_and_wait(create_graph_execution)",
        "get_execution_results = exposed_run_and_wait(get_execution_results)",
        "get_incomplete_executions = exposed_run_and_wait(get_incomplete_executions)",
        "get_latest_execution = exposed_run_and_wait(get_latest_execution)",
        "update_execution_status = exposed_run_and_wait(update_execution_status)",
        "update_graph_execution_stats = exposed_run_and_wait(update_graph_execution_stats)",
        "update_node_execution_stats = exposed_run_and_wait(update_node_execution_stats)",
        "upsert_execution_input = exposed_run_and_wait(upsert_execution_input)",
        "upsert_execution_output = exposed_run_and_wait(upsert_execution_output)",
        "get_node = exposed_run_and_wait(get_node)",
        "get_graph = exposed_run_and_wait(get_graph)",
        "user_credit_model = get_user_credit_model()",
        "get_or_refill_credit = cast(Callable[[Any, str], int], exposed_run_and_wait(user_credit_model.get_or_refill_credit))",
        "spend_credits = cast(Callable[[Any, str, int, str, dict[str, str], float, float], int], exposed_run_and_wait(user_credit_model.spend_credits))",
        "get_user_metadata = exposed_run_and_wait(get_user_metadata)",
        "update_user_metadata = exposed_run_and_wait(update_user_metadata)",
        "get_user_integrations = exposed_run_and_wait(get_user_integrations)",
        "update_user_integrations = exposed_run_and_wait(update_user_integrations)"
      ],
      "code": "create_graph_execution = exposed_run_and_wait(create_graph_execution)\nget_execution_results = exposed_run_and_wait(get_execution_results)\nget_incomplete_executions = exposed_run_and_wait(get_incomplete_executions)\nget_latest_execution = exposed_run_and_wait(get_latest_execution)\nupdate_execution_status = exposed_run_and_wait(update_execution_status)\nupdate_graph_execution_stats = exposed_run_and_wait(update_graph_execution_stats)\nupdate_node_execution_stats = exposed_run_and_wait(update_node_execution_stats)\nupsert_execution_input = exposed_run_and_wait(upsert_execution_input)\nupsert_execution_output = exposed_run_and_wait(upsert_execution_output)\nget_node = exposed_run_and_wait(get_node)\nget_graph = exposed_run_and_wait(get_graph)\nuser_credit_model = get_user_credit_model()\nget_or_refill_credit = cast(Callable[[Any, str], int], exposed_run_and_wait(user_credit_model.get_or_refill_credit))\nspend_credits = cast(Callable[[Any, str, int, str, dict[str, str], float, float], int], exposed_run_and_wait(user_credit_model.spend_credits))\nget_user_metadata = exposed_run_and_wait(get_user_metadata)\nupdate_user_metadata = exposed_run_and_wait(update_user_metadata)\nget_user_integrations = exposed_run_and_wait(get_user_integrations)\nupdate_user_integrations = exposed_run_and_wait(update_user_integrations)"
    }
  ],
  "edges": []
}