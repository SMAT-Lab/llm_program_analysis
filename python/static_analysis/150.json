{
  "nodes": [
    {
      "id": "n0",
      "type": "block",
      "statements": [
        "\"\\nProblem:\\n\\nThe n queens problem is: placing N queens on a N * N chess board such that no queen\\ncan attack any other queens placed on that chess board.  This means that one queen\\ncannot have any other queen on its horizontal, vertical and diagonal lines.\\n\\nSolution:\\n\\nTo solve this problem we will use simple math. First we know the queen can move in all\\nthe possible ways, we can simplify it in this: vertical, horizontal, diagonal left and\\n diagonal right.\\n\\nWe can visualize it like this:\\n\\nleft diagonal = \\\\\\nright diagonal = /\\n\\nOn a chessboard vertical movement could be the rows and horizontal movement could be\\nthe columns.\\n\\nIn programming we can use an array, and in this array each index could be the rows and\\neach value in the array could be the column. For example:\\n\\n    . Q . .     We have this chessboard with one queen in each column and each queen\\n    . . . Q     can't attack to each other.\\n    Q . . .     The array for this example would look like this: [1, 3, 0, 2]\\n    . . Q .\\n\\nSo if we use an array and we verify that each value in the array is different to each\\nother we know that at least the queens can't attack each other in horizontal and\\nvertical.\\n\\nAt this point we have it halfway completed and we will treat the chessboard as a\\nCartesian plane.  Hereinafter we are going to remember basic math, so in the school we\\nlearned this formula:\\n\\n    Slope of a line:\\n\\n           y2 - y1\\n     m = ----------\\n          x2 - x1\\n\\nThis formula allow us to get the slope. For the angles 45º (right diagonal) and 135º\\n(left diagonal) this formula gives us m = 1, and m = -1 respectively.\\n\\nSee::\\nhttps://www.enotes.com/homework-help/write-equation-line-that-hits-origin-45-degree-1474860\\n\\nThen we have this other formula:\\n\\nSlope intercept:\\n\\ny = mx + b\\n\\nb is where the line crosses the Y axis (to get more information see:\\nhttps://www.mathsisfun.com/y_intercept.html), if we change the formula to solve for b\\nwe would have:\\n\\ny - mx = b\\n\\nAnd since we already have the m values for the angles 45º and 135º, this formula would\\nlook like this:\\n\\n45º: y - (1)x = b\\n45º: y - x = b\\n\\n135º: y - (-1)x = b\\n135º: y + x = b\\n\\ny = row\\nx = column\\n\\nApplying these two formulas we can check if a queen in some position is being attacked\\nfor another one or vice versa.\\n\\n\"",
        "from __future__ import annotations",
        "def depth_first_search(possible_board: list[int], diagonal_right_collisions: list[int], diagonal_left_collisions: list[int], boards: list[list[str]], n: int) -> None:\n    \"\"\"\n    >>> boards = []\n    >>> depth_first_search([], [], [], boards, 4)\n    >>> for board in boards:\n    ...     print(board)\n    ['. Q . . ', '. . . Q ', 'Q . . . ', '. . Q . ']\n    ['. . Q . ', 'Q . . . ', '. . . Q ', '. Q . . ']\n    \"\"\"\n    row = len(possible_board)\n    if row == n:\n        boards.append(['. ' * i + 'Q ' + '. ' * (n - 1 - i) for i in possible_board])\n        return\n    for col in range(n):\n        if col in possible_board or row - col in diagonal_right_collisions or row + col in diagonal_left_collisions:\n            continue\n        depth_first_search([*possible_board, col], [*diagonal_right_collisions, row - col], [*diagonal_left_collisions, row + col], boards, n)",
        "\"\\n    >>> boards = []\\n    >>> depth_first_search([], [], [], boards, 4)\\n    >>> for board in boards:\\n    ...     print(board)\\n    ['. Q . . ', '. . . Q ', 'Q . . . ', '. . Q . ']\\n    ['. . Q . ', 'Q . . . ', '. . . Q ', '. Q . . ']\\n    \"",
        "row = len(possible_board)",
        "row Eq n"
      ],
      "code": "\"\\nProblem:\\n\\nThe n queens problem is: placing N queens on a N * N chess board such that no queen\\ncan attack any other queens placed on that chess board.  This means that one queen\\ncannot have any other queen on its horizontal, vertical and diagonal lines.\\n\\nSolution:\\n\\nTo solve this problem we will use simple math. First we know the queen can move in all\\nthe possible ways, we can simplify it in this: vertical, horizontal, diagonal left and\\n diagonal right.\\n\\nWe can visualize it like this:\\n\\nleft diagonal = \\\\\\nright diagonal = /\\n\\nOn a chessboard vertical movement could be the rows and horizontal movement could be\\nthe columns.\\n\\nIn programming we can use an array, and in this array each index could be the rows and\\neach value in the array could be the column. For example:\\n\\n    . Q . .     We have this chessboard with one queen in each column and each queen\\n    . . . Q     can't attack to each other.\\n    Q . . .     The array for this example would look like this: [1, 3, 0, 2]\\n    . . Q .\\n\\nSo if we use an array and we verify that each value in the array is different to each\\nother we know that at least the queens can't attack each other in horizontal and\\nvertical.\\n\\nAt this point we have it halfway completed and we will treat the chessboard as a\\nCartesian plane.  Hereinafter we are going to remember basic math, so in the school we\\nlearned this formula:\\n\\n    Slope of a line:\\n\\n           y2 - y1\\n     m = ----------\\n          x2 - x1\\n\\nThis formula allow us to get the slope. For the angles 45º (right diagonal) and 135º\\n(left diagonal) this formula gives us m = 1, and m = -1 respectively.\\n\\nSee::\\nhttps://www.enotes.com/homework-help/write-equation-line-that-hits-origin-45-degree-1474860\\n\\nThen we have this other formula:\\n\\nSlope intercept:\\n\\ny = mx + b\\n\\nb is where the line crosses the Y axis (to get more information see:\\nhttps://www.mathsisfun.com/y_intercept.html), if we change the formula to solve for b\\nwe would have:\\n\\ny - mx = b\\n\\nAnd since we already have the m values for the angles 45º and 135º, this formula would\\nlook like this:\\n\\n45º: y - (1)x = b\\n45º: y - x = b\\n\\n135º: y - (-1)x = b\\n135º: y + x = b\\n\\ny = row\\nx = column\\n\\nApplying these two formulas we can check if a queen in some position is being attacked\\nfor another one or vice versa.\\n\\n\"\nfrom __future__ import annotations\ndef depth_first_search(possible_board: list[int], diagonal_right_collisions: list[int], diagonal_left_collisions: list[int], boards: list[list[str]], n: int) -> None:\n    \"\"\"\n    >>> boards = []\n    >>> depth_first_search([], [], [], boards, 4)\n    >>> for board in boards:\n    ...     print(board)\n    ['. Q . . ', '. . . Q ', 'Q . . . ', '. . Q . ']\n    ['. . Q . ', 'Q . . . ', '. . . Q ', '. Q . . ']\n    \"\"\"\n    row = len(possible_board)\n    if row == n:\n        boards.append(['. ' * i + 'Q ' + '. ' * (n - 1 - i) for i in possible_board])\n        return\n    for col in range(n):\n        if col in possible_board or row - col in diagonal_right_collisions or row + col in diagonal_left_collisions:\n            continue\n        depth_first_search([*possible_board, col], [*diagonal_right_collisions, row - col], [*diagonal_left_collisions, row + col], boards, n)\n\"\\n    >>> boards = []\\n    >>> depth_first_search([], [], [], boards, 4)\\n    >>> for board in boards:\\n    ...     print(board)\\n    ['. Q . . ', '. . . Q ', 'Q . . . ', '. . Q . ']\\n    ['. . Q . ', 'Q . . . ', '. . . Q ', '. Q . . ']\\n    \"\nrow = len(possible_board)\nrow Eq n"
    },
    {
      "id": "n1",
      "type": "block",
      "statements": [
        "boards.append(['. ' * i + 'Q ' + '. ' * (n - 1 - i) for i in possible_board])",
        "return"
      ],
      "code": "boards.append(['. ' * i + 'Q ' + '. ' * (n - 1 - i) for i in possible_board])\nreturn"
    },
    {
      "id": "n2",
      "type": "block",
      "statements": [],
      "code": "\n"
    },
    {
      "id": "n3",
      "type": "block",
      "statements": [
        "col",
        "range(n)"
      ],
      "code": "col\nrange(n)"
    },
    {
      "id": "n4",
      "type": "block",
      "statements": [
        "col in possible_board or row - col in diagonal_right_collisions or row + col in diagonal_left_collisions"
      ],
      "code": "col in possible_board or row - col in diagonal_right_collisions or row + col in diagonal_left_collisions"
    },
    {
      "id": "n5",
      "type": "block",
      "statements": [
        "def n_queens_solution(n: int) -> None:\n    boards: list[list[str]] = []\n    depth_first_search([], [], [], boards, n)\n    for board in boards:\n        for column in board:\n            print(column)\n        print('')\n    print(len(boards), 'solutions were found.')",
        "boards: list[list[str]] = []",
        "depth_first_search([], [], [], boards, n)"
      ],
      "code": "def n_queens_solution(n: int) -> None:\n    boards: list[list[str]] = []\n    depth_first_search([], [], [], boards, n)\n    for board in boards:\n        for column in board:\n            print(column)\n        print('')\n    print(len(boards), 'solutions were found.')\nboards: list[list[str]] = []\ndepth_first_search([], [], [], boards, n)"
    },
    {
      "id": "n6",
      "type": "block",
      "statements": [
        "continue"
      ],
      "code": "continue"
    },
    {
      "id": "n7",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n8",
      "type": "block",
      "statements": [
        "depth_first_search([*possible_board, col], [*diagonal_right_collisions, row - col], [*diagonal_left_collisions, row + col], boards, n)"
      ],
      "code": "depth_first_search([*possible_board, col], [*diagonal_right_collisions, row - col], [*diagonal_left_collisions, row + col], boards, n)"
    },
    {
      "id": "n9",
      "type": "block",
      "statements": [
        "board",
        "boards"
      ],
      "code": "board\nboards"
    },
    {
      "id": "n10",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n11",
      "type": "block",
      "statements": [
        "print(len(boards), 'solutions were found.')",
        "__name__ Eq '__main__'"
      ],
      "code": "print(len(boards), 'solutions were found.')\n__name__ Eq '__main__'"
    },
    {
      "id": "n12",
      "type": "block",
      "statements": [
        "column",
        "board"
      ],
      "code": "column\nboard"
    },
    {
      "id": "n13",
      "type": "block",
      "statements": [
        "print(column)"
      ],
      "code": "print(column)"
    },
    {
      "id": "n14",
      "type": "block",
      "statements": [
        "print('')"
      ],
      "code": "print('')"
    },
    {
      "id": "n15",
      "type": "block",
      "statements": [
        "import doctest",
        "doctest.testmod()",
        "n_queens_solution(4)"
      ],
      "code": "import doctest\ndoctest.testmod()\nn_queens_solution(4)"
    },
    {
      "id": "n16",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n17",
      "type": "block",
      "statements": [],
      "code": ""
    }
  ],
  "edges": [
    {
      "source": "n5",
      "target": "n9"
    },
    {
      "source": "n0",
      "target": "n1"
    },
    {
      "source": "n11",
      "target": "n15"
    },
    {
      "source": "n2",
      "target": "n3"
    },
    {
      "source": "n13",
      "target": "n12"
    },
    {
      "source": "n16",
      "target": "n17"
    },
    {
      "source": "n3",
      "target": "n4"
    },
    {
      "source": "n4",
      "target": "n6"
    },
    {
      "source": "n12",
      "target": "n13"
    },
    {
      "source": "n7",
      "target": "n8"
    },
    {
      "source": "n8",
      "target": "n3"
    },
    {
      "source": "n12",
      "target": "n14"
    },
    {
      "source": "n9",
      "target": "n11"
    },
    {
      "source": "n4",
      "target": "n7"
    },
    {
      "source": "n11",
      "target": "n16"
    },
    {
      "source": "n9",
      "target": "n10"
    },
    {
      "source": "n10",
      "target": "n12"
    },
    {
      "source": "n14",
      "target": "n9"
    },
    {
      "source": "n3",
      "target": "n5"
    },
    {
      "source": "n6",
      "target": "n8"
    },
    {
      "source": "n0",
      "target": "n2"
    },
    {
      "source": "n15",
      "target": "n17"
    }
  ]
}