{
  "nodes": [
    {
      "id": "n0",
      "type": "block",
      "statements": [
        "import asyncio",
        "import builtins",
        "import logging",
        "import os",
        "import threading",
        "import time",
        "import typing",
        "from abc import ABC, abstractmethod",
        "from enum import Enum",
        "from types import NoneType, UnionType",
        "from typing import Annotated, Any, Awaitable, Callable, Coroutine, Dict, FrozenSet, Iterator, List, Set, Tuple, Type, TypeVar, Union, cast, get_args, get_origin",
        "import Pyro5.api",
        "from pydantic import BaseModel",
        "from Pyro5 import api as pyro",
        "from Pyro5 import config as pyro_config",
        "from backend.data import db, redis",
        "from backend.util.process import AppProcess",
        "from backend.util.retry import conn_retry",
        "from backend.util.settings import Config, Secrets",
        "logger = logging.getLogger(__name__)",
        "T = TypeVar('T')",
        "C = TypeVar('C', bound=Callable)",
        "config = Config()",
        "pyro_host = config.pyro_host",
        "pyro_config.MAX_RETRIES = config.pyro_client_comm_retry",
        "pyro_config.COMMTIMEOUT = config.pyro_client_comm_timeout",
        "def expose(func: C) -> C:\n    \"\"\"\n    Decorator to mark a method or class to be exposed for remote calls.\n\n    ## ⚠️ Gotcha\n    Aside from \"simple\" types, only Pydantic models are passed unscathed *if annotated*.\n    Any other passed or returned class objects are converted to dictionaries by Pyro.\n    \"\"\"\n\n    def wrapper(*args, **kwargs):\n        try:\n            return func(*args, **kwargs)\n        except Exception as e:\n            msg = f'Error in {func.__name__}: {e.__str__()}'\n            logger.exception(msg)\n            raise\n    register_pydantic_serializers(func)\n    return pyro.expose(wrapper)",
        "'\\n    Decorator to mark a method or class to be exposed for remote calls.\\n\\n    ## ⚠️ Gotcha\\n    Aside from \"simple\" types, only Pydantic models are passed unscathed *if annotated*.\\n    Any other passed or returned class objects are converted to dictionaries by Pyro.\\n    '",
        "def wrapper(*args, **kwargs):\n    try:\n        return func(*args, **kwargs)\n    except Exception as e:\n        msg = f'Error in {func.__name__}: {e.__str__()}'\n        logger.exception(msg)\n        raise",
        "try:\n    return func(*args, **kwargs)\nexcept Exception as e:\n    msg = f'Error in {func.__name__}: {e.__str__()}'\n    logger.exception(msg)\n    raise",
        "return func(*args, **kwargs)"
      ],
      "code": "import asyncio\nimport builtins\nimport logging\nimport os\nimport threading\nimport time\nimport typing\nfrom abc import ABC, abstractmethod\nfrom enum import Enum\nfrom types import NoneType, UnionType\nfrom typing import Annotated, Any, Awaitable, Callable, Coroutine, Dict, FrozenSet, Iterator, List, Set, Tuple, Type, TypeVar, Union, cast, get_args, get_origin\nimport Pyro5.api\nfrom pydantic import BaseModel\nfrom Pyro5 import api as pyro\nfrom Pyro5 import config as pyro_config\nfrom backend.data import db, redis\nfrom backend.util.process import AppProcess\nfrom backend.util.retry import conn_retry\nfrom backend.util.settings import Config, Secrets\nlogger = logging.getLogger(__name__)\nT = TypeVar('T')\nC = TypeVar('C', bound=Callable)\nconfig = Config()\npyro_host = config.pyro_host\npyro_config.MAX_RETRIES = config.pyro_client_comm_retry\npyro_config.COMMTIMEOUT = config.pyro_client_comm_timeout\ndef expose(func: C) -> C:\n    \"\"\"\n    Decorator to mark a method or class to be exposed for remote calls.\n\n    ## ⚠️ Gotcha\n    Aside from \"simple\" types, only Pydantic models are passed unscathed *if annotated*.\n    Any other passed or returned class objects are converted to dictionaries by Pyro.\n    \"\"\"\n\n    def wrapper(*args, **kwargs):\n        try:\n            return func(*args, **kwargs)\n        except Exception as e:\n            msg = f'Error in {func.__name__}: {e.__str__()}'\n            logger.exception(msg)\n            raise\n    register_pydantic_serializers(func)\n    return pyro.expose(wrapper)\n'\\n    Decorator to mark a method or class to be exposed for remote calls.\\n\\n    ## ⚠️ Gotcha\\n    Aside from \"simple\" types, only Pydantic models are passed unscathed *if annotated*.\\n    Any other passed or returned class objects are converted to dictionaries by Pyro.\\n    '\ndef wrapper(*args, **kwargs):\n    try:\n        return func(*args, **kwargs)\n    except Exception as e:\n        msg = f'Error in {func.__name__}: {e.__str__()}'\n        logger.exception(msg)\n        raise\ntry:\n    return func(*args, **kwargs)\nexcept Exception as e:\n    msg = f'Error in {func.__name__}: {e.__str__()}'\n    logger.exception(msg)\n    raise\nreturn func(*args, **kwargs)"
    },
    {
      "id": "n1",
      "type": "block",
      "statements": [
        "msg = f'Error in {func.__name__}: {e.__str__()}'",
        "logger.exception(msg)",
        "raise",
        "register_pydantic_serializers(func)",
        "return pyro.expose(wrapper)"
      ],
      "code": "msg = f'Error in {func.__name__}: {e.__str__()}'\nlogger.exception(msg)\nraise\nregister_pydantic_serializers(func)\nreturn pyro.expose(wrapper)"
    },
    {
      "id": "n2",
      "type": "block",
      "statements": [
        "def register_pydantic_serializers(func: Callable):\n    \"\"\"Register custom serializers and deserializers for annotated Pydantic models\"\"\"\n    for (name, annotation) in func.__annotations__.items():\n        try:\n            pydantic_types = _pydantic_models_from_type_annotation(annotation)\n        except Exception as e:\n            raise TypeError(f'Error while exposing {func.__name__}: {e.__str__()}')\n        for model in pydantic_types:\n            logger.debug(f\"Registering Pyro (de)serializers for {func.__name__} annotation '{name}': {model.__qualname__}\")\n            pyro.register_class_to_dict(model, _make_custom_serializer(model))\n            pyro.register_dict_to_class(model.__qualname__, _make_custom_deserializer(model))",
        "'Register custom serializers and deserializers for annotated Pydantic models'"
      ],
      "code": "def register_pydantic_serializers(func: Callable):\n    \"\"\"Register custom serializers and deserializers for annotated Pydantic models\"\"\"\n    for (name, annotation) in func.__annotations__.items():\n        try:\n            pydantic_types = _pydantic_models_from_type_annotation(annotation)\n        except Exception as e:\n            raise TypeError(f'Error while exposing {func.__name__}: {e.__str__()}')\n        for model in pydantic_types:\n            logger.debug(f\"Registering Pyro (de)serializers for {func.__name__} annotation '{name}': {model.__qualname__}\")\n            pyro.register_class_to_dict(model, _make_custom_serializer(model))\n            pyro.register_dict_to_class(model.__qualname__, _make_custom_deserializer(model))\n'Register custom serializers and deserializers for annotated Pydantic models'"
    },
    {
      "id": "n3",
      "type": "block",
      "statements": [
        "(name, annotation)",
        "func.__annotations__.items()"
      ],
      "code": "(name, annotation)\nfunc.__annotations__.items()"
    },
    {
      "id": "n4",
      "type": "block",
      "statements": [
        "try:\n    pydantic_types = _pydantic_models_from_type_annotation(annotation)\nexcept Exception as e:\n    raise TypeError(f'Error while exposing {func.__name__}: {e.__str__()}')",
        "pydantic_types = _pydantic_models_from_type_annotation(annotation)",
        "raise TypeError(f'Error while exposing {func.__name__}: {e.__str__()}')"
      ],
      "code": "try:\n    pydantic_types = _pydantic_models_from_type_annotation(annotation)\nexcept Exception as e:\n    raise TypeError(f'Error while exposing {func.__name__}: {e.__str__()}')\npydantic_types = _pydantic_models_from_type_annotation(annotation)\nraise TypeError(f'Error while exposing {func.__name__}: {e.__str__()}')"
    },
    {
      "id": "n5",
      "type": "block",
      "statements": [
        "def _make_custom_serializer(model: Type[BaseModel]):\n\n    def custom_class_to_dict(obj):\n        data = {'__class__': obj.__class__.__qualname__, **obj.model_dump()}\n        logger.debug(f'Serializing {obj.__class__.__qualname__} with data: {data}')\n        return data\n    return custom_class_to_dict",
        "def custom_class_to_dict(obj):\n    data = {'__class__': obj.__class__.__qualname__, **obj.model_dump()}\n    logger.debug(f'Serializing {obj.__class__.__qualname__} with data: {data}')\n    return data",
        "data = {'__class__': obj.__class__.__qualname__, **obj.model_dump()}",
        "logger.debug(f'Serializing {obj.__class__.__qualname__} with data: {data}')",
        "return data"
      ],
      "code": "def _make_custom_serializer(model: Type[BaseModel]):\n\n    def custom_class_to_dict(obj):\n        data = {'__class__': obj.__class__.__qualname__, **obj.model_dump()}\n        logger.debug(f'Serializing {obj.__class__.__qualname__} with data: {data}')\n        return data\n    return custom_class_to_dict\ndef custom_class_to_dict(obj):\n    data = {'__class__': obj.__class__.__qualname__, **obj.model_dump()}\n    logger.debug(f'Serializing {obj.__class__.__qualname__} with data: {data}')\n    return data\ndata = {'__class__': obj.__class__.__qualname__, **obj.model_dump()}\nlogger.debug(f'Serializing {obj.__class__.__qualname__} with data: {data}')\nreturn data"
    },
    {
      "id": "n6",
      "type": "block",
      "statements": [
        "model",
        "pydantic_types"
      ],
      "code": "model\npydantic_types"
    },
    {
      "id": "n7",
      "type": "block",
      "statements": [
        "logger.debug(f\"Registering Pyro (de)serializers for {func.__name__} annotation '{name}': {model.__qualname__}\")",
        "pyro.register_class_to_dict(model, _make_custom_serializer(model))",
        "pyro.register_dict_to_class(model.__qualname__, _make_custom_deserializer(model))"
      ],
      "code": "logger.debug(f\"Registering Pyro (de)serializers for {func.__name__} annotation '{name}': {model.__qualname__}\")\npyro.register_class_to_dict(model, _make_custom_serializer(model))\npyro.register_dict_to_class(model.__qualname__, _make_custom_deserializer(model))"
    },
    {
      "id": "n8",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n9",
      "type": "block",
      "statements": [
        "return custom_class_to_dict"
      ],
      "code": "return custom_class_to_dict"
    },
    {
      "id": "n10",
      "type": "block",
      "statements": [
        "def _make_custom_deserializer(model: Type[BaseModel]):\n\n    def custom_dict_to_class(qualname, data: dict):\n        logger.debug(f'Deserializing {model.__qualname__} from data: {data}')\n        return model(**data)\n    return custom_dict_to_class",
        "def custom_dict_to_class(qualname, data: dict):\n    logger.debug(f'Deserializing {model.__qualname__} from data: {data}')\n    return model(**data)",
        "logger.debug(f'Deserializing {model.__qualname__} from data: {data}')",
        "return model(**data)"
      ],
      "code": "def _make_custom_deserializer(model: Type[BaseModel]):\n\n    def custom_dict_to_class(qualname, data: dict):\n        logger.debug(f'Deserializing {model.__qualname__} from data: {data}')\n        return model(**data)\n    return custom_dict_to_class\ndef custom_dict_to_class(qualname, data: dict):\n    logger.debug(f'Deserializing {model.__qualname__} from data: {data}')\n    return model(**data)\nlogger.debug(f'Deserializing {model.__qualname__} from data: {data}')\nreturn model(**data)"
    },
    {
      "id": "n11",
      "type": "block",
      "statements": [
        "return custom_dict_to_class"
      ],
      "code": "return custom_dict_to_class"
    },
    {
      "id": "n12",
      "type": "block",
      "statements": [
        "class AppService(AppProcess, ABC):\n    shared_event_loop: asyncio.AbstractEventLoop\n    use_db: bool = False\n    use_redis: bool = False\n    use_supabase: bool = False\n\n    def __init__(self):\n        self.uri = None\n\n    @classmethod\n    @abstractmethod\n    def get_port(cls) -> int:\n        pass\n\n    @classmethod\n    def get_host(cls) -> str:\n        return os.environ.get(f'{cls.service_name.upper()}_HOST', config.pyro_host)\n\n    def run_service(self) -> None:\n        while True:\n            time.sleep(10)\n\n    def __run_async(self, coro: Coroutine[Any, Any, T]):\n        return asyncio.run_coroutine_threadsafe(coro, self.shared_event_loop)\n\n    def run_and_wait(self, coro: Coroutine[Any, Any, T]) -> T:\n        future = self.__run_async(coro)\n        return future.result()\n\n    def run(self):\n        self.shared_event_loop = asyncio.get_event_loop()\n        if self.use_db:\n            self.shared_event_loop.run_until_complete(db.connect())\n        if self.use_redis:\n            redis.connect()\n        if self.use_supabase:\n            from supabase import create_client\n            secrets = Secrets()\n            self.supabase = create_client(secrets.supabase_url, secrets.supabase_service_role_key)\n        async_thread = threading.Thread(target=self.__start_async_loop)\n        async_thread.daemon = True\n        async_thread.start()\n        daemon_thread = threading.Thread(target=self.__start_pyro)\n        daemon_thread.daemon = True\n        daemon_thread.start()\n        self.run_service()\n\n    def cleanup(self):\n        if self.use_db:\n            logger.info(f'[{self.__class__.__name__}] ⏳ Disconnecting DB...')\n            self.run_and_wait(db.disconnect())\n        if self.use_redis:\n            logger.info(f'[{self.__class__.__name__}] ⏳ Disconnecting Redis...')\n            redis.disconnect()\n\n    @conn_retry('Pyro', 'Starting Pyro Service')\n    def __start_pyro(self):\n        maximum_connection_thread_count = max(Pyro5.config.THREADPOOL_SIZE, config.num_node_workers * config.num_graph_workers)\n        Pyro5.config.THREADPOOL_SIZE = maximum_connection_thread_count\n        daemon = Pyro5.api.Daemon(host=config.pyro_host, port=self.get_port())\n        self.uri = daemon.register(self, objectId=self.service_name)\n        logger.info(f'[{self.service_name}] Connected to Pyro; URI = {self.uri}')\n        daemon.requestLoop()\n\n    def __start_async_loop(self):\n        self.shared_event_loop.run_forever()",
        "shared_event_loop: asyncio.AbstractEventLoop",
        "use_db: bool = False",
        "use_redis: bool = False",
        "use_supabase: bool = False",
        "def __init__(self):\n    self.uri = None",
        "self.uri = None",
        "@classmethod\n@abstractmethod\ndef get_port(cls) -> int:\n    pass",
        "pass",
        "@classmethod\ndef get_host(cls) -> str:\n    return os.environ.get(f'{cls.service_name.upper()}_HOST', config.pyro_host)",
        "return os.environ.get(f'{cls.service_name.upper()}_HOST', config.pyro_host)"
      ],
      "code": "class AppService(AppProcess, ABC):\n    shared_event_loop: asyncio.AbstractEventLoop\n    use_db: bool = False\n    use_redis: bool = False\n    use_supabase: bool = False\n\n    def __init__(self):\n        self.uri = None\n\n    @classmethod\n    @abstractmethod\n    def get_port(cls) -> int:\n        pass\n\n    @classmethod\n    def get_host(cls) -> str:\n        return os.environ.get(f'{cls.service_name.upper()}_HOST', config.pyro_host)\n\n    def run_service(self) -> None:\n        while True:\n            time.sleep(10)\n\n    def __run_async(self, coro: Coroutine[Any, Any, T]):\n        return asyncio.run_coroutine_threadsafe(coro, self.shared_event_loop)\n\n    def run_and_wait(self, coro: Coroutine[Any, Any, T]) -> T:\n        future = self.__run_async(coro)\n        return future.result()\n\n    def run(self):\n        self.shared_event_loop = asyncio.get_event_loop()\n        if self.use_db:\n            self.shared_event_loop.run_until_complete(db.connect())\n        if self.use_redis:\n            redis.connect()\n        if self.use_supabase:\n            from supabase import create_client\n            secrets = Secrets()\n            self.supabase = create_client(secrets.supabase_url, secrets.supabase_service_role_key)\n        async_thread = threading.Thread(target=self.__start_async_loop)\n        async_thread.daemon = True\n        async_thread.start()\n        daemon_thread = threading.Thread(target=self.__start_pyro)\n        daemon_thread.daemon = True\n        daemon_thread.start()\n        self.run_service()\n\n    def cleanup(self):\n        if self.use_db:\n            logger.info(f'[{self.__class__.__name__}] ⏳ Disconnecting DB...')\n            self.run_and_wait(db.disconnect())\n        if self.use_redis:\n            logger.info(f'[{self.__class__.__name__}] ⏳ Disconnecting Redis...')\n            redis.disconnect()\n\n    @conn_retry('Pyro', 'Starting Pyro Service')\n    def __start_pyro(self):\n        maximum_connection_thread_count = max(Pyro5.config.THREADPOOL_SIZE, config.num_node_workers * config.num_graph_workers)\n        Pyro5.config.THREADPOOL_SIZE = maximum_connection_thread_count\n        daemon = Pyro5.api.Daemon(host=config.pyro_host, port=self.get_port())\n        self.uri = daemon.register(self, objectId=self.service_name)\n        logger.info(f'[{self.service_name}] Connected to Pyro; URI = {self.uri}')\n        daemon.requestLoop()\n\n    def __start_async_loop(self):\n        self.shared_event_loop.run_forever()\nshared_event_loop: asyncio.AbstractEventLoop\nuse_db: bool = False\nuse_redis: bool = False\nuse_supabase: bool = False\ndef __init__(self):\n    self.uri = None\nself.uri = None\n@classmethod\n@abstractmethod\ndef get_port(cls) -> int:\n    pass\npass\n@classmethod\ndef get_host(cls) -> str:\n    return os.environ.get(f'{cls.service_name.upper()}_HOST', config.pyro_host)\nreturn os.environ.get(f'{cls.service_name.upper()}_HOST', config.pyro_host)"
    },
    {
      "id": "n13",
      "type": "block",
      "statements": [
        "def run_service(self) -> None:\n    while True:\n        time.sleep(10)"
      ],
      "code": "def run_service(self) -> None:\n    while True:\n        time.sleep(10)"
    },
    {
      "id": "n14",
      "type": "block",
      "statements": [
        "True"
      ],
      "code": "True"
    },
    {
      "id": "n15",
      "type": "block",
      "statements": [
        "time.sleep(10)"
      ],
      "code": "time.sleep(10)"
    },
    {
      "id": "n16",
      "type": "block",
      "statements": [
        "def __run_async(self, coro: Coroutine[Any, Any, T]):\n    return asyncio.run_coroutine_threadsafe(coro, self.shared_event_loop)",
        "return asyncio.run_coroutine_threadsafe(coro, self.shared_event_loop)"
      ],
      "code": "def __run_async(self, coro: Coroutine[Any, Any, T]):\n    return asyncio.run_coroutine_threadsafe(coro, self.shared_event_loop)\nreturn asyncio.run_coroutine_threadsafe(coro, self.shared_event_loop)"
    },
    {
      "id": "n17",
      "type": "block",
      "statements": [
        "def run_and_wait(self, coro: Coroutine[Any, Any, T]) -> T:\n    future = self.__run_async(coro)\n    return future.result()",
        "future = self.__run_async(coro)",
        "return future.result()"
      ],
      "code": "def run_and_wait(self, coro: Coroutine[Any, Any, T]) -> T:\n    future = self.__run_async(coro)\n    return future.result()\nfuture = self.__run_async(coro)\nreturn future.result()"
    },
    {
      "id": "n18",
      "type": "block",
      "statements": [
        "def run(self):\n    self.shared_event_loop = asyncio.get_event_loop()\n    if self.use_db:\n        self.shared_event_loop.run_until_complete(db.connect())\n    if self.use_redis:\n        redis.connect()\n    if self.use_supabase:\n        from supabase import create_client\n        secrets = Secrets()\n        self.supabase = create_client(secrets.supabase_url, secrets.supabase_service_role_key)\n    async_thread = threading.Thread(target=self.__start_async_loop)\n    async_thread.daemon = True\n    async_thread.start()\n    daemon_thread = threading.Thread(target=self.__start_pyro)\n    daemon_thread.daemon = True\n    daemon_thread.start()\n    self.run_service()",
        "self.shared_event_loop = asyncio.get_event_loop()",
        "self.use_db"
      ],
      "code": "def run(self):\n    self.shared_event_loop = asyncio.get_event_loop()\n    if self.use_db:\n        self.shared_event_loop.run_until_complete(db.connect())\n    if self.use_redis:\n        redis.connect()\n    if self.use_supabase:\n        from supabase import create_client\n        secrets = Secrets()\n        self.supabase = create_client(secrets.supabase_url, secrets.supabase_service_role_key)\n    async_thread = threading.Thread(target=self.__start_async_loop)\n    async_thread.daemon = True\n    async_thread.start()\n    daemon_thread = threading.Thread(target=self.__start_pyro)\n    daemon_thread.daemon = True\n    daemon_thread.start()\n    self.run_service()\nself.shared_event_loop = asyncio.get_event_loop()\nself.use_db"
    },
    {
      "id": "n19",
      "type": "block",
      "statements": [
        "self.shared_event_loop.run_until_complete(db.connect())"
      ],
      "code": "self.shared_event_loop.run_until_complete(db.connect())"
    },
    {
      "id": "n20",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n21",
      "type": "block",
      "statements": [
        "self.use_redis"
      ],
      "code": "self.use_redis"
    },
    {
      "id": "n22",
      "type": "block",
      "statements": [
        "redis.connect()"
      ],
      "code": "redis.connect()"
    },
    {
      "id": "n23",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n24",
      "type": "block",
      "statements": [
        "self.use_supabase"
      ],
      "code": "self.use_supabase"
    },
    {
      "id": "n25",
      "type": "block",
      "statements": [
        "from supabase import create_client",
        "secrets = Secrets()",
        "self.supabase = create_client(secrets.supabase_url, secrets.supabase_service_role_key)"
      ],
      "code": "from supabase import create_client\nsecrets = Secrets()\nself.supabase = create_client(secrets.supabase_url, secrets.supabase_service_role_key)"
    },
    {
      "id": "n26",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n27",
      "type": "block",
      "statements": [
        "async_thread = threading.Thread(target=self.__start_async_loop)",
        "async_thread.daemon = True",
        "async_thread.start()",
        "daemon_thread = threading.Thread(target=self.__start_pyro)",
        "daemon_thread.daemon = True",
        "daemon_thread.start()",
        "self.run_service()",
        "def cleanup(self):\n    if self.use_db:\n        logger.info(f'[{self.__class__.__name__}] ⏳ Disconnecting DB...')\n        self.run_and_wait(db.disconnect())\n    if self.use_redis:\n        logger.info(f'[{self.__class__.__name__}] ⏳ Disconnecting Redis...')\n        redis.disconnect()",
        "self.use_db"
      ],
      "code": "async_thread = threading.Thread(target=self.__start_async_loop)\nasync_thread.daemon = True\nasync_thread.start()\ndaemon_thread = threading.Thread(target=self.__start_pyro)\ndaemon_thread.daemon = True\ndaemon_thread.start()\nself.run_service()\ndef cleanup(self):\n    if self.use_db:\n        logger.info(f'[{self.__class__.__name__}] ⏳ Disconnecting DB...')\n        self.run_and_wait(db.disconnect())\n    if self.use_redis:\n        logger.info(f'[{self.__class__.__name__}] ⏳ Disconnecting Redis...')\n        redis.disconnect()\nself.use_db"
    },
    {
      "id": "n28",
      "type": "block",
      "statements": [
        "logger.info(f'[{self.__class__.__name__}] ⏳ Disconnecting DB...')",
        "self.run_and_wait(db.disconnect())"
      ],
      "code": "logger.info(f'[{self.__class__.__name__}] ⏳ Disconnecting DB...')\nself.run_and_wait(db.disconnect())"
    },
    {
      "id": "n29",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n30",
      "type": "block",
      "statements": [
        "self.use_redis"
      ],
      "code": "self.use_redis"
    },
    {
      "id": "n31",
      "type": "block",
      "statements": [
        "logger.info(f'[{self.__class__.__name__}] ⏳ Disconnecting Redis...')",
        "redis.disconnect()"
      ],
      "code": "logger.info(f'[{self.__class__.__name__}] ⏳ Disconnecting Redis...')\nredis.disconnect()"
    },
    {
      "id": "n32",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n33",
      "type": "block",
      "statements": [
        "@conn_retry('Pyro', 'Starting Pyro Service')\ndef __start_pyro(self):\n    maximum_connection_thread_count = max(Pyro5.config.THREADPOOL_SIZE, config.num_node_workers * config.num_graph_workers)\n    Pyro5.config.THREADPOOL_SIZE = maximum_connection_thread_count\n    daemon = Pyro5.api.Daemon(host=config.pyro_host, port=self.get_port())\n    self.uri = daemon.register(self, objectId=self.service_name)\n    logger.info(f'[{self.service_name}] Connected to Pyro; URI = {self.uri}')\n    daemon.requestLoop()",
        "maximum_connection_thread_count = max(Pyro5.config.THREADPOOL_SIZE, config.num_node_workers * config.num_graph_workers)",
        "Pyro5.config.THREADPOOL_SIZE = maximum_connection_thread_count",
        "daemon = Pyro5.api.Daemon(host=config.pyro_host, port=self.get_port())",
        "self.uri = daemon.register(self, objectId=self.service_name)",
        "logger.info(f'[{self.service_name}] Connected to Pyro; URI = {self.uri}')",
        "daemon.requestLoop()",
        "def __start_async_loop(self):\n    self.shared_event_loop.run_forever()",
        "self.shared_event_loop.run_forever()",
        "AS = TypeVar('AS', bound=AppService)",
        "class PyroClient:\n    proxy: Pyro5.api.Proxy",
        "proxy: Pyro5.api.Proxy",
        "def close_service_client(client: AppService) -> None:\n    if isinstance(client, PyroClient):\n        client.proxy._pyroRelease()\n    else:\n        raise RuntimeError(f'Client {client.__class__} is not a Pyro client.')",
        "isinstance(client, PyroClient)"
      ],
      "code": "@conn_retry('Pyro', 'Starting Pyro Service')\ndef __start_pyro(self):\n    maximum_connection_thread_count = max(Pyro5.config.THREADPOOL_SIZE, config.num_node_workers * config.num_graph_workers)\n    Pyro5.config.THREADPOOL_SIZE = maximum_connection_thread_count\n    daemon = Pyro5.api.Daemon(host=config.pyro_host, port=self.get_port())\n    self.uri = daemon.register(self, objectId=self.service_name)\n    logger.info(f'[{self.service_name}] Connected to Pyro; URI = {self.uri}')\n    daemon.requestLoop()\nmaximum_connection_thread_count = max(Pyro5.config.THREADPOOL_SIZE, config.num_node_workers * config.num_graph_workers)\nPyro5.config.THREADPOOL_SIZE = maximum_connection_thread_count\ndaemon = Pyro5.api.Daemon(host=config.pyro_host, port=self.get_port())\nself.uri = daemon.register(self, objectId=self.service_name)\nlogger.info(f'[{self.service_name}] Connected to Pyro; URI = {self.uri}')\ndaemon.requestLoop()\ndef __start_async_loop(self):\n    self.shared_event_loop.run_forever()\nself.shared_event_loop.run_forever()\nAS = TypeVar('AS', bound=AppService)\nclass PyroClient:\n    proxy: Pyro5.api.Proxy\nproxy: Pyro5.api.Proxy\ndef close_service_client(client: AppService) -> None:\n    if isinstance(client, PyroClient):\n        client.proxy._pyroRelease()\n    else:\n        raise RuntimeError(f'Client {client.__class__} is not a Pyro client.')\nisinstance(client, PyroClient)"
    },
    {
      "id": "n34",
      "type": "block",
      "statements": [
        "client.proxy._pyroRelease()"
      ],
      "code": "client.proxy._pyroRelease()"
    },
    {
      "id": "n35",
      "type": "block",
      "statements": [
        "raise RuntimeError(f'Client {client.__class__} is not a Pyro client.')"
      ],
      "code": "raise RuntimeError(f'Client {client.__class__} is not a Pyro client.')"
    },
    {
      "id": "n36",
      "type": "block",
      "statements": [
        "def get_service_client(service_type: Type[AS]) -> AS:\n    service_name = service_type.service_name\n\n    class DynamicClient(PyroClient):\n\n        @conn_retry('Pyro', f'Connecting to [{service_name}]')\n        def __init__(self):\n            host = os.environ.get(f'{service_name.upper()}_HOST', pyro_host)\n            uri = f'PYRO:{service_type.service_name}@{host}:{service_type.get_port()}'\n            logger.debug(f'Connecting to service [{service_name}]. URI = {uri}')\n            self.proxy = Pyro5.api.Proxy(uri)\n            self.proxy._pyroBind()\n            logger.debug(f'Successfully connected to service [{service_name}]')\n\n        def __getattr__(self, name: str) -> Callable[..., Any]:\n            res = getattr(self.proxy, name)\n            return res\n    return cast(AS, DynamicClient())",
        "service_name = service_type.service_name",
        "class DynamicClient(PyroClient):\n\n    @conn_retry('Pyro', f'Connecting to [{service_name}]')\n    def __init__(self):\n        host = os.environ.get(f'{service_name.upper()}_HOST', pyro_host)\n        uri = f'PYRO:{service_type.service_name}@{host}:{service_type.get_port()}'\n        logger.debug(f'Connecting to service [{service_name}]. URI = {uri}')\n        self.proxy = Pyro5.api.Proxy(uri)\n        self.proxy._pyroBind()\n        logger.debug(f'Successfully connected to service [{service_name}]')\n\n    def __getattr__(self, name: str) -> Callable[..., Any]:\n        res = getattr(self.proxy, name)\n        return res",
        "@conn_retry('Pyro', f'Connecting to [{service_name}]')\ndef __init__(self):\n    host = os.environ.get(f'{service_name.upper()}_HOST', pyro_host)\n    uri = f'PYRO:{service_type.service_name}@{host}:{service_type.get_port()}'\n    logger.debug(f'Connecting to service [{service_name}]. URI = {uri}')\n    self.proxy = Pyro5.api.Proxy(uri)\n    self.proxy._pyroBind()\n    logger.debug(f'Successfully connected to service [{service_name}]')",
        "host = os.environ.get(f'{service_name.upper()}_HOST', pyro_host)",
        "uri = f'PYRO:{service_type.service_name}@{host}:{service_type.get_port()}'",
        "logger.debug(f'Connecting to service [{service_name}]. URI = {uri}')",
        "self.proxy = Pyro5.api.Proxy(uri)",
        "self.proxy._pyroBind()",
        "logger.debug(f'Successfully connected to service [{service_name}]')",
        "def __getattr__(self, name: str) -> Callable[..., Any]:\n    res = getattr(self.proxy, name)\n    return res",
        "res = getattr(self.proxy, name)",
        "return res"
      ],
      "code": "def get_service_client(service_type: Type[AS]) -> AS:\n    service_name = service_type.service_name\n\n    class DynamicClient(PyroClient):\n\n        @conn_retry('Pyro', f'Connecting to [{service_name}]')\n        def __init__(self):\n            host = os.environ.get(f'{service_name.upper()}_HOST', pyro_host)\n            uri = f'PYRO:{service_type.service_name}@{host}:{service_type.get_port()}'\n            logger.debug(f'Connecting to service [{service_name}]. URI = {uri}')\n            self.proxy = Pyro5.api.Proxy(uri)\n            self.proxy._pyroBind()\n            logger.debug(f'Successfully connected to service [{service_name}]')\n\n        def __getattr__(self, name: str) -> Callable[..., Any]:\n            res = getattr(self.proxy, name)\n            return res\n    return cast(AS, DynamicClient())\nservice_name = service_type.service_name\nclass DynamicClient(PyroClient):\n\n    @conn_retry('Pyro', f'Connecting to [{service_name}]')\n    def __init__(self):\n        host = os.environ.get(f'{service_name.upper()}_HOST', pyro_host)\n        uri = f'PYRO:{service_type.service_name}@{host}:{service_type.get_port()}'\n        logger.debug(f'Connecting to service [{service_name}]. URI = {uri}')\n        self.proxy = Pyro5.api.Proxy(uri)\n        self.proxy._pyroBind()\n        logger.debug(f'Successfully connected to service [{service_name}]')\n\n    def __getattr__(self, name: str) -> Callable[..., Any]:\n        res = getattr(self.proxy, name)\n        return res\n@conn_retry('Pyro', f'Connecting to [{service_name}]')\ndef __init__(self):\n    host = os.environ.get(f'{service_name.upper()}_HOST', pyro_host)\n    uri = f'PYRO:{service_type.service_name}@{host}:{service_type.get_port()}'\n    logger.debug(f'Connecting to service [{service_name}]. URI = {uri}')\n    self.proxy = Pyro5.api.Proxy(uri)\n    self.proxy._pyroBind()\n    logger.debug(f'Successfully connected to service [{service_name}]')\nhost = os.environ.get(f'{service_name.upper()}_HOST', pyro_host)\nuri = f'PYRO:{service_type.service_name}@{host}:{service_type.get_port()}'\nlogger.debug(f'Connecting to service [{service_name}]. URI = {uri}')\nself.proxy = Pyro5.api.Proxy(uri)\nself.proxy._pyroBind()\nlogger.debug(f'Successfully connected to service [{service_name}]')\ndef __getattr__(self, name: str) -> Callable[..., Any]:\n    res = getattr(self.proxy, name)\n    return res\nres = getattr(self.proxy, name)\nreturn res"
    },
    {
      "id": "n37",
      "type": "block",
      "statements": [
        "return cast(AS, DynamicClient())"
      ],
      "code": "return cast(AS, DynamicClient())"
    },
    {
      "id": "n38",
      "type": "block",
      "statements": [
        "builtin_types = [*vars(builtins).values(), NoneType, Enum]",
        "def _pydantic_models_from_type_annotation(annotation) -> Iterator[type[BaseModel]]:\n    if (origin := get_origin(annotation)) and origin is Annotated:\n        annotation = get_args(annotation)[0]\n    origin = get_origin(annotation)\n    args = get_args(annotation)\n    if origin in (Union, UnionType, list, List, tuple, Tuple, set, Set, frozenset, FrozenSet):\n        for arg in args:\n            yield from _pydantic_models_from_type_annotation(arg)\n    elif origin in (dict, Dict):\n        (key_type, value_type) = args\n        yield from _pydantic_models_from_type_annotation(key_type)\n        yield from _pydantic_models_from_type_annotation(value_type)\n    elif origin in (Awaitable, Coroutine):\n        return_type = args[-1]\n        yield from _pydantic_models_from_type_annotation(return_type)\n    else:\n        annotype = annotation if origin is None else origin\n        if annotype is not None and (not hasattr(typing, getattr(annotype, '__name__', ''))) and isinstance(annotype, type):\n            if issubclass(annotype, BaseModel):\n                yield annotype\n            elif annotype not in builtin_types and (not issubclass(annotype, Enum)):\n                raise TypeError(f'Unsupported type encountered: {annotype}')",
        "(origin := get_origin(annotation)) and origin is Annotated"
      ],
      "code": "builtin_types = [*vars(builtins).values(), NoneType, Enum]\ndef _pydantic_models_from_type_annotation(annotation) -> Iterator[type[BaseModel]]:\n    if (origin := get_origin(annotation)) and origin is Annotated:\n        annotation = get_args(annotation)[0]\n    origin = get_origin(annotation)\n    args = get_args(annotation)\n    if origin in (Union, UnionType, list, List, tuple, Tuple, set, Set, frozenset, FrozenSet):\n        for arg in args:\n            yield from _pydantic_models_from_type_annotation(arg)\n    elif origin in (dict, Dict):\n        (key_type, value_type) = args\n        yield from _pydantic_models_from_type_annotation(key_type)\n        yield from _pydantic_models_from_type_annotation(value_type)\n    elif origin in (Awaitable, Coroutine):\n        return_type = args[-1]\n        yield from _pydantic_models_from_type_annotation(return_type)\n    else:\n        annotype = annotation if origin is None else origin\n        if annotype is not None and (not hasattr(typing, getattr(annotype, '__name__', ''))) and isinstance(annotype, type):\n            if issubclass(annotype, BaseModel):\n                yield annotype\n            elif annotype not in builtin_types and (not issubclass(annotype, Enum)):\n                raise TypeError(f'Unsupported type encountered: {annotype}')\n(origin := get_origin(annotation)) and origin is Annotated"
    },
    {
      "id": "n39",
      "type": "block",
      "statements": [
        "annotation = get_args(annotation)[0]"
      ],
      "code": "annotation = get_args(annotation)[0]"
    },
    {
      "id": "n40",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n41",
      "type": "block",
      "statements": [
        "origin = get_origin(annotation)",
        "args = get_args(annotation)",
        "origin In (Union, UnionType, list, List, tuple, Tuple, set, Set, frozenset, FrozenSet)"
      ],
      "code": "origin = get_origin(annotation)\nargs = get_args(annotation)\norigin In (Union, UnionType, list, List, tuple, Tuple, set, Set, frozenset, FrozenSet)"
    },
    {
      "id": "n42",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n43",
      "type": "block",
      "statements": [
        "origin In (dict, Dict)"
      ],
      "code": "origin In (dict, Dict)"
    },
    {
      "id": "n44",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n45",
      "type": "block",
      "statements": [
        "arg",
        "args"
      ],
      "code": "arg\nargs"
    },
    {
      "id": "n46",
      "type": "block",
      "statements": [
        "(yield from _pydantic_models_from_type_annotation(arg))"
      ],
      "code": "(yield from _pydantic_models_from_type_annotation(arg))"
    },
    {
      "id": "n47",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n48",
      "type": "block",
      "statements": [
        "(key_type, value_type) = args",
        "(yield from _pydantic_models_from_type_annotation(key_type))",
        "(yield from _pydantic_models_from_type_annotation(value_type))"
      ],
      "code": "(key_type, value_type) = args\n(yield from _pydantic_models_from_type_annotation(key_type))\n(yield from _pydantic_models_from_type_annotation(value_type))"
    },
    {
      "id": "n49",
      "type": "block",
      "statements": [
        "origin In (Awaitable, Coroutine)"
      ],
      "code": "origin In (Awaitable, Coroutine)"
    },
    {
      "id": "n50",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n51",
      "type": "block",
      "statements": [
        "return_type = args[-1]",
        "(yield from _pydantic_models_from_type_annotation(return_type))"
      ],
      "code": "return_type = args[-1]\n(yield from _pydantic_models_from_type_annotation(return_type))"
    },
    {
      "id": "n52",
      "type": "block",
      "statements": [
        "annotype = annotation if origin is None else origin",
        "annotype is not None and (not hasattr(typing, getattr(annotype, '__name__', ''))) and isinstance(annotype, type)"
      ],
      "code": "annotype = annotation if origin is None else origin\nannotype is not None and (not hasattr(typing, getattr(annotype, '__name__', ''))) and isinstance(annotype, type)"
    },
    {
      "id": "n53",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n54",
      "type": "block",
      "statements": [
        "issubclass(annotype, BaseModel)"
      ],
      "code": "issubclass(annotype, BaseModel)"
    },
    {
      "id": "n55",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n56",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n57",
      "type": "block",
      "statements": [
        "(yield annotype)"
      ],
      "code": "(yield annotype)"
    },
    {
      "id": "n58",
      "type": "block",
      "statements": [
        "annotype not in builtin_types and (not issubclass(annotype, Enum))"
      ],
      "code": "annotype not in builtin_types and (not issubclass(annotype, Enum))"
    },
    {
      "id": "n59",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n60",
      "type": "block",
      "statements": [
        "raise TypeError(f'Unsupported type encountered: {annotype}')"
      ],
      "code": "raise TypeError(f'Unsupported type encountered: {annotype}')"
    },
    {
      "id": "n61",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n62",
      "type": "block",
      "statements": [],
      "code": ""
    }
  ],
  "edges": [
    {
      "source": "n38",
      "target": "n39"
    },
    {
      "source": "n52",
      "target": "n55"
    },
    {
      "source": "n55",
      "target": "n56"
    },
    {
      "source": "n6",
      "target": "n7"
    },
    {
      "source": "n14",
      "target": "n15"
    },
    {
      "source": "n53",
      "target": "n50"
    },
    {
      "source": "n46",
      "target": "n45"
    },
    {
      "source": "n21",
      "target": "n22"
    },
    {
      "source": "n42",
      "target": "n45"
    },
    {
      "source": "n54",
      "target": "n58"
    },
    {
      "source": "n26",
      "target": "n27"
    },
    {
      "source": "n54",
      "target": "n57"
    },
    {
      "source": "n19",
      "target": "n21"
    },
    {
      "source": "n13",
      "target": "n14"
    },
    {
      "source": "n2",
      "target": "n3"
    },
    {
      "source": "n40",
      "target": "n41"
    },
    {
      "source": "n43",
      "target": "n48"
    },
    {
      "source": "n23",
      "target": "n24"
    },
    {
      "source": "n35",
      "target": "n36"
    },
    {
      "source": "n43",
      "target": "n49"
    },
    {
      "source": "n3",
      "target": "n4"
    },
    {
      "source": "n33",
      "target": "n35"
    },
    {
      "source": "n30",
      "target": "n32"
    },
    {
      "source": "n4",
      "target": "n6"
    },
    {
      "source": "n58",
      "target": "n60"
    },
    {
      "source": "n30",
      "target": "n31"
    },
    {
      "source": "n24",
      "target": "n25"
    },
    {
      "source": "n34",
      "target": "n36"
    },
    {
      "source": "n31",
      "target": "n33"
    },
    {
      "source": "n21",
      "target": "n23"
    },
    {
      "source": "n29",
      "target": "n30"
    },
    {
      "source": "n8",
      "target": "n3"
    },
    {
      "source": "n7",
      "target": "n6"
    },
    {
      "source": "n59",
      "target": "n56"
    },
    {
      "source": "n51",
      "target": "n53"
    },
    {
      "source": "n47",
      "target": "n44"
    },
    {
      "source": "n41",
      "target": "n43"
    },
    {
      "source": "n32",
      "target": "n33"
    },
    {
      "source": "n14",
      "target": "n16"
    },
    {
      "source": "n49",
      "target": "n51"
    },
    {
      "source": "n20",
      "target": "n21"
    },
    {
      "source": "n48",
      "target": "n50"
    },
    {
      "source": "n28",
      "target": "n30"
    },
    {
      "source": "n45",
      "target": "n47"
    },
    {
      "source": "n45",
      "target": "n46"
    },
    {
      "source": "n18",
      "target": "n19"
    },
    {
      "source": "n38",
      "target": "n40"
    },
    {
      "source": "n52",
      "target": "n54"
    },
    {
      "source": "n18",
      "target": "n20"
    },
    {
      "source": "n62",
      "target": "n59"
    },
    {
      "source": "n27",
      "target": "n29"
    },
    {
      "source": "n24",
      "target": "n26"
    },
    {
      "source": "n27",
      "target": "n28"
    },
    {
      "source": "n56",
      "target": "n53"
    },
    {
      "source": "n60",
      "target": "n62"
    },
    {
      "source": "n33",
      "target": "n34"
    },
    {
      "source": "n15",
      "target": "n14"
    },
    {
      "source": "n25",
      "target": "n27"
    },
    {
      "source": "n61",
      "target": "n62"
    },
    {
      "source": "n50",
      "target": "n44"
    },
    {
      "source": "n22",
      "target": "n24"
    },
    {
      "source": "n49",
      "target": "n52"
    },
    {
      "source": "n3",
      "target": "n5"
    },
    {
      "source": "n6",
      "target": "n8"
    },
    {
      "source": "n39",
      "target": "n41"
    },
    {
      "source": "n41",
      "target": "n42"
    },
    {
      "source": "n57",
      "target": "n59"
    },
    {
      "source": "n58",
      "target": "n61"
    }
  ]
}