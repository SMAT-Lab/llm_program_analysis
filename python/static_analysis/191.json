{
  "nodes": [
    {
      "id": "n0",
      "type": "block",
      "statements": [
        "from __future__ import annotations",
        "def get_valid_pos(position: tuple[int, int], n: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Find all the valid positions a knight can move to from the current position.\n\n    >>> get_valid_pos((1, 3), 4)\n    [(2, 1), (0, 1), (3, 2)]\n    \"\"\"\n    (y, x) = position\n    positions = [(y + 1, x + 2), (y - 1, x + 2), (y + 1, x - 2), (y - 1, x - 2), (y + 2, x + 1), (y + 2, x - 1), (y - 2, x + 1), (y - 2, x - 1)]\n    permissible_positions = []\n    for inner_position in positions:\n        (y_test, x_test) = inner_position\n        if 0 <= y_test < n and 0 <= x_test < n:\n            permissible_positions.append(inner_position)\n    return permissible_positions",
        "'\\n    Find all the valid positions a knight can move to from the current position.\\n\\n    >>> get_valid_pos((1, 3), 4)\\n    [(2, 1), (0, 1), (3, 2)]\\n    '",
        "(y, x) = position",
        "positions = [(y + 1, x + 2), (y - 1, x + 2), (y + 1, x - 2), (y - 1, x - 2), (y + 2, x + 1), (y + 2, x - 1), (y - 2, x + 1), (y - 2, x - 1)]",
        "permissible_positions = []"
      ],
      "code": "from __future__ import annotations\ndef get_valid_pos(position: tuple[int, int], n: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Find all the valid positions a knight can move to from the current position.\n\n    >>> get_valid_pos((1, 3), 4)\n    [(2, 1), (0, 1), (3, 2)]\n    \"\"\"\n    (y, x) = position\n    positions = [(y + 1, x + 2), (y - 1, x + 2), (y + 1, x - 2), (y - 1, x - 2), (y + 2, x + 1), (y + 2, x - 1), (y - 2, x + 1), (y - 2, x - 1)]\n    permissible_positions = []\n    for inner_position in positions:\n        (y_test, x_test) = inner_position\n        if 0 <= y_test < n and 0 <= x_test < n:\n            permissible_positions.append(inner_position)\n    return permissible_positions\n'\\n    Find all the valid positions a knight can move to from the current position.\\n\\n    >>> get_valid_pos((1, 3), 4)\\n    [(2, 1), (0, 1), (3, 2)]\\n    '\n(y, x) = position\npositions = [(y + 1, x + 2), (y - 1, x + 2), (y + 1, x - 2), (y - 1, x - 2), (y + 2, x + 1), (y + 2, x - 1), (y - 2, x + 1), (y - 2, x - 1)]\npermissible_positions = []"
    },
    {
      "id": "n1",
      "type": "block",
      "statements": [
        "inner_position",
        "positions"
      ],
      "code": "inner_position\npositions"
    },
    {
      "id": "n2",
      "type": "block",
      "statements": [
        "(y_test, x_test) = inner_position",
        "0 <= y_test < n and 0 <= x_test < n"
      ],
      "code": "(y_test, x_test) = inner_position\n0 <= y_test < n and 0 <= x_test < n"
    },
    {
      "id": "n3",
      "type": "block",
      "statements": [
        "return permissible_positions"
      ],
      "code": "return permissible_positions"
    },
    {
      "id": "n4",
      "type": "block",
      "statements": [
        "permissible_positions.append(inner_position)"
      ],
      "code": "permissible_positions.append(inner_position)"
    },
    {
      "id": "n5",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n6",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n7",
      "type": "block",
      "statements": [
        "def is_complete(board: list[list[int]]) -> bool:\n    \"\"\"\n    Check if the board (matrix) has been completely filled with non-zero values.\n\n    >>> is_complete([[1]])\n    True\n\n    >>> is_complete([[1, 2], [3, 0]])\n    False\n    \"\"\"\n    return not any((elem == 0 for row in board for elem in row))",
        "'\\n    Check if the board (matrix) has been completely filled with non-zero values.\\n\\n    >>> is_complete([[1]])\\n    True\\n\\n    >>> is_complete([[1, 2], [3, 0]])\\n    False\\n    '",
        "return not any((elem == 0 for row in board for elem in row))"
      ],
      "code": "def is_complete(board: list[list[int]]) -> bool:\n    \"\"\"\n    Check if the board (matrix) has been completely filled with non-zero values.\n\n    >>> is_complete([[1]])\n    True\n\n    >>> is_complete([[1, 2], [3, 0]])\n    False\n    \"\"\"\n    return not any((elem == 0 for row in board for elem in row))\n'\\n    Check if the board (matrix) has been completely filled with non-zero values.\\n\\n    >>> is_complete([[1]])\\n    True\\n\\n    >>> is_complete([[1, 2], [3, 0]])\\n    False\\n    '\nreturn not any((elem == 0 for row in board for elem in row))"
    },
    {
      "id": "n8",
      "type": "block",
      "statements": [
        "def open_knight_tour_helper(board: list[list[int]], pos: tuple[int, int], curr: int) -> bool:\n    \"\"\"\n    Helper function to solve knight tour problem.\n    \"\"\"\n    if is_complete(board):\n        return True\n    for position in get_valid_pos(pos, len(board)):\n        (y, x) = position\n        if board[y][x] == 0:\n            board[y][x] = curr + 1\n            if open_knight_tour_helper(board, position, curr + 1):\n                return True\n            board[y][x] = 0\n    return False",
        "'\\n    Helper function to solve knight tour problem.\\n    '",
        "is_complete(board)"
      ],
      "code": "def open_knight_tour_helper(board: list[list[int]], pos: tuple[int, int], curr: int) -> bool:\n    \"\"\"\n    Helper function to solve knight tour problem.\n    \"\"\"\n    if is_complete(board):\n        return True\n    for position in get_valid_pos(pos, len(board)):\n        (y, x) = position\n        if board[y][x] == 0:\n            board[y][x] = curr + 1\n            if open_knight_tour_helper(board, position, curr + 1):\n                return True\n            board[y][x] = 0\n    return False\n'\\n    Helper function to solve knight tour problem.\\n    '\nis_complete(board)"
    },
    {
      "id": "n9",
      "type": "block",
      "statements": [
        "return True"
      ],
      "code": "return True"
    },
    {
      "id": "n10",
      "type": "block",
      "statements": [],
      "code": "\n"
    },
    {
      "id": "n11",
      "type": "block",
      "statements": [
        "position",
        "get_valid_pos(pos, len(board))"
      ],
      "code": "position\nget_valid_pos(pos, len(board))"
    },
    {
      "id": "n12",
      "type": "block",
      "statements": [
        "(y, x) = position",
        "board[y][x] Eq 0"
      ],
      "code": "(y, x) = position\nboard[y][x] Eq 0"
    },
    {
      "id": "n13",
      "type": "block",
      "statements": [
        "return False"
      ],
      "code": "return False"
    },
    {
      "id": "n14",
      "type": "block",
      "statements": [
        "board[y][x] = curr + 1",
        "open_knight_tour_helper(board, position, curr Add 1)"
      ],
      "code": "board[y][x] = curr + 1\nopen_knight_tour_helper(board, position, curr Add 1)"
    },
    {
      "id": "n15",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n16",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n17",
      "type": "block",
      "statements": [
        "return True"
      ],
      "code": "return True"
    },
    {
      "id": "n18",
      "type": "block",
      "statements": [],
      "code": "\nboard[y][x] = 0"
    },
    {
      "id": "n19",
      "type": "block",
      "statements": [
        "def open_knight_tour(n: int) -> list[list[int]]:\n    \"\"\"\n    Find the solution for the knight tour problem for a board of size n. Raises\n    ValueError if the tour cannot be performed for the given size.\n\n    >>> open_knight_tour(1)\n    [[1]]\n\n    >>> open_knight_tour(2)\n    Traceback (most recent call last):\n        ...\n    ValueError: Open Knight Tour cannot be performed on a board of size 2\n    \"\"\"\n    board = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        for j in range(n):\n            board[i][j] = 1\n            if open_knight_tour_helper(board, (i, j), 1):\n                return board\n            board[i][j] = 0\n    msg = f'Open Knight Tour cannot be performed on a board of size {n}'\n    raise ValueError(msg)",
        "'\\n    Find the solution for the knight tour problem for a board of size n. Raises\\n    ValueError if the tour cannot be performed for the given size.\\n\\n    >>> open_knight_tour(1)\\n    [[1]]\\n\\n    >>> open_knight_tour(2)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: Open Knight Tour cannot be performed on a board of size 2\\n    '",
        "board = [[0 for i in range(n)] for j in range(n)]"
      ],
      "code": "def open_knight_tour(n: int) -> list[list[int]]:\n    \"\"\"\n    Find the solution for the knight tour problem for a board of size n. Raises\n    ValueError if the tour cannot be performed for the given size.\n\n    >>> open_knight_tour(1)\n    [[1]]\n\n    >>> open_knight_tour(2)\n    Traceback (most recent call last):\n        ...\n    ValueError: Open Knight Tour cannot be performed on a board of size 2\n    \"\"\"\n    board = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        for j in range(n):\n            board[i][j] = 1\n            if open_knight_tour_helper(board, (i, j), 1):\n                return board\n            board[i][j] = 0\n    msg = f'Open Knight Tour cannot be performed on a board of size {n}'\n    raise ValueError(msg)\n'\\n    Find the solution for the knight tour problem for a board of size n. Raises\\n    ValueError if the tour cannot be performed for the given size.\\n\\n    >>> open_knight_tour(1)\\n    [[1]]\\n\\n    >>> open_knight_tour(2)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: Open Knight Tour cannot be performed on a board of size 2\\n    '\nboard = [[0 for i in range(n)] for j in range(n)]"
    },
    {
      "id": "n20",
      "type": "block",
      "statements": [
        "i",
        "range(n)"
      ],
      "code": "i\nrange(n)"
    },
    {
      "id": "n21",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n22",
      "type": "block",
      "statements": [
        "msg = f'Open Knight Tour cannot be performed on a board of size {n}'",
        "raise ValueError(msg)",
        "__name__ Eq '__main__'"
      ],
      "code": "msg = f'Open Knight Tour cannot be performed on a board of size {n}'\nraise ValueError(msg)\n__name__ Eq '__main__'"
    },
    {
      "id": "n23",
      "type": "block",
      "statements": [
        "j",
        "range(n)"
      ],
      "code": "j\nrange(n)"
    },
    {
      "id": "n24",
      "type": "block",
      "statements": [
        "board[i][j] = 1",
        "open_knight_tour_helper(board, (i, j), 1)"
      ],
      "code": "board[i][j] = 1\nopen_knight_tour_helper(board, (i, j), 1)"
    },
    {
      "id": "n25",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n26",
      "type": "block",
      "statements": [
        "return board"
      ],
      "code": "return board"
    },
    {
      "id": "n27",
      "type": "block",
      "statements": [],
      "code": "\nboard[i][j] = 0"
    },
    {
      "id": "n28",
      "type": "block",
      "statements": [
        "import doctest",
        "doctest.testmod()"
      ],
      "code": "import doctest\ndoctest.testmod()"
    },
    {
      "id": "n29",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n30",
      "type": "block",
      "statements": [],
      "code": ""
    }
  ],
  "edges": [
    {
      "source": "n18",
      "target": "n16"
    },
    {
      "source": "n0",
      "target": "n1"
    },
    {
      "source": "n6",
      "target": "n1"
    },
    {
      "source": "n14",
      "target": "n17"
    },
    {
      "source": "n23",
      "target": "n25"
    },
    {
      "source": "n14",
      "target": "n18"
    },
    {
      "source": "n10",
      "target": "n11"
    },
    {
      "source": "n23",
      "target": "n24"
    },
    {
      "source": "n27",
      "target": "n23"
    },
    {
      "source": "n2",
      "target": "n4"
    },
    {
      "source": "n16",
      "target": "n11"
    },
    {
      "source": "n8",
      "target": "n9"
    },
    {
      "source": "n1",
      "target": "n2"
    },
    {
      "source": "n19",
      "target": "n20"
    },
    {
      "source": "n4",
      "target": "n6"
    },
    {
      "source": "n25",
      "target": "n20"
    },
    {
      "source": "n21",
      "target": "n23"
    },
    {
      "source": "n15",
      "target": "n16"
    },
    {
      "source": "n29",
      "target": "n30"
    },
    {
      "source": "n12",
      "target": "n14"
    },
    {
      "source": "n20",
      "target": "n21"
    },
    {
      "source": "n12",
      "target": "n15"
    },
    {
      "source": "n22",
      "target": "n29"
    },
    {
      "source": "n28",
      "target": "n30"
    },
    {
      "source": "n11",
      "target": "n12"
    },
    {
      "source": "n22",
      "target": "n28"
    },
    {
      "source": "n5",
      "target": "n6"
    },
    {
      "source": "n1",
      "target": "n3"
    },
    {
      "source": "n24",
      "target": "n26"
    },
    {
      "source": "n8",
      "target": "n10"
    },
    {
      "source": "n2",
      "target": "n5"
    },
    {
      "source": "n20",
      "target": "n22"
    },
    {
      "source": "n24",
      "target": "n27"
    },
    {
      "source": "n11",
      "target": "n13"
    }
  ]
}