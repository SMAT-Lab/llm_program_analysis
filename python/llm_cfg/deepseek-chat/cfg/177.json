{
    "nodes": [
        {
            "id": "chunk_0_GlobalBlock_1",
            "code": "from threading import Lock\nfrom typing import TYPE_CHECKING, Any\n\nfrom expiringdict import ExpiringDict\n\n"
        },
        {
            "id": "chunk_0_GlobalBlock_2",
            "code": "if TYPE_CHECKING:\n    from redis import Redis\n    from redis.lock import Lock as RedisLock\n"
        },
        {
            "id": "chunk_0_GlobalBlock_3",
            "code": "\n\n\n"
        },
        {
            "id": "chunk_1_RedisKeyedMutex_1",
            "code": "class RedisKeyedMutex:\n    \"\"\"\n    This class provides a mutex that can be locked and unlocked by a specific key,\n    using Redis as a distributed locking provider.\n    It uses an ExpiringDict to automatically clear the mutex after a specified timeout,\n    in case the key is not unlocked for a specified duration, to prevent memory leaks.\n    \"\"\"\n"
        },
        {
            "id": "chunk_1_RedisKeyedMutex_2",
            "code": "    def __init__(self, redis: \"Redis\", timeout: int | None = 60):\n        self.redis = redis\n        self.timeout = timeout\n        self.locks: dict[Any, \"RedisLock\"] = ExpiringDict(\n            max_len=6000, max_age_seconds=self.timeout\n        )\n        self.locks_lock = Lock()\n"
        },
        {
            "id": "chunk_1_RedisKeyedMutex_3",
            "code": "    @contextmanager\n    def locked(self, key: Any):\n        lock = self.acquire(key)\n        try:\n            yield\n        finally:\n            if lock.locked():\n                lock.release()\n\n"
        },
        {
            "id": "chunk_1_RedisKeyedMutex_4",
            "code": "    def acquire(self, key: Any) -> \"RedisLock\":\n        \"\"\"Acquires and returns a lock with the given key\"\"\"\n        with self.locks_lock:\n            if key not in self.locks:\n                self.locks[key] = self.redis.lock(\n                    str(key), self.timeout, thread_local=False\n                )\n            lock = self.locks[key]\n        lock.acquire()\n        return lock\n"
        },
        {
            "id": "chunk_1_RedisKeyedMutex_5",
            "code": "    def release(self, key: Any):\n        if (lock := self.locks.get(key)) and lock.locked() and lock.owned():\n            lock.release()\n\n"
        },
        {
            "id": "chunk_1_RedisKeyedMutex_6",
            "code": "    def release_all_locks(self):\n        \"\"\"Call this on process termination to ensure all locks are released\"\"\"\n        self.locks_lock.acquire(blocking=False)\n        for lock in self.locks.values():\n            if lock.locked() and lock.owned():\n                lock.release()\n\n"
        },
        {
            "id": "chunk_2___init___1",
            "code": "    def __init__(self, redis: \"Redis\", timeout: int | None = 60):\n        self.redis = redis\n        self.timeout = timeout\n        self.locks: dict[Any, \"RedisLock\"] = ExpiringDict(\n            max_len=6000, max_age_seconds=self.timeout\n        )\n        self.locks_lock = Lock()\n"
        },
        {
            "id": "chunk_3_locked_1",
            "code": "    def locked(self, key: Any):\n        lock = self.acquire(key)\n"
        },
        {
            "id": "chunk_3_locked_2",
            "code": "        try:\n            yield\n"
        },
        {
            "id": "chunk_3_locked_3",
            "code": "        finally:\n            if lock.locked():\n                lock.release()\n"
        },
        {
            "id": "chunk_4_acquire_1",
            "code": "    def acquire(self, key: Any) -> \"RedisLock\":\n        \"\"\"Acquires and returns a lock with the given key\"\"\"\n"
        },
        {
            "id": "chunk_4_acquire_2",
            "code": "        with self.locks_lock:\n"
        },
        {
            "id": "chunk_4_acquire_3",
            "code": "            if key not in self.locks:\n                self.locks[key] = self.redis.lock(\n                    str(key), self.timeout, thread_local=False\n                )\n"
        },
        {
            "id": "chunk_4_acquire_4",
            "code": "            lock = self.locks[key]\n"
        },
        {
            "id": "chunk_4_acquire_5",
            "code": "        lock.acquire()\n"
        },
        {
            "id": "chunk_4_acquire_6",
            "code": "        return lock\n"
        },
        {
            "id": "chunk_5_release_1",
            "code": "    def release(self, key: Any):\n"
        },
        {
            "id": "chunk_5_release_2",
            "code": "        if (lock := self.locks.get(key)) and lock.locked() and lock.owned():\n            lock.release()\n"
        },
        {
            "id": "chunk_6_release_all_locks_1",
            "code": "    def release_all_locks(self):\n        \"\"\"Call this on process termination to ensure all locks are released\"\"\"\n"
        },
        {
            "id": "chunk_6_release_all_locks_2",
            "code": "        self.locks_lock.acquire(blocking=False)\n"
        },
        {
            "id": "chunk_6_release_all_locks_3",
            "code": "        for lock in self.locks.values():\n            if lock.locked() and lock.owned():\n                lock.release()\n"
        }
    ],
    "edges": [
        {
            "from": "chunk_0_GlobalBlock_1",
            "to": "chunk_0_GlobalBlock_2"
        },
        {
            "from": "chunk_0_GlobalBlock_2",
            "to": "chunk_0_GlobalBlock_3"
        },
        {
            "from": "chunk_1_RedisKeyedMutex_1",
            "to": "chunk_1_RedisKeyedMutex_2"
        },
        {
            "from": "chunk_1_RedisKeyedMutex_3",
            "to": "chunk_1_RedisKeyedMutex_4"
        },
        {
            "from": "chunk_3_locked_1",
            "to": "chunk_3_locked_2"
        },
        {
            "from": "chunk_3_locked_2",
            "to": "chunk_3_locked_3"
        },
        {
            "from": "chunk_4_acquire_1",
            "to": "chunk_4_acquire_2"
        },
        {
            "from": "chunk_4_acquire_2",
            "to": "chunk_4_acquire_3"
        },
        {
            "from": "chunk_4_acquire_3",
            "to": "chunk_4_acquire_4"
        },
        {
            "from": "chunk_4_acquire_4",
            "to": "chunk_4_acquire_5"
        },
        {
            "from": "chunk_4_acquire_5",
            "to": "chunk_4_acquire_6"
        },
        {
            "from": "chunk_5_release_1",
            "to": "chunk_5_release_2"
        },
        {
            "from": "chunk_6_release_all_locks_1",
            "to": "chunk_6_release_all_locks_2"
        },
        {
            "from": "chunk_6_release_all_locks_2",
            "to": "chunk_6_release_all_locks_3"
        }
    ]
}