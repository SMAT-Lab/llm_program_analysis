{
    "nodes": [
        {
            "id": "chunk_0_GlobalBlock_1",
            "code": "import hashlib\nimport hmac\nimport logging\n\nimport requests\nfrom fastapi import HTTPException, Request\nfrom strenum import StrEnum\n\nfrom backend.data import integrations\nfrom backend.data.model import Credentials\nfrom backend.integrations.providers import ProviderName\n\nfrom ._base import BaseWebhooksManager\n\nlogger = logging.getLogger(__name__)\n\n\n\n"
        },
        {
            "id": "chunk_1_GithubWebhookType_1",
            "code": "class GithubWebhookType(StrEnum):\n    REPO = \"repo\"\n"
        },
        {
            "id": "chunk_2_GithubWebhooksManager_1",
            "code": "class GithubWebhooksManager(BaseWebhooksManager):\n    PROVIDER_NAME = ProviderName.GITHUB\n\n    WebhookType = GithubWebhookType\n\n    GITHUB_API_URL = \"https://api.github.com\"\n    GITHUB_API_DEFAULT_HEADERS = {\"Accept\": \"application/vnd.github.v3+json\"}\n\n"
        },
        {
            "id": "chunk_2_GithubWebhooksManager_2",
            "code": "    @classmethod\n    async def validate_payload(\n        cls, webhook: integrations.Webhook, request: Request\n    ) -> tuple[dict, str]:\n"
        },
        {
            "id": "chunk_2_GithubWebhooksManager_3",
            "code": "        if not (event_type := request.headers.get(\"X-GitHub-Event\")):\n            raise HTTPException(\n                status_code=400, detail=\"X-GitHub-Event header is missing!\"\n            )\n"
        },
        {
            "id": "chunk_2_GithubWebhooksManager_4",
            "code": "        if not (signature_header := request.headers.get(\"X-Hub-Signature-256\")):\n            raise HTTPException(\n                status_code=403, detail=\"X-Hub-Signature-256 header is missing!\"\n            )\n"
        },
        {
            "id": "chunk_2_GithubWebhooksManager_5",
            "code": "        payload_body = await request.body()\n        hash_object = hmac.new(\n            webhook.secret.encode(\"utf-8\"), msg=payload_body, digestmod=hashlib.sha256\n        )\n        expected_signature = \"sha256=\" + hash_object.hexdigest()\n"
        },
        {
            "id": "chunk_2_GithubWebhooksManager_6",
            "code": "        if not hmac.compare_digest(expected_signature, signature_header):\n            raise HTTPException(\n                status_code=403, detail=\"Request signatures didn't match!\"\n            )\n"
        },
        {
            "id": "chunk_2_GithubWebhooksManager_7",
            "code": "        payload = await request.json()\n        if action := payload.get(\"action\"):\n            event_type += f\".{action}\"\n\n        return payload, event_type\n"
        },
        {
            "id": "chunk_2_GithubWebhooksManager_8",
            "code": "    async def trigger_ping(\n        self, webhook: integrations.Webhook, credentials: Credentials | None\n    ) -> None:\n"
        },
        {
            "id": "chunk_2_GithubWebhooksManager_9",
            "code": "        if not credentials:\n            raise ValueError(\"Credentials are required but were not passed\")\n"
        },
        {
            "id": "chunk_2_GithubWebhooksManager_10",
            "code": "        headers = {\n            **self.GITHUB_API_DEFAULT_HEADERS,\n            \"Authorization\": credentials.bearer(),\n        }\n"
        },
        {
            "id": "chunk_2_GithubWebhooksManager_11",
            "code": "        repo, github_hook_id = webhook.resource, webhook.provider_webhook_id\n        ping_url = f\"{self.GITHUB_API_URL}/repos/{repo}/hooks/{github_hook_id}/pings\"\n\n"
        },
        {
            "id": "chunk_2_GithubWebhooksManager_12",
            "code": "        response = requests.post(ping_url, headers=headers)\n\n"
        },
        {
            "id": "chunk_2_GithubWebhooksManager_13",
            "code": "        if response.status_code != 204:\n            error_msg = extract_github_error_msg(response)\n            raise ValueError(f\"Failed to ping GitHub webhook: {error_msg}\")\n"
        },
        {
            "id": "chunk_2_GithubWebhooksManager_14",
            "code": "    async def _register_webhook(\n        self,\n        credentials: Credentials,\n        webhook_type: GithubWebhookType,\n        resource: str,\n        events: list[str],\n        ingress_url: str,\n        secret: str,\n    ) -> tuple[str, dict]:\n"
        },
        {
            "id": "chunk_2_GithubWebhooksManager_15",
            "code": "        if webhook_type == self.WebhookType.REPO and resource.count(\"/\") > 1:\n            raise ValueError(\"Invalid repo format: expected 'owner/repo'\")\n"
        },
        {
            "id": "chunk_2_GithubWebhooksManager_16",
            "code": "        # Extract main event, e.g. `pull_request.opened` -> `pull_request`\n        github_events = list({event.split(\".\")[0] for event in events})\n\n"
        },
        {
            "id": "chunk_2_GithubWebhooksManager_17",
            "code": "        headers = {\n            **self.GITHUB_API_DEFAULT_HEADERS,\n            \"Authorization\": credentials.bearer(),\n        }\n        webhook_data = {\n            \"name\": \"web\",\n            \"active\": True,\n            \"events\": github_events,\n            \"config\": {\n                \"url\": ingress_url,\n                \"content_type\": \"json\",\n                \"insecure_ssl\": \"0\",\n                \"secret\": secret,\n            },\n        }\n"
        },
        {
            "id": "chunk_2_GithubWebhooksManager_18",
            "code": "        response = requests.post(\n            f\"{self.GITHUB_API_URL}/repos/{resource}/hooks\",\n            headers=headers,\n            json=webhook_data,\n        )\n"
        },
        {
            "id": "chunk_2_GithubWebhooksManager_19",
            "code": "        if response.status_code != 201:\n            error_msg = extract_github_error_msg(response)\n            if \"not found\" in error_msg.lower():\n                error_msg = (\n                    f\"{error_msg} \"\n                    \"(Make sure the GitHub account or API key has 'repo' or \"\n                    f\"webhook create permissions to '{resource}')\"\n                )\n            raise ValueError(f\"Failed to create GitHub webhook: {error_msg}\")\n"
        },
        {
            "id": "chunk_2_GithubWebhooksManager_20",
            "code": "        webhook_id = response.json()[\"id\"]\n        config = response.json()[\"config\"]\n\n        return str(webhook_id), config\n"
        },
        {
            "id": "chunk_2_GithubWebhooksManager_21",
            "code": "    async def _deregister_webhook(\n        self, webhook: integrations.Webhook, credentials: Credentials\n    ) -> None:\n"
        },
        {
            "id": "chunk_2_GithubWebhooksManager_22",
            "code": "        webhook_type = self.WebhookType(webhook.webhook_type)\n        if webhook.credentials_id != credentials.id:\n            raise ValueError(\n                f\"Webhook #{webhook.id} does not belong to credentials {credentials.id}\"\n            )\n"
        },
        {
            "id": "chunk_2_GithubWebhooksManager_23",
            "code": "        headers = {\n            **self.GITHUB_API_DEFAULT_HEADERS,\n            \"Authorization\": credentials.bearer(),\n        }\n"
        },
        {
            "id": "chunk_2_GithubWebhooksManager_24",
            "code": "        if webhook_type == self.WebhookType.REPO:\n            repo = webhook.resource\n            delete_url = f\"{self.GITHUB_API_URL}/repos/{repo}/hooks/{webhook.provider_webhook_id}\"  # noqa\n        else:\n            raise NotImplementedError(\n                f\"Unsupported webhook type '{webhook.webhook_type}'\"\n            )\n"
        },
        {
            "id": "chunk_2_GithubWebhooksManager_25",
            "code": "        response = requests.delete(delete_url, headers=headers)\n\n"
        },
        {
            "id": "chunk_2_GithubWebhooksManager_26",
            "code": "        if response.status_code not in [204, 404]:\n            # 204 means successful deletion, 404 means the webhook was already deleted\n            error_msg = extract_github_error_msg(response)\n            raise ValueError(f\"Failed to delete GitHub webhook: {error_msg}\")\n"
        },
        {
            "id": "chunk_3_validate_payload_1",
            "code": "    @classmethod\n    async def validate_payload(\n        cls, webhook: integrations.Webhook, request: Request\n    ) -> tuple[dict, str]:\n"
        },
        {
            "id": "chunk_3_validate_payload_2",
            "code": "        if not (event_type := request.headers.get(\"X-GitHub-Event\")):\n            raise HTTPException(\n                status_code=400, detail=\"X-GitHub-Event header is missing!\"\n            )\n"
        },
        {
            "id": "chunk_3_validate_payload_3",
            "code": "        if not (signature_header := request.headers.get(\"X-Hub-Signature-256\")):\n            raise HTTPException(\n                status_code=403, detail=\"X-Hub-Signature-256 header is missing!\"\n            )\n"
        },
        {
            "id": "chunk_3_validate_payload_4",
            "code": "        payload_body = await request.body()\n        hash_object = hmac.new(\n            webhook.secret.encode(\"utf-8\"), msg=payload_body, digestmod=hashlib.sha256\n        )\n        expected_signature = \"sha256=\" + hash_object.hexdigest()\n"
        },
        {
            "id": "chunk_3_validate_payload_5",
            "code": "        if not hmac.compare_digest(expected_signature, signature_header):\n            raise HTTPException(\n                status_code=403, detail=\"Request signatures didn't match!\"\n            )\n"
        },
        {
            "id": "chunk_3_validate_payload_6",
            "code": "        payload = await request.json()\n        if action := payload.get(\"action\"):\n            event_type += f\".{action}\"\n"
        },
        {
            "id": "chunk_3_validate_payload_7",
            "code": "        return payload, event_type\n"
        },
        {
            "id": "chunk_4_trigger_ping_1",
            "code": "    async def trigger_ping(\n        self, webhook: integrations.Webhook, credentials: Credentials | None\n    ) -> None:\n"
        },
        {
            "id": "chunk_4_trigger_ping_2",
            "code": "        if not credentials:\n            raise ValueError(\"Credentials are required but were not passed\")\n"
        },
        {
            "id": "chunk_4_trigger_ping_3",
            "code": "        headers = {\n            **self.GITHUB_API_DEFAULT_HEADERS,\n            \"Authorization\": credentials.bearer(),\n        }\n"
        },
        {
            "id": "chunk_4_trigger_ping_4",
            "code": "        repo, github_hook_id = webhook.resource, webhook.provider_webhook_id\n        ping_url = f\"{self.GITHUB_API_URL}/repos/{repo}/hooks/{github_hook_id}/pings\"\n"
        },
        {
            "id": "chunk_4_trigger_ping_5",
            "code": "        response = requests.post(ping_url, headers=headers)\n"
        },
        {
            "id": "chunk_4_trigger_ping_6",
            "code": "        if response.status_code != 204:\n            error_msg = extract_github_error_msg(response)\n            raise ValueError(f\"Failed to ping GitHub webhook: {error_msg}\")\n"
        },
        {
            "id": "chunk_5__register_webhook_1",
            "code": "    async def _register_webhook(\n        self,\n        credentials: Credentials,\n        webhook_type: GithubWebhookType,\n        resource: str,\n        events: list[str],\n        ingress_url: str,\n        secret: str,\n    ) -> tuple[str, dict]:\n"
        },
        {
            "id": "chunk_5__register_webhook_2",
            "code": "        if webhook_type == self.WebhookType.REPO and resource.count(\"/\") > 1:\n            raise ValueError(\"Invalid repo format: expected 'owner/repo'\")\n"
        },
        {
            "id": "chunk_5__register_webhook_3",
            "code": "        # Extract main event, e.g. `pull_request.opened` -> `pull_request`\n        github_events = list({event.split(\".\")[0] for event in events})\n"
        },
        {
            "id": "chunk_5__register_webhook_4",
            "code": "        headers = {\n            **self.GITHUB_API_DEFAULT_HEADERS,\n            \"Authorization\": credentials.bearer(),\n        }\n"
        },
        {
            "id": "chunk_5__register_webhook_5",
            "code": "        webhook_data = {\n            \"name\": \"web\",\n            \"active\": True,\n            \"events\": github_events,\n            \"config\": {\n                \"url\": ingress_url,\n                \"content_type\": \"json\",\n                \"insecure_ssl\": \"0\",\n                \"secret\": secret,\n            },\n        }\n"
        },
        {
            "id": "chunk_5__register_webhook_6",
            "code": "        response = requests.post(\n            f\"{self.GITHUB_API_URL}/repos/{resource}/hooks\",\n            headers=headers,\n            json=webhook_data,\n        )\n"
        },
        {
            "id": "chunk_5__register_webhook_7",
            "code": "        if response.status_code != 201:\n            error_msg = extract_github_error_msg(response)\n            if \"not found\" in error_msg.lower():\n                error_msg = (\n                    f\"{error_msg} \"\n                    \"(Make sure the GitHub account or API key has 'repo' or \"\n                    f\"webhook create permissions to '{resource}')\"\n                )\n            raise ValueError(f\"Failed to create GitHub webhook: {error_msg}\")\n"
        },
        {
            "id": "chunk_5__register_webhook_8",
            "code": "        webhook_id = response.json()[\"id\"]\n        config = response.json()[\"config\"]\n"
        },
        {
            "id": "chunk_5__register_webhook_9",
            "code": "        return str(webhook_id), config\n"
        },
        {
            "id": "chunk_6__deregister_webhook_1",
            "code": "    async def _deregister_webhook(\n        self, webhook: integrations.Webhook, credentials: Credentials\n    ) -> None:\n        webhook_type = self.WebhookType(webhook.webhook_type)\n"
        },
        {
            "id": "chunk_6__deregister_webhook_2",
            "code": "        if webhook.credentials_id != credentials.id:\n            raise ValueError(\n                f\"Webhook #{webhook.id} does not belong to credentials {credentials.id}\"\n            )\n"
        },
        {
            "id": "chunk_6__deregister_webhook_3",
            "code": "        headers = {\n            **self.GITHUB_API_DEFAULT_HEADERS,\n            \"Authorization\": credentials.bearer(),\n        }\n"
        },
        {
            "id": "chunk_6__deregister_webhook_4",
            "code": "        if webhook_type == self.WebhookType.REPO:\n            repo = webhook.resource\n            delete_url = f\"{self.GITHUB_API_URL}/repos/{repo}/hooks/{webhook.provider_webhook_id}\"  # noqa\n"
        },
        {
            "id": "chunk_6__deregister_webhook_5",
            "code": "        else:\n            raise NotImplementedError(\n                f\"Unsupported webhook type '{webhook.webhook_type}'\"\n            )\n"
        },
        {
            "id": "chunk_6__deregister_webhook_6",
            "code": "        response = requests.delete(delete_url, headers=headers)\n"
        },
        {
            "id": "chunk_6__deregister_webhook_7",
            "code": "        if response.status_code not in [204, 404]:\n            # 204 means successful deletion, 404 means the webhook was already deleted\n            error_msg = extract_github_error_msg(response)\n            raise ValueError(f\"Failed to delete GitHub webhook: {error_msg}\")\n"
        },
        {
            "id": "chunk_6__deregister_webhook_8",
            "code": "        # If we reach here, the webhook was successfully deleted or didn't exist\n\n"
        },
        {
            "id": "chunk_7_extract_github_error_msg_1",
            "code": "def extract_github_error_msg(response: requests.Response) -> str:\n    error_msgs = []\n    resp = response.json()\n"
        },
        {
            "id": "chunk_7_extract_github_error_msg_2",
            "code": "    if resp.get(\"message\"):\n        error_msgs.append(resp[\"message\"])\n"
        },
        {
            "id": "chunk_7_extract_github_error_msg_3",
            "code": "    if resp.get(\"errors\"):\n        error_msgs.extend(f\"* {err.get('message', err)}\" for err in resp[\"errors\"])\n"
        },
        {
            "id": "chunk_7_extract_github_error_msg_4",
            "code": "    if resp.get(\"error\"):\n        if isinstance(resp[\"error\"], dict):\n            error_msgs.append(resp[\"error\"].get(\"message\", resp[\"error\"]))\n        else:\n            error_msgs.append(resp[\"error\"])\n"
        },
        {
            "id": "chunk_7_extract_github_error_msg_5",
            "code": "    return \"\\n\".join(error_msgs)\n"
        }
    ],
    "edges": [
        {
            "from": "chunk_2_GithubWebhooksManager_2",
            "to": "chunk_2_GithubWebhooksManager_3"
        },
        {
            "from": "chunk_2_GithubWebhooksManager_3",
            "to": "chunk_2_GithubWebhooksManager_4"
        },
        {
            "from": "chunk_2_GithubWebhooksManager_4",
            "to": "chunk_2_GithubWebhooksManager_5"
        },
        {
            "from": "chunk_2_GithubWebhooksManager_5",
            "to": "chunk_2_GithubWebhooksManager_6"
        },
        {
            "from": "chunk_2_GithubWebhooksManager_6",
            "to": "chunk_2_GithubWebhooksManager_7"
        },
        {
            "from": "chunk_2_GithubWebhooksManager_8",
            "to": "chunk_2_GithubWebhooksManager_9"
        },
        {
            "from": "chunk_2_GithubWebhooksManager_9",
            "to": "chunk_2_GithubWebhooksManager_10"
        },
        {
            "from": "chunk_2_GithubWebhooksManager_10",
            "to": "chunk_2_GithubWebhooksManager_11"
        },
        {
            "from": "chunk_2_GithubWebhooksManager_11",
            "to": "chunk_2_GithubWebhooksManager_12"
        },
        {
            "from": "chunk_2_GithubWebhooksManager_12",
            "to": "chunk_2_GithubWebhooksManager_13"
        },
        {
            "from": "chunk_2_GithubWebhooksManager_14",
            "to": "chunk_2_GithubWebhooksManager_15"
        },
        {
            "from": "chunk_2_GithubWebhooksManager_15",
            "to": "chunk_2_GithubWebhooksManager_16"
        },
        {
            "from": "chunk_2_GithubWebhooksManager_16",
            "to": "chunk_2_GithubWebhooksManager_17"
        },
        {
            "from": "chunk_2_GithubWebhooksManager_17",
            "to": "chunk_2_GithubWebhooksManager_18"
        },
        {
            "from": "chunk_2_GithubWebhooksManager_18",
            "to": "chunk_2_GithubWebhooksManager_19"
        },
        {
            "from": "chunk_2_GithubWebhooksManager_19",
            "to": "chunk_2_GithubWebhooksManager_20"
        },
        {
            "from": "chunk_2_GithubWebhooksManager_21",
            "to": "chunk_2_GithubWebhooksManager_22"
        },
        {
            "from": "chunk_2_GithubWebhooksManager_22",
            "to": "chunk_2_GithubWebhooksManager_23"
        },
        {
            "from": "chunk_2_GithubWebhooksManager_23",
            "to": "chunk_2_GithubWebhooksManager_24"
        },
        {
            "from": "chunk_2_GithubWebhooksManager_24",
            "to": "chunk_2_GithubWebhooksManager_25"
        },
        {
            "from": "chunk_2_GithubWebhooksManager_25",
            "to": "chunk_2_GithubWebhooksManager_26"
        },
        {
            "from": "chunk_3_validate_payload_1",
            "to": "chunk_3_validate_payload_2"
        },
        {
            "from": "chunk_3_validate_payload_2",
            "to": "chunk_3_validate_payload_3"
        },
        {
            "from": "chunk_3_validate_payload_3",
            "to": "chunk_3_validate_payload_4"
        },
        {
            "from": "chunk_3_validate_payload_4",
            "to": "chunk_3_validate_payload_5"
        },
        {
            "from": "chunk_3_validate_payload_5",
            "to": "chunk_3_validate_payload_6"
        },
        {
            "from": "chunk_3_validate_payload_6",
            "to": "chunk_3_validate_payload_7"
        },
        {
            "from": "chunk_4_trigger_ping_1",
            "to": "chunk_4_trigger_ping_2"
        },
        {
            "from": "chunk_4_trigger_ping_2",
            "to": "chunk_4_trigger_ping_3"
        },
        {
            "from": "chunk_4_trigger_ping_3",
            "to": "chunk_4_trigger_ping_4"
        },
        {
            "from": "chunk_4_trigger_ping_4",
            "to": "chunk_4_trigger_ping_5"
        },
        {
            "from": "chunk_4_trigger_ping_5",
            "to": "chunk_4_trigger_ping_6"
        },
        {
            "from": "chunk_5__register_webhook_1",
            "to": "chunk_5__register_webhook_2"
        },
        {
            "from": "chunk_5__register_webhook_2",
            "to": "chunk_5__register_webhook_3"
        },
        {
            "from": "chunk_5__register_webhook_3",
            "to": "chunk_5__register_webhook_4"
        },
        {
            "from": "chunk_5__register_webhook_4",
            "to": "chunk_5__register_webhook_5"
        },
        {
            "from": "chunk_5__register_webhook_5",
            "to": "chunk_5__register_webhook_6"
        },
        {
            "from": "chunk_5__register_webhook_6",
            "to": "chunk_5__register_webhook_7"
        },
        {
            "from": "chunk_5__register_webhook_6",
            "to": "chunk_5__register_webhook_8"
        },
        {
            "from": "chunk_5__register_webhook_8",
            "to": "chunk_5__register_webhook_9"
        },
        {
            "from": "chunk_6__deregister_webhook_1",
            "to": "chunk_6__deregister_webhook_2"
        },
        {
            "from": "chunk_6__deregister_webhook_2",
            "to": "chunk_6__deregister_webhook_3"
        },
        {
            "from": "chunk_6__deregister_webhook_3",
            "to": "chunk_6__deregister_webhook_4"
        },
        {
            "from": "chunk_6__deregister_webhook_3",
            "to": "chunk_6__deregister_webhook_5"
        },
        {
            "from": "chunk_6__deregister_webhook_4",
            "to": "chunk_6__deregister_webhook_6"
        },
        {
            "from": "chunk_6__deregister_webhook_6",
            "to": "chunk_6__deregister_webhook_7"
        },
        {
            "from": "chunk_6__deregister_webhook_6",
            "to": "chunk_6__deregister_webhook_8"
        },
        {
            "from": "chunk_7_extract_github_error_msg_1",
            "to": "chunk_7_extract_github_error_msg_2"
        },
        {
            "from": "chunk_7_extract_github_error_msg_1",
            "to": "chunk_7_extract_github_error_msg_3"
        },
        {
            "from": "chunk_7_extract_github_error_msg_1",
            "to": "chunk_7_extract_github_error_msg_4"
        },
        {
            "from": "chunk_7_extract_github_error_msg_2",
            "to": "chunk_7_extract_github_error_msg_3"
        },
        {
            "from": "chunk_7_extract_github_error_msg_2",
            "to": "chunk_7_extract_github_error_msg_4"
        },
        {
            "from": "chunk_7_extract_github_error_msg_3",
            "to": "chunk_7_extract_github_error_msg_4"
        },
        {
            "from": "chunk_7_extract_github_error_msg_4",
            "to": "chunk_7_extract_github_error_msg_5"
        }
    ]
}