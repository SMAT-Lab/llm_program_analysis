{
    "nodes": [
        {
            "id": "chunk_0_GlobalBlock_1",
            "code": "import ipaddress\nimport re\nimport socket\nfrom typing import Callable\nfrom urllib.parse import urlparse, urlunparse\n\nimport idna\nimport requests as req\n\nfrom backend.util.settings import Config\n\n"
        },
        {
            "id": "chunk_0_GlobalBlock_2",
            "code": "# List of IP networks to block\nBLOCKED_IP_NETWORKS = [\n    # --8<-- [start:BLOCKED_IP_NETWORKS]\n    ipaddress.ip_network(\"0.0.0.0/8\"),  # \"This\" Network\n    ipaddress.ip_network(\"10.0.0.0/8\"),  # Private-Use\n    ipaddress.ip_network(\"127.0.0.0/8\"),  # Loopback\n    ipaddress.ip_network(\"169.254.0.0/16\"),  # Link Local\n    ipaddress.ip_network(\"172.16.0.0/12\"),  # Private-Use\n    ipaddress.ip_network(\"192.168.0.0/16\"),  # Private-Use\n    ipaddress.ip_network(\"224.0.0.0/4\"),  # Multicast\n    ipaddress.ip_network(\"240.0.0.0/4\"),  # Reserved for Future Use\n    # --8<-- [end:BLOCKED_IP_NETWORKS]\n]\n"
        },
        {
            "id": "chunk_0_GlobalBlock_3",
            "code": "\nALLOWED_SCHEMES = [\"http\", \"https\"]\nHOSTNAME_REGEX = re.compile(r\"^[A-Za-z0-9.-]+$\")  # Basic DNS-safe hostname pattern\n"
        },
        {
            "id": "chunk_0_GlobalBlock_4",
            "code": "\n\n\n"
        },
        {
            "id": "chunk_1__canonicalize_url_1",
            "code": "def _canonicalize_url(url: str) -> str:\n    # Strip spaces and trailing slashes\n    url = url.strip().strip(\"/\")\n"
        },
        {
            "id": "chunk_1__canonicalize_url_2",
            "code": "    # Ensure the URL starts with http:// or https://\n    if not url.startswith((\"http://\", \"https://\")):\n        url = \"http://\" + url\n"
        },
        {
            "id": "chunk_1__canonicalize_url_3",
            "code": "    # Replace backslashes with forward slashes to avoid parsing ambiguities\n    url = url.replace(\"\\\\\", \"/\")\n    return url\n"
        },
        {
            "id": "chunk_2__is_ip_blocked_1",
            "code": "def _is_ip_blocked(ip: str) -> bool:\n    \"\"\"\n    Checks if the IP address is in a blocked network.\n    \"\"\"\n"
        },
        {
            "id": "chunk_2__is_ip_blocked_2",
            "code": "    ip_addr = ipaddress.ip_address(ip)\n    return any(ip_addr in network for network in BLOCKED_IP_NETWORKS)\n"
        },
        {
            "id": "chunk_3_validate_url_1",
            "code": "def validate_url(url: str, trusted_origins: list[str]) -> str:\n    \"\"\"\n    Validates the URL to prevent SSRF attacks by ensuring it does not point to a private\n    or untrusted IP address, unless whitelisted.\n    \"\"\"\n"
        },
        {
            "id": "chunk_3_validate_url_2",
            "code": "    url = _canonicalize_url(url)\n    parsed = urlparse(url)\n"
        },
        {
            "id": "chunk_3_validate_url_3",
            "code": "    # Check scheme\n    if parsed.scheme not in ALLOWED_SCHEMES:\n        raise ValueError(\n            f\"Scheme '{parsed.scheme}' is not allowed. Only HTTP/HTTPS are supported.\"\n        )\n"
        },
        {
            "id": "chunk_3_validate_url_4",
            "code": "    # Validate and IDNA encode the hostname\n    if not parsed.hostname:\n        raise ValueError(\"Invalid URL: No hostname found.\")\n"
        },
        {
            "id": "chunk_3_validate_url_5",
            "code": "    # IDNA encode to prevent Unicode domain attacks\n    try:\n        ascii_hostname = idna.encode(parsed.hostname).decode(\"ascii\")\n    except idna.IDNAError:\n        raise ValueError(\"Invalid hostname with unsupported characters.\")\n"
        },
        {
            "id": "chunk_3_validate_url_6",
            "code": "    # Check hostname characters\n    if not HOSTNAME_REGEX.match(ascii_hostname):\n        raise ValueError(\"Hostname contains invalid characters.\")\n"
        },
        {
            "id": "chunk_3_validate_url_7",
            "code": "    # Rebuild the URL with the normalized, IDNA-encoded hostname\n    parsed = parsed._replace(netloc=ascii_hostname)\n    url = str(urlunparse(parsed))\n"
        },
        {
            "id": "chunk_3_validate_url_8",
            "code": "    # Check if hostname is a trusted origin (exact match)\n    if ascii_hostname in trusted_origins:\n        return url\n"
        },
        {
            "id": "chunk_3_validate_url_9",
            "code": "    # Resolve all IP addresses for the hostname\n    try:\n        ip_addresses = {res[4][0] for res in socket.getaddrinfo(ascii_hostname, None)}\n    except socket.gaierror:\n        raise ValueError(f\"Unable to resolve IP address for hostname {ascii_hostname}\")\n"
        },
        {
            "id": "chunk_3_validate_url_10",
            "code": "    if not ip_addresses:\n        raise ValueError(f\"No IP addresses found for {ascii_hostname}\")\n"
        },
        {
            "id": "chunk_3_validate_url_11",
            "code": "    # Check if any resolved IP address falls into blocked ranges\n    for ip in ip_addresses:\n        if _is_ip_blocked(ip):\n            raise ValueError(\n                f\"Access to private IP address {ip} for hostname {ascii_hostname} is not allowed.\"\n            )\n"
        },
        {
            "id": "chunk_3_validate_url_12",
            "code": "    return url\n"
        },
        {
            "id": "chunk_4_Requests_1",
            "code": "class Requests:\n    \"\"\"\n    A wrapper around the requests library that validates URLs before making requests.\n    \"\"\"\n"
        },
        {
            "id": "chunk_4_Requests_2",
            "code": "    def __init__(\n        self,\n        trusted_origins: list[str] | None = None,\n        raise_for_status: bool = True,\n        extra_url_validator: Callable[[str], str] | None = None,\n        extra_headers: dict[str, str] | None = None,\n    ):\n"
        },
        {
            "id": "chunk_4_Requests_3",
            "code": "        self.trusted_origins = []\n"
        },
        {
            "id": "chunk_4_Requests_4",
            "code": "        for url in trusted_origins or []:\n            hostname = urlparse(url).hostname\n            if not hostname:\n                raise ValueError(f\"Invalid URL: Unable to determine hostname of {url}\")\n            self.trusted_origins.append(hostname)\n"
        },
        {
            "id": "chunk_4_Requests_5",
            "code": "        self.raise_for_status = raise_for_status\n        self.extra_url_validator = extra_url_validator\n        self.extra_headers = extra_headers\n"
        },
        {
            "id": "chunk_4_Requests_6",
            "code": "    def request(\n        self, method, url, headers=None, allow_redirects=False, *args, **kwargs\n    ) -> req.Response:\n"
        },
        {
            "id": "chunk_4_Requests_7",
            "code": "        if self.extra_headers is not None:\n            headers = {**(headers or {}), **self.extra_headers}\n"
        },
        {
            "id": "chunk_4_Requests_8",
            "code": "        url = validate_url(url, self.trusted_origins)\n"
        },
        {
            "id": "chunk_4_Requests_9",
            "code": "        if self.extra_url_validator is not None:\n            url = self.extra_url_validator(url)\n"
        },
        {
            "id": "chunk_4_Requests_10",
            "code": "        response = req.request(\n            method,\n            url,\n            headers=headers,\n            allow_redirects=allow_redirects,\n            *args,\n            **kwargs,\n        )\n"
        },
        {
            "id": "chunk_4_Requests_11",
            "code": "        if self.raise_for_status:\n            response.raise_for_status()\n"
        },
        {
            "id": "chunk_4_Requests_12",
            "code": "        return response\n"
        },
        {
            "id": "chunk_4_Requests_13",
            "code": "    def get(self, url, *args, **kwargs) -> req.Response:\n        return self.request(\"GET\", url, *args, **kwargs)\n"
        },
        {
            "id": "chunk_4_Requests_14",
            "code": "    def post(self, url, *args, **kwargs) -> req.Response:\n        return self.request(\"POST\", url, *args, **kwargs)\n"
        },
        {
            "id": "chunk_4_Requests_15",
            "code": "    def put(self, url, *args, **kwargs) -> req.Response:\n        return self.request(\"PUT\", url, *args, **kwargs)\n"
        },
        {
            "id": "chunk_4_Requests_16",
            "code": "    def delete(self, url, *args, **kwargs) -> req.Response:\n        return self.request(\"DELETE\", url, *args, **kwargs)\n"
        },
        {
            "id": "chunk_4_Requests_17",
            "code": "    def head(self, url, *args, **kwargs) -> req.Response:\n        return self.request(\"HEAD\", url, *args, **kwargs)\n"
        },
        {
            "id": "chunk_4_Requests_18",
            "code": "    def options(self, url, *args, **kwargs) -> req.Response:\n        return self.request(\"OPTIONS\", url, *args, **kwargs)\n"
        },
        {
            "id": "chunk_4_Requests_19",
            "code": "    def patch(self, url, *args, **kwargs) -> req.Response:\n        return self.request(\"PATCH\", url, *args, **kwargs)\n"
        },
        {
            "id": "chunk_5_requests_1",
            "code": "requests = Requests(trusted_origins=Config().trust_endpoints_for_requests)\n"
        }
    ],
    "edges": [
        {
            "from": "chunk_0_GlobalBlock_1",
            "to": "chunk_0_GlobalBlock_2"
        },
        {
            "from": "chunk_0_GlobalBlock_2",
            "to": "chunk_0_GlobalBlock_3"
        },
        {
            "from": "chunk_0_GlobalBlock_3",
            "to": "chunk_0_GlobalBlock_4"
        },
        {
            "from": "chunk_1__canonicalize_url_1",
            "to": "chunk_1__canonicalize_url_2"
        },
        {
            "from": "chunk_1__canonicalize_url_2",
            "to": "chunk_1__canonicalize_url_3"
        },
        {
            "from": "chunk_2__is_ip_blocked_1",
            "to": "chunk_2__is_ip_blocked_2"
        },
        {
            "from": "chunk_3_validate_url_1",
            "to": "chunk_3_validate_url_2"
        },
        {
            "from": "chunk_3_validate_url_2",
            "to": "chunk_3_validate_url_3"
        },
        {
            "from": "chunk_3_validate_url_3",
            "to": "chunk_3_validate_url_4"
        },
        {
            "from": "chunk_3_validate_url_4",
            "to": "chunk_3_validate_url_5"
        },
        {
            "from": "chunk_3_validate_url_5",
            "to": "chunk_3_validate_url_6"
        },
        {
            "from": "chunk_3_validate_url_6",
            "to": "chunk_3_validate_url_7"
        },
        {
            "from": "chunk_3_validate_url_7",
            "to": "chunk_3_validate_url_8"
        },
        {
            "from": "chunk_3_validate_url_8",
            "to": "chunk_3_validate_url_9"
        },
        {
            "from": "chunk_3_validate_url_8",
            "to": "chunk_3_validate_url_12"
        },
        {
            "from": "chunk_3_validate_url_9",
            "to": "chunk_3_validate_url_10"
        },
        {
            "from": "chunk_3_validate_url_10",
            "to": "chunk_3_validate_url_11"
        },
        {
            "from": "chunk_3_validate_url_11",
            "to": "chunk_3_validate_url_12"
        },
        {
            "from": "chunk_4_Requests_1",
            "to": "chunk_4_Requests_2"
        },
        {
            "from": "chunk_4_Requests_2",
            "to": "chunk_4_Requests_3"
        },
        {
            "from": "chunk_4_Requests_3",
            "to": "chunk_4_Requests_4"
        },
        {
            "from": "chunk_4_Requests_4",
            "to": "chunk_4_Requests_5"
        },
        {
            "from": "chunk_4_Requests_6",
            "to": "chunk_4_Requests_7"
        },
        {
            "from": "chunk_4_Requests_7",
            "to": "chunk_4_Requests_8"
        },
        {
            "from": "chunk_4_Requests_8",
            "to": "chunk_4_Requests_9"
        },
        {
            "from": "chunk_4_Requests_9",
            "to": "chunk_4_Requests_10"
        },
        {
            "from": "chunk_4_Requests_10",
            "to": "chunk_4_Requests_11"
        },
        {
            "from": "chunk_4_Requests_11",
            "to": "chunk_4_Requests_12"
        }
    ]
}