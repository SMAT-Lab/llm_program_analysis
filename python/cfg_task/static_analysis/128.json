{
  "nodes": [
    {
      "id": "n0",
      "type": "block",
      "statements": [
        "import logging",
        "import time",
        "from abc import ABC, abstractmethod",
        "from typing import ClassVar",
        "from backend.data.model import OAuth2Credentials",
        "from backend.integrations.providers import ProviderName",
        "logger = logging.getLogger(__name__)",
        "class BaseOAuthHandler(ABC):\n    PROVIDER_NAME: ClassVar[ProviderName]\n    DEFAULT_SCOPES: ClassVar[list[str]] = []\n\n    @abstractmethod\n    def __init__(self, client_id: str, client_secret: str, redirect_uri: str):\n        ...\n\n    @abstractmethod\n    def get_login_url(self, scopes: list[str], state: str) -> str:\n        \"\"\"Constructs a login URL that the user can be redirected to\"\"\"\n        ...\n\n    @abstractmethod\n    def exchange_code_for_tokens(self, code: str, scopes: list[str]) -> OAuth2Credentials:\n        \"\"\"Exchanges the acquired authorization code from login for a set of tokens\"\"\"\n        ...\n\n    @abstractmethod\n    def _refresh_tokens(self, credentials: OAuth2Credentials) -> OAuth2Credentials:\n        \"\"\"Implements the token refresh mechanism\"\"\"\n        ...\n\n    @abstractmethod\n    def revoke_tokens(self, credentials: OAuth2Credentials) -> bool:\n        \"\"\"Revokes the given token at provider,\n        returns False provider does not support it\"\"\"\n        ...\n\n    def refresh_tokens(self, credentials: OAuth2Credentials) -> OAuth2Credentials:\n        if credentials.provider != self.PROVIDER_NAME:\n            raise ValueError(f\"{self.__class__.__name__} can not refresh tokens for other provider '{credentials.provider}'\")\n        return self._refresh_tokens(credentials)\n\n    def get_access_token(self, credentials: OAuth2Credentials) -> str:\n        \"\"\"Returns a valid access token, refreshing it first if needed\"\"\"\n        if self.needs_refresh(credentials):\n            credentials = self.refresh_tokens(credentials)\n        return credentials.access_token.get_secret_value()\n\n    def needs_refresh(self, credentials: OAuth2Credentials) -> bool:\n        \"\"\"Indicates whether the given tokens need to be refreshed\"\"\"\n        return credentials.access_token_expires_at is not None and credentials.access_token_expires_at < int(time.time()) + 300\n\n    def handle_default_scopes(self, scopes: list[str]) -> list[str]:\n        \"\"\"Handles the default scopes for the provider\"\"\"\n        if not scopes:\n            logger.debug(f'Using default scopes for provider {self.PROVIDER_NAME.value}')\n            scopes = self.DEFAULT_SCOPES\n        return scopes",
        "PROVIDER_NAME: ClassVar[ProviderName]",
        "DEFAULT_SCOPES: ClassVar[list[str]] = []",
        "@abstractmethod\ndef __init__(self, client_id: str, client_secret: str, redirect_uri: str):\n    ...",
        "Ellipsis",
        "@abstractmethod\ndef get_login_url(self, scopes: list[str], state: str) -> str:\n    \"\"\"Constructs a login URL that the user can be redirected to\"\"\"\n    ...",
        "'Constructs a login URL that the user can be redirected to'",
        "Ellipsis",
        "@abstractmethod\ndef exchange_code_for_tokens(self, code: str, scopes: list[str]) -> OAuth2Credentials:\n    \"\"\"Exchanges the acquired authorization code from login for a set of tokens\"\"\"\n    ...",
        "'Exchanges the acquired authorization code from login for a set of tokens'",
        "Ellipsis",
        "@abstractmethod\ndef _refresh_tokens(self, credentials: OAuth2Credentials) -> OAuth2Credentials:\n    \"\"\"Implements the token refresh mechanism\"\"\"\n    ...",
        "'Implements the token refresh mechanism'",
        "Ellipsis",
        "@abstractmethod\ndef revoke_tokens(self, credentials: OAuth2Credentials) -> bool:\n    \"\"\"Revokes the given token at provider,\n        returns False provider does not support it\"\"\"\n    ...",
        "'Revokes the given token at provider,\\n        returns False provider does not support it'",
        "Ellipsis",
        "def refresh_tokens(self, credentials: OAuth2Credentials) -> OAuth2Credentials:\n    if credentials.provider != self.PROVIDER_NAME:\n        raise ValueError(f\"{self.__class__.__name__} can not refresh tokens for other provider '{credentials.provider}'\")\n    return self._refresh_tokens(credentials)",
        "credentials.provider NotEq self.PROVIDER_NAME"
      ],
      "code": "import logging\nimport time\nfrom abc import ABC, abstractmethod\nfrom typing import ClassVar\nfrom backend.data.model import OAuth2Credentials\nfrom backend.integrations.providers import ProviderName\nlogger = logging.getLogger(__name__)\nclass BaseOAuthHandler(ABC):\n    PROVIDER_NAME: ClassVar[ProviderName]\n    DEFAULT_SCOPES: ClassVar[list[str]] = []\n\n    @abstractmethod\n    def __init__(self, client_id: str, client_secret: str, redirect_uri: str):\n        ...\n\n    @abstractmethod\n    def get_login_url(self, scopes: list[str], state: str) -> str:\n        \"\"\"Constructs a login URL that the user can be redirected to\"\"\"\n        ...\n\n    @abstractmethod\n    def exchange_code_for_tokens(self, code: str, scopes: list[str]) -> OAuth2Credentials:\n        \"\"\"Exchanges the acquired authorization code from login for a set of tokens\"\"\"\n        ...\n\n    @abstractmethod\n    def _refresh_tokens(self, credentials: OAuth2Credentials) -> OAuth2Credentials:\n        \"\"\"Implements the token refresh mechanism\"\"\"\n        ...\n\n    @abstractmethod\n    def revoke_tokens(self, credentials: OAuth2Credentials) -> bool:\n        \"\"\"Revokes the given token at provider,\n        returns False provider does not support it\"\"\"\n        ...\n\n    def refresh_tokens(self, credentials: OAuth2Credentials) -> OAuth2Credentials:\n        if credentials.provider != self.PROVIDER_NAME:\n            raise ValueError(f\"{self.__class__.__name__} can not refresh tokens for other provider '{credentials.provider}'\")\n        return self._refresh_tokens(credentials)\n\n    def get_access_token(self, credentials: OAuth2Credentials) -> str:\n        \"\"\"Returns a valid access token, refreshing it first if needed\"\"\"\n        if self.needs_refresh(credentials):\n            credentials = self.refresh_tokens(credentials)\n        return credentials.access_token.get_secret_value()\n\n    def needs_refresh(self, credentials: OAuth2Credentials) -> bool:\n        \"\"\"Indicates whether the given tokens need to be refreshed\"\"\"\n        return credentials.access_token_expires_at is not None and credentials.access_token_expires_at < int(time.time()) + 300\n\n    def handle_default_scopes(self, scopes: list[str]) -> list[str]:\n        \"\"\"Handles the default scopes for the provider\"\"\"\n        if not scopes:\n            logger.debug(f'Using default scopes for provider {self.PROVIDER_NAME.value}')\n            scopes = self.DEFAULT_SCOPES\n        return scopes\nPROVIDER_NAME: ClassVar[ProviderName]\nDEFAULT_SCOPES: ClassVar[list[str]] = []\n@abstractmethod\ndef __init__(self, client_id: str, client_secret: str, redirect_uri: str):\n    ...\nEllipsis\n@abstractmethod\ndef get_login_url(self, scopes: list[str], state: str) -> str:\n    \"\"\"Constructs a login URL that the user can be redirected to\"\"\"\n    ...\n'Constructs a login URL that the user can be redirected to'\nEllipsis\n@abstractmethod\ndef exchange_code_for_tokens(self, code: str, scopes: list[str]) -> OAuth2Credentials:\n    \"\"\"Exchanges the acquired authorization code from login for a set of tokens\"\"\"\n    ...\n'Exchanges the acquired authorization code from login for a set of tokens'\nEllipsis\n@abstractmethod\ndef _refresh_tokens(self, credentials: OAuth2Credentials) -> OAuth2Credentials:\n    \"\"\"Implements the token refresh mechanism\"\"\"\n    ...\n'Implements the token refresh mechanism'\nEllipsis\n@abstractmethod\ndef revoke_tokens(self, credentials: OAuth2Credentials) -> bool:\n    \"\"\"Revokes the given token at provider,\n        returns False provider does not support it\"\"\"\n    ...\n'Revokes the given token at provider,\\n        returns False provider does not support it'\nEllipsis\ndef refresh_tokens(self, credentials: OAuth2Credentials) -> OAuth2Credentials:\n    if credentials.provider != self.PROVIDER_NAME:\n        raise ValueError(f\"{self.__class__.__name__} can not refresh tokens for other provider '{credentials.provider}'\")\n    return self._refresh_tokens(credentials)\ncredentials.provider NotEq self.PROVIDER_NAME"
    },
    {
      "id": "n1",
      "type": "block",
      "statements": [
        "raise ValueError(f\"{self.__class__.__name__} can not refresh tokens for other provider '{credentials.provider}'\")"
      ],
      "code": "raise ValueError(f\"{self.__class__.__name__} can not refresh tokens for other provider '{credentials.provider}'\")"
    },
    {
      "id": "n2",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n3",
      "type": "block",
      "statements": [
        "return self._refresh_tokens(credentials)"
      ],
      "code": "return self._refresh_tokens(credentials)"
    },
    {
      "id": "n4",
      "type": "block",
      "statements": [
        "def get_access_token(self, credentials: OAuth2Credentials) -> str:\n    \"\"\"Returns a valid access token, refreshing it first if needed\"\"\"\n    if self.needs_refresh(credentials):\n        credentials = self.refresh_tokens(credentials)\n    return credentials.access_token.get_secret_value()",
        "'Returns a valid access token, refreshing it first if needed'",
        "self.needs_refresh(credentials)"
      ],
      "code": "def get_access_token(self, credentials: OAuth2Credentials) -> str:\n    \"\"\"Returns a valid access token, refreshing it first if needed\"\"\"\n    if self.needs_refresh(credentials):\n        credentials = self.refresh_tokens(credentials)\n    return credentials.access_token.get_secret_value()\n'Returns a valid access token, refreshing it first if needed'\nself.needs_refresh(credentials)"
    },
    {
      "id": "n5",
      "type": "block",
      "statements": [
        "credentials = self.refresh_tokens(credentials)"
      ],
      "code": "credentials = self.refresh_tokens(credentials)"
    },
    {
      "id": "n6",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n7",
      "type": "block",
      "statements": [
        "return credentials.access_token.get_secret_value()"
      ],
      "code": "return credentials.access_token.get_secret_value()"
    },
    {
      "id": "n8",
      "type": "block",
      "statements": [
        "def needs_refresh(self, credentials: OAuth2Credentials) -> bool:\n    \"\"\"Indicates whether the given tokens need to be refreshed\"\"\"\n    return credentials.access_token_expires_at is not None and credentials.access_token_expires_at < int(time.time()) + 300",
        "'Indicates whether the given tokens need to be refreshed'",
        "return credentials.access_token_expires_at is not None and credentials.access_token_expires_at < int(time.time()) + 300"
      ],
      "code": "def needs_refresh(self, credentials: OAuth2Credentials) -> bool:\n    \"\"\"Indicates whether the given tokens need to be refreshed\"\"\"\n    return credentials.access_token_expires_at is not None and credentials.access_token_expires_at < int(time.time()) + 300\n'Indicates whether the given tokens need to be refreshed'\nreturn credentials.access_token_expires_at is not None and credentials.access_token_expires_at < int(time.time()) + 300"
    },
    {
      "id": "n9",
      "type": "block",
      "statements": [
        "def handle_default_scopes(self, scopes: list[str]) -> list[str]:\n    \"\"\"Handles the default scopes for the provider\"\"\"\n    if not scopes:\n        logger.debug(f'Using default scopes for provider {self.PROVIDER_NAME.value}')\n        scopes = self.DEFAULT_SCOPES\n    return scopes",
        "'Handles the default scopes for the provider'",
        "not scopes"
      ],
      "code": "def handle_default_scopes(self, scopes: list[str]) -> list[str]:\n    \"\"\"Handles the default scopes for the provider\"\"\"\n    if not scopes:\n        logger.debug(f'Using default scopes for provider {self.PROVIDER_NAME.value}')\n        scopes = self.DEFAULT_SCOPES\n    return scopes\n'Handles the default scopes for the provider'\nnot scopes"
    },
    {
      "id": "n10",
      "type": "block",
      "statements": [
        "logger.debug(f'Using default scopes for provider {self.PROVIDER_NAME.value}')",
        "scopes = self.DEFAULT_SCOPES"
      ],
      "code": "logger.debug(f'Using default scopes for provider {self.PROVIDER_NAME.value}')\nscopes = self.DEFAULT_SCOPES"
    },
    {
      "id": "n11",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n12",
      "type": "block",
      "statements": [
        "return scopes"
      ],
      "code": "return scopes"
    }
  ],
  "edges": [
    {
      "source": "n9",
      "target": "n11"
    },
    {
      "source": "n1",
      "target": "n3"
    },
    {
      "source": "n6",
      "target": "n7"
    },
    {
      "source": "n0",
      "target": "n2"
    },
    {
      "source": "n0",
      "target": "n1"
    },
    {
      "source": "n9",
      "target": "n10"
    },
    {
      "source": "n4",
      "target": "n5"
    },
    {
      "source": "n5",
      "target": "n7"
    },
    {
      "source": "n10",
      "target": "n12"
    },
    {
      "source": "n11",
      "target": "n12"
    },
    {
      "source": "n4",
      "target": "n6"
    },
    {
      "source": "n2",
      "target": "n3"
    }
  ]
}