{
  "nodes": [
    {
      "id": "n0",
      "type": "block",
      "statements": [
        "import ipaddress",
        "import re",
        "import socket",
        "from typing import Callable",
        "from urllib.parse import urlparse, urlunparse",
        "import idna",
        "import requests as req",
        "from backend.util.settings import Config",
        "BLOCKED_IP_NETWORKS = [ipaddress.ip_network('0.0.0.0/8'), ipaddress.ip_network('10.0.0.0/8'), ipaddress.ip_network('127.0.0.0/8'), ipaddress.ip_network('169.254.0.0/16'), ipaddress.ip_network('172.16.0.0/12'), ipaddress.ip_network('192.168.0.0/16'), ipaddress.ip_network('224.0.0.0/4'), ipaddress.ip_network('240.0.0.0/4')]",
        "ALLOWED_SCHEMES = ['http', 'https']",
        "HOSTNAME_REGEX = re.compile('^[A-Za-z0-9.-]+$')",
        "def _canonicalize_url(url: str) -> str:\n    url = url.strip().strip('/')\n    if not url.startswith(('http://', 'https://')):\n        url = 'http://' + url\n    url = url.replace('\\\\', '/')\n    return url",
        "url = url.strip().strip('/')",
        "not url.startswith(('http://', 'https://'))"
      ],
      "code": "import ipaddress\nimport re\nimport socket\nfrom typing import Callable\nfrom urllib.parse import urlparse, urlunparse\nimport idna\nimport requests as req\nfrom backend.util.settings import Config\nBLOCKED_IP_NETWORKS = [ipaddress.ip_network('0.0.0.0/8'), ipaddress.ip_network('10.0.0.0/8'), ipaddress.ip_network('127.0.0.0/8'), ipaddress.ip_network('169.254.0.0/16'), ipaddress.ip_network('172.16.0.0/12'), ipaddress.ip_network('192.168.0.0/16'), ipaddress.ip_network('224.0.0.0/4'), ipaddress.ip_network('240.0.0.0/4')]\nALLOWED_SCHEMES = ['http', 'https']\nHOSTNAME_REGEX = re.compile('^[A-Za-z0-9.-]+$')\ndef _canonicalize_url(url: str) -> str:\n    url = url.strip().strip('/')\n    if not url.startswith(('http://', 'https://')):\n        url = 'http://' + url\n    url = url.replace('\\\\', '/')\n    return url\nurl = url.strip().strip('/')\nnot url.startswith(('http://', 'https://'))"
    },
    {
      "id": "n1",
      "type": "block",
      "statements": [
        "url = 'http://' + url"
      ],
      "code": "url = 'http://' + url"
    },
    {
      "id": "n2",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n3",
      "type": "block",
      "statements": [
        "url = url.replace('\\\\', '/')",
        "return url"
      ],
      "code": "url = url.replace('\\\\', '/')\nreturn url"
    },
    {
      "id": "n4",
      "type": "block",
      "statements": [
        "def _is_ip_blocked(ip: str) -> bool:\n    \"\"\"\n    Checks if the IP address is in a blocked network.\n    \"\"\"\n    ip_addr = ipaddress.ip_address(ip)\n    return any((ip_addr in network for network in BLOCKED_IP_NETWORKS))",
        "'\\n    Checks if the IP address is in a blocked network.\\n    '",
        "ip_addr = ipaddress.ip_address(ip)",
        "return any((ip_addr in network for network in BLOCKED_IP_NETWORKS))"
      ],
      "code": "def _is_ip_blocked(ip: str) -> bool:\n    \"\"\"\n    Checks if the IP address is in a blocked network.\n    \"\"\"\n    ip_addr = ipaddress.ip_address(ip)\n    return any((ip_addr in network for network in BLOCKED_IP_NETWORKS))\n'\\n    Checks if the IP address is in a blocked network.\\n    '\nip_addr = ipaddress.ip_address(ip)\nreturn any((ip_addr in network for network in BLOCKED_IP_NETWORKS))"
    },
    {
      "id": "n5",
      "type": "block",
      "statements": [
        "def validate_url(url: str, trusted_origins: list[str]) -> str:\n    \"\"\"\n    Validates the URL to prevent SSRF attacks by ensuring it does not point to a private\n    or untrusted IP address, unless whitelisted.\n    \"\"\"\n    url = _canonicalize_url(url)\n    parsed = urlparse(url)\n    if parsed.scheme not in ALLOWED_SCHEMES:\n        raise ValueError(f\"Scheme '{parsed.scheme}' is not allowed. Only HTTP/HTTPS are supported.\")\n    if not parsed.hostname:\n        raise ValueError('Invalid URL: No hostname found.')\n    try:\n        ascii_hostname = idna.encode(parsed.hostname).decode('ascii')\n    except idna.IDNAError:\n        raise ValueError('Invalid hostname with unsupported characters.')\n    if not HOSTNAME_REGEX.match(ascii_hostname):\n        raise ValueError('Hostname contains invalid characters.')\n    parsed = parsed._replace(netloc=ascii_hostname)\n    url = str(urlunparse(parsed))\n    if ascii_hostname in trusted_origins:\n        return url\n    try:\n        ip_addresses = {res[4][0] for res in socket.getaddrinfo(ascii_hostname, None)}\n    except socket.gaierror:\n        raise ValueError(f'Unable to resolve IP address for hostname {ascii_hostname}')\n    if not ip_addresses:\n        raise ValueError(f'No IP addresses found for {ascii_hostname}')\n    for ip in ip_addresses:\n        if _is_ip_blocked(ip):\n            raise ValueError(f'Access to private IP address {ip} for hostname {ascii_hostname} is not allowed.')\n    return url",
        "'\\n    Validates the URL to prevent SSRF attacks by ensuring it does not point to a private\\n    or untrusted IP address, unless whitelisted.\\n    '",
        "url = _canonicalize_url(url)",
        "parsed = urlparse(url)",
        "parsed.scheme NotIn ALLOWED_SCHEMES"
      ],
      "code": "def validate_url(url: str, trusted_origins: list[str]) -> str:\n    \"\"\"\n    Validates the URL to prevent SSRF attacks by ensuring it does not point to a private\n    or untrusted IP address, unless whitelisted.\n    \"\"\"\n    url = _canonicalize_url(url)\n    parsed = urlparse(url)\n    if parsed.scheme not in ALLOWED_SCHEMES:\n        raise ValueError(f\"Scheme '{parsed.scheme}' is not allowed. Only HTTP/HTTPS are supported.\")\n    if not parsed.hostname:\n        raise ValueError('Invalid URL: No hostname found.')\n    try:\n        ascii_hostname = idna.encode(parsed.hostname).decode('ascii')\n    except idna.IDNAError:\n        raise ValueError('Invalid hostname with unsupported characters.')\n    if not HOSTNAME_REGEX.match(ascii_hostname):\n        raise ValueError('Hostname contains invalid characters.')\n    parsed = parsed._replace(netloc=ascii_hostname)\n    url = str(urlunparse(parsed))\n    if ascii_hostname in trusted_origins:\n        return url\n    try:\n        ip_addresses = {res[4][0] for res in socket.getaddrinfo(ascii_hostname, None)}\n    except socket.gaierror:\n        raise ValueError(f'Unable to resolve IP address for hostname {ascii_hostname}')\n    if not ip_addresses:\n        raise ValueError(f'No IP addresses found for {ascii_hostname}')\n    for ip in ip_addresses:\n        if _is_ip_blocked(ip):\n            raise ValueError(f'Access to private IP address {ip} for hostname {ascii_hostname} is not allowed.')\n    return url\n'\\n    Validates the URL to prevent SSRF attacks by ensuring it does not point to a private\\n    or untrusted IP address, unless whitelisted.\\n    '\nurl = _canonicalize_url(url)\nparsed = urlparse(url)\nparsed.scheme NotIn ALLOWED_SCHEMES"
    },
    {
      "id": "n6",
      "type": "block",
      "statements": [
        "raise ValueError(f\"Scheme '{parsed.scheme}' is not allowed. Only HTTP/HTTPS are supported.\")"
      ],
      "code": "raise ValueError(f\"Scheme '{parsed.scheme}' is not allowed. Only HTTP/HTTPS are supported.\")"
    },
    {
      "id": "n7",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n8",
      "type": "block",
      "statements": [
        "not parsed.hostname"
      ],
      "code": "not parsed.hostname"
    },
    {
      "id": "n9",
      "type": "block",
      "statements": [
        "raise ValueError('Invalid URL: No hostname found.')"
      ],
      "code": "raise ValueError('Invalid URL: No hostname found.')"
    },
    {
      "id": "n10",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n11",
      "type": "block",
      "statements": [
        "try:\n    ascii_hostname = idna.encode(parsed.hostname).decode('ascii')\nexcept idna.IDNAError:\n    raise ValueError('Invalid hostname with unsupported characters.')",
        "ascii_hostname = idna.encode(parsed.hostname).decode('ascii')",
        "raise ValueError('Invalid hostname with unsupported characters.')",
        "not HOSTNAME_REGEX.match(ascii_hostname)"
      ],
      "code": "try:\n    ascii_hostname = idna.encode(parsed.hostname).decode('ascii')\nexcept idna.IDNAError:\n    raise ValueError('Invalid hostname with unsupported characters.')\nascii_hostname = idna.encode(parsed.hostname).decode('ascii')\nraise ValueError('Invalid hostname with unsupported characters.')\nnot HOSTNAME_REGEX.match(ascii_hostname)"
    },
    {
      "id": "n12",
      "type": "block",
      "statements": [
        "raise ValueError('Hostname contains invalid characters.')"
      ],
      "code": "raise ValueError('Hostname contains invalid characters.')"
    },
    {
      "id": "n13",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n14",
      "type": "block",
      "statements": [
        "parsed = parsed._replace(netloc=ascii_hostname)",
        "url = str(urlunparse(parsed))",
        "ascii_hostname In trusted_origins"
      ],
      "code": "parsed = parsed._replace(netloc=ascii_hostname)\nurl = str(urlunparse(parsed))\nascii_hostname In trusted_origins"
    },
    {
      "id": "n15",
      "type": "block",
      "statements": [
        "return url"
      ],
      "code": "return url"
    },
    {
      "id": "n16",
      "type": "block",
      "statements": [],
      "code": "\ntry:\n    ip_addresses = {res[4][0] for res in socket.getaddrinfo(ascii_hostname, None)}\nexcept socket.gaierror:\n    raise ValueError(f'Unable to resolve IP address for hostname {ascii_hostname}')\nip_addresses = {res[4][0] for res in socket.getaddrinfo(ascii_hostname, None)}\nraise ValueError(f'Unable to resolve IP address for hostname {ascii_hostname}')\nnot ip_addresses"
    },
    {
      "id": "n17",
      "type": "block",
      "statements": [
        "raise ValueError(f'No IP addresses found for {ascii_hostname}')"
      ],
      "code": "raise ValueError(f'No IP addresses found for {ascii_hostname}')"
    },
    {
      "id": "n18",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n19",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n20",
      "type": "block",
      "statements": [
        "ip",
        "ip_addresses"
      ],
      "code": "ip\nip_addresses"
    },
    {
      "id": "n21",
      "type": "block",
      "statements": [
        "_is_ip_blocked(ip)"
      ],
      "code": "_is_ip_blocked(ip)"
    },
    {
      "id": "n22",
      "type": "block",
      "statements": [
        "return url"
      ],
      "code": "return url"
    },
    {
      "id": "n23",
      "type": "block",
      "statements": [
        "raise ValueError(f'Access to private IP address {ip} for hostname {ascii_hostname} is not allowed.')"
      ],
      "code": "raise ValueError(f'Access to private IP address {ip} for hostname {ascii_hostname} is not allowed.')"
    },
    {
      "id": "n24",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n25",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n26",
      "type": "block",
      "statements": [
        "class Requests:\n    \"\"\"\n    A wrapper around the requests library that validates URLs before making requests.\n    \"\"\"\n\n    def __init__(self, trusted_origins: list[str] | None=None, raise_for_status: bool=True, extra_url_validator: Callable[[str], str] | None=None, extra_headers: dict[str, str] | None=None):\n        self.trusted_origins = []\n        for url in trusted_origins or []:\n            hostname = urlparse(url).hostname\n            if not hostname:\n                raise ValueError(f'Invalid URL: Unable to determine hostname of {url}')\n            self.trusted_origins.append(hostname)\n        self.raise_for_status = raise_for_status\n        self.extra_url_validator = extra_url_validator\n        self.extra_headers = extra_headers\n\n    def request(self, method, url, headers=None, allow_redirects=False, *args, **kwargs) -> req.Response:\n        if self.extra_headers is not None:\n            headers = {**(headers or {}), **self.extra_headers}\n        url = validate_url(url, self.trusted_origins)\n        if self.extra_url_validator is not None:\n            url = self.extra_url_validator(url)\n        response = req.request(method, url, *args, headers=headers, allow_redirects=allow_redirects, **kwargs)\n        if self.raise_for_status:\n            response.raise_for_status()\n        return response\n\n    def get(self, url, *args, **kwargs) -> req.Response:\n        return self.request('GET', url, *args, **kwargs)\n\n    def post(self, url, *args, **kwargs) -> req.Response:\n        return self.request('POST', url, *args, **kwargs)\n\n    def put(self, url, *args, **kwargs) -> req.Response:\n        return self.request('PUT', url, *args, **kwargs)\n\n    def delete(self, url, *args, **kwargs) -> req.Response:\n        return self.request('DELETE', url, *args, **kwargs)\n\n    def head(self, url, *args, **kwargs) -> req.Response:\n        return self.request('HEAD', url, *args, **kwargs)\n\n    def options(self, url, *args, **kwargs) -> req.Response:\n        return self.request('OPTIONS', url, *args, **kwargs)\n\n    def patch(self, url, *args, **kwargs) -> req.Response:\n        return self.request('PATCH', url, *args, **kwargs)",
        "'\\n    A wrapper around the requests library that validates URLs before making requests.\\n    '",
        "def __init__(self, trusted_origins: list[str] | None=None, raise_for_status: bool=True, extra_url_validator: Callable[[str], str] | None=None, extra_headers: dict[str, str] | None=None):\n    self.trusted_origins = []\n    for url in trusted_origins or []:\n        hostname = urlparse(url).hostname\n        if not hostname:\n            raise ValueError(f'Invalid URL: Unable to determine hostname of {url}')\n        self.trusted_origins.append(hostname)\n    self.raise_for_status = raise_for_status\n    self.extra_url_validator = extra_url_validator\n    self.extra_headers = extra_headers",
        "self.trusted_origins = []"
      ],
      "code": "class Requests:\n    \"\"\"\n    A wrapper around the requests library that validates URLs before making requests.\n    \"\"\"\n\n    def __init__(self, trusted_origins: list[str] | None=None, raise_for_status: bool=True, extra_url_validator: Callable[[str], str] | None=None, extra_headers: dict[str, str] | None=None):\n        self.trusted_origins = []\n        for url in trusted_origins or []:\n            hostname = urlparse(url).hostname\n            if not hostname:\n                raise ValueError(f'Invalid URL: Unable to determine hostname of {url}')\n            self.trusted_origins.append(hostname)\n        self.raise_for_status = raise_for_status\n        self.extra_url_validator = extra_url_validator\n        self.extra_headers = extra_headers\n\n    def request(self, method, url, headers=None, allow_redirects=False, *args, **kwargs) -> req.Response:\n        if self.extra_headers is not None:\n            headers = {**(headers or {}), **self.extra_headers}\n        url = validate_url(url, self.trusted_origins)\n        if self.extra_url_validator is not None:\n            url = self.extra_url_validator(url)\n        response = req.request(method, url, *args, headers=headers, allow_redirects=allow_redirects, **kwargs)\n        if self.raise_for_status:\n            response.raise_for_status()\n        return response\n\n    def get(self, url, *args, **kwargs) -> req.Response:\n        return self.request('GET', url, *args, **kwargs)\n\n    def post(self, url, *args, **kwargs) -> req.Response:\n        return self.request('POST', url, *args, **kwargs)\n\n    def put(self, url, *args, **kwargs) -> req.Response:\n        return self.request('PUT', url, *args, **kwargs)\n\n    def delete(self, url, *args, **kwargs) -> req.Response:\n        return self.request('DELETE', url, *args, **kwargs)\n\n    def head(self, url, *args, **kwargs) -> req.Response:\n        return self.request('HEAD', url, *args, **kwargs)\n\n    def options(self, url, *args, **kwargs) -> req.Response:\n        return self.request('OPTIONS', url, *args, **kwargs)\n\n    def patch(self, url, *args, **kwargs) -> req.Response:\n        return self.request('PATCH', url, *args, **kwargs)\n'\\n    A wrapper around the requests library that validates URLs before making requests.\\n    '\ndef __init__(self, trusted_origins: list[str] | None=None, raise_for_status: bool=True, extra_url_validator: Callable[[str], str] | None=None, extra_headers: dict[str, str] | None=None):\n    self.trusted_origins = []\n    for url in trusted_origins or []:\n        hostname = urlparse(url).hostname\n        if not hostname:\n            raise ValueError(f'Invalid URL: Unable to determine hostname of {url}')\n        self.trusted_origins.append(hostname)\n    self.raise_for_status = raise_for_status\n    self.extra_url_validator = extra_url_validator\n    self.extra_headers = extra_headers\nself.trusted_origins = []"
    },
    {
      "id": "n27",
      "type": "block",
      "statements": [
        "url",
        "trusted_origins or []"
      ],
      "code": "url\ntrusted_origins or []"
    },
    {
      "id": "n28",
      "type": "block",
      "statements": [
        "hostname = urlparse(url).hostname",
        "not hostname"
      ],
      "code": "hostname = urlparse(url).hostname\nnot hostname"
    },
    {
      "id": "n29",
      "type": "block",
      "statements": [
        "self.raise_for_status = raise_for_status",
        "self.extra_url_validator = extra_url_validator",
        "self.extra_headers = extra_headers",
        "def request(self, method, url, headers=None, allow_redirects=False, *args, **kwargs) -> req.Response:\n    if self.extra_headers is not None:\n        headers = {**(headers or {}), **self.extra_headers}\n    url = validate_url(url, self.trusted_origins)\n    if self.extra_url_validator is not None:\n        url = self.extra_url_validator(url)\n    response = req.request(method, url, *args, headers=headers, allow_redirects=allow_redirects, **kwargs)\n    if self.raise_for_status:\n        response.raise_for_status()\n    return response",
        "self.extra_headers IsNot None"
      ],
      "code": "self.raise_for_status = raise_for_status\nself.extra_url_validator = extra_url_validator\nself.extra_headers = extra_headers\ndef request(self, method, url, headers=None, allow_redirects=False, *args, **kwargs) -> req.Response:\n    if self.extra_headers is not None:\n        headers = {**(headers or {}), **self.extra_headers}\n    url = validate_url(url, self.trusted_origins)\n    if self.extra_url_validator is not None:\n        url = self.extra_url_validator(url)\n    response = req.request(method, url, *args, headers=headers, allow_redirects=allow_redirects, **kwargs)\n    if self.raise_for_status:\n        response.raise_for_status()\n    return response\nself.extra_headers IsNot None"
    },
    {
      "id": "n30",
      "type": "block",
      "statements": [
        "raise ValueError(f'Invalid URL: Unable to determine hostname of {url}')"
      ],
      "code": "raise ValueError(f'Invalid URL: Unable to determine hostname of {url}')"
    },
    {
      "id": "n31",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n32",
      "type": "block",
      "statements": [
        "self.trusted_origins.append(hostname)"
      ],
      "code": "self.trusted_origins.append(hostname)"
    },
    {
      "id": "n33",
      "type": "block",
      "statements": [
        "headers = {**(headers or {}), **self.extra_headers}"
      ],
      "code": "headers = {**(headers or {}), **self.extra_headers}"
    },
    {
      "id": "n34",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n35",
      "type": "block",
      "statements": [
        "url = validate_url(url, self.trusted_origins)",
        "self.extra_url_validator IsNot None"
      ],
      "code": "url = validate_url(url, self.trusted_origins)\nself.extra_url_validator IsNot None"
    },
    {
      "id": "n36",
      "type": "block",
      "statements": [
        "url = self.extra_url_validator(url)"
      ],
      "code": "url = self.extra_url_validator(url)"
    },
    {
      "id": "n37",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n38",
      "type": "block",
      "statements": [
        "response = req.request(method, url, *args, headers=headers, allow_redirects=allow_redirects, **kwargs)",
        "self.raise_for_status"
      ],
      "code": "response = req.request(method, url, *args, headers=headers, allow_redirects=allow_redirects, **kwargs)\nself.raise_for_status"
    },
    {
      "id": "n39",
      "type": "block",
      "statements": [
        "response.raise_for_status()"
      ],
      "code": "response.raise_for_status()"
    },
    {
      "id": "n40",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n41",
      "type": "block",
      "statements": [
        "return response"
      ],
      "code": "return response"
    },
    {
      "id": "n42",
      "type": "block",
      "statements": [
        "def get(self, url, *args, **kwargs) -> req.Response:\n    return self.request('GET', url, *args, **kwargs)",
        "return self.request('GET', url, *args, **kwargs)"
      ],
      "code": "def get(self, url, *args, **kwargs) -> req.Response:\n    return self.request('GET', url, *args, **kwargs)\nreturn self.request('GET', url, *args, **kwargs)"
    },
    {
      "id": "n43",
      "type": "block",
      "statements": [
        "def post(self, url, *args, **kwargs) -> req.Response:\n    return self.request('POST', url, *args, **kwargs)",
        "return self.request('POST', url, *args, **kwargs)"
      ],
      "code": "def post(self, url, *args, **kwargs) -> req.Response:\n    return self.request('POST', url, *args, **kwargs)\nreturn self.request('POST', url, *args, **kwargs)"
    },
    {
      "id": "n44",
      "type": "block",
      "statements": [
        "def put(self, url, *args, **kwargs) -> req.Response:\n    return self.request('PUT', url, *args, **kwargs)",
        "return self.request('PUT', url, *args, **kwargs)"
      ],
      "code": "def put(self, url, *args, **kwargs) -> req.Response:\n    return self.request('PUT', url, *args, **kwargs)\nreturn self.request('PUT', url, *args, **kwargs)"
    },
    {
      "id": "n45",
      "type": "block",
      "statements": [
        "def delete(self, url, *args, **kwargs) -> req.Response:\n    return self.request('DELETE', url, *args, **kwargs)",
        "return self.request('DELETE', url, *args, **kwargs)"
      ],
      "code": "def delete(self, url, *args, **kwargs) -> req.Response:\n    return self.request('DELETE', url, *args, **kwargs)\nreturn self.request('DELETE', url, *args, **kwargs)"
    },
    {
      "id": "n46",
      "type": "block",
      "statements": [
        "def head(self, url, *args, **kwargs) -> req.Response:\n    return self.request('HEAD', url, *args, **kwargs)",
        "return self.request('HEAD', url, *args, **kwargs)"
      ],
      "code": "def head(self, url, *args, **kwargs) -> req.Response:\n    return self.request('HEAD', url, *args, **kwargs)\nreturn self.request('HEAD', url, *args, **kwargs)"
    },
    {
      "id": "n47",
      "type": "block",
      "statements": [
        "def options(self, url, *args, **kwargs) -> req.Response:\n    return self.request('OPTIONS', url, *args, **kwargs)",
        "return self.request('OPTIONS', url, *args, **kwargs)"
      ],
      "code": "def options(self, url, *args, **kwargs) -> req.Response:\n    return self.request('OPTIONS', url, *args, **kwargs)\nreturn self.request('OPTIONS', url, *args, **kwargs)"
    },
    {
      "id": "n48",
      "type": "block",
      "statements": [
        "def patch(self, url, *args, **kwargs) -> req.Response:\n    return self.request('PATCH', url, *args, **kwargs)",
        "return self.request('PATCH', url, *args, **kwargs)"
      ],
      "code": "def patch(self, url, *args, **kwargs) -> req.Response:\n    return self.request('PATCH', url, *args, **kwargs)\nreturn self.request('PATCH', url, *args, **kwargs)"
    },
    {
      "id": "n49",
      "type": "block",
      "statements": [
        "requests = Requests(trusted_origins=Config().trust_endpoints_for_requests)"
      ],
      "code": "requests = Requests(trusted_origins=Config().trust_endpoints_for_requests)"
    }
  ],
  "edges": [
    {
      "source": "n38",
      "target": "n39"
    },
    {
      "source": "n14",
      "target": "n15"
    },
    {
      "source": "n0",
      "target": "n1"
    },
    {
      "source": "n29",
      "target": "n33"
    },
    {
      "source": "n23",
      "target": "n25"
    },
    {
      "source": "n35",
      "target": "n37"
    },
    {
      "source": "n34",
      "target": "n35"
    },
    {
      "source": "n10",
      "target": "n11"
    },
    {
      "source": "n21",
      "target": "n24"
    },
    {
      "source": "n17",
      "target": "n19"
    },
    {
      "source": "n26",
      "target": "n27"
    },
    {
      "source": "n2",
      "target": "n3"
    },
    {
      "source": "n11",
      "target": "n13"
    },
    {
      "source": "n40",
      "target": "n41"
    },
    {
      "source": "n13",
      "target": "n14"
    },
    {
      "source": "n28",
      "target": "n31"
    },
    {
      "source": "n35",
      "target": "n36"
    },
    {
      "source": "n16",
      "target": "n17"
    },
    {
      "source": "n8",
      "target": "n9"
    },
    {
      "source": "n16",
      "target": "n18"
    },
    {
      "source": "n33",
      "target": "n35"
    },
    {
      "source": "n19",
      "target": "n20"
    },
    {
      "source": "n29",
      "target": "n34"
    },
    {
      "source": "n24",
      "target": "n25"
    },
    {
      "source": "n7",
      "target": "n8"
    },
    {
      "source": "n21",
      "target": "n23"
    },
    {
      "source": "n25",
      "target": "n20"
    },
    {
      "source": "n12",
      "target": "n14"
    },
    {
      "source": "n9",
      "target": "n11"
    },
    {
      "source": "n32",
      "target": "n27"
    },
    {
      "source": "n36",
      "target": "n38"
    },
    {
      "source": "n14",
      "target": "n16"
    },
    {
      "source": "n20",
      "target": "n21"
    },
    {
      "source": "n28",
      "target": "n30"
    },
    {
      "source": "n31",
      "target": "n32"
    },
    {
      "source": "n11",
      "target": "n12"
    },
    {
      "source": "n18",
      "target": "n19"
    },
    {
      "source": "n37",
      "target": "n38"
    },
    {
      "source": "n38",
      "target": "n40"
    },
    {
      "source": "n5",
      "target": "n6"
    },
    {
      "source": "n27",
      "target": "n29"
    },
    {
      "source": "n1",
      "target": "n3"
    },
    {
      "source": "n27",
      "target": "n28"
    },
    {
      "source": "n8",
      "target": "n10"
    },
    {
      "source": "n20",
      "target": "n22"
    },
    {
      "source": "n5",
      "target": "n7"
    },
    {
      "source": "n6",
      "target": "n8"
    },
    {
      "source": "n39",
      "target": "n41"
    },
    {
      "source": "n0",
      "target": "n2"
    },
    {
      "source": "n30",
      "target": "n32"
    }
  ]
}