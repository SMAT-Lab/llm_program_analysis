{
  "nodes": [
    {
      "id": "n0",
      "type": "block",
      "statements": [
        "import asyncio",
        "import logging",
        "import uuid",
        "from collections import defaultdict",
        "from datetime import datetime, timezone",
        "from typing import Any, Literal, Optional, Type",
        "import prisma",
        "from prisma.models import AgentGraph, AgentGraphExecution, AgentNode, AgentNodeLink",
        "from prisma.types import AgentGraphWhereInput",
        "from pydantic.fields import computed_field",
        "from backend.blocks.agent import AgentExecutorBlock",
        "from backend.blocks.basic import AgentInputBlock, AgentOutputBlock",
        "from backend.util import json",
        "from .block import BlockInput, BlockType, get_block, get_blocks",
        "from .db import BaseDbModel, transaction",
        "from .execution import ExecutionStatus",
        "from .includes import AGENT_GRAPH_INCLUDE, AGENT_NODE_INCLUDE",
        "from .integrations import Webhook",
        "logger = logging.getLogger(__name__)",
        "class Link(BaseDbModel):\n    source_id: str\n    sink_id: str\n    source_name: str\n    sink_name: str\n    is_static: bool = False\n\n    @staticmethod\n    def from_db(link: AgentNodeLink):\n        return Link(id=link.id, source_name=link.sourceName, source_id=link.agentNodeSourceId, sink_name=link.sinkName, sink_id=link.agentNodeSinkId, is_static=link.isStatic)\n\n    def __hash__(self):\n        return hash((self.source_id, self.sink_id, self.source_name, self.sink_name))",
        "source_id: str",
        "sink_id: str",
        "source_name: str",
        "sink_name: str",
        "is_static: bool = False",
        "@staticmethod\ndef from_db(link: AgentNodeLink):\n    return Link(id=link.id, source_name=link.sourceName, source_id=link.agentNodeSourceId, sink_name=link.sinkName, sink_id=link.agentNodeSinkId, is_static=link.isStatic)",
        "return Link(id=link.id, source_name=link.sourceName, source_id=link.agentNodeSourceId, sink_name=link.sinkName, sink_id=link.agentNodeSinkId, is_static=link.isStatic)"
      ],
      "code": "import asyncio\nimport logging\nimport uuid\nfrom collections import defaultdict\nfrom datetime import datetime, timezone\nfrom typing import Any, Literal, Optional, Type\nimport prisma\nfrom prisma.models import AgentGraph, AgentGraphExecution, AgentNode, AgentNodeLink\nfrom prisma.types import AgentGraphWhereInput\nfrom pydantic.fields import computed_field\nfrom backend.blocks.agent import AgentExecutorBlock\nfrom backend.blocks.basic import AgentInputBlock, AgentOutputBlock\nfrom backend.util import json\nfrom .block import BlockInput, BlockType, get_block, get_blocks\nfrom .db import BaseDbModel, transaction\nfrom .execution import ExecutionStatus\nfrom .includes import AGENT_GRAPH_INCLUDE, AGENT_NODE_INCLUDE\nfrom .integrations import Webhook\nlogger = logging.getLogger(__name__)\nclass Link(BaseDbModel):\n    source_id: str\n    sink_id: str\n    source_name: str\n    sink_name: str\n    is_static: bool = False\n\n    @staticmethod\n    def from_db(link: AgentNodeLink):\n        return Link(id=link.id, source_name=link.sourceName, source_id=link.agentNodeSourceId, sink_name=link.sinkName, sink_id=link.agentNodeSinkId, is_static=link.isStatic)\n\n    def __hash__(self):\n        return hash((self.source_id, self.sink_id, self.source_name, self.sink_name))\nsource_id: str\nsink_id: str\nsource_name: str\nsink_name: str\nis_static: bool = False\n@staticmethod\ndef from_db(link: AgentNodeLink):\n    return Link(id=link.id, source_name=link.sourceName, source_id=link.agentNodeSourceId, sink_name=link.sinkName, sink_id=link.agentNodeSinkId, is_static=link.isStatic)\nreturn Link(id=link.id, source_name=link.sourceName, source_id=link.agentNodeSourceId, sink_name=link.sinkName, sink_id=link.agentNodeSinkId, is_static=link.isStatic)"
    },
    {
      "id": "n1",
      "type": "block",
      "statements": [
        "def __hash__(self):\n    return hash((self.source_id, self.sink_id, self.source_name, self.sink_name))",
        "return hash((self.source_id, self.sink_id, self.source_name, self.sink_name))"
      ],
      "code": "def __hash__(self):\n    return hash((self.source_id, self.sink_id, self.source_name, self.sink_name))\nreturn hash((self.source_id, self.sink_id, self.source_name, self.sink_name))"
    },
    {
      "id": "n2",
      "type": "block",
      "statements": [
        "class Node(BaseDbModel):\n    block_id: str\n    input_default: BlockInput = {}\n    metadata: dict[str, Any] = {}\n    input_links: list[Link] = []\n    output_links: list[Link] = []\n    webhook_id: Optional[str] = None",
        "block_id: str",
        "input_default: BlockInput = {}",
        "metadata: dict[str, Any] = {}",
        "input_links: list[Link] = []",
        "output_links: list[Link] = []",
        "webhook_id: Optional[str] = None",
        "class NodeModel(Node):\n    graph_id: str\n    graph_version: int\n    webhook: Optional[Webhook] = None\n\n    @staticmethod\n    def from_db(node: AgentNode):\n        if not node.AgentBlock:\n            raise ValueError(f'Invalid node {node.id}, invalid AgentBlock.')\n        obj = NodeModel(id=node.id, block_id=node.AgentBlock.id, input_default=json.loads(node.constantInput, target_type=dict[str, Any]), metadata=json.loads(node.metadata, target_type=dict[str, Any]), graph_id=node.agentGraphId, graph_version=node.agentGraphVersion, webhook_id=node.webhookId, webhook=Webhook.from_db(node.Webhook) if node.Webhook else None)\n        obj.input_links = [Link.from_db(link) for link in node.Input or []]\n        obj.output_links = [Link.from_db(link) for link in node.Output or []]\n        return obj\n\n    def is_triggered_by_event_type(self, event_type: str) -> bool:\n        if not (block := get_block(self.block_id)):\n            raise ValueError(f'Block #{self.block_id} not found for node #{self.id}')\n        if not block.webhook_config:\n            raise TypeError(\"This method can't be used on non-webhook blocks\")\n        if not block.webhook_config.event_filter_input:\n            return True\n        event_filter = self.input_default.get(block.webhook_config.event_filter_input)\n        if not event_filter:\n            raise ValueError(f'Event filter is not configured on node #{self.id}')\n        return event_type in [block.webhook_config.event_format.format(event=k) for k in event_filter if event_filter[k] is True]",
        "graph_id: str",
        "graph_version: int",
        "webhook: Optional[Webhook] = None",
        "@staticmethod\ndef from_db(node: AgentNode):\n    if not node.AgentBlock:\n        raise ValueError(f'Invalid node {node.id}, invalid AgentBlock.')\n    obj = NodeModel(id=node.id, block_id=node.AgentBlock.id, input_default=json.loads(node.constantInput, target_type=dict[str, Any]), metadata=json.loads(node.metadata, target_type=dict[str, Any]), graph_id=node.agentGraphId, graph_version=node.agentGraphVersion, webhook_id=node.webhookId, webhook=Webhook.from_db(node.Webhook) if node.Webhook else None)\n    obj.input_links = [Link.from_db(link) for link in node.Input or []]\n    obj.output_links = [Link.from_db(link) for link in node.Output or []]\n    return obj",
        "not node.AgentBlock"
      ],
      "code": "class Node(BaseDbModel):\n    block_id: str\n    input_default: BlockInput = {}\n    metadata: dict[str, Any] = {}\n    input_links: list[Link] = []\n    output_links: list[Link] = []\n    webhook_id: Optional[str] = None\nblock_id: str\ninput_default: BlockInput = {}\nmetadata: dict[str, Any] = {}\ninput_links: list[Link] = []\noutput_links: list[Link] = []\nwebhook_id: Optional[str] = None\nclass NodeModel(Node):\n    graph_id: str\n    graph_version: int\n    webhook: Optional[Webhook] = None\n\n    @staticmethod\n    def from_db(node: AgentNode):\n        if not node.AgentBlock:\n            raise ValueError(f'Invalid node {node.id}, invalid AgentBlock.')\n        obj = NodeModel(id=node.id, block_id=node.AgentBlock.id, input_default=json.loads(node.constantInput, target_type=dict[str, Any]), metadata=json.loads(node.metadata, target_type=dict[str, Any]), graph_id=node.agentGraphId, graph_version=node.agentGraphVersion, webhook_id=node.webhookId, webhook=Webhook.from_db(node.Webhook) if node.Webhook else None)\n        obj.input_links = [Link.from_db(link) for link in node.Input or []]\n        obj.output_links = [Link.from_db(link) for link in node.Output or []]\n        return obj\n\n    def is_triggered_by_event_type(self, event_type: str) -> bool:\n        if not (block := get_block(self.block_id)):\n            raise ValueError(f'Block #{self.block_id} not found for node #{self.id}')\n        if not block.webhook_config:\n            raise TypeError(\"This method can't be used on non-webhook blocks\")\n        if not block.webhook_config.event_filter_input:\n            return True\n        event_filter = self.input_default.get(block.webhook_config.event_filter_input)\n        if not event_filter:\n            raise ValueError(f'Event filter is not configured on node #{self.id}')\n        return event_type in [block.webhook_config.event_format.format(event=k) for k in event_filter if event_filter[k] is True]\ngraph_id: str\ngraph_version: int\nwebhook: Optional[Webhook] = None\n@staticmethod\ndef from_db(node: AgentNode):\n    if not node.AgentBlock:\n        raise ValueError(f'Invalid node {node.id}, invalid AgentBlock.')\n    obj = NodeModel(id=node.id, block_id=node.AgentBlock.id, input_default=json.loads(node.constantInput, target_type=dict[str, Any]), metadata=json.loads(node.metadata, target_type=dict[str, Any]), graph_id=node.agentGraphId, graph_version=node.agentGraphVersion, webhook_id=node.webhookId, webhook=Webhook.from_db(node.Webhook) if node.Webhook else None)\n    obj.input_links = [Link.from_db(link) for link in node.Input or []]\n    obj.output_links = [Link.from_db(link) for link in node.Output or []]\n    return obj\nnot node.AgentBlock"
    },
    {
      "id": "n3",
      "type": "block",
      "statements": [
        "raise ValueError(f'Invalid node {node.id}, invalid AgentBlock.')"
      ],
      "code": "raise ValueError(f'Invalid node {node.id}, invalid AgentBlock.')"
    },
    {
      "id": "n4",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n5",
      "type": "block",
      "statements": [
        "obj = NodeModel(id=node.id, block_id=node.AgentBlock.id, input_default=json.loads(node.constantInput, target_type=dict[str, Any]), metadata=json.loads(node.metadata, target_type=dict[str, Any]), graph_id=node.agentGraphId, graph_version=node.agentGraphVersion, webhook_id=node.webhookId, webhook=Webhook.from_db(node.Webhook) if node.Webhook else None)",
        "obj.input_links = [Link.from_db(link) for link in node.Input or []]",
        "obj.output_links = [Link.from_db(link) for link in node.Output or []]",
        "return obj"
      ],
      "code": "obj = NodeModel(id=node.id, block_id=node.AgentBlock.id, input_default=json.loads(node.constantInput, target_type=dict[str, Any]), metadata=json.loads(node.metadata, target_type=dict[str, Any]), graph_id=node.agentGraphId, graph_version=node.agentGraphVersion, webhook_id=node.webhookId, webhook=Webhook.from_db(node.Webhook) if node.Webhook else None)\nobj.input_links = [Link.from_db(link) for link in node.Input or []]\nobj.output_links = [Link.from_db(link) for link in node.Output or []]\nreturn obj"
    },
    {
      "id": "n6",
      "type": "block",
      "statements": [
        "def is_triggered_by_event_type(self, event_type: str) -> bool:\n    if not (block := get_block(self.block_id)):\n        raise ValueError(f'Block #{self.block_id} not found for node #{self.id}')\n    if not block.webhook_config:\n        raise TypeError(\"This method can't be used on non-webhook blocks\")\n    if not block.webhook_config.event_filter_input:\n        return True\n    event_filter = self.input_default.get(block.webhook_config.event_filter_input)\n    if not event_filter:\n        raise ValueError(f'Event filter is not configured on node #{self.id}')\n    return event_type in [block.webhook_config.event_format.format(event=k) for k in event_filter if event_filter[k] is True]",
        "not (block := get_block(self.block_id))"
      ],
      "code": "def is_triggered_by_event_type(self, event_type: str) -> bool:\n    if not (block := get_block(self.block_id)):\n        raise ValueError(f'Block #{self.block_id} not found for node #{self.id}')\n    if not block.webhook_config:\n        raise TypeError(\"This method can't be used on non-webhook blocks\")\n    if not block.webhook_config.event_filter_input:\n        return True\n    event_filter = self.input_default.get(block.webhook_config.event_filter_input)\n    if not event_filter:\n        raise ValueError(f'Event filter is not configured on node #{self.id}')\n    return event_type in [block.webhook_config.event_format.format(event=k) for k in event_filter if event_filter[k] is True]\nnot (block := get_block(self.block_id))"
    },
    {
      "id": "n7",
      "type": "block",
      "statements": [
        "raise ValueError(f'Block #{self.block_id} not found for node #{self.id}')"
      ],
      "code": "raise ValueError(f'Block #{self.block_id} not found for node #{self.id}')"
    },
    {
      "id": "n8",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n9",
      "type": "block",
      "statements": [
        "not block.webhook_config"
      ],
      "code": "not block.webhook_config"
    },
    {
      "id": "n10",
      "type": "block",
      "statements": [
        "raise TypeError(\"This method can't be used on non-webhook blocks\")"
      ],
      "code": "raise TypeError(\"This method can't be used on non-webhook blocks\")"
    },
    {
      "id": "n11",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n12",
      "type": "block",
      "statements": [
        "not block.webhook_config.event_filter_input"
      ],
      "code": "not block.webhook_config.event_filter_input"
    },
    {
      "id": "n13",
      "type": "block",
      "statements": [
        "return True"
      ],
      "code": "return True"
    },
    {
      "id": "n14",
      "type": "block",
      "statements": [],
      "code": "\nevent_filter = self.input_default.get(block.webhook_config.event_filter_input)\nnot event_filter"
    },
    {
      "id": "n15",
      "type": "block",
      "statements": [
        "raise ValueError(f'Event filter is not configured on node #{self.id}')"
      ],
      "code": "raise ValueError(f'Event filter is not configured on node #{self.id}')"
    },
    {
      "id": "n16",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n17",
      "type": "block",
      "statements": [
        "return event_type in [block.webhook_config.event_format.format(event=k) for k in event_filter if event_filter[k] is True]"
      ],
      "code": "return event_type in [block.webhook_config.event_format.format(event=k) for k in event_filter if event_filter[k] is True]"
    },
    {
      "id": "n18",
      "type": "block",
      "statements": [
        "Webhook.model_rebuild()",
        "class GraphExecution(BaseDbModel):\n    execution_id: str\n    started_at: datetime\n    ended_at: datetime\n    duration: float\n    total_run_time: float\n    status: ExecutionStatus\n    graph_id: str\n    graph_version: int\n\n    @staticmethod\n    def from_db(execution: AgentGraphExecution):\n        now = datetime.now(timezone.utc)\n        start_time = execution.startedAt or execution.createdAt\n        end_time = execution.updatedAt or now\n        duration = (end_time - start_time).total_seconds()\n        total_run_time = duration\n        try:\n            stats = json.loads(execution.stats or '{}', target_type=dict[str, Any])\n        except ValueError:\n            stats = {}\n        duration = stats.get('walltime', duration)\n        total_run_time = stats.get('nodes_walltime', total_run_time)\n        return GraphExecution(id=execution.id, execution_id=execution.id, started_at=start_time, ended_at=end_time, duration=duration, total_run_time=total_run_time, status=ExecutionStatus(execution.executionStatus), graph_id=execution.agentGraphId, graph_version=execution.agentGraphVersion)",
        "execution_id: str",
        "started_at: datetime",
        "ended_at: datetime",
        "duration: float",
        "total_run_time: float",
        "status: ExecutionStatus",
        "graph_id: str",
        "graph_version: int",
        "@staticmethod\ndef from_db(execution: AgentGraphExecution):\n    now = datetime.now(timezone.utc)\n    start_time = execution.startedAt or execution.createdAt\n    end_time = execution.updatedAt or now\n    duration = (end_time - start_time).total_seconds()\n    total_run_time = duration\n    try:\n        stats = json.loads(execution.stats or '{}', target_type=dict[str, Any])\n    except ValueError:\n        stats = {}\n    duration = stats.get('walltime', duration)\n    total_run_time = stats.get('nodes_walltime', total_run_time)\n    return GraphExecution(id=execution.id, execution_id=execution.id, started_at=start_time, ended_at=end_time, duration=duration, total_run_time=total_run_time, status=ExecutionStatus(execution.executionStatus), graph_id=execution.agentGraphId, graph_version=execution.agentGraphVersion)",
        "now = datetime.now(timezone.utc)",
        "start_time = execution.startedAt or execution.createdAt",
        "end_time = execution.updatedAt or now",
        "duration = (end_time - start_time).total_seconds()",
        "total_run_time = duration",
        "try:\n    stats = json.loads(execution.stats or '{}', target_type=dict[str, Any])\nexcept ValueError:\n    stats = {}",
        "stats = json.loads(execution.stats or '{}', target_type=dict[str, Any])",
        "stats = {}",
        "duration = stats.get('walltime', duration)",
        "total_run_time = stats.get('nodes_walltime', total_run_time)",
        "return GraphExecution(id=execution.id, execution_id=execution.id, started_at=start_time, ended_at=end_time, duration=duration, total_run_time=total_run_time, status=ExecutionStatus(execution.executionStatus), graph_id=execution.agentGraphId, graph_version=execution.agentGraphVersion)"
      ],
      "code": "Webhook.model_rebuild()\nclass GraphExecution(BaseDbModel):\n    execution_id: str\n    started_at: datetime\n    ended_at: datetime\n    duration: float\n    total_run_time: float\n    status: ExecutionStatus\n    graph_id: str\n    graph_version: int\n\n    @staticmethod\n    def from_db(execution: AgentGraphExecution):\n        now = datetime.now(timezone.utc)\n        start_time = execution.startedAt or execution.createdAt\n        end_time = execution.updatedAt or now\n        duration = (end_time - start_time).total_seconds()\n        total_run_time = duration\n        try:\n            stats = json.loads(execution.stats or '{}', target_type=dict[str, Any])\n        except ValueError:\n            stats = {}\n        duration = stats.get('walltime', duration)\n        total_run_time = stats.get('nodes_walltime', total_run_time)\n        return GraphExecution(id=execution.id, execution_id=execution.id, started_at=start_time, ended_at=end_time, duration=duration, total_run_time=total_run_time, status=ExecutionStatus(execution.executionStatus), graph_id=execution.agentGraphId, graph_version=execution.agentGraphVersion)\nexecution_id: str\nstarted_at: datetime\nended_at: datetime\nduration: float\ntotal_run_time: float\nstatus: ExecutionStatus\ngraph_id: str\ngraph_version: int\n@staticmethod\ndef from_db(execution: AgentGraphExecution):\n    now = datetime.now(timezone.utc)\n    start_time = execution.startedAt or execution.createdAt\n    end_time = execution.updatedAt or now\n    duration = (end_time - start_time).total_seconds()\n    total_run_time = duration\n    try:\n        stats = json.loads(execution.stats or '{}', target_type=dict[str, Any])\n    except ValueError:\n        stats = {}\n    duration = stats.get('walltime', duration)\n    total_run_time = stats.get('nodes_walltime', total_run_time)\n    return GraphExecution(id=execution.id, execution_id=execution.id, started_at=start_time, ended_at=end_time, duration=duration, total_run_time=total_run_time, status=ExecutionStatus(execution.executionStatus), graph_id=execution.agentGraphId, graph_version=execution.agentGraphVersion)\nnow = datetime.now(timezone.utc)\nstart_time = execution.startedAt or execution.createdAt\nend_time = execution.updatedAt or now\nduration = (end_time - start_time).total_seconds()\ntotal_run_time = duration\ntry:\n    stats = json.loads(execution.stats or '{}', target_type=dict[str, Any])\nexcept ValueError:\n    stats = {}\nstats = json.loads(execution.stats or '{}', target_type=dict[str, Any])\nstats = {}\nduration = stats.get('walltime', duration)\ntotal_run_time = stats.get('nodes_walltime', total_run_time)\nreturn GraphExecution(id=execution.id, execution_id=execution.id, started_at=start_time, ended_at=end_time, duration=duration, total_run_time=total_run_time, status=ExecutionStatus(execution.executionStatus), graph_id=execution.agentGraphId, graph_version=execution.agentGraphVersion)"
    },
    {
      "id": "n19",
      "type": "block",
      "statements": [
        "class Graph(BaseDbModel):\n    version: int = 1\n    is_active: bool = True\n    is_template: bool = False\n    name: str\n    description: str\n    nodes: list[Node] = []\n    links: list[Link] = []\n\n    @computed_field\n    @property\n    def input_schema(self) -> dict[str, Any]:\n        return self._generate_schema(AgentInputBlock.Input, [node.input_default for node in self.nodes if (b := get_block(node.block_id)) and b.block_type == BlockType.INPUT and ('name' in node.input_default)])\n\n    @computed_field\n    @property\n    def output_schema(self) -> dict[str, Any]:\n        return self._generate_schema(AgentOutputBlock.Input, [node.input_default for node in self.nodes if (b := get_block(node.block_id)) and b.block_type == BlockType.OUTPUT and ('name' in node.input_default)])\n\n    @staticmethod\n    def _generate_schema(type_class: Type[AgentInputBlock.Input] | Type[AgentOutputBlock.Input], data: list[dict]) -> dict[str, Any]:\n        props = []\n        for p in data:\n            try:\n                props.append(type_class(**p))\n            except Exception as e:\n                logger.warning(f'Invalid {type_class}: {p}, {e}')\n        return {'type': 'object', 'properties': {p.name: {'secret': p.secret, 'advanced': p.advanced, 'title': p.title or p.name, **({'description': p.description} if p.description else {}), **({'default': p.value} if p.value is not None else {})} for p in props}, 'required': [p.name for p in props if p.value is None]}",
        "version: int = 1",
        "is_active: bool = True",
        "is_template: bool = False",
        "name: str",
        "description: str",
        "nodes: list[Node] = []",
        "links: list[Link] = []",
        "@computed_field\n@property\ndef input_schema(self) -> dict[str, Any]:\n    return self._generate_schema(AgentInputBlock.Input, [node.input_default for node in self.nodes if (b := get_block(node.block_id)) and b.block_type == BlockType.INPUT and ('name' in node.input_default)])",
        "return self._generate_schema(AgentInputBlock.Input, [node.input_default for node in self.nodes if (b := get_block(node.block_id)) and b.block_type == BlockType.INPUT and ('name' in node.input_default)])"
      ],
      "code": "class Graph(BaseDbModel):\n    version: int = 1\n    is_active: bool = True\n    is_template: bool = False\n    name: str\n    description: str\n    nodes: list[Node] = []\n    links: list[Link] = []\n\n    @computed_field\n    @property\n    def input_schema(self) -> dict[str, Any]:\n        return self._generate_schema(AgentInputBlock.Input, [node.input_default for node in self.nodes if (b := get_block(node.block_id)) and b.block_type == BlockType.INPUT and ('name' in node.input_default)])\n\n    @computed_field\n    @property\n    def output_schema(self) -> dict[str, Any]:\n        return self._generate_schema(AgentOutputBlock.Input, [node.input_default for node in self.nodes if (b := get_block(node.block_id)) and b.block_type == BlockType.OUTPUT and ('name' in node.input_default)])\n\n    @staticmethod\n    def _generate_schema(type_class: Type[AgentInputBlock.Input] | Type[AgentOutputBlock.Input], data: list[dict]) -> dict[str, Any]:\n        props = []\n        for p in data:\n            try:\n                props.append(type_class(**p))\n            except Exception as e:\n                logger.warning(f'Invalid {type_class}: {p}, {e}')\n        return {'type': 'object', 'properties': {p.name: {'secret': p.secret, 'advanced': p.advanced, 'title': p.title or p.name, **({'description': p.description} if p.description else {}), **({'default': p.value} if p.value is not None else {})} for p in props}, 'required': [p.name for p in props if p.value is None]}\nversion: int = 1\nis_active: bool = True\nis_template: bool = False\nname: str\ndescription: str\nnodes: list[Node] = []\nlinks: list[Link] = []\n@computed_field\n@property\ndef input_schema(self) -> dict[str, Any]:\n    return self._generate_schema(AgentInputBlock.Input, [node.input_default for node in self.nodes if (b := get_block(node.block_id)) and b.block_type == BlockType.INPUT and ('name' in node.input_default)])\nreturn self._generate_schema(AgentInputBlock.Input, [node.input_default for node in self.nodes if (b := get_block(node.block_id)) and b.block_type == BlockType.INPUT and ('name' in node.input_default)])"
    },
    {
      "id": "n20",
      "type": "block",
      "statements": [
        "@computed_field\n@property\ndef output_schema(self) -> dict[str, Any]:\n    return self._generate_schema(AgentOutputBlock.Input, [node.input_default for node in self.nodes if (b := get_block(node.block_id)) and b.block_type == BlockType.OUTPUT and ('name' in node.input_default)])",
        "return self._generate_schema(AgentOutputBlock.Input, [node.input_default for node in self.nodes if (b := get_block(node.block_id)) and b.block_type == BlockType.OUTPUT and ('name' in node.input_default)])"
      ],
      "code": "@computed_field\n@property\ndef output_schema(self) -> dict[str, Any]:\n    return self._generate_schema(AgentOutputBlock.Input, [node.input_default for node in self.nodes if (b := get_block(node.block_id)) and b.block_type == BlockType.OUTPUT and ('name' in node.input_default)])\nreturn self._generate_schema(AgentOutputBlock.Input, [node.input_default for node in self.nodes if (b := get_block(node.block_id)) and b.block_type == BlockType.OUTPUT and ('name' in node.input_default)])"
    },
    {
      "id": "n21",
      "type": "block",
      "statements": [
        "@staticmethod\ndef _generate_schema(type_class: Type[AgentInputBlock.Input] | Type[AgentOutputBlock.Input], data: list[dict]) -> dict[str, Any]:\n    props = []\n    for p in data:\n        try:\n            props.append(type_class(**p))\n        except Exception as e:\n            logger.warning(f'Invalid {type_class}: {p}, {e}')\n    return {'type': 'object', 'properties': {p.name: {'secret': p.secret, 'advanced': p.advanced, 'title': p.title or p.name, **({'description': p.description} if p.description else {}), **({'default': p.value} if p.value is not None else {})} for p in props}, 'required': [p.name for p in props if p.value is None]}",
        "props = []"
      ],
      "code": "@staticmethod\ndef _generate_schema(type_class: Type[AgentInputBlock.Input] | Type[AgentOutputBlock.Input], data: list[dict]) -> dict[str, Any]:\n    props = []\n    for p in data:\n        try:\n            props.append(type_class(**p))\n        except Exception as e:\n            logger.warning(f'Invalid {type_class}: {p}, {e}')\n    return {'type': 'object', 'properties': {p.name: {'secret': p.secret, 'advanced': p.advanced, 'title': p.title or p.name, **({'description': p.description} if p.description else {}), **({'default': p.value} if p.value is not None else {})} for p in props}, 'required': [p.name for p in props if p.value is None]}\nprops = []"
    },
    {
      "id": "n22",
      "type": "block",
      "statements": [
        "p",
        "data"
      ],
      "code": "p\ndata"
    },
    {
      "id": "n23",
      "type": "block",
      "statements": [
        "try:\n    props.append(type_class(**p))\nexcept Exception as e:\n    logger.warning(f'Invalid {type_class}: {p}, {e}')",
        "props.append(type_class())",
        "logger.warning(f'Invalid {type_class}: {p}, {e}')"
      ],
      "code": "try:\n    props.append(type_class(**p))\nexcept Exception as e:\n    logger.warning(f'Invalid {type_class}: {p}, {e}')\nprops.append(type_class())\nlogger.warning(f'Invalid {type_class}: {p}, {e}')"
    },
    {
      "id": "n24",
      "type": "block",
      "statements": [
        "return {'type': 'object', 'properties': {p.name: {'secret': p.secret, 'advanced': p.advanced, 'title': p.title or p.name, **({'description': p.description} if p.description else {}), **({'default': p.value} if p.value is not None else {})} for p in props}, 'required': [p.name for p in props if p.value is None]}"
      ],
      "code": "return {'type': 'object', 'properties': {p.name: {'secret': p.secret, 'advanced': p.advanced, 'title': p.title or p.name, **({'description': p.description} if p.description else {}), **({'default': p.value} if p.value is not None else {})} for p in props}, 'required': [p.name for p in props if p.value is None]}"
    },
    {
      "id": "n25",
      "type": "block",
      "statements": [
        "class GraphModel(Graph):\n    user_id: str\n    nodes: list[NodeModel] = []\n\n    @property\n    def starting_nodes(self) -> list[Node]:\n        outbound_nodes = {link.sink_id for link in self.links}\n        input_nodes = {v.id for v in self.nodes if (b := get_block(v.block_id)) and b.block_type == BlockType.INPUT}\n        return [node for node in self.nodes if node.id not in outbound_nodes or node.id in input_nodes]\n\n    def reassign_ids(self, user_id: str, reassign_graph_id: bool=False):\n        \"\"\"\n        Reassigns all IDs in the graph to new UUIDs.\n        This method can be used before storing a new graph to the database.\n        \"\"\"\n        id_map = {node.id: str(uuid.uuid4()) for node in self.nodes}\n        if reassign_graph_id:\n            self.id = str(uuid.uuid4())\n        for node in self.nodes:\n            node.id = id_map[node.id]\n        for link in self.links:\n            link.source_id = id_map[link.source_id]\n            link.sink_id = id_map[link.sink_id]\n        for node in self.nodes:\n            if node.block_id != AgentExecutorBlock().id:\n                continue\n            node.input_default['user_id'] = user_id\n            node.input_default.setdefault('data', {})\n        self.validate_graph()\n\n    def validate_graph(self, for_run: bool=False):\n\n        def sanitize(name):\n            return name.split('_#_')[0].split('_@_')[0].split('_$_')[0]\n        input_links = defaultdict(list)\n        for link in self.links:\n            input_links[link.sink_id].append(link)\n        for node in self.nodes:\n            block = get_block(node.block_id)\n            if block is None:\n                raise ValueError(f'Invalid block {node.block_id} for node #{node.id}')\n            provided_inputs = set([sanitize(name) for name in node.input_default] + [sanitize(link.sink_name) for link in input_links.get(node.id, [])])\n            for name in block.input_schema.get_required_fields():\n                if name not in provided_inputs and (not (name == 'payload' and block.block_type in (BlockType.WEBHOOK, BlockType.WEBHOOK_MANUAL))) and (for_run or block.block_type == BlockType.INPUT or block.block_type == BlockType.OUTPUT or (block.block_type == BlockType.AGENT)):\n                    raise ValueError(f'Node {block.name} #{node.id} required input missing: `{name}`')\n            input_schema = block.input_schema.model_fields\n            required_fields = block.input_schema.get_required_fields()\n\n            def has_value(name):\n                return node is not None and name in node.input_default and (node.input_default[name] is not None) and (str(node.input_default[name]).strip() != '') or (name in input_schema and input_schema[name].default is not None)\n            for (field_name, field_info) in input_schema.items():\n                json_schema_extra = field_info.json_schema_extra or {}\n                dependencies = json_schema_extra.get('depends_on', [])\n                if not for_run or not dependencies:\n                    continue\n                field_has_value = has_value(field_name)\n                field_is_required = field_name in required_fields\n                missing_deps = [dep for dep in dependencies if not has_value(dep)]\n                if missing_deps and (field_has_value or field_is_required):\n                    raise ValueError(f\"Node {block.name} #{node.id}: Field `{field_name}` requires [{', '.join(missing_deps)}] to be set\")\n        node_map = {v.id: v for v in self.nodes}\n\n        def is_static_output_block(nid: str) -> bool:\n            bid = node_map[nid].block_id\n            b = get_block(bid)\n            return b.static_output if b else False\n        for link in self.links:\n            source = (link.source_id, link.source_name)\n            sink = (link.sink_id, link.sink_name)\n            suffix = f'Link {source} <-> {sink}'\n            for (i, (node_id, name)) in enumerate([source, sink]):\n                node = node_map.get(node_id)\n                if not node:\n                    raise ValueError(f'{suffix}, {node_id} is invalid node id, available nodes: {node_map.keys()}')\n                block = get_block(node.block_id)\n                if not block:\n                    blocks = {v().id: v().name for v in get_blocks().values()}\n                    raise ValueError(f'{suffix}, {node.block_id} is invalid block id, available blocks: {blocks}')\n                sanitized_name = sanitize(name)\n                vals = node.input_default\n                if i == 0:\n                    fields = block.output_schema.get_fields() if block.block_type != BlockType.AGENT else vals.get('output_schema', {}).get('properties', {}).keys()\n                else:\n                    fields = block.input_schema.get_fields() if block.block_type != BlockType.AGENT else vals.get('input_schema', {}).get('properties', {}).keys()\n                if sanitized_name not in fields:\n                    fields_msg = f'Allowed fields: {fields}'\n                    raise ValueError(f'{suffix}, `{name}` invalid, {fields_msg}')\n            if is_static_output_block(link.source_id):\n                link.is_static = True\n\n    @staticmethod\n    def from_db(graph: AgentGraph, for_export: bool=False):\n        return GraphModel(id=graph.id, user_id=graph.userId, version=graph.version, is_active=graph.isActive, is_template=graph.isTemplate, name=graph.name or '', description=graph.description or '', nodes=[NodeModel.from_db(GraphModel._process_node(node, for_export)) for node in graph.AgentNodes or []], links=list({Link.from_db(link) for node in graph.AgentNodes or [] for link in (node.Input or []) + (node.Output or [])}))\n\n    @staticmethod\n    def _process_node(node: AgentNode, for_export: bool) -> AgentNode:\n        if for_export:\n            if node.constantInput:\n                constant_input = json.loads(node.constantInput, target_type=dict[str, Any])\n                constant_input = GraphModel._hide_node_input_credentials(constant_input)\n                node.constantInput = json.dumps(constant_input)\n            node.webhookId = None\n            node.Webhook = None\n        return node\n\n    @staticmethod\n    def _hide_node_input_credentials(input_data: dict[str, Any]) -> dict[str, Any]:\n        sensitive_keys = ['credentials', 'api_key', 'password', 'token', 'secret']\n        result = {}\n        for (key, value) in input_data.items():\n            if isinstance(value, dict):\n                result[key] = GraphModel._hide_node_input_credentials(value)\n            elif isinstance(value, str) and any((sensitive_key in key.lower() for sensitive_key in sensitive_keys)):\n                continue\n            else:\n                result[key] = value\n        return result",
        "user_id: str",
        "nodes: list[NodeModel] = []",
        "@property\ndef starting_nodes(self) -> list[Node]:\n    outbound_nodes = {link.sink_id for link in self.links}\n    input_nodes = {v.id for v in self.nodes if (b := get_block(v.block_id)) and b.block_type == BlockType.INPUT}\n    return [node for node in self.nodes if node.id not in outbound_nodes or node.id in input_nodes]",
        "outbound_nodes = {link.sink_id for link in self.links}",
        "input_nodes = {v.id for v in self.nodes if (b := get_block(v.block_id)) and b.block_type == BlockType.INPUT}",
        "return [node for node in self.nodes if node.id not in outbound_nodes or node.id in input_nodes]"
      ],
      "code": "class GraphModel(Graph):\n    user_id: str\n    nodes: list[NodeModel] = []\n\n    @property\n    def starting_nodes(self) -> list[Node]:\n        outbound_nodes = {link.sink_id for link in self.links}\n        input_nodes = {v.id for v in self.nodes if (b := get_block(v.block_id)) and b.block_type == BlockType.INPUT}\n        return [node for node in self.nodes if node.id not in outbound_nodes or node.id in input_nodes]\n\n    def reassign_ids(self, user_id: str, reassign_graph_id: bool=False):\n        \"\"\"\n        Reassigns all IDs in the graph to new UUIDs.\n        This method can be used before storing a new graph to the database.\n        \"\"\"\n        id_map = {node.id: str(uuid.uuid4()) for node in self.nodes}\n        if reassign_graph_id:\n            self.id = str(uuid.uuid4())\n        for node in self.nodes:\n            node.id = id_map[node.id]\n        for link in self.links:\n            link.source_id = id_map[link.source_id]\n            link.sink_id = id_map[link.sink_id]\n        for node in self.nodes:\n            if node.block_id != AgentExecutorBlock().id:\n                continue\n            node.input_default['user_id'] = user_id\n            node.input_default.setdefault('data', {})\n        self.validate_graph()\n\n    def validate_graph(self, for_run: bool=False):\n\n        def sanitize(name):\n            return name.split('_#_')[0].split('_@_')[0].split('_$_')[0]\n        input_links = defaultdict(list)\n        for link in self.links:\n            input_links[link.sink_id].append(link)\n        for node in self.nodes:\n            block = get_block(node.block_id)\n            if block is None:\n                raise ValueError(f'Invalid block {node.block_id} for node #{node.id}')\n            provided_inputs = set([sanitize(name) for name in node.input_default] + [sanitize(link.sink_name) for link in input_links.get(node.id, [])])\n            for name in block.input_schema.get_required_fields():\n                if name not in provided_inputs and (not (name == 'payload' and block.block_type in (BlockType.WEBHOOK, BlockType.WEBHOOK_MANUAL))) and (for_run or block.block_type == BlockType.INPUT or block.block_type == BlockType.OUTPUT or (block.block_type == BlockType.AGENT)):\n                    raise ValueError(f'Node {block.name} #{node.id} required input missing: `{name}`')\n            input_schema = block.input_schema.model_fields\n            required_fields = block.input_schema.get_required_fields()\n\n            def has_value(name):\n                return node is not None and name in node.input_default and (node.input_default[name] is not None) and (str(node.input_default[name]).strip() != '') or (name in input_schema and input_schema[name].default is not None)\n            for (field_name, field_info) in input_schema.items():\n                json_schema_extra = field_info.json_schema_extra or {}\n                dependencies = json_schema_extra.get('depends_on', [])\n                if not for_run or not dependencies:\n                    continue\n                field_has_value = has_value(field_name)\n                field_is_required = field_name in required_fields\n                missing_deps = [dep for dep in dependencies if not has_value(dep)]\n                if missing_deps and (field_has_value or field_is_required):\n                    raise ValueError(f\"Node {block.name} #{node.id}: Field `{field_name}` requires [{', '.join(missing_deps)}] to be set\")\n        node_map = {v.id: v for v in self.nodes}\n\n        def is_static_output_block(nid: str) -> bool:\n            bid = node_map[nid].block_id\n            b = get_block(bid)\n            return b.static_output if b else False\n        for link in self.links:\n            source = (link.source_id, link.source_name)\n            sink = (link.sink_id, link.sink_name)\n            suffix = f'Link {source} <-> {sink}'\n            for (i, (node_id, name)) in enumerate([source, sink]):\n                node = node_map.get(node_id)\n                if not node:\n                    raise ValueError(f'{suffix}, {node_id} is invalid node id, available nodes: {node_map.keys()}')\n                block = get_block(node.block_id)\n                if not block:\n                    blocks = {v().id: v().name for v in get_blocks().values()}\n                    raise ValueError(f'{suffix}, {node.block_id} is invalid block id, available blocks: {blocks}')\n                sanitized_name = sanitize(name)\n                vals = node.input_default\n                if i == 0:\n                    fields = block.output_schema.get_fields() if block.block_type != BlockType.AGENT else vals.get('output_schema', {}).get('properties', {}).keys()\n                else:\n                    fields = block.input_schema.get_fields() if block.block_type != BlockType.AGENT else vals.get('input_schema', {}).get('properties', {}).keys()\n                if sanitized_name not in fields:\n                    fields_msg = f'Allowed fields: {fields}'\n                    raise ValueError(f'{suffix}, `{name}` invalid, {fields_msg}')\n            if is_static_output_block(link.source_id):\n                link.is_static = True\n\n    @staticmethod\n    def from_db(graph: AgentGraph, for_export: bool=False):\n        return GraphModel(id=graph.id, user_id=graph.userId, version=graph.version, is_active=graph.isActive, is_template=graph.isTemplate, name=graph.name or '', description=graph.description or '', nodes=[NodeModel.from_db(GraphModel._process_node(node, for_export)) for node in graph.AgentNodes or []], links=list({Link.from_db(link) for node in graph.AgentNodes or [] for link in (node.Input or []) + (node.Output or [])}))\n\n    @staticmethod\n    def _process_node(node: AgentNode, for_export: bool) -> AgentNode:\n        if for_export:\n            if node.constantInput:\n                constant_input = json.loads(node.constantInput, target_type=dict[str, Any])\n                constant_input = GraphModel._hide_node_input_credentials(constant_input)\n                node.constantInput = json.dumps(constant_input)\n            node.webhookId = None\n            node.Webhook = None\n        return node\n\n    @staticmethod\n    def _hide_node_input_credentials(input_data: dict[str, Any]) -> dict[str, Any]:\n        sensitive_keys = ['credentials', 'api_key', 'password', 'token', 'secret']\n        result = {}\n        for (key, value) in input_data.items():\n            if isinstance(value, dict):\n                result[key] = GraphModel._hide_node_input_credentials(value)\n            elif isinstance(value, str) and any((sensitive_key in key.lower() for sensitive_key in sensitive_keys)):\n                continue\n            else:\n                result[key] = value\n        return result\nuser_id: str\nnodes: list[NodeModel] = []\n@property\ndef starting_nodes(self) -> list[Node]:\n    outbound_nodes = {link.sink_id for link in self.links}\n    input_nodes = {v.id for v in self.nodes if (b := get_block(v.block_id)) and b.block_type == BlockType.INPUT}\n    return [node for node in self.nodes if node.id not in outbound_nodes or node.id in input_nodes]\noutbound_nodes = {link.sink_id for link in self.links}\ninput_nodes = {v.id for v in self.nodes if (b := get_block(v.block_id)) and b.block_type == BlockType.INPUT}\nreturn [node for node in self.nodes if node.id not in outbound_nodes or node.id in input_nodes]"
    },
    {
      "id": "n26",
      "type": "block",
      "statements": [
        "def reassign_ids(self, user_id: str, reassign_graph_id: bool=False):\n    \"\"\"\n        Reassigns all IDs in the graph to new UUIDs.\n        This method can be used before storing a new graph to the database.\n        \"\"\"\n    id_map = {node.id: str(uuid.uuid4()) for node in self.nodes}\n    if reassign_graph_id:\n        self.id = str(uuid.uuid4())\n    for node in self.nodes:\n        node.id = id_map[node.id]\n    for link in self.links:\n        link.source_id = id_map[link.source_id]\n        link.sink_id = id_map[link.sink_id]\n    for node in self.nodes:\n        if node.block_id != AgentExecutorBlock().id:\n            continue\n        node.input_default['user_id'] = user_id\n        node.input_default.setdefault('data', {})\n    self.validate_graph()",
        "'\\n        Reassigns all IDs in the graph to new UUIDs.\\n        This method can be used before storing a new graph to the database.\\n        '",
        "id_map = {node.id: str(uuid.uuid4()) for node in self.nodes}",
        "reassign_graph_id"
      ],
      "code": "def reassign_ids(self, user_id: str, reassign_graph_id: bool=False):\n    \"\"\"\n        Reassigns all IDs in the graph to new UUIDs.\n        This method can be used before storing a new graph to the database.\n        \"\"\"\n    id_map = {node.id: str(uuid.uuid4()) for node in self.nodes}\n    if reassign_graph_id:\n        self.id = str(uuid.uuid4())\n    for node in self.nodes:\n        node.id = id_map[node.id]\n    for link in self.links:\n        link.source_id = id_map[link.source_id]\n        link.sink_id = id_map[link.sink_id]\n    for node in self.nodes:\n        if node.block_id != AgentExecutorBlock().id:\n            continue\n        node.input_default['user_id'] = user_id\n        node.input_default.setdefault('data', {})\n    self.validate_graph()\n'\\n        Reassigns all IDs in the graph to new UUIDs.\\n        This method can be used before storing a new graph to the database.\\n        '\nid_map = {node.id: str(uuid.uuid4()) for node in self.nodes}\nreassign_graph_id"
    },
    {
      "id": "n27",
      "type": "block",
      "statements": [
        "self.id = str(uuid.uuid4())"
      ],
      "code": "self.id = str(uuid.uuid4())"
    },
    {
      "id": "n28",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n29",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n30",
      "type": "block",
      "statements": [
        "node",
        "self.nodes"
      ],
      "code": "node\nself.nodes"
    },
    {
      "id": "n31",
      "type": "block",
      "statements": [
        "node.id = id_map[node.id]"
      ],
      "code": "node.id = id_map[node.id]"
    },
    {
      "id": "n32",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n33",
      "type": "block",
      "statements": [
        "link",
        "self.links"
      ],
      "code": "link\nself.links"
    },
    {
      "id": "n34",
      "type": "block",
      "statements": [
        "link.source_id = id_map[link.source_id]",
        "link.sink_id = id_map[link.sink_id]"
      ],
      "code": "link.source_id = id_map[link.source_id]\nlink.sink_id = id_map[link.sink_id]"
    },
    {
      "id": "n35",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n36",
      "type": "block",
      "statements": [
        "node",
        "self.nodes"
      ],
      "code": "node\nself.nodes"
    },
    {
      "id": "n37",
      "type": "block",
      "statements": [
        "node.block_id NotEq AgentExecutorBlock().id"
      ],
      "code": "node.block_id NotEq AgentExecutorBlock().id"
    },
    {
      "id": "n38",
      "type": "block",
      "statements": [
        "self.validate_graph()",
        "def validate_graph(self, for_run: bool=False):\n\n    def sanitize(name):\n        return name.split('_#_')[0].split('_@_')[0].split('_$_')[0]\n    input_links = defaultdict(list)\n    for link in self.links:\n        input_links[link.sink_id].append(link)\n    for node in self.nodes:\n        block = get_block(node.block_id)\n        if block is None:\n            raise ValueError(f'Invalid block {node.block_id} for node #{node.id}')\n        provided_inputs = set([sanitize(name) for name in node.input_default] + [sanitize(link.sink_name) for link in input_links.get(node.id, [])])\n        for name in block.input_schema.get_required_fields():\n            if name not in provided_inputs and (not (name == 'payload' and block.block_type in (BlockType.WEBHOOK, BlockType.WEBHOOK_MANUAL))) and (for_run or block.block_type == BlockType.INPUT or block.block_type == BlockType.OUTPUT or (block.block_type == BlockType.AGENT)):\n                raise ValueError(f'Node {block.name} #{node.id} required input missing: `{name}`')\n        input_schema = block.input_schema.model_fields\n        required_fields = block.input_schema.get_required_fields()\n\n        def has_value(name):\n            return node is not None and name in node.input_default and (node.input_default[name] is not None) and (str(node.input_default[name]).strip() != '') or (name in input_schema and input_schema[name].default is not None)\n        for (field_name, field_info) in input_schema.items():\n            json_schema_extra = field_info.json_schema_extra or {}\n            dependencies = json_schema_extra.get('depends_on', [])\n            if not for_run or not dependencies:\n                continue\n            field_has_value = has_value(field_name)\n            field_is_required = field_name in required_fields\n            missing_deps = [dep for dep in dependencies if not has_value(dep)]\n            if missing_deps and (field_has_value or field_is_required):\n                raise ValueError(f\"Node {block.name} #{node.id}: Field `{field_name}` requires [{', '.join(missing_deps)}] to be set\")\n    node_map = {v.id: v for v in self.nodes}\n\n    def is_static_output_block(nid: str) -> bool:\n        bid = node_map[nid].block_id\n        b = get_block(bid)\n        return b.static_output if b else False\n    for link in self.links:\n        source = (link.source_id, link.source_name)\n        sink = (link.sink_id, link.sink_name)\n        suffix = f'Link {source} <-> {sink}'\n        for (i, (node_id, name)) in enumerate([source, sink]):\n            node = node_map.get(node_id)\n            if not node:\n                raise ValueError(f'{suffix}, {node_id} is invalid node id, available nodes: {node_map.keys()}')\n            block = get_block(node.block_id)\n            if not block:\n                blocks = {v().id: v().name for v in get_blocks().values()}\n                raise ValueError(f'{suffix}, {node.block_id} is invalid block id, available blocks: {blocks}')\n            sanitized_name = sanitize(name)\n            vals = node.input_default\n            if i == 0:\n                fields = block.output_schema.get_fields() if block.block_type != BlockType.AGENT else vals.get('output_schema', {}).get('properties', {}).keys()\n            else:\n                fields = block.input_schema.get_fields() if block.block_type != BlockType.AGENT else vals.get('input_schema', {}).get('properties', {}).keys()\n            if sanitized_name not in fields:\n                fields_msg = f'Allowed fields: {fields}'\n                raise ValueError(f'{suffix}, `{name}` invalid, {fields_msg}')\n        if is_static_output_block(link.source_id):\n            link.is_static = True",
        "def sanitize(name):\n    return name.split('_#_')[0].split('_@_')[0].split('_$_')[0]",
        "return name.split('_#_')[0].split('_@_')[0].split('_$_')[0]"
      ],
      "code": "self.validate_graph()\ndef validate_graph(self, for_run: bool=False):\n\n    def sanitize(name):\n        return name.split('_#_')[0].split('_@_')[0].split('_$_')[0]\n    input_links = defaultdict(list)\n    for link in self.links:\n        input_links[link.sink_id].append(link)\n    for node in self.nodes:\n        block = get_block(node.block_id)\n        if block is None:\n            raise ValueError(f'Invalid block {node.block_id} for node #{node.id}')\n        provided_inputs = set([sanitize(name) for name in node.input_default] + [sanitize(link.sink_name) for link in input_links.get(node.id, [])])\n        for name in block.input_schema.get_required_fields():\n            if name not in provided_inputs and (not (name == 'payload' and block.block_type in (BlockType.WEBHOOK, BlockType.WEBHOOK_MANUAL))) and (for_run or block.block_type == BlockType.INPUT or block.block_type == BlockType.OUTPUT or (block.block_type == BlockType.AGENT)):\n                raise ValueError(f'Node {block.name} #{node.id} required input missing: `{name}`')\n        input_schema = block.input_schema.model_fields\n        required_fields = block.input_schema.get_required_fields()\n\n        def has_value(name):\n            return node is not None and name in node.input_default and (node.input_default[name] is not None) and (str(node.input_default[name]).strip() != '') or (name in input_schema and input_schema[name].default is not None)\n        for (field_name, field_info) in input_schema.items():\n            json_schema_extra = field_info.json_schema_extra or {}\n            dependencies = json_schema_extra.get('depends_on', [])\n            if not for_run or not dependencies:\n                continue\n            field_has_value = has_value(field_name)\n            field_is_required = field_name in required_fields\n            missing_deps = [dep for dep in dependencies if not has_value(dep)]\n            if missing_deps and (field_has_value or field_is_required):\n                raise ValueError(f\"Node {block.name} #{node.id}: Field `{field_name}` requires [{', '.join(missing_deps)}] to be set\")\n    node_map = {v.id: v for v in self.nodes}\n\n    def is_static_output_block(nid: str) -> bool:\n        bid = node_map[nid].block_id\n        b = get_block(bid)\n        return b.static_output if b else False\n    for link in self.links:\n        source = (link.source_id, link.source_name)\n        sink = (link.sink_id, link.sink_name)\n        suffix = f'Link {source} <-> {sink}'\n        for (i, (node_id, name)) in enumerate([source, sink]):\n            node = node_map.get(node_id)\n            if not node:\n                raise ValueError(f'{suffix}, {node_id} is invalid node id, available nodes: {node_map.keys()}')\n            block = get_block(node.block_id)\n            if not block:\n                blocks = {v().id: v().name for v in get_blocks().values()}\n                raise ValueError(f'{suffix}, {node.block_id} is invalid block id, available blocks: {blocks}')\n            sanitized_name = sanitize(name)\n            vals = node.input_default\n            if i == 0:\n                fields = block.output_schema.get_fields() if block.block_type != BlockType.AGENT else vals.get('output_schema', {}).get('properties', {}).keys()\n            else:\n                fields = block.input_schema.get_fields() if block.block_type != BlockType.AGENT else vals.get('input_schema', {}).get('properties', {}).keys()\n            if sanitized_name not in fields:\n                fields_msg = f'Allowed fields: {fields}'\n                raise ValueError(f'{suffix}, `{name}` invalid, {fields_msg}')\n        if is_static_output_block(link.source_id):\n            link.is_static = True\ndef sanitize(name):\n    return name.split('_#_')[0].split('_@_')[0].split('_$_')[0]\nreturn name.split('_#_')[0].split('_@_')[0].split('_$_')[0]"
    },
    {
      "id": "n39",
      "type": "block",
      "statements": [
        "continue"
      ],
      "code": "continue"
    },
    {
      "id": "n40",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n41",
      "type": "block",
      "statements": [
        "node.input_default['user_id'] = user_id",
        "node.input_default.setdefault('data', {})"
      ],
      "code": "node.input_default['user_id'] = user_id\nnode.input_default.setdefault('data', {})"
    },
    {
      "id": "n42",
      "type": "block",
      "statements": [
        "input_links = defaultdict(list)"
      ],
      "code": "input_links = defaultdict(list)"
    },
    {
      "id": "n43",
      "type": "block",
      "statements": [
        "link",
        "self.links"
      ],
      "code": "link\nself.links"
    },
    {
      "id": "n44",
      "type": "block",
      "statements": [
        "input_links[link.sink_id].append(link)"
      ],
      "code": "input_links[link.sink_id].append(link)"
    },
    {
      "id": "n45",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n46",
      "type": "block",
      "statements": [
        "node",
        "self.nodes"
      ],
      "code": "node\nself.nodes"
    },
    {
      "id": "n47",
      "type": "block",
      "statements": [
        "block = get_block(node.block_id)",
        "block Is None"
      ],
      "code": "block = get_block(node.block_id)\nblock Is None"
    },
    {
      "id": "n48",
      "type": "block",
      "statements": [
        "node_map = {v.id: v for v in self.nodes}",
        "def is_static_output_block(nid: str) -> bool:\n    bid = node_map[nid].block_id\n    b = get_block(bid)\n    return b.static_output if b else False",
        "bid = node_map[nid].block_id",
        "b = get_block(bid)",
        "return b.static_output if b else False"
      ],
      "code": "node_map = {v.id: v for v in self.nodes}\ndef is_static_output_block(nid: str) -> bool:\n    bid = node_map[nid].block_id\n    b = get_block(bid)\n    return b.static_output if b else False\nbid = node_map[nid].block_id\nb = get_block(bid)\nreturn b.static_output if b else False"
    },
    {
      "id": "n49",
      "type": "block",
      "statements": [
        "raise ValueError(f'Invalid block {node.block_id} for node #{node.id}')"
      ],
      "code": "raise ValueError(f'Invalid block {node.block_id} for node #{node.id}')"
    },
    {
      "id": "n50",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n51",
      "type": "block",
      "statements": [
        "provided_inputs = set([sanitize(name) for name in node.input_default] + [sanitize(link.sink_name) for link in input_links.get(node.id, [])])"
      ],
      "code": "provided_inputs = set([sanitize(name) for name in node.input_default] + [sanitize(link.sink_name) for link in input_links.get(node.id, [])])"
    },
    {
      "id": "n52",
      "type": "block",
      "statements": [
        "name",
        "block.input_schema.get_required_fields()"
      ],
      "code": "name\nblock.input_schema.get_required_fields()"
    },
    {
      "id": "n53",
      "type": "block",
      "statements": [
        "name not in provided_inputs and (not (name == 'payload' and block.block_type in (BlockType.WEBHOOK, BlockType.WEBHOOK_MANUAL))) and (for_run or block.block_type == BlockType.INPUT or block.block_type == BlockType.OUTPUT or (block.block_type == BlockType.AGENT))"
      ],
      "code": "name not in provided_inputs and (not (name == 'payload' and block.block_type in (BlockType.WEBHOOK, BlockType.WEBHOOK_MANUAL))) and (for_run or block.block_type == BlockType.INPUT or block.block_type == BlockType.OUTPUT or (block.block_type == BlockType.AGENT))"
    },
    {
      "id": "n54",
      "type": "block",
      "statements": [
        "input_schema = block.input_schema.model_fields",
        "required_fields = block.input_schema.get_required_fields()",
        "def has_value(name):\n    return node is not None and name in node.input_default and (node.input_default[name] is not None) and (str(node.input_default[name]).strip() != '') or (name in input_schema and input_schema[name].default is not None)",
        "return node is not None and name in node.input_default and (node.input_default[name] is not None) and (str(node.input_default[name]).strip() != '') or (name in input_schema and input_schema[name].default is not None)"
      ],
      "code": "input_schema = block.input_schema.model_fields\nrequired_fields = block.input_schema.get_required_fields()\ndef has_value(name):\n    return node is not None and name in node.input_default and (node.input_default[name] is not None) and (str(node.input_default[name]).strip() != '') or (name in input_schema and input_schema[name].default is not None)\nreturn node is not None and name in node.input_default and (node.input_default[name] is not None) and (str(node.input_default[name]).strip() != '') or (name in input_schema and input_schema[name].default is not None)"
    },
    {
      "id": "n55",
      "type": "block",
      "statements": [
        "raise ValueError(f'Node {block.name} #{node.id} required input missing: `{name}`')"
      ],
      "code": "raise ValueError(f'Node {block.name} #{node.id} required input missing: `{name}`')"
    },
    {
      "id": "n56",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n57",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n58",
      "type": "block",
      "statements": [
        "(field_name, field_info)",
        "input_schema.items()"
      ],
      "code": "(field_name, field_info)\ninput_schema.items()"
    },
    {
      "id": "n59",
      "type": "block",
      "statements": [
        "json_schema_extra = field_info.json_schema_extra or {}",
        "dependencies = json_schema_extra.get('depends_on', [])",
        "not for_run or not dependencies"
      ],
      "code": "json_schema_extra = field_info.json_schema_extra or {}\ndependencies = json_schema_extra.get('depends_on', [])\nnot for_run or not dependencies"
    },
    {
      "id": "n60",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n61",
      "type": "block",
      "statements": [
        "continue"
      ],
      "code": "continue"
    },
    {
      "id": "n62",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n63",
      "type": "block",
      "statements": [
        "field_has_value = has_value(field_name)",
        "field_is_required = field_name in required_fields",
        "missing_deps = [dep for dep in dependencies if not has_value(dep)]",
        "missing_deps and (field_has_value or field_is_required)"
      ],
      "code": "field_has_value = has_value(field_name)\nfield_is_required = field_name in required_fields\nmissing_deps = [dep for dep in dependencies if not has_value(dep)]\nmissing_deps and (field_has_value or field_is_required)"
    },
    {
      "id": "n64",
      "type": "block",
      "statements": [
        "raise ValueError(f\"Node {block.name} #{node.id}: Field `{field_name}` requires [{', '.join(missing_deps)}] to be set\")"
      ],
      "code": "raise ValueError(f\"Node {block.name} #{node.id}: Field `{field_name}` requires [{', '.join(missing_deps)}] to be set\")"
    },
    {
      "id": "n65",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n66",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n67",
      "type": "block",
      "statements": [
        "link",
        "self.links"
      ],
      "code": "link\nself.links"
    },
    {
      "id": "n68",
      "type": "block",
      "statements": [
        "source = (link.source_id, link.source_name)",
        "sink = (link.sink_id, link.sink_name)",
        "suffix = f'Link {source} <-> {sink}'"
      ],
      "code": "source = (link.source_id, link.source_name)\nsink = (link.sink_id, link.sink_name)\nsuffix = f'Link {source} <-> {sink}'"
    },
    {
      "id": "n69",
      "type": "block",
      "statements": [
        "@staticmethod\ndef from_db(graph: AgentGraph, for_export: bool=False):\n    return GraphModel(id=graph.id, user_id=graph.userId, version=graph.version, is_active=graph.isActive, is_template=graph.isTemplate, name=graph.name or '', description=graph.description or '', nodes=[NodeModel.from_db(GraphModel._process_node(node, for_export)) for node in graph.AgentNodes or []], links=list({Link.from_db(link) for node in graph.AgentNodes or [] for link in (node.Input or []) + (node.Output or [])}))",
        "return GraphModel(id=graph.id, user_id=graph.userId, version=graph.version, is_active=graph.isActive, is_template=graph.isTemplate, name=graph.name or '', description=graph.description or '', nodes=[NodeModel.from_db(GraphModel._process_node(node, for_export)) for node in graph.AgentNodes or []], links=list({Link.from_db(link) for node in graph.AgentNodes or [] for link in (node.Input or []) + (node.Output or [])}))"
      ],
      "code": "@staticmethod\ndef from_db(graph: AgentGraph, for_export: bool=False):\n    return GraphModel(id=graph.id, user_id=graph.userId, version=graph.version, is_active=graph.isActive, is_template=graph.isTemplate, name=graph.name or '', description=graph.description or '', nodes=[NodeModel.from_db(GraphModel._process_node(node, for_export)) for node in graph.AgentNodes or []], links=list({Link.from_db(link) for node in graph.AgentNodes or [] for link in (node.Input or []) + (node.Output or [])}))\nreturn GraphModel(id=graph.id, user_id=graph.userId, version=graph.version, is_active=graph.isActive, is_template=graph.isTemplate, name=graph.name or '', description=graph.description or '', nodes=[NodeModel.from_db(GraphModel._process_node(node, for_export)) for node in graph.AgentNodes or []], links=list({Link.from_db(link) for node in graph.AgentNodes or [] for link in (node.Input or []) + (node.Output or [])}))"
    },
    {
      "id": "n70",
      "type": "block",
      "statements": [
        "(i, (node_id, name))",
        "enumerate([source, sink])"
      ],
      "code": "(i, (node_id, name))\nenumerate([source, sink])"
    },
    {
      "id": "n71",
      "type": "block",
      "statements": [
        "node = node_map.get(node_id)",
        "not node"
      ],
      "code": "node = node_map.get(node_id)\nnot node"
    },
    {
      "id": "n72",
      "type": "block",
      "statements": [
        "is_static_output_block(link.source_id)"
      ],
      "code": "is_static_output_block(link.source_id)"
    },
    {
      "id": "n73",
      "type": "block",
      "statements": [
        "raise ValueError(f'{suffix}, {node_id} is invalid node id, available nodes: {node_map.keys()}')"
      ],
      "code": "raise ValueError(f'{suffix}, {node_id} is invalid node id, available nodes: {node_map.keys()}')"
    },
    {
      "id": "n74",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n75",
      "type": "block",
      "statements": [
        "block = get_block(node.block_id)",
        "not block"
      ],
      "code": "block = get_block(node.block_id)\nnot block"
    },
    {
      "id": "n76",
      "type": "block",
      "statements": [
        "blocks = {v().id: v().name for v in get_blocks().values()}",
        "raise ValueError(f'{suffix}, {node.block_id} is invalid block id, available blocks: {blocks}')"
      ],
      "code": "blocks = {v().id: v().name for v in get_blocks().values()}\nraise ValueError(f'{suffix}, {node.block_id} is invalid block id, available blocks: {blocks}')"
    },
    {
      "id": "n77",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n78",
      "type": "block",
      "statements": [
        "sanitized_name = sanitize(name)",
        "vals = node.input_default",
        "i Eq 0"
      ],
      "code": "sanitized_name = sanitize(name)\nvals = node.input_default\ni Eq 0"
    },
    {
      "id": "n79",
      "type": "block",
      "statements": [
        "fields = block.output_schema.get_fields() if block.block_type != BlockType.AGENT else vals.get('output_schema', {}).get('properties', {}).keys()"
      ],
      "code": "fields = block.output_schema.get_fields() if block.block_type != BlockType.AGENT else vals.get('output_schema', {}).get('properties', {}).keys()"
    },
    {
      "id": "n80",
      "type": "block",
      "statements": [
        "fields = block.input_schema.get_fields() if block.block_type != BlockType.AGENT else vals.get('input_schema', {}).get('properties', {}).keys()"
      ],
      "code": "fields = block.input_schema.get_fields() if block.block_type != BlockType.AGENT else vals.get('input_schema', {}).get('properties', {}).keys()"
    },
    {
      "id": "n81",
      "type": "block",
      "statements": [
        "sanitized_name NotIn fields"
      ],
      "code": "sanitized_name NotIn fields"
    },
    {
      "id": "n82",
      "type": "block",
      "statements": [
        "fields_msg = f'Allowed fields: {fields}'",
        "raise ValueError(f'{suffix}, `{name}` invalid, {fields_msg}')"
      ],
      "code": "fields_msg = f'Allowed fields: {fields}'\nraise ValueError(f'{suffix}, `{name}` invalid, {fields_msg}')"
    },
    {
      "id": "n83",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n84",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n85",
      "type": "block",
      "statements": [
        "link.is_static = True"
      ],
      "code": "link.is_static = True"
    },
    {
      "id": "n86",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n87",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n88",
      "type": "block",
      "statements": [
        "@staticmethod\ndef _process_node(node: AgentNode, for_export: bool) -> AgentNode:\n    if for_export:\n        if node.constantInput:\n            constant_input = json.loads(node.constantInput, target_type=dict[str, Any])\n            constant_input = GraphModel._hide_node_input_credentials(constant_input)\n            node.constantInput = json.dumps(constant_input)\n        node.webhookId = None\n        node.Webhook = None\n    return node",
        "for_export"
      ],
      "code": "@staticmethod\ndef _process_node(node: AgentNode, for_export: bool) -> AgentNode:\n    if for_export:\n        if node.constantInput:\n            constant_input = json.loads(node.constantInput, target_type=dict[str, Any])\n            constant_input = GraphModel._hide_node_input_credentials(constant_input)\n            node.constantInput = json.dumps(constant_input)\n        node.webhookId = None\n        node.Webhook = None\n    return node\nfor_export"
    },
    {
      "id": "n89",
      "type": "block",
      "statements": [
        "node.constantInput"
      ],
      "code": "node.constantInput"
    },
    {
      "id": "n90",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n91",
      "type": "block",
      "statements": [
        "return node"
      ],
      "code": "return node"
    },
    {
      "id": "n92",
      "type": "block",
      "statements": [
        "constant_input = json.loads(node.constantInput, target_type=dict[str, Any])",
        "constant_input = GraphModel._hide_node_input_credentials(constant_input)",
        "node.constantInput = json.dumps(constant_input)"
      ],
      "code": "constant_input = json.loads(node.constantInput, target_type=dict[str, Any])\nconstant_input = GraphModel._hide_node_input_credentials(constant_input)\nnode.constantInput = json.dumps(constant_input)"
    },
    {
      "id": "n93",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n94",
      "type": "block",
      "statements": [
        "node.webhookId = None",
        "node.Webhook = None"
      ],
      "code": "node.webhookId = None\nnode.Webhook = None"
    },
    {
      "id": "n95",
      "type": "block",
      "statements": [
        "@staticmethod\ndef _hide_node_input_credentials(input_data: dict[str, Any]) -> dict[str, Any]:\n    sensitive_keys = ['credentials', 'api_key', 'password', 'token', 'secret']\n    result = {}\n    for (key, value) in input_data.items():\n        if isinstance(value, dict):\n            result[key] = GraphModel._hide_node_input_credentials(value)\n        elif isinstance(value, str) and any((sensitive_key in key.lower() for sensitive_key in sensitive_keys)):\n            continue\n        else:\n            result[key] = value\n    return result",
        "sensitive_keys = ['credentials', 'api_key', 'password', 'token', 'secret']",
        "result = {}"
      ],
      "code": "@staticmethod\ndef _hide_node_input_credentials(input_data: dict[str, Any]) -> dict[str, Any]:\n    sensitive_keys = ['credentials', 'api_key', 'password', 'token', 'secret']\n    result = {}\n    for (key, value) in input_data.items():\n        if isinstance(value, dict):\n            result[key] = GraphModel._hide_node_input_credentials(value)\n        elif isinstance(value, str) and any((sensitive_key in key.lower() for sensitive_key in sensitive_keys)):\n            continue\n        else:\n            result[key] = value\n    return result\nsensitive_keys = ['credentials', 'api_key', 'password', 'token', 'secret']\nresult = {}"
    },
    {
      "id": "n96",
      "type": "block",
      "statements": [
        "(key, value)",
        "input_data.items()"
      ],
      "code": "(key, value)\ninput_data.items()"
    },
    {
      "id": "n97",
      "type": "block",
      "statements": [
        "isinstance(value, dict)"
      ],
      "code": "isinstance(value, dict)"
    },
    {
      "id": "n98",
      "type": "block",
      "statements": [
        "return result"
      ],
      "code": "return result"
    },
    {
      "id": "n99",
      "type": "block",
      "statements": [
        "result[key] = GraphModel._hide_node_input_credentials(value)"
      ],
      "code": "result[key] = GraphModel._hide_node_input_credentials(value)"
    },
    {
      "id": "n100",
      "type": "block",
      "statements": [
        "isinstance(value, str) and any((sensitive_key in key.lower() for sensitive_key in sensitive_keys))"
      ],
      "code": "isinstance(value, str) and any((sensitive_key in key.lower() for sensitive_key in sensitive_keys))"
    },
    {
      "id": "n101",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n102",
      "type": "block",
      "statements": [
        "continue"
      ],
      "code": "continue"
    },
    {
      "id": "n103",
      "type": "block",
      "statements": [
        "result[key] = value"
      ],
      "code": "result[key] = value"
    },
    {
      "id": "n104",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n105",
      "type": "block",
      "statements": [
        "async def get_node(node_id: str) -> NodeModel:\n    node = await AgentNode.prisma().find_unique_or_raise(where={'id': node_id}, include=AGENT_NODE_INCLUDE)\n    return NodeModel.from_db(node)",
        "node = await AgentNode.prisma().find_unique_or_raise(where={'id': node_id}, include=AGENT_NODE_INCLUDE)",
        "return NodeModel.from_db(node)"
      ],
      "code": "async def get_node(node_id: str) -> NodeModel:\n    node = await AgentNode.prisma().find_unique_or_raise(where={'id': node_id}, include=AGENT_NODE_INCLUDE)\n    return NodeModel.from_db(node)\nnode = await AgentNode.prisma().find_unique_or_raise(where={'id': node_id}, include=AGENT_NODE_INCLUDE)\nreturn NodeModel.from_db(node)"
    },
    {
      "id": "n106",
      "type": "block",
      "statements": [
        "async def set_node_webhook(node_id: str, webhook_id: str | None) -> NodeModel:\n    node = await AgentNode.prisma().update(where={'id': node_id}, data={'Webhook': {'connect': {'id': webhook_id}}} if webhook_id else {'Webhook': {'disconnect': True}}, include=AGENT_NODE_INCLUDE)\n    if not node:\n        raise ValueError(f'Node #{node_id} not found')\n    return NodeModel.from_db(node)",
        "node = await AgentNode.prisma().update(where={'id': node_id}, data={'Webhook': {'connect': {'id': webhook_id}}} if webhook_id else {'Webhook': {'disconnect': True}}, include=AGENT_NODE_INCLUDE)",
        "not node"
      ],
      "code": "async def set_node_webhook(node_id: str, webhook_id: str | None) -> NodeModel:\n    node = await AgentNode.prisma().update(where={'id': node_id}, data={'Webhook': {'connect': {'id': webhook_id}}} if webhook_id else {'Webhook': {'disconnect': True}}, include=AGENT_NODE_INCLUDE)\n    if not node:\n        raise ValueError(f'Node #{node_id} not found')\n    return NodeModel.from_db(node)\nnode = await AgentNode.prisma().update(where={'id': node_id}, data={'Webhook': {'connect': {'id': webhook_id}}} if webhook_id else {'Webhook': {'disconnect': True}}, include=AGENT_NODE_INCLUDE)\nnot node"
    },
    {
      "id": "n107",
      "type": "block",
      "statements": [
        "raise ValueError(f'Node #{node_id} not found')"
      ],
      "code": "raise ValueError(f'Node #{node_id} not found')"
    },
    {
      "id": "n108",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n109",
      "type": "block",
      "statements": [
        "return NodeModel.from_db(node)"
      ],
      "code": "return NodeModel.from_db(node)"
    },
    {
      "id": "n110",
      "type": "block",
      "statements": [
        "async def get_graphs(user_id: str, filter_by: Literal['active', 'template'] | None='active') -> list[GraphModel]:\n    \"\"\"\n    Retrieves graph metadata objects.\n    Default behaviour is to get all currently active graphs.\n\n    Args:\n        filter_by: An optional filter to either select templates or active graphs.\n        user_id: The ID of the user that owns the graph.\n\n    Returns:\n        list[GraphModel]: A list of objects representing the retrieved graphs.\n    \"\"\"\n    where_clause: AgentGraphWhereInput = {'userId': user_id}\n    if filter_by == 'active':\n        where_clause['isActive'] = True\n    elif filter_by == 'template':\n        where_clause['isTemplate'] = True\n    graphs = await AgentGraph.prisma().find_many(where=where_clause, distinct=['id'], order={'version': 'desc'}, include=AGENT_GRAPH_INCLUDE)\n    graph_models = []\n    for graph in graphs:\n        try:\n            graph_models.append(GraphModel.from_db(graph))\n        except Exception as e:\n            logger.error(f'Error processing graph {graph.id}: {e}')\n            continue\n    return graph_models",
        "'\\n    Retrieves graph metadata objects.\\n    Default behaviour is to get all currently active graphs.\\n\\n    Args:\\n        filter_by: An optional filter to either select templates or active graphs.\\n        user_id: The ID of the user that owns the graph.\\n\\n    Returns:\\n        list[GraphModel]: A list of objects representing the retrieved graphs.\\n    '",
        "where_clause: AgentGraphWhereInput = {'userId': user_id}",
        "filter_by Eq 'active'"
      ],
      "code": "async def get_graphs(user_id: str, filter_by: Literal['active', 'template'] | None='active') -> list[GraphModel]:\n    \"\"\"\n    Retrieves graph metadata objects.\n    Default behaviour is to get all currently active graphs.\n\n    Args:\n        filter_by: An optional filter to either select templates or active graphs.\n        user_id: The ID of the user that owns the graph.\n\n    Returns:\n        list[GraphModel]: A list of objects representing the retrieved graphs.\n    \"\"\"\n    where_clause: AgentGraphWhereInput = {'userId': user_id}\n    if filter_by == 'active':\n        where_clause['isActive'] = True\n    elif filter_by == 'template':\n        where_clause['isTemplate'] = True\n    graphs = await AgentGraph.prisma().find_many(where=where_clause, distinct=['id'], order={'version': 'desc'}, include=AGENT_GRAPH_INCLUDE)\n    graph_models = []\n    for graph in graphs:\n        try:\n            graph_models.append(GraphModel.from_db(graph))\n        except Exception as e:\n            logger.error(f'Error processing graph {graph.id}: {e}')\n            continue\n    return graph_models\n'\\n    Retrieves graph metadata objects.\\n    Default behaviour is to get all currently active graphs.\\n\\n    Args:\\n        filter_by: An optional filter to either select templates or active graphs.\\n        user_id: The ID of the user that owns the graph.\\n\\n    Returns:\\n        list[GraphModel]: A list of objects representing the retrieved graphs.\\n    '\nwhere_clause: AgentGraphWhereInput = {'userId': user_id}\nfilter_by Eq 'active'"
    },
    {
      "id": "n111",
      "type": "block",
      "statements": [
        "where_clause['isActive'] = True"
      ],
      "code": "where_clause['isActive'] = True"
    },
    {
      "id": "n112",
      "type": "block",
      "statements": [
        "filter_by Eq 'template'"
      ],
      "code": "filter_by Eq 'template'"
    },
    {
      "id": "n113",
      "type": "block",
      "statements": [
        "graphs = await AgentGraph.prisma().find_many(where=where_clause, distinct=['id'], order={'version': 'desc'}, include=AGENT_GRAPH_INCLUDE)",
        "graph_models = []"
      ],
      "code": "graphs = await AgentGraph.prisma().find_many(where=where_clause, distinct=['id'], order={'version': 'desc'}, include=AGENT_GRAPH_INCLUDE)\ngraph_models = []"
    },
    {
      "id": "n114",
      "type": "block",
      "statements": [
        "where_clause['isTemplate'] = True"
      ],
      "code": "where_clause['isTemplate'] = True"
    },
    {
      "id": "n115",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n116",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n117",
      "type": "block",
      "statements": [
        "graph",
        "graphs"
      ],
      "code": "graph\ngraphs"
    },
    {
      "id": "n118",
      "type": "block",
      "statements": [
        "try:\n    graph_models.append(GraphModel.from_db(graph))\nexcept Exception as e:\n    logger.error(f'Error processing graph {graph.id}: {e}')\n    continue",
        "graph_models.append(GraphModel.from_db(graph))",
        "logger.error(f'Error processing graph {graph.id}: {e}')",
        "continue"
      ],
      "code": "try:\n    graph_models.append(GraphModel.from_db(graph))\nexcept Exception as e:\n    logger.error(f'Error processing graph {graph.id}: {e}')\n    continue\ngraph_models.append(GraphModel.from_db(graph))\nlogger.error(f'Error processing graph {graph.id}: {e}')\ncontinue"
    },
    {
      "id": "n119",
      "type": "block",
      "statements": [
        "return graph_models"
      ],
      "code": "return graph_models"
    },
    {
      "id": "n120",
      "type": "block",
      "statements": [
        "async def get_executions(user_id: str) -> list[GraphExecution]:\n    executions = await AgentGraphExecution.prisma().find_many(where={'userId': user_id}, order={'createdAt': 'desc'})\n    return [GraphExecution.from_db(execution) for execution in executions]",
        "executions = await AgentGraphExecution.prisma().find_many(where={'userId': user_id}, order={'createdAt': 'desc'})",
        "return [GraphExecution.from_db(execution) for execution in executions]"
      ],
      "code": "async def get_executions(user_id: str) -> list[GraphExecution]:\n    executions = await AgentGraphExecution.prisma().find_many(where={'userId': user_id}, order={'createdAt': 'desc'})\n    return [GraphExecution.from_db(execution) for execution in executions]\nexecutions = await AgentGraphExecution.prisma().find_many(where={'userId': user_id}, order={'createdAt': 'desc'})\nreturn [GraphExecution.from_db(execution) for execution in executions]"
    },
    {
      "id": "n121",
      "type": "block",
      "statements": [
        "async def get_execution(user_id: str, execution_id: str) -> GraphExecution | None:\n    execution = await AgentGraphExecution.prisma().find_first(where={'id': execution_id, 'userId': user_id})\n    return GraphExecution.from_db(execution) if execution else None",
        "execution = await AgentGraphExecution.prisma().find_first(where={'id': execution_id, 'userId': user_id})",
        "return GraphExecution.from_db(execution) if execution else None"
      ],
      "code": "async def get_execution(user_id: str, execution_id: str) -> GraphExecution | None:\n    execution = await AgentGraphExecution.prisma().find_first(where={'id': execution_id, 'userId': user_id})\n    return GraphExecution.from_db(execution) if execution else None\nexecution = await AgentGraphExecution.prisma().find_first(where={'id': execution_id, 'userId': user_id})\nreturn GraphExecution.from_db(execution) if execution else None"
    },
    {
      "id": "n122",
      "type": "block",
      "statements": [
        "async def get_graph(graph_id: str, version: int | None=None, template: bool=False, user_id: str | None=None, for_export: bool=False) -> GraphModel | None:\n    \"\"\"\n    Retrieves a graph from the DB.\n    Defaults to the version with `is_active` if `version` is not passed,\n    or the latest version with `is_template` if `template=True`.\n\n    Returns `None` if the record is not found.\n    \"\"\"\n    where_clause: AgentGraphWhereInput = {'id': graph_id}\n    if version is not None:\n        where_clause['version'] = version\n    elif not template:\n        where_clause['isActive'] = True\n    if user_id is not None and (not template):\n        where_clause['userId'] = user_id\n    graph = await AgentGraph.prisma().find_first(where=where_clause, include=AGENT_GRAPH_INCLUDE, order={'version': 'desc'})\n    return GraphModel.from_db(graph, for_export) if graph else None",
        "'\\n    Retrieves a graph from the DB.\\n    Defaults to the version with `is_active` if `version` is not passed,\\n    or the latest version with `is_template` if `template=True`.\\n\\n    Returns `None` if the record is not found.\\n    '",
        "where_clause: AgentGraphWhereInput = {'id': graph_id}",
        "version IsNot None"
      ],
      "code": "async def get_graph(graph_id: str, version: int | None=None, template: bool=False, user_id: str | None=None, for_export: bool=False) -> GraphModel | None:\n    \"\"\"\n    Retrieves a graph from the DB.\n    Defaults to the version with `is_active` if `version` is not passed,\n    or the latest version with `is_template` if `template=True`.\n\n    Returns `None` if the record is not found.\n    \"\"\"\n    where_clause: AgentGraphWhereInput = {'id': graph_id}\n    if version is not None:\n        where_clause['version'] = version\n    elif not template:\n        where_clause['isActive'] = True\n    if user_id is not None and (not template):\n        where_clause['userId'] = user_id\n    graph = await AgentGraph.prisma().find_first(where=where_clause, include=AGENT_GRAPH_INCLUDE, order={'version': 'desc'})\n    return GraphModel.from_db(graph, for_export) if graph else None\n'\\n    Retrieves a graph from the DB.\\n    Defaults to the version with `is_active` if `version` is not passed,\\n    or the latest version with `is_template` if `template=True`.\\n\\n    Returns `None` if the record is not found.\\n    '\nwhere_clause: AgentGraphWhereInput = {'id': graph_id}\nversion IsNot None"
    },
    {
      "id": "n123",
      "type": "block",
      "statements": [
        "where_clause['version'] = version"
      ],
      "code": "where_clause['version'] = version"
    },
    {
      "id": "n124",
      "type": "block",
      "statements": [
        "not template"
      ],
      "code": "not template"
    },
    {
      "id": "n125",
      "type": "block",
      "statements": [
        "user_id is not None and (not template)"
      ],
      "code": "user_id is not None and (not template)"
    },
    {
      "id": "n126",
      "type": "block",
      "statements": [
        "where_clause['isActive'] = True"
      ],
      "code": "where_clause['isActive'] = True"
    },
    {
      "id": "n127",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n128",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n129",
      "type": "block",
      "statements": [
        "where_clause['userId'] = user_id"
      ],
      "code": "where_clause['userId'] = user_id"
    },
    {
      "id": "n130",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n131",
      "type": "block",
      "statements": [
        "graph = await AgentGraph.prisma().find_first(where=where_clause, include=AGENT_GRAPH_INCLUDE, order={'version': 'desc'})",
        "return GraphModel.from_db(graph, for_export) if graph else None"
      ],
      "code": "graph = await AgentGraph.prisma().find_first(where=where_clause, include=AGENT_GRAPH_INCLUDE, order={'version': 'desc'})\nreturn GraphModel.from_db(graph, for_export) if graph else None"
    },
    {
      "id": "n132",
      "type": "block",
      "statements": [
        "async def set_graph_active_version(graph_id: str, version: int, user_id: str) -> None:\n    updated_count = await AgentGraph.prisma().update_many(data={'isActive': True}, where={'id': graph_id, 'version': version, 'userId': user_id})\n    if updated_count == 0:\n        raise Exception(f'Graph #{graph_id} v{version} not found or not owned by user')\n    await AgentGraph.prisma().update_many(data={'isActive': False}, where={'id': graph_id, 'version': {'not': version}, 'userId': user_id, 'isActive': True})",
        "updated_count = await AgentGraph.prisma().update_many(data={'isActive': True}, where={'id': graph_id, 'version': version, 'userId': user_id})",
        "updated_count Eq 0"
      ],
      "code": "async def set_graph_active_version(graph_id: str, version: int, user_id: str) -> None:\n    updated_count = await AgentGraph.prisma().update_many(data={'isActive': True}, where={'id': graph_id, 'version': version, 'userId': user_id})\n    if updated_count == 0:\n        raise Exception(f'Graph #{graph_id} v{version} not found or not owned by user')\n    await AgentGraph.prisma().update_many(data={'isActive': False}, where={'id': graph_id, 'version': {'not': version}, 'userId': user_id, 'isActive': True})\nupdated_count = await AgentGraph.prisma().update_many(data={'isActive': True}, where={'id': graph_id, 'version': version, 'userId': user_id})\nupdated_count Eq 0"
    },
    {
      "id": "n133",
      "type": "block",
      "statements": [
        "raise Exception(f'Graph #{graph_id} v{version} not found or not owned by user')"
      ],
      "code": "raise Exception(f'Graph #{graph_id} v{version} not found or not owned by user')"
    },
    {
      "id": "n134",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n135",
      "type": "block",
      "statements": [
        "await AgentGraph.prisma().update_many(data={'isActive': False}, where={'id': graph_id, 'version': {'not': version}, 'userId': user_id, 'isActive': True})",
        "async def get_graph_all_versions(graph_id: str, user_id: str) -> list[GraphModel]:\n    graph_versions = await AgentGraph.prisma().find_many(where={'id': graph_id, 'userId': user_id}, order={'version': 'desc'}, include=AGENT_GRAPH_INCLUDE)\n    if not graph_versions:\n        return []\n    return [GraphModel.from_db(graph) for graph in graph_versions]",
        "graph_versions = await AgentGraph.prisma().find_many(where={'id': graph_id, 'userId': user_id}, order={'version': 'desc'}, include=AGENT_GRAPH_INCLUDE)",
        "not graph_versions"
      ],
      "code": "await AgentGraph.prisma().update_many(data={'isActive': False}, where={'id': graph_id, 'version': {'not': version}, 'userId': user_id, 'isActive': True})\nasync def get_graph_all_versions(graph_id: str, user_id: str) -> list[GraphModel]:\n    graph_versions = await AgentGraph.prisma().find_many(where={'id': graph_id, 'userId': user_id}, order={'version': 'desc'}, include=AGENT_GRAPH_INCLUDE)\n    if not graph_versions:\n        return []\n    return [GraphModel.from_db(graph) for graph in graph_versions]\ngraph_versions = await AgentGraph.prisma().find_many(where={'id': graph_id, 'userId': user_id}, order={'version': 'desc'}, include=AGENT_GRAPH_INCLUDE)\nnot graph_versions"
    },
    {
      "id": "n136",
      "type": "block",
      "statements": [
        "return []"
      ],
      "code": "return []"
    },
    {
      "id": "n137",
      "type": "block",
      "statements": [],
      "code": "\nreturn [GraphModel.from_db(graph) for graph in graph_versions]"
    },
    {
      "id": "n138",
      "type": "block",
      "statements": [
        "async def delete_graph(graph_id: str, user_id: str) -> int:\n    entries_count = await AgentGraph.prisma().delete_many(where={'id': graph_id, 'userId': user_id})\n    if entries_count:\n        logger.info(f'Deleted {entries_count} graph entries for Graph #{graph_id}')\n    return entries_count",
        "entries_count = await AgentGraph.prisma().delete_many(where={'id': graph_id, 'userId': user_id})",
        "entries_count"
      ],
      "code": "async def delete_graph(graph_id: str, user_id: str) -> int:\n    entries_count = await AgentGraph.prisma().delete_many(where={'id': graph_id, 'userId': user_id})\n    if entries_count:\n        logger.info(f'Deleted {entries_count} graph entries for Graph #{graph_id}')\n    return entries_count\nentries_count = await AgentGraph.prisma().delete_many(where={'id': graph_id, 'userId': user_id})\nentries_count"
    },
    {
      "id": "n139",
      "type": "block",
      "statements": [
        "logger.info(f'Deleted {entries_count} graph entries for Graph #{graph_id}')"
      ],
      "code": "logger.info(f'Deleted {entries_count} graph entries for Graph #{graph_id}')"
    },
    {
      "id": "n140",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n141",
      "type": "block",
      "statements": [
        "return entries_count"
      ],
      "code": "return entries_count"
    },
    {
      "id": "n142",
      "type": "block",
      "statements": [
        "async def create_graph(graph: Graph, user_id: str) -> GraphModel:\n    async with transaction() as tx:\n        await __create_graph(tx, graph, user_id)\n    if (created_graph := (await get_graph(graph.id, graph.version, graph.is_template, user_id=user_id))):\n        return created_graph\n    raise ValueError(f'Created graph {graph.id} v{graph.version} is not in DB')",
        "async with transaction() as tx:\n    await __create_graph(tx, graph, user_id)",
        "await __create_graph(tx, graph, user_id)",
        "(created_graph := (await get_graph(graph.id, graph.version, graph.is_template, user_id=user_id)))"
      ],
      "code": "async def create_graph(graph: Graph, user_id: str) -> GraphModel:\n    async with transaction() as tx:\n        await __create_graph(tx, graph, user_id)\n    if (created_graph := (await get_graph(graph.id, graph.version, graph.is_template, user_id=user_id))):\n        return created_graph\n    raise ValueError(f'Created graph {graph.id} v{graph.version} is not in DB')\nasync with transaction() as tx:\n    await __create_graph(tx, graph, user_id)\nawait __create_graph(tx, graph, user_id)\n(created_graph := (await get_graph(graph.id, graph.version, graph.is_template, user_id=user_id)))"
    },
    {
      "id": "n143",
      "type": "block",
      "statements": [
        "return created_graph"
      ],
      "code": "return created_graph"
    },
    {
      "id": "n144",
      "type": "block",
      "statements": [],
      "code": "\nraise ValueError(f'Created graph {graph.id} v{graph.version} is not in DB')\nasync def __create_graph(tx, graph: Graph, user_id: str):\n    await AgentGraph.prisma(tx).create(data={'id': graph.id, 'version': graph.version, 'name': graph.name, 'description': graph.description, 'isTemplate': graph.is_template, 'isActive': graph.is_active, 'userId': user_id})\n    await asyncio.gather(*[AgentNode.prisma(tx).create({'id': node.id, 'agentBlockId': node.block_id, 'agentGraphId': graph.id, 'agentGraphVersion': graph.version, 'constantInput': json.dumps(node.input_default), 'metadata': json.dumps(node.metadata)}) for node in graph.nodes])\n    await asyncio.gather(*[AgentNodeLink.prisma(tx).create({'id': str(uuid.uuid4()), 'sourceName': link.source_name, 'sinkName': link.sink_name, 'agentNodeSourceId': link.source_id, 'agentNodeSinkId': link.sink_id, 'isStatic': link.is_static}) for link in graph.links])\nawait AgentGraph.prisma(tx).create(data={'id': graph.id, 'version': graph.version, 'name': graph.name, 'description': graph.description, 'isTemplate': graph.is_template, 'isActive': graph.is_active, 'userId': user_id})\nawait asyncio.gather(*[AgentNode.prisma(tx).create({'id': node.id, 'agentBlockId': node.block_id, 'agentGraphId': graph.id, 'agentGraphVersion': graph.version, 'constantInput': json.dumps(node.input_default), 'metadata': json.dumps(node.metadata)}) for node in graph.nodes])\nawait asyncio.gather(*[AgentNodeLink.prisma(tx).create({'id': str(uuid.uuid4()), 'sourceName': link.source_name, 'sinkName': link.sink_name, 'agentNodeSourceId': link.source_id, 'agentNodeSinkId': link.sink_id, 'isStatic': link.is_static}) for link in graph.links])\ndef make_graph_model(creatable_graph: Graph, user_id: str) -> GraphModel:\n    \"\"\"\n    Convert a Graph to a GraphModel, setting graph_id and graph_version on all nodes.\n\n    Args:\n        creatable_graph (Graph): The creatable graph to convert.\n        user_id (str): The ID of the user creating the graph.\n\n    Returns:\n        GraphModel: The converted Graph object.\n    \"\"\"\n    return GraphModel(**creatable_graph.model_dump(exclude={'nodes'}), user_id=user_id, nodes=[NodeModel(**creatable_node.model_dump(), graph_id=creatable_graph.id, graph_version=creatable_graph.version) for creatable_node in creatable_graph.nodes])\n'\\n    Convert a Graph to a GraphModel, setting graph_id and graph_version on all nodes.\\n\\n    Args:\\n        creatable_graph (Graph): The creatable graph to convert.\\n        user_id (str): The ID of the user creating the graph.\\n\\n    Returns:\\n        GraphModel: The converted Graph object.\\n    '\nreturn GraphModel(**creatable_graph.model_dump(exclude={'nodes'}), user_id=user_id, nodes=[NodeModel(**creatable_node.model_dump(), graph_id=creatable_graph.id, graph_version=creatable_graph.version) for creatable_node in creatable_graph.nodes])"
    },
    {
      "id": "n145",
      "type": "block",
      "statements": [
        "async def fix_llm_provider_credentials():\n    \"\"\"Fix node credentials with provider `llm`\"\"\"\n    from backend.integrations.credentials_store import IntegrationCredentialsStore\n    from .user import get_user_integrations\n    store = IntegrationCredentialsStore()\n    broken_nodes = await prisma.get_client().query_raw('\\n        SELECT    graph.\"userId\"       user_id,\\n                  node.id              node_id,\\n                  node.\"constantInput\" node_preset_input\\n        FROM      platform.\"AgentNode\"  node\\n        LEFT JOIN platform.\"AgentGraph\" graph\\n        ON        node.\"agentGraphId\" = graph.id\\n        WHERE     node.\"constantInput\"::jsonb->\\'credentials\\'->>\\'provider\\' = \\'llm\\'\\n        ORDER BY  graph.\"userId\";\\n        ')\n    logger.info(f'Fixing LLM credential inputs on {len(broken_nodes)} nodes')\n    user_id: str = ''\n    user_integrations = None\n    for node in broken_nodes:\n        if node['user_id'] != user_id:\n            user_id = node['user_id']\n            user_integrations = await get_user_integrations(user_id)\n        elif not user_integrations:\n            raise RuntimeError(f'Impossible state while processing node {node}')\n        node_id: str = node['node_id']\n        node_preset_input: dict = json.loads(node['node_preset_input'])\n        credentials_meta: dict = node_preset_input['credentials']\n        credentials = next((c for c in user_integrations.credentials if c.id == credentials_meta['id']), None)\n        if not credentials:\n            continue\n        if credentials.type != 'api_key':\n            logger.warning(f\"User {user_id} credentials {credentials.id} with provider 'llm' has invalid type '{credentials.type}'\")\n            continue\n        api_key = credentials.api_key.get_secret_value()\n        if api_key.startswith('sk-ant-api03-'):\n            credentials.provider = credentials_meta['provider'] = 'anthropic'\n        elif api_key.startswith('sk-'):\n            credentials.provider = credentials_meta['provider'] = 'openai'\n        elif api_key.startswith('gsk_'):\n            credentials.provider = credentials_meta['provider'] = 'groq'\n        else:\n            logger.warning(f'Could not identify provider from key prefix {api_key[:13]}*****')\n            continue\n        store.update_creds(user_id, credentials)\n        await AgentNode.prisma().update(where={'id': node_id}, data={'constantInput': json.dumps(node_preset_input)})",
        "'Fix node credentials with provider `llm`'",
        "from backend.integrations.credentials_store import IntegrationCredentialsStore",
        "from .user import get_user_integrations",
        "store = IntegrationCredentialsStore()",
        "broken_nodes = await prisma.get_client().query_raw('\\n        SELECT    graph.\"userId\"       user_id,\\n                  node.id              node_id,\\n                  node.\"constantInput\" node_preset_input\\n        FROM      platform.\"AgentNode\"  node\\n        LEFT JOIN platform.\"AgentGraph\" graph\\n        ON        node.\"agentGraphId\" = graph.id\\n        WHERE     node.\"constantInput\"::jsonb->\\'credentials\\'->>\\'provider\\' = \\'llm\\'\\n        ORDER BY  graph.\"userId\";\\n        ')",
        "logger.info(f'Fixing LLM credential inputs on {len(broken_nodes)} nodes')",
        "user_id: str = ''",
        "user_integrations = None"
      ],
      "code": "async def fix_llm_provider_credentials():\n    \"\"\"Fix node credentials with provider `llm`\"\"\"\n    from backend.integrations.credentials_store import IntegrationCredentialsStore\n    from .user import get_user_integrations\n    store = IntegrationCredentialsStore()\n    broken_nodes = await prisma.get_client().query_raw('\\n        SELECT    graph.\"userId\"       user_id,\\n                  node.id              node_id,\\n                  node.\"constantInput\" node_preset_input\\n        FROM      platform.\"AgentNode\"  node\\n        LEFT JOIN platform.\"AgentGraph\" graph\\n        ON        node.\"agentGraphId\" = graph.id\\n        WHERE     node.\"constantInput\"::jsonb->\\'credentials\\'->>\\'provider\\' = \\'llm\\'\\n        ORDER BY  graph.\"userId\";\\n        ')\n    logger.info(f'Fixing LLM credential inputs on {len(broken_nodes)} nodes')\n    user_id: str = ''\n    user_integrations = None\n    for node in broken_nodes:\n        if node['user_id'] != user_id:\n            user_id = node['user_id']\n            user_integrations = await get_user_integrations(user_id)\n        elif not user_integrations:\n            raise RuntimeError(f'Impossible state while processing node {node}')\n        node_id: str = node['node_id']\n        node_preset_input: dict = json.loads(node['node_preset_input'])\n        credentials_meta: dict = node_preset_input['credentials']\n        credentials = next((c for c in user_integrations.credentials if c.id == credentials_meta['id']), None)\n        if not credentials:\n            continue\n        if credentials.type != 'api_key':\n            logger.warning(f\"User {user_id} credentials {credentials.id} with provider 'llm' has invalid type '{credentials.type}'\")\n            continue\n        api_key = credentials.api_key.get_secret_value()\n        if api_key.startswith('sk-ant-api03-'):\n            credentials.provider = credentials_meta['provider'] = 'anthropic'\n        elif api_key.startswith('sk-'):\n            credentials.provider = credentials_meta['provider'] = 'openai'\n        elif api_key.startswith('gsk_'):\n            credentials.provider = credentials_meta['provider'] = 'groq'\n        else:\n            logger.warning(f'Could not identify provider from key prefix {api_key[:13]}*****')\n            continue\n        store.update_creds(user_id, credentials)\n        await AgentNode.prisma().update(where={'id': node_id}, data={'constantInput': json.dumps(node_preset_input)})\n'Fix node credentials with provider `llm`'\nfrom backend.integrations.credentials_store import IntegrationCredentialsStore\nfrom .user import get_user_integrations\nstore = IntegrationCredentialsStore()\nbroken_nodes = await prisma.get_client().query_raw('\\n        SELECT    graph.\"userId\"       user_id,\\n                  node.id              node_id,\\n                  node.\"constantInput\" node_preset_input\\n        FROM      platform.\"AgentNode\"  node\\n        LEFT JOIN platform.\"AgentGraph\" graph\\n        ON        node.\"agentGraphId\" = graph.id\\n        WHERE     node.\"constantInput\"::jsonb->\\'credentials\\'->>\\'provider\\' = \\'llm\\'\\n        ORDER BY  graph.\"userId\";\\n        ')\nlogger.info(f'Fixing LLM credential inputs on {len(broken_nodes)} nodes')\nuser_id: str = ''\nuser_integrations = None"
    },
    {
      "id": "n146",
      "type": "block",
      "statements": [
        "node",
        "broken_nodes"
      ],
      "code": "node\nbroken_nodes"
    },
    {
      "id": "n147",
      "type": "block",
      "statements": [
        "node['user_id'] NotEq user_id"
      ],
      "code": "node['user_id'] NotEq user_id"
    },
    {
      "id": "n148",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n149",
      "type": "block",
      "statements": [
        "user_id = node['user_id']",
        "user_integrations = await get_user_integrations(user_id)"
      ],
      "code": "user_id = node['user_id']\nuser_integrations = await get_user_integrations(user_id)"
    },
    {
      "id": "n150",
      "type": "block",
      "statements": [
        "not user_integrations"
      ],
      "code": "not user_integrations"
    },
    {
      "id": "n151",
      "type": "block",
      "statements": [
        "node_id: str = node['node_id']",
        "node_preset_input: dict = json.loads(node['node_preset_input'])",
        "credentials_meta: dict = node_preset_input['credentials']",
        "credentials = next((c for c in user_integrations.credentials if c.id == credentials_meta['id']), None)",
        "not credentials"
      ],
      "code": "node_id: str = node['node_id']\nnode_preset_input: dict = json.loads(node['node_preset_input'])\ncredentials_meta: dict = node_preset_input['credentials']\ncredentials = next((c for c in user_integrations.credentials if c.id == credentials_meta['id']), None)\nnot credentials"
    },
    {
      "id": "n152",
      "type": "block",
      "statements": [
        "raise RuntimeError(f'Impossible state while processing node {node}')"
      ],
      "code": "raise RuntimeError(f'Impossible state while processing node {node}')"
    },
    {
      "id": "n153",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n154",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n155",
      "type": "block",
      "statements": [
        "continue"
      ],
      "code": "continue"
    },
    {
      "id": "n156",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n157",
      "type": "block",
      "statements": [
        "credentials.type NotEq 'api_key'"
      ],
      "code": "credentials.type NotEq 'api_key'"
    },
    {
      "id": "n158",
      "type": "block",
      "statements": [
        "logger.warning(f\"User {user_id} credentials {credentials.id} with provider 'llm' has invalid type '{credentials.type}'\")",
        "continue"
      ],
      "code": "logger.warning(f\"User {user_id} credentials {credentials.id} with provider 'llm' has invalid type '{credentials.type}'\")\ncontinue"
    },
    {
      "id": "n159",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n160",
      "type": "block",
      "statements": [
        "api_key = credentials.api_key.get_secret_value()",
        "api_key.startswith('sk-ant-api03-')"
      ],
      "code": "api_key = credentials.api_key.get_secret_value()\napi_key.startswith('sk-ant-api03-')"
    },
    {
      "id": "n161",
      "type": "block",
      "statements": [
        "credentials.provider = credentials_meta['provider'] = 'anthropic'"
      ],
      "code": "credentials.provider = credentials_meta['provider'] = 'anthropic'"
    },
    {
      "id": "n162",
      "type": "block",
      "statements": [
        "api_key.startswith('sk-')"
      ],
      "code": "api_key.startswith('sk-')"
    },
    {
      "id": "n163",
      "type": "block",
      "statements": [
        "store.update_creds(user_id, credentials)",
        "await AgentNode.prisma().update(where={'id': node_id}, data={'constantInput': json.dumps(node_preset_input)})"
      ],
      "code": "store.update_creds(user_id, credentials)\nawait AgentNode.prisma().update(where={'id': node_id}, data={'constantInput': json.dumps(node_preset_input)})"
    },
    {
      "id": "n164",
      "type": "block",
      "statements": [
        "credentials.provider = credentials_meta['provider'] = 'openai'"
      ],
      "code": "credentials.provider = credentials_meta['provider'] = 'openai'"
    },
    {
      "id": "n165",
      "type": "block",
      "statements": [
        "api_key.startswith('gsk_')"
      ],
      "code": "api_key.startswith('gsk_')"
    },
    {
      "id": "n166",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n167",
      "type": "block",
      "statements": [
        "credentials.provider = credentials_meta['provider'] = 'groq'"
      ],
      "code": "credentials.provider = credentials_meta['provider'] = 'groq'"
    },
    {
      "id": "n168",
      "type": "block",
      "statements": [
        "logger.warning(f'Could not identify provider from key prefix {api_key[:13]}*****')",
        "continue"
      ],
      "code": "logger.warning(f'Could not identify provider from key prefix {api_key[:13]}*****')\ncontinue"
    },
    {
      "id": "n169",
      "type": "block",
      "statements": [],
      "code": ""
    }
  ],
  "edges": [
    {
      "source": "n60",
      "target": "n46"
    },
    {
      "source": "n70",
      "target": "n71"
    },
    {
      "source": "n101",
      "target": "n96"
    },
    {
      "source": "n74",
      "target": "n75"
    },
    {
      "source": "n82",
      "target": "n84"
    },
    {
      "source": "n152",
      "target": "n154"
    },
    {
      "source": "n14",
      "target": "n15"
    },
    {
      "source": "n67",
      "target": "n69"
    },
    {
      "source": "n50",
      "target": "n51"
    },
    {
      "source": "n76",
      "target": "n78"
    },
    {
      "source": "n107",
      "target": "n109"
    },
    {
      "source": "n157",
      "target": "n159"
    },
    {
      "source": "n132",
      "target": "n133"
    },
    {
      "source": "n26",
      "target": "n27"
    },
    {
      "source": "n89",
      "target": "n92"
    },
    {
      "source": "n40",
      "target": "n41"
    },
    {
      "source": "n34",
      "target": "n33"
    },
    {
      "source": "n122",
      "target": "n124"
    },
    {
      "source": "n133",
      "target": "n135"
    },
    {
      "source": "n35",
      "target": "n36"
    },
    {
      "source": "n2",
      "target": "n4"
    },
    {
      "source": "n103",
      "target": "n104"
    },
    {
      "source": "n158",
      "target": "n160"
    },
    {
      "source": "n80",
      "target": "n81"
    },
    {
      "source": "n8",
      "target": "n9"
    },
    {
      "source": "n71",
      "target": "n74"
    },
    {
      "source": "n160",
      "target": "n162"
    },
    {
      "source": "n53",
      "target": "n55"
    },
    {
      "source": "n139",
      "target": "n141"
    },
    {
      "source": "n12",
      "target": "n13"
    },
    {
      "source": "n132",
      "target": "n134"
    },
    {
      "source": "n51",
      "target": "n52"
    },
    {
      "source": "n127",
      "target": "n128"
    },
    {
      "source": "n155",
      "target": "n157"
    },
    {
      "source": "n115",
      "target": "n116"
    },
    {
      "source": "n125",
      "target": "n129"
    },
    {
      "source": "n118",
      "target": "n117"
    },
    {
      "source": "n59",
      "target": "n61"
    },
    {
      "source": "n45",
      "target": "n46"
    },
    {
      "source": "n88",
      "target": "n90"
    },
    {
      "source": "n88",
      "target": "n89"
    },
    {
      "source": "n28",
      "target": "n29"
    },
    {
      "source": "n81",
      "target": "n82"
    },
    {
      "source": "n96",
      "target": "n98"
    },
    {
      "source": "n168",
      "target": "n169"
    },
    {
      "source": "n75",
      "target": "n77"
    },
    {
      "source": "n93",
      "target": "n94"
    },
    {
      "source": "n75",
      "target": "n76"
    },
    {
      "source": "n36",
      "target": "n37"
    },
    {
      "source": "n22",
      "target": "n24"
    },
    {
      "source": "n59",
      "target": "n62"
    },
    {
      "source": "n6",
      "target": "n8"
    },
    {
      "source": "n97",
      "target": "n99"
    },
    {
      "source": "n87",
      "target": "n67"
    },
    {
      "source": "n65",
      "target": "n66"
    },
    {
      "source": "n66",
      "target": "n58"
    },
    {
      "source": "n147",
      "target": "n149"
    },
    {
      "source": "n15",
      "target": "n17"
    },
    {
      "source": "n63",
      "target": "n64"
    },
    {
      "source": "n146",
      "target": "n147"
    },
    {
      "source": "n41",
      "target": "n36"
    },
    {
      "source": "n145",
      "target": "n146"
    },
    {
      "source": "n84",
      "target": "n70"
    },
    {
      "source": "n53",
      "target": "n56"
    },
    {
      "source": "n21",
      "target": "n22"
    },
    {
      "source": "n146",
      "target": "n148"
    },
    {
      "source": "n2",
      "target": "n3"
    },
    {
      "source": "n117",
      "target": "n119"
    },
    {
      "source": "n108",
      "target": "n109"
    },
    {
      "source": "n113",
      "target": "n117"
    },
    {
      "source": "n151",
      "target": "n155"
    },
    {
      "source": "n138",
      "target": "n140"
    },
    {
      "source": "n138",
      "target": "n139"
    },
    {
      "source": "n92",
      "target": "n94"
    },
    {
      "source": "n81",
      "target": "n83"
    },
    {
      "source": "n44",
      "target": "n43"
    },
    {
      "source": "n117",
      "target": "n118"
    },
    {
      "source": "n157",
      "target": "n158"
    },
    {
      "source": "n134",
      "target": "n135"
    },
    {
      "source": "n163",
      "target": "n146"
    },
    {
      "source": "n96",
      "target": "n97"
    },
    {
      "source": "n42",
      "target": "n43"
    },
    {
      "source": "n58",
      "target": "n60"
    },
    {
      "source": "n29",
      "target": "n30"
    },
    {
      "source": "n9",
      "target": "n11"
    },
    {
      "source": "n153",
      "target": "n154"
    },
    {
      "source": "n79",
      "target": "n81"
    },
    {
      "source": "n37",
      "target": "n39"
    },
    {
      "source": "n58",
      "target": "n59"
    },
    {
      "source": "n150",
      "target": "n152"
    },
    {
      "source": "n11",
      "target": "n12"
    },
    {
      "source": "n114",
      "target": "n116"
    },
    {
      "source": "n72",
      "target": "n86"
    },
    {
      "source": "n7",
      "target": "n9"
    },
    {
      "source": "n140",
      "target": "n141"
    },
    {
      "source": "n26",
      "target": "n28"
    },
    {
      "source": "n86",
      "target": "n87"
    },
    {
      "source": "n47",
      "target": "n50"
    },
    {
      "source": "n33",
      "target": "n34"
    },
    {
      "source": "n73",
      "target": "n75"
    },
    {
      "source": "n94",
      "target": "n91"
    },
    {
      "source": "n164",
      "target": "n166"
    },
    {
      "source": "n128",
      "target": "n125"
    },
    {
      "source": "n130",
      "target": "n131"
    },
    {
      "source": "n30",
      "target": "n32"
    },
    {
      "source": "n135",
      "target": "n136"
    },
    {
      "source": "n106",
      "target": "n108"
    },
    {
      "source": "n122",
      "target": "n123"
    },
    {
      "source": "n47",
      "target": "n49"
    },
    {
      "source": "n83",
      "target": "n84"
    },
    {
      "source": "n77",
      "target": "n78"
    },
    {
      "source": "n102",
      "target": "n104"
    },
    {
      "source": "n22",
      "target": "n23"
    },
    {
      "source": "n85",
      "target": "n87"
    },
    {
      "source": "n160",
      "target": "n161"
    },
    {
      "source": "n112",
      "target": "n115"
    },
    {
      "source": "n95",
      "target": "n96"
    },
    {
      "source": "n90",
      "target": "n91"
    },
    {
      "source": "n37",
      "target": "n40"
    },
    {
      "source": "n129",
      "target": "n131"
    },
    {
      "source": "n156",
      "target": "n157"
    },
    {
      "source": "n30",
      "target": "n31"
    },
    {
      "source": "n167",
      "target": "n169"
    },
    {
      "source": "n142",
      "target": "n143"
    },
    {
      "source": "n112",
      "target": "n114"
    },
    {
      "source": "n57",
      "target": "n52"
    },
    {
      "source": "n89",
      "target": "n93"
    },
    {
      "source": "n14",
      "target": "n16"
    },
    {
      "source": "n46",
      "target": "n48"
    },
    {
      "source": "n100",
      "target": "n103"
    },
    {
      "source": "n62",
      "target": "n63"
    },
    {
      "source": "n10",
      "target": "n12"
    },
    {
      "source": "n64",
      "target": "n66"
    },
    {
      "source": "n124",
      "target": "n126"
    },
    {
      "source": "n27",
      "target": "n29"
    },
    {
      "source": "n149",
      "target": "n151"
    },
    {
      "source": "n110",
      "target": "n111"
    },
    {
      "source": "n147",
      "target": "n150"
    },
    {
      "source": "n70",
      "target": "n72"
    },
    {
      "source": "n104",
      "target": "n101"
    },
    {
      "source": "n3",
      "target": "n5"
    },
    {
      "source": "n123",
      "target": "n125"
    },
    {
      "source": "n63",
      "target": "n65"
    },
    {
      "source": "n39",
      "target": "n41"
    },
    {
      "source": "n150",
      "target": "n153"
    },
    {
      "source": "n151",
      "target": "n156"
    },
    {
      "source": "n161",
      "target": "n163"
    },
    {
      "source": "n111",
      "target": "n113"
    },
    {
      "source": "n52",
      "target": "n53"
    },
    {
      "source": "n6",
      "target": "n7"
    },
    {
      "source": "n165",
      "target": "n168"
    },
    {
      "source": "n78",
      "target": "n79"
    },
    {
      "source": "n159",
      "target": "n160"
    },
    {
      "source": "n61",
      "target": "n63"
    },
    {
      "source": "n124",
      "target": "n127"
    },
    {
      "source": "n100",
      "target": "n102"
    },
    {
      "source": "n23",
      "target": "n22"
    },
    {
      "source": "n71",
      "target": "n73"
    },
    {
      "source": "n16",
      "target": "n17"
    },
    {
      "source": "n169",
      "target": "n166"
    },
    {
      "source": "n165",
      "target": "n167"
    },
    {
      "source": "n68",
      "target": "n70"
    },
    {
      "source": "n33",
      "target": "n35"
    },
    {
      "source": "n97",
      "target": "n100"
    },
    {
      "source": "n4",
      "target": "n5"
    },
    {
      "source": "n142",
      "target": "n144"
    },
    {
      "source": "n43",
      "target": "n44"
    },
    {
      "source": "n126",
      "target": "n128"
    },
    {
      "source": "n12",
      "target": "n14"
    },
    {
      "source": "n162",
      "target": "n165"
    },
    {
      "source": "n116",
      "target": "n113"
    },
    {
      "source": "n72",
      "target": "n85"
    },
    {
      "source": "n55",
      "target": "n57"
    },
    {
      "source": "n46",
      "target": "n47"
    },
    {
      "source": "n36",
      "target": "n38"
    },
    {
      "source": "n32",
      "target": "n33"
    },
    {
      "source": "n49",
      "target": "n51"
    },
    {
      "source": "n106",
      "target": "n107"
    },
    {
      "source": "n9",
      "target": "n10"
    },
    {
      "source": "n166",
      "target": "n163"
    },
    {
      "source": "n67",
      "target": "n68"
    },
    {
      "source": "n110",
      "target": "n112"
    },
    {
      "source": "n135",
      "target": "n137"
    },
    {
      "source": "n52",
      "target": "n54"
    },
    {
      "source": "n162",
      "target": "n164"
    },
    {
      "source": "n43",
      "target": "n45"
    },
    {
      "source": "n31",
      "target": "n30"
    },
    {
      "source": "n99",
      "target": "n101"
    },
    {
      "source": "n78",
      "target": "n80"
    },
    {
      "source": "n125",
      "target": "n130"
    },
    {
      "source": "n154",
      "target": "n151"
    },
    {
      "source": "n56",
      "target": "n57"
    }
  ]
}