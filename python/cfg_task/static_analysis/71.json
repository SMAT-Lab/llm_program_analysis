{
  "nodes": [
    {
      "id": "n0",
      "type": "block",
      "statements": [
        "'\\nGiven a partially filled 9x9 2D array, the objective is to fill a 9x9\\nsquare grid with digits numbered 1 to 9, so that every row, column, and\\nand each of the nine 3x3 sub-grids contains all of the digits.\\n\\nThis can be solved using Backtracking and is similar to n-queens.\\nWe check to see if a cell is safe or not and recursively call the\\nfunction on the next column to see if it returns True. if yes, we\\nhave solved the puzzle. else, we backtrack and place another number\\nin that cell and repeat this process.\\n'",
        "from __future__ import annotations",
        "Matrix = list[list[int]]",
        "initial_grid: Matrix = [[3, 0, 6, 5, 0, 8, 4, 0, 0], [5, 2, 0, 0, 0, 0, 0, 0, 0], [0, 8, 7, 0, 0, 0, 0, 3, 1], [0, 0, 3, 0, 1, 0, 0, 8, 0], [9, 0, 0, 8, 6, 3, 0, 0, 5], [0, 5, 0, 0, 9, 0, 6, 0, 0], [1, 3, 0, 0, 0, 0, 2, 5, 0], [0, 0, 0, 0, 0, 0, 0, 7, 4], [0, 0, 5, 2, 0, 6, 3, 0, 0]]",
        "no_solution: Matrix = [[5, 0, 6, 5, 0, 8, 4, 0, 3], [5, 2, 0, 0, 0, 0, 0, 0, 2], [1, 8, 7, 0, 0, 0, 0, 3, 1], [0, 0, 3, 0, 1, 0, 0, 8, 0], [9, 0, 0, 8, 6, 3, 0, 0, 5], [0, 5, 0, 0, 9, 0, 6, 0, 0], [1, 3, 0, 0, 0, 0, 2, 5, 0], [0, 0, 0, 0, 0, 0, 0, 7, 4], [0, 0, 5, 2, 0, 6, 3, 0, 0]]",
        "def is_safe(grid: Matrix, row: int, column: int, n: int) -> bool:\n    \"\"\"\n    This function checks the grid to see if each row,\n    column, and the 3x3 subgrids contain the digit 'n'.\n    It returns False if it is not 'safe' (a duplicate digit\n    is found) else returns True if it is 'safe'\n    \"\"\"\n    for i in range(9):\n        if n in {grid[row][i], grid[i][column]}:\n            return False\n    for i in range(3):\n        for j in range(3):\n            if grid[row - row % 3 + i][column - column % 3 + j] == n:\n                return False\n    return True",
        "\"\\n    This function checks the grid to see if each row,\\n    column, and the 3x3 subgrids contain the digit 'n'.\\n    It returns False if it is not 'safe' (a duplicate digit\\n    is found) else returns True if it is 'safe'\\n    \""
      ],
      "code": "'\\nGiven a partially filled 9x9 2D array, the objective is to fill a 9x9\\nsquare grid with digits numbered 1 to 9, so that every row, column, and\\nand each of the nine 3x3 sub-grids contains all of the digits.\\n\\nThis can be solved using Backtracking and is similar to n-queens.\\nWe check to see if a cell is safe or not and recursively call the\\nfunction on the next column to see if it returns True. if yes, we\\nhave solved the puzzle. else, we backtrack and place another number\\nin that cell and repeat this process.\\n'\nfrom __future__ import annotations\nMatrix = list[list[int]]\ninitial_grid: Matrix = [[3, 0, 6, 5, 0, 8, 4, 0, 0], [5, 2, 0, 0, 0, 0, 0, 0, 0], [0, 8, 7, 0, 0, 0, 0, 3, 1], [0, 0, 3, 0, 1, 0, 0, 8, 0], [9, 0, 0, 8, 6, 3, 0, 0, 5], [0, 5, 0, 0, 9, 0, 6, 0, 0], [1, 3, 0, 0, 0, 0, 2, 5, 0], [0, 0, 0, 0, 0, 0, 0, 7, 4], [0, 0, 5, 2, 0, 6, 3, 0, 0]]\nno_solution: Matrix = [[5, 0, 6, 5, 0, 8, 4, 0, 3], [5, 2, 0, 0, 0, 0, 0, 0, 2], [1, 8, 7, 0, 0, 0, 0, 3, 1], [0, 0, 3, 0, 1, 0, 0, 8, 0], [9, 0, 0, 8, 6, 3, 0, 0, 5], [0, 5, 0, 0, 9, 0, 6, 0, 0], [1, 3, 0, 0, 0, 0, 2, 5, 0], [0, 0, 0, 0, 0, 0, 0, 7, 4], [0, 0, 5, 2, 0, 6, 3, 0, 0]]\ndef is_safe(grid: Matrix, row: int, column: int, n: int) -> bool:\n    \"\"\"\n    This function checks the grid to see if each row,\n    column, and the 3x3 subgrids contain the digit 'n'.\n    It returns False if it is not 'safe' (a duplicate digit\n    is found) else returns True if it is 'safe'\n    \"\"\"\n    for i in range(9):\n        if n in {grid[row][i], grid[i][column]}:\n            return False\n    for i in range(3):\n        for j in range(3):\n            if grid[row - row % 3 + i][column - column % 3 + j] == n:\n                return False\n    return True\n\"\\n    This function checks the grid to see if each row,\\n    column, and the 3x3 subgrids contain the digit 'n'.\\n    It returns False if it is not 'safe' (a duplicate digit\\n    is found) else returns True if it is 'safe'\\n    \""
    },
    {
      "id": "n1",
      "type": "block",
      "statements": [
        "i",
        "range(9)"
      ],
      "code": "i\nrange(9)"
    },
    {
      "id": "n2",
      "type": "block",
      "statements": [
        "n In {grid[row][i], grid[i][column]}"
      ],
      "code": "n In {grid[row][i], grid[i][column]}"
    },
    {
      "id": "n3",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n4",
      "type": "block",
      "statements": [
        "return False"
      ],
      "code": "return False"
    },
    {
      "id": "n5",
      "type": "block",
      "statements": [],
      "code": "\n"
    },
    {
      "id": "n6",
      "type": "block",
      "statements": [
        "i",
        "range(3)"
      ],
      "code": "i\nrange(3)"
    },
    {
      "id": "n7",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n8",
      "type": "block",
      "statements": [
        "return True"
      ],
      "code": "return True"
    },
    {
      "id": "n9",
      "type": "block",
      "statements": [
        "j",
        "range(3)"
      ],
      "code": "j\nrange(3)"
    },
    {
      "id": "n10",
      "type": "block",
      "statements": [
        "grid[row - row % 3 + i][column - column % 3 + j] Eq n"
      ],
      "code": "grid[row - row % 3 + i][column - column % 3 + j] Eq n"
    },
    {
      "id": "n11",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n12",
      "type": "block",
      "statements": [
        "return False"
      ],
      "code": "return False"
    },
    {
      "id": "n13",
      "type": "block",
      "statements": [],
      "code": "\n"
    },
    {
      "id": "n14",
      "type": "block",
      "statements": [
        "def find_empty_location(grid: Matrix) -> tuple[int, int] | None:\n    \"\"\"\n    This function finds an empty location so that we can assign a number\n    for that particular row and column.\n    \"\"\"\n    for i in range(9):\n        for j in range(9):\n            if grid[i][j] == 0:\n                return (i, j)\n    return None",
        "'\\n    This function finds an empty location so that we can assign a number\\n    for that particular row and column.\\n    '"
      ],
      "code": "def find_empty_location(grid: Matrix) -> tuple[int, int] | None:\n    \"\"\"\n    This function finds an empty location so that we can assign a number\n    for that particular row and column.\n    \"\"\"\n    for i in range(9):\n        for j in range(9):\n            if grid[i][j] == 0:\n                return (i, j)\n    return None\n'\\n    This function finds an empty location so that we can assign a number\\n    for that particular row and column.\\n    '"
    },
    {
      "id": "n15",
      "type": "block",
      "statements": [
        "i",
        "range(9)"
      ],
      "code": "i\nrange(9)"
    },
    {
      "id": "n16",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n17",
      "type": "block",
      "statements": [
        "return None"
      ],
      "code": "return None"
    },
    {
      "id": "n18",
      "type": "block",
      "statements": [
        "j",
        "range(9)"
      ],
      "code": "j\nrange(9)"
    },
    {
      "id": "n19",
      "type": "block",
      "statements": [
        "grid[i][j] Eq 0"
      ],
      "code": "grid[i][j] Eq 0"
    },
    {
      "id": "n20",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n21",
      "type": "block",
      "statements": [
        "return (i, j)"
      ],
      "code": "return (i, j)"
    },
    {
      "id": "n22",
      "type": "block",
      "statements": [],
      "code": "\n"
    },
    {
      "id": "n23",
      "type": "block",
      "statements": [
        "def sudoku(grid: Matrix) -> Matrix | None:\n    \"\"\"\n    Takes a partially filled-in grid and attempts to assign values to\n    all unassigned locations in such a way to meet the requirements\n    for Sudoku solution (non-duplication across rows, columns, and boxes)\n\n    >>> sudoku(initial_grid)  # doctest: +NORMALIZE_WHITESPACE\n    [[3, 1, 6, 5, 7, 8, 4, 9, 2],\n     [5, 2, 9, 1, 3, 4, 7, 6, 8],\n     [4, 8, 7, 6, 2, 9, 5, 3, 1],\n     [2, 6, 3, 4, 1, 5, 9, 8, 7],\n     [9, 7, 4, 8, 6, 3, 1, 2, 5],\n     [8, 5, 1, 7, 9, 2, 6, 4, 3],\n     [1, 3, 8, 9, 4, 7, 2, 5, 6],\n     [6, 9, 2, 3, 5, 1, 8, 7, 4],\n     [7, 4, 5, 2, 8, 6, 3, 1, 9]]\n     >>> sudoku(no_solution) is None\n     True\n    \"\"\"\n    if (location := find_empty_location(grid)):\n        (row, column) = location\n    else:\n        return grid\n    for digit in range(1, 10):\n        if is_safe(grid, row, column, digit):\n            grid[row][column] = digit\n            if sudoku(grid) is not None:\n                return grid\n            grid[row][column] = 0\n    return None",
        "'\\n    Takes a partially filled-in grid and attempts to assign values to\\n    all unassigned locations in such a way to meet the requirements\\n    for Sudoku solution (non-duplication across rows, columns, and boxes)\\n\\n    >>> sudoku(initial_grid)  # doctest: +NORMALIZE_WHITESPACE\\n    [[3, 1, 6, 5, 7, 8, 4, 9, 2],\\n     [5, 2, 9, 1, 3, 4, 7, 6, 8],\\n     [4, 8, 7, 6, 2, 9, 5, 3, 1],\\n     [2, 6, 3, 4, 1, 5, 9, 8, 7],\\n     [9, 7, 4, 8, 6, 3, 1, 2, 5],\\n     [8, 5, 1, 7, 9, 2, 6, 4, 3],\\n     [1, 3, 8, 9, 4, 7, 2, 5, 6],\\n     [6, 9, 2, 3, 5, 1, 8, 7, 4],\\n     [7, 4, 5, 2, 8, 6, 3, 1, 9]]\\n     >>> sudoku(no_solution) is None\\n     True\\n    '",
        "(location := find_empty_location(grid))"
      ],
      "code": "def sudoku(grid: Matrix) -> Matrix | None:\n    \"\"\"\n    Takes a partially filled-in grid and attempts to assign values to\n    all unassigned locations in such a way to meet the requirements\n    for Sudoku solution (non-duplication across rows, columns, and boxes)\n\n    >>> sudoku(initial_grid)  # doctest: +NORMALIZE_WHITESPACE\n    [[3, 1, 6, 5, 7, 8, 4, 9, 2],\n     [5, 2, 9, 1, 3, 4, 7, 6, 8],\n     [4, 8, 7, 6, 2, 9, 5, 3, 1],\n     [2, 6, 3, 4, 1, 5, 9, 8, 7],\n     [9, 7, 4, 8, 6, 3, 1, 2, 5],\n     [8, 5, 1, 7, 9, 2, 6, 4, 3],\n     [1, 3, 8, 9, 4, 7, 2, 5, 6],\n     [6, 9, 2, 3, 5, 1, 8, 7, 4],\n     [7, 4, 5, 2, 8, 6, 3, 1, 9]]\n     >>> sudoku(no_solution) is None\n     True\n    \"\"\"\n    if (location := find_empty_location(grid)):\n        (row, column) = location\n    else:\n        return grid\n    for digit in range(1, 10):\n        if is_safe(grid, row, column, digit):\n            grid[row][column] = digit\n            if sudoku(grid) is not None:\n                return grid\n            grid[row][column] = 0\n    return None\n'\\n    Takes a partially filled-in grid and attempts to assign values to\\n    all unassigned locations in such a way to meet the requirements\\n    for Sudoku solution (non-duplication across rows, columns, and boxes)\\n\\n    >>> sudoku(initial_grid)  # doctest: +NORMALIZE_WHITESPACE\\n    [[3, 1, 6, 5, 7, 8, 4, 9, 2],\\n     [5, 2, 9, 1, 3, 4, 7, 6, 8],\\n     [4, 8, 7, 6, 2, 9, 5, 3, 1],\\n     [2, 6, 3, 4, 1, 5, 9, 8, 7],\\n     [9, 7, 4, 8, 6, 3, 1, 2, 5],\\n     [8, 5, 1, 7, 9, 2, 6, 4, 3],\\n     [1, 3, 8, 9, 4, 7, 2, 5, 6],\\n     [6, 9, 2, 3, 5, 1, 8, 7, 4],\\n     [7, 4, 5, 2, 8, 6, 3, 1, 9]]\\n     >>> sudoku(no_solution) is None\\n     True\\n    '\n(location := find_empty_location(grid))"
    },
    {
      "id": "n24",
      "type": "block",
      "statements": [
        "(row, column) = location"
      ],
      "code": "(row, column) = location\n"
    },
    {
      "id": "n25",
      "type": "block",
      "statements": [
        "return grid"
      ],
      "code": "return grid"
    },
    {
      "id": "n26",
      "type": "block",
      "statements": [
        "digit",
        "range(1, 10)"
      ],
      "code": "digit\nrange(1, 10)"
    },
    {
      "id": "n27",
      "type": "block",
      "statements": [
        "is_safe(grid, row, column, digit)"
      ],
      "code": "is_safe(grid, row, column, digit)"
    },
    {
      "id": "n28",
      "type": "block",
      "statements": [
        "return None"
      ],
      "code": "return None"
    },
    {
      "id": "n29",
      "type": "block",
      "statements": [
        "grid[row][column] = digit",
        "sudoku(grid) IsNot None"
      ],
      "code": "grid[row][column] = digit\nsudoku(grid) IsNot None"
    },
    {
      "id": "n30",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n31",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n32",
      "type": "block",
      "statements": [
        "return grid"
      ],
      "code": "return grid"
    },
    {
      "id": "n33",
      "type": "block",
      "statements": [],
      "code": "\ngrid[row][column] = 0"
    },
    {
      "id": "n34",
      "type": "block",
      "statements": [
        "def print_solution(grid: Matrix) -> None:\n    \"\"\"\n    A function to print the solution in the form\n    of a 9x9 grid\n    \"\"\"\n    for row in grid:\n        for cell in row:\n            print(cell, end=' ')\n        print()",
        "'\\n    A function to print the solution in the form\\n    of a 9x9 grid\\n    '"
      ],
      "code": "def print_solution(grid: Matrix) -> None:\n    \"\"\"\n    A function to print the solution in the form\n    of a 9x9 grid\n    \"\"\"\n    for row in grid:\n        for cell in row:\n            print(cell, end=' ')\n        print()\n'\\n    A function to print the solution in the form\\n    of a 9x9 grid\\n    '"
    },
    {
      "id": "n35",
      "type": "block",
      "statements": [
        "row",
        "grid"
      ],
      "code": "row\ngrid"
    },
    {
      "id": "n36",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n37",
      "type": "block",
      "statements": [
        "__name__ Eq '__main__'"
      ],
      "code": "__name__ Eq '__main__'"
    },
    {
      "id": "n38",
      "type": "block",
      "statements": [
        "cell",
        "row"
      ],
      "code": "cell\nrow"
    },
    {
      "id": "n39",
      "type": "block",
      "statements": [
        "print(cell)"
      ],
      "code": "print(cell)"
    },
    {
      "id": "n40",
      "type": "block",
      "statements": [
        "print()"
      ],
      "code": "print()"
    },
    {
      "id": "n41",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n42",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n43",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n44",
      "type": "block",
      "statements": [
        "example_grid",
        "(initial_grid, no_solution)"
      ],
      "code": "example_grid\n(initial_grid, no_solution)"
    },
    {
      "id": "n45",
      "type": "block",
      "statements": [
        "print('\\nExample grid:\\n' Add '=' Mult 20)",
        "print_solution(example_grid)",
        "print('\\nExample grid solution:')",
        "solution = sudoku(example_grid)",
        "solution IsNot None"
      ],
      "code": "print('\\nExample grid:\\n' Add '=' Mult 20)\nprint_solution(example_grid)\nprint('\\nExample grid solution:')\nsolution = sudoku(example_grid)\nsolution IsNot None"
    },
    {
      "id": "n46",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n47",
      "type": "block",
      "statements": [
        "print_solution(solution)"
      ],
      "code": "print_solution(solution)"
    },
    {
      "id": "n48",
      "type": "block",
      "statements": [
        "print('Cannot find a solution.')"
      ],
      "code": "print('Cannot find a solution.')"
    },
    {
      "id": "n49",
      "type": "block",
      "statements": [],
      "code": ""
    }
  ],
  "edges": [
    {
      "source": "n38",
      "target": "n39"
    },
    {
      "source": "n37",
      "target": "n42"
    },
    {
      "source": "n6",
      "target": "n7"
    },
    {
      "source": "n14",
      "target": "n15"
    },
    {
      "source": "n0",
      "target": "n1"
    },
    {
      "source": "n13",
      "target": "n9"
    },
    {
      "source": "n29",
      "target": "n33"
    },
    {
      "source": "n23",
      "target": "n25"
    },
    {
      "source": "n47",
      "target": "n49"
    },
    {
      "source": "n35",
      "target": "n37"
    },
    {
      "source": "n33",
      "target": "n31"
    },
    {
      "source": "n44",
      "target": "n45"
    },
    {
      "source": "n34",
      "target": "n35"
    },
    {
      "source": "n26",
      "target": "n27"
    },
    {
      "source": "n19",
      "target": "n21"
    },
    {
      "source": "n39",
      "target": "n38"
    },
    {
      "source": "n23",
      "target": "n24"
    },
    {
      "source": "n29",
      "target": "n32"
    },
    {
      "source": "n35",
      "target": "n36"
    },
    {
      "source": "n49",
      "target": "n44"
    },
    {
      "source": "n2",
      "target": "n4"
    },
    {
      "source": "n31",
      "target": "n26"
    },
    {
      "source": "n16",
      "target": "n18"
    },
    {
      "source": "n1",
      "target": "n2"
    },
    {
      "source": "n46",
      "target": "n43"
    },
    {
      "source": "n42",
      "target": "n43"
    },
    {
      "source": "n30",
      "target": "n31"
    },
    {
      "source": "n15",
      "target": "n16"
    },
    {
      "source": "n20",
      "target": "n15"
    },
    {
      "source": "n37",
      "target": "n41"
    },
    {
      "source": "n9",
      "target": "n11"
    },
    {
      "source": "n19",
      "target": "n22"
    },
    {
      "source": "n22",
      "target": "n18"
    },
    {
      "source": "n44",
      "target": "n46"
    },
    {
      "source": "n36",
      "target": "n38"
    },
    {
      "source": "n11",
      "target": "n6"
    },
    {
      "source": "n40",
      "target": "n35"
    },
    {
      "source": "n9",
      "target": "n10"
    },
    {
      "source": "n45",
      "target": "n47"
    },
    {
      "source": "n10",
      "target": "n12"
    },
    {
      "source": "n27",
      "target": "n30"
    },
    {
      "source": "n18",
      "target": "n19"
    },
    {
      "source": "n45",
      "target": "n48"
    },
    {
      "source": "n7",
      "target": "n9"
    },
    {
      "source": "n38",
      "target": "n40"
    },
    {
      "source": "n18",
      "target": "n20"
    },
    {
      "source": "n26",
      "target": "n28"
    },
    {
      "source": "n1",
      "target": "n3"
    },
    {
      "source": "n24",
      "target": "n26"
    },
    {
      "source": "n27",
      "target": "n29"
    },
    {
      "source": "n2",
      "target": "n5"
    },
    {
      "source": "n3",
      "target": "n6"
    },
    {
      "source": "n41",
      "target": "n44"
    },
    {
      "source": "n10",
      "target": "n13"
    },
    {
      "source": "n6",
      "target": "n8"
    },
    {
      "source": "n5",
      "target": "n1"
    },
    {
      "source": "n48",
      "target": "n49"
    },
    {
      "source": "n15",
      "target": "n17"
    }
  ]
}