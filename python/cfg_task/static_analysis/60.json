{
  "nodes": [
    {
      "id": "n0",
      "type": "block",
      "statements": [
        "import json",
        "import os",
        "from enum import Enum",
        "from typing import Any, Dict, Generic, List, Set, Tuple, Type, TypeVar",
        "from pydantic import BaseModel, Field, PrivateAttr, ValidationInfo, field_validator",
        "from pydantic_settings import BaseSettings, JsonConfigSettingsSource, PydanticBaseSettingsSource, SettingsConfigDict",
        "from backend.util.data import get_data_path",
        "T = TypeVar('T', bound=BaseSettings)",
        "class AppEnvironment(str, Enum):\n    LOCAL = 'local'\n    DEVELOPMENT = 'dev'\n    PRODUCTION = 'prod'",
        "LOCAL = 'local'",
        "DEVELOPMENT = 'dev'",
        "PRODUCTION = 'prod'",
        "class BehaveAs(str, Enum):\n    LOCAL = 'local'\n    CLOUD = 'cloud'",
        "LOCAL = 'local'",
        "CLOUD = 'cloud'",
        "class UpdateTrackingModel(BaseModel, Generic[T]):\n    _updated_fields: Set[str] = PrivateAttr(default_factory=set)\n\n    def __setattr__(self, name: str, value) -> None:\n        if name in self.model_fields:\n            self._updated_fields.add(name)\n        super().__setattr__(name, value)\n\n    def mark_updated(self, field_name: str) -> None:\n        if field_name in self.model_fields:\n            self._updated_fields.add(field_name)\n\n    def clear_updates(self) -> None:\n        self._updated_fields.clear()\n\n    def get_updates(self) -> Dict[str, Any]:\n        return {field: getattr(self, field) for field in self._updated_fields}\n\n    @property\n    def updated_fields(self):\n        return self._updated_fields",
        "_updated_fields: Set[str] = PrivateAttr(default_factory=set)",
        "def __setattr__(self, name: str, value) -> None:\n    if name in self.model_fields:\n        self._updated_fields.add(name)\n    super().__setattr__(name, value)",
        "name In self.model_fields"
      ],
      "code": "import json\nimport os\nfrom enum import Enum\nfrom typing import Any, Dict, Generic, List, Set, Tuple, Type, TypeVar\nfrom pydantic import BaseModel, Field, PrivateAttr, ValidationInfo, field_validator\nfrom pydantic_settings import BaseSettings, JsonConfigSettingsSource, PydanticBaseSettingsSource, SettingsConfigDict\nfrom backend.util.data import get_data_path\nT = TypeVar('T', bound=BaseSettings)\nclass AppEnvironment(str, Enum):\n    LOCAL = 'local'\n    DEVELOPMENT = 'dev'\n    PRODUCTION = 'prod'\nLOCAL = 'local'\nDEVELOPMENT = 'dev'\nPRODUCTION = 'prod'\nclass BehaveAs(str, Enum):\n    LOCAL = 'local'\n    CLOUD = 'cloud'\nLOCAL = 'local'\nCLOUD = 'cloud'\nclass UpdateTrackingModel(BaseModel, Generic[T]):\n    _updated_fields: Set[str] = PrivateAttr(default_factory=set)\n\n    def __setattr__(self, name: str, value) -> None:\n        if name in self.model_fields:\n            self._updated_fields.add(name)\n        super().__setattr__(name, value)\n\n    def mark_updated(self, field_name: str) -> None:\n        if field_name in self.model_fields:\n            self._updated_fields.add(field_name)\n\n    def clear_updates(self) -> None:\n        self._updated_fields.clear()\n\n    def get_updates(self) -> Dict[str, Any]:\n        return {field: getattr(self, field) for field in self._updated_fields}\n\n    @property\n    def updated_fields(self):\n        return self._updated_fields\n_updated_fields: Set[str] = PrivateAttr(default_factory=set)\ndef __setattr__(self, name: str, value) -> None:\n    if name in self.model_fields:\n        self._updated_fields.add(name)\n    super().__setattr__(name, value)\nname In self.model_fields"
    },
    {
      "id": "n1",
      "type": "block",
      "statements": [
        "self._updated_fields.add(name)"
      ],
      "code": "self._updated_fields.add(name)"
    },
    {
      "id": "n2",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n3",
      "type": "block",
      "statements": [
        "super().__setattr__(name, value)",
        "def mark_updated(self, field_name: str) -> None:\n    if field_name in self.model_fields:\n        self._updated_fields.add(field_name)",
        "field_name In self.model_fields"
      ],
      "code": "super().__setattr__(name, value)\ndef mark_updated(self, field_name: str) -> None:\n    if field_name in self.model_fields:\n        self._updated_fields.add(field_name)\nfield_name In self.model_fields"
    },
    {
      "id": "n4",
      "type": "block",
      "statements": [
        "self._updated_fields.add(field_name)"
      ],
      "code": "self._updated_fields.add(field_name)"
    },
    {
      "id": "n5",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n6",
      "type": "block",
      "statements": [
        "def clear_updates(self) -> None:\n    self._updated_fields.clear()",
        "self._updated_fields.clear()",
        "def get_updates(self) -> Dict[str, Any]:\n    return {field: getattr(self, field) for field in self._updated_fields}",
        "return {field: getattr(self, field) for field in self._updated_fields}"
      ],
      "code": "def clear_updates(self) -> None:\n    self._updated_fields.clear()\nself._updated_fields.clear()\ndef get_updates(self) -> Dict[str, Any]:\n    return {field: getattr(self, field) for field in self._updated_fields}\nreturn {field: getattr(self, field) for field in self._updated_fields}"
    },
    {
      "id": "n7",
      "type": "block",
      "statements": [
        "@property\ndef updated_fields(self):\n    return self._updated_fields",
        "return self._updated_fields"
      ],
      "code": "@property\ndef updated_fields(self):\n    return self._updated_fields\nreturn self._updated_fields"
    },
    {
      "id": "n8",
      "type": "block",
      "statements": [
        "class Config(UpdateTrackingModel['Config'], BaseSettings):\n    \"\"\"Config for the server.\"\"\"\n    num_graph_workers: int = Field(default=10, ge=1, le=1000, description='Maximum number of workers to use for graph execution.')\n    num_node_workers: int = Field(default=5, ge=1, le=1000, description='Maximum number of workers to use for node execution within a single graph.')\n    pyro_host: str = Field(default='localhost', description='The default hostname of the Pyro server.')\n    pyro_client_comm_timeout: float = Field(default=15, description='The default timeout in seconds, for Pyro client connections.')\n    pyro_client_comm_retry: int = Field(default=3, description='The default number of retries for Pyro client connections.')\n    enable_auth: bool = Field(default=True, description='If authentication is enabled or not')\n    enable_credit: str = Field(default='false', description='If user credit system is enabled or not')\n    num_user_credits_refill: int = Field(default=1500, description='Number of credits to refill for each user')\n    model_config = SettingsConfigDict(env_file='.env', extra='allow')\n    websocket_server_host: str = Field(default='0.0.0.0', description='The host for the websocket server to run on')\n    websocket_server_port: int = Field(default=8001, description='The port for the websocket server to run on')\n    execution_manager_port: int = Field(default=8002, description='The port for execution manager daemon to run on')\n    execution_scheduler_port: int = Field(default=8003, description='The port for execution scheduler daemon to run on')\n    agent_server_port: int = Field(default=8004, description='The port for agent server daemon to run on')\n    database_api_port: int = Field(default=8005, description='The port for database server API to run on')\n    agent_api_host: str = Field(default='0.0.0.0', description='The host for agent server API to run on')\n    agent_api_port: int = Field(default=8006, description='The port for agent server API to run on')\n    platform_base_url: str = Field(default='', description=\"Must be set so the application knows where it's hosted at. This is necessary to make sure webhooks find their way.\")\n    frontend_base_url: str = Field(default='', description='Can be used to explicitly set the base URL for the frontend. This value is then used to generate redirect URLs for OAuth flows.')\n    media_gcs_bucket_name: str = Field(default='', description='The name of the Google Cloud Storage bucket for media files')\n\n    @field_validator('platform_base_url', 'frontend_base_url')\n    @classmethod\n    def validate_platform_base_url(cls, v: str, info: ValidationInfo) -> str:\n        if not v:\n            return v\n        if not v.startswith(('http://', 'https://')):\n            raise ValueError(f'{info.field_name} must be a full URL including a http:// or https:// schema')\n        if v.endswith('/'):\n            return v.rstrip('/')\n        return v\n    app_env: AppEnvironment = Field(default=AppEnvironment.LOCAL, description='The name of the app environment: local or dev or prod')\n    behave_as: BehaveAs = Field(default=BehaveAs.LOCAL, description='What environment to behave as: local or cloud')\n    execution_event_bus_name: str = Field(default='execution_event', description='Name of the event bus')\n    trust_endpoints_for_requests: List[str] = Field(default_factory=list, description='A whitelist of trusted internal endpoints for the backend to make requests to.')\n    backend_cors_allow_origins: List[str] = Field(default_factory=list)\n\n    @field_validator('backend_cors_allow_origins')\n    @classmethod\n    def validate_cors_allow_origins(cls, v: List[str]) -> List[str]:\n        out = []\n        port = None\n        has_localhost = False\n        has_127_0_0_1 = False\n        for url in v:\n            url = url.strip()\n            if url.startswith(('http://', 'https://')):\n                if 'localhost' in url:\n                    port = url.split(':')[2]\n                    has_localhost = True\n                if '127.0.0.1' in url:\n                    port = url.split(':')[2]\n                    has_127_0_0_1 = True\n                out.append(url)\n            else:\n                raise ValueError(f'Invalid URL: {url}')\n        if has_127_0_0_1 and (not has_localhost):\n            out.append(f'http://localhost:{port}')\n        if has_localhost and (not has_127_0_0_1):\n            out.append(f'http://127.0.0.1:{port}')\n        return out\n\n    @classmethod\n    def settings_customise_sources(cls, settings_cls: Type[BaseSettings], init_settings: PydanticBaseSettingsSource, env_settings: PydanticBaseSettingsSource, dotenv_settings: PydanticBaseSettingsSource, file_secret_settings: PydanticBaseSettingsSource) -> Tuple[PydanticBaseSettingsSource, ...]:\n        return (env_settings, file_secret_settings, dotenv_settings, JsonConfigSettingsSource(settings_cls), init_settings)",
        "'Config for the server.'",
        "num_graph_workers: int = Field(default=10, ge=1, le=1000, description='Maximum number of workers to use for graph execution.')",
        "num_node_workers: int = Field(default=5, ge=1, le=1000, description='Maximum number of workers to use for node execution within a single graph.')",
        "pyro_host: str = Field(default='localhost', description='The default hostname of the Pyro server.')",
        "pyro_client_comm_timeout: float = Field(default=15, description='The default timeout in seconds, for Pyro client connections.')",
        "pyro_client_comm_retry: int = Field(default=3, description='The default number of retries for Pyro client connections.')",
        "enable_auth: bool = Field(default=True, description='If authentication is enabled or not')",
        "enable_credit: str = Field(default='false', description='If user credit system is enabled or not')",
        "num_user_credits_refill: int = Field(default=1500, description='Number of credits to refill for each user')",
        "model_config = SettingsConfigDict(env_file='.env', extra='allow')",
        "websocket_server_host: str = Field(default='0.0.0.0', description='The host for the websocket server to run on')",
        "websocket_server_port: int = Field(default=8001, description='The port for the websocket server to run on')",
        "execution_manager_port: int = Field(default=8002, description='The port for execution manager daemon to run on')",
        "execution_scheduler_port: int = Field(default=8003, description='The port for execution scheduler daemon to run on')",
        "agent_server_port: int = Field(default=8004, description='The port for agent server daemon to run on')",
        "database_api_port: int = Field(default=8005, description='The port for database server API to run on')",
        "agent_api_host: str = Field(default='0.0.0.0', description='The host for agent server API to run on')",
        "agent_api_port: int = Field(default=8006, description='The port for agent server API to run on')",
        "platform_base_url: str = Field(default='', description=\"Must be set so the application knows where it's hosted at. This is necessary to make sure webhooks find their way.\")",
        "frontend_base_url: str = Field(default='', description='Can be used to explicitly set the base URL for the frontend. This value is then used to generate redirect URLs for OAuth flows.')",
        "media_gcs_bucket_name: str = Field(default='', description='The name of the Google Cloud Storage bucket for media files')",
        "@field_validator('platform_base_url', 'frontend_base_url')\n@classmethod\ndef validate_platform_base_url(cls, v: str, info: ValidationInfo) -> str:\n    if not v:\n        return v\n    if not v.startswith(('http://', 'https://')):\n        raise ValueError(f'{info.field_name} must be a full URL including a http:// or https:// schema')\n    if v.endswith('/'):\n        return v.rstrip('/')\n    return v",
        "not v"
      ],
      "code": "class Config(UpdateTrackingModel['Config'], BaseSettings):\n    \"\"\"Config for the server.\"\"\"\n    num_graph_workers: int = Field(default=10, ge=1, le=1000, description='Maximum number of workers to use for graph execution.')\n    num_node_workers: int = Field(default=5, ge=1, le=1000, description='Maximum number of workers to use for node execution within a single graph.')\n    pyro_host: str = Field(default='localhost', description='The default hostname of the Pyro server.')\n    pyro_client_comm_timeout: float = Field(default=15, description='The default timeout in seconds, for Pyro client connections.')\n    pyro_client_comm_retry: int = Field(default=3, description='The default number of retries for Pyro client connections.')\n    enable_auth: bool = Field(default=True, description='If authentication is enabled or not')\n    enable_credit: str = Field(default='false', description='If user credit system is enabled or not')\n    num_user_credits_refill: int = Field(default=1500, description='Number of credits to refill for each user')\n    model_config = SettingsConfigDict(env_file='.env', extra='allow')\n    websocket_server_host: str = Field(default='0.0.0.0', description='The host for the websocket server to run on')\n    websocket_server_port: int = Field(default=8001, description='The port for the websocket server to run on')\n    execution_manager_port: int = Field(default=8002, description='The port for execution manager daemon to run on')\n    execution_scheduler_port: int = Field(default=8003, description='The port for execution scheduler daemon to run on')\n    agent_server_port: int = Field(default=8004, description='The port for agent server daemon to run on')\n    database_api_port: int = Field(default=8005, description='The port for database server API to run on')\n    agent_api_host: str = Field(default='0.0.0.0', description='The host for agent server API to run on')\n    agent_api_port: int = Field(default=8006, description='The port for agent server API to run on')\n    platform_base_url: str = Field(default='', description=\"Must be set so the application knows where it's hosted at. This is necessary to make sure webhooks find their way.\")\n    frontend_base_url: str = Field(default='', description='Can be used to explicitly set the base URL for the frontend. This value is then used to generate redirect URLs for OAuth flows.')\n    media_gcs_bucket_name: str = Field(default='', description='The name of the Google Cloud Storage bucket for media files')\n\n    @field_validator('platform_base_url', 'frontend_base_url')\n    @classmethod\n    def validate_platform_base_url(cls, v: str, info: ValidationInfo) -> str:\n        if not v:\n            return v\n        if not v.startswith(('http://', 'https://')):\n            raise ValueError(f'{info.field_name} must be a full URL including a http:// or https:// schema')\n        if v.endswith('/'):\n            return v.rstrip('/')\n        return v\n    app_env: AppEnvironment = Field(default=AppEnvironment.LOCAL, description='The name of the app environment: local or dev or prod')\n    behave_as: BehaveAs = Field(default=BehaveAs.LOCAL, description='What environment to behave as: local or cloud')\n    execution_event_bus_name: str = Field(default='execution_event', description='Name of the event bus')\n    trust_endpoints_for_requests: List[str] = Field(default_factory=list, description='A whitelist of trusted internal endpoints for the backend to make requests to.')\n    backend_cors_allow_origins: List[str] = Field(default_factory=list)\n\n    @field_validator('backend_cors_allow_origins')\n    @classmethod\n    def validate_cors_allow_origins(cls, v: List[str]) -> List[str]:\n        out = []\n        port = None\n        has_localhost = False\n        has_127_0_0_1 = False\n        for url in v:\n            url = url.strip()\n            if url.startswith(('http://', 'https://')):\n                if 'localhost' in url:\n                    port = url.split(':')[2]\n                    has_localhost = True\n                if '127.0.0.1' in url:\n                    port = url.split(':')[2]\n                    has_127_0_0_1 = True\n                out.append(url)\n            else:\n                raise ValueError(f'Invalid URL: {url}')\n        if has_127_0_0_1 and (not has_localhost):\n            out.append(f'http://localhost:{port}')\n        if has_localhost and (not has_127_0_0_1):\n            out.append(f'http://127.0.0.1:{port}')\n        return out\n\n    @classmethod\n    def settings_customise_sources(cls, settings_cls: Type[BaseSettings], init_settings: PydanticBaseSettingsSource, env_settings: PydanticBaseSettingsSource, dotenv_settings: PydanticBaseSettingsSource, file_secret_settings: PydanticBaseSettingsSource) -> Tuple[PydanticBaseSettingsSource, ...]:\n        return (env_settings, file_secret_settings, dotenv_settings, JsonConfigSettingsSource(settings_cls), init_settings)\n'Config for the server.'\nnum_graph_workers: int = Field(default=10, ge=1, le=1000, description='Maximum number of workers to use for graph execution.')\nnum_node_workers: int = Field(default=5, ge=1, le=1000, description='Maximum number of workers to use for node execution within a single graph.')\npyro_host: str = Field(default='localhost', description='The default hostname of the Pyro server.')\npyro_client_comm_timeout: float = Field(default=15, description='The default timeout in seconds, for Pyro client connections.')\npyro_client_comm_retry: int = Field(default=3, description='The default number of retries for Pyro client connections.')\nenable_auth: bool = Field(default=True, description='If authentication is enabled or not')\nenable_credit: str = Field(default='false', description='If user credit system is enabled or not')\nnum_user_credits_refill: int = Field(default=1500, description='Number of credits to refill for each user')\nmodel_config = SettingsConfigDict(env_file='.env', extra='allow')\nwebsocket_server_host: str = Field(default='0.0.0.0', description='The host for the websocket server to run on')\nwebsocket_server_port: int = Field(default=8001, description='The port for the websocket server to run on')\nexecution_manager_port: int = Field(default=8002, description='The port for execution manager daemon to run on')\nexecution_scheduler_port: int = Field(default=8003, description='The port for execution scheduler daemon to run on')\nagent_server_port: int = Field(default=8004, description='The port for agent server daemon to run on')\ndatabase_api_port: int = Field(default=8005, description='The port for database server API to run on')\nagent_api_host: str = Field(default='0.0.0.0', description='The host for agent server API to run on')\nagent_api_port: int = Field(default=8006, description='The port for agent server API to run on')\nplatform_base_url: str = Field(default='', description=\"Must be set so the application knows where it's hosted at. This is necessary to make sure webhooks find their way.\")\nfrontend_base_url: str = Field(default='', description='Can be used to explicitly set the base URL for the frontend. This value is then used to generate redirect URLs for OAuth flows.')\nmedia_gcs_bucket_name: str = Field(default='', description='The name of the Google Cloud Storage bucket for media files')\n@field_validator('platform_base_url', 'frontend_base_url')\n@classmethod\ndef validate_platform_base_url(cls, v: str, info: ValidationInfo) -> str:\n    if not v:\n        return v\n    if not v.startswith(('http://', 'https://')):\n        raise ValueError(f'{info.field_name} must be a full URL including a http:// or https:// schema')\n    if v.endswith('/'):\n        return v.rstrip('/')\n    return v\nnot v"
    },
    {
      "id": "n9",
      "type": "block",
      "statements": [
        "return v"
      ],
      "code": "return v"
    },
    {
      "id": "n10",
      "type": "block",
      "statements": [],
      "code": "\nnot v.startswith(('http://', 'https://'))"
    },
    {
      "id": "n11",
      "type": "block",
      "statements": [
        "raise ValueError(f'{info.field_name} must be a full URL including a http:// or https:// schema')"
      ],
      "code": "raise ValueError(f'{info.field_name} must be a full URL including a http:// or https:// schema')"
    },
    {
      "id": "n12",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n13",
      "type": "block",
      "statements": [
        "v.endswith('/')"
      ],
      "code": "v.endswith('/')"
    },
    {
      "id": "n14",
      "type": "block",
      "statements": [
        "return v.rstrip('/')"
      ],
      "code": "return v.rstrip('/')"
    },
    {
      "id": "n15",
      "type": "block",
      "statements": [],
      "code": "\nreturn v"
    },
    {
      "id": "n16",
      "type": "block",
      "statements": [
        "app_env: AppEnvironment = Field(default=AppEnvironment.LOCAL, description='The name of the app environment: local or dev or prod')",
        "behave_as: BehaveAs = Field(default=BehaveAs.LOCAL, description='What environment to behave as: local or cloud')",
        "execution_event_bus_name: str = Field(default='execution_event', description='Name of the event bus')",
        "trust_endpoints_for_requests: List[str] = Field(default_factory=list, description='A whitelist of trusted internal endpoints for the backend to make requests to.')",
        "backend_cors_allow_origins: List[str] = Field(default_factory=list)",
        "@field_validator('backend_cors_allow_origins')\n@classmethod\ndef validate_cors_allow_origins(cls, v: List[str]) -> List[str]:\n    out = []\n    port = None\n    has_localhost = False\n    has_127_0_0_1 = False\n    for url in v:\n        url = url.strip()\n        if url.startswith(('http://', 'https://')):\n            if 'localhost' in url:\n                port = url.split(':')[2]\n                has_localhost = True\n            if '127.0.0.1' in url:\n                port = url.split(':')[2]\n                has_127_0_0_1 = True\n            out.append(url)\n        else:\n            raise ValueError(f'Invalid URL: {url}')\n    if has_127_0_0_1 and (not has_localhost):\n        out.append(f'http://localhost:{port}')\n    if has_localhost and (not has_127_0_0_1):\n        out.append(f'http://127.0.0.1:{port}')\n    return out",
        "out = []",
        "port = None",
        "has_localhost = False",
        "has_127_0_0_1 = False"
      ],
      "code": "app_env: AppEnvironment = Field(default=AppEnvironment.LOCAL, description='The name of the app environment: local or dev or prod')\nbehave_as: BehaveAs = Field(default=BehaveAs.LOCAL, description='What environment to behave as: local or cloud')\nexecution_event_bus_name: str = Field(default='execution_event', description='Name of the event bus')\ntrust_endpoints_for_requests: List[str] = Field(default_factory=list, description='A whitelist of trusted internal endpoints for the backend to make requests to.')\nbackend_cors_allow_origins: List[str] = Field(default_factory=list)\n@field_validator('backend_cors_allow_origins')\n@classmethod\ndef validate_cors_allow_origins(cls, v: List[str]) -> List[str]:\n    out = []\n    port = None\n    has_localhost = False\n    has_127_0_0_1 = False\n    for url in v:\n        url = url.strip()\n        if url.startswith(('http://', 'https://')):\n            if 'localhost' in url:\n                port = url.split(':')[2]\n                has_localhost = True\n            if '127.0.0.1' in url:\n                port = url.split(':')[2]\n                has_127_0_0_1 = True\n            out.append(url)\n        else:\n            raise ValueError(f'Invalid URL: {url}')\n    if has_127_0_0_1 and (not has_localhost):\n        out.append(f'http://localhost:{port}')\n    if has_localhost and (not has_127_0_0_1):\n        out.append(f'http://127.0.0.1:{port}')\n    return out\nout = []\nport = None\nhas_localhost = False\nhas_127_0_0_1 = False"
    },
    {
      "id": "n17",
      "type": "block",
      "statements": [
        "url",
        "v"
      ],
      "code": "url\nv"
    },
    {
      "id": "n18",
      "type": "block",
      "statements": [
        "url = url.strip()",
        "url.startswith(('http://', 'https://'))"
      ],
      "code": "url = url.strip()\nurl.startswith(('http://', 'https://'))"
    },
    {
      "id": "n19",
      "type": "block",
      "statements": [
        "has_127_0_0_1 and (not has_localhost)"
      ],
      "code": "has_127_0_0_1 and (not has_localhost)"
    },
    {
      "id": "n20",
      "type": "block",
      "statements": [
        "'localhost' In url"
      ],
      "code": "'localhost' In url"
    },
    {
      "id": "n21",
      "type": "block",
      "statements": [
        "raise ValueError(f'Invalid URL: {url}')"
      ],
      "code": "raise ValueError(f'Invalid URL: {url}')"
    },
    {
      "id": "n22",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n23",
      "type": "block",
      "statements": [
        "port = url.split(':')[2]",
        "has_localhost = True"
      ],
      "code": "port = url.split(':')[2]\nhas_localhost = True"
    },
    {
      "id": "n24",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n25",
      "type": "block",
      "statements": [
        "'127.0.0.1' In url"
      ],
      "code": "'127.0.0.1' In url"
    },
    {
      "id": "n26",
      "type": "block",
      "statements": [
        "port = url.split(':')[2]",
        "has_127_0_0_1 = True"
      ],
      "code": "port = url.split(':')[2]\nhas_127_0_0_1 = True"
    },
    {
      "id": "n27",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n28",
      "type": "block",
      "statements": [
        "out.append(url)"
      ],
      "code": "out.append(url)"
    },
    {
      "id": "n29",
      "type": "block",
      "statements": [
        "out.append(f'http://localhost:{port}')"
      ],
      "code": "out.append(f'http://localhost:{port}')"
    },
    {
      "id": "n30",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n31",
      "type": "block",
      "statements": [
        "has_localhost and (not has_127_0_0_1)"
      ],
      "code": "has_localhost and (not has_127_0_0_1)"
    },
    {
      "id": "n32",
      "type": "block",
      "statements": [
        "out.append(f'http://127.0.0.1:{port}')"
      ],
      "code": "out.append(f'http://127.0.0.1:{port}')"
    },
    {
      "id": "n33",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n34",
      "type": "block",
      "statements": [
        "return out"
      ],
      "code": "return out"
    },
    {
      "id": "n35",
      "type": "block",
      "statements": [
        "@classmethod\ndef settings_customise_sources(cls, settings_cls: Type[BaseSettings], init_settings: PydanticBaseSettingsSource, env_settings: PydanticBaseSettingsSource, dotenv_settings: PydanticBaseSettingsSource, file_secret_settings: PydanticBaseSettingsSource) -> Tuple[PydanticBaseSettingsSource, ...]:\n    return (env_settings, file_secret_settings, dotenv_settings, JsonConfigSettingsSource(settings_cls), init_settings)",
        "return (env_settings, file_secret_settings, dotenv_settings, JsonConfigSettingsSource(settings_cls), init_settings)"
      ],
      "code": "@classmethod\ndef settings_customise_sources(cls, settings_cls: Type[BaseSettings], init_settings: PydanticBaseSettingsSource, env_settings: PydanticBaseSettingsSource, dotenv_settings: PydanticBaseSettingsSource, file_secret_settings: PydanticBaseSettingsSource) -> Tuple[PydanticBaseSettingsSource, ...]:\n    return (env_settings, file_secret_settings, dotenv_settings, JsonConfigSettingsSource(settings_cls), init_settings)\nreturn (env_settings, file_secret_settings, dotenv_settings, JsonConfigSettingsSource(settings_cls), init_settings)"
    },
    {
      "id": "n36",
      "type": "block",
      "statements": [
        "class Secrets(UpdateTrackingModel['Secrets'], BaseSettings):\n    \"\"\"Secrets for the server.\"\"\"\n    supabase_url: str = Field(default='', description='Supabase URL')\n    supabase_service_role_key: str = Field(default='', description='Supabase service role key')\n    encryption_key: str = Field(default='', description='Encryption key')\n    github_client_id: str = Field(default='', description='GitHub OAuth client ID')\n    github_client_secret: str = Field(default='', description='GitHub OAuth client secret')\n    google_client_id: str = Field(default='', description='Google OAuth client ID')\n    google_client_secret: str = Field(default='', description='Google OAuth client secret')\n    notion_client_id: str = Field(default='', description='Notion OAuth client ID')\n    notion_client_secret: str = Field(default='', description='Notion OAuth client secret')\n    openai_api_key: str = Field(default='', description='OpenAI API key')\n    anthropic_api_key: str = Field(default='', description='Anthropic API key')\n    groq_api_key: str = Field(default='', description='Groq API key')\n    open_router_api_key: str = Field(default='', description='Open Router API Key')\n    reddit_client_id: str = Field(default='', description='Reddit client ID')\n    reddit_client_secret: str = Field(default='', description='Reddit client secret')\n    reddit_username: str = Field(default='', description='Reddit username')\n    reddit_password: str = Field(default='', description='Reddit password')\n    openweathermap_api_key: str = Field(default='', description='OpenWeatherMap API key')\n    medium_api_key: str = Field(default='', description='Medium API key')\n    medium_author_id: str = Field(default='', description='Medium author ID')\n    did_api_key: str = Field(default='', description='D-ID API Key')\n    revid_api_key: str = Field(default='', description='revid.ai API key')\n    discord_bot_token: str = Field(default='', description='Discord bot token')\n    smtp_server: str = Field(default='', description='SMTP server IP')\n    smtp_port: str = Field(default='', description='SMTP server port')\n    smtp_username: str = Field(default='', description='SMTP username')\n    smtp_password: str = Field(default='', description='SMTP password')\n    sentry_dsn: str = Field(default='', description='Sentry DSN')\n    google_maps_api_key: str = Field(default='', description='Google Maps API Key')\n    replicate_api_key: str = Field(default='', description='Replicate API Key')\n    unreal_speech_api_key: str = Field(default='', description='Unreal Speech API Key')\n    ideogram_api_key: str = Field(default='', description='Ideogram API Key')\n    jina_api_key: str = Field(default='', description='Jina API Key')\n    unreal_speech_api_key: str = Field(default='', description='Unreal Speech API Key')\n    fal_key: str = Field(default='', description='FAL API key')\n    model_config = SettingsConfigDict(env_file='.env', env_file_encoding='utf-8', extra='allow')",
        "'Secrets for the server.'",
        "supabase_url: str = Field(default='', description='Supabase URL')",
        "supabase_service_role_key: str = Field(default='', description='Supabase service role key')",
        "encryption_key: str = Field(default='', description='Encryption key')",
        "github_client_id: str = Field(default='', description='GitHub OAuth client ID')",
        "github_client_secret: str = Field(default='', description='GitHub OAuth client secret')",
        "google_client_id: str = Field(default='', description='Google OAuth client ID')",
        "google_client_secret: str = Field(default='', description='Google OAuth client secret')",
        "notion_client_id: str = Field(default='', description='Notion OAuth client ID')",
        "notion_client_secret: str = Field(default='', description='Notion OAuth client secret')",
        "openai_api_key: str = Field(default='', description='OpenAI API key')",
        "anthropic_api_key: str = Field(default='', description='Anthropic API key')",
        "groq_api_key: str = Field(default='', description='Groq API key')",
        "open_router_api_key: str = Field(default='', description='Open Router API Key')",
        "reddit_client_id: str = Field(default='', description='Reddit client ID')",
        "reddit_client_secret: str = Field(default='', description='Reddit client secret')",
        "reddit_username: str = Field(default='', description='Reddit username')",
        "reddit_password: str = Field(default='', description='Reddit password')",
        "openweathermap_api_key: str = Field(default='', description='OpenWeatherMap API key')",
        "medium_api_key: str = Field(default='', description='Medium API key')",
        "medium_author_id: str = Field(default='', description='Medium author ID')",
        "did_api_key: str = Field(default='', description='D-ID API Key')",
        "revid_api_key: str = Field(default='', description='revid.ai API key')",
        "discord_bot_token: str = Field(default='', description='Discord bot token')",
        "smtp_server: str = Field(default='', description='SMTP server IP')",
        "smtp_port: str = Field(default='', description='SMTP server port')",
        "smtp_username: str = Field(default='', description='SMTP username')",
        "smtp_password: str = Field(default='', description='SMTP password')",
        "sentry_dsn: str = Field(default='', description='Sentry DSN')",
        "google_maps_api_key: str = Field(default='', description='Google Maps API Key')",
        "replicate_api_key: str = Field(default='', description='Replicate API Key')",
        "unreal_speech_api_key: str = Field(default='', description='Unreal Speech API Key')",
        "ideogram_api_key: str = Field(default='', description='Ideogram API Key')",
        "jina_api_key: str = Field(default='', description='Jina API Key')",
        "unreal_speech_api_key: str = Field(default='', description='Unreal Speech API Key')",
        "fal_key: str = Field(default='', description='FAL API key')",
        "model_config = SettingsConfigDict(env_file='.env', env_file_encoding='utf-8', extra='allow')",
        "class Settings(BaseModel):\n    config: Config = Config()\n    secrets: Secrets = Secrets()\n\n    def save(self) -> None:\n        if self.config.updated_fields:\n            config_to_save = self.config.get_updates()\n            config_path = os.path.join(get_data_path(), 'config.json')\n            if os.path.exists(config_path):\n                with open(config_path, 'r+') as f:\n                    existing_config: Dict[str, Any] = json.load(f)\n                    existing_config.update(config_to_save)\n                    f.seek(0)\n                    json.dump(existing_config, f, indent=2)\n                    f.truncate()\n            else:\n                with open(config_path, 'w') as f:\n                    json.dump(config_to_save, f, indent=2)\n            self.config.clear_updates()",
        "config: Config = Config()",
        "secrets: Secrets = Secrets()",
        "def save(self) -> None:\n    if self.config.updated_fields:\n        config_to_save = self.config.get_updates()\n        config_path = os.path.join(get_data_path(), 'config.json')\n        if os.path.exists(config_path):\n            with open(config_path, 'r+') as f:\n                existing_config: Dict[str, Any] = json.load(f)\n                existing_config.update(config_to_save)\n                f.seek(0)\n                json.dump(existing_config, f, indent=2)\n                f.truncate()\n        else:\n            with open(config_path, 'w') as f:\n                json.dump(config_to_save, f, indent=2)\n        self.config.clear_updates()",
        "self.config.updated_fields"
      ],
      "code": "class Secrets(UpdateTrackingModel['Secrets'], BaseSettings):\n    \"\"\"Secrets for the server.\"\"\"\n    supabase_url: str = Field(default='', description='Supabase URL')\n    supabase_service_role_key: str = Field(default='', description='Supabase service role key')\n    encryption_key: str = Field(default='', description='Encryption key')\n    github_client_id: str = Field(default='', description='GitHub OAuth client ID')\n    github_client_secret: str = Field(default='', description='GitHub OAuth client secret')\n    google_client_id: str = Field(default='', description='Google OAuth client ID')\n    google_client_secret: str = Field(default='', description='Google OAuth client secret')\n    notion_client_id: str = Field(default='', description='Notion OAuth client ID')\n    notion_client_secret: str = Field(default='', description='Notion OAuth client secret')\n    openai_api_key: str = Field(default='', description='OpenAI API key')\n    anthropic_api_key: str = Field(default='', description='Anthropic API key')\n    groq_api_key: str = Field(default='', description='Groq API key')\n    open_router_api_key: str = Field(default='', description='Open Router API Key')\n    reddit_client_id: str = Field(default='', description='Reddit client ID')\n    reddit_client_secret: str = Field(default='', description='Reddit client secret')\n    reddit_username: str = Field(default='', description='Reddit username')\n    reddit_password: str = Field(default='', description='Reddit password')\n    openweathermap_api_key: str = Field(default='', description='OpenWeatherMap API key')\n    medium_api_key: str = Field(default='', description='Medium API key')\n    medium_author_id: str = Field(default='', description='Medium author ID')\n    did_api_key: str = Field(default='', description='D-ID API Key')\n    revid_api_key: str = Field(default='', description='revid.ai API key')\n    discord_bot_token: str = Field(default='', description='Discord bot token')\n    smtp_server: str = Field(default='', description='SMTP server IP')\n    smtp_port: str = Field(default='', description='SMTP server port')\n    smtp_username: str = Field(default='', description='SMTP username')\n    smtp_password: str = Field(default='', description='SMTP password')\n    sentry_dsn: str = Field(default='', description='Sentry DSN')\n    google_maps_api_key: str = Field(default='', description='Google Maps API Key')\n    replicate_api_key: str = Field(default='', description='Replicate API Key')\n    unreal_speech_api_key: str = Field(default='', description='Unreal Speech API Key')\n    ideogram_api_key: str = Field(default='', description='Ideogram API Key')\n    jina_api_key: str = Field(default='', description='Jina API Key')\n    unreal_speech_api_key: str = Field(default='', description='Unreal Speech API Key')\n    fal_key: str = Field(default='', description='FAL API key')\n    model_config = SettingsConfigDict(env_file='.env', env_file_encoding='utf-8', extra='allow')\n'Secrets for the server.'\nsupabase_url: str = Field(default='', description='Supabase URL')\nsupabase_service_role_key: str = Field(default='', description='Supabase service role key')\nencryption_key: str = Field(default='', description='Encryption key')\ngithub_client_id: str = Field(default='', description='GitHub OAuth client ID')\ngithub_client_secret: str = Field(default='', description='GitHub OAuth client secret')\ngoogle_client_id: str = Field(default='', description='Google OAuth client ID')\ngoogle_client_secret: str = Field(default='', description='Google OAuth client secret')\nnotion_client_id: str = Field(default='', description='Notion OAuth client ID')\nnotion_client_secret: str = Field(default='', description='Notion OAuth client secret')\nopenai_api_key: str = Field(default='', description='OpenAI API key')\nanthropic_api_key: str = Field(default='', description='Anthropic API key')\ngroq_api_key: str = Field(default='', description='Groq API key')\nopen_router_api_key: str = Field(default='', description='Open Router API Key')\nreddit_client_id: str = Field(default='', description='Reddit client ID')\nreddit_client_secret: str = Field(default='', description='Reddit client secret')\nreddit_username: str = Field(default='', description='Reddit username')\nreddit_password: str = Field(default='', description='Reddit password')\nopenweathermap_api_key: str = Field(default='', description='OpenWeatherMap API key')\nmedium_api_key: str = Field(default='', description='Medium API key')\nmedium_author_id: str = Field(default='', description='Medium author ID')\ndid_api_key: str = Field(default='', description='D-ID API Key')\nrevid_api_key: str = Field(default='', description='revid.ai API key')\ndiscord_bot_token: str = Field(default='', description='Discord bot token')\nsmtp_server: str = Field(default='', description='SMTP server IP')\nsmtp_port: str = Field(default='', description='SMTP server port')\nsmtp_username: str = Field(default='', description='SMTP username')\nsmtp_password: str = Field(default='', description='SMTP password')\nsentry_dsn: str = Field(default='', description='Sentry DSN')\ngoogle_maps_api_key: str = Field(default='', description='Google Maps API Key')\nreplicate_api_key: str = Field(default='', description='Replicate API Key')\nunreal_speech_api_key: str = Field(default='', description='Unreal Speech API Key')\nideogram_api_key: str = Field(default='', description='Ideogram API Key')\njina_api_key: str = Field(default='', description='Jina API Key')\nunreal_speech_api_key: str = Field(default='', description='Unreal Speech API Key')\nfal_key: str = Field(default='', description='FAL API key')\nmodel_config = SettingsConfigDict(env_file='.env', env_file_encoding='utf-8', extra='allow')\nclass Settings(BaseModel):\n    config: Config = Config()\n    secrets: Secrets = Secrets()\n\n    def save(self) -> None:\n        if self.config.updated_fields:\n            config_to_save = self.config.get_updates()\n            config_path = os.path.join(get_data_path(), 'config.json')\n            if os.path.exists(config_path):\n                with open(config_path, 'r+') as f:\n                    existing_config: Dict[str, Any] = json.load(f)\n                    existing_config.update(config_to_save)\n                    f.seek(0)\n                    json.dump(existing_config, f, indent=2)\n                    f.truncate()\n            else:\n                with open(config_path, 'w') as f:\n                    json.dump(config_to_save, f, indent=2)\n            self.config.clear_updates()\nconfig: Config = Config()\nsecrets: Secrets = Secrets()\ndef save(self) -> None:\n    if self.config.updated_fields:\n        config_to_save = self.config.get_updates()\n        config_path = os.path.join(get_data_path(), 'config.json')\n        if os.path.exists(config_path):\n            with open(config_path, 'r+') as f:\n                existing_config: Dict[str, Any] = json.load(f)\n                existing_config.update(config_to_save)\n                f.seek(0)\n                json.dump(existing_config, f, indent=2)\n                f.truncate()\n        else:\n            with open(config_path, 'w') as f:\n                json.dump(config_to_save, f, indent=2)\n        self.config.clear_updates()\nself.config.updated_fields"
    },
    {
      "id": "n37",
      "type": "block",
      "statements": [
        "config_to_save = self.config.get_updates()",
        "config_path = os.path.join(get_data_path(), 'config.json')",
        "os.path.exists(config_path)"
      ],
      "code": "config_to_save = self.config.get_updates()\nconfig_path = os.path.join(get_data_path(), 'config.json')\nos.path.exists(config_path)"
    },
    {
      "id": "n38",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n39",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n40",
      "type": "block",
      "statements": [
        "with open(config_path, 'r+') as f:\n    existing_config: Dict[str, Any] = json.load(f)\n    existing_config.update(config_to_save)\n    f.seek(0)\n    json.dump(existing_config, f, indent=2)\n    f.truncate()",
        "existing_config: Dict[str, Any] = json.load(f)",
        "existing_config.update(config_to_save)",
        "f.seek(0)",
        "json.dump(existing_config, f)",
        "f.truncate()"
      ],
      "code": "with open(config_path, 'r+') as f:\n    existing_config: Dict[str, Any] = json.load(f)\n    existing_config.update(config_to_save)\n    f.seek(0)\n    json.dump(existing_config, f, indent=2)\n    f.truncate()\nexisting_config: Dict[str, Any] = json.load(f)\nexisting_config.update(config_to_save)\nf.seek(0)\njson.dump(existing_config, f)\nf.truncate()"
    },
    {
      "id": "n41",
      "type": "block",
      "statements": [
        "with open(config_path, 'w') as f:\n    json.dump(config_to_save, f, indent=2)",
        "json.dump(config_to_save, f)"
      ],
      "code": "with open(config_path, 'w') as f:\n    json.dump(config_to_save, f, indent=2)\njson.dump(config_to_save, f)"
    },
    {
      "id": "n42",
      "type": "block",
      "statements": [
        "self.config.clear_updates()"
      ],
      "code": "self.config.clear_updates()"
    }
  ],
  "edges": [
    {
      "source": "n38",
      "target": "n39"
    },
    {
      "source": "n0",
      "target": "n1"
    },
    {
      "source": "n17",
      "target": "n18"
    },
    {
      "source": "n23",
      "target": "n25"
    },
    {
      "source": "n21",
      "target": "n22"
    },
    {
      "source": "n10",
      "target": "n11"
    },
    {
      "source": "n17",
      "target": "n19"
    },
    {
      "source": "n19",
      "target": "n30"
    },
    {
      "source": "n2",
      "target": "n3"
    },
    {
      "source": "n13",
      "target": "n14"
    },
    {
      "source": "n20",
      "target": "n23"
    },
    {
      "source": "n19",
      "target": "n29"
    },
    {
      "source": "n16",
      "target": "n17"
    },
    {
      "source": "n13",
      "target": "n15"
    },
    {
      "source": "n8",
      "target": "n9"
    },
    {
      "source": "n42",
      "target": "n39"
    },
    {
      "source": "n37",
      "target": "n40"
    },
    {
      "source": "n3",
      "target": "n4"
    },
    {
      "source": "n41",
      "target": "n42"
    },
    {
      "source": "n4",
      "target": "n6"
    },
    {
      "source": "n12",
      "target": "n13"
    },
    {
      "source": "n24",
      "target": "n25"
    },
    {
      "source": "n30",
      "target": "n31"
    },
    {
      "source": "n31",
      "target": "n33"
    },
    {
      "source": "n22",
      "target": "n17"
    },
    {
      "source": "n37",
      "target": "n41"
    },
    {
      "source": "n36",
      "target": "n38"
    },
    {
      "source": "n18",
      "target": "n21"
    },
    {
      "source": "n31",
      "target": "n32"
    },
    {
      "source": "n10",
      "target": "n12"
    },
    {
      "source": "n29",
      "target": "n31"
    },
    {
      "source": "n5",
      "target": "n6"
    },
    {
      "source": "n25",
      "target": "n26"
    },
    {
      "source": "n18",
      "target": "n20"
    },
    {
      "source": "n26",
      "target": "n28"
    },
    {
      "source": "n1",
      "target": "n3"
    },
    {
      "source": "n40",
      "target": "n42"
    },
    {
      "source": "n27",
      "target": "n28"
    },
    {
      "source": "n8",
      "target": "n10"
    },
    {
      "source": "n36",
      "target": "n37"
    },
    {
      "source": "n33",
      "target": "n34"
    },
    {
      "source": "n25",
      "target": "n27"
    },
    {
      "source": "n3",
      "target": "n5"
    },
    {
      "source": "n20",
      "target": "n24"
    },
    {
      "source": "n32",
      "target": "n34"
    },
    {
      "source": "n11",
      "target": "n13"
    },
    {
      "source": "n28",
      "target": "n22"
    },
    {
      "source": "n0",
      "target": "n2"
    }
  ]
}