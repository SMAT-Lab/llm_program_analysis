{
  "nodes": [
    {
      "id": "n0",
      "type": "block",
      "statements": [
        "from backend.blocks.jina._auth import JinaCredentials, JinaCredentialsField, JinaCredentialsInput",
        "from backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema",
        "from backend.data.model import SchemaField",
        "from backend.util.request import requests",
        "class JinaChunkingBlock(Block):\n\n    class Input(BlockSchema):\n        texts: list = SchemaField(description='List of texts to chunk')\n        credentials: JinaCredentialsInput = JinaCredentialsField()\n        max_chunk_length: int = SchemaField(description='Maximum length of each chunk', default=1000)\n        return_tokens: bool = SchemaField(description='Whether to return token information', default=False)\n\n    class Output(BlockSchema):\n        chunks: list = SchemaField(description='List of chunked texts')\n        tokens: list = SchemaField(description='List of token information for each chunk', optional=True)\n\n    def __init__(self):\n        super().__init__(id='806fb15e-830f-4796-8692-557d300ff43c', description=\"Chunks texts using Jina AI's segmentation service\", categories={BlockCategory.AI, BlockCategory.TEXT}, input_schema=JinaChunkingBlock.Input, output_schema=JinaChunkingBlock.Output)\n\n    def run(self, input_data: Input, *, credentials: JinaCredentials, **kwargs) -> BlockOutput:\n        url = 'https://segment.jina.ai/'\n        headers = {'Content-Type': 'application/json', 'Authorization': f'Bearer {credentials.api_key.get_secret_value()}'}\n        all_chunks = []\n        all_tokens = []\n        for text in input_data.texts:\n            data = {'content': text, 'return_tokens': str(input_data.return_tokens).lower(), 'return_chunks': 'true', 'max_chunk_length': str(input_data.max_chunk_length)}\n            response = requests.post(url, headers=headers, json=data)\n            result = response.json()\n            all_chunks.extend(result.get('chunks', []))\n            if input_data.return_tokens:\n                all_tokens.extend(result.get('tokens', []))\n        yield ('chunks', all_chunks)\n        if input_data.return_tokens:\n            yield ('tokens', all_tokens)",
        "class Input(BlockSchema):\n    texts: list = SchemaField(description='List of texts to chunk')\n    credentials: JinaCredentialsInput = JinaCredentialsField()\n    max_chunk_length: int = SchemaField(description='Maximum length of each chunk', default=1000)\n    return_tokens: bool = SchemaField(description='Whether to return token information', default=False)",
        "texts: list = SchemaField(description='List of texts to chunk')",
        "credentials: JinaCredentialsInput = JinaCredentialsField()",
        "max_chunk_length: int = SchemaField(description='Maximum length of each chunk', default=1000)",
        "return_tokens: bool = SchemaField(description='Whether to return token information', default=False)",
        "class Output(BlockSchema):\n    chunks: list = SchemaField(description='List of chunked texts')\n    tokens: list = SchemaField(description='List of token information for each chunk', optional=True)",
        "chunks: list = SchemaField(description='List of chunked texts')",
        "tokens: list = SchemaField(description='List of token information for each chunk', optional=True)",
        "def __init__(self):\n    super().__init__(id='806fb15e-830f-4796-8692-557d300ff43c', description=\"Chunks texts using Jina AI's segmentation service\", categories={BlockCategory.AI, BlockCategory.TEXT}, input_schema=JinaChunkingBlock.Input, output_schema=JinaChunkingBlock.Output)",
        "super().__init__()",
        "def run(self, input_data: Input, *, credentials: JinaCredentials, **kwargs) -> BlockOutput:\n    url = 'https://segment.jina.ai/'\n    headers = {'Content-Type': 'application/json', 'Authorization': f'Bearer {credentials.api_key.get_secret_value()}'}\n    all_chunks = []\n    all_tokens = []\n    for text in input_data.texts:\n        data = {'content': text, 'return_tokens': str(input_data.return_tokens).lower(), 'return_chunks': 'true', 'max_chunk_length': str(input_data.max_chunk_length)}\n        response = requests.post(url, headers=headers, json=data)\n        result = response.json()\n        all_chunks.extend(result.get('chunks', []))\n        if input_data.return_tokens:\n            all_tokens.extend(result.get('tokens', []))\n    yield ('chunks', all_chunks)\n    if input_data.return_tokens:\n        yield ('tokens', all_tokens)",
        "url = 'https://segment.jina.ai/'",
        "headers = {'Content-Type': 'application/json', 'Authorization': f'Bearer {credentials.api_key.get_secret_value()}'}",
        "all_chunks = []",
        "all_tokens = []"
      ],
      "code": "from backend.blocks.jina._auth import JinaCredentials, JinaCredentialsField, JinaCredentialsInput\nfrom backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema\nfrom backend.data.model import SchemaField\nfrom backend.util.request import requests\nclass JinaChunkingBlock(Block):\n\n    class Input(BlockSchema):\n        texts: list = SchemaField(description='List of texts to chunk')\n        credentials: JinaCredentialsInput = JinaCredentialsField()\n        max_chunk_length: int = SchemaField(description='Maximum length of each chunk', default=1000)\n        return_tokens: bool = SchemaField(description='Whether to return token information', default=False)\n\n    class Output(BlockSchema):\n        chunks: list = SchemaField(description='List of chunked texts')\n        tokens: list = SchemaField(description='List of token information for each chunk', optional=True)\n\n    def __init__(self):\n        super().__init__(id='806fb15e-830f-4796-8692-557d300ff43c', description=\"Chunks texts using Jina AI's segmentation service\", categories={BlockCategory.AI, BlockCategory.TEXT}, input_schema=JinaChunkingBlock.Input, output_schema=JinaChunkingBlock.Output)\n\n    def run(self, input_data: Input, *, credentials: JinaCredentials, **kwargs) -> BlockOutput:\n        url = 'https://segment.jina.ai/'\n        headers = {'Content-Type': 'application/json', 'Authorization': f'Bearer {credentials.api_key.get_secret_value()}'}\n        all_chunks = []\n        all_tokens = []\n        for text in input_data.texts:\n            data = {'content': text, 'return_tokens': str(input_data.return_tokens).lower(), 'return_chunks': 'true', 'max_chunk_length': str(input_data.max_chunk_length)}\n            response = requests.post(url, headers=headers, json=data)\n            result = response.json()\n            all_chunks.extend(result.get('chunks', []))\n            if input_data.return_tokens:\n                all_tokens.extend(result.get('tokens', []))\n        yield ('chunks', all_chunks)\n        if input_data.return_tokens:\n            yield ('tokens', all_tokens)\nclass Input(BlockSchema):\n    texts: list = SchemaField(description='List of texts to chunk')\n    credentials: JinaCredentialsInput = JinaCredentialsField()\n    max_chunk_length: int = SchemaField(description='Maximum length of each chunk', default=1000)\n    return_tokens: bool = SchemaField(description='Whether to return token information', default=False)\ntexts: list = SchemaField(description='List of texts to chunk')\ncredentials: JinaCredentialsInput = JinaCredentialsField()\nmax_chunk_length: int = SchemaField(description='Maximum length of each chunk', default=1000)\nreturn_tokens: bool = SchemaField(description='Whether to return token information', default=False)\nclass Output(BlockSchema):\n    chunks: list = SchemaField(description='List of chunked texts')\n    tokens: list = SchemaField(description='List of token information for each chunk', optional=True)\nchunks: list = SchemaField(description='List of chunked texts')\ntokens: list = SchemaField(description='List of token information for each chunk', optional=True)\ndef __init__(self):\n    super().__init__(id='806fb15e-830f-4796-8692-557d300ff43c', description=\"Chunks texts using Jina AI's segmentation service\", categories={BlockCategory.AI, BlockCategory.TEXT}, input_schema=JinaChunkingBlock.Input, output_schema=JinaChunkingBlock.Output)\nsuper().__init__()\ndef run(self, input_data: Input, *, credentials: JinaCredentials, **kwargs) -> BlockOutput:\n    url = 'https://segment.jina.ai/'\n    headers = {'Content-Type': 'application/json', 'Authorization': f'Bearer {credentials.api_key.get_secret_value()}'}\n    all_chunks = []\n    all_tokens = []\n    for text in input_data.texts:\n        data = {'content': text, 'return_tokens': str(input_data.return_tokens).lower(), 'return_chunks': 'true', 'max_chunk_length': str(input_data.max_chunk_length)}\n        response = requests.post(url, headers=headers, json=data)\n        result = response.json()\n        all_chunks.extend(result.get('chunks', []))\n        if input_data.return_tokens:\n            all_tokens.extend(result.get('tokens', []))\n    yield ('chunks', all_chunks)\n    if input_data.return_tokens:\n        yield ('tokens', all_tokens)\nurl = 'https://segment.jina.ai/'\nheaders = {'Content-Type': 'application/json', 'Authorization': f'Bearer {credentials.api_key.get_secret_value()}'}\nall_chunks = []\nall_tokens = []"
    },
    {
      "id": "n1",
      "type": "block",
      "statements": [
        "text",
        "input_data.texts"
      ],
      "code": "text\ninput_data.texts"
    },
    {
      "id": "n2",
      "type": "block",
      "statements": [
        "data = {'content': text, 'return_tokens': str(input_data.return_tokens).lower(), 'return_chunks': 'true', 'max_chunk_length': str(input_data.max_chunk_length)}",
        "response = requests.post(url, headers=headers, json=data)",
        "result = response.json()",
        "all_chunks.extend(result.get('chunks', []))",
        "input_data.return_tokens"
      ],
      "code": "data = {'content': text, 'return_tokens': str(input_data.return_tokens).lower(), 'return_chunks': 'true', 'max_chunk_length': str(input_data.max_chunk_length)}\nresponse = requests.post(url, headers=headers, json=data)\nresult = response.json()\nall_chunks.extend(result.get('chunks', []))\ninput_data.return_tokens"
    },
    {
      "id": "n3",
      "type": "block",
      "statements": [
        "(yield ('chunks', all_chunks))",
        "input_data.return_tokens"
      ],
      "code": "(yield ('chunks', all_chunks))\ninput_data.return_tokens"
    },
    {
      "id": "n4",
      "type": "block",
      "statements": [
        "all_tokens.extend(result.get('tokens', []))"
      ],
      "code": "all_tokens.extend(result.get('tokens', []))"
    },
    {
      "id": "n5",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n6",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n7",
      "type": "block",
      "statements": [
        "(yield ('tokens', all_tokens))"
      ],
      "code": "(yield ('tokens', all_tokens))"
    },
    {
      "id": "n8",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n9",
      "type": "block",
      "statements": [],
      "code": ""
    }
  ],
  "edges": [
    {
      "source": "n5",
      "target": "n6"
    },
    {
      "source": "n1",
      "target": "n3"
    },
    {
      "source": "n2",
      "target": "n4"
    },
    {
      "source": "n0",
      "target": "n1"
    },
    {
      "source": "n6",
      "target": "n1"
    },
    {
      "source": "n2",
      "target": "n5"
    },
    {
      "source": "n8",
      "target": "n9"
    },
    {
      "source": "n3",
      "target": "n8"
    },
    {
      "source": "n1",
      "target": "n2"
    },
    {
      "source": "n4",
      "target": "n6"
    },
    {
      "source": "n3",
      "target": "n7"
    },
    {
      "source": "n7",
      "target": "n9"
    }
  ]
}