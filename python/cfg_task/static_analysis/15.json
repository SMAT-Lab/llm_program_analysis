{
  "nodes": [
    {
      "id": "n0",
      "type": "block",
      "statements": [
        "from __future__ import annotations",
        "class IIRFilter:\n    \"\"\"\n    N-Order IIR filter\n    Assumes working with float samples normalized on [-1, 1]\n\n    ---\n\n    Implementation details:\n    Based on the 2nd-order function from\n    https://en.wikipedia.org/wiki/Digital_biquad_filter,\n    this generalized N-order function was made.\n\n    Using the following transfer function\n        .. math:: H(z)=\\\\frac{b_{0}+b_{1}z^{-1}+b_{2}z^{-2}+...+b_{k}z^{-k}}\n                  {a_{0}+a_{1}z^{-1}+a_{2}z^{-2}+...+a_{k}z^{-k}}\n\n    we can rewrite this to\n        .. math:: y[n]={\\\\frac{1}{a_{0}}}\n                  \\\\left(\\\\left(b_{0}x[n]+b_{1}x[n-1]+b_{2}x[n-2]+...+b_{k}x[n-k]\\\\right)-\n                  \\\\left(a_{1}y[n-1]+a_{2}y[n-2]+...+a_{k}y[n-k]\\\\right)\\\\right)\n    \"\"\"\n\n    def __init__(self, order: int) -> None:\n        self.order = order\n        self.a_coeffs = [1.0] + [0.0] * order\n        self.b_coeffs = [1.0] + [0.0] * order\n        self.input_history = [0.0] * self.order\n        self.output_history = [0.0] * self.order\n\n    def set_coefficients(self, a_coeffs: list[float], b_coeffs: list[float]) -> None:\n        \"\"\"\n        Set the coefficients for the IIR filter.\n        These should both be of size `order` + 1.\n        :math:`a_0` may be left out, and it will use 1.0 as default value.\n\n        This method works well with scipy's filter design functions\n\n        >>> # Make a 2nd-order 1000Hz butterworth lowpass filter\n        >>> import scipy.signal\n        >>> b_coeffs, a_coeffs = scipy.signal.butter(2, 1000,\n        ...                                          btype='lowpass',\n        ...                                          fs=48000)\n        >>> filt = IIRFilter(2)\n        >>> filt.set_coefficients(a_coeffs, b_coeffs)\n        \"\"\"\n        if len(a_coeffs) < self.order:\n            a_coeffs = [1.0, *a_coeffs]\n        if len(a_coeffs) != self.order + 1:\n            msg = f'Expected a_coeffs to have {self.order + 1} elements for {self.order}-order filter, got {len(a_coeffs)}'\n            raise ValueError(msg)\n        if len(b_coeffs) != self.order + 1:\n            msg = f'Expected b_coeffs to have {self.order + 1} elements for {self.order}-order filter, got {len(a_coeffs)}'\n            raise ValueError(msg)\n        self.a_coeffs = a_coeffs\n        self.b_coeffs = b_coeffs\n\n    def process(self, sample: float) -> float:\n        \"\"\"\n        Calculate :math:`y[n]`\n\n        >>> filt = IIRFilter(2)\n        >>> filt.process(0)\n        0.0\n        \"\"\"\n        result = 0.0\n        for i in range(1, self.order + 1):\n            result += self.b_coeffs[i] * self.input_history[i - 1] - self.a_coeffs[i] * self.output_history[i - 1]\n        result = (result + self.b_coeffs[0] * sample) / self.a_coeffs[0]\n        self.input_history[1:] = self.input_history[:-1]\n        self.output_history[1:] = self.output_history[:-1]\n        self.input_history[0] = sample\n        self.output_history[0] = result\n        return result",
        "'\\n    N-Order IIR filter\\n    Assumes working with float samples normalized on [-1, 1]\\n\\n    ---\\n\\n    Implementation details:\\n    Based on the 2nd-order function from\\n    https://en.wikipedia.org/wiki/Digital_biquad_filter,\\n    this generalized N-order function was made.\\n\\n    Using the following transfer function\\n        .. math:: H(z)=\\\\frac{b_{0}+b_{1}z^{-1}+b_{2}z^{-2}+...+b_{k}z^{-k}}\\n                  {a_{0}+a_{1}z^{-1}+a_{2}z^{-2}+...+a_{k}z^{-k}}\\n\\n    we can rewrite this to\\n        .. math:: y[n]={\\\\frac{1}{a_{0}}}\\n                  \\\\left(\\\\left(b_{0}x[n]+b_{1}x[n-1]+b_{2}x[n-2]+...+b_{k}x[n-k]\\\\right)-\\n                  \\\\left(a_{1}y[n-1]+a_{2}y[n-2]+...+a_{k}y[n-k]\\\\right)\\\\right)\\n    '",
        "def __init__(self, order: int) -> None:\n    self.order = order\n    self.a_coeffs = [1.0] + [0.0] * order\n    self.b_coeffs = [1.0] + [0.0] * order\n    self.input_history = [0.0] * self.order\n    self.output_history = [0.0] * self.order",
        "self.order = order",
        "self.a_coeffs = [1.0] + [0.0] * order",
        "self.b_coeffs = [1.0] + [0.0] * order",
        "self.input_history = [0.0] * self.order",
        "self.output_history = [0.0] * self.order",
        "def set_coefficients(self, a_coeffs: list[float], b_coeffs: list[float]) -> None:\n    \"\"\"\n        Set the coefficients for the IIR filter.\n        These should both be of size `order` + 1.\n        :math:`a_0` may be left out, and it will use 1.0 as default value.\n\n        This method works well with scipy's filter design functions\n\n        >>> # Make a 2nd-order 1000Hz butterworth lowpass filter\n        >>> import scipy.signal\n        >>> b_coeffs, a_coeffs = scipy.signal.butter(2, 1000,\n        ...                                          btype='lowpass',\n        ...                                          fs=48000)\n        >>> filt = IIRFilter(2)\n        >>> filt.set_coefficients(a_coeffs, b_coeffs)\n        \"\"\"\n    if len(a_coeffs) < self.order:\n        a_coeffs = [1.0, *a_coeffs]\n    if len(a_coeffs) != self.order + 1:\n        msg = f'Expected a_coeffs to have {self.order + 1} elements for {self.order}-order filter, got {len(a_coeffs)}'\n        raise ValueError(msg)\n    if len(b_coeffs) != self.order + 1:\n        msg = f'Expected b_coeffs to have {self.order + 1} elements for {self.order}-order filter, got {len(a_coeffs)}'\n        raise ValueError(msg)\n    self.a_coeffs = a_coeffs\n    self.b_coeffs = b_coeffs",
        "\"\\n        Set the coefficients for the IIR filter.\\n        These should both be of size `order` + 1.\\n        :math:`a_0` may be left out, and it will use 1.0 as default value.\\n\\n        This method works well with scipy's filter design functions\\n\\n        >>> # Make a 2nd-order 1000Hz butterworth lowpass filter\\n        >>> import scipy.signal\\n        >>> b_coeffs, a_coeffs = scipy.signal.butter(2, 1000,\\n        ...                                          btype='lowpass',\\n        ...                                          fs=48000)\\n        >>> filt = IIRFilter(2)\\n        >>> filt.set_coefficients(a_coeffs, b_coeffs)\\n        \"",
        "len(a_coeffs) Lt self.order"
      ],
      "code": "from __future__ import annotations\nclass IIRFilter:\n    \"\"\"\n    N-Order IIR filter\n    Assumes working with float samples normalized on [-1, 1]\n\n    ---\n\n    Implementation details:\n    Based on the 2nd-order function from\n    https://en.wikipedia.org/wiki/Digital_biquad_filter,\n    this generalized N-order function was made.\n\n    Using the following transfer function\n        .. math:: H(z)=\\\\frac{b_{0}+b_{1}z^{-1}+b_{2}z^{-2}+...+b_{k}z^{-k}}\n                  {a_{0}+a_{1}z^{-1}+a_{2}z^{-2}+...+a_{k}z^{-k}}\n\n    we can rewrite this to\n        .. math:: y[n]={\\\\frac{1}{a_{0}}}\n                  \\\\left(\\\\left(b_{0}x[n]+b_{1}x[n-1]+b_{2}x[n-2]+...+b_{k}x[n-k]\\\\right)-\n                  \\\\left(a_{1}y[n-1]+a_{2}y[n-2]+...+a_{k}y[n-k]\\\\right)\\\\right)\n    \"\"\"\n\n    def __init__(self, order: int) -> None:\n        self.order = order\n        self.a_coeffs = [1.0] + [0.0] * order\n        self.b_coeffs = [1.0] + [0.0] * order\n        self.input_history = [0.0] * self.order\n        self.output_history = [0.0] * self.order\n\n    def set_coefficients(self, a_coeffs: list[float], b_coeffs: list[float]) -> None:\n        \"\"\"\n        Set the coefficients for the IIR filter.\n        These should both be of size `order` + 1.\n        :math:`a_0` may be left out, and it will use 1.0 as default value.\n\n        This method works well with scipy's filter design functions\n\n        >>> # Make a 2nd-order 1000Hz butterworth lowpass filter\n        >>> import scipy.signal\n        >>> b_coeffs, a_coeffs = scipy.signal.butter(2, 1000,\n        ...                                          btype='lowpass',\n        ...                                          fs=48000)\n        >>> filt = IIRFilter(2)\n        >>> filt.set_coefficients(a_coeffs, b_coeffs)\n        \"\"\"\n        if len(a_coeffs) < self.order:\n            a_coeffs = [1.0, *a_coeffs]\n        if len(a_coeffs) != self.order + 1:\n            msg = f'Expected a_coeffs to have {self.order + 1} elements for {self.order}-order filter, got {len(a_coeffs)}'\n            raise ValueError(msg)\n        if len(b_coeffs) != self.order + 1:\n            msg = f'Expected b_coeffs to have {self.order + 1} elements for {self.order}-order filter, got {len(a_coeffs)}'\n            raise ValueError(msg)\n        self.a_coeffs = a_coeffs\n        self.b_coeffs = b_coeffs\n\n    def process(self, sample: float) -> float:\n        \"\"\"\n        Calculate :math:`y[n]`\n\n        >>> filt = IIRFilter(2)\n        >>> filt.process(0)\n        0.0\n        \"\"\"\n        result = 0.0\n        for i in range(1, self.order + 1):\n            result += self.b_coeffs[i] * self.input_history[i - 1] - self.a_coeffs[i] * self.output_history[i - 1]\n        result = (result + self.b_coeffs[0] * sample) / self.a_coeffs[0]\n        self.input_history[1:] = self.input_history[:-1]\n        self.output_history[1:] = self.output_history[:-1]\n        self.input_history[0] = sample\n        self.output_history[0] = result\n        return result\n'\\n    N-Order IIR filter\\n    Assumes working with float samples normalized on [-1, 1]\\n\\n    ---\\n\\n    Implementation details:\\n    Based on the 2nd-order function from\\n    https://en.wikipedia.org/wiki/Digital_biquad_filter,\\n    this generalized N-order function was made.\\n\\n    Using the following transfer function\\n        .. math:: H(z)=\\\\frac{b_{0}+b_{1}z^{-1}+b_{2}z^{-2}+...+b_{k}z^{-k}}\\n                  {a_{0}+a_{1}z^{-1}+a_{2}z^{-2}+...+a_{k}z^{-k}}\\n\\n    we can rewrite this to\\n        .. math:: y[n]={\\\\frac{1}{a_{0}}}\\n                  \\\\left(\\\\left(b_{0}x[n]+b_{1}x[n-1]+b_{2}x[n-2]+...+b_{k}x[n-k]\\\\right)-\\n                  \\\\left(a_{1}y[n-1]+a_{2}y[n-2]+...+a_{k}y[n-k]\\\\right)\\\\right)\\n    '\ndef __init__(self, order: int) -> None:\n    self.order = order\n    self.a_coeffs = [1.0] + [0.0] * order\n    self.b_coeffs = [1.0] + [0.0] * order\n    self.input_history = [0.0] * self.order\n    self.output_history = [0.0] * self.order\nself.order = order\nself.a_coeffs = [1.0] + [0.0] * order\nself.b_coeffs = [1.0] + [0.0] * order\nself.input_history = [0.0] * self.order\nself.output_history = [0.0] * self.order\ndef set_coefficients(self, a_coeffs: list[float], b_coeffs: list[float]) -> None:\n    \"\"\"\n        Set the coefficients for the IIR filter.\n        These should both be of size `order` + 1.\n        :math:`a_0` may be left out, and it will use 1.0 as default value.\n\n        This method works well with scipy's filter design functions\n\n        >>> # Make a 2nd-order 1000Hz butterworth lowpass filter\n        >>> import scipy.signal\n        >>> b_coeffs, a_coeffs = scipy.signal.butter(2, 1000,\n        ...                                          btype='lowpass',\n        ...                                          fs=48000)\n        >>> filt = IIRFilter(2)\n        >>> filt.set_coefficients(a_coeffs, b_coeffs)\n        \"\"\"\n    if len(a_coeffs) < self.order:\n        a_coeffs = [1.0, *a_coeffs]\n    if len(a_coeffs) != self.order + 1:\n        msg = f'Expected a_coeffs to have {self.order + 1} elements for {self.order}-order filter, got {len(a_coeffs)}'\n        raise ValueError(msg)\n    if len(b_coeffs) != self.order + 1:\n        msg = f'Expected b_coeffs to have {self.order + 1} elements for {self.order}-order filter, got {len(a_coeffs)}'\n        raise ValueError(msg)\n    self.a_coeffs = a_coeffs\n    self.b_coeffs = b_coeffs\n\"\\n        Set the coefficients for the IIR filter.\\n        These should both be of size `order` + 1.\\n        :math:`a_0` may be left out, and it will use 1.0 as default value.\\n\\n        This method works well with scipy's filter design functions\\n\\n        >>> # Make a 2nd-order 1000Hz butterworth lowpass filter\\n        >>> import scipy.signal\\n        >>> b_coeffs, a_coeffs = scipy.signal.butter(2, 1000,\\n        ...                                          btype='lowpass',\\n        ...                                          fs=48000)\\n        >>> filt = IIRFilter(2)\\n        >>> filt.set_coefficients(a_coeffs, b_coeffs)\\n        \"\nlen(a_coeffs) Lt self.order"
    },
    {
      "id": "n1",
      "type": "block",
      "statements": [
        "a_coeffs = [1.0, *a_coeffs]"
      ],
      "code": "a_coeffs = [1.0, *a_coeffs]"
    },
    {
      "id": "n2",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n3",
      "type": "block",
      "statements": [
        "len(a_coeffs) NotEq self.order Add 1"
      ],
      "code": "len(a_coeffs) NotEq self.order Add 1"
    },
    {
      "id": "n4",
      "type": "block",
      "statements": [
        "msg = f'Expected a_coeffs to have {self.order + 1} elements for {self.order}-order filter, got {len(a_coeffs)}'",
        "raise ValueError(msg)"
      ],
      "code": "msg = f'Expected a_coeffs to have {self.order + 1} elements for {self.order}-order filter, got {len(a_coeffs)}'\nraise ValueError(msg)"
    },
    {
      "id": "n5",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n6",
      "type": "block",
      "statements": [
        "len(b_coeffs) NotEq self.order Add 1"
      ],
      "code": "len(b_coeffs) NotEq self.order Add 1"
    },
    {
      "id": "n7",
      "type": "block",
      "statements": [
        "msg = f'Expected b_coeffs to have {self.order + 1} elements for {self.order}-order filter, got {len(a_coeffs)}'",
        "raise ValueError(msg)"
      ],
      "code": "msg = f'Expected b_coeffs to have {self.order + 1} elements for {self.order}-order filter, got {len(a_coeffs)}'\nraise ValueError(msg)"
    },
    {
      "id": "n8",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n9",
      "type": "block",
      "statements": [
        "self.a_coeffs = a_coeffs",
        "self.b_coeffs = b_coeffs",
        "def process(self, sample: float) -> float:\n    \"\"\"\n        Calculate :math:`y[n]`\n\n        >>> filt = IIRFilter(2)\n        >>> filt.process(0)\n        0.0\n        \"\"\"\n    result = 0.0\n    for i in range(1, self.order + 1):\n        result += self.b_coeffs[i] * self.input_history[i - 1] - self.a_coeffs[i] * self.output_history[i - 1]\n    result = (result + self.b_coeffs[0] * sample) / self.a_coeffs[0]\n    self.input_history[1:] = self.input_history[:-1]\n    self.output_history[1:] = self.output_history[:-1]\n    self.input_history[0] = sample\n    self.output_history[0] = result\n    return result",
        "'\\n        Calculate :math:`y[n]`\\n\\n        >>> filt = IIRFilter(2)\\n        >>> filt.process(0)\\n        0.0\\n        '",
        "result = 0.0"
      ],
      "code": "self.a_coeffs = a_coeffs\nself.b_coeffs = b_coeffs\ndef process(self, sample: float) -> float:\n    \"\"\"\n        Calculate :math:`y[n]`\n\n        >>> filt = IIRFilter(2)\n        >>> filt.process(0)\n        0.0\n        \"\"\"\n    result = 0.0\n    for i in range(1, self.order + 1):\n        result += self.b_coeffs[i] * self.input_history[i - 1] - self.a_coeffs[i] * self.output_history[i - 1]\n    result = (result + self.b_coeffs[0] * sample) / self.a_coeffs[0]\n    self.input_history[1:] = self.input_history[:-1]\n    self.output_history[1:] = self.output_history[:-1]\n    self.input_history[0] = sample\n    self.output_history[0] = result\n    return result\n'\\n        Calculate :math:`y[n]`\\n\\n        >>> filt = IIRFilter(2)\\n        >>> filt.process(0)\\n        0.0\\n        '\nresult = 0.0"
    },
    {
      "id": "n10",
      "type": "block",
      "statements": [
        "i",
        "range(1, self.order Add 1)"
      ],
      "code": "i\nrange(1, self.order Add 1)"
    },
    {
      "id": "n11",
      "type": "block",
      "statements": [
        "result += self.b_coeffs[i] * self.input_history[i - 1] - self.a_coeffs[i] * self.output_history[i - 1]"
      ],
      "code": "result += self.b_coeffs[i] * self.input_history[i - 1] - self.a_coeffs[i] * self.output_history[i - 1]"
    },
    {
      "id": "n12",
      "type": "block",
      "statements": [
        "result = (result + self.b_coeffs[0] * sample) / self.a_coeffs[0]",
        "self.input_history[1:] = self.input_history[:-1]",
        "self.output_history[1:] = self.output_history[:-1]",
        "self.input_history[0] = sample",
        "self.output_history[0] = result",
        "return result"
      ],
      "code": "result = (result + self.b_coeffs[0] * sample) / self.a_coeffs[0]\nself.input_history[1:] = self.input_history[:-1]\nself.output_history[1:] = self.output_history[:-1]\nself.input_history[0] = sample\nself.output_history[0] = result\nreturn result"
    }
  ],
  "edges": [
    {
      "source": "n5",
      "target": "n6"
    },
    {
      "source": "n1",
      "target": "n3"
    },
    {
      "source": "n11",
      "target": "n10"
    },
    {
      "source": "n6",
      "target": "n7"
    },
    {
      "source": "n0",
      "target": "n2"
    },
    {
      "source": "n0",
      "target": "n1"
    },
    {
      "source": "n8",
      "target": "n9"
    },
    {
      "source": "n3",
      "target": "n4"
    },
    {
      "source": "n3",
      "target": "n5"
    },
    {
      "source": "n9",
      "target": "n10"
    },
    {
      "source": "n4",
      "target": "n6"
    },
    {
      "source": "n10",
      "target": "n12"
    },
    {
      "source": "n10",
      "target": "n11"
    },
    {
      "source": "n6",
      "target": "n8"
    },
    {
      "source": "n2",
      "target": "n3"
    },
    {
      "source": "n7",
      "target": "n9"
    }
  ]
}