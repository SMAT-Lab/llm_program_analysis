{
  "nodes": [
    {
      "id": "n0",
      "type": "block",
      "statements": [
        "import logging",
        "from typing import TYPE_CHECKING, AsyncGenerator, Optional",
        "from prisma import Json",
        "from prisma.models import IntegrationWebhook",
        "from pydantic import Field, computed_field",
        "from backend.data.includes import INTEGRATION_WEBHOOK_INCLUDE",
        "from backend.data.queue import AsyncRedisEventBus",
        "from backend.integrations.providers import ProviderName",
        "from backend.integrations.webhooks.utils import webhook_ingress_url",
        "from .db import BaseDbModel",
        "TYPE_CHECKING"
      ],
      "code": "import logging\nfrom typing import TYPE_CHECKING, AsyncGenerator, Optional\nfrom prisma import Json\nfrom prisma.models import IntegrationWebhook\nfrom pydantic import Field, computed_field\nfrom backend.data.includes import INTEGRATION_WEBHOOK_INCLUDE\nfrom backend.data.queue import AsyncRedisEventBus\nfrom backend.integrations.providers import ProviderName\nfrom backend.integrations.webhooks.utils import webhook_ingress_url\nfrom .db import BaseDbModel\nTYPE_CHECKING"
    },
    {
      "id": "n1",
      "type": "block",
      "statements": [
        "from .graph import NodeModel"
      ],
      "code": "from .graph import NodeModel"
    },
    {
      "id": "n2",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n3",
      "type": "block",
      "statements": [
        "logger = logging.getLogger(__name__)",
        "class Webhook(BaseDbModel):\n    user_id: str\n    provider: ProviderName\n    credentials_id: str\n    webhook_type: str\n    resource: str\n    events: list[str]\n    config: dict = Field(default_factory=dict)\n    secret: str\n    provider_webhook_id: str\n    attached_nodes: Optional[list['NodeModel']] = None\n\n    @computed_field\n    @property\n    def url(self) -> str:\n        return webhook_ingress_url(self.provider.value, self.id)\n\n    @staticmethod\n    def from_db(webhook: IntegrationWebhook):\n        from .graph import NodeModel\n        return Webhook(id=webhook.id, user_id=webhook.userId, provider=ProviderName(webhook.provider), credentials_id=webhook.credentialsId, webhook_type=webhook.webhookType, resource=webhook.resource, events=webhook.events, config=dict(webhook.config), secret=webhook.secret, provider_webhook_id=webhook.providerWebhookId, attached_nodes=[NodeModel.from_db(node) for node in webhook.AgentNodes] if webhook.AgentNodes is not None else None)",
        "user_id: str",
        "provider: ProviderName",
        "credentials_id: str",
        "webhook_type: str",
        "resource: str",
        "events: list[str]",
        "config: dict = Field(default_factory=dict)",
        "secret: str",
        "provider_webhook_id: str",
        "attached_nodes: Optional[list['NodeModel']] = None",
        "@computed_field\n@property\ndef url(self) -> str:\n    return webhook_ingress_url(self.provider.value, self.id)",
        "return webhook_ingress_url(self.provider.value, self.id)"
      ],
      "code": "logger = logging.getLogger(__name__)\nclass Webhook(BaseDbModel):\n    user_id: str\n    provider: ProviderName\n    credentials_id: str\n    webhook_type: str\n    resource: str\n    events: list[str]\n    config: dict = Field(default_factory=dict)\n    secret: str\n    provider_webhook_id: str\n    attached_nodes: Optional[list['NodeModel']] = None\n\n    @computed_field\n    @property\n    def url(self) -> str:\n        return webhook_ingress_url(self.provider.value, self.id)\n\n    @staticmethod\n    def from_db(webhook: IntegrationWebhook):\n        from .graph import NodeModel\n        return Webhook(id=webhook.id, user_id=webhook.userId, provider=ProviderName(webhook.provider), credentials_id=webhook.credentialsId, webhook_type=webhook.webhookType, resource=webhook.resource, events=webhook.events, config=dict(webhook.config), secret=webhook.secret, provider_webhook_id=webhook.providerWebhookId, attached_nodes=[NodeModel.from_db(node) for node in webhook.AgentNodes] if webhook.AgentNodes is not None else None)\nuser_id: str\nprovider: ProviderName\ncredentials_id: str\nwebhook_type: str\nresource: str\nevents: list[str]\nconfig: dict = Field(default_factory=dict)\nsecret: str\nprovider_webhook_id: str\nattached_nodes: Optional[list['NodeModel']] = None\n@computed_field\n@property\ndef url(self) -> str:\n    return webhook_ingress_url(self.provider.value, self.id)\nreturn webhook_ingress_url(self.provider.value, self.id)"
    },
    {
      "id": "n4",
      "type": "block",
      "statements": [
        "@staticmethod\ndef from_db(webhook: IntegrationWebhook):\n    from .graph import NodeModel\n    return Webhook(id=webhook.id, user_id=webhook.userId, provider=ProviderName(webhook.provider), credentials_id=webhook.credentialsId, webhook_type=webhook.webhookType, resource=webhook.resource, events=webhook.events, config=dict(webhook.config), secret=webhook.secret, provider_webhook_id=webhook.providerWebhookId, attached_nodes=[NodeModel.from_db(node) for node in webhook.AgentNodes] if webhook.AgentNodes is not None else None)",
        "from .graph import NodeModel",
        "return Webhook(id=webhook.id, user_id=webhook.userId, provider=ProviderName(webhook.provider), credentials_id=webhook.credentialsId, webhook_type=webhook.webhookType, resource=webhook.resource, events=webhook.events, config=dict(webhook.config), secret=webhook.secret, provider_webhook_id=webhook.providerWebhookId, attached_nodes=[NodeModel.from_db(node) for node in webhook.AgentNodes] if webhook.AgentNodes is not None else None)"
      ],
      "code": "@staticmethod\ndef from_db(webhook: IntegrationWebhook):\n    from .graph import NodeModel\n    return Webhook(id=webhook.id, user_id=webhook.userId, provider=ProviderName(webhook.provider), credentials_id=webhook.credentialsId, webhook_type=webhook.webhookType, resource=webhook.resource, events=webhook.events, config=dict(webhook.config), secret=webhook.secret, provider_webhook_id=webhook.providerWebhookId, attached_nodes=[NodeModel.from_db(node) for node in webhook.AgentNodes] if webhook.AgentNodes is not None else None)\nfrom .graph import NodeModel\nreturn Webhook(id=webhook.id, user_id=webhook.userId, provider=ProviderName(webhook.provider), credentials_id=webhook.credentialsId, webhook_type=webhook.webhookType, resource=webhook.resource, events=webhook.events, config=dict(webhook.config), secret=webhook.secret, provider_webhook_id=webhook.providerWebhookId, attached_nodes=[NodeModel.from_db(node) for node in webhook.AgentNodes] if webhook.AgentNodes is not None else None)"
    },
    {
      "id": "n5",
      "type": "block",
      "statements": [
        "async def create_webhook(webhook: Webhook) -> Webhook:\n    created_webhook = await IntegrationWebhook.prisma().create(data={'id': webhook.id, 'userId': webhook.user_id, 'provider': webhook.provider.value, 'credentialsId': webhook.credentials_id, 'webhookType': webhook.webhook_type, 'resource': webhook.resource, 'events': webhook.events, 'config': Json(webhook.config), 'secret': webhook.secret, 'providerWebhookId': webhook.provider_webhook_id})\n    return Webhook.from_db(created_webhook)",
        "created_webhook = await IntegrationWebhook.prisma().create(data={'id': webhook.id, 'userId': webhook.user_id, 'provider': webhook.provider.value, 'credentialsId': webhook.credentials_id, 'webhookType': webhook.webhook_type, 'resource': webhook.resource, 'events': webhook.events, 'config': Json(webhook.config), 'secret': webhook.secret, 'providerWebhookId': webhook.provider_webhook_id})",
        "return Webhook.from_db(created_webhook)"
      ],
      "code": "async def create_webhook(webhook: Webhook) -> Webhook:\n    created_webhook = await IntegrationWebhook.prisma().create(data={'id': webhook.id, 'userId': webhook.user_id, 'provider': webhook.provider.value, 'credentialsId': webhook.credentials_id, 'webhookType': webhook.webhook_type, 'resource': webhook.resource, 'events': webhook.events, 'config': Json(webhook.config), 'secret': webhook.secret, 'providerWebhookId': webhook.provider_webhook_id})\n    return Webhook.from_db(created_webhook)\ncreated_webhook = await IntegrationWebhook.prisma().create(data={'id': webhook.id, 'userId': webhook.user_id, 'provider': webhook.provider.value, 'credentialsId': webhook.credentials_id, 'webhookType': webhook.webhook_type, 'resource': webhook.resource, 'events': webhook.events, 'config': Json(webhook.config), 'secret': webhook.secret, 'providerWebhookId': webhook.provider_webhook_id})\nreturn Webhook.from_db(created_webhook)"
    },
    {
      "id": "n6",
      "type": "block",
      "statements": [
        "async def get_webhook(webhook_id: str) -> Webhook:\n    \"\"\"⚠️ No `user_id` check: DO NOT USE without check in user-facing endpoints.\"\"\"\n    webhook = await IntegrationWebhook.prisma().find_unique_or_raise(where={'id': webhook_id}, include=INTEGRATION_WEBHOOK_INCLUDE)\n    return Webhook.from_db(webhook)",
        "'⚠️ No `user_id` check: DO NOT USE without check in user-facing endpoints.'",
        "webhook = await IntegrationWebhook.prisma().find_unique_or_raise(where={'id': webhook_id}, include=INTEGRATION_WEBHOOK_INCLUDE)",
        "return Webhook.from_db(webhook)"
      ],
      "code": "async def get_webhook(webhook_id: str) -> Webhook:\n    \"\"\"⚠️ No `user_id` check: DO NOT USE without check in user-facing endpoints.\"\"\"\n    webhook = await IntegrationWebhook.prisma().find_unique_or_raise(where={'id': webhook_id}, include=INTEGRATION_WEBHOOK_INCLUDE)\n    return Webhook.from_db(webhook)\n'⚠️ No `user_id` check: DO NOT USE without check in user-facing endpoints.'\nwebhook = await IntegrationWebhook.prisma().find_unique_or_raise(where={'id': webhook_id}, include=INTEGRATION_WEBHOOK_INCLUDE)\nreturn Webhook.from_db(webhook)"
    },
    {
      "id": "n7",
      "type": "block",
      "statements": [
        "async def get_all_webhooks_by_creds(credentials_id: str) -> list[Webhook]:\n    \"\"\"⚠️ No `user_id` check: DO NOT USE without check in user-facing endpoints.\"\"\"\n    if not credentials_id:\n        raise ValueError('credentials_id must not be empty')\n    webhooks = await IntegrationWebhook.prisma().find_many(where={'credentialsId': credentials_id}, include=INTEGRATION_WEBHOOK_INCLUDE)\n    return [Webhook.from_db(webhook) for webhook in webhooks]",
        "'⚠️ No `user_id` check: DO NOT USE without check in user-facing endpoints.'",
        "not credentials_id"
      ],
      "code": "async def get_all_webhooks_by_creds(credentials_id: str) -> list[Webhook]:\n    \"\"\"⚠️ No `user_id` check: DO NOT USE without check in user-facing endpoints.\"\"\"\n    if not credentials_id:\n        raise ValueError('credentials_id must not be empty')\n    webhooks = await IntegrationWebhook.prisma().find_many(where={'credentialsId': credentials_id}, include=INTEGRATION_WEBHOOK_INCLUDE)\n    return [Webhook.from_db(webhook) for webhook in webhooks]\n'⚠️ No `user_id` check: DO NOT USE without check in user-facing endpoints.'\nnot credentials_id"
    },
    {
      "id": "n8",
      "type": "block",
      "statements": [
        "raise ValueError('credentials_id must not be empty')"
      ],
      "code": "raise ValueError('credentials_id must not be empty')"
    },
    {
      "id": "n9",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n10",
      "type": "block",
      "statements": [
        "webhooks = await IntegrationWebhook.prisma().find_many(where={'credentialsId': credentials_id}, include=INTEGRATION_WEBHOOK_INCLUDE)",
        "return [Webhook.from_db(webhook) for webhook in webhooks]"
      ],
      "code": "webhooks = await IntegrationWebhook.prisma().find_many(where={'credentialsId': credentials_id}, include=INTEGRATION_WEBHOOK_INCLUDE)\nreturn [Webhook.from_db(webhook) for webhook in webhooks]"
    },
    {
      "id": "n11",
      "type": "block",
      "statements": [
        "async def find_webhook_by_credentials_and_props(credentials_id: str, webhook_type: str, resource: str, events: list[str]) -> Webhook | None:\n    \"\"\"⚠️ No `user_id` check: DO NOT USE without check in user-facing endpoints.\"\"\"\n    webhook = await IntegrationWebhook.prisma().find_first(where={'credentialsId': credentials_id, 'webhookType': webhook_type, 'resource': resource, 'events': {'has_every': events}}, include=INTEGRATION_WEBHOOK_INCLUDE)\n    return Webhook.from_db(webhook) if webhook else None",
        "'⚠️ No `user_id` check: DO NOT USE without check in user-facing endpoints.'",
        "webhook = await IntegrationWebhook.prisma().find_first(where={'credentialsId': credentials_id, 'webhookType': webhook_type, 'resource': resource, 'events': {'has_every': events}}, include=INTEGRATION_WEBHOOK_INCLUDE)",
        "return Webhook.from_db(webhook) if webhook else None"
      ],
      "code": "async def find_webhook_by_credentials_and_props(credentials_id: str, webhook_type: str, resource: str, events: list[str]) -> Webhook | None:\n    \"\"\"⚠️ No `user_id` check: DO NOT USE without check in user-facing endpoints.\"\"\"\n    webhook = await IntegrationWebhook.prisma().find_first(where={'credentialsId': credentials_id, 'webhookType': webhook_type, 'resource': resource, 'events': {'has_every': events}}, include=INTEGRATION_WEBHOOK_INCLUDE)\n    return Webhook.from_db(webhook) if webhook else None\n'⚠️ No `user_id` check: DO NOT USE without check in user-facing endpoints.'\nwebhook = await IntegrationWebhook.prisma().find_first(where={'credentialsId': credentials_id, 'webhookType': webhook_type, 'resource': resource, 'events': {'has_every': events}}, include=INTEGRATION_WEBHOOK_INCLUDE)\nreturn Webhook.from_db(webhook) if webhook else None"
    },
    {
      "id": "n12",
      "type": "block",
      "statements": [
        "async def find_webhook_by_graph_and_props(graph_id: str, provider: str, webhook_type: str, events: list[str]) -> Webhook | None:\n    \"\"\"⚠️ No `user_id` check: DO NOT USE without check in user-facing endpoints.\"\"\"\n    webhook = await IntegrationWebhook.prisma().find_first(where={'provider': provider, 'webhookType': webhook_type, 'events': {'has_every': events}, 'AgentNodes': {'some': {'agentGraphId': graph_id}}}, include=INTEGRATION_WEBHOOK_INCLUDE)\n    return Webhook.from_db(webhook) if webhook else None",
        "'⚠️ No `user_id` check: DO NOT USE without check in user-facing endpoints.'",
        "webhook = await IntegrationWebhook.prisma().find_first(where={'provider': provider, 'webhookType': webhook_type, 'events': {'has_every': events}, 'AgentNodes': {'some': {'agentGraphId': graph_id}}}, include=INTEGRATION_WEBHOOK_INCLUDE)",
        "return Webhook.from_db(webhook) if webhook else None"
      ],
      "code": "async def find_webhook_by_graph_and_props(graph_id: str, provider: str, webhook_type: str, events: list[str]) -> Webhook | None:\n    \"\"\"⚠️ No `user_id` check: DO NOT USE without check in user-facing endpoints.\"\"\"\n    webhook = await IntegrationWebhook.prisma().find_first(where={'provider': provider, 'webhookType': webhook_type, 'events': {'has_every': events}, 'AgentNodes': {'some': {'agentGraphId': graph_id}}}, include=INTEGRATION_WEBHOOK_INCLUDE)\n    return Webhook.from_db(webhook) if webhook else None\n'⚠️ No `user_id` check: DO NOT USE without check in user-facing endpoints.'\nwebhook = await IntegrationWebhook.prisma().find_first(where={'provider': provider, 'webhookType': webhook_type, 'events': {'has_every': events}, 'AgentNodes': {'some': {'agentGraphId': graph_id}}}, include=INTEGRATION_WEBHOOK_INCLUDE)\nreturn Webhook.from_db(webhook) if webhook else None"
    },
    {
      "id": "n13",
      "type": "block",
      "statements": [
        "async def update_webhook_config(webhook_id: str, updated_config: dict) -> Webhook:\n    \"\"\"⚠️ No `user_id` check: DO NOT USE without check in user-facing endpoints.\"\"\"\n    _updated_webhook = await IntegrationWebhook.prisma().update(where={'id': webhook_id}, data={'config': Json(updated_config)}, include=INTEGRATION_WEBHOOK_INCLUDE)\n    if _updated_webhook is None:\n        raise ValueError(f'Webhook #{webhook_id} not found')\n    return Webhook.from_db(_updated_webhook)",
        "'⚠️ No `user_id` check: DO NOT USE without check in user-facing endpoints.'",
        "_updated_webhook = await IntegrationWebhook.prisma().update(where={'id': webhook_id}, data={'config': Json(updated_config)}, include=INTEGRATION_WEBHOOK_INCLUDE)",
        "_updated_webhook Is None"
      ],
      "code": "async def update_webhook_config(webhook_id: str, updated_config: dict) -> Webhook:\n    \"\"\"⚠️ No `user_id` check: DO NOT USE without check in user-facing endpoints.\"\"\"\n    _updated_webhook = await IntegrationWebhook.prisma().update(where={'id': webhook_id}, data={'config': Json(updated_config)}, include=INTEGRATION_WEBHOOK_INCLUDE)\n    if _updated_webhook is None:\n        raise ValueError(f'Webhook #{webhook_id} not found')\n    return Webhook.from_db(_updated_webhook)\n'⚠️ No `user_id` check: DO NOT USE without check in user-facing endpoints.'\n_updated_webhook = await IntegrationWebhook.prisma().update(where={'id': webhook_id}, data={'config': Json(updated_config)}, include=INTEGRATION_WEBHOOK_INCLUDE)\n_updated_webhook Is None"
    },
    {
      "id": "n14",
      "type": "block",
      "statements": [
        "raise ValueError(f'Webhook #{webhook_id} not found')"
      ],
      "code": "raise ValueError(f'Webhook #{webhook_id} not found')"
    },
    {
      "id": "n15",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n16",
      "type": "block",
      "statements": [
        "return Webhook.from_db(_updated_webhook)"
      ],
      "code": "return Webhook.from_db(_updated_webhook)"
    },
    {
      "id": "n17",
      "type": "block",
      "statements": [
        "async def delete_webhook(webhook_id: str) -> None:\n    \"\"\"⚠️ No `user_id` check: DO NOT USE without check in user-facing endpoints.\"\"\"\n    deleted = await IntegrationWebhook.prisma().delete(where={'id': webhook_id})\n    if not deleted:\n        raise ValueError(f'Webhook #{webhook_id} not found')",
        "'⚠️ No `user_id` check: DO NOT USE without check in user-facing endpoints.'",
        "deleted = await IntegrationWebhook.prisma().delete(where={'id': webhook_id})",
        "not deleted"
      ],
      "code": "async def delete_webhook(webhook_id: str) -> None:\n    \"\"\"⚠️ No `user_id` check: DO NOT USE without check in user-facing endpoints.\"\"\"\n    deleted = await IntegrationWebhook.prisma().delete(where={'id': webhook_id})\n    if not deleted:\n        raise ValueError(f'Webhook #{webhook_id} not found')\n'⚠️ No `user_id` check: DO NOT USE without check in user-facing endpoints.'\ndeleted = await IntegrationWebhook.prisma().delete(where={'id': webhook_id})\nnot deleted"
    },
    {
      "id": "n18",
      "type": "block",
      "statements": [
        "raise ValueError(f'Webhook #{webhook_id} not found')"
      ],
      "code": "raise ValueError(f'Webhook #{webhook_id} not found')"
    },
    {
      "id": "n19",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n20",
      "type": "block",
      "statements": [
        "class WebhookEvent(BaseDbModel):\n    provider: str\n    webhook_id: str\n    event_type: str\n    payload: dict",
        "provider: str",
        "webhook_id: str",
        "event_type: str",
        "payload: dict",
        "class WebhookEventBus(AsyncRedisEventBus[WebhookEvent]):\n    Model = WebhookEvent\n\n    @property\n    def event_bus_name(self) -> str:\n        return 'webhooks'",
        "Model = WebhookEvent",
        "@property\ndef event_bus_name(self) -> str:\n    return 'webhooks'",
        "return 'webhooks'"
      ],
      "code": "class WebhookEvent(BaseDbModel):\n    provider: str\n    webhook_id: str\n    event_type: str\n    payload: dict\nprovider: str\nwebhook_id: str\nevent_type: str\npayload: dict\nclass WebhookEventBus(AsyncRedisEventBus[WebhookEvent]):\n    Model = WebhookEvent\n\n    @property\n    def event_bus_name(self) -> str:\n        return 'webhooks'\nModel = WebhookEvent\n@property\ndef event_bus_name(self) -> str:\n    return 'webhooks'\nreturn 'webhooks'"
    },
    {
      "id": "n21",
      "type": "block",
      "statements": [
        "_webhook_event_bus = WebhookEventBus()",
        "async def publish_webhook_event(event: WebhookEvent):\n    await _webhook_event_bus.publish_event(event, f'{event.webhook_id}/{event.event_type}')",
        "await _webhook_event_bus.publish_event(event, f'{event.webhook_id}/{event.event_type}')",
        "async def listen_for_webhook_events(webhook_id: str, event_type: Optional[str]=None) -> AsyncGenerator[WebhookEvent, None]:\n    async for event in _webhook_event_bus.listen_events(f\"{webhook_id}/{event_type or '*'}\"):\n        yield event",
        "async for event in _webhook_event_bus.listen_events(f\"{webhook_id}/{event_type or '*'}\"):\n    yield event",
        "(yield event)",
        "async def wait_for_webhook_event(webhook_id: str, event_type: Optional[str]=None, timeout: Optional[float]=None) -> WebhookEvent | None:\n    return await _webhook_event_bus.wait_for_event(f\"{webhook_id}/{event_type or '*'}\", timeout)",
        "return await _webhook_event_bus.wait_for_event(f\"{webhook_id}/{event_type or '*'}\", timeout)"
      ],
      "code": "_webhook_event_bus = WebhookEventBus()\nasync def publish_webhook_event(event: WebhookEvent):\n    await _webhook_event_bus.publish_event(event, f'{event.webhook_id}/{event.event_type}')\nawait _webhook_event_bus.publish_event(event, f'{event.webhook_id}/{event.event_type}')\nasync def listen_for_webhook_events(webhook_id: str, event_type: Optional[str]=None) -> AsyncGenerator[WebhookEvent, None]:\n    async for event in _webhook_event_bus.listen_events(f\"{webhook_id}/{event_type or '*'}\"):\n        yield event\nasync for event in _webhook_event_bus.listen_events(f\"{webhook_id}/{event_type or '*'}\"):\n    yield event\n(yield event)\nasync def wait_for_webhook_event(webhook_id: str, event_type: Optional[str]=None, timeout: Optional[float]=None) -> WebhookEvent | None:\n    return await _webhook_event_bus.wait_for_event(f\"{webhook_id}/{event_type or '*'}\", timeout)\nreturn await _webhook_event_bus.wait_for_event(f\"{webhook_id}/{event_type or '*'}\", timeout)"
    }
  ],
  "edges": [
    {
      "source": "n18",
      "target": "n20"
    },
    {
      "source": "n1",
      "target": "n3"
    },
    {
      "source": "n15",
      "target": "n16"
    },
    {
      "source": "n8",
      "target": "n10"
    },
    {
      "source": "n0",
      "target": "n1"
    },
    {
      "source": "n0",
      "target": "n2"
    },
    {
      "source": "n14",
      "target": "n16"
    },
    {
      "source": "n13",
      "target": "n15"
    },
    {
      "source": "n17",
      "target": "n18"
    },
    {
      "source": "n9",
      "target": "n10"
    },
    {
      "source": "n19",
      "target": "n20"
    },
    {
      "source": "n17",
      "target": "n19"
    },
    {
      "source": "n7",
      "target": "n8"
    },
    {
      "source": "n2",
      "target": "n3"
    },
    {
      "source": "n13",
      "target": "n14"
    },
    {
      "source": "n7",
      "target": "n9"
    }
  ]
}