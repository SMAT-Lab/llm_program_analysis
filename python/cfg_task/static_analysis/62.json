{
  "nodes": [
    {
      "id": "n0",
      "type": "block",
      "statements": [
        "from urllib.parse import parse_qs, urlparse",
        "from youtube_transcript_api import YouTubeTranscriptApi",
        "from youtube_transcript_api.formatters import TextFormatter",
        "from backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema",
        "from backend.data.model import SchemaField",
        "class TranscribeYoutubeVideoBlock(Block):\n\n    class Input(BlockSchema):\n        youtube_url: str = SchemaField(title='YouTube URL', description='The URL of the YouTube video to transcribe', placeholder='https://www.youtube.com/watch?v=dQw4w9WgXcQ')\n\n    class Output(BlockSchema):\n        video_id: str = SchemaField(description='The extracted YouTube video ID')\n        transcript: str = SchemaField(description='The transcribed text of the video')\n        error: str = SchemaField(description='Any error message if the transcription fails')\n\n    def __init__(self):\n        super().__init__(id='f3a8f7e1-4b1d-4e5f-9f2a-7c3d5a2e6b4c', input_schema=TranscribeYoutubeVideoBlock.Input, output_schema=TranscribeYoutubeVideoBlock.Output, description='Transcribes a YouTube video.', categories={BlockCategory.SOCIAL}, test_input={'youtube_url': 'https://www.youtube.com/watch?v=dQw4w9WgXcQ'}, test_output=[('video_id', 'dQw4w9WgXcQ'), ('transcript', 'Never gonna give you up\\nNever gonna let you down')], test_mock={'get_transcript': lambda video_id: [{'text': 'Never gonna give you up'}, {'text': 'Never gonna let you down'}]})\n\n    @staticmethod\n    def extract_video_id(url: str) -> str:\n        parsed_url = urlparse(url)\n        if parsed_url.netloc == 'youtu.be':\n            return parsed_url.path[1:]\n        if parsed_url.netloc in ('www.youtube.com', 'youtube.com'):\n            if parsed_url.path == '/watch':\n                p = parse_qs(parsed_url.query)\n                return p['v'][0]\n            if parsed_url.path[:7] == '/embed/':\n                return parsed_url.path.split('/')[2]\n            if parsed_url.path[:3] == '/v/':\n                return parsed_url.path.split('/')[2]\n        raise ValueError(f'Invalid YouTube URL: {url}')\n\n    @staticmethod\n    def get_transcript(video_id: str):\n        try:\n            transcript_list = YouTubeTranscriptApi.list_transcripts(video_id)\n            if not transcript_list:\n                raise ValueError(f'No transcripts found for the video: {video_id}')\n            for transcript in transcript_list:\n                first_transcript = transcript_list.find_transcript([transcript.language_code])\n                return YouTubeTranscriptApi.get_transcript(video_id, languages=[first_transcript.language_code])\n        except Exception:\n            raise ValueError(f'No transcripts found for the video: {video_id}')\n\n    def run(self, input_data: Input, **kwargs) -> BlockOutput:\n        video_id = self.extract_video_id(input_data.youtube_url)\n        yield ('video_id', video_id)\n        transcript = self.get_transcript(video_id)\n        formatter = TextFormatter()\n        transcript_text = formatter.format_transcript(transcript)\n        yield ('transcript', transcript_text)",
        "class Input(BlockSchema):\n    youtube_url: str = SchemaField(title='YouTube URL', description='The URL of the YouTube video to transcribe', placeholder='https://www.youtube.com/watch?v=dQw4w9WgXcQ')",
        "youtube_url: str = SchemaField(title='YouTube URL', description='The URL of the YouTube video to transcribe', placeholder='https://www.youtube.com/watch?v=dQw4w9WgXcQ')",
        "class Output(BlockSchema):\n    video_id: str = SchemaField(description='The extracted YouTube video ID')\n    transcript: str = SchemaField(description='The transcribed text of the video')\n    error: str = SchemaField(description='Any error message if the transcription fails')",
        "video_id: str = SchemaField(description='The extracted YouTube video ID')",
        "transcript: str = SchemaField(description='The transcribed text of the video')",
        "error: str = SchemaField(description='Any error message if the transcription fails')",
        "def __init__(self):\n    super().__init__(id='f3a8f7e1-4b1d-4e5f-9f2a-7c3d5a2e6b4c', input_schema=TranscribeYoutubeVideoBlock.Input, output_schema=TranscribeYoutubeVideoBlock.Output, description='Transcribes a YouTube video.', categories={BlockCategory.SOCIAL}, test_input={'youtube_url': 'https://www.youtube.com/watch?v=dQw4w9WgXcQ'}, test_output=[('video_id', 'dQw4w9WgXcQ'), ('transcript', 'Never gonna give you up\\nNever gonna let you down')], test_mock={'get_transcript': lambda video_id: [{'text': 'Never gonna give you up'}, {'text': 'Never gonna let you down'}]})",
        "super().__init__()",
        "@staticmethod\ndef extract_video_id(url: str) -> str:\n    parsed_url = urlparse(url)\n    if parsed_url.netloc == 'youtu.be':\n        return parsed_url.path[1:]\n    if parsed_url.netloc in ('www.youtube.com', 'youtube.com'):\n        if parsed_url.path == '/watch':\n            p = parse_qs(parsed_url.query)\n            return p['v'][0]\n        if parsed_url.path[:7] == '/embed/':\n            return parsed_url.path.split('/')[2]\n        if parsed_url.path[:3] == '/v/':\n            return parsed_url.path.split('/')[2]\n    raise ValueError(f'Invalid YouTube URL: {url}')",
        "parsed_url = urlparse(url)",
        "parsed_url.netloc Eq 'youtu.be'"
      ],
      "code": "from urllib.parse import parse_qs, urlparse\nfrom youtube_transcript_api import YouTubeTranscriptApi\nfrom youtube_transcript_api.formatters import TextFormatter\nfrom backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema\nfrom backend.data.model import SchemaField\nclass TranscribeYoutubeVideoBlock(Block):\n\n    class Input(BlockSchema):\n        youtube_url: str = SchemaField(title='YouTube URL', description='The URL of the YouTube video to transcribe', placeholder='https://www.youtube.com/watch?v=dQw4w9WgXcQ')\n\n    class Output(BlockSchema):\n        video_id: str = SchemaField(description='The extracted YouTube video ID')\n        transcript: str = SchemaField(description='The transcribed text of the video')\n        error: str = SchemaField(description='Any error message if the transcription fails')\n\n    def __init__(self):\n        super().__init__(id='f3a8f7e1-4b1d-4e5f-9f2a-7c3d5a2e6b4c', input_schema=TranscribeYoutubeVideoBlock.Input, output_schema=TranscribeYoutubeVideoBlock.Output, description='Transcribes a YouTube video.', categories={BlockCategory.SOCIAL}, test_input={'youtube_url': 'https://www.youtube.com/watch?v=dQw4w9WgXcQ'}, test_output=[('video_id', 'dQw4w9WgXcQ'), ('transcript', 'Never gonna give you up\\nNever gonna let you down')], test_mock={'get_transcript': lambda video_id: [{'text': 'Never gonna give you up'}, {'text': 'Never gonna let you down'}]})\n\n    @staticmethod\n    def extract_video_id(url: str) -> str:\n        parsed_url = urlparse(url)\n        if parsed_url.netloc == 'youtu.be':\n            return parsed_url.path[1:]\n        if parsed_url.netloc in ('www.youtube.com', 'youtube.com'):\n            if parsed_url.path == '/watch':\n                p = parse_qs(parsed_url.query)\n                return p['v'][0]\n            if parsed_url.path[:7] == '/embed/':\n                return parsed_url.path.split('/')[2]\n            if parsed_url.path[:3] == '/v/':\n                return parsed_url.path.split('/')[2]\n        raise ValueError(f'Invalid YouTube URL: {url}')\n\n    @staticmethod\n    def get_transcript(video_id: str):\n        try:\n            transcript_list = YouTubeTranscriptApi.list_transcripts(video_id)\n            if not transcript_list:\n                raise ValueError(f'No transcripts found for the video: {video_id}')\n            for transcript in transcript_list:\n                first_transcript = transcript_list.find_transcript([transcript.language_code])\n                return YouTubeTranscriptApi.get_transcript(video_id, languages=[first_transcript.language_code])\n        except Exception:\n            raise ValueError(f'No transcripts found for the video: {video_id}')\n\n    def run(self, input_data: Input, **kwargs) -> BlockOutput:\n        video_id = self.extract_video_id(input_data.youtube_url)\n        yield ('video_id', video_id)\n        transcript = self.get_transcript(video_id)\n        formatter = TextFormatter()\n        transcript_text = formatter.format_transcript(transcript)\n        yield ('transcript', transcript_text)\nclass Input(BlockSchema):\n    youtube_url: str = SchemaField(title='YouTube URL', description='The URL of the YouTube video to transcribe', placeholder='https://www.youtube.com/watch?v=dQw4w9WgXcQ')\nyoutube_url: str = SchemaField(title='YouTube URL', description='The URL of the YouTube video to transcribe', placeholder='https://www.youtube.com/watch?v=dQw4w9WgXcQ')\nclass Output(BlockSchema):\n    video_id: str = SchemaField(description='The extracted YouTube video ID')\n    transcript: str = SchemaField(description='The transcribed text of the video')\n    error: str = SchemaField(description='Any error message if the transcription fails')\nvideo_id: str = SchemaField(description='The extracted YouTube video ID')\ntranscript: str = SchemaField(description='The transcribed text of the video')\nerror: str = SchemaField(description='Any error message if the transcription fails')\ndef __init__(self):\n    super().__init__(id='f3a8f7e1-4b1d-4e5f-9f2a-7c3d5a2e6b4c', input_schema=TranscribeYoutubeVideoBlock.Input, output_schema=TranscribeYoutubeVideoBlock.Output, description='Transcribes a YouTube video.', categories={BlockCategory.SOCIAL}, test_input={'youtube_url': 'https://www.youtube.com/watch?v=dQw4w9WgXcQ'}, test_output=[('video_id', 'dQw4w9WgXcQ'), ('transcript', 'Never gonna give you up\\nNever gonna let you down')], test_mock={'get_transcript': lambda video_id: [{'text': 'Never gonna give you up'}, {'text': 'Never gonna let you down'}]})\nsuper().__init__()\n@staticmethod\ndef extract_video_id(url: str) -> str:\n    parsed_url = urlparse(url)\n    if parsed_url.netloc == 'youtu.be':\n        return parsed_url.path[1:]\n    if parsed_url.netloc in ('www.youtube.com', 'youtube.com'):\n        if parsed_url.path == '/watch':\n            p = parse_qs(parsed_url.query)\n            return p['v'][0]\n        if parsed_url.path[:7] == '/embed/':\n            return parsed_url.path.split('/')[2]\n        if parsed_url.path[:3] == '/v/':\n            return parsed_url.path.split('/')[2]\n    raise ValueError(f'Invalid YouTube URL: {url}')\nparsed_url = urlparse(url)\nparsed_url.netloc Eq 'youtu.be'"
    },
    {
      "id": "n1",
      "type": "block",
      "statements": [
        "return parsed_url.path[1:]"
      ],
      "code": "return parsed_url.path[1:]"
    },
    {
      "id": "n2",
      "type": "block",
      "statements": [],
      "code": "\nparsed_url.netloc In ('www.youtube.com', 'youtube.com')"
    },
    {
      "id": "n3",
      "type": "block",
      "statements": [
        "parsed_url.path Eq '/watch'"
      ],
      "code": "parsed_url.path Eq '/watch'"
    },
    {
      "id": "n4",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n5",
      "type": "block",
      "statements": [
        "raise ValueError(f'Invalid YouTube URL: {url}')",
        "@staticmethod\ndef get_transcript(video_id: str):\n    try:\n        transcript_list = YouTubeTranscriptApi.list_transcripts(video_id)\n        if not transcript_list:\n            raise ValueError(f'No transcripts found for the video: {video_id}')\n        for transcript in transcript_list:\n            first_transcript = transcript_list.find_transcript([transcript.language_code])\n            return YouTubeTranscriptApi.get_transcript(video_id, languages=[first_transcript.language_code])\n    except Exception:\n        raise ValueError(f'No transcripts found for the video: {video_id}')",
        "try:\n    transcript_list = YouTubeTranscriptApi.list_transcripts(video_id)\n    if not transcript_list:\n        raise ValueError(f'No transcripts found for the video: {video_id}')\n    for transcript in transcript_list:\n        first_transcript = transcript_list.find_transcript([transcript.language_code])\n        return YouTubeTranscriptApi.get_transcript(video_id, languages=[first_transcript.language_code])\nexcept Exception:\n    raise ValueError(f'No transcripts found for the video: {video_id}')",
        "transcript_list = YouTubeTranscriptApi.list_transcripts(video_id)",
        "not transcript_list"
      ],
      "code": "raise ValueError(f'Invalid YouTube URL: {url}')\n@staticmethod\ndef get_transcript(video_id: str):\n    try:\n        transcript_list = YouTubeTranscriptApi.list_transcripts(video_id)\n        if not transcript_list:\n            raise ValueError(f'No transcripts found for the video: {video_id}')\n        for transcript in transcript_list:\n            first_transcript = transcript_list.find_transcript([transcript.language_code])\n            return YouTubeTranscriptApi.get_transcript(video_id, languages=[first_transcript.language_code])\n    except Exception:\n        raise ValueError(f'No transcripts found for the video: {video_id}')\ntry:\n    transcript_list = YouTubeTranscriptApi.list_transcripts(video_id)\n    if not transcript_list:\n        raise ValueError(f'No transcripts found for the video: {video_id}')\n    for transcript in transcript_list:\n        first_transcript = transcript_list.find_transcript([transcript.language_code])\n        return YouTubeTranscriptApi.get_transcript(video_id, languages=[first_transcript.language_code])\nexcept Exception:\n    raise ValueError(f'No transcripts found for the video: {video_id}')\ntranscript_list = YouTubeTranscriptApi.list_transcripts(video_id)\nnot transcript_list"
    },
    {
      "id": "n6",
      "type": "block",
      "statements": [
        "p = parse_qs(parsed_url.query)",
        "return p['v'][0]"
      ],
      "code": "p = parse_qs(parsed_url.query)\nreturn p['v'][0]"
    },
    {
      "id": "n7",
      "type": "block",
      "statements": [],
      "code": "\nparsed_url.path[:7] Eq '/embed/'"
    },
    {
      "id": "n8",
      "type": "block",
      "statements": [
        "return parsed_url.path.split('/')[2]"
      ],
      "code": "return parsed_url.path.split('/')[2]"
    },
    {
      "id": "n9",
      "type": "block",
      "statements": [],
      "code": "\nparsed_url.path[:3] Eq '/v/'"
    },
    {
      "id": "n10",
      "type": "block",
      "statements": [
        "return parsed_url.path.split('/')[2]"
      ],
      "code": "return parsed_url.path.split('/')[2]"
    },
    {
      "id": "n11",
      "type": "block",
      "statements": [],
      "code": "\n"
    },
    {
      "id": "n12",
      "type": "block",
      "statements": [
        "raise ValueError(f'No transcripts found for the video: {video_id}')"
      ],
      "code": "raise ValueError(f'No transcripts found for the video: {video_id}')"
    },
    {
      "id": "n13",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n14",
      "type": "block",
      "statements": [],
      "code": "\ntranscript\ntranscript_list"
    },
    {
      "id": "n15",
      "type": "block",
      "statements": [
        "first_transcript = transcript_list.find_transcript([transcript.language_code])",
        "return YouTubeTranscriptApi.get_transcript(video_id, languages=[first_transcript.language_code])"
      ],
      "code": "first_transcript = transcript_list.find_transcript([transcript.language_code])\nreturn YouTubeTranscriptApi.get_transcript(video_id, languages=[first_transcript.language_code])"
    },
    {
      "id": "n16",
      "type": "block",
      "statements": [
        "raise ValueError(f'No transcripts found for the video: {video_id}')",
        "def run(self, input_data: Input, **kwargs) -> BlockOutput:\n    video_id = self.extract_video_id(input_data.youtube_url)\n    yield ('video_id', video_id)\n    transcript = self.get_transcript(video_id)\n    formatter = TextFormatter()\n    transcript_text = formatter.format_transcript(transcript)\n    yield ('transcript', transcript_text)",
        "video_id = self.extract_video_id(input_data.youtube_url)",
        "(yield ('video_id', video_id))",
        "transcript = self.get_transcript(video_id)",
        "formatter = TextFormatter()",
        "transcript_text = formatter.format_transcript(transcript)",
        "(yield ('transcript', transcript_text))"
      ],
      "code": "raise ValueError(f'No transcripts found for the video: {video_id}')\ndef run(self, input_data: Input, **kwargs) -> BlockOutput:\n    video_id = self.extract_video_id(input_data.youtube_url)\n    yield ('video_id', video_id)\n    transcript = self.get_transcript(video_id)\n    formatter = TextFormatter()\n    transcript_text = formatter.format_transcript(transcript)\n    yield ('transcript', transcript_text)\nvideo_id = self.extract_video_id(input_data.youtube_url)\n(yield ('video_id', video_id))\ntranscript = self.get_transcript(video_id)\nformatter = TextFormatter()\ntranscript_text = formatter.format_transcript(transcript)\n(yield ('transcript', transcript_text))"
    }
  ],
  "edges": [
    {
      "source": "n12",
      "target": "n14"
    },
    {
      "source": "n9",
      "target": "n11"
    },
    {
      "source": "n2",
      "target": "n3"
    },
    {
      "source": "n2",
      "target": "n4"
    },
    {
      "source": "n14",
      "target": "n15"
    },
    {
      "source": "n0",
      "target": "n1"
    },
    {
      "source": "n14",
      "target": "n16"
    },
    {
      "source": "n11",
      "target": "n5"
    },
    {
      "source": "n5",
      "target": "n12"
    },
    {
      "source": "n5",
      "target": "n13"
    },
    {
      "source": "n3",
      "target": "n6"
    },
    {
      "source": "n9",
      "target": "n10"
    },
    {
      "source": "n4",
      "target": "n5"
    },
    {
      "source": "n13",
      "target": "n14"
    },
    {
      "source": "n7",
      "target": "n8"
    },
    {
      "source": "n0",
      "target": "n2"
    },
    {
      "source": "n3",
      "target": "n7"
    },
    {
      "source": "n7",
      "target": "n9"
    }
  ]
}