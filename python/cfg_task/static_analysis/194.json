{
  "nodes": [
    {
      "id": "n0",
      "type": "block",
      "statements": [
        "'\\nIn this problem, we want to determine all possible permutations\\nof the given sequence. We use backtracking to solve this problem.\\n\\nTime complexity: O(n! * n),\\nwhere n denotes the length of the given sequence.\\n'",
        "from __future__ import annotations",
        "def generate_all_permutations(sequence: list[int | str]) -> None:\n    create_state_space_tree(sequence, [], 0, [0 for i in range(len(sequence))])",
        "create_state_space_tree(sequence, [], 0, [0 for i in range(len(sequence))])",
        "def create_state_space_tree(sequence: list[int | str], current_sequence: list[int | str], index: int, index_used: list[int]) -> None:\n    \"\"\"\n    Creates a state space tree to iterate through each branch using DFS.\n    We know that each state has exactly len(sequence) - index children.\n    It terminates when it reaches the end of the given sequence.\n\n    :param sequence: The input sequence for which permutations are generated.\n    :param current_sequence: The current permutation being built.\n    :param index: The current index in the sequence.\n    :param index_used: list to track which elements are used in permutation.\n\n    Example 1:\n    >>> sequence = [1, 2, 3]\n    >>> current_sequence = []\n    >>> index_used = [False, False, False]\n    >>> create_state_space_tree(sequence, current_sequence, 0, index_used)\n    [1, 2, 3]\n    [1, 3, 2]\n    [2, 1, 3]\n    [2, 3, 1]\n    [3, 1, 2]\n    [3, 2, 1]\n\n    Example 2:\n    >>> sequence = [\"A\", \"B\", \"C\"]\n    >>> current_sequence = []\n    >>> index_used = [False, False, False]\n    >>> create_state_space_tree(sequence, current_sequence, 0, index_used)\n    ['A', 'B', 'C']\n    ['A', 'C', 'B']\n    ['B', 'A', 'C']\n    ['B', 'C', 'A']\n    ['C', 'A', 'B']\n    ['C', 'B', 'A']\n\n    Example 3:\n    >>> sequence = [1]\n    >>> current_sequence = []\n    >>> index_used = [False]\n    >>> create_state_space_tree(sequence, current_sequence, 0, index_used)\n    [1]\n    \"\"\"\n    if index == len(sequence):\n        print(current_sequence)\n        return\n    for i in range(len(sequence)):\n        if not index_used[i]:\n            current_sequence.append(sequence[i])\n            index_used[i] = True\n            create_state_space_tree(sequence, current_sequence, index + 1, index_used)\n            current_sequence.pop()\n            index_used[i] = False",
        "'\\n    Creates a state space tree to iterate through each branch using DFS.\\n    We know that each state has exactly len(sequence) - index children.\\n    It terminates when it reaches the end of the given sequence.\\n\\n    :param sequence: The input sequence for which permutations are generated.\\n    :param current_sequence: The current permutation being built.\\n    :param index: The current index in the sequence.\\n    :param index_used: list to track which elements are used in permutation.\\n\\n    Example 1:\\n    >>> sequence = [1, 2, 3]\\n    >>> current_sequence = []\\n    >>> index_used = [False, False, False]\\n    >>> create_state_space_tree(sequence, current_sequence, 0, index_used)\\n    [1, 2, 3]\\n    [1, 3, 2]\\n    [2, 1, 3]\\n    [2, 3, 1]\\n    [3, 1, 2]\\n    [3, 2, 1]\\n\\n    Example 2:\\n    >>> sequence = [\"A\", \"B\", \"C\"]\\n    >>> current_sequence = []\\n    >>> index_used = [False, False, False]\\n    >>> create_state_space_tree(sequence, current_sequence, 0, index_used)\\n    [\\'A\\', \\'B\\', \\'C\\']\\n    [\\'A\\', \\'C\\', \\'B\\']\\n    [\\'B\\', \\'A\\', \\'C\\']\\n    [\\'B\\', \\'C\\', \\'A\\']\\n    [\\'C\\', \\'A\\', \\'B\\']\\n    [\\'C\\', \\'B\\', \\'A\\']\\n\\n    Example 3:\\n    >>> sequence = [1]\\n    >>> current_sequence = []\\n    >>> index_used = [False]\\n    >>> create_state_space_tree(sequence, current_sequence, 0, index_used)\\n    [1]\\n    '",
        "index Eq len(sequence)"
      ],
      "code": "'\\nIn this problem, we want to determine all possible permutations\\nof the given sequence. We use backtracking to solve this problem.\\n\\nTime complexity: O(n! * n),\\nwhere n denotes the length of the given sequence.\\n'\nfrom __future__ import annotations\ndef generate_all_permutations(sequence: list[int | str]) -> None:\n    create_state_space_tree(sequence, [], 0, [0 for i in range(len(sequence))])\ncreate_state_space_tree(sequence, [], 0, [0 for i in range(len(sequence))])\ndef create_state_space_tree(sequence: list[int | str], current_sequence: list[int | str], index: int, index_used: list[int]) -> None:\n    \"\"\"\n    Creates a state space tree to iterate through each branch using DFS.\n    We know that each state has exactly len(sequence) - index children.\n    It terminates when it reaches the end of the given sequence.\n\n    :param sequence: The input sequence for which permutations are generated.\n    :param current_sequence: The current permutation being built.\n    :param index: The current index in the sequence.\n    :param index_used: list to track which elements are used in permutation.\n\n    Example 1:\n    >>> sequence = [1, 2, 3]\n    >>> current_sequence = []\n    >>> index_used = [False, False, False]\n    >>> create_state_space_tree(sequence, current_sequence, 0, index_used)\n    [1, 2, 3]\n    [1, 3, 2]\n    [2, 1, 3]\n    [2, 3, 1]\n    [3, 1, 2]\n    [3, 2, 1]\n\n    Example 2:\n    >>> sequence = [\"A\", \"B\", \"C\"]\n    >>> current_sequence = []\n    >>> index_used = [False, False, False]\n    >>> create_state_space_tree(sequence, current_sequence, 0, index_used)\n    ['A', 'B', 'C']\n    ['A', 'C', 'B']\n    ['B', 'A', 'C']\n    ['B', 'C', 'A']\n    ['C', 'A', 'B']\n    ['C', 'B', 'A']\n\n    Example 3:\n    >>> sequence = [1]\n    >>> current_sequence = []\n    >>> index_used = [False]\n    >>> create_state_space_tree(sequence, current_sequence, 0, index_used)\n    [1]\n    \"\"\"\n    if index == len(sequence):\n        print(current_sequence)\n        return\n    for i in range(len(sequence)):\n        if not index_used[i]:\n            current_sequence.append(sequence[i])\n            index_used[i] = True\n            create_state_space_tree(sequence, current_sequence, index + 1, index_used)\n            current_sequence.pop()\n            index_used[i] = False\n'\\n    Creates a state space tree to iterate through each branch using DFS.\\n    We know that each state has exactly len(sequence) - index children.\\n    It terminates when it reaches the end of the given sequence.\\n\\n    :param sequence: The input sequence for which permutations are generated.\\n    :param current_sequence: The current permutation being built.\\n    :param index: The current index in the sequence.\\n    :param index_used: list to track which elements are used in permutation.\\n\\n    Example 1:\\n    >>> sequence = [1, 2, 3]\\n    >>> current_sequence = []\\n    >>> index_used = [False, False, False]\\n    >>> create_state_space_tree(sequence, current_sequence, 0, index_used)\\n    [1, 2, 3]\\n    [1, 3, 2]\\n    [2, 1, 3]\\n    [2, 3, 1]\\n    [3, 1, 2]\\n    [3, 2, 1]\\n\\n    Example 2:\\n    >>> sequence = [\"A\", \"B\", \"C\"]\\n    >>> current_sequence = []\\n    >>> index_used = [False, False, False]\\n    >>> create_state_space_tree(sequence, current_sequence, 0, index_used)\\n    [\\'A\\', \\'B\\', \\'C\\']\\n    [\\'A\\', \\'C\\', \\'B\\']\\n    [\\'B\\', \\'A\\', \\'C\\']\\n    [\\'B\\', \\'C\\', \\'A\\']\\n    [\\'C\\', \\'A\\', \\'B\\']\\n    [\\'C\\', \\'B\\', \\'A\\']\\n\\n    Example 3:\\n    >>> sequence = [1]\\n    >>> current_sequence = []\\n    >>> index_used = [False]\\n    >>> create_state_space_tree(sequence, current_sequence, 0, index_used)\\n    [1]\\n    '\nindex Eq len(sequence)"
    },
    {
      "id": "n1",
      "type": "block",
      "statements": [
        "print(current_sequence)",
        "return"
      ],
      "code": "print(current_sequence)\nreturn"
    },
    {
      "id": "n2",
      "type": "block",
      "statements": [],
      "code": "\n"
    },
    {
      "id": "n3",
      "type": "block",
      "statements": [
        "i",
        "range(len(sequence))"
      ],
      "code": "i\nrange(len(sequence))"
    },
    {
      "id": "n4",
      "type": "block",
      "statements": [
        "not index_used[i]"
      ],
      "code": "not index_used[i]"
    },
    {
      "id": "n5",
      "type": "block",
      "statements": [
        "'\\nremove the comment to take an input from the user\\n\\nprint(\"Enter the elements\")\\nsequence = list(map(int, input().split()))\\n'",
        "sequence: list[int | str] = [3, 1, 2, 4]",
        "generate_all_permutations(sequence)",
        "sequence_2: list[int | str] = ['A', 'B', 'C']",
        "generate_all_permutations(sequence_2)"
      ],
      "code": "'\\nremove the comment to take an input from the user\\n\\nprint(\"Enter the elements\")\\nsequence = list(map(int, input().split()))\\n'\nsequence: list[int | str] = [3, 1, 2, 4]\ngenerate_all_permutations(sequence)\nsequence_2: list[int | str] = ['A', 'B', 'C']\ngenerate_all_permutations(sequence_2)"
    },
    {
      "id": "n6",
      "type": "block",
      "statements": [
        "current_sequence.append(sequence[i])",
        "index_used[i] = True",
        "create_state_space_tree(sequence, current_sequence, index Add 1, index_used)",
        "current_sequence.pop()",
        "index_used[i] = False"
      ],
      "code": "current_sequence.append(sequence[i])\nindex_used[i] = True\ncreate_state_space_tree(sequence, current_sequence, index Add 1, index_used)\ncurrent_sequence.pop()\nindex_used[i] = False"
    },
    {
      "id": "n7",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n8",
      "type": "block",
      "statements": [],
      "code": ""
    }
  ],
  "edges": [
    {
      "source": "n0",
      "target": "n2"
    },
    {
      "source": "n0",
      "target": "n1"
    },
    {
      "source": "n4",
      "target": "n7"
    },
    {
      "source": "n3",
      "target": "n4"
    },
    {
      "source": "n3",
      "target": "n5"
    },
    {
      "source": "n4",
      "target": "n6"
    },
    {
      "source": "n6",
      "target": "n8"
    },
    {
      "source": "n7",
      "target": "n8"
    },
    {
      "source": "n2",
      "target": "n3"
    },
    {
      "source": "n8",
      "target": "n3"
    }
  ]
}