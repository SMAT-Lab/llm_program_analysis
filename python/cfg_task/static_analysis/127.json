{
  "nodes": [
    {
      "id": "n0",
      "type": "block",
      "statements": [
        "from __future__ import annotations",
        "def solve_maze(maze: list[list[int]], source_row: int, source_column: int, destination_row: int, destination_column: int) -> list[list[int]]:\n    \"\"\"\n    This method solves the \"rat in maze\" problem.\n    Parameters :\n        - maze: A two dimensional matrix of zeros and ones.\n        - source_row: The row index of the starting point.\n        - source_column: The column index of the starting point.\n        - destination_row: The row index of the destination point.\n        - destination_column: The column index of the destination point.\n    Returns:\n        - solution: A 2D matrix representing the solution path if it exists.\n    Raises:\n        - ValueError: If no solution exists or if the source or\n            destination coordinates are invalid.\n    Description:\n        This method navigates through a maze represented as an n by n matrix,\n        starting from a specified source cell and\n        aiming to reach a destination cell.\n        The maze consists of walls (1s) and open paths (0s).\n        By providing custom row and column values, the source and destination\n        cells can be adjusted.\n    >>> maze = [[0, 1, 0, 1, 1],\n    ...         [0, 0, 0, 0, 0],\n    ...         [1, 0, 1, 0, 1],\n    ...         [0, 0, 1, 0, 0],\n    ...         [1, 0, 0, 1, 0]]\n    >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE\n    [[0, 1, 1, 1, 1],\n    [0, 0, 0, 0, 1],\n    [1, 1, 1, 0, 1],\n    [1, 1, 1, 0, 0],\n    [1, 1, 1, 1, 0]]\n\n    Note:\n        In the output maze, the zeros (0s) represent one of the possible\n        paths from the source to the destination.\n\n    >>> maze = [[0, 1, 0, 1, 1],\n    ...         [0, 0, 0, 0, 0],\n    ...         [0, 0, 0, 0, 1],\n    ...         [0, 0, 0, 0, 0],\n    ...         [0, 0, 0, 0, 0]]\n    >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE\n    [[0, 1, 1, 1, 1],\n    [0, 1, 1, 1, 1],\n    [0, 1, 1, 1, 1],\n    [0, 1, 1, 1, 1],\n    [0, 0, 0, 0, 0]]\n\n    >>> maze = [[0, 0, 0],\n    ...         [0, 1, 0],\n    ...         [1, 0, 0]]\n    >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE\n    [[0, 0, 0],\n    [1, 1, 0],\n    [1, 1, 0]]\n\n    >>> maze = [[1, 0, 0],\n    ...         [0, 1, 0],\n    ...         [1, 0, 0]]\n    >>> solve_maze(maze,0,1,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE\n    [[1, 0, 0],\n    [1, 1, 0],\n    [1, 1, 0]]\n\n    >>> maze = [[1, 1, 0, 0, 1, 0, 0, 1],\n    ...         [1, 0, 1, 0, 0, 1, 1, 1],\n    ...         [0, 1, 0, 1, 0, 0, 1, 0],\n    ...         [1, 1, 1, 0, 0, 1, 0, 1],\n    ...         [0, 1, 0, 0, 1, 0, 1, 1],\n    ...         [0, 0, 0, 1, 1, 1, 0, 1],\n    ...         [0, 1, 0, 1, 0, 1, 1, 1],\n    ...         [1, 1, 0, 0, 0, 0, 0, 1]]\n    >>> solve_maze(maze,0,2,len(maze)-1,2)  # doctest: +NORMALIZE_WHITESPACE\n    [[1, 1, 0, 0, 1, 1, 1, 1],\n    [1, 1, 1, 0, 0, 1, 1, 1],\n    [1, 1, 1, 1, 0, 1, 1, 1],\n    [1, 1, 1, 0, 0, 1, 1, 1],\n    [1, 1, 0, 0, 1, 1, 1, 1],\n    [1, 1, 0, 1, 1, 1, 1, 1],\n    [1, 1, 0, 1, 1, 1, 1, 1],\n    [1, 1, 0, 1, 1, 1, 1, 1]]\n    >>> maze = [[1, 0, 0],\n    ...         [0, 1, 1],\n    ...         [1, 0, 1]]\n    >>> solve_maze(maze,0,1,len(maze)-1,len(maze)-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: No solution exists!\n\n    >>> maze = [[0, 0],\n    ...         [1, 1]]\n    >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: No solution exists!\n\n    >>> maze = [[0, 1],\n    ...         [1, 0]]\n    >>> solve_maze(maze,2,0,len(maze)-1,len(maze)-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid source or destination coordinates\n\n    >>> maze = [[1, 0, 0],\n    ...         [0, 1, 0],\n    ...         [1, 0, 0]]\n    >>> solve_maze(maze,0,1,len(maze),len(maze)-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid source or destination coordinates\n    \"\"\"\n    size = len(maze)\n    if not (0 <= source_row <= size - 1 and 0 <= source_column <= size - 1) or not (0 <= destination_row <= size - 1 and 0 <= destination_column <= size - 1):\n        raise ValueError('Invalid source or destination coordinates')\n    solutions = [[1 for _ in range(size)] for _ in range(size)]\n    solved = run_maze(maze, source_row, source_column, destination_row, destination_column, solutions)\n    if solved:\n        return solutions\n    else:\n        raise ValueError('No solution exists!')",
        "'\\n    This method solves the \"rat in maze\" problem.\\n    Parameters :\\n        - maze: A two dimensional matrix of zeros and ones.\\n        - source_row: The row index of the starting point.\\n        - source_column: The column index of the starting point.\\n        - destination_row: The row index of the destination point.\\n        - destination_column: The column index of the destination point.\\n    Returns:\\n        - solution: A 2D matrix representing the solution path if it exists.\\n    Raises:\\n        - ValueError: If no solution exists or if the source or\\n            destination coordinates are invalid.\\n    Description:\\n        This method navigates through a maze represented as an n by n matrix,\\n        starting from a specified source cell and\\n        aiming to reach a destination cell.\\n        The maze consists of walls (1s) and open paths (0s).\\n        By providing custom row and column values, the source and destination\\n        cells can be adjusted.\\n    >>> maze = [[0, 1, 0, 1, 1],\\n    ...         [0, 0, 0, 0, 0],\\n    ...         [1, 0, 1, 0, 1],\\n    ...         [0, 0, 1, 0, 0],\\n    ...         [1, 0, 0, 1, 0]]\\n    >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE\\n    [[0, 1, 1, 1, 1],\\n    [0, 0, 0, 0, 1],\\n    [1, 1, 1, 0, 1],\\n    [1, 1, 1, 0, 0],\\n    [1, 1, 1, 1, 0]]\\n\\n    Note:\\n        In the output maze, the zeros (0s) represent one of the possible\\n        paths from the source to the destination.\\n\\n    >>> maze = [[0, 1, 0, 1, 1],\\n    ...         [0, 0, 0, 0, 0],\\n    ...         [0, 0, 0, 0, 1],\\n    ...         [0, 0, 0, 0, 0],\\n    ...         [0, 0, 0, 0, 0]]\\n    >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE\\n    [[0, 1, 1, 1, 1],\\n    [0, 1, 1, 1, 1],\\n    [0, 1, 1, 1, 1],\\n    [0, 1, 1, 1, 1],\\n    [0, 0, 0, 0, 0]]\\n\\n    >>> maze = [[0, 0, 0],\\n    ...         [0, 1, 0],\\n    ...         [1, 0, 0]]\\n    >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE\\n    [[0, 0, 0],\\n    [1, 1, 0],\\n    [1, 1, 0]]\\n\\n    >>> maze = [[1, 0, 0],\\n    ...         [0, 1, 0],\\n    ...         [1, 0, 0]]\\n    >>> solve_maze(maze,0,1,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE\\n    [[1, 0, 0],\\n    [1, 1, 0],\\n    [1, 1, 0]]\\n\\n    >>> maze = [[1, 1, 0, 0, 1, 0, 0, 1],\\n    ...         [1, 0, 1, 0, 0, 1, 1, 1],\\n    ...         [0, 1, 0, 1, 0, 0, 1, 0],\\n    ...         [1, 1, 1, 0, 0, 1, 0, 1],\\n    ...         [0, 1, 0, 0, 1, 0, 1, 1],\\n    ...         [0, 0, 0, 1, 1, 1, 0, 1],\\n    ...         [0, 1, 0, 1, 0, 1, 1, 1],\\n    ...         [1, 1, 0, 0, 0, 0, 0, 1]]\\n    >>> solve_maze(maze,0,2,len(maze)-1,2)  # doctest: +NORMALIZE_WHITESPACE\\n    [[1, 1, 0, 0, 1, 1, 1, 1],\\n    [1, 1, 1, 0, 0, 1, 1, 1],\\n    [1, 1, 1, 1, 0, 1, 1, 1],\\n    [1, 1, 1, 0, 0, 1, 1, 1],\\n    [1, 1, 0, 0, 1, 1, 1, 1],\\n    [1, 1, 0, 1, 1, 1, 1, 1],\\n    [1, 1, 0, 1, 1, 1, 1, 1],\\n    [1, 1, 0, 1, 1, 1, 1, 1]]\\n    >>> maze = [[1, 0, 0],\\n    ...         [0, 1, 1],\\n    ...         [1, 0, 1]]\\n    >>> solve_maze(maze,0,1,len(maze)-1,len(maze)-1)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: No solution exists!\\n\\n    >>> maze = [[0, 0],\\n    ...         [1, 1]]\\n    >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: No solution exists!\\n\\n    >>> maze = [[0, 1],\\n    ...         [1, 0]]\\n    >>> solve_maze(maze,2,0,len(maze)-1,len(maze)-1)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: Invalid source or destination coordinates\\n\\n    >>> maze = [[1, 0, 0],\\n    ...         [0, 1, 0],\\n    ...         [1, 0, 0]]\\n    >>> solve_maze(maze,0,1,len(maze),len(maze)-1)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: Invalid source or destination coordinates\\n    '",
        "size = len(maze)",
        "not (0 <= source_row <= size - 1 and 0 <= source_column <= size - 1) or not (0 <= destination_row <= size - 1 and 0 <= destination_column <= size - 1)"
      ],
      "code": "from __future__ import annotations\ndef solve_maze(maze: list[list[int]], source_row: int, source_column: int, destination_row: int, destination_column: int) -> list[list[int]]:\n    \"\"\"\n    This method solves the \"rat in maze\" problem.\n    Parameters :\n        - maze: A two dimensional matrix of zeros and ones.\n        - source_row: The row index of the starting point.\n        - source_column: The column index of the starting point.\n        - destination_row: The row index of the destination point.\n        - destination_column: The column index of the destination point.\n    Returns:\n        - solution: A 2D matrix representing the solution path if it exists.\n    Raises:\n        - ValueError: If no solution exists or if the source or\n            destination coordinates are invalid.\n    Description:\n        This method navigates through a maze represented as an n by n matrix,\n        starting from a specified source cell and\n        aiming to reach a destination cell.\n        The maze consists of walls (1s) and open paths (0s).\n        By providing custom row and column values, the source and destination\n        cells can be adjusted.\n    >>> maze = [[0, 1, 0, 1, 1],\n    ...         [0, 0, 0, 0, 0],\n    ...         [1, 0, 1, 0, 1],\n    ...         [0, 0, 1, 0, 0],\n    ...         [1, 0, 0, 1, 0]]\n    >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE\n    [[0, 1, 1, 1, 1],\n    [0, 0, 0, 0, 1],\n    [1, 1, 1, 0, 1],\n    [1, 1, 1, 0, 0],\n    [1, 1, 1, 1, 0]]\n\n    Note:\n        In the output maze, the zeros (0s) represent one of the possible\n        paths from the source to the destination.\n\n    >>> maze = [[0, 1, 0, 1, 1],\n    ...         [0, 0, 0, 0, 0],\n    ...         [0, 0, 0, 0, 1],\n    ...         [0, 0, 0, 0, 0],\n    ...         [0, 0, 0, 0, 0]]\n    >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE\n    [[0, 1, 1, 1, 1],\n    [0, 1, 1, 1, 1],\n    [0, 1, 1, 1, 1],\n    [0, 1, 1, 1, 1],\n    [0, 0, 0, 0, 0]]\n\n    >>> maze = [[0, 0, 0],\n    ...         [0, 1, 0],\n    ...         [1, 0, 0]]\n    >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE\n    [[0, 0, 0],\n    [1, 1, 0],\n    [1, 1, 0]]\n\n    >>> maze = [[1, 0, 0],\n    ...         [0, 1, 0],\n    ...         [1, 0, 0]]\n    >>> solve_maze(maze,0,1,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE\n    [[1, 0, 0],\n    [1, 1, 0],\n    [1, 1, 0]]\n\n    >>> maze = [[1, 1, 0, 0, 1, 0, 0, 1],\n    ...         [1, 0, 1, 0, 0, 1, 1, 1],\n    ...         [0, 1, 0, 1, 0, 0, 1, 0],\n    ...         [1, 1, 1, 0, 0, 1, 0, 1],\n    ...         [0, 1, 0, 0, 1, 0, 1, 1],\n    ...         [0, 0, 0, 1, 1, 1, 0, 1],\n    ...         [0, 1, 0, 1, 0, 1, 1, 1],\n    ...         [1, 1, 0, 0, 0, 0, 0, 1]]\n    >>> solve_maze(maze,0,2,len(maze)-1,2)  # doctest: +NORMALIZE_WHITESPACE\n    [[1, 1, 0, 0, 1, 1, 1, 1],\n    [1, 1, 1, 0, 0, 1, 1, 1],\n    [1, 1, 1, 1, 0, 1, 1, 1],\n    [1, 1, 1, 0, 0, 1, 1, 1],\n    [1, 1, 0, 0, 1, 1, 1, 1],\n    [1, 1, 0, 1, 1, 1, 1, 1],\n    [1, 1, 0, 1, 1, 1, 1, 1],\n    [1, 1, 0, 1, 1, 1, 1, 1]]\n    >>> maze = [[1, 0, 0],\n    ...         [0, 1, 1],\n    ...         [1, 0, 1]]\n    >>> solve_maze(maze,0,1,len(maze)-1,len(maze)-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: No solution exists!\n\n    >>> maze = [[0, 0],\n    ...         [1, 1]]\n    >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: No solution exists!\n\n    >>> maze = [[0, 1],\n    ...         [1, 0]]\n    >>> solve_maze(maze,2,0,len(maze)-1,len(maze)-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid source or destination coordinates\n\n    >>> maze = [[1, 0, 0],\n    ...         [0, 1, 0],\n    ...         [1, 0, 0]]\n    >>> solve_maze(maze,0,1,len(maze),len(maze)-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid source or destination coordinates\n    \"\"\"\n    size = len(maze)\n    if not (0 <= source_row <= size - 1 and 0 <= source_column <= size - 1) or not (0 <= destination_row <= size - 1 and 0 <= destination_column <= size - 1):\n        raise ValueError('Invalid source or destination coordinates')\n    solutions = [[1 for _ in range(size)] for _ in range(size)]\n    solved = run_maze(maze, source_row, source_column, destination_row, destination_column, solutions)\n    if solved:\n        return solutions\n    else:\n        raise ValueError('No solution exists!')\n'\\n    This method solves the \"rat in maze\" problem.\\n    Parameters :\\n        - maze: A two dimensional matrix of zeros and ones.\\n        - source_row: The row index of the starting point.\\n        - source_column: The column index of the starting point.\\n        - destination_row: The row index of the destination point.\\n        - destination_column: The column index of the destination point.\\n    Returns:\\n        - solution: A 2D matrix representing the solution path if it exists.\\n    Raises:\\n        - ValueError: If no solution exists or if the source or\\n            destination coordinates are invalid.\\n    Description:\\n        This method navigates through a maze represented as an n by n matrix,\\n        starting from a specified source cell and\\n        aiming to reach a destination cell.\\n        The maze consists of walls (1s) and open paths (0s).\\n        By providing custom row and column values, the source and destination\\n        cells can be adjusted.\\n    >>> maze = [[0, 1, 0, 1, 1],\\n    ...         [0, 0, 0, 0, 0],\\n    ...         [1, 0, 1, 0, 1],\\n    ...         [0, 0, 1, 0, 0],\\n    ...         [1, 0, 0, 1, 0]]\\n    >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE\\n    [[0, 1, 1, 1, 1],\\n    [0, 0, 0, 0, 1],\\n    [1, 1, 1, 0, 1],\\n    [1, 1, 1, 0, 0],\\n    [1, 1, 1, 1, 0]]\\n\\n    Note:\\n        In the output maze, the zeros (0s) represent one of the possible\\n        paths from the source to the destination.\\n\\n    >>> maze = [[0, 1, 0, 1, 1],\\n    ...         [0, 0, 0, 0, 0],\\n    ...         [0, 0, 0, 0, 1],\\n    ...         [0, 0, 0, 0, 0],\\n    ...         [0, 0, 0, 0, 0]]\\n    >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE\\n    [[0, 1, 1, 1, 1],\\n    [0, 1, 1, 1, 1],\\n    [0, 1, 1, 1, 1],\\n    [0, 1, 1, 1, 1],\\n    [0, 0, 0, 0, 0]]\\n\\n    >>> maze = [[0, 0, 0],\\n    ...         [0, 1, 0],\\n    ...         [1, 0, 0]]\\n    >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE\\n    [[0, 0, 0],\\n    [1, 1, 0],\\n    [1, 1, 0]]\\n\\n    >>> maze = [[1, 0, 0],\\n    ...         [0, 1, 0],\\n    ...         [1, 0, 0]]\\n    >>> solve_maze(maze,0,1,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE\\n    [[1, 0, 0],\\n    [1, 1, 0],\\n    [1, 1, 0]]\\n\\n    >>> maze = [[1, 1, 0, 0, 1, 0, 0, 1],\\n    ...         [1, 0, 1, 0, 0, 1, 1, 1],\\n    ...         [0, 1, 0, 1, 0, 0, 1, 0],\\n    ...         [1, 1, 1, 0, 0, 1, 0, 1],\\n    ...         [0, 1, 0, 0, 1, 0, 1, 1],\\n    ...         [0, 0, 0, 1, 1, 1, 0, 1],\\n    ...         [0, 1, 0, 1, 0, 1, 1, 1],\\n    ...         [1, 1, 0, 0, 0, 0, 0, 1]]\\n    >>> solve_maze(maze,0,2,len(maze)-1,2)  # doctest: +NORMALIZE_WHITESPACE\\n    [[1, 1, 0, 0, 1, 1, 1, 1],\\n    [1, 1, 1, 0, 0, 1, 1, 1],\\n    [1, 1, 1, 1, 0, 1, 1, 1],\\n    [1, 1, 1, 0, 0, 1, 1, 1],\\n    [1, 1, 0, 0, 1, 1, 1, 1],\\n    [1, 1, 0, 1, 1, 1, 1, 1],\\n    [1, 1, 0, 1, 1, 1, 1, 1],\\n    [1, 1, 0, 1, 1, 1, 1, 1]]\\n    >>> maze = [[1, 0, 0],\\n    ...         [0, 1, 1],\\n    ...         [1, 0, 1]]\\n    >>> solve_maze(maze,0,1,len(maze)-1,len(maze)-1)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: No solution exists!\\n\\n    >>> maze = [[0, 0],\\n    ...         [1, 1]]\\n    >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: No solution exists!\\n\\n    >>> maze = [[0, 1],\\n    ...         [1, 0]]\\n    >>> solve_maze(maze,2,0,len(maze)-1,len(maze)-1)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: Invalid source or destination coordinates\\n\\n    >>> maze = [[1, 0, 0],\\n    ...         [0, 1, 0],\\n    ...         [1, 0, 0]]\\n    >>> solve_maze(maze,0,1,len(maze),len(maze)-1)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: Invalid source or destination coordinates\\n    '\nsize = len(maze)\nnot (0 <= source_row <= size - 1 and 0 <= source_column <= size - 1) or not (0 <= destination_row <= size - 1 and 0 <= destination_column <= size - 1)"
    },
    {
      "id": "n1",
      "type": "block",
      "statements": [
        "raise ValueError('Invalid source or destination coordinates')"
      ],
      "code": "raise ValueError('Invalid source or destination coordinates')"
    },
    {
      "id": "n2",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n3",
      "type": "block",
      "statements": [
        "solutions = [[1 for _ in range(size)] for _ in range(size)]",
        "solved = run_maze(maze, source_row, source_column, destination_row, destination_column, solutions)",
        "solved"
      ],
      "code": "solutions = [[1 for _ in range(size)] for _ in range(size)]\nsolved = run_maze(maze, source_row, source_column, destination_row, destination_column, solutions)\nsolved"
    },
    {
      "id": "n4",
      "type": "block",
      "statements": [
        "return solutions"
      ],
      "code": "return solutions"
    },
    {
      "id": "n5",
      "type": "block",
      "statements": [
        "raise ValueError('No solution exists!')"
      ],
      "code": "raise ValueError('No solution exists!')\ndef run_maze(maze: list[list[int]], i: int, j: int, destination_row: int, destination_column: int, solutions: list[list[int]]) -> bool:\n    \"\"\"\n    This method is recursive starting from (i, j) and going in one of four directions:\n    up, down, left, right.\n    If a path is found to destination it returns True otherwise it returns False.\n    Parameters\n        maze: A two dimensional matrix of zeros and ones.\n        i, j : coordinates of matrix\n        solutions: A two dimensional matrix of solutions.\n    Returns:\n        Boolean if path is found True, Otherwise False.\n    \"\"\"\n    size = len(maze)\n    if i == destination_row and j == destination_column and (maze[i][j] == 0):\n        solutions[i][j] = 0\n        return True\n    lower_flag = not i < 0 and (not j < 0)\n    upper_flag = i < size and j < size\n    if lower_flag and upper_flag:\n        block_flag = solutions[i][j] and (not maze[i][j])\n        if block_flag:\n            solutions[i][j] = 0\n            if run_maze(maze, i + 1, j, destination_row, destination_column, solutions) or run_maze(maze, i, j + 1, destination_row, destination_column, solutions) or run_maze(maze, i - 1, j, destination_row, destination_column, solutions) or run_maze(maze, i, j - 1, destination_row, destination_column, solutions):\n                return True\n            solutions[i][j] = 1\n            return False\n    return False\n'\\n    This method is recursive starting from (i, j) and going in one of four directions:\\n    up, down, left, right.\\n    If a path is found to destination it returns True otherwise it returns False.\\n    Parameters\\n        maze: A two dimensional matrix of zeros and ones.\\n        i, j : coordinates of matrix\\n        solutions: A two dimensional matrix of solutions.\\n    Returns:\\n        Boolean if path is found True, Otherwise False.\\n    '\nsize = len(maze)\ni == destination_row and j == destination_column and (maze[i][j] == 0)"
    },
    {
      "id": "n6",
      "type": "block",
      "statements": [
        "solutions[i][j] = 0",
        "return True"
      ],
      "code": "solutions[i][j] = 0\nreturn True"
    },
    {
      "id": "n7",
      "type": "block",
      "statements": [],
      "code": "\nlower_flag = not i < 0 and (not j < 0)\nupper_flag = i < size and j < size\nlower_flag and upper_flag"
    },
    {
      "id": "n8",
      "type": "block",
      "statements": [
        "block_flag = solutions[i][j] and (not maze[i][j])",
        "block_flag"
      ],
      "code": "block_flag = solutions[i][j] and (not maze[i][j])\nblock_flag"
    },
    {
      "id": "n9",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n10",
      "type": "block",
      "statements": [
        "return False"
      ],
      "code": "return False"
    },
    {
      "id": "n11",
      "type": "block",
      "statements": [
        "solutions[i][j] = 0",
        "run_maze(maze, i + 1, j, destination_row, destination_column, solutions) or run_maze(maze, i, j + 1, destination_row, destination_column, solutions) or run_maze(maze, i - 1, j, destination_row, destination_column, solutions) or run_maze(maze, i, j - 1, destination_row, destination_column, solutions)"
      ],
      "code": "solutions[i][j] = 0\nrun_maze(maze, i + 1, j, destination_row, destination_column, solutions) or run_maze(maze, i, j + 1, destination_row, destination_column, solutions) or run_maze(maze, i - 1, j, destination_row, destination_column, solutions) or run_maze(maze, i, j - 1, destination_row, destination_column, solutions)"
    },
    {
      "id": "n12",
      "type": "block",
      "statements": [],
      "code": "\n"
    },
    {
      "id": "n13",
      "type": "block",
      "statements": [
        "return True"
      ],
      "code": "return True"
    },
    {
      "id": "n14",
      "type": "block",
      "statements": [],
      "code": "\nsolutions[i][j] = 1\nreturn False"
    },
    {
      "id": "n15",
      "type": "block",
      "statements": [
        "__name__ Eq '__main__'"
      ],
      "code": "__name__ Eq '__main__'"
    },
    {
      "id": "n16",
      "type": "block",
      "statements": [
        "import doctest",
        "doctest.testmod()"
      ],
      "code": "import doctest\ndoctest.testmod()"
    },
    {
      "id": "n17",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n18",
      "type": "block",
      "statements": [],
      "code": ""
    }
  ],
  "edges": [
    {
      "source": "n0",
      "target": "n1"
    },
    {
      "source": "n17",
      "target": "n18"
    },
    {
      "source": "n8",
      "target": "n12"
    },
    {
      "source": "n2",
      "target": "n3"
    },
    {
      "source": "n3",
      "target": "n4"
    },
    {
      "source": "n16",
      "target": "n18"
    },
    {
      "source": "n7",
      "target": "n8"
    },
    {
      "source": "n15",
      "target": "n16"
    },
    {
      "source": "n9",
      "target": "n10"
    },
    {
      "source": "n8",
      "target": "n11"
    },
    {
      "source": "n0",
      "target": "n2"
    },
    {
      "source": "n7",
      "target": "n9"
    },
    {
      "source": "n5",
      "target": "n6"
    },
    {
      "source": "n1",
      "target": "n3"
    },
    {
      "source": "n12",
      "target": "n10"
    },
    {
      "source": "n3",
      "target": "n5"
    },
    {
      "source": "n5",
      "target": "n7"
    },
    {
      "source": "n11",
      "target": "n13"
    },
    {
      "source": "n11",
      "target": "n14"
    },
    {
      "source": "n15",
      "target": "n17"
    }
  ]
}