{
  "nodes": [
    {
      "id": "n0",
      "type": "block",
      "statements": [
        "'\\nauthor: Aayush Soni\\nGiven n pairs of parentheses, write a function to generate all\\ncombinations of well-formed parentheses.\\nInput: n = 2\\nOutput: [\"(())\",\"()()\"]\\nLeetcode link: https://leetcode.com/problems/generate-parentheses/description/\\n'",
        "def backtrack(partial: str, open_count: int, close_count: int, n: int, result: list[str]) -> None:\n    \"\"\"\n    Generate valid combinations of balanced parentheses using recursion.\n\n    :param partial: A string representing the current combination.\n    :param open_count: An integer representing the count of open parentheses.\n    :param close_count: An integer representing the count of close parentheses.\n    :param n: An integer representing the total number of pairs.\n    :param result: A list to store valid combinations.\n    :return: None\n\n    This function uses recursion to explore all possible combinations,\n    ensuring that at each step, the parentheses remain balanced.\n\n    Example:\n    >>> result = []\n    >>> backtrack(\"\", 0, 0, 2, result)\n    >>> result\n    ['(())', '()()']\n    \"\"\"\n    if len(partial) == 2 * n:\n        result.append(partial)\n        return\n    if open_count < n:\n        backtrack(partial + '(', open_count + 1, close_count, n, result)\n    if close_count < open_count:\n        backtrack(partial + ')', open_count, close_count + 1, n, result)",
        "'\\n    Generate valid combinations of balanced parentheses using recursion.\\n\\n    :param partial: A string representing the current combination.\\n    :param open_count: An integer representing the count of open parentheses.\\n    :param close_count: An integer representing the count of close parentheses.\\n    :param n: An integer representing the total number of pairs.\\n    :param result: A list to store valid combinations.\\n    :return: None\\n\\n    This function uses recursion to explore all possible combinations,\\n    ensuring that at each step, the parentheses remain balanced.\\n\\n    Example:\\n    >>> result = []\\n    >>> backtrack(\"\", 0, 0, 2, result)\\n    >>> result\\n    [\\'(())\\', \\'()()\\']\\n    '",
        "len(partial) Eq 2 Mult n"
      ],
      "code": "'\\nauthor: Aayush Soni\\nGiven n pairs of parentheses, write a function to generate all\\ncombinations of well-formed parentheses.\\nInput: n = 2\\nOutput: [\"(())\",\"()()\"]\\nLeetcode link: https://leetcode.com/problems/generate-parentheses/description/\\n'\ndef backtrack(partial: str, open_count: int, close_count: int, n: int, result: list[str]) -> None:\n    \"\"\"\n    Generate valid combinations of balanced parentheses using recursion.\n\n    :param partial: A string representing the current combination.\n    :param open_count: An integer representing the count of open parentheses.\n    :param close_count: An integer representing the count of close parentheses.\n    :param n: An integer representing the total number of pairs.\n    :param result: A list to store valid combinations.\n    :return: None\n\n    This function uses recursion to explore all possible combinations,\n    ensuring that at each step, the parentheses remain balanced.\n\n    Example:\n    >>> result = []\n    >>> backtrack(\"\", 0, 0, 2, result)\n    >>> result\n    ['(())', '()()']\n    \"\"\"\n    if len(partial) == 2 * n:\n        result.append(partial)\n        return\n    if open_count < n:\n        backtrack(partial + '(', open_count + 1, close_count, n, result)\n    if close_count < open_count:\n        backtrack(partial + ')', open_count, close_count + 1, n, result)\n'\\n    Generate valid combinations of balanced parentheses using recursion.\\n\\n    :param partial: A string representing the current combination.\\n    :param open_count: An integer representing the count of open parentheses.\\n    :param close_count: An integer representing the count of close parentheses.\\n    :param n: An integer representing the total number of pairs.\\n    :param result: A list to store valid combinations.\\n    :return: None\\n\\n    This function uses recursion to explore all possible combinations,\\n    ensuring that at each step, the parentheses remain balanced.\\n\\n    Example:\\n    >>> result = []\\n    >>> backtrack(\"\", 0, 0, 2, result)\\n    >>> result\\n    [\\'(())\\', \\'()()\\']\\n    '\nlen(partial) Eq 2 Mult n"
    },
    {
      "id": "n1",
      "type": "block",
      "statements": [
        "result.append(partial)",
        "return"
      ],
      "code": "result.append(partial)\nreturn"
    },
    {
      "id": "n2",
      "type": "block",
      "statements": [],
      "code": "\nopen_count Lt n"
    },
    {
      "id": "n3",
      "type": "block",
      "statements": [
        "backtrack(partial Add '(', open_count Add 1, close_count, n, result)"
      ],
      "code": "backtrack(partial Add '(', open_count Add 1, close_count, n, result)"
    },
    {
      "id": "n4",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n5",
      "type": "block",
      "statements": [
        "close_count Lt open_count"
      ],
      "code": "close_count Lt open_count"
    },
    {
      "id": "n6",
      "type": "block",
      "statements": [
        "backtrack(partial Add ')', open_count, close_count Add 1, n, result)"
      ],
      "code": "backtrack(partial Add ')', open_count, close_count Add 1, n, result)"
    },
    {
      "id": "n7",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n8",
      "type": "block",
      "statements": [
        "def generate_parenthesis(n: int) -> list[str]:\n    \"\"\"\n    Generate valid combinations of balanced parentheses for a given n.\n\n    :param n: An integer representing the number of pairs of parentheses.\n    :return: A list of strings with valid combinations.\n\n    This function uses a recursive approach to generate the combinations.\n\n    Time Complexity: O(2^(2n)) - In the worst case, we have 2^(2n) combinations.\n    Space Complexity: O(n) - where 'n' is the number of pairs.\n\n    Example 1:\n    >>> generate_parenthesis(3)\n    ['((()))', '(()())', '(())()', '()(())', '()()()']\n\n    Example 2:\n    >>> generate_parenthesis(1)\n    ['()']\n    \"\"\"\n    result: list[str] = []\n    backtrack('', 0, 0, n, result)\n    return result",
        "\"\\n    Generate valid combinations of balanced parentheses for a given n.\\n\\n    :param n: An integer representing the number of pairs of parentheses.\\n    :return: A list of strings with valid combinations.\\n\\n    This function uses a recursive approach to generate the combinations.\\n\\n    Time Complexity: O(2^(2n)) - In the worst case, we have 2^(2n) combinations.\\n    Space Complexity: O(n) - where 'n' is the number of pairs.\\n\\n    Example 1:\\n    >>> generate_parenthesis(3)\\n    ['((()))', '(()())', '(())()', '()(())', '()()()']\\n\\n    Example 2:\\n    >>> generate_parenthesis(1)\\n    ['()']\\n    \"",
        "result: list[str] = []",
        "backtrack('', 0, 0, n, result)",
        "return result"
      ],
      "code": "def generate_parenthesis(n: int) -> list[str]:\n    \"\"\"\n    Generate valid combinations of balanced parentheses for a given n.\n\n    :param n: An integer representing the number of pairs of parentheses.\n    :return: A list of strings with valid combinations.\n\n    This function uses a recursive approach to generate the combinations.\n\n    Time Complexity: O(2^(2n)) - In the worst case, we have 2^(2n) combinations.\n    Space Complexity: O(n) - where 'n' is the number of pairs.\n\n    Example 1:\n    >>> generate_parenthesis(3)\n    ['((()))', '(()())', '(())()', '()(())', '()()()']\n\n    Example 2:\n    >>> generate_parenthesis(1)\n    ['()']\n    \"\"\"\n    result: list[str] = []\n    backtrack('', 0, 0, n, result)\n    return result\n\"\\n    Generate valid combinations of balanced parentheses for a given n.\\n\\n    :param n: An integer representing the number of pairs of parentheses.\\n    :return: A list of strings with valid combinations.\\n\\n    This function uses a recursive approach to generate the combinations.\\n\\n    Time Complexity: O(2^(2n)) - In the worst case, we have 2^(2n) combinations.\\n    Space Complexity: O(n) - where 'n' is the number of pairs.\\n\\n    Example 1:\\n    >>> generate_parenthesis(3)\\n    ['((()))', '(()())', '(())()', '()(())', '()()()']\\n\\n    Example 2:\\n    >>> generate_parenthesis(1)\\n    ['()']\\n    \"\nresult: list[str] = []\nbacktrack('', 0, 0, n, result)\nreturn result"
    },
    {
      "id": "n9",
      "type": "block",
      "statements": [
        "__name__ Eq '__main__'"
      ],
      "code": "__name__ Eq '__main__'"
    },
    {
      "id": "n10",
      "type": "block",
      "statements": [
        "import doctest",
        "doctest.testmod()"
      ],
      "code": "import doctest\ndoctest.testmod()"
    },
    {
      "id": "n11",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n12",
      "type": "block",
      "statements": [],
      "code": ""
    }
  ],
  "edges": [
    {
      "source": "n5",
      "target": "n6"
    },
    {
      "source": "n9",
      "target": "n11"
    },
    {
      "source": "n2",
      "target": "n4"
    },
    {
      "source": "n0",
      "target": "n1"
    },
    {
      "source": "n0",
      "target": "n2"
    },
    {
      "source": "n3",
      "target": "n5"
    },
    {
      "source": "n9",
      "target": "n10"
    },
    {
      "source": "n5",
      "target": "n7"
    },
    {
      "source": "n4",
      "target": "n5"
    },
    {
      "source": "n10",
      "target": "n12"
    },
    {
      "source": "n11",
      "target": "n12"
    },
    {
      "source": "n6",
      "target": "n8"
    },
    {
      "source": "n7",
      "target": "n8"
    },
    {
      "source": "n2",
      "target": "n3"
    }
  ]
}