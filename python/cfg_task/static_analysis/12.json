{
  "nodes": [
    {
      "id": "n0",
      "type": "block",
      "statements": [
        "import base64",
        "from typing_extensions import TypedDict",
        "from backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema",
        "from backend.data.model import SchemaField",
        "from ._api import get_api",
        "from ._auth import TEST_CREDENTIALS, TEST_CREDENTIALS_INPUT, GithubCredentials, GithubCredentialsField, GithubCredentialsInput",
        "class GithubListTagsBlock(Block):\n\n    class Input(BlockSchema):\n        credentials: GithubCredentialsInput = GithubCredentialsField('repo')\n        repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')\n\n    class Output(BlockSchema):\n\n        class TagItem(TypedDict):\n            name: str\n            url: str\n        tag: TagItem = SchemaField(title='Tag', description='Tags with their name and file tree browser URL')\n        error: str = SchemaField(description='Error message if listing tags failed')\n\n    def __init__(self):\n        super().__init__(id='358924e7-9a11-4d1a-a0f2-13c67fe59e2e', description='This block lists all tags for a specified GitHub repository.', categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=GithubListTagsBlock.Input, output_schema=GithubListTagsBlock.Output, test_input={'repo_url': 'https://github.com/owner/repo', 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('tag', {'name': 'v1.0.0', 'url': 'https://github.com/owner/repo/tree/v1.0.0'})], test_mock={'list_tags': lambda *args, **kwargs: [{'name': 'v1.0.0', 'url': 'https://github.com/owner/repo/tree/v1.0.0'}]})\n\n    @staticmethod\n    def list_tags(credentials: GithubCredentials, repo_url: str) -> list[Output.TagItem]:\n        api = get_api(credentials)\n        tags_url = repo_url + '/tags'\n        response = api.get(tags_url)\n        data = response.json()\n        repo_path = repo_url.replace('https://github.com/', '')\n        tags: list[GithubListTagsBlock.Output.TagItem] = [{'name': tag['name'], 'url': f\"https://github.com/{repo_path}/tree/{tag['name']}\"} for tag in data]\n        return tags\n\n    def run(self, input_data: Input, *, credentials: GithubCredentials, **kwargs) -> BlockOutput:\n        tags = self.list_tags(credentials, input_data.repo_url)\n        yield from (('tag', tag) for tag in tags)",
        "class Input(BlockSchema):\n    credentials: GithubCredentialsInput = GithubCredentialsField('repo')\n    repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')",
        "credentials: GithubCredentialsInput = GithubCredentialsField('repo')",
        "repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')",
        "class Output(BlockSchema):\n\n    class TagItem(TypedDict):\n        name: str\n        url: str\n    tag: TagItem = SchemaField(title='Tag', description='Tags with their name and file tree browser URL')\n    error: str = SchemaField(description='Error message if listing tags failed')",
        "class TagItem(TypedDict):\n    name: str\n    url: str",
        "name: str",
        "url: str",
        "tag: TagItem = SchemaField(title='Tag', description='Tags with their name and file tree browser URL')",
        "error: str = SchemaField(description='Error message if listing tags failed')",
        "def __init__(self):\n    super().__init__(id='358924e7-9a11-4d1a-a0f2-13c67fe59e2e', description='This block lists all tags for a specified GitHub repository.', categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=GithubListTagsBlock.Input, output_schema=GithubListTagsBlock.Output, test_input={'repo_url': 'https://github.com/owner/repo', 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('tag', {'name': 'v1.0.0', 'url': 'https://github.com/owner/repo/tree/v1.0.0'})], test_mock={'list_tags': lambda *args, **kwargs: [{'name': 'v1.0.0', 'url': 'https://github.com/owner/repo/tree/v1.0.0'}]})",
        "super().__init__()",
        "@staticmethod\ndef list_tags(credentials: GithubCredentials, repo_url: str) -> list[Output.TagItem]:\n    api = get_api(credentials)\n    tags_url = repo_url + '/tags'\n    response = api.get(tags_url)\n    data = response.json()\n    repo_path = repo_url.replace('https://github.com/', '')\n    tags: list[GithubListTagsBlock.Output.TagItem] = [{'name': tag['name'], 'url': f\"https://github.com/{repo_path}/tree/{tag['name']}\"} for tag in data]\n    return tags",
        "api = get_api(credentials)",
        "tags_url = repo_url + '/tags'",
        "response = api.get(tags_url)",
        "data = response.json()",
        "repo_path = repo_url.replace('https://github.com/', '')",
        "tags: list[GithubListTagsBlock.Output.TagItem] = [{'name': tag['name'], 'url': f\"https://github.com/{repo_path}/tree/{tag['name']}\"} for tag in data]",
        "return tags"
      ],
      "code": "import base64\nfrom typing_extensions import TypedDict\nfrom backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema\nfrom backend.data.model import SchemaField\nfrom ._api import get_api\nfrom ._auth import TEST_CREDENTIALS, TEST_CREDENTIALS_INPUT, GithubCredentials, GithubCredentialsField, GithubCredentialsInput\nclass GithubListTagsBlock(Block):\n\n    class Input(BlockSchema):\n        credentials: GithubCredentialsInput = GithubCredentialsField('repo')\n        repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')\n\n    class Output(BlockSchema):\n\n        class TagItem(TypedDict):\n            name: str\n            url: str\n        tag: TagItem = SchemaField(title='Tag', description='Tags with their name and file tree browser URL')\n        error: str = SchemaField(description='Error message if listing tags failed')\n\n    def __init__(self):\n        super().__init__(id='358924e7-9a11-4d1a-a0f2-13c67fe59e2e', description='This block lists all tags for a specified GitHub repository.', categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=GithubListTagsBlock.Input, output_schema=GithubListTagsBlock.Output, test_input={'repo_url': 'https://github.com/owner/repo', 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('tag', {'name': 'v1.0.0', 'url': 'https://github.com/owner/repo/tree/v1.0.0'})], test_mock={'list_tags': lambda *args, **kwargs: [{'name': 'v1.0.0', 'url': 'https://github.com/owner/repo/tree/v1.0.0'}]})\n\n    @staticmethod\n    def list_tags(credentials: GithubCredentials, repo_url: str) -> list[Output.TagItem]:\n        api = get_api(credentials)\n        tags_url = repo_url + '/tags'\n        response = api.get(tags_url)\n        data = response.json()\n        repo_path = repo_url.replace('https://github.com/', '')\n        tags: list[GithubListTagsBlock.Output.TagItem] = [{'name': tag['name'], 'url': f\"https://github.com/{repo_path}/tree/{tag['name']}\"} for tag in data]\n        return tags\n\n    def run(self, input_data: Input, *, credentials: GithubCredentials, **kwargs) -> BlockOutput:\n        tags = self.list_tags(credentials, input_data.repo_url)\n        yield from (('tag', tag) for tag in tags)\nclass Input(BlockSchema):\n    credentials: GithubCredentialsInput = GithubCredentialsField('repo')\n    repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')\ncredentials: GithubCredentialsInput = GithubCredentialsField('repo')\nrepo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')\nclass Output(BlockSchema):\n\n    class TagItem(TypedDict):\n        name: str\n        url: str\n    tag: TagItem = SchemaField(title='Tag', description='Tags with their name and file tree browser URL')\n    error: str = SchemaField(description='Error message if listing tags failed')\nclass TagItem(TypedDict):\n    name: str\n    url: str\nname: str\nurl: str\ntag: TagItem = SchemaField(title='Tag', description='Tags with their name and file tree browser URL')\nerror: str = SchemaField(description='Error message if listing tags failed')\ndef __init__(self):\n    super().__init__(id='358924e7-9a11-4d1a-a0f2-13c67fe59e2e', description='This block lists all tags for a specified GitHub repository.', categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=GithubListTagsBlock.Input, output_schema=GithubListTagsBlock.Output, test_input={'repo_url': 'https://github.com/owner/repo', 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('tag', {'name': 'v1.0.0', 'url': 'https://github.com/owner/repo/tree/v1.0.0'})], test_mock={'list_tags': lambda *args, **kwargs: [{'name': 'v1.0.0', 'url': 'https://github.com/owner/repo/tree/v1.0.0'}]})\nsuper().__init__()\n@staticmethod\ndef list_tags(credentials: GithubCredentials, repo_url: str) -> list[Output.TagItem]:\n    api = get_api(credentials)\n    tags_url = repo_url + '/tags'\n    response = api.get(tags_url)\n    data = response.json()\n    repo_path = repo_url.replace('https://github.com/', '')\n    tags: list[GithubListTagsBlock.Output.TagItem] = [{'name': tag['name'], 'url': f\"https://github.com/{repo_path}/tree/{tag['name']}\"} for tag in data]\n    return tags\napi = get_api(credentials)\ntags_url = repo_url + '/tags'\nresponse = api.get(tags_url)\ndata = response.json()\nrepo_path = repo_url.replace('https://github.com/', '')\ntags: list[GithubListTagsBlock.Output.TagItem] = [{'name': tag['name'], 'url': f\"https://github.com/{repo_path}/tree/{tag['name']}\"} for tag in data]\nreturn tags"
    },
    {
      "id": "n1",
      "type": "block",
      "statements": [
        "def run(self, input_data: Input, *, credentials: GithubCredentials, **kwargs) -> BlockOutput:\n    tags = self.list_tags(credentials, input_data.repo_url)\n    yield from (('tag', tag) for tag in tags)",
        "tags = self.list_tags(credentials, input_data.repo_url)",
        "(yield from (('tag', tag) for tag in tags))",
        "class GithubListBranchesBlock(Block):\n\n    class Input(BlockSchema):\n        credentials: GithubCredentialsInput = GithubCredentialsField('repo')\n        repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')\n\n    class Output(BlockSchema):\n\n        class BranchItem(TypedDict):\n            name: str\n            url: str\n        branch: BranchItem = SchemaField(title='Branch', description='Branches with their name and file tree browser URL')\n        error: str = SchemaField(description='Error message if listing branches failed')\n\n    def __init__(self):\n        super().__init__(id='74243e49-2bec-4916-8bf4-db43d44aead5', description='This block lists all branches for a specified GitHub repository.', categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=GithubListBranchesBlock.Input, output_schema=GithubListBranchesBlock.Output, test_input={'repo_url': 'https://github.com/owner/repo', 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('branch', {'name': 'main', 'url': 'https://github.com/owner/repo/tree/main'})], test_mock={'list_branches': lambda *args, **kwargs: [{'name': 'main', 'url': 'https://github.com/owner/repo/tree/main'}]})\n\n    @staticmethod\n    def list_branches(credentials: GithubCredentials, repo_url: str) -> list[Output.BranchItem]:\n        api = get_api(credentials)\n        branches_url = repo_url + '/branches'\n        response = api.get(branches_url)\n        data = response.json()\n        repo_path = repo_url.replace('https://github.com/', '')\n        branches: list[GithubListBranchesBlock.Output.BranchItem] = [{'name': branch['name'], 'url': f\"https://github.com/{repo_path}/tree/{branch['name']}\"} for branch in data]\n        return branches\n\n    def run(self, input_data: Input, *, credentials: GithubCredentials, **kwargs) -> BlockOutput:\n        branches = self.list_branches(credentials, input_data.repo_url)\n        yield from (('branch', branch) for branch in branches)",
        "class Input(BlockSchema):\n    credentials: GithubCredentialsInput = GithubCredentialsField('repo')\n    repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')",
        "credentials: GithubCredentialsInput = GithubCredentialsField('repo')",
        "repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')",
        "class Output(BlockSchema):\n\n    class BranchItem(TypedDict):\n        name: str\n        url: str\n    branch: BranchItem = SchemaField(title='Branch', description='Branches with their name and file tree browser URL')\n    error: str = SchemaField(description='Error message if listing branches failed')",
        "class BranchItem(TypedDict):\n    name: str\n    url: str",
        "name: str",
        "url: str",
        "branch: BranchItem = SchemaField(title='Branch', description='Branches with their name and file tree browser URL')",
        "error: str = SchemaField(description='Error message if listing branches failed')",
        "def __init__(self):\n    super().__init__(id='74243e49-2bec-4916-8bf4-db43d44aead5', description='This block lists all branches for a specified GitHub repository.', categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=GithubListBranchesBlock.Input, output_schema=GithubListBranchesBlock.Output, test_input={'repo_url': 'https://github.com/owner/repo', 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('branch', {'name': 'main', 'url': 'https://github.com/owner/repo/tree/main'})], test_mock={'list_branches': lambda *args, **kwargs: [{'name': 'main', 'url': 'https://github.com/owner/repo/tree/main'}]})",
        "super().__init__()",
        "@staticmethod\ndef list_branches(credentials: GithubCredentials, repo_url: str) -> list[Output.BranchItem]:\n    api = get_api(credentials)\n    branches_url = repo_url + '/branches'\n    response = api.get(branches_url)\n    data = response.json()\n    repo_path = repo_url.replace('https://github.com/', '')\n    branches: list[GithubListBranchesBlock.Output.BranchItem] = [{'name': branch['name'], 'url': f\"https://github.com/{repo_path}/tree/{branch['name']}\"} for branch in data]\n    return branches",
        "api = get_api(credentials)",
        "branches_url = repo_url + '/branches'",
        "response = api.get(branches_url)",
        "data = response.json()",
        "repo_path = repo_url.replace('https://github.com/', '')",
        "branches: list[GithubListBranchesBlock.Output.BranchItem] = [{'name': branch['name'], 'url': f\"https://github.com/{repo_path}/tree/{branch['name']}\"} for branch in data]",
        "return branches"
      ],
      "code": "def run(self, input_data: Input, *, credentials: GithubCredentials, **kwargs) -> BlockOutput:\n    tags = self.list_tags(credentials, input_data.repo_url)\n    yield from (('tag', tag) for tag in tags)\ntags = self.list_tags(credentials, input_data.repo_url)\n(yield from (('tag', tag) for tag in tags))\nclass GithubListBranchesBlock(Block):\n\n    class Input(BlockSchema):\n        credentials: GithubCredentialsInput = GithubCredentialsField('repo')\n        repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')\n\n    class Output(BlockSchema):\n\n        class BranchItem(TypedDict):\n            name: str\n            url: str\n        branch: BranchItem = SchemaField(title='Branch', description='Branches with their name and file tree browser URL')\n        error: str = SchemaField(description='Error message if listing branches failed')\n\n    def __init__(self):\n        super().__init__(id='74243e49-2bec-4916-8bf4-db43d44aead5', description='This block lists all branches for a specified GitHub repository.', categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=GithubListBranchesBlock.Input, output_schema=GithubListBranchesBlock.Output, test_input={'repo_url': 'https://github.com/owner/repo', 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('branch', {'name': 'main', 'url': 'https://github.com/owner/repo/tree/main'})], test_mock={'list_branches': lambda *args, **kwargs: [{'name': 'main', 'url': 'https://github.com/owner/repo/tree/main'}]})\n\n    @staticmethod\n    def list_branches(credentials: GithubCredentials, repo_url: str) -> list[Output.BranchItem]:\n        api = get_api(credentials)\n        branches_url = repo_url + '/branches'\n        response = api.get(branches_url)\n        data = response.json()\n        repo_path = repo_url.replace('https://github.com/', '')\n        branches: list[GithubListBranchesBlock.Output.BranchItem] = [{'name': branch['name'], 'url': f\"https://github.com/{repo_path}/tree/{branch['name']}\"} for branch in data]\n        return branches\n\n    def run(self, input_data: Input, *, credentials: GithubCredentials, **kwargs) -> BlockOutput:\n        branches = self.list_branches(credentials, input_data.repo_url)\n        yield from (('branch', branch) for branch in branches)\nclass Input(BlockSchema):\n    credentials: GithubCredentialsInput = GithubCredentialsField('repo')\n    repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')\ncredentials: GithubCredentialsInput = GithubCredentialsField('repo')\nrepo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')\nclass Output(BlockSchema):\n\n    class BranchItem(TypedDict):\n        name: str\n        url: str\n    branch: BranchItem = SchemaField(title='Branch', description='Branches with their name and file tree browser URL')\n    error: str = SchemaField(description='Error message if listing branches failed')\nclass BranchItem(TypedDict):\n    name: str\n    url: str\nname: str\nurl: str\nbranch: BranchItem = SchemaField(title='Branch', description='Branches with their name and file tree browser URL')\nerror: str = SchemaField(description='Error message if listing branches failed')\ndef __init__(self):\n    super().__init__(id='74243e49-2bec-4916-8bf4-db43d44aead5', description='This block lists all branches for a specified GitHub repository.', categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=GithubListBranchesBlock.Input, output_schema=GithubListBranchesBlock.Output, test_input={'repo_url': 'https://github.com/owner/repo', 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('branch', {'name': 'main', 'url': 'https://github.com/owner/repo/tree/main'})], test_mock={'list_branches': lambda *args, **kwargs: [{'name': 'main', 'url': 'https://github.com/owner/repo/tree/main'}]})\nsuper().__init__()\n@staticmethod\ndef list_branches(credentials: GithubCredentials, repo_url: str) -> list[Output.BranchItem]:\n    api = get_api(credentials)\n    branches_url = repo_url + '/branches'\n    response = api.get(branches_url)\n    data = response.json()\n    repo_path = repo_url.replace('https://github.com/', '')\n    branches: list[GithubListBranchesBlock.Output.BranchItem] = [{'name': branch['name'], 'url': f\"https://github.com/{repo_path}/tree/{branch['name']}\"} for branch in data]\n    return branches\napi = get_api(credentials)\nbranches_url = repo_url + '/branches'\nresponse = api.get(branches_url)\ndata = response.json()\nrepo_path = repo_url.replace('https://github.com/', '')\nbranches: list[GithubListBranchesBlock.Output.BranchItem] = [{'name': branch['name'], 'url': f\"https://github.com/{repo_path}/tree/{branch['name']}\"} for branch in data]\nreturn branches"
    },
    {
      "id": "n2",
      "type": "block",
      "statements": [
        "def run(self, input_data: Input, *, credentials: GithubCredentials, **kwargs) -> BlockOutput:\n    branches = self.list_branches(credentials, input_data.repo_url)\n    yield from (('branch', branch) for branch in branches)",
        "branches = self.list_branches(credentials, input_data.repo_url)",
        "(yield from (('branch', branch) for branch in branches))",
        "class GithubListDiscussionsBlock(Block):\n\n    class Input(BlockSchema):\n        credentials: GithubCredentialsInput = GithubCredentialsField('repo')\n        repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')\n        num_discussions: int = SchemaField(description='Number of discussions to fetch', default=5)\n\n    class Output(BlockSchema):\n\n        class DiscussionItem(TypedDict):\n            title: str\n            url: str\n        discussion: DiscussionItem = SchemaField(title='Discussion', description='Discussions with their title and URL')\n        error: str = SchemaField(description='Error message if listing discussions failed')\n\n    def __init__(self):\n        super().__init__(id='3ef1a419-3d76-4e07-b761-de9dad4d51d7', description='This block lists recent discussions for a specified GitHub repository.', categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=GithubListDiscussionsBlock.Input, output_schema=GithubListDiscussionsBlock.Output, test_input={'repo_url': 'https://github.com/owner/repo', 'num_discussions': 3, 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('discussion', {'title': 'Discussion 1', 'url': 'https://github.com/owner/repo/discussions/1'})], test_mock={'list_discussions': lambda *args, **kwargs: [{'title': 'Discussion 1', 'url': 'https://github.com/owner/repo/discussions/1'}]})\n\n    @staticmethod\n    def list_discussions(credentials: GithubCredentials, repo_url: str, num_discussions: int) -> list[Output.DiscussionItem]:\n        api = get_api(credentials)\n        repo_path = repo_url.replace('https://github.com/', '')\n        (owner, repo) = repo_path.split('/')\n        query = '\\n        query($owner: String!, $repo: String!, $num: Int!) {\\n            repository(owner: $owner, name: $repo) {\\n                discussions(first: $num) {\\n                    nodes {\\n                        title\\n                        url\\n                    }\\n                }\\n            }\\n        }\\n        '\n        variables = {'owner': owner, 'repo': repo, 'num': num_discussions}\n        response = api.post('https://api.github.com/graphql', json={'query': query, 'variables': variables})\n        data = response.json()\n        discussions: list[GithubListDiscussionsBlock.Output.DiscussionItem] = [{'title': discussion['title'], 'url': discussion['url']} for discussion in data['data']['repository']['discussions']['nodes']]\n        return discussions\n\n    def run(self, input_data: Input, *, credentials: GithubCredentials, **kwargs) -> BlockOutput:\n        discussions = self.list_discussions(credentials, input_data.repo_url, input_data.num_discussions)\n        yield from (('discussion', discussion) for discussion in discussions)",
        "class Input(BlockSchema):\n    credentials: GithubCredentialsInput = GithubCredentialsField('repo')\n    repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')\n    num_discussions: int = SchemaField(description='Number of discussions to fetch', default=5)",
        "credentials: GithubCredentialsInput = GithubCredentialsField('repo')",
        "repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')",
        "num_discussions: int = SchemaField(description='Number of discussions to fetch', default=5)",
        "class Output(BlockSchema):\n\n    class DiscussionItem(TypedDict):\n        title: str\n        url: str\n    discussion: DiscussionItem = SchemaField(title='Discussion', description='Discussions with their title and URL')\n    error: str = SchemaField(description='Error message if listing discussions failed')",
        "class DiscussionItem(TypedDict):\n    title: str\n    url: str",
        "title: str",
        "url: str",
        "discussion: DiscussionItem = SchemaField(title='Discussion', description='Discussions with their title and URL')",
        "error: str = SchemaField(description='Error message if listing discussions failed')",
        "def __init__(self):\n    super().__init__(id='3ef1a419-3d76-4e07-b761-de9dad4d51d7', description='This block lists recent discussions for a specified GitHub repository.', categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=GithubListDiscussionsBlock.Input, output_schema=GithubListDiscussionsBlock.Output, test_input={'repo_url': 'https://github.com/owner/repo', 'num_discussions': 3, 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('discussion', {'title': 'Discussion 1', 'url': 'https://github.com/owner/repo/discussions/1'})], test_mock={'list_discussions': lambda *args, **kwargs: [{'title': 'Discussion 1', 'url': 'https://github.com/owner/repo/discussions/1'}]})",
        "super().__init__()",
        "@staticmethod\ndef list_discussions(credentials: GithubCredentials, repo_url: str, num_discussions: int) -> list[Output.DiscussionItem]:\n    api = get_api(credentials)\n    repo_path = repo_url.replace('https://github.com/', '')\n    (owner, repo) = repo_path.split('/')\n    query = '\\n        query($owner: String!, $repo: String!, $num: Int!) {\\n            repository(owner: $owner, name: $repo) {\\n                discussions(first: $num) {\\n                    nodes {\\n                        title\\n                        url\\n                    }\\n                }\\n            }\\n        }\\n        '\n    variables = {'owner': owner, 'repo': repo, 'num': num_discussions}\n    response = api.post('https://api.github.com/graphql', json={'query': query, 'variables': variables})\n    data = response.json()\n    discussions: list[GithubListDiscussionsBlock.Output.DiscussionItem] = [{'title': discussion['title'], 'url': discussion['url']} for discussion in data['data']['repository']['discussions']['nodes']]\n    return discussions",
        "api = get_api(credentials)",
        "repo_path = repo_url.replace('https://github.com/', '')",
        "(owner, repo) = repo_path.split('/')",
        "query = '\\n        query($owner: String!, $repo: String!, $num: Int!) {\\n            repository(owner: $owner, name: $repo) {\\n                discussions(first: $num) {\\n                    nodes {\\n                        title\\n                        url\\n                    }\\n                }\\n            }\\n        }\\n        '",
        "variables = {'owner': owner, 'repo': repo, 'num': num_discussions}",
        "response = api.post('https://api.github.com/graphql', json={'query': query, 'variables': variables})",
        "data = response.json()",
        "discussions: list[GithubListDiscussionsBlock.Output.DiscussionItem] = [{'title': discussion['title'], 'url': discussion['url']} for discussion in data['data']['repository']['discussions']['nodes']]",
        "return discussions"
      ],
      "code": "def run(self, input_data: Input, *, credentials: GithubCredentials, **kwargs) -> BlockOutput:\n    branches = self.list_branches(credentials, input_data.repo_url)\n    yield from (('branch', branch) for branch in branches)\nbranches = self.list_branches(credentials, input_data.repo_url)\n(yield from (('branch', branch) for branch in branches))\nclass GithubListDiscussionsBlock(Block):\n\n    class Input(BlockSchema):\n        credentials: GithubCredentialsInput = GithubCredentialsField('repo')\n        repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')\n        num_discussions: int = SchemaField(description='Number of discussions to fetch', default=5)\n\n    class Output(BlockSchema):\n\n        class DiscussionItem(TypedDict):\n            title: str\n            url: str\n        discussion: DiscussionItem = SchemaField(title='Discussion', description='Discussions with their title and URL')\n        error: str = SchemaField(description='Error message if listing discussions failed')\n\n    def __init__(self):\n        super().__init__(id='3ef1a419-3d76-4e07-b761-de9dad4d51d7', description='This block lists recent discussions for a specified GitHub repository.', categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=GithubListDiscussionsBlock.Input, output_schema=GithubListDiscussionsBlock.Output, test_input={'repo_url': 'https://github.com/owner/repo', 'num_discussions': 3, 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('discussion', {'title': 'Discussion 1', 'url': 'https://github.com/owner/repo/discussions/1'})], test_mock={'list_discussions': lambda *args, **kwargs: [{'title': 'Discussion 1', 'url': 'https://github.com/owner/repo/discussions/1'}]})\n\n    @staticmethod\n    def list_discussions(credentials: GithubCredentials, repo_url: str, num_discussions: int) -> list[Output.DiscussionItem]:\n        api = get_api(credentials)\n        repo_path = repo_url.replace('https://github.com/', '')\n        (owner, repo) = repo_path.split('/')\n        query = '\\n        query($owner: String!, $repo: String!, $num: Int!) {\\n            repository(owner: $owner, name: $repo) {\\n                discussions(first: $num) {\\n                    nodes {\\n                        title\\n                        url\\n                    }\\n                }\\n            }\\n        }\\n        '\n        variables = {'owner': owner, 'repo': repo, 'num': num_discussions}\n        response = api.post('https://api.github.com/graphql', json={'query': query, 'variables': variables})\n        data = response.json()\n        discussions: list[GithubListDiscussionsBlock.Output.DiscussionItem] = [{'title': discussion['title'], 'url': discussion['url']} for discussion in data['data']['repository']['discussions']['nodes']]\n        return discussions\n\n    def run(self, input_data: Input, *, credentials: GithubCredentials, **kwargs) -> BlockOutput:\n        discussions = self.list_discussions(credentials, input_data.repo_url, input_data.num_discussions)\n        yield from (('discussion', discussion) for discussion in discussions)\nclass Input(BlockSchema):\n    credentials: GithubCredentialsInput = GithubCredentialsField('repo')\n    repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')\n    num_discussions: int = SchemaField(description='Number of discussions to fetch', default=5)\ncredentials: GithubCredentialsInput = GithubCredentialsField('repo')\nrepo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')\nnum_discussions: int = SchemaField(description='Number of discussions to fetch', default=5)\nclass Output(BlockSchema):\n\n    class DiscussionItem(TypedDict):\n        title: str\n        url: str\n    discussion: DiscussionItem = SchemaField(title='Discussion', description='Discussions with their title and URL')\n    error: str = SchemaField(description='Error message if listing discussions failed')\nclass DiscussionItem(TypedDict):\n    title: str\n    url: str\ntitle: str\nurl: str\ndiscussion: DiscussionItem = SchemaField(title='Discussion', description='Discussions with their title and URL')\nerror: str = SchemaField(description='Error message if listing discussions failed')\ndef __init__(self):\n    super().__init__(id='3ef1a419-3d76-4e07-b761-de9dad4d51d7', description='This block lists recent discussions for a specified GitHub repository.', categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=GithubListDiscussionsBlock.Input, output_schema=GithubListDiscussionsBlock.Output, test_input={'repo_url': 'https://github.com/owner/repo', 'num_discussions': 3, 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('discussion', {'title': 'Discussion 1', 'url': 'https://github.com/owner/repo/discussions/1'})], test_mock={'list_discussions': lambda *args, **kwargs: [{'title': 'Discussion 1', 'url': 'https://github.com/owner/repo/discussions/1'}]})\nsuper().__init__()\n@staticmethod\ndef list_discussions(credentials: GithubCredentials, repo_url: str, num_discussions: int) -> list[Output.DiscussionItem]:\n    api = get_api(credentials)\n    repo_path = repo_url.replace('https://github.com/', '')\n    (owner, repo) = repo_path.split('/')\n    query = '\\n        query($owner: String!, $repo: String!, $num: Int!) {\\n            repository(owner: $owner, name: $repo) {\\n                discussions(first: $num) {\\n                    nodes {\\n                        title\\n                        url\\n                    }\\n                }\\n            }\\n        }\\n        '\n    variables = {'owner': owner, 'repo': repo, 'num': num_discussions}\n    response = api.post('https://api.github.com/graphql', json={'query': query, 'variables': variables})\n    data = response.json()\n    discussions: list[GithubListDiscussionsBlock.Output.DiscussionItem] = [{'title': discussion['title'], 'url': discussion['url']} for discussion in data['data']['repository']['discussions']['nodes']]\n    return discussions\napi = get_api(credentials)\nrepo_path = repo_url.replace('https://github.com/', '')\n(owner, repo) = repo_path.split('/')\nquery = '\\n        query($owner: String!, $repo: String!, $num: Int!) {\\n            repository(owner: $owner, name: $repo) {\\n                discussions(first: $num) {\\n                    nodes {\\n                        title\\n                        url\\n                    }\\n                }\\n            }\\n        }\\n        '\nvariables = {'owner': owner, 'repo': repo, 'num': num_discussions}\nresponse = api.post('https://api.github.com/graphql', json={'query': query, 'variables': variables})\ndata = response.json()\ndiscussions: list[GithubListDiscussionsBlock.Output.DiscussionItem] = [{'title': discussion['title'], 'url': discussion['url']} for discussion in data['data']['repository']['discussions']['nodes']]\nreturn discussions"
    },
    {
      "id": "n3",
      "type": "block",
      "statements": [
        "def run(self, input_data: Input, *, credentials: GithubCredentials, **kwargs) -> BlockOutput:\n    discussions = self.list_discussions(credentials, input_data.repo_url, input_data.num_discussions)\n    yield from (('discussion', discussion) for discussion in discussions)",
        "discussions = self.list_discussions(credentials, input_data.repo_url, input_data.num_discussions)",
        "(yield from (('discussion', discussion) for discussion in discussions))",
        "class GithubListReleasesBlock(Block):\n\n    class Input(BlockSchema):\n        credentials: GithubCredentialsInput = GithubCredentialsField('repo')\n        repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')\n\n    class Output(BlockSchema):\n\n        class ReleaseItem(TypedDict):\n            name: str\n            url: str\n        release: ReleaseItem = SchemaField(title='Release', description='Releases with their name and file tree browser URL')\n        error: str = SchemaField(description='Error message if listing releases failed')\n\n    def __init__(self):\n        super().__init__(id='3460367a-6ba7-4645-8ce6-47b05d040b92', description='This block lists all releases for a specified GitHub repository.', categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=GithubListReleasesBlock.Input, output_schema=GithubListReleasesBlock.Output, test_input={'repo_url': 'https://github.com/owner/repo', 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('release', {'name': 'v1.0.0', 'url': 'https://github.com/owner/repo/releases/tag/v1.0.0'})], test_mock={'list_releases': lambda *args, **kwargs: [{'name': 'v1.0.0', 'url': 'https://github.com/owner/repo/releases/tag/v1.0.0'}]})\n\n    @staticmethod\n    def list_releases(credentials: GithubCredentials, repo_url: str) -> list[Output.ReleaseItem]:\n        api = get_api(credentials)\n        releases_url = repo_url + '/releases'\n        response = api.get(releases_url)\n        data = response.json()\n        releases: list[GithubListReleasesBlock.Output.ReleaseItem] = [{'name': release['name'], 'url': release['html_url']} for release in data]\n        return releases\n\n    def run(self, input_data: Input, *, credentials: GithubCredentials, **kwargs) -> BlockOutput:\n        releases = self.list_releases(credentials, input_data.repo_url)\n        yield from (('release', release) for release in releases)",
        "class Input(BlockSchema):\n    credentials: GithubCredentialsInput = GithubCredentialsField('repo')\n    repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')",
        "credentials: GithubCredentialsInput = GithubCredentialsField('repo')",
        "repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')",
        "class Output(BlockSchema):\n\n    class ReleaseItem(TypedDict):\n        name: str\n        url: str\n    release: ReleaseItem = SchemaField(title='Release', description='Releases with their name and file tree browser URL')\n    error: str = SchemaField(description='Error message if listing releases failed')",
        "class ReleaseItem(TypedDict):\n    name: str\n    url: str",
        "name: str",
        "url: str",
        "release: ReleaseItem = SchemaField(title='Release', description='Releases with their name and file tree browser URL')",
        "error: str = SchemaField(description='Error message if listing releases failed')",
        "def __init__(self):\n    super().__init__(id='3460367a-6ba7-4645-8ce6-47b05d040b92', description='This block lists all releases for a specified GitHub repository.', categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=GithubListReleasesBlock.Input, output_schema=GithubListReleasesBlock.Output, test_input={'repo_url': 'https://github.com/owner/repo', 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('release', {'name': 'v1.0.0', 'url': 'https://github.com/owner/repo/releases/tag/v1.0.0'})], test_mock={'list_releases': lambda *args, **kwargs: [{'name': 'v1.0.0', 'url': 'https://github.com/owner/repo/releases/tag/v1.0.0'}]})",
        "super().__init__()",
        "@staticmethod\ndef list_releases(credentials: GithubCredentials, repo_url: str) -> list[Output.ReleaseItem]:\n    api = get_api(credentials)\n    releases_url = repo_url + '/releases'\n    response = api.get(releases_url)\n    data = response.json()\n    releases: list[GithubListReleasesBlock.Output.ReleaseItem] = [{'name': release['name'], 'url': release['html_url']} for release in data]\n    return releases",
        "api = get_api(credentials)",
        "releases_url = repo_url + '/releases'",
        "response = api.get(releases_url)",
        "data = response.json()",
        "releases: list[GithubListReleasesBlock.Output.ReleaseItem] = [{'name': release['name'], 'url': release['html_url']} for release in data]",
        "return releases"
      ],
      "code": "def run(self, input_data: Input, *, credentials: GithubCredentials, **kwargs) -> BlockOutput:\n    discussions = self.list_discussions(credentials, input_data.repo_url, input_data.num_discussions)\n    yield from (('discussion', discussion) for discussion in discussions)\ndiscussions = self.list_discussions(credentials, input_data.repo_url, input_data.num_discussions)\n(yield from (('discussion', discussion) for discussion in discussions))\nclass GithubListReleasesBlock(Block):\n\n    class Input(BlockSchema):\n        credentials: GithubCredentialsInput = GithubCredentialsField('repo')\n        repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')\n\n    class Output(BlockSchema):\n\n        class ReleaseItem(TypedDict):\n            name: str\n            url: str\n        release: ReleaseItem = SchemaField(title='Release', description='Releases with their name and file tree browser URL')\n        error: str = SchemaField(description='Error message if listing releases failed')\n\n    def __init__(self):\n        super().__init__(id='3460367a-6ba7-4645-8ce6-47b05d040b92', description='This block lists all releases for a specified GitHub repository.', categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=GithubListReleasesBlock.Input, output_schema=GithubListReleasesBlock.Output, test_input={'repo_url': 'https://github.com/owner/repo', 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('release', {'name': 'v1.0.0', 'url': 'https://github.com/owner/repo/releases/tag/v1.0.0'})], test_mock={'list_releases': lambda *args, **kwargs: [{'name': 'v1.0.0', 'url': 'https://github.com/owner/repo/releases/tag/v1.0.0'}]})\n\n    @staticmethod\n    def list_releases(credentials: GithubCredentials, repo_url: str) -> list[Output.ReleaseItem]:\n        api = get_api(credentials)\n        releases_url = repo_url + '/releases'\n        response = api.get(releases_url)\n        data = response.json()\n        releases: list[GithubListReleasesBlock.Output.ReleaseItem] = [{'name': release['name'], 'url': release['html_url']} for release in data]\n        return releases\n\n    def run(self, input_data: Input, *, credentials: GithubCredentials, **kwargs) -> BlockOutput:\n        releases = self.list_releases(credentials, input_data.repo_url)\n        yield from (('release', release) for release in releases)\nclass Input(BlockSchema):\n    credentials: GithubCredentialsInput = GithubCredentialsField('repo')\n    repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')\ncredentials: GithubCredentialsInput = GithubCredentialsField('repo')\nrepo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')\nclass Output(BlockSchema):\n\n    class ReleaseItem(TypedDict):\n        name: str\n        url: str\n    release: ReleaseItem = SchemaField(title='Release', description='Releases with their name and file tree browser URL')\n    error: str = SchemaField(description='Error message if listing releases failed')\nclass ReleaseItem(TypedDict):\n    name: str\n    url: str\nname: str\nurl: str\nrelease: ReleaseItem = SchemaField(title='Release', description='Releases with their name and file tree browser URL')\nerror: str = SchemaField(description='Error message if listing releases failed')\ndef __init__(self):\n    super().__init__(id='3460367a-6ba7-4645-8ce6-47b05d040b92', description='This block lists all releases for a specified GitHub repository.', categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=GithubListReleasesBlock.Input, output_schema=GithubListReleasesBlock.Output, test_input={'repo_url': 'https://github.com/owner/repo', 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('release', {'name': 'v1.0.0', 'url': 'https://github.com/owner/repo/releases/tag/v1.0.0'})], test_mock={'list_releases': lambda *args, **kwargs: [{'name': 'v1.0.0', 'url': 'https://github.com/owner/repo/releases/tag/v1.0.0'}]})\nsuper().__init__()\n@staticmethod\ndef list_releases(credentials: GithubCredentials, repo_url: str) -> list[Output.ReleaseItem]:\n    api = get_api(credentials)\n    releases_url = repo_url + '/releases'\n    response = api.get(releases_url)\n    data = response.json()\n    releases: list[GithubListReleasesBlock.Output.ReleaseItem] = [{'name': release['name'], 'url': release['html_url']} for release in data]\n    return releases\napi = get_api(credentials)\nreleases_url = repo_url + '/releases'\nresponse = api.get(releases_url)\ndata = response.json()\nreleases: list[GithubListReleasesBlock.Output.ReleaseItem] = [{'name': release['name'], 'url': release['html_url']} for release in data]\nreturn releases"
    },
    {
      "id": "n4",
      "type": "block",
      "statements": [
        "def run(self, input_data: Input, *, credentials: GithubCredentials, **kwargs) -> BlockOutput:\n    releases = self.list_releases(credentials, input_data.repo_url)\n    yield from (('release', release) for release in releases)",
        "releases = self.list_releases(credentials, input_data.repo_url)",
        "(yield from (('release', release) for release in releases))",
        "class GithubReadFileBlock(Block):\n\n    class Input(BlockSchema):\n        credentials: GithubCredentialsInput = GithubCredentialsField('repo')\n        repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')\n        file_path: str = SchemaField(description='Path to the file in the repository', placeholder='path/to/file')\n        branch: str = SchemaField(description='Branch to read from', placeholder='branch_name', default='master')\n\n    class Output(BlockSchema):\n        text_content: str = SchemaField(description='Content of the file (decoded as UTF-8 text)')\n        raw_content: str = SchemaField(description='Raw base64-encoded content of the file')\n        size: int = SchemaField(description='The size of the file (in bytes)')\n        error: str = SchemaField(description='Error message if the file reading failed')\n\n    def __init__(self):\n        super().__init__(id='87ce6c27-5752-4bbc-8e26-6da40a3dcfd3', description='This block reads the content of a specified file from a GitHub repository.', categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=GithubReadFileBlock.Input, output_schema=GithubReadFileBlock.Output, test_input={'repo_url': 'https://github.com/owner/repo', 'file_path': 'path/to/file', 'branch': 'master', 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('raw_content', 'RmlsZSBjb250ZW50'), ('text_content', 'File content'), ('size', 13)], test_mock={'read_file': lambda *args, **kwargs: ('RmlsZSBjb250ZW50', 13)})\n\n    @staticmethod\n    def read_file(credentials: GithubCredentials, repo_url: str, file_path: str, branch: str) -> tuple[str, int]:\n        api = get_api(credentials)\n        content_url = repo_url + f'/contents/{file_path}?ref={branch}'\n        response = api.get(content_url)\n        content = response.json()\n        if isinstance(content, list):\n            if not (file := next((f for f in content if f['type'] == 'file'), None)):\n                raise TypeError('Not a file')\n            content = file\n        if content['type'] != 'file':\n            raise TypeError('Not a file')\n        return (content['content'], content['size'])\n\n    def run(self, input_data: Input, *, credentials: GithubCredentials, **kwargs) -> BlockOutput:\n        (raw_content, size) = self.read_file(credentials, input_data.repo_url, input_data.file_path.lstrip('/'), input_data.branch)\n        yield ('raw_content', raw_content)\n        yield ('text_content', base64.b64decode(raw_content).decode('utf-8'))\n        yield ('size', size)",
        "class Input(BlockSchema):\n    credentials: GithubCredentialsInput = GithubCredentialsField('repo')\n    repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')\n    file_path: str = SchemaField(description='Path to the file in the repository', placeholder='path/to/file')\n    branch: str = SchemaField(description='Branch to read from', placeholder='branch_name', default='master')",
        "credentials: GithubCredentialsInput = GithubCredentialsField('repo')",
        "repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')",
        "file_path: str = SchemaField(description='Path to the file in the repository', placeholder='path/to/file')",
        "branch: str = SchemaField(description='Branch to read from', placeholder='branch_name', default='master')",
        "class Output(BlockSchema):\n    text_content: str = SchemaField(description='Content of the file (decoded as UTF-8 text)')\n    raw_content: str = SchemaField(description='Raw base64-encoded content of the file')\n    size: int = SchemaField(description='The size of the file (in bytes)')\n    error: str = SchemaField(description='Error message if the file reading failed')",
        "text_content: str = SchemaField(description='Content of the file (decoded as UTF-8 text)')",
        "raw_content: str = SchemaField(description='Raw base64-encoded content of the file')",
        "size: int = SchemaField(description='The size of the file (in bytes)')",
        "error: str = SchemaField(description='Error message if the file reading failed')",
        "def __init__(self):\n    super().__init__(id='87ce6c27-5752-4bbc-8e26-6da40a3dcfd3', description='This block reads the content of a specified file from a GitHub repository.', categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=GithubReadFileBlock.Input, output_schema=GithubReadFileBlock.Output, test_input={'repo_url': 'https://github.com/owner/repo', 'file_path': 'path/to/file', 'branch': 'master', 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('raw_content', 'RmlsZSBjb250ZW50'), ('text_content', 'File content'), ('size', 13)], test_mock={'read_file': lambda *args, **kwargs: ('RmlsZSBjb250ZW50', 13)})",
        "super().__init__()",
        "@staticmethod\ndef read_file(credentials: GithubCredentials, repo_url: str, file_path: str, branch: str) -> tuple[str, int]:\n    api = get_api(credentials)\n    content_url = repo_url + f'/contents/{file_path}?ref={branch}'\n    response = api.get(content_url)\n    content = response.json()\n    if isinstance(content, list):\n        if not (file := next((f for f in content if f['type'] == 'file'), None)):\n            raise TypeError('Not a file')\n        content = file\n    if content['type'] != 'file':\n        raise TypeError('Not a file')\n    return (content['content'], content['size'])",
        "api = get_api(credentials)",
        "content_url = repo_url + f'/contents/{file_path}?ref={branch}'",
        "response = api.get(content_url)",
        "content = response.json()",
        "isinstance(content, list)"
      ],
      "code": "def run(self, input_data: Input, *, credentials: GithubCredentials, **kwargs) -> BlockOutput:\n    releases = self.list_releases(credentials, input_data.repo_url)\n    yield from (('release', release) for release in releases)\nreleases = self.list_releases(credentials, input_data.repo_url)\n(yield from (('release', release) for release in releases))\nclass GithubReadFileBlock(Block):\n\n    class Input(BlockSchema):\n        credentials: GithubCredentialsInput = GithubCredentialsField('repo')\n        repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')\n        file_path: str = SchemaField(description='Path to the file in the repository', placeholder='path/to/file')\n        branch: str = SchemaField(description='Branch to read from', placeholder='branch_name', default='master')\n\n    class Output(BlockSchema):\n        text_content: str = SchemaField(description='Content of the file (decoded as UTF-8 text)')\n        raw_content: str = SchemaField(description='Raw base64-encoded content of the file')\n        size: int = SchemaField(description='The size of the file (in bytes)')\n        error: str = SchemaField(description='Error message if the file reading failed')\n\n    def __init__(self):\n        super().__init__(id='87ce6c27-5752-4bbc-8e26-6da40a3dcfd3', description='This block reads the content of a specified file from a GitHub repository.', categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=GithubReadFileBlock.Input, output_schema=GithubReadFileBlock.Output, test_input={'repo_url': 'https://github.com/owner/repo', 'file_path': 'path/to/file', 'branch': 'master', 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('raw_content', 'RmlsZSBjb250ZW50'), ('text_content', 'File content'), ('size', 13)], test_mock={'read_file': lambda *args, **kwargs: ('RmlsZSBjb250ZW50', 13)})\n\n    @staticmethod\n    def read_file(credentials: GithubCredentials, repo_url: str, file_path: str, branch: str) -> tuple[str, int]:\n        api = get_api(credentials)\n        content_url = repo_url + f'/contents/{file_path}?ref={branch}'\n        response = api.get(content_url)\n        content = response.json()\n        if isinstance(content, list):\n            if not (file := next((f for f in content if f['type'] == 'file'), None)):\n                raise TypeError('Not a file')\n            content = file\n        if content['type'] != 'file':\n            raise TypeError('Not a file')\n        return (content['content'], content['size'])\n\n    def run(self, input_data: Input, *, credentials: GithubCredentials, **kwargs) -> BlockOutput:\n        (raw_content, size) = self.read_file(credentials, input_data.repo_url, input_data.file_path.lstrip('/'), input_data.branch)\n        yield ('raw_content', raw_content)\n        yield ('text_content', base64.b64decode(raw_content).decode('utf-8'))\n        yield ('size', size)\nclass Input(BlockSchema):\n    credentials: GithubCredentialsInput = GithubCredentialsField('repo')\n    repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')\n    file_path: str = SchemaField(description='Path to the file in the repository', placeholder='path/to/file')\n    branch: str = SchemaField(description='Branch to read from', placeholder='branch_name', default='master')\ncredentials: GithubCredentialsInput = GithubCredentialsField('repo')\nrepo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')\nfile_path: str = SchemaField(description='Path to the file in the repository', placeholder='path/to/file')\nbranch: str = SchemaField(description='Branch to read from', placeholder='branch_name', default='master')\nclass Output(BlockSchema):\n    text_content: str = SchemaField(description='Content of the file (decoded as UTF-8 text)')\n    raw_content: str = SchemaField(description='Raw base64-encoded content of the file')\n    size: int = SchemaField(description='The size of the file (in bytes)')\n    error: str = SchemaField(description='Error message if the file reading failed')\ntext_content: str = SchemaField(description='Content of the file (decoded as UTF-8 text)')\nraw_content: str = SchemaField(description='Raw base64-encoded content of the file')\nsize: int = SchemaField(description='The size of the file (in bytes)')\nerror: str = SchemaField(description='Error message if the file reading failed')\ndef __init__(self):\n    super().__init__(id='87ce6c27-5752-4bbc-8e26-6da40a3dcfd3', description='This block reads the content of a specified file from a GitHub repository.', categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=GithubReadFileBlock.Input, output_schema=GithubReadFileBlock.Output, test_input={'repo_url': 'https://github.com/owner/repo', 'file_path': 'path/to/file', 'branch': 'master', 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('raw_content', 'RmlsZSBjb250ZW50'), ('text_content', 'File content'), ('size', 13)], test_mock={'read_file': lambda *args, **kwargs: ('RmlsZSBjb250ZW50', 13)})\nsuper().__init__()\n@staticmethod\ndef read_file(credentials: GithubCredentials, repo_url: str, file_path: str, branch: str) -> tuple[str, int]:\n    api = get_api(credentials)\n    content_url = repo_url + f'/contents/{file_path}?ref={branch}'\n    response = api.get(content_url)\n    content = response.json()\n    if isinstance(content, list):\n        if not (file := next((f for f in content if f['type'] == 'file'), None)):\n            raise TypeError('Not a file')\n        content = file\n    if content['type'] != 'file':\n        raise TypeError('Not a file')\n    return (content['content'], content['size'])\napi = get_api(credentials)\ncontent_url = repo_url + f'/contents/{file_path}?ref={branch}'\nresponse = api.get(content_url)\ncontent = response.json()\nisinstance(content, list)"
    },
    {
      "id": "n5",
      "type": "block",
      "statements": [
        "not (file := next((f for f in content if f['type'] == 'file'), None))"
      ],
      "code": "not (file := next((f for f in content if f['type'] == 'file'), None))"
    },
    {
      "id": "n6",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n7",
      "type": "block",
      "statements": [
        "content['type'] NotEq 'file'"
      ],
      "code": "content['type'] NotEq 'file'"
    },
    {
      "id": "n8",
      "type": "block",
      "statements": [
        "raise TypeError('Not a file')"
      ],
      "code": "raise TypeError('Not a file')"
    },
    {
      "id": "n9",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n10",
      "type": "block",
      "statements": [
        "content = file"
      ],
      "code": "content = file"
    },
    {
      "id": "n11",
      "type": "block",
      "statements": [
        "raise TypeError('Not a file')"
      ],
      "code": "raise TypeError('Not a file')"
    },
    {
      "id": "n12",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n13",
      "type": "block",
      "statements": [
        "return (content['content'], content['size'])"
      ],
      "code": "return (content['content'], content['size'])"
    },
    {
      "id": "n14",
      "type": "block",
      "statements": [
        "def run(self, input_data: Input, *, credentials: GithubCredentials, **kwargs) -> BlockOutput:\n    (raw_content, size) = self.read_file(credentials, input_data.repo_url, input_data.file_path.lstrip('/'), input_data.branch)\n    yield ('raw_content', raw_content)\n    yield ('text_content', base64.b64decode(raw_content).decode('utf-8'))\n    yield ('size', size)",
        "(raw_content, size) = self.read_file(credentials, input_data.repo_url, input_data.file_path.lstrip('/'), input_data.branch)",
        "(yield ('raw_content', raw_content))",
        "(yield ('text_content', base64.b64decode(raw_content).decode('utf-8')))",
        "(yield ('size', size))",
        "class GithubReadFolderBlock(Block):\n\n    class Input(BlockSchema):\n        credentials: GithubCredentialsInput = GithubCredentialsField('repo')\n        repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')\n        folder_path: str = SchemaField(description='Path to the folder in the repository', placeholder='path/to/folder')\n        branch: str = SchemaField(description='Branch name to read from (defaults to master)', placeholder='branch_name', default='master')\n\n    class Output(BlockSchema):\n\n        class DirEntry(TypedDict):\n            name: str\n            path: str\n\n        class FileEntry(TypedDict):\n            name: str\n            path: str\n            size: int\n        file: FileEntry = SchemaField(description='Files in the folder')\n        dir: DirEntry = SchemaField(description='Directories in the folder')\n        error: str = SchemaField(description='Error message if reading the folder failed')\n\n    def __init__(self):\n        super().__init__(id='1355f863-2db3-4d75-9fba-f91e8a8ca400', description='This block reads the content of a specified folder from a GitHub repository.', categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=GithubReadFolderBlock.Input, output_schema=GithubReadFolderBlock.Output, test_input={'repo_url': 'https://github.com/owner/repo', 'folder_path': 'path/to/folder', 'branch': 'master', 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('file', {'name': 'file1.txt', 'path': 'path/to/folder/file1.txt', 'size': 1337}), ('dir', {'name': 'dir2', 'path': 'path/to/folder/dir2'})], test_mock={'read_folder': lambda *args, **kwargs: ([{'name': 'file1.txt', 'path': 'path/to/folder/file1.txt', 'size': 1337}], [{'name': 'dir2', 'path': 'path/to/folder/dir2'}])})\n\n    @staticmethod\n    def read_folder(credentials: GithubCredentials, repo_url: str, folder_path: str, branch: str) -> tuple[list[Output.FileEntry], list[Output.DirEntry]]:\n        api = get_api(credentials)\n        contents_url = repo_url + f'/contents/{folder_path}?ref={branch}'\n        response = api.get(contents_url)\n        content = response.json()\n        if not isinstance(content, list):\n            raise TypeError('Not a folder')\n        files = [GithubReadFolderBlock.Output.FileEntry(name=entry['name'], path=entry['path'], size=entry['size']) for entry in content if entry['type'] == 'file']\n        dirs = [GithubReadFolderBlock.Output.DirEntry(name=entry['name'], path=entry['path']) for entry in content if entry['type'] == 'dir']\n        return (files, dirs)\n\n    def run(self, input_data: Input, *, credentials: GithubCredentials, **kwargs) -> BlockOutput:\n        (files, dirs) = self.read_folder(credentials, input_data.repo_url, input_data.folder_path.lstrip('/'), input_data.branch)\n        yield from (('file', file) for file in files)\n        yield from (('dir', dir) for dir in dirs)",
        "class Input(BlockSchema):\n    credentials: GithubCredentialsInput = GithubCredentialsField('repo')\n    repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')\n    folder_path: str = SchemaField(description='Path to the folder in the repository', placeholder='path/to/folder')\n    branch: str = SchemaField(description='Branch name to read from (defaults to master)', placeholder='branch_name', default='master')",
        "credentials: GithubCredentialsInput = GithubCredentialsField('repo')",
        "repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')",
        "folder_path: str = SchemaField(description='Path to the folder in the repository', placeholder='path/to/folder')",
        "branch: str = SchemaField(description='Branch name to read from (defaults to master)', placeholder='branch_name', default='master')",
        "class Output(BlockSchema):\n\n    class DirEntry(TypedDict):\n        name: str\n        path: str\n\n    class FileEntry(TypedDict):\n        name: str\n        path: str\n        size: int\n    file: FileEntry = SchemaField(description='Files in the folder')\n    dir: DirEntry = SchemaField(description='Directories in the folder')\n    error: str = SchemaField(description='Error message if reading the folder failed')",
        "class DirEntry(TypedDict):\n    name: str\n    path: str",
        "name: str",
        "path: str",
        "class FileEntry(TypedDict):\n    name: str\n    path: str\n    size: int",
        "name: str",
        "path: str",
        "size: int",
        "file: FileEntry = SchemaField(description='Files in the folder')",
        "dir: DirEntry = SchemaField(description='Directories in the folder')",
        "error: str = SchemaField(description='Error message if reading the folder failed')",
        "def __init__(self):\n    super().__init__(id='1355f863-2db3-4d75-9fba-f91e8a8ca400', description='This block reads the content of a specified folder from a GitHub repository.', categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=GithubReadFolderBlock.Input, output_schema=GithubReadFolderBlock.Output, test_input={'repo_url': 'https://github.com/owner/repo', 'folder_path': 'path/to/folder', 'branch': 'master', 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('file', {'name': 'file1.txt', 'path': 'path/to/folder/file1.txt', 'size': 1337}), ('dir', {'name': 'dir2', 'path': 'path/to/folder/dir2'})], test_mock={'read_folder': lambda *args, **kwargs: ([{'name': 'file1.txt', 'path': 'path/to/folder/file1.txt', 'size': 1337}], [{'name': 'dir2', 'path': 'path/to/folder/dir2'}])})",
        "super().__init__()",
        "@staticmethod\ndef read_folder(credentials: GithubCredentials, repo_url: str, folder_path: str, branch: str) -> tuple[list[Output.FileEntry], list[Output.DirEntry]]:\n    api = get_api(credentials)\n    contents_url = repo_url + f'/contents/{folder_path}?ref={branch}'\n    response = api.get(contents_url)\n    content = response.json()\n    if not isinstance(content, list):\n        raise TypeError('Not a folder')\n    files = [GithubReadFolderBlock.Output.FileEntry(name=entry['name'], path=entry['path'], size=entry['size']) for entry in content if entry['type'] == 'file']\n    dirs = [GithubReadFolderBlock.Output.DirEntry(name=entry['name'], path=entry['path']) for entry in content if entry['type'] == 'dir']\n    return (files, dirs)",
        "api = get_api(credentials)",
        "contents_url = repo_url + f'/contents/{folder_path}?ref={branch}'",
        "response = api.get(contents_url)",
        "content = response.json()",
        "not isinstance(content, list)"
      ],
      "code": "def run(self, input_data: Input, *, credentials: GithubCredentials, **kwargs) -> BlockOutput:\n    (raw_content, size) = self.read_file(credentials, input_data.repo_url, input_data.file_path.lstrip('/'), input_data.branch)\n    yield ('raw_content', raw_content)\n    yield ('text_content', base64.b64decode(raw_content).decode('utf-8'))\n    yield ('size', size)\n(raw_content, size) = self.read_file(credentials, input_data.repo_url, input_data.file_path.lstrip('/'), input_data.branch)\n(yield ('raw_content', raw_content))\n(yield ('text_content', base64.b64decode(raw_content).decode('utf-8')))\n(yield ('size', size))\nclass GithubReadFolderBlock(Block):\n\n    class Input(BlockSchema):\n        credentials: GithubCredentialsInput = GithubCredentialsField('repo')\n        repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')\n        folder_path: str = SchemaField(description='Path to the folder in the repository', placeholder='path/to/folder')\n        branch: str = SchemaField(description='Branch name to read from (defaults to master)', placeholder='branch_name', default='master')\n\n    class Output(BlockSchema):\n\n        class DirEntry(TypedDict):\n            name: str\n            path: str\n\n        class FileEntry(TypedDict):\n            name: str\n            path: str\n            size: int\n        file: FileEntry = SchemaField(description='Files in the folder')\n        dir: DirEntry = SchemaField(description='Directories in the folder')\n        error: str = SchemaField(description='Error message if reading the folder failed')\n\n    def __init__(self):\n        super().__init__(id='1355f863-2db3-4d75-9fba-f91e8a8ca400', description='This block reads the content of a specified folder from a GitHub repository.', categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=GithubReadFolderBlock.Input, output_schema=GithubReadFolderBlock.Output, test_input={'repo_url': 'https://github.com/owner/repo', 'folder_path': 'path/to/folder', 'branch': 'master', 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('file', {'name': 'file1.txt', 'path': 'path/to/folder/file1.txt', 'size': 1337}), ('dir', {'name': 'dir2', 'path': 'path/to/folder/dir2'})], test_mock={'read_folder': lambda *args, **kwargs: ([{'name': 'file1.txt', 'path': 'path/to/folder/file1.txt', 'size': 1337}], [{'name': 'dir2', 'path': 'path/to/folder/dir2'}])})\n\n    @staticmethod\n    def read_folder(credentials: GithubCredentials, repo_url: str, folder_path: str, branch: str) -> tuple[list[Output.FileEntry], list[Output.DirEntry]]:\n        api = get_api(credentials)\n        contents_url = repo_url + f'/contents/{folder_path}?ref={branch}'\n        response = api.get(contents_url)\n        content = response.json()\n        if not isinstance(content, list):\n            raise TypeError('Not a folder')\n        files = [GithubReadFolderBlock.Output.FileEntry(name=entry['name'], path=entry['path'], size=entry['size']) for entry in content if entry['type'] == 'file']\n        dirs = [GithubReadFolderBlock.Output.DirEntry(name=entry['name'], path=entry['path']) for entry in content if entry['type'] == 'dir']\n        return (files, dirs)\n\n    def run(self, input_data: Input, *, credentials: GithubCredentials, **kwargs) -> BlockOutput:\n        (files, dirs) = self.read_folder(credentials, input_data.repo_url, input_data.folder_path.lstrip('/'), input_data.branch)\n        yield from (('file', file) for file in files)\n        yield from (('dir', dir) for dir in dirs)\nclass Input(BlockSchema):\n    credentials: GithubCredentialsInput = GithubCredentialsField('repo')\n    repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')\n    folder_path: str = SchemaField(description='Path to the folder in the repository', placeholder='path/to/folder')\n    branch: str = SchemaField(description='Branch name to read from (defaults to master)', placeholder='branch_name', default='master')\ncredentials: GithubCredentialsInput = GithubCredentialsField('repo')\nrepo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')\nfolder_path: str = SchemaField(description='Path to the folder in the repository', placeholder='path/to/folder')\nbranch: str = SchemaField(description='Branch name to read from (defaults to master)', placeholder='branch_name', default='master')\nclass Output(BlockSchema):\n\n    class DirEntry(TypedDict):\n        name: str\n        path: str\n\n    class FileEntry(TypedDict):\n        name: str\n        path: str\n        size: int\n    file: FileEntry = SchemaField(description='Files in the folder')\n    dir: DirEntry = SchemaField(description='Directories in the folder')\n    error: str = SchemaField(description='Error message if reading the folder failed')\nclass DirEntry(TypedDict):\n    name: str\n    path: str\nname: str\npath: str\nclass FileEntry(TypedDict):\n    name: str\n    path: str\n    size: int\nname: str\npath: str\nsize: int\nfile: FileEntry = SchemaField(description='Files in the folder')\ndir: DirEntry = SchemaField(description='Directories in the folder')\nerror: str = SchemaField(description='Error message if reading the folder failed')\ndef __init__(self):\n    super().__init__(id='1355f863-2db3-4d75-9fba-f91e8a8ca400', description='This block reads the content of a specified folder from a GitHub repository.', categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=GithubReadFolderBlock.Input, output_schema=GithubReadFolderBlock.Output, test_input={'repo_url': 'https://github.com/owner/repo', 'folder_path': 'path/to/folder', 'branch': 'master', 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('file', {'name': 'file1.txt', 'path': 'path/to/folder/file1.txt', 'size': 1337}), ('dir', {'name': 'dir2', 'path': 'path/to/folder/dir2'})], test_mock={'read_folder': lambda *args, **kwargs: ([{'name': 'file1.txt', 'path': 'path/to/folder/file1.txt', 'size': 1337}], [{'name': 'dir2', 'path': 'path/to/folder/dir2'}])})\nsuper().__init__()\n@staticmethod\ndef read_folder(credentials: GithubCredentials, repo_url: str, folder_path: str, branch: str) -> tuple[list[Output.FileEntry], list[Output.DirEntry]]:\n    api = get_api(credentials)\n    contents_url = repo_url + f'/contents/{folder_path}?ref={branch}'\n    response = api.get(contents_url)\n    content = response.json()\n    if not isinstance(content, list):\n        raise TypeError('Not a folder')\n    files = [GithubReadFolderBlock.Output.FileEntry(name=entry['name'], path=entry['path'], size=entry['size']) for entry in content if entry['type'] == 'file']\n    dirs = [GithubReadFolderBlock.Output.DirEntry(name=entry['name'], path=entry['path']) for entry in content if entry['type'] == 'dir']\n    return (files, dirs)\napi = get_api(credentials)\ncontents_url = repo_url + f'/contents/{folder_path}?ref={branch}'\nresponse = api.get(contents_url)\ncontent = response.json()\nnot isinstance(content, list)"
    },
    {
      "id": "n15",
      "type": "block",
      "statements": [
        "raise TypeError('Not a folder')"
      ],
      "code": "raise TypeError('Not a folder')"
    },
    {
      "id": "n16",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n17",
      "type": "block",
      "statements": [
        "files = [GithubReadFolderBlock.Output.FileEntry(name=entry['name'], path=entry['path'], size=entry['size']) for entry in content if entry['type'] == 'file']",
        "dirs = [GithubReadFolderBlock.Output.DirEntry(name=entry['name'], path=entry['path']) for entry in content if entry['type'] == 'dir']",
        "return (files, dirs)"
      ],
      "code": "files = [GithubReadFolderBlock.Output.FileEntry(name=entry['name'], path=entry['path'], size=entry['size']) for entry in content if entry['type'] == 'file']\ndirs = [GithubReadFolderBlock.Output.DirEntry(name=entry['name'], path=entry['path']) for entry in content if entry['type'] == 'dir']\nreturn (files, dirs)"
    },
    {
      "id": "n18",
      "type": "block",
      "statements": [
        "def run(self, input_data: Input, *, credentials: GithubCredentials, **kwargs) -> BlockOutput:\n    (files, dirs) = self.read_folder(credentials, input_data.repo_url, input_data.folder_path.lstrip('/'), input_data.branch)\n    yield from (('file', file) for file in files)\n    yield from (('dir', dir) for dir in dirs)",
        "(files, dirs) = self.read_folder(credentials, input_data.repo_url, input_data.folder_path.lstrip('/'), input_data.branch)",
        "(yield from (('file', file) for file in files))",
        "(yield from (('dir', dir) for dir in dirs))",
        "class GithubMakeBranchBlock(Block):\n\n    class Input(BlockSchema):\n        credentials: GithubCredentialsInput = GithubCredentialsField('repo')\n        repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')\n        new_branch: str = SchemaField(description='Name of the new branch', placeholder='new_branch_name')\n        source_branch: str = SchemaField(description='Name of the source branch', placeholder='source_branch_name')\n\n    class Output(BlockSchema):\n        status: str = SchemaField(description='Status of the branch creation operation')\n        error: str = SchemaField(description='Error message if the branch creation failed')\n\n    def __init__(self):\n        super().__init__(id='944cc076-95e7-4d1b-b6b6-b15d8ee5448d', description='This block creates a new branch from a specified source branch.', categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=GithubMakeBranchBlock.Input, output_schema=GithubMakeBranchBlock.Output, test_input={'repo_url': 'https://github.com/owner/repo', 'new_branch': 'new_branch_name', 'source_branch': 'source_branch_name', 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('status', 'Branch created successfully')], test_mock={'create_branch': lambda *args, **kwargs: 'Branch created successfully'})\n\n    @staticmethod\n    def create_branch(credentials: GithubCredentials, repo_url: str, new_branch: str, source_branch: str) -> str:\n        api = get_api(credentials)\n        ref_url = repo_url + f'/git/refs/heads/{source_branch}'\n        response = api.get(ref_url)\n        sha = response.json()['object']['sha']\n        create_ref_url = repo_url + '/git/refs'\n        data = {'ref': f'refs/heads/{new_branch}', 'sha': sha}\n        response = api.post(create_ref_url, json=data)\n        return 'Branch created successfully'\n\n    def run(self, input_data: Input, *, credentials: GithubCredentials, **kwargs) -> BlockOutput:\n        status = self.create_branch(credentials, input_data.repo_url, input_data.new_branch, input_data.source_branch)\n        yield ('status', status)",
        "class Input(BlockSchema):\n    credentials: GithubCredentialsInput = GithubCredentialsField('repo')\n    repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')\n    new_branch: str = SchemaField(description='Name of the new branch', placeholder='new_branch_name')\n    source_branch: str = SchemaField(description='Name of the source branch', placeholder='source_branch_name')",
        "credentials: GithubCredentialsInput = GithubCredentialsField('repo')",
        "repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')",
        "new_branch: str = SchemaField(description='Name of the new branch', placeholder='new_branch_name')",
        "source_branch: str = SchemaField(description='Name of the source branch', placeholder='source_branch_name')",
        "class Output(BlockSchema):\n    status: str = SchemaField(description='Status of the branch creation operation')\n    error: str = SchemaField(description='Error message if the branch creation failed')",
        "status: str = SchemaField(description='Status of the branch creation operation')",
        "error: str = SchemaField(description='Error message if the branch creation failed')",
        "def __init__(self):\n    super().__init__(id='944cc076-95e7-4d1b-b6b6-b15d8ee5448d', description='This block creates a new branch from a specified source branch.', categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=GithubMakeBranchBlock.Input, output_schema=GithubMakeBranchBlock.Output, test_input={'repo_url': 'https://github.com/owner/repo', 'new_branch': 'new_branch_name', 'source_branch': 'source_branch_name', 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('status', 'Branch created successfully')], test_mock={'create_branch': lambda *args, **kwargs: 'Branch created successfully'})",
        "super().__init__()",
        "@staticmethod\ndef create_branch(credentials: GithubCredentials, repo_url: str, new_branch: str, source_branch: str) -> str:\n    api = get_api(credentials)\n    ref_url = repo_url + f'/git/refs/heads/{source_branch}'\n    response = api.get(ref_url)\n    sha = response.json()['object']['sha']\n    create_ref_url = repo_url + '/git/refs'\n    data = {'ref': f'refs/heads/{new_branch}', 'sha': sha}\n    response = api.post(create_ref_url, json=data)\n    return 'Branch created successfully'",
        "api = get_api(credentials)",
        "ref_url = repo_url + f'/git/refs/heads/{source_branch}'",
        "response = api.get(ref_url)",
        "sha = response.json()['object']['sha']",
        "create_ref_url = repo_url + '/git/refs'",
        "data = {'ref': f'refs/heads/{new_branch}', 'sha': sha}",
        "response = api.post(create_ref_url, json=data)",
        "return 'Branch created successfully'"
      ],
      "code": "def run(self, input_data: Input, *, credentials: GithubCredentials, **kwargs) -> BlockOutput:\n    (files, dirs) = self.read_folder(credentials, input_data.repo_url, input_data.folder_path.lstrip('/'), input_data.branch)\n    yield from (('file', file) for file in files)\n    yield from (('dir', dir) for dir in dirs)\n(files, dirs) = self.read_folder(credentials, input_data.repo_url, input_data.folder_path.lstrip('/'), input_data.branch)\n(yield from (('file', file) for file in files))\n(yield from (('dir', dir) for dir in dirs))\nclass GithubMakeBranchBlock(Block):\n\n    class Input(BlockSchema):\n        credentials: GithubCredentialsInput = GithubCredentialsField('repo')\n        repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')\n        new_branch: str = SchemaField(description='Name of the new branch', placeholder='new_branch_name')\n        source_branch: str = SchemaField(description='Name of the source branch', placeholder='source_branch_name')\n\n    class Output(BlockSchema):\n        status: str = SchemaField(description='Status of the branch creation operation')\n        error: str = SchemaField(description='Error message if the branch creation failed')\n\n    def __init__(self):\n        super().__init__(id='944cc076-95e7-4d1b-b6b6-b15d8ee5448d', description='This block creates a new branch from a specified source branch.', categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=GithubMakeBranchBlock.Input, output_schema=GithubMakeBranchBlock.Output, test_input={'repo_url': 'https://github.com/owner/repo', 'new_branch': 'new_branch_name', 'source_branch': 'source_branch_name', 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('status', 'Branch created successfully')], test_mock={'create_branch': lambda *args, **kwargs: 'Branch created successfully'})\n\n    @staticmethod\n    def create_branch(credentials: GithubCredentials, repo_url: str, new_branch: str, source_branch: str) -> str:\n        api = get_api(credentials)\n        ref_url = repo_url + f'/git/refs/heads/{source_branch}'\n        response = api.get(ref_url)\n        sha = response.json()['object']['sha']\n        create_ref_url = repo_url + '/git/refs'\n        data = {'ref': f'refs/heads/{new_branch}', 'sha': sha}\n        response = api.post(create_ref_url, json=data)\n        return 'Branch created successfully'\n\n    def run(self, input_data: Input, *, credentials: GithubCredentials, **kwargs) -> BlockOutput:\n        status = self.create_branch(credentials, input_data.repo_url, input_data.new_branch, input_data.source_branch)\n        yield ('status', status)\nclass Input(BlockSchema):\n    credentials: GithubCredentialsInput = GithubCredentialsField('repo')\n    repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')\n    new_branch: str = SchemaField(description='Name of the new branch', placeholder='new_branch_name')\n    source_branch: str = SchemaField(description='Name of the source branch', placeholder='source_branch_name')\ncredentials: GithubCredentialsInput = GithubCredentialsField('repo')\nrepo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')\nnew_branch: str = SchemaField(description='Name of the new branch', placeholder='new_branch_name')\nsource_branch: str = SchemaField(description='Name of the source branch', placeholder='source_branch_name')\nclass Output(BlockSchema):\n    status: str = SchemaField(description='Status of the branch creation operation')\n    error: str = SchemaField(description='Error message if the branch creation failed')\nstatus: str = SchemaField(description='Status of the branch creation operation')\nerror: str = SchemaField(description='Error message if the branch creation failed')\ndef __init__(self):\n    super().__init__(id='944cc076-95e7-4d1b-b6b6-b15d8ee5448d', description='This block creates a new branch from a specified source branch.', categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=GithubMakeBranchBlock.Input, output_schema=GithubMakeBranchBlock.Output, test_input={'repo_url': 'https://github.com/owner/repo', 'new_branch': 'new_branch_name', 'source_branch': 'source_branch_name', 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('status', 'Branch created successfully')], test_mock={'create_branch': lambda *args, **kwargs: 'Branch created successfully'})\nsuper().__init__()\n@staticmethod\ndef create_branch(credentials: GithubCredentials, repo_url: str, new_branch: str, source_branch: str) -> str:\n    api = get_api(credentials)\n    ref_url = repo_url + f'/git/refs/heads/{source_branch}'\n    response = api.get(ref_url)\n    sha = response.json()['object']['sha']\n    create_ref_url = repo_url + '/git/refs'\n    data = {'ref': f'refs/heads/{new_branch}', 'sha': sha}\n    response = api.post(create_ref_url, json=data)\n    return 'Branch created successfully'\napi = get_api(credentials)\nref_url = repo_url + f'/git/refs/heads/{source_branch}'\nresponse = api.get(ref_url)\nsha = response.json()['object']['sha']\ncreate_ref_url = repo_url + '/git/refs'\ndata = {'ref': f'refs/heads/{new_branch}', 'sha': sha}\nresponse = api.post(create_ref_url, json=data)\nreturn 'Branch created successfully'"
    },
    {
      "id": "n19",
      "type": "block",
      "statements": [
        "def run(self, input_data: Input, *, credentials: GithubCredentials, **kwargs) -> BlockOutput:\n    status = self.create_branch(credentials, input_data.repo_url, input_data.new_branch, input_data.source_branch)\n    yield ('status', status)",
        "status = self.create_branch(credentials, input_data.repo_url, input_data.new_branch, input_data.source_branch)",
        "(yield ('status', status))",
        "class GithubDeleteBranchBlock(Block):\n\n    class Input(BlockSchema):\n        credentials: GithubCredentialsInput = GithubCredentialsField('repo')\n        repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')\n        branch: str = SchemaField(description='Name of the branch to delete', placeholder='branch_name')\n\n    class Output(BlockSchema):\n        status: str = SchemaField(description='Status of the branch deletion operation')\n        error: str = SchemaField(description='Error message if the branch deletion failed')\n\n    def __init__(self):\n        super().__init__(id='0d4130f7-e0ab-4d55-adc3-0a40225e80f4', description='This block deletes a specified branch.', categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=GithubDeleteBranchBlock.Input, output_schema=GithubDeleteBranchBlock.Output, test_input={'repo_url': 'https://github.com/owner/repo', 'branch': 'branch_name', 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('status', 'Branch deleted successfully')], test_mock={'delete_branch': lambda *args, **kwargs: 'Branch deleted successfully'})\n\n    @staticmethod\n    def delete_branch(credentials: GithubCredentials, repo_url: str, branch: str) -> str:\n        api = get_api(credentials)\n        ref_url = repo_url + f'/git/refs/heads/{branch}'\n        api.delete(ref_url)\n        return 'Branch deleted successfully'\n\n    def run(self, input_data: Input, *, credentials: GithubCredentials, **kwargs) -> BlockOutput:\n        status = self.delete_branch(credentials, input_data.repo_url, input_data.branch)\n        yield ('status', status)",
        "class Input(BlockSchema):\n    credentials: GithubCredentialsInput = GithubCredentialsField('repo')\n    repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')\n    branch: str = SchemaField(description='Name of the branch to delete', placeholder='branch_name')",
        "credentials: GithubCredentialsInput = GithubCredentialsField('repo')",
        "repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')",
        "branch: str = SchemaField(description='Name of the branch to delete', placeholder='branch_name')",
        "class Output(BlockSchema):\n    status: str = SchemaField(description='Status of the branch deletion operation')\n    error: str = SchemaField(description='Error message if the branch deletion failed')",
        "status: str = SchemaField(description='Status of the branch deletion operation')",
        "error: str = SchemaField(description='Error message if the branch deletion failed')",
        "def __init__(self):\n    super().__init__(id='0d4130f7-e0ab-4d55-adc3-0a40225e80f4', description='This block deletes a specified branch.', categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=GithubDeleteBranchBlock.Input, output_schema=GithubDeleteBranchBlock.Output, test_input={'repo_url': 'https://github.com/owner/repo', 'branch': 'branch_name', 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('status', 'Branch deleted successfully')], test_mock={'delete_branch': lambda *args, **kwargs: 'Branch deleted successfully'})",
        "super().__init__()",
        "@staticmethod\ndef delete_branch(credentials: GithubCredentials, repo_url: str, branch: str) -> str:\n    api = get_api(credentials)\n    ref_url = repo_url + f'/git/refs/heads/{branch}'\n    api.delete(ref_url)\n    return 'Branch deleted successfully'",
        "api = get_api(credentials)",
        "ref_url = repo_url + f'/git/refs/heads/{branch}'",
        "api.delete(ref_url)",
        "return 'Branch deleted successfully'"
      ],
      "code": "def run(self, input_data: Input, *, credentials: GithubCredentials, **kwargs) -> BlockOutput:\n    status = self.create_branch(credentials, input_data.repo_url, input_data.new_branch, input_data.source_branch)\n    yield ('status', status)\nstatus = self.create_branch(credentials, input_data.repo_url, input_data.new_branch, input_data.source_branch)\n(yield ('status', status))\nclass GithubDeleteBranchBlock(Block):\n\n    class Input(BlockSchema):\n        credentials: GithubCredentialsInput = GithubCredentialsField('repo')\n        repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')\n        branch: str = SchemaField(description='Name of the branch to delete', placeholder='branch_name')\n\n    class Output(BlockSchema):\n        status: str = SchemaField(description='Status of the branch deletion operation')\n        error: str = SchemaField(description='Error message if the branch deletion failed')\n\n    def __init__(self):\n        super().__init__(id='0d4130f7-e0ab-4d55-adc3-0a40225e80f4', description='This block deletes a specified branch.', categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=GithubDeleteBranchBlock.Input, output_schema=GithubDeleteBranchBlock.Output, test_input={'repo_url': 'https://github.com/owner/repo', 'branch': 'branch_name', 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('status', 'Branch deleted successfully')], test_mock={'delete_branch': lambda *args, **kwargs: 'Branch deleted successfully'})\n\n    @staticmethod\n    def delete_branch(credentials: GithubCredentials, repo_url: str, branch: str) -> str:\n        api = get_api(credentials)\n        ref_url = repo_url + f'/git/refs/heads/{branch}'\n        api.delete(ref_url)\n        return 'Branch deleted successfully'\n\n    def run(self, input_data: Input, *, credentials: GithubCredentials, **kwargs) -> BlockOutput:\n        status = self.delete_branch(credentials, input_data.repo_url, input_data.branch)\n        yield ('status', status)\nclass Input(BlockSchema):\n    credentials: GithubCredentialsInput = GithubCredentialsField('repo')\n    repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')\n    branch: str = SchemaField(description='Name of the branch to delete', placeholder='branch_name')\ncredentials: GithubCredentialsInput = GithubCredentialsField('repo')\nrepo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')\nbranch: str = SchemaField(description='Name of the branch to delete', placeholder='branch_name')\nclass Output(BlockSchema):\n    status: str = SchemaField(description='Status of the branch deletion operation')\n    error: str = SchemaField(description='Error message if the branch deletion failed')\nstatus: str = SchemaField(description='Status of the branch deletion operation')\nerror: str = SchemaField(description='Error message if the branch deletion failed')\ndef __init__(self):\n    super().__init__(id='0d4130f7-e0ab-4d55-adc3-0a40225e80f4', description='This block deletes a specified branch.', categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=GithubDeleteBranchBlock.Input, output_schema=GithubDeleteBranchBlock.Output, test_input={'repo_url': 'https://github.com/owner/repo', 'branch': 'branch_name', 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('status', 'Branch deleted successfully')], test_mock={'delete_branch': lambda *args, **kwargs: 'Branch deleted successfully'})\nsuper().__init__()\n@staticmethod\ndef delete_branch(credentials: GithubCredentials, repo_url: str, branch: str) -> str:\n    api = get_api(credentials)\n    ref_url = repo_url + f'/git/refs/heads/{branch}'\n    api.delete(ref_url)\n    return 'Branch deleted successfully'\napi = get_api(credentials)\nref_url = repo_url + f'/git/refs/heads/{branch}'\napi.delete(ref_url)\nreturn 'Branch deleted successfully'"
    },
    {
      "id": "n20",
      "type": "block",
      "statements": [
        "def run(self, input_data: Input, *, credentials: GithubCredentials, **kwargs) -> BlockOutput:\n    status = self.delete_branch(credentials, input_data.repo_url, input_data.branch)\n    yield ('status', status)",
        "status = self.delete_branch(credentials, input_data.repo_url, input_data.branch)",
        "(yield ('status', status))"
      ],
      "code": "def run(self, input_data: Input, *, credentials: GithubCredentials, **kwargs) -> BlockOutput:\n    status = self.delete_branch(credentials, input_data.repo_url, input_data.branch)\n    yield ('status', status)\nstatus = self.delete_branch(credentials, input_data.repo_url, input_data.branch)\n(yield ('status', status))"
    }
  ],
  "edges": [
    {
      "source": "n10",
      "target": "n7"
    },
    {
      "source": "n5",
      "target": "n8"
    },
    {
      "source": "n6",
      "target": "n7"
    },
    {
      "source": "n5",
      "target": "n9"
    },
    {
      "source": "n7",
      "target": "n12"
    },
    {
      "source": "n8",
      "target": "n10"
    },
    {
      "source": "n16",
      "target": "n17"
    },
    {
      "source": "n14",
      "target": "n15"
    },
    {
      "source": "n14",
      "target": "n16"
    },
    {
      "source": "n7",
      "target": "n11"
    },
    {
      "source": "n9",
      "target": "n10"
    },
    {
      "source": "n4",
      "target": "n5"
    },
    {
      "source": "n4",
      "target": "n6"
    },
    {
      "source": "n12",
      "target": "n13"
    },
    {
      "source": "n11",
      "target": "n13"
    },
    {
      "source": "n15",
      "target": "n17"
    }
  ]
}