{
  "nodes": [
    {
      "id": "n0",
      "type": "block",
      "statements": [
        "import hashlib",
        "import secrets",
        "from typing import NamedTuple",
        "class APIKeyContainer(NamedTuple):\n    \"\"\"Container for API key parts.\"\"\"\n    raw: str\n    prefix: str\n    postfix: str\n    hash: str",
        "'Container for API key parts.'",
        "raw: str",
        "prefix: str",
        "postfix: str",
        "hash: str",
        "class APIKeyManager:\n    PREFIX: str = 'agpt_'\n    PREFIX_LENGTH: int = 8\n    POSTFIX_LENGTH: int = 8\n\n    def generate_api_key(self) -> APIKeyContainer:\n        \"\"\"Generate a new API key with all its parts.\"\"\"\n        raw_key = f'{self.PREFIX}{secrets.token_urlsafe(32)}'\n        return APIKeyContainer(raw=raw_key, prefix=raw_key[:self.PREFIX_LENGTH], postfix=raw_key[-self.POSTFIX_LENGTH:], hash=hashlib.sha256(raw_key.encode()).hexdigest())\n\n    def verify_api_key(self, provided_key: str, stored_hash: str) -> bool:\n        \"\"\"Verify if a provided API key matches the stored hash.\"\"\"\n        if not provided_key.startswith(self.PREFIX):\n            return False\n        return hashlib.sha256(provided_key.encode()).hexdigest() == stored_hash",
        "PREFIX: str = 'agpt_'",
        "PREFIX_LENGTH: int = 8",
        "POSTFIX_LENGTH: int = 8",
        "def generate_api_key(self) -> APIKeyContainer:\n    \"\"\"Generate a new API key with all its parts.\"\"\"\n    raw_key = f'{self.PREFIX}{secrets.token_urlsafe(32)}'\n    return APIKeyContainer(raw=raw_key, prefix=raw_key[:self.PREFIX_LENGTH], postfix=raw_key[-self.POSTFIX_LENGTH:], hash=hashlib.sha256(raw_key.encode()).hexdigest())",
        "'Generate a new API key with all its parts.'",
        "raw_key = f'{self.PREFIX}{secrets.token_urlsafe(32)}'",
        "return APIKeyContainer(raw=raw_key, prefix=raw_key[:self.PREFIX_LENGTH], postfix=raw_key[-self.POSTFIX_LENGTH:], hash=hashlib.sha256(raw_key.encode()).hexdigest())"
      ],
      "code": "import hashlib\nimport secrets\nfrom typing import NamedTuple\nclass APIKeyContainer(NamedTuple):\n    \"\"\"Container for API key parts.\"\"\"\n    raw: str\n    prefix: str\n    postfix: str\n    hash: str\n'Container for API key parts.'\nraw: str\nprefix: str\npostfix: str\nhash: str\nclass APIKeyManager:\n    PREFIX: str = 'agpt_'\n    PREFIX_LENGTH: int = 8\n    POSTFIX_LENGTH: int = 8\n\n    def generate_api_key(self) -> APIKeyContainer:\n        \"\"\"Generate a new API key with all its parts.\"\"\"\n        raw_key = f'{self.PREFIX}{secrets.token_urlsafe(32)}'\n        return APIKeyContainer(raw=raw_key, prefix=raw_key[:self.PREFIX_LENGTH], postfix=raw_key[-self.POSTFIX_LENGTH:], hash=hashlib.sha256(raw_key.encode()).hexdigest())\n\n    def verify_api_key(self, provided_key: str, stored_hash: str) -> bool:\n        \"\"\"Verify if a provided API key matches the stored hash.\"\"\"\n        if not provided_key.startswith(self.PREFIX):\n            return False\n        return hashlib.sha256(provided_key.encode()).hexdigest() == stored_hash\nPREFIX: str = 'agpt_'\nPREFIX_LENGTH: int = 8\nPOSTFIX_LENGTH: int = 8\ndef generate_api_key(self) -> APIKeyContainer:\n    \"\"\"Generate a new API key with all its parts.\"\"\"\n    raw_key = f'{self.PREFIX}{secrets.token_urlsafe(32)}'\n    return APIKeyContainer(raw=raw_key, prefix=raw_key[:self.PREFIX_LENGTH], postfix=raw_key[-self.POSTFIX_LENGTH:], hash=hashlib.sha256(raw_key.encode()).hexdigest())\n'Generate a new API key with all its parts.'\nraw_key = f'{self.PREFIX}{secrets.token_urlsafe(32)}'\nreturn APIKeyContainer(raw=raw_key, prefix=raw_key[:self.PREFIX_LENGTH], postfix=raw_key[-self.POSTFIX_LENGTH:], hash=hashlib.sha256(raw_key.encode()).hexdigest())"
    },
    {
      "id": "n1",
      "type": "block",
      "statements": [
        "def verify_api_key(self, provided_key: str, stored_hash: str) -> bool:\n    \"\"\"Verify if a provided API key matches the stored hash.\"\"\"\n    if not provided_key.startswith(self.PREFIX):\n        return False\n    return hashlib.sha256(provided_key.encode()).hexdigest() == stored_hash",
        "'Verify if a provided API key matches the stored hash.'",
        "not provided_key.startswith(self.PREFIX)"
      ],
      "code": "def verify_api_key(self, provided_key: str, stored_hash: str) -> bool:\n    \"\"\"Verify if a provided API key matches the stored hash.\"\"\"\n    if not provided_key.startswith(self.PREFIX):\n        return False\n    return hashlib.sha256(provided_key.encode()).hexdigest() == stored_hash\n'Verify if a provided API key matches the stored hash.'\nnot provided_key.startswith(self.PREFIX)"
    },
    {
      "id": "n2",
      "type": "block",
      "statements": [
        "return False"
      ],
      "code": "return False"
    },
    {
      "id": "n3",
      "type": "block",
      "statements": [],
      "code": "\nreturn hashlib.sha256(provided_key.encode()).hexdigest() == stored_hash"
    }
  ],
  "edges": [
    {
      "source": "n1",
      "target": "n2"
    },
    {
      "source": "n1",
      "target": "n3"
    }
  ]
}