{
  "nodes": [
    {
      "id": "n0",
      "type": "block",
      "statements": [
        "import logging",
        "from autogpt_libs.utils.cache import thread_cached",
        "from backend.data.block import Block, BlockCategory, BlockInput, BlockOutput, BlockSchema, BlockType, get_block",
        "from backend.data.execution import ExecutionStatus",
        "from backend.data.model import SchemaField",
        "logger = logging.getLogger(__name__)",
        "@thread_cached\ndef get_executor_manager_client():\n    from backend.executor import ExecutionManager\n    from backend.util.service import get_service_client\n    return get_service_client(ExecutionManager)",
        "from backend.executor import ExecutionManager",
        "from backend.util.service import get_service_client",
        "return get_service_client(ExecutionManager)"
      ],
      "code": "import logging\nfrom autogpt_libs.utils.cache import thread_cached\nfrom backend.data.block import Block, BlockCategory, BlockInput, BlockOutput, BlockSchema, BlockType, get_block\nfrom backend.data.execution import ExecutionStatus\nfrom backend.data.model import SchemaField\nlogger = logging.getLogger(__name__)\n@thread_cached\ndef get_executor_manager_client():\n    from backend.executor import ExecutionManager\n    from backend.util.service import get_service_client\n    return get_service_client(ExecutionManager)\nfrom backend.executor import ExecutionManager\nfrom backend.util.service import get_service_client\nreturn get_service_client(ExecutionManager)"
    },
    {
      "id": "n1",
      "type": "block",
      "statements": [
        "@thread_cached\ndef get_event_bus():\n    from backend.data.execution import RedisExecutionEventBus\n    return RedisExecutionEventBus()",
        "from backend.data.execution import RedisExecutionEventBus",
        "return RedisExecutionEventBus()"
      ],
      "code": "@thread_cached\ndef get_event_bus():\n    from backend.data.execution import RedisExecutionEventBus\n    return RedisExecutionEventBus()\nfrom backend.data.execution import RedisExecutionEventBus\nreturn RedisExecutionEventBus()"
    },
    {
      "id": "n2",
      "type": "block",
      "statements": [
        "class AgentExecutorBlock(Block):\n\n    class Input(BlockSchema):\n        user_id: str = SchemaField(description='User ID')\n        graph_id: str = SchemaField(description='Graph ID')\n        graph_version: int = SchemaField(description='Graph Version')\n        data: BlockInput = SchemaField(description='Input data for the graph')\n        input_schema: dict = SchemaField(description='Input schema for the graph')\n        output_schema: dict = SchemaField(description='Output schema for the graph')\n\n    class Output(BlockSchema):\n        pass\n\n    def __init__(self):\n        super().__init__(id='e189baac-8c20-45a1-94a7-55177ea42565', description='Executes an existing agent inside your agent', input_schema=AgentExecutorBlock.Input, output_schema=AgentExecutorBlock.Output, block_type=BlockType.AGENT, categories={BlockCategory.AGENT})\n\n    def run(self, input_data: Input, **kwargs) -> BlockOutput:\n        executor_manager = get_executor_manager_client()\n        event_bus = get_event_bus()\n        graph_exec = executor_manager.add_execution(graph_id=input_data.graph_id, graph_version=input_data.graph_version, user_id=input_data.user_id, data=input_data.data)\n        log_id = f'Graph #{input_data.graph_id}-V{input_data.graph_version}, exec-id: {graph_exec.graph_exec_id}'\n        logger.info(f'Starting execution of {log_id}')\n        for event in event_bus.listen(graph_id=graph_exec.graph_id, graph_exec_id=graph_exec.graph_exec_id):\n            logger.info(f'Execution {log_id} produced input {event.input_data} output {event.output_data}')\n            if not event.node_id:\n                if event.status in [ExecutionStatus.COMPLETED, ExecutionStatus.FAILED]:\n                    logger.info(f'Execution {log_id} ended with status {event.status}')\n                    break\n                else:\n                    continue\n            if not event.block_id:\n                logger.warning(f'{log_id} received event without block_id {event}')\n                continue\n            block = get_block(event.block_id)\n            if not block or block.block_type != BlockType.OUTPUT:\n                continue\n            output_name = event.input_data.get('name')\n            if not output_name:\n                logger.warning(f'{log_id} produced an output with no name {event}')\n                continue\n            for output_data in event.output_data.get('output', []):\n                logger.info(f'Execution {log_id} produced {output_name}: {output_data}')\n                yield (output_name, output_data)",
        "class Input(BlockSchema):\n    user_id: str = SchemaField(description='User ID')\n    graph_id: str = SchemaField(description='Graph ID')\n    graph_version: int = SchemaField(description='Graph Version')\n    data: BlockInput = SchemaField(description='Input data for the graph')\n    input_schema: dict = SchemaField(description='Input schema for the graph')\n    output_schema: dict = SchemaField(description='Output schema for the graph')",
        "user_id: str = SchemaField(description='User ID')",
        "graph_id: str = SchemaField(description='Graph ID')",
        "graph_version: int = SchemaField(description='Graph Version')",
        "data: BlockInput = SchemaField(description='Input data for the graph')",
        "input_schema: dict = SchemaField(description='Input schema for the graph')",
        "output_schema: dict = SchemaField(description='Output schema for the graph')",
        "class Output(BlockSchema):\n    pass",
        "pass",
        "def __init__(self):\n    super().__init__(id='e189baac-8c20-45a1-94a7-55177ea42565', description='Executes an existing agent inside your agent', input_schema=AgentExecutorBlock.Input, output_schema=AgentExecutorBlock.Output, block_type=BlockType.AGENT, categories={BlockCategory.AGENT})",
        "super().__init__()",
        "def run(self, input_data: Input, **kwargs) -> BlockOutput:\n    executor_manager = get_executor_manager_client()\n    event_bus = get_event_bus()\n    graph_exec = executor_manager.add_execution(graph_id=input_data.graph_id, graph_version=input_data.graph_version, user_id=input_data.user_id, data=input_data.data)\n    log_id = f'Graph #{input_data.graph_id}-V{input_data.graph_version}, exec-id: {graph_exec.graph_exec_id}'\n    logger.info(f'Starting execution of {log_id}')\n    for event in event_bus.listen(graph_id=graph_exec.graph_id, graph_exec_id=graph_exec.graph_exec_id):\n        logger.info(f'Execution {log_id} produced input {event.input_data} output {event.output_data}')\n        if not event.node_id:\n            if event.status in [ExecutionStatus.COMPLETED, ExecutionStatus.FAILED]:\n                logger.info(f'Execution {log_id} ended with status {event.status}')\n                break\n            else:\n                continue\n        if not event.block_id:\n            logger.warning(f'{log_id} received event without block_id {event}')\n            continue\n        block = get_block(event.block_id)\n        if not block or block.block_type != BlockType.OUTPUT:\n            continue\n        output_name = event.input_data.get('name')\n        if not output_name:\n            logger.warning(f'{log_id} produced an output with no name {event}')\n            continue\n        for output_data in event.output_data.get('output', []):\n            logger.info(f'Execution {log_id} produced {output_name}: {output_data}')\n            yield (output_name, output_data)",
        "executor_manager = get_executor_manager_client()",
        "event_bus = get_event_bus()",
        "graph_exec = executor_manager.add_execution(graph_id=input_data.graph_id, graph_version=input_data.graph_version, user_id=input_data.user_id, data=input_data.data)",
        "log_id = f'Graph #{input_data.graph_id}-V{input_data.graph_version}, exec-id: {graph_exec.graph_exec_id}'",
        "logger.info(f'Starting execution of {log_id}')"
      ],
      "code": "class AgentExecutorBlock(Block):\n\n    class Input(BlockSchema):\n        user_id: str = SchemaField(description='User ID')\n        graph_id: str = SchemaField(description='Graph ID')\n        graph_version: int = SchemaField(description='Graph Version')\n        data: BlockInput = SchemaField(description='Input data for the graph')\n        input_schema: dict = SchemaField(description='Input schema for the graph')\n        output_schema: dict = SchemaField(description='Output schema for the graph')\n\n    class Output(BlockSchema):\n        pass\n\n    def __init__(self):\n        super().__init__(id='e189baac-8c20-45a1-94a7-55177ea42565', description='Executes an existing agent inside your agent', input_schema=AgentExecutorBlock.Input, output_schema=AgentExecutorBlock.Output, block_type=BlockType.AGENT, categories={BlockCategory.AGENT})\n\n    def run(self, input_data: Input, **kwargs) -> BlockOutput:\n        executor_manager = get_executor_manager_client()\n        event_bus = get_event_bus()\n        graph_exec = executor_manager.add_execution(graph_id=input_data.graph_id, graph_version=input_data.graph_version, user_id=input_data.user_id, data=input_data.data)\n        log_id = f'Graph #{input_data.graph_id}-V{input_data.graph_version}, exec-id: {graph_exec.graph_exec_id}'\n        logger.info(f'Starting execution of {log_id}')\n        for event in event_bus.listen(graph_id=graph_exec.graph_id, graph_exec_id=graph_exec.graph_exec_id):\n            logger.info(f'Execution {log_id} produced input {event.input_data} output {event.output_data}')\n            if not event.node_id:\n                if event.status in [ExecutionStatus.COMPLETED, ExecutionStatus.FAILED]:\n                    logger.info(f'Execution {log_id} ended with status {event.status}')\n                    break\n                else:\n                    continue\n            if not event.block_id:\n                logger.warning(f'{log_id} received event without block_id {event}')\n                continue\n            block = get_block(event.block_id)\n            if not block or block.block_type != BlockType.OUTPUT:\n                continue\n            output_name = event.input_data.get('name')\n            if not output_name:\n                logger.warning(f'{log_id} produced an output with no name {event}')\n                continue\n            for output_data in event.output_data.get('output', []):\n                logger.info(f'Execution {log_id} produced {output_name}: {output_data}')\n                yield (output_name, output_data)\nclass Input(BlockSchema):\n    user_id: str = SchemaField(description='User ID')\n    graph_id: str = SchemaField(description='Graph ID')\n    graph_version: int = SchemaField(description='Graph Version')\n    data: BlockInput = SchemaField(description='Input data for the graph')\n    input_schema: dict = SchemaField(description='Input schema for the graph')\n    output_schema: dict = SchemaField(description='Output schema for the graph')\nuser_id: str = SchemaField(description='User ID')\ngraph_id: str = SchemaField(description='Graph ID')\ngraph_version: int = SchemaField(description='Graph Version')\ndata: BlockInput = SchemaField(description='Input data for the graph')\ninput_schema: dict = SchemaField(description='Input schema for the graph')\noutput_schema: dict = SchemaField(description='Output schema for the graph')\nclass Output(BlockSchema):\n    pass\npass\ndef __init__(self):\n    super().__init__(id='e189baac-8c20-45a1-94a7-55177ea42565', description='Executes an existing agent inside your agent', input_schema=AgentExecutorBlock.Input, output_schema=AgentExecutorBlock.Output, block_type=BlockType.AGENT, categories={BlockCategory.AGENT})\nsuper().__init__()\ndef run(self, input_data: Input, **kwargs) -> BlockOutput:\n    executor_manager = get_executor_manager_client()\n    event_bus = get_event_bus()\n    graph_exec = executor_manager.add_execution(graph_id=input_data.graph_id, graph_version=input_data.graph_version, user_id=input_data.user_id, data=input_data.data)\n    log_id = f'Graph #{input_data.graph_id}-V{input_data.graph_version}, exec-id: {graph_exec.graph_exec_id}'\n    logger.info(f'Starting execution of {log_id}')\n    for event in event_bus.listen(graph_id=graph_exec.graph_id, graph_exec_id=graph_exec.graph_exec_id):\n        logger.info(f'Execution {log_id} produced input {event.input_data} output {event.output_data}')\n        if not event.node_id:\n            if event.status in [ExecutionStatus.COMPLETED, ExecutionStatus.FAILED]:\n                logger.info(f'Execution {log_id} ended with status {event.status}')\n                break\n            else:\n                continue\n        if not event.block_id:\n            logger.warning(f'{log_id} received event without block_id {event}')\n            continue\n        block = get_block(event.block_id)\n        if not block or block.block_type != BlockType.OUTPUT:\n            continue\n        output_name = event.input_data.get('name')\n        if not output_name:\n            logger.warning(f'{log_id} produced an output with no name {event}')\n            continue\n        for output_data in event.output_data.get('output', []):\n            logger.info(f'Execution {log_id} produced {output_name}: {output_data}')\n            yield (output_name, output_data)\nexecutor_manager = get_executor_manager_client()\nevent_bus = get_event_bus()\ngraph_exec = executor_manager.add_execution(graph_id=input_data.graph_id, graph_version=input_data.graph_version, user_id=input_data.user_id, data=input_data.data)\nlog_id = f'Graph #{input_data.graph_id}-V{input_data.graph_version}, exec-id: {graph_exec.graph_exec_id}'\nlogger.info(f'Starting execution of {log_id}')"
    },
    {
      "id": "n3",
      "type": "block",
      "statements": [
        "event",
        "event_bus.listen()"
      ],
      "code": "event\nevent_bus.listen()"
    },
    {
      "id": "n4",
      "type": "block",
      "statements": [
        "logger.info(f'Execution {log_id} produced input {event.input_data} output {event.output_data}')",
        "not event.node_id"
      ],
      "code": "logger.info(f'Execution {log_id} produced input {event.input_data} output {event.output_data}')\nnot event.node_id"
    },
    {
      "id": "n5",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n6",
      "type": "block",
      "statements": [
        "event.status In [ExecutionStatus.COMPLETED, ExecutionStatus.FAILED]"
      ],
      "code": "event.status In [ExecutionStatus.COMPLETED, ExecutionStatus.FAILED]"
    },
    {
      "id": "n7",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n8",
      "type": "block",
      "statements": [
        "not event.block_id"
      ],
      "code": "not event.block_id"
    },
    {
      "id": "n9",
      "type": "block",
      "statements": [
        "logger.info(f'Execution {log_id} ended with status {event.status}')",
        "break"
      ],
      "code": "logger.info(f'Execution {log_id} ended with status {event.status}')\nbreak"
    },
    {
      "id": "n10",
      "type": "block",
      "statements": [
        "continue"
      ],
      "code": "continue"
    },
    {
      "id": "n11",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n12",
      "type": "block",
      "statements": [
        "logger.warning(f'{log_id} received event without block_id {event}')",
        "continue"
      ],
      "code": "logger.warning(f'{log_id} received event without block_id {event}')\ncontinue"
    },
    {
      "id": "n13",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n14",
      "type": "block",
      "statements": [
        "block = get_block(event.block_id)",
        "not block or block.block_type != BlockType.OUTPUT"
      ],
      "code": "block = get_block(event.block_id)\nnot block or block.block_type != BlockType.OUTPUT"
    },
    {
      "id": "n15",
      "type": "block",
      "statements": [
        "continue"
      ],
      "code": "continue"
    },
    {
      "id": "n16",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n17",
      "type": "block",
      "statements": [
        "output_name = event.input_data.get('name')",
        "not output_name"
      ],
      "code": "output_name = event.input_data.get('name')\nnot output_name"
    },
    {
      "id": "n18",
      "type": "block",
      "statements": [
        "logger.warning(f'{log_id} produced an output with no name {event}')",
        "continue"
      ],
      "code": "logger.warning(f'{log_id} produced an output with no name {event}')\ncontinue"
    },
    {
      "id": "n19",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n20",
      "type": "block",
      "statements": [],
      "code": ""
    },
    {
      "id": "n21",
      "type": "block",
      "statements": [
        "output_data",
        "event.output_data.get('output', [])"
      ],
      "code": "output_data\nevent.output_data.get('output', [])"
    },
    {
      "id": "n22",
      "type": "block",
      "statements": [
        "logger.info(f'Execution {log_id} produced {output_name}: {output_data}')",
        "(yield (output_name, output_data))"
      ],
      "code": "logger.info(f'Execution {log_id} produced {output_name}: {output_data}')\n(yield (output_name, output_data))"
    },
    {
      "id": "n23",
      "type": "block",
      "statements": [],
      "code": ""
    }
  ],
  "edges": [
    {
      "source": "n14",
      "target": "n15"
    },
    {
      "source": "n17",
      "target": "n18"
    },
    {
      "source": "n21",
      "target": "n22"
    },
    {
      "source": "n8",
      "target": "n12"
    },
    {
      "source": "n6",
      "target": "n9"
    },
    {
      "source": "n10",
      "target": "n11"
    },
    {
      "source": "n17",
      "target": "n19"
    },
    {
      "source": "n2",
      "target": "n3"
    },
    {
      "source": "n13",
      "target": "n14"
    },
    {
      "source": "n16",
      "target": "n17"
    },
    {
      "source": "n3",
      "target": "n4"
    },
    {
      "source": "n19",
      "target": "n20"
    },
    {
      "source": "n4",
      "target": "n6"
    },
    {
      "source": "n7",
      "target": "n8"
    },
    {
      "source": "n8",
      "target": "n13"
    },
    {
      "source": "n21",
      "target": "n23"
    },
    {
      "source": "n12",
      "target": "n14"
    },
    {
      "source": "n9",
      "target": "n11"
    },
    {
      "source": "n22",
      "target": "n21"
    },
    {
      "source": "n4",
      "target": "n7"
    },
    {
      "source": "n14",
      "target": "n16"
    },
    {
      "source": "n20",
      "target": "n21"
    },
    {
      "source": "n11",
      "target": "n8"
    },
    {
      "source": "n6",
      "target": "n10"
    },
    {
      "source": "n23",
      "target": "n3"
    },
    {
      "source": "n18",
      "target": "n20"
    },
    {
      "source": "n3",
      "target": "n5"
    },
    {
      "source": "n15",
      "target": "n17"
    }
  ]
}