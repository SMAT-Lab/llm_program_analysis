{
    "nodes": [
        {
            "id": "1",
            "type": "block",
            "statements": [
                "import base64",
                "from typing_extensions import TypedDict",
                "from backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema",
                "from backend.data.model import SchemaField",
                "from ._api import get_api",
                "from ._auth import TEST_CREDENTIALS, TEST_CREDENTIALS_INPUT, GithubCredentials, GithubCredentialsField, GithubCredentialsInput",
                "class GithubListTagsBlock(Block):\n\n    class Input(BlockSchema):\n        credentials: GithubCredentialsInput = GithubCredentialsField('repo')\n        repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')\n\n    class Output(BlockSchema):\n\n        class TagItem(TypedDict):\n            name: str\n            url: str\n        tag: TagItem = SchemaField(title='Tag', description='Tags with their name and file tree browser URL')\n        error: str = SchemaField(description='Error message if listing tags failed')\n\n    def __init__(self):\n        super().__init__(id='358924e7-9a11-4d1a-a0f2-13c67fe59e2e', description='This block lists all tags for a specified GitHub repository.', categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=GithubListTagsBlock.Input, output_schema=GithubListTagsBlock.Output, test_input={'repo_url': 'https://github.com/owner/repo', 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('tag', {'name': 'v1.0.0', 'url': 'https://github.com/owner/repo/tree/v1.0.0'})], test_mock={'list_tags': lambda *args, **kwargs: [{'name': 'v1.0.0', 'url': 'https://github.com/owner/repo/tree/v1.0.0'}]})\n\n    @staticmethod\n    def list_tags(credentials: GithubCredentials, repo_url: str) -> list[Output.TagItem]:\n        api = get_api(credentials)\n        tags_url = repo_url + '/tags'\n        response = api.get(tags_url)\n        data = response.json()\n        repo_path = repo_url.replace('https://github.com/', '')\n        tags: list[GithubListTagsBlock.Output.TagItem] = [{'name': tag['name'], 'url': f\"https://github.com/{repo_path}/tree/{tag['name']}\"} for tag in data]\n        return tags\n\n    def run(self, input_data: Input, *, credentials: GithubCredentials, **kwargs) -> BlockOutput:\n        tags = self.list_tags(credentials, input_data.repo_url)\n        yield from (('tag', tag) for tag in tags)",
                "class Input(BlockSchema):\n    credentials: GithubCredentialsInput = GithubCredentialsField('repo')\n    repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')",
                "credentials: GithubCredentialsInput = GithubCredentialsField('repo')",
                "repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')",
                "class Output(BlockSchema):\n\n    class TagItem(TypedDict):\n        name: str\n        url: str\n    tag: TagItem = SchemaField(title='Tag', description='Tags with their name and file tree browser URL')\n    error: str = SchemaField(description='Error message if listing tags failed')",
                "class TagItem(TypedDict):\n    name: str\n    url: str",
                "name: str",
                "url: str",
                "tag: TagItem = SchemaField(title='Tag', description='Tags with their name and file tree browser URL')",
                "error: str = SchemaField(description='Error message if listing tags failed')",
                "def __init__(self):\n    super().__init__(id='358924e7-9a11-4d1a-a0f2-13c67fe59e2e', description='This block lists all tags for a specified GitHub repository.', categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=GithubListTagsBlock.Input, output_schema=GithubListTagsBlock.Output, test_input={'repo_url': 'https://github.com/owner/repo', 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('tag', {'name': 'v1.0.0', 'url': 'https://github.com/owner/repo/tree/v1.0.0'})], test_mock={'list_tags': lambda *args, **kwargs: [{'name': 'v1.0.0', 'url': 'https://github.com/owner/repo/tree/v1.0.0'}]})",
                "super().__init__()",
                "@staticmethod\ndef list_tags(credentials: GithubCredentials, repo_url: str) -> list[Output.TagItem]:\n    api = get_api(credentials)\n    tags_url = repo_url + '/tags'\n    response = api.get(tags_url)\n    data = response.json()\n    repo_path = repo_url.replace('https://github.com/', '')\n    tags: list[GithubListTagsBlock.Output.TagItem] = [{'name': tag['name'], 'url': f\"https://github.com/{repo_path}/tree/{tag['name']}\"} for tag in data]\n    return tags",
                "api = get_api(credentials)",
                "tags_url = repo_url + '/tags'",
                "response = api.get(tags_url)",
                "data = response.json()",
                "repo_path = repo_url.replace('https://github.com/', '')",
                "tags: list[GithubListTagsBlock.Output.TagItem] = [{'name': tag['name'], 'url': f\"https://github.com/{repo_path}/tree/{tag['name']}\"} for tag in data]",
                "return tags"
            ]
        },
        {
            "id": "2",
            "type": "block",
            "statements": [
                "def run(self, input_data: Input, *, credentials: GithubCredentials, **kwargs) -> BlockOutput:\n    tags = self.list_tags(credentials, input_data.repo_url)\n    yield from (('tag', tag) for tag in tags)",
                "tags = self.list_tags(credentials, input_data.repo_url)",
                "(yield from (('tag', tag) for tag in tags))",
                "class GithubListBranchesBlock(Block):\n\n    class Input(BlockSchema):\n        credentials: GithubCredentialsInput = GithubCredentialsField('repo')\n        repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')\n\n    class Output(BlockSchema):\n\n        class BranchItem(TypedDict):\n            name: str\n            url: str\n        branch: BranchItem = SchemaField(title='Branch', description='Branches with their name and file tree browser URL')\n        error: str = SchemaField(description='Error message if listing branches failed')\n\n    def __init__(self):\n        super().__init__(id='74243e49-2bec-4916-8bf4-db43d44aead5', description='This block lists all branches for a specified GitHub repository.', categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=GithubListBranchesBlock.Input, output_schema=GithubListBranchesBlock.Output, test_input={'repo_url': 'https://github.com/owner/repo', 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('branch', {'name': 'main', 'url': 'https://github.com/owner/repo/tree/main'})], test_mock={'list_branches': lambda *args, **kwargs: [{'name': 'main', 'url': 'https://github.com/owner/repo/tree/main'}]})\n\n    @staticmethod\n    def list_branches(credentials: GithubCredentials, repo_url: str) -> list[Output.BranchItem]:\n        api = get_api(credentials)\n        branches_url = repo_url + '/branches'\n        response = api.get(branches_url)\n        data = response.json()\n        repo_path = repo_url.replace('https://github.com/', '')\n        branches: list[GithubListBranchesBlock.Output.BranchItem] = [{'name': branch['name'], 'url': f\"https://github.com/{repo_path}/tree/{branch['name']}\"} for branch in data]\n        return branches\n\n    def run(self, input_data: Input, *, credentials: GithubCredentials, **kwargs) -> BlockOutput:\n        branches = self.list_branches(credentials, input_data.repo_url)\n        yield from (('branch', branch) for branch in branches)",
                "class Input(BlockSchema):\n    credentials: GithubCredentialsInput = GithubCredentialsField('repo')\n    repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')",
                "credentials: GithubCredentialsInput = GithubCredentialsField('repo')",
                "repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')",
                "class Output(BlockSchema):\n\n    class BranchItem(TypedDict):\n        name: str\n        url: str\n    branch: BranchItem = SchemaField(title='Branch', description='Branches with their name and file tree browser URL')\n    error: str = SchemaField(description='Error message if listing branches failed')",
                "class BranchItem(TypedDict):\n    name: str\n    url: str",
                "name: str",
                "url: str",
                "branch: BranchItem = SchemaField(title='Branch', description='Branches with their name and file tree browser URL')",
                "error: str = SchemaField(description='Error message if listing branches failed')",
                "def __init__(self):\n    super().__init__(id='74243e49-2bec-4916-8bf4-db43d44aead5', description='This block lists all branches for a specified GitHub repository.', categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=GithubListBranchesBlock.Input, output_schema=GithubListBranchesBlock.Output, test_input={'repo_url': 'https://github.com/owner/repo', 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('branch', {'name': 'main', 'url': 'https://github.com/owner/repo/tree/main'})], test_mock={'list_branches': lambda *args, **kwargs: [{'name': 'main', 'url': 'https://github.com/owner/repo/tree/main'}]})",
                "super().__init__()",
                "@staticmethod\ndef list_branches(credentials: GithubCredentials, repo_url: str) -> list[Output.BranchItem]:\n    api = get_api(credentials)\n    branches_url = repo_url + '/branches'\n    response = api.get(branches_url)\n    data = response.json()\n    repo_path = repo_url.replace('https://github.com/', '')\n    branches: list[GithubListBranchesBlock.Output.BranchItem] = [{'name': branch['name'], 'url': f\"https://github.com/{repo_path}/tree/{branch['name']}\"} for branch in data]\n    return branches",
                "api = get_api(credentials)",
                "branches_url = repo_url + '/branches'",
                "response = api.get(branches_url)",
                "data = response.json()",
                "repo_path = repo_url.replace('https://github.com/', '')",
                "branches: list[GithubListBranchesBlock.Output.BranchItem] = [{'name': branch['name'], 'url': f\"https://github.com/{repo_path}/tree/{branch['name']}\"} for branch in data]",
                "return branches"
            ]
        },
        {
            "id": "3",
            "type": "block",
            "statements": [
                "def run(self, input_data: Input, *, credentials: GithubCredentials, **kwargs) -> BlockOutput:\n    branches = self.list_branches(credentials, input_data.repo_url)\n    yield from (('branch', branch) for branch in branches)",
                "branches = self.list_branches(credentials, input_data.repo_url)",
                "(yield from (('branch', branch) for branch in branches))",
                "class GithubListDiscussionsBlock(Block):\n\n    class Input(BlockSchema):\n        credentials: GithubCredentialsInput = GithubCredentialsField('repo')\n        repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')\n        num_discussions: int = SchemaField(description='Number of discussions to fetch', default=5)\n\n    class Output(BlockSchema):\n\n        class DiscussionItem(TypedDict):\n            title: str\n            url: str\n        discussion: DiscussionItem = SchemaField(title='Discussion', description='Discussions with their title and URL')\n        error: str = SchemaField(description='Error message if listing discussions failed')\n\n    def __init__(self):\n        super().__init__(id='3ef1a419-3d76-4e07-b761-de9dad4d51d7', description='This block lists recent discussions for a specified GitHub repository.', categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=GithubListDiscussionsBlock.Input, output_schema=GithubListDiscussionsBlock.Output, test_input={'repo_url': 'https://github.com/owner/repo', 'num_discussions': 3, 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('discussion', {'title': 'Discussion 1', 'url': 'https://github.com/owner/repo/discussions/1'})], test_mock={'list_discussions': lambda *args, **kwargs: [{'title': 'Discussion 1', 'url': 'https://github.com/owner/repo/discussions/1'}]})\n\n    @staticmethod\n    def list_discussions(credentials: GithubCredentials, repo_url: str, num_discussions: int) -> list[Output.DiscussionItem]:\n        api = get_api(credentials)\n        repo_path = repo_url.replace('https://github.com/', '')\n        (owner, repo) = repo_path.split('/')\n        query = '\\n        query($owner: String!, $repo: String!, $num: Int!) {\\n            repository(owner: $owner, name: $repo) {\\n                discussions(first: $num) {\\n                    nodes {\\n                        title\\n                        url\\n                    }\\n                }\\n            }\\n        }\\n        '\n        variables = {'owner': owner, 'repo': repo, 'num': num_discussions}\n        response = api.post('https://api.github.com/graphql', json={'query': query, 'variables': variables})\n        data = response.json()\n        discussions: list[GithubListDiscussionsBlock.Output.DiscussionItem] = [{'title': discussion['title'], 'url': discussion['url']} for discussion in data['data']['repository']['discussions']['nodes']]\n        return discussions\n\n    def run(self, input_data: Input, *, credentials: GithubCredentials, **kwargs) -> BlockOutput:\n        discussions = self.list_discussions(credentials, input_data.repo_url, input_data.num_discussions)\n        yield from (('discussion', discussion) for discussion in discussions)",
                "class Input(BlockSchema):\n    credentials: GithubCredentialsInput = GithubCredentialsField('repo')\n    repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')\n    num_discussions: int = SchemaField(description='Number of discussions to fetch', default=5)",
                "credentials: GithubCredentialsInput = GithubCredentialsField('repo')",
                "repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')",
                "num_discussions: int = SchemaField(description='Number of discussions to fetch', default=5)",
                "class Output(BlockSchema):\n\n    class DiscussionItem(TypedDict):\n        title: str\n        url: str\n    discussion: DiscussionItem = SchemaField(title='Discussion', description='Discussions with their title and URL')\n    error: str = SchemaField(description='Error message if listing discussions failed')",
                "class DiscussionItem(TypedDict):\n    title: str\n    url: str",
                "title: str",
                "url: str",
                "discussion: DiscussionItem = SchemaField(title='Discussion', description='Discussions with their title and URL')",
                "error: str = SchemaField(description='Error message if listing discussions failed')",
                "def __init__(self):\n    super().__init__(id='3ef1a419-3d76-4e07-b761-de9dad4d51d7', description='This block lists recent discussions for a specified GitHub repository.', categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=GithubListDiscussionsBlock.Input, output_schema=GithubListDiscussionsBlock.Output, test_input={'repo_url': 'https://github.com/owner/repo', 'num_discussions': 3, 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('discussion', {'title': 'Discussion 1', 'url': 'https://github.com/owner/repo/discussions/1'})], test_mock={'list_discussions': lambda *args, **kwargs: [{'title': 'Discussion 1', 'url': 'https://github.com/owner/repo/discussions/1'}]})",
                "super().__init__()",
                "@staticmethod\ndef list_discussions(credentials: GithubCredentials, repo_url: str, num_discussions: int) -> list[Output.DiscussionItem]:\n    api = get_api(credentials)\n    repo_path = repo_url.replace('https://github.com/', '')\n    (owner, repo) = repo_path.split('/')\n    query = '\\n        query($owner: String!, $repo: String!, $num: Int!) {\\n            repository(owner: $owner, name: $repo) {\\n                discussions(first: $num) {\\n                    nodes {\\n                        title\\n                        url\\n                    }\\n                }\\n            }\\n        }\\n        '\n    variables = {'owner': owner, 'repo': repo, 'num': num_discussions}\n    response = api.post('https://api.github.com/graphql', json={'query': query, 'variables': variables})\n    data = response.json()\n    discussions: list[GithubListDiscussionsBlock.Output.DiscussionItem] = [{'title': discussion['title'], 'url': discussion['url']} for discussion in data['data']['repository']['discussions']['nodes']]\n    return discussions",
                "api = get_api(credentials)",
                "repo_path = repo_url.replace('https://github.com/', '')",
                "(owner, repo) = repo_path.split('/')",
                "query = '\\n        query($owner: String!, $repo: String!, $num: Int!) {\\n            repository(owner: $owner, name: $repo) {\\n                discussions(first: $num) {\\n                    nodes {\\n                        title\\n                        url\\n                    }\\n                }\\n            }\\n        }\\n        '",
                "variables = {'owner': owner, 'repo': repo, 'num': num_discussions}",
                "response = api.post('https://api.github.com/graphql', json={'query': query, 'variables': variables})",
                "data = response.json()",
                "discussions: list[GithubListDiscussionsBlock.Output.DiscussionItem] = [{'title': discussion['title'], 'url': discussion['url']} for discussion in data['data']['repository']['discussions']['nodes']]",
                "return discussions"
            ]
        },
        {
            "id": "4",
            "type": "block",
            "statements": [
                "def run(self, input_data: Input, *, credentials: GithubCredentials, **kwargs) -> BlockOutput:\n    discussions = self.list_discussions(credentials, input_data.repo_url, input_data.num_discussions)\n    yield from (('discussion', discussion) for discussion in discussions)",
                "discussions = self.list_discussions(credentials, input_data.repo_url, input_data.num_discussions)",
                "(yield from (('discussion', discussion) for discussion in discussions))",
                "class GithubListReleasesBlock(Block):\n\n    class Input(BlockSchema):\n        credentials: GithubCredentialsInput = GithubCredentialsField('repo')\n        repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')\n\n    class Output(BlockSchema):\n\n        class ReleaseItem(TypedDict):\n            name: str\n            url: str\n        release: ReleaseItem = SchemaField(title='Release', description='Releases with their name and file tree browser URL')\n        error: str = SchemaField(description='Error message if listing releases failed')\n\n    def __init__(self):\n        super().__init__(id='3460367a-6ba7-4645-8ce6-47b05d040b92', description='This block lists all releases for a specified GitHub repository.', categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=GithubListReleasesBlock.Input, output_schema=GithubListReleasesBlock.Output, test_input={'repo_url': 'https://github.com/owner/repo', 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('release', {'name': 'v1.0.0', 'url': 'https://github.com/owner/repo/releases/tag/v1.0.0'})], test_mock={'list_releases': lambda *args, **kwargs: [{'name': 'v1.0.0', 'url': 'https://github.com/owner/repo/releases/tag/v1.0.0'}]})\n\n    @staticmethod\n    def list_releases(credentials: GithubCredentials, repo_url: str) -> list[Output.ReleaseItem]:\n        api = get_api(credentials)\n        releases_url = repo_url + '/releases'\n        response = api.get(releases_url)\n        data = response.json()\n        releases: list[GithubListReleasesBlock.Output.ReleaseItem] = [{'name': release['name'], 'url': release['html_url']} for release in data]\n        return releases\n\n    def run(self, input_data: Input, *, credentials: GithubCredentials, **kwargs) -> BlockOutput:\n        releases = self.list_releases(credentials, input_data.repo_url)\n        yield from (('release', release) for release in releases)",
                "class Input(BlockSchema):\n    credentials: GithubCredentialsInput = GithubCredentialsField('repo')\n    repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')",
                "credentials: GithubCredentialsInput = GithubCredentialsField('repo')",
                "repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')",
                "class Output(BlockSchema):\n\n    class ReleaseItem(TypedDict):\n        name: str\n        url: str\n    release: ReleaseItem = SchemaField(title='Release', description='Releases with their name and file tree browser URL')\n    error: str = SchemaField(description='Error message if listing releases failed')",
                "class ReleaseItem(TypedDict):\n    name: str\n    url: str",
                "name: str",
                "url: str",
                "release: ReleaseItem = SchemaField(title='Release', description='Releases with their name and file tree browser URL')",
                "error: str = SchemaField(description='Error message if listing releases failed')",
                "def __init__(self):\n    super().__init__(id='3460367a-6ba7-4645-8ce6-47b05d040b92', description='This block lists all releases for a specified GitHub repository.', categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=GithubListReleasesBlock.Input, output_schema=GithubListReleasesBlock.Output, test_input={'repo_url': 'https://github.com/owner/repo', 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('release', {'name': 'v1.0.0', 'url': 'https://github.com/owner/repo/releases/tag/v1.0.0'})], test_mock={'list_releases': lambda *args, **kwargs: [{'name': 'v1.0.0', 'url': 'https://github.com/owner/repo/releases/tag/v1.0.0'}]})",
                "super().__init__()",
                "@staticmethod\ndef list_releases(credentials: GithubCredentials, repo_url: str) -> list[Output.ReleaseItem]:\n    api = get_api(credentials)\n    releases_url = repo_url + '/releases'\n    response = api.get(releases_url)\n    data = response.json()\n    releases: list[GithubListReleasesBlock.Output.ReleaseItem] = [{'name': release['name'], 'url': release['html_url']} for release in data]\n    return releases",
                "api = get_api(credentials)",
                "releases_url = repo_url + '/releases'",
                "response = api.get(releases_url)",
                "data = response.json()",
                "releases: list[GithubListReleasesBlock.Output.ReleaseItem] = [{'name': release['name'], 'url': release['html_url']} for release in data]",
                "return releases"
            ]
        },
        {
            "id": "5",
            "type": "block",
            "statements": [
                "def run(self, input_data: Input, *, credentials: GithubCredentials, **kwargs) -> BlockOutput:\n    releases = self.list_releases(credentials, input_data.repo_url)\n    yield from (('release', release) for release in releases)",
                "releases = self.list_releases(credentials, input_data.repo_url)",
                "(yield from (('release', release) for release in releases))",
                "class GithubReadFileBlock(Block):\n\n    class Input(BlockSchema):\n        credentials: GithubCredentialsInput = GithubCredentialsField('repo')\n        repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')\n        file_path: str = SchemaField(description='Path to the file in the repository', placeholder='path/to/file')\n        branch: str = SchemaField(description='Branch to read from', placeholder='branch_name', default='master')\n\n    class Output(BlockSchema):\n        text_content: str = SchemaField(description='Content of the file (decoded as UTF-8 text)')\n        raw_content: str = SchemaField(description='Raw base64-encoded content of the file')\n        size: int = SchemaField(description='The size of the file (in bytes)')\n        error: str = SchemaField(description='Error message if the file reading failed')\n\n    def __init__(self):\n        super().__init__(id='87ce6c27-5752-4bbc-8e26-6da40a3dcfd3', description='This block reads the content of a specified file from a GitHub repository.', categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=GithubReadFileBlock.Input, output_schema=GithubReadFileBlock.Output, test_input={'repo_url': 'https://github.com/owner/repo', 'file_path': 'path/to/file', 'branch': 'master', 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('raw_content', 'RmlsZSBjb250ZW50'), ('text_content', 'File content'), ('size', 13)], test_mock={'read_file': lambda *args, **kwargs: ('RmlsZSBjb250ZW50', 13)})\n\n    @staticmethod\n    def read_file(credentials: GithubCredentials, repo_url: str, file_path: str, branch: str) -> tuple[str, int]:\n        api = get_api(credentials)\n        content_url = repo_url + f'/contents/{file_path}?ref={branch}'\n        response = api.get(content_url)\n        content = response.json()\n        if isinstance(content, list):\n            if not (file := next((f for f in content if f['type'] == 'file'), None)):\n                raise TypeError('Not a file')\n            content = file\n        if content['type'] != 'file':\n            raise TypeError('Not a file')\n        return (content['content'], content['size'])\n\n    def run(self, input_data: Input, *, credentials: GithubCredentials, **kwargs) -> BlockOutput:\n        (raw_content, size) = self.read_file(credentials, input_data.repo_url, input_data.file_path.lstrip('/'), input_data.branch)\n        yield ('raw_content', raw_content)\n        yield ('text_content', base64.b64decode(raw_content).decode('utf-8'))\n        yield ('size', size)",
                "class Input(BlockSchema):\n    credentials: GithubCredentialsInput = GithubCredentialsField('repo')\n    repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')\n    file_path: str = SchemaField(description='Path to the file in the repository', placeholder='path/to/file')\n    branch: str = SchemaField(description='Branch to read from', placeholder='branch_name', default='master')",
                "credentials: GithubCredentialsInput = GithubCredentialsField('repo')",
                "repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')",
                "file_path: str = SchemaField(description='Path to the file in the repository', placeholder='path/to/file')",
                "branch: str = SchemaField(description='Branch to read from', placeholder='branch_name', default='master')",
                "class Output(BlockSchema):\n    text_content: str = SchemaField(description='Content of the file (decoded as UTF-8 text)')\n    raw_content: str = SchemaField(description='Raw base64-encoded content of the file')\n    size: int = SchemaField(description='The size of the file (in bytes)')\n    error: str = SchemaField(description='Error message if the file reading failed')",
                "text_content: str = SchemaField(description='Content of the file (decoded as UTF-8 text)')",
                "raw_content: str = SchemaField(description='Raw base64-encoded content of the file')",
                "size: int = SchemaField(description='The size of the file (in bytes)')",
                "error: str = SchemaField(description='Error message if the file reading failed')",
                "def __init__(self):\n    super().__init__(id='87ce6c27-5752-4bbc-8e26-6da40a3dcfd3', description='This block reads the content of a specified file from a GitHub repository.', categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=GithubReadFileBlock.Input, output_schema=GithubReadFileBlock.Output, test_input={'repo_url': 'https://github.com/owner/repo', 'file_path': 'path/to/file', 'branch': 'master', 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('raw_content', 'RmlsZSBjb250ZW50'), ('text_content', 'File content'), ('size', 13)], test_mock={'read_file': lambda *args, **kwargs: ('RmlsZSBjb250ZW50', 13)})",
                "super().__init__()",
                "@staticmethod\ndef read_file(credentials: GithubCredentials, repo_url: str, file_path: str, branch: str) -> tuple[str, int]:\n    api = get_api(credentials)\n    content_url = repo_url + f'/contents/{file_path}?ref={branch}'\n    response = api.get(content_url)\n    content = response.json()\n    if isinstance(content, list):\n        if not (file := next((f for f in content if f['type'] == 'file'), None)):\n            raise TypeError('Not a file')\n        content = file\n    if content['type'] != 'file':\n        raise TypeError('Not a file')\n    return (content['content'], content['size'])",
                "api = get_api(credentials)",
                "content_url = repo_url + f'/contents/{file_path}?ref={branch}'",
                "response = api.get(content_url)",
                "content = response.json()",
                "isinstance(content, list)"
            ]
        },
        {
            "id": "6",
            "type": "block",
            "statements": [
                "not (file := next((f for f in content if f['type'] == 'file'), None))"
            ]
        },
        {
            "id": "7",
            "type": "block",
            "statements": []
        },
        {
            "id": "8",
            "type": "block",
            "statements": [
                "content['type'] NotEq 'file'"
            ]
        },
        {
            "id": "9",
            "type": "block",
            "statements": [
                "raise TypeError('Not a file')"
            ]
        },
        {
            "id": "10",
            "type": "block",
            "statements": []
        },
        {
            "id": "11",
            "type": "block",
            "statements": [
                "content = file"
            ]
        },
        {
            "id": "12",
            "type": "block",
            "statements": [
                "raise TypeError('Not a file')"
            ]
        },
        {
            "id": "13",
            "type": "block",
            "statements": []
        },
        {
            "id": "14",
            "type": "block",
            "statements": [
                "return (content['content'], content['size'])"
            ]
        },
        {
            "id": "15",
            "type": "block",
            "statements": [
                "def run(self, input_data: Input, *, credentials: GithubCredentials, **kwargs) -> BlockOutput:\n    (raw_content, size) = self.read_file(credentials, input_data.repo_url, input_data.file_path.lstrip('/'), input_data.branch)\n    yield ('raw_content', raw_content)\n    yield ('text_content', base64.b64decode(raw_content).decode('utf-8'))\n    yield ('size', size)",
                "(raw_content, size) = self.read_file(credentials, input_data.repo_url, input_data.file_path.lstrip('/'), input_data.branch)",
                "(yield ('raw_content', raw_content))",
                "(yield ('text_content', base64.b64decode(raw_content).decode('utf-8')))",
                "(yield ('size', size))",
                "class GithubReadFolderBlock(Block):\n\n    class Input(BlockSchema):\n        credentials: GithubCredentialsInput = GithubCredentialsField('repo')\n        repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')\n        folder_path: str = SchemaField(description='Path to the folder in the repository', placeholder='path/to/folder')\n        branch: str = SchemaField(description='Branch name to read from (defaults to master)', placeholder='branch_name', default='master')\n\n    class Output(BlockSchema):\n\n        class DirEntry(TypedDict):\n            name: str\n            path: str\n\n        class FileEntry(TypedDict):\n            name: str\n            path: str\n            size: int\n        file: FileEntry = SchemaField(description='Files in the folder')\n        dir: DirEntry = SchemaField(description='Directories in the folder')\n        error: str = SchemaField(description='Error message if reading the folder failed')\n\n    def __init__(self):\n        super().__init__(id='1355f863-2db3-4d75-9fba-f91e8a8ca400', description='This block reads the content of a specified folder from a GitHub repository.', categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=GithubReadFolderBlock.Input, output_schema=GithubReadFolderBlock.Output, test_input={'repo_url': 'https://github.com/owner/repo', 'folder_path': 'path/to/folder', 'branch': 'master', 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('file', {'name': 'file1.txt', 'path': 'path/to/folder/file1.txt', 'size': 1337}), ('dir', {'name': 'dir2', 'path': 'path/to/folder/dir2'})], test_mock={'read_folder': lambda *args, **kwargs: ([{'name': 'file1.txt', 'path': 'path/to/folder/file1.txt', 'size': 1337}], [{'name': 'dir2', 'path': 'path/to/folder/dir2'}])})\n\n    @staticmethod\n    def read_folder(credentials: GithubCredentials, repo_url: str, folder_path: str, branch: str) -> tuple[list[Output.FileEntry], list[Output.DirEntry]]:\n        api = get_api(credentials)\n        contents_url = repo_url + f'/contents/{folder_path}?ref={branch}'\n        response = api.get(contents_url)\n        content = response.json()\n        if not isinstance(content, list):\n            raise TypeError('Not a folder')\n        files = [GithubReadFolderBlock.Output.FileEntry(name=entry['name'], path=entry['path'], size=entry['size']) for entry in content if entry['type'] == 'file']\n        dirs = [GithubReadFolderBlock.Output.DirEntry(name=entry['name'], path=entry['path']) for entry in content if entry['type'] == 'dir']\n        return (files, dirs)\n\n    def run(self, input_data: Input, *, credentials: GithubCredentials, **kwargs) -> BlockOutput:\n        (files, dirs) = self.read_folder(credentials, input_data.repo_url, input_data.folder_path.lstrip('/'), input_data.branch)\n        yield from (('file', file) for file in files)\n        yield from (('dir', dir) for dir in dirs)",
                "class Input(BlockSchema):\n    credentials: GithubCredentialsInput = GithubCredentialsField('repo')\n    repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')\n    folder_path: str = SchemaField(description='Path to the folder in the repository', placeholder='path/to/folder')\n    branch: str = SchemaField(description='Branch name to read from (defaults to master)', placeholder='branch_name', default='master')",
                "credentials: GithubCredentialsInput = GithubCredentialsField('repo')",
                "repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')",
                "folder_path: str = SchemaField(description='Path to the folder in the repository', placeholder='path/to/folder')",
                "branch: str = SchemaField(description='Branch name to read from (defaults to master)', placeholder='branch_name', default='master')",
                "class Output(BlockSchema):\n\n    class DirEntry(TypedDict):\n        name: str\n        path: str\n\n    class FileEntry(TypedDict):\n        name: str\n        path: str\n        size: int\n    file: FileEntry = SchemaField(description='Files in the folder')\n    dir: DirEntry = SchemaField(description='Directories in the folder')\n    error: str = SchemaField(description='Error message if reading the folder failed')",
                "class DirEntry(TypedDict):\n    name: str\n    path: str",
                "name: str",
                "path: str",
                "class FileEntry(TypedDict):\n    name: str\n    path: str\n    size: int",
                "name: str",
                "path: str",
                "size: int",
                "file: FileEntry = SchemaField(description='Files in the folder')",
                "dir: DirEntry = SchemaField(description='Directories in the folder')",
                "error: str = SchemaField(description='Error message if reading the folder failed')",
                "def __init__(self):\n    super().__init__(id='1355f863-2db3-4d75-9fba-f91e8a8ca400', description='This block reads the content of a specified folder from a GitHub repository.', categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=GithubReadFolderBlock.Input, output_schema=GithubReadFolderBlock.Output, test_input={'repo_url': 'https://github.com/owner/repo', 'folder_path': 'path/to/folder', 'branch': 'master', 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('file', {'name': 'file1.txt', 'path': 'path/to/folder/file1.txt', 'size': 1337}), ('dir', {'name': 'dir2', 'path': 'path/to/folder/dir2'})], test_mock={'read_folder': lambda *args, **kwargs: ([{'name': 'file1.txt', 'path': 'path/to/folder/file1.txt', 'size': 1337}], [{'name': 'dir2', 'path': 'path/to/folder/dir2'}])})",
                "super().__init__()",
                "@staticmethod\ndef read_folder(credentials: GithubCredentials, repo_url: str, folder_path: str, branch: str) -> tuple[list[Output.FileEntry], list[Output.DirEntry]]:\n    api = get_api(credentials)\n    contents_url = repo_url + f'/contents/{folder_path}?ref={branch}'\n    response = api.get(contents_url)\n    content = response.json()\n    if not isinstance(content, list):\n        raise TypeError('Not a folder')\n    files = [GithubReadFolderBlock.Output.FileEntry(name=entry['name'], path=entry['path'], size=entry['size']) for entry in content if entry['type'] == 'file']\n    dirs = [GithubReadFolderBlock.Output.DirEntry(name=entry['name'], path=entry['path']) for entry in content if entry['type'] == 'dir']\n    return (files, dirs)",
                "api = get_api(credentials)",
                "contents_url = repo_url + f'/contents/{folder_path}?ref={branch}'",
                "response = api.get(contents_url)",
                "content = response.json()",
                "not isinstance(content, list)"
            ]
        },
        {
            "id": "16",
            "type": "block",
            "statements": [
                "raise TypeError('Not a folder')"
            ]
        },
        {
            "id": "17",
            "type": "block",
            "statements": []
        },
        {
            "id": "18",
            "type": "block",
            "statements": [
                "files = [GithubReadFolderBlock.Output.FileEntry(name=entry['name'], path=entry['path'], size=entry['size']) for entry in content if entry['type'] == 'file']",
                "dirs = [GithubReadFolderBlock.Output.DirEntry(name=entry['name'], path=entry['path']) for entry in content if entry['type'] == 'dir']",
                "return (files, dirs)"
            ]
        },
        {
            "id": "19",
            "type": "block",
            "statements": [
                "def run(self, input_data: Input, *, credentials: GithubCredentials, **kwargs) -> BlockOutput:\n    (files, dirs) = self.read_folder(credentials, input_data.repo_url, input_data.folder_path.lstrip('/'), input_data.branch)\n    yield from (('file', file) for file in files)\n    yield from (('dir', dir) for dir in dirs)",
                "(files, dirs) = self.read_folder(credentials, input_data.repo_url, input_data.folder_path.lstrip('/'), input_data.branch)",
                "(yield from (('file', file) for file in files))",
                "(yield from (('dir', dir) for dir in dirs))",
                "class GithubMakeBranchBlock(Block):\n\n    class Input(BlockSchema):\n        credentials: GithubCredentialsInput = GithubCredentialsField('repo')\n        repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')\n        new_branch: str = SchemaField(description='Name of the new branch', placeholder='new_branch_name')\n        source_branch: str = SchemaField(description='Name of the source branch', placeholder='source_branch_name')\n\n    class Output(BlockSchema):\n        status: str = SchemaField(description='Status of the branch creation operation')\n        error: str = SchemaField(description='Error message if the branch creation failed')\n\n    def __init__(self):\n        super().__init__(id='944cc076-95e7-4d1b-b6b6-b15d8ee5448d', description='This block creates a new branch from a specified source branch.', categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=GithubMakeBranchBlock.Input, output_schema=GithubMakeBranchBlock.Output, test_input={'repo_url': 'https://github.com/owner/repo', 'new_branch': 'new_branch_name', 'source_branch': 'source_branch_name', 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('status', 'Branch created successfully')], test_mock={'create_branch': lambda *args, **kwargs: 'Branch created successfully'})\n\n    @staticmethod\n    def create_branch(credentials: GithubCredentials, repo_url: str, new_branch: str, source_branch: str) -> str:\n        api = get_api(credentials)\n        ref_url = repo_url + f'/git/refs/heads/{source_branch}'\n        response = api.get(ref_url)\n        sha = response.json()['object']['sha']\n        create_ref_url = repo_url + '/git/refs'\n        data = {'ref': f'refs/heads/{new_branch}', 'sha': sha}\n        response = api.post(create_ref_url, json=data)\n        return 'Branch created successfully'\n\n    def run(self, input_data: Input, *, credentials: GithubCredentials, **kwargs) -> BlockOutput:\n        status = self.create_branch(credentials, input_data.repo_url, input_data.new_branch, input_data.source_branch)\n        yield ('status', status)",
                "class Input(BlockSchema):\n    credentials: GithubCredentialsInput = GithubCredentialsField('repo')\n    repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')\n    new_branch: str = SchemaField(description='Name of the new branch', placeholder='new_branch_name')\n    source_branch: str = SchemaField(description='Name of the source branch', placeholder='source_branch_name')",
                "credentials: GithubCredentialsInput = GithubCredentialsField('repo')",
                "repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')",
                "new_branch: str = SchemaField(description='Name of the new branch', placeholder='new_branch_name')",
                "source_branch: str = SchemaField(description='Name of the source branch', placeholder='source_branch_name')",
                "class Output(BlockSchema):\n    status: str = SchemaField(description='Status of the branch creation operation')\n    error: str = SchemaField(description='Error message if the branch creation failed')",
                "status: str = SchemaField(description='Status of the branch creation operation')",
                "error: str = SchemaField(description='Error message if the branch creation failed')",
                "def __init__(self):\n    super().__init__(id='944cc076-95e7-4d1b-b6b6-b15d8ee5448d', description='This block creates a new branch from a specified source branch.', categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=GithubMakeBranchBlock.Input, output_schema=GithubMakeBranchBlock.Output, test_input={'repo_url': 'https://github.com/owner/repo', 'new_branch': 'new_branch_name', 'source_branch': 'source_branch_name', 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('status', 'Branch created successfully')], test_mock={'create_branch': lambda *args, **kwargs: 'Branch created successfully'})",
                "super().__init__()",
                "@staticmethod\ndef create_branch(credentials: GithubCredentials, repo_url: str, new_branch: str, source_branch: str) -> str:\n    api = get_api(credentials)\n    ref_url = repo_url + f'/git/refs/heads/{source_branch}'\n    response = api.get(ref_url)\n    sha = response.json()['object']['sha']\n    create_ref_url = repo_url + '/git/refs'\n    data = {'ref': f'refs/heads/{new_branch}', 'sha': sha}\n    response = api.post(create_ref_url, json=data)\n    return 'Branch created successfully'",
                "api = get_api(credentials)",
                "ref_url = repo_url + f'/git/refs/heads/{source_branch}'",
                "response = api.get(ref_url)",
                "sha = response.json()['object']['sha']",
                "create_ref_url = repo_url + '/git/refs'",
                "data = {'ref': f'refs/heads/{new_branch}', 'sha': sha}",
                "response = api.post(create_ref_url, json=data)",
                "return 'Branch created successfully'"
            ]
        },
        {
            "id": "20",
            "type": "block",
            "statements": [
                "def run(self, input_data: Input, *, credentials: GithubCredentials, **kwargs) -> BlockOutput:\n    status = self.create_branch(credentials, input_data.repo_url, input_data.new_branch, input_data.source_branch)\n    yield ('status', status)",
                "status = self.create_branch(credentials, input_data.repo_url, input_data.new_branch, input_data.source_branch)",
                "(yield ('status', status))",
                "class GithubDeleteBranchBlock(Block):\n\n    class Input(BlockSchema):\n        credentials: GithubCredentialsInput = GithubCredentialsField('repo')\n        repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')\n        branch: str = SchemaField(description='Name of the branch to delete', placeholder='branch_name')\n\n    class Output(BlockSchema):\n        status: str = SchemaField(description='Status of the branch deletion operation')\n        error: str = SchemaField(description='Error message if the branch deletion failed')\n\n    def __init__(self):\n        super().__init__(id='0d4130f7-e0ab-4d55-adc3-0a40225e80f4', description='This block deletes a specified branch.', categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=GithubDeleteBranchBlock.Input, output_schema=GithubDeleteBranchBlock.Output, test_input={'repo_url': 'https://github.com/owner/repo', 'branch': 'branch_name', 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('status', 'Branch deleted successfully')], test_mock={'delete_branch': lambda *args, **kwargs: 'Branch deleted successfully'})\n\n    @staticmethod\n    def delete_branch(credentials: GithubCredentials, repo_url: str, branch: str) -> str:\n        api = get_api(credentials)\n        ref_url = repo_url + f'/git/refs/heads/{branch}'\n        api.delete(ref_url)\n        return 'Branch deleted successfully'\n\n    def run(self, input_data: Input, *, credentials: GithubCredentials, **kwargs) -> BlockOutput:\n        status = self.delete_branch(credentials, input_data.repo_url, input_data.branch)\n        yield ('status', status)",
                "class Input(BlockSchema):\n    credentials: GithubCredentialsInput = GithubCredentialsField('repo')\n    repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')\n    branch: str = SchemaField(description='Name of the branch to delete', placeholder='branch_name')",
                "credentials: GithubCredentialsInput = GithubCredentialsField('repo')",
                "repo_url: str = SchemaField(description='URL of the GitHub repository', placeholder='https://github.com/owner/repo')",
                "branch: str = SchemaField(description='Name of the branch to delete', placeholder='branch_name')",
                "class Output(BlockSchema):\n    status: str = SchemaField(description='Status of the branch deletion operation')\n    error: str = SchemaField(description='Error message if the branch deletion failed')",
                "status: str = SchemaField(description='Status of the branch deletion operation')",
                "error: str = SchemaField(description='Error message if the branch deletion failed')",
                "def __init__(self):\n    super().__init__(id='0d4130f7-e0ab-4d55-adc3-0a40225e80f4', description='This block deletes a specified branch.', categories={BlockCategory.DEVELOPER_TOOLS}, input_schema=GithubDeleteBranchBlock.Input, output_schema=GithubDeleteBranchBlock.Output, test_input={'repo_url': 'https://github.com/owner/repo', 'branch': 'branch_name', 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('status', 'Branch deleted successfully')], test_mock={'delete_branch': lambda *args, **kwargs: 'Branch deleted successfully'})",
                "super().__init__()",
                "@staticmethod\ndef delete_branch(credentials: GithubCredentials, repo_url: str, branch: str) -> str:\n    api = get_api(credentials)\n    ref_url = repo_url + f'/git/refs/heads/{branch}'\n    api.delete(ref_url)\n    return 'Branch deleted successfully'",
                "api = get_api(credentials)",
                "ref_url = repo_url + f'/git/refs/heads/{branch}'",
                "api.delete(ref_url)",
                "return 'Branch deleted successfully'"
            ]
        },
        {
            "id": "21",
            "type": "block",
            "statements": [
                "def run(self, input_data: Input, *, credentials: GithubCredentials, **kwargs) -> BlockOutput:\n    status = self.delete_branch(credentials, input_data.repo_url, input_data.branch)\n    yield ('status', status)",
                "status = self.delete_branch(credentials, input_data.repo_url, input_data.branch)",
                "(yield ('status', status))"
            ]
        }
    ],
    "edges": [
        {
            "source": "5",
            "target": "6",
            "type": "true"
        },
        {
            "source": "5",
            "target": "7",
            "type": "false"
        },
        {
            "source": "6",
            "target": "9",
            "type": "true"
        },
        {
            "source": "6",
            "target": "10",
            "type": "false"
        },
        {
            "source": "7",
            "target": "8",
            "type": "next"
        },
        {
            "source": "8",
            "target": "12",
            "type": "true"
        },
        {
            "source": "8",
            "target": "13",
            "type": "false"
        },
        {
            "source": "9",
            "target": "11",
            "type": "next"
        },
        {
            "source": "10",
            "target": "11",
            "type": "next"
        },
        {
            "source": "11",
            "target": "8",
            "type": "next"
        },
        {
            "source": "12",
            "target": "14",
            "type": "next"
        },
        {
            "source": "13",
            "target": "14",
            "type": "next"
        },
        {
            "source": "15",
            "target": "16",
            "type": "true"
        },
        {
            "source": "15",
            "target": "17",
            "type": "false"
        },
        {
            "source": "16",
            "target": "18",
            "type": "next"
        },
        {
            "source": "17",
            "target": "18",
            "type": "next"
        }
    ]
}