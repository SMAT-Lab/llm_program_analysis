{
    "nodes": [
        {
            "id": "1",
            "type": "block",
            "statements": [
                "import inspect",
                "from abc import ABC, abstractmethod",
                "from enum import Enum",
                "from typing import Any, ClassVar, Generator, Generic, Optional, Type, TypeVar, cast, get_origin",
                "import jsonref",
                "import jsonschema",
                "from prisma.models import AgentBlock",
                "from pydantic import BaseModel",
                "from backend.util import json",
                "from backend.util.settings import Config",
                "from .model import CREDENTIALS_FIELD_NAME, ContributorDetails, Credentials, CredentialsMetaInput",
                "app_config = Config()",
                "BlockData = tuple[str, Any]",
                "BlockInput = dict[str, Any]",
                "BlockOutput = Generator[BlockData, None, None]",
                "CompletedBlockOutput = dict[str, list[Any]]",
                "class BlockType(Enum):\n    STANDARD = 'Standard'\n    INPUT = 'Input'\n    OUTPUT = 'Output'\n    NOTE = 'Note'\n    WEBHOOK = 'Webhook'\n    WEBHOOK_MANUAL = 'Webhook (manual)'\n    AGENT = 'Agent'",
                "STANDARD = 'Standard'",
                "INPUT = 'Input'",
                "OUTPUT = 'Output'",
                "NOTE = 'Note'",
                "WEBHOOK = 'Webhook'",
                "WEBHOOK_MANUAL = 'Webhook (manual)'",
                "AGENT = 'Agent'",
                "class BlockCategory(Enum):\n    AI = 'Block that leverages AI to perform a task.'\n    SOCIAL = 'Block that interacts with social media platforms.'\n    TEXT = 'Block that processes text data.'\n    SEARCH = 'Block that searches or extracts information from the internet.'\n    BASIC = 'Block that performs basic operations.'\n    INPUT = 'Block that interacts with input of the graph.'\n    OUTPUT = 'Block that interacts with output of the graph.'\n    LOGIC = 'Programming logic to control the flow of your agent'\n    COMMUNICATION = 'Block that interacts with communication platforms.'\n    DEVELOPER_TOOLS = 'Developer tools such as GitHub blocks.'\n    DATA = 'Block that interacts with structured data.'\n    HARDWARE = 'Block that interacts with hardware.'\n    AGENT = 'Block that interacts with other agents.'\n    CRM = 'Block that interacts with CRM services.'\n\n    def dict(self) -> dict[str, str]:\n        return {'category': self.name, 'description': self.value}",
                "AI = 'Block that leverages AI to perform a task.'",
                "SOCIAL = 'Block that interacts with social media platforms.'",
                "TEXT = 'Block that processes text data.'",
                "SEARCH = 'Block that searches or extracts information from the internet.'",
                "BASIC = 'Block that performs basic operations.'",
                "INPUT = 'Block that interacts with input of the graph.'",
                "OUTPUT = 'Block that interacts with output of the graph.'",
                "LOGIC = 'Programming logic to control the flow of your agent'",
                "COMMUNICATION = 'Block that interacts with communication platforms.'",
                "DEVELOPER_TOOLS = 'Developer tools such as GitHub blocks.'",
                "DATA = 'Block that interacts with structured data.'",
                "HARDWARE = 'Block that interacts with hardware.'",
                "AGENT = 'Block that interacts with other agents.'",
                "CRM = 'Block that interacts with CRM services.'",
                "def dict(self) -> dict[str, str]:\n    return {'category': self.name, 'description': self.value}",
                "return {'category': self.name, 'description': self.value}"
            ]
        },
        {
            "id": "2",
            "type": "block",
            "statements": [
                "class BlockSchema(BaseModel):\n    cached_jsonschema: ClassVar[dict[str, Any]]\n\n    @classmethod\n    def jsonschema(cls) -> dict[str, Any]:\n        if cls.cached_jsonschema:\n            return cls.cached_jsonschema\n        model = jsonref.replace_refs(cls.model_json_schema(), merge_props=True)\n\n        def ref_to_dict(obj):\n            if isinstance(obj, dict):\n                keys = {'allOf', 'anyOf', 'oneOf'}\n                one_key = next((k for k in keys if k in obj and len(obj[k]) == 1), None)\n                if one_key:\n                    obj.update(obj[one_key][0])\n                return {key: ref_to_dict(value) for (key, value) in obj.items() if not key.startswith('$') and key != one_key}\n            elif isinstance(obj, list):\n                return [ref_to_dict(item) for item in obj]\n            return obj\n        cls.cached_jsonschema = cast(dict[str, Any], ref_to_dict(model))\n        for field in cls.cached_jsonschema.get('properties', {}).values():\n            if isinstance(field, dict) and 'advanced' not in field:\n                field['advanced'] = True\n        return cls.cached_jsonschema\n\n    @classmethod\n    def validate_data(cls, data: BlockInput) -> str | None:\n        return json.validate_with_jsonschema(schema=cls.jsonschema(), data=data)\n\n    @classmethod\n    def validate_field(cls, field_name: str, data: BlockInput) -> str | None:\n        \"\"\"\n        Validate the data against a specific property (one of the input/output name).\n        Returns the validation error message if the data does not match the schema.\n        \"\"\"\n        model_schema = cls.jsonschema().get('properties', {})\n        if not model_schema:\n            return f'Invalid model schema {cls}'\n        property_schema = model_schema.get(field_name)\n        if not property_schema:\n            return f'Invalid property name {field_name}'\n        try:\n            jsonschema.validate(json.to_dict(data), property_schema)\n            return None\n        except jsonschema.ValidationError as e:\n            return str(e)\n\n    @classmethod\n    def get_fields(cls) -> set[str]:\n        return set(cls.model_fields.keys())\n\n    @classmethod\n    def get_required_fields(cls) -> set[str]:\n        return {field for (field, field_info) in cls.model_fields.items() if field_info.is_required()}\n\n    @classmethod\n    def __pydantic_init_subclass__(cls, **kwargs):\n        \"\"\"Validates the schema definition. Rules:\n        - Only one `CredentialsMetaInput` field may be present.\n          - This field MUST be called `credentials`.\n        - A field that is called `credentials` MUST be a `CredentialsMetaInput`.\n        \"\"\"\n        super().__pydantic_init_subclass__(**kwargs)\n        cls.cached_jsonschema = {}\n        credentials_fields = [field_name for (field_name, info) in cls.model_fields.items() if inspect.isclass(info.annotation) and issubclass(get_origin(info.annotation) or info.annotation, CredentialsMetaInput)]\n        if len(credentials_fields) > 1:\n            raise ValueError(f'{cls.__qualname__} can only have one CredentialsMetaInput field')\n        elif len(credentials_fields) == 1 and credentials_fields[0] != CREDENTIALS_FIELD_NAME:\n            raise ValueError(f\"CredentialsMetaInput field on {cls.__qualname__} must be named 'credentials'\")\n        elif len(credentials_fields) == 0 and CREDENTIALS_FIELD_NAME in cls.model_fields.keys():\n            raise TypeError(f\"Field 'credentials' on {cls.__qualname__} must be of type {CredentialsMetaInput.__name__}\")\n        if (credentials_field := cls.model_fields.get(CREDENTIALS_FIELD_NAME)):\n            credentials_input_type = cast(CredentialsMetaInput, credentials_field.annotation)\n            credentials_input_type.validate_credentials_field_schema(cls)",
                "cached_jsonschema: ClassVar[dict[str, Any]]",
                "@classmethod\ndef jsonschema(cls) -> dict[str, Any]:\n    if cls.cached_jsonschema:\n        return cls.cached_jsonschema\n    model = jsonref.replace_refs(cls.model_json_schema(), merge_props=True)\n\n    def ref_to_dict(obj):\n        if isinstance(obj, dict):\n            keys = {'allOf', 'anyOf', 'oneOf'}\n            one_key = next((k for k in keys if k in obj and len(obj[k]) == 1), None)\n            if one_key:\n                obj.update(obj[one_key][0])\n            return {key: ref_to_dict(value) for (key, value) in obj.items() if not key.startswith('$') and key != one_key}\n        elif isinstance(obj, list):\n            return [ref_to_dict(item) for item in obj]\n        return obj\n    cls.cached_jsonschema = cast(dict[str, Any], ref_to_dict(model))\n    for field in cls.cached_jsonschema.get('properties', {}).values():\n        if isinstance(field, dict) and 'advanced' not in field:\n            field['advanced'] = True\n    return cls.cached_jsonschema",
                "cls.cached_jsonschema"
            ]
        },
        {
            "id": "3",
            "type": "block",
            "statements": [
                "return cls.cached_jsonschema"
            ]
        },
        {
            "id": "4",
            "type": "block",
            "statements": []
        },
        {
            "id": "5",
            "type": "block",
            "statements": [
                "model = jsonref.replace_refs(cls.model_json_schema(), merge_props=True)",
                "def ref_to_dict(obj):\n    if isinstance(obj, dict):\n        keys = {'allOf', 'anyOf', 'oneOf'}\n        one_key = next((k for k in keys if k in obj and len(obj[k]) == 1), None)\n        if one_key:\n            obj.update(obj[one_key][0])\n        return {key: ref_to_dict(value) for (key, value) in obj.items() if not key.startswith('$') and key != one_key}\n    elif isinstance(obj, list):\n        return [ref_to_dict(item) for item in obj]\n    return obj",
                "isinstance(obj, dict)"
            ]
        },
        {
            "id": "6",
            "type": "block",
            "statements": [
                "keys = {'allOf', 'anyOf', 'oneOf'}",
                "one_key = next((k for k in keys if k in obj and len(obj[k]) == 1), None)",
                "one_key"
            ]
        },
        {
            "id": "7",
            "type": "block",
            "statements": [
                "isinstance(obj, list)"
            ]
        },
        {
            "id": "8",
            "type": "block",
            "statements": [
                "return obj"
            ]
        },
        {
            "id": "9",
            "type": "block",
            "statements": [
                "obj.update(obj[one_key][0])"
            ]
        },
        {
            "id": "10",
            "type": "block",
            "statements": []
        },
        {
            "id": "11",
            "type": "block",
            "statements": [
                "return {key: ref_to_dict(value) for (key, value) in obj.items() if not key.startswith('$') and key != one_key}"
            ]
        },
        {
            "id": "12",
            "type": "block",
            "statements": [
                "return [ref_to_dict(item) for item in obj]"
            ]
        },
        {
            "id": "13",
            "type": "block",
            "statements": []
        },
        {
            "id": "14",
            "type": "block",
            "statements": []
        },
        {
            "id": "15",
            "type": "block",
            "statements": [
                "cls.cached_jsonschema = cast(dict[str, Any], ref_to_dict(model))"
            ]
        },
        {
            "id": "16",
            "type": "block",
            "statements": [
                "field",
                "cls.cached_jsonschema.get('properties', {}).values()"
            ]
        },
        {
            "id": "17",
            "type": "block",
            "statements": [
                "isinstance(field, dict) and 'advanced' not in field"
            ]
        },
        {
            "id": "18",
            "type": "block",
            "statements": [
                "return cls.cached_jsonschema"
            ]
        },
        {
            "id": "19",
            "type": "block",
            "statements": [
                "field['advanced'] = True"
            ]
        },
        {
            "id": "20",
            "type": "block",
            "statements": []
        },
        {
            "id": "21",
            "type": "block",
            "statements": []
        },
        {
            "id": "22",
            "type": "block",
            "statements": [
                "@classmethod\ndef validate_data(cls, data: BlockInput) -> str | None:\n    return json.validate_with_jsonschema(schema=cls.jsonschema(), data=data)",
                "return json.validate_with_jsonschema(schema=cls.jsonschema(), data=data)"
            ]
        },
        {
            "id": "23",
            "type": "block",
            "statements": [
                "@classmethod\ndef validate_field(cls, field_name: str, data: BlockInput) -> str | None:\n    \"\"\"\n        Validate the data against a specific property (one of the input/output name).\n        Returns the validation error message if the data does not match the schema.\n        \"\"\"\n    model_schema = cls.jsonschema().get('properties', {})\n    if not model_schema:\n        return f'Invalid model schema {cls}'\n    property_schema = model_schema.get(field_name)\n    if not property_schema:\n        return f'Invalid property name {field_name}'\n    try:\n        jsonschema.validate(json.to_dict(data), property_schema)\n        return None\n    except jsonschema.ValidationError as e:\n        return str(e)",
                "'\\n        Validate the data against a specific property (one of the input/output name).\\n        Returns the validation error message if the data does not match the schema.\\n        '",
                "model_schema = cls.jsonschema().get('properties', {})",
                "not model_schema"
            ]
        },
        {
            "id": "24",
            "type": "block",
            "statements": [
                "return f'Invalid model schema {cls}'"
            ]
        },
        {
            "id": "25",
            "type": "block",
            "statements": []
        },
        {
            "id": "26",
            "type": "block",
            "statements": [
                "property_schema = model_schema.get(field_name)",
                "not property_schema"
            ]
        },
        {
            "id": "27",
            "type": "block",
            "statements": [
                "return f'Invalid property name {field_name}'"
            ]
        },
        {
            "id": "28",
            "type": "block",
            "statements": []
        },
        {
            "id": "29",
            "type": "block",
            "statements": [
                "try:\n    jsonschema.validate(json.to_dict(data), property_schema)\n    return None\nexcept jsonschema.ValidationError as e:\n    return str(e)",
                "jsonschema.validate(json.to_dict(data), property_schema)",
                "return None"
            ]
        },
        {
            "id": "30",
            "type": "block",
            "statements": [
                "return str(e)"
            ]
        },
        {
            "id": "31",
            "type": "block",
            "statements": [
                "@classmethod\ndef get_fields(cls) -> set[str]:\n    return set(cls.model_fields.keys())",
                "return set(cls.model_fields.keys())"
            ]
        },
        {
            "id": "32",
            "type": "block",
            "statements": [
                "@classmethod\ndef get_required_fields(cls) -> set[str]:\n    return {field for (field, field_info) in cls.model_fields.items() if field_info.is_required()}",
                "return {field for (field, field_info) in cls.model_fields.items() if field_info.is_required()}"
            ]
        },
        {
            "id": "33",
            "type": "block",
            "statements": [
                "@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"Validates the schema definition. Rules:\n        - Only one `CredentialsMetaInput` field may be present.\n          - This field MUST be called `credentials`.\n        - A field that is called `credentials` MUST be a `CredentialsMetaInput`.\n        \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n    cls.cached_jsonschema = {}\n    credentials_fields = [field_name for (field_name, info) in cls.model_fields.items() if inspect.isclass(info.annotation) and issubclass(get_origin(info.annotation) or info.annotation, CredentialsMetaInput)]\n    if len(credentials_fields) > 1:\n        raise ValueError(f'{cls.__qualname__} can only have one CredentialsMetaInput field')\n    elif len(credentials_fields) == 1 and credentials_fields[0] != CREDENTIALS_FIELD_NAME:\n        raise ValueError(f\"CredentialsMetaInput field on {cls.__qualname__} must be named 'credentials'\")\n    elif len(credentials_fields) == 0 and CREDENTIALS_FIELD_NAME in cls.model_fields.keys():\n        raise TypeError(f\"Field 'credentials' on {cls.__qualname__} must be of type {CredentialsMetaInput.__name__}\")\n    if (credentials_field := cls.model_fields.get(CREDENTIALS_FIELD_NAME)):\n        credentials_input_type = cast(CredentialsMetaInput, credentials_field.annotation)\n        credentials_input_type.validate_credentials_field_schema(cls)",
                "'Validates the schema definition. Rules:\\n        - Only one `CredentialsMetaInput` field may be present.\\n          - This field MUST be called `credentials`.\\n        - A field that is called `credentials` MUST be a `CredentialsMetaInput`.\\n        '",
                "super().__pydantic_init_subclass__()",
                "cls.cached_jsonschema = {}",
                "credentials_fields = [field_name for (field_name, info) in cls.model_fields.items() if inspect.isclass(info.annotation) and issubclass(get_origin(info.annotation) or info.annotation, CredentialsMetaInput)]",
                "len(credentials_fields) Gt 1"
            ]
        },
        {
            "id": "34",
            "type": "block",
            "statements": [
                "raise ValueError(f'{cls.__qualname__} can only have one CredentialsMetaInput field')"
            ]
        },
        {
            "id": "35",
            "type": "block",
            "statements": [
                "len(credentials_fields) == 1 and credentials_fields[0] != CREDENTIALS_FIELD_NAME"
            ]
        },
        {
            "id": "36",
            "type": "block",
            "statements": [
                "(credentials_field := cls.model_fields.get(CREDENTIALS_FIELD_NAME))"
            ]
        },
        {
            "id": "37",
            "type": "block",
            "statements": [
                "raise ValueError(f\"CredentialsMetaInput field on {cls.__qualname__} must be named 'credentials'\")"
            ]
        },
        {
            "id": "38",
            "type": "block",
            "statements": [
                "len(credentials_fields) == 0 and CREDENTIALS_FIELD_NAME in cls.model_fields.keys()"
            ]
        },
        {
            "id": "39",
            "type": "block",
            "statements": []
        },
        {
            "id": "40",
            "type": "block",
            "statements": [
                "raise TypeError(f\"Field 'credentials' on {cls.__qualname__} must be of type {CredentialsMetaInput.__name__}\")"
            ]
        },
        {
            "id": "41",
            "type": "block",
            "statements": []
        },
        {
            "id": "42",
            "type": "block",
            "statements": []
        },
        {
            "id": "43",
            "type": "block",
            "statements": [
                "credentials_input_type = cast(CredentialsMetaInput, credentials_field.annotation)",
                "credentials_input_type.validate_credentials_field_schema(cls)"
            ]
        },
        {
            "id": "44",
            "type": "block",
            "statements": []
        },
        {
            "id": "45",
            "type": "block",
            "statements": [
                "BlockSchemaInputType = TypeVar('BlockSchemaInputType', bound=BlockSchema)",
                "BlockSchemaOutputType = TypeVar('BlockSchemaOutputType', bound=BlockSchema)",
                "class EmptySchema(BlockSchema):\n    pass",
                "pass",
                "class BlockManualWebhookConfig(BaseModel):\n    \"\"\"\n    Configuration model for webhook-triggered blocks on which\n    the user has to manually set up the webhook at the provider.\n    \"\"\"\n    provider: str\n    'The service provider that the webhook connects to'\n    webhook_type: str\n    '\\n    Identifier for the webhook type. E.g. GitHub has repo and organization level hooks.\\n\\n    Only for use in the corresponding `WebhooksManager`.\\n    '\n    event_filter_input: str = ''\n    \"\\n    Name of the block's event filter input.\\n    Leave empty if the corresponding webhook doesn't have distinct event/payload types.\\n    \"\n    event_format: str = '{event}'\n    '\\n    Template string for the event(s) that a block instance subscribes to.\\n    Applied individually to each event selected in the event filter input.\\n\\n    Example: `\"pull_request.{event}\"` -> `\"pull_request.opened\"`\\n    '",
                "'\\n    Configuration model for webhook-triggered blocks on which\\n    the user has to manually set up the webhook at the provider.\\n    '",
                "provider: str",
                "'The service provider that the webhook connects to'",
                "webhook_type: str",
                "'\\n    Identifier for the webhook type. E.g. GitHub has repo and organization level hooks.\\n\\n    Only for use in the corresponding `WebhooksManager`.\\n    '",
                "event_filter_input: str = ''",
                "\"\\n    Name of the block's event filter input.\\n    Leave empty if the corresponding webhook doesn't have distinct event/payload types.\\n    \"",
                "event_format: str = '{event}'",
                "'\\n    Template string for the event(s) that a block instance subscribes to.\\n    Applied individually to each event selected in the event filter input.\\n\\n    Example: `\"pull_request.{event}\"` -> `\"pull_request.opened\"`\\n    '",
                "class BlockWebhookConfig(BlockManualWebhookConfig):\n    \"\"\"\n    Configuration model for webhook-triggered blocks for which\n    the webhook can be automatically set up through the provider's API.\n    \"\"\"\n    resource_format: str\n    '\\n    Template string for the resource that a block instance subscribes to.\\n    Fields will be filled from the block\\'s inputs (except `payload`).\\n\\n    Example: `f\"{repo}/pull_requests\"` (note: not how it\\'s actually implemented)\\n\\n    Only for use in the corresponding `WebhooksManager`.\\n    '",
                "\"\\n    Configuration model for webhook-triggered blocks for which\\n    the webhook can be automatically set up through the provider's API.\\n    \"",
                "resource_format: str",
                "'\\n    Template string for the resource that a block instance subscribes to.\\n    Fields will be filled from the block\\'s inputs (except `payload`).\\n\\n    Example: `f\"{repo}/pull_requests\"` (note: not how it\\'s actually implemented)\\n\\n    Only for use in the corresponding `WebhooksManager`.\\n    '",
                "class Block(ABC, Generic[BlockSchemaInputType, BlockSchemaOutputType]):\n\n    def __init__(self, id: str='', description: str='', contributors: list[ContributorDetails]=[], categories: set[BlockCategory] | None=None, input_schema: Type[BlockSchemaInputType]=EmptySchema, output_schema: Type[BlockSchemaOutputType]=EmptySchema, test_input: BlockInput | list[BlockInput] | None=None, test_output: BlockData | list[BlockData] | None=None, test_mock: dict[str, Any] | None=None, test_credentials: Optional[Credentials]=None, disabled: bool=False, static_output: bool=False, block_type: BlockType=BlockType.STANDARD, webhook_config: Optional[BlockWebhookConfig | BlockManualWebhookConfig]=None):\n        \"\"\"\n        Initialize the block with the given schema.\n\n        Args:\n            id: The unique identifier for the block, this value will be persisted in the\n                DB. So it should be a unique and constant across the application run.\n                Use the UUID format for the ID.\n            description: The description of the block, explaining what the block does.\n            contributors: The list of contributors who contributed to the block.\n            input_schema: The schema, defined as a Pydantic model, for the input data.\n            output_schema: The schema, defined as a Pydantic model, for the output data.\n            test_input: The list or single sample input data for the block, for testing.\n            test_output: The list or single expected output if the test_input is run.\n            test_mock: function names on the block implementation to mock on test run.\n            disabled: If the block is disabled, it will not be available for execution.\n            static_output: Whether the output links of the block are static by default.\n        \"\"\"\n        self.id = id\n        self.input_schema = input_schema\n        self.output_schema = output_schema\n        self.test_input = test_input\n        self.test_output = test_output\n        self.test_mock = test_mock\n        self.test_credentials = test_credentials\n        self.description = description\n        self.categories = categories or set()\n        self.contributors = contributors or set()\n        self.disabled = disabled\n        self.static_output = static_output\n        self.block_type = block_type\n        self.webhook_config = webhook_config\n        self.execution_stats = {}\n        if self.webhook_config:\n            if isinstance(self.webhook_config, BlockWebhookConfig):\n                if CREDENTIALS_FIELD_NAME not in self.input_schema.model_fields:\n                    raise TypeError('credentials field is required on auto-setup webhook blocks')\n                self.block_type = BlockType.WEBHOOK\n            else:\n                self.block_type = BlockType.WEBHOOK_MANUAL\n            if self.webhook_config.event_filter_input:\n                event_filter_field = self.input_schema.model_fields[self.webhook_config.event_filter_input]\n                if not (isinstance(event_filter_field.annotation, type) and issubclass(event_filter_field.annotation, BaseModel) and all((field.annotation is bool for field in event_filter_field.annotation.model_fields.values()))):\n                    raise NotImplementedError(f'{self.name} has an invalid webhook event selector: field must be a BaseModel and all its fields must be boolean')\n            if 'payload' not in self.input_schema.model_fields:\n                raise TypeError(f\"{self.name} is webhook-triggered but has no 'payload' input\")\n            if not app_config.platform_base_url:\n                self.disabled = True\n\n    @classmethod\n    def create(cls: Type['Block']) -> 'Block':\n        return cls()\n\n    @abstractmethod\n    def run(self, input_data: BlockSchemaInputType, **kwargs) -> BlockOutput:\n        \"\"\"\n        Run the block with the given input data.\n        Args:\n            input_data: The input data with the structure of input_schema.\n        Returns:\n            A Generator that yields (output_name, output_data).\n            output_name: One of the output name defined in Block's output_schema.\n            output_data: The data for the output_name, matching the defined schema.\n        \"\"\"\n        pass\n\n    def run_once(self, input_data: BlockSchemaInputType, output: str, **kwargs) -> Any:\n        for (name, data) in self.run(input_data, **kwargs):\n            if name == output:\n                return data\n        raise ValueError(f'{self.name} did not produce any output for {output}')\n\n    def merge_stats(self, stats: dict[str, Any]) -> dict[str, Any]:\n        for (key, value) in stats.items():\n            if isinstance(value, dict):\n                self.execution_stats.setdefault(key, {}).update(value)\n            elif isinstance(value, (int, float)):\n                self.execution_stats.setdefault(key, 0)\n                self.execution_stats[key] += value\n            elif isinstance(value, list):\n                self.execution_stats.setdefault(key, [])\n                self.execution_stats[key].extend(value)\n            else:\n                self.execution_stats[key] = value\n        return self.execution_stats\n\n    @property\n    def name(self):\n        return self.__class__.__name__\n\n    def to_dict(self):\n        return {'id': self.id, 'name': self.name, 'inputSchema': self.input_schema.jsonschema(), 'outputSchema': self.output_schema.jsonschema(), 'description': self.description, 'categories': [category.dict() for category in self.categories], 'contributors': [contributor.model_dump() for contributor in self.contributors], 'staticOutput': self.static_output, 'uiType': self.block_type.value}\n\n    def execute(self, input_data: BlockInput, **kwargs) -> BlockOutput:\n        if (error := self.input_schema.validate_data(input_data)):\n            raise ValueError(f'Unable to execute block with invalid input data: {error}')\n        for (output_name, output_data) in self.run(self.input_schema(**input_data), **kwargs):\n            if output_name == 'error':\n                raise RuntimeError(output_data)\n            if self.block_type == BlockType.STANDARD and (error := self.output_schema.validate_field(output_name, output_data)):\n                raise ValueError(f'Block produced an invalid output data: {error}')\n            yield (output_name, output_data)",
                "def __init__(self, id: str='', description: str='', contributors: list[ContributorDetails]=[], categories: set[BlockCategory] | None=None, input_schema: Type[BlockSchemaInputType]=EmptySchema, output_schema: Type[BlockSchemaOutputType]=EmptySchema, test_input: BlockInput | list[BlockInput] | None=None, test_output: BlockData | list[BlockData] | None=None, test_mock: dict[str, Any] | None=None, test_credentials: Optional[Credentials]=None, disabled: bool=False, static_output: bool=False, block_type: BlockType=BlockType.STANDARD, webhook_config: Optional[BlockWebhookConfig | BlockManualWebhookConfig]=None):\n    \"\"\"\n        Initialize the block with the given schema.\n\n        Args:\n            id: The unique identifier for the block, this value will be persisted in the\n                DB. So it should be a unique and constant across the application run.\n                Use the UUID format for the ID.\n            description: The description of the block, explaining what the block does.\n            contributors: The list of contributors who contributed to the block.\n            input_schema: The schema, defined as a Pydantic model, for the input data.\n            output_schema: The schema, defined as a Pydantic model, for the output data.\n            test_input: The list or single sample input data for the block, for testing.\n            test_output: The list or single expected output if the test_input is run.\n            test_mock: function names on the block implementation to mock on test run.\n            disabled: If the block is disabled, it will not be available for execution.\n            static_output: Whether the output links of the block are static by default.\n        \"\"\"\n    self.id = id\n    self.input_schema = input_schema\n    self.output_schema = output_schema\n    self.test_input = test_input\n    self.test_output = test_output\n    self.test_mock = test_mock\n    self.test_credentials = test_credentials\n    self.description = description\n    self.categories = categories or set()\n    self.contributors = contributors or set()\n    self.disabled = disabled\n    self.static_output = static_output\n    self.block_type = block_type\n    self.webhook_config = webhook_config\n    self.execution_stats = {}\n    if self.webhook_config:\n        if isinstance(self.webhook_config, BlockWebhookConfig):\n            if CREDENTIALS_FIELD_NAME not in self.input_schema.model_fields:\n                raise TypeError('credentials field is required on auto-setup webhook blocks')\n            self.block_type = BlockType.WEBHOOK\n        else:\n            self.block_type = BlockType.WEBHOOK_MANUAL\n        if self.webhook_config.event_filter_input:\n            event_filter_field = self.input_schema.model_fields[self.webhook_config.event_filter_input]\n            if not (isinstance(event_filter_field.annotation, type) and issubclass(event_filter_field.annotation, BaseModel) and all((field.annotation is bool for field in event_filter_field.annotation.model_fields.values()))):\n                raise NotImplementedError(f'{self.name} has an invalid webhook event selector: field must be a BaseModel and all its fields must be boolean')\n        if 'payload' not in self.input_schema.model_fields:\n            raise TypeError(f\"{self.name} is webhook-triggered but has no 'payload' input\")\n        if not app_config.platform_base_url:\n            self.disabled = True",
                "'\\n        Initialize the block with the given schema.\\n\\n        Args:\\n            id: The unique identifier for the block, this value will be persisted in the\\n                DB. So it should be a unique and constant across the application run.\\n                Use the UUID format for the ID.\\n            description: The description of the block, explaining what the block does.\\n            contributors: The list of contributors who contributed to the block.\\n            input_schema: The schema, defined as a Pydantic model, for the input data.\\n            output_schema: The schema, defined as a Pydantic model, for the output data.\\n            test_input: The list or single sample input data for the block, for testing.\\n            test_output: The list or single expected output if the test_input is run.\\n            test_mock: function names on the block implementation to mock on test run.\\n            disabled: If the block is disabled, it will not be available for execution.\\n            static_output: Whether the output links of the block are static by default.\\n        '",
                "self.id = id",
                "self.input_schema = input_schema",
                "self.output_schema = output_schema",
                "self.test_input = test_input",
                "self.test_output = test_output",
                "self.test_mock = test_mock",
                "self.test_credentials = test_credentials",
                "self.description = description",
                "self.categories = categories or set()",
                "self.contributors = contributors or set()",
                "self.disabled = disabled",
                "self.static_output = static_output",
                "self.block_type = block_type",
                "self.webhook_config = webhook_config",
                "self.execution_stats = {}",
                "self.webhook_config"
            ]
        },
        {
            "id": "46",
            "type": "block",
            "statements": [
                "isinstance(self.webhook_config, BlockWebhookConfig)"
            ]
        },
        {
            "id": "47",
            "type": "block",
            "statements": []
        },
        {
            "id": "48",
            "type": "block",
            "statements": [
                "@classmethod\ndef create(cls: Type['Block']) -> 'Block':\n    return cls()",
                "return cls()"
            ]
        },
        {
            "id": "49",
            "type": "block",
            "statements": [
                "CREDENTIALS_FIELD_NAME NotIn self.input_schema.model_fields"
            ]
        },
        {
            "id": "50",
            "type": "block",
            "statements": [
                "self.block_type = BlockType.WEBHOOK_MANUAL"
            ]
        },
        {
            "id": "51",
            "type": "block",
            "statements": [
                "self.webhook_config.event_filter_input"
            ]
        },
        {
            "id": "52",
            "type": "block",
            "statements": [
                "raise TypeError('credentials field is required on auto-setup webhook blocks')"
            ]
        },
        {
            "id": "53",
            "type": "block",
            "statements": []
        },
        {
            "id": "54",
            "type": "block",
            "statements": [
                "self.block_type = BlockType.WEBHOOK"
            ]
        },
        {
            "id": "55",
            "type": "block",
            "statements": [
                "event_filter_field = self.input_schema.model_fields[self.webhook_config.event_filter_input]",
                "not (isinstance(event_filter_field.annotation, type) and issubclass(event_filter_field.annotation, BaseModel) and all((field.annotation is bool for field in event_filter_field.annotation.model_fields.values())))"
            ]
        },
        {
            "id": "56",
            "type": "block",
            "statements": []
        },
        {
            "id": "57",
            "type": "block",
            "statements": [
                "'payload' NotIn self.input_schema.model_fields"
            ]
        },
        {
            "id": "58",
            "type": "block",
            "statements": [
                "raise NotImplementedError(f'{self.name} has an invalid webhook event selector: field must be a BaseModel and all its fields must be boolean')"
            ]
        },
        {
            "id": "59",
            "type": "block",
            "statements": []
        },
        {
            "id": "60",
            "type": "block",
            "statements": []
        },
        {
            "id": "61",
            "type": "block",
            "statements": [
                "raise TypeError(f\"{self.name} is webhook-triggered but has no 'payload' input\")"
            ]
        },
        {
            "id": "62",
            "type": "block",
            "statements": []
        },
        {
            "id": "63",
            "type": "block",
            "statements": [
                "not app_config.platform_base_url"
            ]
        },
        {
            "id": "64",
            "type": "block",
            "statements": [
                "self.disabled = True"
            ]
        },
        {
            "id": "65",
            "type": "block",
            "statements": []
        },
        {
            "id": "66",
            "type": "block",
            "statements": []
        },
        {
            "id": "67",
            "type": "block",
            "statements": [
                "@abstractmethod\ndef run(self, input_data: BlockSchemaInputType, **kwargs) -> BlockOutput:\n    \"\"\"\n        Run the block with the given input data.\n        Args:\n            input_data: The input data with the structure of input_schema.\n        Returns:\n            A Generator that yields (output_name, output_data).\n            output_name: One of the output name defined in Block's output_schema.\n            output_data: The data for the output_name, matching the defined schema.\n        \"\"\"\n    pass",
                "\"\\n        Run the block with the given input data.\\n        Args:\\n            input_data: The input data with the structure of input_schema.\\n        Returns:\\n            A Generator that yields (output_name, output_data).\\n            output_name: One of the output name defined in Block's output_schema.\\n            output_data: The data for the output_name, matching the defined schema.\\n        \"",
                "pass",
                "def run_once(self, input_data: BlockSchemaInputType, output: str, **kwargs) -> Any:\n    for (name, data) in self.run(input_data, **kwargs):\n        if name == output:\n            return data\n    raise ValueError(f'{self.name} did not produce any output for {output}')"
            ]
        },
        {
            "id": "68",
            "type": "block",
            "statements": [
                "(name, data)",
                "self.run(input_data)"
            ]
        },
        {
            "id": "69",
            "type": "block",
            "statements": [
                "name Eq output"
            ]
        },
        {
            "id": "70",
            "type": "block",
            "statements": [
                "raise ValueError(f'{self.name} did not produce any output for {output}')",
                "def merge_stats(self, stats: dict[str, Any]) -> dict[str, Any]:\n    for (key, value) in stats.items():\n        if isinstance(value, dict):\n            self.execution_stats.setdefault(key, {}).update(value)\n        elif isinstance(value, (int, float)):\n            self.execution_stats.setdefault(key, 0)\n            self.execution_stats[key] += value\n        elif isinstance(value, list):\n            self.execution_stats.setdefault(key, [])\n            self.execution_stats[key].extend(value)\n        else:\n            self.execution_stats[key] = value\n    return self.execution_stats"
            ]
        },
        {
            "id": "71",
            "type": "block",
            "statements": [
                "return data"
            ]
        },
        {
            "id": "72",
            "type": "block",
            "statements": []
        },
        {
            "id": "73",
            "type": "block",
            "statements": []
        },
        {
            "id": "74",
            "type": "block",
            "statements": [
                "(key, value)",
                "stats.items()"
            ]
        },
        {
            "id": "75",
            "type": "block",
            "statements": [
                "isinstance(value, dict)"
            ]
        },
        {
            "id": "76",
            "type": "block",
            "statements": [
                "return self.execution_stats"
            ]
        },
        {
            "id": "77",
            "type": "block",
            "statements": [
                "self.execution_stats.setdefault(key, {}).update(value)"
            ]
        },
        {
            "id": "78",
            "type": "block",
            "statements": [
                "isinstance(value, (int, float))"
            ]
        },
        {
            "id": "79",
            "type": "block",
            "statements": []
        },
        {
            "id": "80",
            "type": "block",
            "statements": [
                "self.execution_stats.setdefault(key, 0)",
                "self.execution_stats[key] += value"
            ]
        },
        {
            "id": "81",
            "type": "block",
            "statements": [
                "isinstance(value, list)"
            ]
        },
        {
            "id": "82",
            "type": "block",
            "statements": []
        },
        {
            "id": "83",
            "type": "block",
            "statements": [
                "self.execution_stats.setdefault(key, [])",
                "self.execution_stats[key].extend(value)"
            ]
        },
        {
            "id": "84",
            "type": "block",
            "statements": [
                "self.execution_stats[key] = value"
            ]
        },
        {
            "id": "85",
            "type": "block",
            "statements": []
        },
        {
            "id": "86",
            "type": "block",
            "statements": [
                "@property\ndef name(self):\n    return self.__class__.__name__",
                "return self.__class__.__name__"
            ]
        },
        {
            "id": "87",
            "type": "block",
            "statements": [
                "def to_dict(self):\n    return {'id': self.id, 'name': self.name, 'inputSchema': self.input_schema.jsonschema(), 'outputSchema': self.output_schema.jsonschema(), 'description': self.description, 'categories': [category.dict() for category in self.categories], 'contributors': [contributor.model_dump() for contributor in self.contributors], 'staticOutput': self.static_output, 'uiType': self.block_type.value}",
                "return {'id': self.id, 'name': self.name, 'inputSchema': self.input_schema.jsonschema(), 'outputSchema': self.output_schema.jsonschema(), 'description': self.description, 'categories': [category.dict() for category in self.categories], 'contributors': [contributor.model_dump() for contributor in self.contributors], 'staticOutput': self.static_output, 'uiType': self.block_type.value}"
            ]
        },
        {
            "id": "88",
            "type": "block",
            "statements": [
                "def execute(self, input_data: BlockInput, **kwargs) -> BlockOutput:\n    if (error := self.input_schema.validate_data(input_data)):\n        raise ValueError(f'Unable to execute block with invalid input data: {error}')\n    for (output_name, output_data) in self.run(self.input_schema(**input_data), **kwargs):\n        if output_name == 'error':\n            raise RuntimeError(output_data)\n        if self.block_type == BlockType.STANDARD and (error := self.output_schema.validate_field(output_name, output_data)):\n            raise ValueError(f'Block produced an invalid output data: {error}')\n        yield (output_name, output_data)",
                "(error := self.input_schema.validate_data(input_data))"
            ]
        },
        {
            "id": "89",
            "type": "block",
            "statements": [
                "raise ValueError(f'Unable to execute block with invalid input data: {error}')"
            ]
        },
        {
            "id": "90",
            "type": "block",
            "statements": []
        },
        {
            "id": "91",
            "type": "block",
            "statements": []
        },
        {
            "id": "92",
            "type": "block",
            "statements": [
                "(output_name, output_data)",
                "self.run(self.input_schema())"
            ]
        },
        {
            "id": "93",
            "type": "block",
            "statements": [
                "output_name Eq 'error'"
            ]
        },
        {
            "id": "94",
            "type": "block",
            "statements": [
                "def get_blocks() -> dict[str, Type[Block]]:\n    from backend.blocks import AVAILABLE_BLOCKS\n    return AVAILABLE_BLOCKS",
                "from backend.blocks import AVAILABLE_BLOCKS",
                "return AVAILABLE_BLOCKS"
            ]
        },
        {
            "id": "95",
            "type": "block",
            "statements": [
                "raise RuntimeError(output_data)"
            ]
        },
        {
            "id": "96",
            "type": "block",
            "statements": []
        },
        {
            "id": "97",
            "type": "block",
            "statements": [
                "self.block_type == BlockType.STANDARD and (error := self.output_schema.validate_field(output_name, output_data))"
            ]
        },
        {
            "id": "98",
            "type": "block",
            "statements": [
                "raise ValueError(f'Block produced an invalid output data: {error}')"
            ]
        },
        {
            "id": "99",
            "type": "block",
            "statements": []
        },
        {
            "id": "100",
            "type": "block",
            "statements": [
                "(yield (output_name, output_data))"
            ]
        },
        {
            "id": "101",
            "type": "block",
            "statements": [
                "async def initialize_blocks() -> None:\n    for cls in get_blocks().values():\n        block = cls()\n        existing_block = await AgentBlock.prisma().find_first(where={'OR': [{'id': block.id}, {'name': block.name}]})\n        if not existing_block:\n            await AgentBlock.prisma().create(data={'id': block.id, 'name': block.name, 'inputSchema': json.dumps(block.input_schema.jsonschema()), 'outputSchema': json.dumps(block.output_schema.jsonschema())})\n            continue\n        input_schema = json.dumps(block.input_schema.jsonschema())\n        output_schema = json.dumps(block.output_schema.jsonschema())\n        if block.id != existing_block.id or block.name != existing_block.name or input_schema != existing_block.inputSchema or (output_schema != existing_block.outputSchema):\n            await AgentBlock.prisma().update(where={'id': existing_block.id}, data={'id': block.id, 'name': block.name, 'inputSchema': input_schema, 'outputSchema': output_schema})"
            ]
        },
        {
            "id": "102",
            "type": "block",
            "statements": [
                "cls",
                "get_blocks().values()"
            ]
        },
        {
            "id": "103",
            "type": "block",
            "statements": [
                "block = cls()",
                "existing_block = await AgentBlock.prisma().find_first(where={'OR': [{'id': block.id}, {'name': block.name}]})",
                "not existing_block"
            ]
        },
        {
            "id": "104",
            "type": "block",
            "statements": [
                "def get_block(block_id: str) -> Block | None:\n    cls = get_blocks().get(block_id)\n    return cls() if cls else None",
                "cls = get_blocks().get(block_id)",
                "return cls() if cls else None"
            ]
        },
        {
            "id": "105",
            "type": "block",
            "statements": [
                "await AgentBlock.prisma().create(data={'id': block.id, 'name': block.name, 'inputSchema': json.dumps(block.input_schema.jsonschema()), 'outputSchema': json.dumps(block.output_schema.jsonschema())})",
                "continue"
            ]
        },
        {
            "id": "106",
            "type": "block",
            "statements": []
        },
        {
            "id": "107",
            "type": "block",
            "statements": [
                "input_schema = json.dumps(block.input_schema.jsonschema())",
                "output_schema = json.dumps(block.output_schema.jsonschema())",
                "block.id != existing_block.id or block.name != existing_block.name or input_schema != existing_block.inputSchema or (output_schema != existing_block.outputSchema)"
            ]
        },
        {
            "id": "108",
            "type": "block",
            "statements": [
                "await AgentBlock.prisma().update(where={'id': existing_block.id}, data={'id': block.id, 'name': block.name, 'inputSchema': input_schema, 'outputSchema': output_schema})"
            ]
        },
        {
            "id": "109",
            "type": "block",
            "statements": []
        },
        {
            "id": "110",
            "type": "block",
            "statements": []
        }
    ],
    "edges": [
        {
            "source": "2",
            "target": "3",
            "type": "true"
        },
        {
            "source": "2",
            "target": "4",
            "type": "false"
        },
        {
            "source": "4",
            "target": "5",
            "type": "next"
        },
        {
            "source": "5",
            "target": "6",
            "type": "true"
        },
        {
            "source": "5",
            "target": "7",
            "type": "false"
        },
        {
            "source": "6",
            "target": "9",
            "type": "true"
        },
        {
            "source": "6",
            "target": "10",
            "type": "false"
        },
        {
            "source": "7",
            "target": "12",
            "type": "true"
        },
        {
            "source": "7",
            "target": "13",
            "type": "false"
        },
        {
            "source": "9",
            "target": "11",
            "type": "next"
        },
        {
            "source": "10",
            "target": "11",
            "type": "next"
        },
        {
            "source": "13",
            "target": "14",
            "type": "next"
        },
        {
            "source": "14",
            "target": "8",
            "type": "next"
        },
        {
            "source": "15",
            "target": "16",
            "type": "next"
        },
        {
            "source": "16",
            "target": "17",
            "type": "true"
        },
        {
            "source": "16",
            "target": "18",
            "type": "false"
        },
        {
            "source": "17",
            "target": "19",
            "type": "true"
        },
        {
            "source": "17",
            "target": "20",
            "type": "false"
        },
        {
            "source": "19",
            "target": "21",
            "type": "next"
        },
        {
            "source": "20",
            "target": "21",
            "type": "next"
        },
        {
            "source": "21",
            "target": "16",
            "type": "next"
        },
        {
            "source": "23",
            "target": "24",
            "type": "true"
        },
        {
            "source": "23",
            "target": "25",
            "type": "false"
        },
        {
            "source": "25",
            "target": "26",
            "type": "next"
        },
        {
            "source": "26",
            "target": "27",
            "type": "true"
        },
        {
            "source": "26",
            "target": "28",
            "type": "false"
        },
        {
            "source": "28",
            "target": "29",
            "type": "next"
        },
        {
            "source": "33",
            "target": "34",
            "type": "true"
        },
        {
            "source": "33",
            "target": "35",
            "type": "false"
        },
        {
            "source": "34",
            "target": "36",
            "type": "next"
        },
        {
            "source": "35",
            "target": "37",
            "type": "true"
        },
        {
            "source": "35",
            "target": "38",
            "type": "false"
        },
        {
            "source": "36",
            "target": "43",
            "type": "true"
        },
        {
            "source": "36",
            "target": "44",
            "type": "false"
        },
        {
            "source": "37",
            "target": "39",
            "type": "next"
        },
        {
            "source": "38",
            "target": "40",
            "type": "true"
        },
        {
            "source": "38",
            "target": "41",
            "type": "false"
        },
        {
            "source": "39",
            "target": "36",
            "type": "next"
        },
        {
            "source": "40",
            "target": "42",
            "type": "next"
        },
        {
            "source": "41",
            "target": "42",
            "type": "next"
        },
        {
            "source": "42",
            "target": "39",
            "type": "next"
        },
        {
            "source": "43",
            "target": "45",
            "type": "next"
        },
        {
            "source": "44",
            "target": "45",
            "type": "next"
        },
        {
            "source": "45",
            "target": "46",
            "type": "true"
        },
        {
            "source": "45",
            "target": "47",
            "type": "false"
        },
        {
            "source": "46",
            "target": "49",
            "type": "true"
        },
        {
            "source": "46",
            "target": "50",
            "type": "false"
        },
        {
            "source": "47",
            "target": "48",
            "type": "next"
        },
        {
            "source": "49",
            "target": "52",
            "type": "true"
        },
        {
            "source": "49",
            "target": "53",
            "type": "false"
        },
        {
            "source": "50",
            "target": "51",
            "type": "next"
        },
        {
            "source": "51",
            "target": "55",
            "type": "true"
        },
        {
            "source": "51",
            "target": "56",
            "type": "false"
        },
        {
            "source": "52",
            "target": "54",
            "type": "next"
        },
        {
            "source": "53",
            "target": "54",
            "type": "next"
        },
        {
            "source": "54",
            "target": "51",
            "type": "next"
        },
        {
            "source": "55",
            "target": "58",
            "type": "true"
        },
        {
            "source": "55",
            "target": "59",
            "type": "false"
        },
        {
            "source": "56",
            "target": "57",
            "type": "next"
        },
        {
            "source": "57",
            "target": "61",
            "type": "true"
        },
        {
            "source": "57",
            "target": "62",
            "type": "false"
        },
        {
            "source": "58",
            "target": "60",
            "type": "next"
        },
        {
            "source": "59",
            "target": "60",
            "type": "next"
        },
        {
            "source": "60",
            "target": "57",
            "type": "next"
        },
        {
            "source": "61",
            "target": "63",
            "type": "next"
        },
        {
            "source": "62",
            "target": "63",
            "type": "next"
        },
        {
            "source": "63",
            "target": "64",
            "type": "true"
        },
        {
            "source": "63",
            "target": "65",
            "type": "false"
        },
        {
            "source": "64",
            "target": "66",
            "type": "next"
        },
        {
            "source": "65",
            "target": "66",
            "type": "next"
        },
        {
            "source": "66",
            "target": "48",
            "type": "next"
        },
        {
            "source": "67",
            "target": "68",
            "type": "next"
        },
        {
            "source": "68",
            "target": "69",
            "type": "true"
        },
        {
            "source": "68",
            "target": "70",
            "type": "false"
        },
        {
            "source": "69",
            "target": "71",
            "type": "true"
        },
        {
            "source": "69",
            "target": "72",
            "type": "false"
        },
        {
            "source": "70",
            "target": "74",
            "type": "next"
        },
        {
            "source": "72",
            "target": "73",
            "type": "next"
        },
        {
            "source": "73",
            "target": "68",
            "type": "next"
        },
        {
            "source": "74",
            "target": "75",
            "type": "true"
        },
        {
            "source": "74",
            "target": "76",
            "type": "false"
        },
        {
            "source": "75",
            "target": "77",
            "type": "true"
        },
        {
            "source": "75",
            "target": "78",
            "type": "false"
        },
        {
            "source": "77",
            "target": "79",
            "type": "next"
        },
        {
            "source": "78",
            "target": "80",
            "type": "true"
        },
        {
            "source": "78",
            "target": "81",
            "type": "false"
        },
        {
            "source": "79",
            "target": "74",
            "type": "next"
        },
        {
            "source": "80",
            "target": "82",
            "type": "next"
        },
        {
            "source": "81",
            "target": "83",
            "type": "true"
        },
        {
            "source": "81",
            "target": "84",
            "type": "false"
        },
        {
            "source": "82",
            "target": "79",
            "type": "next"
        },
        {
            "source": "83",
            "target": "85",
            "type": "next"
        },
        {
            "source": "84",
            "target": "85",
            "type": "next"
        },
        {
            "source": "85",
            "target": "82",
            "type": "next"
        },
        {
            "source": "88",
            "target": "89",
            "type": "true"
        },
        {
            "source": "88",
            "target": "90",
            "type": "false"
        },
        {
            "source": "89",
            "target": "91",
            "type": "next"
        },
        {
            "source": "90",
            "target": "91",
            "type": "next"
        },
        {
            "source": "91",
            "target": "92",
            "type": "next"
        },
        {
            "source": "92",
            "target": "93",
            "type": "true"
        },
        {
            "source": "92",
            "target": "94",
            "type": "false"
        },
        {
            "source": "93",
            "target": "95",
            "type": "true"
        },
        {
            "source": "93",
            "target": "96",
            "type": "false"
        },
        {
            "source": "95",
            "target": "97",
            "type": "next"
        },
        {
            "source": "96",
            "target": "97",
            "type": "next"
        },
        {
            "source": "97",
            "target": "98",
            "type": "true"
        },
        {
            "source": "97",
            "target": "99",
            "type": "false"
        },
        {
            "source": "98",
            "target": "100",
            "type": "next"
        },
        {
            "source": "99",
            "target": "100",
            "type": "next"
        },
        {
            "source": "100",
            "target": "92",
            "type": "next"
        },
        {
            "source": "101",
            "target": "102",
            "type": "next"
        },
        {
            "source": "102",
            "target": "103",
            "type": "true"
        },
        {
            "source": "102",
            "target": "104",
            "type": "false"
        },
        {
            "source": "103",
            "target": "105",
            "type": "true"
        },
        {
            "source": "103",
            "target": "106",
            "type": "false"
        },
        {
            "source": "105",
            "target": "107",
            "type": "next"
        },
        {
            "source": "106",
            "target": "107",
            "type": "next"
        },
        {
            "source": "107",
            "target": "108",
            "type": "true"
        },
        {
            "source": "107",
            "target": "109",
            "type": "false"
        },
        {
            "source": "108",
            "target": "110",
            "type": "next"
        },
        {
            "source": "109",
            "target": "110",
            "type": "next"
        },
        {
            "source": "110",
            "target": "102",
            "type": "next"
        }
    ]
}