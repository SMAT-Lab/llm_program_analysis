{
    "nodes": [
        {
            "id": "1",
            "type": "block",
            "statements": [
                "from contextlib import contextmanager",
                "from threading import Lock",
                "from typing import TYPE_CHECKING, Any",
                "from expiringdict import ExpiringDict",
                "TYPE_CHECKING"
            ]
        },
        {
            "id": "2",
            "type": "block",
            "statements": [
                "from redis import Redis",
                "from redis.lock import Lock as RedisLock"
            ]
        },
        {
            "id": "3",
            "type": "block",
            "statements": []
        },
        {
            "id": "4",
            "type": "block",
            "statements": [
                "class RedisKeyedMutex:\n    \"\"\"\n    This class provides a mutex that can be locked and unlocked by a specific key,\n    using Redis as a distributed locking provider.\n    It uses an ExpiringDict to automatically clear the mutex after a specified timeout,\n    in case the key is not unlocked for a specified duration, to prevent memory leaks.\n    \"\"\"\n\n    def __init__(self, redis: 'Redis', timeout: int | None=60):\n        self.redis = redis\n        self.timeout = timeout\n        self.locks: dict[Any, 'RedisLock'] = ExpiringDict(max_len=6000, max_age_seconds=self.timeout)\n        self.locks_lock = Lock()\n\n    @contextmanager\n    def locked(self, key: Any):\n        lock = self.acquire(key)\n        try:\n            yield\n        finally:\n            if lock.locked():\n                lock.release()\n\n    def acquire(self, key: Any) -> 'RedisLock':\n        \"\"\"Acquires and returns a lock with the given key\"\"\"\n        with self.locks_lock:\n            if key not in self.locks:\n                self.locks[key] = self.redis.lock(str(key), self.timeout, thread_local=False)\n            lock = self.locks[key]\n        lock.acquire()\n        return lock\n\n    def release(self, key: Any):\n        if (lock := self.locks.get(key)) and lock.locked() and lock.owned():\n            lock.release()\n\n    def release_all_locks(self):\n        \"\"\"Call this on process termination to ensure all locks are released\"\"\"\n        self.locks_lock.acquire(blocking=False)\n        for lock in self.locks.values():\n            if lock.locked() and lock.owned():\n                lock.release()",
                "'\\n    This class provides a mutex that can be locked and unlocked by a specific key,\\n    using Redis as a distributed locking provider.\\n    It uses an ExpiringDict to automatically clear the mutex after a specified timeout,\\n    in case the key is not unlocked for a specified duration, to prevent memory leaks.\\n    '",
                "def __init__(self, redis: 'Redis', timeout: int | None=60):\n    self.redis = redis\n    self.timeout = timeout\n    self.locks: dict[Any, 'RedisLock'] = ExpiringDict(max_len=6000, max_age_seconds=self.timeout)\n    self.locks_lock = Lock()",
                "self.redis = redis",
                "self.timeout = timeout",
                "self.locks: dict[Any, 'RedisLock'] = ExpiringDict(max_len=6000, max_age_seconds=self.timeout)",
                "self.locks_lock = Lock()",
                "@contextmanager\ndef locked(self, key: Any):\n    lock = self.acquire(key)\n    try:\n        yield\n    finally:\n        if lock.locked():\n            lock.release()",
                "lock = self.acquire(key)",
                "try:\n    yield\nfinally:\n    if lock.locked():\n        lock.release()",
                "(yield)",
                "lock.locked()"
            ]
        },
        {
            "id": "5",
            "type": "block",
            "statements": [
                "lock.release()"
            ]
        },
        {
            "id": "6",
            "type": "block",
            "statements": []
        },
        {
            "id": "7",
            "type": "block",
            "statements": [
                "def acquire(self, key: Any) -> 'RedisLock':\n    \"\"\"Acquires and returns a lock with the given key\"\"\"\n    with self.locks_lock:\n        if key not in self.locks:\n            self.locks[key] = self.redis.lock(str(key), self.timeout, thread_local=False)\n        lock = self.locks[key]\n    lock.acquire()\n    return lock",
                "'Acquires and returns a lock with the given key'",
                "with self.locks_lock:\n    if key not in self.locks:\n        self.locks[key] = self.redis.lock(str(key), self.timeout, thread_local=False)\n    lock = self.locks[key]",
                "key NotIn self.locks"
            ]
        },
        {
            "id": "8",
            "type": "block",
            "statements": [
                "self.locks[key] = self.redis.lock(str(key), self.timeout, thread_local=False)"
            ]
        },
        {
            "id": "9",
            "type": "block",
            "statements": []
        },
        {
            "id": "10",
            "type": "block",
            "statements": [
                "lock = self.locks[key]",
                "lock.acquire()",
                "return lock"
            ]
        },
        {
            "id": "11",
            "type": "block",
            "statements": [
                "def release(self, key: Any):\n    if (lock := self.locks.get(key)) and lock.locked() and lock.owned():\n        lock.release()",
                "(lock := self.locks.get(key)) and lock.locked() and lock.owned()"
            ]
        },
        {
            "id": "12",
            "type": "block",
            "statements": [
                "lock.release()"
            ]
        },
        {
            "id": "13",
            "type": "block",
            "statements": []
        },
        {
            "id": "14",
            "type": "block",
            "statements": [
                "def release_all_locks(self):\n    \"\"\"Call this on process termination to ensure all locks are released\"\"\"\n    self.locks_lock.acquire(blocking=False)\n    for lock in self.locks.values():\n        if lock.locked() and lock.owned():\n            lock.release()",
                "'Call this on process termination to ensure all locks are released'",
                "self.locks_lock.acquire()"
            ]
        },
        {
            "id": "15",
            "type": "block",
            "statements": [
                "lock",
                "self.locks.values()"
            ]
        },
        {
            "id": "16",
            "type": "block",
            "statements": [
                "lock.locked() and lock.owned()"
            ]
        },
        {
            "id": "17",
            "type": "block",
            "statements": []
        },
        {
            "id": "18",
            "type": "block",
            "statements": [
                "lock.release()"
            ]
        },
        {
            "id": "19",
            "type": "block",
            "statements": []
        },
        {
            "id": "20",
            "type": "block",
            "statements": []
        }
    ],
    "edges": [
        {
            "source": "1",
            "target": "2",
            "type": "true"
        },
        {
            "source": "1",
            "target": "3",
            "type": "false"
        },
        {
            "source": "2",
            "target": "4",
            "type": "next"
        },
        {
            "source": "3",
            "target": "4",
            "type": "next"
        },
        {
            "source": "4",
            "target": "5",
            "type": "true"
        },
        {
            "source": "4",
            "target": "6",
            "type": "false"
        },
        {
            "source": "5",
            "target": "7",
            "type": "next"
        },
        {
            "source": "6",
            "target": "7",
            "type": "next"
        },
        {
            "source": "7",
            "target": "8",
            "type": "true"
        },
        {
            "source": "7",
            "target": "9",
            "type": "false"
        },
        {
            "source": "8",
            "target": "10",
            "type": "next"
        },
        {
            "source": "9",
            "target": "10",
            "type": "next"
        },
        {
            "source": "11",
            "target": "12",
            "type": "true"
        },
        {
            "source": "11",
            "target": "13",
            "type": "false"
        },
        {
            "source": "12",
            "target": "14",
            "type": "next"
        },
        {
            "source": "13",
            "target": "14",
            "type": "next"
        },
        {
            "source": "14",
            "target": "15",
            "type": "next"
        },
        {
            "source": "15",
            "target": "16",
            "type": "true"
        },
        {
            "source": "15",
            "target": "17",
            "type": "false"
        },
        {
            "source": "16",
            "target": "18",
            "type": "true"
        },
        {
            "source": "16",
            "target": "19",
            "type": "false"
        },
        {
            "source": "18",
            "target": "20",
            "type": "next"
        },
        {
            "source": "19",
            "target": "20",
            "type": "next"
        },
        {
            "source": "20",
            "target": "15",
            "type": "next"
        }
    ]
}