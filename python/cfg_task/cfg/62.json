{
    "nodes": [
        {
            "id": "1",
            "type": "block",
            "statements": [
                "from urllib.parse import parse_qs, urlparse",
                "from youtube_transcript_api import YouTubeTranscriptApi",
                "from youtube_transcript_api.formatters import TextFormatter",
                "from backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema",
                "from backend.data.model import SchemaField",
                "class TranscribeYoutubeVideoBlock(Block):\n\n    class Input(BlockSchema):\n        youtube_url: str = SchemaField(title='YouTube URL', description='The URL of the YouTube video to transcribe', placeholder='https://www.youtube.com/watch?v=dQw4w9WgXcQ')\n\n    class Output(BlockSchema):\n        video_id: str = SchemaField(description='The extracted YouTube video ID')\n        transcript: str = SchemaField(description='The transcribed text of the video')\n        error: str = SchemaField(description='Any error message if the transcription fails')\n\n    def __init__(self):\n        super().__init__(id='f3a8f7e1-4b1d-4e5f-9f2a-7c3d5a2e6b4c', input_schema=TranscribeYoutubeVideoBlock.Input, output_schema=TranscribeYoutubeVideoBlock.Output, description='Transcribes a YouTube video.', categories={BlockCategory.SOCIAL}, test_input={'youtube_url': 'https://www.youtube.com/watch?v=dQw4w9WgXcQ'}, test_output=[('video_id', 'dQw4w9WgXcQ'), ('transcript', 'Never gonna give you up\\nNever gonna let you down')], test_mock={'get_transcript': lambda video_id: [{'text': 'Never gonna give you up'}, {'text': 'Never gonna let you down'}]})\n\n    @staticmethod\n    def extract_video_id(url: str) -> str:\n        parsed_url = urlparse(url)\n        if parsed_url.netloc == 'youtu.be':\n            return parsed_url.path[1:]\n        if parsed_url.netloc in ('www.youtube.com', 'youtube.com'):\n            if parsed_url.path == '/watch':\n                p = parse_qs(parsed_url.query)\n                return p['v'][0]\n            if parsed_url.path[:7] == '/embed/':\n                return parsed_url.path.split('/')[2]\n            if parsed_url.path[:3] == '/v/':\n                return parsed_url.path.split('/')[2]\n        raise ValueError(f'Invalid YouTube URL: {url}')\n\n    @staticmethod\n    def get_transcript(video_id: str):\n        try:\n            transcript_list = YouTubeTranscriptApi.list_transcripts(video_id)\n            if not transcript_list:\n                raise ValueError(f'No transcripts found for the video: {video_id}')\n            for transcript in transcript_list:\n                first_transcript = transcript_list.find_transcript([transcript.language_code])\n                return YouTubeTranscriptApi.get_transcript(video_id, languages=[first_transcript.language_code])\n        except Exception:\n            raise ValueError(f'No transcripts found for the video: {video_id}')\n\n    def run(self, input_data: Input, **kwargs) -> BlockOutput:\n        video_id = self.extract_video_id(input_data.youtube_url)\n        yield ('video_id', video_id)\n        transcript = self.get_transcript(video_id)\n        formatter = TextFormatter()\n        transcript_text = formatter.format_transcript(transcript)\n        yield ('transcript', transcript_text)",
                "class Input(BlockSchema):\n    youtube_url: str = SchemaField(title='YouTube URL', description='The URL of the YouTube video to transcribe', placeholder='https://www.youtube.com/watch?v=dQw4w9WgXcQ')",
                "youtube_url: str = SchemaField(title='YouTube URL', description='The URL of the YouTube video to transcribe', placeholder='https://www.youtube.com/watch?v=dQw4w9WgXcQ')",
                "class Output(BlockSchema):\n    video_id: str = SchemaField(description='The extracted YouTube video ID')\n    transcript: str = SchemaField(description='The transcribed text of the video')\n    error: str = SchemaField(description='Any error message if the transcription fails')",
                "video_id: str = SchemaField(description='The extracted YouTube video ID')",
                "transcript: str = SchemaField(description='The transcribed text of the video')",
                "error: str = SchemaField(description='Any error message if the transcription fails')",
                "def __init__(self):\n    super().__init__(id='f3a8f7e1-4b1d-4e5f-9f2a-7c3d5a2e6b4c', input_schema=TranscribeYoutubeVideoBlock.Input, output_schema=TranscribeYoutubeVideoBlock.Output, description='Transcribes a YouTube video.', categories={BlockCategory.SOCIAL}, test_input={'youtube_url': 'https://www.youtube.com/watch?v=dQw4w9WgXcQ'}, test_output=[('video_id', 'dQw4w9WgXcQ'), ('transcript', 'Never gonna give you up\\nNever gonna let you down')], test_mock={'get_transcript': lambda video_id: [{'text': 'Never gonna give you up'}, {'text': 'Never gonna let you down'}]})",
                "super().__init__()",
                "@staticmethod\ndef extract_video_id(url: str) -> str:\n    parsed_url = urlparse(url)\n    if parsed_url.netloc == 'youtu.be':\n        return parsed_url.path[1:]\n    if parsed_url.netloc in ('www.youtube.com', 'youtube.com'):\n        if parsed_url.path == '/watch':\n            p = parse_qs(parsed_url.query)\n            return p['v'][0]\n        if parsed_url.path[:7] == '/embed/':\n            return parsed_url.path.split('/')[2]\n        if parsed_url.path[:3] == '/v/':\n            return parsed_url.path.split('/')[2]\n    raise ValueError(f'Invalid YouTube URL: {url}')",
                "parsed_url = urlparse(url)",
                "parsed_url.netloc Eq 'youtu.be'"
            ]
        },
        {
            "id": "2",
            "type": "block",
            "statements": [
                "return parsed_url.path[1:]"
            ]
        },
        {
            "id": "3",
            "type": "block",
            "statements": []
        },
        {
            "id": "4",
            "type": "block",
            "statements": [
                "parsed_url.netloc In ('www.youtube.com', 'youtube.com')"
            ]
        },
        {
            "id": "5",
            "type": "block",
            "statements": [
                "parsed_url.path Eq '/watch'"
            ]
        },
        {
            "id": "6",
            "type": "block",
            "statements": []
        },
        {
            "id": "7",
            "type": "block",
            "statements": [
                "raise ValueError(f'Invalid YouTube URL: {url}')",
                "@staticmethod\ndef get_transcript(video_id: str):\n    try:\n        transcript_list = YouTubeTranscriptApi.list_transcripts(video_id)\n        if not transcript_list:\n            raise ValueError(f'No transcripts found for the video: {video_id}')\n        for transcript in transcript_list:\n            first_transcript = transcript_list.find_transcript([transcript.language_code])\n            return YouTubeTranscriptApi.get_transcript(video_id, languages=[first_transcript.language_code])\n    except Exception:\n        raise ValueError(f'No transcripts found for the video: {video_id}')",
                "try:\n    transcript_list = YouTubeTranscriptApi.list_transcripts(video_id)\n    if not transcript_list:\n        raise ValueError(f'No transcripts found for the video: {video_id}')\n    for transcript in transcript_list:\n        first_transcript = transcript_list.find_transcript([transcript.language_code])\n        return YouTubeTranscriptApi.get_transcript(video_id, languages=[first_transcript.language_code])\nexcept Exception:\n    raise ValueError(f'No transcripts found for the video: {video_id}')",
                "transcript_list = YouTubeTranscriptApi.list_transcripts(video_id)",
                "not transcript_list"
            ]
        },
        {
            "id": "8",
            "type": "block",
            "statements": [
                "p = parse_qs(parsed_url.query)",
                "return p['v'][0]"
            ]
        },
        {
            "id": "9",
            "type": "block",
            "statements": []
        },
        {
            "id": "10",
            "type": "block",
            "statements": [
                "parsed_url.path[:7] Eq '/embed/'"
            ]
        },
        {
            "id": "11",
            "type": "block",
            "statements": [
                "return parsed_url.path.split('/')[2]"
            ]
        },
        {
            "id": "12",
            "type": "block",
            "statements": []
        },
        {
            "id": "13",
            "type": "block",
            "statements": [
                "parsed_url.path[:3] Eq '/v/'"
            ]
        },
        {
            "id": "14",
            "type": "block",
            "statements": [
                "return parsed_url.path.split('/')[2]"
            ]
        },
        {
            "id": "15",
            "type": "block",
            "statements": []
        },
        {
            "id": "16",
            "type": "block",
            "statements": []
        },
        {
            "id": "17",
            "type": "block",
            "statements": [
                "raise ValueError(f'No transcripts found for the video: {video_id}')"
            ]
        },
        {
            "id": "18",
            "type": "block",
            "statements": []
        },
        {
            "id": "19",
            "type": "block",
            "statements": []
        },
        {
            "id": "20",
            "type": "block",
            "statements": [
                "transcript",
                "transcript_list"
            ]
        },
        {
            "id": "21",
            "type": "block",
            "statements": [
                "first_transcript = transcript_list.find_transcript([transcript.language_code])",
                "return YouTubeTranscriptApi.get_transcript(video_id, languages=[first_transcript.language_code])"
            ]
        },
        {
            "id": "22",
            "type": "block",
            "statements": [
                "raise ValueError(f'No transcripts found for the video: {video_id}')",
                "def run(self, input_data: Input, **kwargs) -> BlockOutput:\n    video_id = self.extract_video_id(input_data.youtube_url)\n    yield ('video_id', video_id)\n    transcript = self.get_transcript(video_id)\n    formatter = TextFormatter()\n    transcript_text = formatter.format_transcript(transcript)\n    yield ('transcript', transcript_text)",
                "video_id = self.extract_video_id(input_data.youtube_url)",
                "(yield ('video_id', video_id))",
                "transcript = self.get_transcript(video_id)",
                "formatter = TextFormatter()",
                "transcript_text = formatter.format_transcript(transcript)",
                "(yield ('transcript', transcript_text))"
            ]
        }
    ],
    "edges": [
        {
            "source": "1",
            "target": "2",
            "type": "true"
        },
        {
            "source": "1",
            "target": "3",
            "type": "false"
        },
        {
            "source": "3",
            "target": "4",
            "type": "next"
        },
        {
            "source": "4",
            "target": "5",
            "type": "true"
        },
        {
            "source": "4",
            "target": "6",
            "type": "false"
        },
        {
            "source": "5",
            "target": "8",
            "type": "true"
        },
        {
            "source": "5",
            "target": "9",
            "type": "false"
        },
        {
            "source": "6",
            "target": "7",
            "type": "next"
        },
        {
            "source": "7",
            "target": "17",
            "type": "true"
        },
        {
            "source": "7",
            "target": "18",
            "type": "false"
        },
        {
            "source": "9",
            "target": "10",
            "type": "next"
        },
        {
            "source": "10",
            "target": "11",
            "type": "true"
        },
        {
            "source": "10",
            "target": "12",
            "type": "false"
        },
        {
            "source": "12",
            "target": "13",
            "type": "next"
        },
        {
            "source": "13",
            "target": "14",
            "type": "true"
        },
        {
            "source": "13",
            "target": "15",
            "type": "false"
        },
        {
            "source": "15",
            "target": "16",
            "type": "next"
        },
        {
            "source": "16",
            "target": "7",
            "type": "next"
        },
        {
            "source": "17",
            "target": "19",
            "type": "next"
        },
        {
            "source": "18",
            "target": "19",
            "type": "next"
        },
        {
            "source": "19",
            "target": "20",
            "type": "next"
        },
        {
            "source": "20",
            "target": "21",
            "type": "true"
        },
        {
            "source": "20",
            "target": "22",
            "type": "false"
        }
    ]
}