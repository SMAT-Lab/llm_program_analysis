{
    "nodes": [
        {
            "id": "1",
            "type": "block",
            "statements": [
                "from collections import defaultdict",
                "from datetime import datetime, timezone",
                "from multiprocessing import Manager",
                "from typing import Any, AsyncGenerator, Generator, Generic, TypeVar",
                "from prisma.enums import AgentExecutionStatus",
                "from prisma.models import AgentGraphExecution, AgentNodeExecution, AgentNodeExecutionInputOutput",
                "from pydantic import BaseModel",
                "from backend.data.block import BlockData, BlockInput, CompletedBlockOutput",
                "from backend.data.includes import EXECUTION_RESULT_INCLUDE, GRAPH_EXECUTION_INCLUDE",
                "from backend.data.queue import AsyncRedisEventBus, RedisEventBus",
                "from backend.util import json, mock",
                "from backend.util.settings import Config",
                "class GraphExecutionEntry(BaseModel):\n    user_id: str\n    graph_exec_id: str\n    graph_id: str\n    start_node_execs: list['NodeExecutionEntry']",
                "user_id: str",
                "graph_exec_id: str",
                "graph_id: str",
                "start_node_execs: list['NodeExecutionEntry']",
                "class NodeExecutionEntry(BaseModel):\n    user_id: str\n    graph_exec_id: str\n    graph_id: str\n    node_exec_id: str\n    node_id: str\n    data: BlockInput",
                "user_id: str",
                "graph_exec_id: str",
                "graph_id: str",
                "node_exec_id: str",
                "node_id: str",
                "data: BlockInput",
                "ExecutionStatus = AgentExecutionStatus",
                "T = TypeVar('T')",
                "class ExecutionQueue(Generic[T]):\n    \"\"\"\n    Queue for managing the execution of agents.\n    This will be shared between different processes\n    \"\"\"\n\n    def __init__(self):\n        self.queue = Manager().Queue()\n\n    def add(self, execution: T) -> T:\n        self.queue.put(execution)\n        return execution\n\n    def get(self) -> T:\n        return self.queue.get()\n\n    def empty(self) -> bool:\n        return self.queue.empty()",
                "'\\n    Queue for managing the execution of agents.\\n    This will be shared between different processes\\n    '",
                "def __init__(self):\n    self.queue = Manager().Queue()",
                "self.queue = Manager().Queue()",
                "def add(self, execution: T) -> T:\n    self.queue.put(execution)\n    return execution",
                "self.queue.put(execution)",
                "return execution"
            ]
        },
        {
            "id": "2",
            "type": "block",
            "statements": [
                "def get(self) -> T:\n    return self.queue.get()",
                "return self.queue.get()"
            ]
        },
        {
            "id": "3",
            "type": "block",
            "statements": [
                "def empty(self) -> bool:\n    return self.queue.empty()",
                "return self.queue.empty()"
            ]
        },
        {
            "id": "4",
            "type": "block",
            "statements": [
                "class ExecutionResult(BaseModel):\n    graph_id: str\n    graph_version: int\n    graph_exec_id: str\n    node_exec_id: str\n    node_id: str\n    block_id: str\n    status: ExecutionStatus\n    input_data: BlockInput\n    output_data: CompletedBlockOutput\n    add_time: datetime\n    queue_time: datetime | None\n    start_time: datetime | None\n    end_time: datetime | None\n\n    @staticmethod\n    def from_graph(graph: AgentGraphExecution):\n        return ExecutionResult(graph_id=graph.agentGraphId, graph_version=graph.agentGraphVersion, graph_exec_id=graph.id, node_exec_id='', node_id='', block_id='', status=graph.executionStatus, input_data={}, output_data={}, add_time=graph.createdAt, queue_time=graph.createdAt, start_time=graph.startedAt, end_time=graph.updatedAt)\n\n    @staticmethod\n    def from_db(execution: AgentNodeExecution):\n        if execution.executionData:\n            input_data = json.loads(execution.executionData, target_type=dict[str, Any])\n        else:\n            input_data: BlockInput = defaultdict()\n            for data in execution.Input or []:\n                input_data[data.name] = json.loads(data.data)\n        output_data: CompletedBlockOutput = defaultdict(list)\n        for data in execution.Output or []:\n            output_data[data.name].append(json.loads(data.data))\n        graph_execution: AgentGraphExecution | None = execution.AgentGraphExecution\n        return ExecutionResult(graph_id=graph_execution.agentGraphId if graph_execution else '', graph_version=graph_execution.agentGraphVersion if graph_execution else 0, graph_exec_id=execution.agentGraphExecutionId, block_id=execution.AgentNode.agentBlockId if execution.AgentNode else '', node_exec_id=execution.id, node_id=execution.agentNodeId, status=execution.executionStatus, input_data=input_data, output_data=output_data, add_time=execution.addedTime, queue_time=execution.queuedTime, start_time=execution.startedTime, end_time=execution.endedTime)",
                "graph_id: str",
                "graph_version: int",
                "graph_exec_id: str",
                "node_exec_id: str",
                "node_id: str",
                "block_id: str",
                "status: ExecutionStatus",
                "input_data: BlockInput",
                "output_data: CompletedBlockOutput",
                "add_time: datetime",
                "queue_time: datetime | None",
                "start_time: datetime | None",
                "end_time: datetime | None",
                "@staticmethod\ndef from_graph(graph: AgentGraphExecution):\n    return ExecutionResult(graph_id=graph.agentGraphId, graph_version=graph.agentGraphVersion, graph_exec_id=graph.id, node_exec_id='', node_id='', block_id='', status=graph.executionStatus, input_data={}, output_data={}, add_time=graph.createdAt, queue_time=graph.createdAt, start_time=graph.startedAt, end_time=graph.updatedAt)",
                "return ExecutionResult(graph_id=graph.agentGraphId, graph_version=graph.agentGraphVersion, graph_exec_id=graph.id, node_exec_id='', node_id='', block_id='', status=graph.executionStatus, input_data={}, output_data={}, add_time=graph.createdAt, queue_time=graph.createdAt, start_time=graph.startedAt, end_time=graph.updatedAt)"
            ]
        },
        {
            "id": "5",
            "type": "block",
            "statements": [
                "@staticmethod\ndef from_db(execution: AgentNodeExecution):\n    if execution.executionData:\n        input_data = json.loads(execution.executionData, target_type=dict[str, Any])\n    else:\n        input_data: BlockInput = defaultdict()\n        for data in execution.Input or []:\n            input_data[data.name] = json.loads(data.data)\n    output_data: CompletedBlockOutput = defaultdict(list)\n    for data in execution.Output or []:\n        output_data[data.name].append(json.loads(data.data))\n    graph_execution: AgentGraphExecution | None = execution.AgentGraphExecution\n    return ExecutionResult(graph_id=graph_execution.agentGraphId if graph_execution else '', graph_version=graph_execution.agentGraphVersion if graph_execution else 0, graph_exec_id=execution.agentGraphExecutionId, block_id=execution.AgentNode.agentBlockId if execution.AgentNode else '', node_exec_id=execution.id, node_id=execution.agentNodeId, status=execution.executionStatus, input_data=input_data, output_data=output_data, add_time=execution.addedTime, queue_time=execution.queuedTime, start_time=execution.startedTime, end_time=execution.endedTime)",
                "execution.executionData"
            ]
        },
        {
            "id": "6",
            "type": "block",
            "statements": [
                "input_data = json.loads(execution.executionData, target_type=dict[str, Any])"
            ]
        },
        {
            "id": "7",
            "type": "block",
            "statements": [
                "input_data: BlockInput = defaultdict()"
            ]
        },
        {
            "id": "8",
            "type": "block",
            "statements": [
                "output_data: CompletedBlockOutput = defaultdict(list)"
            ]
        },
        {
            "id": "9",
            "type": "block",
            "statements": [
                "data",
                "execution.Input or []"
            ]
        },
        {
            "id": "10",
            "type": "block",
            "statements": [
                "input_data[data.name] = json.loads(data.data)"
            ]
        },
        {
            "id": "11",
            "type": "block",
            "statements": []
        },
        {
            "id": "12",
            "type": "block",
            "statements": [
                "data",
                "execution.Output or []"
            ]
        },
        {
            "id": "13",
            "type": "block",
            "statements": [
                "output_data[data.name].append(json.loads(data.data))"
            ]
        },
        {
            "id": "14",
            "type": "block",
            "statements": [
                "graph_execution: AgentGraphExecution | None = execution.AgentGraphExecution",
                "return ExecutionResult(graph_id=graph_execution.agentGraphId if graph_execution else '', graph_version=graph_execution.agentGraphVersion if graph_execution else 0, graph_exec_id=execution.agentGraphExecutionId, block_id=execution.AgentNode.agentBlockId if execution.AgentNode else '', node_exec_id=execution.id, node_id=execution.agentNodeId, status=execution.executionStatus, input_data=input_data, output_data=output_data, add_time=execution.addedTime, queue_time=execution.queuedTime, start_time=execution.startedTime, end_time=execution.endedTime)"
            ]
        },
        {
            "id": "15",
            "type": "block",
            "statements": [
                "async def create_graph_execution(graph_id: str, graph_version: int, nodes_input: list[tuple[str, BlockInput]], user_id: str) -> tuple[str, list[ExecutionResult]]:\n    \"\"\"\n    Create a new AgentGraphExecution record.\n    Returns:\n        The id of the AgentGraphExecution and the list of ExecutionResult for each node.\n    \"\"\"\n    result = await AgentGraphExecution.prisma().create(data={'agentGraphId': graph_id, 'agentGraphVersion': graph_version, 'executionStatus': ExecutionStatus.QUEUED, 'AgentNodeExecutions': {'create': [{'agentNodeId': node_id, 'executionStatus': ExecutionStatus.INCOMPLETE, 'Input': {'create': [{'name': name, 'data': json.dumps(data)} for (name, data) in node_input.items()]}} for (node_id, node_input) in nodes_input]}, 'userId': user_id}, include=GRAPH_EXECUTION_INCLUDE)\n    return (result.id, [ExecutionResult.from_db(execution) for execution in result.AgentNodeExecutions or []])",
                "'\\n    Create a new AgentGraphExecution record.\\n    Returns:\\n        The id of the AgentGraphExecution and the list of ExecutionResult for each node.\\n    '",
                "result = await AgentGraphExecution.prisma().create(data={'agentGraphId': graph_id, 'agentGraphVersion': graph_version, 'executionStatus': ExecutionStatus.QUEUED, 'AgentNodeExecutions': {'create': [{'agentNodeId': node_id, 'executionStatus': ExecutionStatus.INCOMPLETE, 'Input': {'create': [{'name': name, 'data': json.dumps(data)} for (name, data) in node_input.items()]}} for (node_id, node_input) in nodes_input]}, 'userId': user_id}, include=GRAPH_EXECUTION_INCLUDE)",
                "return (result.id, [ExecutionResult.from_db(execution) for execution in result.AgentNodeExecutions or []])"
            ]
        },
        {
            "id": "16",
            "type": "block",
            "statements": [
                "async def upsert_execution_input(node_id: str, graph_exec_id: str, input_name: str, input_data: Any, node_exec_id: str | None=None) -> tuple[str, BlockInput]:\n    \"\"\"\n    Insert AgentNodeExecutionInputOutput record for as one of AgentNodeExecution.Input.\n    If there is no AgentNodeExecution that has no `input_name` as input, create new one.\n\n    Args:\n        node_id: The id of the AgentNode.\n        graph_exec_id: The id of the AgentGraphExecution.\n        input_name: The name of the input data.\n        input_data: The input data to be inserted.\n        node_exec_id: [Optional] The id of the AgentNodeExecution that has no `input_name` as input. If not provided, it will find the eligible incomplete AgentNodeExecution or create a new one.\n\n    Returns:\n        * The id of the created or existing AgentNodeExecution.\n        * Dict of node input data, key is the input name, value is the input data.\n    \"\"\"\n    existing_execution = await AgentNodeExecution.prisma().find_first(where={**({'id': node_exec_id} if node_exec_id else {}), 'agentNodeId': node_id, 'agentGraphExecutionId': graph_exec_id, 'executionStatus': ExecutionStatus.INCOMPLETE, 'Input': {'every': {'name': {'not': input_name}}}}, order={'addedTime': 'asc'}, include={'Input': True})\n    json_input_data = json.dumps(input_data)\n    if existing_execution:\n        await AgentNodeExecutionInputOutput.prisma().create(data={'name': input_name, 'data': json_input_data, 'referencedByInputExecId': existing_execution.id})\n        return (existing_execution.id, {**{input_data.name: json.loads(input_data.data) for input_data in existing_execution.Input or []}, input_name: input_data})\n    elif not node_exec_id:\n        result = await AgentNodeExecution.prisma().create(data={'agentNodeId': node_id, 'agentGraphExecutionId': graph_exec_id, 'executionStatus': ExecutionStatus.INCOMPLETE, 'Input': {'create': {'name': input_name, 'data': json_input_data}}})\n        return (result.id, {input_name: input_data})\n    else:\n        raise ValueError(f'NodeExecution {node_exec_id} not found or already has input {input_name}.')",
                "'\\n    Insert AgentNodeExecutionInputOutput record for as one of AgentNodeExecution.Input.\\n    If there is no AgentNodeExecution that has no `input_name` as input, create new one.\\n\\n    Args:\\n        node_id: The id of the AgentNode.\\n        graph_exec_id: The id of the AgentGraphExecution.\\n        input_name: The name of the input data.\\n        input_data: The input data to be inserted.\\n        node_exec_id: [Optional] The id of the AgentNodeExecution that has no `input_name` as input. If not provided, it will find the eligible incomplete AgentNodeExecution or create a new one.\\n\\n    Returns:\\n        * The id of the created or existing AgentNodeExecution.\\n        * Dict of node input data, key is the input name, value is the input data.\\n    '",
                "existing_execution = await AgentNodeExecution.prisma().find_first(where={**({'id': node_exec_id} if node_exec_id else {}), 'agentNodeId': node_id, 'agentGraphExecutionId': graph_exec_id, 'executionStatus': ExecutionStatus.INCOMPLETE, 'Input': {'every': {'name': {'not': input_name}}}}, order={'addedTime': 'asc'}, include={'Input': True})",
                "json_input_data = json.dumps(input_data)",
                "existing_execution"
            ]
        },
        {
            "id": "17",
            "type": "block",
            "statements": [
                "await AgentNodeExecutionInputOutput.prisma().create(data={'name': input_name, 'data': json_input_data, 'referencedByInputExecId': existing_execution.id})",
                "return (existing_execution.id, {**{input_data.name: json.loads(input_data.data) for input_data in existing_execution.Input or []}, input_name: input_data})"
            ]
        },
        {
            "id": "18",
            "type": "block",
            "statements": [
                "not node_exec_id"
            ]
        },
        {
            "id": "19",
            "type": "block",
            "statements": [
                "async def upsert_execution_output(node_exec_id: str, output_name: str, output_data: Any) -> None:\n    \"\"\"\n    Insert AgentNodeExecutionInputOutput record for as one of AgentNodeExecution.Output.\n    \"\"\"\n    await AgentNodeExecutionInputOutput.prisma().create(data={'name': output_name, 'data': json.dumps(output_data), 'referencedByOutputExecId': node_exec_id})",
                "'\\n    Insert AgentNodeExecutionInputOutput record for as one of AgentNodeExecution.Output.\\n    '",
                "await AgentNodeExecutionInputOutput.prisma().create(data={'name': output_name, 'data': json.dumps(output_data), 'referencedByOutputExecId': node_exec_id})",
                "async def update_graph_execution_start_time(graph_exec_id: str):\n    await AgentGraphExecution.prisma().update(where={'id': graph_exec_id}, data={'executionStatus': ExecutionStatus.RUNNING, 'startedAt': datetime.now(tz=timezone.utc)})",
                "await AgentGraphExecution.prisma().update(where={'id': graph_exec_id}, data={'executionStatus': ExecutionStatus.RUNNING, 'startedAt': datetime.now(tz=timezone.utc)})",
                "async def update_graph_execution_stats(graph_exec_id: str, stats: dict[str, Any]) -> ExecutionResult:\n    status = ExecutionStatus.FAILED if stats.get('error') else ExecutionStatus.COMPLETED\n    res = await AgentGraphExecution.prisma().update(where={'id': graph_exec_id}, data={'executionStatus': status, 'stats': json.dumps(stats)})\n    if not res:\n        raise ValueError(f'Execution {graph_exec_id} not found.')\n    return ExecutionResult.from_graph(res)",
                "status = ExecutionStatus.FAILED if stats.get('error') else ExecutionStatus.COMPLETED",
                "res = await AgentGraphExecution.prisma().update(where={'id': graph_exec_id}, data={'executionStatus': status, 'stats': json.dumps(stats)})",
                "not res"
            ]
        },
        {
            "id": "20",
            "type": "block",
            "statements": [
                "result = await AgentNodeExecution.prisma().create(data={'agentNodeId': node_id, 'agentGraphExecutionId': graph_exec_id, 'executionStatus': ExecutionStatus.INCOMPLETE, 'Input': {'create': {'name': input_name, 'data': json_input_data}}})",
                "return (result.id, {input_name: input_data})"
            ]
        },
        {
            "id": "21",
            "type": "block",
            "statements": [
                "raise ValueError(f'NodeExecution {node_exec_id} not found or already has input {input_name}.')"
            ]
        },
        {
            "id": "22",
            "type": "block",
            "statements": []
        },
        {
            "id": "23",
            "type": "block",
            "statements": [
                "raise ValueError(f'Execution {graph_exec_id} not found.')"
            ]
        },
        {
            "id": "24",
            "type": "block",
            "statements": []
        },
        {
            "id": "25",
            "type": "block",
            "statements": [
                "return ExecutionResult.from_graph(res)"
            ]
        },
        {
            "id": "26",
            "type": "block",
            "statements": [
                "async def update_node_execution_stats(node_exec_id: str, stats: dict[str, Any]):\n    await AgentNodeExecution.prisma().update(where={'id': node_exec_id}, data={'stats': json.dumps(stats)})",
                "await AgentNodeExecution.prisma().update(where={'id': node_exec_id}, data={'stats': json.dumps(stats)})",
                "async def update_execution_status(node_exec_id: str, status: ExecutionStatus, execution_data: BlockInput | None=None, stats: dict[str, Any] | None=None) -> ExecutionResult:\n    if status == ExecutionStatus.QUEUED and execution_data is None:\n        raise ValueError('Execution data must be provided when queuing an execution.')\n    now = datetime.now(tz=timezone.utc)\n    data = {**{'executionStatus': status}, **({'queuedTime': now} if status == ExecutionStatus.QUEUED else {}), **({'startedTime': now} if status == ExecutionStatus.RUNNING else {}), **({'endedTime': now} if status == ExecutionStatus.FAILED else {}), **({'endedTime': now} if status == ExecutionStatus.COMPLETED else {}), **({'executionData': json.dumps(execution_data)} if execution_data else {}), **({'stats': json.dumps(stats)} if stats else {})}\n    res = await AgentNodeExecution.prisma().update(where={'id': node_exec_id}, data=data, include=EXECUTION_RESULT_INCLUDE)\n    if not res:\n        raise ValueError(f'Execution {node_exec_id} not found.')\n    return ExecutionResult.from_db(res)",
                "status == ExecutionStatus.QUEUED and execution_data is None"
            ]
        },
        {
            "id": "27",
            "type": "block",
            "statements": [
                "raise ValueError('Execution data must be provided when queuing an execution.')"
            ]
        },
        {
            "id": "28",
            "type": "block",
            "statements": []
        },
        {
            "id": "29",
            "type": "block",
            "statements": [
                "now = datetime.now(tz=timezone.utc)",
                "data = {**{'executionStatus': status}, **({'queuedTime': now} if status == ExecutionStatus.QUEUED else {}), **({'startedTime': now} if status == ExecutionStatus.RUNNING else {}), **({'endedTime': now} if status == ExecutionStatus.FAILED else {}), **({'endedTime': now} if status == ExecutionStatus.COMPLETED else {}), **({'executionData': json.dumps(execution_data)} if execution_data else {}), **({'stats': json.dumps(stats)} if stats else {})}",
                "res = await AgentNodeExecution.prisma().update(where={'id': node_exec_id}, data=data, include=EXECUTION_RESULT_INCLUDE)",
                "not res"
            ]
        },
        {
            "id": "30",
            "type": "block",
            "statements": [
                "raise ValueError(f'Execution {node_exec_id} not found.')"
            ]
        },
        {
            "id": "31",
            "type": "block",
            "statements": []
        },
        {
            "id": "32",
            "type": "block",
            "statements": [
                "return ExecutionResult.from_db(res)"
            ]
        },
        {
            "id": "33",
            "type": "block",
            "statements": [
                "async def get_execution_results(graph_exec_id: str) -> list[ExecutionResult]:\n    executions = await AgentNodeExecution.prisma().find_many(where={'agentGraphExecutionId': graph_exec_id}, include=EXECUTION_RESULT_INCLUDE, order=[{'queuedTime': 'asc'}, {'addedTime': 'asc'}])\n    res = [ExecutionResult.from_db(execution) for execution in executions]\n    return res",
                "executions = await AgentNodeExecution.prisma().find_many(where={'agentGraphExecutionId': graph_exec_id}, include=EXECUTION_RESULT_INCLUDE, order=[{'queuedTime': 'asc'}, {'addedTime': 'asc'}])",
                "res = [ExecutionResult.from_db(execution) for execution in executions]",
                "return res"
            ]
        },
        {
            "id": "34",
            "type": "block",
            "statements": [
                "LIST_SPLIT = '_$_'",
                "DICT_SPLIT = '_#_'",
                "OBJC_SPLIT = '_@_'",
                "def parse_execution_output(output: BlockData, name: str) -> Any | None:\n    (output_name, output_data) = output\n    if name == output_name:\n        return output_data\n    if name.startswith(f'{output_name}{LIST_SPLIT}'):\n        index = int(name.split(LIST_SPLIT)[1])\n        if not isinstance(output_data, list) or len(output_data) <= index:\n            return None\n        return output_data[int(name.split(LIST_SPLIT)[1])]\n    if name.startswith(f'{output_name}{DICT_SPLIT}'):\n        index = name.split(DICT_SPLIT)[1]\n        if not isinstance(output_data, dict) or index not in output_data:\n            return None\n        return output_data[index]\n    if name.startswith(f'{output_name}{OBJC_SPLIT}'):\n        index = name.split(OBJC_SPLIT)[1]\n        if isinstance(output_data, object) and hasattr(output_data, index):\n            return getattr(output_data, index)\n        return None\n    return None",
                "(output_name, output_data) = output",
                "name Eq output_name"
            ]
        },
        {
            "id": "35",
            "type": "block",
            "statements": [
                "return output_data"
            ]
        },
        {
            "id": "36",
            "type": "block",
            "statements": []
        },
        {
            "id": "37",
            "type": "block",
            "statements": [
                "name.startswith(f'{output_name}{LIST_SPLIT}')"
            ]
        },
        {
            "id": "38",
            "type": "block",
            "statements": [
                "index = int(name.split(LIST_SPLIT)[1])",
                "not isinstance(output_data, list) or len(output_data) <= index"
            ]
        },
        {
            "id": "39",
            "type": "block",
            "statements": []
        },
        {
            "id": "40",
            "type": "block",
            "statements": [
                "name.startswith(f'{output_name}{DICT_SPLIT}')"
            ]
        },
        {
            "id": "41",
            "type": "block",
            "statements": [
                "return None"
            ]
        },
        {
            "id": "42",
            "type": "block",
            "statements": []
        },
        {
            "id": "43",
            "type": "block",
            "statements": [
                "return output_data[int(name.split(LIST_SPLIT)[1])]"
            ]
        },
        {
            "id": "44",
            "type": "block",
            "statements": [
                "index = name.split(DICT_SPLIT)[1]",
                "not isinstance(output_data, dict) or index not in output_data"
            ]
        },
        {
            "id": "45",
            "type": "block",
            "statements": []
        },
        {
            "id": "46",
            "type": "block",
            "statements": [
                "name.startswith(f'{output_name}{OBJC_SPLIT}')"
            ]
        },
        {
            "id": "47",
            "type": "block",
            "statements": [
                "return None"
            ]
        },
        {
            "id": "48",
            "type": "block",
            "statements": []
        },
        {
            "id": "49",
            "type": "block",
            "statements": [
                "return output_data[index]"
            ]
        },
        {
            "id": "50",
            "type": "block",
            "statements": [
                "index = name.split(OBJC_SPLIT)[1]",
                "isinstance(output_data, object) and hasattr(output_data, index)"
            ]
        },
        {
            "id": "51",
            "type": "block",
            "statements": []
        },
        {
            "id": "52",
            "type": "block",
            "statements": [
                "return None"
            ]
        },
        {
            "id": "53",
            "type": "block",
            "statements": [
                "return getattr(output_data, index)"
            ]
        },
        {
            "id": "54",
            "type": "block",
            "statements": []
        },
        {
            "id": "55",
            "type": "block",
            "statements": [
                "return None"
            ]
        },
        {
            "id": "56",
            "type": "block",
            "statements": [
                "def merge_execution_input(data: BlockInput) -> BlockInput:\n    \"\"\"\n    Merge all dynamic input pins which described by the following pattern:\n    - <input_name>_$_<index> for list input.\n    - <input_name>_#_<index> for dict input.\n    - <input_name>_@_<index> for object input.\n    This function will construct pins with the same name into a single list/dict/object.\n    \"\"\"\n    items = list(data.items())\n    for (key, value) in items:\n        if LIST_SPLIT not in key:\n            continue\n        (name, index) = key.split(LIST_SPLIT)\n        if not index.isdigit():\n            raise ValueError(f'Invalid key: {key}, #{index} index must be an integer.')\n        data[name] = data.get(name, [])\n        if int(index) >= len(data[name]):\n            data[name].extend([''] * (int(index) - len(data[name]) + 1))\n        data[name][int(index)] = value\n    for (key, value) in items:\n        if DICT_SPLIT not in key:\n            continue\n        (name, index) = key.split(DICT_SPLIT)\n        data[name] = data.get(name, {})\n        data[name][index] = value\n    for (key, value) in items:\n        if OBJC_SPLIT not in key:\n            continue\n        (name, index) = key.split(OBJC_SPLIT)\n        if name not in data or not isinstance(data[name], object):\n            data[name] = mock.MockObject()\n        setattr(data[name], index, value)\n    return data",
                "'\\n    Merge all dynamic input pins which described by the following pattern:\\n    - <input_name>_$_<index> for list input.\\n    - <input_name>_#_<index> for dict input.\\n    - <input_name>_@_<index> for object input.\\n    This function will construct pins with the same name into a single list/dict/object.\\n    '",
                "items = list(data.items())"
            ]
        },
        {
            "id": "57",
            "type": "block",
            "statements": [
                "(key, value)",
                "items"
            ]
        },
        {
            "id": "58",
            "type": "block",
            "statements": [
                "LIST_SPLIT NotIn key"
            ]
        },
        {
            "id": "59",
            "type": "block",
            "statements": []
        },
        {
            "id": "60",
            "type": "block",
            "statements": [
                "continue"
            ]
        },
        {
            "id": "61",
            "type": "block",
            "statements": []
        },
        {
            "id": "62",
            "type": "block",
            "statements": [
                "(name, index) = key.split(LIST_SPLIT)",
                "not index.isdigit()"
            ]
        },
        {
            "id": "63",
            "type": "block",
            "statements": [
                "raise ValueError(f'Invalid key: {key}, #{index} index must be an integer.')"
            ]
        },
        {
            "id": "64",
            "type": "block",
            "statements": []
        },
        {
            "id": "65",
            "type": "block",
            "statements": [
                "data[name] = data.get(name, [])",
                "int(index) GtE len(data[name])"
            ]
        },
        {
            "id": "66",
            "type": "block",
            "statements": [
                "data[name].extend([''] Mult int(index) Sub len(data[name]) Add 1)"
            ]
        },
        {
            "id": "67",
            "type": "block",
            "statements": []
        },
        {
            "id": "68",
            "type": "block",
            "statements": [
                "data[name][int(index)] = value"
            ]
        },
        {
            "id": "69",
            "type": "block",
            "statements": [
                "(key, value)",
                "items"
            ]
        },
        {
            "id": "70",
            "type": "block",
            "statements": [
                "DICT_SPLIT NotIn key"
            ]
        },
        {
            "id": "71",
            "type": "block",
            "statements": []
        },
        {
            "id": "72",
            "type": "block",
            "statements": [
                "continue"
            ]
        },
        {
            "id": "73",
            "type": "block",
            "statements": []
        },
        {
            "id": "74",
            "type": "block",
            "statements": [
                "(name, index) = key.split(DICT_SPLIT)",
                "data[name] = data.get(name, {})",
                "data[name][index] = value"
            ]
        },
        {
            "id": "75",
            "type": "block",
            "statements": [
                "(key, value)",
                "items"
            ]
        },
        {
            "id": "76",
            "type": "block",
            "statements": [
                "OBJC_SPLIT NotIn key"
            ]
        },
        {
            "id": "77",
            "type": "block",
            "statements": [
                "return data"
            ]
        },
        {
            "id": "78",
            "type": "block",
            "statements": [
                "continue"
            ]
        },
        {
            "id": "79",
            "type": "block",
            "statements": []
        },
        {
            "id": "80",
            "type": "block",
            "statements": [
                "(name, index) = key.split(OBJC_SPLIT)",
                "name not in data or not isinstance(data[name], object)"
            ]
        },
        {
            "id": "81",
            "type": "block",
            "statements": [
                "data[name] = mock.MockObject()"
            ]
        },
        {
            "id": "82",
            "type": "block",
            "statements": []
        },
        {
            "id": "83",
            "type": "block",
            "statements": [
                "setattr(data[name], index, value)"
            ]
        },
        {
            "id": "84",
            "type": "block",
            "statements": [
                "async def get_latest_execution(node_id: str, graph_eid: str) -> ExecutionResult | None:\n    execution = await AgentNodeExecution.prisma().find_first(where={'agentNodeId': node_id, 'agentGraphExecutionId': graph_eid, 'executionStatus': {'not': ExecutionStatus.INCOMPLETE}, 'executionData': {'not': None}}, order={'queuedTime': 'desc'}, include=EXECUTION_RESULT_INCLUDE)\n    if not execution:\n        return None\n    return ExecutionResult.from_db(execution)",
                "execution = await AgentNodeExecution.prisma().find_first(where={'agentNodeId': node_id, 'agentGraphExecutionId': graph_eid, 'executionStatus': {'not': ExecutionStatus.INCOMPLETE}, 'executionData': {'not': None}}, order={'queuedTime': 'desc'}, include=EXECUTION_RESULT_INCLUDE)",
                "not execution"
            ]
        },
        {
            "id": "85",
            "type": "block",
            "statements": [
                "return None"
            ]
        },
        {
            "id": "86",
            "type": "block",
            "statements": []
        },
        {
            "id": "87",
            "type": "block",
            "statements": [
                "return ExecutionResult.from_db(execution)"
            ]
        },
        {
            "id": "88",
            "type": "block",
            "statements": [
                "async def get_incomplete_executions(node_id: str, graph_eid: str) -> list[ExecutionResult]:\n    executions = await AgentNodeExecution.prisma().find_many(where={'agentNodeId': node_id, 'agentGraphExecutionId': graph_eid, 'executionStatus': ExecutionStatus.INCOMPLETE}, include=EXECUTION_RESULT_INCLUDE)\n    return [ExecutionResult.from_db(execution) for execution in executions]",
                "executions = await AgentNodeExecution.prisma().find_many(where={'agentNodeId': node_id, 'agentGraphExecutionId': graph_eid, 'executionStatus': ExecutionStatus.INCOMPLETE}, include=EXECUTION_RESULT_INCLUDE)",
                "return [ExecutionResult.from_db(execution) for execution in executions]"
            ]
        },
        {
            "id": "89",
            "type": "block",
            "statements": [
                "config = Config()",
                "class RedisExecutionEventBus(RedisEventBus[ExecutionResult]):\n    Model = ExecutionResult\n\n    @property\n    def event_bus_name(self) -> str:\n        return config.execution_event_bus_name\n\n    def publish(self, res: ExecutionResult):\n        self.publish_event(res, f'{res.graph_id}/{res.graph_exec_id}')\n\n    def listen(self, graph_id: str='*', graph_exec_id: str='*') -> Generator[ExecutionResult, None, None]:\n        for execution_result in self.listen_events(f'{graph_id}/{graph_exec_id}'):\n            yield execution_result",
                "Model = ExecutionResult",
                "@property\ndef event_bus_name(self) -> str:\n    return config.execution_event_bus_name",
                "return config.execution_event_bus_name"
            ]
        },
        {
            "id": "90",
            "type": "block",
            "statements": [
                "def publish(self, res: ExecutionResult):\n    self.publish_event(res, f'{res.graph_id}/{res.graph_exec_id}')",
                "self.publish_event(res, f'{res.graph_id}/{res.graph_exec_id}')",
                "def listen(self, graph_id: str='*', graph_exec_id: str='*') -> Generator[ExecutionResult, None, None]:\n    for execution_result in self.listen_events(f'{graph_id}/{graph_exec_id}'):\n        yield execution_result"
            ]
        },
        {
            "id": "91",
            "type": "block",
            "statements": [
                "execution_result",
                "self.listen_events(f'{graph_id}/{graph_exec_id}')"
            ]
        },
        {
            "id": "92",
            "type": "block",
            "statements": [
                "(yield execution_result)"
            ]
        },
        {
            "id": "93",
            "type": "block",
            "statements": [
                "class AsyncRedisExecutionEventBus(AsyncRedisEventBus[ExecutionResult]):\n    Model = ExecutionResult\n\n    @property\n    def event_bus_name(self) -> str:\n        return config.execution_event_bus_name\n\n    async def publish(self, res: ExecutionResult):\n        await self.publish_event(res, f'{res.graph_id}/{res.graph_exec_id}')\n\n    async def listen(self, graph_id: str='*', graph_exec_id: str='*') -> AsyncGenerator[ExecutionResult, None]:\n        async for execution_result in self.listen_events(f'{graph_id}/{graph_exec_id}'):\n            yield execution_result",
                "Model = ExecutionResult",
                "@property\ndef event_bus_name(self) -> str:\n    return config.execution_event_bus_name",
                "return config.execution_event_bus_name"
            ]
        },
        {
            "id": "94",
            "type": "block",
            "statements": [
                "async def publish(self, res: ExecutionResult):\n    await self.publish_event(res, f'{res.graph_id}/{res.graph_exec_id}')",
                "await self.publish_event(res, f'{res.graph_id}/{res.graph_exec_id}')",
                "async def listen(self, graph_id: str='*', graph_exec_id: str='*') -> AsyncGenerator[ExecutionResult, None]:\n    async for execution_result in self.listen_events(f'{graph_id}/{graph_exec_id}'):\n        yield execution_result",
                "async for execution_result in self.listen_events(f'{graph_id}/{graph_exec_id}'):\n    yield execution_result",
                "(yield execution_result)"
            ]
        }
    ],
    "edges": [
        {
            "source": "5",
            "target": "6",
            "type": "true"
        },
        {
            "source": "5",
            "target": "7",
            "type": "false"
        },
        {
            "source": "6",
            "target": "8",
            "type": "next"
        },
        {
            "source": "7",
            "target": "9",
            "type": "next"
        },
        {
            "source": "8",
            "target": "12",
            "type": "next"
        },
        {
            "source": "9",
            "target": "10",
            "type": "true"
        },
        {
            "source": "9",
            "target": "11",
            "type": "false"
        },
        {
            "source": "10",
            "target": "9",
            "type": "next"
        },
        {
            "source": "11",
            "target": "8",
            "type": "next"
        },
        {
            "source": "12",
            "target": "13",
            "type": "true"
        },
        {
            "source": "12",
            "target": "14",
            "type": "false"
        },
        {
            "source": "13",
            "target": "12",
            "type": "next"
        },
        {
            "source": "16",
            "target": "17",
            "type": "true"
        },
        {
            "source": "16",
            "target": "18",
            "type": "false"
        },
        {
            "source": "18",
            "target": "20",
            "type": "true"
        },
        {
            "source": "18",
            "target": "21",
            "type": "false"
        },
        {
            "source": "19",
            "target": "23",
            "type": "true"
        },
        {
            "source": "19",
            "target": "24",
            "type": "false"
        },
        {
            "source": "21",
            "target": "22",
            "type": "next"
        },
        {
            "source": "22",
            "target": "19",
            "type": "next"
        },
        {
            "source": "23",
            "target": "25",
            "type": "next"
        },
        {
            "source": "24",
            "target": "25",
            "type": "next"
        },
        {
            "source": "26",
            "target": "27",
            "type": "true"
        },
        {
            "source": "26",
            "target": "28",
            "type": "false"
        },
        {
            "source": "27",
            "target": "29",
            "type": "next"
        },
        {
            "source": "28",
            "target": "29",
            "type": "next"
        },
        {
            "source": "29",
            "target": "30",
            "type": "true"
        },
        {
            "source": "29",
            "target": "31",
            "type": "false"
        },
        {
            "source": "30",
            "target": "32",
            "type": "next"
        },
        {
            "source": "31",
            "target": "32",
            "type": "next"
        },
        {
            "source": "34",
            "target": "35",
            "type": "true"
        },
        {
            "source": "34",
            "target": "36",
            "type": "false"
        },
        {
            "source": "36",
            "target": "37",
            "type": "next"
        },
        {
            "source": "37",
            "target": "38",
            "type": "true"
        },
        {
            "source": "37",
            "target": "39",
            "type": "false"
        },
        {
            "source": "38",
            "target": "41",
            "type": "true"
        },
        {
            "source": "38",
            "target": "42",
            "type": "false"
        },
        {
            "source": "39",
            "target": "40",
            "type": "next"
        },
        {
            "source": "40",
            "target": "44",
            "type": "true"
        },
        {
            "source": "40",
            "target": "45",
            "type": "false"
        },
        {
            "source": "42",
            "target": "43",
            "type": "next"
        },
        {
            "source": "44",
            "target": "47",
            "type": "true"
        },
        {
            "source": "44",
            "target": "48",
            "type": "false"
        },
        {
            "source": "45",
            "target": "46",
            "type": "next"
        },
        {
            "source": "46",
            "target": "50",
            "type": "true"
        },
        {
            "source": "46",
            "target": "51",
            "type": "false"
        },
        {
            "source": "48",
            "target": "49",
            "type": "next"
        },
        {
            "source": "50",
            "target": "53",
            "type": "true"
        },
        {
            "source": "50",
            "target": "54",
            "type": "false"
        },
        {
            "source": "51",
            "target": "52",
            "type": "next"
        },
        {
            "source": "54",
            "target": "55",
            "type": "next"
        },
        {
            "source": "56",
            "target": "57",
            "type": "next"
        },
        {
            "source": "57",
            "target": "58",
            "type": "true"
        },
        {
            "source": "57",
            "target": "59",
            "type": "false"
        },
        {
            "source": "58",
            "target": "60",
            "type": "true"
        },
        {
            "source": "58",
            "target": "61",
            "type": "false"
        },
        {
            "source": "59",
            "target": "69",
            "type": "next"
        },
        {
            "source": "60",
            "target": "62",
            "type": "next"
        },
        {
            "source": "61",
            "target": "62",
            "type": "next"
        },
        {
            "source": "62",
            "target": "63",
            "type": "true"
        },
        {
            "source": "62",
            "target": "64",
            "type": "false"
        },
        {
            "source": "63",
            "target": "65",
            "type": "next"
        },
        {
            "source": "64",
            "target": "65",
            "type": "next"
        },
        {
            "source": "65",
            "target": "66",
            "type": "true"
        },
        {
            "source": "65",
            "target": "67",
            "type": "false"
        },
        {
            "source": "66",
            "target": "68",
            "type": "next"
        },
        {
            "source": "67",
            "target": "68",
            "type": "next"
        },
        {
            "source": "68",
            "target": "57",
            "type": "next"
        },
        {
            "source": "69",
            "target": "70",
            "type": "true"
        },
        {
            "source": "69",
            "target": "71",
            "type": "false"
        },
        {
            "source": "70",
            "target": "72",
            "type": "true"
        },
        {
            "source": "70",
            "target": "73",
            "type": "false"
        },
        {
            "source": "71",
            "target": "75",
            "type": "next"
        },
        {
            "source": "72",
            "target": "74",
            "type": "next"
        },
        {
            "source": "73",
            "target": "74",
            "type": "next"
        },
        {
            "source": "74",
            "target": "69",
            "type": "next"
        },
        {
            "source": "75",
            "target": "76",
            "type": "true"
        },
        {
            "source": "75",
            "target": "77",
            "type": "false"
        },
        {
            "source": "76",
            "target": "78",
            "type": "true"
        },
        {
            "source": "76",
            "target": "79",
            "type": "false"
        },
        {
            "source": "78",
            "target": "80",
            "type": "next"
        },
        {
            "source": "79",
            "target": "80",
            "type": "next"
        },
        {
            "source": "80",
            "target": "81",
            "type": "true"
        },
        {
            "source": "80",
            "target": "82",
            "type": "false"
        },
        {
            "source": "81",
            "target": "83",
            "type": "next"
        },
        {
            "source": "82",
            "target": "83",
            "type": "next"
        },
        {
            "source": "83",
            "target": "75",
            "type": "next"
        },
        {
            "source": "84",
            "target": "85",
            "type": "true"
        },
        {
            "source": "84",
            "target": "86",
            "type": "false"
        },
        {
            "source": "86",
            "target": "87",
            "type": "next"
        },
        {
            "source": "90",
            "target": "91",
            "type": "next"
        },
        {
            "source": "91",
            "target": "92",
            "type": "true"
        },
        {
            "source": "91",
            "target": "93",
            "type": "false"
        },
        {
            "source": "92",
            "target": "91",
            "type": "next"
        }
    ]
}