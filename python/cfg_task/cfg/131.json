{
    "nodes": [
        {
            "id": "1",
            "type": "block",
            "statements": [
                "import logging",
                "from typing import TYPE_CHECKING, AsyncGenerator, Optional",
                "from prisma import Json",
                "from prisma.models import IntegrationWebhook",
                "from pydantic import Field, computed_field",
                "from backend.data.includes import INTEGRATION_WEBHOOK_INCLUDE",
                "from backend.data.queue import AsyncRedisEventBus",
                "from backend.integrations.providers import ProviderName",
                "from backend.integrations.webhooks.utils import webhook_ingress_url",
                "from .db import BaseDbModel",
                "TYPE_CHECKING"
            ]
        },
        {
            "id": "2",
            "type": "block",
            "statements": [
                "from .graph import NodeModel"
            ]
        },
        {
            "id": "3",
            "type": "block",
            "statements": []
        },
        {
            "id": "4",
            "type": "block",
            "statements": [
                "logger = logging.getLogger(__name__)",
                "class Webhook(BaseDbModel):\n    user_id: str\n    provider: ProviderName\n    credentials_id: str\n    webhook_type: str\n    resource: str\n    events: list[str]\n    config: dict = Field(default_factory=dict)\n    secret: str\n    provider_webhook_id: str\n    attached_nodes: Optional[list['NodeModel']] = None\n\n    @computed_field\n    @property\n    def url(self) -> str:\n        return webhook_ingress_url(self.provider.value, self.id)\n\n    @staticmethod\n    def from_db(webhook: IntegrationWebhook):\n        from .graph import NodeModel\n        return Webhook(id=webhook.id, user_id=webhook.userId, provider=ProviderName(webhook.provider), credentials_id=webhook.credentialsId, webhook_type=webhook.webhookType, resource=webhook.resource, events=webhook.events, config=dict(webhook.config), secret=webhook.secret, provider_webhook_id=webhook.providerWebhookId, attached_nodes=[NodeModel.from_db(node) for node in webhook.AgentNodes] if webhook.AgentNodes is not None else None)",
                "user_id: str",
                "provider: ProviderName",
                "credentials_id: str",
                "webhook_type: str",
                "resource: str",
                "events: list[str]",
                "config: dict = Field(default_factory=dict)",
                "secret: str",
                "provider_webhook_id: str",
                "attached_nodes: Optional[list['NodeModel']] = None",
                "@computed_field\n@property\ndef url(self) -> str:\n    return webhook_ingress_url(self.provider.value, self.id)",
                "return webhook_ingress_url(self.provider.value, self.id)"
            ]
        },
        {
            "id": "5",
            "type": "block",
            "statements": [
                "@staticmethod\ndef from_db(webhook: IntegrationWebhook):\n    from .graph import NodeModel\n    return Webhook(id=webhook.id, user_id=webhook.userId, provider=ProviderName(webhook.provider), credentials_id=webhook.credentialsId, webhook_type=webhook.webhookType, resource=webhook.resource, events=webhook.events, config=dict(webhook.config), secret=webhook.secret, provider_webhook_id=webhook.providerWebhookId, attached_nodes=[NodeModel.from_db(node) for node in webhook.AgentNodes] if webhook.AgentNodes is not None else None)",
                "from .graph import NodeModel",
                "return Webhook(id=webhook.id, user_id=webhook.userId, provider=ProviderName(webhook.provider), credentials_id=webhook.credentialsId, webhook_type=webhook.webhookType, resource=webhook.resource, events=webhook.events, config=dict(webhook.config), secret=webhook.secret, provider_webhook_id=webhook.providerWebhookId, attached_nodes=[NodeModel.from_db(node) for node in webhook.AgentNodes] if webhook.AgentNodes is not None else None)"
            ]
        },
        {
            "id": "6",
            "type": "block",
            "statements": [
                "async def create_webhook(webhook: Webhook) -> Webhook:\n    created_webhook = await IntegrationWebhook.prisma().create(data={'id': webhook.id, 'userId': webhook.user_id, 'provider': webhook.provider.value, 'credentialsId': webhook.credentials_id, 'webhookType': webhook.webhook_type, 'resource': webhook.resource, 'events': webhook.events, 'config': Json(webhook.config), 'secret': webhook.secret, 'providerWebhookId': webhook.provider_webhook_id})\n    return Webhook.from_db(created_webhook)",
                "created_webhook = await IntegrationWebhook.prisma().create(data={'id': webhook.id, 'userId': webhook.user_id, 'provider': webhook.provider.value, 'credentialsId': webhook.credentials_id, 'webhookType': webhook.webhook_type, 'resource': webhook.resource, 'events': webhook.events, 'config': Json(webhook.config), 'secret': webhook.secret, 'providerWebhookId': webhook.provider_webhook_id})",
                "return Webhook.from_db(created_webhook)"
            ]
        },
        {
            "id": "7",
            "type": "block",
            "statements": [
                "async def get_webhook(webhook_id: str) -> Webhook:\n    \"\"\"\u26a0\ufe0f No `user_id` check: DO NOT USE without check in user-facing endpoints.\"\"\"\n    webhook = await IntegrationWebhook.prisma().find_unique_or_raise(where={'id': webhook_id}, include=INTEGRATION_WEBHOOK_INCLUDE)\n    return Webhook.from_db(webhook)",
                "'\u26a0\ufe0f No `user_id` check: DO NOT USE without check in user-facing endpoints.'",
                "webhook = await IntegrationWebhook.prisma().find_unique_or_raise(where={'id': webhook_id}, include=INTEGRATION_WEBHOOK_INCLUDE)",
                "return Webhook.from_db(webhook)"
            ]
        },
        {
            "id": "8",
            "type": "block",
            "statements": [
                "async def get_all_webhooks_by_creds(credentials_id: str) -> list[Webhook]:\n    \"\"\"\u26a0\ufe0f No `user_id` check: DO NOT USE without check in user-facing endpoints.\"\"\"\n    if not credentials_id:\n        raise ValueError('credentials_id must not be empty')\n    webhooks = await IntegrationWebhook.prisma().find_many(where={'credentialsId': credentials_id}, include=INTEGRATION_WEBHOOK_INCLUDE)\n    return [Webhook.from_db(webhook) for webhook in webhooks]",
                "'\u26a0\ufe0f No `user_id` check: DO NOT USE without check in user-facing endpoints.'",
                "not credentials_id"
            ]
        },
        {
            "id": "9",
            "type": "block",
            "statements": [
                "raise ValueError('credentials_id must not be empty')"
            ]
        },
        {
            "id": "10",
            "type": "block",
            "statements": []
        },
        {
            "id": "11",
            "type": "block",
            "statements": [
                "webhooks = await IntegrationWebhook.prisma().find_many(where={'credentialsId': credentials_id}, include=INTEGRATION_WEBHOOK_INCLUDE)",
                "return [Webhook.from_db(webhook) for webhook in webhooks]"
            ]
        },
        {
            "id": "12",
            "type": "block",
            "statements": [
                "async def find_webhook_by_credentials_and_props(credentials_id: str, webhook_type: str, resource: str, events: list[str]) -> Webhook | None:\n    \"\"\"\u26a0\ufe0f No `user_id` check: DO NOT USE without check in user-facing endpoints.\"\"\"\n    webhook = await IntegrationWebhook.prisma().find_first(where={'credentialsId': credentials_id, 'webhookType': webhook_type, 'resource': resource, 'events': {'has_every': events}}, include=INTEGRATION_WEBHOOK_INCLUDE)\n    return Webhook.from_db(webhook) if webhook else None",
                "'\u26a0\ufe0f No `user_id` check: DO NOT USE without check in user-facing endpoints.'",
                "webhook = await IntegrationWebhook.prisma().find_first(where={'credentialsId': credentials_id, 'webhookType': webhook_type, 'resource': resource, 'events': {'has_every': events}}, include=INTEGRATION_WEBHOOK_INCLUDE)",
                "return Webhook.from_db(webhook) if webhook else None"
            ]
        },
        {
            "id": "13",
            "type": "block",
            "statements": [
                "async def find_webhook_by_graph_and_props(graph_id: str, provider: str, webhook_type: str, events: list[str]) -> Webhook | None:\n    \"\"\"\u26a0\ufe0f No `user_id` check: DO NOT USE without check in user-facing endpoints.\"\"\"\n    webhook = await IntegrationWebhook.prisma().find_first(where={'provider': provider, 'webhookType': webhook_type, 'events': {'has_every': events}, 'AgentNodes': {'some': {'agentGraphId': graph_id}}}, include=INTEGRATION_WEBHOOK_INCLUDE)\n    return Webhook.from_db(webhook) if webhook else None",
                "'\u26a0\ufe0f No `user_id` check: DO NOT USE without check in user-facing endpoints.'",
                "webhook = await IntegrationWebhook.prisma().find_first(where={'provider': provider, 'webhookType': webhook_type, 'events': {'has_every': events}, 'AgentNodes': {'some': {'agentGraphId': graph_id}}}, include=INTEGRATION_WEBHOOK_INCLUDE)",
                "return Webhook.from_db(webhook) if webhook else None"
            ]
        },
        {
            "id": "14",
            "type": "block",
            "statements": [
                "async def update_webhook_config(webhook_id: str, updated_config: dict) -> Webhook:\n    \"\"\"\u26a0\ufe0f No `user_id` check: DO NOT USE without check in user-facing endpoints.\"\"\"\n    _updated_webhook = await IntegrationWebhook.prisma().update(where={'id': webhook_id}, data={'config': Json(updated_config)}, include=INTEGRATION_WEBHOOK_INCLUDE)\n    if _updated_webhook is None:\n        raise ValueError(f'Webhook #{webhook_id} not found')\n    return Webhook.from_db(_updated_webhook)",
                "'\u26a0\ufe0f No `user_id` check: DO NOT USE without check in user-facing endpoints.'",
                "_updated_webhook = await IntegrationWebhook.prisma().update(where={'id': webhook_id}, data={'config': Json(updated_config)}, include=INTEGRATION_WEBHOOK_INCLUDE)",
                "_updated_webhook Is None"
            ]
        },
        {
            "id": "15",
            "type": "block",
            "statements": [
                "raise ValueError(f'Webhook #{webhook_id} not found')"
            ]
        },
        {
            "id": "16",
            "type": "block",
            "statements": []
        },
        {
            "id": "17",
            "type": "block",
            "statements": [
                "return Webhook.from_db(_updated_webhook)"
            ]
        },
        {
            "id": "18",
            "type": "block",
            "statements": [
                "async def delete_webhook(webhook_id: str) -> None:\n    \"\"\"\u26a0\ufe0f No `user_id` check: DO NOT USE without check in user-facing endpoints.\"\"\"\n    deleted = await IntegrationWebhook.prisma().delete(where={'id': webhook_id})\n    if not deleted:\n        raise ValueError(f'Webhook #{webhook_id} not found')",
                "'\u26a0\ufe0f No `user_id` check: DO NOT USE without check in user-facing endpoints.'",
                "deleted = await IntegrationWebhook.prisma().delete(where={'id': webhook_id})",
                "not deleted"
            ]
        },
        {
            "id": "19",
            "type": "block",
            "statements": [
                "raise ValueError(f'Webhook #{webhook_id} not found')"
            ]
        },
        {
            "id": "20",
            "type": "block",
            "statements": []
        },
        {
            "id": "21",
            "type": "block",
            "statements": [
                "class WebhookEvent(BaseDbModel):\n    provider: str\n    webhook_id: str\n    event_type: str\n    payload: dict",
                "provider: str",
                "webhook_id: str",
                "event_type: str",
                "payload: dict",
                "class WebhookEventBus(AsyncRedisEventBus[WebhookEvent]):\n    Model = WebhookEvent\n\n    @property\n    def event_bus_name(self) -> str:\n        return 'webhooks'",
                "Model = WebhookEvent",
                "@property\ndef event_bus_name(self) -> str:\n    return 'webhooks'",
                "return 'webhooks'"
            ]
        },
        {
            "id": "22",
            "type": "block",
            "statements": [
                "_webhook_event_bus = WebhookEventBus()",
                "async def publish_webhook_event(event: WebhookEvent):\n    await _webhook_event_bus.publish_event(event, f'{event.webhook_id}/{event.event_type}')",
                "await _webhook_event_bus.publish_event(event, f'{event.webhook_id}/{event.event_type}')",
                "async def listen_for_webhook_events(webhook_id: str, event_type: Optional[str]=None) -> AsyncGenerator[WebhookEvent, None]:\n    async for event in _webhook_event_bus.listen_events(f\"{webhook_id}/{event_type or '*'}\"):\n        yield event",
                "async for event in _webhook_event_bus.listen_events(f\"{webhook_id}/{event_type or '*'}\"):\n    yield event",
                "(yield event)",
                "async def wait_for_webhook_event(webhook_id: str, event_type: Optional[str]=None, timeout: Optional[float]=None) -> WebhookEvent | None:\n    return await _webhook_event_bus.wait_for_event(f\"{webhook_id}/{event_type or '*'}\", timeout)",
                "return await _webhook_event_bus.wait_for_event(f\"{webhook_id}/{event_type or '*'}\", timeout)"
            ]
        }
    ],
    "edges": [
        {
            "source": "1",
            "target": "2",
            "type": "true"
        },
        {
            "source": "1",
            "target": "3",
            "type": "false"
        },
        {
            "source": "2",
            "target": "4",
            "type": "next"
        },
        {
            "source": "3",
            "target": "4",
            "type": "next"
        },
        {
            "source": "8",
            "target": "9",
            "type": "true"
        },
        {
            "source": "8",
            "target": "10",
            "type": "false"
        },
        {
            "source": "9",
            "target": "11",
            "type": "next"
        },
        {
            "source": "10",
            "target": "11",
            "type": "next"
        },
        {
            "source": "14",
            "target": "15",
            "type": "true"
        },
        {
            "source": "14",
            "target": "16",
            "type": "false"
        },
        {
            "source": "15",
            "target": "17",
            "type": "next"
        },
        {
            "source": "16",
            "target": "17",
            "type": "next"
        },
        {
            "source": "18",
            "target": "19",
            "type": "true"
        },
        {
            "source": "18",
            "target": "20",
            "type": "false"
        },
        {
            "source": "19",
            "target": "21",
            "type": "next"
        },
        {
            "source": "20",
            "target": "21",
            "type": "next"
        }
    ]
}