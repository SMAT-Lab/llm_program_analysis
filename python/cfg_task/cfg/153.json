{
    "nodes": [
        {
            "id": "1",
            "type": "block",
            "statements": [
                "from datetime import datetime, timezone",
                "from typing import Iterator",
                "import praw",
                "from pydantic import BaseModel, ConfigDict",
                "from backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema",
                "from backend.data.model import BlockSecret, SchemaField, SecretField",
                "from backend.util.mock import MockObject",
                "class RedditCredentials(BaseModel):\n    client_id: BlockSecret = SecretField(key='reddit_client_id')\n    client_secret: BlockSecret = SecretField(key='reddit_client_secret')\n    username: BlockSecret = SecretField(key='reddit_username')\n    password: BlockSecret = SecretField(key='reddit_password')\n    user_agent: str = 'AutoGPT:1.0 (by /u/autogpt)'\n    model_config = ConfigDict(title='Reddit Credentials')",
                "client_id: BlockSecret = SecretField(key='reddit_client_id')",
                "client_secret: BlockSecret = SecretField(key='reddit_client_secret')",
                "username: BlockSecret = SecretField(key='reddit_username')",
                "password: BlockSecret = SecretField(key='reddit_password')",
                "user_agent: str = 'AutoGPT:1.0 (by /u/autogpt)'",
                "model_config = ConfigDict(title='Reddit Credentials')",
                "class RedditPost(BaseModel):\n    id: str\n    subreddit: str\n    title: str\n    body: str",
                "id: str",
                "subreddit: str",
                "title: str",
                "body: str",
                "class RedditComment(BaseModel):\n    post_id: str\n    comment: str",
                "post_id: str",
                "comment: str",
                "def get_praw(creds: RedditCredentials) -> praw.Reddit:\n    client = praw.Reddit(client_id=creds.client_id.get_secret_value(), client_secret=creds.client_secret.get_secret_value(), username=creds.username.get_secret_value(), password=creds.password.get_secret_value(), user_agent=creds.user_agent)\n    me = client.user.me()\n    if not me:\n        raise ValueError('Invalid Reddit credentials.')\n    print(f'Logged in as Reddit user: {me.name}')\n    return client",
                "client = praw.Reddit(client_id=creds.client_id.get_secret_value(), client_secret=creds.client_secret.get_secret_value(), username=creds.username.get_secret_value(), password=creds.password.get_secret_value(), user_agent=creds.user_agent)",
                "me = client.user.me()",
                "not me"
            ]
        },
        {
            "id": "2",
            "type": "block",
            "statements": [
                "raise ValueError('Invalid Reddit credentials.')"
            ]
        },
        {
            "id": "3",
            "type": "block",
            "statements": []
        },
        {
            "id": "4",
            "type": "block",
            "statements": [
                "print(f'Logged in as Reddit user: {me.name}')",
                "return client"
            ]
        },
        {
            "id": "5",
            "type": "block",
            "statements": [
                "class GetRedditPostsBlock(Block):\n\n    class Input(BlockSchema):\n        subreddit: str = SchemaField(description='Subreddit name')\n        creds: RedditCredentials = SchemaField(description='Reddit credentials', default=RedditCredentials())\n        last_minutes: int | None = SchemaField(description='Post time to stop minutes ago while fetching posts', default=None)\n        last_post: str | None = SchemaField(description='Post ID to stop when reached while fetching posts', default=None)\n        post_limit: int | None = SchemaField(description='Number of posts to fetch', default=10)\n\n    class Output(BlockSchema):\n        post: RedditPost = SchemaField(description='Reddit post')\n\n    def __init__(self):\n        super().__init__(disabled=True, id='c6731acb-4285-4ee1-bc9b-03d0766c370f', description='This block fetches Reddit posts from a defined subreddit name.', categories={BlockCategory.SOCIAL}, input_schema=GetRedditPostsBlock.Input, output_schema=GetRedditPostsBlock.Output, test_input={'creds': {'client_id': 'client_id', 'client_secret': 'client_secret', 'username': 'username', 'password': 'password', 'user_agent': 'user_agent'}, 'subreddit': 'subreddit', 'last_post': 'id3', 'post_limit': 2}, test_output=[('post', RedditPost(id='id1', subreddit='subreddit', title='title1', body='body1')), ('post', RedditPost(id='id2', subreddit='subreddit', title='title2', body='body2'))], test_mock={'get_posts': lambda _: [MockObject(id='id1', title='title1', selftext='body1'), MockObject(id='id2', title='title2', selftext='body2'), MockObject(id='id3', title='title2', selftext='body2')]})\n\n    @staticmethod\n    def get_posts(input_data: Input) -> Iterator[praw.reddit.Submission]:\n        client = get_praw(input_data.creds)\n        subreddit = client.subreddit(input_data.subreddit)\n        return subreddit.new(limit=input_data.post_limit or 10)\n\n    def run(self, input_data: Input, **kwargs) -> BlockOutput:\n        current_time = datetime.now(tz=timezone.utc)\n        for post in self.get_posts(input_data):\n            if input_data.last_minutes:\n                post_datetime = datetime.fromtimestamp(post.created_utc, tz=timezone.utc)\n                time_difference = current_time - post_datetime\n                if time_difference.total_seconds() / 60 > input_data.last_minutes:\n                    continue\n            if input_data.last_post and post.id == input_data.last_post:\n                break\n            yield ('post', RedditPost(id=post.id, subreddit=input_data.subreddit, title=post.title, body=post.selftext))",
                "class Input(BlockSchema):\n    subreddit: str = SchemaField(description='Subreddit name')\n    creds: RedditCredentials = SchemaField(description='Reddit credentials', default=RedditCredentials())\n    last_minutes: int | None = SchemaField(description='Post time to stop minutes ago while fetching posts', default=None)\n    last_post: str | None = SchemaField(description='Post ID to stop when reached while fetching posts', default=None)\n    post_limit: int | None = SchemaField(description='Number of posts to fetch', default=10)",
                "subreddit: str = SchemaField(description='Subreddit name')",
                "creds: RedditCredentials = SchemaField(description='Reddit credentials', default=RedditCredentials())",
                "last_minutes: int | None = SchemaField(description='Post time to stop minutes ago while fetching posts', default=None)",
                "last_post: str | None = SchemaField(description='Post ID to stop when reached while fetching posts', default=None)",
                "post_limit: int | None = SchemaField(description='Number of posts to fetch', default=10)",
                "class Output(BlockSchema):\n    post: RedditPost = SchemaField(description='Reddit post')",
                "post: RedditPost = SchemaField(description='Reddit post')",
                "def __init__(self):\n    super().__init__(disabled=True, id='c6731acb-4285-4ee1-bc9b-03d0766c370f', description='This block fetches Reddit posts from a defined subreddit name.', categories={BlockCategory.SOCIAL}, input_schema=GetRedditPostsBlock.Input, output_schema=GetRedditPostsBlock.Output, test_input={'creds': {'client_id': 'client_id', 'client_secret': 'client_secret', 'username': 'username', 'password': 'password', 'user_agent': 'user_agent'}, 'subreddit': 'subreddit', 'last_post': 'id3', 'post_limit': 2}, test_output=[('post', RedditPost(id='id1', subreddit='subreddit', title='title1', body='body1')), ('post', RedditPost(id='id2', subreddit='subreddit', title='title2', body='body2'))], test_mock={'get_posts': lambda _: [MockObject(id='id1', title='title1', selftext='body1'), MockObject(id='id2', title='title2', selftext='body2'), MockObject(id='id3', title='title2', selftext='body2')]})",
                "super().__init__()",
                "@staticmethod\ndef get_posts(input_data: Input) -> Iterator[praw.reddit.Submission]:\n    client = get_praw(input_data.creds)\n    subreddit = client.subreddit(input_data.subreddit)\n    return subreddit.new(limit=input_data.post_limit or 10)",
                "client = get_praw(input_data.creds)",
                "subreddit = client.subreddit(input_data.subreddit)",
                "return subreddit.new(limit=input_data.post_limit or 10)"
            ]
        },
        {
            "id": "6",
            "type": "block",
            "statements": [
                "def run(self, input_data: Input, **kwargs) -> BlockOutput:\n    current_time = datetime.now(tz=timezone.utc)\n    for post in self.get_posts(input_data):\n        if input_data.last_minutes:\n            post_datetime = datetime.fromtimestamp(post.created_utc, tz=timezone.utc)\n            time_difference = current_time - post_datetime\n            if time_difference.total_seconds() / 60 > input_data.last_minutes:\n                continue\n        if input_data.last_post and post.id == input_data.last_post:\n            break\n        yield ('post', RedditPost(id=post.id, subreddit=input_data.subreddit, title=post.title, body=post.selftext))",
                "current_time = datetime.now(tz=timezone.utc)"
            ]
        },
        {
            "id": "7",
            "type": "block",
            "statements": [
                "post",
                "self.get_posts(input_data)"
            ]
        },
        {
            "id": "8",
            "type": "block",
            "statements": [
                "input_data.last_minutes"
            ]
        },
        {
            "id": "9",
            "type": "block",
            "statements": [
                "class PostRedditCommentBlock(Block):\n\n    class Input(BlockSchema):\n        creds: RedditCredentials = SchemaField(description='Reddit credentials', default=RedditCredentials())\n        data: RedditComment = SchemaField(description='Reddit comment')\n\n    class Output(BlockSchema):\n        comment_id: str = SchemaField(description='Posted comment ID')\n\n    def __init__(self):\n        super().__init__(id='4a92261b-701e-4ffb-8970-675fd28e261f', description='This block posts a Reddit comment on a specified Reddit post.', categories={BlockCategory.SOCIAL}, input_schema=PostRedditCommentBlock.Input, output_schema=PostRedditCommentBlock.Output, test_input={'data': {'post_id': 'id', 'comment': 'comment'}}, test_output=[('comment_id', 'dummy_comment_id')], test_mock={'reply_post': lambda creds, comment: 'dummy_comment_id'})\n\n    @staticmethod\n    def reply_post(creds: RedditCredentials, comment: RedditComment) -> str:\n        client = get_praw(creds)\n        submission = client.submission(id=comment.post_id)\n        new_comment = submission.reply(comment.comment)\n        if not new_comment:\n            raise ValueError('Failed to post comment.')\n        return new_comment.id\n\n    def run(self, input_data: Input, **kwargs) -> BlockOutput:\n        yield ('comment_id', self.reply_post(input_data.creds, input_data.data))",
                "class Input(BlockSchema):\n    creds: RedditCredentials = SchemaField(description='Reddit credentials', default=RedditCredentials())\n    data: RedditComment = SchemaField(description='Reddit comment')",
                "creds: RedditCredentials = SchemaField(description='Reddit credentials', default=RedditCredentials())",
                "data: RedditComment = SchemaField(description='Reddit comment')",
                "class Output(BlockSchema):\n    comment_id: str = SchemaField(description='Posted comment ID')",
                "comment_id: str = SchemaField(description='Posted comment ID')",
                "def __init__(self):\n    super().__init__(id='4a92261b-701e-4ffb-8970-675fd28e261f', description='This block posts a Reddit comment on a specified Reddit post.', categories={BlockCategory.SOCIAL}, input_schema=PostRedditCommentBlock.Input, output_schema=PostRedditCommentBlock.Output, test_input={'data': {'post_id': 'id', 'comment': 'comment'}}, test_output=[('comment_id', 'dummy_comment_id')], test_mock={'reply_post': lambda creds, comment: 'dummy_comment_id'})",
                "super().__init__()",
                "@staticmethod\ndef reply_post(creds: RedditCredentials, comment: RedditComment) -> str:\n    client = get_praw(creds)\n    submission = client.submission(id=comment.post_id)\n    new_comment = submission.reply(comment.comment)\n    if not new_comment:\n        raise ValueError('Failed to post comment.')\n    return new_comment.id",
                "client = get_praw(creds)",
                "submission = client.submission(id=comment.post_id)",
                "new_comment = submission.reply(comment.comment)",
                "not new_comment"
            ]
        },
        {
            "id": "10",
            "type": "block",
            "statements": [
                "post_datetime = datetime.fromtimestamp(post.created_utc, tz=timezone.utc)",
                "time_difference = current_time - post_datetime",
                "time_difference.total_seconds() Div 60 Gt input_data.last_minutes"
            ]
        },
        {
            "id": "11",
            "type": "block",
            "statements": []
        },
        {
            "id": "12",
            "type": "block",
            "statements": [
                "input_data.last_post and post.id == input_data.last_post"
            ]
        },
        {
            "id": "13",
            "type": "block",
            "statements": [
                "continue"
            ]
        },
        {
            "id": "14",
            "type": "block",
            "statements": []
        },
        {
            "id": "15",
            "type": "block",
            "statements": []
        },
        {
            "id": "16",
            "type": "block",
            "statements": [
                "break"
            ]
        },
        {
            "id": "17",
            "type": "block",
            "statements": []
        },
        {
            "id": "18",
            "type": "block",
            "statements": [
                "(yield ('post', RedditPost(id=post.id, subreddit=input_data.subreddit, title=post.title, body=post.selftext)))"
            ]
        },
        {
            "id": "19",
            "type": "block",
            "statements": [
                "raise ValueError('Failed to post comment.')"
            ]
        },
        {
            "id": "20",
            "type": "block",
            "statements": []
        },
        {
            "id": "21",
            "type": "block",
            "statements": [
                "return new_comment.id"
            ]
        },
        {
            "id": "22",
            "type": "block",
            "statements": [
                "def run(self, input_data: Input, **kwargs) -> BlockOutput:\n    yield ('comment_id', self.reply_post(input_data.creds, input_data.data))",
                "(yield ('comment_id', self.reply_post(input_data.creds, input_data.data)))"
            ]
        }
    ],
    "edges": [
        {
            "source": "1",
            "target": "2",
            "type": "true"
        },
        {
            "source": "1",
            "target": "3",
            "type": "false"
        },
        {
            "source": "2",
            "target": "4",
            "type": "next"
        },
        {
            "source": "3",
            "target": "4",
            "type": "next"
        },
        {
            "source": "6",
            "target": "7",
            "type": "next"
        },
        {
            "source": "7",
            "target": "8",
            "type": "true"
        },
        {
            "source": "7",
            "target": "9",
            "type": "false"
        },
        {
            "source": "8",
            "target": "10",
            "type": "true"
        },
        {
            "source": "8",
            "target": "11",
            "type": "false"
        },
        {
            "source": "9",
            "target": "19",
            "type": "true"
        },
        {
            "source": "9",
            "target": "20",
            "type": "false"
        },
        {
            "source": "10",
            "target": "13",
            "type": "true"
        },
        {
            "source": "10",
            "target": "14",
            "type": "false"
        },
        {
            "source": "11",
            "target": "12",
            "type": "next"
        },
        {
            "source": "12",
            "target": "16",
            "type": "true"
        },
        {
            "source": "12",
            "target": "17",
            "type": "false"
        },
        {
            "source": "13",
            "target": "15",
            "type": "next"
        },
        {
            "source": "14",
            "target": "15",
            "type": "next"
        },
        {
            "source": "15",
            "target": "12",
            "type": "next"
        },
        {
            "source": "16",
            "target": "18",
            "type": "next"
        },
        {
            "source": "17",
            "target": "18",
            "type": "next"
        },
        {
            "source": "18",
            "target": "7",
            "type": "next"
        },
        {
            "source": "19",
            "target": "21",
            "type": "next"
        },
        {
            "source": "20",
            "target": "21",
            "type": "next"
        }
    ]
}