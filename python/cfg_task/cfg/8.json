{
    "nodes": [
        {
            "id": "1",
            "type": "block",
            "statements": [
                "import logging",
                "from autogpt_libs.utils.cache import thread_cached",
                "from backend.data.block import Block, BlockCategory, BlockInput, BlockOutput, BlockSchema, BlockType, get_block",
                "from backend.data.execution import ExecutionStatus",
                "from backend.data.model import SchemaField",
                "logger = logging.getLogger(__name__)",
                "@thread_cached\ndef get_executor_manager_client():\n    from backend.executor import ExecutionManager\n    from backend.util.service import get_service_client\n    return get_service_client(ExecutionManager)",
                "from backend.executor import ExecutionManager",
                "from backend.util.service import get_service_client",
                "return get_service_client(ExecutionManager)"
            ]
        },
        {
            "id": "2",
            "type": "block",
            "statements": [
                "@thread_cached\ndef get_event_bus():\n    from backend.data.execution import RedisExecutionEventBus\n    return RedisExecutionEventBus()",
                "from backend.data.execution import RedisExecutionEventBus",
                "return RedisExecutionEventBus()"
            ]
        },
        {
            "id": "3",
            "type": "block",
            "statements": [
                "class AgentExecutorBlock(Block):\n\n    class Input(BlockSchema):\n        user_id: str = SchemaField(description='User ID')\n        graph_id: str = SchemaField(description='Graph ID')\n        graph_version: int = SchemaField(description='Graph Version')\n        data: BlockInput = SchemaField(description='Input data for the graph')\n        input_schema: dict = SchemaField(description='Input schema for the graph')\n        output_schema: dict = SchemaField(description='Output schema for the graph')\n\n    class Output(BlockSchema):\n        pass\n\n    def __init__(self):\n        super().__init__(id='e189baac-8c20-45a1-94a7-55177ea42565', description='Executes an existing agent inside your agent', input_schema=AgentExecutorBlock.Input, output_schema=AgentExecutorBlock.Output, block_type=BlockType.AGENT, categories={BlockCategory.AGENT})\n\n    def run(self, input_data: Input, **kwargs) -> BlockOutput:\n        executor_manager = get_executor_manager_client()\n        event_bus = get_event_bus()\n        graph_exec = executor_manager.add_execution(graph_id=input_data.graph_id, graph_version=input_data.graph_version, user_id=input_data.user_id, data=input_data.data)\n        log_id = f'Graph #{input_data.graph_id}-V{input_data.graph_version}, exec-id: {graph_exec.graph_exec_id}'\n        logger.info(f'Starting execution of {log_id}')\n        for event in event_bus.listen(graph_id=graph_exec.graph_id, graph_exec_id=graph_exec.graph_exec_id):\n            logger.info(f'Execution {log_id} produced input {event.input_data} output {event.output_data}')\n            if not event.node_id:\n                if event.status in [ExecutionStatus.COMPLETED, ExecutionStatus.FAILED]:\n                    logger.info(f'Execution {log_id} ended with status {event.status}')\n                    break\n                else:\n                    continue\n            if not event.block_id:\n                logger.warning(f'{log_id} received event without block_id {event}')\n                continue\n            block = get_block(event.block_id)\n            if not block or block.block_type != BlockType.OUTPUT:\n                continue\n            output_name = event.input_data.get('name')\n            if not output_name:\n                logger.warning(f'{log_id} produced an output with no name {event}')\n                continue\n            for output_data in event.output_data.get('output', []):\n                logger.info(f'Execution {log_id} produced {output_name}: {output_data}')\n                yield (output_name, output_data)",
                "class Input(BlockSchema):\n    user_id: str = SchemaField(description='User ID')\n    graph_id: str = SchemaField(description='Graph ID')\n    graph_version: int = SchemaField(description='Graph Version')\n    data: BlockInput = SchemaField(description='Input data for the graph')\n    input_schema: dict = SchemaField(description='Input schema for the graph')\n    output_schema: dict = SchemaField(description='Output schema for the graph')",
                "user_id: str = SchemaField(description='User ID')",
                "graph_id: str = SchemaField(description='Graph ID')",
                "graph_version: int = SchemaField(description='Graph Version')",
                "data: BlockInput = SchemaField(description='Input data for the graph')",
                "input_schema: dict = SchemaField(description='Input schema for the graph')",
                "output_schema: dict = SchemaField(description='Output schema for the graph')",
                "class Output(BlockSchema):\n    pass",
                "pass",
                "def __init__(self):\n    super().__init__(id='e189baac-8c20-45a1-94a7-55177ea42565', description='Executes an existing agent inside your agent', input_schema=AgentExecutorBlock.Input, output_schema=AgentExecutorBlock.Output, block_type=BlockType.AGENT, categories={BlockCategory.AGENT})",
                "super().__init__()",
                "def run(self, input_data: Input, **kwargs) -> BlockOutput:\n    executor_manager = get_executor_manager_client()\n    event_bus = get_event_bus()\n    graph_exec = executor_manager.add_execution(graph_id=input_data.graph_id, graph_version=input_data.graph_version, user_id=input_data.user_id, data=input_data.data)\n    log_id = f'Graph #{input_data.graph_id}-V{input_data.graph_version}, exec-id: {graph_exec.graph_exec_id}'\n    logger.info(f'Starting execution of {log_id}')\n    for event in event_bus.listen(graph_id=graph_exec.graph_id, graph_exec_id=graph_exec.graph_exec_id):\n        logger.info(f'Execution {log_id} produced input {event.input_data} output {event.output_data}')\n        if not event.node_id:\n            if event.status in [ExecutionStatus.COMPLETED, ExecutionStatus.FAILED]:\n                logger.info(f'Execution {log_id} ended with status {event.status}')\n                break\n            else:\n                continue\n        if not event.block_id:\n            logger.warning(f'{log_id} received event without block_id {event}')\n            continue\n        block = get_block(event.block_id)\n        if not block or block.block_type != BlockType.OUTPUT:\n            continue\n        output_name = event.input_data.get('name')\n        if not output_name:\n            logger.warning(f'{log_id} produced an output with no name {event}')\n            continue\n        for output_data in event.output_data.get('output', []):\n            logger.info(f'Execution {log_id} produced {output_name}: {output_data}')\n            yield (output_name, output_data)",
                "executor_manager = get_executor_manager_client()",
                "event_bus = get_event_bus()",
                "graph_exec = executor_manager.add_execution(graph_id=input_data.graph_id, graph_version=input_data.graph_version, user_id=input_data.user_id, data=input_data.data)",
                "log_id = f'Graph #{input_data.graph_id}-V{input_data.graph_version}, exec-id: {graph_exec.graph_exec_id}'",
                "logger.info(f'Starting execution of {log_id}')"
            ]
        },
        {
            "id": "4",
            "type": "block",
            "statements": [
                "event",
                "event_bus.listen()"
            ]
        },
        {
            "id": "5",
            "type": "block",
            "statements": [
                "logger.info(f'Execution {log_id} produced input {event.input_data} output {event.output_data}')",
                "not event.node_id"
            ]
        },
        {
            "id": "6",
            "type": "block",
            "statements": []
        },
        {
            "id": "7",
            "type": "block",
            "statements": [
                "event.status In [ExecutionStatus.COMPLETED, ExecutionStatus.FAILED]"
            ]
        },
        {
            "id": "8",
            "type": "block",
            "statements": []
        },
        {
            "id": "9",
            "type": "block",
            "statements": [
                "not event.block_id"
            ]
        },
        {
            "id": "10",
            "type": "block",
            "statements": [
                "logger.info(f'Execution {log_id} ended with status {event.status}')",
                "break"
            ]
        },
        {
            "id": "11",
            "type": "block",
            "statements": [
                "continue"
            ]
        },
        {
            "id": "12",
            "type": "block",
            "statements": []
        },
        {
            "id": "13",
            "type": "block",
            "statements": [
                "logger.warning(f'{log_id} received event without block_id {event}')",
                "continue"
            ]
        },
        {
            "id": "14",
            "type": "block",
            "statements": []
        },
        {
            "id": "15",
            "type": "block",
            "statements": [
                "block = get_block(event.block_id)",
                "not block or block.block_type != BlockType.OUTPUT"
            ]
        },
        {
            "id": "16",
            "type": "block",
            "statements": [
                "continue"
            ]
        },
        {
            "id": "17",
            "type": "block",
            "statements": []
        },
        {
            "id": "18",
            "type": "block",
            "statements": [
                "output_name = event.input_data.get('name')",
                "not output_name"
            ]
        },
        {
            "id": "19",
            "type": "block",
            "statements": [
                "logger.warning(f'{log_id} produced an output with no name {event}')",
                "continue"
            ]
        },
        {
            "id": "20",
            "type": "block",
            "statements": []
        },
        {
            "id": "21",
            "type": "block",
            "statements": []
        },
        {
            "id": "22",
            "type": "block",
            "statements": [
                "output_data",
                "event.output_data.get('output', [])"
            ]
        },
        {
            "id": "23",
            "type": "block",
            "statements": [
                "logger.info(f'Execution {log_id} produced {output_name}: {output_data}')",
                "(yield (output_name, output_data))"
            ]
        },
        {
            "id": "24",
            "type": "block",
            "statements": []
        }
    ],
    "edges": [
        {
            "source": "3",
            "target": "4",
            "type": "next"
        },
        {
            "source": "4",
            "target": "5",
            "type": "true"
        },
        {
            "source": "4",
            "target": "6",
            "type": "false"
        },
        {
            "source": "5",
            "target": "7",
            "type": "true"
        },
        {
            "source": "5",
            "target": "8",
            "type": "false"
        },
        {
            "source": "7",
            "target": "10",
            "type": "true"
        },
        {
            "source": "7",
            "target": "11",
            "type": "false"
        },
        {
            "source": "8",
            "target": "9",
            "type": "next"
        },
        {
            "source": "9",
            "target": "13",
            "type": "true"
        },
        {
            "source": "9",
            "target": "14",
            "type": "false"
        },
        {
            "source": "10",
            "target": "12",
            "type": "next"
        },
        {
            "source": "11",
            "target": "12",
            "type": "next"
        },
        {
            "source": "12",
            "target": "9",
            "type": "next"
        },
        {
            "source": "13",
            "target": "15",
            "type": "next"
        },
        {
            "source": "14",
            "target": "15",
            "type": "next"
        },
        {
            "source": "15",
            "target": "16",
            "type": "true"
        },
        {
            "source": "15",
            "target": "17",
            "type": "false"
        },
        {
            "source": "16",
            "target": "18",
            "type": "next"
        },
        {
            "source": "17",
            "target": "18",
            "type": "next"
        },
        {
            "source": "18",
            "target": "19",
            "type": "true"
        },
        {
            "source": "18",
            "target": "20",
            "type": "false"
        },
        {
            "source": "19",
            "target": "21",
            "type": "next"
        },
        {
            "source": "20",
            "target": "21",
            "type": "next"
        },
        {
            "source": "21",
            "target": "22",
            "type": "next"
        },
        {
            "source": "22",
            "target": "23",
            "type": "true"
        },
        {
            "source": "22",
            "target": "24",
            "type": "false"
        },
        {
            "source": "23",
            "target": "22",
            "type": "next"
        },
        {
            "source": "24",
            "target": "4",
            "type": "next"
        }
    ]
}