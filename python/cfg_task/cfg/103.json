{
    "nodes": [
        {
            "id": "1",
            "type": "block",
            "statements": [
                "import secrets",
                "from datetime import datetime, timedelta, timezone",
                "from typing import TYPE_CHECKING",
                "from pydantic import SecretStr",
                "TYPE_CHECKING"
            ]
        },
        {
            "id": "2",
            "type": "block",
            "statements": [
                "from backend.executor.database import DatabaseManager"
            ]
        },
        {
            "id": "3",
            "type": "block",
            "statements": []
        },
        {
            "id": "4",
            "type": "block",
            "statements": [
                "from autogpt_libs.utils.cache import thread_cached",
                "from autogpt_libs.utils.synchronize import RedisKeyedMutex",
                "from backend.data.model import APIKeyCredentials, Credentials, OAuth2Credentials, OAuthState, UserIntegrations",
                "from backend.util.settings import Settings",
                "settings = Settings()",
                "revid_credentials = APIKeyCredentials(id='fdb7f412-f519-48d1-9b5f-d2f73d0e01fe', provider='revid', api_key=SecretStr(settings.secrets.revid_api_key), title='Use Credits for Revid', expires_at=None)",
                "ideogram_credentials = APIKeyCredentials(id='760f84fc-b270-42de-91f6-08efe1b512d0', provider='ideogram', api_key=SecretStr(settings.secrets.ideogram_api_key), title='Use Credits for Ideogram', expires_at=None)",
                "replicate_credentials = APIKeyCredentials(id='6b9fc200-4726-4973-86c9-cd526f5ce5db', provider='replicate', api_key=SecretStr(settings.secrets.replicate_api_key), title='Use Credits for Replicate', expires_at=None)",
                "openai_credentials = APIKeyCredentials(id='53c25cb8-e3ee-465c-a4d1-e75a4c899c2a', provider='openai', api_key=SecretStr(settings.secrets.openai_api_key), title='Use Credits for OpenAI', expires_at=None)",
                "anthropic_credentials = APIKeyCredentials(id='24e5d942-d9e3-4798-8151-90143ee55629', provider='anthropic', api_key=SecretStr(settings.secrets.anthropic_api_key), title='Use Credits for Anthropic', expires_at=None)",
                "groq_credentials = APIKeyCredentials(id='4ec22295-8f97-4dd1-b42b-2c6957a02545', provider='groq', api_key=SecretStr(settings.secrets.groq_api_key), title='Use Credits for Groq', expires_at=None)",
                "did_credentials = APIKeyCredentials(id='7f7b0654-c36b-4565-8fa7-9a52575dfae2', provider='d_id', api_key=SecretStr(settings.secrets.did_api_key), title='Use Credits for D-ID', expires_at=None)",
                "jina_credentials = APIKeyCredentials(id='7f26de70-ba0d-494e-ba76-238e65e7b45f', provider='jina', api_key=SecretStr(settings.secrets.jina_api_key), title='Use Credits for Jina', expires_at=None)",
                "unreal_credentials = APIKeyCredentials(id='66f20754-1b81-48e4-91d0-f4f0dd82145f', provider='unreal', api_key=SecretStr(settings.secrets.unreal_speech_api_key), title='Use Credits for Unreal', expires_at=None)",
                "open_router_credentials = APIKeyCredentials(id='b5a0e27d-0c98-4df3-a4b9-10193e1f3c40', provider='open_router', api_key=SecretStr(settings.secrets.open_router_api_key), title='Use Credits for Open Router', expires_at=None)",
                "DEFAULT_CREDENTIALS = [revid_credentials, ideogram_credentials, replicate_credentials, openai_credentials, anthropic_credentials, groq_credentials, did_credentials, jina_credentials, unreal_credentials, open_router_credentials]",
                "class IntegrationCredentialsStore:\n\n    def __init__(self):\n        from backend.data.redis import get_redis\n        self.locks = RedisKeyedMutex(get_redis())\n\n    @property\n    @thread_cached\n    def db_manager(self) -> 'DatabaseManager':\n        from backend.executor.database import DatabaseManager\n        from backend.util.service import get_service_client\n        return get_service_client(DatabaseManager)\n\n    def add_creds(self, user_id: str, credentials: Credentials) -> None:\n        with self.locked_user_integrations(user_id):\n            if self.get_creds_by_id(user_id, credentials.id):\n                raise ValueError(f'Can not re-create existing credentials #{credentials.id} for user #{user_id}')\n            self._set_user_integration_creds(user_id, [*self.get_all_creds(user_id), credentials])\n\n    def get_all_creds(self, user_id: str) -> list[Credentials]:\n        users_credentials = self._get_user_integrations(user_id).credentials\n        all_credentials = users_credentials\n        if settings.secrets.revid_api_key:\n            all_credentials.append(revid_credentials)\n        if settings.secrets.ideogram_api_key:\n            all_credentials.append(ideogram_credentials)\n        if settings.secrets.groq_api_key:\n            all_credentials.append(groq_credentials)\n        if settings.secrets.replicate_api_key:\n            all_credentials.append(replicate_credentials)\n        if settings.secrets.openai_api_key:\n            all_credentials.append(openai_credentials)\n        if settings.secrets.anthropic_api_key:\n            all_credentials.append(anthropic_credentials)\n        if settings.secrets.did_api_key:\n            all_credentials.append(did_credentials)\n        if settings.secrets.jina_api_key:\n            all_credentials.append(jina_credentials)\n        if settings.secrets.unreal_speech_api_key:\n            all_credentials.append(unreal_credentials)\n        if settings.secrets.open_router_api_key:\n            all_credentials.append(open_router_credentials)\n        return all_credentials\n\n    def get_creds_by_id(self, user_id: str, credentials_id: str) -> Credentials | None:\n        all_credentials = self.get_all_creds(user_id)\n        return next((c for c in all_credentials if c.id == credentials_id), None)\n\n    def get_creds_by_provider(self, user_id: str, provider: str) -> list[Credentials]:\n        credentials = self.get_all_creds(user_id)\n        return [c for c in credentials if c.provider == provider]\n\n    def get_authorized_providers(self, user_id: str) -> list[str]:\n        credentials = self.get_all_creds(user_id)\n        return list(set((c.provider for c in credentials)))\n\n    def update_creds(self, user_id: str, updated: Credentials) -> None:\n        with self.locked_user_integrations(user_id):\n            current = self.get_creds_by_id(user_id, updated.id)\n            if not current:\n                raise ValueError(f'Credentials with ID {updated.id} for user with ID {user_id} not found')\n            if type(current) is not type(updated):\n                raise TypeError(f'Can not update credentials with ID {updated.id} from type {type(current)} to type {type(updated)}')\n            if isinstance(updated, OAuth2Credentials) and isinstance(current, OAuth2Credentials) and (not set(updated.scopes).issuperset(current.scopes)):\n                raise ValueError(f'Can not update credentials with ID {updated.id} and scopes {current.scopes} to more restrictive set of scopes {updated.scopes}')\n            updated_credentials_list = [updated if c.id == updated.id else c for c in self.get_all_creds(user_id)]\n            self._set_user_integration_creds(user_id, updated_credentials_list)\n\n    def delete_creds_by_id(self, user_id: str, credentials_id: str) -> None:\n        with self.locked_user_integrations(user_id):\n            filtered_credentials = [c for c in self.get_all_creds(user_id) if c.id != credentials_id]\n            self._set_user_integration_creds(user_id, filtered_credentials)\n\n    def store_state_token(self, user_id: str, provider: str, scopes: list[str]) -> str:\n        token = secrets.token_urlsafe(32)\n        expires_at = datetime.now(timezone.utc) + timedelta(minutes=10)\n        state = OAuthState(token=token, provider=provider, expires_at=int(expires_at.timestamp()), scopes=scopes)\n        with self.locked_user_integrations(user_id):\n            user_integrations = self._get_user_integrations(user_id)\n            oauth_states = user_integrations.oauth_states\n            oauth_states.append(state)\n            user_integrations.oauth_states = oauth_states\n            self.db_manager.update_user_integrations(user_id=user_id, data=user_integrations)\n        return token\n\n    def get_any_valid_scopes_from_state_token(self, user_id: str, token: str, provider: str) -> list[str]:\n        \"\"\"\n        Get the valid scopes from the OAuth state token. This will return any valid scopes\n        from any OAuth state token for the given provider. If no valid scopes are found,\n        an empty list is returned. DO NOT RELY ON THIS TOKEN TO AUTHENTICATE A USER, AS IT\n        IS TO CHECK IF THE USER HAS GIVEN PERMISSIONS TO THE APPLICATION BEFORE EXCHANGING\n        THE CODE FOR TOKENS.\n        \"\"\"\n        user_integrations = self._get_user_integrations(user_id)\n        oauth_states = user_integrations.oauth_states\n        now = datetime.now(timezone.utc)\n        valid_state = next((state for state in oauth_states if state.token == token and state.provider == provider and (state.expires_at > now.timestamp())), None)\n        if valid_state:\n            return valid_state.scopes\n        return []\n\n    def verify_state_token(self, user_id: str, token: str, provider: str) -> bool:\n        with self.locked_user_integrations(user_id):\n            user_integrations = self._get_user_integrations(user_id)\n            oauth_states = user_integrations.oauth_states\n            now = datetime.now(timezone.utc)\n            valid_state = next((state for state in oauth_states if state.token == token and state.provider == provider and (state.expires_at > now.timestamp())), None)\n            if valid_state:\n                oauth_states.remove(valid_state)\n                user_integrations.oauth_states = oauth_states\n                self.db_manager.update_user_integrations(user_id, user_integrations)\n                return True\n        return False\n\n    def _set_user_integration_creds(self, user_id: str, credentials: list[Credentials]) -> None:\n        integrations = self._get_user_integrations(user_id)\n        credentials = [c for c in credentials if c not in DEFAULT_CREDENTIALS]\n        integrations.credentials = credentials\n        self.db_manager.update_user_integrations(user_id, integrations)\n\n    def _get_user_integrations(self, user_id: str) -> UserIntegrations:\n        integrations: UserIntegrations = self.db_manager.get_user_integrations(user_id=user_id)\n        return integrations\n\n    def locked_user_integrations(self, user_id: str):\n        key = (f'user:{user_id}', 'integrations')\n        return self.locks.locked(key)",
                "def __init__(self):\n    from backend.data.redis import get_redis\n    self.locks = RedisKeyedMutex(get_redis())",
                "from backend.data.redis import get_redis",
                "self.locks = RedisKeyedMutex(get_redis())",
                "@property\n@thread_cached\ndef db_manager(self) -> 'DatabaseManager':\n    from backend.executor.database import DatabaseManager\n    from backend.util.service import get_service_client\n    return get_service_client(DatabaseManager)",
                "from backend.executor.database import DatabaseManager",
                "from backend.util.service import get_service_client",
                "return get_service_client(DatabaseManager)"
            ]
        },
        {
            "id": "5",
            "type": "block",
            "statements": [
                "def add_creds(self, user_id: str, credentials: Credentials) -> None:\n    with self.locked_user_integrations(user_id):\n        if self.get_creds_by_id(user_id, credentials.id):\n            raise ValueError(f'Can not re-create existing credentials #{credentials.id} for user #{user_id}')\n        self._set_user_integration_creds(user_id, [*self.get_all_creds(user_id), credentials])",
                "with self.locked_user_integrations(user_id):\n    if self.get_creds_by_id(user_id, credentials.id):\n        raise ValueError(f'Can not re-create existing credentials #{credentials.id} for user #{user_id}')\n    self._set_user_integration_creds(user_id, [*self.get_all_creds(user_id), credentials])",
                "self.get_creds_by_id(user_id, credentials.id)"
            ]
        },
        {
            "id": "6",
            "type": "block",
            "statements": [
                "raise ValueError(f'Can not re-create existing credentials #{credentials.id} for user #{user_id}')"
            ]
        },
        {
            "id": "7",
            "type": "block",
            "statements": []
        },
        {
            "id": "8",
            "type": "block",
            "statements": [
                "self._set_user_integration_creds(user_id, [*self.get_all_creds(user_id), credentials])",
                "def get_all_creds(self, user_id: str) -> list[Credentials]:\n    users_credentials = self._get_user_integrations(user_id).credentials\n    all_credentials = users_credentials\n    if settings.secrets.revid_api_key:\n        all_credentials.append(revid_credentials)\n    if settings.secrets.ideogram_api_key:\n        all_credentials.append(ideogram_credentials)\n    if settings.secrets.groq_api_key:\n        all_credentials.append(groq_credentials)\n    if settings.secrets.replicate_api_key:\n        all_credentials.append(replicate_credentials)\n    if settings.secrets.openai_api_key:\n        all_credentials.append(openai_credentials)\n    if settings.secrets.anthropic_api_key:\n        all_credentials.append(anthropic_credentials)\n    if settings.secrets.did_api_key:\n        all_credentials.append(did_credentials)\n    if settings.secrets.jina_api_key:\n        all_credentials.append(jina_credentials)\n    if settings.secrets.unreal_speech_api_key:\n        all_credentials.append(unreal_credentials)\n    if settings.secrets.open_router_api_key:\n        all_credentials.append(open_router_credentials)\n    return all_credentials",
                "users_credentials = self._get_user_integrations(user_id).credentials",
                "all_credentials = users_credentials",
                "settings.secrets.revid_api_key"
            ]
        },
        {
            "id": "9",
            "type": "block",
            "statements": [
                "all_credentials.append(revid_credentials)"
            ]
        },
        {
            "id": "10",
            "type": "block",
            "statements": []
        },
        {
            "id": "11",
            "type": "block",
            "statements": [
                "settings.secrets.ideogram_api_key"
            ]
        },
        {
            "id": "12",
            "type": "block",
            "statements": [
                "all_credentials.append(ideogram_credentials)"
            ]
        },
        {
            "id": "13",
            "type": "block",
            "statements": []
        },
        {
            "id": "14",
            "type": "block",
            "statements": [
                "settings.secrets.groq_api_key"
            ]
        },
        {
            "id": "15",
            "type": "block",
            "statements": [
                "all_credentials.append(groq_credentials)"
            ]
        },
        {
            "id": "16",
            "type": "block",
            "statements": []
        },
        {
            "id": "17",
            "type": "block",
            "statements": [
                "settings.secrets.replicate_api_key"
            ]
        },
        {
            "id": "18",
            "type": "block",
            "statements": [
                "all_credentials.append(replicate_credentials)"
            ]
        },
        {
            "id": "19",
            "type": "block",
            "statements": []
        },
        {
            "id": "20",
            "type": "block",
            "statements": [
                "settings.secrets.openai_api_key"
            ]
        },
        {
            "id": "21",
            "type": "block",
            "statements": [
                "all_credentials.append(openai_credentials)"
            ]
        },
        {
            "id": "22",
            "type": "block",
            "statements": []
        },
        {
            "id": "23",
            "type": "block",
            "statements": [
                "settings.secrets.anthropic_api_key"
            ]
        },
        {
            "id": "24",
            "type": "block",
            "statements": [
                "all_credentials.append(anthropic_credentials)"
            ]
        },
        {
            "id": "25",
            "type": "block",
            "statements": []
        },
        {
            "id": "26",
            "type": "block",
            "statements": [
                "settings.secrets.did_api_key"
            ]
        },
        {
            "id": "27",
            "type": "block",
            "statements": [
                "all_credentials.append(did_credentials)"
            ]
        },
        {
            "id": "28",
            "type": "block",
            "statements": []
        },
        {
            "id": "29",
            "type": "block",
            "statements": [
                "settings.secrets.jina_api_key"
            ]
        },
        {
            "id": "30",
            "type": "block",
            "statements": [
                "all_credentials.append(jina_credentials)"
            ]
        },
        {
            "id": "31",
            "type": "block",
            "statements": []
        },
        {
            "id": "32",
            "type": "block",
            "statements": [
                "settings.secrets.unreal_speech_api_key"
            ]
        },
        {
            "id": "33",
            "type": "block",
            "statements": [
                "all_credentials.append(unreal_credentials)"
            ]
        },
        {
            "id": "34",
            "type": "block",
            "statements": []
        },
        {
            "id": "35",
            "type": "block",
            "statements": [
                "settings.secrets.open_router_api_key"
            ]
        },
        {
            "id": "36",
            "type": "block",
            "statements": [
                "all_credentials.append(open_router_credentials)"
            ]
        },
        {
            "id": "37",
            "type": "block",
            "statements": []
        },
        {
            "id": "38",
            "type": "block",
            "statements": [
                "return all_credentials"
            ]
        },
        {
            "id": "39",
            "type": "block",
            "statements": [
                "def get_creds_by_id(self, user_id: str, credentials_id: str) -> Credentials | None:\n    all_credentials = self.get_all_creds(user_id)\n    return next((c for c in all_credentials if c.id == credentials_id), None)",
                "all_credentials = self.get_all_creds(user_id)",
                "return next((c for c in all_credentials if c.id == credentials_id), None)"
            ]
        },
        {
            "id": "40",
            "type": "block",
            "statements": [
                "def get_creds_by_provider(self, user_id: str, provider: str) -> list[Credentials]:\n    credentials = self.get_all_creds(user_id)\n    return [c for c in credentials if c.provider == provider]",
                "credentials = self.get_all_creds(user_id)",
                "return [c for c in credentials if c.provider == provider]"
            ]
        },
        {
            "id": "41",
            "type": "block",
            "statements": [
                "def get_authorized_providers(self, user_id: str) -> list[str]:\n    credentials = self.get_all_creds(user_id)\n    return list(set((c.provider for c in credentials)))",
                "credentials = self.get_all_creds(user_id)",
                "return list(set((c.provider for c in credentials)))"
            ]
        },
        {
            "id": "42",
            "type": "block",
            "statements": [
                "def update_creds(self, user_id: str, updated: Credentials) -> None:\n    with self.locked_user_integrations(user_id):\n        current = self.get_creds_by_id(user_id, updated.id)\n        if not current:\n            raise ValueError(f'Credentials with ID {updated.id} for user with ID {user_id} not found')\n        if type(current) is not type(updated):\n            raise TypeError(f'Can not update credentials with ID {updated.id} from type {type(current)} to type {type(updated)}')\n        if isinstance(updated, OAuth2Credentials) and isinstance(current, OAuth2Credentials) and (not set(updated.scopes).issuperset(current.scopes)):\n            raise ValueError(f'Can not update credentials with ID {updated.id} and scopes {current.scopes} to more restrictive set of scopes {updated.scopes}')\n        updated_credentials_list = [updated if c.id == updated.id else c for c in self.get_all_creds(user_id)]\n        self._set_user_integration_creds(user_id, updated_credentials_list)",
                "with self.locked_user_integrations(user_id):\n    current = self.get_creds_by_id(user_id, updated.id)\n    if not current:\n        raise ValueError(f'Credentials with ID {updated.id} for user with ID {user_id} not found')\n    if type(current) is not type(updated):\n        raise TypeError(f'Can not update credentials with ID {updated.id} from type {type(current)} to type {type(updated)}')\n    if isinstance(updated, OAuth2Credentials) and isinstance(current, OAuth2Credentials) and (not set(updated.scopes).issuperset(current.scopes)):\n        raise ValueError(f'Can not update credentials with ID {updated.id} and scopes {current.scopes} to more restrictive set of scopes {updated.scopes}')\n    updated_credentials_list = [updated if c.id == updated.id else c for c in self.get_all_creds(user_id)]\n    self._set_user_integration_creds(user_id, updated_credentials_list)",
                "current = self.get_creds_by_id(user_id, updated.id)",
                "not current"
            ]
        },
        {
            "id": "43",
            "type": "block",
            "statements": [
                "raise ValueError(f'Credentials with ID {updated.id} for user with ID {user_id} not found')"
            ]
        },
        {
            "id": "44",
            "type": "block",
            "statements": []
        },
        {
            "id": "45",
            "type": "block",
            "statements": [
                "type(current) IsNot type(updated)"
            ]
        },
        {
            "id": "46",
            "type": "block",
            "statements": [
                "raise TypeError(f'Can not update credentials with ID {updated.id} from type {type(current)} to type {type(updated)}')"
            ]
        },
        {
            "id": "47",
            "type": "block",
            "statements": []
        },
        {
            "id": "48",
            "type": "block",
            "statements": [
                "isinstance(updated, OAuth2Credentials) and isinstance(current, OAuth2Credentials) and (not set(updated.scopes).issuperset(current.scopes))"
            ]
        },
        {
            "id": "49",
            "type": "block",
            "statements": [
                "raise ValueError(f'Can not update credentials with ID {updated.id} and scopes {current.scopes} to more restrictive set of scopes {updated.scopes}')"
            ]
        },
        {
            "id": "50",
            "type": "block",
            "statements": []
        },
        {
            "id": "51",
            "type": "block",
            "statements": [
                "updated_credentials_list = [updated if c.id == updated.id else c for c in self.get_all_creds(user_id)]",
                "self._set_user_integration_creds(user_id, updated_credentials_list)",
                "def delete_creds_by_id(self, user_id: str, credentials_id: str) -> None:\n    with self.locked_user_integrations(user_id):\n        filtered_credentials = [c for c in self.get_all_creds(user_id) if c.id != credentials_id]\n        self._set_user_integration_creds(user_id, filtered_credentials)",
                "with self.locked_user_integrations(user_id):\n    filtered_credentials = [c for c in self.get_all_creds(user_id) if c.id != credentials_id]\n    self._set_user_integration_creds(user_id, filtered_credentials)",
                "filtered_credentials = [c for c in self.get_all_creds(user_id) if c.id != credentials_id]",
                "self._set_user_integration_creds(user_id, filtered_credentials)",
                "def store_state_token(self, user_id: str, provider: str, scopes: list[str]) -> str:\n    token = secrets.token_urlsafe(32)\n    expires_at = datetime.now(timezone.utc) + timedelta(minutes=10)\n    state = OAuthState(token=token, provider=provider, expires_at=int(expires_at.timestamp()), scopes=scopes)\n    with self.locked_user_integrations(user_id):\n        user_integrations = self._get_user_integrations(user_id)\n        oauth_states = user_integrations.oauth_states\n        oauth_states.append(state)\n        user_integrations.oauth_states = oauth_states\n        self.db_manager.update_user_integrations(user_id=user_id, data=user_integrations)\n    return token",
                "token = secrets.token_urlsafe(32)",
                "expires_at = datetime.now(timezone.utc) + timedelta(minutes=10)",
                "state = OAuthState(token=token, provider=provider, expires_at=int(expires_at.timestamp()), scopes=scopes)",
                "with self.locked_user_integrations(user_id):\n    user_integrations = self._get_user_integrations(user_id)\n    oauth_states = user_integrations.oauth_states\n    oauth_states.append(state)\n    user_integrations.oauth_states = oauth_states\n    self.db_manager.update_user_integrations(user_id=user_id, data=user_integrations)",
                "user_integrations = self._get_user_integrations(user_id)",
                "oauth_states = user_integrations.oauth_states",
                "oauth_states.append(state)",
                "user_integrations.oauth_states = oauth_states",
                "self.db_manager.update_user_integrations()",
                "return token"
            ]
        },
        {
            "id": "52",
            "type": "block",
            "statements": [
                "def get_any_valid_scopes_from_state_token(self, user_id: str, token: str, provider: str) -> list[str]:\n    \"\"\"\n        Get the valid scopes from the OAuth state token. This will return any valid scopes\n        from any OAuth state token for the given provider. If no valid scopes are found,\n        an empty list is returned. DO NOT RELY ON THIS TOKEN TO AUTHENTICATE A USER, AS IT\n        IS TO CHECK IF THE USER HAS GIVEN PERMISSIONS TO THE APPLICATION BEFORE EXCHANGING\n        THE CODE FOR TOKENS.\n        \"\"\"\n    user_integrations = self._get_user_integrations(user_id)\n    oauth_states = user_integrations.oauth_states\n    now = datetime.now(timezone.utc)\n    valid_state = next((state for state in oauth_states if state.token == token and state.provider == provider and (state.expires_at > now.timestamp())), None)\n    if valid_state:\n        return valid_state.scopes\n    return []",
                "'\\n        Get the valid scopes from the OAuth state token. This will return any valid scopes\\n        from any OAuth state token for the given provider. If no valid scopes are found,\\n        an empty list is returned. DO NOT RELY ON THIS TOKEN TO AUTHENTICATE A USER, AS IT\\n        IS TO CHECK IF THE USER HAS GIVEN PERMISSIONS TO THE APPLICATION BEFORE EXCHANGING\\n        THE CODE FOR TOKENS.\\n        '",
                "user_integrations = self._get_user_integrations(user_id)",
                "oauth_states = user_integrations.oauth_states",
                "now = datetime.now(timezone.utc)",
                "valid_state = next((state for state in oauth_states if state.token == token and state.provider == provider and (state.expires_at > now.timestamp())), None)",
                "valid_state"
            ]
        },
        {
            "id": "53",
            "type": "block",
            "statements": [
                "return valid_state.scopes"
            ]
        },
        {
            "id": "54",
            "type": "block",
            "statements": []
        },
        {
            "id": "55",
            "type": "block",
            "statements": [
                "return []"
            ]
        },
        {
            "id": "56",
            "type": "block",
            "statements": [
                "def verify_state_token(self, user_id: str, token: str, provider: str) -> bool:\n    with self.locked_user_integrations(user_id):\n        user_integrations = self._get_user_integrations(user_id)\n        oauth_states = user_integrations.oauth_states\n        now = datetime.now(timezone.utc)\n        valid_state = next((state for state in oauth_states if state.token == token and state.provider == provider and (state.expires_at > now.timestamp())), None)\n        if valid_state:\n            oauth_states.remove(valid_state)\n            user_integrations.oauth_states = oauth_states\n            self.db_manager.update_user_integrations(user_id, user_integrations)\n            return True\n    return False",
                "with self.locked_user_integrations(user_id):\n    user_integrations = self._get_user_integrations(user_id)\n    oauth_states = user_integrations.oauth_states\n    now = datetime.now(timezone.utc)\n    valid_state = next((state for state in oauth_states if state.token == token and state.provider == provider and (state.expires_at > now.timestamp())), None)\n    if valid_state:\n        oauth_states.remove(valid_state)\n        user_integrations.oauth_states = oauth_states\n        self.db_manager.update_user_integrations(user_id, user_integrations)\n        return True",
                "user_integrations = self._get_user_integrations(user_id)",
                "oauth_states = user_integrations.oauth_states",
                "now = datetime.now(timezone.utc)",
                "valid_state = next((state for state in oauth_states if state.token == token and state.provider == provider and (state.expires_at > now.timestamp())), None)",
                "valid_state"
            ]
        },
        {
            "id": "57",
            "type": "block",
            "statements": [
                "oauth_states.remove(valid_state)",
                "user_integrations.oauth_states = oauth_states",
                "self.db_manager.update_user_integrations(user_id, user_integrations)",
                "return True"
            ]
        },
        {
            "id": "58",
            "type": "block",
            "statements": []
        },
        {
            "id": "59",
            "type": "block",
            "statements": [
                "return False"
            ]
        },
        {
            "id": "60",
            "type": "block",
            "statements": [
                "def _set_user_integration_creds(self, user_id: str, credentials: list[Credentials]) -> None:\n    integrations = self._get_user_integrations(user_id)\n    credentials = [c for c in credentials if c not in DEFAULT_CREDENTIALS]\n    integrations.credentials = credentials\n    self.db_manager.update_user_integrations(user_id, integrations)",
                "integrations = self._get_user_integrations(user_id)",
                "credentials = [c for c in credentials if c not in DEFAULT_CREDENTIALS]",
                "integrations.credentials = credentials",
                "self.db_manager.update_user_integrations(user_id, integrations)",
                "def _get_user_integrations(self, user_id: str) -> UserIntegrations:\n    integrations: UserIntegrations = self.db_manager.get_user_integrations(user_id=user_id)\n    return integrations",
                "integrations: UserIntegrations = self.db_manager.get_user_integrations(user_id=user_id)",
                "return integrations"
            ]
        },
        {
            "id": "61",
            "type": "block",
            "statements": [
                "def locked_user_integrations(self, user_id: str):\n    key = (f'user:{user_id}', 'integrations')\n    return self.locks.locked(key)",
                "key = (f'user:{user_id}', 'integrations')",
                "return self.locks.locked(key)"
            ]
        }
    ],
    "edges": [
        {
            "source": "1",
            "target": "2",
            "type": "true"
        },
        {
            "source": "1",
            "target": "3",
            "type": "false"
        },
        {
            "source": "2",
            "target": "4",
            "type": "next"
        },
        {
            "source": "3",
            "target": "4",
            "type": "next"
        },
        {
            "source": "5",
            "target": "6",
            "type": "true"
        },
        {
            "source": "5",
            "target": "7",
            "type": "false"
        },
        {
            "source": "6",
            "target": "8",
            "type": "next"
        },
        {
            "source": "7",
            "target": "8",
            "type": "next"
        },
        {
            "source": "8",
            "target": "9",
            "type": "true"
        },
        {
            "source": "8",
            "target": "10",
            "type": "false"
        },
        {
            "source": "9",
            "target": "11",
            "type": "next"
        },
        {
            "source": "10",
            "target": "11",
            "type": "next"
        },
        {
            "source": "11",
            "target": "12",
            "type": "true"
        },
        {
            "source": "11",
            "target": "13",
            "type": "false"
        },
        {
            "source": "12",
            "target": "14",
            "type": "next"
        },
        {
            "source": "13",
            "target": "14",
            "type": "next"
        },
        {
            "source": "14",
            "target": "15",
            "type": "true"
        },
        {
            "source": "14",
            "target": "16",
            "type": "false"
        },
        {
            "source": "15",
            "target": "17",
            "type": "next"
        },
        {
            "source": "16",
            "target": "17",
            "type": "next"
        },
        {
            "source": "17",
            "target": "18",
            "type": "true"
        },
        {
            "source": "17",
            "target": "19",
            "type": "false"
        },
        {
            "source": "18",
            "target": "20",
            "type": "next"
        },
        {
            "source": "19",
            "target": "20",
            "type": "next"
        },
        {
            "source": "20",
            "target": "21",
            "type": "true"
        },
        {
            "source": "20",
            "target": "22",
            "type": "false"
        },
        {
            "source": "21",
            "target": "23",
            "type": "next"
        },
        {
            "source": "22",
            "target": "23",
            "type": "next"
        },
        {
            "source": "23",
            "target": "24",
            "type": "true"
        },
        {
            "source": "23",
            "target": "25",
            "type": "false"
        },
        {
            "source": "24",
            "target": "26",
            "type": "next"
        },
        {
            "source": "25",
            "target": "26",
            "type": "next"
        },
        {
            "source": "26",
            "target": "27",
            "type": "true"
        },
        {
            "source": "26",
            "target": "28",
            "type": "false"
        },
        {
            "source": "27",
            "target": "29",
            "type": "next"
        },
        {
            "source": "28",
            "target": "29",
            "type": "next"
        },
        {
            "source": "29",
            "target": "30",
            "type": "true"
        },
        {
            "source": "29",
            "target": "31",
            "type": "false"
        },
        {
            "source": "30",
            "target": "32",
            "type": "next"
        },
        {
            "source": "31",
            "target": "32",
            "type": "next"
        },
        {
            "source": "32",
            "target": "33",
            "type": "true"
        },
        {
            "source": "32",
            "target": "34",
            "type": "false"
        },
        {
            "source": "33",
            "target": "35",
            "type": "next"
        },
        {
            "source": "34",
            "target": "35",
            "type": "next"
        },
        {
            "source": "35",
            "target": "36",
            "type": "true"
        },
        {
            "source": "35",
            "target": "37",
            "type": "false"
        },
        {
            "source": "36",
            "target": "38",
            "type": "next"
        },
        {
            "source": "37",
            "target": "38",
            "type": "next"
        },
        {
            "source": "42",
            "target": "43",
            "type": "true"
        },
        {
            "source": "42",
            "target": "44",
            "type": "false"
        },
        {
            "source": "43",
            "target": "45",
            "type": "next"
        },
        {
            "source": "44",
            "target": "45",
            "type": "next"
        },
        {
            "source": "45",
            "target": "46",
            "type": "true"
        },
        {
            "source": "45",
            "target": "47",
            "type": "false"
        },
        {
            "source": "46",
            "target": "48",
            "type": "next"
        },
        {
            "source": "47",
            "target": "48",
            "type": "next"
        },
        {
            "source": "48",
            "target": "49",
            "type": "true"
        },
        {
            "source": "48",
            "target": "50",
            "type": "false"
        },
        {
            "source": "49",
            "target": "51",
            "type": "next"
        },
        {
            "source": "50",
            "target": "51",
            "type": "next"
        },
        {
            "source": "52",
            "target": "53",
            "type": "true"
        },
        {
            "source": "52",
            "target": "54",
            "type": "false"
        },
        {
            "source": "54",
            "target": "55",
            "type": "next"
        },
        {
            "source": "56",
            "target": "57",
            "type": "true"
        },
        {
            "source": "56",
            "target": "58",
            "type": "false"
        },
        {
            "source": "58",
            "target": "59",
            "type": "next"
        }
    ]
}