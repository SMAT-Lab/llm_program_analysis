{
    "nodes": [
        {
            "id": "1",
            "type": "block",
            "statements": [
                "import asyncio",
                "from typing import Literal",
                "import aiohttp",
                "import discord",
                "from pydantic import SecretStr",
                "from backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema",
                "from backend.data.model import APIKeyCredentials, CredentialsField, CredentialsMetaInput, SchemaField",
                "from backend.integrations.providers import ProviderName",
                "DiscordCredentials = CredentialsMetaInput[Literal[ProviderName.DISCORD], Literal['api_key']]",
                "def DiscordCredentialsField() -> DiscordCredentials:\n    return CredentialsField(description='Discord bot token')",
                "return CredentialsField(description='Discord bot token')"
            ]
        },
        {
            "id": "2",
            "type": "block",
            "statements": [
                "TEST_CREDENTIALS = APIKeyCredentials(id='01234567-89ab-cdef-0123-456789abcdef', provider='discord', api_key=SecretStr('test_api_key'), title='Mock Discord API key', expires_at=None)",
                "TEST_CREDENTIALS_INPUT = {'provider': TEST_CREDENTIALS.provider, 'id': TEST_CREDENTIALS.id, 'type': TEST_CREDENTIALS.type, 'title': TEST_CREDENTIALS.type}",
                "class ReadDiscordMessagesBlock(Block):\n\n    class Input(BlockSchema):\n        credentials: DiscordCredentials = DiscordCredentialsField()\n\n    class Output(BlockSchema):\n        message_content: str = SchemaField(description='The content of the message received')\n        channel_name: str = SchemaField(description='The name of the channel the message was received from')\n        username: str = SchemaField(description='The username of the user who sent the message')\n\n    def __init__(self):\n        super().__init__(id='df06086a-d5ac-4abb-9996-2ad0acb2eff7', input_schema=ReadDiscordMessagesBlock.Input, output_schema=ReadDiscordMessagesBlock.Output, description='Reads messages from a Discord channel using a bot token.', categories={BlockCategory.SOCIAL}, test_input={'continuous_read': False, 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('message_content', 'Hello!\\n\\nFile from user: example.txt\\nContent: This is the content of the file.'), ('channel_name', 'general'), ('username', 'test_user')], test_mock={'run_bot': lambda token: asyncio.Future()})\n\n    async def run_bot(self, token: SecretStr):\n        intents = discord.Intents.default()\n        intents.message_content = True\n        client = discord.Client(intents=intents)\n        self.output_data = None\n        self.channel_name = None\n        self.username = None\n\n        @client.event\n        async def on_ready():\n            print(f'Logged in as {client.user}')\n\n        @client.event\n        async def on_message(message):\n            if message.author == client.user:\n                return\n            self.output_data = message.content\n            self.channel_name = message.channel.name\n            self.username = message.author.name\n            if message.attachments:\n                attachment = message.attachments[0]\n                if attachment.filename.endswith(('.txt', '.py')):\n                    async with aiohttp.ClientSession() as session:\n                        async with session.get(attachment.url) as response:\n                            file_content = await response.text()\n                            self.output_data += f'\\n\\nFile from user: {attachment.filename}\\nContent: {file_content}'\n            await client.close()\n        await client.start(token.get_secret_value())\n\n    def run(self, input_data: Input, *, credentials: APIKeyCredentials, **kwargs) -> BlockOutput:\n        while True:\n            for (output_name, output_value) in self.__run(input_data, credentials):\n                yield (output_name, output_value)\n            break\n\n    def __run(self, input_data: Input, credentials: APIKeyCredentials) -> BlockOutput:\n        try:\n            loop = asyncio.get_event_loop()\n            future = self.run_bot(credentials.api_key)\n            if isinstance(future, asyncio.Future):\n                future.set_result({'output_data': 'Hello!\\n\\nFile from user: example.txt\\nContent: This is the content of the file.', 'channel_name': 'general', 'username': 'test_user'})\n            result = loop.run_until_complete(future)\n            if isinstance(result, dict):\n                self.output_data = result.get('output_data')\n                self.channel_name = result.get('channel_name')\n                self.username = result.get('username')\n            if self.output_data is None or self.channel_name is None or self.username is None:\n                raise ValueError('No message, channel name, or username received.')\n            yield ('message_content', self.output_data)\n            yield ('channel_name', self.channel_name)\n            yield ('username', self.username)\n        except discord.errors.LoginFailure as login_err:\n            raise ValueError(f'Login error occurred: {login_err}')\n        except Exception as e:\n            raise ValueError(f'An error occurred: {e}')",
                "class Input(BlockSchema):\n    credentials: DiscordCredentials = DiscordCredentialsField()",
                "credentials: DiscordCredentials = DiscordCredentialsField()",
                "class Output(BlockSchema):\n    message_content: str = SchemaField(description='The content of the message received')\n    channel_name: str = SchemaField(description='The name of the channel the message was received from')\n    username: str = SchemaField(description='The username of the user who sent the message')",
                "message_content: str = SchemaField(description='The content of the message received')",
                "channel_name: str = SchemaField(description='The name of the channel the message was received from')",
                "username: str = SchemaField(description='The username of the user who sent the message')",
                "def __init__(self):\n    super().__init__(id='df06086a-d5ac-4abb-9996-2ad0acb2eff7', input_schema=ReadDiscordMessagesBlock.Input, output_schema=ReadDiscordMessagesBlock.Output, description='Reads messages from a Discord channel using a bot token.', categories={BlockCategory.SOCIAL}, test_input={'continuous_read': False, 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('message_content', 'Hello!\\n\\nFile from user: example.txt\\nContent: This is the content of the file.'), ('channel_name', 'general'), ('username', 'test_user')], test_mock={'run_bot': lambda token: asyncio.Future()})",
                "super().__init__()",
                "async def run_bot(self, token: SecretStr):\n    intents = discord.Intents.default()\n    intents.message_content = True\n    client = discord.Client(intents=intents)\n    self.output_data = None\n    self.channel_name = None\n    self.username = None\n\n    @client.event\n    async def on_ready():\n        print(f'Logged in as {client.user}')\n\n    @client.event\n    async def on_message(message):\n        if message.author == client.user:\n            return\n        self.output_data = message.content\n        self.channel_name = message.channel.name\n        self.username = message.author.name\n        if message.attachments:\n            attachment = message.attachments[0]\n            if attachment.filename.endswith(('.txt', '.py')):\n                async with aiohttp.ClientSession() as session:\n                    async with session.get(attachment.url) as response:\n                        file_content = await response.text()\n                        self.output_data += f'\\n\\nFile from user: {attachment.filename}\\nContent: {file_content}'\n        await client.close()\n    await client.start(token.get_secret_value())",
                "intents = discord.Intents.default()",
                "intents.message_content = True",
                "client = discord.Client(intents=intents)",
                "self.output_data = None",
                "self.channel_name = None",
                "self.username = None",
                "@client.event\nasync def on_ready():\n    print(f'Logged in as {client.user}')",
                "print(f'Logged in as {client.user}')",
                "@client.event\nasync def on_message(message):\n    if message.author == client.user:\n        return\n    self.output_data = message.content\n    self.channel_name = message.channel.name\n    self.username = message.author.name\n    if message.attachments:\n        attachment = message.attachments[0]\n        if attachment.filename.endswith(('.txt', '.py')):\n            async with aiohttp.ClientSession() as session:\n                async with session.get(attachment.url) as response:\n                    file_content = await response.text()\n                    self.output_data += f'\\n\\nFile from user: {attachment.filename}\\nContent: {file_content}'\n    await client.close()",
                "message.author Eq client.user"
            ]
        },
        {
            "id": "3",
            "type": "block",
            "statements": [
                "return"
            ]
        },
        {
            "id": "4",
            "type": "block",
            "statements": []
        },
        {
            "id": "5",
            "type": "block",
            "statements": [
                "self.output_data = message.content",
                "self.channel_name = message.channel.name",
                "self.username = message.author.name",
                "message.attachments"
            ]
        },
        {
            "id": "6",
            "type": "block",
            "statements": [
                "attachment = message.attachments[0]",
                "attachment.filename.endswith(('.txt', '.py'))"
            ]
        },
        {
            "id": "7",
            "type": "block",
            "statements": []
        },
        {
            "id": "8",
            "type": "block",
            "statements": [
                "await client.close()",
                "await client.start(token.get_secret_value())",
                "def run(self, input_data: Input, *, credentials: APIKeyCredentials, **kwargs) -> BlockOutput:\n    while True:\n        for (output_name, output_value) in self.__run(input_data, credentials):\n            yield (output_name, output_value)\n        break"
            ]
        },
        {
            "id": "9",
            "type": "block",
            "statements": [
                "async with aiohttp.ClientSession() as session:\n    async with session.get(attachment.url) as response:\n        file_content = await response.text()\n        self.output_data += f'\\n\\nFile from user: {attachment.filename}\\nContent: {file_content}'",
                "async with session.get(attachment.url) as response:\n    file_content = await response.text()\n    self.output_data += f'\\n\\nFile from user: {attachment.filename}\\nContent: {file_content}'",
                "file_content = await response.text()",
                "self.output_data += f'\\n\\nFile from user: {attachment.filename}\\nContent: {file_content}'"
            ]
        },
        {
            "id": "10",
            "type": "block",
            "statements": []
        },
        {
            "id": "11",
            "type": "block",
            "statements": []
        },
        {
            "id": "12",
            "type": "block",
            "statements": [
                "True"
            ]
        },
        {
            "id": "13",
            "type": "block",
            "statements": []
        },
        {
            "id": "14",
            "type": "block",
            "statements": [
                "def __run(self, input_data: Input, credentials: APIKeyCredentials) -> BlockOutput:\n    try:\n        loop = asyncio.get_event_loop()\n        future = self.run_bot(credentials.api_key)\n        if isinstance(future, asyncio.Future):\n            future.set_result({'output_data': 'Hello!\\n\\nFile from user: example.txt\\nContent: This is the content of the file.', 'channel_name': 'general', 'username': 'test_user'})\n        result = loop.run_until_complete(future)\n        if isinstance(result, dict):\n            self.output_data = result.get('output_data')\n            self.channel_name = result.get('channel_name')\n            self.username = result.get('username')\n        if self.output_data is None or self.channel_name is None or self.username is None:\n            raise ValueError('No message, channel name, or username received.')\n        yield ('message_content', self.output_data)\n        yield ('channel_name', self.channel_name)\n        yield ('username', self.username)\n    except discord.errors.LoginFailure as login_err:\n        raise ValueError(f'Login error occurred: {login_err}')\n    except Exception as e:\n        raise ValueError(f'An error occurred: {e}')",
                "try:\n    loop = asyncio.get_event_loop()\n    future = self.run_bot(credentials.api_key)\n    if isinstance(future, asyncio.Future):\n        future.set_result({'output_data': 'Hello!\\n\\nFile from user: example.txt\\nContent: This is the content of the file.', 'channel_name': 'general', 'username': 'test_user'})\n    result = loop.run_until_complete(future)\n    if isinstance(result, dict):\n        self.output_data = result.get('output_data')\n        self.channel_name = result.get('channel_name')\n        self.username = result.get('username')\n    if self.output_data is None or self.channel_name is None or self.username is None:\n        raise ValueError('No message, channel name, or username received.')\n    yield ('message_content', self.output_data)\n    yield ('channel_name', self.channel_name)\n    yield ('username', self.username)\nexcept discord.errors.LoginFailure as login_err:\n    raise ValueError(f'Login error occurred: {login_err}')\nexcept Exception as e:\n    raise ValueError(f'An error occurred: {e}')",
                "loop = asyncio.get_event_loop()",
                "future = self.run_bot(credentials.api_key)",
                "isinstance(future, asyncio.Future)"
            ]
        },
        {
            "id": "15",
            "type": "block",
            "statements": [
                "(output_name, output_value)",
                "self.__run(input_data, credentials)"
            ]
        },
        {
            "id": "16",
            "type": "block",
            "statements": [
                "(yield (output_name, output_value))"
            ]
        },
        {
            "id": "17",
            "type": "block",
            "statements": [
                "break"
            ]
        },
        {
            "id": "18",
            "type": "block",
            "statements": [
                "future.set_result({'output_data': 'Hello!\\n\\nFile from user: example.txt\\nContent: This is the content of the file.', 'channel_name': 'general', 'username': 'test_user'})"
            ]
        },
        {
            "id": "19",
            "type": "block",
            "statements": []
        },
        {
            "id": "20",
            "type": "block",
            "statements": [
                "result = loop.run_until_complete(future)",
                "isinstance(result, dict)"
            ]
        },
        {
            "id": "21",
            "type": "block",
            "statements": [
                "self.output_data = result.get('output_data')",
                "self.channel_name = result.get('channel_name')",
                "self.username = result.get('username')"
            ]
        },
        {
            "id": "22",
            "type": "block",
            "statements": []
        },
        {
            "id": "23",
            "type": "block",
            "statements": [
                "self.output_data is None or self.channel_name is None or self.username is None"
            ]
        },
        {
            "id": "24",
            "type": "block",
            "statements": [
                "raise ValueError('No message, channel name, or username received.')"
            ]
        },
        {
            "id": "25",
            "type": "block",
            "statements": []
        },
        {
            "id": "26",
            "type": "block",
            "statements": [
                "(yield ('message_content', self.output_data))",
                "(yield ('channel_name', self.channel_name))",
                "(yield ('username', self.username))",
                "raise ValueError(f'Login error occurred: {login_err}')",
                "raise ValueError(f'An error occurred: {e}')",
                "class SendDiscordMessageBlock(Block):\n\n    class Input(BlockSchema):\n        credentials: DiscordCredentials = DiscordCredentialsField()\n        message_content: str = SchemaField(description='The content of the message received')\n        channel_name: str = SchemaField(description='The name of the channel the message was received from')\n\n    class Output(BlockSchema):\n        status: str = SchemaField(description=\"The status of the operation (e.g., 'Message sent', 'Error')\")\n\n    def __init__(self):\n        super().__init__(id='d0822ab5-9f8a-44a3-8971-531dd0178b6b', input_schema=SendDiscordMessageBlock.Input, output_schema=SendDiscordMessageBlock.Output, description='Sends a message to a Discord channel using a bot token.', categories={BlockCategory.SOCIAL}, test_input={'channel_name': 'general', 'message_content': 'Hello, Discord!', 'credentials': TEST_CREDENTIALS_INPUT}, test_output=[('status', 'Message sent')], test_mock={'send_message': lambda token, channel_name, message_content: asyncio.Future()}, test_credentials=TEST_CREDENTIALS)\n\n    async def send_message(self, token: str, channel_name: str, message_content: str):\n        intents = discord.Intents.default()\n        intents.guilds = True\n        client = discord.Client(intents=intents)\n\n        @client.event\n        async def on_ready():\n            print(f'Logged in as {client.user}')\n            for guild in client.guilds:\n                for channel in guild.text_channels:\n                    if channel.name == channel_name:\n                        for chunk in self.chunk_message(message_content):\n                            await channel.send(chunk)\n                        self.output_data = 'Message sent'\n                        await client.close()\n                        return\n            self.output_data = 'Channel not found'\n            await client.close()\n        await client.start(token)\n\n    def chunk_message(self, message: str, limit: int=2000) -> list:\n        \"\"\"Splits a message into chunks not exceeding the Discord limit.\"\"\"\n        return [message[i:i + limit] for i in range(0, len(message), limit)]\n\n    def run(self, input_data: Input, *, credentials: APIKeyCredentials, **kwargs) -> BlockOutput:\n        try:\n            loop = asyncio.get_event_loop()\n            future = self.send_message(credentials.api_key.get_secret_value(), input_data.channel_name, input_data.message_content)\n            if isinstance(future, asyncio.Future):\n                future.set_result('Message sent')\n            result = loop.run_until_complete(future)\n            if isinstance(result, str):\n                self.output_data = result\n            if self.output_data is None:\n                raise ValueError('No status message received.')\n            yield ('status', self.output_data)\n        except discord.errors.LoginFailure as login_err:\n            raise ValueError(f'Login error occurred: {login_err}')\n        except Exception as e:\n            raise ValueError(f'An error occurred: {e}')",
                "class Input(BlockSchema):\n    credentials: DiscordCredentials = DiscordCredentialsField()\n    message_content: str = SchemaField(description='The content of the message received')\n    channel_name: str = SchemaField(description='The name of the channel the message was received from')",
                "credentials: DiscordCredentials = DiscordCredentialsField()",
                "message_content: str = SchemaField(description='The content of the message received')",
                "channel_name: str = SchemaField(description='The name of the channel the message was received from')",
                "class Output(BlockSchema):\n    status: str = SchemaField(description=\"The status of the operation (e.g., 'Message sent', 'Error')\")",
                "status: str = SchemaField(description=\"The status of the operation (e.g., 'Message sent', 'Error')\")",
                "def __init__(self):\n    super().__init__(id='d0822ab5-9f8a-44a3-8971-531dd0178b6b', input_schema=SendDiscordMessageBlock.Input, output_schema=SendDiscordMessageBlock.Output, description='Sends a message to a Discord channel using a bot token.', categories={BlockCategory.SOCIAL}, test_input={'channel_name': 'general', 'message_content': 'Hello, Discord!', 'credentials': TEST_CREDENTIALS_INPUT}, test_output=[('status', 'Message sent')], test_mock={'send_message': lambda token, channel_name, message_content: asyncio.Future()}, test_credentials=TEST_CREDENTIALS)",
                "super().__init__()",
                "async def send_message(self, token: str, channel_name: str, message_content: str):\n    intents = discord.Intents.default()\n    intents.guilds = True\n    client = discord.Client(intents=intents)\n\n    @client.event\n    async def on_ready():\n        print(f'Logged in as {client.user}')\n        for guild in client.guilds:\n            for channel in guild.text_channels:\n                if channel.name == channel_name:\n                    for chunk in self.chunk_message(message_content):\n                        await channel.send(chunk)\n                    self.output_data = 'Message sent'\n                    await client.close()\n                    return\n        self.output_data = 'Channel not found'\n        await client.close()\n    await client.start(token)",
                "intents = discord.Intents.default()",
                "intents.guilds = True",
                "client = discord.Client(intents=intents)",
                "@client.event\nasync def on_ready():\n    print(f'Logged in as {client.user}')\n    for guild in client.guilds:\n        for channel in guild.text_channels:\n            if channel.name == channel_name:\n                for chunk in self.chunk_message(message_content):\n                    await channel.send(chunk)\n                self.output_data = 'Message sent'\n                await client.close()\n                return\n    self.output_data = 'Channel not found'\n    await client.close()",
                "print(f'Logged in as {client.user}')"
            ]
        },
        {
            "id": "27",
            "type": "block",
            "statements": [
                "guild",
                "client.guilds"
            ]
        },
        {
            "id": "28",
            "type": "block",
            "statements": []
        },
        {
            "id": "29",
            "type": "block",
            "statements": [
                "self.output_data = 'Channel not found'",
                "await client.close()",
                "await client.start(token)",
                "def chunk_message(self, message: str, limit: int=2000) -> list:\n    \"\"\"Splits a message into chunks not exceeding the Discord limit.\"\"\"\n    return [message[i:i + limit] for i in range(0, len(message), limit)]",
                "'Splits a message into chunks not exceeding the Discord limit.'",
                "return [message[i:i + limit] for i in range(0, len(message), limit)]"
            ]
        },
        {
            "id": "30",
            "type": "block",
            "statements": [
                "channel",
                "guild.text_channels"
            ]
        },
        {
            "id": "31",
            "type": "block",
            "statements": [
                "channel.name Eq channel_name"
            ]
        },
        {
            "id": "32",
            "type": "block",
            "statements": []
        },
        {
            "id": "33",
            "type": "block",
            "statements": []
        },
        {
            "id": "34",
            "type": "block",
            "statements": []
        },
        {
            "id": "35",
            "type": "block",
            "statements": []
        },
        {
            "id": "36",
            "type": "block",
            "statements": [
                "chunk",
                "self.chunk_message(message_content)"
            ]
        },
        {
            "id": "37",
            "type": "block",
            "statements": [
                "await channel.send(chunk)"
            ]
        },
        {
            "id": "38",
            "type": "block",
            "statements": [
                "self.output_data = 'Message sent'",
                "await client.close()",
                "return"
            ]
        },
        {
            "id": "39",
            "type": "block",
            "statements": [
                "def run(self, input_data: Input, *, credentials: APIKeyCredentials, **kwargs) -> BlockOutput:\n    try:\n        loop = asyncio.get_event_loop()\n        future = self.send_message(credentials.api_key.get_secret_value(), input_data.channel_name, input_data.message_content)\n        if isinstance(future, asyncio.Future):\n            future.set_result('Message sent')\n        result = loop.run_until_complete(future)\n        if isinstance(result, str):\n            self.output_data = result\n        if self.output_data is None:\n            raise ValueError('No status message received.')\n        yield ('status', self.output_data)\n    except discord.errors.LoginFailure as login_err:\n        raise ValueError(f'Login error occurred: {login_err}')\n    except Exception as e:\n        raise ValueError(f'An error occurred: {e}')",
                "try:\n    loop = asyncio.get_event_loop()\n    future = self.send_message(credentials.api_key.get_secret_value(), input_data.channel_name, input_data.message_content)\n    if isinstance(future, asyncio.Future):\n        future.set_result('Message sent')\n    result = loop.run_until_complete(future)\n    if isinstance(result, str):\n        self.output_data = result\n    if self.output_data is None:\n        raise ValueError('No status message received.')\n    yield ('status', self.output_data)\nexcept discord.errors.LoginFailure as login_err:\n    raise ValueError(f'Login error occurred: {login_err}')\nexcept Exception as e:\n    raise ValueError(f'An error occurred: {e}')",
                "loop = asyncio.get_event_loop()",
                "future = self.send_message(credentials.api_key.get_secret_value(), input_data.channel_name, input_data.message_content)",
                "isinstance(future, asyncio.Future)"
            ]
        },
        {
            "id": "40",
            "type": "block",
            "statements": [
                "future.set_result('Message sent')"
            ]
        },
        {
            "id": "41",
            "type": "block",
            "statements": []
        },
        {
            "id": "42",
            "type": "block",
            "statements": [
                "result = loop.run_until_complete(future)",
                "isinstance(result, str)"
            ]
        },
        {
            "id": "43",
            "type": "block",
            "statements": [
                "self.output_data = result"
            ]
        },
        {
            "id": "44",
            "type": "block",
            "statements": []
        },
        {
            "id": "45",
            "type": "block",
            "statements": [
                "self.output_data Is None"
            ]
        },
        {
            "id": "46",
            "type": "block",
            "statements": [
                "raise ValueError('No status message received.')"
            ]
        },
        {
            "id": "47",
            "type": "block",
            "statements": []
        },
        {
            "id": "48",
            "type": "block",
            "statements": [
                "(yield ('status', self.output_data))",
                "raise ValueError(f'Login error occurred: {login_err}')",
                "raise ValueError(f'An error occurred: {e}')"
            ]
        }
    ],
    "edges": [
        {
            "source": "2",
            "target": "3",
            "type": "true"
        },
        {
            "source": "2",
            "target": "4",
            "type": "false"
        },
        {
            "source": "4",
            "target": "5",
            "type": "next"
        },
        {
            "source": "5",
            "target": "6",
            "type": "true"
        },
        {
            "source": "5",
            "target": "7",
            "type": "false"
        },
        {
            "source": "6",
            "target": "9",
            "type": "true"
        },
        {
            "source": "6",
            "target": "10",
            "type": "false"
        },
        {
            "source": "7",
            "target": "8",
            "type": "next"
        },
        {
            "source": "8",
            "target": "12",
            "type": "next"
        },
        {
            "source": "9",
            "target": "11",
            "type": "next"
        },
        {
            "source": "10",
            "target": "11",
            "type": "next"
        },
        {
            "source": "11",
            "target": "8",
            "type": "next"
        },
        {
            "source": "12",
            "target": "13",
            "type": "true"
        },
        {
            "source": "12",
            "target": "14",
            "type": "false"
        },
        {
            "source": "13",
            "target": "15",
            "type": "next"
        },
        {
            "source": "14",
            "target": "18",
            "type": "true"
        },
        {
            "source": "14",
            "target": "19",
            "type": "false"
        },
        {
            "source": "15",
            "target": "16",
            "type": "true"
        },
        {
            "source": "15",
            "target": "17",
            "type": "false"
        },
        {
            "source": "16",
            "target": "15",
            "type": "next"
        },
        {
            "source": "17",
            "target": "12",
            "type": "next"
        },
        {
            "source": "18",
            "target": "20",
            "type": "next"
        },
        {
            "source": "19",
            "target": "20",
            "type": "next"
        },
        {
            "source": "20",
            "target": "21",
            "type": "true"
        },
        {
            "source": "20",
            "target": "22",
            "type": "false"
        },
        {
            "source": "21",
            "target": "23",
            "type": "next"
        },
        {
            "source": "22",
            "target": "23",
            "type": "next"
        },
        {
            "source": "23",
            "target": "24",
            "type": "true"
        },
        {
            "source": "23",
            "target": "25",
            "type": "false"
        },
        {
            "source": "24",
            "target": "26",
            "type": "next"
        },
        {
            "source": "25",
            "target": "26",
            "type": "next"
        },
        {
            "source": "26",
            "target": "27",
            "type": "next"
        },
        {
            "source": "27",
            "target": "28",
            "type": "true"
        },
        {
            "source": "27",
            "target": "29",
            "type": "false"
        },
        {
            "source": "28",
            "target": "30",
            "type": "next"
        },
        {
            "source": "30",
            "target": "31",
            "type": "true"
        },
        {
            "source": "30",
            "target": "32",
            "type": "false"
        },
        {
            "source": "31",
            "target": "33",
            "type": "true"
        },
        {
            "source": "31",
            "target": "34",
            "type": "false"
        },
        {
            "source": "32",
            "target": "27",
            "type": "next"
        },
        {
            "source": "33",
            "target": "36",
            "type": "next"
        },
        {
            "source": "34",
            "target": "35",
            "type": "next"
        },
        {
            "source": "35",
            "target": "30",
            "type": "next"
        },
        {
            "source": "36",
            "target": "37",
            "type": "true"
        },
        {
            "source": "36",
            "target": "38",
            "type": "false"
        },
        {
            "source": "37",
            "target": "36",
            "type": "next"
        },
        {
            "source": "39",
            "target": "40",
            "type": "true"
        },
        {
            "source": "39",
            "target": "41",
            "type": "false"
        },
        {
            "source": "40",
            "target": "42",
            "type": "next"
        },
        {
            "source": "41",
            "target": "42",
            "type": "next"
        },
        {
            "source": "42",
            "target": "43",
            "type": "true"
        },
        {
            "source": "42",
            "target": "44",
            "type": "false"
        },
        {
            "source": "43",
            "target": "45",
            "type": "next"
        },
        {
            "source": "44",
            "target": "45",
            "type": "next"
        },
        {
            "source": "45",
            "target": "46",
            "type": "true"
        },
        {
            "source": "45",
            "target": "47",
            "type": "false"
        },
        {
            "source": "46",
            "target": "48",
            "type": "next"
        },
        {
            "source": "47",
            "target": "48",
            "type": "next"
        }
    ]
}