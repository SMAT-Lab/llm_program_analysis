{
    "nodes": [
        {
            "id": "1",
            "type": "block",
            "statements": [
                "'\\nauthor: Aayush Soni\\nGiven n pairs of parentheses, write a function to generate all\\ncombinations of well-formed parentheses.\\nInput: n = 2\\nOutput: [\"(())\",\"()()\"]\\nLeetcode link: https://leetcode.com/problems/generate-parentheses/description/\\n'",
                "def backtrack(partial: str, open_count: int, close_count: int, n: int, result: list[str]) -> None:\n    \"\"\"\n    Generate valid combinations of balanced parentheses using recursion.\n\n    :param partial: A string representing the current combination.\n    :param open_count: An integer representing the count of open parentheses.\n    :param close_count: An integer representing the count of close parentheses.\n    :param n: An integer representing the total number of pairs.\n    :param result: A list to store valid combinations.\n    :return: None\n\n    This function uses recursion to explore all possible combinations,\n    ensuring that at each step, the parentheses remain balanced.\n\n    Example:\n    >>> result = []\n    >>> backtrack(\"\", 0, 0, 2, result)\n    >>> result\n    ['(())', '()()']\n    \"\"\"\n    if len(partial) == 2 * n:\n        result.append(partial)\n        return\n    if open_count < n:\n        backtrack(partial + '(', open_count + 1, close_count, n, result)\n    if close_count < open_count:\n        backtrack(partial + ')', open_count, close_count + 1, n, result)",
                "'\\n    Generate valid combinations of balanced parentheses using recursion.\\n\\n    :param partial: A string representing the current combination.\\n    :param open_count: An integer representing the count of open parentheses.\\n    :param close_count: An integer representing the count of close parentheses.\\n    :param n: An integer representing the total number of pairs.\\n    :param result: A list to store valid combinations.\\n    :return: None\\n\\n    This function uses recursion to explore all possible combinations,\\n    ensuring that at each step, the parentheses remain balanced.\\n\\n    Example:\\n    >>> result = []\\n    >>> backtrack(\"\", 0, 0, 2, result)\\n    >>> result\\n    [\\'(())\\', \\'()()\\']\\n    '",
                "len(partial) Eq 2 Mult n"
            ]
        },
        {
            "id": "2",
            "type": "block",
            "statements": [
                "result.append(partial)",
                "return"
            ]
        },
        {
            "id": "3",
            "type": "block",
            "statements": []
        },
        {
            "id": "4",
            "type": "block",
            "statements": [
                "open_count Lt n"
            ]
        },
        {
            "id": "5",
            "type": "block",
            "statements": [
                "backtrack(partial Add '(', open_count Add 1, close_count, n, result)"
            ]
        },
        {
            "id": "6",
            "type": "block",
            "statements": []
        },
        {
            "id": "7",
            "type": "block",
            "statements": [
                "close_count Lt open_count"
            ]
        },
        {
            "id": "8",
            "type": "block",
            "statements": [
                "backtrack(partial Add ')', open_count, close_count Add 1, n, result)"
            ]
        },
        {
            "id": "9",
            "type": "block",
            "statements": []
        },
        {
            "id": "10",
            "type": "block",
            "statements": [
                "def generate_parenthesis(n: int) -> list[str]:\n    \"\"\"\n    Generate valid combinations of balanced parentheses for a given n.\n\n    :param n: An integer representing the number of pairs of parentheses.\n    :return: A list of strings with valid combinations.\n\n    This function uses a recursive approach to generate the combinations.\n\n    Time Complexity: O(2^(2n)) - In the worst case, we have 2^(2n) combinations.\n    Space Complexity: O(n) - where 'n' is the number of pairs.\n\n    Example 1:\n    >>> generate_parenthesis(3)\n    ['((()))', '(()())', '(())()', '()(())', '()()()']\n\n    Example 2:\n    >>> generate_parenthesis(1)\n    ['()']\n    \"\"\"\n    result: list[str] = []\n    backtrack('', 0, 0, n, result)\n    return result",
                "\"\\n    Generate valid combinations of balanced parentheses for a given n.\\n\\n    :param n: An integer representing the number of pairs of parentheses.\\n    :return: A list of strings with valid combinations.\\n\\n    This function uses a recursive approach to generate the combinations.\\n\\n    Time Complexity: O(2^(2n)) - In the worst case, we have 2^(2n) combinations.\\n    Space Complexity: O(n) - where 'n' is the number of pairs.\\n\\n    Example 1:\\n    >>> generate_parenthesis(3)\\n    ['((()))', '(()())', '(())()', '()(())', '()()()']\\n\\n    Example 2:\\n    >>> generate_parenthesis(1)\\n    ['()']\\n    \"",
                "result: list[str] = []",
                "backtrack('', 0, 0, n, result)",
                "return result"
            ]
        },
        {
            "id": "11",
            "type": "block",
            "statements": [
                "__name__ Eq '__main__'"
            ]
        },
        {
            "id": "12",
            "type": "block",
            "statements": [
                "import doctest",
                "doctest.testmod()"
            ]
        },
        {
            "id": "13",
            "type": "block",
            "statements": []
        },
        {
            "id": "14",
            "type": "block",
            "statements": []
        }
    ],
    "edges": [
        {
            "source": "1",
            "target": "2",
            "type": "true"
        },
        {
            "source": "1",
            "target": "3",
            "type": "false"
        },
        {
            "source": "3",
            "target": "4",
            "type": "next"
        },
        {
            "source": "4",
            "target": "5",
            "type": "true"
        },
        {
            "source": "4",
            "target": "6",
            "type": "false"
        },
        {
            "source": "5",
            "target": "7",
            "type": "next"
        },
        {
            "source": "6",
            "target": "7",
            "type": "next"
        },
        {
            "source": "7",
            "target": "8",
            "type": "true"
        },
        {
            "source": "7",
            "target": "9",
            "type": "false"
        },
        {
            "source": "8",
            "target": "10",
            "type": "next"
        },
        {
            "source": "9",
            "target": "10",
            "type": "next"
        },
        {
            "source": "11",
            "target": "12",
            "type": "true"
        },
        {
            "source": "11",
            "target": "13",
            "type": "false"
        },
        {
            "source": "12",
            "target": "14",
            "type": "next"
        },
        {
            "source": "13",
            "target": "14",
            "type": "next"
        }
    ]
}