{
    "nodes": [
        {
            "id": "1",
            "type": "block",
            "statements": [
                "import functools",
                "import logging",
                "import os",
                "import time",
                "from typing import Callable, ParamSpec, Tuple, TypeVar",
                "from pydantic import BaseModel",
                "class TimingInfo(BaseModel):\n    cpu_time: float\n    wall_time: float",
                "cpu_time: float",
                "wall_time: float",
                "def _start_measurement() -> Tuple[float, float]:\n    return (time.time(), os.times()[0] + os.times()[1])",
                "return (time.time(), os.times()[0] + os.times()[1])"
            ]
        },
        {
            "id": "2",
            "type": "block",
            "statements": [
                "def _end_measurement(start_wall_time: float, start_cpu_time: float) -> Tuple[float, float]:\n    end_wall_time = time.time()\n    end_cpu_time = os.times()[0] + os.times()[1]\n    return (end_wall_time - start_wall_time, end_cpu_time - start_cpu_time)",
                "end_wall_time = time.time()",
                "end_cpu_time = os.times()[0] + os.times()[1]",
                "return (end_wall_time - start_wall_time, end_cpu_time - start_cpu_time)"
            ]
        },
        {
            "id": "3",
            "type": "block",
            "statements": [
                "P = ParamSpec('P')",
                "T = TypeVar('T')",
                "logger = logging.getLogger(__name__)",
                "def time_measured(func: Callable[P, T]) -> Callable[P, Tuple[TimingInfo, T]]:\n    \"\"\"\n    Decorator to measure the time taken by a function to execute.\n    \"\"\"\n\n    @functools.wraps(func)\n    def wrapper(*args: P.args, **kwargs: P.kwargs) -> Tuple[TimingInfo, T]:\n        (start_wall_time, start_cpu_time) = _start_measurement()\n        try:\n            result = func(*args, **kwargs)\n        finally:\n            (wall_duration, cpu_duration) = _end_measurement(start_wall_time, start_cpu_time)\n            timing_info = TimingInfo(cpu_time=cpu_duration, wall_time=wall_duration)\n        return (timing_info, result)\n    return wrapper",
                "'\\n    Decorator to measure the time taken by a function to execute.\\n    '",
                "@functools.wraps(func)\ndef wrapper(*args: P.args, **kwargs: P.kwargs) -> Tuple[TimingInfo, T]:\n    (start_wall_time, start_cpu_time) = _start_measurement()\n    try:\n        result = func(*args, **kwargs)\n    finally:\n        (wall_duration, cpu_duration) = _end_measurement(start_wall_time, start_cpu_time)\n        timing_info = TimingInfo(cpu_time=cpu_duration, wall_time=wall_duration)\n    return (timing_info, result)",
                "(start_wall_time, start_cpu_time) = _start_measurement()",
                "try:\n    result = func(*args, **kwargs)\nfinally:\n    (wall_duration, cpu_duration) = _end_measurement(start_wall_time, start_cpu_time)\n    timing_info = TimingInfo(cpu_time=cpu_duration, wall_time=wall_duration)",
                "result = func(*args, **kwargs)",
                "(wall_duration, cpu_duration) = _end_measurement(start_wall_time, start_cpu_time)",
                "timing_info = TimingInfo(cpu_time=cpu_duration, wall_time=wall_duration)",
                "return (timing_info, result)"
            ]
        },
        {
            "id": "4",
            "type": "block",
            "statements": [
                "return wrapper"
            ]
        },
        {
            "id": "5",
            "type": "block",
            "statements": [
                "def error_logged(func: Callable[P, T]) -> Callable[P, T | None]:\n    \"\"\"\n    Decorator to suppress and log any exceptions raised by a function.\n    \"\"\"\n\n    @functools.wraps(func)\n    def wrapper(*args: P.args, **kwargs: P.kwargs) -> T | None:\n        try:\n            return func(*args, **kwargs)\n        except Exception as e:\n            logger.exception(f'Error when calling function {func.__name__} with arguments {args} {kwargs}: {e}')\n    return wrapper",
                "'\\n    Decorator to suppress and log any exceptions raised by a function.\\n    '",
                "@functools.wraps(func)\ndef wrapper(*args: P.args, **kwargs: P.kwargs) -> T | None:\n    try:\n        return func(*args, **kwargs)\n    except Exception as e:\n        logger.exception(f'Error when calling function {func.__name__} with arguments {args} {kwargs}: {e}')",
                "try:\n    return func(*args, **kwargs)\nexcept Exception as e:\n    logger.exception(f'Error when calling function {func.__name__} with arguments {args} {kwargs}: {e}')",
                "return func(*args, **kwargs)"
            ]
        },
        {
            "id": "6",
            "type": "block",
            "statements": [
                "logger.exception(f'Error when calling function {func.__name__} with arguments {args} {kwargs}: {e}')",
                "return wrapper"
            ]
        }
    ],
    "edges": []
}