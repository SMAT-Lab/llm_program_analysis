{
    "nodes": [
        {
            "id": "1",
            "type": "block",
            "statements": [
                "import time",
                "from typing import Tuple",
                "from redis import Redis",
                "from .config import RATE_LIMIT_SETTINGS",
                "class RateLimiter:\n\n    def __init__(self, redis_host: str=RATE_LIMIT_SETTINGS.redis_host, redis_port: str=RATE_LIMIT_SETTINGS.redis_port, redis_password: str=RATE_LIMIT_SETTINGS.redis_password, requests_per_minute: int=RATE_LIMIT_SETTINGS.requests_per_minute):\n        self.redis = Redis(host=redis_host, port=int(redis_port), password=redis_password, decode_responses=True)\n        self.window = 60\n        self.max_requests = requests_per_minute\n\n    async def check_rate_limit(self, api_key_id: str) -> Tuple[bool, int, int]:\n        \"\"\"\n        Check if request is within rate limits.\n\n        Args:\n            api_key_id: The API key identifier to check\n\n        Returns:\n            Tuple of (is_allowed, remaining_requests, reset_time)\n        \"\"\"\n        now = time.time()\n        window_start = now - self.window\n        key = f'ratelimit:{api_key_id}:1min'\n        pipe = self.redis.pipeline()\n        pipe.zremrangebyscore(key, 0, window_start)\n        pipe.zadd(key, {str(now): now})\n        pipe.zcount(key, window_start, now)\n        pipe.expire(key, self.window)\n        (_, _, request_count, _) = pipe.execute()\n        remaining = max(0, self.max_requests - request_count)\n        reset_time = int(now + self.window)\n        return (request_count <= self.max_requests, remaining, reset_time)",
                "def __init__(self, redis_host: str=RATE_LIMIT_SETTINGS.redis_host, redis_port: str=RATE_LIMIT_SETTINGS.redis_port, redis_password: str=RATE_LIMIT_SETTINGS.redis_password, requests_per_minute: int=RATE_LIMIT_SETTINGS.requests_per_minute):\n    self.redis = Redis(host=redis_host, port=int(redis_port), password=redis_password, decode_responses=True)\n    self.window = 60\n    self.max_requests = requests_per_minute",
                "self.redis = Redis(host=redis_host, port=int(redis_port), password=redis_password, decode_responses=True)",
                "self.window = 60",
                "self.max_requests = requests_per_minute",
                "async def check_rate_limit(self, api_key_id: str) -> Tuple[bool, int, int]:\n    \"\"\"\n        Check if request is within rate limits.\n\n        Args:\n            api_key_id: The API key identifier to check\n\n        Returns:\n            Tuple of (is_allowed, remaining_requests, reset_time)\n        \"\"\"\n    now = time.time()\n    window_start = now - self.window\n    key = f'ratelimit:{api_key_id}:1min'\n    pipe = self.redis.pipeline()\n    pipe.zremrangebyscore(key, 0, window_start)\n    pipe.zadd(key, {str(now): now})\n    pipe.zcount(key, window_start, now)\n    pipe.expire(key, self.window)\n    (_, _, request_count, _) = pipe.execute()\n    remaining = max(0, self.max_requests - request_count)\n    reset_time = int(now + self.window)\n    return (request_count <= self.max_requests, remaining, reset_time)",
                "'\\n        Check if request is within rate limits.\\n\\n        Args:\\n            api_key_id: The API key identifier to check\\n\\n        Returns:\\n            Tuple of (is_allowed, remaining_requests, reset_time)\\n        '",
                "now = time.time()",
                "window_start = now - self.window",
                "key = f'ratelimit:{api_key_id}:1min'",
                "pipe = self.redis.pipeline()",
                "pipe.zremrangebyscore(key, 0, window_start)",
                "pipe.zadd(key, {str(now): now})",
                "pipe.zcount(key, window_start, now)",
                "pipe.expire(key, self.window)",
                "(_, _, request_count, _) = pipe.execute()",
                "remaining = max(0, self.max_requests - request_count)",
                "reset_time = int(now + self.window)",
                "return (request_count <= self.max_requests, remaining, reset_time)"
            ]
        }
    ],
    "edges": []
}