{
  "nodes": [
    {
      "id": "n0",
      "code": "from datetime import datetime, timezone\nfrom typing import Iterator\n\nimport praw\nfrom pydantic import BaseModel, ConfigDict\n\nfrom backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema\nfrom backend.data.model import BlockSecret, SchemaField, SecretField\nfrom backend.util.mock import MockObject\n\n\n"
    },
    {
      "id": "n1",
      "code": "class RedditCredentials(BaseModel):\n\n    client_id: BlockSecret = SecretField(key=\"reddit_client_id\")\n    client_secret: BlockSecret = SecretField(key=\"reddit_client_secret\")\n    username: BlockSecret = SecretField(key=\"reddit_username\")\n    password: BlockSecret = SecretField(key=\"reddit_password\")\n    user_agent: str = \"AutoGPT:1.0 (by /u/autogpt)\"\n\n    model_config = ConfigDict(title=\"Reddit Credentials\")\n"
    },
    {
      "id": "n2",
      "code": "class RedditPost(BaseModel):\n    id: str\n    subreddit: str\n    title: str\n    body: str\n"
    },
    {
      "id": "n3",
      "code": "class RedditComment(BaseModel):\n    post_id: str\n    comment: str\n"
    },
    {
      "id": "n4",
      "code": "def get_praw(creds: RedditCredentials) -> praw.Reddit:\n    client = praw.Reddit(\n        client_id=creds.client_id.get_secret_value(),\n        client_secret=creds.client_secret.get_secret_value(),\n        username=creds.username.get_secret_value(),\n        password=creds.password.get_secret_value(),\n        user_agent=creds.user_agent,\n    )\n\n    me = client.user.me()\n\n    if not me:\n        raise ValueError(\"Invalid Reddit credentials.\")\n"
    },
    {
      "id": "n5",
      "code": "    print(f\"Logged in as Reddit user: {me.name}\")\n"
    },
    {
      "id": "n6",
      "code": "    return client\n"
    },
    {
      "id": "n7",
      "code": "class GetRedditPostsBlock(Block):\n\n    class Input(BlockSchema):\n        subreddit: str = SchemaField(description=\"Subreddit name\")\n        creds: RedditCredentials = SchemaField(\n            description=\"Reddit credentials\",\n            default=RedditCredentials(),\n        )\n        last_minutes: int | None = SchemaField(\n            description=\"Post time to stop minutes ago while fetching posts\",\n            default=None,\n        )\n        last_post: str | None = SchemaField(\n            description=\"Post ID to stop when reached while fetching posts\",\n            default=None,\n        )\n        post_limit: int | None = SchemaField(\n            description=\"Number of posts to fetch\", default=10\n        )\n\n    class Output(BlockSchema):\n        post: RedditPost = SchemaField(description=\"Reddit post\")\n\n    def __init__(self):\n        super().__init__(\n            disabled=True,\n            id=\"c6731acb-4285-4ee1-bc9b-03d0766c370f\",\n            description=\"This block fetches Reddit posts from a defined subreddit name.\",\n            categories={BlockCategory.SOCIAL},\n            input_schema=GetRedditPostsBlock.Input,\n            output_schema=GetRedditPostsBlock.Output,\n            test_input={\n                \"creds\": {\n                    \"client_id\": \"client_id\",\n                    \"client_secret\": \"client_secret\",\n                    \"username\": \"username\",\n                    \"password\": \"password\",\n                    \"user_agent\": \"user_agent\",\n                },\n                \"subreddit\": \"subreddit\",\n                \"last_post\": \"id3\",\n                \"post_limit\": 2,\n            },\n            test_output=[\n                (\n                    \"post\",\n                    RedditPost(\n                        id=\"id1\", subreddit=\"subreddit\", title=\"title1\", body=\"body1\"\n                    ),\n                ),\n                (\n                    \"post\",\n                    RedditPost(\n                        id=\"id2\", subreddit=\"subreddit\", title=\"title2\", body=\"body2\"\n                    ),\n                ),\n            ],\n            test_mock={\n                \"get_posts\": lambda _: [\n                    MockObject(id=\"id1\", title=\"title1\", selftext=\"body1\"),\n                    MockObject(id=\"id2\", title=\"title2\", selftext=\"body2\"),\n                    MockObject(id=\"id3\", title=\"title2\", selftext=\"body2\"),\n                ]\n            },\n        )\n\n    @staticmethod\n    def get_posts(input_data: Input) -> Iterator[praw.reddit.Submission]:\n        client = get_praw(input_data.creds)\n        subreddit = client.subreddit(input_data.subreddit)\n        return subreddit.new(limit=input_data.post_limit or 10)\n\n    def run(self, input_data: Input, **kwargs) -> BlockOutput:\n        current_time = datetime.now(tz=timezone.utc)\n        for post in self.get_posts(input_data):\n            if input_data.last_minutes:\n                post_datetime = datetime.fromtimestamp(\n                    post.created_utc, tz=timezone.utc\n                )\n                time_difference = current_time - post_datetime\n                if time_difference.total_seconds() / 60 > input_data.last_minutes:\n                    continue\n\n            if input_data.last_post and post.id == input_data.last_post:\n                break\n\n            yield \"post\", RedditPost(\n                id=post.id,\n                subreddit=input_data.subreddit,\n                title=post.title,\n                body=post.selftext,\n            )\n"
    },
    {
      "id": "n8",
      "code": "class PostRedditCommentBlock(Block):\n\n    class Input(BlockSchema):\n        creds: RedditCredentials = SchemaField(\n            description=\"Reddit credentials\", default=RedditCredentials()\n        )\n        data: RedditComment = SchemaField(description=\"Reddit comment\")\n\n    class Output(BlockSchema):\n        comment_id: str = SchemaField(description=\"Posted comment ID\")\n\n    def __init__(self):\n        super().__init__(\n            id=\"4a92261b-701e-4ffb-8970-675fd28e261f\",\n            description=\"This block posts a Reddit comment on a specified Reddit post.\",\n            categories={BlockCategory.SOCIAL},\n            input_schema=PostRedditCommentBlock.Input,\n            output_schema=PostRedditCommentBlock.Output,\n            test_input={\"data\": {\"post_id\": \"id\", \"comment\": \"comment\"}},\n            test_output=[(\"comment_id\", \"dummy_comment_id\")],\n            test_mock={\"reply_post\": lambda creds, comment: \"dummy_comment_id\"},\n        )\n\n    @staticmethod\n    def reply_post(creds: RedditCredentials, comment: RedditComment) -> str:\n        client = get_praw(creds)\n        submission = client.submission(id=comment.post_id)\n        new_comment = submission.reply(comment.comment)\n        if not new_comment:\n            raise ValueError(\"Failed to post comment.\")\n        return new_comment.id\n\n    def run(self, input_data: Input, **kwargs) -> BlockOutput:\n        yield \"comment_id\", self.reply_post(input_data.creds, input_data.data)\n"
    }
  ],
  "edges": [
    {
      "source": "n4",
      "target": "n6"
    },
    {
      "source": "n5",
      "target": "n6"
    },
    {
      "source": "n4",
      "target": "n5"
    }
  ]
}