{
  "nodes": [
    {
      "id": "1",
      "type": "block",
      "statements": [
        "from mrjob.job import MRJob",
        "class SalesRanker(MRJob):\n\n    def within_past_week(self, timestamp):\n        \"\"\"Return True if timestamp is within past week, False otherwise.\"\"\"\n        ...\n\n    def mapper(self, _, line):\n        \"\"\"Parse each log line, extract and transform relevant lines.\n\n        Emit key value pairs of the form:\n\n        (foo, p1), 2\n        (bar, p1), 2\n        (bar, p1), 1\n        (foo, p2), 3\n        (bar, p3), 10\n        (foo, p4), 1\n        \"\"\"\n        (timestamp, product_id, category, quantity) = line.split('\\t')\n        if self.within_past_week(timestamp):\n            yield ((category, product_id), quantity)\n\n    def reducer(self, key, values):\n        \"\"\"Sum values for each key.\n\n        (foo, p1), 2\n        (bar, p1), 3\n        (foo, p2), 3\n        (bar, p3), 10\n        (foo, p4), 1\n        \"\"\"\n        yield (key, sum(values))\n\n    def mapper_sort(self, key, value):\n        \"\"\"Construct key to ensure proper sorting.\n\n        Transform key and value to the form:\n\n        (foo, 2), p1\n        (bar, 3), p1\n        (foo, 3), p2\n        (bar, 10), p3\n        (foo, 1), p4\n\n        The shuffle/sort step of MapReduce will then do a\n        distributed sort on the keys, resulting in:\n\n        (category1, 1), product4\n        (category1, 2), product1\n        (category1, 3), product2\n        (category2, 3), product1\n        (category2, 7), product3\n        \"\"\"\n        (category, product_id) = key\n        quantity = value\n        yield ((category, quantity), product_id)\n\n    def reducer_identity(self, key, value):\n        yield (key, value)\n\n    def steps(self):\n        \"\"\"Run the map and reduce steps.\"\"\"\n        return [self.mr(mapper=self.mapper, reducer=self.reducer), self.mr(mapper=self.mapper_sort, reducer=self.reducer_identity)]",
        "def within_past_week(self, timestamp):\n    \"\"\"Return True if timestamp is within past week, False otherwise.\"\"\"\n    ...",
        "'Return True if timestamp is within past week, False otherwise.'",
        "Ellipsis",
        "def mapper(self, _, line):\n    \"\"\"Parse each log line, extract and transform relevant lines.\n\n        Emit key value pairs of the form:\n\n        (foo, p1), 2\n        (bar, p1), 2\n        (bar, p1), 1\n        (foo, p2), 3\n        (bar, p3), 10\n        (foo, p4), 1\n        \"\"\"\n    (timestamp, product_id, category, quantity) = line.split('\\t')\n    if self.within_past_week(timestamp):\n        yield ((category, product_id), quantity)",
        "'Parse each log line, extract and transform relevant lines.\\n\\n        Emit key value pairs of the form:\\n\\n        (foo, p1), 2\\n        (bar, p1), 2\\n        (bar, p1), 1\\n        (foo, p2), 3\\n        (bar, p3), 10\\n        (foo, p4), 1\\n        '",
        "(timestamp, product_id, category, quantity) = line.split('\\t')",
        "self.within_past_week(timestamp)"
      ]
    },
    {
      "id": "2",
      "type": "block",
      "statements": [
        "(yield ((category, product_id), quantity))"
      ]
    },
    {
      "id": "3",
      "type": "block",
      "statements": []
    },
    {
      "id": "4",
      "type": "block",
      "statements": [
        "def reducer(self, key, values):\n    \"\"\"Sum values for each key.\n\n        (foo, p1), 2\n        (bar, p1), 3\n        (foo, p2), 3\n        (bar, p3), 10\n        (foo, p4), 1\n        \"\"\"\n    yield (key, sum(values))",
        "'Sum values for each key.\\n\\n        (foo, p1), 2\\n        (bar, p1), 3\\n        (foo, p2), 3\\n        (bar, p3), 10\\n        (foo, p4), 1\\n        '",
        "(yield (key, sum(values)))",
        "def mapper_sort(self, key, value):\n    \"\"\"Construct key to ensure proper sorting.\n\n        Transform key and value to the form:\n\n        (foo, 2), p1\n        (bar, 3), p1\n        (foo, 3), p2\n        (bar, 10), p3\n        (foo, 1), p4\n\n        The shuffle/sort step of MapReduce will then do a\n        distributed sort on the keys, resulting in:\n\n        (category1, 1), product4\n        (category1, 2), product1\n        (category1, 3), product2\n        (category2, 3), product1\n        (category2, 7), product3\n        \"\"\"\n    (category, product_id) = key\n    quantity = value\n    yield ((category, quantity), product_id)",
        "'Construct key to ensure proper sorting.\\n\\n        Transform key and value to the form:\\n\\n        (foo, 2), p1\\n        (bar, 3), p1\\n        (foo, 3), p2\\n        (bar, 10), p3\\n        (foo, 1), p4\\n\\n        The shuffle/sort step of MapReduce will then do a\\n        distributed sort on the keys, resulting in:\\n\\n        (category1, 1), product4\\n        (category1, 2), product1\\n        (category1, 3), product2\\n        (category2, 3), product1\\n        (category2, 7), product3\\n        '",
        "(category, product_id) = key",
        "quantity = value",
        "(yield ((category, quantity), product_id))",
        "def reducer_identity(self, key, value):\n    yield (key, value)",
        "(yield (key, value))",
        "def steps(self):\n    \"\"\"Run the map and reduce steps.\"\"\"\n    return [self.mr(mapper=self.mapper, reducer=self.reducer), self.mr(mapper=self.mapper_sort, reducer=self.reducer_identity)]",
        "'Run the map and reduce steps.'",
        "return [self.mr(mapper=self.mapper, reducer=self.reducer), self.mr(mapper=self.mapper_sort, reducer=self.reducer_identity)]"
      ]
    },
    {
      "id": "5",
      "type": "block",
      "statements": [
        "__name__ Eq '__main__'"
      ]
    },
    {
      "id": "6",
      "type": "block",
      "statements": [
        "SalesRanker.run()"
      ]
    },
    {
      "id": "7",
      "type": "block",
      "statements": []
    },
    {
      "id": "8",
      "type": "block",
      "statements": []
    }
  ],
  "edges": [
    {
      "source": "1",
      "target": "2",
      "type": "true"
    },
    {
      "source": "1",
      "target": "3",
      "type": "false"
    },
    {
      "source": "2",
      "target": "4",
      "type": "next"
    },
    {
      "source": "3",
      "target": "4",
      "type": "next"
    },
    {
      "source": "5",
      "target": "6",
      "type": "true"
    },
    {
      "source": "5",
      "target": "7",
      "type": "false"
    },
    {
      "source": "6",
      "target": "8",
      "type": "next"
    },
    {
      "source": "7",
      "target": "8",
      "type": "next"
    }
  ]
}