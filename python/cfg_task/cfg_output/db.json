{
  "nodes": [
    {
      "id": "1",
      "type": "block",
      "statements": [
        "import datetime",
        "import typing",
        "import fuzzywuzzy.fuzz",
        "import prisma.enums",
        "import prisma.errors",
        "import prisma.models",
        "import prisma.types",
        "import pydantic",
        "import market.model",
        "import market.utils.extension_types",
        "class AgentQueryError(Exception):\n    \"\"\"Custom exception for agent query errors\"\"\"\n    pass",
        "'Custom exception for agent query errors'",
        "pass",
        "class TopAgentsDBResponse(pydantic.BaseModel):\n    \"\"\"\n    Represents a response containing a list of top agents.\n\n    Attributes:\n        analytics (list[AgentResponse]): The list of top agents.\n        total_count (int): The total count of agents.\n        page (int): The current page number.\n        page_size (int): The number of agents per page.\n        total_pages (int): The total number of pages.\n    \"\"\"\n    analytics: list[prisma.models.AnalyticsTracker]\n    total_count: int\n    page: int\n    page_size: int\n    total_pages: int",
        "'\\n    Represents a response containing a list of top agents.\\n\\n    Attributes:\\n        analytics (list[AgentResponse]): The list of top agents.\\n        total_count (int): The total count of agents.\\n        page (int): The current page number.\\n        page_size (int): The number of agents per page.\\n        total_pages (int): The total number of pages.\\n    '",
        "analytics: list[prisma.models.AnalyticsTracker]",
        "total_count: int",
        "page: int",
        "page_size: int",
        "total_pages: int",
        "class FeaturedAgentResponse(pydantic.BaseModel):\n    \"\"\"\n    Represents a response containing a list of featured agents.\n\n    Attributes:\n        featured_agents (list[FeaturedAgent]): The list of featured agents.\n        total_count (int): The total count of featured agents.\n        page (int): The current page number.\n        page_size (int): The number of agents per page.\n        total_pages (int): The total number of pages.\n    \"\"\"\n    featured_agents: list[prisma.models.FeaturedAgent]\n    total_count: int\n    page: int\n    page_size: int\n    total_pages: int",
        "'\\n    Represents a response containing a list of featured agents.\\n\\n    Attributes:\\n        featured_agents (list[FeaturedAgent]): The list of featured agents.\\n        total_count (int): The total count of featured agents.\\n        page (int): The current page number.\\n        page_size (int): The number of agents per page.\\n        total_pages (int): The total number of pages.\\n    '",
        "featured_agents: list[prisma.models.FeaturedAgent]",
        "total_count: int",
        "page: int",
        "page_size: int",
        "total_pages: int",
        "async def delete_agent(agent_id: str) -> prisma.models.Agents | None:\n    \"\"\"\n    Delete an agent from the database.\n\n    Args:\n        agent_id (str): The ID of the agent to delete.\n\n    Returns:\n        prisma.models.Agents | None: The deleted agent if found, None otherwise.\n\n    Raises:\n        AgentQueryError: If there is an error deleting the agent from the database.\n    \"\"\"\n    try:\n        deleted_agent = await prisma.models.Agents.prisma().delete(where={'id': agent_id})\n        return deleted_agent\n    except prisma.errors.PrismaError as e:\n        raise AgentQueryError(f'Database query failed: {str(e)}')\n    except Exception as e:\n        raise AgentQueryError(f'Unexpected error occurred: {str(e)}')",
        "'\\n    Delete an agent from the database.\\n\\n    Args:\\n        agent_id (str): The ID of the agent to delete.\\n\\n    Returns:\\n        prisma.models.Agents | None: The deleted agent if found, None otherwise.\\n\\n    Raises:\\n        AgentQueryError: If there is an error deleting the agent from the database.\\n    '",
        "try:\n    deleted_agent = await prisma.models.Agents.prisma().delete(where={'id': agent_id})\n    return deleted_agent\nexcept prisma.errors.PrismaError as e:\n    raise AgentQueryError(f'Database query failed: {str(e)}')\nexcept Exception as e:\n    raise AgentQueryError(f'Unexpected error occurred: {str(e)}')",
        "deleted_agent = await prisma.models.Agents.prisma().delete(where={'id': agent_id})",
        "return deleted_agent"
      ]
    },
    {
      "id": "2",
      "type": "block",
      "statements": [
        "raise AgentQueryError(f'Database query failed: {str(e)}')",
        "raise AgentQueryError(f'Unexpected error occurred: {str(e)}')",
        "async def create_agent_entry(name: str, description: str, author: str, keywords: typing.List[str], categories: typing.List[str], graph: prisma.Json, submission_state: prisma.enums.SubmissionStatus=prisma.enums.SubmissionStatus.PENDING):\n    \"\"\"\n    Create a new agent entry in the database.\n\n    Args:\n        name (str): The name of the agent.\n        description (str): The description of the agent.\n        author (str): The author of the agent.\n        keywords (List[str]): The keywords associated with the agent.\n        categories (List[str]): The categories associated with the agent.\n        graph (dict): The graph data of the agent.\n\n    Returns:\n        dict: The newly created agent entry.\n\n    Raises:\n        AgentQueryError: If there is an error creating the agent entry.\n    \"\"\"\n    try:\n        agent = await prisma.models.Agents.prisma().create(data={'name': name, 'description': description, 'author': author, 'keywords': keywords, 'categories': categories, 'graph': graph, 'AnalyticsTracker': {'create': {'downloads': 0, 'views': 0}}, 'submissionStatus': submission_state})\n        return agent\n    except prisma.errors.PrismaError as e:\n        raise AgentQueryError(f'Database query failed: {str(e)}')\n    except Exception as e:\n        raise AgentQueryError(f'Unexpected error occurred: {str(e)}')",
        "'\\n    Create a new agent entry in the database.\\n\\n    Args:\\n        name (str): The name of the agent.\\n        description (str): The description of the agent.\\n        author (str): The author of the agent.\\n        keywords (List[str]): The keywords associated with the agent.\\n        categories (List[str]): The categories associated with the agent.\\n        graph (dict): The graph data of the agent.\\n\\n    Returns:\\n        dict: The newly created agent entry.\\n\\n    Raises:\\n        AgentQueryError: If there is an error creating the agent entry.\\n    '",
        "try:\n    agent = await prisma.models.Agents.prisma().create(data={'name': name, 'description': description, 'author': author, 'keywords': keywords, 'categories': categories, 'graph': graph, 'AnalyticsTracker': {'create': {'downloads': 0, 'views': 0}}, 'submissionStatus': submission_state})\n    return agent\nexcept prisma.errors.PrismaError as e:\n    raise AgentQueryError(f'Database query failed: {str(e)}')\nexcept Exception as e:\n    raise AgentQueryError(f'Unexpected error occurred: {str(e)}')",
        "agent = await prisma.models.Agents.prisma().create(data={'name': name, 'description': description, 'author': author, 'keywords': keywords, 'categories': categories, 'graph': graph, 'AnalyticsTracker': {'create': {'downloads': 0, 'views': 0}}, 'submissionStatus': submission_state})",
        "return agent"
      ]
    },
    {
      "id": "3",
      "type": "block",
      "statements": [
        "raise AgentQueryError(f'Database query failed: {str(e)}')",
        "raise AgentQueryError(f'Unexpected error occurred: {str(e)}')",
        "async def update_agent_entry(agent_id: str, version: int, submission_state: prisma.enums.SubmissionStatus, comments: str | None=None) -> prisma.models.Agents | None:\n    \"\"\"\n    Update an existing agent entry in the database.\n\n    Args:\n        agent_id (str): The ID of the agent.\n        version (int): The version of the agent.\n        submission_state (prisma.enums.SubmissionStatus): The submission state of the agent.\n    \"\"\"\n    try:\n        agent = await prisma.models.Agents.prisma().update(where={'id': agent_id}, data={'version': version, 'submissionStatus': submission_state, 'submissionReviewDate': datetime.datetime.now(datetime.timezone.utc), 'submissionReviewComments': comments})\n        return agent\n    except prisma.errors.PrismaError as e:\n        raise AgentQueryError(f'Agent Update Failed Database query failed: {str(e)}')\n    except Exception as e:\n        raise AgentQueryError(f'Unexpected error occurred: {str(e)}')",
        "'\\n    Update an existing agent entry in the database.\\n\\n    Args:\\n        agent_id (str): The ID of the agent.\\n        version (int): The version of the agent.\\n        submission_state (prisma.enums.SubmissionStatus): The submission state of the agent.\\n    '",
        "try:\n    agent = await prisma.models.Agents.prisma().update(where={'id': agent_id}, data={'version': version, 'submissionStatus': submission_state, 'submissionReviewDate': datetime.datetime.now(datetime.timezone.utc), 'submissionReviewComments': comments})\n    return agent\nexcept prisma.errors.PrismaError as e:\n    raise AgentQueryError(f'Agent Update Failed Database query failed: {str(e)}')\nexcept Exception as e:\n    raise AgentQueryError(f'Unexpected error occurred: {str(e)}')",
        "agent = await prisma.models.Agents.prisma().update(where={'id': agent_id}, data={'version': version, 'submissionStatus': submission_state, 'submissionReviewDate': datetime.datetime.now(datetime.timezone.utc), 'submissionReviewComments': comments})",
        "return agent"
      ]
    },
    {
      "id": "4",
      "type": "block",
      "statements": [
        "raise AgentQueryError(f'Agent Update Failed Database query failed: {str(e)}')",
        "raise AgentQueryError(f'Unexpected error occurred: {str(e)}')",
        "async def get_agents(page: int=1, page_size: int=10, name: str | None=None, keyword: str | None=None, category: str | None=None, description: str | None=None, description_threshold: int=60, submission_status: prisma.enums.SubmissionStatus=prisma.enums.SubmissionStatus.APPROVED, sort_by: str='createdAt', sort_order: typing.Literal['desc'] | typing.Literal['asc']='desc'):\n    \"\"\"\n    Retrieve a list of agents from the database based on the provided filters and pagination parameters.\n\n    Args:\n        page (int, optional): The page number to retrieve. Defaults to 1.\n        page_size (int, optional): The number of agents per page. Defaults to 10.\n        name (str, optional): Filter agents by name. Defaults to None.\n        keyword (str, optional): Filter agents by keyword. Defaults to None.\n        category (str, optional): Filter agents by category. Defaults to None.\n        description (str, optional): Filter agents by description. Defaults to None.\n        description_threshold (int, optional): The minimum fuzzy search threshold for the description. Defaults to 60.\n        sort_by (str, optional): The field to sort the agents by. Defaults to \"createdAt\".\n        sort_order (str, optional): The sort order (\"asc\" or \"desc\"). Defaults to \"desc\".\n\n    Returns:\n        dict: A dictionary containing the list of agents, total count, current page number, page size, and total number of pages.\n    \"\"\"\n    try:\n        query = {}\n        if name:\n            query['name'] = {'contains': name, 'mode': 'insensitive'}\n        if keyword:\n            query['keywords'] = {'has': keyword}\n        if category:\n            query['categories'] = {'has': category}\n        query['submissionStatus'] = submission_status\n        order = {sort_by: sort_order}\n        skip = (page - 1) * page_size\n        try:\n            agents = await prisma.models.Agents.prisma().find_many(where=query, order=order, skip=skip, take=page_size)\n        except prisma.errors.PrismaError as e:\n            raise AgentQueryError(f'Database query failed: {str(e)}')\n        if description:\n            try:\n                filtered_agents = []\n                for agent in agents:\n                    if agent.description and fuzzywuzzy.fuzz.partial_ratio(description.lower(), agent.description.lower()) >= description_threshold:\n                        filtered_agents.append(agent)\n                agents = filtered_agents\n            except AttributeError as e:\n                raise AgentQueryError(f'Error during fuzzy search: {str(e)}')\n        total_count = len(agents)\n        return {'agents': agents, 'total_count': total_count, 'page': page, 'page_size': page_size, 'total_pages': (total_count + page_size - 1) // page_size}\n    except AgentQueryError as e:\n        raise e\n    except ValueError as e:\n        raise AgentQueryError(f'Invalid input parameter: {str(e)}')\n    except Exception as e:\n        raise AgentQueryError(f'Unexpected error occurred: {str(e)}')",
        "'\\n    Retrieve a list of agents from the database based on the provided filters and pagination parameters.\\n\\n    Args:\\n        page (int, optional): The page number to retrieve. Defaults to 1.\\n        page_size (int, optional): The number of agents per page. Defaults to 10.\\n        name (str, optional): Filter agents by name. Defaults to None.\\n        keyword (str, optional): Filter agents by keyword. Defaults to None.\\n        category (str, optional): Filter agents by category. Defaults to None.\\n        description (str, optional): Filter agents by description. Defaults to None.\\n        description_threshold (int, optional): The minimum fuzzy search threshold for the description. Defaults to 60.\\n        sort_by (str, optional): The field to sort the agents by. Defaults to \"createdAt\".\\n        sort_order (str, optional): The sort order (\"asc\" or \"desc\"). Defaults to \"desc\".\\n\\n    Returns:\\n        dict: A dictionary containing the list of agents, total count, current page number, page size, and total number of pages.\\n    '",
        "try:\n    query = {}\n    if name:\n        query['name'] = {'contains': name, 'mode': 'insensitive'}\n    if keyword:\n        query['keywords'] = {'has': keyword}\n    if category:\n        query['categories'] = {'has': category}\n    query['submissionStatus'] = submission_status\n    order = {sort_by: sort_order}\n    skip = (page - 1) * page_size\n    try:\n        agents = await prisma.models.Agents.prisma().find_many(where=query, order=order, skip=skip, take=page_size)\n    except prisma.errors.PrismaError as e:\n        raise AgentQueryError(f'Database query failed: {str(e)}')\n    if description:\n        try:\n            filtered_agents = []\n            for agent in agents:\n                if agent.description and fuzzywuzzy.fuzz.partial_ratio(description.lower(), agent.description.lower()) >= description_threshold:\n                    filtered_agents.append(agent)\n            agents = filtered_agents\n        except AttributeError as e:\n            raise AgentQueryError(f'Error during fuzzy search: {str(e)}')\n    total_count = len(agents)\n    return {'agents': agents, 'total_count': total_count, 'page': page, 'page_size': page_size, 'total_pages': (total_count + page_size - 1) // page_size}\nexcept AgentQueryError as e:\n    raise e\nexcept ValueError as e:\n    raise AgentQueryError(f'Invalid input parameter: {str(e)}')\nexcept Exception as e:\n    raise AgentQueryError(f'Unexpected error occurred: {str(e)}')",
        "query = {}",
        "name"
      ]
    },
    {
      "id": "5",
      "type": "block",
      "statements": [
        "query['name'] = {'contains': name, 'mode': 'insensitive'}"
      ]
    },
    {
      "id": "6",
      "type": "block",
      "statements": []
    },
    {
      "id": "7",
      "type": "block",
      "statements": [
        "keyword"
      ]
    },
    {
      "id": "8",
      "type": "block",
      "statements": [
        "query['keywords'] = {'has': keyword}"
      ]
    },
    {
      "id": "9",
      "type": "block",
      "statements": []
    },
    {
      "id": "10",
      "type": "block",
      "statements": [
        "category"
      ]
    },
    {
      "id": "11",
      "type": "block",
      "statements": [
        "query['categories'] = {'has': category}"
      ]
    },
    {
      "id": "12",
      "type": "block",
      "statements": []
    },
    {
      "id": "13",
      "type": "block",
      "statements": [
        "query['submissionStatus'] = submission_status",
        "order = {sort_by: sort_order}",
        "skip = (page - 1) * page_size",
        "try:\n    agents = await prisma.models.Agents.prisma().find_many(where=query, order=order, skip=skip, take=page_size)\nexcept prisma.errors.PrismaError as e:\n    raise AgentQueryError(f'Database query failed: {str(e)}')",
        "agents = await prisma.models.Agents.prisma().find_many(where=query, order=order, skip=skip, take=page_size)",
        "raise AgentQueryError(f'Database query failed: {str(e)}')",
        "description"
      ]
    },
    {
      "id": "14",
      "type": "block",
      "statements": [
        "try:\n    filtered_agents = []\n    for agent in agents:\n        if agent.description and fuzzywuzzy.fuzz.partial_ratio(description.lower(), agent.description.lower()) >= description_threshold:\n            filtered_agents.append(agent)\n    agents = filtered_agents\nexcept AttributeError as e:\n    raise AgentQueryError(f'Error during fuzzy search: {str(e)}')",
        "filtered_agents = []"
      ]
    },
    {
      "id": "15",
      "type": "block",
      "statements": []
    },
    {
      "id": "16",
      "type": "block",
      "statements": [
        "total_count = len(agents)",
        "return {'agents': agents, 'total_count': total_count, 'page': page, 'page_size': page_size, 'total_pages': (total_count + page_size - 1) // page_size}"
      ]
    },
    {
      "id": "17",
      "type": "block",
      "statements": [
        "agent",
        "agents"
      ]
    },
    {
      "id": "18",
      "type": "block",
      "statements": [
        "agent.description and fuzzywuzzy.fuzz.partial_ratio(description.lower(), agent.description.lower()) >= description_threshold"
      ]
    },
    {
      "id": "19",
      "type": "block",
      "statements": [
        "agents = filtered_agents",
        "raise AgentQueryError(f'Error during fuzzy search: {str(e)}')"
      ]
    },
    {
      "id": "20",
      "type": "block",
      "statements": [
        "filtered_agents.append(agent)"
      ]
    },
    {
      "id": "21",
      "type": "block",
      "statements": []
    },
    {
      "id": "22",
      "type": "block",
      "statements": []
    },
    {
      "id": "23",
      "type": "block",
      "statements": [
        "raise e",
        "raise AgentQueryError(f'Invalid input parameter: {str(e)}')",
        "raise AgentQueryError(f'Unexpected error occurred: {str(e)}')",
        "async def get_agent_details(agent_id: str, version: int | None=None):\n    \"\"\"\n    Retrieve agent details from the database.\n\n    Args:\n        agent_id (str): The ID of the agent.\n        version (int | None, optional): The version of the agent. Defaults to None.\n\n    Returns:\n        dict: The agent details.\n\n    Raises:\n        AgentQueryError: If the agent is not found or if there is an error querying the database.\n    \"\"\"\n    try:\n        query = {'id': agent_id}\n        if version is not None:\n            query['version'] = version\n        agent = await prisma.models.Agents.prisma().find_first(where=query)\n        if not agent:\n            raise AgentQueryError('Agent not found')\n        return agent\n    except prisma.errors.PrismaError as e:\n        raise AgentQueryError(f'Database query failed: {str(e)}')\n    except Exception as e:\n        raise AgentQueryError(f'Unexpected error occurred: {str(e)}')",
        "'\\n    Retrieve agent details from the database.\\n\\n    Args:\\n        agent_id (str): The ID of the agent.\\n        version (int | None, optional): The version of the agent. Defaults to None.\\n\\n    Returns:\\n        dict: The agent details.\\n\\n    Raises:\\n        AgentQueryError: If the agent is not found or if there is an error querying the database.\\n    '",
        "try:\n    query = {'id': agent_id}\n    if version is not None:\n        query['version'] = version\n    agent = await prisma.models.Agents.prisma().find_first(where=query)\n    if not agent:\n        raise AgentQueryError('Agent not found')\n    return agent\nexcept prisma.errors.PrismaError as e:\n    raise AgentQueryError(f'Database query failed: {str(e)}')\nexcept Exception as e:\n    raise AgentQueryError(f'Unexpected error occurred: {str(e)}')",
        "query = {'id': agent_id}",
        "version IsNot None"
      ]
    },
    {
      "id": "24",
      "type": "block",
      "statements": [
        "query['version'] = version"
      ]
    },
    {
      "id": "25",
      "type": "block",
      "statements": []
    },
    {
      "id": "26",
      "type": "block",
      "statements": [
        "agent = await prisma.models.Agents.prisma().find_first(where=query)",
        "not agent"
      ]
    },
    {
      "id": "27",
      "type": "block",
      "statements": [
        "raise AgentQueryError('Agent not found')"
      ]
    },
    {
      "id": "28",
      "type": "block",
      "statements": []
    },
    {
      "id": "29",
      "type": "block",
      "statements": [
        "return agent"
      ]
    },
    {
      "id": "30",
      "type": "block",
      "statements": [
        "raise AgentQueryError(f'Database query failed: {str(e)}')",
        "raise AgentQueryError(f'Unexpected error occurred: {str(e)}')",
        "async def search_db(query: str, page: int=1, page_size: int=10, categories: typing.List[str] | None=None, description_threshold: int=60, sort_by: str='rank', sort_order: typing.Literal['desc'] | typing.Literal['asc']='desc', submission_status: prisma.enums.SubmissionStatus=prisma.enums.SubmissionStatus.APPROVED) -> market.model.ListResponse[market.utils.extension_types.AgentsWithRank]:\n    \"\"\"Perform a search for agents based on the provided query string.\n\n    Args:\n        query (str): the search string\n        page (int, optional): page for searching. Defaults to 1.\n        page_size (int, optional): the number of results to return. Defaults to 10.\n        categories (List[str] | None, optional): list of category filters. Defaults to None.\n        description_threshold (int, optional): number of characters to return. Defaults to 60.\n        sort_by (str, optional): sort by option. Defaults to \"rank\".\n        sort_order (\"asc\" | \"desc\", optional): the sort order. Defaults to \"desc\".\n\n    Raises:\n        AgentQueryError: Raises an error if the query fails.\n        AgentQueryError: Raises if an unexpected error occurs.\n\n    Returns:\n        List[AgentsWithRank]: List of agents matching the search criteria.\n    \"\"\"\n    try:\n        offset = (page - 1) * page_size\n        category_filter = '1=1'\n        if categories:\n            category_conditions = [f\"'{cat}' = ANY(categories)\" for cat in categories]\n            category_filter = 'AND (' + ' OR '.join(category_conditions) + ')'\n        if sort_by in ['createdAt', 'updatedAt']:\n            order_by_clause = f'\"{sort_by}\" {sort_order.upper()}, rank DESC'\n        elif sort_by == 'name':\n            order_by_clause = f'name {sort_order.upper()}, rank DESC'\n        else:\n            order_by_clause = 'rank DESC, \"createdAt\" DESC'\n        submission_status_filter = f\"\"\"\"submissionStatus\" = '{submission_status}'\"\"\"\n        sql_query = f\"\"\"\\n        WITH query AS (\\n            SELECT to_tsquery(string_agg(lexeme || ':*', ' & ' ORDER BY positions)) AS q \\n            FROM unnest(to_tsvector('{query}'))\\n        )\\n        SELECT \\n            id, \\n            \"createdAt\", \\n            \"updatedAt\", \\n            version, \\n            name, \\n            LEFT(description, {description_threshold}) AS description, \\n            author, \\n            keywords, \\n            categories, \\n            graph,\\n            \"submissionStatus\",\\n            \"submissionDate\",\\n            CASE \\n                WHEN query.q::text = '' THEN 1.0\\n                ELSE COALESCE(ts_rank(CAST(search AS tsvector), query.q), 0.0)\\n            END AS rank\\n        FROM market.\"Agents\", query\\n        WHERE \\n            (query.q::text = '' OR search @@ query.q)\\n            AND {category_filter} \\n            AND {submission_status_filter}\\n        ORDER BY {order_by_clause}\\n        LIMIT {page_size}\\n        OFFSET {offset};\\n        \"\"\"\n        results = await prisma.client.get_client().query_raw(query=sql_query, model=market.utils.extension_types.AgentsWithRank)\n\n        class CountResponse(pydantic.BaseModel):\n            count: int\n        count_query = f\"\"\"\\n        WITH query AS (\\n            SELECT to_tsquery(string_agg(lexeme || ':*', ' & ' ORDER BY positions)) AS q \\n            FROM unnest(to_tsvector('{query}'))\\n        )\\n        SELECT COUNT(*)\\n        FROM market.\"Agents\", query\\n        WHERE (search @@ query.q OR query.q = '') AND {category_filter} AND {submission_status_filter};\\n        \"\"\"\n        total_count = await prisma.client.get_client().query_first(query=count_query, model=CountResponse)\n        total_count = total_count.count if total_count else 0\n        return market.model.ListResponse(items=results, total_count=total_count, page=page, page_size=page_size, total_pages=(total_count + page_size - 1) // page_size)\n    except prisma.errors.PrismaError as e:\n        raise AgentQueryError(f'Database query failed: {str(e)}')\n    except Exception as e:\n        raise AgentQueryError(f'Unexpected error occurred: {str(e)}')",
        "'Perform a search for agents based on the provided query string.\\n\\n    Args:\\n        query (str): the search string\\n        page (int, optional): page for searching. Defaults to 1.\\n        page_size (int, optional): the number of results to return. Defaults to 10.\\n        categories (List[str] | None, optional): list of category filters. Defaults to None.\\n        description_threshold (int, optional): number of characters to return. Defaults to 60.\\n        sort_by (str, optional): sort by option. Defaults to \"rank\".\\n        sort_order (\"asc\" | \"desc\", optional): the sort order. Defaults to \"desc\".\\n\\n    Raises:\\n        AgentQueryError: Raises an error if the query fails.\\n        AgentQueryError: Raises if an unexpected error occurs.\\n\\n    Returns:\\n        List[AgentsWithRank]: List of agents matching the search criteria.\\n    '",
        "try:\n    offset = (page - 1) * page_size\n    category_filter = '1=1'\n    if categories:\n        category_conditions = [f\"'{cat}' = ANY(categories)\" for cat in categories]\n        category_filter = 'AND (' + ' OR '.join(category_conditions) + ')'\n    if sort_by in ['createdAt', 'updatedAt']:\n        order_by_clause = f'\"{sort_by}\" {sort_order.upper()}, rank DESC'\n    elif sort_by == 'name':\n        order_by_clause = f'name {sort_order.upper()}, rank DESC'\n    else:\n        order_by_clause = 'rank DESC, \"createdAt\" DESC'\n    submission_status_filter = f\"\"\"\"submissionStatus\" = '{submission_status}'\"\"\"\n    sql_query = f\"\"\"\\n        WITH query AS (\\n            SELECT to_tsquery(string_agg(lexeme || ':*', ' & ' ORDER BY positions)) AS q \\n            FROM unnest(to_tsvector('{query}'))\\n        )\\n        SELECT \\n            id, \\n            \"createdAt\", \\n            \"updatedAt\", \\n            version, \\n            name, \\n            LEFT(description, {description_threshold}) AS description, \\n            author, \\n            keywords, \\n            categories, \\n            graph,\\n            \"submissionStatus\",\\n            \"submissionDate\",\\n            CASE \\n                WHEN query.q::text = '' THEN 1.0\\n                ELSE COALESCE(ts_rank(CAST(search AS tsvector), query.q), 0.0)\\n            END AS rank\\n        FROM market.\"Agents\", query\\n        WHERE \\n            (query.q::text = '' OR search @@ query.q)\\n            AND {category_filter} \\n            AND {submission_status_filter}\\n        ORDER BY {order_by_clause}\\n        LIMIT {page_size}\\n        OFFSET {offset};\\n        \"\"\"\n    results = await prisma.client.get_client().query_raw(query=sql_query, model=market.utils.extension_types.AgentsWithRank)\n\n    class CountResponse(pydantic.BaseModel):\n        count: int\n    count_query = f\"\"\"\\n        WITH query AS (\\n            SELECT to_tsquery(string_agg(lexeme || ':*', ' & ' ORDER BY positions)) AS q \\n            FROM unnest(to_tsvector('{query}'))\\n        )\\n        SELECT COUNT(*)\\n        FROM market.\"Agents\", query\\n        WHERE (search @@ query.q OR query.q = '') AND {category_filter} AND {submission_status_filter};\\n        \"\"\"\n    total_count = await prisma.client.get_client().query_first(query=count_query, model=CountResponse)\n    total_count = total_count.count if total_count else 0\n    return market.model.ListResponse(items=results, total_count=total_count, page=page, page_size=page_size, total_pages=(total_count + page_size - 1) // page_size)\nexcept prisma.errors.PrismaError as e:\n    raise AgentQueryError(f'Database query failed: {str(e)}')\nexcept Exception as e:\n    raise AgentQueryError(f'Unexpected error occurred: {str(e)}')",
        "offset = (page - 1) * page_size",
        "category_filter = '1=1'",
        "categories"
      ]
    },
    {
      "id": "31",
      "type": "block",
      "statements": [
        "category_conditions = [f\"'{cat}' = ANY(categories)\" for cat in categories]",
        "category_filter = 'AND (' + ' OR '.join(category_conditions) + ')'"
      ]
    },
    {
      "id": "32",
      "type": "block",
      "statements": []
    },
    {
      "id": "33",
      "type": "block",
      "statements": [
        "sort_by In ['createdAt', 'updatedAt']"
      ]
    },
    {
      "id": "34",
      "type": "block",
      "statements": [
        "order_by_clause = f'\"{sort_by}\" {sort_order.upper()}, rank DESC'"
      ]
    },
    {
      "id": "35",
      "type": "block",
      "statements": [
        "sort_by Eq 'name'"
      ]
    },
    {
      "id": "36",
      "type": "block",
      "statements": [
        "submission_status_filter = f\"\"\"\"submissionStatus\" = '{submission_status}'\"\"\"",
        "sql_query = f\"\"\"\\n        WITH query AS (\\n            SELECT to_tsquery(string_agg(lexeme || ':*', ' & ' ORDER BY positions)) AS q \\n            FROM unnest(to_tsvector('{query}'))\\n        )\\n        SELECT \\n            id, \\n            \"createdAt\", \\n            \"updatedAt\", \\n            version, \\n            name, \\n            LEFT(description, {description_threshold}) AS description, \\n            author, \\n            keywords, \\n            categories, \\n            graph,\\n            \"submissionStatus\",\\n            \"submissionDate\",\\n            CASE \\n                WHEN query.q::text = '' THEN 1.0\\n                ELSE COALESCE(ts_rank(CAST(search AS tsvector), query.q), 0.0)\\n            END AS rank\\n        FROM market.\"Agents\", query\\n        WHERE \\n            (query.q::text = '' OR search @@ query.q)\\n            AND {category_filter} \\n            AND {submission_status_filter}\\n        ORDER BY {order_by_clause}\\n        LIMIT {page_size}\\n        OFFSET {offset};\\n        \"\"\"",
        "results = await prisma.client.get_client().query_raw(query=sql_query, model=market.utils.extension_types.AgentsWithRank)",
        "class CountResponse(pydantic.BaseModel):\n    count: int",
        "count: int",
        "count_query = f\"\"\"\\n        WITH query AS (\\n            SELECT to_tsquery(string_agg(lexeme || ':*', ' & ' ORDER BY positions)) AS q \\n            FROM unnest(to_tsvector('{query}'))\\n        )\\n        SELECT COUNT(*)\\n        FROM market.\"Agents\", query\\n        WHERE (search @@ query.q OR query.q = '') AND {category_filter} AND {submission_status_filter};\\n        \"\"\"",
        "total_count = await prisma.client.get_client().query_first(query=count_query, model=CountResponse)",
        "total_count = total_count.count if total_count else 0",
        "return market.model.ListResponse(items=results, total_count=total_count, page=page, page_size=page_size, total_pages=(total_count + page_size - 1) // page_size)"
      ]
    },
    {
      "id": "37",
      "type": "block",
      "statements": [
        "order_by_clause = f'name {sort_order.upper()}, rank DESC'"
      ]
    },
    {
      "id": "38",
      "type": "block",
      "statements": [
        "order_by_clause = 'rank DESC, \"createdAt\" DESC'"
      ]
    },
    {
      "id": "39",
      "type": "block",
      "statements": []
    },
    {
      "id": "40",
      "type": "block",
      "statements": [
        "raise AgentQueryError(f'Database query failed: {str(e)}')",
        "raise AgentQueryError(f'Unexpected error occurred: {str(e)}')",
        "async def get_top_agents_by_downloads(page: int=1, page_size: int=10, submission_status: prisma.enums.SubmissionStatus=prisma.enums.SubmissionStatus.APPROVED) -> market.model.ListResponse[prisma.models.AnalyticsTracker]:\n    \"\"\"Retrieve the top agents by download count.\n\n    Args:\n        page (int, optional): The page number. Defaults to 1.\n        page_size (int, optional): The number of agents per page. Defaults to 10.\n\n    Returns:\n        dict: A dictionary containing the list of agents, total count, current page number, page size, and total number of pages.\n    \"\"\"\n    try:\n        skip = (page - 1) * page_size\n        try:\n            analytics = await prisma.models.AnalyticsTracker.prisma().find_many(include={'agent': True}, order={'downloads': 'desc'}, where={'agent': {'is': {'submissionStatus': submission_status}}}, skip=skip, take=page_size)\n        except prisma.errors.PrismaError as e:\n            raise AgentQueryError(f'Database query failed: {str(e)}')\n        try:\n            total_count = await prisma.models.AnalyticsTracker.prisma().count(where={'agent': {'is': {'submissionStatus': submission_status}}})\n        except prisma.errors.PrismaError as e:\n            raise AgentQueryError(f'Database query failed: {str(e)}')\n        return market.model.ListResponse(items=analytics, total_count=total_count, page=page, page_size=page_size, total_pages=(total_count + page_size - 1) // page_size)\n    except AgentQueryError as e:\n        raise e from e\n    except ValueError as e:\n        raise AgentQueryError(f'Invalid input parameter: {str(e)}') from e\n    except Exception as e:\n        raise AgentQueryError(f'Unexpected error occurred: {str(e)}') from e",
        "'Retrieve the top agents by download count.\\n\\n    Args:\\n        page (int, optional): The page number. Defaults to 1.\\n        page_size (int, optional): The number of agents per page. Defaults to 10.\\n\\n    Returns:\\n        dict: A dictionary containing the list of agents, total count, current page number, page size, and total number of pages.\\n    '",
        "try:\n    skip = (page - 1) * page_size\n    try:\n        analytics = await prisma.models.AnalyticsTracker.prisma().find_many(include={'agent': True}, order={'downloads': 'desc'}, where={'agent': {'is': {'submissionStatus': submission_status}}}, skip=skip, take=page_size)\n    except prisma.errors.PrismaError as e:\n        raise AgentQueryError(f'Database query failed: {str(e)}')\n    try:\n        total_count = await prisma.models.AnalyticsTracker.prisma().count(where={'agent': {'is': {'submissionStatus': submission_status}}})\n    except prisma.errors.PrismaError as e:\n        raise AgentQueryError(f'Database query failed: {str(e)}')\n    return market.model.ListResponse(items=analytics, total_count=total_count, page=page, page_size=page_size, total_pages=(total_count + page_size - 1) // page_size)\nexcept AgentQueryError as e:\n    raise e from e\nexcept ValueError as e:\n    raise AgentQueryError(f'Invalid input parameter: {str(e)}') from e\nexcept Exception as e:\n    raise AgentQueryError(f'Unexpected error occurred: {str(e)}') from e",
        "skip = (page - 1) * page_size",
        "try:\n    analytics = await prisma.models.AnalyticsTracker.prisma().find_many(include={'agent': True}, order={'downloads': 'desc'}, where={'agent': {'is': {'submissionStatus': submission_status}}}, skip=skip, take=page_size)\nexcept prisma.errors.PrismaError as e:\n    raise AgentQueryError(f'Database query failed: {str(e)}')",
        "analytics = await prisma.models.AnalyticsTracker.prisma().find_many(include={'agent': True}, order={'downloads': 'desc'}, where={'agent': {'is': {'submissionStatus': submission_status}}}, skip=skip, take=page_size)",
        "raise AgentQueryError(f'Database query failed: {str(e)}')",
        "try:\n    total_count = await prisma.models.AnalyticsTracker.prisma().count(where={'agent': {'is': {'submissionStatus': submission_status}}})\nexcept prisma.errors.PrismaError as e:\n    raise AgentQueryError(f'Database query failed: {str(e)}')",
        "total_count = await prisma.models.AnalyticsTracker.prisma().count(where={'agent': {'is': {'submissionStatus': submission_status}}})",
        "raise AgentQueryError(f'Database query failed: {str(e)}')",
        "return market.model.ListResponse(items=analytics, total_count=total_count, page=page, page_size=page_size, total_pages=(total_count + page_size - 1) // page_size)"
      ]
    },
    {
      "id": "41",
      "type": "block",
      "statements": [
        "raise e from e",
        "raise AgentQueryError(f'Invalid input parameter: {str(e)}') from e",
        "raise AgentQueryError(f'Unexpected error occurred: {str(e)}') from e",
        "async def set_agent_featured(agent_id: str, is_active: bool=True, featured_categories: list[str]=['featured']) -> prisma.models.FeaturedAgent:\n    \"\"\"Set an agent as featured in the database.\n\n    Args:\n        agent_id (str): The ID of the agent.\n        category (str, optional): The category to set the agent as featured. Defaults to \"featured\".\n\n    Raises:\n        AgentQueryError: If there is an error setting the agent as featured.\n    \"\"\"\n    try:\n        agent = await prisma.models.Agents.prisma().find_unique(where={'id': agent_id})\n        if not agent:\n            raise AgentQueryError(f'Agent with ID {agent_id} not found.')\n        featured = await prisma.models.FeaturedAgent.prisma().upsert(where={'agentId': agent_id}, data={'update': {'featuredCategories': featured_categories, 'isActive': is_active}, 'create': {'featuredCategories': featured_categories, 'isActive': is_active, 'agent': {'connect': {'id': agent_id}}}})\n        return featured\n    except prisma.errors.PrismaError as e:\n        raise AgentQueryError(f'Database query failed: {str(e)}')\n    except Exception as e:\n        raise AgentQueryError(f'Unexpected error occurred: {str(e)}')",
        "'Set an agent as featured in the database.\\n\\n    Args:\\n        agent_id (str): The ID of the agent.\\n        category (str, optional): The category to set the agent as featured. Defaults to \"featured\".\\n\\n    Raises:\\n        AgentQueryError: If there is an error setting the agent as featured.\\n    '",
        "try:\n    agent = await prisma.models.Agents.prisma().find_unique(where={'id': agent_id})\n    if not agent:\n        raise AgentQueryError(f'Agent with ID {agent_id} not found.')\n    featured = await prisma.models.FeaturedAgent.prisma().upsert(where={'agentId': agent_id}, data={'update': {'featuredCategories': featured_categories, 'isActive': is_active}, 'create': {'featuredCategories': featured_categories, 'isActive': is_active, 'agent': {'connect': {'id': agent_id}}}})\n    return featured\nexcept prisma.errors.PrismaError as e:\n    raise AgentQueryError(f'Database query failed: {str(e)}')\nexcept Exception as e:\n    raise AgentQueryError(f'Unexpected error occurred: {str(e)}')",
        "agent = await prisma.models.Agents.prisma().find_unique(where={'id': agent_id})",
        "not agent"
      ]
    },
    {
      "id": "42",
      "type": "block",
      "statements": [
        "raise AgentQueryError(f'Agent with ID {agent_id} not found.')"
      ]
    },
    {
      "id": "43",
      "type": "block",
      "statements": []
    },
    {
      "id": "44",
      "type": "block",
      "statements": [
        "featured = await prisma.models.FeaturedAgent.prisma().upsert(where={'agentId': agent_id}, data={'update': {'featuredCategories': featured_categories, 'isActive': is_active}, 'create': {'featuredCategories': featured_categories, 'isActive': is_active, 'agent': {'connect': {'id': agent_id}}}})",
        "return featured"
      ]
    },
    {
      "id": "45",
      "type": "block",
      "statements": [
        "raise AgentQueryError(f'Database query failed: {str(e)}')",
        "raise AgentQueryError(f'Unexpected error occurred: {str(e)}')",
        "async def get_featured_agents(category: str='featured', page: int=1, page_size: int=10, submission_status: prisma.enums.SubmissionStatus=prisma.enums.SubmissionStatus.APPROVED) -> FeaturedAgentResponse:\n    \"\"\"Retrieve a list of featured agents from the database based on the provided category.\n\n    Args:\n        category (str, optional): The category of featured agents to retrieve. Defaults to \"featured\".\n        page (int, optional): The page number to retrieve. Defaults to 1.\n        page_size (int, optional): The number of agents per page. Defaults to 10.\n\n    Returns:\n        dict: A dictionary containing the list of featured agents, total count, current page number, page size, and total number of pages.\n    \"\"\"\n    try:\n        skip = (page - 1) * page_size\n        try:\n            featured_agents = await prisma.models.FeaturedAgent.prisma().find_many(where={'featuredCategories': {'has': category}, 'isActive': True, 'agent': {'is': {'submissionStatus': submission_status}}}, include={'agent': {'include': {'AnalyticsTracker': True}}}, skip=skip, take=page_size)\n        except prisma.errors.PrismaError as e:\n            raise AgentQueryError(f'Database query failed: {str(e)}')\n        total_count = len(featured_agents)\n        return FeaturedAgentResponse(featured_agents=featured_agents, total_count=total_count, page=page, page_size=page_size, total_pages=(total_count + page_size - 1) // page_size)\n    except AgentQueryError as e:\n        raise e from e\n    except ValueError as e:\n        raise AgentQueryError(f'Invalid input parameter: {str(e)}') from e\n    except Exception as e:\n        raise AgentQueryError(f'Unexpected error occurred: {str(e)}') from e",
        "'Retrieve a list of featured agents from the database based on the provided category.\\n\\n    Args:\\n        category (str, optional): The category of featured agents to retrieve. Defaults to \"featured\".\\n        page (int, optional): The page number to retrieve. Defaults to 1.\\n        page_size (int, optional): The number of agents per page. Defaults to 10.\\n\\n    Returns:\\n        dict: A dictionary containing the list of featured agents, total count, current page number, page size, and total number of pages.\\n    '",
        "try:\n    skip = (page - 1) * page_size\n    try:\n        featured_agents = await prisma.models.FeaturedAgent.prisma().find_many(where={'featuredCategories': {'has': category}, 'isActive': True, 'agent': {'is': {'submissionStatus': submission_status}}}, include={'agent': {'include': {'AnalyticsTracker': True}}}, skip=skip, take=page_size)\n    except prisma.errors.PrismaError as e:\n        raise AgentQueryError(f'Database query failed: {str(e)}')\n    total_count = len(featured_agents)\n    return FeaturedAgentResponse(featured_agents=featured_agents, total_count=total_count, page=page, page_size=page_size, total_pages=(total_count + page_size - 1) // page_size)\nexcept AgentQueryError as e:\n    raise e from e\nexcept ValueError as e:\n    raise AgentQueryError(f'Invalid input parameter: {str(e)}') from e\nexcept Exception as e:\n    raise AgentQueryError(f'Unexpected error occurred: {str(e)}') from e",
        "skip = (page - 1) * page_size",
        "try:\n    featured_agents = await prisma.models.FeaturedAgent.prisma().find_many(where={'featuredCategories': {'has': category}, 'isActive': True, 'agent': {'is': {'submissionStatus': submission_status}}}, include={'agent': {'include': {'AnalyticsTracker': True}}}, skip=skip, take=page_size)\nexcept prisma.errors.PrismaError as e:\n    raise AgentQueryError(f'Database query failed: {str(e)}')",
        "featured_agents = await prisma.models.FeaturedAgent.prisma().find_many(where={'featuredCategories': {'has': category}, 'isActive': True, 'agent': {'is': {'submissionStatus': submission_status}}}, include={'agent': {'include': {'AnalyticsTracker': True}}}, skip=skip, take=page_size)",
        "raise AgentQueryError(f'Database query failed: {str(e)}')",
        "total_count = len(featured_agents)",
        "return FeaturedAgentResponse(featured_agents=featured_agents, total_count=total_count, page=page, page_size=page_size, total_pages=(total_count + page_size - 1) // page_size)"
      ]
    },
    {
      "id": "46",
      "type": "block",
      "statements": [
        "raise e from e",
        "raise AgentQueryError(f'Invalid input parameter: {str(e)}') from e",
        "raise AgentQueryError(f'Unexpected error occurred: {str(e)}') from e",
        "async def remove_featured_category(agent_id: str, category: str) -> prisma.models.FeaturedAgent | None:\n    \"\"\"Adds a featured category to an agent.\n\n    Args:\n        agent_id (str): The ID of the agent.\n        category (str): The category to add to the agent.\n\n    Returns:\n        FeaturedAgentResponse: The updated list of featured agents.\n    \"\"\"\n    try:\n        featured_agent = await prisma.models.FeaturedAgent.prisma().find_unique(where={'agentId': agent_id}, include={'agent': True})\n        if not featured_agent:\n            raise AgentQueryError(f'Agent with ID {agent_id} not found.')\n        featured_agent.featuredCategories.remove(category)\n        featured_agent = await prisma.models.FeaturedAgent.prisma().update(where={'agentId': agent_id}, data={'featuredCategories': featured_agent.featuredCategories})\n        return featured_agent\n    except prisma.errors.PrismaError as e:\n        raise AgentQueryError(f'Database query failed: {str(e)}')\n    except Exception as e:\n        raise AgentQueryError(f'Unexpected error occurred: {str(e)}')",
        "'Adds a featured category to an agent.\\n\\n    Args:\\n        agent_id (str): The ID of the agent.\\n        category (str): The category to add to the agent.\\n\\n    Returns:\\n        FeaturedAgentResponse: The updated list of featured agents.\\n    '",
        "try:\n    featured_agent = await prisma.models.FeaturedAgent.prisma().find_unique(where={'agentId': agent_id}, include={'agent': True})\n    if not featured_agent:\n        raise AgentQueryError(f'Agent with ID {agent_id} not found.')\n    featured_agent.featuredCategories.remove(category)\n    featured_agent = await prisma.models.FeaturedAgent.prisma().update(where={'agentId': agent_id}, data={'featuredCategories': featured_agent.featuredCategories})\n    return featured_agent\nexcept prisma.errors.PrismaError as e:\n    raise AgentQueryError(f'Database query failed: {str(e)}')\nexcept Exception as e:\n    raise AgentQueryError(f'Unexpected error occurred: {str(e)}')",
        "featured_agent = await prisma.models.FeaturedAgent.prisma().find_unique(where={'agentId': agent_id}, include={'agent': True})",
        "not featured_agent"
      ]
    },
    {
      "id": "47",
      "type": "block",
      "statements": [
        "raise AgentQueryError(f'Agent with ID {agent_id} not found.')"
      ]
    },
    {
      "id": "48",
      "type": "block",
      "statements": []
    },
    {
      "id": "49",
      "type": "block",
      "statements": [
        "featured_agent.featuredCategories.remove(category)",
        "featured_agent = await prisma.models.FeaturedAgent.prisma().update(where={'agentId': agent_id}, data={'featuredCategories': featured_agent.featuredCategories})",
        "return featured_agent"
      ]
    },
    {
      "id": "50",
      "type": "block",
      "statements": [
        "raise AgentQueryError(f'Database query failed: {str(e)}')",
        "raise AgentQueryError(f'Unexpected error occurred: {str(e)}')",
        "async def add_featured_category(agent_id: str, category: str) -> prisma.models.FeaturedAgent | None:\n    \"\"\"Removes a featured category from an agent.\n\n    Args:\n        agent_id (str): The ID of the agent.\n        category (str): The category to remove from the agent.\n\n    Returns:\n        FeaturedAgentResponse: The updated list of featured agents.\n    \"\"\"\n    try:\n        featured_agent = await prisma.models.FeaturedAgent.prisma().update(where={'agentId': agent_id}, data={'featuredCategories': {'push': [category]}})\n        return featured_agent\n    except prisma.errors.PrismaError as e:\n        raise AgentQueryError(f'Database query failed: {str(e)}')\n    except Exception as e:\n        raise AgentQueryError(f'Unexpected error occurred: {str(e)}')",
        "'Removes a featured category from an agent.\\n\\n    Args:\\n        agent_id (str): The ID of the agent.\\n        category (str): The category to remove from the agent.\\n\\n    Returns:\\n        FeaturedAgentResponse: The updated list of featured agents.\\n    '",
        "try:\n    featured_agent = await prisma.models.FeaturedAgent.prisma().update(where={'agentId': agent_id}, data={'featuredCategories': {'push': [category]}})\n    return featured_agent\nexcept prisma.errors.PrismaError as e:\n    raise AgentQueryError(f'Database query failed: {str(e)}')\nexcept Exception as e:\n    raise AgentQueryError(f'Unexpected error occurred: {str(e)}')",
        "featured_agent = await prisma.models.FeaturedAgent.prisma().update(where={'agentId': agent_id}, data={'featuredCategories': {'push': [category]}})",
        "return featured_agent"
      ]
    },
    {
      "id": "51",
      "type": "block",
      "statements": [
        "raise AgentQueryError(f'Database query failed: {str(e)}')",
        "raise AgentQueryError(f'Unexpected error occurred: {str(e)}')",
        "async def get_agent_featured(agent_id: str) -> prisma.models.FeaturedAgent | None:\n    \"\"\"Retrieve an agent's featured categories from the database.\n\n    Args:\n        agent_id (str): The ID of the agent.\n\n    Returns:\n        FeaturedAgentResponse: The list of featured agents.\n    \"\"\"\n    try:\n        featured_agent = await prisma.models.FeaturedAgent.prisma().find_unique(where={'agentId': agent_id})\n        return featured_agent\n    except prisma.errors.PrismaError as e:\n        raise AgentQueryError(f'Database query failed: {str(e)}')\n    except Exception as e:\n        raise AgentQueryError(f'Unexpected error occurred: {str(e)}')",
        "\"Retrieve an agent's featured categories from the database.\\n\\n    Args:\\n        agent_id (str): The ID of the agent.\\n\\n    Returns:\\n        FeaturedAgentResponse: The list of featured agents.\\n    \"",
        "try:\n    featured_agent = await prisma.models.FeaturedAgent.prisma().find_unique(where={'agentId': agent_id})\n    return featured_agent\nexcept prisma.errors.PrismaError as e:\n    raise AgentQueryError(f'Database query failed: {str(e)}')\nexcept Exception as e:\n    raise AgentQueryError(f'Unexpected error occurred: {str(e)}')",
        "featured_agent = await prisma.models.FeaturedAgent.prisma().find_unique(where={'agentId': agent_id})",
        "return featured_agent"
      ]
    },
    {
      "id": "52",
      "type": "block",
      "statements": [
        "raise AgentQueryError(f'Database query failed: {str(e)}')",
        "raise AgentQueryError(f'Unexpected error occurred: {str(e)}')",
        "async def get_not_featured_agents(page: int=1, page_size: int=10) -> typing.List[prisma.models.Agents]:\n    \"\"\"\n    Retrieve a list of not featured agents from the database.\n    \"\"\"\n    try:\n        agents = await prisma.client.get_client().query_raw(query=f\"\"\"\\n            SELECT \\n                \"market\".\"Agents\".id, \\n                \"market\".\"Agents\".\"createdAt\", \\n                \"market\".\"Agents\".\"updatedAt\", \\n                \"market\".\"Agents\".version, \\n                \"market\".\"Agents\".name, \\n                LEFT(\"market\".\"Agents\".description, 500) AS description, \\n                \"market\".\"Agents\".author, \\n                \"market\".\"Agents\".keywords, \\n                \"market\".\"Agents\".categories, \\n                \"market\".\"Agents\".graph,\\n                \"market\".\"Agents\".\"submissionStatus\",\\n                \"market\".\"Agents\".\"submissionDate\",\\n                \"market\".\"Agents\".search::text AS search\\n            FROM \"market\".\"Agents\"\\n            LEFT JOIN \"market\".\"FeaturedAgent\" ON \"market\".\"Agents\".\"id\" = \"market\".\"FeaturedAgent\".\"agentId\"\\n            WHERE (\"market\".\"FeaturedAgent\".\"agentId\" IS NULL OR \"market\".\"FeaturedAgent\".\"featuredCategories\" = '{{}}')\\n                AND \"market\".\"Agents\".\"submissionStatus\" = 'APPROVED'\\n            ORDER BY \"market\".\"Agents\".\"createdAt\" DESC\\n            LIMIT {page_size} OFFSET {page_size * (page - 1)}\\n            \"\"\", model=prisma.models.Agents)\n        return agents\n    except prisma.errors.PrismaError as e:\n        raise AgentQueryError(f'Database query failed: {str(e)}')\n    except Exception as e:\n        raise AgentQueryError(f'Unexpected error occurred: {str(e)}')",
        "'\\n    Retrieve a list of not featured agents from the database.\\n    '",
        "try:\n    agents = await prisma.client.get_client().query_raw(query=f\"\"\"\\n            SELECT \\n                \"market\".\"Agents\".id, \\n                \"market\".\"Agents\".\"createdAt\", \\n                \"market\".\"Agents\".\"updatedAt\", \\n                \"market\".\"Agents\".version, \\n                \"market\".\"Agents\".name, \\n                LEFT(\"market\".\"Agents\".description, 500) AS description, \\n                \"market\".\"Agents\".author, \\n                \"market\".\"Agents\".keywords, \\n                \"market\".\"Agents\".categories, \\n                \"market\".\"Agents\".graph,\\n                \"market\".\"Agents\".\"submissionStatus\",\\n                \"market\".\"Agents\".\"submissionDate\",\\n                \"market\".\"Agents\".search::text AS search\\n            FROM \"market\".\"Agents\"\\n            LEFT JOIN \"market\".\"FeaturedAgent\" ON \"market\".\"Agents\".\"id\" = \"market\".\"FeaturedAgent\".\"agentId\"\\n            WHERE (\"market\".\"FeaturedAgent\".\"agentId\" IS NULL OR \"market\".\"FeaturedAgent\".\"featuredCategories\" = '{{}}')\\n                AND \"market\".\"Agents\".\"submissionStatus\" = 'APPROVED'\\n            ORDER BY \"market\".\"Agents\".\"createdAt\" DESC\\n            LIMIT {page_size} OFFSET {page_size * (page - 1)}\\n            \"\"\", model=prisma.models.Agents)\n    return agents\nexcept prisma.errors.PrismaError as e:\n    raise AgentQueryError(f'Database query failed: {str(e)}')\nexcept Exception as e:\n    raise AgentQueryError(f'Unexpected error occurred: {str(e)}')",
        "agents = await prisma.client.get_client().query_raw(query=f\"\"\"\\n            SELECT \\n                \"market\".\"Agents\".id, \\n                \"market\".\"Agents\".\"createdAt\", \\n                \"market\".\"Agents\".\"updatedAt\", \\n                \"market\".\"Agents\".version, \\n                \"market\".\"Agents\".name, \\n                LEFT(\"market\".\"Agents\".description, 500) AS description, \\n                \"market\".\"Agents\".author, \\n                \"market\".\"Agents\".keywords, \\n                \"market\".\"Agents\".categories, \\n                \"market\".\"Agents\".graph,\\n                \"market\".\"Agents\".\"submissionStatus\",\\n                \"market\".\"Agents\".\"submissionDate\",\\n                \"market\".\"Agents\".search::text AS search\\n            FROM \"market\".\"Agents\"\\n            LEFT JOIN \"market\".\"FeaturedAgent\" ON \"market\".\"Agents\".\"id\" = \"market\".\"FeaturedAgent\".\"agentId\"\\n            WHERE (\"market\".\"FeaturedAgent\".\"agentId\" IS NULL OR \"market\".\"FeaturedAgent\".\"featuredCategories\" = '{{}}')\\n                AND \"market\".\"Agents\".\"submissionStatus\" = 'APPROVED'\\n            ORDER BY \"market\".\"Agents\".\"createdAt\" DESC\\n            LIMIT {page_size} OFFSET {page_size * (page - 1)}\\n            \"\"\", model=prisma.models.Agents)",
        "return agents"
      ]
    },
    {
      "id": "53",
      "type": "block",
      "statements": [
        "raise AgentQueryError(f'Database query failed: {str(e)}')",
        "raise AgentQueryError(f'Unexpected error occurred: {str(e)}')",
        "async def get_all_categories() -> market.model.CategoriesResponse:\n    \"\"\"\n    Retrieve all unique categories from the database.\n\n    Returns:\n        CategoriesResponse: A list of unique categories.\n    \"\"\"\n    try:\n        agents = await prisma.models.Agents.prisma().find_many(distinct=['categories'])\n        all_categories = set()\n        for agent in agents:\n            all_categories.update(agent.categories)\n        unique_categories = sorted(list(all_categories))\n        return market.model.CategoriesResponse(unique_categories=unique_categories)\n    except prisma.errors.PrismaError as e:\n        raise AgentQueryError(f'Database query failed: {str(e)}')\n    except Exception:\n        return market.model.CategoriesResponse(unique_categories=[])",
        "'\\n    Retrieve all unique categories from the database.\\n\\n    Returns:\\n        CategoriesResponse: A list of unique categories.\\n    '",
        "try:\n    agents = await prisma.models.Agents.prisma().find_many(distinct=['categories'])\n    all_categories = set()\n    for agent in agents:\n        all_categories.update(agent.categories)\n    unique_categories = sorted(list(all_categories))\n    return market.model.CategoriesResponse(unique_categories=unique_categories)\nexcept prisma.errors.PrismaError as e:\n    raise AgentQueryError(f'Database query failed: {str(e)}')\nexcept Exception:\n    return market.model.CategoriesResponse(unique_categories=[])",
        "agents = await prisma.models.Agents.prisma().find_many(distinct=['categories'])",
        "all_categories = set()"
      ]
    },
    {
      "id": "54",
      "type": "block",
      "statements": [
        "agent",
        "agents"
      ]
    },
    {
      "id": "55",
      "type": "block",
      "statements": [
        "all_categories.update(agent.categories)"
      ]
    },
    {
      "id": "56",
      "type": "block",
      "statements": [
        "unique_categories = sorted(list(all_categories))",
        "return market.model.CategoriesResponse(unique_categories=unique_categories)"
      ]
    },
    {
      "id": "57",
      "type": "block",
      "statements": [
        "raise AgentQueryError(f'Database query failed: {str(e)}')",
        "return market.model.CategoriesResponse(unique_categories=[])"
      ]
    },
    {
      "id": "58",
      "type": "block",
      "statements": [
        "async def create_agent_installed_event(event_data: market.model.AgentInstalledFromMarketplaceEventData):\n    try:\n        await prisma.models.InstallTracker.prisma().create(data={'installedAgentId': event_data.installed_agent_id, 'marketplaceAgentId': event_data.marketplace_agent_id, 'installationLocation': prisma.enums.InstallationLocation(event_data.installation_location.name)})\n    except prisma.errors.PrismaError as e:\n        raise AgentQueryError(f'Database query failed: {str(e)}')\n    except Exception as e:\n        raise AgentQueryError(f'Unexpected error occurred: {str(e)}')",
        "try:\n    await prisma.models.InstallTracker.prisma().create(data={'installedAgentId': event_data.installed_agent_id, 'marketplaceAgentId': event_data.marketplace_agent_id, 'installationLocation': prisma.enums.InstallationLocation(event_data.installation_location.name)})\nexcept prisma.errors.PrismaError as e:\n    raise AgentQueryError(f'Database query failed: {str(e)}')\nexcept Exception as e:\n    raise AgentQueryError(f'Unexpected error occurred: {str(e)}')",
        "await prisma.models.InstallTracker.prisma().create(data={'installedAgentId': event_data.installed_agent_id, 'marketplaceAgentId': event_data.marketplace_agent_id, 'installationLocation': prisma.enums.InstallationLocation(event_data.installation_location.name)})",
        "raise AgentQueryError(f'Database query failed: {str(e)}')",
        "raise AgentQueryError(f'Unexpected error occurred: {str(e)}')"
      ]
    }
  ],
  "edges": [
    {
      "source": "4",
      "target": "5",
      "type": "true"
    },
    {
      "source": "4",
      "target": "6",
      "type": "false"
    },
    {
      "source": "5",
      "target": "7",
      "type": "next"
    },
    {
      "source": "6",
      "target": "7",
      "type": "next"
    },
    {
      "source": "7",
      "target": "8",
      "type": "true"
    },
    {
      "source": "7",
      "target": "9",
      "type": "false"
    },
    {
      "source": "8",
      "target": "10",
      "type": "next"
    },
    {
      "source": "9",
      "target": "10",
      "type": "next"
    },
    {
      "source": "10",
      "target": "11",
      "type": "true"
    },
    {
      "source": "10",
      "target": "12",
      "type": "false"
    },
    {
      "source": "11",
      "target": "13",
      "type": "next"
    },
    {
      "source": "12",
      "target": "13",
      "type": "next"
    },
    {
      "source": "13",
      "target": "14",
      "type": "true"
    },
    {
      "source": "13",
      "target": "15",
      "type": "false"
    },
    {
      "source": "14",
      "target": "17",
      "type": "next"
    },
    {
      "source": "15",
      "target": "16",
      "type": "next"
    },
    {
      "source": "17",
      "target": "18",
      "type": "true"
    },
    {
      "source": "17",
      "target": "19",
      "type": "false"
    },
    {
      "source": "18",
      "target": "20",
      "type": "true"
    },
    {
      "source": "18",
      "target": "21",
      "type": "false"
    },
    {
      "source": "19",
      "target": "16",
      "type": "next"
    },
    {
      "source": "20",
      "target": "22",
      "type": "next"
    },
    {
      "source": "21",
      "target": "22",
      "type": "next"
    },
    {
      "source": "22",
      "target": "17",
      "type": "next"
    },
    {
      "source": "23",
      "target": "24",
      "type": "true"
    },
    {
      "source": "23",
      "target": "25",
      "type": "false"
    },
    {
      "source": "24",
      "target": "26",
      "type": "next"
    },
    {
      "source": "25",
      "target": "26",
      "type": "next"
    },
    {
      "source": "26",
      "target": "27",
      "type": "true"
    },
    {
      "source": "26",
      "target": "28",
      "type": "false"
    },
    {
      "source": "27",
      "target": "29",
      "type": "next"
    },
    {
      "source": "28",
      "target": "29",
      "type": "next"
    },
    {
      "source": "30",
      "target": "31",
      "type": "true"
    },
    {
      "source": "30",
      "target": "32",
      "type": "false"
    },
    {
      "source": "31",
      "target": "33",
      "type": "next"
    },
    {
      "source": "32",
      "target": "33",
      "type": "next"
    },
    {
      "source": "33",
      "target": "34",
      "type": "true"
    },
    {
      "source": "33",
      "target": "35",
      "type": "false"
    },
    {
      "source": "34",
      "target": "36",
      "type": "next"
    },
    {
      "source": "35",
      "target": "37",
      "type": "true"
    },
    {
      "source": "35",
      "target": "38",
      "type": "false"
    },
    {
      "source": "37",
      "target": "39",
      "type": "next"
    },
    {
      "source": "38",
      "target": "39",
      "type": "next"
    },
    {
      "source": "39",
      "target": "36",
      "type": "next"
    },
    {
      "source": "41",
      "target": "42",
      "type": "true"
    },
    {
      "source": "41",
      "target": "43",
      "type": "false"
    },
    {
      "source": "42",
      "target": "44",
      "type": "next"
    },
    {
      "source": "43",
      "target": "44",
      "type": "next"
    },
    {
      "source": "46",
      "target": "47",
      "type": "true"
    },
    {
      "source": "46",
      "target": "48",
      "type": "false"
    },
    {
      "source": "47",
      "target": "49",
      "type": "next"
    },
    {
      "source": "48",
      "target": "49",
      "type": "next"
    },
    {
      "source": "53",
      "target": "54",
      "type": "next"
    },
    {
      "source": "54",
      "target": "55",
      "type": "true"
    },
    {
      "source": "54",
      "target": "56",
      "type": "false"
    },
    {
      "source": "55",
      "target": "54",
      "type": "next"
    }
  ]
}