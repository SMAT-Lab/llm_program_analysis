{
  "nodes": [
    {
      "id": "1",
      "type": "block",
      "statements": [
        "import asyncio",
        "import builtins",
        "import logging",
        "import os",
        "import threading",
        "import time",
        "import typing",
        "from abc import ABC, abstractmethod",
        "from enum import Enum",
        "from types import NoneType, UnionType",
        "from typing import Annotated, Any, Awaitable, Callable, Coroutine, Dict, FrozenSet, Iterator, List, Set, Tuple, Type, TypeVar, Union, cast, get_args, get_origin",
        "import Pyro5.api",
        "from pydantic import BaseModel",
        "from Pyro5 import api as pyro",
        "from Pyro5 import config as pyro_config",
        "from backend.data import db, redis",
        "from backend.util.process import AppProcess",
        "from backend.util.retry import conn_retry",
        "from backend.util.settings import Config, Secrets",
        "logger = logging.getLogger(__name__)",
        "T = TypeVar('T')",
        "C = TypeVar('C', bound=Callable)",
        "config = Config()",
        "pyro_host = config.pyro_host",
        "pyro_config.MAX_RETRIES = config.pyro_client_comm_retry",
        "pyro_config.COMMTIMEOUT = config.pyro_client_comm_timeout",
        "def expose(func: C) -> C:\n    \"\"\"\n    Decorator to mark a method or class to be exposed for remote calls.\n\n    ## ⚠️ Gotcha\n    Aside from \"simple\" types, only Pydantic models are passed unscathed *if annotated*.\n    Any other passed or returned class objects are converted to dictionaries by Pyro.\n    \"\"\"\n\n    def wrapper(*args, **kwargs):\n        try:\n            return func(*args, **kwargs)\n        except Exception as e:\n            msg = f'Error in {func.__name__}: {e.__str__()}'\n            logger.exception(msg)\n            raise\n    register_pydantic_serializers(func)\n    return pyro.expose(wrapper)",
        "'\\n    Decorator to mark a method or class to be exposed for remote calls.\\n\\n    ## ⚠️ Gotcha\\n    Aside from \"simple\" types, only Pydantic models are passed unscathed *if annotated*.\\n    Any other passed or returned class objects are converted to dictionaries by Pyro.\\n    '",
        "def wrapper(*args, **kwargs):\n    try:\n        return func(*args, **kwargs)\n    except Exception as e:\n        msg = f'Error in {func.__name__}: {e.__str__()}'\n        logger.exception(msg)\n        raise",
        "try:\n    return func(*args, **kwargs)\nexcept Exception as e:\n    msg = f'Error in {func.__name__}: {e.__str__()}'\n    logger.exception(msg)\n    raise",
        "return func(*args, **kwargs)"
      ]
    },
    {
      "id": "2",
      "type": "block",
      "statements": [
        "msg = f'Error in {func.__name__}: {e.__str__()}'",
        "logger.exception(msg)",
        "raise",
        "register_pydantic_serializers(func)",
        "return pyro.expose(wrapper)"
      ]
    },
    {
      "id": "3",
      "type": "block",
      "statements": [
        "def register_pydantic_serializers(func: Callable):\n    \"\"\"Register custom serializers and deserializers for annotated Pydantic models\"\"\"\n    for (name, annotation) in func.__annotations__.items():\n        try:\n            pydantic_types = _pydantic_models_from_type_annotation(annotation)\n        except Exception as e:\n            raise TypeError(f'Error while exposing {func.__name__}: {e.__str__()}')\n        for model in pydantic_types:\n            logger.debug(f\"Registering Pyro (de)serializers for {func.__name__} annotation '{name}': {model.__qualname__}\")\n            pyro.register_class_to_dict(model, _make_custom_serializer(model))\n            pyro.register_dict_to_class(model.__qualname__, _make_custom_deserializer(model))",
        "'Register custom serializers and deserializers for annotated Pydantic models'"
      ]
    },
    {
      "id": "4",
      "type": "block",
      "statements": [
        "(name, annotation)",
        "func.__annotations__.items()"
      ]
    },
    {
      "id": "5",
      "type": "block",
      "statements": [
        "try:\n    pydantic_types = _pydantic_models_from_type_annotation(annotation)\nexcept Exception as e:\n    raise TypeError(f'Error while exposing {func.__name__}: {e.__str__()}')",
        "pydantic_types = _pydantic_models_from_type_annotation(annotation)",
        "raise TypeError(f'Error while exposing {func.__name__}: {e.__str__()}')"
      ]
    },
    {
      "id": "6",
      "type": "block",
      "statements": [
        "def _make_custom_serializer(model: Type[BaseModel]):\n\n    def custom_class_to_dict(obj):\n        data = {'__class__': obj.__class__.__qualname__, **obj.model_dump()}\n        logger.debug(f'Serializing {obj.__class__.__qualname__} with data: {data}')\n        return data\n    return custom_class_to_dict",
        "def custom_class_to_dict(obj):\n    data = {'__class__': obj.__class__.__qualname__, **obj.model_dump()}\n    logger.debug(f'Serializing {obj.__class__.__qualname__} with data: {data}')\n    return data",
        "data = {'__class__': obj.__class__.__qualname__, **obj.model_dump()}",
        "logger.debug(f'Serializing {obj.__class__.__qualname__} with data: {data}')",
        "return data"
      ]
    },
    {
      "id": "7",
      "type": "block",
      "statements": [
        "model",
        "pydantic_types"
      ]
    },
    {
      "id": "8",
      "type": "block",
      "statements": [
        "logger.debug(f\"Registering Pyro (de)serializers for {func.__name__} annotation '{name}': {model.__qualname__}\")",
        "pyro.register_class_to_dict(model, _make_custom_serializer(model))",
        "pyro.register_dict_to_class(model.__qualname__, _make_custom_deserializer(model))"
      ]
    },
    {
      "id": "9",
      "type": "block",
      "statements": []
    },
    {
      "id": "10",
      "type": "block",
      "statements": [
        "return custom_class_to_dict"
      ]
    },
    {
      "id": "11",
      "type": "block",
      "statements": [
        "def _make_custom_deserializer(model: Type[BaseModel]):\n\n    def custom_dict_to_class(qualname, data: dict):\n        logger.debug(f'Deserializing {model.__qualname__} from data: {data}')\n        return model(**data)\n    return custom_dict_to_class",
        "def custom_dict_to_class(qualname, data: dict):\n    logger.debug(f'Deserializing {model.__qualname__} from data: {data}')\n    return model(**data)",
        "logger.debug(f'Deserializing {model.__qualname__} from data: {data}')",
        "return model(**data)"
      ]
    },
    {
      "id": "12",
      "type": "block",
      "statements": [
        "return custom_dict_to_class"
      ]
    },
    {
      "id": "13",
      "type": "block",
      "statements": [
        "class AppService(AppProcess, ABC):\n    shared_event_loop: asyncio.AbstractEventLoop\n    use_db: bool = False\n    use_redis: bool = False\n    use_supabase: bool = False\n\n    def __init__(self):\n        self.uri = None\n\n    @classmethod\n    @abstractmethod\n    def get_port(cls) -> int:\n        pass\n\n    @classmethod\n    def get_host(cls) -> str:\n        return os.environ.get(f'{cls.service_name.upper()}_HOST', config.pyro_host)\n\n    def run_service(self) -> None:\n        while True:\n            time.sleep(10)\n\n    def __run_async(self, coro: Coroutine[Any, Any, T]):\n        return asyncio.run_coroutine_threadsafe(coro, self.shared_event_loop)\n\n    def run_and_wait(self, coro: Coroutine[Any, Any, T]) -> T:\n        future = self.__run_async(coro)\n        return future.result()\n\n    def run(self):\n        self.shared_event_loop = asyncio.get_event_loop()\n        if self.use_db:\n            self.shared_event_loop.run_until_complete(db.connect())\n        if self.use_redis:\n            redis.connect()\n        if self.use_supabase:\n            from supabase import create_client\n            secrets = Secrets()\n            self.supabase = create_client(secrets.supabase_url, secrets.supabase_service_role_key)\n        async_thread = threading.Thread(target=self.__start_async_loop)\n        async_thread.daemon = True\n        async_thread.start()\n        daemon_thread = threading.Thread(target=self.__start_pyro)\n        daemon_thread.daemon = True\n        daemon_thread.start()\n        self.run_service()\n\n    def cleanup(self):\n        if self.use_db:\n            logger.info(f'[{self.__class__.__name__}] ⏳ Disconnecting DB...')\n            self.run_and_wait(db.disconnect())\n        if self.use_redis:\n            logger.info(f'[{self.__class__.__name__}] ⏳ Disconnecting Redis...')\n            redis.disconnect()\n\n    @conn_retry('Pyro', 'Starting Pyro Service')\n    def __start_pyro(self):\n        maximum_connection_thread_count = max(Pyro5.config.THREADPOOL_SIZE, config.num_node_workers * config.num_graph_workers)\n        Pyro5.config.THREADPOOL_SIZE = maximum_connection_thread_count\n        daemon = Pyro5.api.Daemon(host=config.pyro_host, port=self.get_port())\n        self.uri = daemon.register(self, objectId=self.service_name)\n        logger.info(f'[{self.service_name}] Connected to Pyro; URI = {self.uri}')\n        daemon.requestLoop()\n\n    def __start_async_loop(self):\n        self.shared_event_loop.run_forever()",
        "shared_event_loop: asyncio.AbstractEventLoop",
        "use_db: bool = False",
        "use_redis: bool = False",
        "use_supabase: bool = False",
        "def __init__(self):\n    self.uri = None",
        "self.uri = None",
        "@classmethod\n@abstractmethod\ndef get_port(cls) -> int:\n    pass",
        "pass",
        "@classmethod\ndef get_host(cls) -> str:\n    return os.environ.get(f'{cls.service_name.upper()}_HOST', config.pyro_host)",
        "return os.environ.get(f'{cls.service_name.upper()}_HOST', config.pyro_host)"
      ]
    },
    {
      "id": "14",
      "type": "block",
      "statements": [
        "def run_service(self) -> None:\n    while True:\n        time.sleep(10)"
      ]
    },
    {
      "id": "15",
      "type": "block",
      "statements": [
        "True"
      ]
    },
    {
      "id": "16",
      "type": "block",
      "statements": [
        "time.sleep(10)"
      ]
    },
    {
      "id": "17",
      "type": "block",
      "statements": [
        "def __run_async(self, coro: Coroutine[Any, Any, T]):\n    return asyncio.run_coroutine_threadsafe(coro, self.shared_event_loop)",
        "return asyncio.run_coroutine_threadsafe(coro, self.shared_event_loop)"
      ]
    },
    {
      "id": "18",
      "type": "block",
      "statements": [
        "def run_and_wait(self, coro: Coroutine[Any, Any, T]) -> T:\n    future = self.__run_async(coro)\n    return future.result()",
        "future = self.__run_async(coro)",
        "return future.result()"
      ]
    },
    {
      "id": "19",
      "type": "block",
      "statements": [
        "def run(self):\n    self.shared_event_loop = asyncio.get_event_loop()\n    if self.use_db:\n        self.shared_event_loop.run_until_complete(db.connect())\n    if self.use_redis:\n        redis.connect()\n    if self.use_supabase:\n        from supabase import create_client\n        secrets = Secrets()\n        self.supabase = create_client(secrets.supabase_url, secrets.supabase_service_role_key)\n    async_thread = threading.Thread(target=self.__start_async_loop)\n    async_thread.daemon = True\n    async_thread.start()\n    daemon_thread = threading.Thread(target=self.__start_pyro)\n    daemon_thread.daemon = True\n    daemon_thread.start()\n    self.run_service()",
        "self.shared_event_loop = asyncio.get_event_loop()",
        "self.use_db"
      ]
    },
    {
      "id": "20",
      "type": "block",
      "statements": [
        "self.shared_event_loop.run_until_complete(db.connect())"
      ]
    },
    {
      "id": "21",
      "type": "block",
      "statements": []
    },
    {
      "id": "22",
      "type": "block",
      "statements": [
        "self.use_redis"
      ]
    },
    {
      "id": "23",
      "type": "block",
      "statements": [
        "redis.connect()"
      ]
    },
    {
      "id": "24",
      "type": "block",
      "statements": []
    },
    {
      "id": "25",
      "type": "block",
      "statements": [
        "self.use_supabase"
      ]
    },
    {
      "id": "26",
      "type": "block",
      "statements": [
        "from supabase import create_client",
        "secrets = Secrets()",
        "self.supabase = create_client(secrets.supabase_url, secrets.supabase_service_role_key)"
      ]
    },
    {
      "id": "27",
      "type": "block",
      "statements": []
    },
    {
      "id": "28",
      "type": "block",
      "statements": [
        "async_thread = threading.Thread(target=self.__start_async_loop)",
        "async_thread.daemon = True",
        "async_thread.start()",
        "daemon_thread = threading.Thread(target=self.__start_pyro)",
        "daemon_thread.daemon = True",
        "daemon_thread.start()",
        "self.run_service()",
        "def cleanup(self):\n    if self.use_db:\n        logger.info(f'[{self.__class__.__name__}] ⏳ Disconnecting DB...')\n        self.run_and_wait(db.disconnect())\n    if self.use_redis:\n        logger.info(f'[{self.__class__.__name__}] ⏳ Disconnecting Redis...')\n        redis.disconnect()",
        "self.use_db"
      ]
    },
    {
      "id": "29",
      "type": "block",
      "statements": [
        "logger.info(f'[{self.__class__.__name__}] ⏳ Disconnecting DB...')",
        "self.run_and_wait(db.disconnect())"
      ]
    },
    {
      "id": "30",
      "type": "block",
      "statements": []
    },
    {
      "id": "31",
      "type": "block",
      "statements": [
        "self.use_redis"
      ]
    },
    {
      "id": "32",
      "type": "block",
      "statements": [
        "logger.info(f'[{self.__class__.__name__}] ⏳ Disconnecting Redis...')",
        "redis.disconnect()"
      ]
    },
    {
      "id": "33",
      "type": "block",
      "statements": []
    },
    {
      "id": "34",
      "type": "block",
      "statements": [
        "@conn_retry('Pyro', 'Starting Pyro Service')\ndef __start_pyro(self):\n    maximum_connection_thread_count = max(Pyro5.config.THREADPOOL_SIZE, config.num_node_workers * config.num_graph_workers)\n    Pyro5.config.THREADPOOL_SIZE = maximum_connection_thread_count\n    daemon = Pyro5.api.Daemon(host=config.pyro_host, port=self.get_port())\n    self.uri = daemon.register(self, objectId=self.service_name)\n    logger.info(f'[{self.service_name}] Connected to Pyro; URI = {self.uri}')\n    daemon.requestLoop()",
        "maximum_connection_thread_count = max(Pyro5.config.THREADPOOL_SIZE, config.num_node_workers * config.num_graph_workers)",
        "Pyro5.config.THREADPOOL_SIZE = maximum_connection_thread_count",
        "daemon = Pyro5.api.Daemon(host=config.pyro_host, port=self.get_port())",
        "self.uri = daemon.register(self, objectId=self.service_name)",
        "logger.info(f'[{self.service_name}] Connected to Pyro; URI = {self.uri}')",
        "daemon.requestLoop()",
        "def __start_async_loop(self):\n    self.shared_event_loop.run_forever()",
        "self.shared_event_loop.run_forever()",
        "AS = TypeVar('AS', bound=AppService)",
        "class PyroClient:\n    proxy: Pyro5.api.Proxy",
        "proxy: Pyro5.api.Proxy",
        "def close_service_client(client: AppService) -> None:\n    if isinstance(client, PyroClient):\n        client.proxy._pyroRelease()\n    else:\n        raise RuntimeError(f'Client {client.__class__} is not a Pyro client.')",
        "isinstance(client, PyroClient)"
      ]
    },
    {
      "id": "35",
      "type": "block",
      "statements": [
        "client.proxy._pyroRelease()"
      ]
    },
    {
      "id": "36",
      "type": "block",
      "statements": [
        "raise RuntimeError(f'Client {client.__class__} is not a Pyro client.')"
      ]
    },
    {
      "id": "37",
      "type": "block",
      "statements": [
        "def get_service_client(service_type: Type[AS]) -> AS:\n    service_name = service_type.service_name\n\n    class DynamicClient(PyroClient):\n\n        @conn_retry('Pyro', f'Connecting to [{service_name}]')\n        def __init__(self):\n            host = os.environ.get(f'{service_name.upper()}_HOST', pyro_host)\n            uri = f'PYRO:{service_type.service_name}@{host}:{service_type.get_port()}'\n            logger.debug(f'Connecting to service [{service_name}]. URI = {uri}')\n            self.proxy = Pyro5.api.Proxy(uri)\n            self.proxy._pyroBind()\n            logger.debug(f'Successfully connected to service [{service_name}]')\n\n        def __getattr__(self, name: str) -> Callable[..., Any]:\n            res = getattr(self.proxy, name)\n            return res\n    return cast(AS, DynamicClient())",
        "service_name = service_type.service_name",
        "class DynamicClient(PyroClient):\n\n    @conn_retry('Pyro', f'Connecting to [{service_name}]')\n    def __init__(self):\n        host = os.environ.get(f'{service_name.upper()}_HOST', pyro_host)\n        uri = f'PYRO:{service_type.service_name}@{host}:{service_type.get_port()}'\n        logger.debug(f'Connecting to service [{service_name}]. URI = {uri}')\n        self.proxy = Pyro5.api.Proxy(uri)\n        self.proxy._pyroBind()\n        logger.debug(f'Successfully connected to service [{service_name}]')\n\n    def __getattr__(self, name: str) -> Callable[..., Any]:\n        res = getattr(self.proxy, name)\n        return res",
        "@conn_retry('Pyro', f'Connecting to [{service_name}]')\ndef __init__(self):\n    host = os.environ.get(f'{service_name.upper()}_HOST', pyro_host)\n    uri = f'PYRO:{service_type.service_name}@{host}:{service_type.get_port()}'\n    logger.debug(f'Connecting to service [{service_name}]. URI = {uri}')\n    self.proxy = Pyro5.api.Proxy(uri)\n    self.proxy._pyroBind()\n    logger.debug(f'Successfully connected to service [{service_name}]')",
        "host = os.environ.get(f'{service_name.upper()}_HOST', pyro_host)",
        "uri = f'PYRO:{service_type.service_name}@{host}:{service_type.get_port()}'",
        "logger.debug(f'Connecting to service [{service_name}]. URI = {uri}')",
        "self.proxy = Pyro5.api.Proxy(uri)",
        "self.proxy._pyroBind()",
        "logger.debug(f'Successfully connected to service [{service_name}]')",
        "def __getattr__(self, name: str) -> Callable[..., Any]:\n    res = getattr(self.proxy, name)\n    return res",
        "res = getattr(self.proxy, name)",
        "return res"
      ]
    },
    {
      "id": "38",
      "type": "block",
      "statements": [
        "return cast(AS, DynamicClient())"
      ]
    },
    {
      "id": "39",
      "type": "block",
      "statements": [
        "builtin_types = [*vars(builtins).values(), NoneType, Enum]",
        "def _pydantic_models_from_type_annotation(annotation) -> Iterator[type[BaseModel]]:\n    if (origin := get_origin(annotation)) and origin is Annotated:\n        annotation = get_args(annotation)[0]\n    origin = get_origin(annotation)\n    args = get_args(annotation)\n    if origin in (Union, UnionType, list, List, tuple, Tuple, set, Set, frozenset, FrozenSet):\n        for arg in args:\n            yield from _pydantic_models_from_type_annotation(arg)\n    elif origin in (dict, Dict):\n        (key_type, value_type) = args\n        yield from _pydantic_models_from_type_annotation(key_type)\n        yield from _pydantic_models_from_type_annotation(value_type)\n    elif origin in (Awaitable, Coroutine):\n        return_type = args[-1]\n        yield from _pydantic_models_from_type_annotation(return_type)\n    else:\n        annotype = annotation if origin is None else origin\n        if annotype is not None and (not hasattr(typing, getattr(annotype, '__name__', ''))) and isinstance(annotype, type):\n            if issubclass(annotype, BaseModel):\n                yield annotype\n            elif annotype not in builtin_types and (not issubclass(annotype, Enum)):\n                raise TypeError(f'Unsupported type encountered: {annotype}')",
        "(origin := get_origin(annotation)) and origin is Annotated"
      ]
    },
    {
      "id": "40",
      "type": "block",
      "statements": [
        "annotation = get_args(annotation)[0]"
      ]
    },
    {
      "id": "41",
      "type": "block",
      "statements": []
    },
    {
      "id": "42",
      "type": "block",
      "statements": [
        "origin = get_origin(annotation)",
        "args = get_args(annotation)",
        "origin In (Union, UnionType, list, List, tuple, Tuple, set, Set, frozenset, FrozenSet)"
      ]
    },
    {
      "id": "43",
      "type": "block",
      "statements": []
    },
    {
      "id": "44",
      "type": "block",
      "statements": [
        "origin In (dict, Dict)"
      ]
    },
    {
      "id": "45",
      "type": "block",
      "statements": []
    },
    {
      "id": "46",
      "type": "block",
      "statements": [
        "arg",
        "args"
      ]
    },
    {
      "id": "47",
      "type": "block",
      "statements": [
        "(yield from _pydantic_models_from_type_annotation(arg))"
      ]
    },
    {
      "id": "48",
      "type": "block",
      "statements": []
    },
    {
      "id": "49",
      "type": "block",
      "statements": [
        "(key_type, value_type) = args",
        "(yield from _pydantic_models_from_type_annotation(key_type))",
        "(yield from _pydantic_models_from_type_annotation(value_type))"
      ]
    },
    {
      "id": "50",
      "type": "block",
      "statements": [
        "origin In (Awaitable, Coroutine)"
      ]
    },
    {
      "id": "51",
      "type": "block",
      "statements": []
    },
    {
      "id": "52",
      "type": "block",
      "statements": [
        "return_type = args[-1]",
        "(yield from _pydantic_models_from_type_annotation(return_type))"
      ]
    },
    {
      "id": "53",
      "type": "block",
      "statements": [
        "annotype = annotation if origin is None else origin",
        "annotype is not None and (not hasattr(typing, getattr(annotype, '__name__', ''))) and isinstance(annotype, type)"
      ]
    },
    {
      "id": "54",
      "type": "block",
      "statements": []
    },
    {
      "id": "55",
      "type": "block",
      "statements": [
        "issubclass(annotype, BaseModel)"
      ]
    },
    {
      "id": "56",
      "type": "block",
      "statements": []
    },
    {
      "id": "57",
      "type": "block",
      "statements": []
    },
    {
      "id": "58",
      "type": "block",
      "statements": [
        "(yield annotype)"
      ]
    },
    {
      "id": "59",
      "type": "block",
      "statements": [
        "annotype not in builtin_types and (not issubclass(annotype, Enum))"
      ]
    },
    {
      "id": "60",
      "type": "block",
      "statements": []
    },
    {
      "id": "61",
      "type": "block",
      "statements": [
        "raise TypeError(f'Unsupported type encountered: {annotype}')"
      ]
    },
    {
      "id": "62",
      "type": "block",
      "statements": []
    },
    {
      "id": "63",
      "type": "block",
      "statements": []
    }
  ],
  "edges": [
    {
      "source": "3",
      "target": "4",
      "type": "next"
    },
    {
      "source": "4",
      "target": "5",
      "type": "true"
    },
    {
      "source": "4",
      "target": "6",
      "type": "false"
    },
    {
      "source": "5",
      "target": "7",
      "type": "next"
    },
    {
      "source": "7",
      "target": "8",
      "type": "true"
    },
    {
      "source": "7",
      "target": "9",
      "type": "false"
    },
    {
      "source": "8",
      "target": "7",
      "type": "next"
    },
    {
      "source": "9",
      "target": "4",
      "type": "next"
    },
    {
      "source": "14",
      "target": "15",
      "type": "next"
    },
    {
      "source": "15",
      "target": "16",
      "type": "true"
    },
    {
      "source": "15",
      "target": "17",
      "type": "false"
    },
    {
      "source": "16",
      "target": "15",
      "type": "next"
    },
    {
      "source": "19",
      "target": "20",
      "type": "true"
    },
    {
      "source": "19",
      "target": "21",
      "type": "false"
    },
    {
      "source": "20",
      "target": "22",
      "type": "next"
    },
    {
      "source": "21",
      "target": "22",
      "type": "next"
    },
    {
      "source": "22",
      "target": "23",
      "type": "true"
    },
    {
      "source": "22",
      "target": "24",
      "type": "false"
    },
    {
      "source": "23",
      "target": "25",
      "type": "next"
    },
    {
      "source": "24",
      "target": "25",
      "type": "next"
    },
    {
      "source": "25",
      "target": "26",
      "type": "true"
    },
    {
      "source": "25",
      "target": "27",
      "type": "false"
    },
    {
      "source": "26",
      "target": "28",
      "type": "next"
    },
    {
      "source": "27",
      "target": "28",
      "type": "next"
    },
    {
      "source": "28",
      "target": "29",
      "type": "true"
    },
    {
      "source": "28",
      "target": "30",
      "type": "false"
    },
    {
      "source": "29",
      "target": "31",
      "type": "next"
    },
    {
      "source": "30",
      "target": "31",
      "type": "next"
    },
    {
      "source": "31",
      "target": "32",
      "type": "true"
    },
    {
      "source": "31",
      "target": "33",
      "type": "false"
    },
    {
      "source": "32",
      "target": "34",
      "type": "next"
    },
    {
      "source": "33",
      "target": "34",
      "type": "next"
    },
    {
      "source": "34",
      "target": "35",
      "type": "true"
    },
    {
      "source": "34",
      "target": "36",
      "type": "false"
    },
    {
      "source": "35",
      "target": "37",
      "type": "next"
    },
    {
      "source": "36",
      "target": "37",
      "type": "next"
    },
    {
      "source": "39",
      "target": "40",
      "type": "true"
    },
    {
      "source": "39",
      "target": "41",
      "type": "false"
    },
    {
      "source": "40",
      "target": "42",
      "type": "next"
    },
    {
      "source": "41",
      "target": "42",
      "type": "next"
    },
    {
      "source": "42",
      "target": "43",
      "type": "true"
    },
    {
      "source": "42",
      "target": "44",
      "type": "false"
    },
    {
      "source": "43",
      "target": "46",
      "type": "next"
    },
    {
      "source": "44",
      "target": "49",
      "type": "true"
    },
    {
      "source": "44",
      "target": "50",
      "type": "false"
    },
    {
      "source": "46",
      "target": "47",
      "type": "true"
    },
    {
      "source": "46",
      "target": "48",
      "type": "false"
    },
    {
      "source": "47",
      "target": "46",
      "type": "next"
    },
    {
      "source": "48",
      "target": "45",
      "type": "next"
    },
    {
      "source": "49",
      "target": "51",
      "type": "next"
    },
    {
      "source": "50",
      "target": "52",
      "type": "true"
    },
    {
      "source": "50",
      "target": "53",
      "type": "false"
    },
    {
      "source": "51",
      "target": "45",
      "type": "next"
    },
    {
      "source": "52",
      "target": "54",
      "type": "next"
    },
    {
      "source": "53",
      "target": "55",
      "type": "true"
    },
    {
      "source": "53",
      "target": "56",
      "type": "false"
    },
    {
      "source": "54",
      "target": "51",
      "type": "next"
    },
    {
      "source": "55",
      "target": "58",
      "type": "true"
    },
    {
      "source": "55",
      "target": "59",
      "type": "false"
    },
    {
      "source": "56",
      "target": "57",
      "type": "next"
    },
    {
      "source": "57",
      "target": "54",
      "type": "next"
    },
    {
      "source": "58",
      "target": "60",
      "type": "next"
    },
    {
      "source": "59",
      "target": "61",
      "type": "true"
    },
    {
      "source": "59",
      "target": "62",
      "type": "false"
    },
    {
      "source": "60",
      "target": "57",
      "type": "next"
    },
    {
      "source": "61",
      "target": "63",
      "type": "next"
    },
    {
      "source": "62",
      "target": "63",
      "type": "next"
    },
    {
      "source": "63",
      "target": "60",
      "type": "next"
    }
  ]
}