{
  "nodes": [
    {
      "id": "1",
      "type": "block",
      "statements": [
        "import asyncio",
        "import logging",
        "import os",
        "import threading",
        "from functools import wraps",
        "from uuid import uuid4",
        "from tenacity import retry, stop_after_attempt, wait_exponential",
        "from backend.util.process import get_service_name",
        "logger = logging.getLogger(__name__)",
        "def _log_prefix(resource_name: str, conn_id: str):\n    \"\"\"\n    Returns a prefix string for logging purposes.\n    This needs to be called on the fly to get the current process ID & service name,\n    not the parent process ID & service name.\n    \"\"\"\n    return f'[PID-{os.getpid()}|THREAD-{threading.get_native_id()}|{get_service_name()}|{resource_name}-{conn_id}]'",
        "'\\n    Returns a prefix string for logging purposes.\\n    This needs to be called on the fly to get the current process ID & service name,\\n    not the parent process ID & service name.\\n    '",
        "return f'[PID-{os.getpid()}|THREAD-{threading.get_native_id()}|{get_service_name()}|{resource_name}-{conn_id}]'"
      ]
    },
    {
      "id": "2",
      "type": "block",
      "statements": [
        "def conn_retry(resource_name: str, action_name: str, max_retry: int=5, multiplier: int=1, min_wait: float=1, max_wait: float=30):\n    conn_id = str(uuid4())\n\n    def on_retry(retry_state):\n        prefix = _log_prefix(resource_name, conn_id)\n        exception = retry_state.outcome.exception()\n        logger.error(f'{prefix} {action_name} failed: {exception}. Retrying now...')\n\n    def decorator(func):\n        is_coroutine = asyncio.iscoroutinefunction(func)\n        retry_decorator = retry(stop=stop_after_attempt(max_retry + 1), wait=wait_exponential(multiplier=multiplier, min=min_wait, max=max_wait), before_sleep=on_retry, reraise=True)\n        wrapped_func = retry_decorator(func)\n\n        @wraps(func)\n        def sync_wrapper(*args, **kwargs):\n            prefix = _log_prefix(resource_name, conn_id)\n            logger.info(f'{prefix} {action_name} started...')\n            try:\n                result = wrapped_func(*args, **kwargs)\n                logger.info(f'{prefix} {action_name} completed successfully.')\n                return result\n            except Exception as e:\n                logger.error(f'{prefix} {action_name} failed after retries: {e}')\n                raise\n\n        @wraps(func)\n        async def async_wrapper(*args, **kwargs):\n            prefix = _log_prefix(resource_name, conn_id)\n            logger.info(f'{prefix} {action_name} started...')\n            try:\n                result = await wrapped_func(*args, **kwargs)\n                logger.info(f'{prefix} {action_name} completed successfully.')\n                return result\n            except Exception as e:\n                logger.error(f'{prefix} {action_name} failed after retries: {e}')\n                raise\n        return async_wrapper if is_coroutine else sync_wrapper\n    return decorator",
        "conn_id = str(uuid4())",
        "def on_retry(retry_state):\n    prefix = _log_prefix(resource_name, conn_id)\n    exception = retry_state.outcome.exception()\n    logger.error(f'{prefix} {action_name} failed: {exception}. Retrying now...')",
        "prefix = _log_prefix(resource_name, conn_id)",
        "exception = retry_state.outcome.exception()",
        "logger.error(f'{prefix} {action_name} failed: {exception}. Retrying now...')",
        "def decorator(func):\n    is_coroutine = asyncio.iscoroutinefunction(func)\n    retry_decorator = retry(stop=stop_after_attempt(max_retry + 1), wait=wait_exponential(multiplier=multiplier, min=min_wait, max=max_wait), before_sleep=on_retry, reraise=True)\n    wrapped_func = retry_decorator(func)\n\n    @wraps(func)\n    def sync_wrapper(*args, **kwargs):\n        prefix = _log_prefix(resource_name, conn_id)\n        logger.info(f'{prefix} {action_name} started...')\n        try:\n            result = wrapped_func(*args, **kwargs)\n            logger.info(f'{prefix} {action_name} completed successfully.')\n            return result\n        except Exception as e:\n            logger.error(f'{prefix} {action_name} failed after retries: {e}')\n            raise\n\n    @wraps(func)\n    async def async_wrapper(*args, **kwargs):\n        prefix = _log_prefix(resource_name, conn_id)\n        logger.info(f'{prefix} {action_name} started...')\n        try:\n            result = await wrapped_func(*args, **kwargs)\n            logger.info(f'{prefix} {action_name} completed successfully.')\n            return result\n        except Exception as e:\n            logger.error(f'{prefix} {action_name} failed after retries: {e}')\n            raise\n    return async_wrapper if is_coroutine else sync_wrapper",
        "is_coroutine = asyncio.iscoroutinefunction(func)",
        "retry_decorator = retry(stop=stop_after_attempt(max_retry + 1), wait=wait_exponential(multiplier=multiplier, min=min_wait, max=max_wait), before_sleep=on_retry, reraise=True)",
        "wrapped_func = retry_decorator(func)",
        "@wraps(func)\ndef sync_wrapper(*args, **kwargs):\n    prefix = _log_prefix(resource_name, conn_id)\n    logger.info(f'{prefix} {action_name} started...')\n    try:\n        result = wrapped_func(*args, **kwargs)\n        logger.info(f'{prefix} {action_name} completed successfully.')\n        return result\n    except Exception as e:\n        logger.error(f'{prefix} {action_name} failed after retries: {e}')\n        raise",
        "prefix = _log_prefix(resource_name, conn_id)",
        "logger.info(f'{prefix} {action_name} started...')",
        "try:\n    result = wrapped_func(*args, **kwargs)\n    logger.info(f'{prefix} {action_name} completed successfully.')\n    return result\nexcept Exception as e:\n    logger.error(f'{prefix} {action_name} failed after retries: {e}')\n    raise",
        "result = wrapped_func(*args, **kwargs)",
        "logger.info(f'{prefix} {action_name} completed successfully.')",
        "return result"
      ]
    },
    {
      "id": "3",
      "type": "block",
      "statements": [
        "logger.error(f'{prefix} {action_name} failed after retries: {e}')",
        "raise",
        "@wraps(func)\nasync def async_wrapper(*args, **kwargs):\n    prefix = _log_prefix(resource_name, conn_id)\n    logger.info(f'{prefix} {action_name} started...')\n    try:\n        result = await wrapped_func(*args, **kwargs)\n        logger.info(f'{prefix} {action_name} completed successfully.')\n        return result\n    except Exception as e:\n        logger.error(f'{prefix} {action_name} failed after retries: {e}')\n        raise",
        "prefix = _log_prefix(resource_name, conn_id)",
        "logger.info(f'{prefix} {action_name} started...')",
        "try:\n    result = await wrapped_func(*args, **kwargs)\n    logger.info(f'{prefix} {action_name} completed successfully.')\n    return result\nexcept Exception as e:\n    logger.error(f'{prefix} {action_name} failed after retries: {e}')\n    raise",
        "result = await wrapped_func(*args, **kwargs)",
        "logger.info(f'{prefix} {action_name} completed successfully.')",
        "return result"
      ]
    },
    {
      "id": "4",
      "type": "block",
      "statements": [
        "logger.error(f'{prefix} {action_name} failed after retries: {e}')",
        "raise",
        "return async_wrapper if is_coroutine else sync_wrapper"
      ]
    },
    {
      "id": "5",
      "type": "block",
      "statements": [
        "return decorator"
      ]
    }
  ],
  "edges": []
}