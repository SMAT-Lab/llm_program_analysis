{
  "nodes": [
    {
      "id": "1",
      "type": "block",
      "statements": [
        "import ipaddress",
        "import re",
        "import socket",
        "from typing import Callable",
        "from urllib.parse import urlparse, urlunparse",
        "import idna",
        "import requests as req",
        "from backend.util.settings import Config",
        "BLOCKED_IP_NETWORKS = [ipaddress.ip_network('0.0.0.0/8'), ipaddress.ip_network('10.0.0.0/8'), ipaddress.ip_network('127.0.0.0/8'), ipaddress.ip_network('169.254.0.0/16'), ipaddress.ip_network('172.16.0.0/12'), ipaddress.ip_network('192.168.0.0/16'), ipaddress.ip_network('224.0.0.0/4'), ipaddress.ip_network('240.0.0.0/4')]",
        "ALLOWED_SCHEMES = ['http', 'https']",
        "HOSTNAME_REGEX = re.compile('^[A-Za-z0-9.-]+$')",
        "def _canonicalize_url(url: str) -> str:\n    url = url.strip().strip('/')\n    if not url.startswith(('http://', 'https://')):\n        url = 'http://' + url\n    url = url.replace('\\\\', '/')\n    return url",
        "url = url.strip().strip('/')",
        "not url.startswith(('http://', 'https://'))"
      ]
    },
    {
      "id": "2",
      "type": "block",
      "statements": [
        "url = 'http://' + url"
      ]
    },
    {
      "id": "3",
      "type": "block",
      "statements": []
    },
    {
      "id": "4",
      "type": "block",
      "statements": [
        "url = url.replace('\\\\', '/')",
        "return url"
      ]
    },
    {
      "id": "5",
      "type": "block",
      "statements": [
        "def _is_ip_blocked(ip: str) -> bool:\n    \"\"\"\n    Checks if the IP address is in a blocked network.\n    \"\"\"\n    ip_addr = ipaddress.ip_address(ip)\n    return any((ip_addr in network for network in BLOCKED_IP_NETWORKS))",
        "'\\n    Checks if the IP address is in a blocked network.\\n    '",
        "ip_addr = ipaddress.ip_address(ip)",
        "return any((ip_addr in network for network in BLOCKED_IP_NETWORKS))"
      ]
    },
    {
      "id": "6",
      "type": "block",
      "statements": [
        "def validate_url(url: str, trusted_origins: list[str]) -> str:\n    \"\"\"\n    Validates the URL to prevent SSRF attacks by ensuring it does not point to a private\n    or untrusted IP address, unless whitelisted.\n    \"\"\"\n    url = _canonicalize_url(url)\n    parsed = urlparse(url)\n    if parsed.scheme not in ALLOWED_SCHEMES:\n        raise ValueError(f\"Scheme '{parsed.scheme}' is not allowed. Only HTTP/HTTPS are supported.\")\n    if not parsed.hostname:\n        raise ValueError('Invalid URL: No hostname found.')\n    try:\n        ascii_hostname = idna.encode(parsed.hostname).decode('ascii')\n    except idna.IDNAError:\n        raise ValueError('Invalid hostname with unsupported characters.')\n    if not HOSTNAME_REGEX.match(ascii_hostname):\n        raise ValueError('Hostname contains invalid characters.')\n    parsed = parsed._replace(netloc=ascii_hostname)\n    url = str(urlunparse(parsed))\n    if ascii_hostname in trusted_origins:\n        return url\n    try:\n        ip_addresses = {res[4][0] for res in socket.getaddrinfo(ascii_hostname, None)}\n    except socket.gaierror:\n        raise ValueError(f'Unable to resolve IP address for hostname {ascii_hostname}')\n    if not ip_addresses:\n        raise ValueError(f'No IP addresses found for {ascii_hostname}')\n    for ip in ip_addresses:\n        if _is_ip_blocked(ip):\n            raise ValueError(f'Access to private IP address {ip} for hostname {ascii_hostname} is not allowed.')\n    return url",
        "'\\n    Validates the URL to prevent SSRF attacks by ensuring it does not point to a private\\n    or untrusted IP address, unless whitelisted.\\n    '",
        "url = _canonicalize_url(url)",
        "parsed = urlparse(url)",
        "parsed.scheme NotIn ALLOWED_SCHEMES"
      ]
    },
    {
      "id": "7",
      "type": "block",
      "statements": [
        "raise ValueError(f\"Scheme '{parsed.scheme}' is not allowed. Only HTTP/HTTPS are supported.\")"
      ]
    },
    {
      "id": "8",
      "type": "block",
      "statements": []
    },
    {
      "id": "9",
      "type": "block",
      "statements": [
        "not parsed.hostname"
      ]
    },
    {
      "id": "10",
      "type": "block",
      "statements": [
        "raise ValueError('Invalid URL: No hostname found.')"
      ]
    },
    {
      "id": "11",
      "type": "block",
      "statements": []
    },
    {
      "id": "12",
      "type": "block",
      "statements": [
        "try:\n    ascii_hostname = idna.encode(parsed.hostname).decode('ascii')\nexcept idna.IDNAError:\n    raise ValueError('Invalid hostname with unsupported characters.')",
        "ascii_hostname = idna.encode(parsed.hostname).decode('ascii')",
        "raise ValueError('Invalid hostname with unsupported characters.')",
        "not HOSTNAME_REGEX.match(ascii_hostname)"
      ]
    },
    {
      "id": "13",
      "type": "block",
      "statements": [
        "raise ValueError('Hostname contains invalid characters.')"
      ]
    },
    {
      "id": "14",
      "type": "block",
      "statements": []
    },
    {
      "id": "15",
      "type": "block",
      "statements": [
        "parsed = parsed._replace(netloc=ascii_hostname)",
        "url = str(urlunparse(parsed))",
        "ascii_hostname In trusted_origins"
      ]
    },
    {
      "id": "16",
      "type": "block",
      "statements": [
        "return url"
      ]
    },
    {
      "id": "17",
      "type": "block",
      "statements": []
    },
    {
      "id": "18",
      "type": "block",
      "statements": [
        "try:\n    ip_addresses = {res[4][0] for res in socket.getaddrinfo(ascii_hostname, None)}\nexcept socket.gaierror:\n    raise ValueError(f'Unable to resolve IP address for hostname {ascii_hostname}')",
        "ip_addresses = {res[4][0] for res in socket.getaddrinfo(ascii_hostname, None)}",
        "raise ValueError(f'Unable to resolve IP address for hostname {ascii_hostname}')",
        "not ip_addresses"
      ]
    },
    {
      "id": "19",
      "type": "block",
      "statements": [
        "raise ValueError(f'No IP addresses found for {ascii_hostname}')"
      ]
    },
    {
      "id": "20",
      "type": "block",
      "statements": []
    },
    {
      "id": "21",
      "type": "block",
      "statements": []
    },
    {
      "id": "22",
      "type": "block",
      "statements": [
        "ip",
        "ip_addresses"
      ]
    },
    {
      "id": "23",
      "type": "block",
      "statements": [
        "_is_ip_blocked(ip)"
      ]
    },
    {
      "id": "24",
      "type": "block",
      "statements": [
        "return url"
      ]
    },
    {
      "id": "25",
      "type": "block",
      "statements": [
        "raise ValueError(f'Access to private IP address {ip} for hostname {ascii_hostname} is not allowed.')"
      ]
    },
    {
      "id": "26",
      "type": "block",
      "statements": []
    },
    {
      "id": "27",
      "type": "block",
      "statements": []
    },
    {
      "id": "28",
      "type": "block",
      "statements": [
        "class Requests:\n    \"\"\"\n    A wrapper around the requests library that validates URLs before making requests.\n    \"\"\"\n\n    def __init__(self, trusted_origins: list[str] | None=None, raise_for_status: bool=True, extra_url_validator: Callable[[str], str] | None=None, extra_headers: dict[str, str] | None=None):\n        self.trusted_origins = []\n        for url in trusted_origins or []:\n            hostname = urlparse(url).hostname\n            if not hostname:\n                raise ValueError(f'Invalid URL: Unable to determine hostname of {url}')\n            self.trusted_origins.append(hostname)\n        self.raise_for_status = raise_for_status\n        self.extra_url_validator = extra_url_validator\n        self.extra_headers = extra_headers\n\n    def request(self, method, url, headers=None, allow_redirects=False, *args, **kwargs) -> req.Response:\n        if self.extra_headers is not None:\n            headers = {**(headers or {}), **self.extra_headers}\n        url = validate_url(url, self.trusted_origins)\n        if self.extra_url_validator is not None:\n            url = self.extra_url_validator(url)\n        response = req.request(method, url, *args, headers=headers, allow_redirects=allow_redirects, **kwargs)\n        if self.raise_for_status:\n            response.raise_for_status()\n        return response\n\n    def get(self, url, *args, **kwargs) -> req.Response:\n        return self.request('GET', url, *args, **kwargs)\n\n    def post(self, url, *args, **kwargs) -> req.Response:\n        return self.request('POST', url, *args, **kwargs)\n\n    def put(self, url, *args, **kwargs) -> req.Response:\n        return self.request('PUT', url, *args, **kwargs)\n\n    def delete(self, url, *args, **kwargs) -> req.Response:\n        return self.request('DELETE', url, *args, **kwargs)\n\n    def head(self, url, *args, **kwargs) -> req.Response:\n        return self.request('HEAD', url, *args, **kwargs)\n\n    def options(self, url, *args, **kwargs) -> req.Response:\n        return self.request('OPTIONS', url, *args, **kwargs)\n\n    def patch(self, url, *args, **kwargs) -> req.Response:\n        return self.request('PATCH', url, *args, **kwargs)",
        "'\\n    A wrapper around the requests library that validates URLs before making requests.\\n    '",
        "def __init__(self, trusted_origins: list[str] | None=None, raise_for_status: bool=True, extra_url_validator: Callable[[str], str] | None=None, extra_headers: dict[str, str] | None=None):\n    self.trusted_origins = []\n    for url in trusted_origins or []:\n        hostname = urlparse(url).hostname\n        if not hostname:\n            raise ValueError(f'Invalid URL: Unable to determine hostname of {url}')\n        self.trusted_origins.append(hostname)\n    self.raise_for_status = raise_for_status\n    self.extra_url_validator = extra_url_validator\n    self.extra_headers = extra_headers",
        "self.trusted_origins = []"
      ]
    },
    {
      "id": "29",
      "type": "block",
      "statements": [
        "url",
        "trusted_origins or []"
      ]
    },
    {
      "id": "30",
      "type": "block",
      "statements": [
        "hostname = urlparse(url).hostname",
        "not hostname"
      ]
    },
    {
      "id": "31",
      "type": "block",
      "statements": [
        "self.raise_for_status = raise_for_status",
        "self.extra_url_validator = extra_url_validator",
        "self.extra_headers = extra_headers",
        "def request(self, method, url, headers=None, allow_redirects=False, *args, **kwargs) -> req.Response:\n    if self.extra_headers is not None:\n        headers = {**(headers or {}), **self.extra_headers}\n    url = validate_url(url, self.trusted_origins)\n    if self.extra_url_validator is not None:\n        url = self.extra_url_validator(url)\n    response = req.request(method, url, *args, headers=headers, allow_redirects=allow_redirects, **kwargs)\n    if self.raise_for_status:\n        response.raise_for_status()\n    return response",
        "self.extra_headers IsNot None"
      ]
    },
    {
      "id": "32",
      "type": "block",
      "statements": [
        "raise ValueError(f'Invalid URL: Unable to determine hostname of {url}')"
      ]
    },
    {
      "id": "33",
      "type": "block",
      "statements": []
    },
    {
      "id": "34",
      "type": "block",
      "statements": [
        "self.trusted_origins.append(hostname)"
      ]
    },
    {
      "id": "35",
      "type": "block",
      "statements": [
        "headers = {**(headers or {}), **self.extra_headers}"
      ]
    },
    {
      "id": "36",
      "type": "block",
      "statements": []
    },
    {
      "id": "37",
      "type": "block",
      "statements": [
        "url = validate_url(url, self.trusted_origins)",
        "self.extra_url_validator IsNot None"
      ]
    },
    {
      "id": "38",
      "type": "block",
      "statements": [
        "url = self.extra_url_validator(url)"
      ]
    },
    {
      "id": "39",
      "type": "block",
      "statements": []
    },
    {
      "id": "40",
      "type": "block",
      "statements": [
        "response = req.request(method, url, *args, headers=headers, allow_redirects=allow_redirects, **kwargs)",
        "self.raise_for_status"
      ]
    },
    {
      "id": "41",
      "type": "block",
      "statements": [
        "response.raise_for_status()"
      ]
    },
    {
      "id": "42",
      "type": "block",
      "statements": []
    },
    {
      "id": "43",
      "type": "block",
      "statements": [
        "return response"
      ]
    },
    {
      "id": "44",
      "type": "block",
      "statements": [
        "def get(self, url, *args, **kwargs) -> req.Response:\n    return self.request('GET', url, *args, **kwargs)",
        "return self.request('GET', url, *args, **kwargs)"
      ]
    },
    {
      "id": "45",
      "type": "block",
      "statements": [
        "def post(self, url, *args, **kwargs) -> req.Response:\n    return self.request('POST', url, *args, **kwargs)",
        "return self.request('POST', url, *args, **kwargs)"
      ]
    },
    {
      "id": "46",
      "type": "block",
      "statements": [
        "def put(self, url, *args, **kwargs) -> req.Response:\n    return self.request('PUT', url, *args, **kwargs)",
        "return self.request('PUT', url, *args, **kwargs)"
      ]
    },
    {
      "id": "47",
      "type": "block",
      "statements": [
        "def delete(self, url, *args, **kwargs) -> req.Response:\n    return self.request('DELETE', url, *args, **kwargs)",
        "return self.request('DELETE', url, *args, **kwargs)"
      ]
    },
    {
      "id": "48",
      "type": "block",
      "statements": [
        "def head(self, url, *args, **kwargs) -> req.Response:\n    return self.request('HEAD', url, *args, **kwargs)",
        "return self.request('HEAD', url, *args, **kwargs)"
      ]
    },
    {
      "id": "49",
      "type": "block",
      "statements": [
        "def options(self, url, *args, **kwargs) -> req.Response:\n    return self.request('OPTIONS', url, *args, **kwargs)",
        "return self.request('OPTIONS', url, *args, **kwargs)"
      ]
    },
    {
      "id": "50",
      "type": "block",
      "statements": [
        "def patch(self, url, *args, **kwargs) -> req.Response:\n    return self.request('PATCH', url, *args, **kwargs)",
        "return self.request('PATCH', url, *args, **kwargs)"
      ]
    },
    {
      "id": "51",
      "type": "block",
      "statements": [
        "requests = Requests(trusted_origins=Config().trust_endpoints_for_requests)"
      ]
    }
  ],
  "edges": [
    {
      "source": "1",
      "target": "2",
      "type": "true"
    },
    {
      "source": "1",
      "target": "3",
      "type": "false"
    },
    {
      "source": "2",
      "target": "4",
      "type": "next"
    },
    {
      "source": "3",
      "target": "4",
      "type": "next"
    },
    {
      "source": "6",
      "target": "7",
      "type": "true"
    },
    {
      "source": "6",
      "target": "8",
      "type": "false"
    },
    {
      "source": "7",
      "target": "9",
      "type": "next"
    },
    {
      "source": "8",
      "target": "9",
      "type": "next"
    },
    {
      "source": "9",
      "target": "10",
      "type": "true"
    },
    {
      "source": "9",
      "target": "11",
      "type": "false"
    },
    {
      "source": "10",
      "target": "12",
      "type": "next"
    },
    {
      "source": "11",
      "target": "12",
      "type": "next"
    },
    {
      "source": "12",
      "target": "13",
      "type": "true"
    },
    {
      "source": "12",
      "target": "14",
      "type": "false"
    },
    {
      "source": "13",
      "target": "15",
      "type": "next"
    },
    {
      "source": "14",
      "target": "15",
      "type": "next"
    },
    {
      "source": "15",
      "target": "16",
      "type": "true"
    },
    {
      "source": "15",
      "target": "17",
      "type": "false"
    },
    {
      "source": "17",
      "target": "18",
      "type": "next"
    },
    {
      "source": "18",
      "target": "19",
      "type": "true"
    },
    {
      "source": "18",
      "target": "20",
      "type": "false"
    },
    {
      "source": "19",
      "target": "21",
      "type": "next"
    },
    {
      "source": "20",
      "target": "21",
      "type": "next"
    },
    {
      "source": "21",
      "target": "22",
      "type": "next"
    },
    {
      "source": "22",
      "target": "23",
      "type": "true"
    },
    {
      "source": "22",
      "target": "24",
      "type": "false"
    },
    {
      "source": "23",
      "target": "25",
      "type": "true"
    },
    {
      "source": "23",
      "target": "26",
      "type": "false"
    },
    {
      "source": "25",
      "target": "27",
      "type": "next"
    },
    {
      "source": "26",
      "target": "27",
      "type": "next"
    },
    {
      "source": "27",
      "target": "22",
      "type": "next"
    },
    {
      "source": "28",
      "target": "29",
      "type": "next"
    },
    {
      "source": "29",
      "target": "30",
      "type": "true"
    },
    {
      "source": "29",
      "target": "31",
      "type": "false"
    },
    {
      "source": "30",
      "target": "32",
      "type": "true"
    },
    {
      "source": "30",
      "target": "33",
      "type": "false"
    },
    {
      "source": "31",
      "target": "35",
      "type": "true"
    },
    {
      "source": "31",
      "target": "36",
      "type": "false"
    },
    {
      "source": "32",
      "target": "34",
      "type": "next"
    },
    {
      "source": "33",
      "target": "34",
      "type": "next"
    },
    {
      "source": "34",
      "target": "29",
      "type": "next"
    },
    {
      "source": "35",
      "target": "37",
      "type": "next"
    },
    {
      "source": "36",
      "target": "37",
      "type": "next"
    },
    {
      "source": "37",
      "target": "38",
      "type": "true"
    },
    {
      "source": "37",
      "target": "39",
      "type": "false"
    },
    {
      "source": "38",
      "target": "40",
      "type": "next"
    },
    {
      "source": "39",
      "target": "40",
      "type": "next"
    },
    {
      "source": "40",
      "target": "41",
      "type": "true"
    },
    {
      "source": "40",
      "target": "42",
      "type": "false"
    },
    {
      "source": "41",
      "target": "43",
      "type": "next"
    },
    {
      "source": "42",
      "target": "43",
      "type": "next"
    }
  ]
}