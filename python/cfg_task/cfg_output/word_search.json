{
  "nodes": [
    {
      "id": "1",
      "type": "block",
      "statements": [
        "'\\nAuthor  : Alexander Pantyukhin\\nDate    : November 24, 2022\\n\\nTask:\\nGiven an m x n grid of characters board and a string word,\\nreturn true if word exists in the grid.\\n\\nThe word can be constructed from letters of sequentially adjacent cells,\\nwhere adjacent cells are horizontally or vertically neighboring.\\nThe same letter cell may not be used more than once.\\n\\nExample:\\n\\nMatrix:\\n---------\\n|A|B|C|E|\\n|S|F|C|S|\\n|A|D|E|E|\\n---------\\n\\nWord:\\n\"ABCCED\"\\n\\nResult:\\nTrue\\n\\nImplementation notes: Use backtracking approach.\\nAt each point, check all neighbors to try to find the next letter of the word.\\n\\nleetcode: https://leetcode.com/problems/word-search/\\n\\n'",
        "def get_point_key(len_board: int, len_board_column: int, row: int, column: int) -> int:\n    \"\"\"\n    Returns the hash key of matrix indexes.\n\n    >>> get_point_key(10, 20, 1, 0)\n    200\n    \"\"\"\n    return len_board * len_board_column * row + column",
        "'\\n    Returns the hash key of matrix indexes.\\n\\n    >>> get_point_key(10, 20, 1, 0)\\n    200\\n    '",
        "return len_board * len_board_column * row + column"
      ]
    },
    {
      "id": "2",
      "type": "block",
      "statements": [
        "def exits_word(board: list[list[str]], word: str, row: int, column: int, word_index: int, visited_points_set: set[int]) -> bool:\n    \"\"\"\n    Return True if it's possible to search the word suffix\n    starting from the word_index.\n\n    >>> exits_word([[\"A\"]], \"B\", 0, 0, 0, set())\n    False\n    \"\"\"\n    if board[row][column] != word[word_index]:\n        return False\n    if word_index == len(word) - 1:\n        return True\n    traverts_directions = [(0, 1), (0, -1), (-1, 0), (1, 0)]\n    len_board = len(board)\n    len_board_column = len(board[0])\n    for direction in traverts_directions:\n        next_i = row + direction[0]\n        next_j = column + direction[1]\n        if not (0 <= next_i < len_board and 0 <= next_j < len_board_column):\n            continue\n        key = get_point_key(len_board, len_board_column, next_i, next_j)\n        if key in visited_points_set:\n            continue\n        visited_points_set.add(key)\n        if exits_word(board, word, next_i, next_j, word_index + 1, visited_points_set):\n            return True\n        visited_points_set.remove(key)\n    return False",
        "'\\n    Return True if it\\'s possible to search the word suffix\\n    starting from the word_index.\\n\\n    >>> exits_word([[\"A\"]], \"B\", 0, 0, 0, set())\\n    False\\n    '",
        "board[row][column] NotEq word[word_index]"
      ]
    },
    {
      "id": "3",
      "type": "block",
      "statements": [
        "return False"
      ]
    },
    {
      "id": "4",
      "type": "block",
      "statements": []
    },
    {
      "id": "5",
      "type": "block",
      "statements": [
        "word_index Eq len(word) Sub 1"
      ]
    },
    {
      "id": "6",
      "type": "block",
      "statements": [
        "return True"
      ]
    },
    {
      "id": "7",
      "type": "block",
      "statements": []
    },
    {
      "id": "8",
      "type": "block",
      "statements": [
        "traverts_directions = [(0, 1), (0, -1), (-1, 0), (1, 0)]",
        "len_board = len(board)",
        "len_board_column = len(board[0])"
      ]
    },
    {
      "id": "9",
      "type": "block",
      "statements": [
        "direction",
        "traverts_directions"
      ]
    },
    {
      "id": "10",
      "type": "block",
      "statements": [
        "next_i = row + direction[0]",
        "next_j = column + direction[1]",
        "not (0 <= next_i < len_board and 0 <= next_j < len_board_column)"
      ]
    },
    {
      "id": "11",
      "type": "block",
      "statements": [
        "return False"
      ]
    },
    {
      "id": "12",
      "type": "block",
      "statements": [
        "continue"
      ]
    },
    {
      "id": "13",
      "type": "block",
      "statements": []
    },
    {
      "id": "14",
      "type": "block",
      "statements": [
        "key = get_point_key(len_board, len_board_column, next_i, next_j)",
        "key In visited_points_set"
      ]
    },
    {
      "id": "15",
      "type": "block",
      "statements": [
        "continue"
      ]
    },
    {
      "id": "16",
      "type": "block",
      "statements": []
    },
    {
      "id": "17",
      "type": "block",
      "statements": [
        "visited_points_set.add(key)",
        "exits_word(board, word, next_i, next_j, word_index Add 1, visited_points_set)"
      ]
    },
    {
      "id": "18",
      "type": "block",
      "statements": [
        "return True"
      ]
    },
    {
      "id": "19",
      "type": "block",
      "statements": []
    },
    {
      "id": "20",
      "type": "block",
      "statements": [
        "visited_points_set.remove(key)"
      ]
    },
    {
      "id": "21",
      "type": "block",
      "statements": [
        "def word_exists(board: list[list[str]], word: str) -> bool:\n    \"\"\"\n    >>> word_exists([[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], \"ABCCED\")\n    True\n    >>> word_exists([[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], \"SEE\")\n    True\n    >>> word_exists([[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], \"ABCB\")\n    False\n    >>> word_exists([[\"A\"]], \"A\")\n    True\n    >>> word_exists([[\"B\", \"A\", \"A\"], [\"A\", \"A\", \"A\"], [\"A\", \"B\", \"A\"]], \"ABB\")\n    False\n    >>> word_exists([[\"A\"]], 123)\n    Traceback (most recent call last):\n        ...\n    ValueError: The word parameter should be a string of length greater than 0.\n    >>> word_exists([[\"A\"]], \"\")\n    Traceback (most recent call last):\n        ...\n    ValueError: The word parameter should be a string of length greater than 0.\n    >>> word_exists([[]], \"AB\")\n    Traceback (most recent call last):\n        ...\n    ValueError: The board should be a non empty matrix of single chars strings.\n    >>> word_exists([], \"AB\")\n    Traceback (most recent call last):\n        ...\n    ValueError: The board should be a non empty matrix of single chars strings.\n    >>> word_exists([[\"A\"], [21]], \"AB\")\n    Traceback (most recent call last):\n        ...\n    ValueError: The board should be a non empty matrix of single chars strings.\n    \"\"\"\n    board_error_message = 'The board should be a non empty matrix of single chars strings.'\n    len_board = len(board)\n    if not isinstance(board, list) or len(board) == 0:\n        raise ValueError(board_error_message)\n    for row in board:\n        if not isinstance(row, list) or len(row) == 0:\n            raise ValueError(board_error_message)\n        for item in row:\n            if not isinstance(item, str) or len(item) != 1:\n                raise ValueError(board_error_message)\n    if not isinstance(word, str) or len(word) == 0:\n        raise ValueError('The word parameter should be a string of length greater than 0.')\n    len_board_column = len(board[0])\n    for i in range(len_board):\n        for j in range(len_board_column):\n            if exits_word(board, word, i, j, 0, {get_point_key(len_board, len_board_column, i, j)}):\n                return True\n    return False",
        "'\\n    >>> word_exists([[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], \"ABCCED\")\\n    True\\n    >>> word_exists([[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], \"SEE\")\\n    True\\n    >>> word_exists([[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], \"ABCB\")\\n    False\\n    >>> word_exists([[\"A\"]], \"A\")\\n    True\\n    >>> word_exists([[\"B\", \"A\", \"A\"], [\"A\", \"A\", \"A\"], [\"A\", \"B\", \"A\"]], \"ABB\")\\n    False\\n    >>> word_exists([[\"A\"]], 123)\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: The word parameter should be a string of length greater than 0.\\n    >>> word_exists([[\"A\"]], \"\")\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: The word parameter should be a string of length greater than 0.\\n    >>> word_exists([[]], \"AB\")\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: The board should be a non empty matrix of single chars strings.\\n    >>> word_exists([], \"AB\")\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: The board should be a non empty matrix of single chars strings.\\n    >>> word_exists([[\"A\"], [21]], \"AB\")\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: The board should be a non empty matrix of single chars strings.\\n    '",
        "board_error_message = 'The board should be a non empty matrix of single chars strings.'",
        "len_board = len(board)",
        "not isinstance(board, list) or len(board) == 0"
      ]
    },
    {
      "id": "22",
      "type": "block",
      "statements": [
        "raise ValueError(board_error_message)"
      ]
    },
    {
      "id": "23",
      "type": "block",
      "statements": []
    },
    {
      "id": "24",
      "type": "block",
      "statements": []
    },
    {
      "id": "25",
      "type": "block",
      "statements": [
        "row",
        "board"
      ]
    },
    {
      "id": "26",
      "type": "block",
      "statements": [
        "not isinstance(row, list) or len(row) == 0"
      ]
    },
    {
      "id": "27",
      "type": "block",
      "statements": [
        "not isinstance(word, str) or len(word) == 0"
      ]
    },
    {
      "id": "28",
      "type": "block",
      "statements": [
        "raise ValueError(board_error_message)"
      ]
    },
    {
      "id": "29",
      "type": "block",
      "statements": []
    },
    {
      "id": "30",
      "type": "block",
      "statements": []
    },
    {
      "id": "31",
      "type": "block",
      "statements": [
        "item",
        "row"
      ]
    },
    {
      "id": "32",
      "type": "block",
      "statements": [
        "not isinstance(item, str) or len(item) != 1"
      ]
    },
    {
      "id": "33",
      "type": "block",
      "statements": []
    },
    {
      "id": "34",
      "type": "block",
      "statements": [
        "raise ValueError(board_error_message)"
      ]
    },
    {
      "id": "35",
      "type": "block",
      "statements": []
    },
    {
      "id": "36",
      "type": "block",
      "statements": []
    },
    {
      "id": "37",
      "type": "block",
      "statements": [
        "raise ValueError('The word parameter should be a string of length greater than 0.')"
      ]
    },
    {
      "id": "38",
      "type": "block",
      "statements": []
    },
    {
      "id": "39",
      "type": "block",
      "statements": [
        "len_board_column = len(board[0])"
      ]
    },
    {
      "id": "40",
      "type": "block",
      "statements": [
        "i",
        "range(len_board)"
      ]
    },
    {
      "id": "41",
      "type": "block",
      "statements": []
    },
    {
      "id": "42",
      "type": "block",
      "statements": [
        "return False"
      ]
    },
    {
      "id": "43",
      "type": "block",
      "statements": [
        "j",
        "range(len_board_column)"
      ]
    },
    {
      "id": "44",
      "type": "block",
      "statements": [
        "exits_word(board, word, i, j, 0, {get_point_key(len_board, len_board_column, i, j)})"
      ]
    },
    {
      "id": "45",
      "type": "block",
      "statements": []
    },
    {
      "id": "46",
      "type": "block",
      "statements": [
        "return True"
      ]
    },
    {
      "id": "47",
      "type": "block",
      "statements": []
    },
    {
      "id": "48",
      "type": "block",
      "statements": []
    },
    {
      "id": "49",
      "type": "block",
      "statements": [
        "__name__ Eq '__main__'"
      ]
    },
    {
      "id": "50",
      "type": "block",
      "statements": [
        "import doctest",
        "doctest.testmod()"
      ]
    },
    {
      "id": "51",
      "type": "block",
      "statements": []
    },
    {
      "id": "52",
      "type": "block",
      "statements": []
    }
  ],
  "edges": [
    {
      "source": "2",
      "target": "3",
      "type": "true"
    },
    {
      "source": "2",
      "target": "4",
      "type": "false"
    },
    {
      "source": "4",
      "target": "5",
      "type": "next"
    },
    {
      "source": "5",
      "target": "6",
      "type": "true"
    },
    {
      "source": "5",
      "target": "7",
      "type": "false"
    },
    {
      "source": "7",
      "target": "8",
      "type": "next"
    },
    {
      "source": "8",
      "target": "9",
      "type": "next"
    },
    {
      "source": "9",
      "target": "10",
      "type": "true"
    },
    {
      "source": "9",
      "target": "11",
      "type": "false"
    },
    {
      "source": "10",
      "target": "12",
      "type": "true"
    },
    {
      "source": "10",
      "target": "13",
      "type": "false"
    },
    {
      "source": "12",
      "target": "14",
      "type": "next"
    },
    {
      "source": "13",
      "target": "14",
      "type": "next"
    },
    {
      "source": "14",
      "target": "15",
      "type": "true"
    },
    {
      "source": "14",
      "target": "16",
      "type": "false"
    },
    {
      "source": "15",
      "target": "17",
      "type": "next"
    },
    {
      "source": "16",
      "target": "17",
      "type": "next"
    },
    {
      "source": "17",
      "target": "18",
      "type": "true"
    },
    {
      "source": "17",
      "target": "19",
      "type": "false"
    },
    {
      "source": "19",
      "target": "20",
      "type": "next"
    },
    {
      "source": "20",
      "target": "9",
      "type": "next"
    },
    {
      "source": "21",
      "target": "22",
      "type": "true"
    },
    {
      "source": "21",
      "target": "23",
      "type": "false"
    },
    {
      "source": "22",
      "target": "24",
      "type": "next"
    },
    {
      "source": "23",
      "target": "24",
      "type": "next"
    },
    {
      "source": "24",
      "target": "25",
      "type": "next"
    },
    {
      "source": "25",
      "target": "26",
      "type": "true"
    },
    {
      "source": "25",
      "target": "27",
      "type": "false"
    },
    {
      "source": "26",
      "target": "28",
      "type": "true"
    },
    {
      "source": "26",
      "target": "29",
      "type": "false"
    },
    {
      "source": "27",
      "target": "37",
      "type": "true"
    },
    {
      "source": "27",
      "target": "38",
      "type": "false"
    },
    {
      "source": "28",
      "target": "30",
      "type": "next"
    },
    {
      "source": "29",
      "target": "30",
      "type": "next"
    },
    {
      "source": "30",
      "target": "31",
      "type": "next"
    },
    {
      "source": "31",
      "target": "32",
      "type": "true"
    },
    {
      "source": "31",
      "target": "33",
      "type": "false"
    },
    {
      "source": "32",
      "target": "34",
      "type": "true"
    },
    {
      "source": "32",
      "target": "35",
      "type": "false"
    },
    {
      "source": "33",
      "target": "25",
      "type": "next"
    },
    {
      "source": "34",
      "target": "36",
      "type": "next"
    },
    {
      "source": "35",
      "target": "36",
      "type": "next"
    },
    {
      "source": "36",
      "target": "31",
      "type": "next"
    },
    {
      "source": "37",
      "target": "39",
      "type": "next"
    },
    {
      "source": "38",
      "target": "39",
      "type": "next"
    },
    {
      "source": "39",
      "target": "40",
      "type": "next"
    },
    {
      "source": "40",
      "target": "41",
      "type": "true"
    },
    {
      "source": "40",
      "target": "42",
      "type": "false"
    },
    {
      "source": "41",
      "target": "43",
      "type": "next"
    },
    {
      "source": "43",
      "target": "44",
      "type": "true"
    },
    {
      "source": "43",
      "target": "45",
      "type": "false"
    },
    {
      "source": "44",
      "target": "46",
      "type": "true"
    },
    {
      "source": "44",
      "target": "47",
      "type": "false"
    },
    {
      "source": "45",
      "target": "40",
      "type": "next"
    },
    {
      "source": "47",
      "target": "48",
      "type": "next"
    },
    {
      "source": "48",
      "target": "43",
      "type": "next"
    },
    {
      "source": "49",
      "target": "50",
      "type": "true"
    },
    {
      "source": "49",
      "target": "51",
      "type": "false"
    },
    {
      "source": "50",
      "target": "52",
      "type": "next"
    },
    {
      "source": "51",
      "target": "52",
      "type": "next"
    }
  ]
}