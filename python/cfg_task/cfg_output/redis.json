{
  "nodes": [
    {
      "id": "1",
      "type": "block",
      "statements": [
        "import logging",
        "import os",
        "from dotenv import load_dotenv",
        "from redis import Redis",
        "from redis.asyncio import Redis as AsyncRedis",
        "from backend.util.retry import conn_retry",
        "load_dotenv()",
        "HOST = os.getenv('REDIS_HOST', 'localhost')",
        "PORT = int(os.getenv('REDIS_PORT', '6379'))",
        "PASSWORD = os.getenv('REDIS_PASSWORD', 'password')",
        "logger = logging.getLogger(__name__)",
        "connection: Redis | None = None",
        "connection_async: AsyncRedis | None = None",
        "@conn_retry('Redis', 'Acquiring connection')\ndef connect() -> Redis:\n    global connection\n    if connection:\n        return connection\n    c = Redis(host=HOST, port=PORT, password=PASSWORD, decode_responses=True)\n    c.ping()\n    connection = c\n    return connection",
        "global connection",
        "connection"
      ]
    },
    {
      "id": "2",
      "type": "block",
      "statements": [
        "return connection"
      ]
    },
    {
      "id": "3",
      "type": "block",
      "statements": []
    },
    {
      "id": "4",
      "type": "block",
      "statements": [
        "c = Redis(host=HOST, port=PORT, password=PASSWORD, decode_responses=True)",
        "c.ping()",
        "connection = c",
        "return connection"
      ]
    },
    {
      "id": "5",
      "type": "block",
      "statements": [
        "@conn_retry('Redis', 'Releasing connection')\ndef disconnect():\n    global connection\n    if connection:\n        connection.close()\n    connection = None",
        "global connection",
        "connection"
      ]
    },
    {
      "id": "6",
      "type": "block",
      "statements": [
        "connection.close()"
      ]
    },
    {
      "id": "7",
      "type": "block",
      "statements": []
    },
    {
      "id": "8",
      "type": "block",
      "statements": [
        "connection = None",
        "def get_redis(auto_connect: bool=True) -> Redis:\n    if connection:\n        return connection\n    if auto_connect:\n        return connect()\n    raise RuntimeError('Redis connection is not established')",
        "connection"
      ]
    },
    {
      "id": "9",
      "type": "block",
      "statements": [
        "return connection"
      ]
    },
    {
      "id": "10",
      "type": "block",
      "statements": []
    },
    {
      "id": "11",
      "type": "block",
      "statements": [
        "auto_connect"
      ]
    },
    {
      "id": "12",
      "type": "block",
      "statements": [
        "return connect()"
      ]
    },
    {
      "id": "13",
      "type": "block",
      "statements": []
    },
    {
      "id": "14",
      "type": "block",
      "statements": [
        "raise RuntimeError('Redis connection is not established')",
        "@conn_retry('AsyncRedis', 'Acquiring connection')\nasync def connect_async() -> AsyncRedis:\n    global connection_async\n    if connection_async:\n        return connection_async\n    c = AsyncRedis(host=HOST, port=PORT, password=PASSWORD, decode_responses=True)\n    await c.ping()\n    connection_async = c\n    return connection_async",
        "global connection_async",
        "connection_async"
      ]
    },
    {
      "id": "15",
      "type": "block",
      "statements": [
        "return connection_async"
      ]
    },
    {
      "id": "16",
      "type": "block",
      "statements": []
    },
    {
      "id": "17",
      "type": "block",
      "statements": [
        "c = AsyncRedis(host=HOST, port=PORT, password=PASSWORD, decode_responses=True)",
        "await c.ping()",
        "connection_async = c",
        "return connection_async"
      ]
    },
    {
      "id": "18",
      "type": "block",
      "statements": [
        "@conn_retry('AsyncRedis', 'Releasing connection')\nasync def disconnect_async():\n    global connection_async\n    if connection_async:\n        await connection_async.close()\n    connection_async = None",
        "global connection_async",
        "connection_async"
      ]
    },
    {
      "id": "19",
      "type": "block",
      "statements": [
        "await connection_async.close()"
      ]
    },
    {
      "id": "20",
      "type": "block",
      "statements": []
    },
    {
      "id": "21",
      "type": "block",
      "statements": [
        "connection_async = None",
        "async def get_redis_async(auto_connect: bool=True) -> AsyncRedis:\n    if connection_async:\n        return connection_async\n    if auto_connect:\n        return await connect_async()\n    raise RuntimeError('AsyncRedis connection is not established')",
        "connection_async"
      ]
    },
    {
      "id": "22",
      "type": "block",
      "statements": [
        "return connection_async"
      ]
    },
    {
      "id": "23",
      "type": "block",
      "statements": []
    },
    {
      "id": "24",
      "type": "block",
      "statements": [
        "auto_connect"
      ]
    },
    {
      "id": "25",
      "type": "block",
      "statements": [
        "return await connect_async()"
      ]
    },
    {
      "id": "26",
      "type": "block",
      "statements": []
    },
    {
      "id": "27",
      "type": "block",
      "statements": [
        "raise RuntimeError('AsyncRedis connection is not established')"
      ]
    }
  ],
  "edges": [
    {
      "source": "1",
      "target": "2",
      "type": "true"
    },
    {
      "source": "1",
      "target": "3",
      "type": "false"
    },
    {
      "source": "3",
      "target": "4",
      "type": "next"
    },
    {
      "source": "5",
      "target": "6",
      "type": "true"
    },
    {
      "source": "5",
      "target": "7",
      "type": "false"
    },
    {
      "source": "6",
      "target": "8",
      "type": "next"
    },
    {
      "source": "7",
      "target": "8",
      "type": "next"
    },
    {
      "source": "8",
      "target": "9",
      "type": "true"
    },
    {
      "source": "8",
      "target": "10",
      "type": "false"
    },
    {
      "source": "10",
      "target": "11",
      "type": "next"
    },
    {
      "source": "11",
      "target": "12",
      "type": "true"
    },
    {
      "source": "11",
      "target": "13",
      "type": "false"
    },
    {
      "source": "13",
      "target": "14",
      "type": "next"
    },
    {
      "source": "14",
      "target": "15",
      "type": "true"
    },
    {
      "source": "14",
      "target": "16",
      "type": "false"
    },
    {
      "source": "16",
      "target": "17",
      "type": "next"
    },
    {
      "source": "18",
      "target": "19",
      "type": "true"
    },
    {
      "source": "18",
      "target": "20",
      "type": "false"
    },
    {
      "source": "19",
      "target": "21",
      "type": "next"
    },
    {
      "source": "20",
      "target": "21",
      "type": "next"
    },
    {
      "source": "21",
      "target": "22",
      "type": "true"
    },
    {
      "source": "21",
      "target": "23",
      "type": "false"
    },
    {
      "source": "23",
      "target": "24",
      "type": "next"
    },
    {
      "source": "24",
      "target": "25",
      "type": "true"
    },
    {
      "source": "24",
      "target": "26",
      "type": "false"
    },
    {
      "source": "26",
      "target": "27",
      "type": "next"
    }
  ]
}