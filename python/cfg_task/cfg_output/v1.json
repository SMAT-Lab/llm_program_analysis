{
  "nodes": [
    {
      "id": "1",
      "type": "block",
      "statements": [
        "import asyncio",
        "import logging",
        "from collections import defaultdict",
        "from typing import TYPE_CHECKING, Annotated, Any, Sequence",
        "import pydantic",
        "from autogpt_libs.auth.middleware import auth_middleware",
        "from autogpt_libs.feature_flag.client import feature_flag",
        "from autogpt_libs.utils.cache import thread_cached",
        "from fastapi import APIRouter, Depends, HTTPException",
        "from typing_extensions import Optional, TypedDict",
        "import backend.data.block",
        "import backend.server.integrations.router",
        "import backend.server.routers.analytics",
        "from backend.data import execution as execution_db",
        "from backend.data import graph as graph_db",
        "from backend.data.api_key import APIKeyError, APIKeyNotFoundError, APIKeyPermissionError, APIKeyWithoutHash, generate_api_key, get_api_key_by_id, list_user_api_keys, revoke_api_key, suspend_api_key, update_api_key_permissions",
        "from backend.data.block import BlockInput, CompletedBlockOutput",
        "from backend.data.credit import get_block_costs, get_user_credit_model",
        "from backend.data.user import get_or_create_user",
        "from backend.executor import ExecutionManager, ExecutionScheduler, scheduler",
        "from backend.integrations.creds_manager import IntegrationCredentialsManager",
        "from backend.integrations.webhooks.graph_lifecycle_hooks import on_graph_activate, on_graph_deactivate",
        "from backend.server.model import CreateAPIKeyRequest, CreateAPIKeyResponse, CreateGraph, SetGraphActiveVersion, UpdatePermissionsRequest",
        "from backend.server.utils import get_user_id",
        "from backend.util.service import get_service_client",
        "from backend.util.settings import Settings",
        "TYPE_CHECKING"
      ]
    },
    {
      "id": "2",
      "type": "block",
      "statements": [
        "from backend.data.model import Credentials"
      ]
    },
    {
      "id": "3",
      "type": "block",
      "statements": []
    },
    {
      "id": "4",
      "type": "block",
      "statements": [
        "@thread_cached\ndef execution_manager_client() -> ExecutionManager:\n    return get_service_client(ExecutionManager)",
        "return get_service_client(ExecutionManager)"
      ]
    },
    {
      "id": "5",
      "type": "block",
      "statements": [
        "@thread_cached\ndef execution_scheduler_client() -> ExecutionScheduler:\n    return get_service_client(ExecutionScheduler)",
        "return get_service_client(ExecutionScheduler)"
      ]
    },
    {
      "id": "6",
      "type": "block",
      "statements": [
        "settings = Settings()",
        "logger = logging.getLogger(__name__)",
        "integration_creds_manager = IntegrationCredentialsManager()",
        "_user_credit_model = get_user_credit_model()",
        "v1_router = APIRouter()",
        "v1_router.include_router(backend.server.integrations.router.router)",
        "v1_router.include_router(backend.server.routers.analytics.router)",
        "@v1_router.post('/auth/user', tags=['auth'], dependencies=[Depends(auth_middleware)])\nasync def get_or_create_user_route(user_data: dict=Depends(auth_middleware)):\n    user = await get_or_create_user(user_data)\n    return user.model_dump()",
        "user = await get_or_create_user(user_data)",
        "return user.model_dump()"
      ]
    },
    {
      "id": "7",
      "type": "block",
      "statements": [
        "@v1_router.get(path='/blocks', tags=['blocks'], dependencies=[Depends(auth_middleware)])\ndef get_graph_blocks() -> Sequence[dict[Any, Any]]:\n    blocks = [block() for block in backend.data.block.get_blocks().values()]\n    costs = get_block_costs()\n    return [{**b.to_dict(), 'costs': costs.get(b.id, [])} for b in blocks]",
        "blocks = [block() for block in backend.data.block.get_blocks().values()]",
        "costs = get_block_costs()",
        "return [{**b.to_dict(), 'costs': costs.get(b.id, [])} for b in blocks]"
      ]
    },
    {
      "id": "8",
      "type": "block",
      "statements": [
        "@v1_router.post(path='/blocks/{block_id}/execute', tags=['blocks'], dependencies=[Depends(auth_middleware)])\ndef execute_graph_block(block_id: str, data: BlockInput) -> CompletedBlockOutput:\n    obj = backend.data.block.get_block(block_id)\n    if not obj:\n        raise HTTPException(status_code=404, detail=f'Block #{block_id} not found.')\n    output = defaultdict(list)\n    for (name, data) in obj.execute(data):\n        output[name].append(data)\n    return output",
        "obj = backend.data.block.get_block(block_id)",
        "not obj"
      ]
    },
    {
      "id": "9",
      "type": "block",
      "statements": [
        "raise HTTPException(status_code=404, detail=f'Block #{block_id} not found.')"
      ]
    },
    {
      "id": "10",
      "type": "block",
      "statements": []
    },
    {
      "id": "11",
      "type": "block",
      "statements": [
        "output = defaultdict(list)"
      ]
    },
    {
      "id": "12",
      "type": "block",
      "statements": [
        "(name, data)",
        "obj.execute(data)"
      ]
    },
    {
      "id": "13",
      "type": "block",
      "statements": [
        "output[name].append(data)"
      ]
    },
    {
      "id": "14",
      "type": "block",
      "statements": [
        "return output"
      ]
    },
    {
      "id": "15",
      "type": "block",
      "statements": [
        "@v1_router.get(path='/credits', dependencies=[Depends(auth_middleware)])\nasync def get_user_credits(user_id: Annotated[str, Depends(get_user_id)]) -> dict[str, int]:\n    return {'credits': max(await _user_credit_model.get_or_refill_credit(user_id), 0)}",
        "return {'credits': max(await _user_credit_model.get_or_refill_credit(user_id), 0)}"
      ]
    },
    {
      "id": "16",
      "type": "block",
      "statements": [
        "class DeleteGraphResponse(TypedDict):\n    version_counts: int",
        "version_counts: int",
        "@v1_router.get(path='/graphs', tags=['graphs'], dependencies=[Depends(auth_middleware)])\nasync def get_graphs(user_id: Annotated[str, Depends(get_user_id)]) -> Sequence[graph_db.GraphModel]:\n    return await graph_db.get_graphs(filter_by='active', user_id=user_id)",
        "return await graph_db.get_graphs(filter_by='active', user_id=user_id)"
      ]
    },
    {
      "id": "17",
      "type": "block",
      "statements": [
        "@v1_router.get(path='/graphs/{graph_id}', tags=['graphs'], dependencies=[Depends(auth_middleware)])\n@v1_router.get(path='/graphs/{graph_id}/versions/{version}', tags=['graphs'], dependencies=[Depends(auth_middleware)])\nasync def get_graph(graph_id: str, user_id: Annotated[str, Depends(get_user_id)], version: int | None=None, hide_credentials: bool=False) -> graph_db.GraphModel:\n    graph = await graph_db.get_graph(graph_id, version, user_id=user_id, for_export=hide_credentials)\n    if not graph:\n        raise HTTPException(status_code=404, detail=f'Graph #{graph_id} not found.')\n    return graph",
        "graph = await graph_db.get_graph(graph_id, version, user_id=user_id, for_export=hide_credentials)",
        "not graph"
      ]
    },
    {
      "id": "18",
      "type": "block",
      "statements": [
        "raise HTTPException(status_code=404, detail=f'Graph #{graph_id} not found.')"
      ]
    },
    {
      "id": "19",
      "type": "block",
      "statements": []
    },
    {
      "id": "20",
      "type": "block",
      "statements": [
        "return graph"
      ]
    },
    {
      "id": "21",
      "type": "block",
      "statements": [
        "@v1_router.get(path='/graphs/{graph_id}/versions', tags=['graphs'], dependencies=[Depends(auth_middleware)])\n@v1_router.get(path='/templates/{graph_id}/versions', tags=['templates', 'graphs'], dependencies=[Depends(auth_middleware)])\nasync def get_graph_all_versions(graph_id: str, user_id: Annotated[str, Depends(get_user_id)]) -> Sequence[graph_db.GraphModel]:\n    graphs = await graph_db.get_graph_all_versions(graph_id, user_id=user_id)\n    if not graphs:\n        raise HTTPException(status_code=404, detail=f'Graph #{graph_id} not found.')\n    return graphs",
        "graphs = await graph_db.get_graph_all_versions(graph_id, user_id=user_id)",
        "not graphs"
      ]
    },
    {
      "id": "22",
      "type": "block",
      "statements": [
        "raise HTTPException(status_code=404, detail=f'Graph #{graph_id} not found.')"
      ]
    },
    {
      "id": "23",
      "type": "block",
      "statements": []
    },
    {
      "id": "24",
      "type": "block",
      "statements": [
        "return graphs"
      ]
    },
    {
      "id": "25",
      "type": "block",
      "statements": [
        "@v1_router.post(path='/graphs', tags=['graphs'], dependencies=[Depends(auth_middleware)])\nasync def create_new_graph(create_graph: CreateGraph, user_id: Annotated[str, Depends(get_user_id)]) -> graph_db.GraphModel:\n    return await do_create_graph(create_graph, is_template=False, user_id=user_id)",
        "return await do_create_graph(create_graph, is_template=False, user_id=user_id)"
      ]
    },
    {
      "id": "26",
      "type": "block",
      "statements": [
        "async def do_create_graph(create_graph: CreateGraph, is_template: bool, user_id: str) -> graph_db.GraphModel:\n    if create_graph.graph:\n        graph = graph_db.make_graph_model(create_graph.graph, user_id)\n    elif create_graph.template_id:\n        graph = await graph_db.get_graph(create_graph.template_id, create_graph.template_version, template=True, user_id=user_id)\n        if not graph:\n            raise HTTPException(400, detail=f'Template #{create_graph.template_id} not found')\n        graph.version = 1\n    else:\n        raise HTTPException(status_code=400, detail='Either graph or template_id must be provided.')\n    graph.is_template = is_template\n    graph.is_active = not is_template\n    graph.reassign_ids(user_id=user_id, reassign_graph_id=True)\n    graph = await graph_db.create_graph(graph, user_id=user_id)\n    graph = await on_graph_activate(graph, get_credentials=lambda id: integration_creds_manager.get(user_id, id))\n    return graph",
        "create_graph.graph"
      ]
    },
    {
      "id": "27",
      "type": "block",
      "statements": [
        "graph = graph_db.make_graph_model(create_graph.graph, user_id)"
      ]
    },
    {
      "id": "28",
      "type": "block",
      "statements": [
        "create_graph.template_id"
      ]
    },
    {
      "id": "29",
      "type": "block",
      "statements": [
        "graph.is_template = is_template",
        "graph.is_active = not is_template",
        "graph.reassign_ids()",
        "graph = await graph_db.create_graph(graph, user_id=user_id)",
        "graph = await on_graph_activate(graph, get_credentials=lambda id: integration_creds_manager.get(user_id, id))",
        "return graph"
      ]
    },
    {
      "id": "30",
      "type": "block",
      "statements": [
        "graph = await graph_db.get_graph(create_graph.template_id, create_graph.template_version, template=True, user_id=user_id)",
        "not graph"
      ]
    },
    {
      "id": "31",
      "type": "block",
      "statements": [
        "raise HTTPException(status_code=400, detail='Either graph or template_id must be provided.')"
      ]
    },
    {
      "id": "32",
      "type": "block",
      "statements": []
    },
    {
      "id": "33",
      "type": "block",
      "statements": [
        "raise HTTPException(400, detail=f'Template #{create_graph.template_id} not found')"
      ]
    },
    {
      "id": "34",
      "type": "block",
      "statements": []
    },
    {
      "id": "35",
      "type": "block",
      "statements": [
        "graph.version = 1"
      ]
    },
    {
      "id": "36",
      "type": "block",
      "statements": [
        "@v1_router.delete(path='/graphs/{graph_id}', tags=['graphs'], dependencies=[Depends(auth_middleware)])\nasync def delete_graph(graph_id: str, user_id: Annotated[str, Depends(get_user_id)]) -> DeleteGraphResponse:\n    if (active_version := (await graph_db.get_graph(graph_id, user_id=user_id))):\n\n        def get_credentials(credentials_id: str) -> 'Credentials | None':\n            return integration_creds_manager.get(user_id, credentials_id)\n        await on_graph_deactivate(active_version, get_credentials)\n    return {'version_counts': await graph_db.delete_graph(graph_id, user_id=user_id)}",
        "(active_version := (await graph_db.get_graph(graph_id, user_id=user_id)))"
      ]
    },
    {
      "id": "37",
      "type": "block",
      "statements": [
        "def get_credentials(credentials_id: str) -> 'Credentials | None':\n    return integration_creds_manager.get(user_id, credentials_id)",
        "return integration_creds_manager.get(user_id, credentials_id)"
      ]
    },
    {
      "id": "38",
      "type": "block",
      "statements": []
    },
    {
      "id": "39",
      "type": "block",
      "statements": [
        "return {'version_counts': await graph_db.delete_graph(graph_id, user_id=user_id)}"
      ]
    },
    {
      "id": "40",
      "type": "block",
      "statements": [
        "await on_graph_deactivate(active_version, get_credentials)"
      ]
    },
    {
      "id": "41",
      "type": "block",
      "statements": [
        "@v1_router.put(path='/graphs/{graph_id}', tags=['graphs'], dependencies=[Depends(auth_middleware)])\n@v1_router.put(path='/templates/{graph_id}', tags=['templates', 'graphs'], dependencies=[Depends(auth_middleware)])\nasync def update_graph(graph_id: str, graph: graph_db.Graph, user_id: Annotated[str, Depends(get_user_id)]) -> graph_db.GraphModel:\n    if graph.id and graph.id != graph_id:\n        raise HTTPException(400, detail='Graph ID does not match ID in URI')\n    existing_versions = await graph_db.get_graph_all_versions(graph_id, user_id=user_id)\n    if not existing_versions:\n        raise HTTPException(404, detail=f'Graph #{graph_id} not found')\n    latest_version_number = max((g.version for g in existing_versions))\n    graph.version = latest_version_number + 1\n    latest_version_graph = next((v for v in existing_versions if v.version == latest_version_number))\n    current_active_version = next((v for v in existing_versions if v.is_active), None)\n    if latest_version_graph.is_template != graph.is_template:\n        raise HTTPException(400, detail='Changing is_template on an existing graph is forbidden')\n    graph.is_active = not graph.is_template\n    graph = graph_db.make_graph_model(graph, user_id)\n    graph.reassign_ids(user_id=user_id)\n    new_graph_version = await graph_db.create_graph(graph, user_id=user_id)\n    if new_graph_version.is_active:\n\n        def get_credentials(credentials_id: str) -> 'Credentials | None':\n            return integration_creds_manager.get(user_id, credentials_id)\n        new_graph_version = await on_graph_activate(new_graph_version, get_credentials=get_credentials)\n        await graph_db.set_graph_active_version(graph_id=graph_id, version=new_graph_version.version, user_id=user_id)\n        if current_active_version:\n            await on_graph_deactivate(current_active_version, get_credentials=get_credentials)\n    return new_graph_version",
        "graph.id and graph.id != graph_id"
      ]
    },
    {
      "id": "42",
      "type": "block",
      "statements": [
        "raise HTTPException(400, detail='Graph ID does not match ID in URI')"
      ]
    },
    {
      "id": "43",
      "type": "block",
      "statements": []
    },
    {
      "id": "44",
      "type": "block",
      "statements": [
        "existing_versions = await graph_db.get_graph_all_versions(graph_id, user_id=user_id)",
        "not existing_versions"
      ]
    },
    {
      "id": "45",
      "type": "block",
      "statements": [
        "raise HTTPException(404, detail=f'Graph #{graph_id} not found')"
      ]
    },
    {
      "id": "46",
      "type": "block",
      "statements": []
    },
    {
      "id": "47",
      "type": "block",
      "statements": [
        "latest_version_number = max((g.version for g in existing_versions))",
        "graph.version = latest_version_number + 1",
        "latest_version_graph = next((v for v in existing_versions if v.version == latest_version_number))",
        "current_active_version = next((v for v in existing_versions if v.is_active), None)",
        "latest_version_graph.is_template NotEq graph.is_template"
      ]
    },
    {
      "id": "48",
      "type": "block",
      "statements": [
        "raise HTTPException(400, detail='Changing is_template on an existing graph is forbidden')"
      ]
    },
    {
      "id": "49",
      "type": "block",
      "statements": []
    },
    {
      "id": "50",
      "type": "block",
      "statements": [
        "graph.is_active = not graph.is_template",
        "graph = graph_db.make_graph_model(graph, user_id)",
        "graph.reassign_ids()",
        "new_graph_version = await graph_db.create_graph(graph, user_id=user_id)",
        "new_graph_version.is_active"
      ]
    },
    {
      "id": "51",
      "type": "block",
      "statements": [
        "def get_credentials(credentials_id: str) -> 'Credentials | None':\n    return integration_creds_manager.get(user_id, credentials_id)",
        "return integration_creds_manager.get(user_id, credentials_id)"
      ]
    },
    {
      "id": "52",
      "type": "block",
      "statements": []
    },
    {
      "id": "53",
      "type": "block",
      "statements": [
        "return new_graph_version"
      ]
    },
    {
      "id": "54",
      "type": "block",
      "statements": [
        "new_graph_version = await on_graph_activate(new_graph_version, get_credentials=get_credentials)",
        "await graph_db.set_graph_active_version(graph_id=graph_id, version=new_graph_version.version, user_id=user_id)",
        "current_active_version"
      ]
    },
    {
      "id": "55",
      "type": "block",
      "statements": [
        "await on_graph_deactivate(current_active_version, get_credentials=get_credentials)"
      ]
    },
    {
      "id": "56",
      "type": "block",
      "statements": []
    },
    {
      "id": "57",
      "type": "block",
      "statements": []
    },
    {
      "id": "58",
      "type": "block",
      "statements": [
        "@v1_router.put(path='/graphs/{graph_id}/versions/active', tags=['graphs'], dependencies=[Depends(auth_middleware)])\nasync def set_graph_active_version(graph_id: str, request_body: SetGraphActiveVersion, user_id: Annotated[str, Depends(get_user_id)]):\n    new_active_version = request_body.active_graph_version\n    new_active_graph = await graph_db.get_graph(graph_id, new_active_version, user_id=user_id)\n    if not new_active_graph:\n        raise HTTPException(404, f'Graph #{graph_id} v{new_active_version} not found')\n    current_active_graph = await graph_db.get_graph(graph_id, user_id=user_id)\n\n    def get_credentials(credentials_id: str) -> 'Credentials | None':\n        return integration_creds_manager.get(user_id, credentials_id)\n    await on_graph_activate(new_active_graph, get_credentials=get_credentials)\n    await graph_db.set_graph_active_version(graph_id=graph_id, version=new_active_version, user_id=user_id)\n    if current_active_graph and current_active_graph.version != new_active_version:\n        await on_graph_deactivate(current_active_graph, get_credentials=get_credentials)",
        "new_active_version = request_body.active_graph_version",
        "new_active_graph = await graph_db.get_graph(graph_id, new_active_version, user_id=user_id)",
        "not new_active_graph"
      ]
    },
    {
      "id": "59",
      "type": "block",
      "statements": [
        "raise HTTPException(404, f'Graph #{graph_id} v{new_active_version} not found')"
      ]
    },
    {
      "id": "60",
      "type": "block",
      "statements": []
    },
    {
      "id": "61",
      "type": "block",
      "statements": [
        "current_active_graph = await graph_db.get_graph(graph_id, user_id=user_id)",
        "def get_credentials(credentials_id: str) -> 'Credentials | None':\n    return integration_creds_manager.get(user_id, credentials_id)",
        "return integration_creds_manager.get(user_id, credentials_id)"
      ]
    },
    {
      "id": "62",
      "type": "block",
      "statements": [
        "await on_graph_activate(new_active_graph, get_credentials=get_credentials)",
        "await graph_db.set_graph_active_version(graph_id=graph_id, version=new_active_version, user_id=user_id)",
        "current_active_graph and current_active_graph.version != new_active_version"
      ]
    },
    {
      "id": "63",
      "type": "block",
      "statements": [
        "await on_graph_deactivate(current_active_graph, get_credentials=get_credentials)"
      ]
    },
    {
      "id": "64",
      "type": "block",
      "statements": []
    },
    {
      "id": "65",
      "type": "block",
      "statements": [
        "@v1_router.post(path='/graphs/{graph_id}/execute', tags=['graphs'], dependencies=[Depends(auth_middleware)])\ndef execute_graph(graph_id: str, node_input: dict[Any, Any], user_id: Annotated[str, Depends(get_user_id)]) -> dict[str, Any]:\n    try:\n        graph_exec = execution_manager_client().add_execution(graph_id, node_input, user_id=user_id)\n        return {'id': graph_exec.graph_exec_id}\n    except Exception as e:\n        msg = e.__str__().encode().decode('unicode_escape')\n        raise HTTPException(status_code=400, detail=msg)",
        "try:\n    graph_exec = execution_manager_client().add_execution(graph_id, node_input, user_id=user_id)\n    return {'id': graph_exec.graph_exec_id}\nexcept Exception as e:\n    msg = e.__str__().encode().decode('unicode_escape')\n    raise HTTPException(status_code=400, detail=msg)",
        "graph_exec = execution_manager_client().add_execution(graph_id, node_input, user_id=user_id)",
        "return {'id': graph_exec.graph_exec_id}"
      ]
    },
    {
      "id": "66",
      "type": "block",
      "statements": [
        "msg = e.__str__().encode().decode('unicode_escape')",
        "raise HTTPException(status_code=400, detail=msg)",
        "@v1_router.post(path='/graphs/{graph_id}/executions/{graph_exec_id}/stop', tags=['graphs'], dependencies=[Depends(auth_middleware)])\nasync def stop_graph_run(graph_exec_id: str, user_id: Annotated[str, Depends(get_user_id)]) -> Sequence[execution_db.ExecutionResult]:\n    if not await graph_db.get_execution(user_id=user_id, execution_id=graph_exec_id):\n        raise HTTPException(404, detail=f'Agent execution #{graph_exec_id} not found')\n    await asyncio.to_thread(lambda : execution_manager_client().cancel_execution(graph_exec_id))\n    return await execution_db.get_execution_results(graph_exec_id)",
        "not await graph_db.get_execution(user_id=user_id, execution_id=graph_exec_id)"
      ]
    },
    {
      "id": "67",
      "type": "block",
      "statements": [
        "raise HTTPException(404, detail=f'Agent execution #{graph_exec_id} not found')"
      ]
    },
    {
      "id": "68",
      "type": "block",
      "statements": []
    },
    {
      "id": "69",
      "type": "block",
      "statements": [
        "await asyncio.to_thread(lambda : execution_manager_client().cancel_execution(graph_exec_id))",
        "return await execution_db.get_execution_results(graph_exec_id)"
      ]
    },
    {
      "id": "70",
      "type": "block",
      "statements": [
        "@v1_router.get(path='/executions', tags=['graphs'], dependencies=[Depends(auth_middleware)])\nasync def get_executions(user_id: Annotated[str, Depends(get_user_id)]) -> list[graph_db.GraphExecution]:\n    return await graph_db.get_executions(user_id=user_id)",
        "return await graph_db.get_executions(user_id=user_id)"
      ]
    },
    {
      "id": "71",
      "type": "block",
      "statements": [
        "@v1_router.get(path='/graphs/{graph_id}/executions/{graph_exec_id}', tags=['graphs'], dependencies=[Depends(auth_middleware)])\nasync def get_graph_run_node_execution_results(graph_id: str, graph_exec_id: str, user_id: Annotated[str, Depends(get_user_id)]) -> Sequence[execution_db.ExecutionResult]:\n    graph = await graph_db.get_graph(graph_id, user_id=user_id)\n    if not graph:\n        raise HTTPException(status_code=404, detail=f'Graph #{graph_id} not found.')\n    return await execution_db.get_execution_results(graph_exec_id)",
        "graph = await graph_db.get_graph(graph_id, user_id=user_id)",
        "not graph"
      ]
    },
    {
      "id": "72",
      "type": "block",
      "statements": [
        "raise HTTPException(status_code=404, detail=f'Graph #{graph_id} not found.')"
      ]
    },
    {
      "id": "73",
      "type": "block",
      "statements": []
    },
    {
      "id": "74",
      "type": "block",
      "statements": [
        "return await execution_db.get_execution_results(graph_exec_id)"
      ]
    },
    {
      "id": "75",
      "type": "block",
      "statements": [
        "@v1_router.get(path='/templates', tags=['graphs', 'templates'], dependencies=[Depends(auth_middleware)])\nasync def get_templates(user_id: Annotated[str, Depends(get_user_id)]) -> Sequence[graph_db.GraphModel]:\n    return await graph_db.get_graphs(filter_by='template', user_id=user_id)",
        "return await graph_db.get_graphs(filter_by='template', user_id=user_id)"
      ]
    },
    {
      "id": "76",
      "type": "block",
      "statements": [
        "@v1_router.get(path='/templates/{graph_id}', tags=['templates', 'graphs'], dependencies=[Depends(auth_middleware)])\nasync def get_template(graph_id: str, version: int | None=None) -> graph_db.GraphModel:\n    graph = await graph_db.get_graph(graph_id, version, template=True)\n    if not graph:\n        raise HTTPException(status_code=404, detail=f'Template #{graph_id} not found.')\n    return graph",
        "graph = await graph_db.get_graph(graph_id, version, template=True)",
        "not graph"
      ]
    },
    {
      "id": "77",
      "type": "block",
      "statements": [
        "raise HTTPException(status_code=404, detail=f'Template #{graph_id} not found.')"
      ]
    },
    {
      "id": "78",
      "type": "block",
      "statements": []
    },
    {
      "id": "79",
      "type": "block",
      "statements": [
        "return graph"
      ]
    },
    {
      "id": "80",
      "type": "block",
      "statements": [
        "@v1_router.post(path='/templates', tags=['templates', 'graphs'], dependencies=[Depends(auth_middleware)])\nasync def create_new_template(create_graph: CreateGraph, user_id: Annotated[str, Depends(get_user_id)]) -> graph_db.GraphModel:\n    return await do_create_graph(create_graph, is_template=True, user_id=user_id)",
        "return await do_create_graph(create_graph, is_template=True, user_id=user_id)"
      ]
    },
    {
      "id": "81",
      "type": "block",
      "statements": [
        "class ScheduleCreationRequest(pydantic.BaseModel):\n    cron: str\n    input_data: dict[Any, Any]\n    graph_id: str",
        "cron: str",
        "input_data: dict[Any, Any]",
        "graph_id: str",
        "@v1_router.post(path='/schedules', tags=['schedules'], dependencies=[Depends(auth_middleware)])\nasync def create_schedule(user_id: Annotated[str, Depends(get_user_id)], schedule: ScheduleCreationRequest) -> scheduler.JobInfo:\n    graph = await graph_db.get_graph(schedule.graph_id, user_id=user_id)\n    if not graph:\n        raise HTTPException(status_code=404, detail=f'Graph #{schedule.graph_id} not found.')\n    return await asyncio.to_thread(lambda : execution_scheduler_client().add_execution_schedule(graph_id=schedule.graph_id, graph_version=graph.version, cron=schedule.cron, input_data=schedule.input_data, user_id=user_id))",
        "graph = await graph_db.get_graph(schedule.graph_id, user_id=user_id)",
        "not graph"
      ]
    },
    {
      "id": "82",
      "type": "block",
      "statements": [
        "raise HTTPException(status_code=404, detail=f'Graph #{schedule.graph_id} not found.')"
      ]
    },
    {
      "id": "83",
      "type": "block",
      "statements": []
    },
    {
      "id": "84",
      "type": "block",
      "statements": [
        "return await asyncio.to_thread(lambda : execution_scheduler_client().add_execution_schedule(graph_id=schedule.graph_id, graph_version=graph.version, cron=schedule.cron, input_data=schedule.input_data, user_id=user_id))"
      ]
    },
    {
      "id": "85",
      "type": "block",
      "statements": [
        "@v1_router.delete(path='/schedules/{schedule_id}', tags=['schedules'], dependencies=[Depends(auth_middleware)])\ndef delete_schedule(schedule_id: str, user_id: Annotated[str, Depends(get_user_id)]) -> dict[Any, Any]:\n    execution_scheduler_client().delete_schedule(schedule_id, user_id=user_id)\n    return {'id': schedule_id}",
        "execution_scheduler_client().delete_schedule(schedule_id)",
        "return {'id': schedule_id}"
      ]
    },
    {
      "id": "86",
      "type": "block",
      "statements": [
        "@v1_router.get(path='/schedules', tags=['schedules'], dependencies=[Depends(auth_middleware)])\ndef get_execution_schedules(user_id: Annotated[str, Depends(get_user_id)], graph_id: str | None=None) -> list[scheduler.JobInfo]:\n    return execution_scheduler_client().get_execution_schedules(user_id=user_id, graph_id=graph_id)",
        "return execution_scheduler_client().get_execution_schedules(user_id=user_id, graph_id=graph_id)"
      ]
    },
    {
      "id": "87",
      "type": "block",
      "statements": [
        "@v1_router.post('/api-keys', response_model=list[CreateAPIKeyResponse] | dict[str, str], tags=['api-keys'], dependencies=[Depends(auth_middleware)])\n@feature_flag('api-keys-enabled')\nasync def create_api_key(request: CreateAPIKeyRequest, user_id: Annotated[str, Depends(get_user_id)]) -> CreateAPIKeyResponse:\n    \"\"\"Create a new API key\"\"\"\n    try:\n        (api_key, plain_text) = await generate_api_key(name=request.name, user_id=user_id, permissions=request.permissions, description=request.description)\n        return CreateAPIKeyResponse(api_key=api_key, plain_text_key=plain_text)\n    except APIKeyError as e:\n        logger.error(f'Failed to create API key: {str(e)}')\n        raise HTTPException(status_code=400, detail=str(e))",
        "'Create a new API key'",
        "try:\n    (api_key, plain_text) = await generate_api_key(name=request.name, user_id=user_id, permissions=request.permissions, description=request.description)\n    return CreateAPIKeyResponse(api_key=api_key, plain_text_key=plain_text)\nexcept APIKeyError as e:\n    logger.error(f'Failed to create API key: {str(e)}')\n    raise HTTPException(status_code=400, detail=str(e))",
        "(api_key, plain_text) = await generate_api_key(name=request.name, user_id=user_id, permissions=request.permissions, description=request.description)",
        "return CreateAPIKeyResponse(api_key=api_key, plain_text_key=plain_text)"
      ]
    },
    {
      "id": "88",
      "type": "block",
      "statements": [
        "logger.error(f'Failed to create API key: {str(e)}')",
        "raise HTTPException(status_code=400, detail=str(e))",
        "@v1_router.get('/api-keys', response_model=list[APIKeyWithoutHash] | dict[str, str], tags=['api-keys'], dependencies=[Depends(auth_middleware)])\n@feature_flag('api-keys-enabled')\nasync def get_api_keys(user_id: Annotated[str, Depends(get_user_id)]) -> list[APIKeyWithoutHash]:\n    \"\"\"List all API keys for the user\"\"\"\n    try:\n        return await list_user_api_keys(user_id)\n    except APIKeyError as e:\n        logger.error(f'Failed to list API keys: {str(e)}')\n        raise HTTPException(status_code=400, detail=str(e))",
        "'List all API keys for the user'",
        "try:\n    return await list_user_api_keys(user_id)\nexcept APIKeyError as e:\n    logger.error(f'Failed to list API keys: {str(e)}')\n    raise HTTPException(status_code=400, detail=str(e))",
        "return await list_user_api_keys(user_id)"
      ]
    },
    {
      "id": "89",
      "type": "block",
      "statements": [
        "logger.error(f'Failed to list API keys: {str(e)}')",
        "raise HTTPException(status_code=400, detail=str(e))",
        "@v1_router.get('/api-keys/{key_id}', response_model=list[APIKeyWithoutHash] | dict[str, str], tags=['api-keys'], dependencies=[Depends(auth_middleware)])\n@feature_flag('api-keys-enabled')\nasync def get_api_key(key_id: str, user_id: Annotated[str, Depends(get_user_id)]) -> APIKeyWithoutHash:\n    \"\"\"Get a specific API key\"\"\"\n    try:\n        api_key = await get_api_key_by_id(key_id, user_id)\n        if not api_key:\n            raise HTTPException(status_code=404, detail='API key not found')\n        return api_key\n    except APIKeyError as e:\n        logger.error(f'Failed to get API key: {str(e)}')\n        raise HTTPException(status_code=400, detail=str(e))",
        "'Get a specific API key'",
        "try:\n    api_key = await get_api_key_by_id(key_id, user_id)\n    if not api_key:\n        raise HTTPException(status_code=404, detail='API key not found')\n    return api_key\nexcept APIKeyError as e:\n    logger.error(f'Failed to get API key: {str(e)}')\n    raise HTTPException(status_code=400, detail=str(e))",
        "api_key = await get_api_key_by_id(key_id, user_id)",
        "not api_key"
      ]
    },
    {
      "id": "90",
      "type": "block",
      "statements": [
        "raise HTTPException(status_code=404, detail='API key not found')"
      ]
    },
    {
      "id": "91",
      "type": "block",
      "statements": []
    },
    {
      "id": "92",
      "type": "block",
      "statements": [
        "return api_key"
      ]
    },
    {
      "id": "93",
      "type": "block",
      "statements": [
        "logger.error(f'Failed to get API key: {str(e)}')",
        "raise HTTPException(status_code=400, detail=str(e))",
        "@v1_router.delete('/api-keys/{key_id}', response_model=list[APIKeyWithoutHash] | dict[str, str], tags=['api-keys'], dependencies=[Depends(auth_middleware)])\n@feature_flag('api-keys-enabled')\nasync def delete_api_key(key_id: str, user_id: Annotated[str, Depends(get_user_id)]) -> Optional[APIKeyWithoutHash]:\n    \"\"\"Revoke an API key\"\"\"\n    try:\n        return await revoke_api_key(key_id, user_id)\n    except APIKeyNotFoundError:\n        raise HTTPException(status_code=404, detail='API key not found')\n    except APIKeyPermissionError:\n        raise HTTPException(status_code=403, detail='Permission denied')\n    except APIKeyError as e:\n        logger.error(f'Failed to revoke API key: {str(e)}')\n        raise HTTPException(status_code=400, detail=str(e))",
        "'Revoke an API key'",
        "try:\n    return await revoke_api_key(key_id, user_id)\nexcept APIKeyNotFoundError:\n    raise HTTPException(status_code=404, detail='API key not found')\nexcept APIKeyPermissionError:\n    raise HTTPException(status_code=403, detail='Permission denied')\nexcept APIKeyError as e:\n    logger.error(f'Failed to revoke API key: {str(e)}')\n    raise HTTPException(status_code=400, detail=str(e))",
        "return await revoke_api_key(key_id, user_id)"
      ]
    },
    {
      "id": "94",
      "type": "block",
      "statements": [
        "raise HTTPException(status_code=404, detail='API key not found')",
        "raise HTTPException(status_code=403, detail='Permission denied')",
        "logger.error(f'Failed to revoke API key: {str(e)}')",
        "raise HTTPException(status_code=400, detail=str(e))",
        "@v1_router.post('/api-keys/{key_id}/suspend', response_model=list[APIKeyWithoutHash] | dict[str, str], tags=['api-keys'], dependencies=[Depends(auth_middleware)])\n@feature_flag('api-keys-enabled')\nasync def suspend_key(key_id: str, user_id: Annotated[str, Depends(get_user_id)]) -> Optional[APIKeyWithoutHash]:\n    \"\"\"Suspend an API key\"\"\"\n    try:\n        return await suspend_api_key(key_id, user_id)\n    except APIKeyNotFoundError:\n        raise HTTPException(status_code=404, detail='API key not found')\n    except APIKeyPermissionError:\n        raise HTTPException(status_code=403, detail='Permission denied')\n    except APIKeyError as e:\n        logger.error(f'Failed to suspend API key: {str(e)}')\n        raise HTTPException(status_code=400, detail=str(e))",
        "'Suspend an API key'",
        "try:\n    return await suspend_api_key(key_id, user_id)\nexcept APIKeyNotFoundError:\n    raise HTTPException(status_code=404, detail='API key not found')\nexcept APIKeyPermissionError:\n    raise HTTPException(status_code=403, detail='Permission denied')\nexcept APIKeyError as e:\n    logger.error(f'Failed to suspend API key: {str(e)}')\n    raise HTTPException(status_code=400, detail=str(e))",
        "return await suspend_api_key(key_id, user_id)"
      ]
    },
    {
      "id": "95",
      "type": "block",
      "statements": [
        "raise HTTPException(status_code=404, detail='API key not found')",
        "raise HTTPException(status_code=403, detail='Permission denied')",
        "logger.error(f'Failed to suspend API key: {str(e)}')",
        "raise HTTPException(status_code=400, detail=str(e))",
        "@v1_router.put('/api-keys/{key_id}/permissions', response_model=list[APIKeyWithoutHash] | dict[str, str], tags=['api-keys'], dependencies=[Depends(auth_middleware)])\n@feature_flag('api-keys-enabled')\nasync def update_permissions(key_id: str, request: UpdatePermissionsRequest, user_id: Annotated[str, Depends(get_user_id)]) -> Optional[APIKeyWithoutHash]:\n    \"\"\"Update API key permissions\"\"\"\n    try:\n        return await update_api_key_permissions(key_id, user_id, request.permissions)\n    except APIKeyNotFoundError:\n        raise HTTPException(status_code=404, detail='API key not found')\n    except APIKeyPermissionError:\n        raise HTTPException(status_code=403, detail='Permission denied')\n    except APIKeyError as e:\n        logger.error(f'Failed to update API key permissions: {str(e)}')\n        raise HTTPException(status_code=400, detail=str(e))",
        "'Update API key permissions'",
        "try:\n    return await update_api_key_permissions(key_id, user_id, request.permissions)\nexcept APIKeyNotFoundError:\n    raise HTTPException(status_code=404, detail='API key not found')\nexcept APIKeyPermissionError:\n    raise HTTPException(status_code=403, detail='Permission denied')\nexcept APIKeyError as e:\n    logger.error(f'Failed to update API key permissions: {str(e)}')\n    raise HTTPException(status_code=400, detail=str(e))",
        "return await update_api_key_permissions(key_id, user_id, request.permissions)"
      ]
    },
    {
      "id": "96",
      "type": "block",
      "statements": [
        "raise HTTPException(status_code=404, detail='API key not found')",
        "raise HTTPException(status_code=403, detail='Permission denied')",
        "logger.error(f'Failed to update API key permissions: {str(e)}')",
        "raise HTTPException(status_code=400, detail=str(e))"
      ]
    }
  ],
  "edges": [
    {
      "source": "1",
      "target": "2",
      "type": "true"
    },
    {
      "source": "1",
      "target": "3",
      "type": "false"
    },
    {
      "source": "2",
      "target": "4",
      "type": "next"
    },
    {
      "source": "3",
      "target": "4",
      "type": "next"
    },
    {
      "source": "8",
      "target": "9",
      "type": "true"
    },
    {
      "source": "8",
      "target": "10",
      "type": "false"
    },
    {
      "source": "9",
      "target": "11",
      "type": "next"
    },
    {
      "source": "10",
      "target": "11",
      "type": "next"
    },
    {
      "source": "11",
      "target": "12",
      "type": "next"
    },
    {
      "source": "12",
      "target": "13",
      "type": "true"
    },
    {
      "source": "12",
      "target": "14",
      "type": "false"
    },
    {
      "source": "13",
      "target": "12",
      "type": "next"
    },
    {
      "source": "17",
      "target": "18",
      "type": "true"
    },
    {
      "source": "17",
      "target": "19",
      "type": "false"
    },
    {
      "source": "18",
      "target": "20",
      "type": "next"
    },
    {
      "source": "19",
      "target": "20",
      "type": "next"
    },
    {
      "source": "21",
      "target": "22",
      "type": "true"
    },
    {
      "source": "21",
      "target": "23",
      "type": "false"
    },
    {
      "source": "22",
      "target": "24",
      "type": "next"
    },
    {
      "source": "23",
      "target": "24",
      "type": "next"
    },
    {
      "source": "26",
      "target": "27",
      "type": "true"
    },
    {
      "source": "26",
      "target": "28",
      "type": "false"
    },
    {
      "source": "27",
      "target": "29",
      "type": "next"
    },
    {
      "source": "28",
      "target": "30",
      "type": "true"
    },
    {
      "source": "28",
      "target": "31",
      "type": "false"
    },
    {
      "source": "30",
      "target": "33",
      "type": "true"
    },
    {
      "source": "30",
      "target": "34",
      "type": "false"
    },
    {
      "source": "31",
      "target": "32",
      "type": "next"
    },
    {
      "source": "32",
      "target": "29",
      "type": "next"
    },
    {
      "source": "33",
      "target": "35",
      "type": "next"
    },
    {
      "source": "34",
      "target": "35",
      "type": "next"
    },
    {
      "source": "35",
      "target": "32",
      "type": "next"
    },
    {
      "source": "36",
      "target": "37",
      "type": "true"
    },
    {
      "source": "36",
      "target": "38",
      "type": "false"
    },
    {
      "source": "38",
      "target": "39",
      "type": "next"
    },
    {
      "source": "40",
      "target": "39",
      "type": "next"
    },
    {
      "source": "41",
      "target": "42",
      "type": "true"
    },
    {
      "source": "41",
      "target": "43",
      "type": "false"
    },
    {
      "source": "42",
      "target": "44",
      "type": "next"
    },
    {
      "source": "43",
      "target": "44",
      "type": "next"
    },
    {
      "source": "44",
      "target": "45",
      "type": "true"
    },
    {
      "source": "44",
      "target": "46",
      "type": "false"
    },
    {
      "source": "45",
      "target": "47",
      "type": "next"
    },
    {
      "source": "46",
      "target": "47",
      "type": "next"
    },
    {
      "source": "47",
      "target": "48",
      "type": "true"
    },
    {
      "source": "47",
      "target": "49",
      "type": "false"
    },
    {
      "source": "48",
      "target": "50",
      "type": "next"
    },
    {
      "source": "49",
      "target": "50",
      "type": "next"
    },
    {
      "source": "50",
      "target": "51",
      "type": "true"
    },
    {
      "source": "50",
      "target": "52",
      "type": "false"
    },
    {
      "source": "52",
      "target": "53",
      "type": "next"
    },
    {
      "source": "54",
      "target": "55",
      "type": "true"
    },
    {
      "source": "54",
      "target": "56",
      "type": "false"
    },
    {
      "source": "55",
      "target": "57",
      "type": "next"
    },
    {
      "source": "56",
      "target": "57",
      "type": "next"
    },
    {
      "source": "57",
      "target": "53",
      "type": "next"
    },
    {
      "source": "58",
      "target": "59",
      "type": "true"
    },
    {
      "source": "58",
      "target": "60",
      "type": "false"
    },
    {
      "source": "59",
      "target": "61",
      "type": "next"
    },
    {
      "source": "60",
      "target": "61",
      "type": "next"
    },
    {
      "source": "62",
      "target": "63",
      "type": "true"
    },
    {
      "source": "62",
      "target": "64",
      "type": "false"
    },
    {
      "source": "63",
      "target": "65",
      "type": "next"
    },
    {
      "source": "64",
      "target": "65",
      "type": "next"
    },
    {
      "source": "66",
      "target": "67",
      "type": "true"
    },
    {
      "source": "66",
      "target": "68",
      "type": "false"
    },
    {
      "source": "67",
      "target": "69",
      "type": "next"
    },
    {
      "source": "68",
      "target": "69",
      "type": "next"
    },
    {
      "source": "71",
      "target": "72",
      "type": "true"
    },
    {
      "source": "71",
      "target": "73",
      "type": "false"
    },
    {
      "source": "72",
      "target": "74",
      "type": "next"
    },
    {
      "source": "73",
      "target": "74",
      "type": "next"
    },
    {
      "source": "76",
      "target": "77",
      "type": "true"
    },
    {
      "source": "76",
      "target": "78",
      "type": "false"
    },
    {
      "source": "77",
      "target": "79",
      "type": "next"
    },
    {
      "source": "78",
      "target": "79",
      "type": "next"
    },
    {
      "source": "81",
      "target": "82",
      "type": "true"
    },
    {
      "source": "81",
      "target": "83",
      "type": "false"
    },
    {
      "source": "82",
      "target": "84",
      "type": "next"
    },
    {
      "source": "83",
      "target": "84",
      "type": "next"
    },
    {
      "source": "89",
      "target": "90",
      "type": "true"
    },
    {
      "source": "89",
      "target": "91",
      "type": "false"
    },
    {
      "source": "90",
      "target": "92",
      "type": "next"
    },
    {
      "source": "91",
      "target": "92",
      "type": "next"
    }
  ]
}