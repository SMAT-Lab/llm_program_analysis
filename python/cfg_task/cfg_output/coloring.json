{
  "nodes": [
    {
      "id": "1",
      "type": "block",
      "statements": [
        "'\\nGraph Coloring also called \"m coloring problem\"\\nconsists of coloring a given graph with at most m colors\\nsuch that no adjacent vertices are assigned the same color\\n\\nWikipedia: https://en.wikipedia.org/wiki/Graph_coloring\\n'",
        "def valid_coloring(neighbours: list[int], colored_vertices: list[int], color: int) -> bool:\n    \"\"\"\n    For each neighbour check if the coloring constraint is satisfied\n    If any of the neighbours fail the constraint return False\n    If all neighbours validate the constraint return True\n\n    >>> neighbours = [0,1,0,1,0]\n    >>> colored_vertices = [0, 2, 1, 2, 0]\n\n    >>> color = 1\n    >>> valid_coloring(neighbours, colored_vertices, color)\n    True\n\n    >>> color = 2\n    >>> valid_coloring(neighbours, colored_vertices, color)\n    False\n    \"\"\"\n    return not any((neighbour == 1 and colored_vertices[i] == color for (i, neighbour) in enumerate(neighbours)))",
        "'\\n    For each neighbour check if the coloring constraint is satisfied\\n    If any of the neighbours fail the constraint return False\\n    If all neighbours validate the constraint return True\\n\\n    >>> neighbours = [0,1,0,1,0]\\n    >>> colored_vertices = [0, 2, 1, 2, 0]\\n\\n    >>> color = 1\\n    >>> valid_coloring(neighbours, colored_vertices, color)\\n    True\\n\\n    >>> color = 2\\n    >>> valid_coloring(neighbours, colored_vertices, color)\\n    False\\n    '",
        "return not any((neighbour == 1 and colored_vertices[i] == color for (i, neighbour) in enumerate(neighbours)))"
      ]
    },
    {
      "id": "2",
      "type": "block",
      "statements": [
        "def util_color(graph: list[list[int]], max_colors: int, colored_vertices: list[int], index: int) -> bool:\n    \"\"\"\n    Pseudo-Code\n\n    Base Case:\n    1. Check if coloring is complete\n        1.1 If complete return True (meaning that we successfully colored the graph)\n\n    Recursive Step:\n    2. Iterates over each color:\n        Check if the current coloring is valid:\n            2.1. Color given vertex\n            2.2. Do recursive call, check if this coloring leads to a solution\n            2.4. if current coloring leads to a solution return\n            2.5. Uncolor given vertex\n\n    >>> graph = [[0, 1, 0, 0, 0],\n    ...          [1, 0, 1, 0, 1],\n    ...          [0, 1, 0, 1, 0],\n    ...          [0, 1, 1, 0, 0],\n    ...          [0, 1, 0, 0, 0]]\n    >>> max_colors = 3\n    >>> colored_vertices = [0, 1, 0, 0, 0]\n    >>> index = 3\n\n    >>> util_color(graph, max_colors, colored_vertices, index)\n    True\n\n    >>> max_colors = 2\n    >>> util_color(graph, max_colors, colored_vertices, index)\n    False\n    \"\"\"\n    if index == len(graph):\n        return True\n    for i in range(max_colors):\n        if valid_coloring(graph[index], colored_vertices, i):\n            colored_vertices[index] = i\n            if util_color(graph, max_colors, colored_vertices, index + 1):\n                return True\n            colored_vertices[index] = -1\n    return False",
        "'\\n    Pseudo-Code\\n\\n    Base Case:\\n    1. Check if coloring is complete\\n        1.1 If complete return True (meaning that we successfully colored the graph)\\n\\n    Recursive Step:\\n    2. Iterates over each color:\\n        Check if the current coloring is valid:\\n            2.1. Color given vertex\\n            2.2. Do recursive call, check if this coloring leads to a solution\\n            2.4. if current coloring leads to a solution return\\n            2.5. Uncolor given vertex\\n\\n    >>> graph = [[0, 1, 0, 0, 0],\\n    ...          [1, 0, 1, 0, 1],\\n    ...          [0, 1, 0, 1, 0],\\n    ...          [0, 1, 1, 0, 0],\\n    ...          [0, 1, 0, 0, 0]]\\n    >>> max_colors = 3\\n    >>> colored_vertices = [0, 1, 0, 0, 0]\\n    >>> index = 3\\n\\n    >>> util_color(graph, max_colors, colored_vertices, index)\\n    True\\n\\n    >>> max_colors = 2\\n    >>> util_color(graph, max_colors, colored_vertices, index)\\n    False\\n    '",
        "index Eq len(graph)"
      ]
    },
    {
      "id": "3",
      "type": "block",
      "statements": [
        "return True"
      ]
    },
    {
      "id": "4",
      "type": "block",
      "statements": []
    },
    {
      "id": "5",
      "type": "block",
      "statements": []
    },
    {
      "id": "6",
      "type": "block",
      "statements": [
        "i",
        "range(max_colors)"
      ]
    },
    {
      "id": "7",
      "type": "block",
      "statements": [
        "valid_coloring(graph[index], colored_vertices, i)"
      ]
    },
    {
      "id": "8",
      "type": "block",
      "statements": [
        "return False"
      ]
    },
    {
      "id": "9",
      "type": "block",
      "statements": [
        "colored_vertices[index] = i",
        "util_color(graph, max_colors, colored_vertices, index Add 1)"
      ]
    },
    {
      "id": "10",
      "type": "block",
      "statements": []
    },
    {
      "id": "11",
      "type": "block",
      "statements": []
    },
    {
      "id": "12",
      "type": "block",
      "statements": [
        "return True"
      ]
    },
    {
      "id": "13",
      "type": "block",
      "statements": []
    },
    {
      "id": "14",
      "type": "block",
      "statements": [
        "colored_vertices[index] = -1"
      ]
    },
    {
      "id": "15",
      "type": "block",
      "statements": [
        "def color(graph: list[list[int]], max_colors: int) -> list[int]:\n    \"\"\"\n    Wrapper function to call subroutine called util_color\n    which will either return True or False.\n    If True is returned colored_vertices list is filled with correct colorings\n\n    >>> graph = [[0, 1, 0, 0, 0],\n    ...          [1, 0, 1, 0, 1],\n    ...          [0, 1, 0, 1, 0],\n    ...          [0, 1, 1, 0, 0],\n    ...          [0, 1, 0, 0, 0]]\n\n    >>> max_colors = 3\n    >>> color(graph, max_colors)\n    [0, 1, 0, 2, 0]\n\n    >>> max_colors = 2\n    >>> color(graph, max_colors)\n    []\n    \"\"\"\n    colored_vertices = [-1] * len(graph)\n    if util_color(graph, max_colors, colored_vertices, 0):\n        return colored_vertices\n    return []",
        "'\\n    Wrapper function to call subroutine called util_color\\n    which will either return True or False.\\n    If True is returned colored_vertices list is filled with correct colorings\\n\\n    >>> graph = [[0, 1, 0, 0, 0],\\n    ...          [1, 0, 1, 0, 1],\\n    ...          [0, 1, 0, 1, 0],\\n    ...          [0, 1, 1, 0, 0],\\n    ...          [0, 1, 0, 0, 0]]\\n\\n    >>> max_colors = 3\\n    >>> color(graph, max_colors)\\n    [0, 1, 0, 2, 0]\\n\\n    >>> max_colors = 2\\n    >>> color(graph, max_colors)\\n    []\\n    '",
        "colored_vertices = [-1] * len(graph)",
        "util_color(graph, max_colors, colored_vertices, 0)"
      ]
    },
    {
      "id": "16",
      "type": "block",
      "statements": [
        "return colored_vertices"
      ]
    },
    {
      "id": "17",
      "type": "block",
      "statements": []
    },
    {
      "id": "18",
      "type": "block",
      "statements": [
        "return []"
      ]
    }
  ],
  "edges": [
    {
      "source": "2",
      "target": "3",
      "type": "true"
    },
    {
      "source": "2",
      "target": "4",
      "type": "false"
    },
    {
      "source": "4",
      "target": "5",
      "type": "next"
    },
    {
      "source": "5",
      "target": "6",
      "type": "next"
    },
    {
      "source": "6",
      "target": "7",
      "type": "true"
    },
    {
      "source": "6",
      "target": "8",
      "type": "false"
    },
    {
      "source": "7",
      "target": "9",
      "type": "true"
    },
    {
      "source": "7",
      "target": "10",
      "type": "false"
    },
    {
      "source": "9",
      "target": "12",
      "type": "true"
    },
    {
      "source": "9",
      "target": "13",
      "type": "false"
    },
    {
      "source": "10",
      "target": "11",
      "type": "next"
    },
    {
      "source": "11",
      "target": "6",
      "type": "next"
    },
    {
      "source": "13",
      "target": "14",
      "type": "next"
    },
    {
      "source": "14",
      "target": "11",
      "type": "next"
    },
    {
      "source": "15",
      "target": "16",
      "type": "true"
    },
    {
      "source": "15",
      "target": "17",
      "type": "false"
    },
    {
      "source": "17",
      "target": "18",
      "type": "next"
    }
  ]
}