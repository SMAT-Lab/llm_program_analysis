{
  "nodes": [
    {
      "id": "1",
      "type": "block",
      "statements": [
        "import asyncio",
        "import logging",
        "import uuid",
        "from collections import defaultdict",
        "from datetime import datetime, timezone",
        "from typing import Any, Literal, Optional, Type",
        "import prisma",
        "from prisma.models import AgentGraph, AgentGraphExecution, AgentNode, AgentNodeLink",
        "from prisma.types import AgentGraphWhereInput",
        "from pydantic.fields import computed_field",
        "from backend.blocks.agent import AgentExecutorBlock",
        "from backend.blocks.basic import AgentInputBlock, AgentOutputBlock",
        "from backend.util import json",
        "from .block import BlockInput, BlockType, get_block, get_blocks",
        "from .db import BaseDbModel, transaction",
        "from .execution import ExecutionStatus",
        "from .includes import AGENT_GRAPH_INCLUDE, AGENT_NODE_INCLUDE",
        "from .integrations import Webhook",
        "logger = logging.getLogger(__name__)",
        "class Link(BaseDbModel):\n    source_id: str\n    sink_id: str\n    source_name: str\n    sink_name: str\n    is_static: bool = False\n\n    @staticmethod\n    def from_db(link: AgentNodeLink):\n        return Link(id=link.id, source_name=link.sourceName, source_id=link.agentNodeSourceId, sink_name=link.sinkName, sink_id=link.agentNodeSinkId, is_static=link.isStatic)\n\n    def __hash__(self):\n        return hash((self.source_id, self.sink_id, self.source_name, self.sink_name))",
        "source_id: str",
        "sink_id: str",
        "source_name: str",
        "sink_name: str",
        "is_static: bool = False",
        "@staticmethod\ndef from_db(link: AgentNodeLink):\n    return Link(id=link.id, source_name=link.sourceName, source_id=link.agentNodeSourceId, sink_name=link.sinkName, sink_id=link.agentNodeSinkId, is_static=link.isStatic)",
        "return Link(id=link.id, source_name=link.sourceName, source_id=link.agentNodeSourceId, sink_name=link.sinkName, sink_id=link.agentNodeSinkId, is_static=link.isStatic)"
      ]
    },
    {
      "id": "2",
      "type": "block",
      "statements": [
        "def __hash__(self):\n    return hash((self.source_id, self.sink_id, self.source_name, self.sink_name))",
        "return hash((self.source_id, self.sink_id, self.source_name, self.sink_name))"
      ]
    },
    {
      "id": "3",
      "type": "block",
      "statements": [
        "class Node(BaseDbModel):\n    block_id: str\n    input_default: BlockInput = {}\n    metadata: dict[str, Any] = {}\n    input_links: list[Link] = []\n    output_links: list[Link] = []\n    webhook_id: Optional[str] = None",
        "block_id: str",
        "input_default: BlockInput = {}",
        "metadata: dict[str, Any] = {}",
        "input_links: list[Link] = []",
        "output_links: list[Link] = []",
        "webhook_id: Optional[str] = None",
        "class NodeModel(Node):\n    graph_id: str\n    graph_version: int\n    webhook: Optional[Webhook] = None\n\n    @staticmethod\n    def from_db(node: AgentNode):\n        if not node.AgentBlock:\n            raise ValueError(f'Invalid node {node.id}, invalid AgentBlock.')\n        obj = NodeModel(id=node.id, block_id=node.AgentBlock.id, input_default=json.loads(node.constantInput, target_type=dict[str, Any]), metadata=json.loads(node.metadata, target_type=dict[str, Any]), graph_id=node.agentGraphId, graph_version=node.agentGraphVersion, webhook_id=node.webhookId, webhook=Webhook.from_db(node.Webhook) if node.Webhook else None)\n        obj.input_links = [Link.from_db(link) for link in node.Input or []]\n        obj.output_links = [Link.from_db(link) for link in node.Output or []]\n        return obj\n\n    def is_triggered_by_event_type(self, event_type: str) -> bool:\n        if not (block := get_block(self.block_id)):\n            raise ValueError(f'Block #{self.block_id} not found for node #{self.id}')\n        if not block.webhook_config:\n            raise TypeError(\"This method can't be used on non-webhook blocks\")\n        if not block.webhook_config.event_filter_input:\n            return True\n        event_filter = self.input_default.get(block.webhook_config.event_filter_input)\n        if not event_filter:\n            raise ValueError(f'Event filter is not configured on node #{self.id}')\n        return event_type in [block.webhook_config.event_format.format(event=k) for k in event_filter if event_filter[k] is True]",
        "graph_id: str",
        "graph_version: int",
        "webhook: Optional[Webhook] = None",
        "@staticmethod\ndef from_db(node: AgentNode):\n    if not node.AgentBlock:\n        raise ValueError(f'Invalid node {node.id}, invalid AgentBlock.')\n    obj = NodeModel(id=node.id, block_id=node.AgentBlock.id, input_default=json.loads(node.constantInput, target_type=dict[str, Any]), metadata=json.loads(node.metadata, target_type=dict[str, Any]), graph_id=node.agentGraphId, graph_version=node.agentGraphVersion, webhook_id=node.webhookId, webhook=Webhook.from_db(node.Webhook) if node.Webhook else None)\n    obj.input_links = [Link.from_db(link) for link in node.Input or []]\n    obj.output_links = [Link.from_db(link) for link in node.Output or []]\n    return obj",
        "not node.AgentBlock"
      ]
    },
    {
      "id": "4",
      "type": "block",
      "statements": [
        "raise ValueError(f'Invalid node {node.id}, invalid AgentBlock.')"
      ]
    },
    {
      "id": "5",
      "type": "block",
      "statements": []
    },
    {
      "id": "6",
      "type": "block",
      "statements": [
        "obj = NodeModel(id=node.id, block_id=node.AgentBlock.id, input_default=json.loads(node.constantInput, target_type=dict[str, Any]), metadata=json.loads(node.metadata, target_type=dict[str, Any]), graph_id=node.agentGraphId, graph_version=node.agentGraphVersion, webhook_id=node.webhookId, webhook=Webhook.from_db(node.Webhook) if node.Webhook else None)",
        "obj.input_links = [Link.from_db(link) for link in node.Input or []]",
        "obj.output_links = [Link.from_db(link) for link in node.Output or []]",
        "return obj"
      ]
    },
    {
      "id": "7",
      "type": "block",
      "statements": [
        "def is_triggered_by_event_type(self, event_type: str) -> bool:\n    if not (block := get_block(self.block_id)):\n        raise ValueError(f'Block #{self.block_id} not found for node #{self.id}')\n    if not block.webhook_config:\n        raise TypeError(\"This method can't be used on non-webhook blocks\")\n    if not block.webhook_config.event_filter_input:\n        return True\n    event_filter = self.input_default.get(block.webhook_config.event_filter_input)\n    if not event_filter:\n        raise ValueError(f'Event filter is not configured on node #{self.id}')\n    return event_type in [block.webhook_config.event_format.format(event=k) for k in event_filter if event_filter[k] is True]",
        "not (block := get_block(self.block_id))"
      ]
    },
    {
      "id": "8",
      "type": "block",
      "statements": [
        "raise ValueError(f'Block #{self.block_id} not found for node #{self.id}')"
      ]
    },
    {
      "id": "9",
      "type": "block",
      "statements": []
    },
    {
      "id": "10",
      "type": "block",
      "statements": [
        "not block.webhook_config"
      ]
    },
    {
      "id": "11",
      "type": "block",
      "statements": [
        "raise TypeError(\"This method can't be used on non-webhook blocks\")"
      ]
    },
    {
      "id": "12",
      "type": "block",
      "statements": []
    },
    {
      "id": "13",
      "type": "block",
      "statements": [
        "not block.webhook_config.event_filter_input"
      ]
    },
    {
      "id": "14",
      "type": "block",
      "statements": [
        "return True"
      ]
    },
    {
      "id": "15",
      "type": "block",
      "statements": []
    },
    {
      "id": "16",
      "type": "block",
      "statements": [
        "event_filter = self.input_default.get(block.webhook_config.event_filter_input)",
        "not event_filter"
      ]
    },
    {
      "id": "17",
      "type": "block",
      "statements": [
        "raise ValueError(f'Event filter is not configured on node #{self.id}')"
      ]
    },
    {
      "id": "18",
      "type": "block",
      "statements": []
    },
    {
      "id": "19",
      "type": "block",
      "statements": [
        "return event_type in [block.webhook_config.event_format.format(event=k) for k in event_filter if event_filter[k] is True]"
      ]
    },
    {
      "id": "20",
      "type": "block",
      "statements": [
        "Webhook.model_rebuild()",
        "class GraphExecution(BaseDbModel):\n    execution_id: str\n    started_at: datetime\n    ended_at: datetime\n    duration: float\n    total_run_time: float\n    status: ExecutionStatus\n    graph_id: str\n    graph_version: int\n\n    @staticmethod\n    def from_db(execution: AgentGraphExecution):\n        now = datetime.now(timezone.utc)\n        start_time = execution.startedAt or execution.createdAt\n        end_time = execution.updatedAt or now\n        duration = (end_time - start_time).total_seconds()\n        total_run_time = duration\n        try:\n            stats = json.loads(execution.stats or '{}', target_type=dict[str, Any])\n        except ValueError:\n            stats = {}\n        duration = stats.get('walltime', duration)\n        total_run_time = stats.get('nodes_walltime', total_run_time)\n        return GraphExecution(id=execution.id, execution_id=execution.id, started_at=start_time, ended_at=end_time, duration=duration, total_run_time=total_run_time, status=ExecutionStatus(execution.executionStatus), graph_id=execution.agentGraphId, graph_version=execution.agentGraphVersion)",
        "execution_id: str",
        "started_at: datetime",
        "ended_at: datetime",
        "duration: float",
        "total_run_time: float",
        "status: ExecutionStatus",
        "graph_id: str",
        "graph_version: int",
        "@staticmethod\ndef from_db(execution: AgentGraphExecution):\n    now = datetime.now(timezone.utc)\n    start_time = execution.startedAt or execution.createdAt\n    end_time = execution.updatedAt or now\n    duration = (end_time - start_time).total_seconds()\n    total_run_time = duration\n    try:\n        stats = json.loads(execution.stats or '{}', target_type=dict[str, Any])\n    except ValueError:\n        stats = {}\n    duration = stats.get('walltime', duration)\n    total_run_time = stats.get('nodes_walltime', total_run_time)\n    return GraphExecution(id=execution.id, execution_id=execution.id, started_at=start_time, ended_at=end_time, duration=duration, total_run_time=total_run_time, status=ExecutionStatus(execution.executionStatus), graph_id=execution.agentGraphId, graph_version=execution.agentGraphVersion)",
        "now = datetime.now(timezone.utc)",
        "start_time = execution.startedAt or execution.createdAt",
        "end_time = execution.updatedAt or now",
        "duration = (end_time - start_time).total_seconds()",
        "total_run_time = duration",
        "try:\n    stats = json.loads(execution.stats or '{}', target_type=dict[str, Any])\nexcept ValueError:\n    stats = {}",
        "stats = json.loads(execution.stats or '{}', target_type=dict[str, Any])",
        "stats = {}",
        "duration = stats.get('walltime', duration)",
        "total_run_time = stats.get('nodes_walltime', total_run_time)",
        "return GraphExecution(id=execution.id, execution_id=execution.id, started_at=start_time, ended_at=end_time, duration=duration, total_run_time=total_run_time, status=ExecutionStatus(execution.executionStatus), graph_id=execution.agentGraphId, graph_version=execution.agentGraphVersion)"
      ]
    },
    {
      "id": "21",
      "type": "block",
      "statements": [
        "class Graph(BaseDbModel):\n    version: int = 1\n    is_active: bool = True\n    is_template: bool = False\n    name: str\n    description: str\n    nodes: list[Node] = []\n    links: list[Link] = []\n\n    @computed_field\n    @property\n    def input_schema(self) -> dict[str, Any]:\n        return self._generate_schema(AgentInputBlock.Input, [node.input_default for node in self.nodes if (b := get_block(node.block_id)) and b.block_type == BlockType.INPUT and ('name' in node.input_default)])\n\n    @computed_field\n    @property\n    def output_schema(self) -> dict[str, Any]:\n        return self._generate_schema(AgentOutputBlock.Input, [node.input_default for node in self.nodes if (b := get_block(node.block_id)) and b.block_type == BlockType.OUTPUT and ('name' in node.input_default)])\n\n    @staticmethod\n    def _generate_schema(type_class: Type[AgentInputBlock.Input] | Type[AgentOutputBlock.Input], data: list[dict]) -> dict[str, Any]:\n        props = []\n        for p in data:\n            try:\n                props.append(type_class(**p))\n            except Exception as e:\n                logger.warning(f'Invalid {type_class}: {p}, {e}')\n        return {'type': 'object', 'properties': {p.name: {'secret': p.secret, 'advanced': p.advanced, 'title': p.title or p.name, **({'description': p.description} if p.description else {}), **({'default': p.value} if p.value is not None else {})} for p in props}, 'required': [p.name for p in props if p.value is None]}",
        "version: int = 1",
        "is_active: bool = True",
        "is_template: bool = False",
        "name: str",
        "description: str",
        "nodes: list[Node] = []",
        "links: list[Link] = []",
        "@computed_field\n@property\ndef input_schema(self) -> dict[str, Any]:\n    return self._generate_schema(AgentInputBlock.Input, [node.input_default for node in self.nodes if (b := get_block(node.block_id)) and b.block_type == BlockType.INPUT and ('name' in node.input_default)])",
        "return self._generate_schema(AgentInputBlock.Input, [node.input_default for node in self.nodes if (b := get_block(node.block_id)) and b.block_type == BlockType.INPUT and ('name' in node.input_default)])"
      ]
    },
    {
      "id": "22",
      "type": "block",
      "statements": [
        "@computed_field\n@property\ndef output_schema(self) -> dict[str, Any]:\n    return self._generate_schema(AgentOutputBlock.Input, [node.input_default for node in self.nodes if (b := get_block(node.block_id)) and b.block_type == BlockType.OUTPUT and ('name' in node.input_default)])",
        "return self._generate_schema(AgentOutputBlock.Input, [node.input_default for node in self.nodes if (b := get_block(node.block_id)) and b.block_type == BlockType.OUTPUT and ('name' in node.input_default)])"
      ]
    },
    {
      "id": "23",
      "type": "block",
      "statements": [
        "@staticmethod\ndef _generate_schema(type_class: Type[AgentInputBlock.Input] | Type[AgentOutputBlock.Input], data: list[dict]) -> dict[str, Any]:\n    props = []\n    for p in data:\n        try:\n            props.append(type_class(**p))\n        except Exception as e:\n            logger.warning(f'Invalid {type_class}: {p}, {e}')\n    return {'type': 'object', 'properties': {p.name: {'secret': p.secret, 'advanced': p.advanced, 'title': p.title or p.name, **({'description': p.description} if p.description else {}), **({'default': p.value} if p.value is not None else {})} for p in props}, 'required': [p.name for p in props if p.value is None]}",
        "props = []"
      ]
    },
    {
      "id": "24",
      "type": "block",
      "statements": [
        "p",
        "data"
      ]
    },
    {
      "id": "25",
      "type": "block",
      "statements": [
        "try:\n    props.append(type_class(**p))\nexcept Exception as e:\n    logger.warning(f'Invalid {type_class}: {p}, {e}')",
        "props.append(type_class())",
        "logger.warning(f'Invalid {type_class}: {p}, {e}')"
      ]
    },
    {
      "id": "26",
      "type": "block",
      "statements": [
        "return {'type': 'object', 'properties': {p.name: {'secret': p.secret, 'advanced': p.advanced, 'title': p.title or p.name, **({'description': p.description} if p.description else {}), **({'default': p.value} if p.value is not None else {})} for p in props}, 'required': [p.name for p in props if p.value is None]}"
      ]
    },
    {
      "id": "27",
      "type": "block",
      "statements": [
        "class GraphModel(Graph):\n    user_id: str\n    nodes: list[NodeModel] = []\n\n    @property\n    def starting_nodes(self) -> list[Node]:\n        outbound_nodes = {link.sink_id for link in self.links}\n        input_nodes = {v.id for v in self.nodes if (b := get_block(v.block_id)) and b.block_type == BlockType.INPUT}\n        return [node for node in self.nodes if node.id not in outbound_nodes or node.id in input_nodes]\n\n    def reassign_ids(self, user_id: str, reassign_graph_id: bool=False):\n        \"\"\"\n        Reassigns all IDs in the graph to new UUIDs.\n        This method can be used before storing a new graph to the database.\n        \"\"\"\n        id_map = {node.id: str(uuid.uuid4()) for node in self.nodes}\n        if reassign_graph_id:\n            self.id = str(uuid.uuid4())\n        for node in self.nodes:\n            node.id = id_map[node.id]\n        for link in self.links:\n            link.source_id = id_map[link.source_id]\n            link.sink_id = id_map[link.sink_id]\n        for node in self.nodes:\n            if node.block_id != AgentExecutorBlock().id:\n                continue\n            node.input_default['user_id'] = user_id\n            node.input_default.setdefault('data', {})\n        self.validate_graph()\n\n    def validate_graph(self, for_run: bool=False):\n\n        def sanitize(name):\n            return name.split('_#_')[0].split('_@_')[0].split('_$_')[0]\n        input_links = defaultdict(list)\n        for link in self.links:\n            input_links[link.sink_id].append(link)\n        for node in self.nodes:\n            block = get_block(node.block_id)\n            if block is None:\n                raise ValueError(f'Invalid block {node.block_id} for node #{node.id}')\n            provided_inputs = set([sanitize(name) for name in node.input_default] + [sanitize(link.sink_name) for link in input_links.get(node.id, [])])\n            for name in block.input_schema.get_required_fields():\n                if name not in provided_inputs and (not (name == 'payload' and block.block_type in (BlockType.WEBHOOK, BlockType.WEBHOOK_MANUAL))) and (for_run or block.block_type == BlockType.INPUT or block.block_type == BlockType.OUTPUT or (block.block_type == BlockType.AGENT)):\n                    raise ValueError(f'Node {block.name} #{node.id} required input missing: `{name}`')\n            input_schema = block.input_schema.model_fields\n            required_fields = block.input_schema.get_required_fields()\n\n            def has_value(name):\n                return node is not None and name in node.input_default and (node.input_default[name] is not None) and (str(node.input_default[name]).strip() != '') or (name in input_schema and input_schema[name].default is not None)\n            for (field_name, field_info) in input_schema.items():\n                json_schema_extra = field_info.json_schema_extra or {}\n                dependencies = json_schema_extra.get('depends_on', [])\n                if not for_run or not dependencies:\n                    continue\n                field_has_value = has_value(field_name)\n                field_is_required = field_name in required_fields\n                missing_deps = [dep for dep in dependencies if not has_value(dep)]\n                if missing_deps and (field_has_value or field_is_required):\n                    raise ValueError(f\"Node {block.name} #{node.id}: Field `{field_name}` requires [{', '.join(missing_deps)}] to be set\")\n        node_map = {v.id: v for v in self.nodes}\n\n        def is_static_output_block(nid: str) -> bool:\n            bid = node_map[nid].block_id\n            b = get_block(bid)\n            return b.static_output if b else False\n        for link in self.links:\n            source = (link.source_id, link.source_name)\n            sink = (link.sink_id, link.sink_name)\n            suffix = f'Link {source} <-> {sink}'\n            for (i, (node_id, name)) in enumerate([source, sink]):\n                node = node_map.get(node_id)\n                if not node:\n                    raise ValueError(f'{suffix}, {node_id} is invalid node id, available nodes: {node_map.keys()}')\n                block = get_block(node.block_id)\n                if not block:\n                    blocks = {v().id: v().name for v in get_blocks().values()}\n                    raise ValueError(f'{suffix}, {node.block_id} is invalid block id, available blocks: {blocks}')\n                sanitized_name = sanitize(name)\n                vals = node.input_default\n                if i == 0:\n                    fields = block.output_schema.get_fields() if block.block_type != BlockType.AGENT else vals.get('output_schema', {}).get('properties', {}).keys()\n                else:\n                    fields = block.input_schema.get_fields() if block.block_type != BlockType.AGENT else vals.get('input_schema', {}).get('properties', {}).keys()\n                if sanitized_name not in fields:\n                    fields_msg = f'Allowed fields: {fields}'\n                    raise ValueError(f'{suffix}, `{name}` invalid, {fields_msg}')\n            if is_static_output_block(link.source_id):\n                link.is_static = True\n\n    @staticmethod\n    def from_db(graph: AgentGraph, for_export: bool=False):\n        return GraphModel(id=graph.id, user_id=graph.userId, version=graph.version, is_active=graph.isActive, is_template=graph.isTemplate, name=graph.name or '', description=graph.description or '', nodes=[NodeModel.from_db(GraphModel._process_node(node, for_export)) for node in graph.AgentNodes or []], links=list({Link.from_db(link) for node in graph.AgentNodes or [] for link in (node.Input or []) + (node.Output or [])}))\n\n    @staticmethod\n    def _process_node(node: AgentNode, for_export: bool) -> AgentNode:\n        if for_export:\n            if node.constantInput:\n                constant_input = json.loads(node.constantInput, target_type=dict[str, Any])\n                constant_input = GraphModel._hide_node_input_credentials(constant_input)\n                node.constantInput = json.dumps(constant_input)\n            node.webhookId = None\n            node.Webhook = None\n        return node\n\n    @staticmethod\n    def _hide_node_input_credentials(input_data: dict[str, Any]) -> dict[str, Any]:\n        sensitive_keys = ['credentials', 'api_key', 'password', 'token', 'secret']\n        result = {}\n        for (key, value) in input_data.items():\n            if isinstance(value, dict):\n                result[key] = GraphModel._hide_node_input_credentials(value)\n            elif isinstance(value, str) and any((sensitive_key in key.lower() for sensitive_key in sensitive_keys)):\n                continue\n            else:\n                result[key] = value\n        return result",
        "user_id: str",
        "nodes: list[NodeModel] = []",
        "@property\ndef starting_nodes(self) -> list[Node]:\n    outbound_nodes = {link.sink_id for link in self.links}\n    input_nodes = {v.id for v in self.nodes if (b := get_block(v.block_id)) and b.block_type == BlockType.INPUT}\n    return [node for node in self.nodes if node.id not in outbound_nodes or node.id in input_nodes]",
        "outbound_nodes = {link.sink_id for link in self.links}",
        "input_nodes = {v.id for v in self.nodes if (b := get_block(v.block_id)) and b.block_type == BlockType.INPUT}",
        "return [node for node in self.nodes if node.id not in outbound_nodes or node.id in input_nodes]"
      ]
    },
    {
      "id": "28",
      "type": "block",
      "statements": [
        "def reassign_ids(self, user_id: str, reassign_graph_id: bool=False):\n    \"\"\"\n        Reassigns all IDs in the graph to new UUIDs.\n        This method can be used before storing a new graph to the database.\n        \"\"\"\n    id_map = {node.id: str(uuid.uuid4()) for node in self.nodes}\n    if reassign_graph_id:\n        self.id = str(uuid.uuid4())\n    for node in self.nodes:\n        node.id = id_map[node.id]\n    for link in self.links:\n        link.source_id = id_map[link.source_id]\n        link.sink_id = id_map[link.sink_id]\n    for node in self.nodes:\n        if node.block_id != AgentExecutorBlock().id:\n            continue\n        node.input_default['user_id'] = user_id\n        node.input_default.setdefault('data', {})\n    self.validate_graph()",
        "'\\n        Reassigns all IDs in the graph to new UUIDs.\\n        This method can be used before storing a new graph to the database.\\n        '",
        "id_map = {node.id: str(uuid.uuid4()) for node in self.nodes}",
        "reassign_graph_id"
      ]
    },
    {
      "id": "29",
      "type": "block",
      "statements": [
        "self.id = str(uuid.uuid4())"
      ]
    },
    {
      "id": "30",
      "type": "block",
      "statements": []
    },
    {
      "id": "31",
      "type": "block",
      "statements": []
    },
    {
      "id": "32",
      "type": "block",
      "statements": [
        "node",
        "self.nodes"
      ]
    },
    {
      "id": "33",
      "type": "block",
      "statements": [
        "node.id = id_map[node.id]"
      ]
    },
    {
      "id": "34",
      "type": "block",
      "statements": []
    },
    {
      "id": "35",
      "type": "block",
      "statements": [
        "link",
        "self.links"
      ]
    },
    {
      "id": "36",
      "type": "block",
      "statements": [
        "link.source_id = id_map[link.source_id]",
        "link.sink_id = id_map[link.sink_id]"
      ]
    },
    {
      "id": "37",
      "type": "block",
      "statements": []
    },
    {
      "id": "38",
      "type": "block",
      "statements": [
        "node",
        "self.nodes"
      ]
    },
    {
      "id": "39",
      "type": "block",
      "statements": [
        "node.block_id NotEq AgentExecutorBlock().id"
      ]
    },
    {
      "id": "40",
      "type": "block",
      "statements": [
        "self.validate_graph()",
        "def validate_graph(self, for_run: bool=False):\n\n    def sanitize(name):\n        return name.split('_#_')[0].split('_@_')[0].split('_$_')[0]\n    input_links = defaultdict(list)\n    for link in self.links:\n        input_links[link.sink_id].append(link)\n    for node in self.nodes:\n        block = get_block(node.block_id)\n        if block is None:\n            raise ValueError(f'Invalid block {node.block_id} for node #{node.id}')\n        provided_inputs = set([sanitize(name) for name in node.input_default] + [sanitize(link.sink_name) for link in input_links.get(node.id, [])])\n        for name in block.input_schema.get_required_fields():\n            if name not in provided_inputs and (not (name == 'payload' and block.block_type in (BlockType.WEBHOOK, BlockType.WEBHOOK_MANUAL))) and (for_run or block.block_type == BlockType.INPUT or block.block_type == BlockType.OUTPUT or (block.block_type == BlockType.AGENT)):\n                raise ValueError(f'Node {block.name} #{node.id} required input missing: `{name}`')\n        input_schema = block.input_schema.model_fields\n        required_fields = block.input_schema.get_required_fields()\n\n        def has_value(name):\n            return node is not None and name in node.input_default and (node.input_default[name] is not None) and (str(node.input_default[name]).strip() != '') or (name in input_schema and input_schema[name].default is not None)\n        for (field_name, field_info) in input_schema.items():\n            json_schema_extra = field_info.json_schema_extra or {}\n            dependencies = json_schema_extra.get('depends_on', [])\n            if not for_run or not dependencies:\n                continue\n            field_has_value = has_value(field_name)\n            field_is_required = field_name in required_fields\n            missing_deps = [dep for dep in dependencies if not has_value(dep)]\n            if missing_deps and (field_has_value or field_is_required):\n                raise ValueError(f\"Node {block.name} #{node.id}: Field `{field_name}` requires [{', '.join(missing_deps)}] to be set\")\n    node_map = {v.id: v for v in self.nodes}\n\n    def is_static_output_block(nid: str) -> bool:\n        bid = node_map[nid].block_id\n        b = get_block(bid)\n        return b.static_output if b else False\n    for link in self.links:\n        source = (link.source_id, link.source_name)\n        sink = (link.sink_id, link.sink_name)\n        suffix = f'Link {source} <-> {sink}'\n        for (i, (node_id, name)) in enumerate([source, sink]):\n            node = node_map.get(node_id)\n            if not node:\n                raise ValueError(f'{suffix}, {node_id} is invalid node id, available nodes: {node_map.keys()}')\n            block = get_block(node.block_id)\n            if not block:\n                blocks = {v().id: v().name for v in get_blocks().values()}\n                raise ValueError(f'{suffix}, {node.block_id} is invalid block id, available blocks: {blocks}')\n            sanitized_name = sanitize(name)\n            vals = node.input_default\n            if i == 0:\n                fields = block.output_schema.get_fields() if block.block_type != BlockType.AGENT else vals.get('output_schema', {}).get('properties', {}).keys()\n            else:\n                fields = block.input_schema.get_fields() if block.block_type != BlockType.AGENT else vals.get('input_schema', {}).get('properties', {}).keys()\n            if sanitized_name not in fields:\n                fields_msg = f'Allowed fields: {fields}'\n                raise ValueError(f'{suffix}, `{name}` invalid, {fields_msg}')\n        if is_static_output_block(link.source_id):\n            link.is_static = True",
        "def sanitize(name):\n    return name.split('_#_')[0].split('_@_')[0].split('_$_')[0]",
        "return name.split('_#_')[0].split('_@_')[0].split('_$_')[0]"
      ]
    },
    {
      "id": "41",
      "type": "block",
      "statements": [
        "continue"
      ]
    },
    {
      "id": "42",
      "type": "block",
      "statements": []
    },
    {
      "id": "43",
      "type": "block",
      "statements": [
        "node.input_default['user_id'] = user_id",
        "node.input_default.setdefault('data', {})"
      ]
    },
    {
      "id": "44",
      "type": "block",
      "statements": [
        "input_links = defaultdict(list)"
      ]
    },
    {
      "id": "45",
      "type": "block",
      "statements": [
        "link",
        "self.links"
      ]
    },
    {
      "id": "46",
      "type": "block",
      "statements": [
        "input_links[link.sink_id].append(link)"
      ]
    },
    {
      "id": "47",
      "type": "block",
      "statements": []
    },
    {
      "id": "48",
      "type": "block",
      "statements": [
        "node",
        "self.nodes"
      ]
    },
    {
      "id": "49",
      "type": "block",
      "statements": [
        "block = get_block(node.block_id)",
        "block Is None"
      ]
    },
    {
      "id": "50",
      "type": "block",
      "statements": [
        "node_map = {v.id: v for v in self.nodes}",
        "def is_static_output_block(nid: str) -> bool:\n    bid = node_map[nid].block_id\n    b = get_block(bid)\n    return b.static_output if b else False",
        "bid = node_map[nid].block_id",
        "b = get_block(bid)",
        "return b.static_output if b else False"
      ]
    },
    {
      "id": "51",
      "type": "block",
      "statements": [
        "raise ValueError(f'Invalid block {node.block_id} for node #{node.id}')"
      ]
    },
    {
      "id": "52",
      "type": "block",
      "statements": []
    },
    {
      "id": "53",
      "type": "block",
      "statements": [
        "provided_inputs = set([sanitize(name) for name in node.input_default] + [sanitize(link.sink_name) for link in input_links.get(node.id, [])])"
      ]
    },
    {
      "id": "54",
      "type": "block",
      "statements": [
        "name",
        "block.input_schema.get_required_fields()"
      ]
    },
    {
      "id": "55",
      "type": "block",
      "statements": [
        "name not in provided_inputs and (not (name == 'payload' and block.block_type in (BlockType.WEBHOOK, BlockType.WEBHOOK_MANUAL))) and (for_run or block.block_type == BlockType.INPUT or block.block_type == BlockType.OUTPUT or (block.block_type == BlockType.AGENT))"
      ]
    },
    {
      "id": "56",
      "type": "block",
      "statements": [
        "input_schema = block.input_schema.model_fields",
        "required_fields = block.input_schema.get_required_fields()",
        "def has_value(name):\n    return node is not None and name in node.input_default and (node.input_default[name] is not None) and (str(node.input_default[name]).strip() != '') or (name in input_schema and input_schema[name].default is not None)",
        "return node is not None and name in node.input_default and (node.input_default[name] is not None) and (str(node.input_default[name]).strip() != '') or (name in input_schema and input_schema[name].default is not None)"
      ]
    },
    {
      "id": "57",
      "type": "block",
      "statements": [
        "raise ValueError(f'Node {block.name} #{node.id} required input missing: `{name}`')"
      ]
    },
    {
      "id": "58",
      "type": "block",
      "statements": []
    },
    {
      "id": "59",
      "type": "block",
      "statements": []
    },
    {
      "id": "60",
      "type": "block",
      "statements": [
        "(field_name, field_info)",
        "input_schema.items()"
      ]
    },
    {
      "id": "61",
      "type": "block",
      "statements": [
        "json_schema_extra = field_info.json_schema_extra or {}",
        "dependencies = json_schema_extra.get('depends_on', [])",
        "not for_run or not dependencies"
      ]
    },
    {
      "id": "62",
      "type": "block",
      "statements": []
    },
    {
      "id": "63",
      "type": "block",
      "statements": [
        "continue"
      ]
    },
    {
      "id": "64",
      "type": "block",
      "statements": []
    },
    {
      "id": "65",
      "type": "block",
      "statements": [
        "field_has_value = has_value(field_name)",
        "field_is_required = field_name in required_fields",
        "missing_deps = [dep for dep in dependencies if not has_value(dep)]",
        "missing_deps and (field_has_value or field_is_required)"
      ]
    },
    {
      "id": "66",
      "type": "block",
      "statements": [
        "raise ValueError(f\"Node {block.name} #{node.id}: Field `{field_name}` requires [{', '.join(missing_deps)}] to be set\")"
      ]
    },
    {
      "id": "67",
      "type": "block",
      "statements": []
    },
    {
      "id": "68",
      "type": "block",
      "statements": []
    },
    {
      "id": "69",
      "type": "block",
      "statements": [
        "link",
        "self.links"
      ]
    },
    {
      "id": "70",
      "type": "block",
      "statements": [
        "source = (link.source_id, link.source_name)",
        "sink = (link.sink_id, link.sink_name)",
        "suffix = f'Link {source} <-> {sink}'"
      ]
    },
    {
      "id": "71",
      "type": "block",
      "statements": [
        "@staticmethod\ndef from_db(graph: AgentGraph, for_export: bool=False):\n    return GraphModel(id=graph.id, user_id=graph.userId, version=graph.version, is_active=graph.isActive, is_template=graph.isTemplate, name=graph.name or '', description=graph.description or '', nodes=[NodeModel.from_db(GraphModel._process_node(node, for_export)) for node in graph.AgentNodes or []], links=list({Link.from_db(link) for node in graph.AgentNodes or [] for link in (node.Input or []) + (node.Output or [])}))",
        "return GraphModel(id=graph.id, user_id=graph.userId, version=graph.version, is_active=graph.isActive, is_template=graph.isTemplate, name=graph.name or '', description=graph.description or '', nodes=[NodeModel.from_db(GraphModel._process_node(node, for_export)) for node in graph.AgentNodes or []], links=list({Link.from_db(link) for node in graph.AgentNodes or [] for link in (node.Input or []) + (node.Output or [])}))"
      ]
    },
    {
      "id": "72",
      "type": "block",
      "statements": [
        "(i, (node_id, name))",
        "enumerate([source, sink])"
      ]
    },
    {
      "id": "73",
      "type": "block",
      "statements": [
        "node = node_map.get(node_id)",
        "not node"
      ]
    },
    {
      "id": "74",
      "type": "block",
      "statements": [
        "is_static_output_block(link.source_id)"
      ]
    },
    {
      "id": "75",
      "type": "block",
      "statements": [
        "raise ValueError(f'{suffix}, {node_id} is invalid node id, available nodes: {node_map.keys()}')"
      ]
    },
    {
      "id": "76",
      "type": "block",
      "statements": []
    },
    {
      "id": "77",
      "type": "block",
      "statements": [
        "block = get_block(node.block_id)",
        "not block"
      ]
    },
    {
      "id": "78",
      "type": "block",
      "statements": [
        "blocks = {v().id: v().name for v in get_blocks().values()}",
        "raise ValueError(f'{suffix}, {node.block_id} is invalid block id, available blocks: {blocks}')"
      ]
    },
    {
      "id": "79",
      "type": "block",
      "statements": []
    },
    {
      "id": "80",
      "type": "block",
      "statements": [
        "sanitized_name = sanitize(name)",
        "vals = node.input_default",
        "i Eq 0"
      ]
    },
    {
      "id": "81",
      "type": "block",
      "statements": [
        "fields = block.output_schema.get_fields() if block.block_type != BlockType.AGENT else vals.get('output_schema', {}).get('properties', {}).keys()"
      ]
    },
    {
      "id": "82",
      "type": "block",
      "statements": [
        "fields = block.input_schema.get_fields() if block.block_type != BlockType.AGENT else vals.get('input_schema', {}).get('properties', {}).keys()"
      ]
    },
    {
      "id": "83",
      "type": "block",
      "statements": [
        "sanitized_name NotIn fields"
      ]
    },
    {
      "id": "84",
      "type": "block",
      "statements": [
        "fields_msg = f'Allowed fields: {fields}'",
        "raise ValueError(f'{suffix}, `{name}` invalid, {fields_msg}')"
      ]
    },
    {
      "id": "85",
      "type": "block",
      "statements": []
    },
    {
      "id": "86",
      "type": "block",
      "statements": []
    },
    {
      "id": "87",
      "type": "block",
      "statements": [
        "link.is_static = True"
      ]
    },
    {
      "id": "88",
      "type": "block",
      "statements": []
    },
    {
      "id": "89",
      "type": "block",
      "statements": []
    },
    {
      "id": "90",
      "type": "block",
      "statements": [
        "@staticmethod\ndef _process_node(node: AgentNode, for_export: bool) -> AgentNode:\n    if for_export:\n        if node.constantInput:\n            constant_input = json.loads(node.constantInput, target_type=dict[str, Any])\n            constant_input = GraphModel._hide_node_input_credentials(constant_input)\n            node.constantInput = json.dumps(constant_input)\n        node.webhookId = None\n        node.Webhook = None\n    return node",
        "for_export"
      ]
    },
    {
      "id": "91",
      "type": "block",
      "statements": [
        "node.constantInput"
      ]
    },
    {
      "id": "92",
      "type": "block",
      "statements": []
    },
    {
      "id": "93",
      "type": "block",
      "statements": [
        "return node"
      ]
    },
    {
      "id": "94",
      "type": "block",
      "statements": [
        "constant_input = json.loads(node.constantInput, target_type=dict[str, Any])",
        "constant_input = GraphModel._hide_node_input_credentials(constant_input)",
        "node.constantInput = json.dumps(constant_input)"
      ]
    },
    {
      "id": "95",
      "type": "block",
      "statements": []
    },
    {
      "id": "96",
      "type": "block",
      "statements": [
        "node.webhookId = None",
        "node.Webhook = None"
      ]
    },
    {
      "id": "97",
      "type": "block",
      "statements": [
        "@staticmethod\ndef _hide_node_input_credentials(input_data: dict[str, Any]) -> dict[str, Any]:\n    sensitive_keys = ['credentials', 'api_key', 'password', 'token', 'secret']\n    result = {}\n    for (key, value) in input_data.items():\n        if isinstance(value, dict):\n            result[key] = GraphModel._hide_node_input_credentials(value)\n        elif isinstance(value, str) and any((sensitive_key in key.lower() for sensitive_key in sensitive_keys)):\n            continue\n        else:\n            result[key] = value\n    return result",
        "sensitive_keys = ['credentials', 'api_key', 'password', 'token', 'secret']",
        "result = {}"
      ]
    },
    {
      "id": "98",
      "type": "block",
      "statements": [
        "(key, value)",
        "input_data.items()"
      ]
    },
    {
      "id": "99",
      "type": "block",
      "statements": [
        "isinstance(value, dict)"
      ]
    },
    {
      "id": "100",
      "type": "block",
      "statements": [
        "return result"
      ]
    },
    {
      "id": "101",
      "type": "block",
      "statements": [
        "result[key] = GraphModel._hide_node_input_credentials(value)"
      ]
    },
    {
      "id": "102",
      "type": "block",
      "statements": [
        "isinstance(value, str) and any((sensitive_key in key.lower() for sensitive_key in sensitive_keys))"
      ]
    },
    {
      "id": "103",
      "type": "block",
      "statements": []
    },
    {
      "id": "104",
      "type": "block",
      "statements": [
        "continue"
      ]
    },
    {
      "id": "105",
      "type": "block",
      "statements": [
        "result[key] = value"
      ]
    },
    {
      "id": "106",
      "type": "block",
      "statements": []
    },
    {
      "id": "107",
      "type": "block",
      "statements": [
        "async def get_node(node_id: str) -> NodeModel:\n    node = await AgentNode.prisma().find_unique_or_raise(where={'id': node_id}, include=AGENT_NODE_INCLUDE)\n    return NodeModel.from_db(node)",
        "node = await AgentNode.prisma().find_unique_or_raise(where={'id': node_id}, include=AGENT_NODE_INCLUDE)",
        "return NodeModel.from_db(node)"
      ]
    },
    {
      "id": "108",
      "type": "block",
      "statements": [
        "async def set_node_webhook(node_id: str, webhook_id: str | None) -> NodeModel:\n    node = await AgentNode.prisma().update(where={'id': node_id}, data={'Webhook': {'connect': {'id': webhook_id}}} if webhook_id else {'Webhook': {'disconnect': True}}, include=AGENT_NODE_INCLUDE)\n    if not node:\n        raise ValueError(f'Node #{node_id} not found')\n    return NodeModel.from_db(node)",
        "node = await AgentNode.prisma().update(where={'id': node_id}, data={'Webhook': {'connect': {'id': webhook_id}}} if webhook_id else {'Webhook': {'disconnect': True}}, include=AGENT_NODE_INCLUDE)",
        "not node"
      ]
    },
    {
      "id": "109",
      "type": "block",
      "statements": [
        "raise ValueError(f'Node #{node_id} not found')"
      ]
    },
    {
      "id": "110",
      "type": "block",
      "statements": []
    },
    {
      "id": "111",
      "type": "block",
      "statements": [
        "return NodeModel.from_db(node)"
      ]
    },
    {
      "id": "112",
      "type": "block",
      "statements": [
        "async def get_graphs(user_id: str, filter_by: Literal['active', 'template'] | None='active') -> list[GraphModel]:\n    \"\"\"\n    Retrieves graph metadata objects.\n    Default behaviour is to get all currently active graphs.\n\n    Args:\n        filter_by: An optional filter to either select templates or active graphs.\n        user_id: The ID of the user that owns the graph.\n\n    Returns:\n        list[GraphModel]: A list of objects representing the retrieved graphs.\n    \"\"\"\n    where_clause: AgentGraphWhereInput = {'userId': user_id}\n    if filter_by == 'active':\n        where_clause['isActive'] = True\n    elif filter_by == 'template':\n        where_clause['isTemplate'] = True\n    graphs = await AgentGraph.prisma().find_many(where=where_clause, distinct=['id'], order={'version': 'desc'}, include=AGENT_GRAPH_INCLUDE)\n    graph_models = []\n    for graph in graphs:\n        try:\n            graph_models.append(GraphModel.from_db(graph))\n        except Exception as e:\n            logger.error(f'Error processing graph {graph.id}: {e}')\n            continue\n    return graph_models",
        "'\\n    Retrieves graph metadata objects.\\n    Default behaviour is to get all currently active graphs.\\n\\n    Args:\\n        filter_by: An optional filter to either select templates or active graphs.\\n        user_id: The ID of the user that owns the graph.\\n\\n    Returns:\\n        list[GraphModel]: A list of objects representing the retrieved graphs.\\n    '",
        "where_clause: AgentGraphWhereInput = {'userId': user_id}",
        "filter_by Eq 'active'"
      ]
    },
    {
      "id": "113",
      "type": "block",
      "statements": [
        "where_clause['isActive'] = True"
      ]
    },
    {
      "id": "114",
      "type": "block",
      "statements": [
        "filter_by Eq 'template'"
      ]
    },
    {
      "id": "115",
      "type": "block",
      "statements": [
        "graphs = await AgentGraph.prisma().find_many(where=where_clause, distinct=['id'], order={'version': 'desc'}, include=AGENT_GRAPH_INCLUDE)",
        "graph_models = []"
      ]
    },
    {
      "id": "116",
      "type": "block",
      "statements": [
        "where_clause['isTemplate'] = True"
      ]
    },
    {
      "id": "117",
      "type": "block",
      "statements": []
    },
    {
      "id": "118",
      "type": "block",
      "statements": []
    },
    {
      "id": "119",
      "type": "block",
      "statements": [
        "graph",
        "graphs"
      ]
    },
    {
      "id": "120",
      "type": "block",
      "statements": [
        "try:\n    graph_models.append(GraphModel.from_db(graph))\nexcept Exception as e:\n    logger.error(f'Error processing graph {graph.id}: {e}')\n    continue",
        "graph_models.append(GraphModel.from_db(graph))",
        "logger.error(f'Error processing graph {graph.id}: {e}')",
        "continue"
      ]
    },
    {
      "id": "121",
      "type": "block",
      "statements": [
        "return graph_models"
      ]
    },
    {
      "id": "122",
      "type": "block",
      "statements": [
        "async def get_executions(user_id: str) -> list[GraphExecution]:\n    executions = await AgentGraphExecution.prisma().find_many(where={'userId': user_id}, order={'createdAt': 'desc'})\n    return [GraphExecution.from_db(execution) for execution in executions]",
        "executions = await AgentGraphExecution.prisma().find_many(where={'userId': user_id}, order={'createdAt': 'desc'})",
        "return [GraphExecution.from_db(execution) for execution in executions]"
      ]
    },
    {
      "id": "123",
      "type": "block",
      "statements": [
        "async def get_execution(user_id: str, execution_id: str) -> GraphExecution | None:\n    execution = await AgentGraphExecution.prisma().find_first(where={'id': execution_id, 'userId': user_id})\n    return GraphExecution.from_db(execution) if execution else None",
        "execution = await AgentGraphExecution.prisma().find_first(where={'id': execution_id, 'userId': user_id})",
        "return GraphExecution.from_db(execution) if execution else None"
      ]
    },
    {
      "id": "124",
      "type": "block",
      "statements": [
        "async def get_graph(graph_id: str, version: int | None=None, template: bool=False, user_id: str | None=None, for_export: bool=False) -> GraphModel | None:\n    \"\"\"\n    Retrieves a graph from the DB.\n    Defaults to the version with `is_active` if `version` is not passed,\n    or the latest version with `is_template` if `template=True`.\n\n    Returns `None` if the record is not found.\n    \"\"\"\n    where_clause: AgentGraphWhereInput = {'id': graph_id}\n    if version is not None:\n        where_clause['version'] = version\n    elif not template:\n        where_clause['isActive'] = True\n    if user_id is not None and (not template):\n        where_clause['userId'] = user_id\n    graph = await AgentGraph.prisma().find_first(where=where_clause, include=AGENT_GRAPH_INCLUDE, order={'version': 'desc'})\n    return GraphModel.from_db(graph, for_export) if graph else None",
        "'\\n    Retrieves a graph from the DB.\\n    Defaults to the version with `is_active` if `version` is not passed,\\n    or the latest version with `is_template` if `template=True`.\\n\\n    Returns `None` if the record is not found.\\n    '",
        "where_clause: AgentGraphWhereInput = {'id': graph_id}",
        "version IsNot None"
      ]
    },
    {
      "id": "125",
      "type": "block",
      "statements": [
        "where_clause['version'] = version"
      ]
    },
    {
      "id": "126",
      "type": "block",
      "statements": [
        "not template"
      ]
    },
    {
      "id": "127",
      "type": "block",
      "statements": [
        "user_id is not None and (not template)"
      ]
    },
    {
      "id": "128",
      "type": "block",
      "statements": [
        "where_clause['isActive'] = True"
      ]
    },
    {
      "id": "129",
      "type": "block",
      "statements": []
    },
    {
      "id": "130",
      "type": "block",
      "statements": []
    },
    {
      "id": "131",
      "type": "block",
      "statements": [
        "where_clause['userId'] = user_id"
      ]
    },
    {
      "id": "132",
      "type": "block",
      "statements": []
    },
    {
      "id": "133",
      "type": "block",
      "statements": [
        "graph = await AgentGraph.prisma().find_first(where=where_clause, include=AGENT_GRAPH_INCLUDE, order={'version': 'desc'})",
        "return GraphModel.from_db(graph, for_export) if graph else None"
      ]
    },
    {
      "id": "134",
      "type": "block",
      "statements": [
        "async def set_graph_active_version(graph_id: str, version: int, user_id: str) -> None:\n    updated_count = await AgentGraph.prisma().update_many(data={'isActive': True}, where={'id': graph_id, 'version': version, 'userId': user_id})\n    if updated_count == 0:\n        raise Exception(f'Graph #{graph_id} v{version} not found or not owned by user')\n    await AgentGraph.prisma().update_many(data={'isActive': False}, where={'id': graph_id, 'version': {'not': version}, 'userId': user_id, 'isActive': True})",
        "updated_count = await AgentGraph.prisma().update_many(data={'isActive': True}, where={'id': graph_id, 'version': version, 'userId': user_id})",
        "updated_count Eq 0"
      ]
    },
    {
      "id": "135",
      "type": "block",
      "statements": [
        "raise Exception(f'Graph #{graph_id} v{version} not found or not owned by user')"
      ]
    },
    {
      "id": "136",
      "type": "block",
      "statements": []
    },
    {
      "id": "137",
      "type": "block",
      "statements": [
        "await AgentGraph.prisma().update_many(data={'isActive': False}, where={'id': graph_id, 'version': {'not': version}, 'userId': user_id, 'isActive': True})",
        "async def get_graph_all_versions(graph_id: str, user_id: str) -> list[GraphModel]:\n    graph_versions = await AgentGraph.prisma().find_many(where={'id': graph_id, 'userId': user_id}, order={'version': 'desc'}, include=AGENT_GRAPH_INCLUDE)\n    if not graph_versions:\n        return []\n    return [GraphModel.from_db(graph) for graph in graph_versions]",
        "graph_versions = await AgentGraph.prisma().find_many(where={'id': graph_id, 'userId': user_id}, order={'version': 'desc'}, include=AGENT_GRAPH_INCLUDE)",
        "not graph_versions"
      ]
    },
    {
      "id": "138",
      "type": "block",
      "statements": [
        "return []"
      ]
    },
    {
      "id": "139",
      "type": "block",
      "statements": []
    },
    {
      "id": "140",
      "type": "block",
      "statements": [
        "return [GraphModel.from_db(graph) for graph in graph_versions]"
      ]
    },
    {
      "id": "141",
      "type": "block",
      "statements": [
        "async def delete_graph(graph_id: str, user_id: str) -> int:\n    entries_count = await AgentGraph.prisma().delete_many(where={'id': graph_id, 'userId': user_id})\n    if entries_count:\n        logger.info(f'Deleted {entries_count} graph entries for Graph #{graph_id}')\n    return entries_count",
        "entries_count = await AgentGraph.prisma().delete_many(where={'id': graph_id, 'userId': user_id})",
        "entries_count"
      ]
    },
    {
      "id": "142",
      "type": "block",
      "statements": [
        "logger.info(f'Deleted {entries_count} graph entries for Graph #{graph_id}')"
      ]
    },
    {
      "id": "143",
      "type": "block",
      "statements": []
    },
    {
      "id": "144",
      "type": "block",
      "statements": [
        "return entries_count"
      ]
    },
    {
      "id": "145",
      "type": "block",
      "statements": [
        "async def create_graph(graph: Graph, user_id: str) -> GraphModel:\n    async with transaction() as tx:\n        await __create_graph(tx, graph, user_id)\n    if (created_graph := (await get_graph(graph.id, graph.version, graph.is_template, user_id=user_id))):\n        return created_graph\n    raise ValueError(f'Created graph {graph.id} v{graph.version} is not in DB')",
        "async with transaction() as tx:\n    await __create_graph(tx, graph, user_id)",
        "await __create_graph(tx, graph, user_id)",
        "(created_graph := (await get_graph(graph.id, graph.version, graph.is_template, user_id=user_id)))"
      ]
    },
    {
      "id": "146",
      "type": "block",
      "statements": [
        "return created_graph"
      ]
    },
    {
      "id": "147",
      "type": "block",
      "statements": []
    },
    {
      "id": "148",
      "type": "block",
      "statements": [
        "raise ValueError(f'Created graph {graph.id} v{graph.version} is not in DB')",
        "async def __create_graph(tx, graph: Graph, user_id: str):\n    await AgentGraph.prisma(tx).create(data={'id': graph.id, 'version': graph.version, 'name': graph.name, 'description': graph.description, 'isTemplate': graph.is_template, 'isActive': graph.is_active, 'userId': user_id})\n    await asyncio.gather(*[AgentNode.prisma(tx).create({'id': node.id, 'agentBlockId': node.block_id, 'agentGraphId': graph.id, 'agentGraphVersion': graph.version, 'constantInput': json.dumps(node.input_default), 'metadata': json.dumps(node.metadata)}) for node in graph.nodes])\n    await asyncio.gather(*[AgentNodeLink.prisma(tx).create({'id': str(uuid.uuid4()), 'sourceName': link.source_name, 'sinkName': link.sink_name, 'agentNodeSourceId': link.source_id, 'agentNodeSinkId': link.sink_id, 'isStatic': link.is_static}) for link in graph.links])",
        "await AgentGraph.prisma(tx).create(data={'id': graph.id, 'version': graph.version, 'name': graph.name, 'description': graph.description, 'isTemplate': graph.is_template, 'isActive': graph.is_active, 'userId': user_id})",
        "await asyncio.gather(*[AgentNode.prisma(tx).create({'id': node.id, 'agentBlockId': node.block_id, 'agentGraphId': graph.id, 'agentGraphVersion': graph.version, 'constantInput': json.dumps(node.input_default), 'metadata': json.dumps(node.metadata)}) for node in graph.nodes])",
        "await asyncio.gather(*[AgentNodeLink.prisma(tx).create({'id': str(uuid.uuid4()), 'sourceName': link.source_name, 'sinkName': link.sink_name, 'agentNodeSourceId': link.source_id, 'agentNodeSinkId': link.sink_id, 'isStatic': link.is_static}) for link in graph.links])",
        "def make_graph_model(creatable_graph: Graph, user_id: str) -> GraphModel:\n    \"\"\"\n    Convert a Graph to a GraphModel, setting graph_id and graph_version on all nodes.\n\n    Args:\n        creatable_graph (Graph): The creatable graph to convert.\n        user_id (str): The ID of the user creating the graph.\n\n    Returns:\n        GraphModel: The converted Graph object.\n    \"\"\"\n    return GraphModel(**creatable_graph.model_dump(exclude={'nodes'}), user_id=user_id, nodes=[NodeModel(**creatable_node.model_dump(), graph_id=creatable_graph.id, graph_version=creatable_graph.version) for creatable_node in creatable_graph.nodes])",
        "'\\n    Convert a Graph to a GraphModel, setting graph_id and graph_version on all nodes.\\n\\n    Args:\\n        creatable_graph (Graph): The creatable graph to convert.\\n        user_id (str): The ID of the user creating the graph.\\n\\n    Returns:\\n        GraphModel: The converted Graph object.\\n    '",
        "return GraphModel(**creatable_graph.model_dump(exclude={'nodes'}), user_id=user_id, nodes=[NodeModel(**creatable_node.model_dump(), graph_id=creatable_graph.id, graph_version=creatable_graph.version) for creatable_node in creatable_graph.nodes])"
      ]
    },
    {
      "id": "149",
      "type": "block",
      "statements": [
        "async def fix_llm_provider_credentials():\n    \"\"\"Fix node credentials with provider `llm`\"\"\"\n    from backend.integrations.credentials_store import IntegrationCredentialsStore\n    from .user import get_user_integrations\n    store = IntegrationCredentialsStore()\n    broken_nodes = await prisma.get_client().query_raw('\\n        SELECT    graph.\"userId\"       user_id,\\n                  node.id              node_id,\\n                  node.\"constantInput\" node_preset_input\\n        FROM      platform.\"AgentNode\"  node\\n        LEFT JOIN platform.\"AgentGraph\" graph\\n        ON        node.\"agentGraphId\" = graph.id\\n        WHERE     node.\"constantInput\"::jsonb->\\'credentials\\'->>\\'provider\\' = \\'llm\\'\\n        ORDER BY  graph.\"userId\";\\n        ')\n    logger.info(f'Fixing LLM credential inputs on {len(broken_nodes)} nodes')\n    user_id: str = ''\n    user_integrations = None\n    for node in broken_nodes:\n        if node['user_id'] != user_id:\n            user_id = node['user_id']\n            user_integrations = await get_user_integrations(user_id)\n        elif not user_integrations:\n            raise RuntimeError(f'Impossible state while processing node {node}')\n        node_id: str = node['node_id']\n        node_preset_input: dict = json.loads(node['node_preset_input'])\n        credentials_meta: dict = node_preset_input['credentials']\n        credentials = next((c for c in user_integrations.credentials if c.id == credentials_meta['id']), None)\n        if not credentials:\n            continue\n        if credentials.type != 'api_key':\n            logger.warning(f\"User {user_id} credentials {credentials.id} with provider 'llm' has invalid type '{credentials.type}'\")\n            continue\n        api_key = credentials.api_key.get_secret_value()\n        if api_key.startswith('sk-ant-api03-'):\n            credentials.provider = credentials_meta['provider'] = 'anthropic'\n        elif api_key.startswith('sk-'):\n            credentials.provider = credentials_meta['provider'] = 'openai'\n        elif api_key.startswith('gsk_'):\n            credentials.provider = credentials_meta['provider'] = 'groq'\n        else:\n            logger.warning(f'Could not identify provider from key prefix {api_key[:13]}*****')\n            continue\n        store.update_creds(user_id, credentials)\n        await AgentNode.prisma().update(where={'id': node_id}, data={'constantInput': json.dumps(node_preset_input)})",
        "'Fix node credentials with provider `llm`'",
        "from backend.integrations.credentials_store import IntegrationCredentialsStore",
        "from .user import get_user_integrations",
        "store = IntegrationCredentialsStore()",
        "broken_nodes = await prisma.get_client().query_raw('\\n        SELECT    graph.\"userId\"       user_id,\\n                  node.id              node_id,\\n                  node.\"constantInput\" node_preset_input\\n        FROM      platform.\"AgentNode\"  node\\n        LEFT JOIN platform.\"AgentGraph\" graph\\n        ON        node.\"agentGraphId\" = graph.id\\n        WHERE     node.\"constantInput\"::jsonb->\\'credentials\\'->>\\'provider\\' = \\'llm\\'\\n        ORDER BY  graph.\"userId\";\\n        ')",
        "logger.info(f'Fixing LLM credential inputs on {len(broken_nodes)} nodes')",
        "user_id: str = ''",
        "user_integrations = None"
      ]
    },
    {
      "id": "150",
      "type": "block",
      "statements": [
        "node",
        "broken_nodes"
      ]
    },
    {
      "id": "151",
      "type": "block",
      "statements": [
        "node['user_id'] NotEq user_id"
      ]
    },
    {
      "id": "152",
      "type": "block",
      "statements": []
    },
    {
      "id": "153",
      "type": "block",
      "statements": [
        "user_id = node['user_id']",
        "user_integrations = await get_user_integrations(user_id)"
      ]
    },
    {
      "id": "154",
      "type": "block",
      "statements": [
        "not user_integrations"
      ]
    },
    {
      "id": "155",
      "type": "block",
      "statements": [
        "node_id: str = node['node_id']",
        "node_preset_input: dict = json.loads(node['node_preset_input'])",
        "credentials_meta: dict = node_preset_input['credentials']",
        "credentials = next((c for c in user_integrations.credentials if c.id == credentials_meta['id']), None)",
        "not credentials"
      ]
    },
    {
      "id": "156",
      "type": "block",
      "statements": [
        "raise RuntimeError(f'Impossible state while processing node {node}')"
      ]
    },
    {
      "id": "157",
      "type": "block",
      "statements": []
    },
    {
      "id": "158",
      "type": "block",
      "statements": []
    },
    {
      "id": "159",
      "type": "block",
      "statements": [
        "continue"
      ]
    },
    {
      "id": "160",
      "type": "block",
      "statements": []
    },
    {
      "id": "161",
      "type": "block",
      "statements": [
        "credentials.type NotEq 'api_key'"
      ]
    },
    {
      "id": "162",
      "type": "block",
      "statements": [
        "logger.warning(f\"User {user_id} credentials {credentials.id} with provider 'llm' has invalid type '{credentials.type}'\")",
        "continue"
      ]
    },
    {
      "id": "163",
      "type": "block",
      "statements": []
    },
    {
      "id": "164",
      "type": "block",
      "statements": [
        "api_key = credentials.api_key.get_secret_value()",
        "api_key.startswith('sk-ant-api03-')"
      ]
    },
    {
      "id": "165",
      "type": "block",
      "statements": [
        "credentials.provider = credentials_meta['provider'] = 'anthropic'"
      ]
    },
    {
      "id": "166",
      "type": "block",
      "statements": [
        "api_key.startswith('sk-')"
      ]
    },
    {
      "id": "167",
      "type": "block",
      "statements": [
        "store.update_creds(user_id, credentials)",
        "await AgentNode.prisma().update(where={'id': node_id}, data={'constantInput': json.dumps(node_preset_input)})"
      ]
    },
    {
      "id": "168",
      "type": "block",
      "statements": [
        "credentials.provider = credentials_meta['provider'] = 'openai'"
      ]
    },
    {
      "id": "169",
      "type": "block",
      "statements": [
        "api_key.startswith('gsk_')"
      ]
    },
    {
      "id": "170",
      "type": "block",
      "statements": []
    },
    {
      "id": "171",
      "type": "block",
      "statements": [
        "credentials.provider = credentials_meta['provider'] = 'groq'"
      ]
    },
    {
      "id": "172",
      "type": "block",
      "statements": [
        "logger.warning(f'Could not identify provider from key prefix {api_key[:13]}*****')",
        "continue"
      ]
    },
    {
      "id": "173",
      "type": "block",
      "statements": []
    }
  ],
  "edges": [
    {
      "source": "3",
      "target": "4",
      "type": "true"
    },
    {
      "source": "3",
      "target": "5",
      "type": "false"
    },
    {
      "source": "4",
      "target": "6",
      "type": "next"
    },
    {
      "source": "5",
      "target": "6",
      "type": "next"
    },
    {
      "source": "7",
      "target": "8",
      "type": "true"
    },
    {
      "source": "7",
      "target": "9",
      "type": "false"
    },
    {
      "source": "8",
      "target": "10",
      "type": "next"
    },
    {
      "source": "9",
      "target": "10",
      "type": "next"
    },
    {
      "source": "10",
      "target": "11",
      "type": "true"
    },
    {
      "source": "10",
      "target": "12",
      "type": "false"
    },
    {
      "source": "11",
      "target": "13",
      "type": "next"
    },
    {
      "source": "12",
      "target": "13",
      "type": "next"
    },
    {
      "source": "13",
      "target": "14",
      "type": "true"
    },
    {
      "source": "13",
      "target": "15",
      "type": "false"
    },
    {
      "source": "15",
      "target": "16",
      "type": "next"
    },
    {
      "source": "16",
      "target": "17",
      "type": "true"
    },
    {
      "source": "16",
      "target": "18",
      "type": "false"
    },
    {
      "source": "17",
      "target": "19",
      "type": "next"
    },
    {
      "source": "18",
      "target": "19",
      "type": "next"
    },
    {
      "source": "23",
      "target": "24",
      "type": "next"
    },
    {
      "source": "24",
      "target": "25",
      "type": "true"
    },
    {
      "source": "24",
      "target": "26",
      "type": "false"
    },
    {
      "source": "25",
      "target": "24",
      "type": "next"
    },
    {
      "source": "28",
      "target": "29",
      "type": "true"
    },
    {
      "source": "28",
      "target": "30",
      "type": "false"
    },
    {
      "source": "29",
      "target": "31",
      "type": "next"
    },
    {
      "source": "30",
      "target": "31",
      "type": "next"
    },
    {
      "source": "31",
      "target": "32",
      "type": "next"
    },
    {
      "source": "32",
      "target": "33",
      "type": "true"
    },
    {
      "source": "32",
      "target": "34",
      "type": "false"
    },
    {
      "source": "33",
      "target": "32",
      "type": "next"
    },
    {
      "source": "34",
      "target": "35",
      "type": "next"
    },
    {
      "source": "35",
      "target": "36",
      "type": "true"
    },
    {
      "source": "35",
      "target": "37",
      "type": "false"
    },
    {
      "source": "36",
      "target": "35",
      "type": "next"
    },
    {
      "source": "37",
      "target": "38",
      "type": "next"
    },
    {
      "source": "38",
      "target": "39",
      "type": "true"
    },
    {
      "source": "38",
      "target": "40",
      "type": "false"
    },
    {
      "source": "39",
      "target": "41",
      "type": "true"
    },
    {
      "source": "39",
      "target": "42",
      "type": "false"
    },
    {
      "source": "41",
      "target": "43",
      "type": "next"
    },
    {
      "source": "42",
      "target": "43",
      "type": "next"
    },
    {
      "source": "43",
      "target": "38",
      "type": "next"
    },
    {
      "source": "44",
      "target": "45",
      "type": "next"
    },
    {
      "source": "45",
      "target": "46",
      "type": "true"
    },
    {
      "source": "45",
      "target": "47",
      "type": "false"
    },
    {
      "source": "46",
      "target": "45",
      "type": "next"
    },
    {
      "source": "47",
      "target": "48",
      "type": "next"
    },
    {
      "source": "48",
      "target": "49",
      "type": "true"
    },
    {
      "source": "48",
      "target": "50",
      "type": "false"
    },
    {
      "source": "49",
      "target": "51",
      "type": "true"
    },
    {
      "source": "49",
      "target": "52",
      "type": "false"
    },
    {
      "source": "51",
      "target": "53",
      "type": "next"
    },
    {
      "source": "52",
      "target": "53",
      "type": "next"
    },
    {
      "source": "53",
      "target": "54",
      "type": "next"
    },
    {
      "source": "54",
      "target": "55",
      "type": "true"
    },
    {
      "source": "54",
      "target": "56",
      "type": "false"
    },
    {
      "source": "55",
      "target": "57",
      "type": "true"
    },
    {
      "source": "55",
      "target": "58",
      "type": "false"
    },
    {
      "source": "57",
      "target": "59",
      "type": "next"
    },
    {
      "source": "58",
      "target": "59",
      "type": "next"
    },
    {
      "source": "59",
      "target": "54",
      "type": "next"
    },
    {
      "source": "60",
      "target": "61",
      "type": "true"
    },
    {
      "source": "60",
      "target": "62",
      "type": "false"
    },
    {
      "source": "61",
      "target": "63",
      "type": "true"
    },
    {
      "source": "61",
      "target": "64",
      "type": "false"
    },
    {
      "source": "62",
      "target": "48",
      "type": "next"
    },
    {
      "source": "63",
      "target": "65",
      "type": "next"
    },
    {
      "source": "64",
      "target": "65",
      "type": "next"
    },
    {
      "source": "65",
      "target": "66",
      "type": "true"
    },
    {
      "source": "65",
      "target": "67",
      "type": "false"
    },
    {
      "source": "66",
      "target": "68",
      "type": "next"
    },
    {
      "source": "67",
      "target": "68",
      "type": "next"
    },
    {
      "source": "68",
      "target": "60",
      "type": "next"
    },
    {
      "source": "69",
      "target": "70",
      "type": "true"
    },
    {
      "source": "69",
      "target": "71",
      "type": "false"
    },
    {
      "source": "70",
      "target": "72",
      "type": "next"
    },
    {
      "source": "72",
      "target": "73",
      "type": "true"
    },
    {
      "source": "72",
      "target": "74",
      "type": "false"
    },
    {
      "source": "73",
      "target": "75",
      "type": "true"
    },
    {
      "source": "73",
      "target": "76",
      "type": "false"
    },
    {
      "source": "74",
      "target": "87",
      "type": "true"
    },
    {
      "source": "74",
      "target": "88",
      "type": "false"
    },
    {
      "source": "75",
      "target": "77",
      "type": "next"
    },
    {
      "source": "76",
      "target": "77",
      "type": "next"
    },
    {
      "source": "77",
      "target": "78",
      "type": "true"
    },
    {
      "source": "77",
      "target": "79",
      "type": "false"
    },
    {
      "source": "78",
      "target": "80",
      "type": "next"
    },
    {
      "source": "79",
      "target": "80",
      "type": "next"
    },
    {
      "source": "80",
      "target": "81",
      "type": "true"
    },
    {
      "source": "80",
      "target": "82",
      "type": "false"
    },
    {
      "source": "81",
      "target": "83",
      "type": "next"
    },
    {
      "source": "82",
      "target": "83",
      "type": "next"
    },
    {
      "source": "83",
      "target": "84",
      "type": "true"
    },
    {
      "source": "83",
      "target": "85",
      "type": "false"
    },
    {
      "source": "84",
      "target": "86",
      "type": "next"
    },
    {
      "source": "85",
      "target": "86",
      "type": "next"
    },
    {
      "source": "86",
      "target": "72",
      "type": "next"
    },
    {
      "source": "87",
      "target": "89",
      "type": "next"
    },
    {
      "source": "88",
      "target": "89",
      "type": "next"
    },
    {
      "source": "89",
      "target": "69",
      "type": "next"
    },
    {
      "source": "90",
      "target": "91",
      "type": "true"
    },
    {
      "source": "90",
      "target": "92",
      "type": "false"
    },
    {
      "source": "91",
      "target": "94",
      "type": "true"
    },
    {
      "source": "91",
      "target": "95",
      "type": "false"
    },
    {
      "source": "92",
      "target": "93",
      "type": "next"
    },
    {
      "source": "94",
      "target": "96",
      "type": "next"
    },
    {
      "source": "95",
      "target": "96",
      "type": "next"
    },
    {
      "source": "96",
      "target": "93",
      "type": "next"
    },
    {
      "source": "97",
      "target": "98",
      "type": "next"
    },
    {
      "source": "98",
      "target": "99",
      "type": "true"
    },
    {
      "source": "98",
      "target": "100",
      "type": "false"
    },
    {
      "source": "99",
      "target": "101",
      "type": "true"
    },
    {
      "source": "99",
      "target": "102",
      "type": "false"
    },
    {
      "source": "101",
      "target": "103",
      "type": "next"
    },
    {
      "source": "102",
      "target": "104",
      "type": "true"
    },
    {
      "source": "102",
      "target": "105",
      "type": "false"
    },
    {
      "source": "103",
      "target": "98",
      "type": "next"
    },
    {
      "source": "104",
      "target": "106",
      "type": "next"
    },
    {
      "source": "105",
      "target": "106",
      "type": "next"
    },
    {
      "source": "106",
      "target": "103",
      "type": "next"
    },
    {
      "source": "108",
      "target": "109",
      "type": "true"
    },
    {
      "source": "108",
      "target": "110",
      "type": "false"
    },
    {
      "source": "109",
      "target": "111",
      "type": "next"
    },
    {
      "source": "110",
      "target": "111",
      "type": "next"
    },
    {
      "source": "112",
      "target": "113",
      "type": "true"
    },
    {
      "source": "112",
      "target": "114",
      "type": "false"
    },
    {
      "source": "113",
      "target": "115",
      "type": "next"
    },
    {
      "source": "114",
      "target": "116",
      "type": "true"
    },
    {
      "source": "114",
      "target": "117",
      "type": "false"
    },
    {
      "source": "115",
      "target": "119",
      "type": "next"
    },
    {
      "source": "116",
      "target": "118",
      "type": "next"
    },
    {
      "source": "117",
      "target": "118",
      "type": "next"
    },
    {
      "source": "118",
      "target": "115",
      "type": "next"
    },
    {
      "source": "119",
      "target": "120",
      "type": "true"
    },
    {
      "source": "119",
      "target": "121",
      "type": "false"
    },
    {
      "source": "120",
      "target": "119",
      "type": "next"
    },
    {
      "source": "124",
      "target": "125",
      "type": "true"
    },
    {
      "source": "124",
      "target": "126",
      "type": "false"
    },
    {
      "source": "125",
      "target": "127",
      "type": "next"
    },
    {
      "source": "126",
      "target": "128",
      "type": "true"
    },
    {
      "source": "126",
      "target": "129",
      "type": "false"
    },
    {
      "source": "127",
      "target": "131",
      "type": "true"
    },
    {
      "source": "127",
      "target": "132",
      "type": "false"
    },
    {
      "source": "128",
      "target": "130",
      "type": "next"
    },
    {
      "source": "129",
      "target": "130",
      "type": "next"
    },
    {
      "source": "130",
      "target": "127",
      "type": "next"
    },
    {
      "source": "131",
      "target": "133",
      "type": "next"
    },
    {
      "source": "132",
      "target": "133",
      "type": "next"
    },
    {
      "source": "134",
      "target": "135",
      "type": "true"
    },
    {
      "source": "134",
      "target": "136",
      "type": "false"
    },
    {
      "source": "135",
      "target": "137",
      "type": "next"
    },
    {
      "source": "136",
      "target": "137",
      "type": "next"
    },
    {
      "source": "137",
      "target": "138",
      "type": "true"
    },
    {
      "source": "137",
      "target": "139",
      "type": "false"
    },
    {
      "source": "139",
      "target": "140",
      "type": "next"
    },
    {
      "source": "141",
      "target": "142",
      "type": "true"
    },
    {
      "source": "141",
      "target": "143",
      "type": "false"
    },
    {
      "source": "142",
      "target": "144",
      "type": "next"
    },
    {
      "source": "143",
      "target": "144",
      "type": "next"
    },
    {
      "source": "145",
      "target": "146",
      "type": "true"
    },
    {
      "source": "145",
      "target": "147",
      "type": "false"
    },
    {
      "source": "147",
      "target": "148",
      "type": "next"
    },
    {
      "source": "149",
      "target": "150",
      "type": "next"
    },
    {
      "source": "150",
      "target": "151",
      "type": "true"
    },
    {
      "source": "150",
      "target": "152",
      "type": "false"
    },
    {
      "source": "151",
      "target": "153",
      "type": "true"
    },
    {
      "source": "151",
      "target": "154",
      "type": "false"
    },
    {
      "source": "153",
      "target": "155",
      "type": "next"
    },
    {
      "source": "154",
      "target": "156",
      "type": "true"
    },
    {
      "source": "154",
      "target": "157",
      "type": "false"
    },
    {
      "source": "155",
      "target": "159",
      "type": "true"
    },
    {
      "source": "155",
      "target": "160",
      "type": "false"
    },
    {
      "source": "156",
      "target": "158",
      "type": "next"
    },
    {
      "source": "157",
      "target": "158",
      "type": "next"
    },
    {
      "source": "158",
      "target": "155",
      "type": "next"
    },
    {
      "source": "159",
      "target": "161",
      "type": "next"
    },
    {
      "source": "160",
      "target": "161",
      "type": "next"
    },
    {
      "source": "161",
      "target": "162",
      "type": "true"
    },
    {
      "source": "161",
      "target": "163",
      "type": "false"
    },
    {
      "source": "162",
      "target": "164",
      "type": "next"
    },
    {
      "source": "163",
      "target": "164",
      "type": "next"
    },
    {
      "source": "164",
      "target": "165",
      "type": "true"
    },
    {
      "source": "164",
      "target": "166",
      "type": "false"
    },
    {
      "source": "165",
      "target": "167",
      "type": "next"
    },
    {
      "source": "166",
      "target": "168",
      "type": "true"
    },
    {
      "source": "166",
      "target": "169",
      "type": "false"
    },
    {
      "source": "167",
      "target": "150",
      "type": "next"
    },
    {
      "source": "168",
      "target": "170",
      "type": "next"
    },
    {
      "source": "169",
      "target": "171",
      "type": "true"
    },
    {
      "source": "169",
      "target": "172",
      "type": "false"
    },
    {
      "source": "170",
      "target": "167",
      "type": "next"
    },
    {
      "source": "171",
      "target": "173",
      "type": "next"
    },
    {
      "source": "172",
      "target": "173",
      "type": "next"
    },
    {
      "source": "173",
      "target": "170",
      "type": "next"
    }
  ]
}