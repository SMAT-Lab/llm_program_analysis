{
  "nodes": [
    {
      "id": "1",
      "type": "block",
      "statements": [
        "import logging",
        "from typing import TYPE_CHECKING, Annotated, Literal",
        "from fastapi import APIRouter, Body, Depends, HTTPException, Path, Query, Request",
        "from pydantic import BaseModel, Field, SecretStr",
        "from backend.data.graph import set_node_webhook",
        "from backend.data.integrations import WebhookEvent, get_all_webhooks_by_creds, get_webhook, publish_webhook_event, wait_for_webhook_event",
        "from backend.data.model import APIKeyCredentials, Credentials, CredentialsType, OAuth2Credentials",
        "from backend.executor.manager import ExecutionManager",
        "from backend.integrations.creds_manager import IntegrationCredentialsManager",
        "from backend.integrations.oauth import HANDLERS_BY_NAME",
        "from backend.integrations.providers import ProviderName",
        "from backend.integrations.webhooks import WEBHOOK_MANAGERS_BY_NAME",
        "from backend.util.exceptions import NeedConfirmation",
        "from backend.util.service import get_service_client",
        "from backend.util.settings import Settings",
        "TYPE_CHECKING"
      ]
    },
    {
      "id": "2",
      "type": "block",
      "statements": [
        "from backend.integrations.oauth import BaseOAuthHandler"
      ]
    },
    {
      "id": "3",
      "type": "block",
      "statements": []
    },
    {
      "id": "4",
      "type": "block",
      "statements": [
        "from ..utils import get_user_id",
        "logger = logging.getLogger(__name__)",
        "settings = Settings()",
        "router = APIRouter()",
        "creds_manager = IntegrationCredentialsManager()",
        "class LoginResponse(BaseModel):\n    login_url: str\n    state_token: str",
        "login_url: str",
        "state_token: str",
        "@router.get('/{provider}/login')\ndef login(provider: Annotated[ProviderName, Path(title='The provider to initiate an OAuth flow for')], user_id: Annotated[str, Depends(get_user_id)], request: Request, scopes: Annotated[str, Query(title='Comma-separated list of authorization scopes')]='') -> LoginResponse:\n    handler = _get_provider_oauth_handler(request, provider)\n    requested_scopes = scopes.split(',') if scopes else []\n    state_token = creds_manager.store.store_state_token(user_id, provider, requested_scopes)\n    login_url = handler.get_login_url(requested_scopes, state_token)\n    return LoginResponse(login_url=login_url, state_token=state_token)",
        "handler = _get_provider_oauth_handler(request, provider)",
        "requested_scopes = scopes.split(',') if scopes else []",
        "state_token = creds_manager.store.store_state_token(user_id, provider, requested_scopes)",
        "login_url = handler.get_login_url(requested_scopes, state_token)",
        "return LoginResponse(login_url=login_url, state_token=state_token)"
      ]
    },
    {
      "id": "5",
      "type": "block",
      "statements": [
        "class CredentialsMetaResponse(BaseModel):\n    id: str\n    provider: str\n    type: CredentialsType\n    title: str | None\n    scopes: list[str] | None\n    username: str | None",
        "id: str",
        "provider: str",
        "type: CredentialsType",
        "title: str | None",
        "scopes: list[str] | None",
        "username: str | None",
        "@router.post('/{provider}/callback')\ndef callback(provider: Annotated[ProviderName, Path(title='The target provider for this OAuth exchange')], code: Annotated[str, Body(title='Authorization code acquired by user login')], state_token: Annotated[str, Body(title='Anti-CSRF nonce')], user_id: Annotated[str, Depends(get_user_id)], request: Request) -> CredentialsMetaResponse:\n    logger.debug(f'Received OAuth callback for provider: {provider}')\n    handler = _get_provider_oauth_handler(request, provider)\n    if not creds_manager.store.verify_state_token(user_id, state_token, provider):\n        logger.warning(f'Invalid or expired state token for user {user_id}')\n        raise HTTPException(status_code=400, detail='Invalid or expired state token')\n    try:\n        scopes = creds_manager.store.get_any_valid_scopes_from_state_token(user_id, state_token, provider)\n        logger.debug(f'Retrieved scopes from state token: {scopes}')\n        scopes = handler.handle_default_scopes(scopes)\n        credentials = handler.exchange_code_for_tokens(code, scopes)\n        logger.debug(f'Received credentials with final scopes: {credentials.scopes}')\n        if not set(scopes).issubset(set(credentials.scopes)):\n            logger.warning(f'Granted scopes {credentials.scopes} for provider {provider.value} do not include all requested scopes {scopes}')\n    except Exception as e:\n        logger.error(f'Code->Token exchange failed for provider {provider.value}: {e}')\n        raise HTTPException(status_code=400, detail=f'Failed to exchange code for tokens: {str(e)}')\n    creds_manager.create(user_id, credentials)\n    logger.debug(f'Successfully processed OAuth callback for user {user_id} and provider {provider.value}')\n    return CredentialsMetaResponse(id=credentials.id, provider=credentials.provider, type=credentials.type, title=credentials.title, scopes=credentials.scopes, username=credentials.username)",
        "logger.debug(f'Received OAuth callback for provider: {provider}')",
        "handler = _get_provider_oauth_handler(request, provider)",
        "not creds_manager.store.verify_state_token(user_id, state_token, provider)"
      ]
    },
    {
      "id": "6",
      "type": "block",
      "statements": [
        "logger.warning(f'Invalid or expired state token for user {user_id}')",
        "raise HTTPException(status_code=400, detail='Invalid or expired state token')"
      ]
    },
    {
      "id": "7",
      "type": "block",
      "statements": []
    },
    {
      "id": "8",
      "type": "block",
      "statements": [
        "try:\n    scopes = creds_manager.store.get_any_valid_scopes_from_state_token(user_id, state_token, provider)\n    logger.debug(f'Retrieved scopes from state token: {scopes}')\n    scopes = handler.handle_default_scopes(scopes)\n    credentials = handler.exchange_code_for_tokens(code, scopes)\n    logger.debug(f'Received credentials with final scopes: {credentials.scopes}')\n    if not set(scopes).issubset(set(credentials.scopes)):\n        logger.warning(f'Granted scopes {credentials.scopes} for provider {provider.value} do not include all requested scopes {scopes}')\nexcept Exception as e:\n    logger.error(f'Code->Token exchange failed for provider {provider.value}: {e}')\n    raise HTTPException(status_code=400, detail=f'Failed to exchange code for tokens: {str(e)}')",
        "scopes = creds_manager.store.get_any_valid_scopes_from_state_token(user_id, state_token, provider)",
        "logger.debug(f'Retrieved scopes from state token: {scopes}')",
        "scopes = handler.handle_default_scopes(scopes)",
        "credentials = handler.exchange_code_for_tokens(code, scopes)",
        "logger.debug(f'Received credentials with final scopes: {credentials.scopes}')",
        "not set(scopes).issubset(set(credentials.scopes))"
      ]
    },
    {
      "id": "9",
      "type": "block",
      "statements": [
        "logger.warning(f'Granted scopes {credentials.scopes} for provider {provider.value} do not include all requested scopes {scopes}')"
      ]
    },
    {
      "id": "10",
      "type": "block",
      "statements": []
    },
    {
      "id": "11",
      "type": "block",
      "statements": [
        "logger.error(f'Code->Token exchange failed for provider {provider.value}: {e}')",
        "raise HTTPException(status_code=400, detail=f'Failed to exchange code for tokens: {str(e)}')",
        "creds_manager.create(user_id, credentials)",
        "logger.debug(f'Successfully processed OAuth callback for user {user_id} and provider {provider.value}')",
        "return CredentialsMetaResponse(id=credentials.id, provider=credentials.provider, type=credentials.type, title=credentials.title, scopes=credentials.scopes, username=credentials.username)"
      ]
    },
    {
      "id": "12",
      "type": "block",
      "statements": [
        "@router.get('/credentials')\ndef list_credentials(user_id: Annotated[str, Depends(get_user_id)]) -> list[CredentialsMetaResponse]:\n    credentials = creds_manager.store.get_all_creds(user_id)\n    return [CredentialsMetaResponse(id=cred.id, provider=cred.provider, type=cred.type, title=cred.title, scopes=cred.scopes if isinstance(cred, OAuth2Credentials) else None, username=cred.username if isinstance(cred, OAuth2Credentials) else None) for cred in credentials]",
        "credentials = creds_manager.store.get_all_creds(user_id)",
        "return [CredentialsMetaResponse(id=cred.id, provider=cred.provider, type=cred.type, title=cred.title, scopes=cred.scopes if isinstance(cred, OAuth2Credentials) else None, username=cred.username if isinstance(cred, OAuth2Credentials) else None) for cred in credentials]"
      ]
    },
    {
      "id": "13",
      "type": "block",
      "statements": [
        "@router.get('/{provider}/credentials')\ndef list_credentials_by_provider(provider: Annotated[ProviderName, Path(title='The provider to list credentials for')], user_id: Annotated[str, Depends(get_user_id)]) -> list[CredentialsMetaResponse]:\n    credentials = creds_manager.store.get_creds_by_provider(user_id, provider)\n    return [CredentialsMetaResponse(id=cred.id, provider=cred.provider, type=cred.type, title=cred.title, scopes=cred.scopes if isinstance(cred, OAuth2Credentials) else None, username=cred.username if isinstance(cred, OAuth2Credentials) else None) for cred in credentials]",
        "credentials = creds_manager.store.get_creds_by_provider(user_id, provider)",
        "return [CredentialsMetaResponse(id=cred.id, provider=cred.provider, type=cred.type, title=cred.title, scopes=cred.scopes if isinstance(cred, OAuth2Credentials) else None, username=cred.username if isinstance(cred, OAuth2Credentials) else None) for cred in credentials]"
      ]
    },
    {
      "id": "14",
      "type": "block",
      "statements": [
        "@router.get('/{provider}/credentials/{cred_id}')\ndef get_credential(provider: Annotated[ProviderName, Path(title='The provider to retrieve credentials for')], cred_id: Annotated[str, Path(title='The ID of the credentials to retrieve')], user_id: Annotated[str, Depends(get_user_id)]) -> Credentials:\n    credential = creds_manager.get(user_id, cred_id)\n    if not credential:\n        raise HTTPException(status_code=404, detail='Credentials not found')\n    if credential.provider != provider:\n        raise HTTPException(status_code=404, detail='Credentials do not match the specified provider')\n    return credential",
        "credential = creds_manager.get(user_id, cred_id)",
        "not credential"
      ]
    },
    {
      "id": "15",
      "type": "block",
      "statements": [
        "raise HTTPException(status_code=404, detail='Credentials not found')"
      ]
    },
    {
      "id": "16",
      "type": "block",
      "statements": []
    },
    {
      "id": "17",
      "type": "block",
      "statements": [
        "credential.provider NotEq provider"
      ]
    },
    {
      "id": "18",
      "type": "block",
      "statements": [
        "raise HTTPException(status_code=404, detail='Credentials do not match the specified provider')"
      ]
    },
    {
      "id": "19",
      "type": "block",
      "statements": []
    },
    {
      "id": "20",
      "type": "block",
      "statements": [
        "return credential"
      ]
    },
    {
      "id": "21",
      "type": "block",
      "statements": [
        "@router.post('/{provider}/credentials', status_code=201)\ndef create_api_key_credentials(user_id: Annotated[str, Depends(get_user_id)], provider: Annotated[ProviderName, Path(title='The provider to create credentials for')], api_key: Annotated[str, Body(title='The API key to store')], title: Annotated[str, Body(title='Optional title for the credentials')], expires_at: Annotated[int | None, Body(title='Unix timestamp when the key expires')]=None) -> APIKeyCredentials:\n    new_credentials = APIKeyCredentials(provider=provider, api_key=SecretStr(api_key), title=title, expires_at=expires_at)\n    try:\n        creds_manager.create(user_id, new_credentials)\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f'Failed to store credentials: {str(e)}')\n    return new_credentials",
        "new_credentials = APIKeyCredentials(provider=provider, api_key=SecretStr(api_key), title=title, expires_at=expires_at)",
        "try:\n    creds_manager.create(user_id, new_credentials)\nexcept Exception as e:\n    raise HTTPException(status_code=500, detail=f'Failed to store credentials: {str(e)}')",
        "creds_manager.create(user_id, new_credentials)",
        "raise HTTPException(status_code=500, detail=f'Failed to store credentials: {str(e)}')",
        "return new_credentials"
      ]
    },
    {
      "id": "22",
      "type": "block",
      "statements": [
        "class CredentialsDeletionResponse(BaseModel):\n    deleted: Literal[True] = True\n    revoked: bool | None = Field(description='Indicates whether the credentials were also revoked by their provider. `None`/`null` if not applicable, e.g. when deleting non-revocable credentials such as API keys.')",
        "deleted: Literal[True] = True",
        "revoked: bool | None = Field(description='Indicates whether the credentials were also revoked by their provider. `None`/`null` if not applicable, e.g. when deleting non-revocable credentials such as API keys.')",
        "class CredentialsDeletionNeedsConfirmationResponse(BaseModel):\n    deleted: Literal[False] = False\n    need_confirmation: Literal[True] = True\n    message: str",
        "deleted: Literal[False] = False",
        "need_confirmation: Literal[True] = True",
        "message: str",
        "@router.delete('/{provider}/credentials/{cred_id}')\nasync def delete_credentials(request: Request, provider: Annotated[ProviderName, Path(title='The provider to delete credentials for')], cred_id: Annotated[str, Path(title='The ID of the credentials to delete')], user_id: Annotated[str, Depends(get_user_id)], force: Annotated[bool, Query(title='Whether to proceed if any linked webhooks are still in use')]=False) -> CredentialsDeletionResponse | CredentialsDeletionNeedsConfirmationResponse:\n    creds = creds_manager.store.get_creds_by_id(user_id, cred_id)\n    if not creds:\n        raise HTTPException(status_code=404, detail='Credentials not found')\n    if creds.provider != provider:\n        raise HTTPException(status_code=404, detail='Credentials do not match the specified provider')\n    try:\n        await remove_all_webhooks_for_credentials(creds, force)\n    except NeedConfirmation as e:\n        return CredentialsDeletionNeedsConfirmationResponse(message=str(e))\n    creds_manager.delete(user_id, cred_id)\n    tokens_revoked = None\n    if isinstance(creds, OAuth2Credentials):\n        handler = _get_provider_oauth_handler(request, provider)\n        tokens_revoked = handler.revoke_tokens(creds)\n    return CredentialsDeletionResponse(revoked=tokens_revoked)",
        "creds = creds_manager.store.get_creds_by_id(user_id, cred_id)",
        "not creds"
      ]
    },
    {
      "id": "23",
      "type": "block",
      "statements": [
        "raise HTTPException(status_code=404, detail='Credentials not found')"
      ]
    },
    {
      "id": "24",
      "type": "block",
      "statements": []
    },
    {
      "id": "25",
      "type": "block",
      "statements": [
        "creds.provider NotEq provider"
      ]
    },
    {
      "id": "26",
      "type": "block",
      "statements": [
        "raise HTTPException(status_code=404, detail='Credentials do not match the specified provider')"
      ]
    },
    {
      "id": "27",
      "type": "block",
      "statements": []
    },
    {
      "id": "28",
      "type": "block",
      "statements": [
        "try:\n    await remove_all_webhooks_for_credentials(creds, force)\nexcept NeedConfirmation as e:\n    return CredentialsDeletionNeedsConfirmationResponse(message=str(e))",
        "await remove_all_webhooks_for_credentials(creds, force)",
        "return CredentialsDeletionNeedsConfirmationResponse(message=str(e))"
      ]
    },
    {
      "id": "29",
      "type": "block",
      "statements": [
        "creds_manager.delete(user_id, cred_id)",
        "tokens_revoked = None",
        "isinstance(creds, OAuth2Credentials)"
      ]
    },
    {
      "id": "30",
      "type": "block",
      "statements": [
        "handler = _get_provider_oauth_handler(request, provider)",
        "tokens_revoked = handler.revoke_tokens(creds)"
      ]
    },
    {
      "id": "31",
      "type": "block",
      "statements": []
    },
    {
      "id": "32",
      "type": "block",
      "statements": [
        "return CredentialsDeletionResponse(revoked=tokens_revoked)"
      ]
    },
    {
      "id": "33",
      "type": "block",
      "statements": [
        "@router.post('/{provider}/webhooks/{webhook_id}/ingress')\nasync def webhook_ingress_generic(request: Request, provider: Annotated[ProviderName, Path(title='Provider where the webhook was registered')], webhook_id: Annotated[str, Path(title='Our ID for the webhook')]):\n    logger.debug(f'Received {provider.value} webhook ingress for ID {webhook_id}')\n    webhook_manager = WEBHOOK_MANAGERS_BY_NAME[provider]()\n    webhook = await get_webhook(webhook_id)\n    logger.debug(f'Webhook #{webhook_id}: {webhook}')\n    (payload, event_type) = await webhook_manager.validate_payload(webhook, request)\n    logger.debug(f'Validated {provider.value} {webhook.webhook_type} {event_type} event with payload {payload}')\n    webhook_event = WebhookEvent(provider=provider, webhook_id=webhook_id, event_type=event_type, payload=payload)\n    await publish_webhook_event(webhook_event)\n    logger.debug(f'Webhook event published: {webhook_event}')\n    if not webhook.attached_nodes:\n        return\n    executor = get_service_client(ExecutionManager)\n    for node in webhook.attached_nodes:\n        logger.debug(f'Webhook-attached node: {node}')\n        if not node.is_triggered_by_event_type(event_type):\n            logger.debug(f\"Node #{node.id} doesn't trigger on event {event_type}\")\n            continue\n        logger.debug(f'Executing graph #{node.graph_id} node #{node.id}')\n        executor.add_execution(node.graph_id, data={f'webhook_{webhook_id}_payload': payload}, user_id=webhook.user_id)",
        "logger.debug(f'Received {provider.value} webhook ingress for ID {webhook_id}')",
        "webhook_manager = WEBHOOK_MANAGERS_BY_NAME[provider]()",
        "webhook = await get_webhook(webhook_id)",
        "logger.debug(f'Webhook #{webhook_id}: {webhook}')",
        "(payload, event_type) = await webhook_manager.validate_payload(webhook, request)",
        "logger.debug(f'Validated {provider.value} {webhook.webhook_type} {event_type} event with payload {payload}')",
        "webhook_event = WebhookEvent(provider=provider, webhook_id=webhook_id, event_type=event_type, payload=payload)",
        "await publish_webhook_event(webhook_event)",
        "logger.debug(f'Webhook event published: {webhook_event}')",
        "not webhook.attached_nodes"
      ]
    },
    {
      "id": "34",
      "type": "block",
      "statements": [
        "return"
      ]
    },
    {
      "id": "35",
      "type": "block",
      "statements": []
    },
    {
      "id": "36",
      "type": "block",
      "statements": [
        "executor = get_service_client(ExecutionManager)"
      ]
    },
    {
      "id": "37",
      "type": "block",
      "statements": [
        "node",
        "webhook.attached_nodes"
      ]
    },
    {
      "id": "38",
      "type": "block",
      "statements": [
        "logger.debug(f'Webhook-attached node: {node}')",
        "not node.is_triggered_by_event_type(event_type)"
      ]
    },
    {
      "id": "39",
      "type": "block",
      "statements": [
        "@router.post('/webhooks/{webhook_id}/ping')\nasync def webhook_ping(webhook_id: Annotated[str, Path(title='Our ID for the webhook')], user_id: Annotated[str, Depends(get_user_id)]):\n    webhook = await get_webhook(webhook_id)\n    webhook_manager = WEBHOOK_MANAGERS_BY_NAME[webhook.provider]()\n    credentials = creds_manager.get(user_id, webhook.credentials_id) if webhook.credentials_id else None\n    try:\n        await webhook_manager.trigger_ping(webhook, credentials)\n    except NotImplementedError:\n        return False\n    if not await wait_for_webhook_event(webhook_id, event_type='ping', timeout=10):\n        raise HTTPException(status_code=504, detail='Webhook ping timed out')\n    return True",
        "webhook = await get_webhook(webhook_id)",
        "webhook_manager = WEBHOOK_MANAGERS_BY_NAME[webhook.provider]()",
        "credentials = creds_manager.get(user_id, webhook.credentials_id) if webhook.credentials_id else None",
        "try:\n    await webhook_manager.trigger_ping(webhook, credentials)\nexcept NotImplementedError:\n    return False",
        "await webhook_manager.trigger_ping(webhook, credentials)",
        "return False"
      ]
    },
    {
      "id": "40",
      "type": "block",
      "statements": [
        "logger.debug(f\"Node #{node.id} doesn't trigger on event {event_type}\")",
        "continue"
      ]
    },
    {
      "id": "41",
      "type": "block",
      "statements": []
    },
    {
      "id": "42",
      "type": "block",
      "statements": [
        "logger.debug(f'Executing graph #{node.graph_id} node #{node.id}')",
        "executor.add_execution(node.graph_id)"
      ]
    },
    {
      "id": "43",
      "type": "block",
      "statements": [
        "not await wait_for_webhook_event(webhook_id, event_type='ping', timeout=10)"
      ]
    },
    {
      "id": "44",
      "type": "block",
      "statements": [
        "raise HTTPException(status_code=504, detail='Webhook ping timed out')"
      ]
    },
    {
      "id": "45",
      "type": "block",
      "statements": []
    },
    {
      "id": "46",
      "type": "block",
      "statements": [
        "return True"
      ]
    },
    {
      "id": "47",
      "type": "block",
      "statements": [
        "async def remove_all_webhooks_for_credentials(credentials: Credentials, force: bool=False) -> None:\n    \"\"\"\n    Remove and deregister all webhooks that were registered using the given credentials.\n\n    Params:\n        credentials: The credentials for which to remove the associated webhooks.\n        force: Whether to proceed if any of the webhooks are still in use.\n\n    Raises:\n        NeedConfirmation: If any of the webhooks are still in use and `force` is `False`\n    \"\"\"\n    webhooks = await get_all_webhooks_by_creds(credentials.id)\n    if credentials.provider not in WEBHOOK_MANAGERS_BY_NAME:\n        if webhooks:\n            logger.error(f'Credentials #{credentials.id} for provider {credentials.provider} are attached to {len(webhooks)} webhooks, but there is no available WebhooksHandler for {credentials.provider}')\n        return\n    if any((w.attached_nodes for w in webhooks)) and (not force):\n        raise NeedConfirmation('Some webhooks linked to these credentials are still in use by an agent')\n    for webhook in webhooks:\n        for node in webhook.attached_nodes or []:\n            await set_node_webhook(node.id, None)\n        webhook_manager = WEBHOOK_MANAGERS_BY_NAME[credentials.provider]()\n        success = await webhook_manager.prune_webhook_if_dangling(webhook.id, credentials)\n        if not success:\n            logger.warning(f'Webhook #{webhook.id} failed to prune')",
        "'\\n    Remove and deregister all webhooks that were registered using the given credentials.\\n\\n    Params:\\n        credentials: The credentials for which to remove the associated webhooks.\\n        force: Whether to proceed if any of the webhooks are still in use.\\n\\n    Raises:\\n        NeedConfirmation: If any of the webhooks are still in use and `force` is `False`\\n    '",
        "webhooks = await get_all_webhooks_by_creds(credentials.id)",
        "credentials.provider NotIn WEBHOOK_MANAGERS_BY_NAME"
      ]
    },
    {
      "id": "48",
      "type": "block",
      "statements": [
        "webhooks"
      ]
    },
    {
      "id": "49",
      "type": "block",
      "statements": []
    },
    {
      "id": "50",
      "type": "block",
      "statements": [
        "any((w.attached_nodes for w in webhooks)) and (not force)"
      ]
    },
    {
      "id": "51",
      "type": "block",
      "statements": [
        "logger.error(f'Credentials #{credentials.id} for provider {credentials.provider} are attached to {len(webhooks)} webhooks, but there is no available WebhooksHandler for {credentials.provider}')"
      ]
    },
    {
      "id": "52",
      "type": "block",
      "statements": []
    },
    {
      "id": "53",
      "type": "block",
      "statements": [
        "return"
      ]
    },
    {
      "id": "54",
      "type": "block",
      "statements": [
        "raise NeedConfirmation('Some webhooks linked to these credentials are still in use by an agent')"
      ]
    },
    {
      "id": "55",
      "type": "block",
      "statements": []
    },
    {
      "id": "56",
      "type": "block",
      "statements": []
    },
    {
      "id": "57",
      "type": "block",
      "statements": [
        "webhook",
        "webhooks"
      ]
    },
    {
      "id": "58",
      "type": "block",
      "statements": []
    },
    {
      "id": "59",
      "type": "block",
      "statements": [
        "def _get_provider_oauth_handler(req: Request, provider_name: ProviderName) -> 'BaseOAuthHandler':\n    if provider_name not in HANDLERS_BY_NAME:\n        raise HTTPException(status_code=404, detail=f\"Provider '{provider_name.value}' does not support OAuth\")\n    client_id = getattr(settings.secrets, f'{provider_name.value}_client_id')\n    client_secret = getattr(settings.secrets, f'{provider_name.value}_client_secret')\n    if not (client_id and client_secret):\n        raise HTTPException(status_code=501, detail=f\"Integration with provider '{provider_name.value}' is not configured\")\n    handler_class = HANDLERS_BY_NAME[provider_name]\n    frontend_base_url = settings.config.frontend_base_url or settings.config.platform_base_url or str(req.base_url)\n    return handler_class(client_id=client_id, client_secret=client_secret, redirect_uri=f'{frontend_base_url}/auth/integrations/oauth_callback')",
        "provider_name NotIn HANDLERS_BY_NAME"
      ]
    },
    {
      "id": "60",
      "type": "block",
      "statements": [
        "node",
        "webhook.attached_nodes or []"
      ]
    },
    {
      "id": "61",
      "type": "block",
      "statements": [
        "await set_node_webhook(node.id, None)"
      ]
    },
    {
      "id": "62",
      "type": "block",
      "statements": [
        "webhook_manager = WEBHOOK_MANAGERS_BY_NAME[credentials.provider]()",
        "success = await webhook_manager.prune_webhook_if_dangling(webhook.id, credentials)",
        "not success"
      ]
    },
    {
      "id": "63",
      "type": "block",
      "statements": [
        "logger.warning(f'Webhook #{webhook.id} failed to prune')"
      ]
    },
    {
      "id": "64",
      "type": "block",
      "statements": []
    },
    {
      "id": "65",
      "type": "block",
      "statements": []
    },
    {
      "id": "66",
      "type": "block",
      "statements": [
        "raise HTTPException(status_code=404, detail=f\"Provider '{provider_name.value}' does not support OAuth\")"
      ]
    },
    {
      "id": "67",
      "type": "block",
      "statements": []
    },
    {
      "id": "68",
      "type": "block",
      "statements": [
        "client_id = getattr(settings.secrets, f'{provider_name.value}_client_id')",
        "client_secret = getattr(settings.secrets, f'{provider_name.value}_client_secret')",
        "not (client_id and client_secret)"
      ]
    },
    {
      "id": "69",
      "type": "block",
      "statements": [
        "raise HTTPException(status_code=501, detail=f\"Integration with provider '{provider_name.value}' is not configured\")"
      ]
    },
    {
      "id": "70",
      "type": "block",
      "statements": []
    },
    {
      "id": "71",
      "type": "block",
      "statements": [
        "handler_class = HANDLERS_BY_NAME[provider_name]",
        "frontend_base_url = settings.config.frontend_base_url or settings.config.platform_base_url or str(req.base_url)",
        "return handler_class(client_id=client_id, client_secret=client_secret, redirect_uri=f'{frontend_base_url}/auth/integrations/oauth_callback')"
      ]
    }
  ],
  "edges": [
    {
      "source": "1",
      "target": "2",
      "type": "true"
    },
    {
      "source": "1",
      "target": "3",
      "type": "false"
    },
    {
      "source": "2",
      "target": "4",
      "type": "next"
    },
    {
      "source": "3",
      "target": "4",
      "type": "next"
    },
    {
      "source": "5",
      "target": "6",
      "type": "true"
    },
    {
      "source": "5",
      "target": "7",
      "type": "false"
    },
    {
      "source": "6",
      "target": "8",
      "type": "next"
    },
    {
      "source": "7",
      "target": "8",
      "type": "next"
    },
    {
      "source": "8",
      "target": "9",
      "type": "true"
    },
    {
      "source": "8",
      "target": "10",
      "type": "false"
    },
    {
      "source": "9",
      "target": "11",
      "type": "next"
    },
    {
      "source": "10",
      "target": "11",
      "type": "next"
    },
    {
      "source": "14",
      "target": "15",
      "type": "true"
    },
    {
      "source": "14",
      "target": "16",
      "type": "false"
    },
    {
      "source": "15",
      "target": "17",
      "type": "next"
    },
    {
      "source": "16",
      "target": "17",
      "type": "next"
    },
    {
      "source": "17",
      "target": "18",
      "type": "true"
    },
    {
      "source": "17",
      "target": "19",
      "type": "false"
    },
    {
      "source": "18",
      "target": "20",
      "type": "next"
    },
    {
      "source": "19",
      "target": "20",
      "type": "next"
    },
    {
      "source": "22",
      "target": "23",
      "type": "true"
    },
    {
      "source": "22",
      "target": "24",
      "type": "false"
    },
    {
      "source": "23",
      "target": "25",
      "type": "next"
    },
    {
      "source": "24",
      "target": "25",
      "type": "next"
    },
    {
      "source": "25",
      "target": "26",
      "type": "true"
    },
    {
      "source": "25",
      "target": "27",
      "type": "false"
    },
    {
      "source": "26",
      "target": "28",
      "type": "next"
    },
    {
      "source": "27",
      "target": "28",
      "type": "next"
    },
    {
      "source": "29",
      "target": "30",
      "type": "true"
    },
    {
      "source": "29",
      "target": "31",
      "type": "false"
    },
    {
      "source": "30",
      "target": "32",
      "type": "next"
    },
    {
      "source": "31",
      "target": "32",
      "type": "next"
    },
    {
      "source": "33",
      "target": "34",
      "type": "true"
    },
    {
      "source": "33",
      "target": "35",
      "type": "false"
    },
    {
      "source": "35",
      "target": "36",
      "type": "next"
    },
    {
      "source": "36",
      "target": "37",
      "type": "next"
    },
    {
      "source": "37",
      "target": "38",
      "type": "true"
    },
    {
      "source": "37",
      "target": "39",
      "type": "false"
    },
    {
      "source": "38",
      "target": "40",
      "type": "true"
    },
    {
      "source": "38",
      "target": "41",
      "type": "false"
    },
    {
      "source": "40",
      "target": "42",
      "type": "next"
    },
    {
      "source": "41",
      "target": "42",
      "type": "next"
    },
    {
      "source": "42",
      "target": "37",
      "type": "next"
    },
    {
      "source": "43",
      "target": "44",
      "type": "true"
    },
    {
      "source": "43",
      "target": "45",
      "type": "false"
    },
    {
      "source": "44",
      "target": "46",
      "type": "next"
    },
    {
      "source": "45",
      "target": "46",
      "type": "next"
    },
    {
      "source": "47",
      "target": "48",
      "type": "true"
    },
    {
      "source": "47",
      "target": "49",
      "type": "false"
    },
    {
      "source": "48",
      "target": "51",
      "type": "true"
    },
    {
      "source": "48",
      "target": "52",
      "type": "false"
    },
    {
      "source": "49",
      "target": "50",
      "type": "next"
    },
    {
      "source": "50",
      "target": "54",
      "type": "true"
    },
    {
      "source": "50",
      "target": "55",
      "type": "false"
    },
    {
      "source": "51",
      "target": "53",
      "type": "next"
    },
    {
      "source": "52",
      "target": "53",
      "type": "next"
    },
    {
      "source": "54",
      "target": "56",
      "type": "next"
    },
    {
      "source": "55",
      "target": "56",
      "type": "next"
    },
    {
      "source": "56",
      "target": "57",
      "type": "next"
    },
    {
      "source": "57",
      "target": "58",
      "type": "true"
    },
    {
      "source": "57",
      "target": "59",
      "type": "false"
    },
    {
      "source": "58",
      "target": "60",
      "type": "next"
    },
    {
      "source": "59",
      "target": "66",
      "type": "true"
    },
    {
      "source": "59",
      "target": "67",
      "type": "false"
    },
    {
      "source": "60",
      "target": "61",
      "type": "true"
    },
    {
      "source": "60",
      "target": "62",
      "type": "false"
    },
    {
      "source": "61",
      "target": "60",
      "type": "next"
    },
    {
      "source": "62",
      "target": "63",
      "type": "true"
    },
    {
      "source": "62",
      "target": "64",
      "type": "false"
    },
    {
      "source": "63",
      "target": "65",
      "type": "next"
    },
    {
      "source": "64",
      "target": "65",
      "type": "next"
    },
    {
      "source": "65",
      "target": "57",
      "type": "next"
    },
    {
      "source": "66",
      "target": "68",
      "type": "next"
    },
    {
      "source": "67",
      "target": "68",
      "type": "next"
    },
    {
      "source": "68",
      "target": "69",
      "type": "true"
    },
    {
      "source": "68",
      "target": "70",
      "type": "false"
    },
    {
      "source": "69",
      "target": "71",
      "type": "next"
    },
    {
      "source": "70",
      "target": "71",
      "type": "next"
    }
  ]
}