{
  "nodes": [
    {
      "id": "1",
      "type": "block",
      "statements": [
        "'\\nThe sum-of-subsetsproblem states that a set of non-negative integers, and a\\nvalue M, determine all possible subsets of the given set whose summation sum\\nequal to given M.\\n\\nSummation of the chosen numbers must be equal to given number M and one number\\ncan be used only once.\\n'",
        "from __future__ import annotations",
        "def generate_sum_of_subsets_soln(nums: list[int], max_sum: int) -> list[list[int]]:\n    result: list[list[int]] = []\n    path: list[int] = []\n    num_index = 0\n    remaining_nums_sum = sum(nums)\n    create_state_space_tree(nums, max_sum, num_index, path, result, remaining_nums_sum)\n    return result",
        "result: list[list[int]] = []",
        "path: list[int] = []",
        "num_index = 0",
        "remaining_nums_sum = sum(nums)",
        "create_state_space_tree(nums, max_sum, num_index, path, result, remaining_nums_sum)",
        "return result"
      ]
    },
    {
      "id": "2",
      "type": "block",
      "statements": [
        "def create_state_space_tree(nums: list[int], max_sum: int, num_index: int, path: list[int], result: list[list[int]], remaining_nums_sum: int) -> None:\n    \"\"\"\n    Creates a state space tree to iterate through each branch using DFS.\n    It terminates the branching of a node when any of the two conditions\n    given below satisfy.\n    This algorithm follows depth-fist-search and backtracks when the node is not\n    branchable.\n\n    \"\"\"\n    if sum(path) > max_sum or remaining_nums_sum + sum(path) < max_sum:\n        return\n    if sum(path) == max_sum:\n        result.append(path)\n        return\n    for index in range(num_index, len(nums)):\n        create_state_space_tree(nums, max_sum, index + 1, [*path, nums[index]], result, remaining_nums_sum - nums[index])",
        "'\\n    Creates a state space tree to iterate through each branch using DFS.\\n    It terminates the branching of a node when any of the two conditions\\n    given below satisfy.\\n    This algorithm follows depth-fist-search and backtracks when the node is not\\n    branchable.\\n\\n    '",
        "sum(path) > max_sum or remaining_nums_sum + sum(path) < max_sum"
      ]
    },
    {
      "id": "3",
      "type": "block",
      "statements": [
        "return"
      ]
    },
    {
      "id": "4",
      "type": "block",
      "statements": []
    },
    {
      "id": "5",
      "type": "block",
      "statements": [
        "sum(path) Eq max_sum"
      ]
    },
    {
      "id": "6",
      "type": "block",
      "statements": [
        "result.append(path)",
        "return"
      ]
    },
    {
      "id": "7",
      "type": "block",
      "statements": []
    },
    {
      "id": "8",
      "type": "block",
      "statements": []
    },
    {
      "id": "9",
      "type": "block",
      "statements": [
        "index",
        "range(num_index, len(nums))"
      ]
    },
    {
      "id": "10",
      "type": "block",
      "statements": [
        "create_state_space_tree(nums, max_sum, index Add 1, [*path, nums[index]], result, remaining_nums_sum Sub nums[index])"
      ]
    },
    {
      "id": "11",
      "type": "block",
      "statements": [
        "'\\nremove the comment to take an input from the user\\n\\nprint(\"Enter the elements\")\\nnums = list(map(int, input().split()))\\nprint(\"Enter max_sum sum\")\\nmax_sum = int(input())\\n\\n'",
        "nums = [3, 34, 4, 12, 5, 2]",
        "max_sum = 9",
        "result = generate_sum_of_subsets_soln(nums, max_sum)",
        "print(*result)"
      ]
    }
  ],
  "edges": [
    {
      "source": "2",
      "target": "3",
      "type": "true"
    },
    {
      "source": "2",
      "target": "4",
      "type": "false"
    },
    {
      "source": "4",
      "target": "5",
      "type": "next"
    },
    {
      "source": "5",
      "target": "6",
      "type": "true"
    },
    {
      "source": "5",
      "target": "7",
      "type": "false"
    },
    {
      "source": "7",
      "target": "8",
      "type": "next"
    },
    {
      "source": "8",
      "target": "9",
      "type": "next"
    },
    {
      "source": "9",
      "target": "10",
      "type": "true"
    },
    {
      "source": "9",
      "target": "11",
      "type": "false"
    },
    {
      "source": "10",
      "target": "9",
      "type": "next"
    }
  ]
}