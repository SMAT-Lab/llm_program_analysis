{
  "nodes": [
    {
      "id": "1",
      "type": "block",
      "statements": [
        "import base64",
        "from email.utils import parseaddr",
        "from typing import List",
        "from google.oauth2.credentials import Credentials",
        "from googleapiclient.discovery import build",
        "from pydantic import BaseModel",
        "from backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema",
        "from backend.data.model import SchemaField",
        "from ._auth import GOOGLE_OAUTH_IS_CONFIGURED, TEST_CREDENTIALS, TEST_CREDENTIALS_INPUT, GoogleCredentials, GoogleCredentialsField, GoogleCredentialsInput",
        "class Attachment(BaseModel):\n    filename: str\n    content_type: str\n    size: int\n    attachment_id: str",
        "filename: str",
        "content_type: str",
        "size: int",
        "attachment_id: str",
        "class Email(BaseModel):\n    id: str\n    subject: str\n    snippet: str\n    from_: str\n    to: str\n    date: str\n    body: str = ''\n    sizeEstimate: int\n    attachments: List[Attachment]",
        "id: str",
        "subject: str",
        "snippet: str",
        "from_: str",
        "to: str",
        "date: str",
        "body: str = ''",
        "sizeEstimate: int",
        "attachments: List[Attachment]",
        "class GmailReadBlock(Block):\n\n    class Input(BlockSchema):\n        credentials: GoogleCredentialsInput = GoogleCredentialsField(['https://www.googleapis.com/auth/gmail.readonly'])\n        query: str = SchemaField(description='Search query for reading emails', default='is:unread')\n        max_results: int = SchemaField(description='Maximum number of emails to retrieve', default=10)\n\n    class Output(BlockSchema):\n        email: Email = SchemaField(description='Email data')\n        emails: list[Email] = SchemaField(description='List of email data')\n        error: str = SchemaField(description='Error message if any')\n\n    def __init__(self):\n        super().__init__(id='25310c70-b89b-43ba-b25c-4dfa7e2a481c', description='This block reads emails from Gmail.', categories={BlockCategory.COMMUNICATION}, disabled=not GOOGLE_OAUTH_IS_CONFIGURED, input_schema=GmailReadBlock.Input, output_schema=GmailReadBlock.Output, test_input={'query': 'is:unread', 'max_results': 5, 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('email', {'id': '1', 'subject': 'Test Email', 'snippet': 'This is a test email', 'from_': 'test@example.com', 'to': 'recipient@example.com', 'date': '2024-01-01', 'body': 'This is a test email', 'sizeEstimate': 100, 'attachments': []}), ('emails', [{'id': '1', 'subject': 'Test Email', 'snippet': 'This is a test email', 'from_': 'test@example.com', 'to': 'recipient@example.com', 'date': '2024-01-01', 'body': 'This is a test email', 'sizeEstimate': 100, 'attachments': []}])], test_mock={'_read_emails': lambda *args, **kwargs: [{'id': '1', 'subject': 'Test Email', 'snippet': 'This is a test email', 'from_': 'test@example.com', 'to': 'recipient@example.com', 'date': '2024-01-01', 'body': 'This is a test email', 'sizeEstimate': 100, 'attachments': []}], '_send_email': lambda *args, **kwargs: {'id': '1', 'status': 'sent'}})\n\n    def run(self, input_data: Input, *, credentials: GoogleCredentials, **kwargs) -> BlockOutput:\n        service = self._build_service(credentials, **kwargs)\n        messages = self._read_emails(service, input_data.query, input_data.max_results)\n        for email in messages:\n            yield ('email', email)\n        yield ('emails', messages)\n\n    @staticmethod\n    def _build_service(credentials: GoogleCredentials, **kwargs):\n        creds = Credentials(token=credentials.access_token.get_secret_value() if credentials.access_token else None, refresh_token=credentials.refresh_token.get_secret_value() if credentials.refresh_token else None, token_uri='https://oauth2.googleapis.com/token', client_id=kwargs.get('client_id'), client_secret=kwargs.get('client_secret'), scopes=credentials.scopes)\n        return build('gmail', 'v1', credentials=creds)\n\n    def _read_emails(self, service, query: str | None, max_results: int | None) -> list[Email]:\n        results = service.users().messages().list(userId='me', q=query or '', maxResults=max_results or 10).execute()\n        messages = results.get('messages', [])\n        email_data = []\n        for message in messages:\n            msg = service.users().messages().get(userId='me', id=message['id'], format='full').execute()\n            headers = {header['name'].lower(): header['value'] for header in msg['payload']['headers']}\n            attachments = self._get_attachments(service, msg)\n            email = Email(id=msg['id'], subject=headers.get('subject', 'No Subject'), snippet=msg['snippet'], from_=parseaddr(headers.get('from', ''))[1], to=parseaddr(headers.get('to', ''))[1], date=headers.get('date', ''), body=self._get_email_body(msg), sizeEstimate=msg['sizeEstimate'], attachments=attachments)\n            email_data.append(email)\n        return email_data\n\n    def _get_email_body(self, msg):\n        if 'parts' in msg['payload']:\n            for part in msg['payload']['parts']:\n                if part['mimeType'] == 'text/plain':\n                    return base64.urlsafe_b64decode(part['body']['data']).decode('utf-8')\n        elif msg['payload']['mimeType'] == 'text/plain':\n            return base64.urlsafe_b64decode(msg['payload']['body']['data']).decode('utf-8')\n        return 'This email does not contain a text body.'\n\n    def _get_attachments(self, service, message):\n        attachments = []\n        if 'parts' in message['payload']:\n            for part in message['payload']['parts']:\n                if part['filename']:\n                    attachment = Attachment(filename=part['filename'], content_type=part['mimeType'], size=int(part['body'].get('size', 0)), attachment_id=part['body']['attachmentId'])\n                    attachments.append(attachment)\n        return attachments\n\n    def download_attachment(self, service, message_id: str, attachment_id: str):\n        attachment = service.users().messages().attachments().get(userId='me', messageId=message_id, id=attachment_id).execute()\n        file_data = base64.urlsafe_b64decode(attachment['data'].encode('UTF-8'))\n        return file_data",
        "class Input(BlockSchema):\n    credentials: GoogleCredentialsInput = GoogleCredentialsField(['https://www.googleapis.com/auth/gmail.readonly'])\n    query: str = SchemaField(description='Search query for reading emails', default='is:unread')\n    max_results: int = SchemaField(description='Maximum number of emails to retrieve', default=10)",
        "credentials: GoogleCredentialsInput = GoogleCredentialsField(['https://www.googleapis.com/auth/gmail.readonly'])",
        "query: str = SchemaField(description='Search query for reading emails', default='is:unread')",
        "max_results: int = SchemaField(description='Maximum number of emails to retrieve', default=10)",
        "class Output(BlockSchema):\n    email: Email = SchemaField(description='Email data')\n    emails: list[Email] = SchemaField(description='List of email data')\n    error: str = SchemaField(description='Error message if any')",
        "email: Email = SchemaField(description='Email data')",
        "emails: list[Email] = SchemaField(description='List of email data')",
        "error: str = SchemaField(description='Error message if any')",
        "def __init__(self):\n    super().__init__(id='25310c70-b89b-43ba-b25c-4dfa7e2a481c', description='This block reads emails from Gmail.', categories={BlockCategory.COMMUNICATION}, disabled=not GOOGLE_OAUTH_IS_CONFIGURED, input_schema=GmailReadBlock.Input, output_schema=GmailReadBlock.Output, test_input={'query': 'is:unread', 'max_results': 5, 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('email', {'id': '1', 'subject': 'Test Email', 'snippet': 'This is a test email', 'from_': 'test@example.com', 'to': 'recipient@example.com', 'date': '2024-01-01', 'body': 'This is a test email', 'sizeEstimate': 100, 'attachments': []}), ('emails', [{'id': '1', 'subject': 'Test Email', 'snippet': 'This is a test email', 'from_': 'test@example.com', 'to': 'recipient@example.com', 'date': '2024-01-01', 'body': 'This is a test email', 'sizeEstimate': 100, 'attachments': []}])], test_mock={'_read_emails': lambda *args, **kwargs: [{'id': '1', 'subject': 'Test Email', 'snippet': 'This is a test email', 'from_': 'test@example.com', 'to': 'recipient@example.com', 'date': '2024-01-01', 'body': 'This is a test email', 'sizeEstimate': 100, 'attachments': []}], '_send_email': lambda *args, **kwargs: {'id': '1', 'status': 'sent'}})",
        "super().__init__()",
        "def run(self, input_data: Input, *, credentials: GoogleCredentials, **kwargs) -> BlockOutput:\n    service = self._build_service(credentials, **kwargs)\n    messages = self._read_emails(service, input_data.query, input_data.max_results)\n    for email in messages:\n        yield ('email', email)\n    yield ('emails', messages)",
        "service = self._build_service(credentials, **kwargs)",
        "messages = self._read_emails(service, input_data.query, input_data.max_results)"
      ]
    },
    {
      "id": "2",
      "type": "block",
      "statements": [
        "email",
        "messages"
      ]
    },
    {
      "id": "3",
      "type": "block",
      "statements": [
        "(yield ('email', email))"
      ]
    },
    {
      "id": "4",
      "type": "block",
      "statements": [
        "(yield ('emails', messages))",
        "@staticmethod\ndef _build_service(credentials: GoogleCredentials, **kwargs):\n    creds = Credentials(token=credentials.access_token.get_secret_value() if credentials.access_token else None, refresh_token=credentials.refresh_token.get_secret_value() if credentials.refresh_token else None, token_uri='https://oauth2.googleapis.com/token', client_id=kwargs.get('client_id'), client_secret=kwargs.get('client_secret'), scopes=credentials.scopes)\n    return build('gmail', 'v1', credentials=creds)",
        "creds = Credentials(token=credentials.access_token.get_secret_value() if credentials.access_token else None, refresh_token=credentials.refresh_token.get_secret_value() if credentials.refresh_token else None, token_uri='https://oauth2.googleapis.com/token', client_id=kwargs.get('client_id'), client_secret=kwargs.get('client_secret'), scopes=credentials.scopes)",
        "return build('gmail', 'v1', credentials=creds)"
      ]
    },
    {
      "id": "5",
      "type": "block",
      "statements": [
        "def _read_emails(self, service, query: str | None, max_results: int | None) -> list[Email]:\n    results = service.users().messages().list(userId='me', q=query or '', maxResults=max_results or 10).execute()\n    messages = results.get('messages', [])\n    email_data = []\n    for message in messages:\n        msg = service.users().messages().get(userId='me', id=message['id'], format='full').execute()\n        headers = {header['name'].lower(): header['value'] for header in msg['payload']['headers']}\n        attachments = self._get_attachments(service, msg)\n        email = Email(id=msg['id'], subject=headers.get('subject', 'No Subject'), snippet=msg['snippet'], from_=parseaddr(headers.get('from', ''))[1], to=parseaddr(headers.get('to', ''))[1], date=headers.get('date', ''), body=self._get_email_body(msg), sizeEstimate=msg['sizeEstimate'], attachments=attachments)\n        email_data.append(email)\n    return email_data",
        "results = service.users().messages().list(userId='me', q=query or '', maxResults=max_results or 10).execute()",
        "messages = results.get('messages', [])",
        "email_data = []"
      ]
    },
    {
      "id": "6",
      "type": "block",
      "statements": [
        "message",
        "messages"
      ]
    },
    {
      "id": "7",
      "type": "block",
      "statements": [
        "msg = service.users().messages().get(userId='me', id=message['id'], format='full').execute()",
        "headers = {header['name'].lower(): header['value'] for header in msg['payload']['headers']}",
        "attachments = self._get_attachments(service, msg)",
        "email = Email(id=msg['id'], subject=headers.get('subject', 'No Subject'), snippet=msg['snippet'], from_=parseaddr(headers.get('from', ''))[1], to=parseaddr(headers.get('to', ''))[1], date=headers.get('date', ''), body=self._get_email_body(msg), sizeEstimate=msg['sizeEstimate'], attachments=attachments)",
        "email_data.append(email)"
      ]
    },
    {
      "id": "8",
      "type": "block",
      "statements": [
        "return email_data"
      ]
    },
    {
      "id": "9",
      "type": "block",
      "statements": [
        "def _get_email_body(self, msg):\n    if 'parts' in msg['payload']:\n        for part in msg['payload']['parts']:\n            if part['mimeType'] == 'text/plain':\n                return base64.urlsafe_b64decode(part['body']['data']).decode('utf-8')\n    elif msg['payload']['mimeType'] == 'text/plain':\n        return base64.urlsafe_b64decode(msg['payload']['body']['data']).decode('utf-8')\n    return 'This email does not contain a text body.'",
        "'parts' In msg['payload']"
      ]
    },
    {
      "id": "10",
      "type": "block",
      "statements": []
    },
    {
      "id": "11",
      "type": "block",
      "statements": [
        "msg['payload']['mimeType'] Eq 'text/plain'"
      ]
    },
    {
      "id": "12",
      "type": "block",
      "statements": [
        "return 'This email does not contain a text body.'"
      ]
    },
    {
      "id": "13",
      "type": "block",
      "statements": [
        "part",
        "msg['payload']['parts']"
      ]
    },
    {
      "id": "14",
      "type": "block",
      "statements": [
        "part['mimeType'] Eq 'text/plain'"
      ]
    },
    {
      "id": "15",
      "type": "block",
      "statements": []
    },
    {
      "id": "16",
      "type": "block",
      "statements": [
        "return base64.urlsafe_b64decode(part['body']['data']).decode('utf-8')"
      ]
    },
    {
      "id": "17",
      "type": "block",
      "statements": []
    },
    {
      "id": "18",
      "type": "block",
      "statements": []
    },
    {
      "id": "19",
      "type": "block",
      "statements": [
        "return base64.urlsafe_b64decode(msg['payload']['body']['data']).decode('utf-8')"
      ]
    },
    {
      "id": "20",
      "type": "block",
      "statements": []
    },
    {
      "id": "21",
      "type": "block",
      "statements": []
    },
    {
      "id": "22",
      "type": "block",
      "statements": [
        "def _get_attachments(self, service, message):\n    attachments = []\n    if 'parts' in message['payload']:\n        for part in message['payload']['parts']:\n            if part['filename']:\n                attachment = Attachment(filename=part['filename'], content_type=part['mimeType'], size=int(part['body'].get('size', 0)), attachment_id=part['body']['attachmentId'])\n                attachments.append(attachment)\n    return attachments",
        "attachments = []",
        "'parts' In message['payload']"
      ]
    },
    {
      "id": "23",
      "type": "block",
      "statements": []
    },
    {
      "id": "24",
      "type": "block",
      "statements": []
    },
    {
      "id": "25",
      "type": "block",
      "statements": [
        "return attachments"
      ]
    },
    {
      "id": "26",
      "type": "block",
      "statements": [
        "part",
        "message['payload']['parts']"
      ]
    },
    {
      "id": "27",
      "type": "block",
      "statements": [
        "part['filename']"
      ]
    },
    {
      "id": "28",
      "type": "block",
      "statements": []
    },
    {
      "id": "29",
      "type": "block",
      "statements": [
        "attachment = Attachment(filename=part['filename'], content_type=part['mimeType'], size=int(part['body'].get('size', 0)), attachment_id=part['body']['attachmentId'])",
        "attachments.append(attachment)"
      ]
    },
    {
      "id": "30",
      "type": "block",
      "statements": []
    },
    {
      "id": "31",
      "type": "block",
      "statements": []
    },
    {
      "id": "32",
      "type": "block",
      "statements": [
        "def download_attachment(self, service, message_id: str, attachment_id: str):\n    attachment = service.users().messages().attachments().get(userId='me', messageId=message_id, id=attachment_id).execute()\n    file_data = base64.urlsafe_b64decode(attachment['data'].encode('UTF-8'))\n    return file_data",
        "attachment = service.users().messages().attachments().get(userId='me', messageId=message_id, id=attachment_id).execute()",
        "file_data = base64.urlsafe_b64decode(attachment['data'].encode('UTF-8'))",
        "return file_data"
      ]
    },
    {
      "id": "33",
      "type": "block",
      "statements": [
        "class GmailSendBlock(Block):\n\n    class Input(BlockSchema):\n        credentials: GoogleCredentialsInput = GoogleCredentialsField(['https://www.googleapis.com/auth/gmail.send'])\n        to: str = SchemaField(description='Recipient email address')\n        subject: str = SchemaField(description='Email subject')\n        body: str = SchemaField(description='Email body')\n\n    class Output(BlockSchema):\n        result: dict = SchemaField(description='Send confirmation')\n        error: str = SchemaField(description='Error message if any')\n\n    def __init__(self):\n        super().__init__(id='6c27abc2-e51d-499e-a85f-5a0041ba94f0', description='This block sends an email using Gmail.', categories={BlockCategory.COMMUNICATION}, input_schema=GmailSendBlock.Input, output_schema=GmailSendBlock.Output, disabled=not GOOGLE_OAUTH_IS_CONFIGURED, test_input={'to': 'recipient@example.com', 'subject': 'Test Email', 'body': 'This is a test email sent from GmailSendBlock.', 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('result', {'id': '1', 'status': 'sent'})], test_mock={'_send_email': lambda *args, **kwargs: {'id': '1', 'status': 'sent'}})\n\n    def run(self, input_data: Input, *, credentials: GoogleCredentials, **kwargs) -> BlockOutput:\n        service = GmailReadBlock._build_service(credentials, **kwargs)\n        send_result = self._send_email(service, input_data.to, input_data.subject, input_data.body)\n        yield ('result', send_result)\n\n    def _send_email(self, service, to: str, subject: str, body: str) -> dict:\n        if not to or not subject or (not body):\n            raise ValueError('To, subject, and body are required for sending an email')\n        message = self._create_message(to, subject, body)\n        sent_message = service.users().messages().send(userId='me', body=message).execute()\n        return {'id': sent_message['id'], 'status': 'sent'}\n\n    def _create_message(self, to: str, subject: str, body: str) -> dict:\n        import base64\n        from email.mime.text import MIMEText\n        message = MIMEText(body)\n        message['to'] = to\n        message['subject'] = subject\n        raw_message = base64.urlsafe_b64encode(message.as_bytes()).decode('utf-8')\n        return {'raw': raw_message}",
        "class Input(BlockSchema):\n    credentials: GoogleCredentialsInput = GoogleCredentialsField(['https://www.googleapis.com/auth/gmail.send'])\n    to: str = SchemaField(description='Recipient email address')\n    subject: str = SchemaField(description='Email subject')\n    body: str = SchemaField(description='Email body')",
        "credentials: GoogleCredentialsInput = GoogleCredentialsField(['https://www.googleapis.com/auth/gmail.send'])",
        "to: str = SchemaField(description='Recipient email address')",
        "subject: str = SchemaField(description='Email subject')",
        "body: str = SchemaField(description='Email body')",
        "class Output(BlockSchema):\n    result: dict = SchemaField(description='Send confirmation')\n    error: str = SchemaField(description='Error message if any')",
        "result: dict = SchemaField(description='Send confirmation')",
        "error: str = SchemaField(description='Error message if any')",
        "def __init__(self):\n    super().__init__(id='6c27abc2-e51d-499e-a85f-5a0041ba94f0', description='This block sends an email using Gmail.', categories={BlockCategory.COMMUNICATION}, input_schema=GmailSendBlock.Input, output_schema=GmailSendBlock.Output, disabled=not GOOGLE_OAUTH_IS_CONFIGURED, test_input={'to': 'recipient@example.com', 'subject': 'Test Email', 'body': 'This is a test email sent from GmailSendBlock.', 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('result', {'id': '1', 'status': 'sent'})], test_mock={'_send_email': lambda *args, **kwargs: {'id': '1', 'status': 'sent'}})",
        "super().__init__()",
        "def run(self, input_data: Input, *, credentials: GoogleCredentials, **kwargs) -> BlockOutput:\n    service = GmailReadBlock._build_service(credentials, **kwargs)\n    send_result = self._send_email(service, input_data.to, input_data.subject, input_data.body)\n    yield ('result', send_result)",
        "service = GmailReadBlock._build_service(credentials, **kwargs)",
        "send_result = self._send_email(service, input_data.to, input_data.subject, input_data.body)",
        "(yield ('result', send_result))",
        "def _send_email(self, service, to: str, subject: str, body: str) -> dict:\n    if not to or not subject or (not body):\n        raise ValueError('To, subject, and body are required for sending an email')\n    message = self._create_message(to, subject, body)\n    sent_message = service.users().messages().send(userId='me', body=message).execute()\n    return {'id': sent_message['id'], 'status': 'sent'}",
        "not to or not subject or (not body)"
      ]
    },
    {
      "id": "34",
      "type": "block",
      "statements": [
        "raise ValueError('To, subject, and body are required for sending an email')"
      ]
    },
    {
      "id": "35",
      "type": "block",
      "statements": []
    },
    {
      "id": "36",
      "type": "block",
      "statements": [
        "message = self._create_message(to, subject, body)",
        "sent_message = service.users().messages().send(userId='me', body=message).execute()",
        "return {'id': sent_message['id'], 'status': 'sent'}"
      ]
    },
    {
      "id": "37",
      "type": "block",
      "statements": [
        "def _create_message(self, to: str, subject: str, body: str) -> dict:\n    import base64\n    from email.mime.text import MIMEText\n    message = MIMEText(body)\n    message['to'] = to\n    message['subject'] = subject\n    raw_message = base64.urlsafe_b64encode(message.as_bytes()).decode('utf-8')\n    return {'raw': raw_message}",
        "import base64",
        "from email.mime.text import MIMEText",
        "message = MIMEText(body)",
        "message['to'] = to",
        "message['subject'] = subject",
        "raw_message = base64.urlsafe_b64encode(message.as_bytes()).decode('utf-8')",
        "return {'raw': raw_message}"
      ]
    },
    {
      "id": "38",
      "type": "block",
      "statements": [
        "class GmailListLabelsBlock(Block):\n\n    class Input(BlockSchema):\n        credentials: GoogleCredentialsInput = GoogleCredentialsField(['https://www.googleapis.com/auth/gmail.labels'])\n\n    class Output(BlockSchema):\n        result: list[dict] = SchemaField(description='List of labels')\n        error: str = SchemaField(description='Error message if any')\n\n    def __init__(self):\n        super().__init__(id='3e1c2c1c-c689-4520-b956-1f3bf4e02bb7', description='This block lists all labels in Gmail.', categories={BlockCategory.COMMUNICATION}, input_schema=GmailListLabelsBlock.Input, output_schema=GmailListLabelsBlock.Output, disabled=not GOOGLE_OAUTH_IS_CONFIGURED, test_input={'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('result', [{'id': 'Label_1', 'name': 'Important'}, {'id': 'Label_2', 'name': 'Work'}])], test_mock={'_list_labels': lambda *args, **kwargs: [{'id': 'Label_1', 'name': 'Important'}, {'id': 'Label_2', 'name': 'Work'}]})\n\n    def run(self, input_data: Input, *, credentials: GoogleCredentials, **kwargs) -> BlockOutput:\n        service = GmailReadBlock._build_service(credentials, **kwargs)\n        labels = self._list_labels(service)\n        yield ('result', labels)\n\n    def _list_labels(self, service) -> list[dict]:\n        results = service.users().labels().list(userId='me').execute()\n        labels = results.get('labels', [])\n        return [{'id': label['id'], 'name': label['name']} for label in labels]",
        "class Input(BlockSchema):\n    credentials: GoogleCredentialsInput = GoogleCredentialsField(['https://www.googleapis.com/auth/gmail.labels'])",
        "credentials: GoogleCredentialsInput = GoogleCredentialsField(['https://www.googleapis.com/auth/gmail.labels'])",
        "class Output(BlockSchema):\n    result: list[dict] = SchemaField(description='List of labels')\n    error: str = SchemaField(description='Error message if any')",
        "result: list[dict] = SchemaField(description='List of labels')",
        "error: str = SchemaField(description='Error message if any')",
        "def __init__(self):\n    super().__init__(id='3e1c2c1c-c689-4520-b956-1f3bf4e02bb7', description='This block lists all labels in Gmail.', categories={BlockCategory.COMMUNICATION}, input_schema=GmailListLabelsBlock.Input, output_schema=GmailListLabelsBlock.Output, disabled=not GOOGLE_OAUTH_IS_CONFIGURED, test_input={'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('result', [{'id': 'Label_1', 'name': 'Important'}, {'id': 'Label_2', 'name': 'Work'}])], test_mock={'_list_labels': lambda *args, **kwargs: [{'id': 'Label_1', 'name': 'Important'}, {'id': 'Label_2', 'name': 'Work'}]})",
        "super().__init__()",
        "def run(self, input_data: Input, *, credentials: GoogleCredentials, **kwargs) -> BlockOutput:\n    service = GmailReadBlock._build_service(credentials, **kwargs)\n    labels = self._list_labels(service)\n    yield ('result', labels)",
        "service = GmailReadBlock._build_service(credentials, **kwargs)",
        "labels = self._list_labels(service)",
        "(yield ('result', labels))",
        "def _list_labels(self, service) -> list[dict]:\n    results = service.users().labels().list(userId='me').execute()\n    labels = results.get('labels', [])\n    return [{'id': label['id'], 'name': label['name']} for label in labels]",
        "results = service.users().labels().list(userId='me').execute()",
        "labels = results.get('labels', [])",
        "return [{'id': label['id'], 'name': label['name']} for label in labels]"
      ]
    },
    {
      "id": "39",
      "type": "block",
      "statements": [
        "class GmailAddLabelBlock(Block):\n\n    class Input(BlockSchema):\n        credentials: GoogleCredentialsInput = GoogleCredentialsField(['https://www.googleapis.com/auth/gmail.modify'])\n        message_id: str = SchemaField(description='Message ID to add label to')\n        label_name: str = SchemaField(description='Label name to add')\n\n    class Output(BlockSchema):\n        result: dict = SchemaField(description='Label addition result')\n        error: str = SchemaField(description='Error message if any')\n\n    def __init__(self):\n        super().__init__(id='f884b2fb-04f4-4265-9658-14f433926ac9', description='This block adds a label to a Gmail message.', categories={BlockCategory.COMMUNICATION}, input_schema=GmailAddLabelBlock.Input, output_schema=GmailAddLabelBlock.Output, disabled=not GOOGLE_OAUTH_IS_CONFIGURED, test_input={'message_id': '12345', 'label_name': 'Important', 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('result', {'status': 'Label added successfully', 'label_id': 'Label_1'})], test_mock={'_add_label': lambda *args, **kwargs: {'status': 'Label added successfully', 'label_id': 'Label_1'}})\n\n    def run(self, input_data: Input, *, credentials: GoogleCredentials, **kwargs) -> BlockOutput:\n        service = GmailReadBlock._build_service(credentials, **kwargs)\n        result = self._add_label(service, input_data.message_id, input_data.label_name)\n        yield ('result', result)\n\n    def _add_label(self, service, message_id: str, label_name: str) -> dict:\n        label_id = self._get_or_create_label(service, label_name)\n        service.users().messages().modify(userId='me', id=message_id, body={'addLabelIds': [label_id]}).execute()\n        return {'status': 'Label added successfully', 'label_id': label_id}\n\n    def _get_or_create_label(self, service, label_name: str) -> str:\n        label_id = self._get_label_id(service, label_name)\n        if not label_id:\n            label = service.users().labels().create(userId='me', body={'name': label_name}).execute()\n            label_id = label['id']\n        return label_id\n\n    def _get_label_id(self, service, label_name: str) -> str | None:\n        results = service.users().labels().list(userId='me').execute()\n        labels = results.get('labels', [])\n        for label in labels:\n            if label['name'] == label_name:\n                return label['id']\n        return None",
        "class Input(BlockSchema):\n    credentials: GoogleCredentialsInput = GoogleCredentialsField(['https://www.googleapis.com/auth/gmail.modify'])\n    message_id: str = SchemaField(description='Message ID to add label to')\n    label_name: str = SchemaField(description='Label name to add')",
        "credentials: GoogleCredentialsInput = GoogleCredentialsField(['https://www.googleapis.com/auth/gmail.modify'])",
        "message_id: str = SchemaField(description='Message ID to add label to')",
        "label_name: str = SchemaField(description='Label name to add')",
        "class Output(BlockSchema):\n    result: dict = SchemaField(description='Label addition result')\n    error: str = SchemaField(description='Error message if any')",
        "result: dict = SchemaField(description='Label addition result')",
        "error: str = SchemaField(description='Error message if any')",
        "def __init__(self):\n    super().__init__(id='f884b2fb-04f4-4265-9658-14f433926ac9', description='This block adds a label to a Gmail message.', categories={BlockCategory.COMMUNICATION}, input_schema=GmailAddLabelBlock.Input, output_schema=GmailAddLabelBlock.Output, disabled=not GOOGLE_OAUTH_IS_CONFIGURED, test_input={'message_id': '12345', 'label_name': 'Important', 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('result', {'status': 'Label added successfully', 'label_id': 'Label_1'})], test_mock={'_add_label': lambda *args, **kwargs: {'status': 'Label added successfully', 'label_id': 'Label_1'}})",
        "super().__init__()",
        "def run(self, input_data: Input, *, credentials: GoogleCredentials, **kwargs) -> BlockOutput:\n    service = GmailReadBlock._build_service(credentials, **kwargs)\n    result = self._add_label(service, input_data.message_id, input_data.label_name)\n    yield ('result', result)",
        "service = GmailReadBlock._build_service(credentials, **kwargs)",
        "result = self._add_label(service, input_data.message_id, input_data.label_name)",
        "(yield ('result', result))",
        "def _add_label(self, service, message_id: str, label_name: str) -> dict:\n    label_id = self._get_or_create_label(service, label_name)\n    service.users().messages().modify(userId='me', id=message_id, body={'addLabelIds': [label_id]}).execute()\n    return {'status': 'Label added successfully', 'label_id': label_id}",
        "label_id = self._get_or_create_label(service, label_name)",
        "service.users().messages().modify(userId='me', id=message_id, body={'addLabelIds': [label_id]}).execute()",
        "return {'status': 'Label added successfully', 'label_id': label_id}"
      ]
    },
    {
      "id": "40",
      "type": "block",
      "statements": [
        "def _get_or_create_label(self, service, label_name: str) -> str:\n    label_id = self._get_label_id(service, label_name)\n    if not label_id:\n        label = service.users().labels().create(userId='me', body={'name': label_name}).execute()\n        label_id = label['id']\n    return label_id",
        "label_id = self._get_label_id(service, label_name)",
        "not label_id"
      ]
    },
    {
      "id": "41",
      "type": "block",
      "statements": [
        "label = service.users().labels().create(userId='me', body={'name': label_name}).execute()",
        "label_id = label['id']"
      ]
    },
    {
      "id": "42",
      "type": "block",
      "statements": []
    },
    {
      "id": "43",
      "type": "block",
      "statements": [
        "return label_id"
      ]
    },
    {
      "id": "44",
      "type": "block",
      "statements": [
        "def _get_label_id(self, service, label_name: str) -> str | None:\n    results = service.users().labels().list(userId='me').execute()\n    labels = results.get('labels', [])\n    for label in labels:\n        if label['name'] == label_name:\n            return label['id']\n    return None",
        "results = service.users().labels().list(userId='me').execute()",
        "labels = results.get('labels', [])"
      ]
    },
    {
      "id": "45",
      "type": "block",
      "statements": [
        "label",
        "labels"
      ]
    },
    {
      "id": "46",
      "type": "block",
      "statements": [
        "label['name'] Eq label_name"
      ]
    },
    {
      "id": "47",
      "type": "block",
      "statements": [
        "return None"
      ]
    },
    {
      "id": "48",
      "type": "block",
      "statements": [
        "return label['id']"
      ]
    },
    {
      "id": "49",
      "type": "block",
      "statements": []
    },
    {
      "id": "50",
      "type": "block",
      "statements": []
    },
    {
      "id": "51",
      "type": "block",
      "statements": [
        "class GmailRemoveLabelBlock(Block):\n\n    class Input(BlockSchema):\n        credentials: GoogleCredentialsInput = GoogleCredentialsField(['https://www.googleapis.com/auth/gmail.modify'])\n        message_id: str = SchemaField(description='Message ID to remove label from')\n        label_name: str = SchemaField(description='Label name to remove')\n\n    class Output(BlockSchema):\n        result: dict = SchemaField(description='Label removal result')\n        error: str = SchemaField(description='Error message if any')\n\n    def __init__(self):\n        super().__init__(id='0afc0526-aba1-4b2b-888e-a22b7c3f359d', description='This block removes a label from a Gmail message.', categories={BlockCategory.COMMUNICATION}, input_schema=GmailRemoveLabelBlock.Input, output_schema=GmailRemoveLabelBlock.Output, disabled=not GOOGLE_OAUTH_IS_CONFIGURED, test_input={'message_id': '12345', 'label_name': 'Important', 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('result', {'status': 'Label removed successfully', 'label_id': 'Label_1'})], test_mock={'_remove_label': lambda *args, **kwargs: {'status': 'Label removed successfully', 'label_id': 'Label_1'}})\n\n    def run(self, input_data: Input, *, credentials: GoogleCredentials, **kwargs) -> BlockOutput:\n        service = GmailReadBlock._build_service(credentials, **kwargs)\n        result = self._remove_label(service, input_data.message_id, input_data.label_name)\n        yield ('result', result)\n\n    def _remove_label(self, service, message_id: str, label_name: str) -> dict:\n        label_id = self._get_label_id(service, label_name)\n        if label_id:\n            service.users().messages().modify(userId='me', id=message_id, body={'removeLabelIds': [label_id]}).execute()\n            return {'status': 'Label removed successfully', 'label_id': label_id}\n        else:\n            return {'status': 'Label not found', 'label_name': label_name}\n\n    def _get_label_id(self, service, label_name: str) -> str | None:\n        results = service.users().labels().list(userId='me').execute()\n        labels = results.get('labels', [])\n        for label in labels:\n            if label['name'] == label_name:\n                return label['id']\n        return None",
        "class Input(BlockSchema):\n    credentials: GoogleCredentialsInput = GoogleCredentialsField(['https://www.googleapis.com/auth/gmail.modify'])\n    message_id: str = SchemaField(description='Message ID to remove label from')\n    label_name: str = SchemaField(description='Label name to remove')",
        "credentials: GoogleCredentialsInput = GoogleCredentialsField(['https://www.googleapis.com/auth/gmail.modify'])",
        "message_id: str = SchemaField(description='Message ID to remove label from')",
        "label_name: str = SchemaField(description='Label name to remove')",
        "class Output(BlockSchema):\n    result: dict = SchemaField(description='Label removal result')\n    error: str = SchemaField(description='Error message if any')",
        "result: dict = SchemaField(description='Label removal result')",
        "error: str = SchemaField(description='Error message if any')",
        "def __init__(self):\n    super().__init__(id='0afc0526-aba1-4b2b-888e-a22b7c3f359d', description='This block removes a label from a Gmail message.', categories={BlockCategory.COMMUNICATION}, input_schema=GmailRemoveLabelBlock.Input, output_schema=GmailRemoveLabelBlock.Output, disabled=not GOOGLE_OAUTH_IS_CONFIGURED, test_input={'message_id': '12345', 'label_name': 'Important', 'credentials': TEST_CREDENTIALS_INPUT}, test_credentials=TEST_CREDENTIALS, test_output=[('result', {'status': 'Label removed successfully', 'label_id': 'Label_1'})], test_mock={'_remove_label': lambda *args, **kwargs: {'status': 'Label removed successfully', 'label_id': 'Label_1'}})",
        "super().__init__()",
        "def run(self, input_data: Input, *, credentials: GoogleCredentials, **kwargs) -> BlockOutput:\n    service = GmailReadBlock._build_service(credentials, **kwargs)\n    result = self._remove_label(service, input_data.message_id, input_data.label_name)\n    yield ('result', result)",
        "service = GmailReadBlock._build_service(credentials, **kwargs)",
        "result = self._remove_label(service, input_data.message_id, input_data.label_name)",
        "(yield ('result', result))",
        "def _remove_label(self, service, message_id: str, label_name: str) -> dict:\n    label_id = self._get_label_id(service, label_name)\n    if label_id:\n        service.users().messages().modify(userId='me', id=message_id, body={'removeLabelIds': [label_id]}).execute()\n        return {'status': 'Label removed successfully', 'label_id': label_id}\n    else:\n        return {'status': 'Label not found', 'label_name': label_name}",
        "label_id = self._get_label_id(service, label_name)",
        "label_id"
      ]
    },
    {
      "id": "52",
      "type": "block",
      "statements": [
        "service.users().messages().modify(userId='me', id=message_id, body={'removeLabelIds': [label_id]}).execute()",
        "return {'status': 'Label removed successfully', 'label_id': label_id}"
      ]
    },
    {
      "id": "53",
      "type": "block",
      "statements": [
        "return {'status': 'Label not found', 'label_name': label_name}"
      ]
    },
    {
      "id": "54",
      "type": "block",
      "statements": [
        "def _get_label_id(self, service, label_name: str) -> str | None:\n    results = service.users().labels().list(userId='me').execute()\n    labels = results.get('labels', [])\n    for label in labels:\n        if label['name'] == label_name:\n            return label['id']\n    return None",
        "results = service.users().labels().list(userId='me').execute()",
        "labels = results.get('labels', [])"
      ]
    },
    {
      "id": "55",
      "type": "block",
      "statements": [
        "label",
        "labels"
      ]
    },
    {
      "id": "56",
      "type": "block",
      "statements": [
        "label['name'] Eq label_name"
      ]
    },
    {
      "id": "57",
      "type": "block",
      "statements": [
        "return None"
      ]
    },
    {
      "id": "58",
      "type": "block",
      "statements": [
        "return label['id']"
      ]
    },
    {
      "id": "59",
      "type": "block",
      "statements": []
    },
    {
      "id": "60",
      "type": "block",
      "statements": []
    }
  ],
  "edges": [
    {
      "source": "1",
      "target": "2",
      "type": "next"
    },
    {
      "source": "2",
      "target": "3",
      "type": "true"
    },
    {
      "source": "2",
      "target": "4",
      "type": "false"
    },
    {
      "source": "3",
      "target": "2",
      "type": "next"
    },
    {
      "source": "5",
      "target": "6",
      "type": "next"
    },
    {
      "source": "6",
      "target": "7",
      "type": "true"
    },
    {
      "source": "6",
      "target": "8",
      "type": "false"
    },
    {
      "source": "7",
      "target": "6",
      "type": "next"
    },
    {
      "source": "9",
      "target": "10",
      "type": "true"
    },
    {
      "source": "9",
      "target": "11",
      "type": "false"
    },
    {
      "source": "10",
      "target": "13",
      "type": "next"
    },
    {
      "source": "11",
      "target": "19",
      "type": "true"
    },
    {
      "source": "11",
      "target": "20",
      "type": "false"
    },
    {
      "source": "13",
      "target": "14",
      "type": "true"
    },
    {
      "source": "13",
      "target": "15",
      "type": "false"
    },
    {
      "source": "14",
      "target": "16",
      "type": "true"
    },
    {
      "source": "14",
      "target": "17",
      "type": "false"
    },
    {
      "source": "15",
      "target": "12",
      "type": "next"
    },
    {
      "source": "17",
      "target": "18",
      "type": "next"
    },
    {
      "source": "18",
      "target": "13",
      "type": "next"
    },
    {
      "source": "20",
      "target": "21",
      "type": "next"
    },
    {
      "source": "21",
      "target": "12",
      "type": "next"
    },
    {
      "source": "22",
      "target": "23",
      "type": "true"
    },
    {
      "source": "22",
      "target": "24",
      "type": "false"
    },
    {
      "source": "23",
      "target": "26",
      "type": "next"
    },
    {
      "source": "24",
      "target": "25",
      "type": "next"
    },
    {
      "source": "26",
      "target": "27",
      "type": "true"
    },
    {
      "source": "26",
      "target": "28",
      "type": "false"
    },
    {
      "source": "27",
      "target": "29",
      "type": "true"
    },
    {
      "source": "27",
      "target": "30",
      "type": "false"
    },
    {
      "source": "28",
      "target": "25",
      "type": "next"
    },
    {
      "source": "29",
      "target": "31",
      "type": "next"
    },
    {
      "source": "30",
      "target": "31",
      "type": "next"
    },
    {
      "source": "31",
      "target": "26",
      "type": "next"
    },
    {
      "source": "33",
      "target": "34",
      "type": "true"
    },
    {
      "source": "33",
      "target": "35",
      "type": "false"
    },
    {
      "source": "34",
      "target": "36",
      "type": "next"
    },
    {
      "source": "35",
      "target": "36",
      "type": "next"
    },
    {
      "source": "40",
      "target": "41",
      "type": "true"
    },
    {
      "source": "40",
      "target": "42",
      "type": "false"
    },
    {
      "source": "41",
      "target": "43",
      "type": "next"
    },
    {
      "source": "42",
      "target": "43",
      "type": "next"
    },
    {
      "source": "44",
      "target": "45",
      "type": "next"
    },
    {
      "source": "45",
      "target": "46",
      "type": "true"
    },
    {
      "source": "45",
      "target": "47",
      "type": "false"
    },
    {
      "source": "46",
      "target": "48",
      "type": "true"
    },
    {
      "source": "46",
      "target": "49",
      "type": "false"
    },
    {
      "source": "49",
      "target": "50",
      "type": "next"
    },
    {
      "source": "50",
      "target": "45",
      "type": "next"
    },
    {
      "source": "51",
      "target": "52",
      "type": "true"
    },
    {
      "source": "51",
      "target": "53",
      "type": "false"
    },
    {
      "source": "54",
      "target": "55",
      "type": "next"
    },
    {
      "source": "55",
      "target": "56",
      "type": "true"
    },
    {
      "source": "55",
      "target": "57",
      "type": "false"
    },
    {
      "source": "56",
      "target": "58",
      "type": "true"
    },
    {
      "source": "56",
      "target": "59",
      "type": "false"
    },
    {
      "source": "59",
      "target": "60",
      "type": "next"
    },
    {
      "source": "60",
      "target": "55",
      "type": "next"
    }
  ]
}