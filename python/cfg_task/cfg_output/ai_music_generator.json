{
  "nodes": [
    {
      "id": "1",
      "type": "block",
      "statements": [
        "import logging",
        "import time",
        "from enum import Enum",
        "from typing import Literal",
        "import replicate",
        "from pydantic import SecretStr",
        "from backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema",
        "from backend.data.model import APIKeyCredentials, CredentialsField, CredentialsMetaInput, SchemaField",
        "from backend.integrations.providers import ProviderName",
        "logger = logging.getLogger(__name__)",
        "TEST_CREDENTIALS = APIKeyCredentials(id='01234567-89ab-cdef-0123-456789abcdef', provider='replicate', api_key=SecretStr('mock-replicate-api-key'), title='Mock Replicate API key', expires_at=None)",
        "TEST_CREDENTIALS_INPUT = {'provider': TEST_CREDENTIALS.provider, 'id': TEST_CREDENTIALS.id, 'type': TEST_CREDENTIALS.type, 'title': TEST_CREDENTIALS.type}",
        "class MusicGenModelVersion(str, Enum):\n    STEREO_LARGE = 'stereo-large'\n    MELODY_LARGE = 'melody-large'\n    LARGE = 'large'",
        "STEREO_LARGE = 'stereo-large'",
        "MELODY_LARGE = 'melody-large'",
        "LARGE = 'large'",
        "class AudioFormat(str, Enum):\n    WAV = 'wav'\n    MP3 = 'mp3'",
        "WAV = 'wav'",
        "MP3 = 'mp3'",
        "class NormalizationStrategy(str, Enum):\n    LOUDNESS = 'loudness'\n    CLIP = 'clip'\n    PEAK = 'peak'\n    RMS = 'rms'",
        "LOUDNESS = 'loudness'",
        "CLIP = 'clip'",
        "PEAK = 'peak'",
        "RMS = 'rms'",
        "class AIMusicGeneratorBlock(Block):\n\n    class Input(BlockSchema):\n        credentials: CredentialsMetaInput[Literal[ProviderName.REPLICATE], Literal['api_key']] = CredentialsField(description='The Replicate integration can be used with any API key with sufficient permissions for the blocks it is used on.')\n        prompt: str = SchemaField(description='A description of the music you want to generate', placeholder=\"e.g., 'An upbeat electronic dance track with heavy bass'\", title='Prompt')\n        music_gen_model_version: MusicGenModelVersion = SchemaField(description='Model to use for generation', default=MusicGenModelVersion.STEREO_LARGE, title='Model Version')\n        duration: int = SchemaField(description='Duration of the generated audio in seconds', default=8, title='Duration')\n        temperature: float = SchemaField(description=\"Controls the 'conservativeness' of the sampling process. Higher temperature means more diversity\", default=1.0, title='Temperature')\n        top_k: int = SchemaField(description='Reduces sampling to the k most likely tokens', default=250, title='Top K')\n        top_p: float = SchemaField(description='Reduces sampling to tokens with cumulative probability of p. When set to 0 (default), top_k sampling is used', default=0.0, title='Top P')\n        classifier_free_guidance: int = SchemaField(description='Increases the influence of inputs on the output. Higher values produce lower-variance outputs that adhere more closely to inputs', default=3, title='Classifier Free Guidance')\n        output_format: AudioFormat = SchemaField(description='Output format for generated audio', default=AudioFormat.WAV, title='Output Format')\n        normalization_strategy: NormalizationStrategy = SchemaField(description='Strategy for normalizing audio', default=NormalizationStrategy.LOUDNESS, title='Normalization Strategy')\n\n    class Output(BlockSchema):\n        result: str = SchemaField(description='URL of the generated audio file')\n        error: str = SchemaField(description='Error message if the model run failed')\n\n    def __init__(self):\n        super().__init__(id='44f6c8ad-d75c-4ae1-8209-aad1c0326928', description=\"This block generates music using Meta's MusicGen model on Replicate.\", categories={BlockCategory.AI}, input_schema=AIMusicGeneratorBlock.Input, output_schema=AIMusicGeneratorBlock.Output, test_input={'credentials': TEST_CREDENTIALS_INPUT, 'prompt': 'An upbeat electronic dance track with heavy bass', 'music_gen_model_version': MusicGenModelVersion.STEREO_LARGE, 'duration': 8, 'temperature': 1.0, 'top_k': 250, 'top_p': 0.0, 'classifier_free_guidance': 3, 'output_format': AudioFormat.WAV, 'normalization_strategy': NormalizationStrategy.LOUDNESS}, test_output=[('result', 'https://replicate.com/output/generated-audio-url.wav')], test_mock={'run_model': lambda api_key, music_gen_model_version, prompt, duration, temperature, top_k, top_p, classifier_free_guidance, output_format, normalization_strategy: 'https://replicate.com/output/generated-audio-url.wav'}, test_credentials=TEST_CREDENTIALS)\n\n    def run(self, input_data: Input, *, credentials: APIKeyCredentials, **kwargs) -> BlockOutput:\n        max_retries = 3\n        retry_delay = 5\n        last_error = None\n        for attempt in range(max_retries):\n            try:\n                logger.debug(f'[AIMusicGeneratorBlock] - Running model (attempt {attempt + 1})')\n                result = self.run_model(api_key=credentials.api_key, music_gen_model_version=input_data.music_gen_model_version, prompt=input_data.prompt, duration=input_data.duration, temperature=input_data.temperature, top_k=input_data.top_k, top_p=input_data.top_p, classifier_free_guidance=input_data.classifier_free_guidance, output_format=input_data.output_format, normalization_strategy=input_data.normalization_strategy)\n                if result and result != 'No output received':\n                    yield ('result', result)\n                    return\n                else:\n                    last_error = 'Model returned empty or invalid response'\n                    raise ValueError(last_error)\n            except Exception as e:\n                last_error = f'Unexpected error: {str(e)}'\n                logger.error(f'[AIMusicGeneratorBlock] - Error: {last_error}')\n                if attempt < max_retries - 1:\n                    time.sleep(retry_delay)\n                    continue\n        yield ('error', f'Failed after {max_retries} attempts. Last error: {last_error}')\n\n    def run_model(self, api_key: SecretStr, music_gen_model_version: MusicGenModelVersion, prompt: str, duration: int, temperature: float, top_k: int, top_p: float, classifier_free_guidance: int, output_format: AudioFormat, normalization_strategy: NormalizationStrategy):\n        client = replicate.Client(api_token=api_key.get_secret_value())\n        output = client.run('meta/musicgen:671ac645ce5e552cc63a54a2bbff63fcf798043055d2dac5fc9e36a837eedcfb', input={'prompt': prompt, 'music_gen_model_version': music_gen_model_version, 'duration': duration, 'temperature': temperature, 'top_k': top_k, 'top_p': top_p, 'classifier_free_guidance': classifier_free_guidance, 'output_format': output_format, 'normalization_strategy': normalization_strategy})\n        if isinstance(output, list) and len(output) > 0:\n            result_url = output[0]\n        elif isinstance(output, str):\n            result_url = output\n        else:\n            result_url = 'No output received'\n        return result_url",
        "class Input(BlockSchema):\n    credentials: CredentialsMetaInput[Literal[ProviderName.REPLICATE], Literal['api_key']] = CredentialsField(description='The Replicate integration can be used with any API key with sufficient permissions for the blocks it is used on.')\n    prompt: str = SchemaField(description='A description of the music you want to generate', placeholder=\"e.g., 'An upbeat electronic dance track with heavy bass'\", title='Prompt')\n    music_gen_model_version: MusicGenModelVersion = SchemaField(description='Model to use for generation', default=MusicGenModelVersion.STEREO_LARGE, title='Model Version')\n    duration: int = SchemaField(description='Duration of the generated audio in seconds', default=8, title='Duration')\n    temperature: float = SchemaField(description=\"Controls the 'conservativeness' of the sampling process. Higher temperature means more diversity\", default=1.0, title='Temperature')\n    top_k: int = SchemaField(description='Reduces sampling to the k most likely tokens', default=250, title='Top K')\n    top_p: float = SchemaField(description='Reduces sampling to tokens with cumulative probability of p. When set to 0 (default), top_k sampling is used', default=0.0, title='Top P')\n    classifier_free_guidance: int = SchemaField(description='Increases the influence of inputs on the output. Higher values produce lower-variance outputs that adhere more closely to inputs', default=3, title='Classifier Free Guidance')\n    output_format: AudioFormat = SchemaField(description='Output format for generated audio', default=AudioFormat.WAV, title='Output Format')\n    normalization_strategy: NormalizationStrategy = SchemaField(description='Strategy for normalizing audio', default=NormalizationStrategy.LOUDNESS, title='Normalization Strategy')",
        "credentials: CredentialsMetaInput[Literal[ProviderName.REPLICATE], Literal['api_key']] = CredentialsField(description='The Replicate integration can be used with any API key with sufficient permissions for the blocks it is used on.')",
        "prompt: str = SchemaField(description='A description of the music you want to generate', placeholder=\"e.g., 'An upbeat electronic dance track with heavy bass'\", title='Prompt')",
        "music_gen_model_version: MusicGenModelVersion = SchemaField(description='Model to use for generation', default=MusicGenModelVersion.STEREO_LARGE, title='Model Version')",
        "duration: int = SchemaField(description='Duration of the generated audio in seconds', default=8, title='Duration')",
        "temperature: float = SchemaField(description=\"Controls the 'conservativeness' of the sampling process. Higher temperature means more diversity\", default=1.0, title='Temperature')",
        "top_k: int = SchemaField(description='Reduces sampling to the k most likely tokens', default=250, title='Top K')",
        "top_p: float = SchemaField(description='Reduces sampling to tokens with cumulative probability of p. When set to 0 (default), top_k sampling is used', default=0.0, title='Top P')",
        "classifier_free_guidance: int = SchemaField(description='Increases the influence of inputs on the output. Higher values produce lower-variance outputs that adhere more closely to inputs', default=3, title='Classifier Free Guidance')",
        "output_format: AudioFormat = SchemaField(description='Output format for generated audio', default=AudioFormat.WAV, title='Output Format')",
        "normalization_strategy: NormalizationStrategy = SchemaField(description='Strategy for normalizing audio', default=NormalizationStrategy.LOUDNESS, title='Normalization Strategy')",
        "class Output(BlockSchema):\n    result: str = SchemaField(description='URL of the generated audio file')\n    error: str = SchemaField(description='Error message if the model run failed')",
        "result: str = SchemaField(description='URL of the generated audio file')",
        "error: str = SchemaField(description='Error message if the model run failed')",
        "def __init__(self):\n    super().__init__(id='44f6c8ad-d75c-4ae1-8209-aad1c0326928', description=\"This block generates music using Meta's MusicGen model on Replicate.\", categories={BlockCategory.AI}, input_schema=AIMusicGeneratorBlock.Input, output_schema=AIMusicGeneratorBlock.Output, test_input={'credentials': TEST_CREDENTIALS_INPUT, 'prompt': 'An upbeat electronic dance track with heavy bass', 'music_gen_model_version': MusicGenModelVersion.STEREO_LARGE, 'duration': 8, 'temperature': 1.0, 'top_k': 250, 'top_p': 0.0, 'classifier_free_guidance': 3, 'output_format': AudioFormat.WAV, 'normalization_strategy': NormalizationStrategy.LOUDNESS}, test_output=[('result', 'https://replicate.com/output/generated-audio-url.wav')], test_mock={'run_model': lambda api_key, music_gen_model_version, prompt, duration, temperature, top_k, top_p, classifier_free_guidance, output_format, normalization_strategy: 'https://replicate.com/output/generated-audio-url.wav'}, test_credentials=TEST_CREDENTIALS)",
        "super().__init__()",
        "def run(self, input_data: Input, *, credentials: APIKeyCredentials, **kwargs) -> BlockOutput:\n    max_retries = 3\n    retry_delay = 5\n    last_error = None\n    for attempt in range(max_retries):\n        try:\n            logger.debug(f'[AIMusicGeneratorBlock] - Running model (attempt {attempt + 1})')\n            result = self.run_model(api_key=credentials.api_key, music_gen_model_version=input_data.music_gen_model_version, prompt=input_data.prompt, duration=input_data.duration, temperature=input_data.temperature, top_k=input_data.top_k, top_p=input_data.top_p, classifier_free_guidance=input_data.classifier_free_guidance, output_format=input_data.output_format, normalization_strategy=input_data.normalization_strategy)\n            if result and result != 'No output received':\n                yield ('result', result)\n                return\n            else:\n                last_error = 'Model returned empty or invalid response'\n                raise ValueError(last_error)\n        except Exception as e:\n            last_error = f'Unexpected error: {str(e)}'\n            logger.error(f'[AIMusicGeneratorBlock] - Error: {last_error}')\n            if attempt < max_retries - 1:\n                time.sleep(retry_delay)\n                continue\n    yield ('error', f'Failed after {max_retries} attempts. Last error: {last_error}')",
        "max_retries = 3",
        "retry_delay = 5",
        "last_error = None"
      ]
    },
    {
      "id": "2",
      "type": "block",
      "statements": [
        "attempt",
        "range(max_retries)"
      ]
    },
    {
      "id": "3",
      "type": "block",
      "statements": [
        "try:\n    logger.debug(f'[AIMusicGeneratorBlock] - Running model (attempt {attempt + 1})')\n    result = self.run_model(api_key=credentials.api_key, music_gen_model_version=input_data.music_gen_model_version, prompt=input_data.prompt, duration=input_data.duration, temperature=input_data.temperature, top_k=input_data.top_k, top_p=input_data.top_p, classifier_free_guidance=input_data.classifier_free_guidance, output_format=input_data.output_format, normalization_strategy=input_data.normalization_strategy)\n    if result and result != 'No output received':\n        yield ('result', result)\n        return\n    else:\n        last_error = 'Model returned empty or invalid response'\n        raise ValueError(last_error)\nexcept Exception as e:\n    last_error = f'Unexpected error: {str(e)}'\n    logger.error(f'[AIMusicGeneratorBlock] - Error: {last_error}')\n    if attempt < max_retries - 1:\n        time.sleep(retry_delay)\n        continue",
        "logger.debug(f'[AIMusicGeneratorBlock] - Running model (attempt {attempt + 1})')",
        "result = self.run_model(api_key=credentials.api_key, music_gen_model_version=input_data.music_gen_model_version, prompt=input_data.prompt, duration=input_data.duration, temperature=input_data.temperature, top_k=input_data.top_k, top_p=input_data.top_p, classifier_free_guidance=input_data.classifier_free_guidance, output_format=input_data.output_format, normalization_strategy=input_data.normalization_strategy)",
        "result and result != 'No output received'"
      ]
    },
    {
      "id": "4",
      "type": "block",
      "statements": [
        "(yield ('error', f'Failed after {max_retries} attempts. Last error: {last_error}'))",
        "def run_model(self, api_key: SecretStr, music_gen_model_version: MusicGenModelVersion, prompt: str, duration: int, temperature: float, top_k: int, top_p: float, classifier_free_guidance: int, output_format: AudioFormat, normalization_strategy: NormalizationStrategy):\n    client = replicate.Client(api_token=api_key.get_secret_value())\n    output = client.run('meta/musicgen:671ac645ce5e552cc63a54a2bbff63fcf798043055d2dac5fc9e36a837eedcfb', input={'prompt': prompt, 'music_gen_model_version': music_gen_model_version, 'duration': duration, 'temperature': temperature, 'top_k': top_k, 'top_p': top_p, 'classifier_free_guidance': classifier_free_guidance, 'output_format': output_format, 'normalization_strategy': normalization_strategy})\n    if isinstance(output, list) and len(output) > 0:\n        result_url = output[0]\n    elif isinstance(output, str):\n        result_url = output\n    else:\n        result_url = 'No output received'\n    return result_url",
        "client = replicate.Client(api_token=api_key.get_secret_value())",
        "output = client.run('meta/musicgen:671ac645ce5e552cc63a54a2bbff63fcf798043055d2dac5fc9e36a837eedcfb', input={'prompt': prompt, 'music_gen_model_version': music_gen_model_version, 'duration': duration, 'temperature': temperature, 'top_k': top_k, 'top_p': top_p, 'classifier_free_guidance': classifier_free_guidance, 'output_format': output_format, 'normalization_strategy': normalization_strategy})",
        "isinstance(output, list) and len(output) > 0"
      ]
    },
    {
      "id": "5",
      "type": "block",
      "statements": [
        "(yield ('result', result))",
        "return"
      ]
    },
    {
      "id": "6",
      "type": "block",
      "statements": [
        "last_error = 'Model returned empty or invalid response'",
        "raise ValueError(last_error)"
      ]
    },
    {
      "id": "7",
      "type": "block",
      "statements": [
        "last_error = f'Unexpected error: {str(e)}'",
        "logger.error(f'[AIMusicGeneratorBlock] - Error: {last_error}')",
        "attempt Lt max_retries Sub 1"
      ]
    },
    {
      "id": "8",
      "type": "block",
      "statements": [
        "time.sleep(retry_delay)",
        "continue"
      ]
    },
    {
      "id": "9",
      "type": "block",
      "statements": []
    },
    {
      "id": "10",
      "type": "block",
      "statements": []
    },
    {
      "id": "11",
      "type": "block",
      "statements": [
        "result_url = output[0]"
      ]
    },
    {
      "id": "12",
      "type": "block",
      "statements": [
        "isinstance(output, str)"
      ]
    },
    {
      "id": "13",
      "type": "block",
      "statements": [
        "return result_url"
      ]
    },
    {
      "id": "14",
      "type": "block",
      "statements": [
        "result_url = output"
      ]
    },
    {
      "id": "15",
      "type": "block",
      "statements": [
        "result_url = 'No output received'"
      ]
    },
    {
      "id": "16",
      "type": "block",
      "statements": []
    }
  ],
  "edges": [
    {
      "source": "1",
      "target": "2",
      "type": "next"
    },
    {
      "source": "2",
      "target": "3",
      "type": "true"
    },
    {
      "source": "2",
      "target": "4",
      "type": "false"
    },
    {
      "source": "3",
      "target": "5",
      "type": "true"
    },
    {
      "source": "3",
      "target": "6",
      "type": "false"
    },
    {
      "source": "4",
      "target": "11",
      "type": "true"
    },
    {
      "source": "4",
      "target": "12",
      "type": "false"
    },
    {
      "source": "6",
      "target": "7",
      "type": "next"
    },
    {
      "source": "7",
      "target": "8",
      "type": "true"
    },
    {
      "source": "7",
      "target": "9",
      "type": "false"
    },
    {
      "source": "8",
      "target": "10",
      "type": "next"
    },
    {
      "source": "9",
      "target": "10",
      "type": "next"
    },
    {
      "source": "10",
      "target": "2",
      "type": "next"
    },
    {
      "source": "11",
      "target": "13",
      "type": "next"
    },
    {
      "source": "12",
      "target": "14",
      "type": "true"
    },
    {
      "source": "12",
      "target": "15",
      "type": "false"
    },
    {
      "source": "14",
      "target": "16",
      "type": "next"
    },
    {
      "source": "15",
      "target": "16",
      "type": "next"
    },
    {
      "source": "16",
      "target": "13",
      "type": "next"
    }
  ]
}