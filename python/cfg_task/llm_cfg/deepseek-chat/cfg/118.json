{
    "nodes": [
        {
            "id": "chunk_0_GlobalBlock_1",
            "code": "\"\"\"\nauthor: Aayush Soni\nGiven n pairs of parentheses, write a function to generate all\ncombinations of well-formed parentheses.\nInput: n = 2\nOutput: [\"(())\",\"()()\"]\nLeetcode link: https://leetcode.com/problems/generate-parentheses/description/\n\"\"\"\n"
        },
        {
            "id": "chunk_0_GlobalBlock_2",
            "code": "\n\n\n"
        },
        {
            "id": "chunk_1_backtrack_1",
            "code": "def backtrack(\n    partial: str, open_count: int, close_count: int, n: int, result: list[str]\n) -> None:\n"
        },
        {
            "id": "chunk_1_backtrack_2",
            "code": "    \"\"\"\n    Generate valid combinations of balanced parentheses using recursion.\n\n    :param partial: A string representing the current combination.\n    :param open_count: An integer representing the count of open parentheses.\n    :param close_count: An integer representing the count of close parentheses.\n    :param n: An integer representing the total number of pairs.\n    :param result: A list to store valid combinations.\n    :return: None\n\n    This function uses recursion to explore all possible combinations,\n    ensuring that at each step, the parentheses remain balanced.\n\n    Example:\n    >>> result = []\n    >>> backtrack(\"\", 0, 0, 2, result)\n    >>> result\n    ['(())', '()()']\n    \"\"\"\n"
        },
        {
            "id": "chunk_1_backtrack_3",
            "code": "    if len(partial) == 2 * n:\n        # When the combination is complete, add it to the result.\n        result.append(partial)\n        return\n"
        },
        {
            "id": "chunk_1_backtrack_4",
            "code": "    if open_count < n:\n        # If we can add an open parenthesis, do so, and recurse.\n        backtrack(partial + \"(\", open_count + 1, close_count, n, result)\n"
        },
        {
            "id": "chunk_1_backtrack_5",
            "code": "    if close_count < open_count:\n        # If we can add a close parenthesis (it won't make the combination invalid),\n        # do so, and recurse.\n        backtrack(partial + \")\", open_count, close_count + 1, n, result)\n"
        },
        {
            "id": "chunk_2_generate_parenthesis_1",
            "code": "def generate_parenthesis(n: int) -> list[str]:\n"
        },
        {
            "id": "chunk_2_generate_parenthesis_2",
            "code": "    \"\"\"\n    Generate valid combinations of balanced parentheses for a given n.\n\n    :param n: An integer representing the number of pairs of parentheses.\n    :return: A list of strings with valid combinations.\n\n    This function uses a recursive approach to generate the combinations.\n\n    Time Complexity: O(2^(2n)) - In the worst case, we have 2^(2n) combinations.\n    Space Complexity: O(n) - where 'n' is the number of pairs.\n\n    Example 1:\n    >>> generate_parenthesis(3)\n    ['((()))', '(()())', '(())()', '()(())', '()()()']\n\n    Example 2:\n    >>> generate_parenthesis(1)\n    ['()']\n    \"\"\"\n"
        },
        {
            "id": "chunk_2_generate_parenthesis_3",
            "code": "\n"
        },
        {
            "id": "chunk_2_generate_parenthesis_4",
            "code": "    result: list[str] = []\n"
        },
        {
            "id": "chunk_2_generate_parenthesis_5",
            "code": "    backtrack(\"\", 0, 0, n, result)\n"
        },
        {
            "id": "chunk_2_generate_parenthesis_6",
            "code": "    return result\n"
        },
        {
            "id": "chunk_2_generate_parenthesis_7",
            "code": "\n"
        },
        {
            "id": "chunk_3_GlobalBlock_1",
            "code": "if __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n"
        }
    ],
    "edges": [
        {
            "from": "chunk_0_GlobalBlock_1",
            "to": "chunk_0_GlobalBlock_2"
        },
        {
            "from": "chunk_1_backtrack_1",
            "to": "chunk_1_backtrack_2"
        },
        {
            "from": "chunk_1_backtrack_2",
            "to": "chunk_1_backtrack_3"
        },
        {
            "from": "chunk_1_backtrack_3",
            "to": "chunk_1_backtrack_4"
        },
        {
            "from": "chunk_1_backtrack_3",
            "to": "chunk_1_backtrack_5"
        },
        {
            "from": "chunk_1_backtrack_4",
            "to": "chunk_1_backtrack_3"
        },
        {
            "from": "chunk_1_backtrack_5",
            "to": "chunk_1_backtrack_3"
        },
        {
            "from": "chunk_2_generate_parenthesis_1",
            "to": "chunk_2_generate_parenthesis_2"
        },
        {
            "from": "chunk_2_generate_parenthesis_2",
            "to": "chunk_2_generate_parenthesis_3"
        },
        {
            "from": "chunk_2_generate_parenthesis_3",
            "to": "chunk_2_generate_parenthesis_4"
        },
        {
            "from": "chunk_2_generate_parenthesis_4",
            "to": "chunk_2_generate_parenthesis_5"
        },
        {
            "from": "chunk_2_generate_parenthesis_5",
            "to": "chunk_2_generate_parenthesis_6"
        },
        {
            "from": "chunk_2_generate_parenthesis_6",
            "to": "chunk_2_generate_parenthesis_7"
        }
    ]
}