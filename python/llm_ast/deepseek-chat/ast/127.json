{
    "type": "Program",
    "name": "Global",
    "range": [
        0,
        542
    ],
    "children": [
        {
            "type": "ImportDeclaration",
            "name": "annotations",
            "range": [
                0,
                3
            ],
            "children": [
                {
                    "type": "ModuleSpecifier",
                    "name": "__future__",
                    "range": [
                        1,
                        1
                    ],
                    "children": [],
                    "content": "__future__"
                }
            ],
            "content": "from __future__ import annotations"
        },
        {
            "type": "FunctionDecl",
            "name": "solve_maze",
            "range": [
                7,
                206
            ],
            "children": [
                {
                    "type": "ParameterList",
                    "name": "parameters",
                    "range": [
                        9,
                        42
                    ],
                    "children": [
                        {
                            "type": "Parameter",
                            "name": "maze",
                            "range": [
                                11,
                                19
                            ],
                            "children": [],
                            "content": "maze:list[list[int]]"
                        },
                        {
                            "type": "Parameter",
                            "name": "source_row",
                            "range": [
                                22,
                                24
                            ],
                            "children": [],
                            "content": "source_row:int"
                        },
                        {
                            "type": "Parameter",
                            "name": "source_column",
                            "range": [
                                27,
                                29
                            ],
                            "children": [],
                            "content": "source_column:int"
                        },
                        {
                            "type": "Parameter",
                            "name": "destination_row",
                            "range": [
                                32,
                                34
                            ],
                            "children": [],
                            "content": "destination_row:int"
                        },
                        {
                            "type": "Parameter",
                            "name": "destination_column",
                            "range": [
                                37,
                                39
                            ],
                            "children": [],
                            "content": "destination_column:int"
                        }
                    ],
                    "content": "(\nmaze:list[list[int]],\nsource_row:int,\nsource_column:int,\ndestination_row:int,\ndestination_column:int,\n)"
                },
                {
                    "type": "ReturnType",
                    "name": "return_type",
                    "range": [
                        43,
                        51
                    ],
                    "children": [],
                    "content": "->list[list[int]]"
                },
                {
                    "type": "FunctionBody",
                    "name": "body",
                    "range": [
                        54,
                        206
                    ],
                    "children": [
                        {
                            "type": "Docstring",
                            "name": "docstring",
                            "range": [
                                54,
                                60
                            ],
                            "children": [],
                            "content": "\"\"\" \\n     This method solves the \" rat in maze \" problem. \\n     Parameters : \\n         - maze: A two dimensional matrix of zeros and ones. \\n         - source_row: The row index of the starting point. \\n         - source_column: The column index of the starting point. \\n         - destination_row: The row index of the destination point. \\n         - destination_column: The column index of the destination point. \\n     Returns: \\n         - solution: A 2D matrix representing the solution path if it exists. \\n     Raises: \\n         - ValueError: If no solution exists or if the source or \\n             destination coordinates are invalid. \\n     Description: \\n         This method navigates through a maze represented as an n by n matrix, \\n         starting from a specified source cell and \\n         aiming to reach a destination cell. \\n         The maze consists of walls (1s) and open paths (0s). \\n         By providing custom row and column values, the source and destination \\n         cells can be adjusted. \\n     >>> maze = [[0, 1, 0, 1, 1], \\n     ...         [0, 0, 0, 0, 0], \\n     ...         [1, 0, 1, 0, 1], \\n     ...         [0, 0, 1, 0, 0], \\n     ...         [1, 0, 0, 1, 0]] \\n     >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE \\n     [[0, 1, 1, 1, 1], \\n     [0, 0, 0, 0, 1], \\n     [1, 1, 1, 0, 1], \\n     [1, 1, 1, 0, 0], \\n     [1, 1, 1, 1, 0]] \\n  \\n     Note: \\n         In the output maze, the zeros (0s) represent one of the possible \\n         paths from the source to the destination. \\n  \\n     >>> maze = [[0, 1, 0, 1, 1], \\n     ...         [0, 0, 0, 0, 0], \\n     ...         [0, 0, 0, 0, 1], \\n     ...         [0, 0, 0, 0, 0], \\n     ...         [0, 0, 0, 0, 0]] \\n     >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE \\n     [[0, 1, 1, 1, 1], \\n     [0, 1, 1, 1, 1], \\n     [0, 1, 1, 1, 1], \\n     [0, 1, 1, 1, 1], \\n     [0, 0, 0, 0, 0]] \\n  \\n     >>> maze = [[0, 0, 0], \\n     ...         [0, 1, 0], \\n     ...         [1, 0, 0]] \\n     >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE \\n     [[0, 0, 0], \\n     [1, 1, 0], \\n     [1, 1, 0]] \\n  \\n     >>> maze = [[1, 0, 0], \\n     ...         [0, 1, 0], \\n     ...         [1, 0, 0]] \\n     >>> solve_maze(maze,0,1,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE \\n     [[1, 0, 0], \\n     [1, 1, 0], \\n     [1, 1, 0]] \\n  \\n     >>> maze = [[1, 1, 0, 0, 1, 0, 0, 1], \\n     ...         [1, 0, 1, 0, 0, 1, 1, 1], \\n     ...         [0, 1, 0, 1, 0, 0, 1, 0], \\n     ...         [1, 1, 1, 0, 0, 1, 0, 1], \\n     ...         [0, 1, 0, 0, 1, 0, 1, 1], \\n     ...         [0, 0, 0, 1, 1, 1, 0, 1], \\n     ...         [0, 1, 0, 1, 0, 1, 1, 1], \\n     ...         [1, 1, 0, 0, 0, 0, 0, 1]] \\n     >>> solve_maze(maze,0,2,len(maze)-1,2)  # doctest: +NORMALIZE_WHITESPACE \\n     [[1, 1, 0, 0, 1, 1, 1, 1], \\n     [1, 1, 1, 0, 0, 1, 1, 1], \\n     [1, 1, 1, 1, 0, 1, 1, 1], \\n     [1, 1, 1, 0, 0, 1, 1, 1], \\n     [1, 1, 0, 0, 1, 1, 1, 1], \\n     [1, 1, 0, 1, 1, 1, 1, 1], \\n     [1, 1, 0, 1, 1, 1, 1, 1], \\n     [1, 1, 0, 1, 1, 1, 1, 1]] \\n     >>> maze = [[1, 0, 0], \\n     ...         [0, 1, 1], \\n     ...         [1, 0, 1]] \\n     >>> solve_maze(maze,0,1,len(maze)-1,len(maze)-1) \\n     Traceback (most recent call last): \\n         ... \\n     ValueError: No solution exists! \\n  \\n     >>> maze = [[0, 0], \\n     ...         [1, 1]] \\n     >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1) \\n     Traceback (most recent call last): \\n         ... \\n     ValueError: No solution exists! \\n  \\n     >>> maze = [[0, 1], \\n     ...         [1, 0]] \\n     >>> solve_maze(maze,2,0,len(maze)-1,len(maze)-1) \\n     Traceback (most recent call last): \\n         ... \\n     ValueError: Invalid source or destination coordinates \\n  \\n     >>> maze = [[1, 0, 0], \\n     ...         [0, 1, 0], \\n     ...         [1, 0, 0]] \\n     >>> solve_maze(maze,0,1,len(maze),len(maze)-1) \\n     Traceback (most recent call last): \\n         ... \\n     ValueError: Invalid source or destination coordinates \\n     \"\"\""
                        },
                        {
                            "type": "VariableDecl",
                            "name": "size",
                            "range": [
                                62,
                                67
                            ],
                            "children": [],
                            "content": "size=len(maze)"
                        },
                        {
                            "type": "IfStatement",
                            "name": "if_statement",
                            "range": [
                                80,
                                136
                            ],
                            "children": [
                                {
                                    "type": "Condition",
                                    "name": "condition",
                                    "range": [
                                        82,
                                        129
                                    ],
                                    "children": [],
                                    "content": "(0<=source_row<=size-1and0<=source_column<=size-1)or(\nnot(0<=destination_row<=size-1and0<=destination_column<=size-1)\n)"
                                },
                                {
                                    "type": "RaiseStatement",
                                    "name": "raise_statement",
                                    "range": [
                                        132,
                                        136
                                    ],
                                    "children": [],
                                    "content": "raise ValueError(\"Invalid source or destination coordinates\")"
                                }
                            ],
                            "content": "if not(0<=source_row<=size-1and0<=source_column<=size-1)or(\nnot(0<=destination_row<=size-1and0<=destination_column<=size-1)\n):\nraise ValueError(\"Invalid source or destination coordinates\")"
                        },
                        {
                            "type": "VariableDecl",
                            "name": "solutions",
                            "range": [
                                150,
                                170
                            ],
                            "children": [],
                            "content": "solutions=[[1for _ in range(size)]for _ in range(size)]"
                        },
                        {
                            "type": "VariableAssignment",
                            "name": "solved",
                            "range": [
                                172,
                                189
                            ],
                            "children": [],
                            "content": "solved=run_maze(\nmaze,source_row,source_column,destination_row,destination_column,solutions\n)"
                        },
                        {
                            "type": "IfStatement",
                            "name": "if_statement",
                            "range": [
                                191,
                                205
                            ],
                            "children": [
                                {
                                    "type": "Condition",
                                    "name": "condition",
                                    "range": [
                                        192,
                                        193
                                    ],
                                    "children": [],
                                    "content": "solved:"
                                },
                                {
                                    "type": "ReturnStatement",
                                    "name": "return_statement",
                                    "range": [
                                        195,
                                        196
                                    ],
                                    "children": [],
                                    "content": "return solutions"
                                },
                                {
                                    "type": "ElseStatement",
                                    "name": "else_statement",
                                    "range": [
                                        198,
                                        205
                                    ],
                                    "children": [
                                        {
                                            "type": "RaiseStatement",
                                            "name": "raise_statement",
                                            "range": [
                                                201,
                                                205
                                            ],
                                            "children": [],
                                            "content": "raise ValueError(\"No solution exists!\")"
                                        }
                                    ],
                                    "content": "else:\nraise ValueError(\"No solution exists!\")"
                                }
                            ],
                            "content": "if solved:\nreturn solutions\nelse:\nraise ValueError(\"No solution exists!\")"
                        }
                    ],
                    "content": "\"\"\" \\n     This method solves the \" rat in maze \" problem. \\n     Parameters : \\n         - maze: A two dimensional matrix of zeros and ones. \\n         - source_row: The row index of the starting point. \\n         - source_column: The column index of the starting point. \\n         - destination_row: The row index of the destination point. \\n         - destination_column: The column index of the destination point. \\n     Returns: \\n         - solution: A 2D matrix representing the solution path if it exists. \\n     Raises: \\n         - ValueError: If no solution exists or if the source or \\n             destination coordinates are invalid. \\n     Description: \\n         This method navigates through a maze represented as an n by n matrix, \\n         starting from a specified source cell and \\n         aiming to reach a destination cell. \\n         The maze consists of walls (1s) and open paths (0s). \\n         By providing custom row and column values, the source and destination \\n         cells can be adjusted. \\n     >>> maze = [[0, 1, 0, 1, 1], \\n     ...         [0, 0, 0, 0, 0], \\n     ...         [1, 0, 1, 0, 1], \\n     ...         [0, 0, 1, 0, 0], \\n     ...         [1, 0, 0, 1, 0]] \\n     >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE \\n     [[0, 1, 1, 1, 1], \\n     [0, 0, 0, 0, 1], \\n     [1, 1, 1, 0, 1], \\n     [1, 1, 1, 0, 0], \\n     [1, 1, 1, 1, 0]] \\n  \\n     Note: \\n         In the output maze, the zeros (0s) represent one of the possible \\n         paths from the source to the destination. \\n  \\n     >>> maze = [[0, 1, 0, 1, 1], \\n     ...         [0, 0, 0, 0, 0], \\n     ...         [0, 0, 0, 0, 1], \\n     ...         [0, 0, 0, 0, 0], \\n     ...         [0, 0, 0, 0, 0]] \\n     >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE \\n     [[0, 1, 1, 1, 1], \\n     [0, 1, 1, 1, 1], \\n     [0, 1, 1, 1, 1], \\n     [0, 1, 1, 1, 1], \\n     [0, 0, 0, 0, 0]] \\n  \\n     >>> maze = [[0, 0, 0], \\n     ...         [0, 1, 0], \\n     ...         [1, 0, 0]] \\n     >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE \\n     [[0, 0, 0], \\n     [1, 1, 0], \\n     [1, 1, 0]] \\n  \\n     >>> maze = [[1, 0, 0], \\n     ...         [0, 1, 0], \\n     ...         [1, 0, 0]] \\n     >>> solve_maze(maze,0,1,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE \\n     [[1, 0, 0], \\n     [1, 1, 0], \\n     [1, 1, 0]] \\n  \\n     >>> maze = [[1, 1, 0, 0, 1, 0, 0, 1], \\n     ...         [1, 0, 1, 0, 0, 1, 1, 1], \\n     ...         [0, 1, 0, 1, 0, 0, 1, 0], \\n     ...         [1, 1, 1, 0, 0, 1, 0, 1], \\n     ...         [0, 1, 0, 0, 1, 0, 1, 1], \\n     ...         [0, 0, 0, 1, 1, 1, 0, 1], \\n     ...         [0, 1, 0, 1, 0, 1, 1, 1], \\n     ...         [1, 1, 0, 0, 0, 0, 0, 1]] \\n     >>> solve_maze(maze,0,2,len(maze)-1,2)  # doctest: +NORMALIZE_WHITESPACE \\n     [[1, 1, 0, 0, 1, 1, 1, 1], \\n     [1, 1, 1, 0, 0, 1, 1, 1], \\n     [1, 1, 1, 1, 0, 1, 1, 1], \\n     [1, 1, 1, 0, 0, 1, 1, 1], \\n     [1, 1, 0, 0, 1, 1, 1, 1], \\n     [1, 1, 0, 1, 1, 1, 1, 1], \\n     [1, 1, 0, 1, 1, 1, 1, 1], \\n     [1, 1, 0, 1, 1, 1, 1, 1]] \\n     >>> maze = [[1, 0, 0], \\n     ...         [0, 1, 1], \\n     ...         [1, 0, 1]] \\n     >>> solve_maze(maze,0,1,len(maze)-1,len(maze)-1) \\n     Traceback (most recent call last): \\n         ... \\n     ValueError: No solution exists! \\n  \\n     >>> maze = [[0, 0], \\n     ...         [1, 1]] \\n     >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1) \\n     Traceback (most recent call last): \\n         ... \\n     ValueError: No solution exists! \\n  \\n     >>> maze = [[0, 1], \\n     ...         [1, 0]] \\n     >>> solve_maze(maze,2,0,len(maze)-1,len(maze)-1) \\n     Traceback (most recent call last): \\n         ... \\n     ValueError: Invalid source or destination coordinates \\n  \\n     >>> maze = [[1, 0, 0], \\n     ...         [0, 1, 0], \\n     ...         [1, 0, 0]] \\n     >>> solve_maze(maze,0,1,len(maze),len(maze)-1) \\n     Traceback (most recent call last): \\n         ... \\n     ValueError: Invalid source or destination coordinates \\n     \"\"\"\nsize=len(maze)\n#Check if source and destination coordinates are Invalid.\nif not(0<=source_row<=size-1and0<=source_column<=size-1)or(\nnot(0<=destination_row<=size-1and0<=destination_column<=size-1)\n):\nraise ValueError(\"Invalid source or destination coordinates\")\n#We need to create solution object to save path.\nsolutions=[[1for _ in range(size)]for _ in range(size)]\nsolved=run_maze(\nmaze,source_row,source_column,destination_row,destination_column,solutions\n)\nif solved:\nreturn solutions\nelse:\nraise ValueError(\"No solution exists!\")\n"
                }
            ],
            "content": "def solve_maze(\nmaze:list[list[int]],\nsource_row:int,\nsource_column:int,\ndestination_row:int,\ndestination_column:int,\n)->list[list[int]]:\n\"\"\" \\n     This method solves the \" rat in maze \" problem. \\n     Parameters : \\n         - maze: A two dimensional matrix of zeros and ones. \\n         - source_row: The row index of the starting point. \\n         - source_column: The column index of the starting point. \\n         - destination_row: The row index of the destination point. \\n         - destination_column: The column index of the destination point. \\n     Returns: \\n         - solution: A 2D matrix representing the solution path if it exists. \\n     Raises: \\n         - ValueError: If no solution exists or if the source or \\n             destination coordinates are invalid. \\n     Description: \\n         This method navigates through a maze represented as an n by n matrix, \\n         starting from a specified source cell and \\n         aiming to reach a destination cell. \\n         The maze consists of walls (1s) and open paths (0s). \\n         By providing custom row and column values, the source and destination \\n         cells can be adjusted. \\n     >>> maze = [[0, 1, 0, 1, 1], \\n     ...         [0, 0, 0, 0, 0], \\n     ...         [1, 0, 1, 0, 1], \\n     ...         [0, 0, 1, 0, 0], \\n     ...         [1, 0, 0, 1, 0]] \\n     >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE \\n     [[0, 1, 1, 1, 1], \\n     [0, 0, 0, 0, 1], \\n     [1, 1, 1, 0, 1], \\n     [1, 1, 1, 0, 0], \\n     [1, 1, 1, 1, 0]] \\n  \\n     Note: \\n         In the output maze, the zeros (0s) represent one of the possible \\n         paths from the source to the destination. \\n  \\n     >>> maze = [[0, 1, 0, 1, 1], \\n     ...         [0, 0, 0, 0, 0], \\n     ...         [0, 0, 0, 0, 1], \\n     ...         [0, 0, 0, 0, 0], \\n     ...         [0, 0, 0, 0, 0]] \\n     >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE \\n     [[0, 1, 1, 1, 1], \\n     [0, 1, 1, 1, 1], \\n     [0, 1, 1, 1, 1], \\n     [0, 1, 1, 1, 1], \\n     [0, 0, 0, 0, 0]] \\n  \\n     >>> maze = [[0, 0, 0], \\n     ...         [0, 1, 0], \\n     ...         [1, 0, 0]] \\n     >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE \\n     [[0, 0, 0], \\n     [1, 1, 0], \\n     [1, 1, 0]] \\n  \\n     >>> maze = [[1, 0, 0], \\n     ...         [0, 1, 0], \\n     ...         [1, 0, 0]] \\n     >>> solve_maze(maze,0,1,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE \\n     [[1, 0, 0], \\n     [1, 1, 0], \\n     [1, 1, 0]] \\n  \\n     >>> maze = [[1, 1, 0, 0, 1, 0, 0, 1], \\n     ...         [1, 0, 1, 0, 0, 1, 1, 1], \\n     ...         [0, 1, 0, 1, 0, 0, 1, 0], \\n     ...         [1, 1, 1, 0, 0, 1, 0, 1], \\n     ...         [0, 1, 0, 0, 1, 0, 1, 1], \\n     ...         [0, 0, 0, 1, 1, 1, 0, 1], \\n     ...         [0, 1, 0, 1, 0, 1, 1, 1], \\n     ...         [1, 1, 0, 0, 0, 0, 0, 1]] \\n     >>> solve_maze(maze,0,2,len(maze)-1,2)  # doctest: +NORMALIZE_WHITESPACE \\n     [[1, 1, 0, 0, 1, 1, 1, 1], \\n     [1, 1, 1, 0, 0, 1, 1, 1], \\n     [1, 1, 1, 1, 0, 1, 1, 1], \\n     [1, 1, 1, 0, 0, 1, 1, 1], \\n     [1, 1, 0, 0, 1, 1, 1, 1], \\n     [1, 1, 0, 1, 1, 1, 1, 1], \\n     [1, 1, 0, 1, 1, 1, 1, 1], \\n     [1, 1, 0, 1, 1, 1, 1, 1]] \\n     >>> maze = [[1, 0, 0], \\n     ...         [0, 1, 1], \\n     ...         [1, 0, 1]] \\n     >>> solve_maze(maze,0,1,len(maze)-1,len(maze)-1) \\n     Traceback (most recent call last): \\n         ... \\n     ValueError: No solution exists! \\n  \\n     >>> maze = [[0, 0], \\n     ...         [1, 1]] \\n     >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1) \\n     Traceback (most recent call last): \\n         ... \\n     ValueError: No solution exists! \\n  \\n     >>> maze = [[0, 1], \\n     ...         [1, 0]] \\n     >>> solve_maze(maze,2,0,len(maze)-1,len(maze)-1) \\n     Traceback (most recent call last): \\n         ... \\n     ValueError: Invalid source or destination coordinates \\n  \\n     >>> maze = [[1, 0, 0], \\n     ...         [0, 1, 0], \\n     ...         [1, 0, 0]] \\n     >>> solve_maze(maze,0,1,len(maze),len(maze)-1) \\n     Traceback (most recent call last): \\n         ... \\n     ValueError: Invalid source or destination coordinates \\n     \"\"\"\nsize=len(maze)\n#Check if source and destination coordinates are Invalid.\nif not(0<=source_row<=size-1and0<=source_column<=size-1)or(\nnot(0<=destination_row<=size-1and0<=destination_column<=size-1)\n):\nraise ValueError(\"Invalid source or destination coordinates\")\n#We need to create solution object to save path.\nsolutions=[[1for _ in range(size)]for _ in range(size)]\nsolved=run_maze(\nmaze,source_row,source_column,destination_row,destination_column,solutions\n)\nif solved:\nreturn solutions\nelse:\nraise ValueError(\"No solution exists!\")\n"
        },
        {
            "type": "FunctionDecl",
            "name": "run_maze",
            "range": [
                208,
                518
            ],
            "children": [
                {
                    "type": "Parameters",
                    "name": "parameters",
                    "range": [
                        210,
                        254
                    ],
                    "children": [
                        {
                            "type": "Parameter",
                            "name": "maze",
                            "range": [
                                212,
                                220
                            ],
                            "children": [],
                            "content": "\nmaze:list[list[int]"
                        },
                        {
                            "type": "Parameter",
                            "name": "i",
                            "range": [
                                223,
                                226
                            ],
                            "children": [],
                            "content": "\ni:int"
                        },
                        {
                            "type": "Parameter",
                            "name": "j",
                            "range": [
                                228,
                                231
                            ],
                            "children": [],
                            "content": "\nj:int"
                        },
                        {
                            "type": "Parameter",
                            "name": "destination_row",
                            "range": [
                                233,
                                236
                            ],
                            "children": [],
                            "content": "\ndestination_row:int"
                        },
                        {
                            "type": "Parameter",
                            "name": "destination_column",
                            "range": [
                                238,
                                241
                            ],
                            "children": [],
                            "content": "\ndestination_column:int"
                        },
                        {
                            "type": "Parameter",
                            "name": "solutions",
                            "range": [
                                243,
                                252
                            ],
                            "children": [],
                            "content": "\nsolutions:list[list[int]]"
                        }
                    ],
                    "content": "run_maze(\nmaze:list[list[int]],\ni:int,\nj:int,\ndestination_row:int,\ndestination_column:int,\nsolutions:list[list[int]],\n"
                },
                {
                    "type": "ReturnType",
                    "name": "returnType",
                    "range": [
                        255,
                        257
                    ],
                    "children": [],
                    "content": ")->"
                },
                {
                    "type": "BlockStatement",
                    "name": "body",
                    "range": [
                        258,
                        518
                    ],
                    "children": [
                        {
                            "type": "Docstring",
                            "name": "docstring",
                            "range": [
                                260,
                                262
                            ],
                            "children": [],
                            "content": "\n\"\"\" \\n     This method is recursive starting from (i, j) and going in one of four directions: \\n     up, down, left, right. \\n     If a path is found to destination it returns True otherwise it returns False. \\n     Parameters \\n         maze: A two dimensional matrix of zeros and ones. \\n         i, j : coordinates of matrix \\n         solutions: A two dimensional matrix of solutions. \\n     Returns: \\n         Boolean if path is found True, Otherwise False. \\n     \""
                        },
                        {
                            "type": "VariableDeclaration",
                            "name": "size",
                            "range": [
                                264,
                                270
                            ],
                            "children": [],
                            "content": "\nsize=len(maze)"
                        },
                        {
                            "type": "IfStatement",
                            "name": "ifStatement",
                            "range": [
                                277,
                                312
                            ],
                            "children": [
                                {
                                    "type": "Condition",
                                    "name": "condition",
                                    "range": [
                                        278,
                                        298
                                    ],
                                    "children": [],
                                    "content": "if i==destination_row and j==destination_column and maze[i][j]==0"
                                },
                                {
                                    "type": "BlockStatement",
                                    "name": "consequent",
                                    "range": [
                                        299,
                                        312
                                    ],
                                    "children": [
                                        {
                                            "type": "AssignmentExpression",
                                            "name": "assignment",
                                            "range": [
                                                300,
                                                309
                                            ],
                                            "children": [],
                                            "content": "\nsolutions[i][j]=0"
                                        },
                                        {
                                            "type": "ReturnStatement",
                                            "name": "return",
                                            "range": [
                                                310,
                                                312
                                            ],
                                            "children": [],
                                            "content": "\nreturn True"
                                        }
                                    ],
                                    "content": ":\nsolutions[i][j]=0\nreturn True"
                                }
                            ],
                            "content": "\nif i==destination_row and j==destination_column and maze[i][j]==0:\nsolutions[i][j]=0\nreturn True"
                        },
                        {
                            "type": "VariableDeclaration",
                            "name": "lower_flag",
                            "range": [
                                314,
                                333
                            ],
                            "children": [],
                            "content": "\nlower_flag=(not i<0)and(not j<0)#Check lower bounds"
                        },
                        {
                            "type": "VariableDeclaration",
                            "name": "upper_flag",
                            "range": [
                                334,
                                351
                            ],
                            "children": [],
                            "content": "\nupper_flag=(i<size)and(j<size)#Check upper bounds"
                        },
                        {
                            "type": "IfStatement",
                            "name": "ifStatement",
                            "range": [
                                353,
                                514
                            ],
                            "children": [
                                {
                                    "type": "Condition",
                                    "name": "condition",
                                    "range": [
                                        354,
                                        357
                                    ],
                                    "children": [],
                                    "content": "if lower_flag and upper_flag"
                                },
                                {
                                    "type": "BlockStatement",
                                    "name": "consequent",
                                    "range": [
                                        358,
                                        514
                                    ],
                                    "children": [
                                        {
                                            "type": "VariableDeclaration",
                                            "name": "block_flag",
                                            "range": [
                                                369,
                                                391
                                            ],
                                            "children": [],
                                            "content": "\nblock_flag=(solutions[i][j])and(not maze[i][j])"
                                        },
                                        {
                                            "type": "IfStatement",
                                            "name": "ifStatement",
                                            "range": [
                                                392,
                                                409
                                            ],
                                            "children": [
                                                {
                                                    "type": "Condition",
                                                    "name": "condition",
                                                    "range": [
                                                        393,
                                                        394
                                                    ],
                                                    "children": [],
                                                    "content": "if block_flag"
                                                },
                                                {
                                                    "type": "BlockStatement",
                                                    "name": "consequent",
                                                    "range": [
                                                        395,
                                                        409
                                                    ],
                                                    "children": [
                                                        {
                                                            "type": "AssignmentExpression",
                                                            "name": "assignment",
                                                            "range": [
                                                                400,
                                                                409
                                                            ],
                                                            "children": [],
                                                            "content": "\nsolutions[i][j]=0"
                                                        }
                                                    ],
                                                    "content": ":\n#check visited\nsolutions[i][j]=0"
                                                }
                                            ],
                                            "content": "\nif block_flag:\n#check visited\nsolutions[i][j]=0"
                                        },
                                        {
                                            "type": "IfStatement",
                                            "name": "ifStatement",
                                            "range": [
                                                416,
                                                501
                                            ],
                                            "children": [
                                                {
                                                    "type": "Condition",
                                                    "name": "condition",
                                                    "range": [
                                                        417,
                                                        497
                                                    ],
                                                    "children": [],
                                                    "content": "if(\nrun_maze(maze,i+1,j,destination_row,destination_column,solutions)\nor run_maze(\nmaze,i,j+1,destination_row,destination_column,solutions\n)\nor run_maze(\nmaze,i-1,j,destination_row,destination_column,solutions\n)\nor run_maze(\nmaze,i,j-1,destination_row,destination_column,solutions\n)\n)"
                                                },
                                                {
                                                    "type": "BlockStatement",
                                                    "name": "consequent",
                                                    "range": [
                                                        498,
                                                        501
                                                    ],
                                                    "children": [
                                                        {
                                                            "type": "ReturnStatement",
                                                            "name": "return",
                                                            "range": [
                                                                499,
                                                                501
                                                            ],
                                                            "children": [],
                                                            "content": "\nreturn True"
                                                        }
                                                    ],
                                                    "content": ":\nreturn True"
                                                }
                                            ],
                                            "content": "\nif(\nrun_maze(maze,i+1,j,destination_row,destination_column,solutions)\nor run_maze(\nmaze,i,j+1,destination_row,destination_column,solutions\n)\nor run_maze(\nmaze,i-1,j,destination_row,destination_column,solutions\n)\nor run_maze(\nmaze,i,j-1,destination_row,destination_column,solutions\n)\n):\nreturn True"
                                        },
                                        {
                                            "type": "AssignmentExpression",
                                            "name": "assignment",
                                            "range": [
                                                503,
                                                512
                                            ],
                                            "children": [],
                                            "content": "\nsolutions[i][j]=1"
                                        },
                                        {
                                            "type": "ReturnStatement",
                                            "name": "return",
                                            "range": [
                                                513,
                                                514
                                            ],
                                            "children": [],
                                            "content": "\nreturn"
                                        }
                                    ],
                                    "content": ":\n#check for already visited and block points.\nblock_flag=(solutions[i][j])and(not maze[i][j])\nif block_flag:\n#check visited\nsolutions[i][j]=0\n\n#check for directions\nif(\nrun_maze(maze,i+1,j,destination_row,destination_column,solutions)\nor run_maze(\nmaze,i,j+1,destination_row,destination_column,solutions\n)\nor run_maze(\nmaze,i-1,j,destination_row,destination_column,solutions\n)\nor run_maze(\nmaze,i,j-1,destination_row,destination_column,solutions\n)\n):\nreturn True\n\nsolutions[i][j]=1\nreturn"
                                }
                            ],
                            "content": "\nif lower_flag and upper_flag:\n#check for already visited and block points.\nblock_flag=(solutions[i][j])and(not maze[i][j])\nif block_flag:\n#check visited\nsolutions[i][j]=0\n\n#check for directions\nif(\nrun_maze(maze,i+1,j,destination_row,destination_column,solutions)\nor run_maze(\nmaze,i,j+1,destination_row,destination_column,solutions\n)\nor run_maze(\nmaze,i-1,j,destination_row,destination_column,solutions\n)\nor run_maze(\nmaze,i,j-1,destination_row,destination_column,solutions\n)\n):\nreturn True\n\nsolutions[i][j]=1\nreturn"
                        },
                        {
                            "type": "ReturnStatement",
                            "name": "return",
                            "range": [
                                516,
                                518
                            ],
                            "children": [],
                            "content": "\nreturn False"
                        }
                    ],
                    "content": "bool:\n\"\"\" \\n     This method is recursive starting from (i, j) and going in one of four directions: \\n     up, down, left, right. \\n     If a path is found to destination it returns True otherwise it returns False. \\n     Parameters \\n         maze: A two dimensional matrix of zeros and ones. \\n         i, j : coordinates of matrix \\n         solutions: A two dimensional matrix of solutions. \\n     Returns: \\n         Boolean if path is found True, Otherwise False. \\n     \"\"\"\nsize=len(maze)\n#Final check point.\nif i==destination_row and j==destination_column and maze[i][j]==0:\nsolutions[i][j]=0\nreturn True\n\nlower_flag=(not i<0)and(not j<0)#Check lower bounds\nupper_flag=(i<size)and(j<size)#Check upper bounds\n\nif lower_flag and upper_flag:\n#check for already visited and block points.\nblock_flag=(solutions[i][j])and(not maze[i][j])\nif block_flag:\n#check visited\nsolutions[i][j]=0\n\n#check for directions\nif(\nrun_maze(maze,i+1,j,destination_row,destination_column,solutions)\nor run_maze(\nmaze,i,j+1,destination_row,destination_column,solutions\n)\nor run_maze(\nmaze,i-1,j,destination_row,destination_column,solutions\n)\nor run_maze(\nmaze,i,j-1,destination_row,destination_column,solutions\n)\n):\nreturn True\n\nsolutions[i][j]=1\nreturn False\nreturn False"
                }
            ],
            "content": "\ndef run_maze(\nmaze:list[list[int]],\ni:int,\nj:int,\ndestination_row:int,\ndestination_column:int,\nsolutions:list[list[int]],\n)->bool:\n\"\"\" \\n     This method is recursive starting from (i, j) and going in one of four directions: \\n     up, down, left, right. \\n     If a path is found to destination it returns True otherwise it returns False. \\n     Parameters \\n         maze: A two dimensional matrix of zeros and ones. \\n         i, j : coordinates of matrix \\n         solutions: A two dimensional matrix of solutions. \\n     Returns: \\n         Boolean if path is found True, Otherwise False. \\n     \"\"\"\nsize=len(maze)\n#Final check point.\nif i==destination_row and j==destination_column and maze[i][j]==0:\nsolutions[i][j]=0\nreturn True\n\nlower_flag=(not i<0)and(not j<0)#Check lower bounds\nupper_flag=(i<size)and(j<size)#Check upper bounds\n\nif lower_flag and upper_flag:\n#check for already visited and block points.\nblock_flag=(solutions[i][j])and(not maze[i][j])\nif block_flag:\n#check visited\nsolutions[i][j]=0\n\n#check for directions\nif(\nrun_maze(maze,i+1,j,destination_row,destination_column,solutions)\nor run_maze(\nmaze,i,j+1,destination_row,destination_column,solutions\n)\nor run_maze(\nmaze,i-1,j,destination_row,destination_column,solutions\n)\nor run_maze(\nmaze,i,j-1,destination_row,destination_column,solutions\n)\n):\nreturn True\n\nsolutions[i][j]=1\nreturn False\nreturn False"
        },
        {
            "type": "IfStatement",
            "name": "",
            "range": [
                521,
                527
            ],
            "children": [
                {
                    "type": "Condition",
                    "name": "",
                    "range": [
                        521,
                        526
                    ],
                    "children": [
                        {
                            "type": "BinaryExpression",
                            "name": "",
                            "range": [
                                522,
                                525
                            ],
                            "children": [
                                {
                                    "type": "Identifier",
                                    "name": "__name__",
                                    "range": [
                                        522,
                                        522
                                    ],
                                    "children": [],
                                    "content": "if"
                                },
                                {
                                    "type": "Operator",
                                    "name": "==",
                                    "range": [
                                        523,
                                        524
                                    ],
                                    "children": [],
                                    "content": "__name__="
                                },
                                {
                                    "type": "StringLiteral",
                                    "name": "\"__main__\"",
                                    "range": [
                                        525,
                                        525
                                    ],
                                    "children": [],
                                    "content": "="
                                }
                            ],
                            "content": "if __name__=="
                        }
                    ],
                    "content": "\nif __name__==\"__main__\""
                }
            ],
            "content": "\nif __name__==\"__main__\":"
        },
        {
            "type": "ImportStatement",
            "name": "doctest",
            "range": [
                528,
                530
            ],
            "children": [
                {
                    "type": "Module",
                    "name": "doctest",
                    "range": [
                        529,
                        529
                    ],
                    "children": [],
                    "content": "import"
                }
            ],
            "content": "\nimport doctest"
        },
        {
            "type": "ExpressionStatement",
            "name": "",
            "range": [
                532,
                542
            ],
            "children": [
                {
                    "type": "CallExpression",
                    "name": "testmod",
                    "range": [
                        532,
                        541
                    ],
                    "children": [
                        {
                            "type": "MemberExpression",
                            "name": "doctest",
                            "range": [
                                532,
                                534
                            ],
                            "children": [
                                {
                                    "type": "Identifier",
                                    "name": "doctest",
                                    "range": [
                                        532,
                                        532
                                    ],
                                    "children": [],
                                    "content": "\n"
                                },
                                {
                                    "type": "Identifier",
                                    "name": "testmod",
                                    "range": [
                                        534,
                                        534
                                    ],
                                    "children": [],
                                    "content": "."
                                }
                            ],
                            "content": "\ndoctest."
                        },
                        {
                            "type": "ArgumentList",
                            "name": "",
                            "range": [
                                535,
                                541
                            ],
                            "children": [
                                {
                                    "type": "AssignmentExpression",
                                    "name": "optionflags",
                                    "range": [
                                        536,
                                        540
                                    ],
                                    "children": [
                                        {
                                            "type": "Identifier",
                                            "name": "optionflags",
                                            "range": [
                                                536,
                                                536
                                            ],
                                            "children": [],
                                            "content": "("
                                        },
                                        {
                                            "type": "MemberExpression",
                                            "name": "doctest",
                                            "range": [
                                                538,
                                                540
                                            ],
                                            "children": [
                                                {
                                                    "type": "Identifier",
                                                    "name": "doctest",
                                                    "range": [
                                                        538,
                                                        538
                                                    ],
                                                    "children": [],
                                                    "content": "="
                                                },
                                                {
                                                    "type": "Identifier",
                                                    "name": "NORMALIZE_WHITESPACE",
                                                    "range": [
                                                        540,
                                                        540
                                                    ],
                                                    "children": [],
                                                    "content": "."
                                                }
                                            ],
                                            "content": "=doctest."
                                        }
                                    ],
                                    "content": "(optionflags=doctest."
                                }
                            ],
                            "content": "testmod(optionflags=doctest.NORMALIZE_WHITESPACE"
                        }
                    ],
                    "content": "\ndoctest.testmod(optionflags=doctest.NORMALIZE_WHITESPACE"
                }
            ],
            "content": "\ndoctest.testmod(optionflags=doctest.NORMALIZE_WHITESPACE)"
        }
    ],
    "content": "from __future__ import annotations\n\n\ndef solve_maze(\nmaze:list[list[int]],\nsource_row:int,\nsource_column:int,\ndestination_row:int,\ndestination_column:int,\n)->list[list[int]]:\n\"\"\" \\n     This method solves the \" rat in maze \" problem. \\n     Parameters : \\n         - maze: A two dimensional matrix of zeros and ones. \\n         - source_row: The row index of the starting point. \\n         - source_column: The column index of the starting point. \\n         - destination_row: The row index of the destination point. \\n         - destination_column: The column index of the destination point. \\n     Returns: \\n         - solution: A 2D matrix representing the solution path if it exists. \\n     Raises: \\n         - ValueError: If no solution exists or if the source or \\n             destination coordinates are invalid. \\n     Description: \\n         This method navigates through a maze represented as an n by n matrix, \\n         starting from a specified source cell and \\n         aiming to reach a destination cell. \\n         The maze consists of walls (1s) and open paths (0s). \\n         By providing custom row and column values, the source and destination \\n         cells can be adjusted. \\n     >>> maze = [[0, 1, 0, 1, 1], \\n     ...         [0, 0, 0, 0, 0], \\n     ...         [1, 0, 1, 0, 1], \\n     ...         [0, 0, 1, 0, 0], \\n     ...         [1, 0, 0, 1, 0]] \\n     >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE \\n     [[0, 1, 1, 1, 1], \\n     [0, 0, 0, 0, 1], \\n     [1, 1, 1, 0, 1], \\n     [1, 1, 1, 0, 0], \\n     [1, 1, 1, 1, 0]] \\n  \\n     Note: \\n         In the output maze, the zeros (0s) represent one of the possible \\n         paths from the source to the destination. \\n  \\n     >>> maze = [[0, 1, 0, 1, 1], \\n     ...         [0, 0, 0, 0, 0], \\n     ...         [0, 0, 0, 0, 1], \\n     ...         [0, 0, 0, 0, 0], \\n     ...         [0, 0, 0, 0, 0]] \\n     >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE \\n     [[0, 1, 1, 1, 1], \\n     [0, 1, 1, 1, 1], \\n     [0, 1, 1, 1, 1], \\n     [0, 1, 1, 1, 1], \\n     [0, 0, 0, 0, 0]] \\n  \\n     >>> maze = [[0, 0, 0], \\n     ...         [0, 1, 0], \\n     ...         [1, 0, 0]] \\n     >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE \\n     [[0, 0, 0], \\n     [1, 1, 0], \\n     [1, 1, 0]] \\n  \\n     >>> maze = [[1, 0, 0], \\n     ...         [0, 1, 0], \\n     ...         [1, 0, 0]] \\n     >>> solve_maze(maze,0,1,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE \\n     [[1, 0, 0], \\n     [1, 1, 0], \\n     [1, 1, 0]] \\n  \\n     >>> maze = [[1, 1, 0, 0, 1, 0, 0, 1], \\n     ...         [1, 0, 1, 0, 0, 1, 1, 1], \\n     ...         [0, 1, 0, 1, 0, 0, 1, 0], \\n     ...         [1, 1, 1, 0, 0, 1, 0, 1], \\n     ...         [0, 1, 0, 0, 1, 0, 1, 1], \\n     ...         [0, 0, 0, 1, 1, 1, 0, 1], \\n     ...         [0, 1, 0, 1, 0, 1, 1, 1], \\n     ...         [1, 1, 0, 0, 0, 0, 0, 1]] \\n     >>> solve_maze(maze,0,2,len(maze)-1,2)  # doctest: +NORMALIZE_WHITESPACE \\n     [[1, 1, 0, 0, 1, 1, 1, 1], \\n     [1, 1, 1, 0, 0, 1, 1, 1], \\n     [1, 1, 1, 1, 0, 1, 1, 1], \\n     [1, 1, 1, 0, 0, 1, 1, 1], \\n     [1, 1, 0, 0, 1, 1, 1, 1], \\n     [1, 1, 0, 1, 1, 1, 1, 1], \\n     [1, 1, 0, 1, 1, 1, 1, 1], \\n     [1, 1, 0, 1, 1, 1, 1, 1]] \\n     >>> maze = [[1, 0, 0], \\n     ...         [0, 1, 1], \\n     ...         [1, 0, 1]] \\n     >>> solve_maze(maze,0,1,len(maze)-1,len(maze)-1) \\n     Traceback (most recent call last): \\n         ... \\n     ValueError: No solution exists! \\n  \\n     >>> maze = [[0, 0], \\n     ...         [1, 1]] \\n     >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1) \\n     Traceback (most recent call last): \\n         ... \\n     ValueError: No solution exists! \\n  \\n     >>> maze = [[0, 1], \\n     ...         [1, 0]] \\n     >>> solve_maze(maze,2,0,len(maze)-1,len(maze)-1) \\n     Traceback (most recent call last): \\n         ... \\n     ValueError: Invalid source or destination coordinates \\n  \\n     >>> maze = [[1, 0, 0], \\n     ...         [0, 1, 0], \\n     ...         [1, 0, 0]] \\n     >>> solve_maze(maze,0,1,len(maze),len(maze)-1) \\n     Traceback (most recent call last): \\n         ... \\n     ValueError: Invalid source or destination coordinates \\n     \"\"\"\nsize=len(maze)\n#Check if source and destination coordinates are Invalid.\nif not(0<=source_row<=size-1and0<=source_column<=size-1)or(\nnot(0<=destination_row<=size-1and0<=destination_column<=size-1)\n):\nraise ValueError(\"Invalid source or destination coordinates\")\n#We need to create solution object to save path.\nsolutions=[[1for _ in range(size)]for _ in range(size)]\nsolved=run_maze(\nmaze,source_row,source_column,destination_row,destination_column,solutions\n)\nif solved:\nreturn solutions\nelse:\nraise ValueError(\"No solution exists!\")\n\n\ndef run_maze(\nmaze:list[list[int]],\ni:int,\nj:int,\ndestination_row:int,\ndestination_column:int,\nsolutions:list[list[int]],\n)->bool:\n\"\"\" \\n     This method is recursive starting from (i, j) and going in one of four directions: \\n     up, down, left, right. \\n     If a path is found to destination it returns True otherwise it returns False. \\n     Parameters \\n         maze: A two dimensional matrix of zeros and ones. \\n         i, j : coordinates of matrix \\n         solutions: A two dimensional matrix of solutions. \\n     Returns: \\n         Boolean if path is found True, Otherwise False. \\n     \"\"\"\nsize=len(maze)\n#Final check point.\nif i==destination_row and j==destination_column and maze[i][j]==0:\nsolutions[i][j]=0\nreturn True\n\nlower_flag=(not i<0)and(not j<0)#Check lower bounds\nupper_flag=(i<size)and(j<size)#Check upper bounds\n\nif lower_flag and upper_flag:\n#check for already visited and block points.\nblock_flag=(solutions[i][j])and(not maze[i][j])\nif block_flag:\n#check visited\nsolutions[i][j]=0\n\n#check for directions\nif(\nrun_maze(maze,i+1,j,destination_row,destination_column,solutions)\nor run_maze(\nmaze,i,j+1,destination_row,destination_column,solutions\n)\nor run_maze(\nmaze,i-1,j,destination_row,destination_column,solutions\n)\nor run_maze(\nmaze,i,j-1,destination_row,destination_column,solutions\n)\n):\nreturn True\n\nsolutions[i][j]=1\nreturn False\nreturn False\n\n\nif __name__==\"__main__\":\nimport doctest\n\ndoctest.testmod(optionflags=doctest.NORMALIZE_WHITESPACE)"
}