{
    "type": "Program",
    "name": "Global",
    "range": [
        0,
        387
    ],
    "children": [
        {
            "type": "Comment",
            "name": "",
            "range": [
                1,
                1
            ],
            "children": [
                {
                    "type": "Text",
                    "name": "",
                    "range": [
                        1,
                        1
                    ],
                    "children": [],
                    "content": "\" \\n A Hamiltonian cycle (Hamiltonian circuit) is a graph cycle \\n through a graph that visits each node exactly once. \\n Determining whether such paths and cycles exist in graphs \\n is the 'Hamiltonian path problem', which is NP-complete. \\n  \\n Wikipedia: https://en.wikipedia.org/wiki/Hamiltonian_path \\n \""
                }
            ],
            "content": "\" \\n A Hamiltonian cycle (Hamiltonian circuit) is a graph cycle \\n through a graph that visits each node exactly once. \\n Determining whether such paths and cycles exist in graphs \\n is the 'Hamiltonian path problem', which is NP-complete. \\n  \\n Wikipedia: https://en.wikipedia.org/wiki/Hamiltonian_path \\n \""
        },
        {
            "type": "NewLine",
            "name": "",
            "range": [
                3,
                3
            ],
            "children": [],
            "content": "\n"
        },
        {
            "type": "NewLine",
            "name": "",
            "range": [
                4,
                4
            ],
            "children": [],
            "content": "\n"
        },
        {
            "type": "NewLine",
            "name": "",
            "range": [
                5,
                5
            ],
            "children": [],
            "content": "\n"
        },
        {
            "type": "FunctionDecl",
            "name": "valid_connection",
            "range": [
                6,
                108
            ],
            "children": [
                {
                    "type": "ParameterList",
                    "name": "parameters",
                    "range": [
                        8,
                        34
                    ],
                    "children": [
                        {
                            "type": "Parameter",
                            "name": "graph",
                            "range": [
                                10,
                                18
                            ],
                            "children": [
                                {
                                    "type": "TypeAnnotation",
                                    "name": "list[list[int]]",
                                    "range": [
                                        12,
                                        18
                                    ],
                                    "children": [],
                                    "content": "list[list[int]]"
                                }
                            ],
                            "content": "graph:list[list[int]]"
                        },
                        {
                            "type": "Parameter",
                            "name": "next_ver",
                            "range": [
                                20,
                                22
                            ],
                            "children": [
                                {
                                    "type": "TypeAnnotation",
                                    "name": "int",
                                    "range": [
                                        22,
                                        22
                                    ],
                                    "children": [],
                                    "content": "int"
                                }
                            ],
                            "content": "next_ver:int"
                        },
                        {
                            "type": "Parameter",
                            "name": "curr_ind",
                            "range": [
                                24,
                                26
                            ],
                            "children": [
                                {
                                    "type": "TypeAnnotation",
                                    "name": "int",
                                    "range": [
                                        26,
                                        26
                                    ],
                                    "children": [],
                                    "content": "int"
                                }
                            ],
                            "content": "curr_ind:int"
                        },
                        {
                            "type": "Parameter",
                            "name": "path",
                            "range": [
                                28,
                                33
                            ],
                            "children": [
                                {
                                    "type": "TypeAnnotation",
                                    "name": "list[int]",
                                    "range": [
                                        30,
                                        33
                                    ],
                                    "children": [],
                                    "content": "list[int]"
                                }
                            ],
                            "content": "path:list[int]"
                        }
                    ],
                    "content": "(\ngraph:list[list[int]],next_ver:int,curr_ind:int,path:list[int]\n"
                },
                {
                    "type": "ReturnType",
                    "name": "bool",
                    "range": [
                        38,
                        38
                    ],
                    "children": [],
                    "content": "bool"
                },
                {
                    "type": "FunctionBody",
                    "name": "body",
                    "range": [
                        40,
                        108
                    ],
                    "children": [
                        {
                            "type": "Docstring",
                            "name": "docstring",
                            "range": [
                                41,
                                43
                            ],
                            "children": [],
                            "content": "\"\"\" \\n     Checks whether it is possible to add next into path by validating 2 statements \\n     1. There should be path between current and next vertex \\n     2. Next vertex should not be in path \\n     If both validations succeed we return True, saying that it is possible to connect \\n     this vertices, otherwise we return False \\n  \\n     Case 1:Use exact graph as in main function, with initialized values \\n     >>> graph = [[0, 1, 0, 1, 0], \\n     ...          [1, 0, 1, 1, 1], \\n     ...          [0, 1, 0, 0, 1], \\n     ...          [1, 1, 0, 0, 1], \\n     ...          [0, 1, 1, 1, 0]] \\n     >>> path = [0, -1, -1, -1, -1, 0] \\n     >>> curr_ind = 1 \\n     >>> next_ver = 1 \\n     >>> valid_connection(graph, next_ver, curr_ind, path) \\n     True \\n  \\n     Case 2: Same graph, but trying to connect to node that is already in path \\n     >>> path = [0, 1, 2, 4, -1, 0] \\n     >>> curr_ind = 4 \\n     >>> next_ver = 1 \\n     >>> valid_connection(graph, next_ver, curr_ind, path) \\n     False \\n     \"\"\""
                        },
                        {
                            "type": "Comment",
                            "name": "comment",
                            "range": [
                                46,
                                58
                            ],
                            "children": [],
                            "content": "#1.Validate that path exists between current and next vertices\n"
                        },
                        {
                            "type": "IfStatement",
                            "name": "if",
                            "range": [
                                59,
                                79
                            ],
                            "children": [
                                {
                                    "type": "Condition",
                                    "name": "condition",
                                    "range": [
                                        60,
                                        74
                                    ],
                                    "children": [
                                        {
                                            "type": "BinaryExpression",
                                            "name": "==",
                                            "range": [
                                                72,
                                                74
                                            ],
                                            "children": [
                                                {
                                                    "type": "ArrayAccess",
                                                    "name": "graph[path[curr_ind - 1]][next_ver]",
                                                    "range": [
                                                        60,
                                                        71
                                                    ],
                                                    "children": [],
                                                    "content": "graph[path[curr_ind-1]][next_ver]"
                                                },
                                                {
                                                    "type": "Literal",
                                                    "name": "0",
                                                    "range": [
                                                        74,
                                                        74
                                                    ],
                                                    "children": [],
                                                    "content": "0"
                                                }
                                            ],
                                            "content": "==0"
                                        }
                                    ],
                                    "content": "graph[path[curr_ind-1]][next_ver]==0"
                                },
                                {
                                    "type": "ReturnStatement",
                                    "name": "return",
                                    "range": [
                                        77,
                                        78
                                    ],
                                    "children": [
                                        {
                                            "type": "Literal",
                                            "name": "False",
                                            "range": [
                                                78,
                                                78
                                            ],
                                            "children": [],
                                            "content": "False"
                                        }
                                    ],
                                    "content": "return False"
                                }
                            ],
                            "content": "if graph[path[curr_ind-1]][next_ver]==0:\nreturn False\n"
                        },
                        {
                            "type": "Comment",
                            "name": "comment",
                            "range": [
                                81,
                                93
                            ],
                            "children": [],
                            "content": "#2.Validate that next vertex is not already in path\n"
                        },
                        {
                            "type": "ReturnStatement",
                            "name": "return",
                            "range": [
                                94,
                                107
                            ],
                            "children": [
                                {
                                    "type": "UnaryExpression",
                                    "name": "not",
                                    "range": [
                                        95,
                                        107
                                    ],
                                    "children": [
                                        {
                                            "type": "CallExpression",
                                            "name": "any",
                                            "range": [
                                                96,
                                                106
                                            ],
                                            "children": [
                                                {
                                                    "type": "GeneratorExpression",
                                                    "name": "vertex == next_ver for vertex in path",
                                                    "range": [
                                                        97,
                                                        106
                                                    ],
                                                    "children": [],
                                                    "content": "(vertex==next_ver for vertex in path)"
                                                }
                                            ],
                                            "content": "any(vertex==next_ver for vertex in path)"
                                        }
                                    ],
                                    "content": "not any(vertex==next_ver for vertex in path)\n"
                                }
                            ],
                            "content": "return not any(vertex==next_ver for vertex in path)\n"
                        }
                    ],
                    "content": "\n\"\"\" \\n     Checks whether it is possible to add next into path by validating 2 statements \\n     1. There should be path between current and next vertex \\n     2. Next vertex should not be in path \\n     If both validations succeed we return True, saying that it is possible to connect \\n     this vertices, otherwise we return False \\n  \\n     Case 1:Use exact graph as in main function, with initialized values \\n     >>> graph = [[0, 1, 0, 1, 0], \\n     ...          [1, 0, 1, 1, 1], \\n     ...          [0, 1, 0, 0, 1], \\n     ...          [1, 1, 0, 0, 1], \\n     ...          [0, 1, 1, 1, 0]] \\n     >>> path = [0, -1, -1, -1, -1, 0] \\n     >>> curr_ind = 1 \\n     >>> next_ver = 1 \\n     >>> valid_connection(graph, next_ver, curr_ind, path) \\n     True \\n  \\n     Case 2: Same graph, but trying to connect to node that is already in path \\n     >>> path = [0, 1, 2, 4, -1, 0] \\n     >>> curr_ind = 4 \\n     >>> next_ver = 1 \\n     >>> valid_connection(graph, next_ver, curr_ind, path) \\n     False \\n     \"\"\"\n\n#1.Validate that path exists between current and next vertices\nif graph[path[curr_ind-1]][next_ver]==0:\nreturn False\n\n#2.Validate that next vertex is not already in path\nreturn not any(vertex==next_ver for vertex in path)\n\n"
                }
            ],
            "content": "def valid_connection(\ngraph:list[list[int]],next_ver:int,curr_ind:int,path:list[int]\n)->bool:\n\"\"\" \\n     Checks whether it is possible to add next into path by validating 2 statements \\n     1. There should be path between current and next vertex \\n     2. Next vertex should not be in path \\n     If both validations succeed we return True, saying that it is possible to connect \\n     this vertices, otherwise we return False \\n  \\n     Case 1:Use exact graph as in main function, with initialized values \\n     >>> graph = [[0, 1, 0, 1, 0], \\n     ...          [1, 0, 1, 1, 1], \\n     ...          [0, 1, 0, 0, 1], \\n     ...          [1, 1, 0, 0, 1], \\n     ...          [0, 1, 1, 1, 0]] \\n     >>> path = [0, -1, -1, -1, -1, 0] \\n     >>> curr_ind = 1 \\n     >>> next_ver = 1 \\n     >>> valid_connection(graph, next_ver, curr_ind, path) \\n     True \\n  \\n     Case 2: Same graph, but trying to connect to node that is already in path \\n     >>> path = [0, 1, 2, 4, -1, 0] \\n     >>> curr_ind = 4 \\n     >>> next_ver = 1 \\n     >>> valid_connection(graph, next_ver, curr_ind, path) \\n     False \\n     \"\"\"\n\n#1.Validate that path exists between current and next vertices\nif graph[path[curr_ind-1]][next_ver]==0:\nreturn False\n\n#2.Validate that next vertex is not already in path\nreturn not any(vertex==next_ver for vertex in path)\n\n"
        },
        {
            "type": "FunctionDecl",
            "name": "util_hamilton_cycle",
            "range": [
                109,
                269
            ],
            "children": [
                {
                    "type": "ParameterList",
                    "name": "parameters",
                    "range": [
                        111,
                        132
                    ],
                    "children": [
                        {
                            "type": "Parameter",
                            "name": "graph",
                            "range": [
                                112,
                                120
                            ],
                            "children": [],
                            "content": "(graph:list[list[int]"
                        },
                        {
                            "type": "Parameter",
                            "name": "path",
                            "range": [
                                122,
                                127
                            ],
                            "children": [],
                            "content": ",path:list[int"
                        },
                        {
                            "type": "Parameter",
                            "name": "curr_ind",
                            "range": [
                                129,
                                131
                            ],
                            "children": [],
                            "content": ",curr_ind:"
                        }
                    ],
                    "content": "util_hamilton_cycle(graph:list[list[int]],path:list[int],curr_ind:int"
                },
                {
                    "type": "ReturnType",
                    "name": "bool",
                    "range": [
                        133,
                        135
                    ],
                    "children": [],
                    "content": ")->"
                },
                {
                    "type": "FunctionBody",
                    "name": "body",
                    "range": [
                        136,
                        269
                    ],
                    "children": [
                        {
                            "type": "Docstring",
                            "name": "docstring",
                            "range": [
                                138,
                                140
                            ],
                            "children": [],
                            "content": "\n\"\"\" \\n     Pseudo-Code \\n     Base Case: \\n     1. Check if we visited all of vertices \\n         1.1 If last visited vertex has path to starting vertex return True either \\n             return False \\n     Recursive Step: \\n     2. Iterate over each vertex \\n         Check if next vertex is valid for transiting from current vertex \\n             2.1 Remember next vertex as next transition \\n             2.2 Do recursive call and check if going to this vertex solves problem \\n             2.3 If next vertex leads to solution return True \\n             2.4 Else backtrack, delete remembered vertex \\n  \\n     Case 1: Use exact graph as in main function, with initialized values \\n     >>> graph = [[0, 1, 0, 1, 0], \\n     ...          [1, 0, 1, 1, 1], \\n     ...          [0, 1, 0, 0, 1], \\n     ...          [1, 1, 0, 0, 1], \\n     ...          [0, 1, 1, 1, 0]] \\n     >>> path = [0, -1, -1, -1, -1, 0] \\n     >>> curr_ind = 1 \\n     >>> util_hamilton_cycle(graph, path, curr_ind) \\n     True \\n     >>> path \\n     [0, 1, 2, 4, 3, 0] \\n  \\n     Case 2: Use exact graph as in previous case, but in the properties taken from \\n         middle of calculation \\n     >>> graph = [[0, 1, 0, 1, 0], \\n     ...          [1, 0, 1, 1, 1], \\n     ...          [0, 1, 0, 0, 1], \\n     ...          [1, 1, 0, 0, 1], \\n     ...          [0, 1, 1, 1, 0]] \\n     >>> path = [0, 1, 2, -1, -1, 0] \\n     >>> curr_ind = 3 \\n     >>> util_hamilton_cycle(graph, path, curr_ind) \\n     True \\n     >>> path \\n     [0, 1, 2, 4, 3, 0] \\n     \""
                        },
                        {
                            "type": "BaseCase",
                            "name": "base_case",
                            "range": [
                                143,
                                187
                            ],
                            "children": [
                                {
                                    "type": "IfStatement",
                                    "name": "if_statement",
                                    "range": [
                                        147,
                                        187
                                    ],
                                    "children": [
                                        {
                                            "type": "Condition",
                                            "name": "condition",
                                            "range": [
                                                148,
                                                154
                                            ],
                                            "children": [],
                                            "content": "if curr_ind==len(graph"
                                        },
                                        {
                                            "type": "ReturnStatement",
                                            "name": "return_statement",
                                            "range": [
                                                168,
                                                187
                                            ],
                                            "children": [],
                                            "content": "\nreturn graph[path[curr_ind-1]][path[0]]==1"
                                        }
                                    ],
                                    "content": "\nif curr_ind==len(graph):\n#return whether path exists between current and starting vertices\nreturn graph[path[curr_ind-1]][path[0]]==1"
                                }
                            ],
                            "content": "\n#Base Case\nif curr_ind==len(graph):\n#return whether path exists between current and starting vertices\nreturn graph[path[curr_ind-1]][path[0]]==1"
                        },
                        {
                            "type": "RecursiveStep",
                            "name": "recursive_step",
                            "range": [
                                189,
                                269
                            ],
                            "children": [
                                {
                                    "type": "ForStatement",
                                    "name": "for_loop",
                                    "range": [
                                        193,
                                        269
                                    ],
                                    "children": [
                                        {
                                            "type": "Iteration",
                                            "name": "iteration",
                                            "range": [
                                                194,
                                                202
                                            ],
                                            "children": [],
                                            "content": "for next_ver in range(len(graph)"
                                        },
                                        {
                                            "type": "IfStatement",
                                            "name": "if_statement",
                                            "range": [
                                                205,
                                                266
                                            ],
                                            "children": [
                                                {
                                                    "type": "Condition",
                                                    "name": "condition",
                                                    "range": [
                                                        206,
                                                        215
                                                    ],
                                                    "children": [],
                                                    "content": "if valid_connection(graph,next_ver,curr_ind,path"
                                                },
                                                {
                                                    "type": "Assignment",
                                                    "name": "assignment",
                                                    "range": [
                                                        228,
                                                        234
                                                    ],
                                                    "children": [],
                                                    "content": "\npath[curr_ind]=next_ver"
                                                },
                                                {
                                                    "type": "IfStatement",
                                                    "name": "if_statement",
                                                    "range": [
                                                        240,
                                                        255
                                                    ],
                                                    "children": [
                                                        {
                                                            "type": "Condition",
                                                            "name": "condition",
                                                            "range": [
                                                                241,
                                                                250
                                                            ],
                                                            "children": [],
                                                            "content": "if util_hamilton_cycle(graph,path,curr_ind+1"
                                                        },
                                                        {
                                                            "type": "ReturnStatement",
                                                            "name": "return_statement",
                                                            "range": [
                                                                253,
                                                                255
                                                            ],
                                                            "children": [],
                                                            "content": "\nreturn True"
                                                        }
                                                    ],
                                                    "content": "\nif util_hamilton_cycle(graph,path,curr_ind+1):\nreturn True"
                                                },
                                                {
                                                    "type": "Assignment",
                                                    "name": "assignment",
                                                    "range": [
                                                        259,
                                                        266
                                                    ],
                                                    "children": [],
                                                    "content": "\npath[curr_ind]=-1"
                                                }
                                            ],
                                            "content": "\nif valid_connection(graph,next_ver,curr_ind,path):\n#Insert current vertex into path as next transition\npath[curr_ind]=next_ver\n#Validate created path\nif util_hamilton_cycle(graph,path,curr_ind+1):\nreturn True\n#Backtrack\npath[curr_ind]=-1"
                                        }
                                    ],
                                    "content": "\nfor next_ver in range(len(graph)):\nif valid_connection(graph,next_ver,curr_ind,path):\n#Insert current vertex into path as next transition\npath[curr_ind]=next_ver\n#Validate created path\nif util_hamilton_cycle(graph,path,curr_ind+1):\nreturn True\n#Backtrack\npath[curr_ind]=-1\nreturn False"
                                },
                                {
                                    "type": "ReturnStatement",
                                    "name": "return_statement",
                                    "range": [
                                        267,
                                        269
                                    ],
                                    "children": [],
                                    "content": "\nreturn False"
                                }
                            ],
                            "content": "\n#Recursive Step\nfor next_ver in range(len(graph)):\nif valid_connection(graph,next_ver,curr_ind,path):\n#Insert current vertex into path as next transition\npath[curr_ind]=next_ver\n#Validate created path\nif util_hamilton_cycle(graph,path,curr_ind+1):\nreturn True\n#Backtrack\npath[curr_ind]=-1\nreturn False"
                        }
                    ],
                    "content": "bool:\n\"\"\" \\n     Pseudo-Code \\n     Base Case: \\n     1. Check if we visited all of vertices \\n         1.1 If last visited vertex has path to starting vertex return True either \\n             return False \\n     Recursive Step: \\n     2. Iterate over each vertex \\n         Check if next vertex is valid for transiting from current vertex \\n             2.1 Remember next vertex as next transition \\n             2.2 Do recursive call and check if going to this vertex solves problem \\n             2.3 If next vertex leads to solution return True \\n             2.4 Else backtrack, delete remembered vertex \\n  \\n     Case 1: Use exact graph as in main function, with initialized values \\n     >>> graph = [[0, 1, 0, 1, 0], \\n     ...          [1, 0, 1, 1, 1], \\n     ...          [0, 1, 0, 0, 1], \\n     ...          [1, 1, 0, 0, 1], \\n     ...          [0, 1, 1, 1, 0]] \\n     >>> path = [0, -1, -1, -1, -1, 0] \\n     >>> curr_ind = 1 \\n     >>> util_hamilton_cycle(graph, path, curr_ind) \\n     True \\n     >>> path \\n     [0, 1, 2, 4, 3, 0] \\n  \\n     Case 2: Use exact graph as in previous case, but in the properties taken from \\n         middle of calculation \\n     >>> graph = [[0, 1, 0, 1, 0], \\n     ...          [1, 0, 1, 1, 1], \\n     ...          [0, 1, 0, 0, 1], \\n     ...          [1, 1, 0, 0, 1], \\n     ...          [0, 1, 1, 1, 0]] \\n     >>> path = [0, 1, 2, -1, -1, 0] \\n     >>> curr_ind = 3 \\n     >>> util_hamilton_cycle(graph, path, curr_ind) \\n     True \\n     >>> path \\n     [0, 1, 2, 4, 3, 0] \\n     \"\"\"\n\n#Base Case\nif curr_ind==len(graph):\n#return whether path exists between current and starting vertices\nreturn graph[path[curr_ind-1]][path[0]]==1\n\n#Recursive Step\nfor next_ver in range(len(graph)):\nif valid_connection(graph,next_ver,curr_ind,path):\n#Insert current vertex into path as next transition\npath[curr_ind]=next_ver\n#Validate created path\nif util_hamilton_cycle(graph,path,curr_ind+1):\nreturn True\n#Backtrack\npath[curr_ind]=-1\nreturn False"
                }
            ],
            "content": "\ndef util_hamilton_cycle(graph:list[list[int]],path:list[int],curr_ind:int)->bool:\n\"\"\" \\n     Pseudo-Code \\n     Base Case: \\n     1. Check if we visited all of vertices \\n         1.1 If last visited vertex has path to starting vertex return True either \\n             return False \\n     Recursive Step: \\n     2. Iterate over each vertex \\n         Check if next vertex is valid for transiting from current vertex \\n             2.1 Remember next vertex as next transition \\n             2.2 Do recursive call and check if going to this vertex solves problem \\n             2.3 If next vertex leads to solution return True \\n             2.4 Else backtrack, delete remembered vertex \\n  \\n     Case 1: Use exact graph as in main function, with initialized values \\n     >>> graph = [[0, 1, 0, 1, 0], \\n     ...          [1, 0, 1, 1, 1], \\n     ...          [0, 1, 0, 0, 1], \\n     ...          [1, 1, 0, 0, 1], \\n     ...          [0, 1, 1, 1, 0]] \\n     >>> path = [0, -1, -1, -1, -1, 0] \\n     >>> curr_ind = 1 \\n     >>> util_hamilton_cycle(graph, path, curr_ind) \\n     True \\n     >>> path \\n     [0, 1, 2, 4, 3, 0] \\n  \\n     Case 2: Use exact graph as in previous case, but in the properties taken from \\n         middle of calculation \\n     >>> graph = [[0, 1, 0, 1, 0], \\n     ...          [1, 0, 1, 1, 1], \\n     ...          [0, 1, 0, 0, 1], \\n     ...          [1, 1, 0, 0, 1], \\n     ...          [0, 1, 1, 1, 0]] \\n     >>> path = [0, 1, 2, -1, -1, 0] \\n     >>> curr_ind = 3 \\n     >>> util_hamilton_cycle(graph, path, curr_ind) \\n     True \\n     >>> path \\n     [0, 1, 2, 4, 3, 0] \\n     \"\"\"\n\n#Base Case\nif curr_ind==len(graph):\n#return whether path exists between current and starting vertices\nreturn graph[path[curr_ind-1]][path[0]]==1\n\n#Recursive Step\nfor next_ver in range(len(graph)):\nif valid_connection(graph,next_ver,curr_ind,path):\n#Insert current vertex into path as next transition\npath[curr_ind]=next_ver\n#Validate created path\nif util_hamilton_cycle(graph,path,curr_ind+1):\nreturn True\n#Backtrack\npath[curr_ind]=-1\nreturn False"
        },
        {
            "type": "FunctionDecl",
            "name": "hamilton_cycle",
            "range": [
                270,
                387
            ],
            "children": [
                {
                    "type": "ParameterList",
                    "name": "parameters",
                    "range": [
                        272,
                        288
                    ],
                    "children": [
                        {
                            "type": "Parameter",
                            "name": "graph",
                            "range": [
                                273,
                                281
                            ],
                            "children": [],
                            "content": "def hamilton_cycle(graph:list[list["
                        },
                        {
                            "type": "Parameter",
                            "name": "start_index",
                            "range": [
                                283,
                                287
                            ],
                            "children": [],
                            "content": "]],start_index:"
                        }
                    ],
                    "content": "\ndef hamilton_cycle(graph:list[list[int]],start_index:int"
                },
                {
                    "type": "ReturnType",
                    "name": "return_type",
                    "range": [
                        289,
                        294
                    ],
                    "children": [],
                    "content": "=0)->list"
                },
                {
                    "type": "BlockStatement",
                    "name": "body",
                    "range": [
                        296,
                        387
                    ],
                    "children": [
                        {
                            "type": "Comment",
                            "name": "comment",
                            "range": [
                                297,
                                300
                            ],
                            "children": [],
                            "content": "]:\nr"
                        },
                        {
                            "type": "VariableDeclaration",
                            "name": "path_initialization",
                            "range": [
                                319,
                                334
                            ],
                            "children": [],
                            "content": "them yet\npath=[-1]*(len(graph)+"
                        },
                        {
                            "type": "Comment",
                            "name": "comment",
                            "range": [
                                335,
                                345
                            ],
                            "children": [],
                            "content": "1)\n#initialize start and end of path with"
                        },
                        {
                            "type": "AssignmentExpression",
                            "name": "path_start_end_initialization",
                            "range": [
                                346,
                                358
                            ],
                            "children": [],
                            "content": "starting index\npath[0]=path[-1]"
                        },
                        {
                            "type": "Comment",
                            "name": "comment",
                            "range": [
                                359,
                                372
                            ],
                            "children": [],
                            "content": "=start_index\n#evaluate and if we find answer return path either return"
                        },
                        {
                            "type": "ReturnStatement",
                            "name": "return_statement",
                            "range": [
                                373,
                                387
                            ],
                            "children": [
                                {
                                    "type": "ConditionalExpression",
                                    "name": "conditional_expression",
                                    "range": [
                                        375,
                                        386
                                    ],
                                    "children": [
                                        {
                                            "type": "CallExpression",
                                            "name": "util_hamilton_cycle",
                                            "range": [
                                                376,
                                                383
                                            ],
                                            "children": [],
                                            "content": "return path if util_hamilton_cycle(graph,path"
                                        },
                                        {
                                            "type": "ArrayExpression",
                                            "name": "empty_array",
                                            "range": [
                                                385,
                                                386
                                            ],
                                            "children": [],
                                            "content": "1)"
                                        }
                                    ],
                                    "content": "\nreturn path if util_hamilton_cycle(graph,path,1)"
                                }
                            ],
                            "content": "empty array\nreturn path if util_hamilton_cycle(graph,path,1)else"
                        }
                    ],
                    "content": "int]:\nr\"\"\" \\n     Wrapper function to call subroutine called util_hamilton_cycle, \\n     which will either return array of vertices indicating hamiltonian cycle \\n     or an empty list indicating that hamiltonian cycle was not found. \\n     Case 1: \\n     Following graph consists of 5 edges. \\n     If we look closely, we can see that there are multiple Hamiltonian cycles. \\n     For example one result is when we iterate like: \\n     (0)->(1)->(2)->(4)->(3)->(0) \\n  \\n     (0)---(1)---(2) \\n      |   /   \\   | \\n      |  /     \\  | \\n      | /       \\ | \\n      |/         \\| \\n     (3)---------(4) \\n     >>> graph = [[0, 1, 0, 1, 0], \\n     ...          [1, 0, 1, 1, 1], \\n     ...          [0, 1, 0, 0, 1], \\n     ...          [1, 1, 0, 0, 1], \\n     ...          [0, 1, 1, 1, 0]] \\n     >>> hamilton_cycle(graph) \\n     [0, 1, 2, 4, 3, 0] \\n  \\n     Case 2: \\n     Same Graph as it was in Case 1, changed starting index from default to 3 \\n  \\n     (0)---(1)---(2) \\n      |   /   \\   | \\n      |  /     \\  | \\n      | /       \\ | \\n      |/         \\| \\n     (3)---------(4) \\n     >>> graph = [[0, 1, 0, 1, 0], \\n     ...          [1, 0, 1, 1, 1], \\n     ...          [0, 1, 0, 0, 1], \\n     ...          [1, 1, 0, 0, 1], \\n     ...          [0, 1, 1, 1, 0]] \\n     >>> hamilton_cycle(graph, 3) \\n     [3, 0, 1, 2, 4, 3] \\n  \\n     Case 3: \\n     Following Graph is exactly what it was before, but edge 3-4 is removed. \\n     Result is that there is no Hamiltonian Cycle anymore. \\n  \\n     (0)---(1)---(2) \\n      |   /   \\   | \\n      |  /     \\  | \\n      | /       \\ | \\n      |/         \\| \\n     (3)         (4) \\n     >>> graph = [[0, 1, 0, 1, 0], \\n     ...          [1, 0, 1, 1, 1], \\n     ...          [0, 1, 0, 0, 1], \\n     ...          [1, 1, 0, 0, 0], \\n     ...          [0, 1, 1, 0, 0]] \\n     >>> hamilton_cycle(graph,4) \\n     [] \\n     \"\"\"\n\n#Initialize path with-1,indicating that we have not visited them yet\npath=[-1]*(len(graph)+1)\n#initialize start and end of path with starting index\npath[0]=path[-1]=start_index\n#evaluate and if we find answer return path either return empty array\nreturn path if util_hamilton_cycle(graph,path,1)else"
                }
            ],
            "content": "\n\n\ndef hamilton_cycle(graph:list[list[int]],start_index:int=0)->list[int]:\nr\"\"\" \\n     Wrapper function to call subroutine called util_hamilton_cycle, \\n     which will either return array of vertices indicating hamiltonian cycle \\n     or an empty list indicating that hamiltonian cycle was not found. \\n     Case 1: \\n     Following graph consists of 5 edges. \\n     If we look closely, we can see that there are multiple Hamiltonian cycles. \\n     For example one result is when we iterate like: \\n     (0)->(1)->(2)->(4)->(3)->(0) \\n  \\n     (0)---(1)---(2) \\n      |   /   \\   | \\n      |  /     \\  | \\n      | /       \\ | \\n      |/         \\| \\n     (3)---------(4) \\n     >>> graph = [[0, 1, 0, 1, 0], \\n     ...          [1, 0, 1, 1, 1], \\n     ...          [0, 1, 0, 0, 1], \\n     ...          [1, 1, 0, 0, 1], \\n     ...          [0, 1, 1, 1, 0]] \\n     >>> hamilton_cycle(graph) \\n     [0, 1, 2, 4, 3, 0] \\n  \\n     Case 2: \\n     Same Graph as it was in Case 1, changed starting index from default to 3 \\n  \\n     (0)---(1)---(2) \\n      |   /   \\   | \\n      |  /     \\  | \\n      | /       \\ | \\n      |/         \\| \\n     (3)---------(4) \\n     >>> graph = [[0, 1, 0, 1, 0], \\n     ...          [1, 0, 1, 1, 1], \\n     ...          [0, 1, 0, 0, 1], \\n     ...          [1, 1, 0, 0, 1], \\n     ...          [0, 1, 1, 1, 0]] \\n     >>> hamilton_cycle(graph, 3) \\n     [3, 0, 1, 2, 4, 3] \\n  \\n     Case 3: \\n     Following Graph is exactly what it was before, but edge 3-4 is removed. \\n     Result is that there is no Hamiltonian Cycle anymore. \\n  \\n     (0)---(1)---(2) \\n      |   /   \\   | \\n      |  /     \\  | \\n      | /       \\ | \\n      |/         \\| \\n     (3)         (4) \\n     >>> graph = [[0, 1, 0, 1, 0], \\n     ...          [1, 0, 1, 1, 1], \\n     ...          [0, 1, 0, 0, 1], \\n     ...          [1, 1, 0, 0, 0], \\n     ...          [0, 1, 1, 0, 0]] \\n     >>> hamilton_cycle(graph,4) \\n     [] \\n     \"\"\"\n\n#Initialize path with-1,indicating that we have not visited them yet\npath=[-1]*(len(graph)+1)\n#initialize start and end of path with starting index\npath[0]=path[-1]=start_index\n#evaluate and if we find answer return path either return empty array\nreturn path if util_hamilton_cycle(graph,path,1)else"
        }
    ],
    "content": "\"\"\" \\n A Hamiltonian cycle (Hamiltonian circuit) is a graph cycle \\n through a graph that visits each node exactly once. \\n Determining whether such paths and cycles exist in graphs \\n is the 'Hamiltonian path problem', which is NP-complete. \\n  \\n Wikipedia: https://en.wikipedia.org/wiki/Hamiltonian_path \\n \"\"\"\n\n\ndef valid_connection(\ngraph:list[list[int]],next_ver:int,curr_ind:int,path:list[int]\n)->bool:\n\"\"\" \\n     Checks whether it is possible to add next into path by validating 2 statements \\n     1. There should be path between current and next vertex \\n     2. Next vertex should not be in path \\n     If both validations succeed we return True, saying that it is possible to connect \\n     this vertices, otherwise we return False \\n  \\n     Case 1:Use exact graph as in main function, with initialized values \\n     >>> graph = [[0, 1, 0, 1, 0], \\n     ...          [1, 0, 1, 1, 1], \\n     ...          [0, 1, 0, 0, 1], \\n     ...          [1, 1, 0, 0, 1], \\n     ...          [0, 1, 1, 1, 0]] \\n     >>> path = [0, -1, -1, -1, -1, 0] \\n     >>> curr_ind = 1 \\n     >>> next_ver = 1 \\n     >>> valid_connection(graph, next_ver, curr_ind, path) \\n     True \\n  \\n     Case 2: Same graph, but trying to connect to node that is already in path \\n     >>> path = [0, 1, 2, 4, -1, 0] \\n     >>> curr_ind = 4 \\n     >>> next_ver = 1 \\n     >>> valid_connection(graph, next_ver, curr_ind, path) \\n     False \\n     \"\"\"\n\n#1.Validate that path exists between current and next vertices\nif graph[path[curr_ind-1]][next_ver]==0:\nreturn False\n\n#2.Validate that next vertex is not already in path\nreturn not any(vertex==next_ver for vertex in path)\n\n\ndef util_hamilton_cycle(graph:list[list[int]],path:list[int],curr_ind:int)->bool:\n\"\"\" \\n     Pseudo-Code \\n     Base Case: \\n     1. Check if we visited all of vertices \\n         1.1 If last visited vertex has path to starting vertex return True either \\n             return False \\n     Recursive Step: \\n     2. Iterate over each vertex \\n         Check if next vertex is valid for transiting from current vertex \\n             2.1 Remember next vertex as next transition \\n             2.2 Do recursive call and check if going to this vertex solves problem \\n             2.3 If next vertex leads to solution return True \\n             2.4 Else backtrack, delete remembered vertex \\n  \\n     Case 1: Use exact graph as in main function, with initialized values \\n     >>> graph = [[0, 1, 0, 1, 0], \\n     ...          [1, 0, 1, 1, 1], \\n     ...          [0, 1, 0, 0, 1], \\n     ...          [1, 1, 0, 0, 1], \\n     ...          [0, 1, 1, 1, 0]] \\n     >>> path = [0, -1, -1, -1, -1, 0] \\n     >>> curr_ind = 1 \\n     >>> util_hamilton_cycle(graph, path, curr_ind) \\n     True \\n     >>> path \\n     [0, 1, 2, 4, 3, 0] \\n  \\n     Case 2: Use exact graph as in previous case, but in the properties taken from \\n         middle of calculation \\n     >>> graph = [[0, 1, 0, 1, 0], \\n     ...          [1, 0, 1, 1, 1], \\n     ...          [0, 1, 0, 0, 1], \\n     ...          [1, 1, 0, 0, 1], \\n     ...          [0, 1, 1, 1, 0]] \\n     >>> path = [0, 1, 2, -1, -1, 0] \\n     >>> curr_ind = 3 \\n     >>> util_hamilton_cycle(graph, path, curr_ind) \\n     True \\n     >>> path \\n     [0, 1, 2, 4, 3, 0] \\n     \"\"\"\n\n#Base Case\nif curr_ind==len(graph):\n#return whether path exists between current and starting vertices\nreturn graph[path[curr_ind-1]][path[0]]==1\n\n#Recursive Step\nfor next_ver in range(len(graph)):\nif valid_connection(graph,next_ver,curr_ind,path):\n#Insert current vertex into path as next transition\npath[curr_ind]=next_ver\n#Validate created path\nif util_hamilton_cycle(graph,path,curr_ind+1):\nreturn True\n#Backtrack\npath[curr_ind]=-1\nreturn False\n\n\ndef hamilton_cycle(graph:list[list[int]],start_index:int=0)->list[int]:\nr\"\"\" \\n     Wrapper function to call subroutine called util_hamilton_cycle, \\n     which will either return array of vertices indicating hamiltonian cycle \\n     or an empty list indicating that hamiltonian cycle was not found. \\n     Case 1: \\n     Following graph consists of 5 edges. \\n     If we look closely, we can see that there are multiple Hamiltonian cycles. \\n     For example one result is when we iterate like: \\n     (0)->(1)->(2)->(4)->(3)->(0) \\n  \\n     (0)---(1)---(2) \\n      |   /   \\   | \\n      |  /     \\  | \\n      | /       \\ | \\n      |/         \\| \\n     (3)---------(4) \\n     >>> graph = [[0, 1, 0, 1, 0], \\n     ...          [1, 0, 1, 1, 1], \\n     ...          [0, 1, 0, 0, 1], \\n     ...          [1, 1, 0, 0, 1], \\n     ...          [0, 1, 1, 1, 0]] \\n     >>> hamilton_cycle(graph) \\n     [0, 1, 2, 4, 3, 0] \\n  \\n     Case 2: \\n     Same Graph as it was in Case 1, changed starting index from default to 3 \\n  \\n     (0)---(1)---(2) \\n      |   /   \\   | \\n      |  /     \\  | \\n      | /       \\ | \\n      |/         \\| \\n     (3)---------(4) \\n     >>> graph = [[0, 1, 0, 1, 0], \\n     ...          [1, 0, 1, 1, 1], \\n     ...          [0, 1, 0, 0, 1], \\n     ...          [1, 1, 0, 0, 1], \\n     ...          [0, 1, 1, 1, 0]] \\n     >>> hamilton_cycle(graph, 3) \\n     [3, 0, 1, 2, 4, 3] \\n  \\n     Case 3: \\n     Following Graph is exactly what it was before, but edge 3-4 is removed. \\n     Result is that there is no Hamiltonian Cycle anymore. \\n  \\n     (0)---(1)---(2) \\n      |   /   \\   | \\n      |  /     \\  | \\n      | /       \\ | \\n      |/         \\| \\n     (3)         (4) \\n     >>> graph = [[0, 1, 0, 1, 0], \\n     ...          [1, 0, 1, 1, 1], \\n     ...          [0, 1, 0, 0, 1], \\n     ...          [1, 1, 0, 0, 0], \\n     ...          [0, 1, 1, 0, 0]] \\n     >>> hamilton_cycle(graph,4) \\n     [] \\n     \"\"\"\n\n#Initialize path with-1,indicating that we have not visited them yet\npath=[-1]*(len(graph)+1)\n#initialize start and end of path with starting index\npath[0]=path[-1]=start_index\n#evaluate and if we find answer return path either return empty array\nreturn path if util_hamilton_cycle(graph,path,1)else"
}