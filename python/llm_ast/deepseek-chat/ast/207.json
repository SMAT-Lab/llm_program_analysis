{
    "type": "Program",
    "name": "Global",
    "range": [
        0,
        396
    ],
    "children": [
        {
            "type": "Comment",
            "name": "",
            "range": [
                1,
                1
            ],
            "children": [],
            "content": "\" \\n Word Ladder is a classic problem in computer science. \\n The problem is to transform a start word into an end word \\n by changing one letter at a time. \\n Each intermediate word must be a valid word from a given list of words. \\n The goal is to find a transformation sequence \\n from the start word to the end word. \\n  \\n Wikipedia: https://en.wikipedia.org/wiki/Word_ladder \\n \""
        },
        {
            "type": "ImportDeclaration",
            "name": "string",
            "range": [
                4,
                5
            ],
            "children": [],
            "content": "\nimport"
        },
        {
            "type": "FunctionDecl",
            "name": "backtrack",
            "range": [
                7,
                267
            ],
            "children": [
                {
                    "type": "Parameters",
                    "name": "parameters",
                    "range": [
                        9,
                        33
                    ],
                    "children": [
                        {
                            "type": "Parameter",
                            "name": "current_word",
                            "range": [
                                11,
                                13
                            ],
                            "children": [],
                            "content": "backtrack(\n"
                        },
                        {
                            "type": "Parameter",
                            "name": "path",
                            "range": [
                                15,
                                20
                            ],
                            "children": [],
                            "content": ":str,path:list"
                        },
                        {
                            "type": "Parameter",
                            "name": "end_word",
                            "range": [
                                22,
                                24
                            ],
                            "children": [],
                            "content": "str],"
                        },
                        {
                            "type": "Parameter",
                            "name": "word_set",
                            "range": [
                                26,
                                31
                            ],
                            "children": [],
                            "content": ":str,word_set:set"
                        }
                    ],
                    "content": "\ndef backtrack(\ncurrent_word:str,path:list[str],end_word:str,word_set:set[str"
                },
                {
                    "type": "ReturnType",
                    "name": "returnType",
                    "range": [
                        34,
                        39
                    ],
                    "children": [],
                    "content": "]\n)->list"
                },
                {
                    "type": "FunctionBody",
                    "name": "body",
                    "range": [
                        41,
                        267
                    ],
                    "children": [
                        {
                            "type": "Docstring",
                            "name": "docstring",
                            "range": [
                                42,
                                110
                            ],
                            "children": [],
                            "content": "]:\n\"\"\" \\n     Helper function to perform backtracking to find the transformation \\n     from the current_word to the end_word. \\n  \\n     Parameters: \\n     current_word (str): The current word in the transformation sequence. \\n     path (list[str]): The list of transformations from begin_word to current_word. \\n     end_word (str): The target word for transformation. \\n     word_set (set[str]): The set of valid words for transformation. \\n  \\n     Returns: \\n     list[str]: The list of transformations from begin_word to end_word. \\n                Returns an empty list if there is no valid \\n                 transformation from current_word to end_word. \\n  \\n     Example: \\n     >>> backtrack(\" hit\", [\"hit\"], \"cog\", {\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog \"}) \\n     ['hit', 'hot', 'dot', 'lot', 'log', 'cog'] \\n  \\n     >>> backtrack(\" hit\", [\"hit\"], \"cog\", {\"hot\", \"dot\", \"dog\", \"lot\", \"log \"}) \\n     [] \\n  \\n     >>> backtrack(\" lead\", [\"lead\"], \"gold\", {\"load\", \"goad\", \"gold\", \"lead\", \"lord \"}) \\n     ['lead', 'lead', 'load', 'goad', 'gold'] \\n  \\n     >>> backtrack(\" game\", [\"game\"], \"code\", {\"came\", \"cage\", \"code\", \"cade\", \""
                        },
                        {
                            "type": "Comment",
                            "name": "comment",
                            "range": [
                                113,
                                129
                            ],
                            "children": [],
                            "content": "\"\"\n\n#Base case:If the current word is the end word,return"
                        },
                        {
                            "type": "IfStatement",
                            "name": "ifStatement",
                            "range": [
                                130,
                                139
                            ],
                            "children": [
                                {
                                    "type": "Condition",
                                    "name": "condition",
                                    "range": [
                                        131,
                                        134
                                    ],
                                    "children": [],
                                    "content": "path\nif current_word"
                                },
                                {
                                    "type": "ReturnStatement",
                                    "name": "returnStatement",
                                    "range": [
                                        137,
                                        138
                                    ],
                                    "children": [],
                                    "content": "end_word:"
                                }
                            ],
                            "content": "the path\nif current_word==end_word:\n"
                        },
                        {
                            "type": "Comment",
                            "name": "comment",
                            "range": [
                                141,
                                149
                            ],
                            "children": [],
                            "content": "path\n\n#Try all possible single-"
                        },
                        {
                            "type": "ForStatement",
                            "name": "forLoop",
                            "range": [
                                150,
                                257
                            ],
                            "children": [
                                {
                                    "type": "Initialization",
                                    "name": "initialization",
                                    "range": [
                                        151,
                                        159
                                    ],
                                    "children": [],
                                    "content": "transformations\nfor i in range(len("
                                },
                                {
                                    "type": "ForStatement",
                                    "name": "nestedForLoop",
                                    "range": [
                                        162,
                                        254
                                    ],
                                    "children": [
                                        {
                                            "type": "Initialization",
                                            "name": "initialization",
                                            "range": [
                                                163,
                                                168
                                            ],
                                            "children": [],
                                            "content": ":\nfor c in string"
                                        },
                                        {
                                            "type": "Body",
                                            "name": "body",
                                            "range": [
                                                175,
                                                253
                                            ],
                                            "children": [
                                                {
                                                    "type": "IfStatement",
                                                    "name": "ifStatement",
                                                    "range": [
                                                        193,
                                                        247
                                                    ],
                                                    "children": [
                                                        {
                                                            "type": "Condition",
                                                            "name": "condition",
                                                            "range": [
                                                                194,
                                                                196
                                                            ],
                                                            "children": [],
                                                            "content": "]\nif"
                                                        },
                                                        {
                                                            "type": "CallExpression",
                                                            "name": "functionCall",
                                                            "range": [
                                                                199,
                                                                204
                                                            ],
                                                            "children": [],
                                                            "content": "word_set:\nword_set.remove"
                                                        },
                                                        {
                                                            "type": "Comment",
                                                            "name": "comment",
                                                            "range": [
                                                                206,
                                                                216
                                                            ],
                                                            "children": [],
                                                            "content": "transformed_word)\n#Recur with the new word added to"
                                                        },
                                                        {
                                                            "type": "CallExpression",
                                                            "name": "functionCall",
                                                            "range": [
                                                                219,
                                                                235
                                                            ],
                                                            "children": [],
                                                            "content": "\nresult=backtrack(\ntransformed_word,[*path,transformed_word],end_word,"
                                                        },
                                                        {
                                                            "type": "IfStatement",
                                                            "name": "ifStatement",
                                                            "range": [
                                                                237,
                                                                246
                                                            ],
                                                            "children": [
                                                                {
                                                                    "type": "Condition",
                                                                    "name": "condition",
                                                                    "range": [
                                                                        238,
                                                                        239
                                                                    ],
                                                                    "children": [],
                                                                    "content": ")\n"
                                                                },
                                                                {
                                                                    "type": "ReturnStatement",
                                                                    "name": "returnStatement",
                                                                    "range": [
                                                                        245,
                                                                        246
                                                                    ],
                                                                    "children": [],
                                                                    "content": "transformation found"
                                                                }
                                                            ],
                                                            "content": "\n)\nif result:#valid transformation found"
                                                        }
                                                    ],
                                                    "content": ":]\nif transformed_word in word_set:\nword_set.remove(transformed_word)\n#Recur with the new word added to the path\nresult=backtrack(\ntransformed_word,[*path,transformed_word],end_word,word_set\n)\nif result:#valid transformation found\n"
                                                },
                                                {
                                                    "type": "CallExpression",
                                                    "name": "functionCall",
                                                    "range": [
                                                        249,
                                                        253
                                                    ],
                                                    "children": [],
                                                    "content": "result\nword_set.add"
                                                }
                                            ],
                                            "content": "each letter\ntransformed_word=current_word[:i]+c+current_word[i+1:]\nif transformed_word in word_set:\nword_set.remove(transformed_word)\n#Recur with the new word added to the path\nresult=backtrack(\ntransformed_word,[*path,transformed_word],end_word,word_set\n)\nif result:#valid transformation found\nreturn result\nword_set.add"
                                        }
                                    ],
                                    "content": "):\nfor c in string.ascii_lowercase:#Try changing each letter\ntransformed_word=current_word[:i]+c+current_word[i+1:]\nif transformed_word in word_set:\nword_set.remove(transformed_word)\n#Recur with the new word added to the path\nresult=backtrack(\ntransformed_word,[*path,transformed_word],end_word,word_set\n)\nif result:#valid transformation found\nreturn result\nword_set.add("
                                }
                            ],
                            "content": "letter transformations\nfor i in range(len(current_word)):\nfor c in string.ascii_lowercase:#Try changing each letter\ntransformed_word=current_word[:i]+c+current_word[i+1:]\nif transformed_word in word_set:\nword_set.remove(transformed_word)\n#Recur with the new word added to the path\nresult=backtrack(\ntransformed_word,[*path,transformed_word],end_word,word_set\n)\nif result:#valid transformation found\nreturn result\nword_set.add(transformed_word)#"
                        },
                        {
                            "type": "ReturnStatement",
                            "name": "returnStatement",
                            "range": [
                                258,
                                260
                            ],
                            "children": [],
                            "content": "backtrack\n\n"
                        },
                        {
                            "type": "Comment",
                            "name": "comment",
                            "range": [
                                261,
                                266
                            ],
                            "children": [],
                            "content": "return[]#No valid"
                        }
                    ],
                    "content": "str]:\n\"\"\" \\n     Helper function to perform backtracking to find the transformation \\n     from the current_word to the end_word. \\n  \\n     Parameters: \\n     current_word (str): The current word in the transformation sequence. \\n     path (list[str]): The list of transformations from begin_word to current_word. \\n     end_word (str): The target word for transformation. \\n     word_set (set[str]): The set of valid words for transformation. \\n  \\n     Returns: \\n     list[str]: The list of transformations from begin_word to end_word. \\n                Returns an empty list if there is no valid \\n                 transformation from current_word to end_word. \\n  \\n     Example: \\n     >>> backtrack(\" hit\", [\"hit\"], \"cog\", {\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog \"}) \\n     ['hit', 'hot', 'dot', 'lot', 'log', 'cog'] \\n  \\n     >>> backtrack(\" hit\", [\"hit\"], \"cog\", {\"hot\", \"dot\", \"dog\", \"lot\", \"log \"}) \\n     [] \\n  \\n     >>> backtrack(\" lead\", [\"lead\"], \"gold\", {\"load\", \"goad\", \"gold\", \"lead\", \"lord \"}) \\n     ['lead', 'lead', 'load', 'goad', 'gold'] \\n  \\n     >>> backtrack(\" game\", [\"game\"], \"code\", {\"came\", \"cage\", \"code\", \"cade\", \"gave \"}) \\n     ['game', 'came', 'cade', 'code'] \\n     \"\"\"\n\n#Base case:If the current word is the end word,return the path\nif current_word==end_word:\nreturn path\n\n#Try all possible single-letter transformations\nfor i in range(len(current_word)):\nfor c in string.ascii_lowercase:#Try changing each letter\ntransformed_word=current_word[:i]+c+current_word[i+1:]\nif transformed_word in word_set:\nword_set.remove(transformed_word)\n#Recur with the new word added to the path\nresult=backtrack(\ntransformed_word,[*path,transformed_word],end_word,word_set\n)\nif result:#valid transformation found\nreturn result\nword_set.add(transformed_word)#backtrack\n\nreturn[]#No valid transformation"
                }
            ],
            "content": "\n\n\ndef backtrack(\ncurrent_word:str,path:list[str],end_word:str,word_set:set[str]\n)->list[str]:\n\"\"\" \\n     Helper function to perform backtracking to find the transformation \\n     from the current_word to the end_word. \\n  \\n     Parameters: \\n     current_word (str): The current word in the transformation sequence. \\n     path (list[str]): The list of transformations from begin_word to current_word. \\n     end_word (str): The target word for transformation. \\n     word_set (set[str]): The set of valid words for transformation. \\n  \\n     Returns: \\n     list[str]: The list of transformations from begin_word to end_word. \\n                Returns an empty list if there is no valid \\n                 transformation from current_word to end_word. \\n  \\n     Example: \\n     >>> backtrack(\" hit\", [\"hit\"], \"cog\", {\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog \"}) \\n     ['hit', 'hot', 'dot', 'lot', 'log', 'cog'] \\n  \\n     >>> backtrack(\" hit\", [\"hit\"], \"cog\", {\"hot\", \"dot\", \"dog\", \"lot\", \"log \"}) \\n     [] \\n  \\n     >>> backtrack(\" lead\", [\"lead\"], \"gold\", {\"load\", \"goad\", \"gold\", \"lead\", \"lord \"}) \\n     ['lead', 'lead', 'load', 'goad', 'gold'] \\n  \\n     >>> backtrack(\" game\", [\"game\"], \"code\", {\"came\", \"cage\", \"code\", \"cade\", \"gave \"}) \\n     ['game', 'came', 'cade', 'code'] \\n     \"\"\"\n\n#Base case:If the current word is the end word,return the path\nif current_word==end_word:\nreturn path\n\n#Try all possible single-letter transformations\nfor i in range(len(current_word)):\nfor c in string.ascii_lowercase:#Try changing each letter\ntransformed_word=current_word[:i]+c+current_word[i+1:]\nif transformed_word in word_set:\nword_set.remove(transformed_word)\n#Recur with the new word added to the path\nresult=backtrack(\ntransformed_word,[*path,transformed_word],end_word,word_set\n)\nif result:#valid transformation found\nreturn result\nword_set.add(transformed_word)#backtrack\n\nreturn[]#No valid transformation"
        },
        {
            "type": "FunctionDecl",
            "name": "word_ladder",
            "range": [
                268,
                396
            ],
            "children": [
                {
                    "type": "Parameters",
                    "name": "parameters",
                    "range": [
                        270,
                        285
                    ],
                    "children": [
                        {
                            "type": "Parameter",
                            "name": "begin_word",
                            "range": [
                                271,
                                273
                            ],
                            "children": [],
                            "content": "\ndef word_ladder"
                        },
                        {
                            "type": "Parameter",
                            "name": "end_word",
                            "range": [
                                275,
                                277
                            ],
                            "children": [],
                            "content": "begin_word:str"
                        },
                        {
                            "type": "Parameter",
                            "name": "word_set",
                            "range": [
                                279,
                                284
                            ],
                            "children": [],
                            "content": "end_word:str,word_set:"
                        }
                    ],
                    "content": "\n\ndef word_ladder(begin_word:str,end_word:str,word_set:set"
                },
                {
                    "type": "ReturnType",
                    "name": "return_type",
                    "range": [
                        286,
                        291
                    ],
                    "children": [],
                    "content": "[str])->"
                },
                {
                    "type": "Docstring",
                    "name": "docstring",
                    "range": [
                        294,
                        354
                    ],
                    "children": [],
                    "content": "str]:\n\"\"\" \\n     Solve the Word Ladder problem using Backtracking and return \\n     the list of transformations from begin_word to end_word. \\n  \\n     Parameters: \\n     begin_word (str): The word from which the transformation starts. \\n     end_word (str): The target word for transformation. \\n     word_list (list[str]): The list of valid words for transformation. \\n  \\n     Returns: \\n     list[str]: The list of transformations from begin_word to end_word. \\n                Returns an empty list if there is no valid transformation. \\n  \\n     Example: \\n     >>> word_ladder(\" hit\", \"cog\", [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog \"]) \\n     ['hit', 'hot', 'dot', 'lot', 'log', 'cog'] \\n  \\n     >>> word_ladder(\" hit\", \"cog\", [\"hot\", \"dot\", \"dog\", \"lot\", \"log \"]) \\n     [] \\n  \\n     >>> word_ladder(\" lead\", \"gold\", [\"load\", \"goad\", \"gold\", \"lead\", \"lord \"]) \\n     ['lead', 'lead', 'load', 'goad', 'gold'] \\n  \\n     >>> word_ladder(\" game\", \"code\", [\"came\", \"cage\", \"code\", \"cade"
                },
                {
                    "type": "IfStatement",
                    "name": "if_statement",
                    "range": [
                        357,
                        372
                    ],
                    "children": [
                        {
                            "type": "Condition",
                            "name": "condition",
                            "range": [
                                358,
                                361
                            ],
                            "children": [],
                            "content": "\"\"\n\nif"
                        },
                        {
                            "type": "Body",
                            "name": "body",
                            "range": [
                                362,
                                372
                            ],
                            "children": [
                                {
                                    "type": "ReturnStatement",
                                    "name": "return_statement",
                                    "range": [
                                        369,
                                        371
                                    ],
                                    "children": [],
                                    "content": "valid transformation possible"
                                }
                            ],
                            "content": "end_word not in word_set:#no valid transformation possible\n"
                        }
                    ],
                    "content": "\"]) \\n     ['game', 'came', 'cade', 'code'] \\n     \"\"\"\n\nif end_word not in word_set:#no valid transformation possible\n"
                },
                {
                    "type": "ReturnStatement",
                    "name": "return_statement",
                    "range": [
                        382,
                        395
                    ],
                    "children": [
                        {
                            "type": "CallExpression",
                            "name": "backtrack",
                            "range": [
                                383,
                                394
                            ],
                            "children": [
                                {
                                    "type": "Arguments",
                                    "name": "arguments",
                                    "range": [
                                        384,
                                        394
                                    ],
                                    "children": [
                                        {
                                            "type": "Identifier",
                                            "name": "begin_word",
                                            "range": [
                                                385,
                                                385
                                            ],
                                            "children": [],
                                            "content": "\n"
                                        },
                                        {
                                            "type": "Identifier",
                                            "name": "list",
                                            "range": [
                                                387,
                                                389
                                            ],
                                            "children": [],
                                            "content": "backtrack(begin_word"
                                        },
                                        {
                                            "type": "Identifier",
                                            "name": "end_word",
                                            "range": [
                                                391,
                                                391
                                            ],
                                            "children": [],
                                            "content": "["
                                        },
                                        {
                                            "type": "Identifier",
                                            "name": "word_set",
                                            "range": [
                                                393,
                                                393
                                            ],
                                            "children": [],
                                            "content": "]"
                                        }
                                    ],
                                    "content": "begin_word\nreturn backtrack(begin_word,[begin_word],"
                                }
                            ],
                            "content": "the begin_word\nreturn backtrack(begin_word,[begin_word],"
                        }
                    ],
                    "content": "from the begin_word\nreturn backtrack(begin_word,[begin_word],end_word"
                }
            ],
            "content": "found\n\n\ndef word_ladder(begin_word:str,end_word:str,word_set:set[str])->list[str]:\n\"\"\" \\n     Solve the Word Ladder problem using Backtracking and return \\n     the list of transformations from begin_word to end_word. \\n  \\n     Parameters: \\n     begin_word (str): The word from which the transformation starts. \\n     end_word (str): The target word for transformation. \\n     word_list (list[str]): The list of valid words for transformation. \\n  \\n     Returns: \\n     list[str]: The list of transformations from begin_word to end_word. \\n                Returns an empty list if there is no valid transformation. \\n  \\n     Example: \\n     >>> word_ladder(\" hit\", \"cog\", [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog \"]) \\n     ['hit', 'hot', 'dot', 'lot', 'log', 'cog'] \\n  \\n     >>> word_ladder(\" hit\", \"cog\", [\"hot\", \"dot\", \"dog\", \"lot\", \"log \"]) \\n     [] \\n  \\n     >>> word_ladder(\" lead\", \"gold\", [\"load\", \"goad\", \"gold\", \"lead\", \"lord \"]) \\n     ['lead', 'lead', 'load', 'goad', 'gold'] \\n  \\n     >>> word_ladder(\" game\", \"code\", [\"came\", \"cage\", \"code\", \"cade\", \"gave \"]) \\n     ['game', 'came', 'cade', 'code'] \\n     \"\"\"\n\nif end_word not in word_set:#no valid transformation possible\nreturn[]\n\n#Perform backtracking starting from the begin_word\nreturn backtrack(begin_word,[begin_word],end_word,"
        }
    ],
    "content": "\"\"\" \\n Word Ladder is a classic problem in computer science. \\n The problem is to transform a start word into an end word \\n by changing one letter at a time. \\n Each intermediate word must be a valid word from a given list of words. \\n The goal is to find a transformation sequence \\n from the start word to the end word. \\n  \\n Wikipedia: https://en.wikipedia.org/wiki/Word_ladder \\n \"\"\"\n\nimport string\n\n\ndef backtrack(\ncurrent_word:str,path:list[str],end_word:str,word_set:set[str]\n)->list[str]:\n\"\"\" \\n     Helper function to perform backtracking to find the transformation \\n     from the current_word to the end_word. \\n  \\n     Parameters: \\n     current_word (str): The current word in the transformation sequence. \\n     path (list[str]): The list of transformations from begin_word to current_word. \\n     end_word (str): The target word for transformation. \\n     word_set (set[str]): The set of valid words for transformation. \\n  \\n     Returns: \\n     list[str]: The list of transformations from begin_word to end_word. \\n                Returns an empty list if there is no valid \\n                 transformation from current_word to end_word. \\n  \\n     Example: \\n     >>> backtrack(\" hit\", [\"hit\"], \"cog\", {\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog \"}) \\n     ['hit', 'hot', 'dot', 'lot', 'log', 'cog'] \\n  \\n     >>> backtrack(\" hit\", [\"hit\"], \"cog\", {\"hot\", \"dot\", \"dog\", \"lot\", \"log \"}) \\n     [] \\n  \\n     >>> backtrack(\" lead\", [\"lead\"], \"gold\", {\"load\", \"goad\", \"gold\", \"lead\", \"lord \"}) \\n     ['lead', 'lead', 'load', 'goad', 'gold'] \\n  \\n     >>> backtrack(\" game\", [\"game\"], \"code\", {\"came\", \"cage\", \"code\", \"cade\", \"gave \"}) \\n     ['game', 'came', 'cade', 'code'] \\n     \"\"\"\n\n#Base case:If the current word is the end word,return the path\nif current_word==end_word:\nreturn path\n\n#Try all possible single-letter transformations\nfor i in range(len(current_word)):\nfor c in string.ascii_lowercase:#Try changing each letter\ntransformed_word=current_word[:i]+c+current_word[i+1:]\nif transformed_word in word_set:\nword_set.remove(transformed_word)\n#Recur with the new word added to the path\nresult=backtrack(\ntransformed_word,[*path,transformed_word],end_word,word_set\n)\nif result:#valid transformation found\nreturn result\nword_set.add(transformed_word)#backtrack\n\nreturn[]#No valid transformation found\n\n\ndef word_ladder(begin_word:str,end_word:str,word_set:set[str])->list[str]:\n\"\"\" \\n     Solve the Word Ladder problem using Backtracking and return \\n     the list of transformations from begin_word to end_word. \\n  \\n     Parameters: \\n     begin_word (str): The word from which the transformation starts. \\n     end_word (str): The target word for transformation. \\n     word_list (list[str]): The list of valid words for transformation. \\n  \\n     Returns: \\n     list[str]: The list of transformations from begin_word to end_word. \\n                Returns an empty list if there is no valid transformation. \\n  \\n     Example: \\n     >>> word_ladder(\" hit\", \"cog\", [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog \"]) \\n     ['hit', 'hot', 'dot', 'lot', 'log', 'cog'] \\n  \\n     >>> word_ladder(\" hit\", \"cog\", [\"hot\", \"dot\", \"dog\", \"lot\", \"log \"]) \\n     [] \\n  \\n     >>> word_ladder(\" lead\", \"gold\", [\"load\", \"goad\", \"gold\", \"lead\", \"lord \"]) \\n     ['lead', 'lead', 'load', 'goad', 'gold'] \\n  \\n     >>> word_ladder(\" game\", \"code\", [\"came\", \"cage\", \"code\", \"cade\", \"gave \"]) \\n     ['game', 'came', 'cade', 'code'] \\n     \"\"\"\n\nif end_word not in word_set:#no valid transformation possible\nreturn[]\n\n#Perform backtracking starting from the begin_word\nreturn backtrack(begin_word,[begin_word],end_word,"
}