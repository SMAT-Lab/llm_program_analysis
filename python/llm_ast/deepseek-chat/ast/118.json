{
    "type": "Program",
    "name": "Global",
    "range": [
        0,
        225
    ],
    "children": [
        {
            "type": "Literal",
            "name": "",
            "range": [
                0,
                12
            ],
            "children": [
                {
                    "type": "Text",
                    "name": "",
                    "range": [
                        1,
                        11
                    ],
                    "children": [],
                    "content": "\" \\n author: Aayush Soni \\n Given n pairs of parentheses, write a function to generate all \\n combinations of well-formed parentheses. \\n Input: n = 2 \\n Output: [\"(())\",\"()()\"] \\n Leetcode link: https://leetcode.com/problems/generate-parentheses/description/ \\n \""
                }
            ],
            "content": "\"\"\" \\n author: Aayush Soni \\n Given n pairs of parentheses, write a function to generate all \\n combinations of well-formed parentheses. \\n Input: n = 2 \\n Output: [\"(())\",\"()()\"] \\n Leetcode link: https://leetcode.com/problems/generate-parentheses/description/ \\n \"\"\""
        },
        {
            "type": "NewLine",
            "name": "",
            "range": [
                13,
                13
            ],
            "children": [],
            "content": "\n"
        },
        {
            "type": "FunctionDecl",
            "name": "backtrack",
            "range": [
                14,
                179
            ],
            "children": [
                {
                    "type": "ParameterList",
                    "name": "parameters",
                    "range": [
                        16,
                        41
                    ],
                    "children": [
                        {
                            "type": "Parameter",
                            "name": "partial",
                            "range": [
                                18,
                                20
                            ],
                            "children": [],
                            "content": "(\npartial"
                        },
                        {
                            "type": "Parameter",
                            "name": "open_count",
                            "range": [
                                22,
                                24
                            ],
                            "children": [],
                            "content": "str,open_count"
                        },
                        {
                            "type": "Parameter",
                            "name": "close_count",
                            "range": [
                                26,
                                28
                            ],
                            "children": [],
                            "content": "int,close_count"
                        },
                        {
                            "type": "Parameter",
                            "name": "n",
                            "range": [
                                30,
                                32
                            ],
                            "children": [],
                            "content": "int,n"
                        },
                        {
                            "type": "Parameter",
                            "name": "result",
                            "range": [
                                34,
                                39
                            ],
                            "children": [],
                            "content": "int,result:list["
                        }
                    ],
                    "content": "def backtrack(\npartial:str,open_count:int,close_count:int,n:int,result:list[str]"
                },
                {
                    "type": "ReturnType",
                    "name": "None",
                    "range": [
                        42,
                        44
                    ],
                    "children": [],
                    "content": "\n)-"
                },
                {
                    "type": "Block",
                    "name": "body",
                    "range": [
                        46,
                        179
                    ],
                    "children": [
                        {
                            "type": "Docstring",
                            "name": "docstring",
                            "range": [
                                47,
                                50
                            ],
                            "children": [],
                            "content": ":\n\"\"\" \\n     Generate valid combinations of balanced parentheses using recursion. \\n  \\n     :param partial: A string representing the current combination. \\n     :param open_count: An integer representing the count of open parentheses. \\n     :param close_count: An integer representing the count of close parentheses. \\n     :param n: An integer representing the total number of pairs. \\n     :param result: A list to store valid combinations. \\n     :return: None \\n  \\n     This function uses recursion to explore all possible combinations, \\n     ensuring that at each step, the parentheses remain balanced. \\n  \\n     Example: \\n     >>> result = [] \\n     >>> backtrack(\""
                        },
                        {
                            "type": "IfStatement",
                            "name": "if",
                            "range": [
                                52,
                                86
                            ],
                            "children": [
                                {
                                    "type": "Condition",
                                    "name": "condition",
                                    "range": [
                                        53,
                                        62
                                    ],
                                    "children": [],
                                    "content": "\nif len(partial)==2*"
                                },
                                {
                                    "type": "Block",
                                    "name": "then",
                                    "range": [
                                        63,
                                        86
                                    ],
                                    "children": [
                                        {
                                            "type": "Comment",
                                            "name": "comment",
                                            "range": [
                                                64,
                                                76
                                            ],
                                            "children": [],
                                            "content": ":\n#When the combination is complete,add it to the"
                                        },
                                        {
                                            "type": "ExpressionStatement",
                                            "name": "append",
                                            "range": [
                                                78,
                                                83
                                            ],
                                            "children": [],
                                            "content": ".\nresult.append("
                                        },
                                        {
                                            "type": "ReturnStatement",
                                            "name": "return",
                                            "range": [
                                                85,
                                                86
                                            ],
                                            "children": [],
                                            "content": ")\n"
                                        }
                                    ],
                                    "content": "n:\n#When the combination is complete,add it to the result.\nresult.append(partial)\n"
                                }
                            ],
                            "content": "\"\"\nif len(partial)==2*n:\n#When the combination is complete,add it to the result.\nresult.append(partial)\n"
                        },
                        {
                            "type": "IfStatement",
                            "name": "if",
                            "range": [
                                88,
                                126
                            ],
                            "children": [
                                {
                                    "type": "Condition",
                                    "name": "condition",
                                    "range": [
                                        89,
                                        92
                                    ],
                                    "children": [],
                                    "content": "\nif open_count<"
                                },
                                {
                                    "type": "Block",
                                    "name": "then",
                                    "range": [
                                        93,
                                        126
                                    ],
                                    "children": [
                                        {
                                            "type": "Comment",
                                            "name": "comment",
                                            "range": [
                                                94,
                                                108
                                            ],
                                            "children": [],
                                            "content": ":\n#If we can add an open parenthesis,do so,and"
                                        },
                                        {
                                            "type": "ExpressionStatement",
                                            "name": "backtrack",
                                            "range": [
                                                110,
                                                125
                                            ],
                                            "children": [],
                                            "content": ".\nbacktrack(partial+\"(\",open_count+1,close_count,n,"
                                        }
                                    ],
                                    "content": "n:\n#If we can add an open parenthesis,do so,and recurse.\nbacktrack(partial+\"(\",open_count+1,close_count,n,result"
                                }
                            ],
                            "content": "\n\nif open_count<n:\n#If we can add an open parenthesis,do so,and recurse.\nbacktrack(partial+\"(\",open_count+1,close_count,n,result"
                        },
                        {
                            "type": "IfStatement",
                            "name": "if",
                            "range": [
                                128,
                                178
                            ],
                            "children": [
                                {
                                    "type": "Condition",
                                    "name": "condition",
                                    "range": [
                                        129,
                                        132
                                    ],
                                    "children": [],
                                    "content": "\nif close_count<"
                                },
                                {
                                    "type": "Block",
                                    "name": "then",
                                    "range": [
                                        133,
                                        178
                                    ],
                                    "children": [
                                        {
                                            "type": "Comment",
                                            "name": "comment",
                                            "range": [
                                                134,
                                                160
                                            ],
                                            "children": [],
                                            "content": ":\n#If we can add a close parenthesis(it won 't make the combination invalid), \\n         # do so, and recurse. \\n         backtrack(partial + \")\", open_count, close_count + 1, n, result) \\n  \\n  \\n def generate_parenthesis(n: int) -> list[str]: \\n     \"\"\" \\n     Generate valid combinations of balanced parentheses for a given n. \\n  \\n     :param n: An integer representing the number of pairs of parentheses. \\n     :return: A list of strings with valid combinations. \\n  \\n     This function uses a recursive approach to generate the combinations. \\n  \\n     Time Complexity: O(2^(2n)) - In the worst case, we have 2^(2n) combinations. \\n     Space Complexity: O(n) - where ' n ' is the number of pairs. \\n  \\n     Example 1: \\n     >>> generate_parenthesis(3) \\n     ['((()))', '(()("
                                        },
                                        {
                                            "type": "ExpressionStatement",
                                            "name": "backtrack",
                                            "range": [
                                                162,
                                                177
                                            ],
                                            "children": [],
                                            "content": ")', '(())()', '()(())', '"
                                        }
                                    ],
                                    "content": "open_count:\n#If we can add a close parenthesis(it won 't make the combination invalid), \\n         # do so, and recurse. \\n         backtrack(partial + \")\", open_count, close_count + 1, n, result) \\n  \\n  \\n def generate_parenthesis(n: int) -> list[str]: \\n     \"\"\" \\n     Generate valid combinations of balanced parentheses for a given n. \\n  \\n     :param n: An integer representing the number of pairs of parentheses. \\n     :return: A list of strings with valid combinations. \\n  \\n     This function uses a recursive approach to generate the combinations. \\n  \\n     Time Complexity: O(2^(2n)) - In the worst case, we have 2^(2n) combinations. \\n     Space Complexity: O(n) - where ' n ' is the number of pairs. \\n  \\n     Example 1: \\n     >>> generate_parenthesis(3) \\n     ['((()))', '(()())', '(())()', '()(())', '("
                                }
                            ],
                            "content": "\n\nif close_count<open_count:\n#If we can add a close parenthesis(it won 't make the combination invalid), \\n         # do so, and recurse. \\n         backtrack(partial + \")\", open_count, close_count + 1, n, result) \\n  \\n  \\n def generate_parenthesis(n: int) -> list[str]: \\n     \"\"\" \\n     Generate valid combinations of balanced parentheses for a given n. \\n  \\n     :param n: An integer representing the number of pairs of parentheses. \\n     :return: A list of strings with valid combinations. \\n  \\n     This function uses a recursive approach to generate the combinations. \\n  \\n     Time Complexity: O(2^(2n)) - In the worst case, we have 2^(2n) combinations. \\n     Space Complexity: O(n) - where ' n ' is the number of pairs. \\n  \\n     Example 1: \\n     >>> generate_parenthesis(3) \\n     ['((()))', '(()())', '(())()', '()(())', '("
                        }
                    ],
                    "content": "None:\n\"\"\" \\n     Generate valid combinations of balanced parentheses using recursion. \\n  \\n     :param partial: A string representing the current combination. \\n     :param open_count: An integer representing the count of open parentheses. \\n     :param close_count: An integer representing the count of close parentheses. \\n     :param n: An integer representing the total number of pairs. \\n     :param result: A list to store valid combinations. \\n     :return: None \\n  \\n     This function uses recursion to explore all possible combinations, \\n     ensuring that at each step, the parentheses remain balanced. \\n  \\n     Example: \\n     >>> result = [] \\n     >>> backtrack(\" \", 0, 0, 2, result) \\n     >>> result \\n     ['(())', '()()'] \\n     \"\"\"\nif len(partial)==2*n:\n#When the combination is complete,add it to the result.\nresult.append(partial)\nreturn\n\nif open_count<n:\n#If we can add an open parenthesis,do so,and recurse.\nbacktrack(partial+\"(\",open_count+1,close_count,n,result)\n\nif close_count<open_count:\n#If we can add a close parenthesis(it won 't make the combination invalid), \\n         # do so, and recurse. \\n         backtrack(partial + \")\", open_count, close_count + 1, n, result) \\n  \\n  \\n def generate_parenthesis(n: int) -> list[str]: \\n     \"\"\" \\n     Generate valid combinations of balanced parentheses for a given n. \\n  \\n     :param n: An integer representing the number of pairs of parentheses. \\n     :return: A list of strings with valid combinations. \\n  \\n     This function uses a recursive approach to generate the combinations. \\n  \\n     Time Complexity: O(2^(2n)) - In the worst case, we have 2^(2n) combinations. \\n     Space Complexity: O(n) - where ' n ' is the number of pairs. \\n  \\n     Example 1: \\n     >>> generate_parenthesis(3) \\n     ['((()))', '(()())', '(())()', '()(())', '()"
                }
            ],
            "content": "\n\ndef backtrack(\npartial:str,open_count:int,close_count:int,n:int,result:list[str]\n)->None:\n\"\"\" \\n     Generate valid combinations of balanced parentheses using recursion. \\n  \\n     :param partial: A string representing the current combination. \\n     :param open_count: An integer representing the count of open parentheses. \\n     :param close_count: An integer representing the count of close parentheses. \\n     :param n: An integer representing the total number of pairs. \\n     :param result: A list to store valid combinations. \\n     :return: None \\n  \\n     This function uses recursion to explore all possible combinations, \\n     ensuring that at each step, the parentheses remain balanced. \\n  \\n     Example: \\n     >>> result = [] \\n     >>> backtrack(\" \", 0, 0, 2, result) \\n     >>> result \\n     ['(())', '()()'] \\n     \"\"\"\nif len(partial)==2*n:\n#When the combination is complete,add it to the result.\nresult.append(partial)\nreturn\n\nif open_count<n:\n#If we can add an open parenthesis,do so,and recurse.\nbacktrack(partial+\"(\",open_count+1,close_count,n,result)\n\nif close_count<open_count:\n#If we can add a close parenthesis(it won 't make the combination invalid), \\n         # do so, and recurse. \\n         backtrack(partial + \")\", open_count, close_count + 1, n, result) \\n  \\n  \\n def generate_parenthesis(n: int) -> list[str]: \\n     \"\"\" \\n     Generate valid combinations of balanced parentheses for a given n. \\n  \\n     :param n: An integer representing the number of pairs of parentheses. \\n     :return: A list of strings with valid combinations. \\n  \\n     This function uses a recursive approach to generate the combinations. \\n  \\n     Time Complexity: O(2^(2n)) - In the worst case, we have 2^(2n) combinations. \\n     Space Complexity: O(n) - where ' n ' is the number of pairs. \\n  \\n     Example 1: \\n     >>> generate_parenthesis(3) \\n     ['((()))', '(()())', '(())()', '()(())', '()"
        },
        {
            "type": "FunctionDecl",
            "name": "generate_parenthesis",
            "range": [
                180,
                225
            ],
            "children": [
                {
                    "type": "Parameter",
                    "name": "n",
                    "range": [
                        183,
                        185
                    ],
                    "children": [],
                    "content": ")'] \\n  \\n     Example 2: \\n     >>> generate_parenthesis(1) \\n     ['("
                },
                {
                    "type": "ReturnType",
                    "name": "list[str]",
                    "range": [
                        189,
                        192
                    ],
                    "children": [],
                    "content": "\n\"\"\" \\n  \\n     result: list[str] = [] \\n     backtrack(\" \", 0, 0, n, result) \\n     return result \\n  \\n  \\n if __name__ == \""
                },
                {
                    "type": "Docstring",
                    "name": "docstring",
                    "range": [
                        195,
                        197
                    ],
                    "children": [],
                    "content": ":\nimport"
                },
                {
                    "type": "VariableDecl",
                    "name": "result",
                    "range": [
                        200,
                        205
                    ],
                    "children": [],
                    "content": "\ndoctest.testmod()"
                },
                {
                    "type": "Assignment",
                    "name": "result",
                    "range": [
                        206,
                        208
                    ],
                    "children": [],
                    "content": "\n"
                },
                {
                    "type": "CallExpression",
                    "name": "backtrack",
                    "range": [
                        210,
                        221
                    ],
                    "children": [
                        {
                            "type": "Literal",
                            "name": "\"\"",
                            "range": [
                                212,
                                212
                            ],
                            "children": [],
                            "content": ""
                        },
                        {
                            "type": "Literal",
                            "name": "0",
                            "range": [
                                214,
                                214
                            ],
                            "children": [],
                            "content": ""
                        },
                        {
                            "type": "Literal",
                            "name": "0",
                            "range": [
                                216,
                                216
                            ],
                            "children": [],
                            "content": ""
                        },
                        {
                            "type": "Identifier",
                            "name": "n",
                            "range": [
                                218,
                                218
                            ],
                            "children": [],
                            "content": ""
                        },
                        {
                            "type": "Identifier",
                            "name": "result",
                            "range": [
                                220,
                                220
                            ],
                            "children": [],
                            "content": ""
                        }
                    ],
                    "content": ""
                },
                {
                    "type": "ReturnStatement",
                    "name": "return",
                    "range": [
                        223,
                        224
                    ],
                    "children": [],
                    "content": ""
                }
            ],
            "content": "()()'] \\n  \\n     Example 2: \\n     >>> generate_parenthesis(1) \\n     ['()']\n\"\"\" \\n  \\n     result: list[str] = [] \\n     backtrack(\" \", 0, 0, n, result) \\n     return result \\n  \\n  \\n if __name__ == \" __main__\":\nimport doctest\n\ndoctest.testmod()\n"
        }
    ],
    "content": "\"\"\" \\n author: Aayush Soni \\n Given n pairs of parentheses, write a function to generate all \\n combinations of well-formed parentheses. \\n Input: n = 2 \\n Output: [\"(())\",\"()()\"] \\n Leetcode link: https://leetcode.com/problems/generate-parentheses/description/ \\n \"\"\"\n\n\ndef backtrack(\npartial:str,open_count:int,close_count:int,n:int,result:list[str]\n)->None:\n\"\"\" \\n     Generate valid combinations of balanced parentheses using recursion. \\n  \\n     :param partial: A string representing the current combination. \\n     :param open_count: An integer representing the count of open parentheses. \\n     :param close_count: An integer representing the count of close parentheses. \\n     :param n: An integer representing the total number of pairs. \\n     :param result: A list to store valid combinations. \\n     :return: None \\n  \\n     This function uses recursion to explore all possible combinations, \\n     ensuring that at each step, the parentheses remain balanced. \\n  \\n     Example: \\n     >>> result = [] \\n     >>> backtrack(\" \", 0, 0, 2, result) \\n     >>> result \\n     ['(())', '()()'] \\n     \"\"\"\nif len(partial)==2*n:\n#When the combination is complete,add it to the result.\nresult.append(partial)\nreturn\n\nif open_count<n:\n#If we can add an open parenthesis,do so,and recurse.\nbacktrack(partial+\"(\",open_count+1,close_count,n,result)\n\nif close_count<open_count:\n#If we can add a close parenthesis(it won 't make the combination invalid), \\n         # do so, and recurse. \\n         backtrack(partial + \")\", open_count, close_count + 1, n, result) \\n  \\n  \\n def generate_parenthesis(n: int) -> list[str]: \\n     \"\"\" \\n     Generate valid combinations of balanced parentheses for a given n. \\n  \\n     :param n: An integer representing the number of pairs of parentheses. \\n     :return: A list of strings with valid combinations. \\n  \\n     This function uses a recursive approach to generate the combinations. \\n  \\n     Time Complexity: O(2^(2n)) - In the worst case, we have 2^(2n) combinations. \\n     Space Complexity: O(n) - where ' n ' is the number of pairs. \\n  \\n     Example 1: \\n     >>> generate_parenthesis(3) \\n     ['((()))', '(()())', '(())()', '()(())', '()()()'] \\n  \\n     Example 2: \\n     >>> generate_parenthesis(1) \\n     ['()']\n\"\"\" \\n  \\n     result: list[str] = [] \\n     backtrack(\" \", 0, 0, n, result) \\n     return result \\n  \\n  \\n if __name__ == \" __main__\":\nimport doctest\n\ndoctest.testmod()\n"
}