# 在这个问题中，我们想要确定给定序列的所有可能排列。
# 我们使用回溯法来解决这个问题。
# 
# 时间复杂度: O(n! * n),
# 其中 n 表示给定序列的长度。

从 __未来__ 导入 注释

定义 生成所有排列(序列: 列表[整数 | 字符串]) -> 无:
    创建状态空间树(序列, [], 0, [0 对于 i 在 范围(长度(序列))])

定义 创建状态空间树(序列: 列表[整数 | 字符串], 当前序列: 列表[整数 | 字符串], 索引: 整数, 索引已用: 列表[整数]) -> 无:
    """
    创建一个状态空间树，使用深度优先搜索遍历每个分支。
    我们知道每个状态正好有 长度(序列) - 索引 个子节点。
    当它到达给定序列的末尾时终止。

    :param 序列: 生成排列的输入序列。
    :param 当前序列: 正在构建的当前排列。
    :param 索引: 序列中的当前索引。
    :param 索引已用: 用于跟踪哪些元素已用于排列的列表。

    示例 1:
    >>> 序列 = [1, 2, 3]
    >>> 当前序列 = []
    >>> 索引已用 = [假, 假, 假]
    >>> 创建状态空间树(序列, 当前序列, 0, 索引已用)
    [1, 2, 3]
    [1, 3, 2]
    [2, 1, 3]
    [2, 3, 1]
    [3, 1, 2]
    [3, 2, 1]

    示例 2:
    >>> 序列 = ["A", "B", "C"]
    >>> 当前序列 = []
    >>> 索引已用 = [假, 假, 假]
    >>> 创建状态空间树(序列, 当前序列, 0, 索引已用)
    ['A', 'B', 'C']
    ['A', 'C', 'B']
    ['B', 'A', 'C']
    ['B', 'C', 'A']
    ['C', 'A', 'B']
    ['C', 'B', 'A']

    示例 3:
    >>> 序列 = [1]
    >>> 当前序列 = []
    >>> 索引已用 = [假]
    >>> 创建状态空间树(序列, 当前序列, 0, 索引已用)
    [1]
    """

    如果 索引 == 长度(序列):
        打印(当前序列)
        返回

    对于 i 在 范围(长度(序列)):
        如果 不 索引已用[i]:
            当前序列.追加(序列[i])
            索引已用[i] = 真
            创建状态空间树(序列, 当前序列, 索引 + 1, 索引已用)
            当前序列.弹出()
            索引已用[i] = 假


"""
移除注释以从用户获取输入

打印("输入")