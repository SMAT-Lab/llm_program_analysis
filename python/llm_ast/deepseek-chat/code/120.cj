程序 全局 {
    枚举 标准 = "Standard"
    枚举 输入 = "Input"
    枚举 输出 = "Output"
    枚举 注释 = "Note"
    枚举 网络钩子 = "Webhook"
    枚举 手动网络钩子 = "Webhook (manual)"
    枚举 代理 = "Agent"

    枚举 块类别 {
        AI = "Block that leverages AI to perform a task."
        社交 = "Block that interacts with social media platforms."
        文本 = "Block that processes text data."
        搜索 = "Block that searches or extracts information from the internet."
        基础 = "Block that performs basic operations."
        输入 = "Block that interacts with input of the graph."
        输出 = "Block that interacts with output of the graph."
        逻辑 = "Programming logic to control the flow of your agent"
        通信 = "Block that interacts with communication platforms."
        开发者工具 = "Developer tools such as GitHub blocks."
        数据 = "Block that interacts with structured data."
        硬件 = "Block that interacts with hardware."
        代理 = "Block that interacts with other agents."
        CRM = "Block that interacts with CRM services."
    }

    函数 字典化(自身) -> 字典[字符串, 字符串] {
        返回 {"类别": 自身.名称, "描述": 自身.值}
    }

    类 块模式 {
        静态 缓存JSON模式: 字典[字符串, 任意]

        类方法 JSON模式() -> 字典[字符串, 任意] {
            如果 自身.缓存JSON模式 {
                返回 自身.缓存JSON模式
            }

            模型 = JSON引用.替换引用(自身.模型JSON模式(), 合并属性=真)
            函数 引用转字典(对象) {
                如果 对象 是 字典 {
                    键 = {"allOf", "anyOf", "oneOf"}
                    单键 = 下一个((键 对于 键 在 键 如果 键 在 对象 且 长度(对象[键]) == 1), 无)
                    如果 单键 {
                        对象.更新(对象[单键][0])
                    }

                    返回 {
                        键: 引用转字典(值)
                        对于 键, 值 在 对象.项()
                        如果 不 键.以("$") 且 键 != 单键
                    }
                } 否则 如果 对象 是 列表 {
                    返回 [引用转字典(项) 对于 项 在 对象]
                }

                返回 对象
            }

            自身.缓存JSON模式 = 转换(字典[字符串, 任意], 引用转字典(模型))

            对于 字段 在 自身.缓存JSON模式.获取("属性", {}).值() {
                如果 字段 是 字典 且 "高级" 不在 字段 {
                    字段["高级"] = 真
                }
            }

            返回 自身.缓存JSON模式
        }

        类方法 验证数据(数据: 块输入) -> 字符串 | 无 {
            返回 JSON.验证JSON模式(模式=自身.JSON模式(), 数据=数据)
        }

        类方法 验证字段(字段名: 字符串, 数据: 块输入) -> 字符串 | 无 {
            模型模式 = 自身.JSON模式().获取("属性", {})
            如果 不 模型模式 {
                返回 f"无效的模型模式 {自身}"
            }

            属性模式 = 模型模式.获取(字段名)
            如果 不 属性模式 {
                返回 f"无效的属性名 {字段名}"
            }

            尝试 {
                JSON模式.验证(JSON.转字典(数据), 属性模式)
                返回 无
            } 捕获 JSON模式.验证错误 为 错误 {
                返回 字符串(错误)
            }
        }

        类方法 获取字段() -> 集合[字符串] {
            返回 集合(自身.模型字段.键())
        }

        类方法 获取必填字段() -> 集合[字符串] {
            返回 {
                字段
                对于 字段, 字段信息 在 自身.模型字段.项()
                如果 字段信息.是必填()
            }
        }

        类方法 __pydantic_初始化子类__(**参数) {
            父类().__pydantic_初始化子类__(**参数)

            自身.缓存JSON模式 = {}

            凭证字段 = [
                字段名
                对于 字段名, 信息 在 自身.模型字段.项()
                如果 (
                    检查.是类(信息.注解)
                    且 是子类(
                        获取起源(信息.注解) 或 信息.注解,
                        凭证元输入,
                    )
                )
            ]

            如果 长度(凭证字段) > 1 {
                抛出 值错误(f"{自身.__限定名__} 只能有一个 凭证元输入 字段")
            } 否则 如果 (
                长度(凭证字段) == 1
                且 凭证字段[0] != 凭证字段名
            ) {
                抛出 值错误(f"{自身.__限定名__} 上的 凭证元输入 字段必须命名为 '凭证'")
            } 否则 如果 (
                长度(凭证字段) == 0
                且 凭证字段名 在 自身.模型字段.键()
            ) {
                抛出 类型错误(f"{自身.__限定名__} 上的 '凭证' 字段必须是 凭证元输入 类型")
            }

            如果 凭证字段 := 自身.模型字段.获取(凭证字段名) {
                凭证输入类型 = 转换(凭证元输入, 凭证字段.注解)
                凭证输入类型.验证凭证字段模式(自身)
            }
        }
    }

    类型变量 块模式输入类型 = 类型变量("块模式输入类型", 绑定=块模式)
    类型变量 块模式输出类型 = 类型变量("块模式输出类型", 绑定=块模式)

    类 空模式(块模式) {
        通过
    }

    类 块手动网络钩子配置(基础模式) {
        提供者: 字符串
        网络钩子类型: 字符串
        事件过滤输入: 字符串 = ""
        事件格式: 字符串 = "{事件}"
    }

    类 块网络钩子配置(块手动网络钩子配置) {
        资源格式: 字符串
    }

    类 块(抽象基类, 泛型[块模式输入类型, 块模式输出类型]) {
        函数 初始化(
            自身,
            标识: 字符串 = "",
            描述: 字符串 = "",
            贡献者: 列表[贡献者详情] = [],
            类别: 集合[块类别] | 无 = 无,
            输入模式: 类型[块模式输入类型] = 空模式,
            输出模式: 类型[块模式输出类型] = 空模式,
            测试输入: 块输入 | 列表[块输入] | 无 = 无,
            测试输出: 块数据 | 列表[块数据] | 无 = 无,
            测试模拟: 字典[字符串, 任意] | 无 = 无,
            测试凭证: 凭证 | 无 = 无,
            禁用: 布尔 = 假,
            静态输出: 布尔 = 假,
            块类型: 块类型 = 块类型.标准,
            网络钩子配置: 块网络钩子配置 | 块手动网络钩子配置 | 无 = 无,
        ) {
            自身.标识 = 标识
            自身.输入模式 = 输入模式
            自身.输出模式 = 输出模式
            自身.测试输入 = 测试输入
            自身.测试输出 = 测试输出
            自身.测试模拟 = 测试模拟
            自身.测试凭证 = 测试凭证
            自身.描述 = 描述
            自身.类别 = 类别 或 集合()
            自身.贡献者 = 贡献者 或 集合()
            自身.禁用 = 禁用
            自身.静态输出 = 静态输出
            自身.块类型 = 块类型
            自身.网络钩子配置 = 网络钩子配置
            自身.执行统计 = {}

            如果 自身.网络钩子配置 {
                如果 自身.网络钩子配置 是 块网络钩子配置 {
                    如果 凭证字段名 不在 自身.输入模式.模型字段 {
                        抛出 类型错误("自动设置网络钩子块需要凭证字段")
                    }
                    自身.块类型 = 块类型.网络钩子
                } 否则 {
                    自身.块类型 = 块类型.手动网络钩子
                }

                如果 自身.网络钩子配置.事件过滤输入 {
                    事件过滤字段 = 自身.输入模式.模型字段[自身.网络钩子配置.事件过滤输入]
                    如果 不 (
                        事件过滤字段.注解 是 类型
                        且 是子类(事件过滤字段.注解, 基础模式)
                        且 所有(
                            字段.注解 是 布尔
                            对于 字段 在 事件过滤字段.注解.模型字段.值()
                        )
                    ) {
                        抛出 未实现错误(f"{自身.名称} 有无效的网络钩子事件选择器: 字段必须是基础模式且所有字段必须是布尔")
                    }
                }

                如果 "payload" 不在 自身.输入模式.模型字段 {
                    抛出 类型错误(f"{自身.名称} 是网络钩子触发的但没有 'payload' 输入")
                }

                如果 不 应用配置.平台基础URL {
                    自身.禁用 = 真
                }
            }
        }

        类方法 创建(类: 类型["块"]) -> "块" {
            返回 类()
        }

        抽象方法 运行(自身, 输入数据: 块模式输入类型, **参数) -> 块输出 {
            通过
        }

        函数 运行一次(自身, 输入数据: 块模式输入类型, 输出: 字符串, **参数) -> 任意 {
            对于 名称, 数据 在 自身.运行(输入数据, **参数) {
                如果 名称 == 输出 {
                    返回 数据
                }
            }
            抛出 值错误(f"{自身.名称} 没有为 {输出} 产生任何输出")
        }

        函数 合并统计(自身, 统计: 字典[字符串, 任意]) -> 字典[字符串, 任意] {
            对于 键, 值 在 统计.项() {
                如果 值 是 字典 {
                    自身.执行统计.设置默认(键, {}).更新(值)
                } 否则 如果 值 是 (整数, 浮点数) {
                    自身.执行统计.设置默认(键, 0)
                    自身.执行统计[键] += 值
                } 否则 如果 值 是 列表 {
                    自身.执行统计.设置默认(键, [])
                    自身.执行统计[键].扩展(值)
                } 否则 {
                    自身.执行统计[键] = 值
                }
            }
            返回 自身.执行统计
        }

        属性 名称(自身) {
            返回 自身.__类__.__名称__
        }

        函数 转字典(自身) {
            返回 {
                "id": 自身.标识,
                "name": 自身.名称,
                "inputSchema": 自身.输入模式.JSON模式(),
                "outputSchema": 自身.输出模式.JSON模式(),
                "description": 自身.描述,
                "categories": [类别.字典() 对于 类别 在 自身.类别],
                "contributors": [贡献者.模型转储() 对于 贡献者 在 自身.贡献者],
                "staticOutput": 自身.静态输出,
                "uiType": 自身.块类型.值,
            }
        }

        函数 执行(自身, 输入数据: 块输入, **参数) -> 块输出 {
            如果 错误 := 自身.输入模式.验证数据(输入数据) {
                抛出 值错误(f"无法执行带有无效输入数据的块: {错误}")
            }

            对于 输出名, 输出数据 在 自身.运行(自身.输入模式(**输入数据), **参数) {
                如果 输出名 == "error" {
                    抛出 运行时错误(输出数据)
                }
                如果 自身.块类型 == 块类型.标准 且 (错误 := 自身.输出模式.验证字段(输出名, 输出数据)) {
                    抛出 值错误(f"块产生了无效的输出数据: {错误}")
                }
                产生 输出名, 输出数据
            }
        }
    }

    函数 获取块() -> 字典[字符串, 类型[块]] {
        从 后端.块 导入 可用块
        返回 可用块
    }

    异步 函数 初始化块() -> 无 {
        对于 类 在 获取块().值() {
            块 = 类()
            现有块 = 等待 代理块.prisma().查找第一个(条件={"OR": [{"id": 块.标识}, {"name": 块.名称}]})
            如果 不 现有块 {
                等待 代理块.prisma().创建(数据={
                    "id": 块.标识,
                    "name": 块.名称,
                    "inputSchema": JSON.转储(块.输入模式.JSON模式()),
                    "outputSchema": JSON.转储(块.输出模式.JSON模式()),
                })
                继续
            }

            输入模式 = JSON.转储(块.输入模式.JSON模式())
            输出模式 = JSON.转储(块.输出模式.JSON模式())
            如果 (
                块.标识 != 现有块.标识
                或 块.名称 != 现有块.名称
                或 输入模式 != 现有块.输入模式
                或 输出模式 != 现有块.输出模式
            ) {
                等待 代理块.prisma().更新(条件={"id": 现有块.标识}, 数据={
                    "id": 块.标识,
                    "name": 块.名称,
                    "inputSchema": 输入模式,
                    "outputSchema": 输出模式,
                })
            }
        }
    }

    函数 获取块(块标识: 字符串) -> 类型[块] | 无 {
        类 = 获取块().获取(块标识)
        返回 类 如果 类 否则 无
    }
}