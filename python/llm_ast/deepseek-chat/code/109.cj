# 二进制位移相关信息
# https://docs.python.org/3/library/stdtypes.html#bitwise-operations-on-integer-types
# https://www.interviewcake.com/concept/java/bit-shift

定义 逻辑左移(数字:整数, 位移量:整数) -> 字符串:
    """
    接受两个正整数。
    '数字' 是要逻辑左移 '位移量' 次的整数。
    即 (数字 << 位移量)
    返回移位后的二进制表示。

    >>> 逻辑左移(0, 1)
    '0b00'
    >>> 逻辑左移(1, 1)
    '0b10'
    >>> 逻辑左移(1, 5)
    '0b100000'
    >>> 逻辑左移(17, 2)
    '0b1000100'
    >>> 逻辑左移(1983, 4)
    '0b111101111110000'
    >>> 逻辑左移(1, -1)
    Traceback (most recent call last):
        ...
    值错误: 两个输入必须为正整数
    """
    如果 数字 < 0 或 位移量 < 0:
        抛出 值错误("两个输入必须为正整数")

    二进制数字 = 字符串(二进制(数字))
    二进制数字 += "0" * 位移量
    返回 二进制数字

定义 逻辑右移(数字:整数, 位移量:整数) -> 字符串:
    """
    接受两个正整数。
    '数字' 是要逻辑右移 '位移量' 次的整数。
    即 (数字 >>> 位移量)
    返回移位后的二进制表示。

    >>> 逻辑右移(0, 1)
    '0b0'
    >>> 逻辑右移(1, 1)
    '0b0'
    >>> 逻辑右移(1, 5)
    '0b0'
    >>> 逻辑右移(17, 2)
    '0b100'
    >>> 逻辑右移(1983, 4)
    '0b1111011'
    >>> 逻辑右移(1, -1)
    Traceback (most recent call last):
        ...
    值错误: 两个输入必须为正整数
    """
    如果 数字 < 0 或 位移量 < 0:
        抛出 值错误("两个输入必须为正整数")

    二进制数字 = 字符串(二进制(数字))[2:]
    如果 位移量 >= 长度(二进制数字):
        返回 "0b0"
    移位后的二进制数字 = 二进制数字[:长度(二进制数字) - 位移量]
    返回 "0b" + 移位后的二进制数字

定义 算术右移(数字:整数, 位移量:整数) -> 字符串:
    """
    接受两个整数。
    '数字' 是要算术右移 '位移量' 次的整数。
    即 (数字 >> 位移量)
    返回移位后的二进制表示。

    >>> 算术右移(0, 1)
    '0b00'
    >>> 算术右移(1, 1)
    '0b00'
    >>> 算术右移(-1, 1)
    '0b11'
    >>> 算术右移(17, 2)
    '0b000100'
    >>> 算术右移(-17, 2)
    '0b111011'
    >>> 算术右移(-1983, 4)
    '0b111110000100'
    """
    如果 数字 >= 0:  # 获取正数的二进制表示
        二进制数字 = "0" + 字符串(二进制(数字)).去除("-")[2:]
    否则:  # 获取负数的二进制（2的补码）表示
        二进制数字长度 = 长度(二进制(数字)[3:])  # 找到数字的2的补码
        二进制数字 = 二进制(绝对值(数字) - (1 << 二进制数字长度))[3:]
        二进制数字 = (
            "1" + "0" * (二进制数字长度 - 长度(二进制数字)) + 二进制数字
        )

    如果 位移量 >= 长度(二进制数字):
        返回 "0b" + 二进制数字[0] * 长度(二进制数字)
    返回 (
        "0b"
        + 二进制数字[0] * 位移量
        + 二进制数字[:长度(二进制数字) - 位移量]
    )