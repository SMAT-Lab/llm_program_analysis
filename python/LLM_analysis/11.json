{
  "nodes": [
    {
      "id": "n0",
      "code": "import functools\nimport logging\nimport os\nimport time\nfrom typing import Callable, ParamSpec, Tuple, TypeVar\n\nfrom pydantic import BaseModel\n"
    },
    {
      "id": "n1",
      "code": "class TimingInfo(BaseModel):\n    cpu_time: float\n    wall_time: float\n"
    },
    {
      "id": "n2",
      "code": "def _start_measurement() -> Tuple[float, float]:\n    return time.time(), os.times()[0] + os.times()[1]\n"
    },
    {
      "id": "n3",
      "code": "def _end_measurement(\n    start_wall_time: float, start_cpu_time: float\n) -> Tuple[float, float]:\n\n    end_wall_time = time.time()\n    end_cpu_time = os.times()[0] + os.times()[1]\n\n    return end_wall_time - start_wall_time, end_cpu_time - start_cpu_time\n"
    },
    {
      "id": "n4",
      "code": "P = ParamSpec(\"P\")\nT = TypeVar(\"T\")\n\nlogger = logging.getLogger(__name__)\n"
    },
    {
      "id": "n5",
      "code": "def time_measured(func: Callable[P, T]) -> Callable[P, Tuple[TimingInfo, T]]:\n    \"\"\"\n    Decorator to measure the time taken by a function to execute.\n    \"\"\"\n\n\n    @functools.wraps(func)\n    def wrapper(*args: P.args, **kwargs: P.kwargs) -> Tuple[TimingInfo, T]:\n\n        start_wall_time, start_cpu_time = _start_measurement()\n\n        try:\n            result = func(*args, **kwargs)\n\n        finally:\n            wall_duration, cpu_duration = _end_measurement(\n                start_wall_time, start_cpu_time\n            )\n            timing_info = TimingInfo(cpu_time=cpu_duration, wall_time=wall_duration)\n\n        return timing_info, result\n\n    return wrapper\n"
    },
    {
      "id": "n6",
      "code": "    def wrapper(*args: P.args, **kwargs: P.kwargs) -> Tuple[TimingInfo, T]:\n        start_wall_time, start_cpu_time = _start_measurement()\n\n        try:\n            result = func(*args, **kwargs)\n\n        finally:\n            wall_duration, cpu_duration = _end_measurement(\n                start_wall_time, start_cpu_time\n            )\n            timing_info = TimingInfo(cpu_time=cpu_duration, wall_time=wall_duration)\n\n        return timing_info, result\n"
    },
    {
      "id": "n7",
      "code": "def error_logged(func: Callable[P, T]) -> Callable[P, T | None]:\n    \"\"\"\n    Decorator to suppress and log any exceptions raised by a function.\n    \"\"\"\n\n\n    @functools.wraps(func)\n    def wrapper(*args: P.args, **kwargs: P.kwargs) -> T | None:\n\n        try:\n            return func(*args, **kwargs)\n"
    },
    {
      "id": "n8",
      "code": "        except Exception as e:\n            logger.exception(\n                f\"Error when calling function {func.__name__} with arguments {args} {kwargs}: {e}\"\n            )\n"
    },
    {
      "id": "n9",
      "code": "    return wrapper\n"
    },
    {
      "id": "n10",
      "code": "    def wrapper(*args: P.args, **kwargs: P.kwargs) -> T | None:\n\n        try:\n            return func(*args, **kwargs)\n\n        except Exception as e:\n            logger.exception(\n                f\"Error when calling function {func.__name__} with arguments {args} {kwargs}: {e}\"\n            )\n"
    }
  ],
  "edges": [
    {
      "source": "n7",
      "target": "n8"
    },
    {
      "source": "n8",
      "target": "n9"
    },
    {
      "source": "n7",
      "target": "n9"
    }
  ]
}