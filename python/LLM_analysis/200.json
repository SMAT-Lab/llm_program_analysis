{
  "nodes": [
    {
      "id": "n0",
      "code": "import ipaddress\nimport re\nimport socket\nfrom typing import Callable\nfrom urllib.parse import urlparse, urlunparse\n\nimport idna\nimport requests as req\n\nfrom backend.util.settings import Config\n\n\n# List of IP networks to block\nBLOCKED_IP_NETWORKS = [\n    # --8<-- [start:BLOCKED_IP_NETWORKS]\n    ipaddress.ip_network(\"0.0.0.0/8\"),  # \"This\" Network\n    ipaddress.ip_network(\"10.0.0.0/8\"),  # Private-Use\n    ipaddress.ip_network(\"127.0.0.0/8\"),  # Loopback\n    ipaddress.ip_network(\"169.254.0.0/16\"),  # Link Local\n    ipaddress.ip_network(\"172.16.0.0/12\"),  # Private-Use\n    ipaddress.ip_network(\"192.168.0.0/16\"),  # Private-Use\n    ipaddress.ip_network(\"224.0.0.0/4\"),  # Multicast\n    ipaddress.ip_network(\"240.0.0.0/4\"),  # Reserved for Future Use\n    # --8<-- [end:BLOCKED_IP_NETWORKS]\n]\n\n\nALLOWED_SCHEMES = [\"http\", \"https\"]\nHOSTNAME_REGEX = re.compile(r\"^[A-Za-z0-9.-]+$\")  # Basic DNS-safe hostname pattern\n\n\n\n\n"
    },
    {
      "id": "n1",
      "code": "def _canonicalize_url(url: str) -> str:\n    # Strip spaces and trailing slashes\n    url = url.strip().strip(\"/\")\n\n    # Ensure the URL starts with http:// or https://\n    if not url.startswith((\"http://\", \"https://\")):\n        url = \"http://\" + url\n\n    # Replace backslashes with forward slashes to avoid parsing ambiguities\n    url = url.replace(\"\\\\\", \"/\")\n    return url\n"
    },
    {
      "id": "n2",
      "code": "def _is_ip_blocked(ip: str) -> bool:\n    \"\"\"\n    Checks if the IP address is in a blocked network.\n    \"\"\"\n\n    ip_addr = ipaddress.ip_address(ip)\n    return any(ip_addr in network for network in BLOCKED_IP_NETWORKS)\n"
    },
    {
      "id": "n3",
      "code": "def validate_url(url: str, trusted_origins: list[str]) -> str:\n    \"\"\"\n    Validates the URL to prevent SSRF attacks by ensuring it does not point to a private\n    or untrusted IP address, unless whitelisted.\n    \"\"\"\n\n    url = _canonicalize_url(url)\n    parsed = urlparse(url)\n\n    # Check scheme\n    if parsed.scheme not in ALLOWED_SCHEMES:\n        raise ValueError(\n            f\"Scheme '{parsed.scheme}' is not allowed. Only HTTP/HTTPS are supported.\"\n        )\n\n    # Validate and IDNA encode the hostname\n    if not parsed.hostname:\n        raise ValueError(\"Invalid URL: No hostname found.\")\n\n    # IDNA encode to prevent Unicode domain attacks\n    try:\n        ascii_hostname = idna.encode(parsed.hostname).decode(\"ascii\")\n    except idna.IDNAError:\n        raise ValueError(\"Invalid hostname with unsupported characters.\")\n\n    # Check hostname characters\n    if not HOSTNAME_REGEX.match(ascii_hostname):\n        raise ValueError(\"Hostname contains invalid characters.\")\n\n    # Rebuild the URL with the normalized, IDNA-encoded hostname\n    parsed = parsed._replace(netloc=ascii_hostname)\n    url = str(urlunparse(parsed))\n\n    # Check if hostname is a trusted origin (exact match)\n    if ascii_hostname in trusted_origins:\n        return url\n"
    },
    {
      "id": "n4",
      "code": "    # Resolve all IP addresses for the hostname\n    try:\n        ip_addresses = {res[4][0] for res in socket.getaddrinfo(ascii_hostname, None)}\n    except socket.gaierror:\n        raise ValueError(f\"Unable to resolve IP address for hostname {ascii_hostname}\")\n\n    if not ip_addresses:\n        raise ValueError(f\"No IP addresses found for {ascii_hostname}\")\n\n    # Check if any resolved IP address falls into blocked ranges\n    for ip in ip_addresses:\n        if _is_ip_blocked(ip):\n            raise ValueError(\n                f\"Access to private IP address {ip} for hostname {ascii_hostname} is not allowed.\"\n            )\n"
    },
    {
      "id": "n5",
      "code": "    return url\n"
    },
    {
      "id": "n6",
      "code": "class Requests:\n    \"\"\"\n    A wrapper around the requests library that validates URLs before making requests.\n    \"\"\"\n\n    def __init__(\n        self,\n        trusted_origins: list[str] | None = None,\n        raise_for_status: bool = True,\n        extra_url_validator: Callable[[str], str] | None = None,\n        extra_headers: dict[str, str] | None = None,\n    ):\n\n        self.trusted_origins = []\n\n        for url in trusted_origins or []:\n            hostname = urlparse(url).hostname\n            if not hostname:\n                raise ValueError(f\"Invalid URL: Unable to determine hostname of {url}\")\n            self.trusted_origins.append(hostname)\n\n        self.raise_for_status = raise_for_status\n        self.extra_url_validator = extra_url_validator\n        self.extra_headers = extra_headers\n"
    },
    {
      "id": "n7",
      "code": "    def request(\n        self, method, url, headers=None, allow_redirects=False, *args, **kwargs\n    ) -> req.Response:\n\n        if self.extra_headers is not None:\n            headers = {**(headers or {}), **self.extra_headers}\n\n        url = validate_url(url, self.trusted_origins)\n\n        if self.extra_url_validator is not None:\n            url = self.extra_url_validator(url)\n\n        response = req.request(\n            method,\n            url,\n            headers=headers,\n            allow_redirects=allow_redirects,\n            *args,\n            **kwargs,\n        )\n\n        if self.raise_for_status:\n            response.raise_for_status()\n\n        return response\n"
    },
    {
      "id": "n8",
      "code": "    def get(self, url, *args, **kwargs) -> req.Response:\n        return self.request(\"GET\", url, *args, **kwargs)\n"
    },
    {
      "id": "n9",
      "code": "    def post(self, url, *args, **kwargs) -> req.Response:\n        return self.request(\"POST\", url, *args, **kwargs)\n"
    },
    {
      "id": "n10",
      "code": "    def put(self, url, *args, **kwargs) -> req.Response:\n        return self.request(\"PUT\", url, *args, **kwargs)\n"
    },
    {
      "id": "n11",
      "code": "    def delete(self, url, *args, **kwargs) -> req.Response:\n        return self.request(\"DELETE\", url, *args, **kwargs)\n"
    },
    {
      "id": "n12",
      "code": "    def head(self, url, *args, **kwargs) -> req.Response:\n        return self.request(\"HEAD\", url, *args, **kwargs)\n"
    },
    {
      "id": "n13",
      "code": "    def options(self, url, *args, **kwargs) -> req.Response:\n        return self.request(\"OPTIONS\", url, *args, **kwargs)\n"
    },
    {
      "id": "n14",
      "code": "    def patch(self, url, *args, **kwargs) -> req.Response:\n        return self.request(\"PATCH\", url, *args, **kwargs)\n"
    },
    {
      "id": "n15",
      "code": "requests = Requests(trusted_origins=Config().trust_endpoints_for_requests)\n"
    }
  ],
  "edges": [
    {
      "source": "n3",
      "target": "n5"
    },
    {
      "source": "n3",
      "target": "n4"
    },
    {
      "source": "n4",
      "target": "n5"
    }
  ]
}