{
  "nodes": [
    {
      "id": "n0",
      "code": "import logging\n\nimport pytest\n\nfrom prisma.models import User\n\nfrom backend.blocks.basic import FindInDictionaryBlock, StoreValueBlock\n\nfrom backend.blocks.maths import CalculatorBlock, Operation\n\nfrom backend.data import execution, graph\n\nfrom backend.server.model import CreateGraph\n\nfrom backend.server.rest_api import AgentServer\n\nfrom backend.usecases.sample import create_test_graph, create_test_user\n\nfrom backend.util.test import SpinTestServer, wait_execution\n\nlogger = logging.getLogger(__name__)\n"
    },
    {
      "id": "n1",
      "code": "async def create_graph(s: SpinTestServer, g: graph.Graph, u: User) -> graph.Graph:\n    logger.info(f\"Creating graph for user {u.id}\")\n    return await s.agent_server.test_create_graph(CreateGraph(graph=g), u.id)\n"
    },
    {
      "id": "n2",
      "code": "async def execute_graph(\n    agent_server: AgentServer,\n    test_graph: graph.Graph,\n    test_user: User,\n    input_data: dict,\n    num_execs: int = 4,\n) -> str:\n\n    logger.info(f\"Executing graph {test_graph.id} for user {test_user.id}\")\n    logger.info(f\"Input data: {input_data}\")\n\n    # --- Test adding new executions --- #\n\n    response = await agent_server.test_execute_graph(\n        test_graph.id, input_data, test_user.id\n    )\n\n    graph_exec_id = response[\"id\"]\n    logger.info(f\"Created execution with ID: {graph_exec_id}\")\n\n    # Execution queue should be empty\n    logger.info(\"Waiting for execution to complete...\")\n\n    result = await wait_execution(test_user.id, test_graph.id, graph_exec_id)\n    logger.info(f\"Execution completed with {len(result)} results\")\n\n    assert result and len(result) == num_execs\n\n    return graph_exec_id\n"
    },
    {
      "id": "n3",
      "code": "async def assert_sample_graph_executions(\n    agent_server: AgentServer,\n    test_graph: graph.Graph,\n    test_user: User,\n    graph_exec_id: str,\n):\n\n    logger.info(f\"Checking execution results for graph {test_graph.id}\")\n\n    executions = await agent_server.test_get_graph_run_node_execution_results(\n        test_graph.id,\n        graph_exec_id,\n        test_user.id,\n    )\n\n    output_list = [{\"result\": [\"Hello\"]}, {\"result\": [\"World\"]}]\n\n    input_list = [\n        {\n            \"name\": \"input_1\",\n            \"value\": \"Hello\",\n        },\n        {\n            \"name\": \"input_2\",\n            \"value\": \"World\",\n        },\n    ]\n\n    # Executing StoreValueBlock\n\n    exec = executions[0]\n    logger.info(f\"Checking first StoreValueBlock execution: {exec}\")\n\n    assert exec.status == execution.ExecutionStatus.COMPLETED\n    assert exec.graph_exec_id == graph_exec_id\n    assert (\n        exec.output_data in output_list\n    ), f\"Output data: {exec.output_data} and {output_list}\"\n    assert (\n        exec.input_data in input_list\n    ), f\"Input data: {exec.input_data} and {input_list}\"\n    assert exec.node_id in [test_graph.nodes[0].id, test_graph.nodes[1].id]\n\n    # Executing StoreValueBlock\n\n    exec = executions[1]\n    logger.info(f\"Checking second StoreValueBlock execution: {exec}\")\n\n    assert exec.status == execution.ExecutionStatus.COMPLETED\n    assert exec.graph_exec_id == graph_exec_id\n    assert (\n        exec.output_data in output_list\n    ), f\"Output data: {exec.output_data} and {output_list}\"\n    assert (\n        exec.input_data in input_list\n    ), f\"Input data: {exec.input_data} and {input_list}\"\n    assert exec.node_id in [test_graph.nodes[0].id, test_graph.nodes[1].id]\n\n    # Executing FillTextTemplateBlock\n\n    exec = executions[2]\n    logger.info(f\"Checking FillTextTemplateBlock execution: {exec}\")\n\n    assert exec.status == execution.ExecutionStatus.COMPLETED\n    assert exec.graph_exec_id == graph_exec_id\n    assert exec.output_data == {\"output\": [\"Hello, World!!!\"]}\n    assert exec.input_data == {\n        \"format\": \"{a}, {b}{c}\",\n        \"values\": {\"a\": \"Hello\", \"b\": \"World\", \"c\": \"!!!\"},\n        \"values_#_a\": \"Hello\",\n        \"values_#_b\": \"World\",\n        \"values_#_c\": \"!!!\",\n    }\n    assert exec.node_id == test_graph.nodes[2].id\n\n    # Executing PrintToConsoleBlock\n\n    exec = executions[3]\n    logger.info(f\"Checking PrintToConsoleBlock execution: {exec}\")\n\n    assert exec.status == execution.ExecutionStatus.COMPLETED\n    assert exec.graph_exec_id == graph_exec_id\n    assert exec.output_data == {\"status\": [\"printed\"]}\n    assert exec.input_data == {\"text\": \"Hello, World!!!\"}\n    assert exec.node_id == test_graph.nodes[3].id\n"
    },
    {
      "id": "n4",
      "code": "@pytest.mark.asyncio(scope=\"session\")\nasync def test_agent_execution(server: SpinTestServer):\n\n    logger.info(\"Starting test_agent_execution\")\n\n    test_user = await create_test_user()\n\n    test_graph = await create_graph(server, create_test_graph(), test_user)\n\n    data = {\"input_1\": \"Hello\", \"input_2\": \"World\"}\n\n    graph_exec_id = await execute_graph(\n        server.agent_server,\n        test_graph,\n        test_user,\n        data,\n        4,\n    )\n\n    await assert_sample_graph_executions(\n        server.agent_server, test_graph, test_user, graph_exec_id\n    )\n\n    logger.info(\"Completed test_agent_execution\")\n"
    },
    {
      "id": "n5",
      "code": "@pytest.mark.asyncio(scope=\"session\")\nasync def test_input_pin_always_waited(server: SpinTestServer):\n\n    \"\"\"\n    This test is asserting that the input pin should always be waited for the execution,\n    even when default value on that pin is defined, the value has to be ignored.\n\n    Test scenario:\n    StoreValueBlock1\n                \\\\ input\n                     >------- FindInDictionaryBlock | input_default: key: \"\", input: {}\n                // key\n    StoreValueBlock2\n    \"\"\"\n\n    logger.info(\"Starting test_input_pin_always_waited\")\n\n    nodes = [\n        graph.Node(\n            block_id=StoreValueBlock().id,\n            input_default={\"input\": {\"key1\": \"value1\", \"key2\": \"value2\"}},\n        ),\n        graph.Node(\n            block_id=StoreValueBlock().id,\n            input_default={\"input\": \"key2\"},\n        ),\n        graph.Node(\n            block_id=FindInDictionaryBlock().id,\n            input_default={\"key\": \"\", \"input\": {}},\n        ),\n    ]\n\n    links = [\n        graph.Link(\n            source_id=nodes[0].id,\n            sink_id=nodes[2].id,\n            source_name=\"output\",\n            sink_name=\"input\",\n        ),\n        graph.Link(\n            source_id=nodes[1].id,\n            sink_id=nodes[2].id,\n            source_name=\"output\",\n            sink_name=\"key\",\n        ),\n    ]\n\n    test_graph = graph.Graph(\n        name=\"TestGraph\",\n        description=\"Test graph\",\n        nodes=nodes,\n        links=links,\n    )\n\n    test_user = await create_test_user()\n\n    test_graph = await create_graph(server, test_graph, test_user)\n\n    graph_exec_id = await execute_graph(\n        server.agent_server, test_graph, test_user, {}, 3\n    )\n\n\n\n    logger.info(\"Checking execution results\")\n\n    executions = await server.agent_server.test_get_graph_run_node_execution_results(\n        test_graph.id, graph_exec_id, test_user.id\n    )\n\n    assert len(executions) == 3\n\n    # FindInDictionaryBlock should wait for the input pin to be provided,\n    # Hence executing extraction of \"key\" from {\"key1\": \"value1\", \"key2\": \"value2\"}\n    assert executions[2].status == execution.ExecutionStatus.COMPLETED\n    assert executions[2].output_data == {\"output\": [\"value2\"]}\n\n    logger.info(\"Completed test_input_pin_always_waited\")\n\n\n"
    },
    {
      "id": "n6",
      "code": "@pytest.mark.asyncio(scope=\"session\")\nasync def test_static_input_link_on_graph(server: SpinTestServer):\n\n    \"\"\"\n    This test is asserting the behaviour of static input link, e.g: reusable input link.\n\n    Test scenario:\n    *StoreValueBlock1*===a=========\\\\\n    *StoreValueBlock2*===a=====\\\\  ||\n    *StoreValueBlock3*===a===*MathBlock*====b / static====*StoreValueBlock5*\n    *StoreValueBlock4*=========================================//\n\n    In this test, there will be three input waiting in the MathBlock input pin `a`.\n    And later, another output is produced on input pin `b`, which is a static link,\n    this input will complete the input of those three incomplete executions.\n    \"\"\"\n\n    logger.info(\"Starting test_static_input_link_on_graph\")\n\n    nodes = [\n        graph.Node(block_id=StoreValueBlock().id, input_default={\"input\": 4}),  # a\n        graph.Node(block_id=StoreValueBlock().id, input_default={\"input\": 4}),  # a\n        graph.Node(block_id=StoreValueBlock().id, input_default={\"input\": 4}),  # a\n        graph.Node(block_id=StoreValueBlock().id, input_default={\"input\": 5}),  # b\n        graph.Node(block_id=StoreValueBlock().id),\n        graph.Node(\n            block_id=CalculatorBlock().id,\n            input_default={\"operation\": Operation.ADD.value},\n        ),\n    ]\n\n    links = [\n        graph.Link(\n            source_id=nodes[0].id,\n            sink_id=nodes[5].id,\n            source_name=\"output\",\n            sink_name=\"a\",\n        ),\n        graph.Link(\n            source_id=nodes[1].id,\n            sink_id=nodes[5].id,\n            source_name=\"output\",\n            sink_name=\"a\",\n        ),\n        graph.Link(\n            source_id=nodes[2].id,\n            sink_id=nodes[5].id,\n            source_name=\"output\",\n            sink_name=\"a\",\n        ),\n        graph.Link(\n            source_id=nodes[3].id,\n            sink_id=nodes[4].id,\n            source_name=\"output\",\n            sink_name=\"input\",\n        ),\n        graph.Link(\n            source_id=nodes[4].id,\n            sink_id=nodes[5].id,\n            source_name=\"output\",\n            sink_name=\"b\",\n            is_static=True,  # This is the static link to test.\n        ),\n    ]\n\n    test_graph = graph.Graph(\n        name=\"TestGraph\",\n        description=\"Test graph\",\n        nodes=nodes,\n        links=links,\n    )\n\n    test_user = await create_test_user()\n\n    test_graph = await create_graph(server, test_graph, test_user)\n\n    graph_exec_id = await execute_graph(\n        server.agent_server, test_graph, test_user, {}, 8\n    )\n\n    logger.info(\"Checking execution results\")\n\n    executions = await server.agent_server.test_get_graph_run_node_execution_results(\n        test_graph.id, graph_exec_id, test_user.id\n    )\n\n    assert len(executions) == 8\n\n    # The last 3 executions will be a+b=4+5=9\n\n    for i, exec_data in enumerate(executions[-3:]):\n        logger.info(f\"Checking execution {i+1} of last 3: {exec_data}\")\n        assert exec_data.status == execution.ExecutionStatus.COMPLETED\n        assert exec_data.output_data == {\"result\": [9]}\n\n    logger.info(\"Completed test_static_input_link_on_graph\")\n\n\n"
    }
  ],
  "edges": []
}