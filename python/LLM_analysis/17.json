{
  "nodes": [
    {
      "id": "n0",
      "code": "\"\"\"\nAuthor  : Alexander Pantyukhin\nDate    : November 24, 2022\n\nTask:\nGiven an m x n grid of characters board and a string word,\nreturn true if word exists in the grid.\n\nThe word can be constructed from letters of sequentially adjacent cells,\nwhere adjacent cells are horizontally or vertically neighboring.\nThe same letter cell may not be used more than once.\n\nExample:\n\nMatrix:\n---------\n|A|B|C|E|\n|S|F|C|S|\n|A|D|E|E|\n---------\n\nWord:\n\"ABCCED\"\n\nResult:\nTrue\n\nImplementation notes: Use backtracking approach.\nAt each point, check all neighbors to try to find the next letter of the word.\n\nleetcode: https://leetcode.com/problems/word-search/\n\n\"\"\"\n\n\n\n\n"
    },
    {
      "id": "n1",
      "code": "def get_point_key(len_board: int, len_board_column: int, row: int, column: int) -> int:\n    \"\"\"\n    Returns the hash key of matrix indexes.\n\n    >>> get_point_key(10, 20, 1, 0)\n    200\n    \"\"\"\n\n    return len_board * len_board_column * row + column\n"
    },
    {
      "id": "n2",
      "code": "def exits_word(\n    board: list[list[str]],\n    word: str,\n    row: int,\n    column: int,\n    word_index: int,\n    visited_points_set: set[int],\n) -> bool:\n\n    \"\"\"\n    Return True if it's possible to search the word suffix\n    starting from the word_index.\n\n    >>> exits_word([[\"A\"]], \"B\", 0, 0, 0, set())\n    False\n    \"\"\"\n\n\n    if board[row][column] != word[word_index]:\n        return False\n"
    },
    {
      "id": "n3",
      "code": "    if word_index == len(word) - 1:\n        return True\n"
    },
    {
      "id": "n4",
      "code": "    traverts_directions = [(0, 1), (0, -1), (-1, 0), (1, 0)]\n    len_board = len(board)\n    len_board_column = len(board[0])\n"
    },
    {
      "id": "n5",
      "code": "    for direction in traverts_directions:\n        next_i = row + direction[0]\n        next_j = column + direction[1]\n        if not (0 <= next_i < len_board and 0 <= next_j < len_board_column):\n            continue\n"
    },
    {
      "id": "n6",
      "code": "        key = get_point_key(len_board, len_board_column, next_i, next_j)\n        if key in visited_points_set:\n            continue\n"
    },
    {
      "id": "n7",
      "code": "        visited_points_set.add(key)\n        if exits_word(board, word, next_i, next_j, word_index + 1, visited_points_set):\n            return True\n"
    },
    {
      "id": "n8",
      "code": "        visited_points_set.remove(key)\n"
    },
    {
      "id": "n9",
      "code": "    return False\n"
    },
    {
      "id": "n10",
      "code": "def word_exists(board: list[list[str]], word: str) -> bool:\n    \"\"\"\n    >>> word_exists([[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], \"ABCCED\")\n    True\n    >>> word_exists([[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], \"SEE\")\n    True\n    >>> word_exists([[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], \"ABCB\")\n    False\n    >>> word_exists([[\"A\"]], \"A\")\n    True\n    >>> word_exists([[\"B\", \"A\", \"A\"], [\"A\", \"A\", \"A\"], [\"A\", \"B\", \"A\"]], \"ABB\")\n    False\n    >>> word_exists([[\"A\"]], 123)\n    Traceback (most recent call last):\n        ...\n    ValueError: The word parameter should be a string of length greater than 0.\n    >>> word_exists([[\"A\"]], \"\")\n    Traceback (most recent call last):\n        ...\n    ValueError: The word parameter should be a string of length greater than 0.\n    >>> word_exists([[]], \"AB\")\n    Traceback (most recent call last):\n        ...\n    ValueError: The board should be a non empty matrix of single chars strings.\n    >>> word_exists([], \"AB\")\n    Traceback (most recent call last):\n        ...\n    ValueError: The board should be a non empty matrix of single chars strings.\n    >>> word_exists([[\"A\"], [21]], \"AB\")\n    Traceback (most recent call last):\n        ...\n    ValueError: The board should be a non empty matrix of single chars strings.\n    \"\"\"\n\n    # Validate board\n    board_error_message = (\n        \"The board should be a non empty matrix of single chars strings.\"\n    )\n\n    len_board = len(board)\n    if not isinstance(board, list) or len(board) == 0:\n        raise ValueError(board_error_message)\n"
    },
    {
      "id": "n11",
      "code": "    for row in board:\n        if not isinstance(row, list) or len(row) == 0:\n            raise ValueError(board_error_message)\n\n        for item in row:\n            if not isinstance(item, str) or len(item) != 1:\n                raise ValueError(board_error_message)\n"
    },
    {
      "id": "n12",
      "code": "    # Validate word\n    if not isinstance(word, str) or len(word) == 0:\n        raise ValueError(\n            \"The word parameter should be a string of length greater than 0.\"\n        )\n\n    len_board_column = len(board[0])\n\n    for i in range(len_board):\n        for j in range(len_board_column):\n            if exits_word(\n                board, word, i, j, 0, {get_point_key(len_board, len_board_column, i, j)}\n            ):\n                return True\n\n    return False\n"
    },
    {
      "id": "n13",
      "code": "if __name__ == \"__main__\":\n\n    import doctest\n\n    doctest.testmod()\n"
    }
  ],
  "edges": [
    {
      "source": "n5",
      "target": "n6"
    },
    {
      "source": "n11",
      "target": "n12"
    },
    {
      "source": "n6",
      "target": "n7"
    },
    {
      "source": "n5",
      "target": "n5"
    },
    {
      "source": "n2",
      "target": "n9"
    },
    {
      "source": "n3",
      "target": "n4"
    },
    {
      "source": "n8",
      "target": "n5"
    },
    {
      "source": "n3",
      "target": "n9"
    },
    {
      "source": "n4",
      "target": "n5"
    },
    {
      "source": "n6",
      "target": "n5"
    },
    {
      "source": "n10",
      "target": "n11"
    },
    {
      "source": "n7",
      "target": "n8"
    },
    {
      "source": "n2",
      "target": "n3"
    },
    {
      "source": "n7",
      "target": "n9"
    }
  ]
}