--- ground_truth
+++ llm_generated
@@ -5,26 +5,30 @@
 from abc import ABC, abstractmethod
 from multiprocessing import Process, set_start_method
 from typing import Optional
+
 from backend.util.logging import configure_logging
 from backend.util.metrics import sentry_init
+
 logger = logging.getLogger(__name__)
-_SERVICE_NAME = 'MainProcess'
+_SERVICE_NAME = "MainProcess"
 def get_service_name():
     return _SERVICE_NAME
-return _SERVICE_NAME
 def set_service_name(name: str):
     global _SERVICE_NAME
     _SERVICE_NAME = name
-global _SERVICE_NAME
-_SERVICE_NAME = name
 class AppProcess(ABC):
     """
     A class to represent an object that can be executed in a background process.
     """
+
     process: Optional[Process] = None
-    set_start_method('spawn', force=True)
+
+    set_start_method("spawn", force=True)
     configure_logging()
     sentry_init()
+
+    # Methods that are executed INSIDE the process #
+
 
     @abstractmethod
     def run(self):
@@ -53,19 +57,17 @@
 
     def execute_run_command(self, silent):
         signal.signal(signal.SIGTERM, self._self_terminate)
+
         try:
             if silent:
-                sys.stdout = open(os.devnull, 'w')
-                sys.stderr = open(os.devnull, 'w')
+                sys.stdout = open(os.devnull, "w")
+                sys.stderr = open(os.devnull, "w")
+
             set_service_name(self.service_name)
-            logger.info(f'[{self.service_name}] Starting...')
+            logger.info(f"[{self.service_name}] Starting...")
             self.run()
-        except (KeyboardInterrupt, SystemExit) as e:
-            logger.warning(f'[{self.service_name}] Terminated: {e}; quitting...')
+# Methods that are executed OUTSIDE the process #
 
-    def _self_terminate(self, signum: int, frame):
-        self.cleanup()
-        sys.exit(0)
 
     def __enter__(self):
         self.start(background=True)
@@ -73,8 +75,7 @@
 
     def __exit__(self, *args, **kwargs):
         self.stop()
-
-    def start(self, background: bool=False, silent: bool=False, **proc_args) -> int:
+def start(self, background: bool = False, silent: bool = False, **proc_args) -> int:
         """
         Start the background process.
         Args:
@@ -84,83 +85,60 @@
         Returns:
             the process id or 0 if the process is not running in the background.
         """
-        if not background:
-            self.execute_run_command(silent)
-            return 0
-        self.process = Process(name=self.__class__.__name__, target=self.execute_run_command, args=(silent,), **proc_args)
-        self.process.start()
-        self.health_check()
-        return self.process.pid or 0
-
-    def stop(self):
+def stop(self):
         """
         Stop the background process.
         """
+
         if not self.process:
             return
+
         self.process.terminate()
         self.process.join()
         self.process = None
-'\n    A class to represent an object that can be executed in a background process.\n    '
-process: Optional[Process] = None
-set_start_method('spawn')
-configure_logging()
-sentry_init()
-@abstractmethod
 def run(self):
-    """
+        """
         The method that will be executed in the process.
         """
-    pass
-'\n        The method that will be executed in the process.\n        '
-pass
-@classmethod
-@property
+        pass
 def service_name(cls) -> str:
-    return cls.__name__
-return cls.__name__
+        return cls.__name__
 def cleanup(self):
-    """
+        """
         Implement this method on a subclass to do post-execution cleanup,
         e.g. disconnecting from a database or terminating child processes.
         """
-    pass
-'\n        Implement this method on a subclass to do post-execution cleanup,\n        e.g. disconnecting from a database or terminating child processes.\n        '
-pass
+        pass
 def health_check(self):
-    """
+        """
         A method to check the health of the process.
         """
-    pass
-'\n        A method to check the health of the process.\n        '
-pass
+        pass
 def execute_run_command(self, silent):
-    signal.signal(signal.SIGTERM, self._self_terminate)
-    try:
-        if silent:
-            sys.stdout = open(os.devnull, 'w')
-            sys.stderr = open(os.devnull, 'w')
-        set_service_name(self.service_name)
-        logger.info(f'[{self.service_name}] Starting...')
-        self.run()
-    except (KeyboardInterrupt, SystemExit) as e:
-        logger.warning(f'[{self.service_name}] Terminated: {e}; quitting...')
-signal.signal(signal.SIGTERM, self._self_terminate)
-try:
-    if silent:
-        sys.stdout = open(os.devnull, 'w')
-        sys.stderr = open(os.devnull, 'w')
-    set_service_name(self.service_name)
-    logger.info(f'[{self.service_name}] Starting...')
-    self.run()
-except (KeyboardInterrupt, SystemExit) as e:
-    logger.warning(f'[{self.service_name}] Terminated: {e}; quitting...')
-silent
+        signal.signal(signal.SIGTERM, self._self_terminate)
+
+        try:
+            if silent:
+                sys.stdout = open(os.devnull, "w")
+                sys.stderr = open(os.devnull, "w")
+
+            set_service_name(self.service_name)
+            logger.info(f"[{self.service_name}] Starting...")
+            self.run()
+
+        except (KeyboardInterrupt, SystemExit) as e:
+            logger.warning(f"[{self.service_name}] Terminated: {e}; quitting...")
+def _self_terminate(self, signum: int, frame):
+def _self_terminate(self, signum: int, frame):
+        self.cleanup()
+        sys.exit(0)
+def __enter__(self):
+        self.start(background=True)
+        return self
 def __exit__(self, *args, **kwargs):
-    self.stop()
-self.stop()
-def start(self, background: bool=False, silent: bool=False, **proc_args) -> int:
-    """
+        self.stop()
+def start(self, background: bool = False, silent: bool = False, **proc_args) -> int:
+        """
         Start the background process.
         Args:
             background: Whether to run the process in the background.
@@ -169,42 +147,45 @@
         Returns:
             the process id or 0 if the process is not running in the background.
         """
-    if not background:
-        self.execute_run_command(silent)
-        return 0
-    self.process = Process(name=self.__class__.__name__, target=self.execute_run_command, args=(silent,), **proc_args)
-    self.process.start()
-    self.health_check()
-    return self.process.pid or 0
-'\n        Start the background process.\n        Args:\n            background: Whether to run the process in the background.\n            silent: Whether to disable stdout and stderr.\n            proc_args: Additional arguments to pass to the process.\n        Returns:\n            the process id or 0 if the process is not running in the background.\n        '
-not background
+
+        if not background:
+            self.execute_run_command(silent)
+            return 0
+
+        self.process = Process(
+            name=self.__class__.__name__,
+            target=self.execute_run_command,
+            args=(silent,),
+            **proc_args,
+        )
+        self.process.start()
+        self.health_check()
+        return self.process.pid or 0
 def stop(self):
-    """
+        """
         Stop the background process.
         """
-    if not self.process:
-        return
-    self.process.terminate()
-    self.process.join()
-    self.process = None
-'\n        Stop the background process.\n        '
-not self.process
-sys.stdout = open(os.devnull, 'w')
-sys.stderr = open(os.devnull, 'w')
-self.execute_run_command(silent)
-return 0
-return
-set_service_name(self.service_name)
-logger.info(f'[{self.service_name}] Starting...')
-self.run()
-logger.warning(f'[{self.service_name}] Terminated: {e}; quitting...')
+
+        if not self.process:
+            return
+
+        self.process.terminate()
+        self.process.join()
+        self.process = None
 def _self_terminate(self, signum: int, frame):
-    self.cleanup()
-    sys.exit(0)
-self.cleanup()
-sys.exit(0)
-def __enter__(self):
-    self.start(background=True)
-    return self
-self.start()
-return self+        self.cleanup()
+        sys.exit(0)
+except (KeyboardInterrupt, SystemExit) as e:
+            logger.warning(f"[{self.service_name}] Terminated: {e}; quitting...")
+if not background:
+            self.execute_run_command(silent)
+            return 0
+self.process = Process(
+            name=self.__class__.__name__,
+            target=self.execute_run_command,
+            args=(silent,),
+            **proc_args,
+        )
+        self.process.start()
+        self.health_check()
+        return self.process.pid or 0