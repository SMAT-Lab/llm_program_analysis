--- ground_truth
+++ llm_generated
@@ -1,6 +1,7 @@
 import logging
 import time
 from typing import Sequence
+
 from backend.data import db
 from backend.data.block import Block, initialize_blocks
 from backend.data.execution import ExecutionResult, ExecutionStatus
@@ -9,6 +10,8 @@
 from backend.executor import DatabaseManager, ExecutionManager, ExecutionScheduler
 from backend.server.rest_api import AgentServer
 from backend.server.utils import get_user_id
+
+
 log = logging.getLogger(__name__)
 class SpinTestServer:
 
@@ -17,137 +20,145 @@
         self.exec_manager = ExecutionManager()
         self.agent_server = AgentServer()
         self.scheduler = ExecutionScheduler()
-
-    @staticmethod
+@staticmethod
     def test_get_user_id():
-        return '3e53486c-cf57-477e-ba2a-cb02dc828e1a'
-
-    async def __aenter__(self):
+        return "3e53486c-cf57-477e-ba2a-cb02dc828e1a"
+async def __aenter__(self):
         self.setup_dependency_overrides()
         self.db_api.__enter__()
         self.agent_server.__enter__()
         self.exec_manager.__enter__()
         self.scheduler.__enter__()
+
         await db.connect()
         await initialize_blocks()
         await create_default_user()
+
         return self
-
-    async def __aexit__(self, exc_type, exc_val, exc_tb):
+async def __aexit__(self, exc_type, exc_val, exc_tb):
         await db.disconnect()
+
         self.scheduler.__exit__(exc_type, exc_val, exc_tb)
         self.exec_manager.__exit__(exc_type, exc_val, exc_tb)
         self.agent_server.__exit__(exc_type, exc_val, exc_tb)
         self.db_api.__exit__(exc_type, exc_val, exc_tb)
-
-    def setup_dependency_overrides(self):
-        self.agent_server.set_test_dependency_overrides({get_user_id: self.test_get_user_id})
-def __init__(self):
-    self.db_api = DatabaseManager()
-    self.exec_manager = ExecutionManager()
-    self.agent_server = AgentServer()
-    self.scheduler = ExecutionScheduler()
-self.db_api = DatabaseManager()
-self.exec_manager = ExecutionManager()
-self.agent_server = AgentServer()
-self.scheduler = ExecutionScheduler()
-@staticmethod
+def setup_dependency_overrides(self):
+        # Override get_user_id for testing
+        self.agent_server.set_test_dependency_overrides(
+            {get_user_id: self.test_get_user_id}
+        )
 def test_get_user_id():
-    return '3e53486c-cf57-477e-ba2a-cb02dc828e1a'
-return '3e53486c-cf57-477e-ba2a-cb02dc828e1a'
+        return "3e53486c-cf57-477e-ba2a-cb02dc828e1a"
 async def __aenter__(self):
-    self.setup_dependency_overrides()
-    self.db_api.__enter__()
-    self.agent_server.__enter__()
-    self.exec_manager.__enter__()
-    self.scheduler.__enter__()
-    await db.connect()
-    await initialize_blocks()
-    await create_default_user()
-    return self
-self.setup_dependency_overrides()
-self.db_api.__enter__()
-self.agent_server.__enter__()
-self.exec_manager.__enter__()
-self.scheduler.__enter__()
-await db.connect()
-await initialize_blocks()
-await create_default_user()
-return self
+        self.setup_dependency_overrides()
+
+        self.setup_dependency_overrides()
+        self.db_api.__enter__()
+
+        self.db_api.__enter__()
+        self.agent_server.__enter__()
+
+        self.agent_server.__enter__()
+        self.exec_manager.__enter__()
+
+        self.exec_manager.__enter__()
+        self.scheduler.__enter__()
+
+        self.scheduler.__enter__()
+
+        await db.connect()
+
+        await db.connect()
+        await initialize_blocks()
+
+        await initialize_blocks()
+        await create_default_user()
+
+        await create_default_user()
+
+        return self
 async def __aexit__(self, exc_type, exc_val, exc_tb):
-    await db.disconnect()
-    self.scheduler.__exit__(exc_type, exc_val, exc_tb)
-    self.exec_manager.__exit__(exc_type, exc_val, exc_tb)
-    self.agent_server.__exit__(exc_type, exc_val, exc_tb)
-    self.db_api.__exit__(exc_type, exc_val, exc_tb)
-await db.disconnect()
-self.scheduler.__exit__(exc_type, exc_val, exc_tb)
-self.exec_manager.__exit__(exc_type, exc_val, exc_tb)
-self.agent_server.__exit__(exc_type, exc_val, exc_tb)
-self.db_api.__exit__(exc_type, exc_val, exc_tb)
+        await db.disconnect()
+
+        self.scheduler.__exit__(exc_type, exc_val, exc_tb)
+        self.exec_manager.__exit__(exc_type, exc_val, exc_tb)
+        self.agent_server.__exit__(exc_type, exc_val, exc_tb)
+        self.db_api.__exit__(exc_type, exc_val, exc_tb)
 def setup_dependency_overrides(self):
-    self.agent_server.set_test_dependency_overrides({get_user_id: self.test_get_user_id})
-self.agent_server.set_test_dependency_overrides({get_user_id: self.test_get_user_id})
-async def wait_execution(user_id: str, graph_id: str, graph_exec_id: str, timeout: int=20) -> Sequence[ExecutionResult]:
-
-    async def is_execution_completed():
+        # Override get_user_id for testing
+        self.agent_server.set_test_dependency_overrides(
+            {get_user_id: self.test_get_user_id}
+        )
+async def wait_execution(
+    user_id: str,
+    graph_id: str,
+    graph_exec_id: str,
+    timeout: int = 20,
+) -> Sequence[ExecutionResult]:
+async def is_execution_completed():
         status = await AgentServer().test_get_graph_run_status(graph_exec_id, user_id)
-        log.info(f'Execution status: {status}')
+        log.info(f"Execution status: {status}")
         if status == ExecutionStatus.FAILED:
-            log.info('Execution failed')
-            raise Exception('Execution failed')
+            log.info("Execution failed")
+            raise Exception("Execution failed")
         return status == ExecutionStatus.COMPLETED
+# Wait for the executions to complete
     for i in range(timeout):
-        if await is_execution_completed():
-            return await AgentServer().test_get_graph_run_node_execution_results(graph_id, graph_exec_id, user_id)
+if await is_execution_completed():
+            return await AgentServer().test_get_graph_run_node_execution_results(
+                graph_id, graph_exec_id, user_id
+            )
+
         time.sleep(1)
-    assert False, 'Execution did not complete in time.'
+assert False, "Execution did not complete in time."
 async def is_execution_completed():
-    status = await AgentServer().test_get_graph_run_status(graph_exec_id, user_id)
-    log.info(f'Execution status: {status}')
-    if status == ExecutionStatus.FAILED:
-        log.info('Execution failed')
-        raise Exception('Execution failed')
-    return status == ExecutionStatus.COMPLETED
-status = await AgentServer().test_get_graph_run_status(graph_exec_id, user_id)
-log.info(f'Execution status: {status}')
-status Eq ExecutionStatus.FAILED
-log.info('Execution failed')
-raise Exception('Execution failed')
-return status == ExecutionStatus.COMPLETED
-i
-range(timeout)
-await is_execution_completed()
-assert False, 'Execution did not complete in time.'
+        status = await AgentServer().test_get_graph_run_status(graph_exec_id, user_id)
+
+        log.info(f"Execution status: {status}")
+
+        if status == ExecutionStatus.FAILED:
+            log.info("Execution failed")
+            raise Exception("Execution failed")
+
+        return status == ExecutionStatus.COMPLETED
 def execute_block_test(block: Block):
-    prefix = f'[Test-{block.name}]'
+    prefix = f"[Test-{block.name}]"
+
     if not block.test_input or not block.test_output:
-        log.info(f'{prefix} No test data provided')
+        log.info(f"{prefix} No test data provided")
         return
-    if not isinstance(block.test_input, list):
+if not isinstance(block.test_input, list):
         block.test_input = [block.test_input]
+
     if not isinstance(block.test_output, list):
         block.test_output = [block.test_output]
-    output_index = 0
-    log.info(f'{prefix} Executing {len(block.test_input)} tests...')
-    prefix = ' ' * 4 + prefix
-    for (mock_name, mock_obj) in (block.test_mock or {}).items():
-        log.info(f'{prefix} mocking {mock_name}...')
+output_index = 0
+    log.info(f"{prefix} Executing {len(block.test_input)} tests...")
+
+    prefix = " " * 4 + prefix
+
+    for mock_name, mock_obj in (block.test_mock or {}).items():
+        log.info(f"{prefix} mocking {mock_name}...")
         if hasattr(block, mock_name):
             setattr(block, mock_name, mock_obj)
         else:
-            log.info(f'{prefix} mock {mock_name} not found in block')
+            log.info(f"{prefix} mock {mock_name} not found in block")
+
     extra_exec_kwargs = {}
+
     if CREDENTIALS_FIELD_NAME in block.input_schema.model_fields:
         if not block.test_credentials:
-            raise ValueError(f'{prefix} requires credentials but has no test_credentials')
+            raise ValueError(
+                f"{prefix} requires credentials but has no test_credentials"
+            )
         extra_exec_kwargs[CREDENTIALS_FIELD_NAME] = block.test_credentials
-    for input_data in block.test_input:
-        log.info(f'{prefix} in: {input_data}')
-        for (output_name, output_data) in block.execute(input_data, **extra_exec_kwargs):
+for input_data in block.test_input:
+        log.info(f"{prefix} in: {input_data}")
+
+        for output_name, output_data in block.execute(input_data, **extra_exec_kwargs):
             if output_index >= len(block.test_output):
-                raise ValueError(f'{prefix} produced output more than expected')
-            (ex_output_name, ex_output_data) = block.test_output[output_index]
+                raise ValueError(f"{prefix} produced output more than expected")
+            ex_output_name, ex_output_data = block.test_output[output_index]
 
             def compare(data, expected_data):
                 if data == expected_data:
@@ -158,71 +169,37 @@
                     is_matching = expected_data(data)
                 else:
                     is_matching = False
-                mark = '✅' if is_matching else '❌'
-                log.info(f'{prefix} {mark} comparing `{data}` vs `{expected_data}`')
+
+                mark = "✅" if is_matching else "❌"
+                log.info(f"{prefix} {mark} comparing `{data}` vs `{expected_data}`")
                 if not is_matching:
-                    raise ValueError(f'{prefix}: wrong output {data} vs {expected_data}')
+                    raise ValueError(
+                        f"{prefix}: wrong output {data} vs {expected_data}"
+                    )
+
             compare(output_data, ex_output_data)
             compare(output_name, ex_output_name)
+
             output_index += 1
-    if output_index < len(block.test_output):
-        raise ValueError(f'{prefix} produced output less than expected. output_index={output_index}, len(block.test_output)={len(block.test_output)}')
-prefix = f'[Test-{block.name}]'
-not block.test_input or not block.test_output
-return await AgentServer().test_get_graph_run_node_execution_results(graph_id, graph_exec_id, user_id)
-log.info(f'{prefix} No test data provided')
-return
-block.test_input = [block.test_input]
-not isinstance(block.test_output, list)
-block.test_output = [block.test_output]
-output_index = 0
-log.info(f'{prefix} Executing {len(block.test_input)} tests...')
-prefix = ' ' * 4 + prefix
-(mock_name, mock_obj)
-(block.test_mock or {}).items()
-log.info(f'{prefix} mocking {mock_name}...')
-hasattr(block, mock_name)
-extra_exec_kwargs = {}
-CREDENTIALS_FIELD_NAME In block.input_schema.model_fields
-setattr(block, mock_name, mock_obj)
-log.info(f'{prefix} mock {mock_name} not found in block')
-not block.test_credentials
-raise ValueError(f'{prefix} requires credentials but has no test_credentials')
-extra_exec_kwargs[CREDENTIALS_FIELD_NAME] = block.test_credentials
-input_data
-block.test_input
-log.info(f'{prefix} in: {input_data}')
-output_index Lt len(block.test_output)
-(output_name, output_data)
-block.execute(input_data)
-output_index GtE len(block.test_output)
-raise ValueError(f'{prefix} produced output more than expected')
-(ex_output_name, ex_output_data) = block.test_output[output_index]
+if output_index < len(block.test_output):
+        raise ValueError(
+            f"{prefix} produced output less than expected. output_index={output_index}, len(block.test_output)={len(block.test_output)}"
+        )
 def compare(data, expected_data):
-    if data == expected_data:
-        is_matching = True
-    elif isinstance(expected_data, type):
-        is_matching = isinstance(data, expected_data)
-    elif callable(expected_data):
-        is_matching = expected_data(data)
-    else:
-        is_matching = False
-    mark = '✅' if is_matching else '❌'
-    log.info(f'{prefix} {mark} comparing `{data}` vs `{expected_data}`')
-    if not is_matching:
-        raise ValueError(f'{prefix}: wrong output {data} vs {expected_data}')
-data Eq expected_data
-is_matching = True
-isinstance(expected_data, type)
-mark = '✅' if is_matching else '❌'
-log.info(f'{prefix} {mark} comparing `{data}` vs `{expected_data}`')
-not is_matching
-is_matching = isinstance(data, expected_data)
-callable(expected_data)
-is_matching = expected_data(data)
-is_matching = False
-raise ValueError(f'{prefix}: wrong output {data} vs {expected_data}')
-compare(output_data, ex_output_data)
-compare(output_name, ex_output_name)
-output_index += 1
-raise ValueError(f'{prefix} produced output less than expected. output_index={output_index}, len(block.test_output)={len(block.test_output)}')+
+                if data == expected_data:
+                    is_matching = True
+elif isinstance(expected_data, type):
+                    is_matching = isinstance(data, expected_data)
+elif callable(expected_data):
+                    is_matching = expected_data(data)
+else:
+                    is_matching = False
+
+                mark = "✅" if is_matching else "❌"
+                log.info(f"{prefix} {mark} comparing `{data}` vs `{expected_data}`")
+
+                if not is_matching:
+                    raise ValueError(
+                        f"{prefix}: wrong output {data} vs {expected_data}"
+                    )