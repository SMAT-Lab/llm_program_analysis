--- ground_truth
+++ llm_generated
@@ -1,5 +1,14 @@
-'\nGraph Coloring also called "m coloring problem"\nconsists of coloring a given graph with at most m colors\nsuch that no adjacent vertices are assigned the same color\n\nWikipedia: https://en.wikipedia.org/wiki/Graph_coloring\n'
-def valid_coloring(neighbours: list[int], colored_vertices: list[int], color: int) -> bool:
+"""
+Graph Coloring also called "m coloring problem"
+consists of coloring a given graph with at most m colors
+such that no adjacent vertices are assigned the same color
+
+Wikipedia: https://en.wikipedia.org/wiki/Graph_coloring
+"""
+def valid_coloring(
+    neighbours: list[int], colored_vertices: list[int], color: int
+) -> bool:
+
     """
     For each neighbour check if the coloring constraint is satisfied
     If any of the neighbours fail the constraint return False
@@ -16,10 +25,16 @@
     >>> valid_coloring(neighbours, colored_vertices, color)
     False
     """
-    return not any((neighbour == 1 and colored_vertices[i] == color for (i, neighbour) in enumerate(neighbours)))
-'\n    For each neighbour check if the coloring constraint is satisfied\n    If any of the neighbours fail the constraint return False\n    If all neighbours validate the constraint return True\n\n    >>> neighbours = [0,1,0,1,0]\n    >>> colored_vertices = [0, 2, 1, 2, 0]\n\n    >>> color = 1\n    >>> valid_coloring(neighbours, colored_vertices, color)\n    True\n\n    >>> color = 2\n    >>> valid_coloring(neighbours, colored_vertices, color)\n    False\n    '
-return not any((neighbour == 1 and colored_vertices[i] == color for (i, neighbour) in enumerate(neighbours)))
-def util_color(graph: list[list[int]], max_colors: int, colored_vertices: list[int], index: int) -> bool:
+
+    # Does any neighbour not satisfy the constraints
+    return not any(
+        neighbour == 1 and colored_vertices[i] == color
+        for i, neighbour in enumerate(neighbours)
+    )
+def util_color(
+    graph: list[list[int]], max_colors: int, colored_vertices: list[int], index: int
+) -> bool:
+
     """
     Pseudo-Code
 
@@ -51,25 +66,25 @@
     >>> util_color(graph, max_colors, colored_vertices, index)
     False
     """
+
+
+
+    # Base Case
     if index == len(graph):
         return True
+# Recursive Step
     for i in range(max_colors):
+
         if valid_coloring(graph[index], colored_vertices, i):
+            # Color current vertex
             colored_vertices[index] = i
+
+            # Validate coloring
             if util_color(graph, max_colors, colored_vertices, index + 1):
                 return True
+# Backtrack
             colored_vertices[index] = -1
-    return False
-'\n    Pseudo-Code\n\n    Base Case:\n    1. Check if coloring is complete\n        1.1 If complete return True (meaning that we successfully colored the graph)\n\n    Recursive Step:\n    2. Iterates over each color:\n        Check if the current coloring is valid:\n            2.1. Color given vertex\n            2.2. Do recursive call, check if this coloring leads to a solution\n            2.4. if current coloring leads to a solution return\n            2.5. Uncolor given vertex\n\n    >>> graph = [[0, 1, 0, 0, 0],\n    ...          [1, 0, 1, 0, 1],\n    ...          [0, 1, 0, 1, 0],\n    ...          [0, 1, 1, 0, 0],\n    ...          [0, 1, 0, 0, 0]]\n    >>> max_colors = 3\n    >>> colored_vertices = [0, 1, 0, 0, 0]\n    >>> index = 3\n\n    >>> util_color(graph, max_colors, colored_vertices, index)\n    True\n\n    >>> max_colors = 2\n    >>> util_color(graph, max_colors, colored_vertices, index)\n    False\n    '
-index Eq len(graph)
-return True
-i
-range(max_colors)
-valid_coloring(graph[index], colored_vertices, i)
 return False
-colored_vertices[index] = i
-util_color(graph, max_colors, colored_vertices, index Add 1)
-return True
 def color(graph: list[list[int]], max_colors: int) -> list[int]:
     """
     Wrapper function to call subroutine called util_color
@@ -90,11 +105,10 @@
     >>> color(graph, max_colors)
     []
     """
+
     colored_vertices = [-1] * len(graph)
+
     if util_color(graph, max_colors, colored_vertices, 0):
         return colored_vertices
-    return []
-'\n    Wrapper function to call subroutine called util_color\n    which will either return True or False.\n    If True is returned colored_vertices list is filled with correct colorings\n\n    >>> graph = [[0, 1, 0, 0, 0],\n    ...          [1, 0, 1, 0, 1],\n    ...          [0, 1, 0, 1, 0],\n    ...          [0, 1, 1, 0, 0],\n    ...          [0, 1, 0, 0, 0]]\n\n    >>> max_colors = 3\n    >>> color(graph, max_colors)\n    [0, 1, 0, 2, 0]\n\n    >>> max_colors = 2\n    >>> color(graph, max_colors)\n    []\n    '
-colored_vertices = [-1] * len(graph)
-util_color(graph, max_colors, colored_vertices, 0)
-return colored_vertices+
+    return []