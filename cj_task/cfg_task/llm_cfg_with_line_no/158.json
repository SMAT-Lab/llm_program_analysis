{
  "name": "cangjie_script",
  "type": "CFG",
  "start_line": 1,
  "end_line": 208,
  "functions": [],
  "classes": [
    {
      "name": "AlignmentPatternFinder",
      "type": "class",
      "start_line": 6,
      "end_line": 208,
      "functions": [
        {
          "name": "init",
          "type": "function",
          "start_line": 16,
          "end_line": 34,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 16,
              "line": "    init("
            },
            {
              "lineno": 17,
              "line": "        image: BitMatrix,"
            },
            {
              "lineno": 18,
              "line": "        startX: Int64,"
            },
            {
              "lineno": 19,
              "line": "        startY: Int64,"
            },
            {
              "lineno": 20,
              "line": "        width: Int64,"
            },
            {
              "lineno": 21,
              "line": "        height: Int64,"
            },
            {
              "lineno": 22,
              "line": "        moduleSize: Float32,"
            },
            {
              "lineno": 23,
              "line": "        resultPointCallback: ?ResultPointCallback"
            },
            {
              "lineno": 24,
              "line": "    ) {"
            },
            {
              "lineno": 25,
              "line": "        this.image = image"
            },
            {
              "lineno": 26,
              "line": "        this.possibleCenters = ArrayList<AlignmentPattern>(5)"
            },
            {
              "lineno": 27,
              "line": "        this.startX = startX"
            },
            {
              "lineno": 28,
              "line": "        this.startY = startY"
            },
            {
              "lineno": 29,
              "line": "        this.width = width"
            },
            {
              "lineno": 30,
              "line": "        this.height = height"
            },
            {
              "lineno": 31,
              "line": "        this.moduleSize = moduleSize"
            },
            {
              "lineno": 32,
              "line": "        this.crossCheckStateCount = Array<Int64>(3, item: 0)"
            },
            {
              "lineno": 33,
              "line": "        this.resultPointCallback = resultPointCallback"
            },
            {
              "lineno": 34,
              "line": "    }"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 16,
              "end_line": 34,
              "label": "    init(\n        image: BitMatrix,\n        startX: Int64,\n        startY: Int64,\n        width: Int64,\n        height: Int64,\n        moduleSize: Float32,\n        resultPointCallback: ?ResultPointCallback\n    ) {\n        this.image = image\n        this.possibleCenters = ArrayList<AlignmentPattern>(5)\n        this.startX = startX\n        this.startY = startY\n        this.width = width\n        this.height = height\n        this.moduleSize = moduleSize\n        this.crossCheckStateCount = Array<Int64>(3, item: 0)\n        this.resultPointCallback = resultPointCallback\n    }",
              "successors": []
            }
          ]
        },
        {
          "name": "find",
          "type": "function",
          "start_line": 35,
          "end_line": 92,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 35,
              "line": "    func find(): AlignmentPattern {"
            },
            {
              "lineno": 36,
              "line": "        let startX: Int64 = this.startX;"
            },
            {
              "lineno": 37,
              "line": "        let height: Int64 = this.height;"
            },
            {
              "lineno": 38,
              "line": "        let maxJ: Int64 = startX + width"
            },
            {
              "lineno": 39,
              "line": "        let middleI: Int64 = startY + (height / 2)"
            },
            {
              "lineno": 40,
              "line": "        // We are looking for black/white/black modules in 1:1:1 ratio;"
            },
            {
              "lineno": 41,
              "line": "        // this tracks the number of black/white/black modules seen so far"
            },
            {
              "lineno": 42,
              "line": "        var stateCount: Array<Int64> = Array<Int64>(3, item: 0);"
            },
            {
              "lineno": 43,
              "line": "        for (iGen in 0..height) {"
            },
            {
              "lineno": 44,
              "line": "            // Search from middle outwards"
            },
            {
              "lineno": 45,
              "line": "            let iGenResult: Int64 = if ((iGen & 0x01) == 0) {"
            },
            {
              "lineno": 46,
              "line": "                (iGen + 1) / 2"
            },
            {
              "lineno": 47,
              "line": "            } else {"
            },
            {
              "lineno": 48,
              "line": "                -(iGen + 1) / 2"
            },
            {
              "lineno": 49,
              "line": "            }"
            },
            {
              "lineno": 50,
              "line": "            var i: Int64 = middleI + iGenResult"
            },
            {
              "lineno": 51,
              "line": "            stateCount[0] = 0"
            },
            {
              "lineno": 52,
              "line": "            stateCount[1] = 0"
            },
            {
              "lineno": 53,
              "line": "            stateCount[2] = 0"
            },
            {
              "lineno": 54,
              "line": "            var j: Int64 = startX"
            },
            {
              "lineno": 55,
              "line": "            // Burn off leading white pixels before anything else; if we start in the middle of"
            },
            {
              "lineno": 56,
              "line": "            // a white run, it doesn't make sense to count its length, since we don't know if the"
            },
            {
              "lineno": 57,
              "line": "            // white run continued to the left of the start point"
            },
            {
              "lineno": 58,
              "line": "            while (j < maxJ && !image.get(j, i)) {"
            },
            {
              "lineno": 59,
              "line": "                j++"
            },
            {
              "lineno": 60,
              "line": "            }"
            },
            {
              "lineno": 61,
              "line": "            var currentState: Int64 = 0;"
            },
            {
              "lineno": 62,
              "line": "            while (j < maxJ) {"
            },
            {
              "lineno": 63,
              "line": "                if (image.get(j, i)) {"
            },
            {
              "lineno": 64,
              "line": "                    // Black pixel"
            },
            {
              "lineno": 65,
              "line": "                    var res: Option<AlignmentPattern>"
            },
            {
              "lineno": 66,
              "line": "                    (currentState, res) = exfind(currentState, stateCount, i, j)"
            },
            {
              "lineno": 67,
              "line": "                    if (let Some(con) <- res) {"
            },
            {
              "lineno": 68,
              "line": "                        return con"
            },
            {
              "lineno": 69,
              "line": "                    }"
            },
            {
              "lineno": 70,
              "line": "                } else { // White pixel"
            },
            {
              "lineno": 71,
              "line": "                    if (currentState == 1) { // Counting black pixels"
            },
            {
              "lineno": 72,
              "line": "                        currentState++"
            },
            {
              "lineno": 73,
              "line": "                    }"
            },
            {
              "lineno": 74,
              "line": "                    //currentState++"
            },
            {
              "lineno": 75,
              "line": "                    stateCount[Int64(currentState)] += 1"
            },
            {
              "lineno": 76,
              "line": "                }"
            },
            {
              "lineno": 77,
              "line": "                j++"
            },
            {
              "lineno": 78,
              "line": "            }"
            },
            {
              "lineno": 79,
              "line": "            if (foundPatternCross(stateCount)) {"
            },
            {
              "lineno": 80,
              "line": "                let confirmed: Option<AlignmentPattern> = handlePossibleCenter(stateCount, i, maxJ);"
            },
            {
              "lineno": 81,
              "line": "                if (let Some(con) <- confirmed) {"
            },
            {
              "lineno": 82,
              "line": "                    return con"
            },
            {
              "lineno": 83,
              "line": "                }"
            },
            {
              "lineno": 84,
              "line": "            }"
            },
            {
              "lineno": 85,
              "line": "        }"
            },
            {
              "lineno": 86,
              "line": "        // Hmm, nothing we saw was observed and confirmed twice. If we had"
            },
            {
              "lineno": 87,
              "line": "        // any guess at all, return it."
            },
            {
              "lineno": 88,
              "line": "        if (!possibleCenters.isEmpty()) {"
            },
            {
              "lineno": 89,
              "line": "            return possibleCenters[0]"
            },
            {
              "lineno": 90,
              "line": "        }"
            },
            {
              "lineno": 91,
              "line": "        throw Qrcoder4cjNotFoundException.getNotFoundInstance();"
            },
            {
              "lineno": 92,
              "line": "    }"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 35,
              "end_line": 43,
              "label": "func find(): AlignmentPattern { let startX: Int64 = this.startX; let height: Int64 = this.height; let maxJ: Int64 = startX + width let middleI: Int64 = startY + (height / 2) var stateCount: Array<Int64> = Array<Int64>(3, item: 0); for (iGen in 0..height) {",
              "successors": [
                {
                  "id": 2,
                  "start_line": 44,
                  "end_line": 50,
                  "label": "// Search from middle outwards let iGenResult: Int64 = if ((iGen & 0x01) == 0) { (iGen + 1) / 2 } else { -(iGen + 1) / 2 } var i: Int64 = middleI + iGenResult",
                  "successors": [
                    {
                      "id": 3,
                      "start_line": 51,
                      "end_line": 58,
                      "label": "stateCount[0] = 0 stateCount[1] = 0 stateCount[2] = 0 var j: Int64 = startX while (j < maxJ && !image.get(j, i)) { j++ }",
                      "successors": [
                        {
                          "id": 4,
                          "start_line": 61,
                          "end_line": 78,
                          "label": "var currentState: Int64 = 0; while (j < maxJ) { if (image.get(j, i)) { var res: Option<AlignmentPattern> (currentState, res) = exfind(currentState, stateCount, i, j) if (let Some(con) <- res) { return con } } else { if (currentState == 1) { currentState++ } stateCount[Int64(currentState)] += 1 } j++ }",
                          "successors": [
                            {
                              "id": 5,
                              "start_line": 79,
                              "end_line": 84,
                              "label": "if (foundPatternCross(stateCount)) { let confirmed: Option<AlignmentPattern> = handlePossibleCenter(stateCount, i, maxJ); if (let Some(con) <- confirmed) { return con } }",
                              "successors": [
                                {
                                  "id": 6,
                                  "start_line": 86,
                                  "end_line": 91,
                                  "label": "if (!possibleCenters.isEmpty()) { return possibleCenters[0] } throw Qrcoder4cjNotFoundException.getNotFoundInstance();",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "exfind",
          "type": "function",
          "start_line": 93,
          "end_line": 115,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 93,
              "line": "    func exfind(currentState: Int64, stateCount: Array<Int64>, i: Int64, j: Int64): (Int64, Option<AlignmentPattern>) {"
            },
            {
              "lineno": 94,
              "line": "        var currentState_p = currentState"
            },
            {
              "lineno": 95,
              "line": "        if (currentState == 1) { // Counting black pixels"
            },
            {
              "lineno": 96,
              "line": "            stateCount[1] += 1"
            },
            {
              "lineno": 97,
              "line": "        } else {"
            },
            {
              "lineno": 98,
              "line": "            if (currentState_p == 2) { // A winner?"
            },
            {
              "lineno": 99,
              "line": "                if (foundPatternCross(stateCount)) { // Yes"
            },
            {
              "lineno": 100,
              "line": "                    let confirmed: Option<AlignmentPattern> = handlePossibleCenter(stateCount, i, j);"
            },
            {
              "lineno": 101,
              "line": "                    if (let Some(con) <- confirmed) {"
            },
            {
              "lineno": 102,
              "line": "                        return (0, con)"
            },
            {
              "lineno": 103,
              "line": "                    }"
            },
            {
              "lineno": 104,
              "line": "                }"
            },
            {
              "lineno": 105,
              "line": "                stateCount[0] = stateCount[2]"
            },
            {
              "lineno": 106,
              "line": "                stateCount[1] = 1"
            },
            {
              "lineno": 107,
              "line": "                stateCount[2] = 0"
            },
            {
              "lineno": 108,
              "line": "                currentState_p = 1"
            },
            {
              "lineno": 109,
              "line": "            } else {"
            },
            {
              "lineno": 110,
              "line": "                currentState_p++"
            },
            {
              "lineno": 111,
              "line": "                stateCount[Int64(currentState_p)] += 1"
            },
            {
              "lineno": 112,
              "line": "            }"
            },
            {
              "lineno": 113,
              "line": "        }"
            },
            {
              "lineno": 114,
              "line": "        return (currentState_p, None)"
            },
            {
              "lineno": 115,
              "line": "    }"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 93,
              "end_line": 94,
              "label": "    func exfind(currentState: Int64, stateCount: Array<Int64>, i: Int64, j: Int64): (Int64, Option<AlignmentPattern>) {\n        var currentState_p = currentState",
              "successors": [
                {
                  "id": 2,
                  "start_line": 95,
                  "end_line": 97,
                  "label": "        if (currentState == 1) { // Counting black pixels\n            stateCount[1] += 1\n        } else {",
                  "successors": [
                    {
                      "id": 3,
                      "start_line": 96,
                      "end_line": 96,
                      "label": "            stateCount[1] += 1",
                      "successors": [
                        {
                          "id": 4,
                          "start_line": 114,
                          "end_line": 115,
                          "label": "        return (currentState_p, None)\n    }",
                          "successors": []
                        }
                      ]
                    },
                    {
                      "id": 5,
                      "start_line": 98,
                      "end_line": 113,
                      "label": "            if (currentState_p == 2) { // A winner?\n                if (foundPatternCross(stateCount)) { // Yes\n                    let confirmed: Option<AlignmentPattern> = handlePossibleCenter(stateCount, i, j);\n                    if (let Some(con) <- confirmed) {\n                        return (0, con)\n                    }\n                }\n                stateCount[0] = stateCount[2]\n                stateCount[1] = 1\n                stateCount[2] = 0\n                currentState_p = 1\n            } else {\n                currentState_p++\n                stateCount[Int64(currentState_p)] += 1\n            }",
                      "successors": [
                        {
                          "id": 6,
                          "start_line": 102,
                          "end_line": 103,
                          "label": "                        return (0, con)\n                    }",
                          "successors": []
                        },
                        {
                          "id": 7,
                          "start_line": 105,
                          "end_line": 108,
                          "label": "                stateCount[0] = stateCount[2]\n                stateCount[1] = 1\n                stateCount[2] = 0\n                currentState_p = 1",
                          "successors": [
                            {
                              "id": 8,
                              "start_line": 114,
                              "end_line": 115,
                              "label": "        return (currentState_p, None)\n    }",
                              "successors": []
                            }
                          ]
                        },
                        {
                          "id": 9,
                          "start_line": 110,
                          "end_line": 111,
                          "label": "                currentState_p++\n                stateCount[Int64(currentState_p)] += 1",
                          "successors": [
                            {
                              "id": 10,
                              "start_line": 114,
                              "end_line": 115,
                              "label": "        return (currentState_p, None)\n    }",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "centerFromEnd",
          "type": "function",
          "start_line": 116,
          "end_line": 118,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 116,
              "line": "    private static func centerFromEnd(stateCount: Array<Int64>, end: Int64): Float32 {"
            },
            {
              "lineno": 117,
              "line": "        return Float32(end - stateCount[2]) - Float32(stateCount[1]) / 2.0f32"
            },
            {
              "lineno": 118,
              "line": "    }"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 116,
              "end_line": 118,
              "label": "    private static func centerFromEnd(stateCount: Array<Int64>, end: Int64): Float32 {\n        return Float32(end - stateCount[2]) - Float32(stateCount[1]) / 2.0f32\n    }",
              "successors": []
            }
          ]
        },
        {
          "name": "foundPatternCross",
          "type": "function",
          "start_line": 119,
          "end_line": 128,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 119,
              "line": "    private func foundPatternCross(stateCount: Array<Int64>): Bool {"
            },
            {
              "lineno": 120,
              "line": "        let moduleSize: Float32 = this.moduleSize;"
            },
            {
              "lineno": 121,
              "line": "        let maxVariance: Float32 = moduleSize / 2.0f32"
            },
            {
              "lineno": 122,
              "line": "        for (i in 0..3) {"
            },
            {
              "lineno": 123,
              "line": "            if (abs(moduleSize - Float32(stateCount[i])) >= maxVariance) {"
            },
            {
              "lineno": 124,
              "line": "                return false;"
            },
            {
              "lineno": 125,
              "line": "            }"
            },
            {
              "lineno": 126,
              "line": "        }"
            },
            {
              "lineno": 127,
              "line": "        return true;"
            },
            {
              "lineno": 128,
              "line": "    }"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 119,
              "end_line": 121,
              "label": "    private func foundPatternCross(stateCount: Array<Int64>): Bool {\n        let moduleSize: Float32 = this.moduleSize;\n        let maxVariance: Float32 = moduleSize / 2.0f32",
              "successors": [
                {
                  "id": 2,
                  "start_line": 122,
                  "end_line": 122,
                  "label": "        for (i in 0..3) {",
                  "successors": [
                    {
                      "id": 3,
                      "start_line": 123,
                      "end_line": 125,
                      "label": "            if (abs(moduleSize - Float32(stateCount[i])) >= maxVariance) {\n                return false;\n            }",
                      "successors": [
                        {
                          "id": 4,
                          "start_line": 126,
                          "end_line": 126,
                          "label": "        }",
                          "successors": [
                            {
                              "id": 5,
                              "start_line": 127,
                              "end_line": 127,
                              "label": "        return true;",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "crossCheckVertical",
          "type": "function",
          "start_line": 129,
          "end_line": 179,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 129,
              "line": "    private func crossCheckVertical("
            },
            {
              "lineno": 130,
              "line": "        startI: Int64,"
            },
            {
              "lineno": 131,
              "line": "        centerJ: Int64,"
            },
            {
              "lineno": 132,
              "line": "        maxCount: Int64,"
            },
            {
              "lineno": 133,
              "line": "        originalStateCountTotal: Int64"
            },
            {
              "lineno": 134,
              "line": "    ): Float32 {"
            },
            {
              "lineno": 135,
              "line": "        let image: BitMatrix = this.image;"
            },
            {
              "lineno": 136,
              "line": "        let maxI: Int64 = image.getHeight();"
            },
            {
              "lineno": 137,
              "line": "        let stateCount: Array<Int64> = crossCheckStateCount"
            },
            {
              "lineno": 138,
              "line": "        stateCount[0] = 0"
            },
            {
              "lineno": 139,
              "line": "        stateCount[1] = 0"
            },
            {
              "lineno": 140,
              "line": "        stateCount[2] = 0"
            },
            {
              "lineno": 141,
              "line": "        // Start counting up from center"
            },
            {
              "lineno": 142,
              "line": "        var i: Int64 = startI"
            },
            {
              "lineno": 143,
              "line": "        while (i >= 0 && image.get(centerJ, i) && stateCount[1] <= maxCount) {"
            },
            {
              "lineno": 144,
              "line": "            stateCount[1] += 1"
            },
            {
              "lineno": 145,
              "line": "            i--"
            },
            {
              "lineno": 146,
              "line": "        }"
            },
            {
              "lineno": 147,
              "line": "        // If already too many modules in this state or ran off the edge:"
            },
            {
              "lineno": 148,
              "line": "        if (i < 0 || stateCount[1] > maxCount) {"
            },
            {
              "lineno": 149,
              "line": "            return Float32.NaN;"
            },
            {
              "lineno": 150,
              "line": "        }"
            },
            {
              "lineno": 151,
              "line": "        while (i >= 0 && !image.get(centerJ, i) && stateCount[0] <= maxCount) {"
            },
            {
              "lineno": 152,
              "line": "            stateCount[0] += 1"
            },
            {
              "lineno": 153,
              "line": "            i--"
            },
            {
              "lineno": 154,
              "line": "        }"
            },
            {
              "lineno": 155,
              "line": "        if (stateCount[0] > maxCount) {"
            },
            {
              "lineno": 156,
              "line": "            return Float32.NaN;"
            },
            {
              "lineno": 157,
              "line": "        }"
            },
            {
              "lineno": 158,
              "line": "        // Now also count down from center"
            },
            {
              "lineno": 159,
              "line": "        i = startI + 1"
            },
            {
              "lineno": 160,
              "line": "        while (i < maxI && image.get(centerJ, i) && stateCount[1] <= maxCount) {"
            },
            {
              "lineno": 161,
              "line": "            stateCount[1] += 1"
            },
            {
              "lineno": 162,
              "line": "            i++"
            },
            {
              "lineno": 163,
              "line": "        }"
            },
            {
              "lineno": 164,
              "line": "        if (i == maxI || stateCount[1] > maxCount) {"
            },
            {
              "lineno": 165,
              "line": "            return Float32.NaN;"
            },
            {
              "lineno": 166,
              "line": "        }"
            },
            {
              "lineno": 167,
              "line": "        while (i < maxI && !image.get(centerJ, i) && stateCount[2] <= maxCount) {"
            },
            {
              "lineno": 168,
              "line": "            stateCount[2] += 1"
            },
            {
              "lineno": 169,
              "line": "            i++"
            },
            {
              "lineno": 170,
              "line": "        }"
            },
            {
              "lineno": 171,
              "line": "        if (stateCount[2] > maxCount) {"
            },
            {
              "lineno": 172,
              "line": "            return Float32.NaN;"
            },
            {
              "lineno": 173,
              "line": "        }"
            },
            {
              "lineno": 174,
              "line": "        let stateCountTotal: Int64 = stateCount[0] + stateCount[1] + stateCount[2]"
            },
            {
              "lineno": 175,
              "line": "        if (5 * abs(stateCountTotal - originalStateCountTotal) >= 2 * originalStateCountTotal) {"
            },
            {
              "lineno": 176,
              "line": "            return Float32.NaN;"
            },
            {
              "lineno": 177,
              "line": "        }"
            },
            {
              "lineno": 178,
              "line": "        return excrossCheckVertical(stateCount, i)"
            },
            {
              "lineno": 179,
              "line": "    }"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 129,
              "end_line": 141,
              "label": "    private func crossCheckVertical(\n        startI: Int64,\n        centerJ: Int64,\n        maxCount: Int64,\n        originalStateCountTotal: Int64\n    ): Float32 {\n        let image: BitMatrix = this.image;\n        let maxI: Int64 = image.getHeight();\n        let stateCount: Array<Int64> = crossCheckStateCount\n        stateCount[0] = 0\n        stateCount[1] = 0\n        stateCount[2] = 0\n        // Start counting up from center",
              "successors": [
                {
                  "id": 2,
                  "start_line": 142,
                  "end_line": 143,
                  "label": "        var i: Int64 = startI\n        while (i >= 0 && image.get(centerJ, i) && stateCount[1] <= maxCount) {",
                  "successors": [
                    {
                      "id": 3,
                      "start_line": 144,
                      "end_line": 145,
                      "label": "            stateCount[1] += 1\n            i--",
                      "successors": [
                        {
                          "id": 4,
                          "start_line": 143,
                          "end_line": 143,
                          "label": "        while (i >= 0 && image.get(centerJ, i) && stateCount[1] <= maxCount) {",
                          "successors": [
                            {
                              "id": 5,
                              "start_line": 146,
                              "end_line": 147,
                              "label": "        }",
                              "successors": [
                                {
                                  "id": 6,
                                  "start_line": 148,
                                  "end_line": 149,
                                  "label": "        if (i < 0 || stateCount[1] > maxCount) {\n            return Float32.NaN;",
                                  "successors": []
                                },
                                {
                                  "id": 7,
                                  "start_line": 150,
                                  "end_line": 154,
                                  "label": "        }\n        while (i >= 0 && !image.get(centerJ, i) && stateCount[0] <= maxCount) {\n            stateCount[0] += 1\n            i--\n        }",
                                  "successors": [
                                    {
                                      "id": 8,
                                      "start_line": 155,
                                      "end_line": 156,
                                      "label": "        if (stateCount[0] > maxCount) {\n            return Float32.NaN;",
                                      "successors": []
                                    },
                                    {
                                      "id": 9,
                                      "start_line": 157,
                                      "end_line": 166,
                                      "label": "        }\n        // Now also count down from center\n        i = startI + 1\n        while (i < maxI && image.get(centerJ, i) && stateCount[1] <= maxCount) {\n            stateCount[1] += 1\n            i++\n        }\n        if (i == maxI || stateCount[1] > maxCount) {\n            return Float32.NaN;",
                                      "successors": []
                                    },
                                    {
                                      "id": 10,
                                      "start_line": 167,
                                      "end_line": 172,
                                      "label": "        }\n        while (i < maxI && !image.get(centerJ, i) && stateCount[2] <= maxCount) {\n            stateCount[2] += 1\n            i++\n        }\n        if (stateCount[2] > maxCount) {\n            return Float32.NaN;",
                                      "successors": []
                                    },
                                    {
                                      "id": 11,
                                      "start_line": 173,
                                      "end_line": 179,
                                      "label": "        }\n        let stateCountTotal: Int64 = stateCount[0] + stateCount[1] + stateCount[2]\n        if (5 * abs(stateCountTotal - originalStateCountTotal) >= 2 * originalStateCountTotal) {\n            return Float32.NaN;\n        }\n        return excrossCheckVertical(stateCount, i)\n    }",
                                      "successors": []
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "excrossCheckVertical",
          "type": "function",
          "start_line": 180,
          "end_line": 186,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 180,
              "line": "    private func excrossCheckVertical(stateCount: Array<Int64>, i: Int64) {"
            },
            {
              "lineno": 181,
              "line": "        if (foundPatternCross(stateCount)) {"
            },
            {
              "lineno": 182,
              "line": "            centerFromEnd(stateCount, i)"
            },
            {
              "lineno": 183,
              "line": "        } else {"
            },
            {
              "lineno": 184,
              "line": "            Float32.NaN"
            },
            {
              "lineno": 185,
              "line": "        }"
            },
            {
              "lineno": 186,
              "line": "    }"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 180,
              "end_line": 180,
              "label": "private func excrossCheckVertical(stateCount: Array<Int64>, i: Int64) {",
              "successors": [
                {
                  "id": 2,
                  "start_line": 181,
                  "end_line": 182,
                  "label": "if (foundPatternCross(stateCount)) {\n    centerFromEnd(stateCount, i)",
                  "successors": [
                    {
                      "id": 3,
                      "start_line": 183,
                      "end_line": 184,
                      "label": "} else {\n    Float32.NaN",
                      "successors": [
                        {
                          "id": 4,
                          "start_line": 185,
                          "end_line": 186,
                          "label": "}",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "handlePossibleCenter",
          "type": "function",
          "start_line": 187,
          "end_line": 207,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 187,
              "line": "    private func handlePossibleCenter(stateCount: Array<Int64>, i: Int64, j: Int64): Option<AlignmentPattern> {"
            },
            {
              "lineno": 188,
              "line": "        let stateCountTotal: Int64 = stateCount[0] + stateCount[1] + stateCount[2]"
            },
            {
              "lineno": 189,
              "line": "        let centerJ: Float32 = centerFromEnd(stateCount, j);"
            },
            {
              "lineno": 190,
              "line": "        let centerI: Float32 = crossCheckVertical(i, Int64(centerJ), 2 * stateCount[1], stateCountTotal);"
            },
            {
              "lineno": 191,
              "line": "        if (!centerI.isNaN()) {"
            },
            {
              "lineno": 192,
              "line": "            let estimatedModuleSize: Float32 = Float32(stateCount[0] + stateCount[1] + stateCount[2]) / 3.0f32"
            },
            {
              "lineno": 193,
              "line": "            for (i in 0..possibleCenters.size) {"
            },
            {
              "lineno": 194,
              "line": "                // Look for about the same center and module size:"
            },
            {
              "lineno": 195,
              "line": "                if (possibleCenters[i].aboutEquals(estimatedModuleSize, centerI, centerJ)) {"
            },
            {
              "lineno": 196,
              "line": "                    return possibleCenters[i].combineEstimate(centerI, centerJ, estimatedModuleSize);"
            },
            {
              "lineno": 197,
              "line": "                }"
            },
            {
              "lineno": 198,
              "line": "            }"
            },
            {
              "lineno": 199,
              "line": "            // Hadn't found this before; save it"
            },
            {
              "lineno": 200,
              "line": "            let point: AlignmentPattern = AlignmentPattern(centerJ, centerI, estimatedModuleSize);"
            },
            {
              "lineno": 201,
              "line": "            possibleCenters.append(point);"
            },
            {
              "lineno": 202,
              "line": "            if (let Some(res) <- resultPointCallback) {"
            },
            {
              "lineno": 203,
              "line": "                res.foundPossibleResultPoint(point);"
            },
            {
              "lineno": 204,
              "line": "            }"
            },
            {
              "lineno": 205,
              "line": "        }"
            },
            {
              "lineno": 206,
              "line": "        return None"
            },
            {
              "lineno": 207,
              "line": "    }"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 187,
              "end_line": 190,
              "label": "private func handlePossibleCenter(stateCount: Array<Int64>, i: Int64, j: Int64): Option<AlignmentPattern> {\n    let stateCountTotal: Int64 = stateCount[0] + stateCount[1] + stateCount[2]\n    let centerJ: Float32 = centerFromEnd(stateCount, j);\n    let centerI: Float32 = crossCheckVertical(i, Int64(centerJ), 2 * stateCount[1], stateCountTotal);",
              "successors": [
                {
                  "id": 2,
                  "start_line": 191,
                  "end_line": 191,
                  "label": "if (!centerI.isNaN()) {",
                  "successors": [
                    {
                      "id": 3,
                      "start_line": 192,
                      "end_line": 192,
                      "label": "let estimatedModuleSize: Float32 = Float32(stateCount[0] + stateCount[1] + stateCount[2]) / 3.0f32",
                      "successors": [
                        {
                          "id": 4,
                          "start_line": 193,
                          "end_line": 193,
                          "label": "for (i in 0..possibleCenters.size) {",
                          "successors": [
                            {
                              "id": 5,
                              "start_line": 195,
                              "end_line": 195,
                              "label": "if (possibleCenters[i].aboutEquals(estimatedModuleSize, centerI, centerJ)) {",
                              "successors": [
                                {
                                  "id": 6,
                                  "start_line": 196,
                                  "end_line": 196,
                                  "label": "return possibleCenters[i].combineEstimate(centerI, centerJ, estimatedModuleSize);",
                                  "successors": []
                                }
                              ]
                            },
                            {
                              "id": 7,
                              "start_line": 198,
                              "end_line": 198,
                              "label": "}",
                              "successors": []
                            }
                          ]
                        },
                        {
                          "id": 8,
                          "start_line": 199,
                          "end_line": 204,
                          "label": "// Hadn't found this before; save it\nlet point: AlignmentPattern = AlignmentPattern(centerJ, centerI, estimatedModuleSize);\npossibleCenters.append(point);\nif (let Some(res) <- resultPointCallback) {\n    res.foundPossibleResultPoint(point);\n}",
                          "successors": [
                            {
                              "id": 9,
                              "start_line": 205,
                              "end_line": 205,
                              "label": "}",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "id": 10,
                  "start_line": 206,
                  "end_line": 206,
                  "label": "return None",
                  "successors": []
                }
              ]
            }
          ]
        }
      ],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 6,
          "line": "public class AlignmentPatternFinder {"
        },
        {
          "lineno": 7,
          "line": "    private var image: BitMatrix = BitMatrix();"
        },
        {
          "lineno": 8,
          "line": "    private var possibleCenters: ArrayList<AlignmentPattern> = ArrayList<AlignmentPattern>();"
        },
        {
          "lineno": 9,
          "line": "    private var startX: Int64 = 0;"
        },
        {
          "lineno": 10,
          "line": "    private var startY: Int64 = 0;"
        },
        {
          "lineno": 11,
          "line": "    private var width: Int64 = 0;"
        },
        {
          "lineno": 12,
          "line": "    private var height: Int64 = 0;"
        },
        {
          "lineno": 13,
          "line": "    private var moduleSize: Float32 = 0.0f32;"
        },
        {
          "lineno": 14,
          "line": "    private var crossCheckStateCount: Array<Int64> = Array<Int64>();"
        },
        {
          "lineno": 15,
          "line": "    private var resultPointCallback: ?ResultPointCallback = None"
        },
        {
          "lineno": 208,
          "line": "}"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "start_line": 6,
          "end_line": 15,
          "label": "public class AlignmentPatternFinder {\n    private var image: BitMatrix = BitMatrix();\n    private var possibleCenters: ArrayList<AlignmentPattern> = ArrayList<AlignmentPattern>();\n    private var startX: Int64 = 0;\n    private var startY: Int64 = 0;\n    private var width: Int64 = 0;\n    private var height: Int64 = 0;\n    private var moduleSize: Float32 = 0.0f32;\n    private var crossCheckStateCount: Array<Int64> = Array<Int64>();\n    private var resultPointCallback: ?ResultPointCallback = None",
          "successors": [
            {
              "id": 2,
              "start_line": 208,
              "end_line": 208,
              "label": "}",
              "successors": []
            }
          ]
        }
      ]
    }
  ],
  "simplified_code": [
    {
      "lineno": 1,
      "line": "package qrcode.detector"
    },
    {
      "lineno": 2,
      "line": "import common.Qrcoder4cjNotFoundException"
    },
    {
      "lineno": 3,
      "line": "import common.ResultPointCallback"
    },
    {
      "lineno": 4,
      "line": "import common.BitMatrix"
    },
    {
      "lineno": 5,
      "line": "from std import collection.*"
    }
  ],
  "blocks": [
    {
      "id": 1,
      "start_line": 1,
      "end_line": 5,
      "label": "package qrcode.detector\nimport common.Qrcoder4cjNotFoundException\nimport common.ResultPointCallback\nimport common.BitMatrix\nfrom std import collection.*",
      "successors": []
    }
  ]
}