{
  "name": "example_script",
  "type": "CFG",
  "start_line": 1,
  "end_line": 350,
  "functions": [
    {
      "name": "SplitCurrentState",
      "type": "function",
      "start_line": 2,
      "end_line": 21,
      "functions": [],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 2,
          "line": "func SplitCurrentState<V, G>("
        },
        {
          "lineno": 3,
          "line": "    coreEdge : Edge<V, G>,"
        },
        {
          "lineno": 4,
          "line": "    numberOfStateWires : Int64,"
        },
        {
          "lineno": 5,
          "line": "    rewriteStartingElements : HashSet<TraversalElement<V, G>>,"
        },
        {
          "lineno": 6,
          "line": "    rewriteEndingElements : HashSet<TraversalElement<V, G>>"
        },
        {
          "lineno": 7,
          "line": ") : Array<(Vertex<V, G>, Vertex<V, G>)>"
        },
        {
          "lineno": 8,
          "line": "    where V <: ValueSymbol<V>, G <: PrimitiveSymbol<V, G>"
        },
        {
          "lineno": 9,
          "line": "{"
        },
        {
          "lineno": 10,
          "line": "    Array<(Vertex<V, G>, Vertex<V, G>)>("
        },
        {
          "lineno": 11,
          "line": "        numberOfStateWires,"
        },
        {
          "lineno": 12,
          "line": "        { i : Int64 =>"
        },
        {
          "lineno": 13,
          "line": "            let joinEdge = coreEdge.NextEdgeLeft(i).getOrThrow().GetEdge()"
        },
        {
          "lineno": 14,
          "line": "            let joinSourceLeft = joinEdge.GetSource(0)"
        },
        {
          "lineno": 15,
          "line": "            let (left, right) = joinSourceLeft.SplitVertex()"
        },
        {
          "lineno": 16,
          "line": "            rewriteStartingElements.put(VERTEX(left))"
        },
        {
          "lineno": 17,
          "line": "            rewriteEndingElements.put(EDGE(joinEdge))"
        },
        {
          "lineno": 18,
          "line": "            (left, right)"
        },
        {
          "lineno": 19,
          "line": "        }"
        },
        {
          "lineno": 20,
          "line": "    )"
        },
        {
          "lineno": 21,
          "line": "}"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "start_line": 2,
          "end_line": 8,
          "label": "func SplitCurrentState<V, G>(\n    coreEdge : Edge<V, G>,\n    numberOfStateWires : Int64,\n    rewriteStartingElements : HashSet<TraversalElement<V, G>>,\n    rewriteEndingElements : HashSet<TraversalElement<V, G>>\n) : Array<(Vertex<V, G>, Vertex<V, G>)>\n    where V <: ValueSymbol<V>, G <: PrimitiveSymbol<V, G>",
          "successors": [
            {
              "id": 2,
              "start_line": 9,
              "end_line": 20,
              "label": "{\n    Array<(Vertex<V, G>, Vertex<V, G>)>(\n        numberOfStateWires,\n        { i : Int64 =>\n            let joinEdge = coreEdge.NextEdgeLeft(i).getOrThrow().GetEdge()\n            let joinSourceLeft = joinEdge.GetSource(0)\n            let (left, right) = joinSourceLeft.SplitVertex()\n            rewriteStartingElements.put(VERTEX(left))\n            rewriteEndingElements.put(EDGE(joinEdge))\n            (left, right)\n        }\n    )\n}",
              "successors": [
                {
                  "id": 3,
                  "start_line": 21,
                  "end_line": 21,
                  "label": "}"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "GetCoreSourceVertices",
      "type": "function",
      "start_line": 22,
      "end_line": 73,
      "functions": [],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 22,
          "line": "func GetCoreSourceVertices<V, G>("
        },
        {
          "lineno": 23,
          "line": "    coreEdge : Edge<V, G>,"
        },
        {
          "lineno": 24,
          "line": "    numberOfStateWires : Int64,"
        },
        {
          "lineno": 25,
          "line": "    inputSignals : Array<CycleInput<V>>,"
        },
        {
          "lineno": 26,
          "line": "    splitStateVertices : Array<(Vertex<V, G>, Vertex<V, G>)>,"
        },
        {
          "lineno": 27,
          "line": "    rewriteStartingElements : HashSet<TraversalElement<V, G>>"
        },
        {
          "lineno": 28,
          "line": ") : Array<Vertex<V, G>>"
        },
        {
          "lineno": 29,
          "line": "    where V <: ValueSymbol<V>, G <: PrimitiveSymbol<V, G> {"
        },
        {
          "lineno": 30,
          "line": "    Array<Vertex<V, G>>("
        },
        {
          "lineno": 31,
          "line": "        coreEdge.GetArity(),"
        },
        {
          "lineno": 32,
          "line": "        { i : Int64 =>"
        },
        {
          "lineno": 33,
          "line": "            // Check which partition of sources this belongs to"
        },
        {
          "lineno": 34,
          "line": "            if(i < numberOfStateWires) {"
        },
        {
          "lineno": 35,
          "line": "                // This is a vertex from the state"
        },
        {
          "lineno": 36,
          "line": "                // We grab the existing state vertex"
        },
        {
          "lineno": 37,
          "line": "                splitStateVertices[i][0]"
        },
        {
          "lineno": 38,
          "line": "            } else {"
        },
        {
          "lineno": 39,
          "line": "                // This is a vertex from the inputs"
        },
        {
          "lineno": 40,
          "line": "                // We create the input edge and grab its target"
        },
        {
          "lineno": 41,
          "line": "                // Get the signal"
        },
        {
          "lineno": 42,
          "line": "                let input = inputSignals[i - numberOfStateWires]"
        },
        {
          "lineno": 43,
          "line": "                let (inputLabel, inputSubgraph) ="
        },
        {
          "lineno": 44,
          "line": "                    match(input) {"
        },
        {
          "lineno": 45,
          "line": "                        case DEFINITE(signal) =>"
        },
        {
          "lineno": 46,
          "line": "                            // Make a label"
        },
        {
          "lineno": 47,
          "line": "                            let signalLabel = GetSignalLabel<V, G>(signal)"
        },
        {
          "lineno": 48,
          "line": "                            let signalSubgraph = if(signal.GetWidth() == 1) {"
        },
        {
          "lineno": 49,
          "line": "                                None<InterfacedHypergraph<V, G>>"
        },
        {
          "lineno": 50,
          "line": "                            } else {"
        },
        {
          "lineno": 51,
          "line": "                                MakeSignal<V, G>(signal)"
        },
        {
          "lineno": 52,
          "line": "                            }"
        },
        {
          "lineno": 53,
          "line": "                            (signalLabel, signalSubgraph)"
        },
        {
          "lineno": 54,
          "line": "                        case PARTIAL(pi) =>"
        },
        {
          "lineno": 55,
          "line": "                            let partialLabel = Label<V, G>.PARTIAL(pi)"
        },
        {
          "lineno": 56,
          "line": "                            let partialSubgraph ="
        },
        {
          "lineno": 57,
          "line": "                                None<InterfacedHypergraph<V, G>>"
        },
        {
          "lineno": 58,
          "line": "                            (partialLabel, partialSubgraph)"
        },
        {
          "lineno": 59,
          "line": "                    }"
        },
        {
          "lineno": 60,
          "line": "                let inputTarget = Vertex<V, G>(input.GetWidth(), None)"
        },
        {
          "lineno": 61,
          "line": "                // Create the signal"
        },
        {
          "lineno": 62,
          "line": "                let inputEdge = Edge("
        },
        {
          "lineno": 63,
          "line": "                    inputLabel, Array<Vertex<V, G>>(), [inputTarget],"
        },
        {
          "lineno": 64,
          "line": "                    inputSubgraph, coreEdge.GetGraph()"
        },
        {
          "lineno": 65,
          "line": "                )"
        },
        {
          "lineno": 66,
          "line": "                // The target of this edge will need to be traversed"
        },
        {
          "lineno": 67,
          "line": "                // during rewriting"
        },
        {
          "lineno": 68,
          "line": "                rewriteStartingElements.put(VERTEX(inputTarget))"
        },
        {
          "lineno": 69,
          "line": "                inputTarget"
        },
        {
          "lineno": 70,
          "line": "            }"
        },
        {
          "lineno": 71,
          "line": "        }"
        },
        {
          "lineno": 72,
          "line": "    )"
        },
        {
          "lineno": 73,
          "line": "}"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "start_line": 22,
          "end_line": 24,
          "label": "func GetCoreSourceVertices<V, G>(\n    coreEdge : Edge<V, G>,\n    numberOfStateWires : Int64,",
          "successors": [
            {
              "id": 2,
              "start_line": 25,
              "end_line": 27,
              "label": "inputSignals : Array<CycleInput<V>>,\n    splitStateVertices : Array<(Vertex<V, G>, Vertex<V, G>)>,\n    rewriteStartingElements : HashSet<TraversalElement<V, G>>",
              "successors": [
                {
                  "id": 3,
                  "start_line": 28,
                  "end_line": 29,
                  "label": ") : Array<Vertex<V, G>>\n    where V <: ValueSymbol<V>, G <: PrimitiveSymbol<V, G> {",
                  "successors": [
                    {
                      "id": 4,
                      "start_line": 30,
                      "end_line": 32,
                      "label": "Array<Vertex<V, G>>(\n        coreEdge.GetArity(),\n        { i : Int64 =>",
                      "successors": [
                        {
                          "id": 5,
                          "start_line": 33,
                          "end_line": 34,
                          "label": "// Check which partition of sources this belongs to\n            if(i < numberOfStateWires) {",
                          "successors": [
                            {
                              "id": 6,
                              "start_line": 35,
                              "end_line": 37,
                              "label": "// This is a vertex from the state\n                // We grab the existing state vertex\n                splitStateVertices[i][0]",
                              "successors": []
                            },
                            {
                              "id": 7,
                              "start_line": 38,
                              "end_line": 43,
                              "label": "} else {\n                // This is a vertex from the inputs\n                // We create the input edge and grab its target\n                // Get the signal\n                let input = inputSignals[i - numberOfStateWires]\n                let (inputLabel, inputSubgraph) =",
                              "successors": [
                                {
                                  "id": 8,
                                  "start_line": 44,
                                  "end_line": 45,
                                  "label": "match(input) {\n                        case DEFINITE(signal) =>",
                                  "successors": [
                                    {
                                      "id": 9,
                                      "start_line": 46,
                                      "end_line": 53,
                                      "label": "// Make a label\n                            let signalLabel = GetSignalLabel<V, G>(signal)\n                            let signalSubgraph = if(signal.GetWidth() == 1) {\n                                None<InterfacedHypergraph<V, G>>\n                            } else {\n                                MakeSignal<V, G>(signal)\n                            }\n                            (signalLabel, signalSubgraph)",
                                      "successors": []
                                    },
                                    {
                                      "id": 10,
                                      "start_line": 54,
                                      "end_line": 58,
                                      "label": "case PARTIAL(pi) =>\n                            let partialLabel = Label<V, G>.PARTIAL(pi)\n                            let partialSubgraph =\n                                None<InterfacedHypergraph<V, G>>\n                            (partialLabel, partialSubgraph)",
                                      "successors": []
                                    }
                                  ]
                                },
                                {
                                  "id": 11,
                                  "start_line": 59,
                                  "end_line": 70,
                                  "label": "}\n                let inputTarget = Vertex<V, G>(input.GetWidth(), None)\n                // Create the signal\n                let inputEdge = Edge(\n                    inputLabel, Array<Vertex<V, G>>(), [inputTarget],\n                    inputSubgraph, coreEdge.GetGraph()\n                )\n                // The target of this edge will need to be traversed\n                // during rewriting\n                rewriteStartingElements.put(VERTEX(inputTarget))\n                inputTarget\n            }",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        },
                        {
                          "id": 12,
                          "start_line": 71,
                          "end_line": 73,
                          "label": "}\n    )\n}",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "CreateOutputJoinEdges",
      "type": "function",
      "start_line": 74,
      "end_line": 102,
      "functions": [],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 74,
          "line": "func CreateOutputJoinEdges<V, G>("
        },
        {
          "lineno": 75,
          "line": "    graph : Hypergraph<V, G>,"
        },
        {
          "lineno": 76,
          "line": "    latestDelayVertices : Array<Vertex<V, G>>,"
        },
        {
          "lineno": 77,
          "line": "    latestInstantVertices : Array<Vertex<V, G>>,"
        },
        {
          "lineno": 78,
          "line": "    rewriteEndingElements : HashSet<TraversalElement<V, G>>"
        },
        {
          "lineno": 79,
          "line": ") : Array<Edge<V, G>> where V <: ValueSymbol<V>, G <: PrimitiveSymbol<V, G> {"
        },
        {
          "lineno": 80,
          "line": "    mapi("
        },
        {
          "lineno": 81,
          "line": "        { v : Vertex<V, G>, i : Int64 =>"
        },
        {
          "lineno": 82,
          "line": "            // Split this vertex, as we are going to insert a register"
        },
        {
          "lineno": 83,
          "line": "            let (leftVertex, rightVertex) = v.SplitVertex()"
        },
        {
          "lineno": 84,
          "line": "            let outputWidth = v.GetWidth()"
        },
        {
          "lineno": 85,
          "line": "            let delayTarget = Vertex<V, G>(outputWidth, Some(graph))"
        },
        {
          "lineno": 86,
          "line": "            let delayEdge = Edge("
        },
        {
          "lineno": 87,
          "line": "                DELAY(outputWidth), [leftVertex], [delayTarget], None, graph"
        },
        {
          "lineno": 88,
          "line": "            )"
        },
        {
          "lineno": 89,
          "line": "            latestDelayVertices[i] = leftVertex"
        },
        {
          "lineno": 90,
          "line": "            // Create the instant component for this register"
        },
        {
          "lineno": 91,
          "line": "            let outputTarget = Vertex<V, G>(outputWidth, Some(graph))"
        },
        {
          "lineno": 92,
          "line": "            latestInstantVertices[i] = outputTarget"
        },
        {
          "lineno": 93,
          "line": "            // Create the join for this register"
        },
        {
          "lineno": 94,
          "line": "            let joinEdge = Edge("
        },
        {
          "lineno": 95,
          "line": "                JOIN(outputWidth), [outputTarget, delayTarget],"
        },
        {
          "lineno": 96,
          "line": "                [rightVertex], None, graph"
        },
        {
          "lineno": 97,
          "line": "            )"
        },
        {
          "lineno": 98,
          "line": "            rewriteEndingElements.put(VERTEX(outputTarget))"
        },
        {
          "lineno": 99,
          "line": "            joinEdge"
        },
        {
          "lineno": 100,
          "line": "        }, latestDelayVertices"
        },
        {
          "lineno": 101,
          "line": "    )"
        },
        {
          "lineno": 102,
          "line": "}"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "start_line": 74,
          "end_line": 79,
          "label": "func CreateOutputJoinEdges<V, G>(\n    graph : Hypergraph<V, G>,\n    latestDelayVertices : Array<Vertex<V, G>>,\n    latestInstantVertices : Array<Vertex<V, G>>,\n    rewriteEndingElements : HashSet<TraversalElement<V, G>>\n) : Array<Edge<V, G>> where V <: ValueSymbol<V>, G <: PrimitiveSymbol<V, G> {",
          "successors": [
            {
              "id": 2,
              "start_line": 80,
              "end_line": 101,
              "label": "mapi(\n    { v : Vertex<V, G>, i : Int64 =>\n        // Split this vertex, as we are going to insert a register\n        let (leftVertex, rightVertex) = v.SplitVertex()\n        let outputWidth = v.GetWidth()\n        let delayTarget = Vertex<V, G>(outputWidth, Some(graph))\n        let delayEdge = Edge(\n            DELAY(outputWidth), [leftVertex], [delayTarget], None, graph\n        )\n        latestDelayVertices[i] = leftVertex\n        // Create the instant component for this register\n        let outputTarget = Vertex<V, G>(outputWidth, Some(graph))\n        latestInstantVertices[i] = outputTarget\n        // Create the join for this register\n        let joinEdge = Edge(\n            JOIN(outputWidth), [outputTarget, delayTarget],\n            [rightVertex], None, graph\n        )\n        rewriteEndingElements.put(VERTEX(outputTarget))\n        joinEdge\n    }, latestDelayVertices\n)",
              "successors": [
                {
                  "id": 3,
                  "start_line": 102,
                  "end_line": 102,
                  "label": "}",
                  "successors": []
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "GetCoreTargetVertices",
      "type": "function",
      "start_line": 103,
      "end_line": 126,
      "functions": [],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 103,
          "line": "public func GetCoreTargetVertices<V, G>("
        },
        {
          "lineno": 104,
          "line": "    coreEdge : Edge<V, G>,"
        },
        {
          "lineno": 105,
          "line": "    numberOfStateWires : Int64,"
        },
        {
          "lineno": 106,
          "line": "    splitStateVertices : Array<(Vertex<V, G>, Vertex<V, G>)>,"
        },
        {
          "lineno": 107,
          "line": "    latestInstantVertices : Array<Vertex<V, G>>"
        },
        {
          "lineno": 108,
          "line": ") : Array<Vertex<V, G>>"
        },
        {
          "lineno": 109,
          "line": "    where V <: ValueSymbol<V>, G <: PrimitiveSymbol<V, G>"
        },
        {
          "lineno": 110,
          "line": "{"
        },
        {
          "lineno": 111,
          "line": "    Array<Vertex<V, G>>(coreEdge.GetCoarity()) {"
        },
        {
          "lineno": 112,
          "line": "        i : Int64 =>"
        },
        {
          "lineno": 113,
          "line": "            // The targets of the cloned core edge are paritioned between"
        },
        {
          "lineno": 114,
          "line": "            // the state transition and the outputs. If we are getting the"
        },
        {
          "lineno": 115,
          "line": "            // target for a state transition, we just use the right vertex"
        },
        {
          "lineno": 116,
          "line": "            // of the split state we made earlier. If we are getting the"
        },
        {
          "lineno": 117,
          "line": "            // target for an output, we split the corresponding output"
        },
        {
          "lineno": 118,
          "line": "            // vertex and insert a register, the instnat component of which"
        },
        {
          "lineno": 119,
          "line": "            // is the target we are getting."
        },
        {
          "lineno": 120,
          "line": "            if(i < numberOfStateWires) {"
        },
        {
          "lineno": 121,
          "line": "                splitStateVertices[i][1]"
        },
        {
          "lineno": 122,
          "line": "            } else {"
        },
        {
          "lineno": 123,
          "line": "                latestInstantVertices[i - numberOfStateWires]"
        },
        {
          "lineno": 124,
          "line": "            }"
        },
        {
          "lineno": 125,
          "line": "    }"
        },
        {
          "lineno": 126,
          "line": "}"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "start_line": 103,
          "end_line": 110,
          "label": "public func GetCoreTargetVertices<V, G>(\n    coreEdge : Edge<V, G>,\n    numberOfStateWires : Int64,\n    splitStateVertices : Array<(Vertex<V, G>, Vertex<V, G>)>,\n    latestInstantVertices : Array<Vertex<V, G>>\n) : Array<Vertex<V, G>>\n    where V <: ValueSymbol<V>, G <: PrimitiveSymbol<V, G>\n{",
          "successors": [
            {
              "id": 2,
              "start_line": 111,
              "end_line": 119,
              "label": "Array<Vertex<V, G>>(coreEdge.GetCoarity()) {\n    i : Int64 =>\n        // The targets of the cloned core edge are paritioned between\n        // the state transition and the outputs. If we are getting the\n        // target for a state transition, we just use the right vertex\n        // of the split state we made earlier. If we are getting the\n        // target for an output, we split the corresponding output\n        // vertex and insert a register, the instnat component of which\n        // is the target we are getting.",
              "successors": [
                {
                  "id": 3,
                  "start_line": 120,
                  "end_line": 120,
                  "label": "if(i < numberOfStateWires) {",
                  "successors": [
                    {
                      "id": 4,
                      "start_line": 121,
                      "end_line": 121,
                      "label": "splitStateVertices[i][1]",
                      "successors": [
                        {
                          "id": 5,
                          "start_line": 122,
                          "end_line": 122,
                          "label": "} else {",
                          "successors": [
                            {
                              "id": 6,
                              "start_line": 123,
                              "end_line": 123,
                              "label": "latestInstantVertices[i - numberOfStateWires]",
                              "successors": [
                                {
                                  "id": 7,
                                  "start_line": 124,
                                  "end_line": 126,
                                  "label": "}\n}\n}",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "GetOutputData",
      "type": "function",
      "start_line": 127,
      "end_line": 138,
      "functions": [],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 127,
          "line": "func GetOutputData<V, G>("
        },
        {
          "lineno": 128,
          "line": "    outputSubgraphs : Array<InterfacedHypergraph<V, G>>"
        },
        {
          "lineno": 129,
          "line": ") : Array<OutputData<V, G>>"
        },
        {
          "lineno": 130,
          "line": "    where V <: ValueSymbol<V>, G <: PrimitiveSymbol<V, G>"
        },
        {
          "lineno": 131,
          "line": "{"
        },
        {
          "lineno": 132,
          "line": "    map("
        },
        {
          "lineno": 133,
          "line": "        { f =>"
        },
        {
          "lineno": 134,
          "line": "            let term = GetOutputTerm(f.GetOutput(0).GetVertex())"
        },
        {
          "lineno": 135,
          "line": "            OutputData<V, G>(term, f)"
        },
        {
          "lineno": 136,
          "line": "        }, outputSubgraphs"
        },
        {
          "lineno": 137,
          "line": "    )"
        },
        {
          "lineno": 138,
          "line": "}"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "start_line": 127,
          "end_line": 130,
          "label": "func GetOutputData<V, G>(\n    outputSubgraphs : Array<InterfacedHypergraph<V, G>>\n) : Array<OutputData<V, G>>\n    where V <: ValueSymbol<V>, G <: PrimitiveSymbol<V, G>",
          "successors": [
            {
              "id": 2,
              "start_line": 131,
              "end_line": 138,
              "label": "{\n    map(\n        { f =>\n            let term = GetOutputTerm(f.GetOutput(0).GetVertex())\n            OutputData<V, G>(term, f)\n        }, outputSubgraphs\n    )\n}",
              "successors": []
            }
          ]
        }
      ]
    },
    {
      "name": "UpdateInputOutputHistory",
      "type": "function",
      "start_line": 139,
      "end_line": 156,
      "functions": [],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 139,
          "line": "func UpdateInputOutputHistory<V, G>("
        },
        {
          "lineno": 140,
          "line": "    graph : InterfacedHypergraph<V, G>,"
        },
        {
          "lineno": 141,
          "line": "    inputSignals : Array<CycleInput<V>>,"
        },
        {
          "lineno": 142,
          "line": "    outputSubgraphs : Array<InterfacedHypergraph<V, G>>,"
        },
        {
          "lineno": 143,
          "line": "    history : InputOutputHistory<V, G>"
        },
        {
          "lineno": 144,
          "line": ") : Unit where V <: ValueSymbol<V>, G <: PrimitiveSymbol<V, G> {"
        },
        {
          "lineno": 145,
          "line": "    let outputData = GetOutputData(outputSubgraphs)"
        },
        {
          "lineno": 146,
          "line": "    history.inputHistoryPerTick.append(inputSignals)"
        },
        {
          "lineno": 147,
          "line": "    history.outputHistoryPerTick.append(outputData)"
        },
        {
          "lineno": 148,
          "line": "    let inputOutput = InputOutput(inputSignals, outputData)"
        },
        {
          "lineno": 149,
          "line": "    history.inputOutputHistoryPerTick.append(inputOutput)"
        },
        {
          "lineno": 150,
          "line": "    for(i in 0..graph.GetArity()) {"
        },
        {
          "lineno": 151,
          "line": "        history.inputHistoryPerPort[i].append(inputSignals[i])"
        },
        {
          "lineno": 152,
          "line": "    }"
        },
        {
          "lineno": 153,
          "line": "    for(i in 0..graph.GetCoarity()) {"
        },
        {
          "lineno": 154,
          "line": "        history.outputHistoryPerPort[i].append(outputData[i])"
        },
        {
          "lineno": 155,
          "line": "    }"
        },
        {
          "lineno": 156,
          "line": "}"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "start_line": 139,
          "end_line": 149,
          "label": "func UpdateInputOutputHistory<V, G>(\n    graph : InterfacedHypergraph<V, G>,\n    inputSignals : Array<CycleInput<V>>,\n    outputSubgraphs : Array<InterfacedHypergraph<V, G>>,\n    history : InputOutputHistory<V, G>\n) : Unit where V <: ValueSymbol<V>, G <: PrimitiveSymbol<V, G> {\n    let outputData = GetOutputData(outputSubgraphs)\n    history.inputHistoryPerTick.append(inputSignals)\n    history.outputHistoryPerTick.append(outputData)\n    let inputOutput = InputOutput(inputSignals, outputData)\n    history.inputOutputHistoryPerTick.append(inputOutput)",
          "successors": [
            {
              "id": 2,
              "start_line": 150,
              "end_line": 152,
              "label": "for(i in 0..graph.GetArity()) {\n    history.inputHistoryPerPort[i].append(inputSignals[i])\n}",
              "successors": [
                {
                  "id": 3,
                  "start_line": 153,
                  "end_line": 155,
                  "label": "for(i in 0..graph.GetCoarity()) {\n    history.outputHistoryPerPort[i].append(outputData[i])\n}",
                  "successors": [
                    {
                      "id": 4,
                      "start_line": 156,
                      "end_line": 156,
                      "label": "}",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "CollapseSingleOutput",
      "type": "function",
      "start_line": 157,
      "end_line": 168,
      "functions": [],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 157,
          "line": "func CollapseSingleOutput<V, G>("
        },
        {
          "lineno": 158,
          "line": "    rootVertex : Vertex<V, G>, label : Label<V, G>, tick : Int64, index : Int64"
        },
        {
          "lineno": 159,
          "line": ") : InterfacedHypergraph<V, G>"
        },
        {
          "lineno": 160,
          "line": "    where V <: ValueSymbol<V>, G <: PrimitiveSymbol<V, G>"
        },
        {
          "lineno": 161,
          "line": "{"
        },
        {
          "lineno": 162,
          "line": "    let (subgraph, _) = rootVertex.GetGraph().CollapseSubgraph("
        },
        {
          "lineno": 163,
          "line": "        Array<TentacleOrigin<V, G>>(),"
        },
        {
          "lineno": 164,
          "line": "        [FROM_EDGE(rootVertex.GetInEdge().getOrThrow())],"
        },
        {
          "lineno": 165,
          "line": "        \"${label.GetName()}[${index}] @ ${tick}\""
        },
        {
          "lineno": 166,
          "line": "    )"
        },
        {
          "lineno": 167,
          "line": "    subgraph"
        },
        {
          "lineno": 168,
          "line": "}"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "start_line": 157,
          "end_line": 168,
          "label": "func CollapseSingleOutput<V, G>(\n    rootVertex : Vertex<V, G>, label : Label<V, G>, tick : Int64, index : Int64\n) : InterfacedHypergraph<V, G>\n    where V <: ValueSymbol<V>, G <: PrimitiveSymbol<V, G>\n{\n    let (subgraph, _) = rootVertex.GetGraph().CollapseSubgraph(\n        Array<TentacleOrigin<V, G>>(),\n        [FROM_EDGE(rootVertex.GetInEdge().getOrThrow())],\n        \"${label.GetName()}[${index}] @ ${tick}\"\n    )\n    subgraph\n}",
          "successors": []
        }
      ]
    },
    {
      "name": "CollapseOutputs",
      "type": "function",
      "start_line": 169,
      "end_line": 180,
      "functions": [],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 169,
          "line": "func CollapseOutputs<V, G>("
        },
        {
          "lineno": 170,
          "line": "    joinEdges : Array<Edge<V, G>>, label : Label<V, G>, tick : Int64"
        },
        {
          "lineno": 171,
          "line": ") : Array<InterfacedHypergraph<V, G>>"
        },
        {
          "lineno": 172,
          "line": "    where V <: ValueSymbol<V>, G <: PrimitiveSymbol<V, G>"
        },
        {
          "lineno": 173,
          "line": "{"
        },
        {
          "lineno": 174,
          "line": "    mapi("
        },
        {
          "lineno": 175,
          "line": "        { e : Edge<V, G>, i : Int64 =>"
        },
        {
          "lineno": 176,
          "line": "            CollapseSingleOutput(e.GetSource(0), label, tick, i)"
        },
        {
          "lineno": 177,
          "line": "        },"
        },
        {
          "lineno": 178,
          "line": "        joinEdges"
        },
        {
          "lineno": 179,
          "line": "    )"
        },
        {
          "lineno": 180,
          "line": "}"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "start_line": 169,
          "end_line": 180,
          "label": "func CollapseOutputs<V, G>(\n    joinEdges : Array<Edge<V, G>>, label : Label<V, G>, tick : Int64\n) : Array<InterfacedHypergraph<V, G>>\n    where V <: ValueSymbol<V>, G <: PrimitiveSymbol<V, G>\n{\n    mapi(\n        { e : Edge<V, G>, i : Int64 =>\n            CollapseSingleOutput(e.GetSource(0), label, tick, i)\n        },\n        joinEdges\n    )\n}",
          "successors": []
        }
      ]
    },
    {
      "name": "PerformCycle",
      "type": "function",
      "start_line": 181,
      "end_line": 234,
      "functions": [],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 181,
          "line": "func PerformCycle<V, G>("
        },
        {
          "lineno": 182,
          "line": "    graph : InterfacedHypergraph<V, G>, inputSignals : Array<CycleInput<V>>,"
        },
        {
          "lineno": 183,
          "line": "    signature : Signature<V, G>, coreEdge : Edge<V, G>,"
        },
        {
          "lineno": 184,
          "line": "    numberOfStateWires : Int64, latestInstantVertices : Array<Vertex<V, G>>,"
        },
        {
          "lineno": 185,
          "line": "    latestDelayVertices : Array<Vertex<V, G>>,"
        },
        {
          "lineno": 186,
          "line": "    history : InputOutputHistory<V, G>, debug : Bool, draw!: Bool = false"
        },
        {
          "lineno": 187,
          "line": ") : Unit where V <: ValueSymbol<V>, G <: PrimitiveSymbol<V, G> {"
        },
        {
          "lineno": 188,
          "line": "    // Can only perform a cycle for the right number of inputs"
        },
        {
          "lineno": 189,
          "line": "    AssertHasInputs(graph, inputSignals.size)"
        },
        {
          "lineno": 190,
          "line": "    // Track the elements we will be starting and ending the rewrite later"
        },
        {
          "lineno": 191,
          "line": "    let rewriteStartingElements = HashSet<TraversalElement<V, G>>()"
        },
        {
          "lineno": 192,
          "line": "    let rewriteEndingElements = HashSet<TraversalElement<V, G>>()"
        },
        {
          "lineno": 193,
          "line": "    // Split the state vertices so we can insert the next state"
        },
        {
          "lineno": 194,
          "line": "    let splitJoinVertices = SplitCurrentState("
        },
        {
          "lineno": 195,
          "line": "        coreEdge, numberOfStateWires,"
        },
        {
          "lineno": 196,
          "line": "        rewriteStartingElements, rewriteEndingElements"
        },
        {
          "lineno": 197,
          "line": "    )"
        },
        {
          "lineno": 198,
          "line": "    let currentJoinEdges = CreateOutputJoinEdges("
        },
        {
          "lineno": 199,
          "line": "        graph.GetGraph(), latestDelayVertices, latestInstantVertices,"
        },
        {
          "lineno": 200,
          "line": "        rewriteEndingElements"
        },
        {
          "lineno": 201,
          "line": "    )"
        },
        {
          "lineno": 202,
          "line": "    // The next step is to clone the core so we can attach the current state"
        },
        {
          "lineno": 203,
          "line": "    // and input values to it and reduce appropriately."
        },
        {
          "lineno": 204,
          "line": "    // To do this we need to get or create the vertices that will make up"
        },
        {
          "lineno": 205,
          "line": "    // its inputs and outputs."
        },
        {
          "lineno": 206,
          "line": "    let coreCopyInputs = GetCoreSourceVertices("
        },
        {
          "lineno": 207,
          "line": "        coreEdge, numberOfStateWires, inputSignals, splitJoinVertices,"
        },
        {
          "lineno": 208,
          "line": "        rewriteStartingElements"
        },
        {
          "lineno": 209,
          "line": "    )"
        },
        {
          "lineno": 210,
          "line": "    let coreCopyOutputs = GetCoreTargetVertices("
        },
        {
          "lineno": 211,
          "line": "        coreEdge, numberOfStateWires, splitJoinVertices, latestInstantVertices"
        },
        {
          "lineno": 212,
          "line": "    )"
        },
        {
          "lineno": 213,
          "line": "    // Now we can actually clone the core edge and attach it to the inputs"
        },
        {
          "lineno": 214,
          "line": "    // and outputs we just made"
        },
        {
          "lineno": 215,
          "line": "    let coreCopyEdge = coreEdge.Clone("
        },
        {
          "lineno": 216,
          "line": "        coreCopyInputs, coreCopyOutputs, graph.GetGraph()"
        },
        {
          "lineno": 217,
          "line": "    )"
        },
        {
          "lineno": 218,
          "line": "    // Rewrite the copy of the combinational core. We want to"
        },
        {
          "lineno": 219,
          "line": "    // force blackboxes as much as possible to the right so that each"
        },
        {
          "lineno": 220,
          "line": "    // element of the state is isolated. Moreover, since the core is"
        },
        {
          "lineno": 221,
          "line": "    // guaranteed to be capped off with values, we can safely apply"
        },
        {
          "lineno": 222,
          "line": "    // instantaneous rules"
        },
        {
          "lineno": 223,
          "line": "    RewriteCombinational("
        },
        {
          "lineno": 224,
          "line": "        signature, graph, rewriteStartingElements, rewriteEndingElements,"
        },
        {
          "lineno": 225,
          "line": "        copyBlackBoxes: true, allInstantaneous: true, debug: debug, draw: draw"
        },
        {
          "lineno": 226,
          "line": "    )"
        },
        {
          "lineno": 227,
          "line": "    let outputSubgraphs = CollapseOutputs("
        },
        {
          "lineno": 228,
          "line": "        currentJoinEdges, graph.GetLabel(), history.GetCurrentTick()"
        },
        {
          "lineno": 229,
          "line": "    )"
        },
        {
          "lineno": 230,
          "line": "    // Look at what we've just done and update the input output history"
        },
        {
          "lineno": 231,
          "line": "    UpdateInputOutputHistory("
        },
        {
          "lineno": 232,
          "line": "        graph, inputSignals, outputSubgraphs, history"
        },
        {
          "lineno": 233,
          "line": "    )"
        },
        {
          "lineno": 234,
          "line": "}"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "start_line": 181,
          "end_line": 189,
          "label": "func PerformCycle<V, G>(\n    graph : InterfacedHypergraph<V, G>, inputSignals : Array<CycleInput<V>>,\n    signature : Signature<V, G>, coreEdge : Edge<V, G>,\n    numberOfStateWires : Int64, latestInstantVertices : Array<Vertex<V, G>>,\n    latestDelayVertices : Array<Vertex<V, G>>,\n    history : InputOutputHistory<V, G>, debug : Bool, draw!: Bool = false\n) : Unit where V <: ValueSymbol<V>, G <: PrimitiveSymbol<V, G> {\n    // Can only perform a cycle for the right number of inputs\n    AssertHasInputs(graph, inputSignals.size)",
          "successors": [
            {
              "id": 2,
              "start_line": 190,
              "end_line": 192,
              "label": "// Track the elements we will be starting and ending the rewrite later\n    let rewriteStartingElements = HashSet<TraversalElement<V, G>>()\n    let rewriteEndingElements = HashSet<TraversalElement<V, G>>()",
              "successors": [
                {
                  "id": 3,
                  "start_line": 193,
                  "end_line": 197,
                  "label": "// Split the state vertices so we can insert the next state\n    let splitJoinVertices = SplitCurrentState(\n        coreEdge, numberOfStateWires,\n        rewriteStartingElements, rewriteEndingElements\n    )",
                  "successors": [
                    {
                      "id": 4,
                      "start_line": 198,
                      "end_line": 201,
                      "label": "let currentJoinEdges = CreateOutputJoinEdges(\n        graph.GetGraph(), latestDelayVertices, latestInstantVertices,\n        rewriteEndingElements\n    )",
                      "successors": [
                        {
                          "id": 5,
                          "start_line": 202,
                          "end_line": 209,
                          "label": "// The next step is to clone the core so we can attach the current state\n    // and input values to it and reduce appropriately.\n    // To do this we need to get or create the vertices that will make up\n    // its inputs and outputs.\n    let coreCopyInputs = GetCoreSourceVertices(\n        coreEdge, numberOfStateWires, inputSignals, splitJoinVertices,\n        rewriteStartingElements\n    )",
                          "successors": [
                            {
                              "id": 6,
                              "start_line": 210,
                              "end_line": 212,
                              "label": "let coreCopyOutputs = GetCoreTargetVertices(\n        coreEdge, numberOfStateWires, splitJoinVertices, latestInstantVertices\n    )",
                              "successors": [
                                {
                                  "id": 7,
                                  "start_line": 213,
                                  "end_line": 217,
                                  "label": "// Now we can actually clone the core edge and attach it to the inputs\n    // and outputs we just made\n    let coreCopyEdge = coreEdge.Clone(\n        coreCopyInputs, coreCopyOutputs, graph.GetGraph()\n    )",
                                  "successors": [
                                    {
                                      "id": 8,
                                      "start_line": 218,
                                      "end_line": 226,
                                      "label": "// Rewrite the copy of the combinational core. We want to\n    // force blackboxes as much as possible to the right so that each\n    // element of the state is isolated. Moreover, since the core is\n    // guaranteed to be capped off with values, we can safely apply\n    // instantaneous rules\n    RewriteCombinational(\n        signature, graph, rewriteStartingElements, rewriteEndingElements,\n        copyBlackBoxes: true, allInstantaneous: true, debug: debug, draw: draw\n    )",
                                      "successors": [
                                        {
                                          "id": 9,
                                          "start_line": 227,
                                          "end_line": 229,
                                          "label": "let outputSubgraphs = CollapseOutputs(\n        currentJoinEdges, graph.GetLabel(), history.GetCurrentTick()\n    )",
                                          "successors": [
                                            {
                                              "id": 10,
                                              "start_line": 230,
                                              "end_line": 233,
                                              "label": "// Look at what we've just done and update the input output history\n    UpdateInputOutputHistory(\n        graph, inputSignals, outputSubgraphs, history\n    )",
                                              "successors": []
                                            }
                                          ]
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    }
  ],
  "classes": [
    {
      "name": "Evaluator",
      "type": "class",
      "start_line": 235,
      "end_line": 311,
      "functions": [
        {
          "name": "PerformCycle",
          "type": "function",
          "start_line": 236,
          "end_line": 246,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 236,
              "line": "    public func PerformCycle("
            },
            {
              "lineno": 237,
              "line": "        inputs : Array<CycleInput<V>>, debug!: Bool = false,  draw!: Bool = false"
            },
            {
              "lineno": 238,
              "line": "    ) : Unit {"
            },
            {
              "lineno": 239,
              "line": "        PerformCycle<V, G>("
            },
            {
              "lineno": 240,
              "line": "            this.graph, inputs, this.sig, this.coreEdge,"
            },
            {
              "lineno": 241,
              "line": "            this.numberOfStateWires, this.latestInstantVertices,"
            },
            {
              "lineno": 242,
              "line": "            this.latestDelayVertices, this.history, debug, draw: draw"
            },
            {
              "lineno": 243,
              "line": "        )"
            },
            {
              "lineno": 244,
              "line": "        // We're done!"
            },
            {
              "lineno": 245,
              "line": "        this.currentCycle++"
            },
            {
              "lineno": 246,
              "line": "    }"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 236,
              "end_line": 243,
              "label": "    public func PerformCycle(\n        inputs : Array<CycleInput<V>>, debug!: Bool = false,  draw!: Bool = false\n    ) : Unit {\n        PerformCycle<V, G>(\n            this.graph, inputs, this.sig, this.coreEdge,\n            this.numberOfStateWires, this.latestInstantVertices,\n            this.latestDelayVertices, this.history, debug, draw: draw\n        )",
              "successors": [
                {
                  "id": 2,
                  "start_line": 244,
                  "end_line": 245,
                  "label": "        // We're done!\n        this.currentCycle++",
                  "successors": [
                    {
                      "id": 3,
                      "start_line": 246,
                      "end_line": 246,
                      "label": "    }",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "PerformCycle",
          "type": "function",
          "start_line": 247,
          "end_line": 252,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 247,
              "line": "    public func PerformCycle("
            },
            {
              "lineno": 248,
              "line": "        signals : Array<Signal<V>>, debug!: Bool = false, draw!: Bool = false"
            },
            {
              "lineno": 249,
              "line": "    ) : Unit {"
            },
            {
              "lineno": 250,
              "line": "        let inputs = map({ s : Signal<V> => DEFINITE(s) }, signals)"
            },
            {
              "lineno": 251,
              "line": "        PerformCycle(inputs, debug: debug, draw: draw)"
            },
            {
              "lineno": 252,
              "line": "    }"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 247,
              "end_line": 249,
              "label": "    public func PerformCycle(\n        signals : Array<Signal<V>>, debug!: Bool = false, draw!: Bool = false\n    ) : Unit {",
              "successors": [
                {
                  "id": 2,
                  "start_line": 250,
                  "end_line": 251,
                  "label": "        let inputs = map({ s : Signal<V> => DEFINITE(s) }, signals)\n        PerformCycle(inputs, debug: debug, draw: draw)",
                  "successors": [
                    {
                      "id": 3,
                      "start_line": 252,
                      "end_line": 252,
                      "label": "    }",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "PerformCycle",
          "type": "function",
          "start_line": 253,
          "end_line": 258,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 253,
              "line": "    public func PerformCycle("
            },
            {
              "lineno": 254,
              "line": "        values : Array<V>, debug!: Bool = false, draw!: Bool = false"
            },
            {
              "lineno": 255,
              "line": "    ) : Unit {"
            },
            {
              "lineno": 256,
              "line": "        let inputSignals = map({ v : V => Signal(v) }, values)"
            },
            {
              "lineno": 257,
              "line": "        this.PerformCycle(inputSignals, debug: debug, draw: draw)"
            },
            {
              "lineno": 258,
              "line": "    }"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 253,
              "end_line": 258,
              "label": "public func PerformCycle(\n    values : Array<V>, debug!: Bool = false, draw!: Bool = false\n) : Unit {\n    let inputSignals = map({ v : V => Signal(v) }, values)\n    this.PerformCycle(inputSignals, debug: debug, draw: draw)\n}",
              "successors": []
            }
          ]
        },
        {
          "name": "PerformCycle",
          "type": "function",
          "start_line": 259,
          "end_line": 264,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 259,
              "line": "    public func PerformCycle("
            },
            {
              "lineno": 260,
              "line": "        signal : Signal<V>, debug!: Bool = false, draw!: Bool = false"
            },
            {
              "lineno": 261,
              "line": "    ) : Unit {"
            },
            {
              "lineno": 262,
              "line": "        AssertHasInputs(this.graph, 1)"
            },
            {
              "lineno": 263,
              "line": "        this.PerformCycle([signal], debug: debug, draw: draw)"
            },
            {
              "lineno": 264,
              "line": "    }"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 259,
              "end_line": 263,
              "label": "    public func PerformCycle(\n        signal : Signal<V>, debug!: Bool = false, draw!: Bool = false\n    ) : Unit {\n        AssertHasInputs(this.graph, 1)\n        this.PerformCycle([signal], debug: debug, draw: draw)",
              "successors": [
                {
                  "id": 2,
                  "start_line": 264,
                  "end_line": 264,
                  "label": "    }",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "PerformCycle",
          "type": "function",
          "start_line": 265,
          "end_line": 270,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 265,
              "line": "    public func PerformCycle("
            },
            {
              "lineno": 266,
              "line": "        value : V, debug!: Bool = false, draw!: Bool = false"
            },
            {
              "lineno": 267,
              "line": "    ) : Unit {"
            },
            {
              "lineno": 268,
              "line": "        AssertHasInputs(this.graph, 1)"
            },
            {
              "lineno": 269,
              "line": "        this.PerformCycle(Signal(value), debug: debug, draw: draw)"
            },
            {
              "lineno": 270,
              "line": "    }"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 265,
              "end_line": 267,
              "label": "    public func PerformCycle(\n        value : V, debug!: Bool = false, draw!: Bool = false\n    ) : Unit {",
              "successors": [
                {
                  "id": 2,
                  "start_line": 268,
                  "end_line": 269,
                  "label": "        AssertHasInputs(this.graph, 1)\n        this.PerformCycle(Signal(value), debug: debug, draw: draw)",
                  "successors": [
                    {
                      "id": 3,
                      "start_line": 270,
                      "end_line": 270,
                      "label": "    }",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "PerformCycles",
          "type": "function",
          "start_line": 271,
          "end_line": 277,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 271,
              "line": "    public func PerformCycles("
            },
            {
              "lineno": 272,
              "line": "        signalsPerTick: Array<Array<CycleInput<V>>>, debug!: Bool = false, draw!: Bool = false"
            },
            {
              "lineno": 273,
              "line": "    ) : Unit {"
            },
            {
              "lineno": 274,
              "line": "        for(signals in signalsPerTick) {"
            },
            {
              "lineno": 275,
              "line": "            this.PerformCycle(signals, debug: debug, draw: draw)"
            },
            {
              "lineno": 276,
              "line": "        }"
            },
            {
              "lineno": 277,
              "line": "    }"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 271,
              "end_line": 273,
              "label": "    public func PerformCycles(\n        signalsPerTick: Array<Array<CycleInput<V>>>, debug!: Bool = false, draw!: Bool = false\n    ) : Unit {",
              "successors": [
                {
                  "id": 2,
                  "start_line": 274,
                  "end_line": 276,
                  "label": "        for(signals in signalsPerTick) {\n            this.PerformCycle(signals, debug: debug, draw: draw)\n        }",
                  "successors": [
                    {
                      "id": 3,
                      "start_line": 277,
                      "end_line": 277,
                      "label": "    }",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "PerformCycles",
          "type": "function",
          "start_line": 278,
          "end_line": 283,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 278,
              "line": "    public func PerformCycles("
            },
            {
              "lineno": 279,
              "line": "        valuesPerTick: Array<Array<V>>, debug!: Bool = false, draw!: Bool = false) : Unit {"
            },
            {
              "lineno": 280,
              "line": "        for(values in valuesPerTick) {"
            },
            {
              "lineno": 281,
              "line": "            this.PerformCycle(values, debug: debug, draw: draw)"
            },
            {
              "lineno": 282,
              "line": "        }"
            },
            {
              "lineno": 283,
              "line": "    }"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 278,
              "end_line": 279,
              "label": "    public func PerformCycles(\n        valuesPerTick: Array<Array<V>>, debug!: Bool = false, draw!: Bool = false) : Unit {",
              "successors": [
                {
                  "id": 2,
                  "start_line": 280,
                  "end_line": 282,
                  "label": "        for(values in valuesPerTick) {\n            this.PerformCycle(values, debug: debug, draw: draw)\n        }",
                  "successors": [
                    {
                      "id": 3,
                      "start_line": 283,
                      "end_line": 283,
                      "label": "    }",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "PerformCycles",
          "type": "function",
          "start_line": 284,
          "end_line": 288,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 284,
              "line": "    public func PerformCycles("
            },
            {
              "lineno": 285,
              "line": "        waveforms: Array<Waveform<V>>, debug!: Bool = false, draw!: Bool = false) : Unit {"
            },
            {
              "lineno": 286,
              "line": "        let signalsPerTick = ArrayOfInputsToArrayOfTicks(waveforms)"
            },
            {
              "lineno": 287,
              "line": "        PerformCycles(signalsPerTick, debug: debug, draw: draw)"
            },
            {
              "lineno": 288,
              "line": "    }"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 284,
              "end_line": 288,
              "label": "    public func PerformCycles(\n        waveforms: Array<Waveform<V>>, debug!: Bool = false, draw!: Bool = false) : Unit {\n        let signalsPerTick = ArrayOfInputsToArrayOfTicks(waveforms)\n        PerformCycles(signalsPerTick, debug: debug, draw: draw)\n    }",
              "successors": []
            }
          ]
        },
        {
          "name": "PerformCycles",
          "type": "function",
          "start_line": 289,
          "end_line": 294,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 289,
              "line": "    public func PerformCycles("
            },
            {
              "lineno": 290,
              "line": "        waveform: Waveform<V>, debug!: Bool = false, draw!: Bool = false"
            },
            {
              "lineno": 291,
              "line": "    ) : Unit {"
            },
            {
              "lineno": 292,
              "line": "        AssertHasInputs(this.graph, 1)"
            },
            {
              "lineno": 293,
              "line": "        PerformCycles([waveform], debug: debug, draw: draw)"
            },
            {
              "lineno": 294,
              "line": "    }"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 289,
              "end_line": 294,
              "label": "    public func PerformCycles(\n        waveform: Waveform<V>, debug!: Bool = false, draw!: Bool = false\n    ) : Unit {\n        AssertHasInputs(this.graph, 1)\n        PerformCycles([waveform], debug: debug, draw: draw)\n    }",
              "successors": []
            }
          ]
        },
        {
          "name": "PerformCycles",
          "type": "function",
          "start_line": 295,
          "end_line": 302,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 295,
              "line": "    public func PerformCycles("
            },
            {
              "lineno": 296,
              "line": "        signals: Array<Signal<V>>, ticks!: Int64, debug!: Bool = false, draw!: Bool = false"
            },
            {
              "lineno": 297,
              "line": "    ) : Unit {"
            },
            {
              "lineno": 298,
              "line": "        AssertHasInputs(this.graph, signals.size)"
            },
            {
              "lineno": 299,
              "line": "        for(_ in 0..ticks) {"
            },
            {
              "lineno": 300,
              "line": "            PerformCycle(signals, debug: debug, draw: draw)"
            },
            {
              "lineno": 301,
              "line": "        }"
            },
            {
              "lineno": 302,
              "line": "    }"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 295,
              "end_line": 298,
              "label": "    public func PerformCycles(\n        signals: Array<Signal<V>>, ticks!: Int64, debug!: Bool = false, draw!: Bool = false\n    ) : Unit {\n        AssertHasInputs(this.graph, signals.size)",
              "successors": [
                {
                  "id": 2,
                  "start_line": 299,
                  "end_line": 301,
                  "label": "        for(_ in 0..ticks) {\n            PerformCycle(signals, debug: debug, draw: draw)\n        }",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "PerformCycles",
          "type": "function",
          "start_line": 303,
          "end_line": 310,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 303,
              "line": "    public func PerformCycles("
            },
            {
              "lineno": 304,
              "line": "        values: Array<V>, ticks!: Int64, debug!: Bool = false, draw!: Bool = false"
            },
            {
              "lineno": 305,
              "line": "    ) : Unit {"
            },
            {
              "lineno": 306,
              "line": "        AssertHasInputs(this.graph, values.size)"
            },
            {
              "lineno": 307,
              "line": "        for(_ in 0..ticks) {"
            },
            {
              "lineno": 308,
              "line": "            PerformCycle(values, debug: debug, draw: draw)"
            },
            {
              "lineno": 309,
              "line": "        }"
            },
            {
              "lineno": 310,
              "line": "    }"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 303,
              "end_line": 306,
              "label": "public func PerformCycles(\n    values: Array<V>, ticks!: Int64, debug!: Bool = false, draw!: Bool = false\n) : Unit {\n    AssertHasInputs(this.graph, values.size)",
              "successors": [
                {
                  "id": 2,
                  "start_line": 307,
                  "end_line": 309,
                  "label": "for(_ in 0..ticks) {\n    PerformCycle(values, debug: debug, draw: draw)\n}",
                  "successors": [
                    {
                      "id": 3,
                      "start_line": 310,
                      "end_line": 310,
                      "label": "}",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 235,
          "line": "extend Evaluator<V, G> {"
        },
        {
          "lineno": 311,
          "line": "}"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "start_line": 235,
          "end_line": 235,
          "label": "extend Evaluator<V, G> {",
          "successors": [
            {
              "id": 2,
              "start_line": 311,
              "end_line": 311,
              "label": "}",
              "successors": []
            }
          ]
        }
      ]
    },
    {
      "name": "EvaluatorDecimal",
      "type": "class",
      "start_line": 312,
      "end_line": 350,
      "functions": [
        {
          "name": "PerformCycle",
          "type": "function",
          "start_line": 313,
          "end_line": 326,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 313,
              "line": "    public func PerformCycle("
            },
            {
              "lineno": 314,
              "line": "        inputs : Array<Int64>, signed!: Bool, debug!: Bool = false, draw!: Bool = false"
            },
            {
              "lineno": 315,
              "line": "    ) : Unit {"
            },
            {
              "lineno": 316,
              "line": "        AssertHasInputs(this.graph, inputs.size)"
            },
            {
              "lineno": 317,
              "line": "        let inputSignals = mapi("
            },
            {
              "lineno": 318,
              "line": "            { v : Int64, i : Int64 =>"
            },
            {
              "lineno": 319,
              "line": "                V.DecToSignal("
            },
            {
              "lineno": 320,
              "line": "                    v, width: this.graph.GetInput(i).GetWidth(), signed: signed"
            },
            {
              "lineno": 321,
              "line": "                )"
            },
            {
              "lineno": 322,
              "line": "            },"
            },
            {
              "lineno": 323,
              "line": "            inputs"
            },
            {
              "lineno": 324,
              "line": "        )"
            },
            {
              "lineno": 325,
              "line": "        this.PerformCycle(inputSignals, debug: debug, draw: draw)"
            },
            {
              "lineno": 326,
              "line": "    }"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 313,
              "end_line": 326,
              "label": "    public func PerformCycle(\n        inputs : Array<Int64>, signed!: Bool, debug!: Bool = false, draw!: Bool = false\n    ) : Unit {\n        AssertHasInputs(this.graph, inputs.size)\n        let inputSignals = mapi(\n            { v : Int64, i : Int64 =>\n                V.DecToSignal(\n                    v, width: this.graph.GetInput(i).GetWidth(), signed: signed\n                )\n            },\n            inputs\n        )\n        this.PerformCycle(inputSignals, debug: debug, draw: draw)\n    }",
              "successors": []
            }
          ]
        },
        {
          "name": "PerformCycle",
          "type": "function",
          "start_line": 327,
          "end_line": 332,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 327,
              "line": "    public func PerformCycle("
            },
            {
              "lineno": 328,
              "line": "        input: Int64, signed!: Bool, debug!: Bool = false, draw!: Bool = false"
            },
            {
              "lineno": 329,
              "line": "    ) : Unit {"
            },
            {
              "lineno": 330,
              "line": "        AssertHasInputs(this.graph, 1)"
            },
            {
              "lineno": 331,
              "line": "        this.PerformCycle([input], signed: signed, debug: debug, draw: draw)"
            },
            {
              "lineno": 332,
              "line": "    }"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 327,
              "end_line": 332,
              "label": "    public func PerformCycle(\n        input: Int64, signed!: Bool, debug!: Bool = false, draw!: Bool = false\n    ) : Unit {\n        AssertHasInputs(this.graph, 1)\n        this.PerformCycle([input], signed: signed, debug: debug, draw: draw)\n    }",
              "successors": []
            }
          ]
        },
        {
          "name": "PerformCycles",
          "type": "function",
          "start_line": 333,
          "end_line": 341,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 333,
              "line": "    public func PerformCycles("
            },
            {
              "lineno": 334,
              "line": "        inputs : Array<Int64>, signed!: Bool, ticks!: Int64,"
            },
            {
              "lineno": 335,
              "line": "        debug!: Bool = false, draw!: Bool = false"
            },
            {
              "lineno": 336,
              "line": "    ) : Unit {"
            },
            {
              "lineno": 337,
              "line": "        AssertHasInputs(this.graph, inputs.size)"
            },
            {
              "lineno": 338,
              "line": "        for(_ in 0..ticks) {"
            },
            {
              "lineno": 339,
              "line": "            PerformCycle(inputs, signed: signed, debug: debug, draw: draw)"
            },
            {
              "lineno": 340,
              "line": "        }"
            },
            {
              "lineno": 341,
              "line": "    }"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 333,
              "end_line": 337,
              "label": "    public func PerformCycles(\n        inputs : Array<Int64>, signed!: Bool, ticks!: Int64,\n        debug!: Bool = false, draw!: Bool = false\n    ) : Unit {\n        AssertHasInputs(this.graph, inputs.size)",
              "successors": [
                {
                  "id": 2,
                  "start_line": 338,
                  "end_line": 340,
                  "label": "        for(_ in 0..ticks) {\n            PerformCycle(inputs, signed: signed, debug: debug, draw: draw)\n        }",
                  "successors": [
                    {
                      "id": 3,
                      "start_line": 341,
                      "end_line": 341,
                      "label": "    }",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "PerformCycles",
          "type": "function",
          "start_line": 342,
          "end_line": 350,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 342,
              "line": "    public func PerformCycles("
            },
            {
              "lineno": 343,
              "line": "        input : Int64, signed!: Bool, ticks!: Int64, debug!: Bool = false, draw!: Bool = false"
            },
            {
              "lineno": 344,
              "line": "    ) : Unit {"
            },
            {
              "lineno": 345,
              "line": "        AssertHasInputs(this.graph, 1)"
            },
            {
              "lineno": 346,
              "line": "        for(_ in 0..ticks) {"
            },
            {
              "lineno": 347,
              "line": "            PerformCycle(input, signed: signed, debug: debug, draw: draw)"
            },
            {
              "lineno": 348,
              "line": "        }"
            },
            {
              "lineno": 349,
              "line": "    }"
            },
            {
              "lineno": 350,
              "line": "}"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "start_line": 342,
              "end_line": 345,
              "label": "    public func PerformCycles(\n        input : Int64, signed!: Bool, ticks!: Int64, debug!: Bool = false, draw!: Bool = false\n    ) : Unit {\n        AssertHasInputs(this.graph, 1)",
              "successors": [
                {
                  "id": 2,
                  "start_line": 346,
                  "end_line": 348,
                  "label": "        for(_ in 0..ticks) {\n            PerformCycle(input, signed: signed, debug: debug, draw: draw)\n        }",
                  "successors": []
                },
                {
                  "id": 3,
                  "start_line": 349,
                  "end_line": 349,
                  "label": "    }",
                  "successors": []
                },
                {
                  "id": 4,
                  "start_line": 350,
                  "end_line": 350,
                  "label": "}",
                  "successors": []
                }
              ]
            }
          ]
        }
      ],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 312,
          "line": "extend Evaluator<V, G> where V <: Decimal<V> {"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "start_line": 312,
          "end_line": 312,
          "label": "extend Evaluator<V, G> where V <: Decimal<V> {",
          "successors": []
        }
      ]
    }
  ],
  "simplified_code": [
    {
      "lineno": 1,
      "line": "package rewrite"
    }
  ],
  "blocks": []
}