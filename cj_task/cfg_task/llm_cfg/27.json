{
  "name": "example_script",
  "type": "CFG",
  "start_line": 1,
  "end_line": 672,
  "functions": [
    {
      "name": "isSeparator",
      "type": "function",
      "start_line": 74,
      "end_line": 76,
      "functions": [],
      "classes": [],
      "simplified_code": "func isSeparator(c: Rune): Bool {\n    return c.isAscii() && (c == r'/' || c == r'\\\\')\n}",
      "blocks": [
        {
          "id": 1,
          "label": "func isSeparator(c: Rune): Bool {",
          "successors": [
            {
              "id": 2,
              "label": "    return c.isAscii() && (c == r'/' || c == r'\\\\')",
              "successors": []
            }
          ]
        }
      ]
    },
    {
      "name": "parseCharSpecifiers",
      "type": "function",
      "start_line": 78,
      "end_line": 91,
      "functions": [],
      "classes": [],
      "simplified_code": "func parseCharSpecifiers(s: Array<Rune>): Array<CharSpecifier> {\n    let ret = ArrayList<CharSpecifier>()\n    var i = 0\n    while (i < s.size) {\n        if (i + 3 <= s.size && s[i + 1] == r'-') {\n            ret.append(CharSpecifier.CharRange(s[i], s[i + 2]))\n            i += 3\n        } else {\n            ret.append(CharSpecifier.SingleChar(s[i]))\n            i += 1\n        }\n    }\n    return ret.toArray()\n}",
      "blocks": [
        {
          "id": 1,
          "label": "func parseCharSpecifiers(s: Array<Rune>): Array<CharSpecifier> {",
          "successors": [
            {
              "id": 2,
              "label": "let ret = ArrayList<CharSpecifier>()\nvar i = 0",
              "successors": [
                {
                  "id": 3,
                  "label": "while (i < s.size) {",
                  "successors": [
                    {
                      "id": 4,
                      "label": "if (i + 3 <= s.size && s[i + 1] == r'-') {",
                      "successors": [
                        {
                          "id": 5,
                          "label": "ret.append(CharSpecifier.CharRange(s[i], s[i + 2]))\ni += 3",
                          "successors": [
                            {
                              "id": 3,
                              "label": "while (i < s.size) {",
                              "successors": []
                            }
                          ]
                        },
                        {
                          "id": 6,
                          "label": "ret.append(CharSpecifier.SingleChar(s[i]))\ni += 1",
                          "successors": [
                            {
                              "id": 3,
                              "label": "while (i < s.size) {",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "id": 7,
                  "label": "return ret.toArray()",
                  "successors": []
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "charsEq",
      "type": "function",
      "start_line": 117,
      "end_line": 123,
      "functions": [],
      "classes": [],
      "simplified_code": "func charsEq(a: Rune, b: Rune, caseSensitive: Bool): Bool {\n    if (!caseSensitive && a.isAscii() && b.isAscii()) {\n        a.toAsciiLowerCase() == b.toAsciiLowerCase()\n    } else {\n        a == b\n    }\n}",
      "blocks": [
        {
          "id": 1,
          "label": "func charsEq(a: Rune, b: Rune, caseSensitive: Bool): Bool",
          "successors": [
            {
              "id": 2,
              "label": "if (!caseSensitive && a.isAscii() && b.isAscii())",
              "successors": [
                {
                  "id": 3,
                  "label": "a.toAsciiLowerCase() == b.toAsciiLowerCase()",
                  "successors": []
                },
                {
                  "id": 4,
                  "label": "a == b",
                  "successors": []
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "inCharSpecifiers",
      "type": "function",
      "start_line": 126,
      "end_line": 159,
      "functions": [],
      "classes": [],
      "simplified_code": "func inCharSpecifiers(cs: Array<CharSpecifier>, c: Rune, options: MatchOptions): Bool {\n    for (spec in cs) {\n        match (spec) {\n            case CharSpecifier.SingleChar(cs) =>\n                if (charsEq(c, cs, options.caseSensitive)) {\n                    return true\n                } else {\n                    continue\n                }\n\n            case CharSpecifier.CharRange(start, end) =>\n                if (!options.caseSensitive && c.isAscii() && start.isAscii() && end.isAscii()) {\n                    let sl = start.toAsciiLowerCase()\n                    let el = end.toAsciiLowerCase()\n\n                    let su = sl.toAsciiUpperCase()\n                    let eu = el.toAsciiUpperCase()\n\n                    if (sl != su && el != eu) {\n                        let cl = c.toAsciiLowerCase()\n                        if (cl >= sl && cl <= el) {\n                            return true;\n                        }\n                    }\n                }\n\n                if (c >= start && c <= end) {\n                    return true\n                }\n        }\n    }\n\n    return false\n}",
      "blocks": [
        {
          "id": 1,
          "label": "func inCharSpecifiers(cs: Array<CharSpecifier>, c: Rune, options: MatchOptions): Bool {",
          "successors": [
            {
              "id": 2,
              "label": "for (spec in cs) {",
              "successors": [
                {
                  "id": 3,
                  "label": "match (spec) {",
                  "successors": [
                    {
                      "id": 4,
                      "label": "case CharSpecifier.SingleChar(cs) =>",
                      "successors": [
                        {
                          "id": 5,
                          "label": "if (charsEq(c, cs, options.caseSensitive)) {",
                          "successors": [
                            {
                              "id": 6,
                              "label": "return true",
                              "successors": []
                            }
                          ]
                        },
                        {
                          "id": 7,
                          "label": "else {",
                          "successors": [
                            {
                              "id": 8,
                              "label": "continue",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "id": 9,
                      "label": "case CharSpecifier.CharRange(start, end) =>",
                      "successors": [
                        {
                          "id": 10,
                          "label": "if (!options.caseSensitive && c.isAscii() && start.isAscii() && end.isAscii()) {",
                          "successors": [
                            {
                              "id": 11,
                              "label": "let sl = start.toAsciiLowerCase()",
                              "successors": []
                            },
                            {
                              "id": 12,
                              "label": "let el = end.toAsciiLowerCase()",
                              "successors": []
                            },
                            {
                              "id": 13,
                              "label": "let su = sl.toAsciiUpperCase()",
                              "successors": []
                            },
                            {
                              "id": 14,
                              "label": "let eu = el.toAsciiUpperCase()",
                              "successors": []
                            },
                            {
                              "id": 15,
                              "label": "if (sl != su && el != eu) {",
                              "successors": [
                                {
                                  "id": 16,
                                  "label": "let cl = c.toAsciiLowerCase()",
                                  "successors": []
                                },
                                {
                                  "id": 17,
                                  "label": "if (cl >= sl && cl <= el) {",
                                  "successors": [
                                    {
                                      "id": 18,
                                      "label": "return true",
                                      "successors": []
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        },
                        {
                          "id": 19,
                          "label": "if (c >= start && c <= end) {",
                          "successors": [
                            {
                              "id": 20,
                              "label": "return true",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "id": 21,
              "label": "return false",
              "successors": []
            }
          ]
        }
      ]
    },
    {
      "name": "checkWindowsVerbatim",
      "type": "function",
      "start_line": 349,
      "end_line": 370,
      "functions": [],
      "classes": [],
      "simplified_code": "func checkWindowsVerbatim(path: String): Bool {\n    if (path.size < 4) {\n        return false\n    }\n    let chars = path.toRuneArray()\n\n    let c0 = chars[0]\n    let c1 = chars[1]\n    let c2 = chars[2]\n    let c3 = chars[3]\n\n    // \\\\.\\\n    if (c0 == r'\\\\' && c1 == r'\\\\' && c2 == r'.' && c3 == r'\\\\') {\n        return true\n    }\n    // \\\\?\\\n    if (c0 == r'\\\\' && c1 == r'\\\\' && c2 == r'?' && c3 == r'\\\\') {\n        return true\n    }\n\n    return false\n}",
      "blocks": [
        {
          "id": 1,
          "label": "func checkWindowsVerbatim(path: String): Bool {",
          "successors": [
            {
              "id": 2,
              "label": "if (path.size < 4) {",
              "successors": [
                {
                  "id": 3,
                  "label": "return false",
                  "successors": []
                }
              ]
            },
            {
              "id": 4,
              "label": "let chars = path.toRuneArray()",
              "successors": [
                {
                  "id": 5,
                  "label": "let c0 = chars[0]",
                  "successors": [
                    {
                      "id": 6,
                      "label": "let c1 = chars[1]",
                      "successors": [
                        {
                          "id": 7,
                          "label": "let c2 = chars[2]",
                          "successors": [
                            {
                              "id": 8,
                              "label": "let c3 = chars[3]",
                              "successors": [
                                {
                                  "id": 9,
                                  "label": "if (c0 == r'\\\\' && c1 == r'\\\\' && c2 == r'.' && c3 == r'\\\\') {",
                                  "successors": [
                                    {
                                      "id": 10,
                                      "label": "return true",
                                      "successors": []
                                    }
                                  ]
                                },
                                {
                                  "id": 11,
                                  "label": "if (c0 == r'\\\\' && c1 == r'\\\\' && c2 == r'?' && c3 == r'\\\\') {",
                                  "successors": [
                                    {
                                      "id": 12,
                                      "label": "return true",
                                      "successors": []
                                    }
                                  ]
                                },
                                {
                                  "id": 13,
                                  "label": "return false",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "fillTodo",
      "type": "function",
      "start_line": 387,
      "end_line": 467,
      "functions": [],
      "classes": [],
      "simplified_code": "func fillTodo(\n    todo: ArrayList<(PathWrapper, Int64)>,\n    patterns: Array<Pattern>,\n    idx: Int,\n    path: PathWrapper,\n    options: MatchOptions\n): Unit {\n    let pattern = patterns[idx]\n    let isDir = path.isDirectory\n    let curDir = path.path.toString() == \".\"\n\n    let add = {\n        todo: ArrayList<(PathWrapper, Int64)>, nextPath: PathWrapper => if (idx + 1 == patterns.size) {\n            todo.append((nextPath, Int64.Max))\n        } else {\n            fillTodo(todo, patterns, idx + 1, nextPath, options)\n        }\n    }\n\n    match (pattern.toCharString()) {\n        case Some(s) =>\n            let special = s == \".\" || s == \"..\"\n            let nextPath = if (curDir) {\n                Path(s)\n            } else {\n                path.path.join(s)\n            }\n            let nextPathWrapper: PathWrapper\n            try {\n                nextPathWrapper = PathWrapper(nextPath)\n            } catch (e: FSException) {\n                return\n            }\n            if ((special && isDir) || !special) {\n                add(todo, nextPathWrapper)\n            }\n        case None =>\n            if (isDir) {\n                let dirFiles = Directory.readFrom(path.path)\n                let dirs = ArrayList<PathWrapper>()\n                for (e in dirFiles) {\n                    if (curDir) {\n                        dirs.append(PathWrapper(Path(e.path.fileName), e.isDirectory()))\n                    } else {\n                        dirs.append(PathWrapper(e.path, e.isDirectory()))\n                    }\n                }\n                var children = dirs.iterator()\n                if (options.requireLiteralLeadingDot) {\n                    children = children.filter {\n                        c => !(c.path.fileName.startsWith(\".\"))\n                    }\n                }\n                let cc = ArrayList<PathWrapper>()\n                for (c in children) {\n                    cc.append(c)\n                }\n                cc.sortBy {\n                    l: PathWrapper, r: PathWrapper => if (l.path.fileName > r.path.fileName) {\n                        Ordering.GT\n                    } else if (l.path.fileName < r.path.fileName) {\n                        Ordering.LT\n                    } else {\n                        Ordering.EQ\n                    }\n                }\n\n                for (c in cc) {\n                    todo.append((c, idx))\n                }\n\n                if (!pattern.tokens.isEmpty() && pattern.tokens[0] == PatternToken.Char(r'.')) {\n                    for (sp in [\".\", \"..\"]) {\n                        if (pattern.matchesWith(sp, options)) {\n                            add(todo, PathWrapper(path.path.join(sp)))\n                        }\n                    }\n                }\n            }\n    }\n}",
      "blocks": [
        {
          "id": 1,
          "label": "let pattern = patterns[idx]",
          "successors": [
            {
              "id": 2,
              "label": "let isDir = path.isDirectory",
              "successors": [
                {
                  "id": 3,
                  "label": "let curDir = path.path.toString() == \".\"",
                  "successors": [
                    {
                      "id": 4,
                      "label": "let add = { todo: ArrayList<(PathWrapper, Int64)>, nextPath: PathWrapper => if (idx + 1 == patterns.size) { todo.append((nextPath, Int64.Max)) } else { fillTodo(todo, patterns, idx + 1, nextPath, options) } }",
                      "successors": [
                        {
                          "id": 5,
                          "label": "match (pattern.toCharString())",
                          "successors": [
                            {
                              "id": 6,
                              "label": "case Some(s) =>",
                              "successors": [
                                {
                                  "id": 7,
                                  "label": "let special = s == \".\" || s == \"..\"",
                                  "successors": [
                                    {
                                      "id": 8,
                                      "label": "let nextPath = if (curDir) { Path(s) } else { path.path.join(s) }",
                                      "successors": [
                                        {
                                          "id": 9,
                                          "label": "let nextPathWrapper: PathWrapper",
                                          "successors": [
                                            {
                                              "id": 10,
                                              "label": "try",
                                              "successors": [
                                                {
                                                  "id": 11,
                                                  "label": "nextPathWrapper = PathWrapper(nextPath)",
                                                  "successors": [
                                                    {
                                                      "id": 12,
                                                      "label": "if ((special && isDir) || !special) { add(todo, nextPathWrapper) }",
                                                      "successors": []
                                                    }
                                                  ]
                                                },
                                                {
                                                  "id": 13,
                                                  "label": "catch (e: FSException)",
                                                  "successors": [
                                                    {
                                                      "id": 14,
                                                      "label": "return",
                                                      "successors": []
                                                    }
                                                  ]
                                                }
                                              ]
                                            }
                                          ]
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            },
                            {
                              "id": 15,
                              "label": "case None =>",
                              "successors": [
                                {
                                  "id": 16,
                                  "label": "if (isDir) { let dirFiles = Directory.readFrom(path.path) let dirs = ArrayList<PathWrapper>() for (e in dirFiles) { if (curDir) { dirs.append(PathWrapper(Path(e.path.fileName), e.isDirectory())) } else { dirs.append(PathWrapper(e.path, e.isDirectory())) } } var children = dirs.iterator() if (options.requireLiteralLeadingDot) { children = children.filter { c => !(c.path.fileName.startsWith(\".\")) } } let cc = ArrayList<PathWrapper>() for (c in children) { cc.append(c) } cc.sortBy { l: PathWrapper, r: PathWrapper => if (l.path.fileName > r.path.fileName) { Ordering.GT } else if (l.path.fileName < r.path.fileName) { Ordering.LT } else { Ordering.EQ } } for (c in cc) { todo.append((c, idx)) } if (!pattern.tokens.isEmpty() && pattern.tokens[0] == PatternToken.Char(r'.')) { for (sp in [\".\", \"..\"]) { if (pattern.matchesWith(sp, options)) { add(todo, PathWrapper(path.path.join(sp))) } } } }",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "getRoot",
      "type": "function",
      "start_line": 562,
      "end_line": 580,
      "functions": [],
      "classes": [],
      "simplified_code": "func getRoot(pattern: String): Option<String> {\n    let chars = pattern.toRuneArray()\n\n    if (chars.size == 0) {\n        return \"\"\n    }\n\n    if (chars[0] == r'/') {\n        return \"/\"\n    }\n\n    if (chars.size >= 2) {\n        if (chars[0].isAsciiLetter() && chars[1] == r':') {\n            return pattern[0..2] + \"\\\\\"\n        }\n    }\n\n    None\n}",
      "blocks": [
        {
          "id": 1,
          "label": "func getRoot(pattern: String): Option<String> {",
          "successors": [
            {
              "id": 2,
              "label": "let chars = pattern.toRuneArray()",
              "successors": [
                {
                  "id": 3,
                  "label": "if (chars.size == 0) {",
                  "successors": [
                    {
                      "id": 4,
                      "label": "return \"\"",
                      "successors": []
                    }
                  ]
                },
                {
                  "id": 5,
                  "label": "if (chars[0] == r'/') {",
                  "successors": [
                    {
                      "id": 6,
                      "label": "return \"/\"",
                      "successors": []
                    }
                  ]
                },
                {
                  "id": 7,
                  "label": "if (chars.size >= 2) {",
                  "successors": [
                    {
                      "id": 8,
                      "label": "if (chars[0].isAsciiLetter() && chars[1] == r':') {",
                      "successors": [
                        {
                          "id": 9,
                          "label": "return pattern[0..2] + \"\\\\\"",
                          "successors": []
                        }
                      ]
                    }
                  ]
                },
                {
                  "id": 10,
                  "label": "None",
                  "successors": []
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "glob",
      "type": "function",
      "start_line": 612,
      "end_line": 614,
      "functions": [],
      "classes": [],
      "simplified_code": "public func glob(pattern: String): Paths {\n    globWith(pattern, MatchOptions())\n}",
      "blocks": [
        {
          "id": 1,
          "label": "public func glob(pattern: String): Paths {",
          "successors": [
            {
              "id": 2,
              "label": "    globWith(pattern, MatchOptions())",
              "successors": []
            }
          ]
        }
      ]
    },
    {
      "name": "globWith",
      "type": "function",
      "start_line": 622,
      "end_line": 670,
      "functions": [],
      "classes": [],
      "simplified_code": "public func globWith(pattern: String, options: MatchOptions): Paths {\n    let _ = Pattern(pattern)\n\n    if (checkWindowsVerbatim(pattern)) {\n        throw PatternException(0, \"verbatim paths are not supported\")\n    }\n\n    var root: String\n    var foundRoot = false\n\n    match (getRoot(pattern)) {\n        case Some(r) =>\n            root = r\n            foundRoot = true\n        case None =>\n            root = \".\"\n            foundRoot = false\n    }\n\n    let dirPatterns = ArrayList<Pattern>()\n    let skip = if (foundRoot) {\n        root.size\n    } else {\n        0\n    }\n    let components = pattern[(min(skip, pattern.size))..].split(isSeparator)\n    for (c in components) {\n        dirPatterns.append(Pattern(c))\n    }\n\n    if (foundRoot && root.size == pattern.size) {\n        dirPatterns.append(Pattern(\"\"))\n    }\n\n    let lastIsSeparator = if (pattern.size > 0) {\n        let ra = pattern.toRuneArray()\n        isSeparator(ra[ra.size - 1])\n    } else {\n        false\n    }\n\n    return Paths(\n        dirPatterns.toArray(),\n        lastIsSeparator,\n        options,\n        ArrayList<(PathWrapper, Int64)>(),\n        PathWrapper(Path(root))\n    )\n}",
      "blocks": [
        {
          "id": 1,
          "label": "public func globWith(pattern: String, options: MatchOptions): Paths {",
          "successors": [
            {
              "id": 2,
              "label": "    let _ = Pattern(pattern)",
              "successors": [
                {
                  "id": 3,
                  "label": "if (checkWindowsVerbatim(pattern)) {",
                  "successors": [
                    {
                      "id": 4,
                      "label": "    throw PatternException(0, \"verbatim paths are not supported\")",
                      "successors": []
                    }
                  ]
                },
                {
                  "id": 5,
                  "label": "var root: String\nvar foundRoot = false",
                  "successors": [
                    {
                      "id": 6,
                      "label": "match (getRoot(pattern)) {",
                      "successors": [
                        {
                          "id": 7,
                          "label": "    case Some(r) =>\n        root = r\n        foundRoot = true",
                          "successors": [
                            {
                              "id": 9,
                              "label": "let dirPatterns = ArrayList<Pattern>()",
                              "successors": [
                                {
                                  "id": 11,
                                  "label": "let skip = if (foundRoot) {\n    root.size\n} else {\n    0\n}",
                                  "successors": [
                                    {
                                      "id": 12,
                                      "label": "let components = pattern[(min(skip, pattern.size))..].split(isSeparator)",
                                      "successors": [
                                        {
                                          "id": 13,
                                          "label": "for (c in components) {\n    dirPatterns.append(Pattern(c))\n}",
                                          "successors": [
                                            {
                                              "id": 14,
                                              "label": "if (foundRoot && root.size == pattern.size) {\n    dirPatterns.append(Pattern(\"\"))\n}",
                                              "successors": [
                                                {
                                                  "id": 15,
                                                  "label": "let lastIsSeparator = if (pattern.size > 0) {\n    let ra = pattern.toRuneArray()\n    isSeparator(ra[ra.size - 1])\n} else {\n    false\n}",
                                                  "successors": [
                                                    {
                                                      "id": 16,
                                                      "label": "return Paths(\n    dirPatterns.toArray(),\n    lastIsSeparator,\n    options,\n    ArrayList<(PathWrapper, Int64)>(),\n    PathWrapper(Path(root))\n)",
                                                      "successors": []
                                                    }
                                                  ]
                                                }
                                              ]
                                            }
                                          ]
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        },
                        {
                          "id": 8,
                          "label": "    case None =>\n        root = \".\"\n        foundRoot = false",
                          "successors": [
                            {
                              "id": 9,
                              "label": "let dirPatterns = ArrayList<Pattern>()",
                              "successors": [
                                {
                                  "id": 11,
                                  "label": "let skip = if (foundRoot) {\n    root.size\n} else {\n    0\n}",
                                  "successors": [
                                    {
                                      "id": 12,
                                      "label": "let components = pattern[(min(skip, pattern.size))..].split(isSeparator)",
                                      "successors": [
                                        {
                                          "id": 13,
                                          "label": "for (c in components) {\n    dirPatterns.append(Pattern(c))\n}",
                                          "successors": [
                                            {
                                              "id": 14,
                                              "label": "if (foundRoot && root.size == pattern.size) {\n    dirPatterns.append(Pattern(\"\"))\n}",
                                              "successors": [
                                                {
                                                  "id": 15,
                                                  "label": "let lastIsSeparator = if (pattern.size > 0) {\n    let ra = pattern.toRuneArray()\n    isSeparator(ra[ra.size - 1])\n} else {\n    false\n}",
                                                  "successors": [
                                                    {
                                                      "id": 16,
                                                      "label": "return Paths(\n    dirPatterns.toArray(),\n    lastIsSeparator,\n    options,\n    ArrayList<(PathWrapper, Int64)>(),\n    PathWrapper(Path(root))\n)",
                                                      "successors": []
                                                    }
                                                  ]
                                                }
                                              ]
                                            }
                                          ]
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    }
  ],
  "classes": [
    {
      "name": "PatternException",
      "type": "class",
      "start_line": 61,
      "end_line": 72,
      "functions": [
        {
          "name": "getClassName",
          "type": "function",
          "start_line": 69,
          "end_line": 71,
          "functions": [],
          "classes": [],
          "simplified_code": "    public override func getClassName(): String {\n        \"PatternException\"\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "public override func getClassName(): String {",
              "successors": [
                {
                  "id": 2,
                  "label": "\"PatternException\"",
                  "successors": []
                }
              ]
            }
          ]
        }
      ],
      "classes": [],
      "simplified_code": "public class PatternException <: Exception {\n    public let pos: Int\n\n    public init(pos: Int, message: String) {\n        super(message)\n        this.pos = pos\n    }\n\n    }\n}",
      "blocks": [
        {
          "id": 1,
          "label": "public class PatternException <: Exception {",
          "successors": [
            {
              "id": 2,
              "label": "    public let pos: Int",
              "successors": [
                {
                  "id": 3,
                  "label": "    public init(pos: Int, message: String) {",
                  "successors": [
                    {
                      "id": 4,
                      "label": "        super(message)",
                      "successors": []
                    },
                    {
                      "id": 5,
                      "label": "        this.pos = pos",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "CharsIterator",
      "type": "class",
      "start_line": 93,
      "end_line": 115,
      "functions": [
        {
          "name": "clone",
          "type": "function",
          "start_line": 102,
          "end_line": 104,
          "functions": [],
          "classes": [],
          "simplified_code": "    public func clone(): CharsIterator {\n        return CharsIterator(this.chars, i: this.i)\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "public func clone(): CharsIterator {",
              "successors": [
                {
                  "id": 2,
                  "label": "    return CharsIterator(this.chars, i: this.i)",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "next",
          "type": "function",
          "start_line": 106,
          "end_line": 114,
          "functions": [],
          "classes": [],
          "simplified_code": "    public func next(): Option<Rune> {\n        if (this.i < this.chars.size) {\n            let c = this.chars[this.i]\n            this.i++\n            return Some(c)\n        } else {\n            return None\n        }\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "public func next(): Option<Rune> {",
              "successors": [
                {
                  "id": 2,
                  "label": "if (this.i < this.chars.size) {",
                  "successors": [
                    {
                      "id": 3,
                      "label": "let c = this.chars[this.i]\nthis.i++\nreturn Some(c)",
                      "successors": []
                    },
                    {
                      "id": 4,
                      "label": "} else {",
                      "successors": [
                        {
                          "id": 5,
                          "label": "return None",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "classes": [],
      "simplified_code": "public class CharsIterator <: Iterator<Rune> {\n    let chars: Array<Rune>\n    var i: Int\n\n    init(c: Array<Rune>, i!: Int = 0) {\n        this.chars = c\n        this.i = i\n    }\n\n    }\n\n    }\n}",
      "blocks": [
        {
          "id": 1,
          "label": "public class CharsIterator <: Iterator<Rune> {",
          "successors": [
            {
              "id": 2,
              "label": "let chars: Array<Rune>\nvar i: Int",
              "successors": [
                {
                  "id": 3,
                  "label": "init(c: Array<Rune>, i!: Int = 0) {",
                  "successors": [
                    {
                      "id": 4,
                      "label": "this.chars = c\nthis.i = i",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "Pattern",
      "type": "class",
      "start_line": 161,
      "end_line": 347,
      "functions": [
        {
          "name": "init",
          "type": "function",
          "start_line": 166,
          "end_line": 246,
          "functions": [],
          "classes": [],
          "simplified_code": "    init(pattern: String) {\n        let chars = pattern.toRuneArray()\n        let tokens = ArrayList<PatternToken>()\n        var is_recursive = false\n        var i = 0\n\n        while (i < chars.size) {\n            match (chars[i]) {\n                case r'?' =>\n                    tokens.append(PatternToken.AnyChar)\n                    i++\n                case r'*' =>\n                    let old = i\n\n                    while (i < chars.size && chars[i] == r'*') {\n                        i++\n                    }\n\n                    let count = i - old\n\n                    if (count > 2) {\n                        throw PatternException(old + 2, ERROR_WILDCARDS)\n                    } else if (count == 2) {\n                        let is_valid = if (i == 2 || isSeparator(chars[i - count - 1])) {\n                            if (i < chars.size && isSeparator(chars[i])) {\n                                i++\n                                true\n                            } else if (i == chars.size) {\n                                true\n                            } else {\n                                throw PatternException(i, ERROR_RECURSIVE_WILDCARDS)\n                            }\n                        } else {\n                            throw PatternException(old - 1, ERROR_RECURSIVE_WILDCARDS)\n                        }\n\n                        if (is_valid) {\n                            let tokens_len = tokens.size\n\n                            if (!(tokens_len > 1 && tokens.get(tokens_len - 1) == PatternToken.AnyRecursiveSequence)) {\n                                is_recursive = true\n                                tokens.append(PatternToken.AnyRecursiveSequence)\n                            }\n                        }\n                    } else {\n                        tokens.append(PatternToken.AnySequence)\n                    }\n                case r'[' =>\n                    if (i + 4 <= chars.size && chars[i + 1] == r'!') {\n                        match (chars[i + 3..].indexOf(r']')) {\n                            case None => ()\n                            case Some(j) =>\n                                let subChars = chars[i + 2..i + 3 + j]\n                                let cs = parseCharSpecifiers(subChars)\n                                tokens.append(PatternToken.AnyExcept(cs))\n                                i += 4 + j\n                                continue\n                        }\n                    } else if (i + 3 <= chars.size && chars[i + 1] != r'!') {\n                        match (chars[i + 2..].indexOf(r']')) {\n                            case None => ()\n                            case Some(j) =>\n                                let subChars = chars[i + 1..i + 2 + j]\n                                let cs = parseCharSpecifiers(subChars)\n                                tokens.append(PatternToken.AnyWithin(cs))\n                                i += 3 + j\n                                continue\n                        }\n                    }\n\n                    throw PatternException(i, ERROR_INVALID_RANGE)\n                case c =>\n                    tokens.append(PatternToken.Char(c))\n                    i++\n            }\n        }\n\n        this.original = pattern\n        this.tokens = tokens\n        this.isRecursive = is_recursive\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "init(pattern: String) {",
              "successors": [
                {
                  "id": 2,
                  "label": "let chars = pattern.toRuneArray()\nlet tokens = ArrayList<PatternToken>()\nvar is_recursive = false\nvar i = 0",
                  "successors": [
                    {
                      "id": 3,
                      "label": "while (i < chars.size) {",
                      "successors": [
                        {
                          "id": 4,
                          "label": "match (chars[i]) {",
                          "successors": [
                            {
                              "id": 5,
                              "label": "case r'?' =>",
                              "successors": [
                                {
                                  "id": 6,
                                  "label": "tokens.append(PatternToken.AnyChar)\ni++",
                                  "successors": []
                                }
                              ]
                            },
                            {
                              "id": 7,
                              "label": "case r'*' =>",
                              "successors": [
                                {
                                  "id": 8,
                                  "label": "let old = i\nwhile (i < chars.size && chars[i] == r'*') {\ni++ }",
                                  "successors": [
                                    {
                                      "id": 9,
                                      "label": "let count = i - old\nif (count > 2) {",
                                      "successors": [
                                        {
                                          "id": 10,
                                          "label": "throw PatternException(old + 2, ERROR_WILDCARDS)",
                                          "successors": []
                                        },
                                        {
                                          "id": 11,
                                          "label": "} else if (count == 2) {",
                                          "successors": [
                                            {
                                              "id": 12,
                                              "label": "let is_valid = if (i == 2 || isSeparator(chars[i - count - 1])) {",
                                              "successors": [
                                                {
                                                  "id": 13,
                                                  "label": "if (i < chars.size && isSeparator(chars[i])) {\ni++\ntrue\n} else if (i == chars.size) {\ntrue\n} else {\nthrow PatternException(i, ERROR_RECURSIVE_WILDCARDS)\n}",
                                                  "successors": []
                                                }
                                              ]
                                            },
                                            {
                                              "id": 14,
                                              "label": "} else {\nthrow PatternException(old - 1, ERROR_RECURSIVE_WILDCARDS)\n}",
                                              "successors": [
                                                {
                                                  "id": 15,
                                                  "label": "if (is_valid) {\nlet tokens_len = tokens.size\nif (!(tokens_len > 1 && tokens.get(tokens_len - 1) == PatternToken.AnyRecursiveSequence)) {\nis_recursive = true\ntokens.append(PatternToken.AnyRecursiveSequence)\n}\n}",
                                                  "successors": []
                                                }
                                              ]
                                            }
                                          ]
                                        },
                                        {
                                          "id": 16,
                                          "label": "} else {\ntokens.append(PatternToken.AnySequence)\n}",
                                          "successors": []
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            },
                            {
                              "id": 17,
                              "label": "case r'[' =>",
                              "successors": [
                                {
                                  "id": 18,
                                  "label": "if (i + 4 <= chars.size && chars[i + 1] == r'!') {",
                                  "successors": [
                                    {
                                      "id": 19,
                                      "label": "match (chars[i + 3..].indexOf(r']')) {",
                                      "successors": [
                                        {
                                          "id": 20,
                                          "label": "case None => ()",
                                          "successors": []
                                        },
                                        {
                                          "id": 21,
                                          "label": "case Some(j) =>",
                                          "successors": [
                                            {
                                              "id": 22,
                                              "label": "let subChars = chars[i + 2..i + 3 + j]\nlet cs = parseCharSpecifiers(subChars)\ntokens.append(PatternToken.AnyExcept(cs))\ni += 4 + j\ncontinue",
                                              "successors": []
                                            }
                                          ]
                                        }
                                      ]
                                    }
                                  ]
                                },
                                {
                                  "id": 23,
                                  "label": "} else if (i + 3 <= chars.size && chars[i + 1] != r'!') {",
                                  "successors": [
                                    {
                                      "id": 24,
                                      "label": "match (chars[i + 2..].indexOf(r']')) {",
                                      "successors": [
                                        {
                                          "id": 25,
                                          "label": "case None => ()",
                                          "successors": []
                                        },
                                        {
                                          "id": 26,
                                          "label": "case Some(j) =>",
                                          "successors": [
                                            {
                                              "id": 27,
                                              "label": "let subChars = chars[i + 1..i + 2 + j]\nlet cs = parseCharSpecifiers(subChars)\ntokens.append(PatternToken.AnyWithin(cs))\ni += 3 + j\ncontinue",
                                              "successors": []
                                            }
                                          ]
                                        }
                                      ]
                                    }
                                  ]
                                },
                                {
                                  "id": 28,
                                  "label": "throw PatternException(i, ERROR_INVALID_RANGE)",
                                  "successors": []
                                }
                              ]
                            },
                            {
                              "id": 29,
                              "label": "case c =>",
                              "successors": [
                                {
                                  "id": 30,
                                  "label": "tokens.append(PatternToken.Char(c))\ni++",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "id": 31,
                      "label": "this.original = pattern\nthis.tokens = tokens\nthis.isRecursive = is_recursive",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "matches",
          "type": "function",
          "start_line": 248,
          "end_line": 250,
          "functions": [],
          "classes": [],
          "simplified_code": "    public func matches(str: String): Bool {\n        this.matchesWith(str, MatchOptions())\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "public func matches(str: String): Bool {",
              "successors": [
                {
                  "id": 2,
                  "label": "this.matchesWith(str, MatchOptions())",
                  "successors": [
                    {
                      "id": 3,
                      "label": "}",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "matchesWith",
          "type": "function",
          "start_line": 252,
          "end_line": 257,
          "functions": [],
          "classes": [],
          "simplified_code": "    public func matchesWith(\n        str: String,\n        options: MatchOptions\n    ): Bool {\n        this.matchesFrom(true, CharsIterator(str.toRuneArray()), 0, options) == MatchResult.Match\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "public func matchesWith( str: String, options: MatchOptions ): Bool {",
              "successors": [
                {
                  "id": 2,
                  "label": "this.matchesFrom(true, CharsIterator(str.toRuneArray()), 0, options) == MatchResult.Match",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "matchesFrom",
          "type": "function",
          "start_line": 259,
          "end_line": 335,
          "functions": [],
          "classes": [],
          "simplified_code": "    public func matchesFrom(\n        followsSeparator: Bool,\n        file: CharsIterator,\n        i: Int,\n        options: MatchOptions\n    ): MatchResult {\n        var fs = followsSeparator\n        for ((ti, token) in this.tokens[i..].iterator().enumerate()) {\n            match (token) {\n                case AnySequence | AnyRecursiveSequence =>\n                    match (this.matchesFrom(fs, file.clone(), i + ti + 1, options)) {\n                        case MatchResult.SubPatternDoesntMatch => ()\n                        case m => return m\n                    }\n\n                    while (let Some(c) <- file.next()) {\n                        if (fs && options.requireLiteralLeadingDot && c == r'.') {\n                            return MatchResult.SubPatternDoesntMatch\n                        }\n                        fs = isSeparator(c)\n                        match (token) {\n                            case PatternToken.AnyRecursiveSequence =>\n                                if (!fs) {\n                                    continue\n                                }\n                            case PatternToken.AnySequence =>\n                                if (options.requireLiteralSeparator && fs) {\n                                    return MatchResult.SubPatternDoesntMatch\n                                }\n                            case _ => ()\n                        }\n\n                        match (this.matchesFrom(fs, file.clone(), i + ti + 1, options)) {\n                            case MatchResult.SubPatternDoesntMatch => ()\n                            case m => return m\n                        }\n                    }\n                case _ =>\n                    let c = match (file.next()) {\n                        case Some(c) => c\n                        case None => return MatchResult.EntirePatternDoesntMatch\n                    }\n\n                    let is_sep = isSeparator(c)\n\n                    if (!match (token) {\n                        case PatternToken.AnyChar | PatternToken.AnyWithin(_) | AnyExcept(_) =>\n                            if ((options.requireLiteralSeparator && is_sep) || (fs && options.requireLiteralLeadingDot &&\n                                c == r'.')) {\n                                false\n                            } else {\n                                true\n                            }\n                        case _ => true\n                    }) {\n                        return MatchResult.SubPatternDoesntMatch\n                    }\n\n                    if (!match (token) {\n                        case PatternToken.AnyChar => true\n                        case PatternToken.AnyWithin(cs) => inCharSpecifiers(cs, c, options)\n                        case PatternToken.AnyExcept(cs) => !inCharSpecifiers(cs, c, options)\n                        case PatternToken.Char(tc) => charsEq(c, tc, options.caseSensitive)\n                        case _ => throw Exception(\"unreachable\")\n                    }) {\n                        return MatchResult.SubPatternDoesntMatch\n                    }\n                    fs = is_sep\n            }\n        }\n\n        if (file.next().isNone()) {\n            return MatchResult.Match\n        } else {\n            return MatchResult.SubPatternDoesntMatch\n        }\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "var fs = followsSeparator",
              "successors": [
                {
                  "id": 2,
                  "label": "for ((ti, token) in this.tokens[i..].iterator().enumerate()) {",
                  "successors": [
                    {
                      "id": 3,
                      "label": "match (token) {",
                      "successors": [
                        {
                          "id": 4,
                          "label": "case AnySequence | AnyRecursiveSequence =>",
                          "successors": [
                            {
                              "id": 5,
                              "label": "match (this.matchesFrom(fs, file.clone(), i + ti + 1, options)) {",
                              "successors": [
                                {
                                  "id": 6,
                                  "label": "case MatchResult.SubPatternDoesntMatch => ()",
                                  "successors": [
                                    {
                                      "id": 10,
                                      "label": "while (let Some(c) <- file.next()) {",
                                      "successors": [
                                        {
                                          "id": 11,
                                          "label": "if (fs && options.requireLiteralLeadingDot && c == r'.') {",
                                          "successors": [
                                            {
                                              "id": 12,
                                              "label": "return MatchResult.SubPatternDoesntMatch",
                                              "successors": []
                                            }
                                          ]
                                        },
                                        {
                                          "id": 13,
                                          "label": "fs = isSeparator(c)",
                                          "successors": [
                                            {
                                              "id": 14,
                                              "label": "match (token) {",
                                              "successors": [
                                                {
                                                  "id": 15,
                                                  "label": "case PatternToken.AnyRecursiveSequence =>",
                                                  "successors": [
                                                    {
                                                      "id": 16,
                                                      "label": "if (!fs) {",
                                                      "successors": [
                                                        {
                                                          "id": 17,
                                                          "label": "continue",
                                                          "successors": [
                                                            {
                                                              "id": 10,
                                                              "label": "while (let Some(c) <- file.next()) {",
                                                              "successors": []
                                                            }
                                                          ]
                                                        }
                                                      ]
                                                    }
                                                  ]
                                                },
                                                {
                                                  "id": 18,
                                                  "label": "case PatternToken.AnySequence =>",
                                                  "successors": [
                                                    {
                                                      "id": 19,
                                                      "label": "if (options.requireLiteralSeparator && fs) {",
                                                      "successors": [
                                                        {
                                                          "id": 20,
                                                          "label": "return MatchResult.SubPatternDoesntMatch",
                                                          "successors": []
                                                        }
                                                      ]
                                                    }
                                                  ]
                                                },
                                                {
                                                  "id": 21,
                                                  "label": "case _ => ()",
                                                  "successors": [
                                                    {
                                                      "id": 22,
                                                      "label": "match (this.matchesFrom(fs, file.clone(), i + ti + 1, options)) {",
                                                      "successors": [
                                                        {
                                                          "id": 23,
                                                          "label": "case MatchResult.SubPatternDoesntMatch => ()",
                                                          "successors": [
                                                            {
                                                              "id": 10,
                                                              "label": "while (let Some(c) <- file.next()) {",
                                                              "successors": []
                                                            }
                                                          ]
                                                        },
                                                        {
                                                          "id": 24,
                                                          "label": "case m => return m",
                                                          "successors": []
                                                        }
                                                      ]
                                                    }
                                                  ]
                                                }
                                              ]
                                            }
                                          ]
                                        }
                                      ]
                                    }
                                  ]
                                },
                                {
                                  "id": 7,
                                  "label": "case m => return m",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        },
                        {
                          "id": 8,
                          "label": "case _ =>",
                          "successors": [
                            {
                              "id": 9,
                              "label": "let c = match (file.next()) {",
                              "successors": [
                                {
                                  "id": 25,
                                  "label": "case Some(c) => c",
                                  "successors": [
                                    {
                                      "id": 26,
                                      "label": "let is_sep = isSeparator(c)",
                                      "successors": [
                                        {
                                          "id": 27,
                                          "label": "if (!match (token) {",
                                          "successors": [
                                            {
                                              "id": 28,
                                              "label": "case PatternToken.AnyChar | PatternToken.AnyWithin(_) | AnyExcept(_) =>",
                                              "successors": [
                                                {
                                                  "id": 29,
                                                  "label": "if ((options.requireLiteralSeparator && is_sep) || (fs && options.requireLiteralLeadingDot && c == r'.')) {",
                                                  "successors": [
                                                    {
                                                      "id": 30,
                                                      "label": "false",
                                                      "successors": []
                                                    }
                                                  ]
                                                },
                                                {
                                                  "id": 31,
                                                  "label": "else {",
                                                  "successors": [
                                                    {
                                                      "id": 32,
                                                      "label": "true",
                                                      "successors": []
                                                    }
                                                  ]
                                                }
                                              ]
                                            },
                                            {
                                              "id": 33,
                                              "label": "case _ => true",
                                              "successors": [
                                                {
                                                  "id": 34,
                                                  "label": "if (!match (token) {",
                                                  "successors": [
                                                    {
                                                      "id": 35,
                                                      "label": "case PatternToken.AnyChar => true",
                                                      "successors": []
                                                    },
                                                    {
                                                      "id": 36,
                                                      "label": "case PatternToken.AnyWithin(cs) => inCharSpecifiers(cs, c, options)",
                                                      "successors": []
                                                    },
                                                    {
                                                      "id": 37,
                                                      "label": "case PatternToken.AnyExcept(cs) => !inCharSpecifiers(cs, c, options)",
                                                      "successors": []
                                                    },
                                                    {
                                                      "id": 38,
                                                      "label": "case PatternToken.Char(tc) => charsEq(c, tc, options.caseSensitive)",
                                                      "successors": []
                                                    },
                                                    {
                                                      "id": 39,
                                                      "label": "case _ => throw Exception(\"unreachable\")",
                                                      "successors": []
                                                    }
                                                  ]
                                                }
                                              ]
                                            }
                                          ]
                                        },
                                        {
                                          "id": 40,
                                          "label": "return MatchResult.SubPatternDoesntMatch",
                                          "successors": []
                                        },
                                        {
                                          "id": 41,
                                          "label": "fs = is_sep",
                                          "successors": []
                                        }
                                      ]
                                    }
                                  ]
                                },
                                {
                                  "id": 42,
                                  "label": "case None => return MatchResult.EntirePatternDoesntMatch",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "id": 43,
                  "label": "if (file.next().isNone()) {",
                  "successors": [
                    {
                      "id": 44,
                      "label": "return MatchResult.Match",
                      "successors": []
                    }
                  ]
                },
                {
                  "id": 45,
                  "label": "else {",
                  "successors": [
                    {
                      "id": 46,
                      "label": "return MatchResult.SubPatternDoesntMatch",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "toCharString",
          "type": "function",
          "start_line": 337,
          "end_line": 346,
          "functions": [],
          "classes": [],
          "simplified_code": "    func toCharString(): Option<String> {\n        let ret = StringBuilder()\n        for (token in this.tokens) {\n            match (token) {\n                case Char(c) => ret.append(c)\n                case _ => return None\n            }\n        }\n        return ret.toString()\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "let ret = StringBuilder()",
              "successors": [
                {
                  "id": 2,
                  "label": "for (token in this.tokens):",
                  "successors": [
                    {
                      "id": 3,
                      "label": "match (token):",
                      "successors": [
                        {
                          "id": 4,
                          "label": "case Char(c) => ret.append(c)",
                          "successors": [
                            {
                              "id": 2,
                              "label": "for (token in this.tokens):",
                              "successors": []
                            }
                          ]
                        },
                        {
                          "id": 5,
                          "label": "case _ => return None",
                          "successors": []
                        }
                      ]
                    }
                  ]
                },
                {
                  "id": 6,
                  "label": "return ret.toString()",
                  "successors": []
                }
              ]
            }
          ]
        }
      ],
      "classes": [],
      "simplified_code": "public struct Pattern {\n    let original: String\n    let tokens: ArrayList<PatternToken>\n    let isRecursive: Bool\n\n    }\n\n    }\n\n    }\n\n    }\n\n    }\n}",
      "blocks": [
        {
          "id": 1,
          "label": "public struct Pattern {",
          "successors": [
            {
              "id": 2,
              "label": "let original: String",
              "successors": [
                {
                  "id": 3,
                  "label": "let tokens: ArrayList<PatternToken>",
                  "successors": [
                    {
                      "id": 4,
                      "label": "let isRecursive: Bool",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "PathWrapper",
      "type": "class",
      "start_line": 372,
      "end_line": 385,
      "functions": [],
      "classes": [],
      "simplified_code": "public struct PathWrapper {\n    public let path: Path\n    let isDirectory: Bool\n\n    init(path: Path) {\n        this.path = path\n        this.isDirectory = FileInfo(path).isDirectory()\n    }\n\n    init(path: Path, isDirectory: Bool) {\n        this.path = path\n        this.isDirectory = isDirectory\n    }\n}",
      "blocks": [
        {
          "id": 1,
          "label": "public struct PathWrapper {",
          "successors": [
            {
              "id": 2,
              "label": "public let path: Path",
              "successors": [
                {
                  "id": 3,
                  "label": "let isDirectory: Bool",
                  "successors": [
                    {
                      "id": 4,
                      "label": "init(path: Path) {",
                      "successors": [
                        {
                          "id": 5,
                          "label": "this.path = path",
                          "successors": [
                            {
                              "id": 6,
                              "label": "this.isDirectory = FileInfo(path).isDirectory()",
                              "successors": [
                                {
                                  "id": 7,
                                  "label": "}",
                                  "successors": [
                                    {
                                      "id": 8,
                                      "label": "init(path: Path, isDirectory: Bool) {",
                                      "successors": [
                                        {
                                          "id": 9,
                                          "label": "this.path = path",
                                          "successors": [
                                            {
                                              "id": 10,
                                              "label": "this.isDirectory = isDirectory",
                                              "successors": [
                                                {
                                                  "id": 11,
                                                  "label": "}",
                                                  "successors": []
                                                }
                                              ]
                                            }
                                          ]
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "Paths",
      "type": "class",
      "start_line": 469,
      "end_line": 560,
      "functions": [
        {
          "name": "next",
          "type": "function",
          "start_line": 491,
          "end_line": 559,
          "functions": [],
          "classes": [],
          "simplified_code": "    public func next(): Option<Path> {\n        if (!this.initialized) {\n            this.initialized = true\n            if (!this.dirPatterns.isEmpty()) {\n                fillTodo(this.todo, this.dirPatterns, 0, this.scope, this.options)\n            }\n        }\n        while (true) {\n            if (this.dirPatterns.isEmpty() || this.todo.isEmpty()) {\n                return None\n            }\n\n            let t = this.todo.remove(this.todo.size - 1)\n            let path = t[0]\n            var idx = t[1]\n\n            if (idx == Int64.Max) {\n                if (this.requireDir && !path.isDirectory) {\n                    continue\n                }\n                return Some(path.path)\n            }\n\n            if (this.dirPatterns[idx].isRecursive) {\n                var next = idx\n                while (next + 1 < this.dirPatterns.size && this.dirPatterns[next + 1].isRecursive) {\n                    next++\n                }\n\n                if (path.isDirectory) {\n                    fillTodo(\n                        this.todo,\n                        this.dirPatterns,\n                        next,\n                        path,\n                        this.options\n                    )\n\n                    if (next == this.dirPatterns.size - 1) {\n                        return Some(path.path)\n                    } else {\n                        idx = next + 1\n                    }\n                } else if (next == this.dirPatterns.size - 1) {\n                    continue\n                } else {\n                    idx = next + 1\n                }\n            }\n\n            if (this.dirPatterns[idx].matchesWith(path.path.fileName, this.options)) {\n                if (idx == this.dirPatterns.size - 1) {\n                    if (!this.requireDir || path.isDirectory) {\n                        return Some(path.path)\n                    }\n                } else {\n                    fillTodo(\n                        this.todo,\n                        this.dirPatterns,\n                        idx + 1,\n                        path,\n                        this.options\n                    )\n                }\n            }\n        }\n\n        None\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "public func next(): Option<Path> {\n    if (!this.initialized) {",
              "successors": [
                {
                  "id": 2,
                  "label": "this.initialized = true\n        if (!this.dirPatterns.isEmpty()) {",
                  "successors": [
                    {
                      "id": 3,
                      "label": "fillTodo(this.todo, this.dirPatterns, 0, this.scope, this.options)",
                      "successors": [
                        {
                          "id": 4,
                          "label": "}\n    }",
                          "successors": [
                            {
                              "id": 5,
                              "label": "while (true) {",
                              "successors": [
                                {
                                  "id": 6,
                                  "label": "if (this.dirPatterns.isEmpty() || this.todo.isEmpty()) {",
                                  "successors": [
                                    {
                                      "id": 7,
                                      "label": "return None",
                                      "successors": []
                                    }
                                  ]
                                },
                                {
                                  "id": 8,
                                  "label": "let t = this.todo.remove(this.todo.size - 1)\n            let path = t[0]\n            var idx = t[1]\n\n            if (idx == Int64.Max) {",
                                  "successors": [
                                    {
                                      "id": 9,
                                      "label": "if (this.requireDir && !path.isDirectory) {",
                                      "successors": [
                                        {
                                          "id": 10,
                                          "label": "continue",
                                          "successors": [
                                            {
                                              "id": 5,
                                              "label": "while (true) { [...] end",
                                              "successors": []
                                            }
                                          ]
                                        }
                                      ]
                                    },
                                    {
                                      "id": 11,
                                      "label": "return Some(path.path)",
                                      "successors": []
                                    }
                                  ]
                                },
                                {
                                  "id": 12,
                                  "label": "if (this.dirPatterns[idx].isRecursive) {",
                                  "successors": [
                                    {
                                      "id": 13,
                                      "label": "var next = idx\n                while (next + 1 < this.dirPatterns.size && this.dirPatterns[next + 1].isRecursive) {",
                                      "successors": [
                                        {
                                          "id": 14,
                                          "label": "next++",
                                          "successors": [
                                            {
                                              "id": 13,
                                              "label": "while (next + 1 < this.dirPatterns.size && this.dirPatterns[next + 1].isRecursive) { [...] end",
                                              "successors": []
                                            }
                                          ]
                                        }
                                      ]
                                    },
                                    {
                                      "id": 15,
                                      "label": "if (path.isDirectory) {",
                                      "successors": [
                                        {
                                          "id": 16,
                                          "label": "fillTodo(\n                    this.todo,\n                    this.dirPatterns,\n                    next,\n                    path,\n                    this.options\n                )\n\n                if (next == this.dirPatterns.size - 1) {",
                                          "successors": [
                                            {
                                              "id": 17,
                                              "label": "return Some(path.path)",
                                              "successors": []
                                            }
                                          ]
                                        },
                                        {
                                          "id": 18,
                                          "label": "idx = next + 1",
                                          "successors": []
                                        }
                                      ]
                                    },
                                    {
                                      "id": 19,
                                      "label": "else if (next == this.dirPatterns.size - 1) {",
                                      "successors": [
                                        {
                                          "id": 20,
                                          "label": "continue",
                                          "successors": [
                                            {
                                              "id": 5,
                                              "label": "while (true) { [...] end",
                                              "successors": []
                                            }
                                          ]
                                        }
                                      ]
                                    },
                                    {
                                      "id": 21,
                                      "label": "idx = next + 1",
                                      "successors": []
                                    }
                                  ]
                                },
                                {
                                  "id": 22,
                                  "label": "if (this.dirPatterns[idx].matchesWith(path.path.fileName, this.options)) {",
                                  "successors": [
                                    {
                                      "id": 23,
                                      "label": "if (idx == this.dirPatterns.size - 1) {",
                                      "successors": [
                                        {
                                          "id": 24,
                                          "label": "if (!this.requireDir || path.isDirectory) {",
                                          "successors": [
                                            {
                                              "id": 25,
                                              "label": "return Some(path.path)",
                                              "successors": []
                                            }
                                          ]
                                        }
                                      ]
                                    },
                                    {
                                      "id": 26,
                                      "label": "fillTodo(\n                this.todo,\n                this.dirPatterns,\n                idx + 1,\n                path,\n                this.options\n            )",
                                      "successors": []
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "id": 27,
              "label": "None\n}",
              "successors": []
            }
          ]
        }
      ],
      "classes": [],
      "simplified_code": "public class Paths <: Iterator<Path> {\n    let dirPatterns: Array<Pattern>\n    let requireDir: Bool\n    let options: MatchOptions\n    let todo: ArrayList<(PathWrapper, Int64)>\n    let scope: PathWrapper\n    var initialized: Bool = false\n\n    init(\n        dirPatterns: Array<Pattern>,\n        requireDir: Bool,\n        options: MatchOptions,\n        todo: ArrayList<(PathWrapper, Int64)>,\n        scope: PathWrapper\n    ) {\n        this.dirPatterns = dirPatterns\n        this.requireDir = requireDir\n        this.options = options\n        this.todo = todo\n        this.scope = scope\n    }\n\n    }\n}",
      "blocks": [
        {
          "id": 1,
          "label": "public class Paths <: Iterator<Path> {",
          "successors": [
            {
              "id": 2,
              "label": "let dirPatterns: Array<Pattern>",
              "successors": []
            },
            {
              "id": 3,
              "label": "let requireDir: Bool",
              "successors": []
            },
            {
              "id": 4,
              "label": "let options: MatchOptions",
              "successors": []
            },
            {
              "id": 5,
              "label": "let todo: ArrayList<(PathWrapper, Int64)>",
              "successors": []
            },
            {
              "id": 6,
              "label": "let scope: PathWrapper",
              "successors": []
            },
            {
              "id": 7,
              "label": "var initialized: Bool = false",
              "successors": []
            },
            {
              "id": 8,
              "label": "init(",
              "successors": [
                {
                  "id": 9,
                  "label": "dirPatterns: Array<Pattern>,",
                  "successors": []
                },
                {
                  "id": 10,
                  "label": "requireDir: Bool,",
                  "successors": []
                },
                {
                  "id": 11,
                  "label": "options: MatchOptions,",
                  "successors": []
                },
                {
                  "id": 12,
                  "label": "todo: ArrayList<(PathWrapper, Int64)>,",
                  "successors": []
                },
                {
                  "id": 13,
                  "label": "scope: PathWrapper",
                  "successors": []
                }
              ]
            },
            {
              "id": 14,
              "label": ") {",
              "successors": [
                {
                  "id": 15,
                  "label": "this.dirPatterns = dirPatterns",
                  "successors": []
                },
                {
                  "id": 16,
                  "label": "this.requireDir = requireDir",
                  "successors": []
                },
                {
                  "id": 17,
                  "label": "this.options = options",
                  "successors": []
                },
                {
                  "id": 18,
                  "label": "this.todo = todo",
                  "successors": []
                },
                {
                  "id": 19,
                  "label": "this.scope = scope",
                  "successors": []
                }
              ]
            },
            {
              "id": 20,
              "label": "}",
              "successors": []
            }
          ]
        }
      ]
    }
  ],
  "simplified_code": "package glob\n\nimport std.regex.Regex\nimport std.collection.ArrayList\nimport std.fs.{Directory, Path, FileInfo, FSException}\nimport std.deriving.Derive\n\n// cjlint-ignore -start !G.OPR.01 !G.NAM.04 !G.ITF.04 macro\n@Derive[Equatable]\nenum CharSpecifier {\n    SingleChar(Rune)\n    | CharRange(Rune, Rune)\n}\n\n@Derive[Equatable]\nenum PatternToken {\n    Char(Rune)\n    | AnyChar\n    | AnySequence\n    | AnyRecursiveSequence\n    | AnyWithin(Array<CharSpecifier>)\n    | AnyExcept(Array<CharSpecifier>)\n}\n\npublic struct MatchOptions {\n    /**\n     * \u662f\u5426\u4ee5\u5927\u5c0f\u5199\u654f\u611f\u7684\u65b9\u5f0f\u5339\u914d\u6a21\u5f0f\u3002\n     * \u76ee\u524d\u53ea\u8003\u8651 ASCII \u5b57\u7b26\u4e4b\u95f4\u7684\u5927/\u5c0f\u5199\u5173\u7cfb\uff0c\n     * \u4f46\u5c06\u6765\u53ef\u80fd\u4f1a\u6269\u5c55\u5230\u9002\u7528\u4e8e Unicode\u3002\n     */\n    public var caseSensitive: Bool = false\n\n    /**\n     * \u662f\u5426\u8981\u6c42\u8def\u5f84\u5206\u9694\u7b26\u5b57\u7b26\uff08\u4f8b\u5982 Posix \u4e0a\u7684 `/`\uff09\u5fc5\u987b\u7531\u5b57\u9762\u91cf `/` \u5339\u914d\uff0c\n     * \u800c\u4e0d\u662f\u7531 `*` \u6216 `?` \u6216 `[...]` \u5339\u914d\u3002\n     */\n    public var requireLiteralSeparator: Bool = false\n\n    /**\n     * \u662f\u5426\u8981\u6c42\u8def\u5f84\u7ec4\u4ef6\u7684\u5f00\u5934\u662f `.` \u5b57\u7b26\uff0c\u5fc5\u987b\u7531\u5b57\u9762\u91cf `.` \u5339\u914d\uff0c\n     * \u800c\u4e0d\u662f\u7531 `*` \u6216 `?` \u6216 `**` \u6216 `[...]` \u5339\u914d\u3002\n     * \u8fd9\u5bf9\u4e8e Unix \u7cfb\u7edf\u4e0a\u88ab\u4f20\u7edf\u8ba4\u4e3a\u662f\u9690\u85cf\u7684\u6587\u4ef6\u5f88\u6709\u7528\uff0c\n     * \u53ef\u80fd\u5e0c\u671b\u5728\u5217\u51fa\u6587\u4ef6\u65f6\u8df3\u8fc7\u5b83\u4eec\u3002\n     */\n    public var requireLiteralLeadingDot: Bool = false\n}\n\n@Derive[Equatable]\npublic enum MatchResult {\n    Match\n    | SubPatternDoesntMatch\n    | EntirePatternDoesntMatch\n}\n\n// cjlint-ignore -end macro\n\nconst ERROR_WILDCARDS = \"wildcards are either regular `*` or recursive `**`\";\nconst ERROR_RECURSIVE_WILDCARDS = \"recursive wildcards must form a single path component\";\nconst ERROR_INVALID_RANGE = \"invalid range pattern\";\n\n}\n\n}\n\n}\n\n}\n\n}\n\n// cjlint-ignore -start !G.FUN.01 fun\n}\n\n}\n\n}\n\n}\n\n}\n\n}\n\n}\n\nextend String {\n    func split(checker: (Rune) -> Bool): Array<String> {\n        let chars = this.toRuneArray()\n        let ret = ArrayList<String>()\n        var start = 0\n        var i = 0\n\n        while (i < chars.size) {\n            if (checker(chars[i])) {\n                if (start < i) {\n                    ret.append(this[start..i])\n                }\n                start = i + 1\n            }\n            i++\n        }\n\n        if (start < i) {\n            ret.append(this[start..i])\n        }\n\n        return ret.toArray()\n    }\n}\n\n/** \u8fd4\u56de\u4e00\u4e2a\u8fed\u4ee3\u5668\uff0c\u4f7f\u7528\u9ed8\u8ba4\u5339\u914d\u9009\u9879\u751f\u6210\u4e0e\u7ed9\u5b9a\u6a21\u5f0f\u5339\u914d\u7684\u6240\u6709 Path\u3002 \n * \u8fd9\u4e9b\u8def\u5f84\u53ef\u4ee5\u662f\u7edd\u5bf9\u8def\u5f84\uff0c\u4e5f\u53ef\u4ee5\u662f\u76f8\u5bf9\u4e8e\u5f53\u524d\u5de5\u4f5c\u76ee\u5f55\u7684\u76f8\u5bf9\u8def\u5f84\u3002\n *\n * \u5982\u679c\u6a21\u5f0f\u65e0\u6548\uff0c\u5219\u53ef\u80fd\u4f1a\u5f15\u53d1 PatternException\u3002\n */\n}\n\n/** \u8fd4\u56de\u4e00\u4e2a\u8fed\u4ee3\u5668\uff0c\u4f7f\u7528\u7ed9\u5b9a\u7684\u5339\u914d\u9009\u9879\u751f\u6210\u4e0e\u7ed9\u5b9a\u6a21\u5f0f\u5339\u914d\u7684\u6240\u6709 Path\u3002 \n * \u8fd9\u4e9b\u8def\u5f84\u53ef\u4ee5\u662f\u7edd\u5bf9\u8def\u5f84\uff0c\u4e5f\u53ef\u4ee5\u662f\u76f8\u5bf9\u4e8e\u5f53\u524d\u5de5\u4f5c\u76ee\u5f55\u7684\u76f8\u5bf9\u8def\u5f84\u3002\n * \u6b64\u51fd\u6570\u5141\u8bb8\u60a8\u6307\u5b9a\u5339\u914d\u9009\u9879\uff0c\u4f8b\u5982\u5927\u5c0f\u5199\u654f\u611f\u6027\u3002\n *\n * \u5982\u679c\u6a21\u5f0f\u65e0\u6548\uff0c\u5219\u53ef\u80fd\u4f1a\u5f15\u53d1 PatternException\u3002\n */\n}\n\n// cjlint-ignore -end fun",
  "blocks": [
    {
      "id": 1,
      "label": "package glob",
      "successors": [
        {
          "id": 2,
          "label": "import std.regex.Regex\nimport std.collection.ArrayList\nimport std.fs.{Directory, Path, FileInfo, FSException}\nimport std.deriving.Derive",
          "successors": [
            {
              "id": 3,
              "label": "@Derive[Equatable]\nenum CharSpecifier {\n    SingleChar(Rune)\n    | CharRange(Rune, Rune)\n}",
              "successors": [
                {
                  "id": 4,
                  "label": "@Derive[Equatable]\nenum PatternToken {\n    Char(Rune)\n    | AnyChar\n    | AnySequence\n    | AnyRecursiveSequence\n    | AnyWithin(Array<CharSpecifier>)\n    | AnyExcept(Array<CharSpecifier>)\n}\n\npublic struct MatchOptions {\n    /**\n     * \u662f\u5426\u4ee5\u5927\u5c0f\u5199\u654f\u611f\u7684\u65b9\u5f0f\u5339\u914d\u6a21\u5f0f\u3002\n     * \u76ee\u524d\u53ea\u8003\u8651 ASCII \u5b57\u7b26\u4e4b\u95f4\u7684\u5927/\u5c0f\u5199\u5173\u7cfb\uff0c\n     * \u4f46\u5c06\u6765\u53ef\u80fd\u4f1a\u6269\u5c55\u5230\u9002\u7528\u4e8e Unicode\u3002\n     */\n    public var caseSensitive: Bool = false\n\n    /**\n     * \u662f\u5426\u8981\u6c42\u8def\u5f84\u5206\u9694\u7b26\u5b57\u7b26\uff08\u4f8b\u5982 Posix \u4e0a\u7684 `/`\uff09\u5fc5\u987b\u7531\u5b57\u9762\u91cf `/` \u5339\u914d\uff0c\n     * \u800c\u4e0d\u662f\u7531 `*` \u6216 `?` \u6216 `[...]` \u5339\u914d\u3002\n     */\n    public var requireLiteralSeparator: Bool = false\n\n    /**\n     * \u662f\u5426\u8981\u6c42\u8def\u5f84\u7ec4\u4ef6\u7684\u5f00\u5934\u662f `.` \u5b57\u7b26\uff0c\u5fc5\u987b\u7531\u5b57\u9762\u91cf `.` \u5339\u914d\uff0c\n     * \u800c\u4e0d\u662f\u7531 `*` \u6216 `?` \u6216 `**` \u6216 `[...]` \u5339\u914d\u3002\n     * \u8fd9\u5bf9\u4e8e Unix \u7cfb\u7edf\u4e0a\u88ab\u4f20\u7edf\u8ba4\u4e3a\u662f\u9690\u85cf\u7684\u6587\u4ef6\u5f88\u6709\u7528\uff0c\n     * \u53ef\u80fd\u5e0c\u671b\u5728\u5217\u51fa\u6587\u4ef6\u65f6\u8df3\u8fc7\u5b83\u4eec\u3002\n     */\n    public var requireLiteralLeadingDot: Bool = false\n}",
                  "successors": [
                    {
                      "id": 5,
                      "label": "@Derive[Equatable]\npublic enum MatchResult {\n    Match\n    | SubPatternDoesntMatch\n    | EntirePatternDoesntMatch\n}",
                      "successors": [
                        {
                          "id": 6,
                          "label": "const ERROR_WILDCARDS = \"wildcards are either regular `*` or recursive `**`\";\nconst ERROR_RECURSIVE_WILDCARDS = \"recursive wildcards must form a single path component\";\nconst ERROR_INVALID_RANGE = \"invalid range pattern\";",
                          "successors": [
                            {
                              "id": 7,
                              "label": "extend String {\n    func split(checker: (Rune) -> Bool): Array<String> {\n        let chars = this.toRuneArray()\n        let ret = ArrayList<String>()\n        var start = 0\n        var i = 0\n\n        while (i < chars.size) {\n            if (checker(chars[i])) {\n                if (start < i) {\n                    ret.append(this[start..i])\n                }\n                start = i + 1\n            }\n            i++\n        }\n\n        if (start < i) {\n            ret.append(this[start..i])\n        }\n\n        return ret.toArray()\n    }\n}\n\n/** \u8fd4\u56de\u4e00\u4e2a\u8fed\u4ee3\u5668\uff0c\u4f7f\u7528\u9ed8\u8ba4\u5339\u914d\u9009\u9879\u751f\u6210\u4e0e\u7ed9\u5b9a\u6a21\u5f0f\u5339\u914d\u7684\u6240\u6709 Path\u3002 \n * \u8fd9\u4e9b\u8def\u5f84\u53ef\u4ee5\u662f\u7edd\u5bf9\u8def\u5f84\uff0c\u4e5f\u53ef\u4ee5\u662f\u76f8\u5bf9\u4e8e\u5f53\u524d\u5de5\u4f5c\u76ee\u5f55\u7684\u76f8\u5bf9\u8def\u5f84\u3002\n *\n * \u5982\u679c\u6a21\u5f0f\u65e0\u6548\uff0c\u5219\u53ef\u80fd\u4f1a\u5f15\u53d1 PatternException\u3002\n */\n\n/** \u8fd4\u56de\u4e00\u4e2a\u8fed\u4ee3\u5668\uff0c\u4f7f\u7528\u7ed9\u5b9a\u7684\u5339\u914d\u9009\u9879\u751f\u6210\u4e0e\u7ed9\u5b9a\u6a21\u5f0f\u5339\u914d\u7684\u6240\u6709 Path\u3002 \n * \u8fd9\u4e9b\u8def\u5f84\u53ef\u4ee5\u662f\u7edd\u5bf9\u8def\u5f84\uff0c\u4e5f\u53ef\u4ee5\u662f\u76f8\u5bf9\u4e8e\u5f53\u524d\u5de5\u4f5c\u76ee\u5f55\u7684\u76f8\u5bf9\u8def\u5f84\u3002\n * \u6b64\u51fd\u6570\u5141\u8bb8\u60a8\u6307\u5b9a\u5339\u914d\u9009\u9879\uff0c\u4f8b\u5982\u5927\u5c0f\u5199\u654f\u611f\u6027\u3002\n *\n * \u5982\u679c\u6a21\u5f0f\u65e0\u6548\uff0c\u5219\u53ef\u80fd\u4f1a\u5f15\u53d1 PatternException\u3002\n */\n",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    }
  ]
}