{
  "name": "example_script",
  "type": "CFG",
  "start_line": 1,
  "end_line": 699,
  "functions": [
    {
      "name": "clip",
      "type": "function",
      "start_line": 42,
      "end_line": 61,
      "functions": [],
      "classes": [],
      "simplified_code": "func clip(dst: ImageI, r: Rectangle, src: Image, sp: Point, mask: Image, mp: Point): (ImageI, Rectangle) {\n    let orig = r.min.clone()\n    var rect = r.intersect(dst.bounds())\n    rect = rect.intersect(src.bounds() + (orig - sp))\n    if (!(mask is NilImage)) {\n        rect = rect.intersect(mask.bounds() + (orig - mp))\n    }\n    let dx = rect.min.x - orig.x\n    let dy = rect.min.y - orig.y\n    if (dx == 0 && dy == 0) {\n        return (dst, rect)\n    }\n    sp.x += dx\n    sp.y += dy\n    if (!(mp is NilPoint)) {\n        mp.x += dx\n        mp.y += dy\n    }\n    return (dst, rect)\n}",
      "blocks": [
        {
          "id": 1,
          "label": "func clip(dst: ImageI, r: Rectangle, src: Image, sp: Point, mask: Image, mp: Point): (ImageI, Rectangle) {",
          "successors": [
            {
              "id": 2,
              "label": "let orig = r.min.clone()",
              "successors": [
                {
                  "id": 3,
                  "label": "var rect = r.intersect(dst.bounds())",
                  "successors": [
                    {
                      "id": 4,
                      "label": "rect = rect.intersect(src.bounds() + (orig - sp))",
                      "successors": [
                        {
                          "id": 5,
                          "label": "if (!(mask is NilImage)) {",
                          "successors": [
                            {
                              "id": 6,
                              "label": "rect = rect.intersect(mask.bounds() + (orig - mp))",
                              "successors": []
                            }
                          ]
                        },
                        {
                          "id": 7,
                          "label": "let dx = rect.min.x - orig.x",
                          "successors": [
                            {
                              "id": 8,
                              "label": "let dy = rect.min.y - orig.y",
                              "successors": [
                                {
                                  "id": 9,
                                  "label": "if (dx == 0 && dy == 0) {",
                                  "successors": [
                                    {
                                      "id": 10,
                                      "label": "return (dst, rect)",
                                      "successors": []
                                    }
                                  ]
                                },
                                {
                                  "id": 11,
                                  "label": "sp.x += dx",
                                  "successors": [
                                    {
                                      "id": 12,
                                      "label": "sp.y += dy",
                                      "successors": [
                                        {
                                          "id": 13,
                                          "label": "if (!(mp is NilPoint)) {",
                                          "successors": [
                                            {
                                              "id": 14,
                                              "label": "mp.x += dx",
                                              "successors": [
                                                {
                                                  "id": 15,
                                                  "label": "mp.y += dy",
                                                  "successors": []
                                                }
                                              ]
                                            }
                                          ]
                                        },
                                        {
                                          "id": 16,
                                          "label": "return (dst, rect)",
                                          "successors": []
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "processBackward",
      "type": "function",
      "start_line": 62,
      "end_line": 64,
      "functions": [],
      "classes": [],
      "simplified_code": "func processBackward(dst: Image, r: Rectangle, src: Image, sp: Point): Bool {\n    dst.eq(src) && r.overlaps(r + (sp - r.min)) && (sp.y < r.min.y || (sp.y == r.min.y && sp.x < r.min.x))\n}",
      "blocks": [
        {
          "id": 1,
          "label": "func processBackward(dst: Image, r: Rectangle, src: Image, sp: Point): Bool {",
          "successors": [
            {
              "id": 2,
              "label": "dst.eq(src) && r.overlaps(r + (sp - r.min)) && (sp.y < r.min.y || (sp.y == r.min.y && sp.x < r.min.x))",
              "successors": []
            }
          ]
        }
      ]
    },
    {
      "name": "draw",
      "type": "function",
      "start_line": 65,
      "end_line": 67,
      "functions": [],
      "classes": [],
      "simplified_code": "public func draw(dst: ImageI, r: Rectangle, src: Image, sp: Point, op: Op): (ImageI, Rectangle) {\n    drawMask(dst, r, src, sp, nilImage, Point(), op)\n}",
      "blocks": [
        {
          "id": 1,
          "label": "public func draw(dst: ImageI, r: Rectangle, src: Image, sp: Point, op: Op): (ImageI, Rectangle) {",
          "successors": [
            {
              "id": 2,
              "label": "    drawMask(dst, r, src, sp, nilImage, Point(), op)",
              "successors": [
                {
                  "id": 3,
                  "label": "}",
                  "successors": []
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "drawMask",
      "type": "function",
      "start_line": 68,
      "end_line": 230,
      "functions": [],
      "classes": [],
      "simplified_code": "public func drawMask(\n    dst: ImageI,\n    r: Rectangle,\n    src: Image,\n    sp: Point,\n    mask: Image,\n    mp: Point,\n    op: Op\n): (ImageI, Rectangle) {\n    var (dst0, rect0) = clip(dst, r, src, sp, mask, mp)\n    if (rect0.empty()) {\n        return (dst0, rect0)\n    }\n    var mDst: ImageI = dst0\n    var mRect: Rectangle = rect0\n    if (mDst is image.RGBA) {\n        let dstx = (mDst as image.RGBA).getOrThrow()\n        if (op == Over) {\n            if (mask is NilImage) {\n                if (src is image.Uniform) {\n                    let src0 = (src as image.Uniform).getOrThrow()\n                    let (sr, sg, sb, sa) = src0.rgba()\n                    if (sa == 0xffff) {\n                        return drawFillSrc(dstx, mRect, sr, sg, sb, sa)\n                    } else {\n                        return drawFillOver(dstx, mRect, sr, sg, sb, sa)\n                    }\n                } else if (src is image.RGBA) {\n                    let src0 = (src as image.RGBA).getOrThrow()\n                    return drawCopyOver(dstx, mRect, src0, sp)\n                } else if (src is image.NRGBA) {\n                    let src0 = (src as image.NRGBA).getOrThrow()\n                    return drawNRGBAOver(dstx, mRect, src0, sp)\n                } else if (src is image.YCbCr) {\n                    let src0 = (src as image.YCbCr).getOrThrow()\n                    if (drawYCbCr(dstx, mRect, src0, sp)) {\n                        return (dstx, mRect)\n                    }\n                } else if (src is image.Gray) {\n                    let src0 = (src as image.Gray).getOrThrow()\n                    return drawGray(dstx, mRect, src0, sp)\n                } else if (src is image.CMYK) {\n                    let src0 = (src as image.CMYK).getOrThrow()\n                    return drawCMYK(dstx, mRect, src0, sp)\n                }\n            } else if (mask is image.Alpha) {\n                if (src is image.Uniform) {\n                    let mask0 = (mask as image.Alpha).getOrThrow()\n                    let src0 = (src as image.Uniform).getOrThrow()\n                    return drawGlyphOver(dstx, mRect, src0, mask0, mp)\n                }\n            }\n        } else {\n            if (mask is NilImage) {\n                if (src is image.Uniform) {\n                    let src0 = (src as image.Uniform).getOrThrow()\n                    let (sr, sg, sb, sa) = src0.rgba()\n                    return drawFillSrc(dstx, mRect, sr, sg, sb, sa)\n                } else if (src is image.RGBA) {\n                    let src0 = (src as image.RGBA).getOrThrow()\n                    return drawCopySrc(dstx, mRect, src0, sp)\n                } else if (src is image.NRGBA) {\n                    let src0 = (src as image.NRGBA).getOrThrow()\n                    return drawNRGBASrc(dstx, mRect, src0, sp)\n                } else if (src is image.YCbCr) {\n                    let src0 = (src as image.YCbCr).getOrThrow()\n                    if (drawYCbCr(dstx, mRect, src0, sp)) {\n                        return (dstx, mRect)\n                    }\n                } else if (src is image.Gray) {\n                    let src0 = (src as image.Gray).getOrThrow()\n                    return drawGray(dstx, mRect, src0, sp)\n                } else if (src is image.CMYK) {\n                    let src0 = (src as image.CMYK).getOrThrow()\n                    return drawCMYK(dstx, mRect, src0, sp)\n                }\n            }\n        }\n        return drawRGBA(dstx, mRect, src, sp, mask, mp, op)\n    } else if (mDst is image.Paletted) {\n        let dst0 = (mDst as image.Paletted).getOrThrow()\n        if (op == Src && mask is NilImage) {\n            if (src is image.Uniform) {\n                let src0 = (src as image.Uniform).getOrThrow()\n                let colorIndex = UInt8(dst0.palette.index(src0.c))\n                var i0 = dst0.pixOffset(mRect.min.x, mRect.min.y)\n                var i1 = i0 + mRect.dx()\n                for (i in i0..i1) {\n                    dst0.pix[i] = colorIndex\n                }\n                let firstRow = dst0.pix[i0..i1]\n                for (_ in (mRect.min.y + 1)..mRect.max.y) {\n                    i0 += dst0.stride\n                    i1 += dst0.stride\n                    firstRow.copyTo(dst0.pix, 0, i0, i1 - i0)\n                }\n                return (dst0, mRect)\n            } else if (!processBackward(dst0, mRect, src, sp)) {\n                return drawPaletted(dst0, mRect, src, sp, false)\n            }\n        }\n    }\n    var x0 = mRect.min.x\n    var x1 = mRect.max.x\n    var dx = 1\n    var y0 = mRect.min.y\n    var y1 = mRect.max.y\n    var dy = 1\n    if (processBackward(mDst, mRect, src, sp)) {\n        x0 = x1 - 1\n        x1 = x0 - 1\n        dx = -1\n        y0 = y1 - 1\n        y1 = y0 - 1\n        dy = -1\n    }\n    var out: color.RGBA64C = color.RGBA64C()\n    var sy = sp.y + y0 - mRect.min.y\n    var my = mp.y + y0 - mRect.min.y\n    var y = y0\n    while (y != y1) {\n        var sx = sp.x + x0 - mRect.min.x\n        var mx = mp.x + x0 - mRect.min.x\n        var x = x0\n        while (x != x1) {\n            var ma = UInt32(m)\n            if (!(mask is NilImage)) {\n                let (_, _, _, a) = mask.at(mx, my).rgba()\n                ma = a\n            }\n            if (ma == 0) {\n                if (op != Over) {\n                    mDst.set(x, y, color.Transparent)\n                }\n            } else if (ma == m && op == Src) {\n                mDst.set(x, y, src.at(sx, sy))\n            } else {\n                let (sr, sg, sb, sa) = src.at(sx, sy).rgba()\n                if (op == Src) {\n                    let (dr, dg, db, da) = mDst.at(x, y).rgba()\n                    let a = m - (sa * ma / m)\n                    out.r = UInt16((dr * a + sr * ma) / m)\n                    out.g = UInt16((dg * a + sg * ma) / m)\n                    out.b = UInt16((db * a + sb * ma) / m)\n                    out.a = UInt16((da * a + sa * ma) / m)\n                } else {\n                    out.r = UInt16(sr * ma / m)\n                    out.g = UInt16(sg * ma / m)\n                    out.b = UInt16(sb * ma / m)\n                    out.a = UInt16(sa * ma / m)\n                }\n                mDst.set(x, y, out)\n            }\n            x += dx\n            sx += dx\n            mx += dx\n        }\n        y += dy\n        sy += dy\n        my += dy\n    }\n    (mDst, mRect)\n}",
      "blocks": [
        {
          "id": 1,
          "label": "var (dst0, rect0) = clip(dst, r, src, sp, mask, mp)",
          "successors": [
            {
              "id": 2,
              "label": "if (rect0.empty())",
              "successors": [
                {
                  "id": 3,
                  "label": "return (dst0, rect0)",
                  "successors": []
                }
              ]
            },
            {
              "id": 4,
              "label": "var mDst: ImageI = dst0\nvar mRect: Rectangle = rect0\nif (mDst is image.RGBA)",
              "successors": [
                {
                  "id": 5,
                  "label": "let dstx = (mDst as image.RGBA).getOrThrow()\nif (op == Over)",
                  "successors": [
                    {
                      "id": 6,
                      "label": "if (mask is NilImage)",
                      "successors": [
                        {
                          "id": 7,
                          "label": "if (src is image.Uniform)",
                          "successors": [
                            {
                              "id": 8,
                              "label": "let src0 = (src as image.Uniform).getOrThrow()\nlet (sr, sg, sb, sa) = src0.rgba()\nif (sa == 0xffff)",
                              "successors": [
                                {
                                  "id": 9,
                                  "label": "return drawFillSrc(dstx, mRect, sr, sg, sb, sa)",
                                  "successors": []
                                },
                                {
                                  "id": 10,
                                  "label": "return drawFillOver(dstx, mRect, sr, sg, sb, sa)",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        },
                        {
                          "id": 11,
                          "label": "else if (src is image.RGBA)",
                          "successors": [
                            {
                              "id": 12,
                              "label": "let src0 = (src as image.RGBA).getOrThrow()\nreturn drawCopyOver(dstx, mRect, src0, sp)",
                              "successors": []
                            }
                          ]
                        },
                        {
                          "id": 13,
                          "label": "else if (src is image.NRGBA)",
                          "successors": [
                            {
                              "id": 14,
                              "label": "let src0 = (src as image.NRGBA).getOrThrow()\nreturn drawNRGBAOver(dstx, mRect, src0, sp)",
                              "successors": []
                            }
                          ]
                        },
                        {
                          "id": 15,
                          "label": "else if (src is image.YCbCr)",
                          "successors": [
                            {
                              "id": 16,
                              "label": "let src0 = (src as image.YCbCr).getOrThrow()\nif (drawYCbCr(dstx, mRect, src0, sp))",
                              "successors": [
                                {
                                  "id": 17,
                                  "label": "return (dstx, mRect)",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        },
                        {
                          "id": 18,
                          "label": "else if (src is image.Gray)",
                          "successors": [
                            {
                              "id": 19,
                              "label": "let src0 = (src as image.Gray).getOrThrow()\nreturn drawGray(dstx, mRect, src0, sp)",
                              "successors": []
                            }
                          ]
                        },
                        {
                          "id": 20,
                          "label": "else if (src is image.CMYK)",
                          "successors": [
                            {
                              "id": 21,
                              "label": "let src0 = (src as image.CMYK).getOrThrow()\nreturn drawCMYK(dstx, mRect, src0, sp)",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "id": 22,
                      "label": "else if (mask is image.Alpha)",
                      "successors": [
                        {
                          "id": 23,
                          "label": "if (src is image.Uniform)",
                          "successors": [
                            {
                              "id": 24,
                              "label": "let mask0 = (mask as image.Alpha).getOrThrow()\nlet src0 = (src as image.Uniform).getOrThrow()\nreturn drawGlyphOver(dstx, mRect, src0, mask0, mp)",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "id": 25,
                  "label": "else",
                  "successors": [
                    {
                      "id": 26,
                      "label": "if (mask is NilImage)",
                      "successors": [
                        {
                          "id": 27,
                          "label": "if (src is image.Uniform)",
                          "successors": [
                            {
                              "id": 28,
                              "label": "let src0 = (src as image.Uniform).getOrThrow()\nlet (sr, sg, sb, sa) = src0.rgba()\nreturn drawFillSrc(dstx, mRect, sr, sg, sb, sa)",
                              "successors": []
                            }
                          ]
                        },
                        {
                          "id": 29,
                          "label": "else if (src is image.RGBA)",
                          "successors": [
                            {
                              "id": 30,
                              "label": "let src0 = (src as image.RGBA).getOrThrow()\nreturn drawCopySrc(dstx, mRect, src0, sp)",
                              "successors": []
                            }
                          ]
                        },
                        {
                          "id": 31,
                          "label": "else if (src is image.NRGBA)",
                          "successors": [
                            {
                              "id": 32,
                              "label": "let src0 = (src as image.NRGBA).getOrThrow()\nreturn drawNRGBASrc(dstx, mRect, src0, sp)",
                              "successors": []
                            }
                          ]
                        },
                        {
                          "id": 33,
                          "label": "else if (src is image.YCbCr)",
                          "successors": [
                            {
                              "id": 34,
                              "label": "let src0 = (src as image.YCbCr).getOrThrow()\nif (drawYCbCr(dstx, mRect, src0, sp))",
                              "successors": [
                                {
                                  "id": 35,
                                  "label": "return (dstx, mRect)",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        },
                        {
                          "id": 36,
                          "label": "else if (src is image.Gray)",
                          "successors": [
                            {
                              "id": 37,
                              "label": "let src0 = (src as image.Gray).getOrThrow()\nreturn drawGray(dstx, mRect, src0, sp)",
                              "successors": []
                            }
                          ]
                        },
                        {
                          "id": 38,
                          "label": "else if (src is image.CMYK)",
                          "successors": [
                            {
                              "id": 39,
                              "label": "let src0 = (src as image.CMYK).getOrThrow()\nreturn drawCMYK(dstx, mRect, src0, sp)",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "id": 40,
                  "label": "return drawRGBA(dstx, mRect, src, sp, mask, mp, op)",
                  "successors": []
                }
              ]
            },
            {
              "id": 41,
              "label": "else if (mDst is image.Paletted)",
              "successors": [
                {
                  "id": 42,
                  "label": "let dst0 = (mDst as image.Paletted).getOrThrow()\nif (op == Src && mask is NilImage)",
                  "successors": [
                    {
                      "id": 43,
                      "label": "if (src is image.Uniform)",
                      "successors": [
                        {
                          "id": 44,
                          "label": "let src0 = (src as image.Uniform).getOrThrow()\nlet colorIndex = UInt8(dst0.palette.index(src0.c))\nvar i0 = dst0.pixOffset(mRect.min.x, mRect.min.y)\nvar i1 = i0 + mRect.dx()\nfor (i in i0..i1)",
                          "successors": [
                            {
                              "id": 45,
                              "label": "dst0.pix[i] = colorIndex\nlet firstRow = dst0.pix[i0..i1]\nfor (_ in (mRect.min.y + 1)..mRect.max.y)",
                              "successors": [
                                {
                                  "id": 46,
                                  "label": "i0 += dst0.stride\ni1 += dst0.stride\nfirstRow.copyTo(dst0.pix, 0, i0, i1 - i0)",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        },
                        {
                          "id": 47,
                          "label": "return (dst0, mRect)",
                          "successors": []
                        }
                      ]
                    },
                    {
                      "id": 48,
                      "label": "else if (!processBackward(dst0, mRect, src, sp))",
                      "successors": [
                        {
                          "id": 49,
                          "label": "return drawPaletted(dst0, mRect, src, sp, false)",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "id": 50,
              "label": "var x0 = mRect.min.x\nvar x1 = mRect.max.x\nvar dx = 1\nvar y0 = mRect.min.y\nvar y1 = mRect.max.y\nvar dy = 1\nif (processBackward(mDst, mRect, src, sp))",
              "successors": [
                {
                  "id": 51,
                  "label": "x0 = x1 - 1\nx1 = x0 - 1\ndx = -1\ny0 = y1 - 1\ny1 = y0 - 1\ndy = -1",
                  "successors": []
                }
              ]
            },
            {
              "id": 52,
              "label": "var out: color.RGBA64C = color.RGBA64C()\nvar sy = sp.y + y0 - mRect.min.y\nvar my = mp.y + y0 - mRect.min.y\nvar y = y0\nwhile (y != y1)",
              "successors": [
                {
                  "id": 53,
                  "label": "var sx = sp.x + x0 - mRect.min.x\nvar mx = mp.x + x0 - mRect.min.x\nvar x = x0\nwhile (x != x1)",
                  "successors": [
                    {
                      "id": 54,
                      "label": "var ma = UInt32(m)\nif (!(mask is NilImage))",
                      "successors": [
                        {
                          "id": 55,
                          "label": "let (_, _, _, a) = mask.at(mx, my).rgba()\nma = a",
                          "successors": []
                        }
                      ]
                    },
                    {
                      "id": 56,
                      "label": "if (ma == 0)",
                      "successors": [
                        {
                          "id": 57,
                          "label": "if (op != Over)\nmDst.set(x, y, color.Transparent)",
                          "successors": []
                        }
                      ]
                    },
                    {
                      "id": 58,
                      "label": "else if (ma == m && op == Src)",
                      "successors": [
                        {
                          "id": 59,
                          "label": "mDst.set(x, y, src.at(sx, sy))",
                          "successors": []
                        }
                      ]
                    },
                    {
                      "id": 60,
                      "label": "else",
                      "successors": [
                        {
                          "id": 61,
                          "label": "let (sr, sg, sb, sa) = src.at(sx, sy).rgba()\nif (op == Src)",
                          "successors": [
                            {
                              "id": 62,
                              "label": "let (dr, dg, db, da) = mDst.at(x, y).rgba()\nlet a = m - (sa * ma / m)\nout.r = UInt16((dr * a + sr * ma) / m)\nout.g = UInt16((dg * a + sg * ma) / m)\nout.b = UInt16((db * a + sb * ma) / m)\nout.a = UInt16((da * a + sa * ma) / m)",
                              "successors": []
                            }
                          ]
                        },
                        {
                          "id": 63,
                          "label": "else",
                          "successors": [
                            {
                              "id": 64,
                              "label": "out.r = UInt16(sr * ma / m)\nout.g = UInt16(sg * ma / m)\nout.b = UInt16(sb * ma / m)\nout.a = UInt16(sa * ma / m)",
                              "successors": []
                            }
                          ]
                        },
                        {
                          "id": 65,
                          "label": "mDst.set(x, y, out)",
                          "successors": []
                        }
                      ]
                    },
                    {
                      "id": 66,
                      "label": "x += dx\nsx += dx\nmx += dx",
                      "successors": []
                    }
                  ]
                },
                {
                  "id": 67,
                  "label": "y += dy\nsy += dy\nmy += dy",
                  "successors": []
                }
              ]
            },
            {
              "id": 68,
              "label": "(mDst, mRect)",
              "successors": []
            }
          ]
        }
      ]
    },
    {
      "name": "drawFillOver",
      "type": "function",
      "start_line": 232,
      "end_line": 252,
      "functions": [],
      "classes": [],
      "simplified_code": "func drawFillOver(dst: image.RGBA, r: Rectangle, sr: UInt32, sg: UInt32, sb: UInt32, sa: UInt32): (image.RGBA, Rectangle) {\n    // The 0x101 is here for the same reason as in drawRGBA.\n    let a = (m - sa) * 0x101\n    var i0 = dst.pixOffset(r.min.x, r.min.y)\n    var i1 = i0 + r.dx() * 4\n    for (_ in r.min.y..r.max.y) {\n        for (i in i0..i1 : 4) {\n            let dr = dst.pix[i + 0]\n            let dg = dst.pix[i + 1]\n            let db = dst.pix[i + 2]\n            let da = dst.pix[i + 3]\n            dst.pix[i + 0] = UInt8((UInt32(dr) * a / m + sr) >> 8)\n            dst.pix[i + 1] = UInt8((UInt32(dg) * a / m + sg) >> 8)\n            dst.pix[i + 2] = UInt8((UInt32(db) * a / m + sb) >> 8)\n            dst.pix[i + 3] = UInt8((UInt32(da) * a / m + sa) >> 8)\n        }\n        i0 += dst.stride\n        i1 += dst.stride\n    }\n    (dst, r)\n}",
      "blocks": [
        {
          "id": 1,
          "label": "func drawFillOver(dst: image.RGBA, r: Rectangle, sr: UInt32, sg: UInt32, sb: UInt32, sa: UInt32): (image.RGBA, Rectangle) {",
          "successors": [
            {
              "id": 2,
              "label": "    let a = (m - sa) * 0x101",
              "successors": [
                {
                  "id": 3,
                  "label": "    var i0 = dst.pixOffset(r.min.x, r.min.y)",
                  "successors": [
                    {
                      "id": 4,
                      "label": "    var i1 = i0 + r.dx() * 4",
                      "successors": [
                        {
                          "id": 5,
                          "label": "    for (_ in r.min.y..r.max.y) {",
                          "successors": [
                            {
                              "id": 6,
                              "label": "        for (i in i0..i1 : 4) {",
                              "successors": [
                                {
                                  "id": 7,
                                  "label": "            let dr = dst.pix[i + 0]",
                                  "successors": [
                                    {
                                      "id": 8,
                                      "label": "            let dg = dst.pix[i + 1]",
                                      "successors": [
                                        {
                                          "id": 9,
                                          "label": "            let db = dst.pix[i + 2]",
                                          "successors": [
                                            {
                                              "id": 10,
                                              "label": "            let da = dst.pix[i + 3]",
                                              "successors": [
                                                {
                                                  "id": 11,
                                                  "label": "            dst.pix[i + 0] = UInt8((UInt32(dr) * a / m + sr) >> 8)",
                                                  "successors": [
                                                    {
                                                      "id": 12,
                                                      "label": "            dst.pix[i + 1] = UInt8((UInt32(dg) * a / m + sg) >> 8)",
                                                      "successors": [
                                                        {
                                                          "id": 13,
                                                          "label": "            dst.pix[i + 2] = UInt8((UInt32(db) * a / m + sb) >> 8)",
                                                          "successors": [
                                                            {
                                                              "id": 14,
                                                              "label": "            dst.pix[i + 3] = UInt8((UInt32(da) * a / m + sa) >> 8)",
                                                              "successors": []
                                                            }
                                                          ]
                                                        }
                                                      ]
                                                    }
                                                  ]
                                                }
                                              ]
                                            }
                                          ]
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            },
                            {
                              "id": 15,
                              "label": "        i0 += dst.stride",
                              "successors": [
                                {
                                  "id": 16,
                                  "label": "        i1 += dst.stride",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        },
                        {
                          "id": 17,
                          "label": "    (dst, r)",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "drawFillSrc",
      "type": "function",
      "start_line": 254,
      "end_line": 277,
      "functions": [],
      "classes": [],
      "simplified_code": "func drawFillSrc(dst: image.RGBA, r: Rectangle, sr: UInt32, sg: UInt32, sb: UInt32, sa: UInt32): (image.RGBA, Rectangle) {\n    let sr8 = UInt8(sr >> 8)\n    let sg8 = UInt8(sg >> 8)\n    let sb8 = UInt8(sb >> 8)\n    let sa8 = UInt8(sa >> 8)\n    // The built-in copy function is faster than a straightforward for loop to fill the destination with\n    // the color, but copy requires a slice source. We therefore use a for loop to fill the first row, and\n    // then use the first row as the slice source for the remaining rows.\n    var i0 = dst.pixOffset(r.min.x, r.min.y)\n    var i1 = i0 + r.dx() * 4\n    for (i in i0..i1 : 4) {\n        dst.pix[i + 0] = sr8\n        dst.pix[i + 1] = sg8\n        dst.pix[i + 2] = sb8\n        dst.pix[i + 3] = sa8\n    }\n    let firstRow = dst.pix[i0..i1]\n    for (_ in (r.min.y + 1)..r.max.y) {\n        i0 += dst.stride\n        i1 += dst.stride\n        firstRow.copyTo(dst.pix, 0, i0, firstRow.size)\n    }\n    (dst, r)\n}",
      "blocks": [
        {
          "id": 1,
          "label": "func drawFillSrc(dst: image.RGBA, r: Rectangle, sr: UInt32, sg: UInt32, sb: UInt32, sa: UInt32): (image.RGBA, Rectangle) {",
          "successors": [
            {
              "id": 2,
              "label": "let sr8 = UInt8(sr >> 8)\nlet sg8 = UInt8(sg >> 8)\nlet sb8 = UInt8(sb >> 8)\nlet sa8 = UInt8(sa >> 8)",
              "successors": [
                {
                  "id": 3,
                  "label": "var i0 = dst.pixOffset(r.min.x, r.min.y)\nvar i1 = i0 + r.dx() * 4",
                  "successors": [
                    {
                      "id": 4,
                      "label": "for (i in i0..i1 : 4) {",
                      "successors": [
                        {
                          "id": 5,
                          "label": "dst.pix[i + 0] = sr8\ndst.pix[i + 1] = sg8\ndst.pix[i + 2] = sb8\ndst.pix[i + 3] = sa8",
                          "successors": [
                            {
                              "id": 6,
                              "label": "}",
                              "successors": [
                                {
                                  "id": 7,
                                  "label": "let firstRow = dst.pix[i0..i1]",
                                  "successors": [
                                    {
                                      "id": 8,
                                      "label": "for (_ in (r.min.y + 1)..r.max.y) {",
                                      "successors": [
                                        {
                                          "id": 9,
                                          "label": "i0 += dst.stride\ni1 += dst.stride\nfirstRow.copyTo(dst.pix, 0, i0, firstRow.size)",
                                          "successors": [
                                            {
                                              "id": 10,
                                              "label": "}",
                                              "successors": [
                                                {
                                                  "id": 11,
                                                  "label": "(dst, r)",
                                                  "successors": [
                                                    {
                                                      "id": 12,
                                                      "label": "}",
                                                      "successors": []
                                                    }
                                                  ]
                                                }
                                              ]
                                            }
                                          ]
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "drawCopyOver",
      "type": "function",
      "start_line": 279,
      "end_line": 325,
      "functions": [],
      "classes": [],
      "simplified_code": "func drawCopyOver(dst: image.RGBA, r: Rectangle, src: image.RGBA, sp: Point): (image.RGBA, Rectangle) {\n    let dx = r.dx()\n    var dy = r.dy()\n    var d0 = dst.pixOffset(r.min.x, r.min.y)\n    var s0 = src.pixOffset(sp.x, sp.y)\n    var ddelta = 0\n    var sdelta = 0\n    var idelta = 0\n    var i0 = 0\n    var i1 = 0\n    if (r.min.y < sp.y || r.min.y == sp.y && r.min.x <= sp.x) {\n        ddelta = dst.stride\n        sdelta = src.stride\n        i0 = 0\n        i1 = dx * 4\n        idelta = 4\n    } else {\n        // If the source start point is higher than the destination start point, or equal height but to the left,\n        // then we compose the rows in right-to-left, bottom-up order instead of left-to-right, top-down.\n        d0 += (dy - 1) * dst.stride\n        s0 += (dy - 1) * src.stride\n        ddelta = -dst.stride\n        sdelta = -src.stride\n        i0 = (dx - 1) * 4\n        i1 = -4\n        idelta = -4\n    }\n    let dpix = dst.pix\n    let spix = src.pix\n    while (dy > 0) {\n        var i = i0\n        while (i != i1) {\n            let sr = UInt32(spix[s0 + i + 0]) * 0x101\n            let sg = UInt32(spix[s0 + i + 1]) * 0x101\n            let sb = UInt32(spix[s0 + i + 2]) * 0x101\n            let sa = UInt32(spix[s0 + i + 3]) * 0x101\n            let a = (m - sa) * 0x101\n            dpix[d0 + i + 0] = UInt8((UInt32(dpix[d0 + i + 0]) * a / m + sr) >> 8)\n            dpix[d0 + i + 1] = UInt8((UInt32(dpix[d0 + i + 1]) * a / m + sg) >> 8)\n            dpix[d0 + i + 2] = UInt8((UInt32(dpix[d0 + i + 2]) * a / m + sb) >> 8)\n            dpix[d0 + i + 3] = UInt8((UInt32(dpix[d0 + i + 3]) * a / m + sa) >> 8)\n            i += idelta\n        }\n        dy--\n    }\n    (dst, r)\n}",
      "blocks": [
        {
          "id": 1,
          "label": "func drawCopyOver(dst: image.RGBA, r: Rectangle, src: image.RGBA, sp: Point): (image.RGBA, Rectangle) {",
          "successors": [
            {
              "id": 2,
              "label": "let dx = r.dx()",
              "successors": [
                {
                  "id": 3,
                  "label": "var dy = r.dy()",
                  "successors": [
                    {
                      "id": 4,
                      "label": "var d0 = dst.pixOffset(r.min.x, r.min.y)",
                      "successors": [
                        {
                          "id": 5,
                          "label": "var s0 = src.pixOffset(sp.x, sp.y)",
                          "successors": [
                            {
                              "id": 6,
                              "label": "var ddelta = 0",
                              "successors": [
                                {
                                  "id": 7,
                                  "label": "var sdelta = 0",
                                  "successors": [
                                    {
                                      "id": 8,
                                      "label": "var idelta = 0",
                                      "successors": [
                                        {
                                          "id": 9,
                                          "label": "var i0 = 0",
                                          "successors": [
                                            {
                                              "id": 10,
                                              "label": "var i1 = 0",
                                              "successors": [
                                                {
                                                  "id": 11,
                                                  "label": "if (r.min.y < sp.y || r.min.y == sp.y && r.min.x <= sp.x) {",
                                                  "successors": [
                                                    {
                                                      "id": 12,
                                                      "label": "ddelta = dst.stride",
                                                      "successors": [
                                                        {
                                                          "id": 13,
                                                          "label": "sdelta = src.stride",
                                                          "successors": [
                                                            {
                                                              "id": 14,
                                                              "label": "i0 = 0",
                                                              "successors": [
                                                                {
                                                                  "id": 15,
                                                                  "label": "i1 = dx * 4",
                                                                  "successors": [
                                                                    {
                                                                      "id": 16,
                                                                      "label": "idelta = 4",
                                                                      "successors": [
                                                                        {
                                                                          "id": 17,
                                                                          "label": "} else {",
                                                                          "successors": [
                                                                            {
                                                                              "id": 18,
                                                                              "label": "d0 += (dy - 1) * dst.stride",
                                                                              "successors": [
                                                                                {
                                                                                  "id": 19,
                                                                                  "label": "s0 += (dy - 1) * src.stride",
                                                                                  "successors": [
                                                                                    {
                                                                                      "id": 20,
                                                                                      "label": "ddelta = -dst.stride",
                                                                                      "successors": [
                                                                                        {
                                                                                          "id": 21,
                                                                                          "label": "sdelta = -src.stride",
                                                                                          "successors": [
                                                                                            {
                                                                                              "id": 22,
                                                                                              "label": "i0 = (dx - 1) * 4",
                                                                                              "successors": [
                                                                                                {
                                                                                                  "id": 23,
                                                                                                  "label": "i1 = -4",
                                                                                                  "successors": [
                                                                                                    {
                                                                                                      "id": 24,
                                                                                                      "label": "idelta = -4",
                                                                                                      "successors": [
                                                                                                        {
                                                                                                          "id": 25,
                                                                                                          "label": "}",
                                                                                                          "successors": [
                                                                                                            {
                                                                                                              "id": 26,
                                                                                                              "label": "let dpix = dst.pix",
                                                                                                              "successors": [
                                                                                                                {
                                                                                                                  "id": 27,
                                                                                                                  "label": "let spix = src.pix",
                                                                                                                  "successors": [
                                                                                                                    {
                                                                                                                      "id": 28,
                                                                                                                      "label": "while (dy > 0) {",
                                                                                                                      "successors": [
                                                                                                                        {
                                                                                                                          "id": 29,
                                                                                                                          "label": "var i = i0",
                                                                                                                          "successors": [
                                                                                                                            {
                                                                                                                              "id": 30,
                                                                                                                              "label": "while (i != i1) {",
                                                                                                                              "successors": [
                                                                                                                                {
                                                                                                                                  "id": 31,
                                                                                                                                  "label": "let sr = UInt32(spix[s0 + i + 0]) * 0x101",
                                                                                                                                  "successors": [
                                                                                                                                    {
                                                                                                                                      "id": 32,
                                                                                                                                      "label": "let sg = UInt32(spix[s0 + i + 1]) * 0x101",
                                                                                                                                      "successors": [
                                                                                                                                        {
                                                                                                                                          "id": 33,
                                                                                                                                          "label": "let sb = UInt32(spix[s0 + i + 2]) * 0x101",
                                                                                                                                          "successors": [
                                                                                                                                            {
                                                                                                                                              "id": 34,
                                                                                                                                              "label": "let sa = UInt32(spix[s0 + i + 3]) * 0x101",
                                                                                                                                              "successors": [
                                                                                                                                                {
                                                                                                                                                  "id": 35,
                                                                                                                                                  "label": "let a = (m - sa) * 0x101",
                                                                                                                                                  "successors": [
                                                                                                                                                    {
                                                                                                                                                      "id": 36,
                                                                                                                                                      "label": "dpix[d0 + i + 0] = UInt8((UInt32(dpix[d0 + i + 0]) * a / m + sr) >> 8)",
                                                                                                                                                      "successors": [
                                                                                                                                                        {
                                                                                                                                                          "id": 37,
                                                                                                                                                          "label": "dpix[d0 + i + 1] = UInt8((UInt32(dpix[d0 + i + 1]) * a / m + sg) >> 8)",
                                                                                                                                                          "successors": [
                                                                                                                                                            {
                                                                                                                                                              "id": 38,
                                                                                                                                                              "label": "dpix[d0 + i + 2] = UInt8((UInt32(dpix[d0 + i + 2]) * a / m + sb) >> 8)",
                                                                                                                                                              "successors": [
                                                                                                                                                                {
                                                                                                                                                                  "id": 39,
                                                                                                                                                                  "label": "dpix[d0 + i + 3] = UInt8((UInt32(dpix[d0 + i + 3]) * a / m + sa) >> 8)",
                                                                                                                                                                  "successors": [
                                                                                                                                                                    {
                                                                                                                                                                      "id": 40,
                                                                                                                                                                      "label": "i += idelta",
                                                                                                                                                                      "successors": []
                                                                                                                                                                    }
                                                                                                                                                                  ]
                                                                                                                                                                }
                                                                                                                                                              ]
                                                                                                                                                            }
                                                                                                                                                          ]
                                                                                                                                                        }
                                                                                                                                                      ]
                                                                                                                                                    }
                                                                                                                                                  ]
                                                                                                                                                }
                                                                                                                                              ]
                                                                                                                                            }
                                                                                                                                          ]
                                                                                                                                        }
                                                                                                                                      ]
                                                                                                                                    }
                                                                                                                                  ]
                                                                                                                                }
                                                                                                                              ]
                                                                                                                            },
                                                                                                                            {
                                                                                                                              "id": 41,
                                                                                                                              "label": "dy--",
                                                                                                                              "successors": []
                                                                                                                            }
                                                                                                                          ]
                                                                                                                        }
                                                                                                                      ]
                                                                                                                    },
                                                                                                                    {
                                                                                                                      "id": 42,
                                                                                                                      "label": "(dst, r)",
                                                                                                                      "successors": []
                                                                                                                    }
                                                                                                                  ]
                                                                                                                }
                                                                                                              ]
                                                                                                            }
                                                                                                          ]
                                                                                                        }
                                                                                                      ]
                                                                                                    }
                                                                                                  ]
                                                                                                }
                                                                                              ]
                                                                                            }
                                                                                          ]
                                                                                        }
                                                                                      ]
                                                                                    }
                                                                                  ]
                                                                                }
                                                                              ]
                                                                            }
                                                                          ]
                                                                        }
                                                                      ]
                                                                    }
                                                                  ]
                                                                }
                                                              ]
                                                            }
                                                          ]
                                                        }
                                                      ]
                                                    }
                                                  ]
                                                }
                                              ]
                                            }
                                          ]
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "drawCopySrc",
      "type": "function",
      "start_line": 326,
      "end_line": 350,
      "functions": [],
      "classes": [],
      "simplified_code": "func drawCopySrc(dst: image.RGBA, r: Rectangle, src: image.RGBA, sp: Point): (image.RGBA, Rectangle) {\n    let n = 4 * r.dx()\n    var dy = r.dy()\n    var d0 = dst.pixOffset(r.min.x, r.min.y)\n    var s0 = src.pixOffset(sp.x, sp.y)\n    var ddelta = 0\n    var sdelta = 0\n    if (r.min.y <= sp.y) {\n        ddelta = dst.stride\n        sdelta = src.stride\n    } else {\n        d0 += (dy - 1) * dst.stride\n        s0 += (dy - 1) * src.stride\n        ddelta = -dst.stride\n        sdelta = -src.stride\n    }\n    while (dy > 0) {\n        for (i in 0..n) {\n            dst.pix[d0 + i] = src.pix[s0 + i]\n        }\n        d0 += ddelta\n        s0 += sdelta\n        dy--\n    }\n    (dst, r)",
      "blocks": [
        {
          "id": 1,
          "label": "let n = 4 * r.dx()\nvar dy = r.dy()\nvar d0 = dst.pixOffset(r.min.x, r.min.y)\nvar s0 = src.pixOffset(sp.x, sp.y)\nvar ddelta = 0\nvar sdelta = 0",
          "successors": [
            {
              "id": 2,
              "label": "if (r.min.y <= sp.y):",
              "successors": [
                {
                  "id": 3,
                  "label": "    ddelta = dst.stride\n    sdelta = src.stride",
                  "successors": [
                    {
                      "id": 5,
                      "label": "while (dy > 0):",
                      "successors": [
                        {
                          "id": 6,
                          "label": "    for (i in 0..n):\n        dst.pix[d0 + i] = src.pix[s0 + i]",
                          "successors": [
                            {
                              "id": 7,
                              "label": "    d0 += ddelta\n    s0 += sdelta\n    dy--",
                              "successors": [
                                {
                                  "id": 5,
                                  "label": "while (dy > 0):",
                                  "successors": [
                                    {
                                      "id": 6,
                                      "label": "    for (i in 0..n):\n        dst.pix[d0 + i] = src.pix[s0 + i]",
                                      "successors": [
                                        {
                                          "id": 7,
                                          "label": "    d0 += ddelta\n    s0 += sdelta\n    dy--",
                                          "successors": []
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "id": 4,
                  "label": "    d0 += (dy - 1) * dst.stride\n    s0 += (dy - 1) * src.stride\n    ddelta = -dst.stride\n    sdelta = -src.stride",
                  "successors": [
                    {
                      "id": 5,
                      "label": "while (dy > 0):",
                      "successors": [
                        {
                          "id": 6,
                          "label": "    for (i in 0..n):\n        dst.pix[d0 + i] = src.pix[s0 + i]",
                          "successors": [
                            {
                              "id": 7,
                              "label": "    d0 += ddelta\n    s0 += sdelta\n    dy--",
                              "successors": [
                                {
                                  "id": 5,
                                  "label": "while (dy > 0):",
                                  "successors": [
                                    {
                                      "id": 6,
                                      "label": "    for (i in 0..n):\n        dst.pix[d0 + i] = src.pix[s0 + i]",
                                      "successors": [
                                        {
                                          "id": 7,
                                          "label": "    d0 += ddelta\n    s0 += sdelta\n    dy--",
                                          "successors": []
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "id": 8,
          "label": "(dst, r)",
          "successors": []
        }
      ]
    },
    {
      "name": "drawNRGBAOver",
      "type": "function",
      "start_line": 353,
      "end_line": 384,
      "functions": [],
      "classes": [],
      "simplified_code": "func drawNRGBAOver(dst: image.RGBA, r: Rectangle, src: image.NRGBA, sp: Point): (image.RGBA, Rectangle) {\n    let i0 = (r.min.x - dst.rect.min.x) * 4\n    let i1 = (r.max.x - dst.rect.min.x) * 4\n    let si0 = (sp.x - src.rect.min.x) * 4\n    let yMax = r.max.y - dst.rect.min.y\n    var y = r.min.y - dst.rect.min.y\n    var sy = sp.y - src.rect.min.y\n    let dpix = dst.pix\n    let spix = src.pix\n    while (y != yMax) {\n        let dpis = y * dst.stride\n        let spis = sy * src.stride\n        var i = i0\n        var si = si0\n        while (i < i1) {\n            let sa = UInt32(spix[spis + i + 3]) * 0x101\n            let sr = UInt32(spix[spis + i + 0]) * sa / 0xff\n            let sg = UInt32(spix[spis + i + 1]) * sa / 0xff\n            let sb = UInt32(spix[spis + i + 2]) * sa / 0xff\n            let a = (m - sa) * 0x101\n            dpix[dpis + i + 0] = UInt8((UInt32(dpix[dpis + i + 0]) * a / m + sr) >> 8)\n            dpix[dpis + i + 1] = UInt8((UInt32(dpix[dpis + i + 1]) * a / m + sg) >> 8)\n            dpix[dpis + i + 2] = UInt8((UInt32(dpix[dpis + i + 2]) * a / m + sb) >> 8)\n            dpix[dpis + i + 3] = UInt8((UInt32(dpix[dpis + i + 3]) * a / m + sa) >> 8)\n            i += 4\n            si += 4\n        }\n        y++\n        sy++\n    }\n    (dst, r)\n}",
      "blocks": [
        {
          "id": 1,
          "label": "func drawNRGBAOver(dst: image.RGBA, r: Rectangle, src: image.NRGBA, sp: Point): (image.RGBA, Rectangle) {",
          "successors": [
            {
              "id": 2,
              "label": "let i0 = (r.min.x - dst.rect.min.x) * 4\nlet i1 = (r.max.x - dst.rect.min.x) * 4\nlet si0 = (sp.x - src.rect.min.x) * 4\nlet yMax = r.max.y - dst.rect.min.y\nvar y = r.min.y - dst.rect.min.y\nvar sy = sp.y - src.rect.min.y\nlet dpix = dst.pix\nlet spix = src.pix",
              "successors": [
                {
                  "id": 3,
                  "label": "while (y != yMax) {",
                  "successors": [
                    {
                      "id": 4,
                      "label": "let dpis = y * dst.stride\nlet spis = sy * src.stride\nvar i = i0\nvar si = si0",
                      "successors": [
                        {
                          "id": 5,
                          "label": "while (i < i1) {",
                          "successors": [
                            {
                              "id": 6,
                              "label": "let sa = UInt32(spix[spis + i + 3]) * 0x101\nlet sr = UInt32(spix[spis + i + 0]) * sa / 0xff\nlet sg = UInt32(spix[spis + i + 1]) * sa / 0xff\nlet sb = UInt32(spix[spis + i + 2]) * sa / 0xff\nlet a = (m - sa) * 0x101\ndpix[dpis + i + 0] = UInt8((UInt32(dpix[dpis + i + 0]) * a / m + sr) >> 8)\ndpix[dpis + i + 1] = UInt8((UInt32(dpix[dpis + i + 1]) * a / m + sg) >> 8)\ndpix[dpis + i + 2] = UInt8((UInt32(dpix[dpis + i + 2]) * a / m + sb) >> 8)\ndpix[dpis + i + 3] = UInt8((UInt32(dpix[dpis + i + 3]) * a / m + sa) >> 8)\ni += 4\nsi += 4",
                              "successors": [
                                {
                                  "id": 5,
                                  "label": "while (i < i1) {",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        },
                        {
                          "id": 3,
                          "label": "while (y != yMax) {",
                          "successors": [
                            {
                              "id": 7,
                              "label": "y++\nsy++",
                              "successors": [
                                {
                                  "id": 3,
                                  "label": "while (y != yMax) {",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "id": 8,
                  "label": "(dst, r)",
                  "successors": []
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "drawNRGBASrc",
      "type": "function",
      "start_line": 386,
      "end_line": 415,
      "functions": [],
      "classes": [],
      "simplified_code": "func drawNRGBASrc(dst: image.RGBA, r: Rectangle, src: image.NRGBA, sp: Point): (image.RGBA, Rectangle) {\n    let i0 = (r.min.x - dst.rect.min.x) * 4\n    let i1 = (r.max.x - dst.rect.min.x) * 4\n    let si0 = (sp.x - src.rect.min.x) * 4\n    let yMax = r.max.y - dst.rect.min.y\n    var y = r.min.y - dst.rect.min.y\n    var sy = sp.y - src.rect.min.y\n    let dpix = dst.pix\n    let spix = src.pix\n    while (y != yMax) {\n        let dpis = y * dst.stride\n        let spis = sy * src.stride\n        var i = i0\n        var si = si0\n        while (i < i1) {\n            let sa = UInt32(spix[spis + i + 3]) * 0x101\n            let sr = UInt32(spix[spis + i + 0]) * sa / 0xff\n            let sg = UInt32(spix[spis + i + 1]) * sa / 0xff\n            let sb = UInt32(spix[spis + i + 2]) * sa / 0xff\n            dpix[dpis + i + 0] = UInt8(sr >> 8)\n            dpix[dpis + i + 1] = UInt8(sg >> 8)\n            dpix[dpis + i + 2] = UInt8(sb >> 8)\n            dpix[dpis + i + 3] = UInt8(sa >> 8)\n            i += 4\n            si += 4\n        }\n        y++\n        sy++\n    }\n    (dst, r)",
      "blocks": [
        {
          "id": 1,
          "label": "func drawNRGBASrc(dst: image.RGBA, r: Rectangle, src: image.NRGBA, sp: Point): (image.RGBA, Rectangle) {",
          "successors": [
            {
              "id": 2,
              "label": "let i0 = (r.min.x - dst.rect.min.x) * 4\nlet i1 = (r.max.x - dst.rect.min.x) * 4\nlet si0 = (sp.x - src.rect.min.x) * 4\nlet yMax = r.max.y - dst.rect.min.y\nvar y = r.min.y - dst.rect.min.y\nvar sy = sp.y - src.rect.min.y\nlet dpix = dst.pix\nlet spix = src.pix",
              "successors": [
                {
                  "id": 3,
                  "label": "while (y != yMax) {",
                  "successors": [
                    {
                      "id": 4,
                      "label": "let dpis = y * dst.stride\nlet spis = sy * src.stride\nvar i = i0\nvar si = si0",
                      "successors": [
                        {
                          "id": 5,
                          "label": "while (i < i1) {",
                          "successors": [
                            {
                              "id": 6,
                              "label": "let sa = UInt32(spix[spis + i + 3]) * 0x101\nlet sr = UInt32(spix[spis + i + 0]) * sa / 0xff\nlet sg = UInt32(spix[spis + i + 1]) * sa / 0xff\nlet sb = UInt32(spix[spis + i + 2]) * sa / 0xff\ndpix[dpis + i + 0] = UInt8(sr >> 8)\ndpix[dpis + i + 1] = UInt8(sg >> 8)\ndpix[dpis + i + 2] = UInt8(sb >> 8)\ndpix[dpis + i + 3] = UInt8(sa >> 8)\ni += 4\nsi += 4",
                              "successors": [
                                {
                                  "id": 5,
                                  "label": "while (i < i1) {",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        },
                        {
                          "id": 7,
                          "label": "y++\nsy++",
                          "successors": [
                            {
                              "id": 3,
                              "label": "while (y != yMax) {",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "id": 8,
                  "label": "(dst, r)",
                  "successors": []
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "drawGray",
      "type": "function",
      "start_line": 417,
      "end_line": 443,
      "functions": [],
      "classes": [],
      "simplified_code": "func drawGray(dst: image.RGBA, r: Rectangle, src: image.Gray, sp: Point): (image.RGBA, Rectangle) {\n    let i0 = (r.min.x - dst.rect.min.x) * 4\n    let i1 = (r.max.x - dst.rect.min.x) * 4\n    let si0 = (sp.x - src.rect.min.x) * 1\n    let yMax = r.max.y - dst.rect.min.y\n    var y = r.min.y - dst.rect.min.y\n    var sy = sp.y - src.rect.min.y\n    let dpix = dst.pix\n    let spix = src.pix\n    while (y != yMax) {\n        let dpis = y * dst.stride\n        let spis = sy * src.stride\n        var i = i0\n        var si = si0\n        while (i < i1) {\n            let p = spix[spis + i + si]\n            dpix[dpis + i + 0] = p\n            dpix[dpis + i + 1] = p\n            dpix[dpis + i + 2] = p\n            dpix[dpis + i + 3] = 255\n            i += 4\n            si += 4\n        }\n        y++\n        sy++\n    }\n    (dst, r)",
      "blocks": [
        {
          "id": 1,
          "label": "let i0 = (r.min.x - dst.rect.min.x) * 4\nlet i1 = (r.max.x - dst.rect.min.x) * 4\nlet si0 = (sp.x - src.rect.min.x) * 1\nlet yMax = r.max.y - dst.rect.min.y\nvar y = r.min.y - dst.rect.min.y\nvar sy = sp.y - src.rect.min.y\nlet dpix = dst.pix\nlet spix = src.pix",
          "successors": [
            {
              "id": 2,
              "label": "while (y != yMax)",
              "successors": [
                {
                  "id": 3,
                  "label": "let dpis = y * dst.stride\nlet spis = sy * src.stride\nvar i = i0\nvar si = si0",
                  "successors": [
                    {
                      "id": 4,
                      "label": "while (i < i1)",
                      "successors": [
                        {
                          "id": 5,
                          "label": "let p = spix[spis + i + si]\ndpix[dpis + i + 0] = p\ndpix[dpis + i + 1] = p\ndpix[dpis + i + 2] = p\ndpix[dpis + i + 3] = 255\ni += 4\nsi += 4",
                          "successors": [
                            {
                              "id": 4,
                              "label": "while (i < i1)",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "id": 6,
                      "label": "y++\nsy++",
                      "successors": [
                        {
                          "id": 2,
                          "label": "while (y != yMax)",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "id": 7,
              "label": "(dst, r)",
              "successors": []
            }
          ]
        }
      ]
    },
    {
      "name": "drawCMYK",
      "type": "function",
      "start_line": 445,
      "end_line": 476,
      "functions": [],
      "classes": [],
      "simplified_code": "func drawCMYK(dst: image.RGBA, r: Rectangle, src: image.CMYK, sp: Point): (image.RGBA, Rectangle) {\n    let i0 = (r.min.x - dst.rect.min.x) * 4\n    let i1 = (r.max.x - dst.rect.min.x) * 4\n    let si0 = (sp.x - src.rect.min.x) * 4\n    let yMax = r.max.y - dst.rect.min.y\n    var y = r.min.y - dst.rect.min.y\n    var sy = sp.y - src.rect.min.y\n    let dpix = dst.pix\n    let spix = src.pix\n    while (y != yMax) {\n        let dpis = y * dst.stride\n        let spis = sy * src.stride\n        var i = i0\n        var si = si0\n        while (i < i1) {\n            let (sr, sg, sb) = color.CMYKToRGB(\n                spix[spis + i + 0],\n                spix[spis + i + 1],\n                spix[spis + i + 2],\n                spix[spis + i + 3]\n            )\n            dpix[dpis + i + 0] = sr\n            dpix[dpis + i + 1] = sg\n            dpix[dpis + i + 2] = sb\n            dpix[dpis + i + 3] = 255\n            i += 4\n            si += 4\n        }\n        y++\n        sy++\n    }\n    (dst, r)",
      "blocks": [
        {
          "id": 1,
          "label": "func drawCMYK(dst: image.RGBA, r: Rectangle, src: image.CMYK, sp: Point): (image.RGBA, Rectangle) {",
          "successors": [
            {
              "id": 2,
              "label": "let i0 = (r.min.x - dst.rect.min.x) * 4\nlet i1 = (r.max.x - dst.rect.min.x) * 4\nlet si0 = (sp.x - src.rect.min.x) * 4\nlet yMax = r.max.y - dst.rect.min.y\nvar y = r.min.y - dst.rect.min.y\nvar sy = sp.y - src.rect.min.y\nlet dpix = dst.pix\nlet spix = src.pix",
              "successors": [
                {
                  "id": 3,
                  "label": "while (y != yMax) {",
                  "successors": [
                    {
                      "id": 4,
                      "label": "let dpis = y * dst.stride\nlet spis = sy * src.stride\nvar i = i0\nvar si = si0",
                      "successors": [
                        {
                          "id": 5,
                          "label": "while (i < i1) {",
                          "successors": [
                            {
                              "id": 6,
                              "label": "let (sr, sg, sb) = color.CMYKToRGB(\n    spix[spis + i + 0],\n    spix[spis + i + 1],\n    spix[spis + i + 2],\n    spix[spis + i + 3]\n)\ndpix[dpis + i + 0] = sr\ndpix[dpis + i + 1] = sg\ndpix[dpis + i + 2] = sb\ndpix[dpis + i + 3] = 255\ni += 4\nsi += 4",
                              "successors": [
                                {
                                  "id": 5,
                                  "label": "while (i < i1) {",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        },
                        {
                          "id": 3,
                          "label": "while (y != yMax) {",
                          "successors": []
                        }
                      ]
                    },
                    {
                      "id": 7,
                      "label": "y++\nsy++",
                      "successors": [
                        {
                          "id": 3,
                          "label": "while (y != yMax) {",
                          "successors": []
                        }
                      ]
                    }
                  ]
                },
                {
                  "id": 8,
                  "label": "(dst, r)\n}",
                  "successors": []
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "drawGlyphOver",
      "type": "function",
      "start_line": 479,
      "end_line": 514,
      "functions": [],
      "classes": [],
      "simplified_code": "func drawGlyphOver(dst: image.RGBA, r: Rectangle, src: image.Uniform, mask: image.Alpha, mp: Point): (image.RGBA,\n    Rectangle) {\n    var i0 = dst.pixOffset(r.min.y, r.min.y)\n    var i1 = i0 + r.dx() * 4\n    var mi0 = mask.pixOffset(mp.x, mp.y)\n    let (sr, _, _, sa) = src.rgba()\n    var y = r.min.y\n    var my = mp.y\n    let dpix = dst.pix\n    while (y != r.max.y) {\n        var i = i0\n        var mi = mi0\n        while (i < i1) {\n            var ma = UInt32(mask.pix[mi])\n            if (ma == 0) {\n                i += 4\n                mi++\n                continue\n            }\n            ma |= ma << 8\n            let a = (m - (sa * ma / m)) * 0x101\n            dpix[i + 0] = UInt8((UInt32(dpix[i + 0]) * a + sr * ma) >> 8)\n            dpix[i + 1] = UInt8((UInt32(dpix[i + 1]) * a + sr * ma) >> 8)\n            dpix[i + 2] = UInt8((UInt32(dpix[i + 2]) * a + sr * ma) >> 8)\n            dpix[i + 3] = UInt8((UInt32(dpix[i + 3]) * a + sr * ma) >> 8)\n            i += 4\n            mi++\n        }\n        i0 += dst.stride\n        i1 += dst.stride\n        mi0 += mask.stride\n        y++\n        my++\n    }\n    (dst, r)\n}",
      "blocks": [
        {
          "id": 1,
          "label": "func drawGlyphOver(dst: image.RGBA, r: Rectangle, src: image.Uniform, mask: image.Alpha, mp: Point): (image.RGBA, Rectangle) {",
          "successors": [
            {
              "id": 2,
              "label": "    var i0 = dst.pixOffset(r.min.y, r.min.y)\n    var i1 = i0 + r.dx() * 4\n    var mi0 = mask.pixOffset(mp.x, mp.y)\n    let (sr, _, _, sa) = src.rgba()\n    var y = r.min.y\n    var my = mp.y\n    let dpix = dst.pix",
              "successors": [
                {
                  "id": 3,
                  "label": "    while (y != r.max.y) {",
                  "successors": [
                    {
                      "id": 4,
                      "label": "        var i = i0\n        var mi = mi0",
                      "successors": [
                        {
                          "id": 5,
                          "label": "        while (i < i1) {",
                          "successors": [
                            {
                              "id": 6,
                              "label": "            var ma = UInt32(mask.pix[mi])",
                              "successors": [
                                {
                                  "id": 7,
                                  "label": "            if (ma == 0) {",
                                  "successors": [
                                    {
                                      "id": 8,
                                      "label": "                i += 4\n                mi++\n                continue",
                                      "successors": [
                                        {
                                          "id": 5,
                                          "label": "        while (i < i1) {",
                                          "successors": []
                                        }
                                      ]
                                    }
                                  ]
                                },
                                {
                                  "id": 9,
                                  "label": "            ma |= ma << 8\n            let a = (m - (sa * ma / m)) * 0x101\n            dpix[i + 0] = UInt8((UInt32(dpix[i + 0]) * a + sr * ma) >> 8)\n            dpix[i + 1] = UInt8((UInt32(dpix[i + 1]) * a + sr * ma) >> 8)\n            dpix[i + 2] = UInt8((UInt32(dpix[i + 2]) * a + sr * ma) >> 8)\n            dpix[i + 3] = UInt8((UInt32(dpix[i + 3]) * a + sr * ma) >> 8)\n            i += 4\n            mi++",
                                  "successors": [
                                    {
                                      "id": 5,
                                      "label": "        while (i < i1) {",
                                      "successors": []
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        },
                        {
                          "id": 10,
                          "label": "        }",
                          "successors": [
                            {
                              "id": 11,
                              "label": "        i0 += dst.stride\n        i1 += dst.stride\n        mi0 += mask.stride\n        y++\n        my++",
                              "successors": [
                                {
                                  "id": 3,
                                  "label": "    while (y != r.max.y) {",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "id": 12,
                  "label": "    }",
                  "successors": [
                    {
                      "id": 13,
                      "label": "    (dst, r)\n}",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "drawRGBA",
      "type": "function",
      "start_line": 516,
      "end_line": 576,
      "functions": [],
      "classes": [],
      "simplified_code": "func drawRGBA(dst: image.RGBA, r: Rectangle, src: Image, sp: Point, mask: Image, mp: Point, op: Op): (image.RGBA,\n    Rectangle) {\n    var x0 = r.min.x\n    var x1 = r.max.x\n    var dx = 1\n    var y0 = r.min.y\n    var y1 = r.max.y\n    var dy = 1\n    if (dst.eq(src) && r.overlaps(r + (sp - r.min))) {\n        if (sp.y < r.min.y || sp.y == r.min.y && sp.x < r.min.x) {\n            x0 = x1 - 1\n            x1 = x0 - 1\n            dx = -1\n            y0 = y1 - 1\n            y1 = y0 - 1\n            dy = -1\n        }\n    }\n    var sy = sp.y + y0 - r.min.y\n    var my = mp.y + y0 - r.min.y\n    var sx0 = sp.x + x0 - r.min.x\n    var mx0 = mp.x + x0 - r.min.x\n    var sx1 = sx0 + (x1 - x0)\n    var i0 = dst.pixOffset(x0, y0)\n    var di = dx * 4\n    var y = y0\n    let dpix = dst.pix\n    while (y != y1) {\n        var i = i0\n        var sx = sx0\n        var mx = mx0\n        while (sx != sx1) {\n            var ma = m\n            if (!(mask is NilImage)) {\n                let (_, _, _, a) = mask.at(mx, my).rgba()\n                ma = a\n            }\n            let (sr, sg, sb, sa) = src.at(sx, sy).rgba()\n            if (op == Src) {\n                let a = (m - (sa * ma / m)) * 0x101\n                dpix[i + 0] = UInt8((UInt32(dpix[i + 0]) * a + sr * ma) / m >> 8)\n                dpix[i + 1] = UInt8((UInt32(dpix[i + 1]) * a + sr * ma) / m >> 8)\n                dpix[i + 2] = UInt8((UInt32(dpix[i + 2]) * a + sr * ma) / m >> 8)\n                dpix[i + 3] = UInt8((UInt32(dpix[i + 3]) * a + sr * ma) / m >> 8)\n            } else {\n                dpix[i + 0] = UInt8(sr * ma / m >> 8)\n                dpix[i + 1] = UInt8(sg * ma / m >> 8)\n                dpix[i + 2] = UInt8(sb * ma / m >> 8)\n                dpix[i + 3] = UInt8(sa * ma / m >> 8)\n            }\n            i += di\n            sx += dx\n            mx += dx\n        }\n        y += dy\n        sy += dy\n        my += dy\n        i0 += dy * dst.stride\n    }\n    (dst, r)\n}",
      "blocks": [
        {
          "id": 1,
          "label": "var x0 = r.min.x\nvar x1 = r.max.x\nvar dx = 1\nvar y0 = r.min.y\nvar y1 = r.max.y\nvar dy = 1",
          "successors": [
            {
              "id": 2,
              "label": "if (dst.eq(src) && r.overlaps(r + (sp - r.min)))",
              "successors": [
                {
                  "id": 3,
                  "label": "if (sp.y < r.min.y || sp.y == r.min.y && sp.x < r.min.x)",
                  "successors": [
                    {
                      "id": 4,
                      "label": "x0 = x1 - 1\nx1 = x0 - 1\ndx = -1\ny0 = y1 - 1\ny1 = y0 - 1\ndy = -1",
                      "successors": [
                        {
                          "id": 5,
                          "label": "var sy = sp.y + y0 - r.min.y\nvar my = mp.y + y0 - r.min.y\nvar sx0 = sp.x + x0 - r.min.x\nvar mx0 = mp.x + x0 - r.min.x\nvar sx1 = sx0 + (x1 - x0)\nvar i0 = dst.pixOffset(x0, y0)\nvar di = dx * 4\nvar y = y0\nlet dpix = dst.pix",
                          "successors": [
                            {
                              "id": 6,
                              "label": "while (y != y1)",
                              "successors": [
                                {
                                  "id": 7,
                                  "label": "var i = i0\nvar sx = sx0\nvar mx = mx0",
                                  "successors": [
                                    {
                                      "id": 8,
                                      "label": "while (sx != sx1)",
                                      "successors": [
                                        {
                                          "id": 9,
                                          "label": "var ma = m\nif (!(mask is NilImage))",
                                          "successors": [
                                            {
                                              "id": 10,
                                              "label": "let (_, _, _, a) = mask.at(mx, my).rgba()\nma = a",
                                              "successors": []
                                            }
                                          ]
                                        },
                                        {
                                          "id": 11,
                                          "label": "let (sr, sg, sb, sa) = src.at(sx, sy).rgba()\nif (op == Src)",
                                          "successors": [
                                            {
                                              "id": 12,
                                              "label": "let a = (m - (sa * ma / m)) * 0x101\ndpix[i + 0] = UInt8((UInt32(dpix[i + 0]) * a + sr * ma) / m >> 8)\ndpix[i + 1] = UInt8((UInt32(dpix[i + 1]) * a + sr * ma) / m >> 8)\ndpix[i + 2] = UInt8((UInt32(dpix[i + 2]) * a + sr * ma) / m >> 8)\ndpix[i + 3] = UInt8((UInt32(dpix[i + 3]) * a + sr * ma) / m >> 8)",
                                              "successors": []
                                            },
                                            {
                                              "id": 13,
                                              "label": "dpix[i + 0] = UInt8(sr * ma / m >> 8)\ndpix[i + 1] = UInt8(sg * ma / m >> 8)\ndpix[i + 2] = UInt8(sb * ma / m >> 8)\ndpix[i + 3] = UInt8(sa * ma / m >> 8)",
                                              "successors": []
                                            }
                                          ]
                                        },
                                        {
                                          "id": 14,
                                          "label": "i += di\nsx += dx\nmx += dx",
                                          "successors": []
                                        }
                                      ]
                                    },
                                    {
                                      "id": 15,
                                      "label": "y += dy\nsy += dy\nmy += dy\ni0 += dy * dst.stride",
                                      "successors": []
                                    }
                                  ]
                                },
                                {
                                  "id": 16,
                                  "label": "(dst, r)",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "id": 17,
                  "label": "var sy = sp.y + y0 - r.min.y\nvar my = mp.y + y0 - r.min.y\nvar sx0 = sp.x + x0 - r.min.x\nvar mx0 = mp.x + x0 - r.min.x\nvar sx1 = sx0 + (x1 - x0)\nvar i0 = dst.pixOffset(x0, y0)\nvar di = dx * 4\nvar y = y0\nlet dpix = dst.pix",
                  "successors": [
                    {
                      "id": 18,
                      "label": "while (y != y1)",
                      "successors": [
                        {
                          "id": 19,
                          "label": "var i = i0\nvar sx = sx0\nvar mx = mx0",
                          "successors": [
                            {
                              "id": 20,
                              "label": "while (sx != sx1)",
                              "successors": [
                                {
                                  "id": 21,
                                  "label": "var ma = m\nif (!(mask is NilImage))",
                                  "successors": [
                                    {
                                      "id": 22,
                                      "label": "let (_, _, _, a) = mask.at(mx, my).rgba()\nma = a",
                                      "successors": []
                                    }
                                  ]
                                },
                                {
                                  "id": 23,
                                  "label": "let (sr, sg, sb, sa) = src.at(sx, sy).rgba()\nif (op == Src)",
                                  "successors": [
                                    {
                                      "id": 24,
                                      "label": "let a = (m - (sa * ma / m)) * 0x101\ndpix[i + 0] = UInt8((UInt32(dpix[i + 0]) * a + sr * ma) / m >> 8)\ndpix[i + 1] = UInt8((UInt32(dpix[i + 1]) * a + sr * ma) / m >> 8)\ndpix[i + 2] = UInt8((UInt32(dpix[i + 2]) * a + sr * ma) / m >> 8)\ndpix[i + 3] = UInt8((UInt32(dpix[i + 3]) * a + sr * ma) / m >> 8)",
                                      "successors": []
                                    },
                                    {
                                      "id": 25,
                                      "label": "dpix[i + 0] = UInt8(sr * ma / m >> 8)\ndpix[i + 1] = UInt8(sg * ma / m >> 8)\ndpix[i + 2] = UInt8(sb * ma / m >> 8)\ndpix[i + 3] = UInt8(sa * ma / m >> 8)",
                                      "successors": []
                                    }
                                  ]
                                },
                                {
                                  "id": 26,
                                  "label": "i += di\nsx += dx\nmx += dx",
                                  "successors": []
                                }
                              ]
                            },
                            {
                              "id": 27,
                              "label": "y += dy\nsy += dy\nmy += dy\ni0 += dy * dst.stride",
                              "successors": []
                            }
                          ]
                        },
                        {
                          "id": 28,
                          "label": "(dst, r)",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "clamp",
      "type": "function",
      "start_line": 577,
      "end_line": 585,
      "functions": [],
      "classes": [],
      "simplified_code": "func clamp(i: Int32): Int32 {\n    if (i < 0) {\n        0\n    } else if (i > 0xffff) {\n        0xffff\n    } else {\n        i\n    }\n}",
      "blocks": [
        {
          "id": 1,
          "label": "func clamp(i: Int32): Int32 {",
          "successors": [
            {
              "id": 2,
              "label": "if (i < 0) {",
              "successors": [
                {
                  "id": 3,
                  "label": "0",
                  "successors": []
                },
                {
                  "id": 4,
                  "label": "} else if (i > 0xffff) {",
                  "successors": [
                    {
                      "id": 5,
                      "label": "0xffff",
                      "successors": []
                    },
                    {
                      "id": 6,
                      "label": "} else {",
                      "successors": [
                        {
                          "id": 7,
                          "label": "i",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "sqDiff",
      "type": "function",
      "start_line": 587,
      "end_line": 590,
      "functions": [],
      "classes": [],
      "simplified_code": "func sqDiff(x: Int32, y: Int32): UInt32 {\n    let d = UInt32(x - y)\n    (d * d) >> 2\n}",
      "blocks": [
        {
          "id": 1,
          "label": "func sqDiff(x: Int32, y: Int32): UInt32 {",
          "successors": [
            {
              "id": 2,
              "label": "    let d = UInt32(x - y)",
              "successors": [
                {
                  "id": 3,
                  "label": "    (d * d) >> 2",
                  "successors": []
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "drawPaletted",
      "type": "function",
      "start_line": 591,
      "end_line": 699,
      "functions": [],
      "classes": [],
      "simplified_code": "func drawPaletted(dst: ImageI, r: Rectangle, src: Image, sp: Point, floydSteinberg: Bool): (ImageI, Rectangle) {\n    var palette: ?Array<Array<Int32>> = None\n    var pixS = 0\n    var stride = 0\n    if (dst is image.Paletted) {\n        let p = (dst as image.Paletted).getOrThrow()\n        let mPalette = Array<Array<Int32>>(p.palette.size(), {_ => Array<Int32>(4, item: 0)})\n        let buf = p.palette.buf\n        for (i in 0..buf.size) {\n            let (rr, g, b, a) = buf[i].rgba()\n            mPalette[i][0] = Int32(rr)\n            mPalette[i][1] = Int32(g)\n            mPalette[i][2] = Int32(b)\n            mPalette[i][3] = Int32(a)\n        }\n        palette = mPalette\n        pixS = p.pixOffset(r.min.x, r.min.y)\n        stride = p.stride\n    } else {\n        throw Exception(\"dst is not image.Paletted type\")\n    }\n    var quantErrorCurr: Array<Array<Int32>>\n    var quantErrorNext: Array<Array<Int32>>\n    if (floydSteinberg) {\n        quantErrorCurr = Array<Array<Int32>>(r.dx() + 2, {_ => Array<Int32>(4, item: 0)})\n        quantErrorNext = Array<Array<Int32>>(r.dx() + 2, {_ => Array<Int32>(4, item: 0)})\n    } else {\n        quantErrorCurr = Array<Array<Int32>>(0, {_ => Array<Int32>(4, item: 0)})\n        quantErrorNext = Array<Array<Int32>>(0, {_ => Array<Int32>(4, item: 0)})\n    }\n    var pxRGBA: (Int64, Int64) -> (UInt32, UInt32, UInt32, UInt32) = {x, y => src.at(x, y).rgba()}\n    if (src is image.RGBA) {\n        let src0 = (src as image.RGBA).getOrThrow()\n        pxRGBA = {x, y => src0.rgbaAt(x, y).rgba()}\n    } else if (src is image.NRGBA) {\n        let src0 = (src as image.NRGBA).getOrThrow()\n        pxRGBA = {x, y => src0.nrgbaAt(x, y).rgba()}\n    } else if (src is image.YCbCr) {\n        let src0 = (src as image.YCbCr).getOrThrow()\n        pxRGBA = {x, y => src0.ycbcrAt(x, y).rgba()}\n    }\n    // let out = color.RGBA64C(0, 0, 0, 0xffff)\n    var y = 0\n    let pixd = (dst as image.Paletted).getOrThrow().pix\n    while (y != r.dy()) {\n        var x = 0\n        while (x != r.dx()) {\n            var (sr, sg, sb, sa) = pxRGBA(sp.x + x, sp.y + y)\n            var (er, eg, eb, ea) = (Int32(sr), Int32(sg), Int32(sb), Int32(sa))\n            if (floydSteinberg) {\n                er = clamp(er + quantErrorCurr[x + 1][0] / 16)\n                eg = clamp(eg + quantErrorCurr[x + 1][1] / 16)\n                eb = clamp(eb + quantErrorCurr[x + 1][2] / 16)\n                ea = clamp(ea + quantErrorCurr[x + 1][3] / 16)\n            }\n            if (let Some(mPalette) <- palette) {\n                var bestIndex = 0\n                var bestSum = UInt32((1 << 32) - 1)\n                for (index in 0..mPalette.size) {\n                    let p = mPalette[index]\n                    let sum = sqDiff(er, p[0]) + sqDiff(eg, p[1]) + sqDiff(eb, p[2]) + sqDiff(ea, p[3])\n                    if (sum < bestSum) {\n                        bestIndex = index\n                        bestSum = sum\n                        if (sum == 0) {\n                            break\n                        }\n                    }\n                }\n                pixd[y * stride + x + pixS] = UInt8(bestIndex)\n                if (!floydSteinberg) {\n                    x++\n                    continue\n                }\n                er -= mPalette[bestIndex][0]\n                eg -= mPalette[bestIndex][1]\n                eb -= mPalette[bestIndex][2]\n                ea -= mPalette[bestIndex][3]\n            }\n            quantErrorNext[x + 0][0] += er * 3\n            quantErrorNext[x + 0][1] += eg * 3\n            quantErrorNext[x + 0][2] += eb * 3\n            quantErrorNext[x + 0][3] += ea * 3\n            quantErrorNext[x + 1][0] += er * 5\n            quantErrorNext[x + 1][1] += eg * 5\n            quantErrorNext[x + 1][2] += eb * 5\n            quantErrorNext[x + 1][3] += ea * 5\n            quantErrorNext[x + 2][0] += er * 1\n            quantErrorNext[x + 2][1] += eg * 1\n            quantErrorNext[x + 2][2] += eb * 1\n            quantErrorNext[x + 2][3] += ea * 1\n            quantErrorCurr[x + 2][0] += er * 7\n            quantErrorCurr[x + 2][1] += eg * 7\n            quantErrorCurr[x + 2][2] += eb * 7\n            quantErrorCurr[x + 2][3] += ea * 7\n            x++\n        }\n        if (floydSteinberg) {\n            let (qec, qen) = (quantErrorNext, quantErrorCurr)\n            quantErrorCurr = qen\n            quantErrorNext = qec\n            for (i in 0..quantErrorNext.size) {\n                quantErrorNext[i] = Array<Int32>(4, item: 0)\n            }\n        }\n        y++\n    }\n    (dst, r)\n}",
      "blocks": [
        {
          "id": 1,
          "label": "func drawPaletted(dst: ImageI, r: Rectangle, src: Image, sp: Point, floydSteinberg: Bool): (ImageI, Rectangle) {",
          "successors": [
            {
              "id": 2,
              "label": "var palette: ?Array<Array<Int32>> = None\nvar pixS = 0\nvar stride = 0",
              "successors": [
                {
                  "id": 3,
                  "label": "if (dst is image.Paletted) {",
                  "successors": [
                    {
                      "id": 4,
                      "label": "let p = (dst as image.Paletted).getOrThrow()\nlet mPalette = Array<Array<Int32>>(p.palette.size(), {_ => Array<Int32>(4, item: 0)})\nlet buf = p.palette.buf",
                      "successors": [
                        {
                          "id": 5,
                          "label": "for (i in 0..buf.size) {",
                          "successors": [
                            {
                              "id": 6,
                              "label": "let (rr, g, b, a) = buf[i].rgba()\nmPalette[i][0] = Int32(rr)\nmPalette[i][1] = Int32(g)\nmPalette[i][2] = Int32(b)\nmPalette[i][3] = Int32(a)",
                              "successors": []
                            }
                          ]
                        },
                        {
                          "id": 7,
                          "label": "palette = mPalette\npixS = p.pixOffset(r.min.x, r.min.y)\nstride = p.stride",
                          "successors": []
                        }
                      ]
                    },
                    {
                      "id": 8,
                      "label": "} else {",
                      "successors": [
                        {
                          "id": 9,
                          "label": "throw Exception(\"dst is not image.Paletted type\")",
                          "successors": []
                        }
                      ]
                    }
                  ]
                },
                {
                  "id": 10,
                  "label": "var quantErrorCurr: Array<Array<Int32>>\nvar quantErrorNext: Array<Array<Int32>>",
                  "successors": [
                    {
                      "id": 11,
                      "label": "if (floydSteinberg) {",
                      "successors": [
                        {
                          "id": 12,
                          "label": "quantErrorCurr = Array<Array<Int32>>(r.dx() + 2, {_ => Array<Int32>(4, item: 0)})\nquantErrorNext = Array<Array<Int32>>(r.dx() + 2, {_ => Array<Int32>(4, item: 0)})",
                          "successors": []
                        },
                        {
                          "id": 13,
                          "label": "} else {",
                          "successors": [
                            {
                              "id": 14,
                              "label": "quantErrorCurr = Array<Array<Int32>>(0, {_ => Array<Int32>(4, item: 0)})\nquantErrorNext = Array<Array<Int32>>(0, {_ => Array<Int32>(4, item: 0)})",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "id": 15,
                      "label": "var pxRGBA: (Int64, Int64) -> (UInt32, UInt32, UInt32, UInt32) = {x, y => src.at(x, y).rgba()}",
                      "successors": [
                        {
                          "id": 16,
                          "label": "if (src is image.RGBA) {",
                          "successors": [
                            {
                              "id": 17,
                              "label": "let src0 = (src as image.RGBA).getOrThrow()\npxRGBA = {x, y => src0.rgbaAt(x, y).rgba()}",
                              "successors": []
                            },
                            {
                              "id": 18,
                              "label": "} else if (src is image.NRGBA) {",
                              "successors": [
                                {
                                  "id": 19,
                                  "label": "let src0 = (src as image.NRGBA).getOrThrow()\npxRGBA = {x, y => src0.nrgbaAt(x, y).rgba()}",
                                  "successors": []
                                },
                                {
                                  "id": 20,
                                  "label": "} else if (src is image.YCbCr) {",
                                  "successors": [
                                    {
                                      "id": 21,
                                      "label": "let src0 = (src as image.YCbCr).getOrThrow()\npxRGBA = {x, y => src0.ycbcrAt(x, y).rgba()}",
                                      "successors": []
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        },
                        {
                          "id": 22,
                          "label": "var y = 0\nlet pixd = (dst as image.Paletted).getOrThrow().pix",
                          "successors": [
                            {
                              "id": 23,
                              "label": "while (y != r.dy()) {",
                              "successors": [
                                {
                                  "id": 24,
                                  "label": "var x = 0",
                                  "successors": [
                                    {
                                      "id": 25,
                                      "label": "while (x != r.dx()) {",
                                      "successors": [
                                        {
                                          "id": 26,
                                          "label": "var (sr, sg, sb, sa) = pxRGBA(sp.x + x, sp.y + y)\nvar (er, eg, eb, ea) = (Int32(sr), Int32(sg), Int32(sb), Int32(sa))",
                                          "successors": [
                                            {
                                              "id": 27,
                                              "label": "if (floydSteinberg) {",
                                              "successors": [
                                                {
                                                  "id": 28,
                                                  "label": "er = clamp(er + quantErrorCurr[x + 1][0] / 16)\neg = clamp(eg + quantErrorCurr[x + 1][1] / 16)\neb = clamp(eb + quantErrorCurr[x + 1][2] / 16)\nea = clamp(ea + quantErrorCurr[x + 1][3] / 16)",
                                                  "successors": []
                                                }
                                              ]
                                            },
                                            {
                                              "id": 29,
                                              "label": "if (let Some(mPalette) <- palette) {",
                                              "successors": [
                                                {
                                                  "id": 30,
                                                  "label": "var bestIndex = 0\nvar bestSum = UInt32((1 << 32) - 1)\nfor (index in 0..mPalette.size) {",
                                                  "successors": [
                                                    {
                                                      "id": 31,
                                                      "label": "let p = mPalette[index]\nlet sum = sqDiff(er, p[0]) + sqDiff(eg, p[1]) + sqDiff(eb, p[2]) + sqDiff(ea, p[3])\nif (sum < bestSum) {\n    bestIndex = index\n    bestSum = sum\n    if (sum == 0) {\n        break\n    }\n}",
                                                      "successors": []
                                                    }
                                                  ]
                                                },
                                                {
                                                  "id": 32,
                                                  "label": "pixd[y * stride + x + pixS] = UInt8(bestIndex)\nif (!floydSteinberg) {\n    x++\n    continue\n}",
                                                  "successors": []
                                                },
                                                {
                                                  "id": 33,
                                                  "label": "er -= mPalette[bestIndex][0]\neg -= mPalette[bestIndex][1]\neb -= mPalette[bestIndex][2]\nea -= mPalette[bestIndex][3]",
                                                  "successors": []
                                                }
                                              ]
                                            },
                                            {
                                              "id": 34,
                                              "label": "quantErrorNext[x + 0][0] += er * 3\nquantErrorNext[x + 0][1] += eg * 3\nquantErrorNext[x + 0][2] += eb * 3\nquantErrorNext[x + 0][3] += ea * 3\nquantErrorNext[x + 1][0] += er * 5\nquantErrorNext[x + 1][1] += eg * 5\nquantErrorNext[x + 1][2] += eb * 5\nquantErrorNext[x + 1][3] += ea * 5\nquantErrorNext[x + 2][0] += er * 1\nquantErrorNext[x + 2][1] += eg * 1\nquantErrorNext[x + 2][2] += eb * 1\nquantErrorNext[x + 2][3] += ea * 1\nquantErrorCurr[x + 2][0] += er * 7\nquantErrorCurr[x + 2][1] += eg * 7\nquantErrorCurr[x + 2][2] += eb * 7\nquantErrorCurr[x + 2][3] += ea * 7\nx++",
                                              "successors": []
                                            }
                                          ]
                                        }
                                      ]
                                    },
                                    {
                                      "id": 35,
                                      "label": "if (floydSteinberg) {",
                                      "successors": [
                                        {
                                          "id": 36,
                                          "label": "let (qec, qen) = (quantErrorNext, quantErrorCurr)\nquantErrorCurr = qen\nquantErrorNext = qec\nfor (i in 0..quantErrorNext.size) {\n    quantErrorNext[i] = Array<Int32>(4, item: 0)\n}",
                                          "successors": []
                                        }
                                      ]
                                    },
                                    {
                                      "id": 37,
                                      "label": "y++",
                                      "successors": []
                                    }
                                  ]
                                },
                                {
                                  "id": 38,
                                  "label": "(dst, r)",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    }
  ],
  "classes": [
    {
      "name": "Quantizer",
      "type": "interface",
      "start_line": 9,
      "end_line": 11,
      "functions": [
        {
          "name": "quantize",
          "type": "function",
          "start_line": 10,
          "end_line": 10,
          "functions": [],
          "classes": [],
          "simplified_code": "    func quantize(p: color.Palette, m: Image): color.Palette",
          "blocks": [
            {
              "id": 1,
              "label": "func quantize(p: color.Palette, m: Image): color.Palette",
              "successors": []
            }
          ]
        }
      ],
      "simplified_code": "public interface Quantizer {\n    func quantize(p: color.Palette, m: Image): color.Palette\n}",
      "blocks": [
        {
          "id": 1,
          "label": "public interface Quantizer {",
          "successors": [
            {
              "id": 2,
              "label": "func quantize(p: color.Palette, m: Image): color.Palette",
              "successors": []
            }
          ]
        },
        {
          "id": 3,
          "label": "}",
          "successors": []
        }
      ]
    },
    {
      "name": "Op",
      "type": "enum",
      "start_line": 12,
      "end_line": 26,
      "functions": [
        {
          "name": "hashCode",
          "type": "function",
          "start_line": 14,
          "end_line": 19,
          "functions": [],
          "classes": [],
          "simplified_code": "    public func hashCode(): Int64 {\n        match (this) {\n            case Over => 0\n            case Src => 1\n        }\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "public func hashCode(): Int64 {",
              "successors": [
                {
                  "id": 2,
                  "label": "match (this) {",
                  "successors": [
                    {
                      "id": 3,
                      "label": "case Over => 0",
                      "successors": []
                    },
                    {
                      "id": 4,
                      "label": "case Src => 1",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "==",
          "type": "function",
          "start_line": 20,
          "end_line": 22,
          "functions": [],
          "classes": [],
          "simplified_code": "    public operator func ==(op: Op): Bool {\n        this.hashCode() == op.hashCode()\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "public operator func ==(op: Op): Bool {",
              "successors": [
                {
                  "id": 2,
                  "label": "this.hashCode() == op.hashCode()",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "!=",
          "type": "function",
          "start_line": 23,
          "end_line": 25,
          "functions": [],
          "classes": [],
          "simplified_code": "    public operator func !=(op: Op): Bool {\n        !(this == op)\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "public operator func !=(op: Op): Bool {",
              "successors": [
                {
                  "id": 2,
                  "label": "    !(this == op)",
                  "successors": []
                }
              ]
            }
          ]
        }
      ],
      "simplified_code": "public enum Op <: Hashable {\n    Over | Src\n    }\n    }\n    }\n}",
      "blocks": [
        {
          "id": 1,
          "label": "public enum Op <: Hashable {",
          "successors": [
            {
              "id": 2,
              "label": "    Over | Src",
              "successors": [
                {
                  "id": 3,
                  "label": "}",
                  "successors": []
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "Drawer",
      "type": "interface",
      "start_line": 27,
      "end_line": 29,
      "functions": [
        {
          "name": "drawer",
          "type": "function",
          "start_line": 28,
          "end_line": 28,
          "functions": [],
          "classes": [],
          "simplified_code": "    func drawer(dst: ImageI, r: Rectangle, src: Image, sp: Point): (ImageI, Rectangle)",
          "blocks": [
            {
              "id": 1,
              "label": "def drawer(dst, r, src, sp):",
              "successors": []
            }
          ]
        }
      ],
      "simplified_code": "public interface Drawer {\n    func drawer(dst: ImageI, r: Rectangle, src: Image, sp: Point): (ImageI, Rectangle)\n}",
      "blocks": [
        {
          "id": 1,
          "label": "public interface Drawer {\n    func drawer(dst: ImageI, r: Rectangle, src: Image, sp: Point): (ImageI, Rectangle)\n}",
          "successors": []
        }
      ]
    },
    {
      "name": "FloydSteinbergClazz",
      "type": "class",
      "start_line": 31,
      "end_line": 41,
      "functions": [
        {
          "name": "drawer",
          "type": "function",
          "start_line": 32,
          "end_line": 40,
          "functions": [],
          "classes": [],
          "simplified_code": "    public func drawer(dst: ImageI, r: Rectangle, src: Image, sp: Point): (ImageI, Rectangle) {\n        var (dst0, rect0) = clip(dst, r, src, sp, nilImage, nilPoint)\n        if (rect0.empty()) {\n            return (dst0, rect0)\n        }\n        var mDst: ImageI = dst0\n        var mRect: Rectangle = rect0\n        return drawPaletted(mDst, mRect, src, sp, true)\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "public func drawer(dst: ImageI, r: Rectangle, src: Image, sp: Point): (ImageI, Rectangle) {",
              "successors": [
                {
                  "id": 2,
                  "label": "    var (dst0, rect0) = clip(dst, r, src, sp, nilImage, nilPoint)",
                  "successors": [
                    {
                      "id": 3,
                      "label": "if (rect0.empty()) {",
                      "successors": [
                        {
                          "id": 4,
                          "label": "    return (dst0, rect0)",
                          "successors": []
                        }
                      ]
                    },
                    {
                      "id": 5,
                      "label": "}",
                      "successors": [
                        {
                          "id": 6,
                          "label": "var mDst: ImageI = dst0\n    var mRect: Rectangle = rect0",
                          "successors": [
                            {
                              "id": 7,
                              "label": "return drawPaletted(mDst, mRect, src, sp, true)",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "id": 8,
                  "label": "}",
                  "successors": []
                }
              ]
            }
          ]
        }
      ],
      "simplified_code": "public class FloydSteinbergClazz <: Drawer {\n    }\n}",
      "blocks": []
    }
  ],
  "simplified_code": "package drawer\nfrom std import collection.*\nfrom std import objectpool.*\nimport image.*\nimport color.*\nimport internals.model.*\nimport internals.imageutil.*\nlet m = UInt32((1 << 16) - 1)\n}\n}\n}\npublic let FloydSteinberg: Drawer = FloydSteinbergClazz()\n}\n}\n}\n}\n}\n@OverflowWrapping\n}\n@OverflowWrapping\n}\n@OverflowWrapping\n}\n    (dst, r)\n}\n@OverflowWrapping\n}\n@OverflowWrapping\n    (dst, r)\n}\n    (dst, r)\n}\n    (dst, r)\n}\n@OverflowWrapping\n}\n@OverflowWrapping\n}\n}\n@OverflowWrapping\n}\n}",
  "blocks": [
    {
      "id": 1,
      "label": "package drawer\nfrom std import collection.*\nfrom std import objectpool.*\nimport image.*\nimport color.*\nimport internals.model.*\nimport internals.imageutil.*\nlet m = UInt32((1 << 16) - 1)\n}\n}\n}",
      "successors": [
        {
          "id": 2,
          "label": "public let FloydSteinberg: Drawer = FloydSteinbergClazz()\n}\n}\n}\n}\n}",
          "successors": [
            {
              "id": 3,
              "label": "@OverflowWrapping\n}\n@OverflowWrapping\n}\n@OverflowWrapping\n}\n    (dst, r)\n}\n@OverflowWrapping\n}\n@OverflowWrapping\n    (dst, r)\n}\n    (dst, r)\n}\n    (dst, r)\n}\n@OverflowWrapping\n}\n@OverflowWrapping\n}\n}\n@OverflowWrapping\n}\n}",
              "successors": []
            }
          ]
        }
      ]
    }
  ]
}