{
  "edge_analysis": {
    "static_total": 0,
    "llm_total": 26,
    "matched_edges": {
      "exact_matches": 0,
      "partial_matches": 0
    },
    "accuracy_metrics": {
      "precision": 0,
      "recall": 0,
      "f1_score": 0
    }
  },
  "structure_validation": {
    "missing_blocks": [],
    "extra_blocks": [
      "Edge 0: [Source] func find(): AlignmentPattern { let startX: Int64 = this.startX; let height: Int64 = this.height; let maxJ: Int64 = startX + width let middleI: Int64 = startY + (height / 2) var stateCount: Array<Int64> = Array<Int64>(3, item: 0); for (iGen in 0..height) {\\n// Search from middle outwards let iGenResult: Int64 = if ((iGen & 0x01) == 0) { (iGen + 1) / 2 } else { -(iGen + 1) / 2 } var i: Int64 = middleI + iGenResult => [Target] stateCount[0] = 0 stateCount[1] = 0 stateCount[2] = 0 var j: Int64 = startX while (j < maxJ && !image.get(j, i)) { j++ }\\nvar currentState: Int64 = 0; while (j < maxJ) { if (image.get(j, i)) { var res: Option<AlignmentPattern> (currentState, res) = exfind(currentState, stateCount, i, j) if (let Some(con) <- res) { return con } } else { if (currentState == 1) { currentState++ } stateCount[Int64(currentState)] += 1 } j++ }",
      "Edge 1: [Source] stateCount[0] = 0 stateCount[1] = 0 stateCount[2] = 0 var j: Int64 = startX while (j < maxJ && !image.get(j, i)) { j++ }\\nvar currentState: Int64 = 0; while (j < maxJ) { if (image.get(j, i)) { var res: Option<AlignmentPattern> (currentState, res) = exfind(currentState, stateCount, i, j) if (let Some(con) <- res) { return con } } else { if (currentState == 1) { currentState++ } stateCount[Int64(currentState)] += 1 } j++ } => [Target] if (foundPatternCross(stateCount)) { let confirmed: Option<AlignmentPattern> = handlePossibleCenter(stateCount, i, maxJ); if (let Some(con) <- confirmed) { return con } }\\nif (!possibleCenters.isEmpty()) { return possibleCenters[0] } throw Qrcoder4cjNotFoundException.getNotFoundInstance();",
      "Edge 2: [Source] func exfind(currentState: Int64, stateCount: Array<Int64>, i: Int64, j: Int64): (Int64, Option<AlignmentPattern>) {\\n var currentState_p = currentState\\n if (currentState == 1) { // Counting black pixels\\n stateCount[1] += 1\\n } else { => [Target] stateCount[1] += 1\\n return (currentState_p, None)\\n }",
      "Edge 3: [Source] func exfind(currentState: Int64, stateCount: Array<Int64>, i: Int64, j: Int64): (Int64, Option<AlignmentPattern>) {\\n var currentState_p = currentState\\n if (currentState == 1) { // Counting black pixels\\n stateCount[1] += 1\\n } else { => [Target] if (currentState_p == 2) { // A winner?\\n if (foundPatternCross(stateCount)) { // Yes\\n let confirmed: Option<AlignmentPattern> = handlePossibleCenter(stateCount, i, j);\\n if (let Some(con) <- confirmed) {\\n return (0, con)\\n }\\n }\\n stateCount[0] = stateCount[2]\\n stateCount[1] = 1\\n stateCount[2] = 0\\n currentState_p = 1\\n } else {\\n currentState_p++\\n stateCount[Int64(currentState_p)] += 1\\n }",
      "Edge 4: [Source] if (currentState_p == 2) { // A winner?\\n if (foundPatternCross(stateCount)) { // Yes\\n let confirmed: Option<AlignmentPattern> = handlePossibleCenter(stateCount, i, j);\\n if (let Some(con) <- confirmed) {\\n return (0, con)\\n }\\n }\\n stateCount[0] = stateCount[2]\\n stateCount[1] = 1\\n stateCount[2] = 0\\n currentState_p = 1\\n } else {\\n currentState_p++\\n stateCount[Int64(currentState_p)] += 1\\n } => [Target] return (0, con)\\n }",
      "Edge 5: [Source] if (currentState_p == 2) { // A winner?\\n if (foundPatternCross(stateCount)) { // Yes\\n let confirmed: Option<AlignmentPattern> = handlePossibleCenter(stateCount, i, j);\\n if (let Some(con) <- confirmed) {\\n return (0, con)\\n }\\n }\\n stateCount[0] = stateCount[2]\\n stateCount[1] = 1\\n stateCount[2] = 0\\n currentState_p = 1\\n } else {\\n currentState_p++\\n stateCount[Int64(currentState_p)] += 1\\n } => [Target] stateCount[0] = stateCount[2]\\n stateCount[1] = 1\\n stateCount[2] = 0\\n currentState_p = 1\\n return (currentState_p, None)\\n }",
      "Edge 6: [Source] if (currentState_p == 2) { // A winner?\\n if (foundPatternCross(stateCount)) { // Yes\\n let confirmed: Option<AlignmentPattern> = handlePossibleCenter(stateCount, i, j);\\n if (let Some(con) <- confirmed) {\\n return (0, con)\\n }\\n }\\n stateCount[0] = stateCount[2]\\n stateCount[1] = 1\\n stateCount[2] = 0\\n currentState_p = 1\\n } else {\\n currentState_p++\\n stateCount[Int64(currentState_p)] += 1\\n } => [Target] currentState_p++\\n stateCount[Int64(currentState_p)] += 1\\n return (currentState_p, None)\\n }",
      "Edge 7: [Source] private func foundPatternCross(stateCount: Array<Int64>): Bool {\\n let moduleSize: Float32 = this.moduleSize;\\n let maxVariance: Float32 = moduleSize / 2.0f32 => [Target] for (i in 0..3) {",
      "Edge 8: [Source] for (i in 0..3) { => [Target] if (abs(moduleSize - Float32(stateCount[i])) >= maxVariance) {\\n return false;\\n }\\n }",
      "Edge 9: [Source] if (abs(moduleSize - Float32(stateCount[i])) >= maxVariance) {\\n return false;\\n }\\n } => [Target] return true;",
      "Edge 10: [Source] private func crossCheckVertical(\\n startI: Int64,\\n centerJ: Int64,\\n maxCount: Int64,\\n originalStateCountTotal: Int64\\n ): Float32 {\\n let image: BitMatrix = this.image;\\n let maxI: Int64 = image.getHeight();\\n let stateCount: Array<Int64> = crossCheckStateCount\\n stateCount[0] = 0\\n stateCount[1] = 0\\n stateCount[2] = 0\\n // Start counting up from center\\n var i: Int64 = startI\\n while (i >= 0 && image.get(centerJ, i) && stateCount[1] <= maxCount) { => [Target] stateCount[1] += 1\\n i--",
      "Edge 11: [Source] stateCount[1] += 1\\n i-- => [Target] while (i >= 0 && image.get(centerJ, i) && stateCount[1] <= maxCount) {",
      "Edge 12: [Source] while (i >= 0 && image.get(centerJ, i) && stateCount[1] <= maxCount) { => [Target] }",
      "Edge 13: [Source] } => [Target] if (i < 0 || stateCount[1] > maxCount) {\\n return Float32.NaN;",
      "Edge 14: [Source] } => [Target] }\\n while (i >= 0 && !image.get(centerJ, i) && stateCount[0] <= maxCount) {\\n stateCount[0] += 1\\n i--\\n }",
      "Edge 15: [Source] }\\n while (i >= 0 && !image.get(centerJ, i) && stateCount[0] <= maxCount) {\\n stateCount[0] += 1\\n i--\\n } => [Target] if (stateCount[0] > maxCount) {\\n return Float32.NaN;",
      "Edge 16: [Source] }\\n while (i >= 0 && !image.get(centerJ, i) && stateCount[0] <= maxCount) {\\n stateCount[0] += 1\\n i--\\n } => [Target] }\\n // Now also count down from center\\n i = startI + 1\\n while (i < maxI && image.get(centerJ, i) && stateCount[1] <= maxCount) {\\n stateCount[1] += 1\\n i++\\n }\\n if (i == maxI || stateCount[1] > maxCount) {\\n return Float32.NaN;",
      "Edge 17: [Source] }\\n while (i >= 0 && !image.get(centerJ, i) && stateCount[0] <= maxCount) {\\n stateCount[0] += 1\\n i--\\n } => [Target] }\\n while (i < maxI && !image.get(centerJ, i) && stateCount[2] <= maxCount) {\\n stateCount[2] += 1\\n i++\\n }\\n if (stateCount[2] > maxCount) {\\n return Float32.NaN;",
      "Edge 18: [Source] }\\n while (i >= 0 && !image.get(centerJ, i) && stateCount[0] <= maxCount) {\\n stateCount[0] += 1\\n i--\\n } => [Target] }\\n let stateCountTotal: Int64 = stateCount[0] + stateCount[1] + stateCount[2]\\n if (5 * abs(stateCountTotal - originalStateCountTotal) >= 2 * originalStateCountTotal) {\\n return Float32.NaN;\\n }\\n return excrossCheckVertical(stateCount, i)\\n }",
      "Edge 19: [Source] private func excrossCheckVertical(stateCount: Array<Int64>, i: Int64) {\\nif (foundPatternCross(stateCount)) {\\n centerFromEnd(stateCount, i) => [Target] } else {\\n Float32.NaN\\n}",
      "Edge 20: [Source] private func handlePossibleCenter(stateCount: Array<Int64>, i: Int64, j: Int64): Option<AlignmentPattern> {\\n let stateCountTotal: Int64 = stateCount[0] + stateCount[1] + stateCount[2]\\n let centerJ: Float32 = centerFromEnd(stateCount, j);\\n let centerI: Float32 = crossCheckVertical(i, Int64(centerJ), 2 * stateCount[1], stateCountTotal); => [Target] if (!centerI.isNaN()) {\\nlet estimatedModuleSize: Float32 = Float32(stateCount[0] + stateCount[1] + stateCount[2]) / 3.0f32",
      "Edge 21: [Source] private func handlePossibleCenter(stateCount: Array<Int64>, i: Int64, j: Int64): Option<AlignmentPattern> {\\n let stateCountTotal: Int64 = stateCount[0] + stateCount[1] + stateCount[2]\\n let centerJ: Float32 = centerFromEnd(stateCount, j);\\n let centerI: Float32 = crossCheckVertical(i, Int64(centerJ), 2 * stateCount[1], stateCountTotal); => [Target] return None",
      "Edge 22: [Source] if (!centerI.isNaN()) {\\nlet estimatedModuleSize: Float32 = Float32(stateCount[0] + stateCount[1] + stateCount[2]) / 3.0f32 => [Target] for (i in 0..possibleCenters.size) {",
      "Edge 23: [Source] if (!centerI.isNaN()) {\\nlet estimatedModuleSize: Float32 = Float32(stateCount[0] + stateCount[1] + stateCount[2]) / 3.0f32 => [Target] // Hadn't found this before; save it\\nlet point: AlignmentPattern = AlignmentPattern(centerJ, centerI, estimatedModuleSize);\\npossibleCenters.append(point);\\nif (let Some(res) <- resultPointCallback) {\\n res.foundPossibleResultPoint(point);\\n}\\n}",
      "Edge 24: [Source] for (i in 0..possibleCenters.size) { => [Target] if (possibleCenters[i].aboutEquals(estimatedModuleSize, centerI, centerJ)) {\\nreturn possibleCenters[i].combineEstimate(centerI, centerJ, estimatedModuleSize);",
      "Edge 25: [Source] for (i in 0..possibleCenters.size) { => [Target] }"
    ]
  }
}