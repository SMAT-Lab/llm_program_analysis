{
  "name": "example_script",
  "type": "CFG",
  "start_line": 1,
  "end_line": 672,
  "functions": [
    {
      "name": "isSeparator",
      "type": "function",
      "start_line": 74,
      "end_line": 76,
      "functions": [],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 74,
          "line": "func isSeparator(c: Rune): Bool {"
        },
        {
          "lineno": 75,
          "line": "    return c.isAscii() && (c == r'/' || c == r'\\\\')"
        },
        {
          "lineno": 76,
          "line": "}"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "label": "func isSeparator(c: Rune): Bool {\n    return c.isAscii() && (c == r'/' || c == r'\\\\')\n}",
          "successors": []
        }
      ]
    },
    {
      "name": "parseCharSpecifiers",
      "type": "function",
      "start_line": 78,
      "end_line": 91,
      "functions": [],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 78,
          "line": "func parseCharSpecifiers(s: Array<Rune>): Array<CharSpecifier> {"
        },
        {
          "lineno": 79,
          "line": "    let ret = ArrayList<CharSpecifier>()"
        },
        {
          "lineno": 80,
          "line": "    var i = 0"
        },
        {
          "lineno": 81,
          "line": "    while (i < s.size) {"
        },
        {
          "lineno": 82,
          "line": "        if (i + 3 <= s.size && s[i + 1] == r'-') {"
        },
        {
          "lineno": 83,
          "line": "            ret.append(CharSpecifier.CharRange(s[i], s[i + 2]))"
        },
        {
          "lineno": 84,
          "line": "            i += 3"
        },
        {
          "lineno": 85,
          "line": "        } else {"
        },
        {
          "lineno": 86,
          "line": "            ret.append(CharSpecifier.SingleChar(s[i]))"
        },
        {
          "lineno": 87,
          "line": "            i += 1"
        },
        {
          "lineno": 88,
          "line": "        }"
        },
        {
          "lineno": 89,
          "line": "    }"
        },
        {
          "lineno": 90,
          "line": "    return ret.toArray()"
        },
        {
          "lineno": 91,
          "line": "}"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "label": "func parseCharSpecifiers(s: Array<Rune>): Array<CharSpecifier> {\n    let ret = ArrayList<CharSpecifier>()\n    var i = 0",
          "successors": [
            {
              "id": 2,
              "label": "while (i < s.size) {",
              "successors": [
                {
                  "id": 3,
                  "label": "if (i + 3 <= s.size && s[i + 1] == r'-') {\n    ret.append(CharSpecifier.CharRange(s[i], s[i + 2]))\n    i += 3\n} else {\n    ret.append(CharSpecifier.SingleChar(s[i]))\n    i += 1\n}",
                  "successors": [
                    {
                      "id": 5,
                      "label": "while (i < s.size) {",
                      "successors": []
                    }
                  ]
                }
              ]
            },
            {
              "id": 6,
              "label": "return ret.toArray()\n}",
              "successors": []
            }
          ]
        }
      ]
    },
    {
      "name": "charsEq",
      "type": "function",
      "start_line": 117,
      "end_line": 123,
      "functions": [],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 117,
          "line": "func charsEq(a: Rune, b: Rune, caseSensitive: Bool): Bool {"
        },
        {
          "lineno": 118,
          "line": "    if (!caseSensitive && a.isAscii() && b.isAscii()) {"
        },
        {
          "lineno": 119,
          "line": "        a.toAsciiLowerCase() == b.toAsciiLowerCase()"
        },
        {
          "lineno": 120,
          "line": "    } else {"
        },
        {
          "lineno": 121,
          "line": "        a == b"
        },
        {
          "lineno": 122,
          "line": "    }"
        },
        {
          "lineno": 123,
          "line": "}"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "label": "func charsEq(a: Rune, b: Rune, caseSensitive: Bool): Bool {",
          "successors": [
            {
              "id": 2,
              "label": "if (!caseSensitive && a.isAscii() && b.isAscii()) {\n    a.toAsciiLowerCase() == b.toAsciiLowerCase()",
              "successors": []
            },
            {
              "id": 3,
              "label": "else {\n    a == b",
              "successors": []
            }
          ]
        }
      ]
    },
    {
      "name": "inCharSpecifiers",
      "type": "function",
      "start_line": 126,
      "end_line": 159,
      "functions": [],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 126,
          "line": "func inCharSpecifiers(cs: Array<CharSpecifier>, c: Rune, options: MatchOptions): Bool {"
        },
        {
          "lineno": 127,
          "line": "    for (spec in cs) {"
        },
        {
          "lineno": 128,
          "line": "        match (spec) {"
        },
        {
          "lineno": 129,
          "line": "            case CharSpecifier.SingleChar(cs) =>"
        },
        {
          "lineno": 130,
          "line": "                if (charsEq(c, cs, options.caseSensitive)) {"
        },
        {
          "lineno": 131,
          "line": "                    return true"
        },
        {
          "lineno": 132,
          "line": "                } else {"
        },
        {
          "lineno": 133,
          "line": "                    continue"
        },
        {
          "lineno": 134,
          "line": "                }"
        },
        {
          "lineno": 135,
          "line": ""
        },
        {
          "lineno": 136,
          "line": "            case CharSpecifier.CharRange(start, end) =>"
        },
        {
          "lineno": 137,
          "line": "                if (!options.caseSensitive && c.isAscii() && start.isAscii() && end.isAscii()) {"
        },
        {
          "lineno": 138,
          "line": "                    let sl = start.toAsciiLowerCase()"
        },
        {
          "lineno": 139,
          "line": "                    let el = end.toAsciiLowerCase()"
        },
        {
          "lineno": 140,
          "line": ""
        },
        {
          "lineno": 141,
          "line": "                    let su = sl.toAsciiUpperCase()"
        },
        {
          "lineno": 142,
          "line": "                    let eu = el.toAsciiUpperCase()"
        },
        {
          "lineno": 143,
          "line": ""
        },
        {
          "lineno": 144,
          "line": "                    if (sl != su && el != eu) {"
        },
        {
          "lineno": 145,
          "line": "                        let cl = c.toAsciiLowerCase()"
        },
        {
          "lineno": 146,
          "line": "                        if (cl >= sl && cl <= el) {"
        },
        {
          "lineno": 147,
          "line": "                            return true;"
        },
        {
          "lineno": 148,
          "line": "                        }"
        },
        {
          "lineno": 149,
          "line": "                    }"
        },
        {
          "lineno": 150,
          "line": "                }"
        },
        {
          "lineno": 151,
          "line": ""
        },
        {
          "lineno": 152,
          "line": "                if (c >= start && c <= end) {"
        },
        {
          "lineno": 153,
          "line": "                    return true"
        },
        {
          "lineno": 154,
          "line": "                }"
        },
        {
          "lineno": 155,
          "line": "        }"
        },
        {
          "lineno": 156,
          "line": "    }"
        },
        {
          "lineno": 157,
          "line": ""
        },
        {
          "lineno": 158,
          "line": "    return false"
        },
        {
          "lineno": 159,
          "line": "}"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "label": "func inCharSpecifiers(cs: Array<CharSpecifier>, c: Rune, options: MatchOptions): Bool {",
          "successors": [
            {
              "id": 2,
              "label": "for (spec in cs) {",
              "successors": [
                {
                  "id": 3,
                  "label": "match (spec) {\ncase CharSpecifier.SingleChar(cs) =>\n                if (charsEq(c, cs, options.caseSensitive)) {\n                    return true\n                } else {\n                    continue\n                }",
                  "successors": [
                    {
                      "id": 5,
                      "label": "case CharSpecifier.CharRange(start, end) =>\n                if (!options.caseSensitive && c.isAscii() && start.isAscii() && end.isAscii()) {\n                    let sl = start.toAsciiLowerCase()\n                    let el = end.toAsciiLowerCase()\n\n                    let su = sl.toAsciiUpperCase()\n                    let eu = el.toAsciiUpperCase()\n\n                    if (sl != su && el != eu) {\n                        let cl = c.toAsciiLowerCase()\n                        if (cl >= sl && cl <= el) {\n                            return true;\n                        }\n                    }\n                }\nif (c >= start && c <= end) {\n                    return true\n                }",
                      "successors": []
                    }
                  ]
                }
              ]
            },
            {
              "id": 7,
              "label": "return false",
              "successors": []
            }
          ]
        }
      ]
    },
    {
      "name": "fillTodo",
      "type": "function",
      "start_line": 387,
      "end_line": 467,
      "functions": [],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 387,
          "line": "func fillTodo("
        },
        {
          "lineno": 388,
          "line": "    todo: ArrayList<(PathWrapper, Int64)>,"
        },
        {
          "lineno": 389,
          "line": "    patterns: Array<Pattern>,"
        },
        {
          "lineno": 390,
          "line": "    idx: Int,"
        },
        {
          "lineno": 391,
          "line": "    path: PathWrapper,"
        },
        {
          "lineno": 392,
          "line": "    options: MatchOptions"
        },
        {
          "lineno": 393,
          "line": "): Unit {"
        },
        {
          "lineno": 394,
          "line": "    let pattern = patterns[idx]"
        },
        {
          "lineno": 395,
          "line": "    let isDir = path.isDirectory"
        },
        {
          "lineno": 396,
          "line": "    let curDir = path.path.toString() == \".\""
        },
        {
          "lineno": 397,
          "line": ""
        },
        {
          "lineno": 398,
          "line": "    let add = {"
        },
        {
          "lineno": 399,
          "line": "        todo: ArrayList<(PathWrapper, Int64)>, nextPath: PathWrapper => if (idx + 1 == patterns.size) {"
        },
        {
          "lineno": 400,
          "line": "            todo.append((nextPath, Int64.Max))"
        },
        {
          "lineno": 401,
          "line": "        } else {"
        },
        {
          "lineno": 402,
          "line": "            fillTodo(todo, patterns, idx + 1, nextPath, options)"
        },
        {
          "lineno": 403,
          "line": "        }"
        },
        {
          "lineno": 404,
          "line": "    }"
        },
        {
          "lineno": 405,
          "line": ""
        },
        {
          "lineno": 406,
          "line": "    match (pattern.toCharString()) {"
        },
        {
          "lineno": 407,
          "line": "        case Some(s) =>"
        },
        {
          "lineno": 408,
          "line": "            let special = s == \".\" || s == \"..\""
        },
        {
          "lineno": 409,
          "line": "            let nextPath = if (curDir) {"
        },
        {
          "lineno": 410,
          "line": "                Path(s)"
        },
        {
          "lineno": 411,
          "line": "            } else {"
        },
        {
          "lineno": 412,
          "line": "                path.path.join(s)"
        },
        {
          "lineno": 413,
          "line": "            }"
        },
        {
          "lineno": 414,
          "line": "            let nextPathWrapper: PathWrapper"
        },
        {
          "lineno": 415,
          "line": "            try {"
        },
        {
          "lineno": 416,
          "line": "                nextPathWrapper = PathWrapper(nextPath)"
        },
        {
          "lineno": 417,
          "line": "            } catch (e: FSException) {"
        },
        {
          "lineno": 418,
          "line": "                return"
        },
        {
          "lineno": 419,
          "line": "            }"
        },
        {
          "lineno": 420,
          "line": "            if ((special && isDir) || !special) {"
        },
        {
          "lineno": 421,
          "line": "                add(todo, nextPathWrapper)"
        },
        {
          "lineno": 422,
          "line": "            }"
        },
        {
          "lineno": 423,
          "line": "        case None =>"
        },
        {
          "lineno": 424,
          "line": "            if (isDir) {"
        },
        {
          "lineno": 425,
          "line": "                let dirFiles = Directory.readFrom(path.path)"
        },
        {
          "lineno": 426,
          "line": "                let dirs = ArrayList<PathWrapper>()"
        },
        {
          "lineno": 427,
          "line": "                for (e in dirFiles) {"
        },
        {
          "lineno": 428,
          "line": "                    if (curDir) {"
        },
        {
          "lineno": 429,
          "line": "                        dirs.append(PathWrapper(Path(e.path.fileName), e.isDirectory()))"
        },
        {
          "lineno": 430,
          "line": "                    } else {"
        },
        {
          "lineno": 431,
          "line": "                        dirs.append(PathWrapper(e.path, e.isDirectory()))"
        },
        {
          "lineno": 432,
          "line": "                    }"
        },
        {
          "lineno": 433,
          "line": "                }"
        },
        {
          "lineno": 434,
          "line": "                var children = dirs.iterator()"
        },
        {
          "lineno": 435,
          "line": "                if (options.requireLiteralLeadingDot) {"
        },
        {
          "lineno": 436,
          "line": "                    children = children.filter {"
        },
        {
          "lineno": 437,
          "line": "                        c => !(c.path.fileName.startsWith(\".\"))"
        },
        {
          "lineno": 438,
          "line": "                    }"
        },
        {
          "lineno": 439,
          "line": "                }"
        },
        {
          "lineno": 440,
          "line": "                let cc = ArrayList<PathWrapper>()"
        },
        {
          "lineno": 441,
          "line": "                for (c in children) {"
        },
        {
          "lineno": 442,
          "line": "                    cc.append(c)"
        },
        {
          "lineno": 443,
          "line": "                }"
        },
        {
          "lineno": 444,
          "line": "                cc.sortBy {"
        },
        {
          "lineno": 445,
          "line": "                    l: PathWrapper, r: PathWrapper => if (l.path.fileName > r.path.fileName) {"
        },
        {
          "lineno": 446,
          "line": "                        Ordering.GT"
        },
        {
          "lineno": 447,
          "line": "                    } else if (l.path.fileName < r.path.fileName) {"
        },
        {
          "lineno": 448,
          "line": "                        Ordering.LT"
        },
        {
          "lineno": 449,
          "line": "                    } else {"
        },
        {
          "lineno": 450,
          "line": "                        Ordering.EQ"
        },
        {
          "lineno": 451,
          "line": "                    }"
        },
        {
          "lineno": 452,
          "line": "                }"
        },
        {
          "lineno": 453,
          "line": ""
        },
        {
          "lineno": 454,
          "line": "                for (c in cc) {"
        },
        {
          "lineno": 455,
          "line": "                    todo.append((c, idx))"
        },
        {
          "lineno": 456,
          "line": "                }"
        },
        {
          "lineno": 457,
          "line": ""
        },
        {
          "lineno": 458,
          "line": "                if (!pattern.tokens.isEmpty() && pattern.tokens[0] == PatternToken.Char(r'.')) {"
        },
        {
          "lineno": 459,
          "line": "                    for (sp in [\".\", \"..\"]) {"
        },
        {
          "lineno": 460,
          "line": "                        if (pattern.matchesWith(sp, options)) {"
        },
        {
          "lineno": 461,
          "line": "                            add(todo, PathWrapper(path.path.join(sp)))"
        },
        {
          "lineno": 462,
          "line": "                        }"
        },
        {
          "lineno": 463,
          "line": "                    }"
        },
        {
          "lineno": 464,
          "line": "                }"
        },
        {
          "lineno": 465,
          "line": "            }"
        },
        {
          "lineno": 466,
          "line": "    }"
        },
        {
          "lineno": 467,
          "line": "}"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "label": "func fillTodo(\n    todo: ArrayList<(PathWrapper, Int64)>,\n    patterns: Array<Pattern>,\n    idx: Int,\n    path: PathWrapper,\n    options: MatchOptions\n): Unit {\n    let pattern = patterns[idx]\n    let isDir = path.isDirectory\n    let curDir = path.path.toString() == \".\"\nlet add = {\n    todo: ArrayList<(PathWrapper, Int64)>, nextPath: PathWrapper => if (idx + 1 == patterns.size) {\n        todo.append((nextPath, Int64.Max))\n    } else {\n        fillTodo(todo, patterns, idx + 1, nextPath, options)\n    }\n}",
          "successors": [
            {
              "id": 3,
              "label": "match (pattern.toCharString()) {\n    case Some(s) =>\nlet special = s == \".\" || s == \"..\"\nlet nextPath = if (curDir) {\n    Path(s)\n} else {\n    path.path.join(s)\n}\nlet nextPathWrapper: PathWrapper\ntry {\n    nextPathWrapper = PathWrapper(nextPath)\n} catch (e: FSException) {\n    return\n}",
              "successors": [
                {
                  "id": 5,
                  "label": "if ((special && isDir) || !special) {\n    add(todo, nextPathWrapper)\n}\ncase None =>",
                  "successors": [
                    {
                      "id": 7,
                      "label": "if (isDir) {\n    let dirFiles = Directory.readFrom(path.path)\n    let dirs = ArrayList<PathWrapper>()\n    for (e in dirFiles) {\n        if (curDir) {\n            dirs.append(PathWrapper(Path(e.path.fileName), e.isDirectory()))\n        } else {\n            dirs.append(PathWrapper(e.path, e.isDirectory()))\n        }\n    }\n    var children = dirs.iterator()\n    if (options.requireLiteralLeadingDot) {\n        children = children.filter {\n            c => !(c.path.fileName.startsWith(\".\"))\n        }\n    }\n    let cc = ArrayList<PathWrapper>()\n    for (c in children) {\n        cc.append(c)\n    }\n    cc.sortBy {\n        l: PathWrapper, r: PathWrapper => if (l.path.fileName > r.path.fileName) {\n            Ordering.GT\n        } else if (l.path.fileName < r.path.fileName) {\n            Ordering.LT\n        } else {\n            Ordering.EQ\n        }\n    }\n\n    for (c in cc) {\n        todo.append((c, idx))\n    }\n\n    if (!pattern.tokens.isEmpty() && pattern.tokens[0] == PatternToken.Char(r'.')) {\n        for (sp in [\".\", \"..\"]) {\n            if (pattern.matchesWith(sp, options)) {\n                add(todo, PathWrapper(path.path.join(sp)))\n            }\n        }\n    }\n}\n}",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "checkWindowsVerbatim",
      "type": "function",
      "start_line": 349,
      "end_line": 370,
      "functions": [],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 349,
          "line": "func checkWindowsVerbatim(path: String): Bool {"
        },
        {
          "lineno": 350,
          "line": "    if (path.size < 4) {"
        },
        {
          "lineno": 351,
          "line": "        return false"
        },
        {
          "lineno": 352,
          "line": "    }"
        },
        {
          "lineno": 353,
          "line": "    let chars = path.toRuneArray()"
        },
        {
          "lineno": 354,
          "line": ""
        },
        {
          "lineno": 355,
          "line": "    let c0 = chars[0]"
        },
        {
          "lineno": 356,
          "line": "    let c1 = chars[1]"
        },
        {
          "lineno": 357,
          "line": "    let c2 = chars[2]"
        },
        {
          "lineno": 358,
          "line": "    let c3 = chars[3]"
        },
        {
          "lineno": 359,
          "line": ""
        },
        {
          "lineno": 360,
          "line": "    // \\\\.\\"
        },
        {
          "lineno": 361,
          "line": "    if (c0 == r'\\\\' && c1 == r'\\\\' && c2 == r'.' && c3 == r'\\\\') {"
        },
        {
          "lineno": 362,
          "line": "        return true"
        },
        {
          "lineno": 363,
          "line": "    }"
        },
        {
          "lineno": 364,
          "line": "    // \\\\?\\"
        },
        {
          "lineno": 365,
          "line": "    if (c0 == r'\\\\' && c1 == r'\\\\' && c2 == r'?' && c3 == r'\\\\') {"
        },
        {
          "lineno": 366,
          "line": "        return true"
        },
        {
          "lineno": 367,
          "line": "    }"
        },
        {
          "lineno": 368,
          "line": ""
        },
        {
          "lineno": 369,
          "line": "    return false"
        },
        {
          "lineno": 370,
          "line": "}"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "label": "func checkWindowsVerbatim(path: String): Bool {\nif (path.size < 4) {\n    return false\n}",
          "successors": [
            {
              "id": 3,
              "label": "let chars = path.toRuneArray()\nlet c0 = chars[0]\nlet c1 = chars[1]\nlet c2 = chars[2]\nlet c3 = chars[3]\nif (c0 == r'\\\\' && c1 == r'\\\\' && c2 == r'.' && c3 == r'\\\\') {\n    return true\n}",
              "successors": [
                {
                  "id": 5,
                  "label": "if (c0 == r'\\\\' && c1 == r'\\\\' && c2 == r'?' && c3 == r'\\\\') {\n    return true\n}\nreturn false",
                  "successors": []
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "getRoot",
      "type": "function",
      "start_line": 562,
      "end_line": 580,
      "functions": [],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 562,
          "line": "func getRoot(pattern: String): Option<String> {"
        },
        {
          "lineno": 563,
          "line": "    let chars = pattern.toRuneArray()"
        },
        {
          "lineno": 564,
          "line": ""
        },
        {
          "lineno": 565,
          "line": "    if (chars.size == 0) {"
        },
        {
          "lineno": 566,
          "line": "        return \"\""
        },
        {
          "lineno": 567,
          "line": "    }"
        },
        {
          "lineno": 568,
          "line": ""
        },
        {
          "lineno": 569,
          "line": "    if (chars[0] == r'/') {"
        },
        {
          "lineno": 570,
          "line": "        return \"/\""
        },
        {
          "lineno": 571,
          "line": "    }"
        },
        {
          "lineno": 572,
          "line": ""
        },
        {
          "lineno": 573,
          "line": "    if (chars.size >= 2) {"
        },
        {
          "lineno": 574,
          "line": "        if (chars[0].isAsciiLetter() && chars[1] == r':') {"
        },
        {
          "lineno": 575,
          "line": "            return pattern[0..2] + \"\\\\\""
        },
        {
          "lineno": 576,
          "line": "        }"
        },
        {
          "lineno": 577,
          "line": "    }"
        },
        {
          "lineno": 578,
          "line": ""
        },
        {
          "lineno": 579,
          "line": "    None"
        },
        {
          "lineno": 580,
          "line": "}"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "label": "func getRoot(pattern: String): Option<String> {\n    let chars = pattern.toRuneArray()",
          "successors": [
            {
              "id": 2,
              "label": "if (chars.size == 0) {\n        return \"\"\n}",
              "successors": []
            },
            {
              "id": 4,
              "label": "if (chars[0] == r'/') {\n        return \"/\"\n}",
              "successors": []
            },
            {
              "id": 6,
              "label": "if (chars.size >= 2) {\n        if (chars[0].isAsciiLetter() && chars[1] == r':') {\n            return pattern[0..2] + \"\\\\\"\n        }\n    }",
              "successors": []
            },
            {
              "id": 8,
              "label": "None\n}",
              "successors": []
            }
          ]
        }
      ]
    },
    {
      "name": "glob",
      "type": "function",
      "start_line": 612,
      "end_line": 614,
      "functions": [],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 612,
          "line": "public func glob(pattern: String): Paths {"
        },
        {
          "lineno": 613,
          "line": "    globWith(pattern, MatchOptions())"
        },
        {
          "lineno": 614,
          "line": "}"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "label": "public func glob(pattern: String): Paths {\n    globWith(pattern, MatchOptions())\n}",
          "successors": []
        }
      ]
    },
    {
      "name": "globWith",
      "type": "function",
      "start_line": 622,
      "end_line": 670,
      "functions": [],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 622,
          "line": "public func globWith(pattern: String, options: MatchOptions): Paths {"
        },
        {
          "lineno": 623,
          "line": "    let _ = Pattern(pattern)"
        },
        {
          "lineno": 624,
          "line": ""
        },
        {
          "lineno": 625,
          "line": "    if (checkWindowsVerbatim(pattern)) {"
        },
        {
          "lineno": 626,
          "line": "        throw PatternException(0, \"verbatim paths are not supported\")"
        },
        {
          "lineno": 627,
          "line": "    }"
        },
        {
          "lineno": 628,
          "line": ""
        },
        {
          "lineno": 629,
          "line": "    var root: String"
        },
        {
          "lineno": 630,
          "line": "    var foundRoot = false"
        },
        {
          "lineno": 631,
          "line": ""
        },
        {
          "lineno": 632,
          "line": "    match (getRoot(pattern)) {"
        },
        {
          "lineno": 633,
          "line": "        case Some(r) =>"
        },
        {
          "lineno": 634,
          "line": "            root = r"
        },
        {
          "lineno": 635,
          "line": "            foundRoot = true"
        },
        {
          "lineno": 636,
          "line": "        case None =>"
        },
        {
          "lineno": 637,
          "line": "            root = \".\""
        },
        {
          "lineno": 638,
          "line": "            foundRoot = false"
        },
        {
          "lineno": 639,
          "line": "    }"
        },
        {
          "lineno": 640,
          "line": ""
        },
        {
          "lineno": 641,
          "line": "    let dirPatterns = ArrayList<Pattern>()"
        },
        {
          "lineno": 642,
          "line": "    let skip = if (foundRoot) {"
        },
        {
          "lineno": 643,
          "line": "        root.size"
        },
        {
          "lineno": 644,
          "line": "    } else {"
        },
        {
          "lineno": 645,
          "line": "        0"
        },
        {
          "lineno": 646,
          "line": "    }"
        },
        {
          "lineno": 647,
          "line": "    let components = pattern[(min(skip, pattern.size))..].split(isSeparator)"
        },
        {
          "lineno": 648,
          "line": "    for (c in components) {"
        },
        {
          "lineno": 649,
          "line": "        dirPatterns.append(Pattern(c))"
        },
        {
          "lineno": 650,
          "line": "    }"
        },
        {
          "lineno": 651,
          "line": ""
        },
        {
          "lineno": 652,
          "line": "    if (foundRoot && root.size == pattern.size) {"
        },
        {
          "lineno": 653,
          "line": "        dirPatterns.append(Pattern(\"\"))"
        },
        {
          "lineno": 654,
          "line": "    }"
        },
        {
          "lineno": 655,
          "line": ""
        },
        {
          "lineno": 656,
          "line": "    let lastIsSeparator = if (pattern.size > 0) {"
        },
        {
          "lineno": 657,
          "line": "        let ra = pattern.toRuneArray()"
        },
        {
          "lineno": 658,
          "line": "        isSeparator(ra[ra.size - 1])"
        },
        {
          "lineno": 659,
          "line": "    } else {"
        },
        {
          "lineno": 660,
          "line": "        false"
        },
        {
          "lineno": 661,
          "line": "    }"
        },
        {
          "lineno": 662,
          "line": ""
        },
        {
          "lineno": 663,
          "line": "    return Paths("
        },
        {
          "lineno": 664,
          "line": "        dirPatterns.toArray(),"
        },
        {
          "lineno": 665,
          "line": "        lastIsSeparator,"
        },
        {
          "lineno": 666,
          "line": "        options,"
        },
        {
          "lineno": 667,
          "line": "        ArrayList<(PathWrapper, Int64)>(),"
        },
        {
          "lineno": 668,
          "line": "        PathWrapper(Path(root))"
        },
        {
          "lineno": 669,
          "line": "    )"
        },
        {
          "lineno": 670,
          "line": "}"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "label": "public func globWith(pattern: String, options: MatchOptions): Paths {\n    let _ = Pattern(pattern)\n\n    if (checkWindowsVerbatim(pattern)) {\n        throw PatternException(0, \"verbatim paths are not supported\")\n    }",
          "successors": [
            {
              "id": 3,
              "label": "\n    var root: String\n    var foundRoot = false\n\n    match (getRoot(pattern)) {\n        case Some(r) =>\n            root = r\n            foundRoot = true\n        case None =>\n            root = \".\"\n            foundRoot = false\n    }",
              "successors": [
                {
                  "id": 5,
                  "label": "\n    let dirPatterns = ArrayList<Pattern>()\n    let skip = if (foundRoot) {\n        root.size\n    } else {\n        0\n    }\n    let components = pattern[(min(skip, pattern.size))..].split(isSeparator)\n    for (c in components) {\n        dirPatterns.append(Pattern(c))\n    }",
                  "successors": [
                    {
                      "id": 7,
                      "label": "    \n    if (foundRoot && root.size == pattern.size) {\n        dirPatterns.append(Pattern(\"\"))\n    }\n\n    let lastIsSeparator = if (pattern.size > 0) {\n        let ra = pattern.toRuneArray()\n        isSeparator(ra[ra.size - 1])\n    } else {\n        false\n    }",
                      "successors": [
                        {
                          "id": 9,
                          "label": "\n    return Paths(\n        dirPatterns.toArray(),\n        lastIsSeparator,\n        options,\n        ArrayList<(PathWrapper, Int64)>(),\n        PathWrapper(Path(root))\n    )\n}",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    }
  ],
  "classes": [
    {
      "name": "PatternException",
      "type": "class",
      "start_line": 61,
      "end_line": 72,
      "functions": [
        {
          "name": "init",
          "type": "function",
          "start_line": 64,
          "end_line": 67,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 64,
              "line": "    public init(pos: Int, message: String) {"
            },
            {
              "lineno": 65,
              "line": "        super(message)"
            },
            {
              "lineno": 66,
              "line": "        this.pos = pos"
            },
            {
              "lineno": 67,
              "line": "    }"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "label": "    public init(pos: Int, message: String) {\n        super(message)\n        this.pos = pos\n    }",
              "successors": []
            }
          ]
        },
        {
          "name": "getClassName",
          "type": "function",
          "start_line": 69,
          "end_line": 71,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 69,
              "line": "    public override func getClassName(): String {"
            },
            {
              "lineno": 70,
              "line": "        \"PatternException\""
            },
            {
              "lineno": 71,
              "line": "    }"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "label": "    public override func getClassName(): String {\n        \"PatternException\"\n    }",
              "successors": []
            }
          ]
        }
      ],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 61,
          "line": "public class PatternException <: Exception {"
        },
        {
          "lineno": 62,
          "line": "    public let pos: Int"
        },
        {
          "lineno": 63,
          "line": ""
        },
        {
          "lineno": 68,
          "line": ""
        },
        {
          "lineno": 72,
          "line": "}"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "label": "public class PatternException <: Exception {\n    public let pos: Int\n\n\n}",
          "successors": []
        }
      ]
    },
    {
      "name": "CharsIterator",
      "type": "class",
      "start_line": 93,
      "end_line": 115,
      "functions": [
        {
          "name": "clone",
          "type": "function",
          "start_line": 102,
          "end_line": 104,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 102,
              "line": "    public func clone(): CharsIterator {"
            },
            {
              "lineno": 103,
              "line": "        return CharsIterator(this.chars, i: this.i)"
            },
            {
              "lineno": 104,
              "line": "    }"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "label": "    public func clone(): CharsIterator {\n        return CharsIterator(this.chars, i: this.i)\n    }",
              "successors": []
            }
          ]
        },
        {
          "name": "next",
          "type": "function",
          "start_line": 106,
          "end_line": 114,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 106,
              "line": "    public func next(): Option<Rune> {"
            },
            {
              "lineno": 107,
              "line": "        if (this.i < this.chars.size) {"
            },
            {
              "lineno": 108,
              "line": "            let c = this.chars[this.i]"
            },
            {
              "lineno": 109,
              "line": "            this.i++"
            },
            {
              "lineno": 110,
              "line": "            return Some(c)"
            },
            {
              "lineno": 111,
              "line": "        } else {"
            },
            {
              "lineno": 112,
              "line": "            return None"
            },
            {
              "lineno": 113,
              "line": "        }"
            },
            {
              "lineno": 114,
              "line": "    }"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "label": "    public func next(): Option<Rune> {",
              "successors": [
                {
                  "id": 2,
                  "label": "        if (this.i < this.chars.size) {\n            let c = this.chars[this.i]\n            this.i++\n            return Some(c)\n        }",
                  "successors": []
                },
                {
                  "id": 4,
                  "label": "        } else {\n            return None\n        }",
                  "successors": []
                }
              ]
            }
          ]
        }
      ],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 93,
          "line": "public class CharsIterator <: Iterator<Rune> {"
        },
        {
          "lineno": 94,
          "line": "    let chars: Array<Rune>"
        },
        {
          "lineno": 95,
          "line": "    var i: Int"
        },
        {
          "lineno": 96,
          "line": ""
        },
        {
          "lineno": 97,
          "line": "    init(c: Array<Rune>, i!: Int = 0) {"
        },
        {
          "lineno": 98,
          "line": "        this.chars = c"
        },
        {
          "lineno": 99,
          "line": "        this.i = i"
        },
        {
          "lineno": 100,
          "line": "    }"
        },
        {
          "lineno": 101,
          "line": ""
        },
        {
          "lineno": 105,
          "line": ""
        },
        {
          "lineno": 115,
          "line": "}"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "label": "public class CharsIterator <: Iterator<Rune> {\n    let chars: Array<Rune>\n    var i: Int\n\n    init(c: Array<Rune>, i!: Int = 0) {\n        this.chars = c\n        this.i = i\n    }\n\n\n}",
          "successors": []
        }
      ]
    },
    {
      "name": "Pattern",
      "type": "class",
      "start_line": 161,
      "end_line": 347,
      "functions": [
        {
          "name": "init",
          "type": "function",
          "start_line": 166,
          "end_line": 246,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 166,
              "line": "    init(pattern: String) {"
            },
            {
              "lineno": 167,
              "line": "        let chars = pattern.toRuneArray()"
            },
            {
              "lineno": 168,
              "line": "        let tokens = ArrayList<PatternToken>()"
            },
            {
              "lineno": 169,
              "line": "        var is_recursive = false"
            },
            {
              "lineno": 170,
              "line": "        var i = 0"
            },
            {
              "lineno": 171,
              "line": ""
            },
            {
              "lineno": 172,
              "line": "        while (i < chars.size) {"
            },
            {
              "lineno": 173,
              "line": "            match (chars[i]) {"
            },
            {
              "lineno": 174,
              "line": "                case r'?' =>"
            },
            {
              "lineno": 175,
              "line": "                    tokens.append(PatternToken.AnyChar)"
            },
            {
              "lineno": 176,
              "line": "                    i++"
            },
            {
              "lineno": 177,
              "line": "                case r'*' =>"
            },
            {
              "lineno": 178,
              "line": "                    let old = i"
            },
            {
              "lineno": 179,
              "line": ""
            },
            {
              "lineno": 180,
              "line": "                    while (i < chars.size && chars[i] == r'*') {"
            },
            {
              "lineno": 181,
              "line": "                        i++"
            },
            {
              "lineno": 182,
              "line": "                    }"
            },
            {
              "lineno": 183,
              "line": ""
            },
            {
              "lineno": 184,
              "line": "                    let count = i - old"
            },
            {
              "lineno": 185,
              "line": ""
            },
            {
              "lineno": 186,
              "line": "                    if (count > 2) {"
            },
            {
              "lineno": 187,
              "line": "                        throw PatternException(old + 2, ERROR_WILDCARDS)"
            },
            {
              "lineno": 188,
              "line": "                    } else if (count == 2) {"
            },
            {
              "lineno": 189,
              "line": "                        let is_valid = if (i == 2 || isSeparator(chars[i - count - 1])) {"
            },
            {
              "lineno": 190,
              "line": "                            if (i < chars.size && isSeparator(chars[i])) {"
            },
            {
              "lineno": 191,
              "line": "                                i++"
            },
            {
              "lineno": 192,
              "line": "                                true"
            },
            {
              "lineno": 193,
              "line": "                            } else if (i == chars.size) {"
            },
            {
              "lineno": 194,
              "line": "                                true"
            },
            {
              "lineno": 195,
              "line": "                            } else {"
            },
            {
              "lineno": 196,
              "line": "                                throw PatternException(i, ERROR_RECURSIVE_WILDCARDS)"
            },
            {
              "lineno": 197,
              "line": "                            }"
            },
            {
              "lineno": 198,
              "line": "                        } else {"
            },
            {
              "lineno": 199,
              "line": "                            throw PatternException(old - 1, ERROR_RECURSIVE_WILDCARDS)"
            },
            {
              "lineno": 200,
              "line": "                        }"
            },
            {
              "lineno": 201,
              "line": ""
            },
            {
              "lineno": 202,
              "line": "                        if (is_valid) {"
            },
            {
              "lineno": 203,
              "line": "                            let tokens_len = tokens.size"
            },
            {
              "lineno": 204,
              "line": ""
            },
            {
              "lineno": 205,
              "line": "                            if (!(tokens_len > 1 && tokens.get(tokens_len - 1) == PatternToken.AnyRecursiveSequence)) {"
            },
            {
              "lineno": 206,
              "line": "                                is_recursive = true"
            },
            {
              "lineno": 207,
              "line": "                                tokens.append(PatternToken.AnyRecursiveSequence)"
            },
            {
              "lineno": 208,
              "line": "                            }"
            },
            {
              "lineno": 209,
              "line": "                        }"
            },
            {
              "lineno": 210,
              "line": "                    } else {"
            },
            {
              "lineno": 211,
              "line": "                        tokens.append(PatternToken.AnySequence)"
            },
            {
              "lineno": 212,
              "line": "                    }"
            },
            {
              "lineno": 213,
              "line": "                case r'[' =>"
            },
            {
              "lineno": 214,
              "line": "                    if (i + 4 <= chars.size && chars[i + 1] == r'!') {"
            },
            {
              "lineno": 215,
              "line": "                        match (chars[i + 3..].indexOf(r']')) {"
            },
            {
              "lineno": 216,
              "line": "                            case None => ()"
            },
            {
              "lineno": 217,
              "line": "                            case Some(j) =>"
            },
            {
              "lineno": 218,
              "line": "                                let subChars = chars[i + 2..i + 3 + j]"
            },
            {
              "lineno": 219,
              "line": "                                let cs = parseCharSpecifiers(subChars)"
            },
            {
              "lineno": 220,
              "line": "                                tokens.append(PatternToken.AnyExcept(cs))"
            },
            {
              "lineno": 221,
              "line": "                                i += 4 + j"
            },
            {
              "lineno": 222,
              "line": "                                continue"
            },
            {
              "lineno": 223,
              "line": "                        }"
            },
            {
              "lineno": 224,
              "line": "                    } else if (i + 3 <= chars.size && chars[i + 1] != r'!') {"
            },
            {
              "lineno": 225,
              "line": "                        match (chars[i + 2..].indexOf(r']')) {"
            },
            {
              "lineno": 226,
              "line": "                            case None => ()"
            },
            {
              "lineno": 227,
              "line": "                            case Some(j) =>"
            },
            {
              "lineno": 228,
              "line": "                                let subChars = chars[i + 1..i + 2 + j]"
            },
            {
              "lineno": 229,
              "line": "                                let cs = parseCharSpecifiers(subChars)"
            },
            {
              "lineno": 230,
              "line": "                                tokens.append(PatternToken.AnyWithin(cs))"
            },
            {
              "lineno": 231,
              "line": "                                i += 3 + j"
            },
            {
              "lineno": 232,
              "line": "                                continue"
            },
            {
              "lineno": 233,
              "line": "                        }"
            },
            {
              "lineno": 234,
              "line": "                    }"
            },
            {
              "lineno": 235,
              "line": ""
            },
            {
              "lineno": 236,
              "line": "                    throw PatternException(i, ERROR_INVALID_RANGE)"
            },
            {
              "lineno": 237,
              "line": "                case c =>"
            },
            {
              "lineno": 238,
              "line": "                    tokens.append(PatternToken.Char(c))"
            },
            {
              "lineno": 239,
              "line": "                    i++"
            },
            {
              "lineno": 240,
              "line": "            }"
            },
            {
              "lineno": 241,
              "line": "        }"
            },
            {
              "lineno": 242,
              "line": ""
            },
            {
              "lineno": 243,
              "line": "        this.original = pattern"
            },
            {
              "lineno": 244,
              "line": "        this.tokens = tokens"
            },
            {
              "lineno": 245,
              "line": "        this.isRecursive = is_recursive"
            },
            {
              "lineno": 246,
              "line": "    }"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "label": "    init(pattern: String) {\n        let chars = pattern.toRuneArray()\n        let tokens = ArrayList<PatternToken>()\n        var is_recursive = false\n        var i = 0\n",
              "successors": [
                {
                  "id": 2,
                  "label": "        while (i < chars.size) {",
                  "successors": [
                    {
                      "id": 3,
                      "label": "            match (chars[i]) {\n                case r'?' =>\n                    tokens.append(PatternToken.AnyChar)\n                    i++",
                      "successors": [
                        {
                          "id": 5,
                          "label": "                case r'*' =>\n                    let old = i\n\n                    while (i < chars.size && chars[i] == r'*') {\n                        i++\n                    }\n\n                    let count = i - old\n\n                    if (count > 2) {\n                        throw PatternException(old + 2, ERROR_WILDCARDS)\n                    } else if (count == 2) {\n                        let is_valid = if (i == 2 || isSeparator(chars[i - count - 1])) {\n                            if (i < chars.size && isSeparator(chars[i])) {\n                                i++\n                                true\n                            } else if (i == chars.size) {\n                                true\n                            } else {\n                                throw PatternException(i, ERROR_RECURSIVE_WILDCARDS)\n                            }\n                        } else {\n                            throw PatternException(old - 1, ERROR_RECURSIVE_WILDCARDS)\n                        }\n\n                        if (is_valid) {\n                            let tokens_len = tokens.size\n\n                            if (!(tokens_len > 1 && tokens.get(tokens_len - 1) == PatternToken.AnyRecursiveSequence)) {\n                                is_recursive = true\n                                tokens.append(PatternToken.AnyRecursiveSequence)\n                            }\n                        }\n                    } else {\n                        tokens.append(PatternToken.AnySequence)\n                    }\n                case r'[' =>\n                    if (i + 4 <= chars.size && chars[i + 1] == r'!') {\n                        match (chars[i + 3..].indexOf(r']')) {\n                            case None => ()\n                            case Some(j) =>\n                                let subChars = chars[i + 2..i + 3 + j]\n                                let cs = parseCharSpecifiers(subChars)\n                                tokens.append(PatternToken.AnyExcept(cs))\n                                i += 4 + j\n                                continue\n                        }\n                    } else if (i + 3 <= chars.size && chars[i + 1] != r'!') {\n                        match (chars[i + 2..].indexOf(r']')) {\n                            case None => ()\n                            case Some(j) =>\n                                let subChars = chars[i + 1..i + 2 + j]\n                                let cs = parseCharSpecifiers(subChars)\n                                tokens.append(PatternToken.AnyWithin(cs))\n                                i += 3 + j\n                                continue\n                        }\n                    }\n\n                    throw PatternException(i, ERROR_INVALID_RANGE)",
                          "successors": [
                            {
                              "id": 7,
                              "label": "                case c =>\n                    tokens.append(PatternToken.Char(c))\n                    i++\n            }\n        }",
                              "successors": [
                                {
                                  "id": 9,
                                  "label": "        this.original = pattern\n        this.tokens = tokens\n        this.isRecursive = is_recursive\n    }",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "matches",
          "type": "function",
          "start_line": 248,
          "end_line": 250,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 248,
              "line": "    public func matches(str: String): Bool {"
            },
            {
              "lineno": 249,
              "line": "        this.matchesWith(str, MatchOptions())"
            },
            {
              "lineno": 250,
              "line": "    }"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "label": "    public func matches(str: String): Bool {\n        this.matchesWith(str, MatchOptions())\n    }",
              "successors": []
            }
          ]
        },
        {
          "name": "matchesWith",
          "type": "function",
          "start_line": 252,
          "end_line": 257,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 252,
              "line": "    public func matchesWith("
            },
            {
              "lineno": 253,
              "line": "        str: String,"
            },
            {
              "lineno": 254,
              "line": "        options: MatchOptions"
            },
            {
              "lineno": 255,
              "line": "    ): Bool {"
            },
            {
              "lineno": 256,
              "line": "        this.matchesFrom(true, CharsIterator(str.toRuneArray()), 0, options) == MatchResult.Match"
            },
            {
              "lineno": 257,
              "line": "    }"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "label": "    public func matchesWith(\n        str: String,\n        options: MatchOptions\n    ): Bool {\n        this.matchesFrom(true, CharsIterator(str.toRuneArray()), 0, options) == MatchResult.Match\n    }",
              "successors": []
            }
          ]
        },
        {
          "name": "matchesFrom",
          "type": "function",
          "start_line": 259,
          "end_line": 335,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 259,
              "line": "    public func matchesFrom("
            },
            {
              "lineno": 260,
              "line": "        followsSeparator: Bool,"
            },
            {
              "lineno": 261,
              "line": "        file: CharsIterator,"
            },
            {
              "lineno": 262,
              "line": "        i: Int,"
            },
            {
              "lineno": 263,
              "line": "        options: MatchOptions"
            },
            {
              "lineno": 264,
              "line": "    ): MatchResult {"
            },
            {
              "lineno": 265,
              "line": "        var fs = followsSeparator"
            },
            {
              "lineno": 266,
              "line": "        for ((ti, token) in this.tokens[i..].iterator().enumerate()) {"
            },
            {
              "lineno": 267,
              "line": "            match (token) {"
            },
            {
              "lineno": 268,
              "line": "                case AnySequence | AnyRecursiveSequence =>"
            },
            {
              "lineno": 269,
              "line": "                    match (this.matchesFrom(fs, file.clone(), i + ti + 1, options)) {"
            },
            {
              "lineno": 270,
              "line": "                        case MatchResult.SubPatternDoesntMatch => ()"
            },
            {
              "lineno": 271,
              "line": "                        case m => return m"
            },
            {
              "lineno": 272,
              "line": "                    }"
            },
            {
              "lineno": 273,
              "line": ""
            },
            {
              "lineno": 274,
              "line": "                    while (let Some(c) <- file.next()) {"
            },
            {
              "lineno": 275,
              "line": "                        if (fs && options.requireLiteralLeadingDot && c == r'.') {"
            },
            {
              "lineno": 276,
              "line": "                            return MatchResult.SubPatternDoesntMatch"
            },
            {
              "lineno": 277,
              "line": "                        }"
            },
            {
              "lineno": 278,
              "line": "                        fs = isSeparator(c)"
            },
            {
              "lineno": 279,
              "line": "                        match (token) {"
            },
            {
              "lineno": 280,
              "line": "                            case PatternToken.AnyRecursiveSequence =>"
            },
            {
              "lineno": 281,
              "line": "                                if (!fs) {"
            },
            {
              "lineno": 282,
              "line": "                                    continue"
            },
            {
              "lineno": 283,
              "line": "                                }"
            },
            {
              "lineno": 284,
              "line": "                            case PatternToken.AnySequence =>"
            },
            {
              "lineno": 285,
              "line": "                                if (options.requireLiteralSeparator && fs) {"
            },
            {
              "lineno": 286,
              "line": "                                    return MatchResult.SubPatternDoesntMatch"
            },
            {
              "lineno": 287,
              "line": "                                }"
            },
            {
              "lineno": 288,
              "line": "                            case _ => ()"
            },
            {
              "lineno": 289,
              "line": "                        }"
            },
            {
              "lineno": 290,
              "line": ""
            },
            {
              "lineno": 291,
              "line": "                        match (this.matchesFrom(fs, file.clone(), i + ti + 1, options)) {"
            },
            {
              "lineno": 292,
              "line": "                            case MatchResult.SubPatternDoesntMatch => ()"
            },
            {
              "lineno": 293,
              "line": "                            case m => return m"
            },
            {
              "lineno": 294,
              "line": "                        }"
            },
            {
              "lineno": 295,
              "line": "                    }"
            },
            {
              "lineno": 296,
              "line": "                case _ =>"
            },
            {
              "lineno": 297,
              "line": "                    let c = match (file.next()) {"
            },
            {
              "lineno": 298,
              "line": "                        case Some(c) => c"
            },
            {
              "lineno": 299,
              "line": "                        case None => return MatchResult.EntirePatternDoesntMatch"
            },
            {
              "lineno": 300,
              "line": "                    }"
            },
            {
              "lineno": 301,
              "line": ""
            },
            {
              "lineno": 302,
              "line": "                    let is_sep = isSeparator(c)"
            },
            {
              "lineno": 303,
              "line": ""
            },
            {
              "lineno": 304,
              "line": "                    if (!match (token) {"
            },
            {
              "lineno": 305,
              "line": "                        case PatternToken.AnyChar | PatternToken.AnyWithin(_) | AnyExcept(_) =>"
            },
            {
              "lineno": 306,
              "line": "                            if ((options.requireLiteralSeparator && is_sep) || (fs && options.requireLiteralLeadingDot &&"
            },
            {
              "lineno": 307,
              "line": "                                c == r'.')) {"
            },
            {
              "lineno": 308,
              "line": "                                false"
            },
            {
              "lineno": 309,
              "line": "                            } else {"
            },
            {
              "lineno": 310,
              "line": "                                true"
            },
            {
              "lineno": 311,
              "line": "                            }"
            },
            {
              "lineno": 312,
              "line": "                        case _ => true"
            },
            {
              "lineno": 313,
              "line": "                    }) {"
            },
            {
              "lineno": 314,
              "line": "                        return MatchResult.SubPatternDoesntMatch"
            },
            {
              "lineno": 315,
              "line": "                    }"
            },
            {
              "lineno": 316,
              "line": ""
            },
            {
              "lineno": 317,
              "line": "                    if (!match (token) {"
            },
            {
              "lineno": 318,
              "line": "                        case PatternToken.AnyChar => true"
            },
            {
              "lineno": 319,
              "line": "                        case PatternToken.AnyWithin(cs) => inCharSpecifiers(cs, c, options)"
            },
            {
              "lineno": 320,
              "line": "                        case PatternToken.AnyExcept(cs) => !inCharSpecifiers(cs, c, options)"
            },
            {
              "lineno": 321,
              "line": "                        case PatternToken.Char(tc) => charsEq(c, tc, options.caseSensitive)"
            },
            {
              "lineno": 322,
              "line": "                        case _ => throw Exception(\"unreachable\")"
            },
            {
              "lineno": 323,
              "line": "                    }) {"
            },
            {
              "lineno": 324,
              "line": "                        return MatchResult.SubPatternDoesntMatch"
            },
            {
              "lineno": 325,
              "line": "                    }"
            },
            {
              "lineno": 326,
              "line": "                    fs = is_sep"
            },
            {
              "lineno": 327,
              "line": "            }"
            },
            {
              "lineno": 328,
              "line": "        }"
            },
            {
              "lineno": 329,
              "line": ""
            },
            {
              "lineno": 330,
              "line": "        if (file.next().isNone()) {"
            },
            {
              "lineno": 331,
              "line": "            return MatchResult.Match"
            },
            {
              "lineno": 332,
              "line": "        } else {"
            },
            {
              "lineno": 333,
              "line": "            return MatchResult.SubPatternDoesntMatch"
            },
            {
              "lineno": 334,
              "line": "        }"
            },
            {
              "lineno": 335,
              "line": "    }"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "label": "    public func matchesFrom(\n        followsSeparator: Bool,\n        file: CharsIterator,\n        i: Int,\n        options: MatchOptions\n    ): MatchResult {",
              "successors": [
                {
                  "id": 3,
                  "label": "        var fs = followsSeparator",
                  "successors": [
                    {
                      "id": 4,
                      "label": "        for ((ti, token) in this.tokens[i..].iterator().enumerate()) {",
                      "successors": [
                        {
                          "id": 5,
                          "label": "            match (token) {\n                case AnySequence | AnyRecursiveSequence =>\n                    match (this.matchesFrom(fs, file.clone(), i + ti + 1, options)) {\n                        case MatchResult.SubPatternDoesntMatch => ()\n                        case m => return m",
                          "successors": [
                            {
                              "id": 7,
                              "label": "                    while (let Some(c) <- file.next()) {\n                        if (fs && options.requireLiteralLeadingDot && c == r'.') {\n                            return MatchResult.SubPatternDoesntMatch\n                        }\n                        fs = isSeparator(c)\n                        match (token) {\n                            case PatternToken.AnyRecursiveSequence =>\n                                if (!fs) {\n                                    continue\n                                }\n                            case PatternToken.AnySequence =>\n                                if (options.requireLiteralSeparator && fs) {\n                                    return MatchResult.SubPatternDoesntMatch\n                                }\n                            case _ => ()\n                        }\n\n                        match (this.matchesFrom(fs, file.clone(), i + ti + 1, options)) {\n                            case MatchResult.SubPatternDoesntMatch => ()\n                            case m => return m\n                        }\n                    }",
                              "successors": [
                                {
                                  "id": 8,
                                  "label": "                case _ =>\n                    let c = match (file.next()) {\n                        case Some(c) => c\n                        case None => return MatchResult.EntirePatternDoesntMatch\n                    let is_sep = isSeparator(c)\n\n                    if (!match (token) {\n                        case PatternToken.AnyChar | PatternToken.AnyWithin(_) | AnyExcept(_) =>\n                            if ((options.requireLiteralSeparator && is_sep) || (fs && options.requireLiteralLeadingDot &&\n                                c == r'.')) {\n                                false\n                            } else {\n                                true\n                            }\n                        case _ => true\n                    }) {\n                        return MatchResult.SubPatternDoesntMatch\n                    }\n\n                    if (!match (token) {\n                        case PatternToken.AnyChar => true\n                        case PatternToken.AnyWithin(cs) => inCharSpecifiers(cs, c, options)\n                        case PatternToken.AnyExcept(cs) => !inCharSpecifiers(cs, c, options)\n                        case PatternToken.Char(tc) => charsEq(c, tc, options.caseSensitive)\n                        case _ => throw Exception(\"unreachable\")\n                    }) {\n                        return MatchResult.SubPatternDoesntMatch\n                    }\n                    fs = is_sep",
                                  "successors": [
                                    {
                                      "id": 10,
                                      "label": "        }\n        if (file.next().isNone()) {\n            return MatchResult.Match\n        } else {\n            return MatchResult.SubPatternDoesntMatch\n        }",
                                      "successors": []
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "toCharString",
          "type": "function",
          "start_line": 337,
          "end_line": 346,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 337,
              "line": "    func toCharString(): Option<String> {"
            },
            {
              "lineno": 338,
              "line": "        let ret = StringBuilder()"
            },
            {
              "lineno": 339,
              "line": "        for (token in this.tokens) {"
            },
            {
              "lineno": 340,
              "line": "            match (token) {"
            },
            {
              "lineno": 341,
              "line": "                case Char(c) => ret.append(c)"
            },
            {
              "lineno": 342,
              "line": "                case _ => return None"
            },
            {
              "lineno": 343,
              "line": "            }"
            },
            {
              "lineno": 344,
              "line": "        }"
            },
            {
              "lineno": 345,
              "line": "        return ret.toString()"
            },
            {
              "lineno": 346,
              "line": "    }"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "label": "    func toCharString(): Option<String> {\n        let ret = StringBuilder()",
              "successors": [
                {
                  "id": 2,
                  "label": "        for (token in this.tokens) {\n            match (token) {\n                case Char(c) => ret.append(c)\n                case _ => return None\n            }\n        }",
                  "successors": [
                    {
                      "id": 3,
                      "label": "        return ret.toString()",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 161,
          "line": "public struct Pattern {"
        },
        {
          "lineno": 162,
          "line": "    let original: String"
        },
        {
          "lineno": 163,
          "line": "    let tokens: ArrayList<PatternToken>"
        },
        {
          "lineno": 164,
          "line": "    let isRecursive: Bool"
        },
        {
          "lineno": 165,
          "line": ""
        },
        {
          "lineno": 247,
          "line": ""
        },
        {
          "lineno": 251,
          "line": ""
        },
        {
          "lineno": 258,
          "line": ""
        },
        {
          "lineno": 336,
          "line": ""
        },
        {
          "lineno": 347,
          "line": "}"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "label": "public struct Pattern {\n    let original: String\n    let tokens: ArrayList<PatternToken>\n    let isRecursive: Bool\n}",
          "successors": []
        }
      ]
    },
    {
      "name": "PathWrapper",
      "type": "class",
      "start_line": 372,
      "end_line": 385,
      "functions": [
        {
          "name": "init",
          "type": "function",
          "start_line": 376,
          "end_line": 379,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 376,
              "line": "    init(path: Path) {"
            },
            {
              "lineno": 377,
              "line": "        this.path = path"
            },
            {
              "lineno": 378,
              "line": "        this.isDirectory = FileInfo(path).isDirectory()"
            },
            {
              "lineno": 379,
              "line": "    }"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "label": "    init(path: Path) {\n        this.path = path\n        this.isDirectory = FileInfo(path).isDirectory()\n    }",
              "successors": []
            }
          ]
        },
        {
          "name": "init",
          "type": "function",
          "start_line": 381,
          "end_line": 384,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 381,
              "line": "    init(path: Path, isDirectory: Bool) {"
            },
            {
              "lineno": 382,
              "line": "        this.path = path"
            },
            {
              "lineno": 383,
              "line": "        this.isDirectory = isDirectory"
            },
            {
              "lineno": 384,
              "line": "    }"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "label": "    init(path: Path, isDirectory: Bool) {\n        this.path = path\n        this.isDirectory = isDirectory\n    }",
              "successors": []
            }
          ]
        }
      ],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 372,
          "line": "public struct PathWrapper {"
        },
        {
          "lineno": 373,
          "line": "    public let path: Path"
        },
        {
          "lineno": 374,
          "line": "    let isDirectory: Bool"
        },
        {
          "lineno": 375,
          "line": ""
        },
        {
          "lineno": 380,
          "line": ""
        },
        {
          "lineno": 385,
          "line": "}"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "label": "public struct PathWrapper {\n    public let path: Path\n    let isDirectory: Bool",
          "successors": [
            {
              "id": 3,
              "label": "}",
              "successors": []
            }
          ]
        }
      ]
    },
    {
      "name": "Paths",
      "type": "class",
      "start_line": 469,
      "end_line": 560,
      "functions": [
        {
          "name": "init",
          "type": "function",
          "start_line": 477,
          "end_line": 489,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 477,
              "line": "    init("
            },
            {
              "lineno": 478,
              "line": "        dirPatterns: Array<Pattern>,"
            },
            {
              "lineno": 479,
              "line": "        requireDir: Bool,"
            },
            {
              "lineno": 480,
              "line": "        options: MatchOptions,"
            },
            {
              "lineno": 481,
              "line": "        todo: ArrayList<(PathWrapper, Int64)>,"
            },
            {
              "lineno": 482,
              "line": "        scope: PathWrapper"
            },
            {
              "lineno": 483,
              "line": "    ) {"
            },
            {
              "lineno": 484,
              "line": "        this.dirPatterns = dirPatterns"
            },
            {
              "lineno": 485,
              "line": "        this.requireDir = requireDir"
            },
            {
              "lineno": 486,
              "line": "        this.options = options"
            },
            {
              "lineno": 487,
              "line": "        this.todo = todo"
            },
            {
              "lineno": 488,
              "line": "        this.scope = scope"
            },
            {
              "lineno": 489,
              "line": "    }"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "label": "    init(\n        dirPatterns: Array<Pattern>,\n        requireDir: Bool,\n        options: MatchOptions,\n        todo: ArrayList<(PathWrapper, Int64)>,\n        scope: PathWrapper\n    ) {\n        this.dirPatterns = dirPatterns\n        this.requireDir = requireDir\n        this.options = options\n        this.todo = todo\n        this.scope = scope\n    }",
              "successors": []
            }
          ]
        },
        {
          "name": "next",
          "type": "function",
          "start_line": 491,
          "end_line": 559,
          "functions": [],
          "classes": [],
          "simplified_code": [
            {
              "lineno": 491,
              "line": "    public func next(): Option<Path> {"
            },
            {
              "lineno": 492,
              "line": "        if (!this.initialized) {"
            },
            {
              "lineno": 493,
              "line": "            this.initialized = true"
            },
            {
              "lineno": 494,
              "line": "            if (!this.dirPatterns.isEmpty()) {"
            },
            {
              "lineno": 495,
              "line": "                fillTodo(this.todo, this.dirPatterns, 0, this.scope, this.options)"
            },
            {
              "lineno": 496,
              "line": "            }"
            },
            {
              "lineno": 497,
              "line": "        }"
            },
            {
              "lineno": 498,
              "line": "        while (true) {"
            },
            {
              "lineno": 499,
              "line": "            if (this.dirPatterns.isEmpty() || this.todo.isEmpty()) {"
            },
            {
              "lineno": 500,
              "line": "                return None"
            },
            {
              "lineno": 501,
              "line": "            }"
            },
            {
              "lineno": 502,
              "line": ""
            },
            {
              "lineno": 503,
              "line": "            let t = this.todo.remove(this.todo.size - 1)"
            },
            {
              "lineno": 504,
              "line": "            let path = t[0]"
            },
            {
              "lineno": 505,
              "line": "            var idx = t[1]"
            },
            {
              "lineno": 506,
              "line": ""
            },
            {
              "lineno": 507,
              "line": "            if (idx == Int64.Max) {"
            },
            {
              "lineno": 508,
              "line": "                if (this.requireDir && !path.isDirectory) {"
            },
            {
              "lineno": 509,
              "line": "                    continue"
            },
            {
              "lineno": 510,
              "line": "                }"
            },
            {
              "lineno": 511,
              "line": "                return Some(path.path)"
            },
            {
              "lineno": 512,
              "line": "            }"
            },
            {
              "lineno": 513,
              "line": ""
            },
            {
              "lineno": 514,
              "line": "            if (this.dirPatterns[idx].isRecursive) {"
            },
            {
              "lineno": 515,
              "line": "                var next = idx"
            },
            {
              "lineno": 516,
              "line": "                while (next + 1 < this.dirPatterns.size && this.dirPatterns[next + 1].isRecursive) {"
            },
            {
              "lineno": 517,
              "line": "                    next++"
            },
            {
              "lineno": 518,
              "line": "                }"
            },
            {
              "lineno": 519,
              "line": ""
            },
            {
              "lineno": 520,
              "line": "                if (path.isDirectory) {"
            },
            {
              "lineno": 521,
              "line": "                    fillTodo("
            },
            {
              "lineno": 522,
              "line": "                        this.todo,"
            },
            {
              "lineno": 523,
              "line": "                        this.dirPatterns,"
            },
            {
              "lineno": 524,
              "line": "                        next,"
            },
            {
              "lineno": 525,
              "line": "                        path,"
            },
            {
              "lineno": 526,
              "line": "                        this.options"
            },
            {
              "lineno": 527,
              "line": "                    )"
            },
            {
              "lineno": 528,
              "line": ""
            },
            {
              "lineno": 529,
              "line": "                    if (next == this.dirPatterns.size - 1) {"
            },
            {
              "lineno": 530,
              "line": "                        return Some(path.path)"
            },
            {
              "lineno": 531,
              "line": "                    } else {"
            },
            {
              "lineno": 532,
              "line": "                        idx = next + 1"
            },
            {
              "lineno": 533,
              "line": "                    }"
            },
            {
              "lineno": 534,
              "line": "                } else if (next == this.dirPatterns.size - 1) {"
            },
            {
              "lineno": 535,
              "line": "                    continue"
            },
            {
              "lineno": 536,
              "line": "                } else {"
            },
            {
              "lineno": 537,
              "line": "                    idx = next + 1"
            },
            {
              "lineno": 538,
              "line": "                }"
            },
            {
              "lineno": 539,
              "line": "            }"
            },
            {
              "lineno": 540,
              "line": ""
            },
            {
              "lineno": 541,
              "line": "            if (this.dirPatterns[idx].matchesWith(path.path.fileName, this.options)) {"
            },
            {
              "lineno": 542,
              "line": "                if (idx == this.dirPatterns.size - 1) {"
            },
            {
              "lineno": 543,
              "line": "                    if (!this.requireDir || path.isDirectory) {"
            },
            {
              "lineno": 544,
              "line": "                        return Some(path.path)"
            },
            {
              "lineno": 545,
              "line": "                    }"
            },
            {
              "lineno": 546,
              "line": "                } else {"
            },
            {
              "lineno": 547,
              "line": "                    fillTodo("
            },
            {
              "lineno": 548,
              "line": "                        this.todo,"
            },
            {
              "lineno": 549,
              "line": "                        this.dirPatterns,"
            },
            {
              "lineno": 550,
              "line": "                        idx + 1,"
            },
            {
              "lineno": 551,
              "line": "                        path,"
            },
            {
              "lineno": 552,
              "line": "                        this.options"
            },
            {
              "lineno": 553,
              "line": "                    )"
            },
            {
              "lineno": 554,
              "line": "                }"
            },
            {
              "lineno": 555,
              "line": "            }"
            },
            {
              "lineno": 556,
              "line": "        }"
            },
            {
              "lineno": 557,
              "line": ""
            },
            {
              "lineno": 558,
              "line": "        None"
            },
            {
              "lineno": 559,
              "line": "    }"
            }
          ],
          "blocks": [
            {
              "id": 1,
              "label": "    public func next(): Option<Path> {",
              "successors": [
                {
                  "id": 2,
                  "label": "        if (!this.initialized) {\n            this.initialized = true\n            if (!this.dirPatterns.isEmpty()) {\n                fillTodo(this.todo, this.dirPatterns, 0, this.scope, this.options)\n            }",
                  "successors": []
                },
                {
                  "id": 4,
                  "label": "        while (true) {\n            if (this.dirPatterns.isEmpty() || this.todo.isEmpty()) {\n                return None\n            }\n\n            let t = this.todo.remove(this.todo.size - 1)\n            let path = t[0]\n            var idx = t[1]\n\n            if (idx == Int64.Max) {\n                if (this.requireDir && !path.isDirectory) {\n                    continue\n                }\n                return Some(path.path)\n            }\n\n            if (this.dirPatterns[idx].isRecursive) {\n                var next = idx\n                while (next + 1 < this.dirPatterns.size && this.dirPatterns[next + 1].isRecursive) {\n                    next++\n                }\n\n                if (path.isDirectory) {\n                    fillTodo(\n                        this.todo,\n                        this.dirPatterns,\n                        next,\n                        path,\n                        this.options\n                    )\n\n                    if (next == this.dirPatterns.size - 1) {\n                        return Some(path.path)\n                    } else {\n                        idx = next + 1\n                    }\n                } else if (next == this.dirPatterns.size - 1) {\n                    continue\n                } else {\n                    idx = next + 1\n                }\n            }\n\n            if (this.dirPatterns[idx].matchesWith(path.path.fileName, this.options)) {\n                if (idx == this.dirPatterns.size - 1) {\n                    if (!this.requireDir || path.isDirectory) {\n                        return Some(path.path)\n                    }\n                } else {\n                    fillTodo(\n                        this.todo,\n                        this.dirPatterns,\n                        idx + 1,\n                        path,\n                        this.options\n                    )\n                }\n            }\n        }",
                  "successors": []
                },
                {
                  "id": 5,
                  "label": "        None\n    }",
                  "successors": []
                }
              ]
            }
          ]
        }
      ],
      "classes": [],
      "simplified_code": [
        {
          "lineno": 469,
          "line": "public class Paths <: Iterator<Path> {"
        },
        {
          "lineno": 470,
          "line": "    let dirPatterns: Array<Pattern>"
        },
        {
          "lineno": 471,
          "line": "    let requireDir: Bool"
        },
        {
          "lineno": 472,
          "line": "    let options: MatchOptions"
        },
        {
          "lineno": 473,
          "line": "    let todo: ArrayList<(PathWrapper, Int64)>"
        },
        {
          "lineno": 474,
          "line": "    let scope: PathWrapper"
        },
        {
          "lineno": 475,
          "line": "    var initialized: Bool = false"
        },
        {
          "lineno": 476,
          "line": ""
        },
        {
          "lineno": 490,
          "line": ""
        },
        {
          "lineno": 560,
          "line": "}"
        }
      ],
      "blocks": [
        {
          "id": 1,
          "label": "public class Paths <: Iterator<Path> {\n    let dirPatterns: Array<Pattern>\n    let requireDir: Bool\n    let options: MatchOptions\n    let todo: ArrayList<(PathWrapper, Int64)>\n    let scope: PathWrapper\n    var initialized: Bool = false\n}",
          "successors": []
        }
      ]
    }
  ],
  "simplified_code": [
    {
      "lineno": 1,
      "line": "package glob"
    },
    {
      "lineno": 2,
      "line": ""
    },
    {
      "lineno": 3,
      "line": "import std.regex.Regex"
    },
    {
      "lineno": 4,
      "line": "import std.collection.ArrayList"
    },
    {
      "lineno": 5,
      "line": "import std.fs.{Directory, Path, FileInfo, FSException}"
    },
    {
      "lineno": 6,
      "line": "import std.deriving.Derive"
    },
    {
      "lineno": 7,
      "line": ""
    },
    {
      "lineno": 8,
      "line": "// cjlint-ignore -start !G.OPR.01 !G.NAM.04 !G.ITF.04 macro"
    },
    {
      "lineno": 9,
      "line": "@Derive[Equatable]"
    },
    {
      "lineno": 10,
      "line": "enum CharSpecifier {"
    },
    {
      "lineno": 11,
      "line": "    SingleChar(Rune)"
    },
    {
      "lineno": 12,
      "line": "    | CharRange(Rune, Rune)"
    },
    {
      "lineno": 13,
      "line": "}"
    },
    {
      "lineno": 14,
      "line": ""
    },
    {
      "lineno": 15,
      "line": "@Derive[Equatable]"
    },
    {
      "lineno": 16,
      "line": "enum PatternToken {"
    },
    {
      "lineno": 17,
      "line": "    Char(Rune)"
    },
    {
      "lineno": 18,
      "line": "    | AnyChar"
    },
    {
      "lineno": 19,
      "line": "    | AnySequence"
    },
    {
      "lineno": 20,
      "line": "    | AnyRecursiveSequence"
    },
    {
      "lineno": 21,
      "line": "    | AnyWithin(Array<CharSpecifier>)"
    },
    {
      "lineno": 22,
      "line": "    | AnyExcept(Array<CharSpecifier>)"
    },
    {
      "lineno": 23,
      "line": "}"
    },
    {
      "lineno": 24,
      "line": ""
    },
    {
      "lineno": 25,
      "line": "public struct MatchOptions {"
    },
    {
      "lineno": 26,
      "line": "    /**"
    },
    {
      "lineno": 27,
      "line": "     * 是否以大小写敏感的方式匹配模式。"
    },
    {
      "lineno": 28,
      "line": "     * 目前只考虑 ASCII 字符之间的大/小写关系，"
    },
    {
      "lineno": 29,
      "line": "     * 但将来可能会扩展到适用于 Unicode。"
    },
    {
      "lineno": 30,
      "line": "     */"
    },
    {
      "lineno": 31,
      "line": "    public var caseSensitive: Bool = false"
    },
    {
      "lineno": 32,
      "line": ""
    },
    {
      "lineno": 33,
      "line": "    /**"
    },
    {
      "lineno": 34,
      "line": "     * 是否要求路径分隔符字符（例如 Posix 上的 `/`）必须由字面量 `/` 匹配，"
    },
    {
      "lineno": 35,
      "line": "     * 而不是由 `*` 或 `?` 或 `[...]` 匹配。"
    },
    {
      "lineno": 36,
      "line": "     */"
    },
    {
      "lineno": 37,
      "line": "    public var requireLiteralSeparator: Bool = false"
    },
    {
      "lineno": 38,
      "line": ""
    },
    {
      "lineno": 39,
      "line": "    /**"
    },
    {
      "lineno": 40,
      "line": "     * 是否要求路径组件的开头是 `.` 字符，必须由字面量 `.` 匹配，"
    },
    {
      "lineno": 41,
      "line": "     * 而不是由 `*` 或 `?` 或 `**` 或 `[...]` 匹配。"
    },
    {
      "lineno": 42,
      "line": "     * 这对于 Unix 系统上被传统认为是隐藏的文件很有用，"
    },
    {
      "lineno": 43,
      "line": "     * 可能希望在列出文件时跳过它们。"
    },
    {
      "lineno": 44,
      "line": "     */"
    },
    {
      "lineno": 45,
      "line": "    public var requireLiteralLeadingDot: Bool = false"
    },
    {
      "lineno": 46,
      "line": "}"
    },
    {
      "lineno": 47,
      "line": ""
    },
    {
      "lineno": 48,
      "line": "@Derive[Equatable]"
    },
    {
      "lineno": 49,
      "line": "public enum MatchResult {"
    },
    {
      "lineno": 50,
      "line": "    Match"
    },
    {
      "lineno": 51,
      "line": "    | SubPatternDoesntMatch"
    },
    {
      "lineno": 52,
      "line": "    | EntirePatternDoesntMatch"
    },
    {
      "lineno": 53,
      "line": "}"
    },
    {
      "lineno": 54,
      "line": ""
    },
    {
      "lineno": 55,
      "line": "// cjlint-ignore -end macro"
    },
    {
      "lineno": 56,
      "line": ""
    },
    {
      "lineno": 57,
      "line": "const ERROR_WILDCARDS = \"wildcards are either regular `*` or recursive `**`\";"
    },
    {
      "lineno": 58,
      "line": "const ERROR_RECURSIVE_WILDCARDS = \"recursive wildcards must form a single path component\";"
    },
    {
      "lineno": 59,
      "line": "const ERROR_INVALID_RANGE = \"invalid range pattern\";"
    },
    {
      "lineno": 60,
      "line": ""
    },
    {
      "lineno": 73,
      "line": ""
    },
    {
      "lineno": 77,
      "line": ""
    },
    {
      "lineno": 92,
      "line": ""
    },
    {
      "lineno": 116,
      "line": ""
    },
    {
      "lineno": 124,
      "line": ""
    },
    {
      "lineno": 125,
      "line": "// cjlint-ignore -start !G.FUN.01 fun"
    },
    {
      "lineno": 160,
      "line": ""
    },
    {
      "lineno": 348,
      "line": ""
    },
    {
      "lineno": 371,
      "line": ""
    },
    {
      "lineno": 386,
      "line": ""
    },
    {
      "lineno": 468,
      "line": ""
    },
    {
      "lineno": 561,
      "line": ""
    },
    {
      "lineno": 581,
      "line": ""
    },
    {
      "lineno": 582,
      "line": "extend String {"
    },
    {
      "lineno": 583,
      "line": "    func split(checker: (Rune) -> Bool): Array<String> {"
    },
    {
      "lineno": 584,
      "line": "        let chars = this.toRuneArray()"
    },
    {
      "lineno": 585,
      "line": "        let ret = ArrayList<String>()"
    },
    {
      "lineno": 586,
      "line": "        var start = 0"
    },
    {
      "lineno": 587,
      "line": "        var i = 0"
    },
    {
      "lineno": 588,
      "line": ""
    },
    {
      "lineno": 589,
      "line": "        while (i < chars.size) {"
    },
    {
      "lineno": 590,
      "line": "            if (checker(chars[i])) {"
    },
    {
      "lineno": 591,
      "line": "                if (start < i) {"
    },
    {
      "lineno": 592,
      "line": "                    ret.append(this[start..i])"
    },
    {
      "lineno": 593,
      "line": "                }"
    },
    {
      "lineno": 594,
      "line": "                start = i + 1"
    },
    {
      "lineno": 595,
      "line": "            }"
    },
    {
      "lineno": 596,
      "line": "            i++"
    },
    {
      "lineno": 597,
      "line": "        }"
    },
    {
      "lineno": 598,
      "line": ""
    },
    {
      "lineno": 599,
      "line": "        if (start < i) {"
    },
    {
      "lineno": 600,
      "line": "            ret.append(this[start..i])"
    },
    {
      "lineno": 601,
      "line": "        }"
    },
    {
      "lineno": 602,
      "line": ""
    },
    {
      "lineno": 603,
      "line": "        return ret.toArray()"
    },
    {
      "lineno": 604,
      "line": "    }"
    },
    {
      "lineno": 605,
      "line": "}"
    },
    {
      "lineno": 606,
      "line": ""
    },
    {
      "lineno": 607,
      "line": "/** 返回一个迭代器，使用默认匹配选项生成与给定模式匹配的所有 Path。 "
    },
    {
      "lineno": 608,
      "line": " * 这些路径可以是绝对路径，也可以是相对于当前工作目录的相对路径。"
    },
    {
      "lineno": 609,
      "line": " *"
    },
    {
      "lineno": 610,
      "line": " * 如果模式无效，则可能会引发 PatternException。"
    },
    {
      "lineno": 611,
      "line": " */"
    },
    {
      "lineno": 615,
      "line": ""
    },
    {
      "lineno": 616,
      "line": "/** 返回一个迭代器，使用给定的匹配选项生成与给定模式匹配的所有 Path。 "
    },
    {
      "lineno": 617,
      "line": " * 这些路径可以是绝对路径，也可以是相对于当前工作目录的相对路径。"
    },
    {
      "lineno": 618,
      "line": " * 此函数允许您指定匹配选项，例如大小写敏感性。"
    },
    {
      "lineno": 619,
      "line": " *"
    },
    {
      "lineno": 620,
      "line": " * 如果模式无效，则可能会引发 PatternException。"
    },
    {
      "lineno": 621,
      "line": " */"
    },
    {
      "lineno": 671,
      "line": ""
    },
    {
      "lineno": 672,
      "line": "// cjlint-ignore -end fun"
    }
  ],
  "blocks": [
    {
      "id": 1,
      "label": "package glob\nimport std.regex.Regex\nimport std.collection.ArrayList\nimport std.fs.{Directory, Path, FileInfo, FSException}",
      "successors": [
        {
          "id": 3,
          "label": "import std.deriving.Derive\n@Derive[Equatable]\nenum CharSpecifier {\n    SingleChar(Rune)\n    | CharRange(Rune, Rune)\n}",
          "successors": [
            {
              "id": 5,
              "label": "@Derive[Equatable]\nenum PatternToken {\n    Char(Rune)\n    | AnyChar\n    | AnySequence\n    | AnyRecursiveSequence\n    | AnyWithin(Array<CharSpecifier>)\n    | AnyExcept(Array<CharSpecifier>)\n}\npublic struct MatchOptions {\n    /**\n     * 是是否以大小写敏感的方式匹配模式。\n     * 目前只考虑 ASCII 字符之间的大/小写关系，\n     * 但将来可能会扩展到适用于 Unicode。\n     */\n    public var caseSensitive: Bool = false\n\n    /**\n     * 是否要求路径分隔符字符（例如 Posix 上的 `\\`）必须由字面量 `/` 匹配，\n     * 而 不是由 `*` 或 `?` 或 `[...]` 匹配。\n     */\n    public var requireLiteralSeparator: Bool = false\n\n    /**\n     * 是否要求路径组件的开头是 `.` 字符，必须由字面量 `.` 匹配，\n     * 而不是由 `*` 或 `?` 或 `**` 或 `[...]` 匹配。\n     * 这对于 Unix 系统上被传统认为是隐藏的文件很有用，\n     * 可能希在列出文件时跳过它们。\n     */\n    public var requireLiteralLeadingDot: Bool = false\n}",
              "successors": [
                {
                  "id": 7,
                  "label": "@Derive[Equatable]\npublic enum MatchResult {\n    Match\n    | SubPatternDoesntMatch\n    | EntirePatternDoesntMatch\n}\nconst ERROR_WILDCARDS = \"wildcards are either regular `*` or recursive `**`\";\nconst ERROR_RECURSIVE_WILDCARDS = \"recursive wildcards must form a single path component\";\nconst ERROR_INVALID_RANGE = \"invalid range pattern\";",
                  "successors": [
                    {
                      "id": 9,
                      "label": "extend String {\n    func split(checker: (Rune) -> Bool): Array<String> {\n        let chars = this.toRuneArray()\n        let ret = ArrayList<String>()\n        var start = 0\n        var i = 0\n\n        while (i < chars.size) {\n            if (checker(chars[i])) {\n                if (start < i) {\n                    ret.append(this[start..i])\n                }\n                start = i + 1\n            }\n            i++\n        }\n\n        if (start < i) {\n            ret.append(this[start..i])\n        }\n\n        return ret.toArray()\n    }\n}",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    }
  ]
}