{
  "name": "rewrite",
  "type": "CFG",
  "start_line": 1,
  "end_line": 350,
  "functions": [
    {
      "name": "SplitCurrentState",
      "type": "function",
      "start_line": 2,
      "end_line": 21,
      "functions": [],
      "classes": [],
      "simplified_code": "func SplitCurrentState<V, G>(\n    coreEdge : Edge<V, G>,\n    numberOfStateWires : Int64,\n    rewriteStartingElements : HashSet<TraversalElement<V, G>>,\n    rewriteEndingElements : HashSet<TraversalElement<V, G>>\n) : Array<(Vertex<V, G>, Vertex<V, G>)>\n    where V <: ValueSymbol<V>, G <: PrimitiveSymbol<V, G>\n{\n    Array<(Vertex<V, G>, Vertex<V, G>)>(\n        numberOfStateWires,\n        { i : Int64 =>\n            let joinEdge = coreEdge.NextEdgeLeft(i).getOrThrow().GetEdge()\n            let joinSourceLeft = joinEdge.GetSource(0)\n            let (left, right) = joinSourceLeft.SplitVertex()\n            rewriteStartingElements.put(VERTEX(left))\n            rewriteEndingElements.put(EDGE(joinEdge))\n            (left, right)\n        }\n    )\n}",
      "blocks": [
        {
          "id": 1,
          "label": "func SplitCurrentState<V, G>(\n    coreEdge : Edge<V, G>,\n    numberOfStateWires : Int64,\n    rewriteStartingElements : HashSet<TraversalElement<V, G>>,\n    rewriteEndingElements : HashSet<TraversalElement<V, G>>\n) : Array<(Vertex<V, G>, Vertex<V, G>)>\n    where V <: ValueSymbol<V>, G <: PrimitiveSymbol<V, G>\n{\n    Array<(Vertex<V, G>, Vertex<V, G>)>(\n        numberOfStateWires,\n        { i : Int64 =>",
          "successors": [
            {
              "id": 3,
              "label": "            let joinEdge = coreEdge.NextEdgeLeft(i).getOrThrow().GetEdge()\n            let joinSourceLeft = joinEdge.GetSource(0)",
              "successors": [
                {
                  "id": 5,
                  "label": "            let (left, right) = joinSourceLeft.SplitVertex()\n            rewriteStartingElements.put(VERTEX(left))",
                  "successors": [
                    {
                      "id": 7,
                      "label": "            rewriteEndingElements.put(EDGE(joinEdge))\n            (left, right)",
                      "successors": [
                        {
                          "id": 9,
                          "label": "        }\n    )\n}",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "GetCoreSourceVertices",
      "type": "function",
      "start_line": 22,
      "end_line": 73,
      "functions": [],
      "classes": [],
      "simplified_code": "func GetCoreSourceVertices<V, G>(\n    coreEdge : Edge<V, G>,\n    numberOfStateWires : Int64,\n    inputSignals : Array<CycleInput<V>>,\n    splitStateVertices : Array<(Vertex<V, G>, Vertex<V, G>)>,\n    rewriteStartingElements : HashSet<TraversalElement<V, G>>\n) : Array<Vertex<V, G>>\n    where V <: ValueSymbol<V>, G <: PrimitiveSymbol<V, G> {\n    Array<Vertex<V, G>>(\n        coreEdge.GetArity(),\n        { i : Int64 =>\n            // Check which partition of sources this belongs to\n            if(i < numberOfStateWires) {\n                // This is a vertex from the state\n                // We grab the existing state vertex\n                splitStateVertices[i][0]\n            } else {\n                // This is a vertex from the inputs\n                // We create the input edge and grab its target\n                // Get the signal\n                let input = inputSignals[i - numberOfStateWires]\n                let (inputLabel, inputSubgraph) =\n                    match(input) {\n                        case DEFINITE(signal) =>\n                            // Make a label\n                            let signalLabel = GetSignalLabel<V, G>(signal)\n                            let signalSubgraph = if(signal.GetWidth() == 1) {\n                                None<InterfacedHypergraph<V, G>>\n                            } else {\n                                MakeSignal<V, G>(signal)\n                            }\n                            (signalLabel, signalSubgraph)\n                        case PARTIAL(pi) =>\n                            let partialLabel = Label<V, G>.PARTIAL(pi)\n                            let partialSubgraph =\n                                None<InterfacedHypergraph<V, G>>\n                            (partialLabel, partialSubgraph)\n                    }\n                let inputTarget = Vertex<V, G>(input.GetWidth(), None)\n                // Create the signal\n                let inputEdge = Edge(\n                    inputLabel, Array<Vertex<V, G>>(), [inputTarget],\n                    inputSubgraph, coreEdge.GetGraph()\n                )\n                // The target of this edge will need to be traversed\n                // during rewriting\n                rewriteStartingElements.put(VERTEX(inputTarget))\n                inputTarget\n            }\n        }\n    )\n}",
      "blocks": [
        {
          "id": 1,
          "label": "func GetCoreSourceVertices<V, G>(coreEdge : Edge<V, G>, numberOfStateWires : Int64, inputSignals : Array<CycleInput<V>>, splitStateVertices : Array<(Vertex<V, G>, Vertex<V, G>)>, rewriteStartingElements : HashSet<TraversalElement<V, G>>) : Array<Vertex<V, G>> where V <: ValueSymbol<V>, G <: PrimitiveSymbol<V, G> {\nArray<Vertex<V, G>>(coreEdge.GetArity(), { i : Int64 =>",
          "successors": [
            {
              "id": 3,
              "label": "if(i < numberOfStateWires) {",
              "successors": [
                {
                  "id": 4,
                  "label": "splitStateVertices[i][0]\n})",
                  "successors": []
                },
                {
                  "id": 5,
                  "label": "let input = inputSignals[i - numberOfStateWires]\nlet (inputLabel, inputSubgraph) = match(input) {",
                  "successors": [
                    {
                      "id": 7,
                      "label": "case DEFINITE(signal) => let signalLabel = GetSignalLabel<V, G>(signal) let signalSubgraph = if(signal.GetWidth() == 1) { None<InterfacedHypergraph<V, G>> } else { MakeSignal<V, G>(signal) } (signalLabel, signalSubgraph) case PARTIAL(pi) => let partialLabel = Label<V, G>.PARTIAL(pi) let partialSubgraph = None<InterfacedHypergraph<V, G>> (partialLabel, partialSubgraph)\nlet inputTarget = Vertex<V, G>(input.GetWidth(), None) let inputEdge = Edge(inputLabel, Array<Vertex<V, G>>(), [inputTarget], inputSubgraph, coreEdge.GetGraph()) rewriteStartingElements.put(VERTEX(inputTarget)) inputTarget })",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "CreateOutputJoinEdges",
      "type": "function",
      "start_line": 74,
      "end_line": 102,
      "functions": [],
      "classes": [],
      "simplified_code": "func CreateOutputJoinEdges<V, G>(\n    graph : Hypergraph<V, G>,\n    latestDelayVertices : Array<Vertex<V, G>>,\n    latestInstantVertices : Array<Vertex<V, G>>,\n    rewriteEndingElements : HashSet<TraversalElement<V, G>>\n) : Array<Edge<V, G>> where V <: ValueSymbol<V>, G <: PrimitiveSymbol<V, G> {\n    mapi(\n        { v : Vertex<V, G>, i : Int64 =>\n            // Split this vertex, as we are going to insert a register\n            let (leftVertex, rightVertex) = v.SplitVertex()\n            let outputWidth = v.GetWidth()\n            let delayTarget = Vertex<V, G>(outputWidth, Some(graph))\n            let delayEdge = Edge(\n                DELAY(outputWidth), [leftVertex], [delayTarget], None, graph\n            )\n            latestDelayVertices[i] = leftVertex\n            // Create the instant component for this register\n            let outputTarget = Vertex<V, G>(outputWidth, Some(graph))\n            latestInstantVertices[i] = outputTarget\n            // Create the join for this register\n            let joinEdge = Edge(\n                JOIN(outputWidth), [outputTarget, delayTarget],\n                [rightVertex], None, graph\n            )\n            rewriteEndingElements.put(VERTEX(outputTarget))\n            joinEdge\n        }, latestDelayVertices\n    )\n}",
      "blocks": [
        {
          "id": 1,
          "label": "func CreateOutputJoinEdges<V, G>(graph : Hypergraph<V, G>, latestDelayVertices : Array<Vertex<V, G>>, latestInstantVertices : Array<Vertex<V, G>>, rewriteEndingElements : HashSet<TraversalElement<V, G>>) : Array<Edge<V, G>> where V <: ValueSymbol<V>, G <: PrimitiveSymbol<V, G> {\nmapi(",
          "successors": [
            {
              "id": 3,
              "label": "{ v : Vertex<V, G>, i : Int64 =>\nlet (leftVertex, rightVertex) = v.SplitVertex()",
              "successors": [
                {
                  "id": 5,
                  "label": "let outputWidth = v.GetWidth()\nlet delayTarget = Vertex<V, G>(outputWidth, Some(graph))",
                  "successors": [
                    {
                      "id": 7,
                      "label": "let delayEdge = Edge(DELAY(outputWidth), [leftVertex], [delayTarget], None, graph)\nlatestDelayVertices[i] = leftVertex",
                      "successors": [
                        {
                          "id": 9,
                          "label": "let outputTarget = Vertex<V, G>(outputWidth, Some(graph))\nlatestInstantVertices[i] = outputTarget",
                          "successors": [
                            {
                              "id": 11,
                              "label": "let joinEdge = Edge(JOIN(outputWidth), [outputTarget, delayTarget], [rightVertex], None, graph)\nrewriteEndingElements.put(VERTEX(outputTarget))",
                              "successors": [
                                {
                                  "id": 13,
                                  "label": "joinEdge",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "GetCoreTargetVertices",
      "type": "function",
      "start_line": 103,
      "end_line": 126,
      "functions": [],
      "classes": [],
      "simplified_code": "public func GetCoreTargetVertices<V, G>(\n    coreEdge : Edge<V, G>,\n    numberOfStateWires : Int64,\n    splitStateVertices : Array<(Vertex<V, G>, Vertex<V, G>)>,\n    latestInstantVertices : Array<Vertex<V, G>>\n) : Array<Vertex<V, G>>\n    where V <: ValueSymbol<V>, G <: PrimitiveSymbol<V, G>\n{\n    Array<Vertex<V, G>>(coreEdge.GetCoarity()) {\n        i : Int64 =>\n            // The targets of the cloned core edge are paritioned between\n            // the state transition and the outputs. If we are getting the\n            // target for a state transition, we just use the right vertex\n            // of the split state we made earlier. If we are getting the\n            // target for an output, we split the corresponding output\n            // vertex and insert a register, the instnat component of which\n            // is the target we are getting.\n            if(i < numberOfStateWires) {\n                splitStateVertices[i][1]\n            } else {\n                latestInstantVertices[i - numberOfStateWires]\n            }\n    }\n}",
      "blocks": [
        {
          "id": 1,
          "label": "public func GetCoreTargetVertices<V, G>\\n(\\n    coreEdge : Edge<V, G>,\\n    numberOfStateWires : Int64,\\n    splitStateVertices : Array<(Vertex<V, G>, Vertex<V, G>)>,\\n    latestInstantVertices : Array<Vertex<V, G>>\\n) : Array<Vertex<V, G>>\\n    where V <: ValueSymbol<V>, G <: PrimitiveSymbol<V, G>\\n{\n    Array<Vertex<V, G>>(coreEdge.GetCoarity()) {",
          "successors": [
            {
              "id": 3,
              "label": "        i : Int64 =>\n            if(i < numberOfStateWires) {",
              "successors": [
                {
                  "id": 5,
                  "label": "                splitStateVertices[i][1]",
                  "successors": []
                },
                {
                  "id": 6,
                  "label": "                latestInstantVertices[i - numberOfStateWires]",
                  "successors": []
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "GetOutputData",
      "type": "function",
      "start_line": 127,
      "end_line": 138,
      "functions": [],
      "classes": [],
      "simplified_code": "func GetOutputData<V, G>(\n    outputSubgraphs : Array<InterfacedHypergraph<V, G>>\n) : Array<OutputData<V, G>>\n    where V <: ValueSymbol<V>, G <: PrimitiveSymbol<V, G>\n{\n    map(\n        { f =>\n            let term = GetOutputTerm(f.GetOutput(0).GetVertex())\n            OutputData<V, G>(term, f)\n        }, outputSubgraphs\n    )\n}",
      "blocks": [
        {
          "id": 1,
          "label": "func GetOutputData<V, G>(\n    outputSubgraphs : Array<InterfacedHypergraph<V, G>>\n) : Array<OutputData<V, G>>\n    where V <: ValueSymbol<V>, G <: PrimitiveSymbol<V, G>\n{",
          "successors": [
            {
              "id": 3,
              "label": "map(",
              "successors": [
                {
                  "id": 4,
                  "label": "{ f =>\nlet term = GetOutputTerm(f.GetOutput(0).GetVertex())",
                  "successors": [
                    {
                      "id": 6,
                      "label": "OutputData<V, G>(term, f)",
                      "successors": []
                    }
                  ]
                },
                {
                  "id": 7,
                  "label": "}, outputSubgraphs",
                  "successors": []
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "UpdateInputOutputHistory",
      "type": "function",
      "start_line": 139,
      "end_line": 156,
      "functions": [],
      "classes": [],
      "simplified_code": "func UpdateInputOutputHistory<V, G>(\n    graph : InterfacedHypergraph<V, G>,\n    inputSignals : Array<CycleInput<V>>,\n    outputSubgraphs : Array<InterfacedHypergraph<V, G>>,\n    history : InputOutputHistory<V, G>\n) : Unit where V <: ValueSymbol<V>, G <: PrimitiveSymbol<V, G> {\n    let outputData = GetOutputData(outputSubgraphs)\n    history.inputHistoryPerTick.append(inputSignals)\n    history.outputHistoryPerTick.append(outputData)\n    let inputOutput = InputOutput(inputSignals, outputData)\n    history.inputOutputHistoryPerTick.append(inputOutput)\n    for(i in 0..graph.GetArity()) {\n        history.inputHistoryPerPort[i].append(inputSignals[i])\n    }\n    for(i in 0..graph.GetCoarity()) {\n        history.outputHistoryPerPort[i].append(outputData[i])\n    }\n}",
      "blocks": [
        {
          "id": 1,
          "label": "let outputData = GetOutputData(outputSubgraphs)\nhistory.inputHistoryPerTick.append(inputSignals)",
          "successors": [
            {
              "id": 3,
              "label": "history.outputHistoryPerTick.append(outputData)\nlet inputOutput = InputOutput(inputSignals, outputData)",
              "successors": [
                {
                  "id": 5,
                  "label": "history.inputOutputHistoryPerTick.append(inputOutput)\nfor(i in 0..graph.GetArity())",
                  "successors": [
                    {
                      "id": 7,
                      "label": "history.inputHistoryPerPort[i].append(inputSignals[i])\nfor(i in 0..graph.GetCoarity())",
                      "successors": [
                        {
                          "id": 9,
                          "label": "history.outputHistoryPerPort[i].append(outputData[i])",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "CollapseSingleOutput",
      "type": "function",
      "start_line": 157,
      "end_line": 168,
      "functions": [],
      "classes": [],
      "simplified_code": "func CollapseSingleOutput<V, G>(\n    rootVertex : Vertex<V, G>, label : Label<V, G>, tick : Int64, index : Int64\n) : InterfacedHypergraph<V, G>\n    where V <: ValueSymbol<V>, G <: PrimitiveSymbol<V, G>\n{\n    let (subgraph, _) = rootVertex.GetGraph().CollapseSubgraph(\n        Array<TentacleOrigin<V, G>>(),\n        [FROM_EDGE(rootVertex.GetInEdge().getOrThrow())],\n        \"${label.GetName()}[${index}] @ ${tick}\"\n    )\n    subgraph\n}",
      "blocks": [
        {
          "id": 1,
          "label": "func CollapseSingleOutput<V, G>(\n    rootVertex : Vertex<V, G>, label : Label<V, G>, tick : Int64, index : Int64\n) : InterfacedHypergraph<V, G>\n    where V <: ValueSymbol<V>, G <: PrimitiveSymbol<V, G>\n{\n    let (subgraph, _) = rootVertex.GetGraph().CollapseSubgraph(\n        Array<TentacleOrigin<V, G>>(),\n        [FROM_EDGE(rootVertex.GetInEdge().getOrThrow())],\n        \"${label.GetName()}[${index}] @ ${tick}\"\n    )",
          "successors": [
            {
              "id": 3,
              "label": "    subgraph",
              "successors": []
            }
          ]
        }
      ]
    },
    {
      "name": "CollapseOutputs",
      "type": "function",
      "start_line": 169,
      "end_line": 180,
      "functions": [],
      "classes": [],
      "simplified_code": "func CollapseOutputs<V, G>(\n    joinEdges : Array<Edge<V, G>>, label : Label<V, G>, tick : Int64\n) : Array<InterfacedHypergraph<V, G>>\n    where V <: ValueSymbol<V>, G <: PrimitiveSymbol<V, G>\n{\n    mapi(\n        { e : Edge<V, G>, i : Int64 =>\n            CollapseSingleOutput(e.GetSource(0), label, tick, i)\n        },\n        joinEdges\n    )\n}",
      "blocks": [
        {
          "id": 1,
          "label": "func CollapseOutputs<V, G>(joinEdges : Array<Edge<V, G>>, label : Label<V, G>, tick : Int64) : Array<InterfacedHypergraph<V, G>> where V <: ValueSymbol<V>, G <: PrimitiveSymbol<V, G> {\nmapi({ e : Edge<V, G>, i : Int64 => CollapseSingleOutput(e.GetSource(0), label, tick, i) }, joinEdges)",
          "successors": []
        }
      ]
    },
    {
      "name": "PerformCycle",
      "type": "function",
      "start_line": 181,
      "end_line": 234,
      "functions": [],
      "classes": [],
      "simplified_code": "func PerformCycle<V, G>(\n    graph : InterfacedHypergraph<V, G>, inputSignals : Array<CycleInput<V>>,\n    signature : Signature<V, G>, coreEdge : Edge<V, G>,\n    numberOfStateWires : Int64, latestInstantVertices : Array<Vertex<V, G>>,\n    latestDelayVertices : Array<Vertex<V, G>>,\n    history : InputOutputHistory<V, G>, debug : Bool, draw!: Bool = false\n) : Unit where V <: ValueSymbol<V>, G <: PrimitiveSymbol<V, G> {\n    // Can only perform a cycle for the right number of inputs\n    AssertHasInputs(graph, inputSignals.size)\n    // Track the elements we will be starting and ending the rewrite later\n    let rewriteStartingElements = HashSet<TraversalElement<V, G>>()\n    let rewriteEndingElements = HashSet<TraversalElement<V, G>>()\n    // Split the state vertices so we can insert the next state\n    let splitJoinVertices = SplitCurrentState(\n        coreEdge, numberOfStateWires,\n        rewriteStartingElements, rewriteEndingElements\n    )\n    let currentJoinEdges = CreateOutputJoinEdges(\n        graph.GetGraph(), latestDelayVertices, latestInstantVertices,\n        rewriteEndingElements\n    )\n    // The next step is to clone the core so we can attach the current state\n    // and input values to it and reduce appropriately.\n    // To do this we need to get or create the vertices that will make up\n    // its inputs and outputs.\n    let coreCopyInputs = GetCoreSourceVertices(\n        coreEdge, numberOfStateWires, inputSignals, splitJoinVertices,\n        rewriteStartingElements\n    )\n    let coreCopyOutputs = GetCoreTargetVertices(\n        coreEdge, numberOfStateWires, splitJoinVertices, latestInstantVertices\n    )\n    // Now we can actually clone the core edge and attach it to the inputs\n    // and outputs we just made\n    let coreCopyEdge = coreEdge.Clone(\n        coreCopyInputs, coreCopyOutputs, graph.GetGraph()\n    )\n    // Rewrite the copy of the combinational core. We want to\n    // force blackboxes as much as possible to the right so that each\n    // element of the state is isolated. Moreover, since the core is\n    // guaranteed to be capped off with values, we can safely apply\n    // instantaneous rules\n    RewriteCombinational(\n        signature, graph, rewriteStartingElements, rewriteEndingElements,\n        copyBlackBoxes: true, allInstantaneous: true, debug: debug, draw: draw\n    )\n    let outputSubgraphs = CollapseOutputs(\n        currentJoinEdges, graph.GetLabel(), history.GetCurrentTick()\n    )\n    // Look at what we've just done and update the input output history\n    UpdateInputOutputHistory(\n        graph, inputSignals, outputSubgraphs, history\n    )\n}",
      "blocks": [
        {
          "id": 1,
          "label": "func PerformCycle<V, G>(\n    graph : InterfacedHypergraph<V, G>, inputSignals : Array<CycleInput<V>>,\n    signature : Signature<V, G>, coreEdge : Edge<V, G>,\n    numberOfStateWires : Int64, latestInstantVertices : Array<Vertex<V, G>>,\n    latestDelayVertices : Array<Vertex<V, G>>,\n    history : InputOutputHistory<V, G>, debug : Bool, draw!: Bool = false\n) : Unit where V <: ValueSymbol<V>, G <: PrimitiveSymbol<V, G> {\nAssertHasInputs(graph, inputSignals.size)",
          "successors": [
            {
              "id": 3,
              "label": "let rewriteStartingElements = HashSet<TraversalElement<V, G>>()\nlet rewriteEndingElements = HashSet<TraversalElement<V, G>>()",
              "successors": [
                {
                  "id": 5,
                  "label": "let splitJoinVertices = SplitCurrentState(\n    coreEdge, numberOfStateWires,\n    rewriteStartingElements, rewriteEndingElements\n)\nlet currentJoinEdges = CreateOutputJoinEdges(\n    graph.GetGraph(), latestDelayVertices, latestInstantVertices,\n    rewriteEndingElements\n)",
                  "successors": [
                    {
                      "id": 7,
                      "label": "let coreCopyInputs = GetCoreSourceVertices(\n    coreEdge, numberOfStateWires, inputSignals, splitJoinVertices,\n    rewriteStartingElements\n)\nlet coreCopyOutputs = GetCoreTargetVertices(\n    coreEdge, numberOfStateWires, splitJoinVertices, latestInstantVertices\n)",
                      "successors": [
                        {
                          "id": 9,
                          "label": "let coreCopyEdge = coreEdge.Clone(\n    coreCopyInputs, coreCopyOutputs, graph.GetGraph()\n)\nRewriteCombinational(\n    signature, graph, rewriteStartingElements, rewriteEndingElements,\n    copyBlackBoxes: true, allInstantaneous: true, debug: debug, draw: draw\n)",
                          "successors": [
                            {
                              "id": 11,
                              "label": "let outputSubgraphs = CollapseOutputs(\n    currentJoinEdges, graph.GetLabel(), history.GetCurrentTick()\n)\nUpdateInputOutputHistory(\n    graph, inputSignals, outputSubgraphs, history\n)",
                              "successors": [
                                {
                                  "id": 13,
                                  "label": "}",
                                  "successors": []
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    }
  ],
  "classes": [
    {
      "name": "Evaluator",
      "type": "class",
      "start_line": 235,
      "end_line": 311,
      "functions": [
        {
          "name": "PerformCycle",
          "type": "function",
          "start_line": 236,
          "end_line": 246,
          "functions": [],
          "classes": [],
          "simplified_code": "    public func PerformCycle(\n        inputs : Array<CycleInput<V>>, debug!: Bool = false,  draw!: Bool = false\n    ) : Unit {\n        PerformCycle<V, G>(\n            this.graph, inputs, this.sig, this.coreEdge,\n            this.numberOfStateWires, this.latestInstantVertices,\n            this.latestDelayVertices, this.history, debug, draw: draw\n        )\n        // We're done!\n        this.currentCycle++\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "public func PerformCycle(inputs : Array<CycleInput<V>>, debug!: Bool = false, draw!: Bool = false) : Unit {\n    PerformCycle<V, G>(\n        this.graph, inputs, this.sig, this.coreEdge,\n        this.numberOfStateWires, this.latestInstantVertices,\n        this.latestDelayVertices, this.history, debug, draw: draw\n    )",
              "successors": [
                {
                  "id": 3,
                  "label": "    this.currentCycle++",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "PerformCycle",
          "type": "function",
          "start_line": 247,
          "end_line": 252,
          "functions": [],
          "classes": [],
          "simplified_code": "    public func PerformCycle(\n        signals : Array<Signal<V>>, debug!: Bool = false, draw!: Bool = false\n    ) : Unit {\n        let inputs = map({ s : Signal<V> => DEFINITE(s) }, signals)\n        PerformCycle(inputs, debug: debug, draw: draw)\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "public func PerformCycle(signals : Array<Signal<V>>, debug!: Bool = false, draw!: Bool = false) : Unit {\nlet inputs = map({ s : Signal<V> => DEFINITE(s) }, signals)",
              "successors": [
                {
                  "id": 3,
                  "label": "PerformCycle(inputs, debug: debug, draw: draw)",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "PerformCycle",
          "type": "function",
          "start_line": 253,
          "end_line": 258,
          "functions": [],
          "classes": [],
          "simplified_code": "    public func PerformCycle(\n        values : Array<V>, debug!: Bool = false, draw!: Bool = false\n    ) : Unit {\n        let inputSignals = map({ v : V => Signal(v) }, values)\n        this.PerformCycle(inputSignals, debug: debug, draw: draw)\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "public func PerformCycle(values : Array<V>, debug!: Bool = false, draw!: Bool = false) : Unit {\nlet inputSignals = map({ v : V => Signal(v) }, values)",
              "successors": [
                {
                  "id": 3,
                  "label": "this.PerformCycle(inputSignals, debug: debug, draw: draw)",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "PerformCycle",
          "type": "function",
          "start_line": 259,
          "end_line": 264,
          "functions": [],
          "classes": [],
          "simplified_code": "    public func PerformCycle(\n        signal : Signal<V>, debug!: Bool = false, draw!: Bool = false\n    ) : Unit {\n        AssertHasInputs(this.graph, 1)\n        this.PerformCycle([signal], debug: debug, draw: draw)\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "public func PerformCycle(\n    signal : Signal<V>, debug!: Bool = false, draw!: Bool = false\n) : Unit {\n    AssertHasInputs(this.graph, 1)",
              "successors": [
                {
                  "id": 3,
                  "label": "    this.PerformCycle([signal], debug: debug, draw: draw)",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "PerformCycle",
          "type": "function",
          "start_line": 265,
          "end_line": 270,
          "functions": [],
          "classes": [],
          "simplified_code": "    public func PerformCycle(\n        value : V, debug!: Bool = false, draw!: Bool = false\n    ) : Unit {\n        AssertHasInputs(this.graph, 1)\n        this.PerformCycle(Signal(value), debug: debug, draw: draw)\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "public func PerformCycle(\n    value : V, debug!: Bool = false, draw!: Bool = false\n) : Unit {\nAssertHasInputs(this.graph, 1)",
              "successors": [
                {
                  "id": 3,
                  "label": "this.PerformCycle(Signal(value), debug: debug, draw: draw)",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "PerformCycles",
          "type": "function",
          "start_line": 271,
          "end_line": 277,
          "functions": [],
          "classes": [],
          "simplified_code": "    public func PerformCycles(\n        signalsPerTick: Array<Array<CycleInput<V>>>, debug!: Bool = false, draw!: Bool = false\n    ) : Unit {\n        for(signals in signalsPerTick) {\n            this.PerformCycle(signals, debug: debug, draw: draw)\n        }\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "public func PerformCycles(signalsPerTick: Array<Array<CycleInput<V>>>, debug!: Bool = false, draw!: Bool = false) : Unit {\nfor(signals in signalsPerTick) {",
              "successors": [
                {
                  "id": 3,
                  "label": "this.PerformCycle(signals, debug: debug, draw: draw)\nfor(signals in signalsPerTick) {",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "PerformCycles",
          "type": "function",
          "start_line": 278,
          "end_line": 282,
          "functions": [],
          "classes": [],
          "simplified_code": "    public func PerformCycles(\n        valuesPerTick: Array<Array<V>>, debug!: Bool = false, draw!: Bool = false) : Unit {\n        for(values in valuesPerTick) {\n            this.PerformCycle(values, debug: debug, draw: draw)\n        }",
          "blocks": [
            {
              "id": 1,
              "label": "for(values in valuesPerTick):\n this.PerformCycle(values, debug: debug, draw: draw)",
              "successors": [
                {
                  "id": 1,
                  "label": "for(values in valuesPerTick):\n this.PerformCycle(values, debug: debug, draw: draw)",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "PerformCycles",
          "type": "function",
          "start_line": 283,
          "end_line": 288,
          "functions": [],
          "classes": [],
          "simplified_code": "    }\n    public func PerformCycles(\n        waveforms: Array<Waveform<V>>, debug!: Bool = false, draw!: Bool = false) : Unit {\n        let signalsPerTick = ArrayOfInputsToArrayOfTicks(waveforms)\n        PerformCycles(signalsPerTick, debug: debug, draw: draw)\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "public func PerformCycles(\n    waveforms: Array<Waveform<V>>, debug!: Bool = false, draw!: Bool = false) : Unit {\n    let signalsPerTick = ArrayOfInputsToArrayOfTicks(waveforms)",
              "successors": [
                {
                  "id": 3,
                  "label": "    PerformCycles(signalsPerTick, debug: debug, draw: draw)",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "PerformCycles",
          "type": "function",
          "start_line": 289,
          "end_line": 293,
          "functions": [],
          "classes": [],
          "simplified_code": "    public func PerformCycles(\n        waveform: Waveform<V>, debug!: Bool = false, draw!: Bool = false\n    ) : Unit {\n        AssertHasInputs(this.graph, 1)\n        PerformCycles([waveform], debug: debug, draw: draw)",
          "blocks": [
            {
              "id": 1,
              "label": "public func PerformCycles(",
              "successors": []
            }
          ]
        },
        {
          "name": "PerformCycles",
          "type": "function",
          "start_line": 295,
          "end_line": 302,
          "functions": [],
          "classes": [],
          "simplified_code": "    public func PerformCycles(\n        signals: Array<Signal<V>>, ticks!: Int64, debug!: Bool = false, draw!: Bool = false\n    ) : Unit {\n        AssertHasInputs(this.graph, signals.size)\n        for(_ in 0..ticks) {\n            PerformCycle(signals, debug: debug, draw: draw)\n        }\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "public func PerformCycles(signals: Array<Signal<V>>, ticks!: Int64, debug!: Bool = false, draw!: Bool = false) : Unit {\nAssertHasInputs(this.graph, signals.size)",
              "successors": [
                {
                  "id": 3,
                  "label": "for(_ in 0..ticks) {\nPerformCycle(signals, debug: debug, draw: draw)",
                  "successors": [
                    {
                      "id": 3,
                      "label": "for(_ in 0..ticks) {\nPerformCycle(signals, debug: debug, draw: draw)",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "PerformCycles",
          "type": "function",
          "start_line": 303,
          "end_line": 310,
          "functions": [],
          "classes": [],
          "simplified_code": "    public func PerformCycles(\n        values: Array<V>, ticks!: Int64, debug!: Bool = false, draw!: Bool = false\n    ) : Unit {\n        AssertHasInputs(this.graph, values.size)\n        for(_ in 0..ticks) {\n            PerformCycle(values, debug: debug, draw: draw)\n        }\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "AssertHasInputs(this.graph, values.size)\nfor(_ in 0..ticks):",
              "successors": [
                {
                  "id": 3,
                  "label": "    PerformCycle(values, debug: debug, draw: draw)\nfor(_ in 0..ticks):",
                  "successors": []
                }
              ]
            }
          ]
        }
      ],
      "classes": [],
      "simplified_code": "extend Evaluator<V, G> {\n    }\n    }\n    }\n    }\n    }\n    }\n        }\n    }\n        PerformCycles([waveform], debug: debug, draw: draw)\n    }\n    }\n    }\n}",
      "blocks": [
        {
          "id": 1,
          "label": "extend Evaluator<V, G> {\n}",
          "successors": [
            {
              "id": 3,
              "label": "}\n}",
              "successors": [
                {
                  "id": 5,
                  "label": "}\n}",
                  "successors": [
                    {
                      "id": 7,
                      "label": "}\n}",
                      "successors": [
                        {
                          "id": 9,
                          "label": "PerformCycles([waveform], debug: debug, draw: draw)\n}",
                          "successors": [
                            {
                              "id": 11,
                              "label": "}\n}",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "Evaluator<V, G> where V <: Decimal<V>",
      "type": "class",
      "start_line": 312,
      "end_line": 350,
      "functions": [
        {
          "name": "PerformCycle",
          "type": "function",
          "start_line": 313,
          "end_line": 326,
          "functions": [],
          "classes": [],
          "simplified_code": "    public func PerformCycle(\n        inputs : Array<Int64>, signed!: Bool, debug!: Bool = false, draw!: Bool = false\n    ) : Unit {\n        AssertHasInputs(this.graph, inputs.size)\n        let inputSignals = mapi(\n            { v : Int64, i : Int64 =>\n                V.DecToSignal(\n                    v, width: this.graph.GetInput(i).GetWidth(), signed: signed\n                )\n            },\n            inputs\n        )\n        this.PerformCycle(inputSignals, debug: debug, draw: draw)\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "AssertHasInputs(this.graph, inputs.size)\nlet inputSignals = mapi( { v : Int64, i : Int64 => V.DecToSignal( v, width: this.graph.GetInput(i).GetWidth(), signed: signed ) }, inputs )",
              "successors": [
                {
                  "id": 3,
                  "label": "this.PerformCycle(inputSignals, debug: debug, draw: draw)",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "PerformCycle",
          "type": "function",
          "start_line": 327,
          "end_line": 332,
          "functions": [],
          "classes": [],
          "simplified_code": "    public func PerformCycle(\n        input: Int64, signed!: Bool, debug!: Bool = false, draw!: Bool = false\n    ) : Unit {\n        AssertHasInputs(this.graph, 1)\n        this.PerformCycle([input], signed: signed, debug: debug, draw: draw)\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "public func PerformCycle(input: Int64, signed!: Bool, debug!: Bool = false, draw!: Bool = false) : Unit {\n    AssertHasInputs(this.graph, 1)",
              "successors": [
                {
                  "id": 3,
                  "label": "    this.PerformCycle([input], signed: signed, debug: debug, draw: draw)",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "PerformCycles",
          "type": "function",
          "start_line": 333,
          "end_line": 341,
          "functions": [],
          "classes": [],
          "simplified_code": "    public func PerformCycles(\n        inputs : Array<Int64>, signed!: Bool, ticks!: Int64,\n        debug!: Bool = false, draw!: Bool = false\n    ) : Unit {\n        AssertHasInputs(this.graph, inputs.size)\n        for(_ in 0..ticks) {\n            PerformCycle(inputs, signed: signed, debug: debug, draw: draw)\n        }\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "AssertHasInputs(this.graph, inputs.size)\nfor(_ in 0..ticks) {",
              "successors": [
                {
                  "id": 3,
                  "label": "    PerformCycle(inputs, signed: signed, debug: debug, draw: draw)\nfor(_ in 0..ticks) {",
                  "successors": [
                    {
                      "id": 3,
                      "label": "    PerformCycle(inputs, signed: signed, debug: debug, draw: draw)",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "PerformCycles",
          "type": "function",
          "start_line": 342,
          "end_line": 349,
          "functions": [],
          "classes": [],
          "simplified_code": "    public func PerformCycles(\n        input : Int64, signed!: Bool, ticks!: Int64, debug!: Bool = false, draw!: Bool = false\n    ) : Unit {\n        AssertHasInputs(this.graph, 1)\n        for(_ in 0..ticks) {\n            PerformCycle(input, signed: signed, debug: debug, draw: draw)\n        }\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "public func PerformCycles(input : Int64, signed!: Bool, ticks!: Int64, debug!: Bool = false, draw!: Bool = false) : Unit {\nAssertHasInputs(this.graph, 1)",
              "successors": [
                {
                  "id": 3,
                  "label": "for(_ in 0..ticks) {\nPerformCycle(input, signed: signed, debug: debug, draw: draw)",
                  "successors": [
                    {
                      "id": 3,
                      "label": "for(_ in 0..ticks) {",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "classes": [],
      "simplified_code": "extend Evaluator<V, G> where V <: Decimal<V> {\n    }\n    }\n    }\n    }\n}",
      "blocks": [
        {
          "id": 1,
          "label": "extend Evaluator<V, G> where V <: Decimal<V> {",
          "successors": []
        }
      ]
    }
  ],
  "simplified_code": "package rewrite\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}",
  "blocks": [
    {
      "id": 1,
      "label": "package rewrite",
      "successors": []
    }
  ]
}