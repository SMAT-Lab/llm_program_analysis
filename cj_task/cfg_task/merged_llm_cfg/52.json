{
  "name": "Cangjie script",
  "type": "CFG",
  "start_line": 1,
  "end_line": 306,
  "functions": [
    {
      "name": "main",
      "type": "function",
      "start_line": 270,
      "end_line": 306,
      "functions": [],
      "classes": [],
      "simplified_code": "main() {\n    let cube = Cube()\n    cube.print()\n    // 1.基本操作\n    for (r in [F, B, L, R, U, D]) {\n        cube.transform(r) // 原子操作\n    }\n    Cube().transform(F * R * I(F * R)) // 复合操作\n\n    // 2.置换的阶数\n    // FFRR 是 2,3 阶置换的组合，其最小公倍数是 6，重复 6 次两类置换都会还原\n    Cube().transform((F * F * R * R) ** 6)\n    // FULLR 是 3,4,6,9,18 阶置换的组合，同理可得其阶数为 36\n    Cube().transform((F * U * L * L * R) ** 36)\n    Cube().transform((F * F * L * L * B * R) ** 90)\n\n    // 3.相似变换 UGU⁻¹\n    // 已知 R⁻¹DRFDF⁻¹ 可以翻转 FUR 角块\n    let G = I(R) * D * R * F * D * I(F)\n    Cube().transform(G)\n    // 为了翻转 BUR 角块，可以先执行 U 把 BUR 换到 FUR 位置，然后执行 G 翻转 FUR，最后执行 U⁻¹ 恢复 BUR 位置\n    let H = U * G * I(U)\n    Cube().transform(H)\n\n    // 4.组合子变换 MU⁻¹M⁻¹U\n    // 已知 RL⁻¹FFLR⁻¹D⁻¹RL⁻¹FLR⁻¹ 可以保持顶面其他方块不变、仅翻转 UF 棱块，但下面两层会被打乱\n    let M = R * I(L) * F * F * L * I(R) * I(D) * R * I(L) * F * L * I(R)\n    Cube().transform(M)\n    // 为了同时翻转 UF 和 UL，可以先执行 M 翻转 UF，然后执行 U⁻¹ 把 UL 换到 UF 位置\n    // 再执行 M⁻¹ 翻转 UL 并还原下面两层，最后执行 U 恢复 UF 和 UL 位置，这样整个魔方仅有 UF 和 UL 被翻转\n    let N = M * I(U) * I(M) * U\n    Cube().transform(N)\n    // 在此基础上，如果我们想同时翻转 UL 和 UR，可以按组合子思想执行 NUN⁻¹U⁻¹\n    let P = N * U * I(N) * I(U)\n    Cube().transform(P)\n    ()\n}",
      "blocks": [
        {
          "id": 1,
          "label": "main() {\nlet cube = Cube()",
          "successors": [
            {
              "id": 3,
              "label": "cube.print()\n// 1.基本操作",
              "successors": [
                {
                  "id": 5,
                  "label": "for (r in [F, B, L, R, U, D]) {",
                  "successors": [
                    {
                      "id": 6,
                      "label": "cube.transform(r) // 原子操作\n}",
                      "successors": [
                        {
                          "id": 8,
                          "label": "Cube().transform(F * R * I(F * R)) // 复合操作\n// 2.置换的阶数",
                          "successors": [
                            {
                              "id": 10,
                              "label": "// FFRR 是 2,3 阶置换的组合，其最小公倍数是 6，重复 6 次两类置换都会还原\nCube().transform((F * F * R * R) ** 6)",
                              "successors": [
                                {
                                  "id": 12,
                                  "label": "// FULLR 是 3,4,6,9,18 阶置换的组合，同理可得其阶数为 36\nCube().transform((F * U * L * L * R) ** 36)",
                                  "successors": [
                                    {
                                      "id": 14,
                                      "label": "Cube().transform((F * F * L * L * B * R) ** 90)\n// 3.相似变换 UGU⁻¹",
                                      "successors": [
                                        {
                                          "id": 16,
                                          "label": "// 已知 R⁻¹DRFDF⁻¹ 可以翻转 FUR 角块\nlet G = I(R) * D * R * F * D * I(F)",
                                          "successors": [
                                            {
                                              "id": 18,
                                              "label": "Cube().transform(G)\n// 为了翻转 BUR 角块，可以先执行 U 把 BUR 换到 FUR 位置，然后执行 G 翻转 FUR，最后执行 U⁻¹ 恢复 BUR 位置",
                                              "successors": [
                                                {
                                                  "id": 20,
                                                  "label": "let H = U * G * I(U)\nCube().transform(H)",
                                                  "successors": [
                                                    {
                                                      "id": 22,
                                                      "label": "// 4.组合子变换 MU⁻¹M⁻¹U\n// 已知 RL⁻¹FFLR⁻¹D⁻¹RL⁻¹FLR⁻¹ 可以保持顶面其他方块不变、仅翻转 UF 棱块，但下面两层会被打乱",
                                                      "successors": [
                                                        {
                                                          "id": 24,
                                                          "label": "let M = R * I(L) * F * F * L * I(R) * I(D) * R * I(L) * F * L * I(R)\nCube().transform(M)",
                                                          "successors": [
                                                            {
                                                              "id": 26,
                                                              "label": "// 为了同时翻转 UF 和 UL，可以先执行 M 翻转 UF，然后执行 U⁻¹ 把 UL 换到 UF 位置\n// 再执行 M⁻¹ 翻转 UL 并还原下面两层，最后执行 U 恢复 UF 和 UL 位置，这样整个魔方仅有 UF 和 UL 被翻转",
                                                              "successors": [
                                                                {
                                                                  "id": 28,
                                                                  "label": "let N = M * I(U) * I(M) * U\nCube().transform(N)",
                                                                  "successors": [
                                                                    {
                                                                      "id": 30,
                                                                      "label": "// 在此基础上，如果我们想同时翻转 UL 和 UR，可以按组合子思想执行 NUN⁻¹U⁻¹\nlet P = N * U * I(N) * I(U)",
                                                                      "successors": [
                                                                        {
                                                                          "id": 32,
                                                                          "label": "Cube().transform(P)\n()",
                                                                          "successors": []
                                                                        }
                                                                      ]
                                                                    }
                                                                  ]
                                                                }
                                                              ]
                                                            }
                                                          ]
                                                        }
                                                      ]
                                                    }
                                                  ]
                                                }
                                              ]
                                            }
                                          ]
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    }
  ],
  "classes": [
    {
      "name": "Rotation",
      "type": "class",
      "start_line": 10,
      "end_line": 65,
      "functions": [
        {
          "name": "*",
          "type": "function",
          "start_line": 17,
          "end_line": 22,
          "functions": [],
          "classes": [],
          "simplified_code": "    public operator func *(that: Rotation): Rotation {\n        match (this) {\n            case X(x1, x2) => X(x1, X(x2, that)) // 按此顺序分解重组，使得递归时按从左到右的顺序执行变换\n            case _ => X(this, that)\n        }\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "public operator func *(that: Rotation): Rotation {\nmatch (this) {",
              "successors": [
                {
                  "id": 3,
                  "label": "case X(x1, x2) => X(x1, X(x2, that))\n}",
                  "successors": []
                },
                {
                  "id": 4,
                  "label": "case _ => X(this, that)\n}",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "**",
          "type": "function",
          "start_line": 25,
          "end_line": 31,
          "functions": [],
          "classes": [],
          "simplified_code": "    public operator func **(exp: UInt32): Rotation {\n        var result = this\n        for (_ in 0..(exp - 1)) {\n            result = result * this\n        }\n        return result\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "public operator func **(exp: UInt32): Rotation {\nvar result = this",
              "successors": [
                {
                  "id": 3,
                  "label": "for (_ in 0..(exp - 1)) {",
                  "successors": [
                    {
                      "id": 4,
                      "label": "result = result * this",
                      "successors": [
                        {
                          "id": 3,
                          "label": "for (_ in 0..(exp - 1)) {",
                          "successors": [
                            {
                              "id": 5,
                              "label": "return result",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "id": 5,
                  "label": "return result",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "text",
          "type": "function",
          "start_line": 34,
          "end_line": 47,
          "functions": [],
          "classes": [],
          "simplified_code": "    private func text(inv: Bool): String {\n        let exp = if (inv) { \"⁻¹\" } else { \"\" }\n        match (this) {\n            case F => \"F${exp}\" case B => \"B${exp}\" case L => \"L${exp}\"\n            case R => \"R${exp}\" case U => \"U${exp}\" case D => \"D${exp}\"\n            case I(r) => r.text(!inv)\n            case X(x1, x2) =>\n                if (inv) { // 逆变换需要反序\n                    x2.text(inv) + x1.text(inv)\n                } else {\n                    x1.text(inv) + x2.text(inv)\n                }\n        }\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "let exp = if (inv) { \"⁻¹\" } else { \"\" }\nmatch (this)",
              "successors": [
                {
                  "id": 3,
                  "label": "case F => \"F${exp}\"",
                  "successors": []
                },
                {
                  "id": 4,
                  "label": "case B => \"B${exp}\"",
                  "successors": []
                },
                {
                  "id": 5,
                  "label": "case L => \"L${exp}\"",
                  "successors": []
                },
                {
                  "id": 6,
                  "label": "case R => \"R${exp}\"",
                  "successors": []
                },
                {
                  "id": 7,
                  "label": "case U => \"U${exp}\"",
                  "successors": []
                },
                {
                  "id": 8,
                  "label": "case D => \"D${exp}\"",
                  "successors": []
                },
                {
                  "id": 9,
                  "label": "case I(r) => r.text(!inv)",
                  "successors": []
                },
                {
                  "id": 10,
                  "label": "case X(x1, x2)\nif (inv)",
                  "successors": [
                    {
                      "id": 12,
                      "label": "x2.text(inv) + x1.text(inv)",
                      "successors": []
                    },
                    {
                      "id": 13,
                      "label": "x1.text(inv) + x2.text(inv)",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "toString",
          "type": "function",
          "start_line": 49,
          "end_line": 51,
          "functions": [],
          "classes": [],
          "simplified_code": "    public func toString(): String {\n        text(false)\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "public func toString(): String {\n    text(false)",
              "successors": []
            }
          ]
        },
        {
          "name": "hashCode",
          "type": "function",
          "start_line": 54,
          "end_line": 56,
          "functions": [],
          "classes": [],
          "simplified_code": "    public func hashCode(): Int64 {\n        this.toString().hashCode()\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "public func hashCode(): Int64 {\n    this.toString().hashCode()",
              "successors": []
            }
          ]
        },
        {
          "name": "==",
          "type": "function",
          "start_line": 58,
          "end_line": 60,
          "functions": [],
          "classes": [],
          "simplified_code": "    public operator func ==(that: Rotation): Bool {\n        this.toString() == that.toString()\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "public operator func ==(that: Rotation): Bool {\nthis.toString() == that.toString()",
              "successors": []
            }
          ]
        },
        {
          "name": "!=",
          "type": "function",
          "start_line": 62,
          "end_line": 64,
          "functions": [],
          "classes": [],
          "simplified_code": "    public operator func !=(that: Rotation): Bool {\n        this.toString() != that.toString()\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "public operator func !=(that: Rotation): Bool {\nthis.toString() != that.toString()",
              "successors": []
            }
          ]
        }
      ],
      "classes": [],
      "simplified_code": "enum Rotation <: ToString & Hashable & Equatable<Rotation> {\n    // 在魔方研究中，通常用 Front/Back/Left/Right/Up/Down 表示六个面以及对应的原子操作，即正对此面顺时针旋转 90 度\n    F | B | L | R | U | D\n      | X(Rotation, Rotation) // 仓颉支持 enum 构造器和递归定义，此处 X 用于组织复合旋转操作\n      | I(Rotation) // I(r) 用于表示 r 的逆变换，即正对 r 面逆时针旋转 90 度\n\n    // enum 中也可以定义成员函数，这里我们重载 * 运算符以实现旋转操作的组合，由此可生成一个置换群\n    }\n\n    // 重载 ** 运算符实现幂运算，以便表示和验证高阶置换操作，如 (F*F*L*L*B*R)**90 会让魔方回归初态\n    }\n\n    // 实现 ToString 接口以便打印和调试此代数系统\n    }\n\n    }\n\n    // 下面实现 Hashable 和 Equatable 接口，以便 Rotation 作为 HashMap 的 Key\n    }\n\n    }\n\n    }\n}",
      "blocks": [
        {
          "id": 1,
          "label": "enum Rotation <: ToString & Hashable & Equatable<Rotation> {",
          "successors": [
            {
              "id": 2,
              "label": "    F | B | L | R | U | D",
              "successors": []
            },
            {
              "id": 3,
              "label": "    | X(Rotation, Rotation)",
              "successors": []
            },
            {
              "id": 4,
              "label": "    | I(Rotation)",
              "successors": []
            },
            {
              "id": 5,
              "label": "    }",
              "successors": []
            },
            {
              "id": 6,
              "label": "    }",
              "successors": []
            },
            {
              "id": 7,
              "label": "    }",
              "successors": []
            },
            {
              "id": 8,
              "label": "    }",
              "successors": []
            },
            {
              "id": 9,
              "label": "    }",
              "successors": []
            }
          ]
        }
      ]
    },
    {
      "name": "Index",
      "type": "class",
      "start_line": 70,
      "end_line": 86,
      "functions": [
        {
          "name": "-",
          "type": "function",
          "start_line": 73,
          "end_line": 78,
          "functions": [],
          "classes": [],
          "simplified_code": "    public operator func -(): Index {\n        match (this) {\n            case Inv(v) => v\n            case _ => Inv(this)\n        }\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "match (this) {",
              "successors": [
                {
                  "id": 2,
                  "label": "    case Inv(v) => v",
                  "successors": []
                },
                {
                  "id": 3,
                  "label": "    case _ => Inv(this)",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "value",
          "type": "function",
          "start_line": 80,
          "end_line": 85,
          "functions": [],
          "classes": [],
          "simplified_code": "    public func value(): Index {\n        match (this) {\n            case Inv(v) => v\n            case _ => this\n        }\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "public func value(): Index {\nmatch (this) {",
              "successors": [
                {
                  "id": 3,
                  "label": "case Inv(v) => v",
                  "successors": []
                },
                {
                  "id": 4,
                  "label": "case _ => this",
                  "successors": []
                }
              ]
            }
          ]
        }
      ],
      "classes": [],
      "simplified_code": "enum Index {\n    Row(Int64) | Col(Int64) | Inv(Index)\n    // 用于标记向量倒置\n    }\n    // 去掉 Inv 符号\n    }\n}",
      "blocks": [
        {
          "id": 1,
          "label": "enum Index {\nRow(Int64) | Col(Int64) | Inv(Index)",
          "successors": [
            {
              "id": 3,
              "label": "// 用于标记向量倒置\n}",
              "successors": [
                {
                  "id": 5,
                  "label": "// 去掉 Inv 符号\n}",
                  "successors": []
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "Matrix",
      "type": "class",
      "start_line": 88,
      "end_line": 134,
      "functions": [
        {
          "name": "create",
          "type": "function",
          "start_line": 90,
          "end_line": 94,
          "functions": [],
          "classes": [],
          "simplified_code": "    public static func create(face: Face) {\n        Matrix(3, { i =>\n            Vector(3, { j => (face, 3 * i + j + 1)})\n        })\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "public static func create(face: Face) {\nMatrix(3, { i =>",
              "successors": [
                {
                  "id": 3,
                  "label": "Vector(3, { j => (face, 3 * i + j + 1)})",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "[]",
          "type": "function",
          "start_line": 97,
          "end_line": 103,
          "functions": [],
          "classes": [],
          "simplified_code": "    public operator func [](index: Index): Vector {\n        match (index) {\n            case Row(r) => this[r].clone()\n            case Col(c) => Vector(this.size, { i => this[i][c] })\n            case Inv(i) => this[i] // 应用场景需要，取值时忽略符号、不做倒置\n        }\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "public operator func [](index: Index): Vector {\nmatch (index) {",
              "successors": [
                {
                  "id": 3,
                  "label": "case Row(r) => this[r].clone()",
                  "successors": []
                },
                {
                  "id": 4,
                  "label": "case Col(c) => Vector(this.size, { i => this[i][c] })",
                  "successors": []
                },
                {
                  "id": 5,
                  "label": "case Inv(i) => this[i] // 应用场景需要，取值时忽略符号、不做倒置",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "set",
          "type": "function",
          "start_line": 106,
          "end_line": 117,
          "functions": [],
          "classes": [],
          "simplified_code": "    public func set(index: Index, value: Vector): Unit {\n        match (index) {\n            case Row(r) => this[r] = value\n            case Col(c) =>\n                for (i in 0..value.size) {\n                    this[i][c] = value[i]\n                }\n            case Inv(i) => // 赋值时根据 index 符号做倒置\n                value.reverse()\n                this.set(i, value)\n        }\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "match (index)",
              "successors": [
                {
                  "id": 2,
                  "label": "case Row(r) => this[r] = value",
                  "successors": []
                },
                {
                  "id": 3,
                  "label": "case Col(c)",
                  "successors": [
                    {
                      "id": 4,
                      "label": "for (i in 0..value.size)",
                      "successors": [
                        {
                          "id": 5,
                          "label": "this[i][c] = value[i]",
                          "successors": []
                        }
                      ]
                    }
                  ]
                },
                {
                  "id": 6,
                  "label": "case Inv(i)\nvalue.reverse()",
                  "successors": [
                    {
                      "id": 8,
                      "label": "this.set(i, value)",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "print",
          "type": "function",
          "start_line": 120,
          "end_line": 124,
          "functions": [],
          "classes": [],
          "simplified_code": "    public func print(row: Int64) {\n        for ((face, id) in this[row]) {\n            print(\"${face}${id} \")\n        }\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "public func print(row: Int64) {",
              "successors": [
                {
                  "id": 2,
                  "label": "for ((face, id) in this[row]) {",
                  "successors": [
                    {
                      "id": 3,
                      "label": "print(\"${face}${id} \")",
                      "successors": [
                        {
                          "id": 2,
                          "label": "for ((face, id) in this[row]) {",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "print",
          "type": "function",
          "start_line": 127,
          "end_line": 133,
          "functions": [],
          "classes": [],
          "simplified_code": "    public func print() {\n        for (row in 0..this.size) {\n            print(\"         \")\n            print(row)\n            println()\n        }\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "public func print() {",
              "successors": [
                {
                  "id": 2,
                  "label": "for (row in 0..this.size) {",
                  "successors": [
                    {
                      "id": 3,
                      "label": "print(\"         \")\nprint(row)",
                      "successors": [
                        {
                          "id": 5,
                          "label": "println()",
                          "successors": [
                            {
                              "id": 2,
                              "label": "for (row in 0..this.size) {",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "classes": [],
      "simplified_code": "extend Matrix {\n    // 给指定的魔方面创建初始矩阵\n    }\n\n    // 获取矩阵的行或列\n    }\n\n    // 给矩阵的行或列赋值\n    }\n\n    // 打印矩阵的一行\n    }\n\n    // 打印整个矩阵\n    }\n}",
      "blocks": [
        {
          "id": 1,
          "label": "extend Matrix {\n// 给指定的魔方面创建初始矩阵\n    }",
          "successors": [
            {
              "id": 3,
              "label": "// 获取矩阵的行或列\n    }\n// 给矩阵的行或列赋值\n    }",
              "successors": [
                {
                  "id": 5,
                  "label": "// 打印矩阵的一行\n    }\n// 打印整个矩阵\n    }",
                  "successors": []
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "Int64",
      "type": "class",
      "start_line": 137,
      "end_line": 144,
      "functions": [],
      "classes": [],
      "simplified_code": "extend Int64 {\n    public prop r: Index {\n        get() { Index.Row(this) }\n    }\n    public prop c: Index {\n        get() { Index.Col(this) }\n    }\n}",
      "blocks": [
        {
          "id": 1,
          "label": "extend Int64 {",
          "successors": [
            {
              "id": 2,
              "label": "public prop r: Index {\nget() { Index.Row(this) }",
              "successors": []
            },
            {
              "id": 4,
              "label": "public prop c: Index {\nget() { Index.Col(this) }",
              "successors": []
            }
          ]
        }
      ]
    },
    {
      "name": "Permutation",
      "type": "class",
      "start_line": 149,
      "end_line": 165,
      "functions": [
        {
          "name": "inverse",
          "type": "function",
          "start_line": 151,
          "end_line": 164,
          "functions": [],
          "classes": [],
          "simplified_code": "    public func inverse() {\n        let perm = this.clone()\n        for (i in 0..perm.size) {\n            let j = (i + 1) % perm.size\n            let (face, index) = this[i] // 解构元组\n            if (let Inv(_) <- this[j][1]) { // if-let 模式匹配\n                perm[i] = (face, -(index.value()))\n            } else {\n                perm[i] = (face, index.value())\n            }\n        }\n        perm.reverse()\n        return perm\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "public func inverse() {\n    let perm = this.clone()",
              "successors": [
                {
                  "id": 3,
                  "label": "    for (i in 0..perm.size) {",
                  "successors": [
                    {
                      "id": 4,
                      "label": "        let j = (i + 1) % perm.size\n        let (face, index) = this[i]\n        if (let Inv(_) <- this[j][1]) {",
                      "successors": [
                        {
                          "id": 6,
                          "label": "            perm[i] = (face, -(index.value()))\n        }",
                          "successors": [
                            {
                              "id": 9,
                              "label": "    }",
                              "successors": []
                            }
                          ]
                        },
                        {
                          "id": 7,
                          "label": "        } else {\n            perm[i] = (face, index.value())",
                          "successors": [
                            {
                              "id": 9,
                              "label": "        }\n    }",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "id": 10,
                  "label": "    perm.reverse()\n    return perm",
                  "successors": []
                }
              ]
            }
          ]
        }
      ],
      "classes": [],
      "simplified_code": "extend Permutation {\n    // 获取当前置换的逆变换\n    }\n}",
      "blocks": []
    },
    {
      "name": "Cube",
      "type": "class",
      "start_line": 167,
      "end_line": 268,
      "functions": [
        {
          "name": "init",
          "type": "function",
          "start_line": 172,
          "end_line": 174,
          "functions": [],
          "classes": [],
          "simplified_code": "    public init() {\n        reset()\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "public init() {\n    reset()",
              "successors": []
            }
          ]
        },
        {
          "name": "init",
          "type": "function",
          "start_line": 176,
          "end_line": 184,
          "functions": [],
          "classes": [],
          "simplified_code": "    static init() {\n        // 每个面顺时针转动 90 度时，相邻四面的置换关系\n        permutation[F] = [(L, 2.c), (U, -2.r), (R, 0.c), (D, -0.r)]\n        permutation[B] = [(L, -0.c), (D, 2.r), (R, -2.c), (U, 0.r)]\n        permutation[L] = [(U, 0.c), (F, 0.c), (D, 0.c), (B, 0.c)]\n        permutation[R] = [(B, 2.c), (D, 2.c), (F, 2.c), (U, 2.c)]\n        permutation[U] = [(L, 0.r), (B, -2.r), (R, -0.r), (F, 0.r)]\n        permutation[D] = [(R, 2.r), (B, -0.r), (L, -2.r), (F, 2.r)]\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "static init() {\npermutation[F] = [(L, 2.c), (U, -2.r), (R, 0.c), (D, -0.r)]\npermutation[B] = [(L, -0.c), (D, 2.r), (R, -2.c), (U, 0.r)]\npermutation[L] = [(U, 0.c), (F, 0.c), (D, 0.c), (B, 0.c)]\npermutation[R] = [(B, 2.c), (D, 2.c), (F, 2.c), (U, 2.c)]\npermutation[U] = [(L, 0.r), (B, -2.r), (R, -0.r), (F, 0.r)]\npermutation[D] = [(R, 2.r), (B, -0.r), (L, -2.r), (F, 2.r)]",
              "successors": [
                {
                  "id": 3,
                  "label": "}",
                  "successors": []
                }
              ]
            }
          ]
        },
        {
          "name": "reset",
          "type": "function",
          "start_line": 186,
          "end_line": 191,
          "functions": [],
          "classes": [],
          "simplified_code": "    public func reset() {\n        history = ArrayList<Rotation>()\n        for (face in [F, B, L, R, U, D]) {\n            data[face] = Matrix.create(face)\n        }\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "public func reset() {\n    history = ArrayList<Rotation>()",
              "successors": [
                {
                  "id": 3,
                  "label": "    for (face in [F, B, L, R, U, D]) {",
                  "successors": [
                    {
                      "id": 4,
                      "label": "        data[face] = Matrix.create(face)\n    }",
                      "successors": []
                    },
                    {
                      "id": 5,
                      "label": "    }",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "rotate",
          "type": "function",
          "start_line": 195,
          "end_line": 210,
          "functions": [],
          "classes": [],
          "simplified_code": "    private func rotate(face: Face, inverse: Bool) {\n        const N = 3\n        let matrix = Matrix.create(face)\n        let map = if (inverse) {\n            { i: Int64, j: Int64 => (N - 1 - j, i) }\n        } else {\n            { i: Int64, j: Int64 => (j, N - 1 - i) }\n        }\n        for (i in 0..N) {\n            for (j in 0..N) {\n                let (u, v) = map(i, j)\n                matrix[u][v] = data[face][i][j]\n            }\n        }\n        data[face] = matrix\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "private func rotate(face: Face, inverse: Bool) {\nconst N = 3",
              "successors": [
                {
                  "id": 3,
                  "label": "let matrix = Matrix.create(face)",
                  "successors": [
                    {
                      "id": 4,
                      "label": "let map = if (inverse) {",
                      "successors": [
                        {
                          "id": 5,
                          "label": "{ i: Int64, j: Int64 => (N - 1 - j, i) }",
                          "successors": []
                        },
                        {
                          "id": 6,
                          "label": "else { { i: Int64, j: Int64 => (j, N - 1 - i) }",
                          "successors": []
                        }
                      ]
                    },
                    {
                      "id": 7,
                      "label": "for (i in 0..N) {",
                      "successors": [
                        {
                          "id": 8,
                          "label": "for (j in 0..N) {",
                          "successors": [
                            {
                              "id": 9,
                              "label": "let (u, v) = map(i, j)\nmatrix[u][v] = data[face][i][j]",
                              "successors": []
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "id": 11,
                      "label": "data[face] = matrix",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "permute",
          "type": "function",
          "start_line": 213,
          "end_line": 224,
          "functions": [],
          "classes": [],
          "simplified_code": "    private func permute(perm: Permutation, inverse: Bool) {\n        let p = if (inverse) { perm.inverse() } else { perm.clone() }\n        p.reverse()\n        var (lastFace, lastIndex) = p[0]\n        let vector = data[lastFace][lastIndex]\n        for (i in 1..p.size) {\n            let (face, index) = p[i]\n            data[lastFace].set(lastIndex, data[face][index])\n            (lastFace, lastIndex) = (face, index)\n        }\n        data[lastFace].set(lastIndex, vector)\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "let p = if (inverse) { perm.inverse() } else { perm.clone() }\np.reverse()\nvar (lastFace, lastIndex) = p[0]\nlet vector = data[lastFace][lastIndex]",
              "successors": [
                {
                  "id": 3,
                  "label": "for (i in 1..p.size) {",
                  "successors": [
                    {
                      "id": 4,
                      "label": "let (face, index) = p[i]\ndata[lastFace].set(lastIndex, data[face][index])\n(lastFace, lastIndex) = (face, index)",
                      "successors": [
                        {
                          "id": 3,
                          "label": "for (i in 1..p.size) {",
                          "successors": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "transform",
          "type": "function",
          "start_line": 227,
          "end_line": 242,
          "functions": [],
          "classes": [],
          "simplified_code": "    private func transform(rotation: Rotation, inverse: Bool): Unit {\n        match (rotation) {\n            case I(r) => transform(r, !inverse)\n            case X(r1, r2) => // 对复合操作进行递归分解\n                if (inverse) { // 逆变换需要反序\n                    transform(r2, inverse)\n                    transform(r1, inverse)\n                } else {\n                    transform(r1, inverse)\n                    transform(r2, inverse)\n                }\n            case _ => // 各原子操作对应面先旋转 90 度，然后对相邻四个面执行置换操作\n                rotate(rotation, inverse)\n                permute(permutation[rotation], inverse)\n        }\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "private func transform(rotation: Rotation, inverse: Bool): Unit {\nmatch (rotation) {",
              "successors": [
                {
                  "id": 3,
                  "label": "case I(r) => transform(r, !inverse)",
                  "successors": []
                },
                {
                  "id": 4,
                  "label": "case X(r1, r2) =>",
                  "successors": [
                    {
                      "id": 5,
                      "label": "if (inverse) {\ntransform(r2, inverse)",
                      "successors": [
                        {
                          "id": 7,
                          "label": "transform(r1, inverse)",
                          "successors": []
                        }
                      ]
                    },
                    {
                      "id": 8,
                      "label": "} else {\ntransform(r1, inverse)",
                      "successors": [
                        {
                          "id": 10,
                          "label": "transform(r2, inverse)",
                          "successors": []
                        }
                      ]
                    }
                  ]
                },
                {
                  "id": 11,
                  "label": "case _ =>\nrotate(rotation, inverse)",
                  "successors": [
                    {
                      "id": 13,
                      "label": "permute(permutation[rotation], inverse)",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "transform",
          "type": "function",
          "start_line": 244,
          "end_line": 249,
          "functions": [],
          "classes": [],
          "simplified_code": "    public func transform(rotation: Rotation) {\n        transform(rotation, false)\n        history.append(rotation)\n        print()\n        return this\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "public func transform(rotation: Rotation) {\n    transform(rotation, false)",
              "successors": [
                {
                  "id": 3,
                  "label": "    history.append(rotation)\n    print()",
                  "successors": [
                    {
                      "id": 5,
                      "label": "    return this",
                      "successors": []
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "print",
          "type": "function",
          "start_line": 251,
          "end_line": 267,
          "functions": [],
          "classes": [],
          "simplified_code": "    public func print() {\n        var prompt = \">> \"\n        for (rotation in history) {\n            prompt += rotation.toString()\n        }\n        println(prompt)\n        data[U].print()\n        for (i in 0..3) {\n            for (face in [L, F, R]) {\n                data[face].print(i)\n            }\n            println()\n        }\n        data[D].print()\n        data[B].print()\n        println()\n    }",
          "blocks": [
            {
              "id": 1,
              "label": "public func print() {\n    var prompt = \">> \"",
              "successors": [
                {
                  "id": 3,
                  "label": "for (rotation in history) {",
                  "successors": [
                    {
                      "id": 4,
                      "label": "    prompt += rotation.toString()\n}",
                      "successors": [
                        {
                          "id": 6,
                          "label": "println(prompt)\ndata[U].print()",
                          "successors": [
                            {
                              "id": 8,
                              "label": "for (i in 0..3) {",
                              "successors": [
                                {
                                  "id": 9,
                                  "label": "for (face in [L, F, R]) {",
                                  "successors": [
                                    {
                                      "id": 10,
                                      "label": "data[face].print(i)\n}",
                                      "successors": [
                                        {
                                          "id": 12,
                                          "label": "println()\n}",
                                          "successors": [
                                            {
                                              "id": 14,
                                              "label": "data[D].print()\ndata[B].print()",
                                              "successors": [
                                                {
                                                  "id": 16,
                                                  "label": "println()\n}",
                                                  "successors": []
                                                }
                                              ]
                                            }
                                          ]
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "classes": [],
      "simplified_code": "class Cube {\n    public let data = HashMap<Face, Matrix>()\n    private var history = ArrayList<Rotation>()\n    private static let permutation = HashMap<Face, Permutation>()\n\n    }\n\n    }\n\n    }\n\n    // 对指定面上的矩阵旋转 90 度，inverse = true 代表逆时针方向\n    // 此操作不影响其他面，要配合邻边置换操作才能完成魔方的实际转动\n    }\n\n    // 实现各面行/列之间的置换操作，输入是一个置换序列\n    }\n\n    // 在魔方上按序执行 rotation 中定义的操作序列\n    }\n\n    }\n\n    }\n}",
      "blocks": [
        {
          "id": 1,
          "label": "class Cube {",
          "successors": [
            {
              "id": 2,
              "label": "public let data = HashMap<Face, Matrix>()",
              "successors": []
            },
            {
              "id": 3,
              "label": "private var history = ArrayList<Rotation>()",
              "successors": []
            },
            {
              "id": 4,
              "label": "private static let permutation = HashMap<Face, Permutation>()",
              "successors": []
            }
          ]
        }
      ]
    }
  ],
  "simplified_code": "/**\n * 示例场景：用仓颉语言表达魔方置换群，并进行模拟验证\n *         本例体现了仓颉在代数/符号演算方面的定制能力，以及语言的易用性和灵活性等\n * 涉及特性：enum/构造器/递归定义/模式匹配，操作符重载，接口，类型别名，递归调用，\n *         class，tuple，Array，HashMap，for-in/Range，if-let，lambda\n * 仓颉语言团队 刘俊杰 2024/7/25\n */ \nimport std.collection.*\n\n}\n\ntype Face = Rotation\ntype Vector = Array<(Face, Int64)>\ntype Matrix = Array<Vector>\n}\n\n}\n\n// 直接用以上 enum 表示行列索引还不够优雅，我们为整型扩展两个属性，让索引数值可以直接标记行列\n}\n\n// Permutation 可以表示一个置换序列\n// 如 [(L, 2.c), (U, -0.r)] 表示 L 面第三列和 U 面第一行之间的轮换，且前者在换到后者时需要倒置\ntype Permutation = Array<(Face, Index)>\n}\n\n}\n\n}",
  "blocks": [
    {
      "id": 1,
      "label": "import std.collection.*\ntype Face = Rotation\ntype Vector = Array<(Face, Int64)>\ntype Matrix = Array<Vector>",
      "successors": [
        {
          "id": 3,
          "label": "// 直接用以上 enum 表示行列索引还不够优雅，我们为整型扩展两个属性，让索引数值可以直接标记行列\ntype Permutation = Array<(Face, Index)>",
          "successors": []
        }
      ]
    }
  ]
}