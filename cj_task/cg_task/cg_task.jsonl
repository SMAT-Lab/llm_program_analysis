{"source_code": "macro package json_cj\n\nimport std.ast.Tokens\n\npublic import json_cj.helper.*\nimport json_cj.impl.jsonTransform\n\npublic macro Json(input: Tokens): Tokens {\n    return jsonTransform(input)\n}", "llm_cg": {"main": [], "Json": ["jsonTransform"]}, "static_cg": {}}
{"source_code": "package json_cj.testutil\n\nimport std.unittest.*\nimport std.unittest.testmacro.{Assert, Fail}\nimport encoding.json.*\n\npublic func assertJson(a: JsonValue, b: JsonValue): Unit {\n    match ((a, b)) {\n        case (_: JsonNull, _: JsonNull) => return\n        case (a: JsonBool, b: JsonBool) => @Assert(a.getValue(), b.getValue())\n        case (a: JsonInt, b: JsonInt) => @Assert(a.getValue(), b.getValue())\n        case (a: JsonFloat, b: JsonFloat) => @Assert(a.getValue(), b.getValue())\n        case (a: JsonString, b: JsonString) => @Assert(a.getValue(), b.getValue())\n        case (a: JsonArray, b: JsonArray) =>\n            @Assert(a.size(), b.size())\n            for (i in 0..a.size()) {\n                assertJson(a.get(i).getOrThrow(), b.get(i).getOrThrow())\n            }\n        case (a: JsonObject, b: JsonObject) =>\n            @Assert(a.size(), b.size())\n            let fields = a.getFields()\n            for ((k, v) in fields) {\n                match (b.get(k)) {\n                    case Some(bv) => assertJson(v, bv)\n                    case None => @Fail(\"Field not found: \" + k)\n                }\n            }\n        case _ => @Fail(\"Different types: \" + a.toJsonString() + \" vs \" + b.toJsonString())\n    }\n\n    return\n}\n", "llm_cg": {"main": [], "assertJson": ["std.unittest.testmacro.Assert", "std.unittest.testmacro.Assert", "std.unittest.testmacro.Assert", "std.unittest.testmacro.Assert", "std.unittest.testmacro.Assert", "assertJson", "assertJson", "std.unittest.testmacro.Fail", "std.unittest.testmacro.Fail"]}, "static_cg": {}}
{"source_code": "package json_cj.testutil\n\nimport std.unittest.*\nimport std.unittest.testmacro.{Assert, Fail, Test, TestCase}\nimport encoding.json.*\n\n@Test\nclass TestJsonTestUtils {\n    @TestCase\n    func bool() {\n        let a: JsonValue = JsonBool(true)\n        let b: JsonValue = JsonBool(true)\n        assertJson(a, b)\n    }\n\n    @TestCase\n    func int() {\n        let a: JsonValue = JsonInt(1)\n        let b: JsonValue = JsonInt(1)\n        assertJson(a, b)\n    }\n\n    @TestCase\n    func float() {\n        let a: JsonValue = JsonFloat(1.0)\n        let b: JsonValue = JsonFloat(1.0)\n        assertJson(a, b)\n    }\n\n    @TestCase\n    func string() {\n        let a: JsonValue = JsonString(\"hello\")\n        let b: JsonValue = JsonString(\"hello\")\n        assertJson(a, b)\n    }\n\n    @TestCase\n    func array() {\n        let a: JsonValue = JsonArray([JsonInt(1), JsonInt(2), JsonInt(3)])\n        let b: JsonValue = JsonArray([JsonInt(1), JsonInt(2), JsonInt(3)])\n        assertJson(a, b)\n    }\n\n    @TestCase\n    func object() {\n        let a = JsonObject()\n        a.put(\"a\", JsonInt(1))\n        a.put(\"b\", JsonInt(2))\n        a.put(\"c\", JsonInt(3))\n        \n        let b = JsonObject()\n        b.put(\"a\", JsonInt(1))\n        b.put(\"b\", JsonInt(2))\n        b.put(\"c\", JsonInt(3))\n        assertJson(a, b)\n    }\n}", "llm_cg": {"main": [], "TestJsonTestUtils": [], "TestJsonTestUtils.bool": ["JsonBool", "assertJson"], "TestJsonTestUtils.int": ["JsonInt", "assertJson"], "TestJsonTestUtils.float": ["JsonFloat", "assertJson"], "TestJsonTestUtils.string": ["JsonString", "assertJson"], "TestJsonTestUtils.array": ["JsonArray", "JsonInt", "assertJson"], "TestJsonTestUtils.object": ["JsonObject", "JsonInt", "assertJson"]}, "static_cg": {}}
{"source_code": "package json_cj.impl\n\nimport std.ast.*\nimport std.collection.ArrayList\nimport json_cj.helper.*\n\nenum JsonState {\n    | Initial\n    | ObjectStart\n    | ObjectKey\n    | ObjectColon\n    | ObjectValue\n    | ObjectComma\n    | ArrayStart\n    | ArrayValue\n    | ArrayComma\n    | PartEnd\n    | End\n}\n\nfunc safeParseExprFragment(t: Tokens, start: Int64): Option<(Expr, Int64)> {\n    try {\n        let (expr, next) = parseExprFragment(t, startFrom: start)\n        return Some((expr, next))\n    } catch (e: ParseASTException) {\n        return None\n    }\n}\n\nfunc wrap(tt: Tokens): Tokens {\n    return quote({=> $(tt) }())\n}\n\nfunc getIdent(s: String): Token {\n    return Token(TokenKind.IDENTIFIER, s)\n}\n\nfunc parseValue(t: Tokens, start: Int64): (Tokens, Int64) {\n    let tf = t[start]\n    match (tf.kind) {\n        case TokenKind.LCURL => return parseObject(t, start + 1)\n        case TokenKind.LSQUARE => return parseArray(t, start + 1)\n        case TokenKind.IDENTIFIER where (tf.value == \"null\" || tf.value == \"None\") => return (quote(JsonNull()), start +\n                1)\n        case _ => if (let Some((expr, next)) <- safeParseExprFragment(t, start)) {\n            let exprTokens = expr.toTokens()\n            if (exprTokens.size > 1) {\n                return (quote(castJsonValue($(expr))), next)\n            }\n            let first = exprTokens[0]\n            match (first.kind) {\n                case TokenKind.STRING_LITERAL => return (quote(JsonString($(first))), next)\n                case TokenKind.INTEGER_LITERAL => return (quote(JsonInt($(first))), next)\n                case TokenKind.FLOAT_LITERAL => return (quote(JsonFloat($(first))), next)\n                case TokenKind.BOOL_LITERAL => return (quote(JsonBool($(first))), next)\n                case _ => return (quote(castJsonValue($(expr))), next)\n            }\n        } else {\n            diagReport(DiagReportLevel.ERROR, t, \"Unexpected token ${tf.value} in parseValue\", \"Unexpected token\")\n            throw Exception(\"Unexpected token ${tf.value} in parseValue\")\n        }\n    }\n}\n\nfunc parseObject(t: Tokens, start: Int64): (Tokens, Int64) {\n    let ident = getIdent(\"jsonCjObject\")\n    let tokens = quote(\n        let $(ident) = JsonObject();\n    )\n    var i = start\n    var state = JsonState.ObjectStart\n    while (i < t.size) {\n        let cur = t[i]\n        match (cur.kind) {\n            case TokenKind.RCURL => match (state) {\n                case JsonState.ObjectStart => return (quote(JsonObject()), i + 1)\n                case JsonState.ObjectValue | JsonState.ObjectComma =>\n                    tokens.append(quote(\n                            return $(ident);\n                        ))\n                    return (wrap(tokens), i + 1)\n                case _ =>\n                    diagReport(DiagReportLevel.ERROR, t, \"Unexpected state for RCURL in parseObject\", \"Unexpected state\"\n                    )\n                    throw Exception(\"Unexpected state for RCURL in parseObject\")\n            }\n            case TokenKind.COMMA => match (state) {\n                case JsonState.ObjectValue =>\n                    i++\n                    state = JsonState.ObjectComma\n                    continue\n                case _ =>\n                    diagReport(DiagReportLevel.ERROR, t, \"Unexpected state for COMMA in parseObject\", \"Unexpected state\"\n                    )\n                    throw Exception(\"Unexpected state for COMMA in parseObject\")\n            }\n            case TokenKind.STRING_LITERAL => match (state) {\n                case JsonState.ObjectStart | JsonState.ObjectComma =>\n                    let key = cur.value\n                    i++\n                    if (t[i].kind != TokenKind.COLON) {\n                        diagReport(DiagReportLevel.ERROR, t, \"No colon in object\", \"No colon\")\n                        throw Exception(\"No colon in object\")\n                    }\n                    i++\n                    let (value, next) = parseValue(t, i)\n                    i = next\n                    state = JsonState.ObjectValue\n                    tokens.append(quote(\n                        $(ident).put($(key), $(value));\n                    ))\n                    continue\n                case _ =>\n                    diagReport(DiagReportLevel.ERROR, t, \"Unexpected state for STRING_LITERAL in parseObject\",\n                        \"Unexpected state\")\n                    throw Exception(\"Unexpected state for STRING_LITERAL in parseObject\")\n            }\n            case _ =>\n                diagReport(DiagReportLevel.ERROR, t, \"Unexpected token ${cur.value} in parseObject\", \"Unexpected token\")\n                throw Exception(\"Unexpected token ${cur.value} in parseObject\")\n        }\n    }\n\n    diagReport(DiagReportLevel.ERROR, t, \"No closing curly bracket\", \"No closing curly bracket\")\n    throw Exception(\"No closing curly bracket\")\n}\n\nfunc parseArray(t: Tokens, start: Int64): (Tokens, Int64) {\n    let ident = getIdent(\"jsonCjArray\")\n    let tokens = quote(\n        let $(ident) = JsonArray();\n    )\n    var i = start\n    var state = JsonState.ArrayStart\n\n    while (i < t.size) {\n        let cur = t[i]\n        match (cur.kind) {\n            case TokenKind.RSQUARE => match (state) {\n                case JsonState.ArrayStart => return (quote(JsonArray()), i + 1)\n                case JsonState.ArrayValue | JsonState.ArrayComma =>\n                    tokens.append(quote(\n                            return $(ident);\n                        ))\n                    return (wrap(tokens), i + 1)\n                case _ =>\n                    diagReport(DiagReportLevel.ERROR, t, \"Unexpected state for RSQUARE in parseArray\",\n                        \"Unexpected state\")\n                    throw Exception(\"Unexpected state for RSQUARE in parseArray\")\n            }\n            case TokenKind.COMMA => match (state) {\n                case JsonState.ArrayValue =>\n                    i++\n                    state = JsonState.ArrayComma\n                    continue\n                case _ =>\n                    diagReport(DiagReportLevel.ERROR, t, \"Unexpected state for COMMA in parseArray\", \"Unexpected state\")\n                    throw Exception(\"Unexpected state for COMMA in parseArray\")\n            }\n            case _ => match (state) {\n                case JsonState.ArrayStart | JsonState.ArrayComma =>\n                    let (value, next) = parseValue(t, i)\n                    i = next\n                    state = JsonState.ArrayValue\n                    tokens.append(quote(\n                        $(ident).add($(value));\n                    ))\n                    continue\n                case _ =>\n                    diagReport(DiagReportLevel.ERROR, t, \"Unexpected token ${cur.value} in parseArray\",\n                        \"Unexpected token\")\n                    throw Exception(\"Unexpected token ${cur.value} in parseArray\")\n            }\n        }\n    }\n\n    diagReport(DiagReportLevel.ERROR, t, \"No closing bracket\", \"No closing bracket\")\n    throw Exception(\"No closing bracket\")\n}\n\nprotected func jsonTransform(input: Tokens): Tokens {\n    let t = Tokens()\n\n    for (ti in input) {\n        if (let TokenKind.NL <- ti.kind) {\n            continue\n        }\n        t.append(ti)\n    }\n\n    let ret = Tokens()\n\n    if (t.size == 0) {\n        return quote(())\n    }\n\n    let cur = t[0]\n    let cv = cur.value\n    match (cur.kind) {\n        case TokenKind.LCURL =>\n            let (ts, next) = parseObject(t, 1)\n            ret.append(quote(\n                    return $(ts);\n                ))\n            if (next != t.size) {\n                diagReport(DiagReportLevel.ERROR, t, \"Unexpected token after initial object\",\n                    \"Unexpected token after initial object\")\n                throw Exception(\"Unexpected token after initial object\")\n            }\n            return wrap(ret)\n        case TokenKind.LSQUARE =>\n            let (ts, next) = parseArray(t, 1)\n            ret.append(quote(\n                        return $(ts);\n                    ))\n            if (next != t.size) {\n                diagReport(DiagReportLevel.ERROR, t, \"Unexpected token after initial array\",\n                    \"Unexpected token after initial array\")\n                throw Exception(\"Unexpected token after initial array\")\n            }\n            return wrap(ret)\n        case TokenKind.IDENTIFIER where (cv == \"null\" || cv == \"None\") => return quote(JsonNull())\n        case _ =>\n            let (ts, next) = parseValue(t, 0)\n            if (next != t.size) {\n                diagReport(DiagReportLevel.ERROR, t, \"Unexpected token after initial value\",\n                    \"Unexpected token after initial value\")\n                throw Exception(\"Unexpected token after initial value\")\n            }\n            return ts\n    }\n}\n", "llm_cg": {"safeParseExprFragment": ["parseExprFragment", "Some", "None"], "wrap": [], "getIdent": ["Token"], "parseValue": ["safeParseExprFragment", "expr.toTokens", "exprTokens.size", "quote", "quote", "quote", "quote", "quote", "diagReport", "Exception"], "parseObject": ["getIdent", "quote", "diagReport", "Exception", "diagReport", "Exception", "parseValue", "diagReport", "Exception", "diagReport", "Exception", "diagReport", "Exception"], "parseArray": ["getIdent", "quote", "diagReport", "Exception", "diagReport", "Exception", "parseValue", "diagReport", "Exception", "diagReport", "Exception"], "jsonTransform": ["TokenKind.NL", "quote", "parseObject", "quote", "diagReport", "Exception", "wrap", "parseArray", "quote", "diagReport", "Exception", "wrap", "quote", "parseValue", "diagReport", "Exception"]}, "static_cg": {}}
{"source_code": "package json_cj.test\n\nimport std.unittest.*\nimport std.ast.*\nimport std.unittest.testmacro.{Test, Assert, TestCase, Fail}\nimport encoding.json.*\nimport json_cj.*\nimport json_cj.testutil.assertJson\n\n@Test\nclass JSONTests {\n    @TestCase\n    func jsonEqual() {\n        const jsonStr = \"\"\"\n                        {\n                          \"name\": \"John Doe\",\n                          \"age\": 30,\n                          \"city\": \"New York\"\n                        }\n                        \"\"\"\n\n        var jsonVal = JsonValue.fromStr(jsonStr)\n        var jsonVal2 = JsonValue.fromStr(jsonStr)\n\n        assertJson(jsonVal, jsonVal2)\n    }\n\n    @TestCase\n    func basic() {\n        assertJson(@Json( 1 + 2 ), JsonInt(3))\n        assertJson(@Json( 1.0 + 2.0 ), JsonFloat(3.0))\n        assertJson(@Json( \"Hello, \" + \"world!\" ), JsonString(\"Hello, world!\"))\n        assertJson(@Json( true ), JsonBool(true))\n        assertJson(@Json( false ), JsonBool(false))\n        assertJson(@Json( null ), JsonNull())\n        assertJson(@Json( None ), JsonNull())\n    }\n\n    @TestCase\n    func variable() {\n        var a = 1\n        var b = 2\n        var c = \"Hello, \"\n        var d = \"world!\"\n        var e = true\n        var f = false\n        var h = None<Int>\n\n        assertJson(@Json( a + b ), JsonInt(3))\n        assertJson(@Json( 1.0 + 2.0 ), JsonFloat(3.0))\n        assertJson(@Json( c + d ), JsonString(\"Hello, world!\"))\n        assertJson(@Json( e ), JsonBool(true))\n        assertJson(@Json( f ), JsonBool(false))\n        assertJson(@Json( h ), JsonNull())\n    }\n\n    @TestCase\n    func array() {\n        assertJson(@Json( [1, 2, 3] ), JsonArray([JsonInt(1), JsonInt(2), JsonInt(3)]))\n        assertJson(@Json( [\"apple\", \"banana\", \"cherry\"] ),\n            JsonArray([JsonString(\"apple\"), JsonString(\"banana\"), JsonString(\"cherry\")]))\n        assertJson(\n            @Json( [1, \"two\", true, null ] ),\n            JsonArray([JsonInt(1), JsonString(\"two\"), JsonBool(true), JsonNull()])\n        )\n    }\n\n    @TestCase\n    func object() {\n        const jsonStr = \"\"\"\n                        {\n                          \"name\": \"John Doe\",\n                          \"age\": 30,\n                          \"city\": \"New York\"\n                        }\n                        \"\"\"\n        let jsonVal = JsonValue.fromStr(jsonStr)\n        let jsonMVal = @Json(\n            {\n                \"name\": \"John Doe\",\n                \"age\": 30,\n                \"city\": \"New York\"\n            }\n        )\n        assertJson(jsonVal, jsonMVal)\n\n        const jsonStr2 = \"\"\"\n                        {\n                          \"fruits\": [\"apple\", \"banana\", \"cherry\"],\n                          \"numbers\": [1, 2, 3, 4, 5],\n                          \"mixed\": [1, \"two\", true, null]\n                        }\n                        \"\"\"\n        let jsonVal2 = JsonValue.fromStr(jsonStr2)\n        let jsonMVal2 = @Json(\n            {\n                \"fruits\": [\"apple\", \"banana\", \"cherry\"],\n                \"numbers\": [1, 2, 3, 4, 5],\n                \"mixed\": [1, \"two\", true, null]\n            }\n        )\n        assertJson(jsonVal2, jsonMVal2)\n\n        const jsonStr3 = \"\"\"\n                        {\n                          \"person\": {\n                            \"name\": {\n                              \"first\": \"Jane\",\n                              \"last\": \"Smith\"\n                            },\n                            \"age\": 28,\n                            \"address\": {\n                              \"street\": \"123 Main St\",\n                              \"city\": \"Boston\",\n                              \"country\": \"USA\"\n                            }\n                          }\n                        }\n                        \"\"\"\n        let jsonVal3 = JsonValue.fromStr(jsonStr3)\n        let jsonMVal3 = @Json(\n            {\n                \"person\": {\n                    \"name\": {\n                        \"first\": \"Jane\",\n                        \"last\": \"Smith\"\n                    },\n                    \"age\": 28,\n                    \"address\": {\n                        \"street\": \"123 Main St\",\n                        \"city\": \"Boston\",\n                        \"country\": \"USA\"\n                    }\n                }\n            }\n        )\n        assertJson(jsonVal3, jsonMVal3)\n\n        const jsonStr4 = \"\"\"\n                        {\n                          \"company\": \"Tech Corp\",\n                          \"employees\": [\n                            {\n                              \"id\": 1,\n                              \"name\": \"Alice\",\n                              \"department\": \"Engineering\",\n                              \"projects\": [\"Project A\", \"Project B\"]\n                            },\n                            {\n                              \"id\": 2,\n                              \"name\": \"Bob\",\n                              \"department\": \"Marketing\",\n                              \"campaigns\": {\n                                \"online\": [\"Social Media\", \"Email\"],\n                                \"offline\": [\"TV\", \"Radio\"]\n                              }\n                            }\n                          ],\n                          \"founded\": 1995,\n                          \"active\": true,\n                          \"CEO\": null\n                        }\n                        \"\"\"\n        let jsonVal4 = JsonValue.fromStr(jsonStr4)\n        let jsonMVal4 = @Json(\n            {\n                \"company\": \"Tech Corp\",\n                \"employees\": [\n                    {\n                        \"id\": 1,\n                        \"name\": \"Alice\",\n                        \"department\": \"Engineering\",\n                        \"projects\": [\"Project A\", \"Project B\"]\n                    },\n                    {\n                        \"id\": 2,\n                        \"name\": \"Bob\",\n                        \"department\": \"Marketing\",\n                        \"campaigns\": {\n                            \"online\": [\"Social Media\", \"Email\"],\n                            \"offline\": [\"TV\", \"Radio\"]\n                        }\n                    }\n                ],\n                \"founded\": 1995,\n                \"active\": true,\n                \"CEO\": null\n            }\n        )\n        assertJson(jsonVal4, jsonMVal4)\n    }\n\n    @TestCase\n    func empty() {\n        assertJson(@Json( {} ), JsonObject())\n        assertJson(@Json( [] ), JsonArray())\n\n        @Assert((), @Json())\n    }\n\n    @TestCase\n    func trailingComma() {\n        assertJson(@Json( [1, 2, 3,] ), JsonArray([JsonInt(1), JsonInt(2), JsonInt(3)]))\n        assertJson(@Json( {\"a\": 1, \"b\": 2, \"c\": 3,} ), @Json( {\"a\": 1, \"b\": 2, \"c\": 3} ))\n    }\n}\n", "llm_cg": {"main": [], "JSONTests": [], "JSONTests.jsonEqual": ["JsonValue.fromStr", "assertJson"], "JSONTests.basic": ["assertJson"], "JSONTests.variable": ["assertJson"], "JSONTests.array": ["assertJson"], "JSONTests.object": ["JsonValue.fromStr", "assertJson"], "JSONTests.empty": ["assertJson", "JsonObject", "JsonArray"], "JSONTests.trailingComma": ["assertJson"]}, "static_cg": {}}
{"source_code": "package json_cj.helper\n\nimport std.collection.*\nimport encoding.json.*\n\npublic interface ToJsonValue {\n    func toJsonValue(): JsonValue\n}\n\nextend Bool <: ToJsonValue {\n    public func toJsonValue(): JsonValue {\n        return JsonBool(this)\n    }\n}\n\nextend Int8 <: ToJsonValue {\n    public func toJsonValue(): JsonValue {\n        return JsonInt(Int64(this))\n    }\n}\n\nextend Int16 <: ToJsonValue {\n    public func toJsonValue(): JsonValue {\n        return JsonInt(Int64(this))\n    }\n}\n\nextend Int32 <: ToJsonValue {\n    public func toJsonValue(): JsonValue {\n        return JsonInt(Int64(this))\n    }\n}\n\nextend Int64 <: ToJsonValue {\n    public func toJsonValue(): JsonValue {\n        return JsonInt(this)\n    }\n}\n\nextend IntNative <: ToJsonValue {\n    public func toJsonValue(): JsonValue {\n        return JsonInt(Int64(this))\n    }\n}\n\nextend UInt8 <: ToJsonValue {\n    public func toJsonValue(): JsonValue {\n        return JsonInt(Int64(this))\n    }\n}\n\nextend UInt16 <: ToJsonValue {\n    public func toJsonValue(): JsonValue {\n        return JsonInt(Int64(this))\n    }\n}\n\nextend UInt32 <: ToJsonValue {\n    public func toJsonValue(): JsonValue {\n        return JsonInt(Int64(this))\n    }\n}\n\nextend UInt64 <: ToJsonValue {\n    public func toJsonValue(): JsonValue {\n        return JsonInt(Int64(this))\n    }\n}\n\nextend UIntNative <: ToJsonValue {\n    public func toJsonValue(): JsonValue {\n        return JsonInt(Int64(this))\n    }\n}\n\nextend Float16 <: ToJsonValue {\n    public func toJsonValue(): JsonValue {\n        return JsonFloat(Float64(this))\n    }\n}\n\nextend Float32 <: ToJsonValue {\n    public func toJsonValue(): JsonValue {\n        return JsonFloat(Float64(this))\n    }\n}\n\nextend Float64 <: ToJsonValue {\n    public func toJsonValue(): JsonValue {\n        return JsonFloat(this)\n    }\n}\n\nextend String <: ToJsonValue {\n    public func toJsonValue(): JsonValue {\n        return JsonString(this)\n    }\n}\n\nextend<T> Array<T> <: ToJsonValue where T <: ToJsonValue {\n    public func toJsonValue(): JsonValue {\n        let arr = JsonArray()\n        for (i in this) {\n            arr.add(i.toJsonValue())\n        }\n        return arr\n    }\n}\n\nextend<T> ArrayList<T> <: ToJsonValue where T <: ToJsonValue {\n    public func toJsonValue(): JsonValue {\n        let arr = JsonArray()\n        for (i in this) {\n            arr.add(i.toJsonValue())\n        }\n        return arr\n    }\n}\n\nextend<T> LinkedList<T> <: ToJsonValue where T <: ToJsonValue {\n    public func toJsonValue(): JsonValue {\n        let arr = JsonArray()\n        for (i in this) {\n            arr.add(i.toJsonValue())\n        }\n        return arr\n    }\n}\n\nfunc matchValue<T>(v: T): JsonValue {\n    match (v) {\n        case vv: ToJson => return vv.toJson()\n        case vv: ToJsonValue => return vv.toJsonValue()\n        case _ => throw Exception(\"Value must implement ToJson or ToJsonValue\")\n    }\n}\n\nextend<K> Option<K> <: ToJsonValue {\n    public func toJsonValue(): JsonValue {\n        match (this) {\n            case Some(v) => return matchValue(v)\n            case None => return JsonNull()\n        }\n    }\n}\n\n\nextend<K, V> TreeMap<K, V> <: ToJsonValue where K <: ToString & Equatable<K> {\n    public func toJsonValue(): JsonValue {\n        let obj = JsonObject()\n        \n        for ((k,v) in this) {\n            obj.put(k.toString(), matchValue(v))\n        }\n\n        return obj\n    }\n}\n\nextend<K, V> HashMap<K, V> <: ToJsonValue where K <: ToString & Equatable<K> {\n    public func toJsonValue(): JsonValue {\n        let obj = JsonObject()\n        \n        for ((k,v) in this) {\n            obj.put(k.toString(), matchValue(v))\n        }\n\n        return obj\n    }\n}\n\npublic func castJsonValue(t: ToJsonValue): JsonValue {\n    return t.toJsonValue()\n}\n\npublic func castJsonValue(t: JsonValue): JsonValue {\n    return t\n}\n\npublic func castJsonValue(t: ToJson): JsonValue {\n    return t.toJson()\n}", "llm_cg": {"main": [], "ToJsonValue.toJsonValue": [], "Bool.toJsonValue": ["JsonBool"], "Int8.toJsonValue": ["Int64", "JsonInt"], "Int16.toJsonValue": ["Int64", "JsonInt"], "Int32.toJsonValue": ["Int64", "JsonInt"], "Int64.toJsonValue": ["JsonInt"], "IntNative.toJsonValue": ["Int64", "JsonInt"], "UInt8.toJsonValue": ["Int64", "JsonInt"], "UInt16.toJsonValue": ["Int64", "JsonInt"], "UInt32.toJsonValue": ["Int64", "JsonInt"], "UInt64.toJsonValue": ["JsonInt"], "UIntNative.toJsonValue": ["Int64", "JsonInt"], "Float16.toJsonValue": ["Float64", "JsonFloat"], "Float32.toJsonValue": ["Float64", "JsonFloat"], "Float64.toJsonValue": ["JsonFloat"], "String.toJsonValue": ["JsonString"], "Array.toJsonValue": ["JsonArray", "Array.toJsonValue.toJsonValue", "JsonArray.add"], "ArrayList.toJsonValue": ["JsonArray", "ArrayList.toJsonValue.toJsonValue", "JsonArray.add"], "LinkedList.toJsonValue": ["JsonArray", "LinkedList.toJsonValue.toJsonValue", "JsonArray.add"], "matchValue": ["Exception", "ToJson.toJson", "ToJsonValue.toJsonValue"], "Option.toJsonValue": ["matchValue", "JsonNull"], "TreeMap.toJsonValue": ["JsonObject", "TreeMap.toJsonValue.toString", "TreeMap.toJsonValue.matchValue", "JsonObject.put"], "HashMap.toJsonValue": ["JsonObject", "HashMap.toJsonValue.toString", "HashMap.toJsonValue.matchValue", "JsonObject.put"], "castJsonValue": ["ToJson.toJson", "ToJsonValue.toJsonValue"]}, "static_cg": {}}
{"source_code": "package json_cj.helper\n\nimport std.unittest.testmacro.{Test, Assert, TestCase}\nimport std.unittest.*\nimport std.collection.*\nimport encoding.json.*\nimport serialization.serialization.*\nimport json_cj.testutil.assertJson\n\n@Test\nclass HelperTests {\n    @TestCase\n    func basic() {\n        let a: Bool = true\n        let i8: Int8 = 1\n        let i16: Int16 = 2\n        let i32: Int32 = 3\n        let i64: Int64 = 4\n        let ina: IntNative = 5\n        let u8: UInt8 = 6\n        let u16: UInt16 = 7\n        let u32: UInt32 = 8\n        let u64: UInt64 = 9\n        let una: UIntNative = 10 \n        let f16: Float16 = 0.5\n        let f32: Float32 = 0.25\n        let f64: Float64 = 0.125\n        let s: String = \"hello\"\n\n        assertJson(castJsonValue(a), JsonBool(true))\n        assertJson(castJsonValue(i8), JsonInt(1))\n        assertJson(castJsonValue(i16), JsonInt(2))\n        assertJson(castJsonValue(i32), JsonInt(3))\n        assertJson(castJsonValue(i64), JsonInt(4))\n        assertJson(castJsonValue(ina), JsonInt(5))\n        assertJson(castJsonValue(u8), JsonInt(6))\n        assertJson(castJsonValue(u16), JsonInt(7))\n        assertJson(castJsonValue(u32), JsonInt(8))\n        assertJson(castJsonValue(u64), JsonInt(9))\n        assertJson(castJsonValue(una), JsonInt(10))\n        assertJson(castJsonValue(f16), JsonFloat(0.5))\n        assertJson(castJsonValue(f32), JsonFloat(0.25))\n        assertJson(castJsonValue(f64), JsonFloat(0.125))\n        assertJson(castJsonValue(s), JsonString(\"hello\"))\n\n        assertJson(a.toJsonValue(), JsonBool(true))\n        assertJson(i8.toJsonValue(), JsonInt(1))\n        assertJson(i16.toJsonValue(), JsonInt(2))\n        assertJson(i32.toJsonValue(), JsonInt(3))\n        assertJson(i64.toJsonValue(), JsonInt(4))\n        assertJson(ina.toJsonValue(), JsonInt(5))\n        assertJson(u8.toJsonValue(), JsonInt(6))\n        assertJson(u16.toJsonValue(), JsonInt(7))\n        assertJson(u32.toJsonValue(), JsonInt(8))\n        assertJson(u64.toJsonValue(), JsonInt(9))\n        assertJson(una.toJsonValue(), JsonInt(10))\n        assertJson(f16.toJsonValue(), JsonFloat(0.5))\n        assertJson(f32.toJsonValue(), JsonFloat(0.25))\n        assertJson(f64.toJsonValue(), JsonFloat(0.125))\n        assertJson(s.toJsonValue(), JsonString(\"hello\"))\n    }\n\n    @TestCase\n    func tojson() {\n        let t = DataModelInt(233)\n        assertJson(castJsonValue(t), JsonInt(233))\n    }\n\n    @TestCase\n    func jsonValue() {\n        let a = JsonInt(1)\n        let b = JsonFloat(1.0)\n        let c = JsonBool(true)\n        let d = JsonString(\"hello\")\n        let e = JsonNull()\n\n        assertJson(castJsonValue(a), a)\n        assertJson(castJsonValue(b), b)\n        assertJson(castJsonValue(c), c)\n        assertJson(castJsonValue(d), d)\n        assertJson(castJsonValue(e), e)\n    }\n\n    @TestCase\n    func list() {\n        let a = [1, 2, 3]\n        let b = ArrayList([1, 2, 3])\n        let c = LinkedList([1, 2, 3])\n\n        let target = JsonArray([JsonInt(1), JsonInt(2), JsonInt(3)])\n\n        assertJson(castJsonValue(a), target)\n        assertJson(castJsonValue(b), target)\n        assertJson(castJsonValue(c), target)\n    }\n\n    @TestCase\n    func map() {\n        let a = TreeMap([(\"a\", 1), (\"b\", 2), (\"c\", 3)])\n        let target = JsonObject()\n        target.put(\"a\", JsonInt(1))\n        target.put(\"b\", JsonInt(2))\n        target.put(\"c\", JsonInt(3))\n\n        assertJson(castJsonValue(a), target)\n    }\n\n    @TestCase\n    func option() {\n        let a: Option<Int> = Some(1)\n        let b: Option<Int> = None\n\n        assertJson(castJsonValue(a), JsonInt(1))\n        assertJson(castJsonValue(b), JsonNull())\n    }\n}", "llm_cg": {"main": [], "HelperTests": [], "HelperTests.basic": ["assertJson", "castJsonValue", "JsonBool", "JsonInt", "JsonFloat", "JsonString", "a.toJsonValue", "i8.toJsonValue", "i16.toJsonValue", "i32.toJsonValue", "i64.toJsonValue", "ina.toJsonValue", "u8.toJsonValue", "u16.toJsonValue", "u32.toJsonValue", "u64.toJsonValue", "una.toJsonValue", "f16.toJsonValue", "f32.toJsonValue", "f64.toJsonValue", "s.toJsonValue"], "HelperTests.tojson": ["DataModelInt", "assertJson", "castJsonValue", "JsonInt"], "HelperTests.jsonValue": ["JsonInt", "JsonFloat", "JsonBool", "JsonString", "JsonNull", "assertJson", "castJsonValue"], "HelperTests.list": ["ArrayList", "LinkedList", "JsonArray", "JsonInt", "assertJson", "castJsonValue"], "HelperTests.map": ["TreeMap", "JsonObject", "target.put", "JsonInt", "assertJson", "castJsonValue"], "HelperTests.option": ["Option", "Some", "None", "assertJson", "castJsonValue", "JsonInt", "JsonNull"]}, "static_cg": {}}
{"source_code": "package Macro_JsonSerializable\n\nimport serialization.serialization.*\nimport encoding.json.*\nimport Macro_JsonSerializable.macros.*\n\n@JsonSerializable[private]\npublic struct S0 <: Serializable<S0> & ToString & ToJson {\n    let name: String\n}\n\n@JsonSerializable[protected]\npublic struct S1<T> <: Serializable<S1<T>> & ToString & ToJson where T <: Serializable<T> {\n    let name: String\n    let t: T\n}\n\n@JsonSerializable[internal]\npublic struct S2<T, Q> <: Serializable<S2<T, Q>> & ToString & ToJson where T <: Serializable<T>, Q <: Serializable<Q> {\n    let t: T\n    let q: Q\n}\n\n@JsonSerializable[public]\npublic struct S3<T, Q> <: Serializable<S3<T, Q>> & ToString & ToJson where T <: Serializable<T>, Q <: Serializable<Q> {\n    let t: Option<T>\n    let q: ????Q\n}\n\nmain() {\n    println(S3(t: \"T\", q: \"Q\")) // {\"t\":\"T\",\"q\":\"Q\"}\n}", "llm_cg": {"main": ["<builtin>.println", "S3"]}, "static_cg": {}}
{"source_code": "macro package Macro_JsonSerializable.macros\n\nimport std.ast.*\n\n// 工具方法，查找结构体是否需要实现某个接口\nfunc findInterface(name: String, decl: StructDecl): Bool {\n    for (sp in decl.superTypes) {\n        match (sp) {\n            case rt: RefType => if (rt.identifier.value == name) {\n                return true\n            } else {\n                continue\n            }\n            case _ => continue\n        }\n    }\n    return false\n}", "llm_cg": {}, "static_cg": {}}
{"source_code": "macro package Macro_JsonSerializable.macros\n\nimport std.ast.*\n\n// 结构体 fromJson、toJson 方法生成器\nclass StructToJsonFunctionGenerator <: Generator {\n\n    public func generate(context: Context): Unit {\n        if (!findInterface(\"ToJson\", context.structDecl)) {\n            return\n        }\n        let fromJsonFunc = FuncDecl(quote(\n            public static func fromJson(jv: JsonValue): DataModel {\n                return DataModel.fromJson(jv)\n            }\n        ))\n        context.structDecl.body.decls.append(fromJsonFunc)\n        let toJsonFunc = FuncDecl(quote(\n            public func toJson(): JsonValue {\n                return this.serialize().toJson()\n            }\n        ))\n        context.structDecl.body.decls.append(toJsonFunc)\n    }\n}", "llm_cg": {"main": [], "StructToJsonFunctionGenerator": [], "StructToJsonFunctionGenerator.generate": ["findInterface", "FuncDecl", "DataModel.fromJson", "context.structDecl.body.decls.append", "this.serialize.toJson"]}, "static_cg": {}}
{"source_code": "macro package Macro_JsonSerializable.macros\n\nimport std.ast.*\nimport std.collection.*\n\n// 结构体 serialize、deserialize 方法生成器\nclass StructSerializableFunctionGenerator <: Generator {\n\n    public func generate(context: Context): Unit {\n        this.generateDeserialize(context)\n        this.generateSerialize(context)\n    }\n\n    private func generateStructNameTokens(decl: StructDecl): Tokens {\n        try {\n            return quote($(decl.identifier)$(decl.genericParam))\n        } catch (_: Exception) {\n            return quote($(decl.identifier))\n        }\n    }\n\n    private func generateDeserialize(context: Context): Unit {\n        let arguments = ArrayList<Argument>()\n        let assign = quote()\n        for (reval in context.valDecls) {\n            if (reval.assign.kind != TokenKind.ASSIGN) {\n                let arg = Argument()\n                arg.identifier = Token(TokenKind.IDENTIFIER, reval.identifier.value)\n                arg.expr = CallExpr(quote(\n                    $(reval.declType).deserialize(dms.get($(reval.identifier.value)))\n                ))\n                arg.colon = Token(TokenKind.COLON, \":\")\n                arguments.append(arg)\n            } else if (reval.keyword.kind == TokenKind.VAR) {\n                assign.append(quote(\n                    reval.$(reval.identifier) = $(reval.declType).deserialize(dms.get($(reval.identifier.value)))\n                ))\n            }\n        }\n        let ce = CallExpr(quote($(generateStructNameTokens(context.structDecl))()))\n        ce.arguments = arguments\n        let body: Tokens\n        if (assign.size == 0) {\n            body = quote(\n                return $(ce)\n            )\n        } else {\n            body = quote(\n                var reval = $(ce)\n                $(assign)\n                return reval\n            )\n        }\n        let deserializeFunc = FuncDecl(quote(\n            public static func deserialize(dm: DataModel): $(generateStructNameTokens(context.structDecl)) {\n                let dms = match (dm) {\n                    case d: DataModelStruct => d\n                    case _ => throw Exception(\"This data is not DataModelStruct\")\n                }\n                $(body)\n            }\n        ))\n        context.structDecl.body.decls.append(deserializeFunc)\n    }\n\n    private func generateSerialize(context: Context): Unit {\n        let body = quote()\n        for (reval in context.valDecls) {\n            body.append(quote(\n                dms.add(field($(reval.identifier.value), this.$(reval.identifier)))\n            ))\n        }\n        let serializeFunc = FuncDecl(quote(\n            public func serialize(): DataModel {\n                let dms = DataModelStruct()\n                $(body)\n                return dms\n            }\n        ))\n        context.structDecl.body.decls.append(serializeFunc)\n    }\n}", "llm_cg": {"main": [], "StructSerializableFunctionGenerator": [], "StructSerializableFunctionGenerator.generate": ["StructSerializableFunctionGenerator.generateDeserialize", "StructSerializableFunctionGenerator.generateSerialize"], "StructSerializableFunctionGenerator.generateStructNameTokens": ["<builtin>.quote", "<builtin>.try", "<builtin>.catch", "Exception"], "StructSerializableFunctionGenerator.generateDeserialize": ["ArrayList", "<builtin>.quote", "context.valDecls", "Argument", "Token", "reval.declType.deserialize", "reval.declType.deserialize", "reval.identifier.value", "ce.arguments", "generateStructNameTokens", "<builtin>.return", "<builtin>.match", "DataModelStruct", "Exception", "reval.identifier.value"], "StructSerializableFunctionGenerator.generateSerialize": ["<builtin>.quote", "<builtin>.append", "reval.identifier", "DataModelStruct", "context.structDecl.body.decls"]}, "static_cg": {}}
{"source_code": "macro package Macro_JsonSerializable.macros\n\nimport std.ast.*\n\n// 生成器抽象类\nabstract class Generator {\n    public func generate(context: Context) : Unit\n}", "llm_cg": {"main": [], "Generator": []}, "static_cg": {}}
{"source_code": "macro package Macro_JsonSerializable.macros\n\nimport std.ast.*\nimport std.collection.*\n\n// 宏入口\npublic macro JsonSerializable(attrs: Tokens, input: Tokens): Tokens {\n    let context = Context(attrs, input)\n    let generators: Array<Generator> = [\n        StructValDeclTransfromGenerator(),\n        StructInitFunctionGenerator(),\n        StructSerializableFunctionGenerator(),\n        StructToJsonFunctionGenerator(),\n        StructToStringFunctionGenerator()\n    ]\n    generators |> forEach { g: Generator => g.generate(context) }\n    return context.structDecl.toTokens()\n}", "llm_cg": {"main": [], "JsonSerializable": ["Context", "StructValDeclTransfromGenerator", "StructInitFunctionGenerator", "StructSerializableFunctionGenerator", "StructToJsonFunctionGenerator", "StructToStringFunctionGenerator", "<builtin>.forEach", "Generator.generate", "context.structDecl.toTokens"]}, "static_cg": {}}
{"source_code": "macro package Macro_JsonSerializable.macros\n\nimport std.ast.*\nimport std.collection.*\n\n// 结构体属性访问器\nclass StructDeclVisitor <: Visitor {\n\n    let varDecls = ArrayList<VarDecl>()\n\n    public override func visit(varDecl: VarDecl) {\n        this.varDecls.append(varDecl)\n        breakTraverse()\n    }\n}", "llm_cg": {"StructDeclVisitor": ["ArrayList"], "StructDeclVisitor.visit": ["this.varDecls.append", "this.breakTraverse"]}, "static_cg": {}}
{"source_code": "macro package Macro_JsonSerializable.macros\n\nimport std.ast.*\n\n// 将属性中 ?T 转换为 Option<T>\nclass StructValDeclTransfromGenerator <: Generator {\n\n    public func generate(context: Context): Unit {\n        for (decl in context.valDecls) {\n            match (decl.declType) {\n                case t: PrefixType =>\n                    var reval = t.baseType.toTokens()\n                    for (op in t.prefixOps) {\n                        if (op.kind == TokenKind.QUEST) {\n                            reval = quote(Option<$(reval)>)    \n                        } else {\n                            diagReport(DiagReportLevel.ERROR, op.toTokens(), \"不支持的标识\", \"仅支持问号\")\n                            throw Exception(\"不支持的标识\")\n                        }\n                    }\n                    decl.declType = RefType(reval.toTokens())\n                case _ => continue\n            }\n        }\n    }\n}", "llm_cg": {"StructValDeclTransfromGenerator": [], "StructValDeclTransfromGenerator.generate": ["context.valDecls", "t.baseType.toTokens", "t.prefixOps", "quote", "diagReport", "op.toTokens", "Exception", "reval.toTokens"]}, "static_cg": {}}
{"source_code": "macro package Macro_JsonSerializable.macros\n\nimport std.ast.*\n\n// 结构体 toString、toJsonString 方法生成器\nclass StructToStringFunctionGenerator <: Generator {\n\n    public func generate(context: Context): Unit {\n        if (!findInterface(\"ToString\", context.structDecl)) {\n            return\n        }\n        let toStringFunc = FuncDecl(quote(\n            public func toString(): String {\n                return this.serialize().toJson().toString()\n            }\n        ))\n        context.structDecl.body.decls.append(toStringFunc)\n        let toJsonStringFunc = FuncDecl(quote(\n            public func toJsonString(): String {\n                return this.serialize().toJson().toJsonString()\n            }\n        ))\n        context.structDecl.body.decls.append(toJsonStringFunc)\n    }\n}", "llm_cg": {"StructToStringFunctionGenerator": [], "StructToStringFunctionGenerator.generate": ["findInterface", "context.structDecl.body.decls.append", "FuncDecl", "quote", "this.serialize", "this.serialize.toJson", "this.serialize.toJson.toString", "this.serialize.toJson.toJsonString"], "main": []}, "static_cg": {}}
{"source_code": "macro package Macro_JsonSerializable.macros\n\nimport std.ast.*\nimport std.collection.*\n\n// 结构体命名构造函数生成器\nclass StructInitFunctionGenerator <: Generator {\n\n    public func generate(context: Context): Unit {\n        var tokens = context.attrs\n        if (tokens.size == 0) {\n            tokens = Token(TokenKind.PRIVATE, \"private\").toTokens()\n        } else if (tokens.size > 1) {\n            diagReport(DiagReportLevel.ERROR, context.attrs, \"构造函数可见性设置错误\", \"不支持多个关键字\")\n            throw Exception(\"构造函数可见性设置错误\")\n        }\n        let illegal = match (tokens[0].kind) {\n            case TokenKind.PUBLIC => false\n            case TokenKind.PRIVATE => false\n            case TokenKind.PROTECTED => false\n            case TokenKind.INTERNAL => false\n            case _ => true\n        }\n        if (illegal) {\n            diagReport(DiagReportLevel.ERROR, context.attrs, \"构造函数可见性设置错误\", \"不支持的关键字: ${tokens[0].value}\")\n            return\n        }\n        let params = ArrayList<FuncParam>()\n        let body = quote()\n        for (reval in context.valDecls) {\n            if (reval.assign.kind == TokenKind.ASSIGN) {\n                continue\n            }\n            params.append(FuncParam(quote(\n                $(reval.identifier)!: $(reval.declType)\n            )))\n            body.append(quote(\n                this.$(reval.identifier) = $(reval.identifier)\n            ))\n        }\n        let funcDecl = FuncDecl(quote(\n            $(tokens) init() {\n                $(body)\n            }\n        ))\n        funcDecl.funcParams = params\n        context.structDecl.body.decls.append(funcDecl)\n    }\n}", "llm_cg": {"StructInitFunctionGenerator": [], "StructInitFunctionGenerator.generate": ["context.attrs", "context.attrs.size", "context.attrs.size", "diagReport", "context.attrs", "Exception", "match", "tokens[0].kind", "diagReport", "context.attrs", "tokens[0].value", "ArrayList", "quote", "context.valDecls", "reval.assign.kind", "params.append", "quote", "body.append", "FuncDecl", "quote", "context.structDecl.body.decls.append"]}, "static_cg": {}}
{"source_code": "macro package Macro_JsonSerializable.macros\n\nimport std.ast.*\n\n// 生成上下文\nclass Context {\n\n    let attrs: Tokens\n    let input: Tokens\n    let structDecl: StructDecl\n    let valDecls: Array<VarDecl>\n    \n    init(attrs: Tokens, input: Tokens) {\n        this.attrs = attrs\n        this.input = input\n        this.structDecl = match (parseDecl(input)) {\n            case d: StructDecl => d\n            case _ =>\n                diagReport(DiagReportLevel.ERROR, input, \"宏仅适用于结构体\", \"请检查宏是否作用在结构体上\")\n                throw Exception(\"不支持的类型\")\n        }\n        if (!findInterface(\"Serializable\", this.structDecl)) {\n            diagReport(DiagReportLevel.ERROR, input, \"结构体需要声明 Serializable 接口\", \"请检查结构体是否声明要实现 Serializable 接口\")\n            throw Exception(\"未声明 Serializable 接口\")\n        }\n        let visitor = StructDeclVisitor()\n        this.structDecl.traverse(visitor)\n        this.valDecls = visitor.varDecls.toArray()\n    }\n}", "llm_cg": {"Context": ["parseDecl", "diagReport", "Exception", "findInterface", "StructDeclVisitor", "this.structDecl.traverse", "visitor.varDecls.toArray"], "Context.init": []}, "static_cg": {}}
{"source_code": "package cj_easy_data\nimport cj_easy_data.pojo.*\nmain() :Unit{\n    let a= User()\n    println(a)\n}\n\n", "llm_cg": {"main": ["User", "<builtin>.println"]}, "static_cg": {}}
{"source_code": "macro package cj_easy_data.macros\n\nimport std.ast.*\nimport std.collection.*\n\npublic macro InitNone(input: Tokens):Tokens{\n    var clazz= getClassDecl(input)\n    return addDefaultNones(clazz).toTokens()\n}\n\n\nfunc addDefaultNones(classDecl: ClassDecl): ClassDecl {\n    classDecl.body.decls = classDecl.body.decls |> map(addDefaultNone) |> collectArrayList\n    return classDecl\n}\n//给加了问号的参数自动添加None\nfunc addDefaultNone(decl: Decl): Decl {\n    if (isFunc(decl.keyword)) {\n        return decl\n    }\n    match (decl) {\n        case m: MacroExpandDecl =>\n            let vd = (m.macroInputDecl as VarDecl).getOrThrow()\n            vd.expr = parseExpr(quote(None))\n            vd.assign = Token(ASSIGN, '=')\n        case v: VarDecl =>\n            v.expr = parseExpr(quote(None))\n            v.assign = Token(ASSIGN, '=')\n        case _ => decl\n    }\n    return decl\n}\n\n\n", "llm_cg": {"main": [], "InitNone": ["getClassDecl", "addDefaultNones", "ClassDecl.toTokens"], "addDefaultNones": ["map", "addDefaultNone", "collectArrayList"], "addDefaultNone": ["isFunc", "quote", "parseExpr", "Token", "quote", "parseExpr", "Token"]}, "static_cg": {}}
{"source_code": "macro package cj_easy_data.macros\n\nimport std.ast.*\nimport std.collection.*\n\nconst NO_TO_STRING = \"NoToString\"\n//加在类上\npublic macro ToStringClass(input: Tokens): Tokens {\n    var classDecl = getClassDecl(input)\n    return addToString(classDecl).toTokens()\n}\n//加在字段上,避免没有toString方法的类编译错误\npublic macro NoToString(input: Tokens): Tokens {\n    //当判断外部宏不存在Data或ToStringClass注解时会报错\n    if (!insideParentContext(\"Data\") && !insideParentContext(\"ToStringClass\")) {\n            throw MacroContextException (\"NoToString need Data or ToStringClass\")\n    }\n    let decl = VarDecl(input)\n    setItem(decl.identifier.value, true)\n    return input\n}\n\n//添加toString方法\nfunc addToString(clazz: ClassDecl): ClassDecl {\n    let types = clazz.superTypes\n    if (!isSuperToString(types)) {\n        if (clazz.upperBound.value != \"<:\") {\n            clazz.upperBound = Token(UPPERBOUND, \"<:\")\n        }\n        types.append(RefType(quote(ToString)))\n    }\n    if (isFuncToString(clazz)) {\n        return clazz\n    }\n    var sb = StringBuilder()\n    //接受内部宏NoToString消息\n    let msg = getChildMessages(NO_TO_STRING)\n    for (d in clazz.body.decls) {\n        if (isFunc(d.keyword)) {\n            continue;\n        }\n        var kind = match (d) {\n            case m: MacroExpandDecl =>\n                let vd = (m.macroInputDecl as VarDecl).getOrThrow()\n                Some(vd.identifier.value)\n            case v: VarDecl => Some(v.identifier.value)\n            case _ => None<String>\n        }\n\n        if (let Some(value) <- kind) {\n            let hasKey = msg |> any {m => m.hasItem(value)}\n            if (!hasKey) {\n                sb.append(\"${value}:\\${${value}},\")\n            }\n        }\n    }\n    let str = sb.toString().trimRight(\",\")\n    let funDecl = FuncDecl(quote(public func toString():String{\n        return $(str)\n    }))\n    clazz.body.decls.append(funDecl)\n    return clazz\n}\n\nfunc isFuncToString(clazz: ClassDecl): Bool {\n    return clazz.body.decls |> filter {d => isFunc(d.keyword)} |> any {\n        d => d.identifier.value == \"toString\"\n    }\n}\n\nfunc isSuperToString(superTypes: ArrayList<TypeNode>): Bool {\n    return superTypes |>\n        any {x: TypeNode => x is RefType && (x as RefType).getOrThrow().identifier.value.indexOf(\"ToString\") != None}\n}\n", "llm_cg": {"main": [], "ToStringClass": ["getClassDecl", "addToString", "ClassDecl.toTokens"], "NoToString": ["insideParentContext", "MacroContextException", "VarDecl", "setItem"], "addToString": ["ClassDecl.superTypes", "isSuperToString", "RefType", "quote", "isFuncToString", "StringBuilder", "getChildMessages", "isFunc", "MacroExpandDecl.macroInputDecl", "VarDecl.getOrThrow", "StringBuilder.append", "StringBuilder.toString", "String.trimRight", "FuncDecl", "quote", "str", "clazz.body.decls.append"], "isFuncToString": ["filter", "isFunc"], "isSuperToString": ["any", "RefType", "RefType.getOrThrow", "String.indexOf"]}, "static_cg": {}}
{"source_code": "macro package cj_easy_data.macros\n\nimport std.ast.*\nimport std.collection.*\n\n//支持一次添加ToString和默认None\npublic macro Data(input: Tokens): Tokens {\n    var classDecl =getClassDecl(input)\n    let handler = addToString ~> addDefaultNones\n    classDecl = handler(classDecl)\n    return classDecl.toTokens()\n}\n\nfunc isFunc(token: Token): Bool {\n    return token.kind==FUNC;\n}\nfunc getClassDecl(input: Tokens):ClassDecl{\n    let varDecl = parseDecl(input)\n   return (varDecl as ClassDecl).getOrThrow()\n}", "llm_cg": {"main": [], "Data": ["getClassDecl", "addToString", "addDefaultNones", "classDecl.toTokens"], "isFunc": [], "getClassDecl": ["parseDecl"]}, "static_cg": {}}
{"source_code": "package cj_easy_data.pojo\nimport cj_easy_data.macros.*\n@Data\npublic class User{\n    public var name:?String\n    @NoToString\n    public var age:?Int32\n    @NoToString\n    public var any:?Any\n}\n", "llm_cg": {}, "static_cg": {}}
{"source_code": "package cj_easy_data.pojo\nimport cj_easy_data.macros.Data\npublic class Role {\n    public var id: ?Int64=None\n    public var name: ?String=None\n}\n", "llm_cg": {"main": [], "Role": []}, "static_cg": {}}
{"source_code": "/*\n题目描述\n给你一个字符串数组 words 和一个字符 separator ，请你按 separator 拆分 words 中的每个字符串。\n返回一个由拆分后的新字符串组成的字符串数组，不包括空字符串 。\n- separator 用于决定拆分发生的位置，但它不包含在结果字符串中。\n- 拆分可能形成两个以上的字符串。\n- 结果字符串必须保持初始相同的先后顺序。\n\n仓颉语言团队 刘俊杰 2024.10.24\n*/\n\nimport std.collection.*\n\nfunc split(words: Array<String>, separator: Rune): Array<String> {\n    words |> map { text =>\n        text.split(String(separator), removeEmpty: true)\n    } |> flatten |> collectArray\n}\n\nmain() {\n    let words = [\"one.two.three\", \".four.five\", \"six.\", \"seven\"]\n    let separator = r'.'\n    let result = split(words, separator)\n    println(result)\n}", "llm_cg": {"main": ["split", "<builtin>.println"], "split": ["<builtin>.map", "<builtin>.text.split", "<builtin>.flatten", "<builtin>.collectArray"]}, "static_cg": {}}
{"source_code": "// 用分隔符拆分字符串，支持多分隔符\n// 仓颉语言团队 刘俊杰 2024.10.24\nimport std.collection.*\n\n// 处理 ASCII 字符串\n// 常规实现\nfunc split_ascii_normal(text: String, sep: String): ArrayList<String> {\n    let indices = ArrayList<Int64>()\n    var last = true\n    for (i in 0..text.size) {\n        let current = sep.indexOf(text[i]).isSome()\n        if (last != current) {\n            indices.append(i)\n        }\n        last = current\n    }\n    if (!last) { indices.append(text.size) }\n\n    let result = ArrayList<String>()\n    for (i in 0..indices.size:2) {\n        result.append(text[indices[i]..indices[i + 1]])\n    }\n    return result\n}\n\n// 函数式编程实现\nfunc split_ascii(text: String, sep: String): ArrayList<String> {\n    let indices = ArrayList<Int64>()\n    text |> enumerate |> fold(false) { state, e =>\n        let current = sep.indexOf(e[1]).isNone()\n        if (state != current) { indices.append(e[0]) }\n        current\n    } |> { valid: Bool => if (valid) {\n        indices.append(text.size)\n    }}\n\n    let result = ArrayList<String>()\n    for (i in 0..indices.size:2) {\n        result.append(text[indices[i]..indices[i + 1]])\n    }\n    return result\n}\n\n// 处理 Unicode 字符串\nfunc split_unicode(text: String, sep: String) {\n    let indices = ArrayList<Int64>()\n    text.runes() |> enumerate |> fold(false) { state, e =>\n        let current = !sep.contains(e[1].toString())\n        if (state != current) { indices.append(e[0]) }\n        current\n    } |> { valid: Bool => if (valid) { indices.append(text.size) } }\n\n    let runes = text.toRuneArray()\n    let result = ArrayList<String>()\n    for (i in 0..indices.size:2) {\n        result.append(String(runes[indices[i]..indices[i + 1]]))\n    }\n    return result\n}\n\nmain() {\n    let text = \"123, 456 7&89, , 96^3, 567\"\n    println(split_ascii(text, \"&^, \"))\n}\n", "llm_cg": {"main": ["split_ascii", "println"], "split_ascii_normal": ["ArrayList", "sep.indexOf", "indices.append", "ArrayList", "indices.size", "result.append"], "split_ascii": ["ArrayList", "enumerate", "fold", "sep.indexOf", "indices.append", "indices.append", "ArrayList", "indices.size", "result.append"], "split_unicode": ["ArrayList", "text.runes", "enumerate", "fold", "sep.contains", "indices.append", "indices.append", "text.toRuneArray", "ArrayList", "indices.size", "result.append"]}, "static_cg": {}}
{"source_code": "package glob\n\nimport std.unittest.*\nimport std.unittest.testmacro.*\n\n@Test\nclass PatternTests {\n    @TestCase\n    func testPatternFromStr() {\n        let p1 = Pattern(\"a*b\")\n        @Assert(p1.matches(\"a_b\"), true)\n\n        let e = @AssertThrows[PatternException]({\n            let _ = Pattern(\"a/**b\")\n        })\n        @Assert(e.pos, 4)\n    }\n\n    func assertInitException(pattern: String, pos: Int) {\n        let e = @AssertThrows[PatternException]({\n            let _ = Pattern(pattern)\n        })\n        @Assert(e.pos, pos)\n    }\n\n    @TestCase\n    func testWildcardErrors() {\n        assertInitException(\"a/**b\", 4)\n        assertInitException(\"a/bc**\", 3)\n        assertInitException(\"a/*****\", 4)\n        assertInitException(\"a/b**c**d\", 2)\n        assertInitException(\"a**b\", 0)\n    }\n\n    @TestCase\n    func testUnclosedBracketErrors() {\n        assertInitException(\"abc[def\", 3)\n        assertInitException(\"abc[!def\", 3)\n        assertInitException(\"abc[\", 3)\n        assertInitException(\"abc[!\", 3)\n        assertInitException(\"abc[d\", 3)\n        assertInitException(\"abc[!d\", 3)\n        assertInitException(\"abc[]\", 3)\n        assertInitException(\"abc[!]\", 3)\n    }\n\n    @TestCase\n    func testWildcards() {\n        let p1 = Pattern(\"a*b\")\n        @Assert(p1.matches(\"a_b\"), true)\n\n        let p2 = Pattern(\"a*b*c\")\n        @Assert(p2.matches(\"abc\"), true)\n        @Assert(p2.matches(\"abcd\"), false)\n        @Assert(p2.matches(\"a_b_c\"), true)\n        @Assert(p2.matches(\"a___b___c\"), true)\n\n        let p3 = Pattern(\"abc*abc*abc\")\n        @Assert(p3.matches(\"abcabcabcabcabcabcabc\"), true)\n        @Assert(p3.matches(\"abcabcabcabcabcabcabca\"), false)\n\n        let p4 = Pattern(\"a*a*a*a*a*a*a*a*a\")\n        @Assert(p4.matches(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"), true)\n\n        let p5 = Pattern(\"a*b[xyz]c*d\")\n        @Assert(p5.matches(\"abxcdbxcddd\"), true)\n    }\n\n    @TestCase\n    func testRecursiveWildcards() {\n        let pat = Pattern(\"some/**/needle.txt\")\n        @Assert(pat.matches(\"some/needle.txt\"), true)\n        @Assert(pat.matches(\"some/one/needle.txt\"), true)\n        @Assert(pat.matches(\"some/one/two/needle.txt\"), true)\n        @Assert(pat.matches(\"some/other/needle.txt\"), true)\n        @Assert(pat.matches(\"some/other/notthis.txt\"), false)\n\n        let pat2 = Pattern(\"**\")\n        @Assert(pat2.matches(\"abcde\"), true)\n        @Assert(pat2.matches(\"\"), true)\n        @Assert(pat2.matches(\".asdf\"), true)\n        @Assert(pat2.matches(\"/x/.asdf\"), true)\n\n        let pat3 = Pattern(\"some/**/**/needle.txt\")\n        @Assert(pat3.matches(\"some/needle.txt\"), true)\n        @Assert(pat3.matches(\"some/one/needle.txt\"), true)\n        @Assert(pat3.matches(\"some/one/two/needle.txt\"), true)\n        @Assert(pat3.matches(\"some/other/needle.txt\"), true)\n        @Assert(pat3.matches(\"some/other/notthis.txt\"), false)\n\n        let pat4 = Pattern(\"**/test\")\n        @Assert(pat4.matches(\"one/two/test\"), true)\n        @Assert(pat4.matches(\"one/test\"), true)\n        @Assert(pat4.matches(\"test\"), true)\n\n        let pat5 = Pattern(\"/**/test\")\n        @Assert(pat5.matches(\"/one/two/test\"), true)\n        @Assert(pat5.matches(\"/one/test\"), true)\n        @Assert(pat5.matches(\"/test\"), true)\n        @Assert(pat5.matches(\"/one/notthis\"), false)\n        @Assert(pat5.matches(\"/notthis\"), false)\n\n        let pat6 = Pattern(\"**/.*\")\n        @Assert(pat6.matches(\".abc\"), true)\n        @Assert(pat6.matches(\"abc/.abc\"), true)\n        @Assert(pat6.matches(\"ab.c\"), false)\n        @Assert(pat6.matches(\"abc/ab.c\"), false)\n    }\n\n    @TestCase\n    func testRangePattern() {\n        let pat = Pattern(\"a[0-9]b\")\n        for (i in 0..10) {\n            @Assert(pat.matches(\"a${i}b\"), true)\n        }\n        @Assert(pat.matches(\"a_b\"), false)\n\n        let pat2 = Pattern(\"a[!0-9]b\")\n        for (i in 0..10) {\n            @Assert(pat2.matches(\"a${i}b\"), false)\n        }\n        @Assert(pat2.matches(\"a_b\"), true)\n\n        let pats = [\"[a-z123]\", \"[1a-z23]\", \"[123a-z]\"]\n        for (p in pats) {\n            let pat = Pattern(p)\n            for (c in \"abcdefghijklmnopqrstuvwxyz\".toRuneArray()) {\n                @Assert(pat.matches(String(c)), true)\n            }\n            for (c in \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".toRuneArray()) {\n                var options = MatchOptions()\n                options.caseSensitive = false\n                @Assert(pat.matchesWith(String(c), options), true)\n            }\n            @Assert(pat.matches(\"1\"), true)\n            @Assert(pat.matches(\"2\"), true)\n            @Assert(pat.matches(\"3\"), true)\n        }\n\n        let pats2 = [\"[abc-]\", \"[-abc]\", \"[a-c-]\"]\n        for (p in pats2) {\n            let pat = Pattern(p)\n            @Assert(pat.matches(\"a\"), true)\n            @Assert(pat.matches(\"b\"), true)\n            @Assert(pat.matches(\"c\"), true)\n            @Assert(pat.matches(\"-\"), true)\n            @Assert(pat.matches(\"d\"), false)\n        }\n\n        let pat3 = Pattern(\"[2-1]\")\n        @Assert(pat3.matches(\"1\"), false)\n        @Assert(pat3.matches(\"2\"), false)\n\n        let pat4 = Pattern(\"[-]\")\n        @Assert(pat4.matches(\"-\"), true)\n        let pat5 = Pattern(\"[!-]\")\n        @Assert(pat5.matches(\"-\"), false)\n    }\n\n    @TestCase\n    func testPatternMatches() {\n        let txtPat = Pattern(\"*hello.txt\")\n        @Assert(txtPat.matches(\"hello.txt\"), true)\n        @Assert(txtPat.matches(\"gareth_says_hello.txt\"), true)\n        @Assert(txtPat.matches(\"some/path/to/hello.txt\"), true)\n        @Assert(txtPat.matches(\"some\\\\path\\\\to\\\\hello.txt\"), true)\n        @Assert(txtPat.matches(\"/an/absolute/path/to/hello.txt\"), true)\n        @Assert(txtPat.matches(\"hello.txt-and-then-some\"), false)\n        @Assert(txtPat.matches(\"goodbye.txt\"), false)\n\n        let dirPat = Pattern(\"*some/path/to/hello.txt\")\n        @Assert(dirPat.matches(\"some/path/to/hello.txt\"), true)\n        @Assert(dirPat.matches(\"a/bigger/some/path/to/hello.txt\"), true)\n        @Assert(dirPat.matches(\"some/path/to/hello.txt-and-then-some\"), false)\n        @Assert(dirPat.matches(\"some/other/path/to/hello.txt\"), false)\n    }\n\n    @TestCase\n    func testPatternMatchesWith() {\n        let pat = Pattern(\"aBcDeFg\")\n        var options = MatchOptions()\n        options.caseSensitive = false\n        @Assert(pat.matchesWith(\"aBcDeFg\", options), true)\n        @Assert(pat.matchesWith(\"abcdefg\", options), true)\n        @Assert(pat.matchesWith(\"ABCDEFG\", options), true)\n        @Assert(pat.matchesWith(\"AbCdEfG\", options), true)\n    }\n\n    @TestCase\n    func testPatternMatchesWithLiteralSeparator() {\n        let pat = Pattern(\"a/b/c\")\n        var options = MatchOptions()\n        options.requireLiteralSeparator = true\n        @Assert(pat.matchesWith(\"a/b/c\", options), true)\n        @Assert(pat.matchesWith(\"a/b/c/d\", options), false)\n        @Assert(pat.matchesWith(\"a/b/cd\", options), false)\n        @Assert(pat.matchesWith(\"a/b/c/\", options), false)\n        @Assert(pat.matchesWith(\"a/b/c//\", options), false)\n        @Assert(pat.matchesWith(\"a/b/c//d\", options), false)\n    }\n\n    @TestCase\n    func testPatternMatchesRequireLiteralSeparator() {\n        var optionsRequireLiteral = MatchOptions()\n        optionsRequireLiteral.caseSensitive = true\n        optionsRequireLiteral.requireLiteralSeparator = true\n        optionsRequireLiteral.requireLiteralLeadingDot = false\n\n        var optionsNotRequireLiteral = MatchOptions()\n        optionsNotRequireLiteral.caseSensitive = true\n        optionsNotRequireLiteral.requireLiteralSeparator = false\n        optionsNotRequireLiteral.requireLiteralLeadingDot = false\n\n        @Assert(Pattern(\"abc/def\").matchesWith(\"abc/def\", optionsRequireLiteral), true)\n        @Assert(Pattern(\"abc?def\").matchesWith(\"abc/def\", optionsRequireLiteral), false)\n        @Assert(Pattern(\"abc*def\").matchesWith(\"abc/def\", optionsRequireLiteral), false)\n        @Assert(Pattern(\"abc[/]def\").matchesWith(\"abc/def\", optionsRequireLiteral), false)\n\n        @Assert(Pattern(\"abc/def\").matchesWith(\"abc/def\", optionsNotRequireLiteral), true)\n        @Assert(Pattern(\"abc?def\").matchesWith(\"abc/def\", optionsNotRequireLiteral), true)\n        @Assert(Pattern(\"abc*def\").matchesWith(\"abc/def\", optionsNotRequireLiteral), true)\n        @Assert(Pattern(\"abc[/]def\").matchesWith(\"abc/def\", optionsNotRequireLiteral), true)\n    }\n\n    @TestCase\n    func testPatternMatchesWithLiteralLeadingDot() {\n        var optionsRequireLiteralLeadingDot = MatchOptions()\n        optionsRequireLiteralLeadingDot.caseSensitive = true\n        optionsRequireLiteralLeadingDot.requireLiteralSeparator = false\n        optionsRequireLiteralLeadingDot.requireLiteralLeadingDot = true\n\n        var optionsNotRequireLiteralLeadingDot = MatchOptions()\n        optionsNotRequireLiteralLeadingDot.caseSensitive = true\n        optionsNotRequireLiteralLeadingDot.requireLiteralSeparator = false\n        optionsNotRequireLiteralLeadingDot.requireLiteralLeadingDot = false\n\n        @Assert(Pattern(\"*.txt\").matchesWith(\".hello.txt\", optionsNotRequireLiteralLeadingDot), true)\n        @Assert(Pattern(\"*.txt\").matchesWith(\".hello.txt\", optionsRequireLiteralLeadingDot), false)\n\n        @Assert(Pattern(\".*.*\").matchesWith(\".hello.txt\", optionsNotRequireLiteralLeadingDot), true)\n        @Assert(Pattern(\".*.*\").matchesWith(\".hello.txt\", optionsRequireLiteralLeadingDot), true)\n\n        @Assert(Pattern(\"aaa/bbb/*\").matchesWith(\"aaa/bbb/.ccc\", optionsNotRequireLiteralLeadingDot), true)\n        @Assert(Pattern(\"aaa/bbb/*\").matchesWith(\"aaa/bbb/.ccc\", optionsRequireLiteralLeadingDot), false)\n\n        @Assert(Pattern(\"aaa/bbb/*\").matchesWith(\"aaa/bbb/c.c.c.\", optionsNotRequireLiteralLeadingDot), true)\n        @Assert(Pattern(\"aaa/bbb/*\").matchesWith(\"aaa/bbb/c.c.c.\", optionsRequireLiteralLeadingDot), true)\n\n        @Assert(Pattern(\"aaa/bbb/.*\").matchesWith(\"aaa/bbb/.ccc\", optionsNotRequireLiteralLeadingDot), true)\n        @Assert(Pattern(\"aaa/bbb/.*\").matchesWith(\"aaa/bbb/.ccc\", optionsRequireLiteralLeadingDot), true)\n\n        @Assert(Pattern(\"aaa/?bbb\").matchesWith(\"aaa/.bbb\", optionsNotRequireLiteralLeadingDot), true)\n        @Assert(Pattern(\"aaa/?bbb\").matchesWith(\"aaa/.bbb\", optionsRequireLiteralLeadingDot), false)\n\n        @Assert(Pattern(\"aaa/[.]bbb\").matchesWith(\"aaa/.bbb\", optionsNotRequireLiteralLeadingDot), true)\n        @Assert(Pattern(\"aaa/[.]bbb\").matchesWith(\"aaa/.bbb\", optionsRequireLiteralLeadingDot), false)\n\n        @Assert(Pattern(\"**/*\").matchesWith(\".bbb\", optionsNotRequireLiteralLeadingDot), true)\n        @Assert(Pattern(\"**/*\").matchesWith(\".bbb\", optionsRequireLiteralLeadingDot), false)\n    }\n\n    @TestCase\n    func testGlob() {\n        let g1 = glob(\"/\")\n        @Assert(g1.next().isSome(), true)\n\n        let g2 = glob(\"src/*\")\n        @Assert(g2.next().isSome(), true)\n    }\n}\n", "llm_cg": {"main": [], "PatternTests": ["PatternTests.testPatternFromStr", "PatternTests.assertInitException", "PatternTests.testWildcardErrors", "PatternTests.testUnclosedBracketErrors", "PatternTests.testWildcards", "PatternTests.testRecursiveWildcards", "PatternTests.testRangePattern", "PatternTests.testPatternMatches", "PatternTests.testPatternMatchesWith", "PatternTests.testPatternMatchesWithLiteralSeparator", "PatternTests.testPatternMatchesRequireLiteralSeparator", "PatternTests.testPatternMatchesWithLiteralLeadingDot", "PatternTests.testGlob"], "PatternTests.testPatternFromStr": ["Pattern", "Pattern.matches", "PatternException"], "PatternTests.assertInitException": ["Pattern", "PatternException"], "PatternTests.testWildcardErrors": ["PatternTests.assertInitException"], "PatternTests.testUnclosedBracketErrors": ["PatternTests.assertInitException"], "PatternTests.testWildcards": ["Pattern", "Pattern.matches"], "PatternTests.testRecursiveWildcards": ["Pattern", "Pattern.matches"], "PatternTests.testRangePattern": ["Pattern", "Pattern.matches", "Pattern.matchesWith", "MatchOptions", "<builtin>.String", "String.toRuneArray"], "PatternTests.testPatternMatches": ["Pattern", "Pattern.matches"], "PatternTests.testPatternMatchesWith": ["Pattern", "Pattern.matchesWith", "MatchOptions"], "PatternTests.testPatternMatchesWithLiteralSeparator": ["Pattern", "Pattern.matchesWith", "MatchOptions"], "PatternTests.testPatternMatchesRequireLiteralSeparator": ["Pattern", "Pattern.matchesWith", "MatchOptions"], "PatternTests.testPatternMatchesWithLiteralLeadingDot": ["Pattern", "Pattern.matchesWith", "MatchOptions"], "PatternTests.testGlob": ["glob", "glob.next", "glob.next.isSome"]}, "static_cg": {}}
{"source_code": "package glob\n\nimport std.regex.Regex\nimport std.collection.ArrayList\nimport std.fs.{Directory, Path, FileInfo, FSException}\nimport std.deriving.Derive\n\n// cjlint-ignore -start !G.OPR.01 !G.NAM.04 !G.ITF.04 macro\n@Derive[Equatable]\nenum CharSpecifier {\n    SingleChar(Rune)\n    | CharRange(Rune, Rune)\n}\n\n@Derive[Equatable]\nenum PatternToken {\n    Char(Rune)\n    | AnyChar\n    | AnySequence\n    | AnyRecursiveSequence\n    | AnyWithin(Array<CharSpecifier>)\n    | AnyExcept(Array<CharSpecifier>)\n}\n\npublic struct MatchOptions {\n    /**\n     * 是否以大小写敏感的方式匹配模式。\n     * 目前只考虑 ASCII 字符之间的大/小写关系，\n     * 但将来可能会扩展到适用于 Unicode。\n     */\n    public var caseSensitive: Bool = false\n\n    /**\n     * 是否要求路径分隔符字符（例如 Posix 上的 `/`）必须由字面量 `/` 匹配，\n     * 而不是由 `*` 或 `?` 或 `[...]` 匹配。\n     */\n    public var requireLiteralSeparator: Bool = false\n\n    /**\n     * 是否要求路径组件的开头是 `.` 字符，必须由字面量 `.` 匹配，\n     * 而不是由 `*` 或 `?` 或 `**` 或 `[...]` 匹配。\n     * 这对于 Unix 系统上被传统认为是隐藏的文件很有用，\n     * 可能希望在列出文件时跳过它们。\n     */\n    public var requireLiteralLeadingDot: Bool = false\n}\n\n@Derive[Equatable]\npublic enum MatchResult {\n    Match\n    | SubPatternDoesntMatch\n    | EntirePatternDoesntMatch\n}\n\n// cjlint-ignore -end macro\n\nconst ERROR_WILDCARDS = \"wildcards are either regular `*` or recursive `**`\";\nconst ERROR_RECURSIVE_WILDCARDS = \"recursive wildcards must form a single path component\";\nconst ERROR_INVALID_RANGE = \"invalid range pattern\";\n\npublic class PatternException <: Exception {\n    public let pos: Int\n\n    public init(pos: Int, message: String) {\n        super(message)\n        this.pos = pos\n    }\n\n    public override func getClassName(): String {\n        \"PatternException\"\n    }\n}\n\nfunc isSeparator(c: Rune): Bool {\n    return c.isAscii() && (c == r'/' || c == r'\\\\')\n}\n\nfunc parseCharSpecifiers(s: Array<Rune>): Array<CharSpecifier> {\n    let ret = ArrayList<CharSpecifier>()\n    var i = 0\n    while (i < s.size) {\n        if (i + 3 <= s.size && s[i + 1] == r'-') {\n            ret.append(CharSpecifier.CharRange(s[i], s[i + 2]))\n            i += 3\n        } else {\n            ret.append(CharSpecifier.SingleChar(s[i]))\n            i += 1\n        }\n    }\n    return ret.toArray()\n}\n\npublic class CharsIterator <: Iterator<Rune> {\n    let chars: Array<Rune>\n    var i: Int\n\n    init(c: Array<Rune>, i!: Int = 0) {\n        this.chars = c\n        this.i = i\n    }\n\n    public func clone(): CharsIterator {\n        return CharsIterator(this.chars, i: this.i)\n    }\n\n    public func next(): Option<Rune> {\n        if (this.i < this.chars.size) {\n            let c = this.chars[this.i]\n            this.i++\n            return Some(c)\n        } else {\n            return None\n        }\n    }\n}\n\nfunc charsEq(a: Rune, b: Rune, caseSensitive: Bool): Bool {\n    if (!caseSensitive && a.isAscii() && b.isAscii()) {\n        a.toAsciiLowerCase() == b.toAsciiLowerCase()\n    } else {\n        a == b\n    }\n}\n\n// cjlint-ignore -start !G.FUN.01 fun\nfunc inCharSpecifiers(cs: Array<CharSpecifier>, c: Rune, options: MatchOptions): Bool {\n    for (spec in cs) {\n        match (spec) {\n            case CharSpecifier.SingleChar(cs) =>\n                if (charsEq(c, cs, options.caseSensitive)) {\n                    return true\n                } else {\n                    continue\n                }\n\n            case CharSpecifier.CharRange(start, end) =>\n                if (!options.caseSensitive && c.isAscii() && start.isAscii() && end.isAscii()) {\n                    let sl = start.toAsciiLowerCase()\n                    let el = end.toAsciiLowerCase()\n\n                    let su = sl.toAsciiUpperCase()\n                    let eu = el.toAsciiUpperCase()\n\n                    if (sl != su && el != eu) {\n                        let cl = c.toAsciiLowerCase()\n                        if (cl >= sl && cl <= el) {\n                            return true;\n                        }\n                    }\n                }\n\n                if (c >= start && c <= end) {\n                    return true\n                }\n        }\n    }\n\n    return false\n}\n\npublic struct Pattern {\n    let original: String\n    let tokens: ArrayList<PatternToken>\n    let isRecursive: Bool\n\n    init(pattern: String) {\n        let chars = pattern.toRuneArray()\n        let tokens = ArrayList<PatternToken>()\n        var is_recursive = false\n        var i = 0\n\n        while (i < chars.size) {\n            match (chars[i]) {\n                case r'?' =>\n                    tokens.append(PatternToken.AnyChar)\n                    i++\n                case r'*' =>\n                    let old = i\n\n                    while (i < chars.size && chars[i] == r'*') {\n                        i++\n                    }\n\n                    let count = i - old\n\n                    if (count > 2) {\n                        throw PatternException(old + 2, ERROR_WILDCARDS)\n                    } else if (count == 2) {\n                        let is_valid = if (i == 2 || isSeparator(chars[i - count - 1])) {\n                            if (i < chars.size && isSeparator(chars[i])) {\n                                i++\n                                true\n                            } else if (i == chars.size) {\n                                true\n                            } else {\n                                throw PatternException(i, ERROR_RECURSIVE_WILDCARDS)\n                            }\n                        } else {\n                            throw PatternException(old - 1, ERROR_RECURSIVE_WILDCARDS)\n                        }\n\n                        if (is_valid) {\n                            let tokens_len = tokens.size\n\n                            if (!(tokens_len > 1 && tokens.get(tokens_len - 1) == PatternToken.AnyRecursiveSequence)) {\n                                is_recursive = true\n                                tokens.append(PatternToken.AnyRecursiveSequence)\n                            }\n                        }\n                    } else {\n                        tokens.append(PatternToken.AnySequence)\n                    }\n                case r'[' =>\n                    if (i + 4 <= chars.size && chars[i + 1] == r'!') {\n                        match (chars[i + 3..].indexOf(r']')) {\n                            case None => ()\n                            case Some(j) =>\n                                let subChars = chars[i + 2..i + 3 + j]\n                                let cs = parseCharSpecifiers(subChars)\n                                tokens.append(PatternToken.AnyExcept(cs))\n                                i += 4 + j\n                                continue\n                        }\n                    } else if (i + 3 <= chars.size && chars[i + 1] != r'!') {\n                        match (chars[i + 2..].indexOf(r']')) {\n                            case None => ()\n                            case Some(j) =>\n                                let subChars = chars[i + 1..i + 2 + j]\n                                let cs = parseCharSpecifiers(subChars)\n                                tokens.append(PatternToken.AnyWithin(cs))\n                                i += 3 + j\n                                continue\n                        }\n                    }\n\n                    throw PatternException(i, ERROR_INVALID_RANGE)\n                case c =>\n                    tokens.append(PatternToken.Char(c))\n                    i++\n            }\n        }\n\n        this.original = pattern\n        this.tokens = tokens\n        this.isRecursive = is_recursive\n    }\n\n    public func matches(str: String): Bool {\n        this.matchesWith(str, MatchOptions())\n    }\n\n    public func matchesWith(\n        str: String,\n        options: MatchOptions\n    ): Bool {\n        this.matchesFrom(true, CharsIterator(str.toRuneArray()), 0, options) == MatchResult.Match\n    }\n\n    public func matchesFrom(\n        followsSeparator: Bool,\n        file: CharsIterator,\n        i: Int,\n        options: MatchOptions\n    ): MatchResult {\n        var fs = followsSeparator\n        for ((ti, token) in this.tokens[i..].iterator().enumerate()) {\n            match (token) {\n                case AnySequence | AnyRecursiveSequence =>\n                    match (this.matchesFrom(fs, file.clone(), i + ti + 1, options)) {\n                        case MatchResult.SubPatternDoesntMatch => ()\n                        case m => return m\n                    }\n\n                    while (let Some(c) <- file.next()) {\n                        if (fs && options.requireLiteralLeadingDot && c == r'.') {\n                            return MatchResult.SubPatternDoesntMatch\n                        }\n                        fs = isSeparator(c)\n                        match (token) {\n                            case PatternToken.AnyRecursiveSequence =>\n                                if (!fs) {\n                                    continue\n                                }\n                            case PatternToken.AnySequence =>\n                                if (options.requireLiteralSeparator && fs) {\n                                    return MatchResult.SubPatternDoesntMatch\n                                }\n                            case _ => ()\n                        }\n\n                        match (this.matchesFrom(fs, file.clone(), i + ti + 1, options)) {\n                            case MatchResult.SubPatternDoesntMatch => ()\n                            case m => return m\n                        }\n                    }\n                case _ =>\n                    let c = match (file.next()) {\n                        case Some(c) => c\n                        case None => return MatchResult.EntirePatternDoesntMatch\n                    }\n\n                    let is_sep = isSeparator(c)\n\n                    if (!match (token) {\n                        case PatternToken.AnyChar | PatternToken.AnyWithin(_) | AnyExcept(_) =>\n                            if ((options.requireLiteralSeparator && is_sep) || (fs && options.requireLiteralLeadingDot &&\n                                c == r'.')) {\n                                false\n                            } else {\n                                true\n                            }\n                        case _ => true\n                    }) {\n                        return MatchResult.SubPatternDoesntMatch\n                    }\n\n                    if (!match (token) {\n                        case PatternToken.AnyChar => true\n                        case PatternToken.AnyWithin(cs) => inCharSpecifiers(cs, c, options)\n                        case PatternToken.AnyExcept(cs) => !inCharSpecifiers(cs, c, options)\n                        case PatternToken.Char(tc) => charsEq(c, tc, options.caseSensitive)\n                        case _ => throw Exception(\"unreachable\")\n                    }) {\n                        return MatchResult.SubPatternDoesntMatch\n                    }\n                    fs = is_sep\n            }\n        }\n\n        if (file.next().isNone()) {\n            return MatchResult.Match\n        } else {\n            return MatchResult.SubPatternDoesntMatch\n        }\n    }\n\n    func toCharString(): Option<String> {\n        let ret = StringBuilder()\n        for (token in this.tokens) {\n            match (token) {\n                case Char(c) => ret.append(c)\n                case _ => return None\n            }\n        }\n        return ret.toString()\n    }\n}\n\nfunc checkWindowsVerbatim(path: String): Bool {\n    if (path.size < 4) {\n        return false\n    }\n    let chars = path.toRuneArray()\n\n    let c0 = chars[0]\n    let c1 = chars[1]\n    let c2 = chars[2]\n    let c3 = chars[3]\n\n    // \\\\.\\\n    if (c0 == r'\\\\' && c1 == r'\\\\' && c2 == r'.' && c3 == r'\\\\') {\n        return true\n    }\n    // \\\\?\\\n    if (c0 == r'\\\\' && c1 == r'\\\\' && c2 == r'?' && c3 == r'\\\\') {\n        return true\n    }\n\n    return false\n}\n\npublic struct PathWrapper {\n    public let path: Path\n    let isDirectory: Bool\n\n    init(path: Path) {\n        this.path = path\n        this.isDirectory = FileInfo(path).isDirectory()\n    }\n\n    init(path: Path, isDirectory: Bool) {\n        this.path = path\n        this.isDirectory = isDirectory\n    }\n}\n\nfunc fillTodo(\n    todo: ArrayList<(PathWrapper, Int64)>,\n    patterns: Array<Pattern>,\n    idx: Int,\n    path: PathWrapper,\n    options: MatchOptions\n): Unit {\n    let pattern = patterns[idx]\n    let isDir = path.isDirectory\n    let curDir = path.path.toString() == \".\"\n\n    let add = {\n        todo: ArrayList<(PathWrapper, Int64)>, nextPath: PathWrapper => if (idx + 1 == patterns.size) {\n            todo.append((nextPath, Int64.Max))\n        } else {\n            fillTodo(todo, patterns, idx + 1, nextPath, options)\n        }\n    }\n\n    match (pattern.toCharString()) {\n        case Some(s) =>\n            let special = s == \".\" || s == \"..\"\n            let nextPath = if (curDir) {\n                Path(s)\n            } else {\n                path.path.join(s)\n            }\n            let nextPathWrapper: PathWrapper\n            try {\n                nextPathWrapper = PathWrapper(nextPath)\n            } catch (e: FSException) {\n                return\n            }\n            if ((special && isDir) || !special) {\n                add(todo, nextPathWrapper)\n            }\n        case None =>\n            if (isDir) {\n                let dirFiles = Directory.readFrom(path.path)\n                let dirs = ArrayList<PathWrapper>()\n                for (e in dirFiles) {\n                    if (curDir) {\n                        dirs.append(PathWrapper(Path(e.path.fileName), e.isDirectory()))\n                    } else {\n                        dirs.append(PathWrapper(e.path, e.isDirectory()))\n                    }\n                }\n                var children = dirs.iterator()\n                if (options.requireLiteralLeadingDot) {\n                    children = children.filter {\n                        c => !(c.path.fileName.startsWith(\".\"))\n                    }\n                }\n                let cc = ArrayList<PathWrapper>()\n                for (c in children) {\n                    cc.append(c)\n                }\n                cc.sortBy {\n                    l: PathWrapper, r: PathWrapper => if (l.path.fileName > r.path.fileName) {\n                        Ordering.GT\n                    } else if (l.path.fileName < r.path.fileName) {\n                        Ordering.LT\n                    } else {\n                        Ordering.EQ\n                    }\n                }\n\n                for (c in cc) {\n                    todo.append((c, idx))\n                }\n\n                if (!pattern.tokens.isEmpty() && pattern.tokens[0] == PatternToken.Char(r'.')) {\n                    for (sp in [\".\", \"..\"]) {\n                        if (pattern.matchesWith(sp, options)) {\n                            add(todo, PathWrapper(path.path.join(sp)))\n                        }\n                    }\n                }\n            }\n    }\n}\n\npublic class Paths <: Iterator<Path> {\n    let dirPatterns: Array<Pattern>\n    let requireDir: Bool\n    let options: MatchOptions\n    let todo: ArrayList<(PathWrapper, Int64)>\n    let scope: PathWrapper\n    var initialized: Bool = false\n\n    init(\n        dirPatterns: Array<Pattern>,\n        requireDir: Bool,\n        options: MatchOptions,\n        todo: ArrayList<(PathWrapper, Int64)>,\n        scope: PathWrapper\n    ) {\n        this.dirPatterns = dirPatterns\n        this.requireDir = requireDir\n        this.options = options\n        this.todo = todo\n        this.scope = scope\n    }\n\n    public func next(): Option<Path> {\n        if (!this.initialized) {\n            this.initialized = true\n            if (!this.dirPatterns.isEmpty()) {\n                fillTodo(this.todo, this.dirPatterns, 0, this.scope, this.options)\n            }\n        }\n        while (true) {\n            if (this.dirPatterns.isEmpty() || this.todo.isEmpty()) {\n                return None\n            }\n\n            let t = this.todo.remove(this.todo.size - 1)\n            let path = t[0]\n            var idx = t[1]\n\n            if (idx == Int64.Max) {\n                if (this.requireDir && !path.isDirectory) {\n                    continue\n                }\n                return Some(path.path)\n            }\n\n            if (this.dirPatterns[idx].isRecursive) {\n                var next = idx\n                while (next + 1 < this.dirPatterns.size && this.dirPatterns[next + 1].isRecursive) {\n                    next++\n                }\n\n                if (path.isDirectory) {\n                    fillTodo(\n                        this.todo,\n                        this.dirPatterns,\n                        next,\n                        path,\n                        this.options\n                    )\n\n                    if (next == this.dirPatterns.size - 1) {\n                        return Some(path.path)\n                    } else {\n                        idx = next + 1\n                    }\n                } else if (next == this.dirPatterns.size - 1) {\n                    continue\n                } else {\n                    idx = next + 1\n                }\n            }\n\n            if (this.dirPatterns[idx].matchesWith(path.path.fileName, this.options)) {\n                if (idx == this.dirPatterns.size - 1) {\n                    if (!this.requireDir || path.isDirectory) {\n                        return Some(path.path)\n                    }\n                } else {\n                    fillTodo(\n                        this.todo,\n                        this.dirPatterns,\n                        idx + 1,\n                        path,\n                        this.options\n                    )\n                }\n            }\n        }\n\n        None\n    }\n}\n\nfunc getRoot(pattern: String): Option<String> {\n    let chars = pattern.toRuneArray()\n\n    if (chars.size == 0) {\n        return \"\"\n    }\n\n    if (chars[0] == r'/') {\n        return \"/\"\n    }\n\n    if (chars.size >= 2) {\n        if (chars[0].isAsciiLetter() && chars[1] == r':') {\n            return pattern[0..2] + \"\\\\\"\n        }\n    }\n\n    None\n}\n\nextend String {\n    func split(checker: (Rune) -> Bool): Array<String> {\n        let chars = this.toRuneArray()\n        let ret = ArrayList<String>()\n        var start = 0\n        var i = 0\n\n        while (i < chars.size) {\n            if (checker(chars[i])) {\n                if (start < i) {\n                    ret.append(this[start..i])\n                }\n                start = i + 1\n            }\n            i++\n        }\n\n        if (start < i) {\n            ret.append(this[start..i])\n        }\n\n        return ret.toArray()\n    }\n}\n\n/** 返回一个迭代器，使用默认匹配选项生成与给定模式匹配的所有 Path。 \n * 这些路径可以是绝对路径，也可以是相对于当前工作目录的相对路径。\n *\n * 如果模式无效，则可能会引发 PatternException。\n */\npublic func glob(pattern: String): Paths {\n    globWith(pattern, MatchOptions())\n}\n\n/** 返回一个迭代器，使用给定的匹配选项生成与给定模式匹配的所有 Path。 \n * 这些路径可以是绝对路径，也可以是相对于当前工作目录的相对路径。\n * 此函数允许您指定匹配选项，例如大小写敏感性。\n *\n * 如果模式无效，则可能会引发 PatternException。\n */\npublic func globWith(pattern: String, options: MatchOptions): Paths {\n    let _ = Pattern(pattern)\n\n    if (checkWindowsVerbatim(pattern)) {\n        throw PatternException(0, \"verbatim paths are not supported\")\n    }\n\n    var root: String\n    var foundRoot = false\n\n    match (getRoot(pattern)) {\n        case Some(r) =>\n            root = r\n            foundRoot = true\n        case None =>\n            root = \".\"\n            foundRoot = false\n    }\n\n    let dirPatterns = ArrayList<Pattern>()\n    let skip = if (foundRoot) {\n        root.size\n    } else {\n        0\n    }\n    let components = pattern[(min(skip, pattern.size))..].split(isSeparator)\n    for (c in components) {\n        dirPatterns.append(Pattern(c))\n    }\n\n    if (foundRoot && root.size == pattern.size) {\n        dirPatterns.append(Pattern(\"\"))\n    }\n\n    let lastIsSeparator = if (pattern.size > 0) {\n        let ra = pattern.toRuneArray()\n        isSeparator(ra[ra.size - 1])\n    } else {\n        false\n    }\n\n    return Paths(\n        dirPatterns.toArray(),\n        lastIsSeparator,\n        options,\n        ArrayList<(PathWrapper, Int64)>(),\n        PathWrapper(Path(root))\n    )\n}\n\n// cjlint-ignore -end fun\n", "llm_cg": {"main": [], "PatternException": [], "PatternException.init": [], "PatternException.getClassName": [], "isSeparator": ["Rune.isAscii"], "parseCharSpecifiers": ["ArrayList.append", "ArrayList.toArray"], "CharsIterator": [], "CharsIterator.init": [], "CharsIterator.clone": ["CharsIterator"], "CharsIterator.next": ["Array.size", "Array.get", "Some", "None"], "charsEq": ["Rune.isAscii", "Rune.toAsciiLowerCase", "Rune.toAsciiLowerCase", "Rune.toAsciiLowerCase"], "inCharSpecifiers": ["charsEq", "Rune.isAscii"], "Pattern": [], "Pattern.init": ["Pattern.toRuneArray", "ArrayList.append", "isSeparator", "PatternException", "PatternException", "ArrayList.size", "ArrayList.get", "isSeparator", "PatternException", "PatternException", "PatternException", "PatternException", "PatternException"], "Pattern.matches": ["Pattern.matchesWith"], "Pattern.matchesWith": ["CharsIterator", "Pattern.matchesFrom"], "Pattern.matchesFrom": ["ArrayList.iterator", "ArrayList.enumerate", "CharsIterator.clone", "Pattern.matchesFrom", "CharsIterator.next", "isSeparator", "Pattern.matchesFrom", "CharsIterator.next", "isSeparator", "Pattern.matchesFrom", "Pattern.matchesFrom", "Pattern.matchesFrom", "inCharSpecifiers", "inCharSpecifiers", "charsEq", "Exception", "CharsIterator.next", "MatchResult.Match", "MatchResult.SubPatternDoesntMatch"], "Pattern.toCharString": ["StringBuilder.append", "StringBuilder.toString"], "checkWindowsVerbatim": ["String.size", "Array.get"], "PathWrapper": [], "PathWrapper.init": [], "fillTodo": ["ArrayList.append", "ArrayList.size", "PathWrapper.path", "Pattern.toCharString", "PathWrapper.toString", "Path", "Path.join", "PathWrapper", "ArrayList.append", "fillTodo", "fillTodo", "Directory.readFrom", "ArrayList.append", "ArrayList.iterator", "Option.get", "PathWrapper", "ArrayList.sortBy", "Ordering.GT", "Ordering.LT", "Ordering.EQ", "ArrayList.append", "PatternToken.Char"], "Paths": [], "Paths.init": [], "Paths.next": ["fillTodo", "ArrayList.isEmpty", "PathWrapper.isDirectory", "Paths.fillTodo", "Paths.fillTodo", "Paths.fillTodo", "Int64.Max", "Paths.fillTodo", "Pattern.matchesWith", "Paths.fillTodo", "Option.get", "Int64.Max"], "getRoot": ["String.size", "Array.get", "Rune.isAsciiLetter", "Pattern.get"], "String.split": ["toRuneArray", "ArrayList.append", "Ordering.GT", "Ordering.EQ", "ArrayList.toArray"], "glob": ["globWith"], "globWith": ["Pattern", "checkWindowsVerbatim", "PatternException", "getRoot", "ArrayList.append", "Paths"]}, "static_cg": {}}
{"source_code": "package cangjieWeb\nimport serialization.serialization.*\nimport encoding.json.*\nimport std.database.sql.{DriverManager, SqlDbType, SqlBigInt, SqlInteger, SqlVarchar}\nimport cangjieWeb.mysql.MySqlDatasource\nimport std.collection.{ArrayList}\nmain() {\n    let connectionString = \"root:12345678@tcp(10.200.1.164:3306)/admin-api\"\n    let opts = [\n        (\"cachePrepStmts\", \"true\")\n    ]\n    let drv = DriverManager.getDriver(\"mysql\") ?? return\n    let ds = drv.open(connectionString, opts)\n    let connection = ds.connect()\n\n    let deleteTable = \"\"\"\n        drop table if exists `sys_dept`;\n    \"\"\"\n    let deleteTableStatement = connection.prepareStatement(deleteTable)\n    let deleteTableParams = ArrayList<SqlDbType>()\n    let deleteTableResult = deleteTableStatement.update(deleteTableParams.toArray())\n    println(\"delete table sys_dept if exists success\")\n        \n\n    let createTable = \"\"\"\n        CREATE TABLE `sys_dept` (\n            `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',\n            `parent_id` int NOT NULL COMMENT '父id',\n            `dept_type` int NOT NULL COMMENT '部门类型（1->公司, 2->中心，3->部门）',\n            `dept_name` varchar(30) CHARACTER SET utf8mb3 COLLATE utf8mb3_bin NOT NULL COMMENT '部门名称',\n            `dept_status` int NOT NULL DEFAULT '1' COMMENT '部门状态（1->正常 2->停用）',\n            PRIMARY KEY (`id`) USING BTREE,\n            UNIQUE KEY `dept_name` (`dept_name`) USING BTREE\n        ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb3 COLLATE=utf8mb3_bin ROW_FORMAT=DYNAMIC COMMENT='部门表';\"\"\"\n\n    let createTableStatement = connection.prepareStatement(createTable)\n    let createTableParams= ArrayList<SqlDbType>()\n    let createTableResult = createTableStatement.update(createTableParams.toArray())\n    println(\"create table sys_dept success\")\n\n    // INSERT INTO `admin-api`.sys_dept(id, parent_id, dept_type, dept_name, dept_status) VALUES(1, 0, 1, 'develop1', 1);\n    let insertTableStatement = connection.prepareStatement(\"INSERT INTO sys_dept(parent_id, dept_type, dept_name, dept_status) VALUES(?,?,?,?);\")\n    var companyUpdateResult = insertTableStatement.update(SqlInteger(0), SqlInteger(1), SqlVarchar(\"cangjie company\"), SqlInteger(1))\n    var heNanUpdateResult = insertTableStatement.update(SqlInteger(Int32(companyUpdateResult.lastInsertId)), SqlInteger(2), SqlVarchar(\"henan center\"), SqlInteger(1))\n    var zheJiangUpdateResult = insertTableStatement.update(SqlInteger(Int32(companyUpdateResult.lastInsertId)), SqlInteger(2), SqlVarchar(\"zhejiang center\"), SqlInteger(1))\n    insertTableStatement.update(SqlInteger(Int32(heNanUpdateResult.lastInsertId)), SqlInteger(3), SqlVarchar(\"henan development1\"), SqlInteger(1))\n    insertTableStatement.update(SqlInteger(Int32(heNanUpdateResult.lastInsertId)), SqlInteger(3), SqlVarchar(\"henan development2\"), SqlInteger(1))\n    insertTableStatement.update(SqlInteger(Int32(zheJiangUpdateResult.lastInsertId)), SqlInteger(3), SqlVarchar(\"zhejiang development1\"), SqlInteger(1))\n    insertTableStatement.update(SqlInteger(Int32(zheJiangUpdateResult.lastInsertId)), SqlInteger(3), SqlVarchar(\"zhejiang development2\"), SqlInteger(1))\n    println(\"insert into table sys_dept, 7 rows\")\n\n    let id = SqlInteger(0)\n    let parentId = SqlInteger(0)\n    let deptType = SqlInteger(0)\n    let deptName = SqlVarchar(\"\")\n    let deptStatus = SqlInteger(0)\n\n    let statement = connection.prepareStatement(\"select * from `sys_dept`;\")\n    let param = ArrayList<SqlDbType>()\n    let queryResult = statement.query(param.toArray())\n    var tempIndex = 1\n    println(\"query sys_dept all data\")\n    while(queryResult.next(id, parentId, deptType, deptName, deptStatus)) {\n        println(\" ${tempIndex} rows data, id = ${id.value}, parentId = ${parentId.value},\" + \n            \"deptType = ${deptType.value}, deptName = ${deptName.value}, deptStatus = ${deptStatus.value}\"\n        )\n        tempIndex ++ \n    }\n\n    tempIndex = 1\n    println(\"query sys_dept where dept_type = 2\")\n        let statement2 = connection.prepareStatement(\"select * from sys_dept where dept_type = ?;\")\n        param.append(SqlBigInt(2))\n    let queryResult2 = statement2.query(param.toArray())\n    while(queryResult2.next(id, parentId, deptType, deptName, deptStatus)) {\n        println(\" ${tempIndex} rows data, id = ${id.value}, parentId = ${parentId.value},\" + \n            \"deptType = ${deptType.value},  deptName = ${deptName.value}, deptStatus = ${deptStatus.value}\"\n        )\n        tempIndex ++ \n    }\n}", "llm_cg": {"main": ["DriverManager.getDriver", "drv.open", "ds.connect", "connection.prepareStatement", "ArrayList", "deleteTableStatement.update", "deleteTableParams.toArray", "<builtin>.println", "connection.prepareStatement", "ArrayList", "createTableStatement.update", "createTableParams.toArray", "<builtin>.println", "connection.prepareStatement", "insertTableStatement.update", "SqlInteger", "SqlVarchar", "companyUpdateResult.lastInsertId", "heNanUpdateResult.lastInsertId", "zheJiangUpdateResult.lastInsertId", "<builtin>.println", "SqlInteger", "SqlVarchar", "connection.prepareStatement", "ArrayList", "statement.query", "param.toArray", "<builtin>.println", "queryResult.next", "id.value", "parentId.value", "deptType.value", "deptName.value", "deptStatus.value", "<builtin>.println", "connection.prepareStatement", "param.append", "SqlBigInt", "statement2.query", "param.toArray", "queryResult2.next", "id.value", "parentId.value", "deptType.value", "deptName.value", "deptStatus.value", "<builtin>.println"]}, "static_cg": {}}
{"source_code": "package cangjieWeb.utils\nimport std.collection.{ArrayList}\nimport crypto.digest.{SHA256, SHA1}\nimport crypto.keys.{RSAPublicKey, PadOption, OAEPOption}\nimport std.io.ByteArrayStream\npublic class ByteArrayUtils {\n    private static var CACHING_SHA2_DIGEST_LENGTH = 32\n\n    public static func indexByte(source: Array<Byte>, target: Byte): Int64 {\n        for (i in 0 .. source.size) {\n            if (source[i] == target) {\n                return i\n            }\n        }\n        return -1\n    }\n\n    public static func littleEndianUint16(b: Array<Byte>):UInt16 {\n        return UInt16(b[0]) | UInt16(b[1])<<8\n    }\n\n    public static func littleEndianUint32(b: Array<Byte>):UInt32 {\n        return UInt32(b[0]) | UInt32(b[1])<<8 | UInt32(b[2])<<16 | UInt32(b[3]) << 24\n    }\n\n    public static func scrambleCachingSha2(cipher: Array<Byte>, passwd: Array<Byte>):Array<Byte> {\n        // 使用本包需要外部依赖 OpenSSL 3 的 crypto 动态库文件，故使用前需安装相关工具。\n        // 并配置环境变量\n        var sha2Instance = SHA256()\n        var dig1 = Array<Byte>(CACHING_SHA2_DIGEST_LENGTH, item: 0)\n        var dig2 = Array<Byte>(CACHING_SHA2_DIGEST_LENGTH, item: 0)\n        var scramble1 = Array<Byte>(CACHING_SHA2_DIGEST_LENGTH, item: 0)\n        \n        sha2Instance.write(passwd)\n        dig1 = sha2Instance.finish()\n        sha2Instance.reset()\n        sha2Instance.write(dig1)\n        dig2 = sha2Instance.finish()\n        sha2Instance.reset()\n        sha2Instance.write(dig2)\n        sha2Instance.write(cipher)\n        scramble1 = sha2Instance.finish()\n        sha2Instance.reset()\n        var mysqlScrambleBuff = Array<Byte>(CACHING_SHA2_DIGEST_LENGTH, item: 0)\n        xorString(dig1, mysqlScrambleBuff, scramble1, CACHING_SHA2_DIGEST_LENGTH)\n        return mysqlScrambleBuff\n    }\n\n    public static func scrambleRSA(password: String, publicKey: Array<Byte>, cipher: Array<Byte>): Array<Byte> {\n        var input: Array<Byte>\n        if(password.toArray().size == 0) {\n            input = Array<Byte>(1, item: 0)\n        } else {\n            input = Array<Byte>(password.toArray().size + 1, item: 0)\n            password.toArray().copyTo(input, 0, 0, password.toArray().size)\n            input[password.toArray().size] = 0\n        }\n\n        var mysqlScrambleBuff = Array<Byte>(input.size, item: 0)\n        xorString(input, mysqlScrambleBuff, cipher, input.size)\n        var rsaPub = RSAPublicKey.decodeFromPem(String.fromUtf8(publicKey))\n       \n        var byteArraySteam1 = ByteArrayStream()\n        byteArraySteam1.write(mysqlScrambleBuff)\n        \n        var byteArraySteam2 = ByteArrayStream()\n        var opt = OAEPOption(SHA1(),SHA1())\n        rsaPub.encrypt(byteArraySteam1,byteArraySteam2,padType:OAEP(opt))\n        // rsaPub.encrypt(byteArraySteam1, byteArraySteam2, padType: PadOption.PKCS1)\n        var buffer = Array<Byte>(1024, item: 0)\n        var len = byteArraySteam2.read(buffer)\n        var res = Array<Byte>(len, item: 0)\n        buffer.copyTo(res, 0, 0, len)\n        return res\n    }\n\n    public static func xorString(src: Array<Byte>, to: Array<Byte>,scramble:Array<Byte>,len:Int64) {\n        var pos = 0\n        var scrambleLen = scramble.size\n        while (pos < len) {\n            to[pos] = src[pos] ^ scramble[pos % scrambleLen]\n            pos++\n        }\n    }  \n\n    public static func appendLengthEncodedInteger(n: UInt64): Array<Byte> {\n        let result = ArrayList<Byte>()\n        if (n <= 250) {\n            result.append(UInt8(n))\n        } else if (n <= 0xffff) {\n            result.append(0xfc)\n            result.append(UInt8(n & 0xff))\n            result.append(UInt8(n >> 8 & 0xff))\n        } else if (n <= 0xffffff) {\n            result.append(0xfd)\n            result.append(UInt8(n & 0xff))\n            result.append(UInt8(n >> 8 & 0xff))\n            result.append(UInt8(n >> 16 & 0xff))\n        } else {\n            result.append(0xfe)\n            result.append(UInt8(n & 0xff))\n            result.append(UInt8(n >> 8 & 0xff))\n            result.append(UInt8(n >> 16 & 0xff))\n            result.append(UInt8(n >> 24 & 0xff))\n            result.append(UInt8(n >> 32 & 0xff))\n            result.append(UInt8(n >> 40 & 0xff))\n            result.append(UInt8(n >> 48 & 0xff))\n            result.append(UInt8(n >> 56 & 0xff))\n        }\n        return result.toArray()\n    }\n\n    public static func uint64ToBytes(n: UInt64): Array<Byte> {\n        let result = ArrayList<Byte>()\n        result.append(UInt8(n & 0xff))\n        result.append(UInt8(n >> 8 & 0xff))\n        result.append(UInt8(n >> 16 & 0xff))\n        result.append(UInt8(n >> 24 & 0xff))\n        result.append(UInt8(n >> 32 & 0xff))\n        result.append(UInt8(n >> 40 & 0xff))\n        result.append(UInt8(n >> 48 & 0xff))\n        result.append(UInt8(n >> 56 & 0xff))\n        return result.toArray()\n    }\n\n    public static func uint32ToBytes(n: UInt32): Array<Byte> {\n        let result = ArrayList<Byte>()\n        result.append(UInt8(n & 0xff))\n        result.append(UInt8(n >> 8 & 0xff))\n        result.append(UInt8(n >> 16 & 0xff))\n        result.append(UInt8(n >> 24 & 0xff))\n        return result.toArray()\n    }\n\n    public static func readLengthEncodedString(data: Array<Byte>) {\n        let result = readLengthEncodedInteger(data)\n        var num = result[0]\n        var isNull = result[1]\n        var n = result[2]\n        if (num < 1) {\n            return (data[n..n], isNull, n)\n        }\n\n        n += Int64(num)\n        if (data.size >= n) {\n            return (data[n - Int64(num) .. n], false, n)\n        }\n        return (Array<Byte>(), false, n)\n    }\n    public static func lengthEncoderInteger(number: UInt64): Array<Byte> {\n        let result = ArrayList<Byte>()\n        if (number <= 250) {\n            result.append(UInt8(number))\n        } else if (number <= 0xffff) {\n             result.append(UInt8(0xfc))\n\n        }\n\n        return result.toArray()\n    }\n\n    /*\n        第一个参数，the number\n        第二个参数，数值是否为NULL\n        第三个参数，所占字节数\n    */\n    public static func readLengthEncodedInteger(data: Array<Byte>): (UInt64, Bool, Int64) {\n        match(data[0]) {\n            case 251 => \n                return (0, true, 1)\n            case 252 => \n                return (\n                    UInt64(data[1]) | UInt64(data[2])<<8, false, 3\n                )\n            case 253 => \n                return (\n                    UInt64(data[1]) | UInt64(data[2])<<8 | UInt64(data[3])<<16, false, 4\n                )\n            case 254 => \n                return (\n                    UInt64(data[1]) | UInt64(data[2])<<8 | UInt64(data[3])<<16 | UInt64(data[4]) << 24 |\n                    UInt64(data[5]) << 32 | UInt64(data[6]) << 40 | UInt64(data[7]) << 48 | UInt64(data[8]) << 56,\n                    false, 9\n                )\n            case _ => return (UInt64(data[0]), false , 1)\n        }\n    }\n\n\n}", "llm_cg": {"main": [], "ByteArrayUtils": [], "ByteArrayUtils.indexByte": [], "ByteArrayUtils.littleEndianUint16": [], "ByteArrayUtils.littleEndianUint32": [], "ByteArrayUtils.scrambleCachingSha2": ["SHA256", "sha2Instance.write", "sha2Instance.finish", "sha2Instance.reset", "xorString"], "ByteArrayUtils.scrambleRSA": ["password.toArray", "password.toArray.size", "password.toArray.copyTo", "RSAPublicKey.decodeFromPem", "String.fromUtf8", "ByteArrayStream", "byteArraySteam1.write", "OAEPOption", "SHA1", "rsaPub.encrypt", "byteArraySteam2.read", "buffer.copyTo"], "ByteArrayUtils.xorString": [], "ByteArrayUtils.appendLengthEncodedInteger": ["ArrayList.append", "result.toArray"], "ByteArrayUtils.uint64ToBytes": ["ArrayList.append", "result.toArray"], "ByteArrayUtils.uint32ToBytes": ["ArrayList.append", "result.toArray"], "ByteArrayUtils.readLengthEncodedString": ["readLengthEncodedInteger"], "ByteArrayUtils.lengthEncoderInteger": ["ArrayList.append", "result.toArray"], "ByteArrayUtils.readLengthEncodedInteger": []}, "static_cg": {}}
{"source_code": "package cangjieWeb.mysql\nimport std.database.sql.{UpdateResult}\npublic class MySqlUpdateResult <: UpdateResult {\n\n    private var _rowCount: Int64 \n    private var _lastInsertId: Int64 \n\n    public init(rowCount: Int64, lastInsertId: Int64) {\n        this._rowCount = rowCount\n        this._lastInsertId = lastInsertId\n    }\n\n\n    public prop lastInsertId: Int64 {\n        get() {\n            return _lastInsertId\n        }\n    }\n    public prop rowCount: Int64 {\n        get() {\n            return _rowCount\n        }\n    }\n\n    public func close() {\n        \n    }\n\n    public func isClosed(): Bool {\n        return false\n    } \n}", "llm_cg": {"main": [], "MySqlUpdateResult": [], "MySqlUpdateResult.init": [], "MySqlUpdateResult.lastInsertId.get": [], "MySqlUpdateResult.rowCount.get": [], "MySqlUpdateResult.close": [], "MySqlUpdateResult.isClosed": []}, "static_cg": {}}
{"source_code": "package cangjieWeb.mysql\n\nprotected class MySqlField {\n    private var tableName: String = \"\"\n\tprivate var name: String = \"\"\n\tprivate var length: UInt32 = 0\n\tprivate var flags: UInt16 = 0\n\tprivate var fieldType: UInt16 = 0\n\tprivate var decimals: Byte = 0\n\tprivate var charSet: UInt8 = 0\n\n\n    public func getTableName() {\n        return this.tableName\n    }\n\n    public func setTableName(tableName: String) {\n        this.tableName = tableName\n    }\n\n    public func getName() {\n        return this.name\n    }\n\n    public func setName(name: String) {\n        this.name = name\n    }\n\n    public func getLength() {\n        return this.length\n    }\n\n    public func setLength(length: UInt32) {\n        this.length = length\n    }\n\n    public func getFlags() {\n        return this.flags\n    }\n\n    public func setFlags(flags: UInt16) {\n        this.flags = flags\n    }\n\n    public func getFieldType() {\n        return this.fieldType\n    }\n\n    public func setFieldType(fieldType: UInt16) {\n        this.fieldType = fieldType\n    }\n\n    public func getDecimals() {\n        return this.decimals\n    }\n\n    public func setDecimals(decimals: Byte) {\n        this.decimals = decimals\n    }\n\n    public func getCharSet() {\n        return this.charSet\n    }\n\n    public func setCharSet(charSet: UInt8) {\n        this.charSet = charSet\n    }\n}", "llm_cg": {"main": [], "MySqlField": [], "MySqlField.getTableName": [], "MySqlField.setTableName": [], "MySqlField.getName": [], "MySqlField.setName": [], "MySqlField.getLength": [], "MySqlField.setLength": [], "MySqlField.getFlags": [], "MySqlField.setFlags": [], "MySqlField.getFieldType": [], "MySqlField.setFieldType": [], "MySqlField.getDecimals": [], "MySqlField.setDecimals": [], "MySqlField.getCharSet": [], "MySqlField.setCharSet": []}, "static_cg": {}}
{"source_code": "package cangjieWeb.mysql\n\nimport std.net.{TcpSocket}\n\npublic class Buffer {\n    private var idx: Int64 = 0\n    private var length: Int64 = 0\n    private var buf: Array<Byte>\n    private let socket: TcpSocket\n\n    init(socket: TcpSocket) {\n        this.socket = socket\n        this.buf = Array<Byte>(4096, item: 0)\n    }\n\n    public func readNext(need: Int64): Array<Byte> {\n        if (length < need) {\n            fill(need)\n        }\n        \n        let data = buf[idx .. idx + need]\n        idx += need\n        length -= need\n\n        return data\n    }\n\n    public func fill(need: Int64) {\n        if (length > 0 && idx > 0) {\n            buf.copyTo(buf, idx, 0, length - idx)\n        }\n        if (need > buf.size) {\n            grow(need)\n        }\n        idx = 0\n        while (length < need) {\n            var readSize = socket.read(buf[length..])\n            length += readSize\n        }\n    }\n\n    public func grow(need: Int64) {\n        let newBuf = Array<Byte>(need, item: 0)\n        buf.copyTo(newBuf, 0, 0, length)\n        this.buf = newBuf\n    }\n}", "llm_cg": {}, "static_cg": {}}
{"source_code": "package cangjieWeb.mysql\nimport std.database.sql.{Transaction, TransactionAccessMode, TransactionDeferrableMode, TransactionIsoLevel}\npublic class MySqlTransaction <: Transaction {\n    private var _accessMode: TransactionAccessMode = TransactionAccessMode.ReadOnly\n    private var _deferrableMode: TransactionDeferrableMode = TransactionDeferrableMode.Deferrable\n    private var _isoLevel: TransactionIsoLevel = TransactionIsoLevel.RepeatableRead\n    public mut prop accessMode: TransactionAccessMode {\n        get() {\n            _accessMode\n        }\n        set(accessMode) {\n            _accessMode = accessMode\n        }\n    }\n    public mut prop deferrableMode: TransactionDeferrableMode {\n        get() {\n            _deferrableMode\n        }\n        set(deferrableMode) {\n            _deferrableMode = deferrableMode\n        }\n    }\n    public mut prop isoLevel: TransactionIsoLevel {\n        get() {\n            _isoLevel\n        }\n        set(isoLevel) {\n            _isoLevel = isoLevel\n        }\n    }\n    public func begin(): Unit {\n\n    }\n    public func commit(): Unit {\n\n    }\n    public func release(savePointName: String): Unit {\n\n    }\n    public func rollback(): Unit {\n\n    }\n    public func rollback(savePointName: String): Unit {\n\n    }\n    public func save(savePointName: String): Unit {\n\n    }\n}", "llm_cg": {"main": [], "MySqlTransaction": [], "MySqlTransaction.begin": [], "MySqlTransaction.commit": [], "MySqlTransaction.release": [], "MySqlTransaction.rollback": [], "MySqlTransaction.rollback(String)": [], "MySqlTransaction.save": []}, "static_cg": {}}
{"source_code": "package cangjieWeb.mysql\nimport std.database.sql.{Datasource, Connection}\npublic class MySqlDatasource <: Datasource {\n\n    private let config: Config\n\n    init(config: Config) {\n        this.config = config\n    }\n\n    public func connect(): Connection {\n        return MysqlConnection(config)\n    }\n    public func setOption(key: String, value: String) {\n\n    }\n\n    public func close() {\n        \n    }\n\n    public func isClosed(): Bool {\n        return false\n    }\n}", "llm_cg": {"main": [], "MySqlDatasource": [], "MySqlDatasource.init": [], "MySqlDatasource.connect": ["MysqlConnection"], "MySqlDatasource.setOption": [], "MySqlDatasource.close": [], "MySqlDatasource.isClosed": []}, "static_cg": {}}
{"source_code": "package cangjieWeb.mysql\nimport std.database.sql.{Statement, ColumnInfo, QueryResult, SqlDbType, UpdateResult, SqlNullableBigInt, SqlBigInt, SqlVarchar, SqlInteger}\nimport std.collection.{ArrayList}\nimport cangjieWeb.utils.ByteArrayUtils\npublic class MySqlStatement <: Statement {\n\n    private let connection: MysqlConnection\n    private let sql: String\n    private var id : UInt32 = 0\n    private var columnCount: UInt16 = 0\n    private var paramCount: UInt16 = 0\n    private let _parameters: Array<ColumnInfo> = Array<ColumnInfo>()\n    private let _columns: Array<ColumnInfo> = Array<ColumnInfo>()\n\n    private var rowCount: Int64 = 0\n    private var lastInsertId: Int64 = 0\n\n\n\n    init(connection: MysqlConnection, sql: String) {\n        this.connection = connection\n        this.sql = sql\n\n        this.connection.writeCommandPacketStr(comStmtPrepare, sql)\n        readPrepareResultPacket()\n    }\n\n    public prop parameterColumnInfos: Array<ColumnInfo> {\n        get() {\n            return ArrayList<ColumnInfo>().toArray()\n        }\n    }\n\n\n    public func query(params: Array<SqlDbType>): QueryResult {\n        // 发送\n        writeExecutePacket(params)\n        // 接收结果\n        let columnNumber = readRequstSetHeaderPacket()\n        // println(\"columnCount = ${columnNumber}\")\n        var columns: ArrayList<MySqlField> = ArrayList<MySqlField>()\n        var rows: ArrayList<Array<Byte>> = ArrayList<Array<Byte>>()\n        if (columnNumber > 0) {\n            // read columns\n            columns = this.connection.readColumns(UInt16(columnNumber))\n            // read rows\n            rows = this.connection.readRows()\n        }\n        return MysqlQueryResult(columns, rows)\n    }\n    public func setOption(key: String, value: String): Unit {\n\n    }\n    public func update(params: Array<SqlDbType>): UpdateResult {\n        // 发送\n        writeExecutePacket(params)\n\n        // 接收结果\n        let updateResult = readRequstSetHeaderPacket()        \n        return MySqlUpdateResult(rowCount, lastInsertId)\n    }\n\n    public func close() {\n        \n    }\n\n    public func isClosed(): Bool {\n        return false\n    }\n\n    private func readRequstSetHeaderPacket(): Int64 {\n        let data = connection.readPacket()\n        match(data[0]) {\n            case 0 => \n                handleOkPacket(data[1..])\n                return 0\n            case 255 =>\n                println(\"err, do later\")\n                return -1\n            case _ => \n                1 + 1\n                // println(\"unknow, do later\")\n                // return -1\n        }\n\n        // column count\n        let (number, isNull, n) = ByteArrayUtils.readLengthEncodedInteger(data)\n        return Int64(number)\n    }\n\n    private func handleOkPacket(data: Array<Byte>) {\n        // Affected rows [Length Coded Binary]\n\t    let (affectedRows, affectedRowsIsNull, n) = ByteArrayUtils.readLengthEncodedInteger(data[0..])\n\n\t    // Insert id [Length Coded Binary]\n\t    let (insertId, insertIdIsNull, m )= ByteArrayUtils.readLengthEncodedInteger(data[n..])\n        rowCount = Int64(affectedRows)\n        lastInsertId = Int64(insertId)\n    }\n\n\n    private func readPrepareResultPacket() {\n        let data = this.connection.readPacket()\n        if (data[0] != iOK) {\n            println(\"error here, do later\")\n        }\n\n        id = ByteArrayUtils.littleEndianUint32(data[1..5])\n        columnCount = ByteArrayUtils.littleEndianUint16(data[5..7])\n        paramCount = ByteArrayUtils.littleEndianUint16(data[7..9])\n        if (paramCount > 0) {\n           let params:ArrayList<MySqlField> = this.connection.readColumns(paramCount)\n        } \n        if (columnCount > 0) {\n            let columns = this.connection.readColumns(columnCount)\n        }\n    }\n\n    private func writeExecutePacket(params: Array<SqlDbType>) {\n        connection.sequence = 0\n        var pktLen = 1 + 4 + 1 + 4 + ((Int64(paramCount) + 7) / 8) + 1 + (Int64(paramCount) * 2)\n        let paramValues = ArrayList<Array<Byte>>() \n        let paramTypes = Array<Byte>(Int64(paramCount) * 2, item: 0)\n        var bitMask = UInt64(0)\n\n        for(i in 0 .. params.size) {\n            let param = params.get(i).getOrThrow()\n            // 先只处理 SqlBigInt 和 SqlNullableBigInt\n            match(param.name) {\n                case \"SqlNullableBigInt\" => \n                    let temp = param as SqlNullableBigInt\n                    let value = temp.getOrThrow()\n                    match(value.value) {\n                        case Some(number) => \n                            paramTypes[i<<1] = fieldTypeLongLong\n                            let appenValue = ByteArrayUtils.uint64ToBytes(UInt64(number))\n                            paramValues.append(appenValue)\n                            pktLen += 8\n                        case None => \n                            bitMask += 1 << UInt64(i)\n                            paramTypes[i<<1] = fieldTypeNULL\n                    }\n                    \n                case \"SqlBigInt\" => \n                    let temp = param as SqlBigInt\n                    let number = temp.getOrThrow().value\n                    paramTypes[i<<1] = fieldTypeLongLong\n                    let appenValue = ByteArrayUtils.uint64ToBytes(UInt64(number))\n                    paramValues.append(appenValue)\n                    pktLen += 8\n\n                case \"SqlInteger\" =>\n                    let temp = param as SqlInteger\n                    let number = temp.getOrThrow().value\n                    paramTypes[i<<1] = fieldTypeLong\n                    let appenValue = ByteArrayUtils.uint32ToBytes(UInt32(number))\n                    paramValues.append(appenValue)\n                    pktLen += 4\n\n                case \"SqlVarchar\" =>\n                    let temp = param as SqlVarchar\n                    let s = temp.getOrThrow().value\n                    paramTypes[i<<1] = fieldTypeVarString\n                    let result = ArrayList<Byte>()\n                    var lengthBytes = ByteArrayUtils.appendLengthEncodedInteger(UInt64(s.toArray().size))\n                    result.appendAll(lengthBytes)\n                    result.appendAll(s.toArray())\n                    paramValues.append(result.toArray())\n                    pktLen = pktLen + result.toArray().size\n\n                case _ => println(\"unsupport data type\")\n            }\n        }\n\n        let data = Array<Byte>(pktLen + 4, item: UInt8(0))\n\n        data[0] = UInt8(pktLen & 0xff)\n\t    data[1] = UInt8(pktLen >> 8)\n\t    data[2] = UInt8(pktLen >> 16)\n\t    data[3] = connection.sequence\n\n        data[4] = comStmtExecute\n\n        data[5] = UInt8(id)\n        data[6] = UInt8(id>>8)\n        data[7] = UInt8(id>>16)\n        data[8] = UInt8(id>>24)\n\n        data[10] = 0x01\n\n        if (paramCount > 0) {\n            var pos = 14 + ((Int64(paramCount) + 7) / 8)\n            for(i in 14 .. pos) {\n                data[i] = UInt8(bitMask >> UInt64((i - 14)* 8))\n            }\n\n            data[pos] = 0x01\n            pos ++\n\n            paramTypes.copyTo(data, 0, pos, paramTypes.size)\n            pos += paramTypes.size\n            for(i in 0 .. paramCount) {\n                let paramValue = paramValues[Int64(i)]\n                paramValue.toArray().copyTo(data, 0, pos, paramValue.toArray().size)\n                pos += paramValue.toArray().size\n            }\n        }\n        connection.writePacket(data)\n    }\n\n}", "llm_cg": {"MySqlStatement": [], "MySqlStatement.init": ["MysqlConnection.writeCommandPacketStr", "MySqlStatement.readPrepareResultPacket"], "MySqlStatement.parameterColumnInfos.get": ["std.collection.ArrayList.toArray"], "MySqlStatement.query": ["MySqlStatement.writeExecutePacket", "MySqlStatement.readRequstSetHeaderPacket", "MysqlConnection.readColumns", "MysqlConnection.readRows", "MysqlQueryResult"], "MySqlStatement.setOption": [], "MySqlStatement.update": ["MySqlStatement.writeExecutePacket", "MySqlStatement.readRequstSetHeaderPacket", "MySqlUpdateResult"], "MySqlStatement.close": [], "MySqlStatement.isClosed": [], "MySqlStatement.readRequstSetHeaderPacket": ["MysqlConnection.readPacket", "MySqlStatement.handleOkPacket", "cangjieWeb.utils.ByteArrayUtils.readLengthEncodedInteger"], "MySqlStatement.handleOkPacket": ["cangjieWeb.utils.ByteArrayUtils.readLengthEncodedInteger", "<builtin>.Int64"], "MySqlStatement.readPrepareResultPacket": ["MysqlConnection.readPacket", "<builtin>.println", "cangjieWeb.utils.ByteArrayUtils.littleEndianUint32", "cangjieWeb.utils.ByteArrayUtils.littleEndianUint16", "MysqlConnection.readColumns"], "MySqlStatement.writeExecutePacket": ["<builtin>.Int64", "std.collection.ArrayList.append", "cangjieWeb.utils.ByteArrayUtils.uint64ToBytes", "cangjieWeb.utils.ByteArrayUtils.uint32ToBytes", "cangjieWeb.utils.ByteArrayUtils.appendLengthEncodedInteger", "std.collection.ArrayList.appendAll", "<builtin>.println", "std.collection.Array.copyTo", "MysqlConnection.writePacket"]}, "static_cg": {}}
{"source_code": "package cangjieWeb.mysql\n\npublic let maxPacketSize = 1<<24 - 1\n\npublic let clientLongPassword: UInt32  = 1\npublic let clientLongFlag: UInt32  = 4\npublic let clientConnectWithDB: UInt32  = 8\npublic let clientLocalFiles: UInt32 = 128\npublic let clientProtocol41: UInt32 = 512\npublic let clientTransactions: UInt32 = 8192\npublic let clientSecureConn: UInt32 = 32768\npublic let clientMultiResults:UInt32 = 131072\npublic let clientPluginAuth:UInt32 = 524288\npublic let clientConnectAttrs:UInt32 = 1048576\npublic let clientPluginAuthLenEncClientData:UInt32 = 2097152\n\n\npublic let iOK: Byte = UInt8(0)\npublic let iAuthMoreData: Byte = UInt8(1)\npublic let iLocalInFile: Byte = UInt8(251)\npublic let iEOF: Byte = UInt8(254)\npublic let iERR: Byte = UInt8(255)\n\npublic let cachingSha2PasswordRequestPublicKey: Byte = UInt8(2)\npublic let cachingSha2PasswordPerformFullAuthentication: Byte = UInt8(4)\n\n\n\npublic let comQuit: Byte = 1\npublic let comQuery: Byte = 3\npublic let comPing: Byte = 14\npublic let comStmtPrepare: Byte = 22\npublic let comStmtExecute: Byte = 23\npublic let comStmtSendLongData: Byte = 24\npublic let comStmtClose: Byte = 25\n\n\npublic let fieldTypeLong: Byte = 3\npublic let fieldTypeNULL: Byte = 6\npublic let fieldTypeLongLong: Byte = 8\npublic let fieldTypeVarString: Byte = 253", "llm_cg": {}, "static_cg": {}}
{"source_code": "package cangjieWeb.mysql\nimport std.collection.HashMap\nclass Config {\n    public var username = \"\"\n    public var password = \"\"\n    public var address = \"\"\n    public var protocol = \"\"\n    public var dbname = \"\"\n    public var params = HashMap<String, String>()\n}", "llm_cg": {"main": [], "Config": []}, "static_cg": {}}
{"source_code": "package cangjieWeb.mysql\nimport std.database.sql.{QueryResult, ColumnInfo, SqlDbType, SqlInteger, SqlVarchar}\nimport std.collection.{ArrayList}\nimport cangjieWeb.utils.ByteArrayUtils\npublic class MysqlQueryResult <: QueryResult {\n\n    private let columns: ArrayList<MySqlField>\n    private let rows: ArrayList<Array<Byte>>\n    private var tempRowsIndex = 0\n    private var nullBitMapStartPos = 1\n    private var nullBitMapEndPos = 0\n    private var tempRowPos = 0\n\n    init(columns: ArrayList<MySqlField>, rows: ArrayList<Array<Byte>>) {\n        this.columns = columns\n        this.rows = rows\n        this.nullBitMapEndPos = (this.columns.size + 7) / 8 + nullBitMapStartPos\n    }\n\n\n   public prop columnInfos: Array<ColumnInfo> {\n        get() {\n            return ArrayList<ColumnInfo>().toArray()\n        }\n    }\n    public func next(values: Array<SqlDbType>): Bool {\n        tempRowPos = nullBitMapStartPos + 1\n        if (tempRowsIndex < rows.size) {\n            for(i in 0 .. values.size) {\n                fillData(values[i])\n            }\n            tempRowsIndex ++\n            return true\n        }\n        return false\n    }\n\n    public func close() {\n        \n    }\n\n    public func isClosed(): Bool {\n        return false\n    }\n\n    private func fillData(value: SqlDbType) {\n            match (value) {\n                case v: SqlInteger\t=> \n                    let number = ByteArrayUtils.littleEndianUint32(rows[tempRowsIndex][tempRowPos..])\n                    v.value = Int32(number)\n                    tempRowPos += 4\n                case v: SqlVarchar => \n                    let (s, isNull, n) = ByteArrayUtils.readLengthEncodedString(rows[tempRowsIndex][tempRowPos..])\n                    v.value = String.fromUtf8(s)\n                    tempRowPos += n\n                case _ =>\n                    println(\"unsupport Type\")\n            }\n    }\n}", "llm_cg": {"main": [], "MysqlQueryResult": ["ArrayList.toArray"], "MysqlQueryResult.init": [], "MysqlQueryResult.next": ["MysqlQueryResult.fillData"], "MysqlQueryResult.close": [], "MysqlQueryResult.isClosed": [], "MysqlQueryResult.fillData": ["ByteArrayUtils.littleEndianUint32", "Int32", "ByteArrayUtils.readLengthEncodedString", "String.fromUtf8", "<builtin>.println"]}, "static_cg": {}}
{"source_code": "package cangjieWeb.mysql\nimport std.database.sql.{Driver, DriverManager, Datasource}\npublic class MySqlDriver <: Driver {\n    static init() {\n        println(\"mysql register MySqlDriver\")\n        DriverManager.register(\"mysql\", MySqlDriver())\n    }\n\n    public prop name: String {\n        get() {\n            return \"mysql\"\n        }\n    }\n    public prop version: String {\n        get() {\n            return \"0.0.1\"\n        }\n    }\n    public prop preferredPooling: Bool {\n        get() {\n            return true\n        }\n    }\n\n    // 要实现的第一个方法\n    // connectionString 格式  username:password@protocol(address)/dbname\n    // opts 目前仅支持 charset\n    public func open(connectionString: String, opts: Array<(String, String)>): Datasource {\n        // let connectionString = \"username:password@protocol(192.168.4.44:3307)/dbname\"\n        let config = parseConnectStringAndParams(connectionString, opts)\n        return MySqlDatasource(config)\n    }\n\n    private func parseConnectStringAndParams(connectionString: String, opts: Array<(String, String)>): Config {\n        let usernameEnd = connectionString.indexOf(\":\", 0).getOrDefault({ => -1})\n        let passwordEnd = connectionString.indexOf(\"@\").getOrDefault({ => -1})\n        let protocolEnd = connectionString.indexOf(\"(\").getOrDefault({ => -1})\n        let addressEnd = connectionString.indexOf(\")\").getOrDefault({ => -1})\n        let dbnameStart = addressEnd + 2\n        let username = connectionString[0..usernameEnd]\n        let password = connectionString[usernameEnd + 1 .. passwordEnd]\n        let protocol = connectionString[passwordEnd + 1 .. protocolEnd]\n        let address  = connectionString[protocolEnd + 1 .. addressEnd]\n        let dbname = connectionString[dbnameStart .. ]\n\n        println(\"username = ${username}, password = ${password}, protocol = ${protocol}, address = ${address}, \" \n        + \"dbname = ${dbname}\")\n\n        let config = Config()\n        config.address = address\n        config.username = username\n        config.password = password\n        config.protocol = protocol\n        config.dbname = dbname\n\n        for((key, value) in opts) {\n            config.params.put(key, value)\n        }\n\n        return config\n    }\n}", "llm_cg": {"main": [], "MySqlDriver": [], "MySqlDriver.init": ["<builtin>.println", "DriverManager.register", "MySqlDriver"], "MySqlDriver.name.get": [], "MySqlDriver.version.get": [], "MySqlDriver.preferredPooling.get": [], "MySqlDriver.open": ["MySqlDriver.parseConnectStringAndParams", "MySqlDatasource"], "MySqlDriver.parseConnectStringAndParams": ["connectionString.indexOf", "connectionString.indexOf", "connectionString.indexOf", "connectionString.indexOf", "<builtin>.println", "Config", "config.params.put"]}, "static_cg": {}}
{"source_code": "package cangjieWeb.mysql\nimport std.database.sql.{Connection, Transaction, ConnectionState, Statement}\nimport std.collection.{Map, HashMap, ArrayList}\nimport std.net.{TcpSocket, IPSocketAddress, SocketException, SocketKeepAliveConfig}\nimport cangjieWeb.utils.ByteArrayUtils\nimport encoding.hex.{toHexString,fromHexString}\npublic class MysqlConnection <: Connection {\n\n    private let config: Config\n    private let tcpSocket: TcpSocket\n    private let buffer: Buffer\n    protected var sequence: Byte = 0\n    private var cipher: Array<Byte> = Array<Byte>()\n    private var charset: Byte = 0\n    private var flags: UInt32 = 0\n    private var plugin: String = \"\"\n\n    private var maxPacketAllowed: Int64 = maxPacketSize\n\tprivate var maxWriteSize: Int64 = maxPacketSize - 1\n\n    init(config: Config) {\n        this.config = config\n\n        // 构造tcpSocket\n        var socket = TcpSocket(IPSocketAddress.parse(config.address))\n        socket.keepAlive = SocketKeepAliveConfig()\n        \n        // 三次握手建立连接\n        socket.connect()\n        this.tcpSocket = socket\n        this.buffer = Buffer(socket)\n        // 处理handshake, mysql server 向 client 发送\n        readInitPacket()\n\n        // Send Client Authentication Packet\n        writeAuthPacket()\n        // handleAuthResult\n        handleAuthResult()\n\n        // get max allowed packet size\n        // let result = getSystemVar(\"max_allowed_packet\")\n    }\n\n    public func getMetaData(): Map<String, String> {\n        HashMap([])\n    }\n    public func createTransaction():Transaction {\n        return MySqlTransaction()\n    }\n\n    public prop state: ConnectionState {\n        get() {\n            ConnectionState.Connected\n        }\n    }\n\n    public func close() {\n        \n    }\n\n    public func isClosed(): Bool {\n        return false\n    }\n\n    public func prepareStatement(sql: String): Statement {\n        return MySqlStatement(this, sql)\n    }\n\n    private func readInitPacket() {\n        let data = readPacket()\n        \n        // 协议版本: 1 字节\n        // 服务器版本: 以 \\0 结尾的字符串\n        // 连接 ID: 4 字节\n        var pos = 1 + ByteArrayUtils.indexByte(data[1..], 0) + 1 + 4 // 11\n\n        // 密码加密部分: 8 字节\n        cipher = cipher.concat(data[pos..pos + 8])\n        // 填充字节: 1 字节（始终为 0x00）\n        pos = pos + 8 + 1 \n\n        // 能力标志（低 2 字节）: 2 字节\n        flags = UInt32(ByteArrayUtils.littleEndianUint16(data[pos .. pos + 2]))\n        pos = pos + 2\n\n        // 字符集: 1 字节\n        charset = data.get(pos).getOrThrow()\n        \n        // 状态标志: 2 字节\n        // 能力标志（高 2 字节）: 2 字节\n        // 认证插件数据长度: 1 字节\n        // 保留字节: 10 字节（全部为 0x00）\n        pos = pos + 1 + 2 + 2 + 1 + 10 // 38\n\n        // 密码加密部分: 可变长度（通常为 12 字节）\n        cipher = cipher.concat(data[pos..pos + 12])\n        pos += 13\n\n        let end = ByteArrayUtils.indexByte(data[pos..], 0)\n        if (end != -1) {\n            plugin = String.fromUtf8(data[pos .. pos + end])\n        }else {\n            plugin = String.fromUtf8(data[pos .. ])\n        }\n    }\n\n    private func writeAuthPacket() {\n        var clientFlags: UInt32 = \n\t\t    clientProtocol41 |  \n\t\t\tclientSecureConn | \n\t\t\tclientLongPassword | \n\t\t\tclientTransactions | \n\t\t\tclientLocalFiles |  \n            clientPluginAuth |  \n            clientMultiResults | \n            flags &\n            clientLongFlag \n\t    \n\n        let authResp = ByteArrayUtils.scrambleCachingSha2(cipher, config.password.toArray())\n\n        // 4 长度 + sequence\n        // 4 clientFlags\n        // 4 个空位\n        // 1 charset\n        // 23 空\n        // username\n        // 1 以0结尾\n        // 1 密码长度\n        // 密码\n        // dbname\n\n        let authRespLen = authResp.size\n        let authRespLEI = ByteArrayUtils.appendLengthEncodedInteger(UInt64(authRespLen))\n        if (authRespLEI.size > 1) {\n            clientFlags |= clientPluginAuthLenEncClientData\n        }\n        var pktLen = 4 + 4 + 1 + 23 + config.username.toArray().size + 1 + authRespLEI.size + authResp.size + 21 \n\t    if (config.dbname.size > 0) {\n\t\t    clientFlags |= UInt32(clientConnectWithDB)\n\t\t    pktLen += config.dbname.toArray().size + 1\n\t    }\n\n        let data = Array<Byte>(pktLen + 4, item: UInt8(0))\n\n        data[0] = UInt8(pktLen & 0xff)\n\t    data[1] = UInt8(pktLen >> 8)\n\t    data[2] = UInt8(pktLen >> 16)\n\t    data[3] = sequence\n\n        data[4] = UInt8(clientFlags & 0xff)\n\t    data[5] = UInt8(clientFlags >> 8 & 0xff)\n\t    data[6] = UInt8(clientFlags >> 16 & 0xff)\n\t    data[7] = UInt8(clientFlags >> 24 & 0xff)\n\n        data[12] = charset\n\n        var pos = 13 + 23\n\n        if (config.username.size > 0) {\n            config.username.toArray().copyTo(data, 0, pos, config.username.toArray().size)\n            pos += config.username.toArray().size\n        }\n        pos += 1\n\n        authRespLEI.copyTo(data, 0, pos, authRespLEI.size)\n        pos += authRespLEI.size\n\n        authResp.copyTo(data, 0, pos, authResp.size)\n        pos += authResp.size\n\n        if (config.dbname.size > 0) {\n            config.dbname.toArray().copyTo(data, 0, pos, config.dbname.toArray().size)\n            pos +=  config.dbname.toArray().size\n            pos += 1\n        }\n        plugin.toArray().copyTo(data, 0, pos, plugin.toArray().size)\n        pos += plugin.toArray().size\n        writePacket(data)\n    }\n\n    private func handleAuthResult() {\n\n        var result = readAuthResult()\n        var authData = result[0]\n        var newPlugin = result[1]\n        if (newPlugin != \"\") {\n            if (authData.size > 0) {\n                // cipher = authData\n                authData.copyTo(cipher, 0, 0, cipher.size)\n            } else {\n                authData = cipher\n            }\n            plugin = newPlugin\n            let authResp = ByteArrayUtils.scrambleCachingSha2(authData, config.password.toArray())\n            writeAuthSwitchPacket(authResp)\n\n            result = readAuthResult()\n            authData = result[0]\n            newPlugin = result[1]\n        }\n\n        match(plugin) {\n            case \"caching_sha2_password\" => \n                match(authData.size) {\n                    case 1 =>\n                        match(authData[0]) {\n                            case 4 =>\n                                // request public key from server\n                                let pktLen = 1\n        \n                                let data = Array<Byte>(pktLen + 4, item: UInt8(0))\n\n                                data[0] = UInt8(pktLen & 0xff)\n                                data[1] = UInt8(pktLen >> 8)\n                                data[2] = UInt8(pktLen >> 16)\n                                data[3] = sequence\n\n                                data[4] = cachingSha2PasswordRequestPublicKey\n                                writePacket(data)\n\n                                let publicKeyData = readPacket()\n\n                                sendEncryptedPassword(publicKeyData[1..])\n\n                                readPacket()\n                            case _ =>\n                                println(\"eror or correct but do later\")\n                        }\n                    case _ =>\n                        println(\"error size or correct size but do later \")\n                }\n            case _ => \n                println(\"other, do later\")\n            \n        }\n    }\n\n    private func writeAuthSwitchPacket(authData: Array<Byte>) {\n        let pktLen = authData.size\n        \n        let data = Array<Byte>(pktLen + 4, item: UInt8(0))\n\n        data[0] = UInt8(pktLen & 0xff)\n\t    data[1] = UInt8(pktLen >> 8)\n\t    data[2] = UInt8(pktLen >> 16)\n\t    data[3] = sequence\n\n        authData.copyTo(data, 0, 4, authData.size)\n        writePacket(data)\n    }\n\n    private func readAuthResult() {\n        // let data = fromHexString(data: String)\n\n        let data = readPacket()\n        \n        match(data[0]) {\n            case 1 =>\n                return (data[1..], \"\")\n            case 254 => \n                if (data.size == 1) {\n                    return (Array<Byte>(), \"mysql_old_password\")\n                }\n                let pluginEndIndex = ByteArrayUtils.indexByte(data, 0)\n                if (pluginEndIndex < 0) {\n                    return (Array<Byte>(), \"\")\n                }\n                let plugin = String.fromUtf8(data[1..pluginEndIndex])\n                let authData = data[pluginEndIndex + 1 ..]\n                return (authData, plugin)\n            case _ => \n                println(\"other, do later\")\n                return (Array<Byte>(), \"\")\n        }\n    }\n\n    private func sendEncryptedPassword(publicKey: Array<Byte>) {\n        let encrypted = ByteArrayUtils.scrambleRSA(config.password, publicKey, cipher)\n        (\"encrypted = \" + encrypted.toString())\n        writeAuthSwitchPacket(encrypted)\n    }\n\n    protected func writeCommandPacketStr(command: Byte, sql: String) {\n        sequence = 0\n        let pktLen = 1 + sql.toArray().size\n\n        let data = Array<Byte>(pktLen + 4, item: UInt8(0))\n\n        data[0] = UInt8(pktLen & 0xff)\n\t    data[1] = UInt8(pktLen >> 8)\n\t    data[2] = UInt8(pktLen >> 16)\n\t    data[3] = sequence\n\n        data[4] = command\n        sql.toArray().copyTo(data, 0, 5, sql.toArray().size)\n        writePacket(data)\n\n    }\n\n    // private func getSystemVar(name: String): Array<Byte> {\n\n    // }\n\n    protected func readColumns(count: UInt16): ArrayList<MySqlField> {\n        let returnResult = ArrayList<MySqlField>()\n        \n        for(i in 0..count) {\n            let data = readPacket()\n            var pos = 0\n            let mysqlField = MySqlField()\n            \n\n            // catalog\n            var result = ByteArrayUtils.readLengthEncodedString(data)\n            var catalog = String.fromUtf8(result[0])\n            pos += result[2]\n\n            // database\n            result = ByteArrayUtils.readLengthEncodedString(data[pos..])\n            var database = String.fromUtf8(result[0])\n            pos += result[2]\n            // tableName\n            result = ByteArrayUtils.readLengthEncodedString(data[pos..])\n            var tableName = String.fromUtf8(result[0])\n            pos += result[2]\n            mysqlField.setTableName(tableName)\n            \n            // org_table\n            result = ByteArrayUtils.readLengthEncodedString(data[pos..])\n            var orgTableName = String.fromUtf8(result[0])\n            pos += result[2]\n\n            // name\n            result = ByteArrayUtils.readLengthEncodedString(data[pos..])\n            var name = String.fromUtf8(result[0])\n            pos += result[2]\n            mysqlField.setName(name)\n\n            // org_name\n            result = ByteArrayUtils.readLengthEncodedString(data[pos..])\n            var orgName = String.fromUtf8(result[0])\n            pos += result[2]\n            // filter\n            pos ++\n\n            mysqlField.setCharSet(data[pos])\n            pos += 2\n\n            mysqlField.setLength(ByteArrayUtils.littleEndianUint32(data[pos..pos + 4]))\n            pos += 4\n\n            mysqlField.setFieldType(UInt16(data[pos]))\n            pos ++\n\n            mysqlField.setFlags(ByteArrayUtils.littleEndianUint16(data[pos .. pos + 2]))\n            pos += 2\n\n            mysqlField.setDecimals(data[pos])\n            returnResult.append(mysqlField)\n        }\n\n        let data = readPacket()\n        // match(data[0]) {\n        //     case 254 => println(\"read end\")\n        //     case _ => println(\"error, do later\")\n        // }\n        return returnResult\n    }\n\n    protected func readRows():ArrayList<Array<Byte>> {\n        let result = ArrayList<Array<Byte>>()\n        while(true) {\n            let data = readPacket()\n            match(data[0]) {\n                case 254 =>\n                    break\n                case _ =>\n                    result.append(data)\n            }\n        }\n        return result\n    }\n\n\n\n\n    protected func readPacket(): Array<Byte> {\n        let data = buffer.readNext(4)\n        let pktLen = Int64(UInt32(data[0]) | UInt32(data[1])<<8 | UInt32(data[2])<<16)\n        if (data[3] != sequence) {\n            println(\"ERROR sequence NOT EQUAL\")\n        }\n        sequence ++\n\n        let resultData = buffer.readNext(pktLen)\n        if (pktLen < maxPacketSize) {\n            return resultData\n        }\n        let resultData2 = readPacket()\n        return resultData.concat(resultData2)\n    }\n\n    protected func readUntilEOF(): Array<Byte> {\n        let result = ArrayList<Byte>()\n        while (true) {\n            let tempData = readPacket()\n            match(tempData[0]) {\n                case 254 => break\n                case 255 => println(\"error happen, do later\")\n                case _ => result.appendAll(tempData)\n            }\n        }\n        return result.toArray()\n    }\n\n    protected func writePacket(data: Array<Byte>) {\n        // TODO 拆包发送\n        // if (data.size - 4 <= maxWriteSize) {\n        try {\n            this.tcpSocket.write(data)\n            sequence ++\n        } catch (e: SocketException) {\n            println(\"send fail \" + e.message)\n        } finally {\n            // println(\"send success\")\n        }\n        // } \n        // splitPacket(data)\n    }\n}", "llm_cg": {"main": [], "MysqlConnection": ["tcpSocket.connect", "Buffer", "ipv4.SocketKeepAliveConfig", "ByteArrayUtils.indexByte", "ByteArrayUtils.littleEndianUint16", "ByteArrayUtils.scrambleCachingSha2", "ByteArrayUtils.appendLengthEncodedInteger", "String.fromUtf8", "ByteArrayUtils.concat", "ByteArrayUtils.indexByte", "ByteArrayUtils.readLengthEncodedString", "ByteArrayUtils.littleEndianUint32", "ByteArrayUtils.size", "readInitPacket", "writeAuthPacket", "handleAuthResult", "PacketQueue", "Buffer", "println"], "MysqlConnection.init": ["TcpSocket", "IPSocketAddress.parse", "SocketKeepAliveConfig", "socket.connect", "Buffer", "readInitPacket", "writeAuthPacket", "handleAuthResult"], "MysqlConnection.getMetaData": ["HashMap"], "MysqlConnection.createTransaction": [], "MysqlConnection.state.get": [], "MysqlConnection.close": [], "MysqlConnection.isClosed": [], "MysqlConnection.prepareStatement": ["MySqlStatement"], "MysqlConnection.readInitPacket": ["readPacket", "ByteArrayUtils.indexByte", "ByteArrayUtils.concat", "String.fromUtf8"], "MysqlConnection.writeAuthPacket": ["ByteArrayUtils.scrambleCachingSha2", "ByteArrayUtils.appendLengthEncodedInteger", "writePacket"], "MysqlConnection.handleAuthResult": ["readAuthResult", "ByteArrayUtils.scrambleCachingSha2", "writeAuthSwitchPacket", "readAuthResult", "<builtin>.match", "Array", "writePacket", "readPacket", "sendEncryptedPassword", "<builtin>.println"], "MysqlConnection.writeAuthSwitchPacket": ["writePacket"], "MysqlConnection.readAuthResult": ["readPacket", "ByteArrayUtils.indexByte", "String.fromUtf8", "<builtin>.match", "<builtin>.println"], "MysqlConnection.sendEncryptedPassword": ["ByteArrayUtils.scrambleRSA", "writeAuthSwitchPacket"], "MysqlConnection.writeCommandPacketStr": ["writePacket"], "MysqlConnection.readColumns": ["readPacket", "String.fromUtf8", "mysqlField.setTableName", "mysqlField.setName", "mysqlField.setCharSet", "ByteArrayUtils.littleEndianUint32", "mysqlField.setLength", "mysqlField.setFieldType", "ByteArrayUtils.littleEndianUint16", "mysqlField.setFlags", "mysqlField.setDecimals", "readPacket", "<builtin>.match", "<builtin>.println"], "MysqlConnection.readRows": ["readPacket", "<builtin>.match", "<builtin>.println"], "MysqlConnection.readPacket": ["buffer.readNext", "<builtin>.println", "readPacket", "ByteArrayUtils.concat"], "MysqlConnection.readUntilEOF": ["readPacket", "<builtin>.match", "<builtin>.println"], "MysqlConnection.writePacket": ["tcpSocket.write", "<builtin>.println"]}, "static_cg": {}}
{"source_code": "// 测试 Windows API\n// 仓颉语言团队 刘俊杰 2024.11.04\n\nunsafe main() {\n    let instance = GetModuleHandleA(EMPTY_STRING)\n    // 注册窗口类\n    let className = LibC.mallocCString('Cangjie Window')\n    var windowClass = WNDCLASSEX(lpszClassName: className,\n        hInstance: instance,\n        lpfnWndProc: onMessage,\n        hbrBackground: CreateSolidBrush(0x0095D6C0) // 中国传统色 欧碧\n    )\n    if (RegisterClassExA(inout windowClass) == 0) {\n        println('RegisterClass Failed: ${GetLastError()}')\n        return\n    }\n    // 创建窗口实例\n    let windowName = LibC.mallocCString('Cangjie')\n    let window = CreateWindowExA(\n        0,                                   // 扩展样式\n        className,                           // 窗口类名\n        windowName,                          // 窗口标题\n        WS_OVERLAPPEDWINDOW,                 // 窗口风格\n        CW_USEDEFAULT, CW_USEDEFAULT,        // 窗口位置\n        640, 480,                            // 窗口大小\n        NULL,                                // 父窗口句柄\n        NULL,                                // 菜单句柄\n        instance,                            // 实例句柄\n        NULL                                 // 附加参数\n    )\n    if (window.isNull()) {\n        println('CreateWindow Failed: ${GetLastError()}')\n        return\n    }\n    // 显示窗口\n    ShowWindow(window, SW_SHOWNORMAL)\n    UpdateWindow(window)\n    // 启动消息循环\n    var message = MSG()\n    while (GetMessageA(inout message, NULL, 0, 0)) {\n        TranslateMessage(inout message)\n        DispatchMessageA(inout message)\n    }\n    // 退出消息循环\n    println('Out of Message Loop')\n    LibC.free(className)\n    LibC.free(windowName)\n}\n\n@C\n@CallingConv[STDCALL]\nfunc onMessage(hWnd: Handle, msg: UInt32, wParam: UIntNative, lParam: UIntNative): Int64 {\n    var result = 0\n    const VK_ESCAPE: UInt16 = 0x1B\n    if (msg == WM_KEYDOWN && wParam == UIntNative(VK_ESCAPE)) {\n        unsafe { DestroyWindow(hWnd) }\n    } else if (msg == WM_DESTROY) {\n        unsafe { PostQuitMessage(0) }\n    }\n    result = unsafe { DefWindowProcA(hWnd, msg, wParam, lParam) }\n    return result\n}", "llm_cg": {"entry": []}, "static_cg": {}}
{"source_code": "// Windows 相关数据结构和接口声明\n// 仓颉语言团队 刘俊杰 2024.11.04\n\ntype Handle = CPointer<Unit>\ntype WindowProc = CFunc<(Handle, UInt32, UIntNative, UIntNative) -> Int64>\nlet NULL = Handle()\nlet EMPTY_STRING = CString(CPointer<UInt8>())\n\n@C\nstruct WNDCLASSEX {\n    public WNDCLASSEX(\n        let cbSize!: UInt32 = UInt32(sizeOf<WNDCLASSEX>()),\n        let style!: UInt32 = CS_HREDRAW | CS_VREDRAW,\n        let lpfnWndProc!: WindowProc = DefWindowProcA,\n        let cbClsExtra!: Int32 = 0,\n        let cbWndExtra!: Int32 = 0,\n        let hInstance!: Handle = NULL,\n        let hIcon!: Handle = NULL,\n        let hCursor!: Handle = NULL,\n        let hbrBackground!: Handle = NULL,\n        let lpszMenuName!: CString = EMPTY_STRING,\n        let lpszClassName!: CString = EMPTY_STRING,\n        let hIconSm!: Handle = NULL\n    ) {}\n}\n\n@C\nstruct POINT {\n    public var x: Int32 = 0\n    public var y: Int32 = 0\n}\n\n@C\nstruct MSG {\n    public MSG(\n        let hWnd!: Handle = NULL,\n        let message!: UInt32 = 0,\n        let wParam!: UInt16 = 0,\n        let lParam!: UInt32 = 0,\n        let time!: UInt32 = 0,\n        let pt!: POINT = POINT(),\n        let lPrivate!: UInt32 = 0\n    ) {}\n}\n\nforeign func CreateWindowExA(\n    dwExStyle: UInt32,\n    lpClassName: CString,\n    lpWindowName: CString,\n    dwStyle: UInt32,\n    x: UInt32, y: UInt32,\n    nWidth: UInt32, nHeight: UInt32,\n    hWndParent: Handle,\n    hMenu: Handle,\n    hInstance: Handle,\n    lpParam: Handle\n): Handle\n\nforeign func RegisterClassExA(winClass: CPointer<WNDCLASSEX>): UInt16\nforeign func ShowWindow(hWnd: Handle, nCmdShow: Int32): Bool\nforeign func UpdateWindow(hWnd: Handle): Bool\nforeign func GetMessageA(lpMsg: CPointer<MSG>, hWnd: Handle,\n    wMsgFilterMin: UInt32, wMsgFilterMax: UInt32): Bool\nforeign func TranslateMessage(lpMsg: CPointer<MSG>): Bool\nforeign func DispatchMessageA(lpMsg: CPointer<MSG>): UInt64\nforeign func PostQuitMessage(nExitCode: Int32): Unit\nforeign func DestroyWindow(hWnd: Handle): Bool\nforeign func DefWindowProcA(hWnd: Handle, msg: UInt32,\n    wParam: UIntNative, lParam: UIntNative): Int64\nforeign func GetModuleHandleA(lpModuleName: CString): Handle\nforeign func GetLastError(): UInt32\nforeign func CreateSolidBrush(color: UInt32): Handle", "llm_cg": {"main": [], "WNDCLASSEX": ["<builtin>.sizeOf"], "POINT": [], "MSG": [], "CreateWindowExA": [], "RegisterClassExA": [], "ShowWindow": [], "UpdateWindow": [], "GetMessageA": [], "TranslateMessage": [], "DispatchMessageA": [], "PostQuitMessage": [], "DestroyWindow": [], "DefWindowProcA": [], "GetModuleHandleA": [], "GetLastError": [], "CreateSolidBrush": []}, "static_cg": {}}
{"source_code": "// Windows 编程相关常量，取值参考 Windows SDK 10.0.22000.0\nconst CS_VREDRAW: UInt32 = 0x0001\nconst CS_HREDRAW: UInt32 = 0x0002\nconst CS_DBLCLKS: UInt32 = 0x0008\nconst CS_OWNDC: UInt32 = 0x0020\nconst CS_CLASSDC: UInt32 = 0x0040\nconst CS_PARENTDC: UInt32 = 0x0080\nconst CS_NOCLOSE: UInt32 = 0x0200\nconst CS_SAVEBITS: UInt32 = 0x0800\nconst CS_BYTEALIGNCLIENT: UInt32 = 0x1000\nconst CS_BYTEALIGNWINDOW: UInt32 = 0x2000\nconst CS_GLOBALCLASS: UInt32 = 0x4000\n\nconst SW_HIDE: Int32 = 0\nconst SW_SHOWNORMAL: Int32 = 1\nconst SW_NORMAL: Int32 = 1\nconst SW_SHOWMINIMIZED: Int32 = 2\nconst SW_SHOWMAXIMIZED: Int32 = 3\nconst SW_MAXIMIZE: Int32 = 3\nconst SW_SHOWNOACTIVATE: Int32 = 4\nconst SW_SHOW: Int32 = 5\nconst SW_MINIMIZE: Int32 = 6\nconst SW_SHOWMINNOACTIVE: Int32 = 7\nconst SW_SHOWNA: Int32 = 8\nconst SW_RESTORE: Int32 = 9\nconst SW_SHOWDEFAULT: Int32 = 10\nconst SW_FORCEMINIMIZE: Int32 = 11\nconst SW_MAX: Int32 = 11\n\nconst CW_USEDEFAULT: UInt32 = 0x80000000\n\nconst WS_OVERLAPPED: UInt32 = 0x00000000\nconst WS_POPUP: UInt32 = 0x80000000\nconst WS_CHILD: UInt32 = 0x40000000\nconst WS_MINIMIZE: UInt32 = 0x20000000\nconst WS_VISIBLE: UInt32 = 0x10000000\nconst WS_DISABLED: UInt32 = 0x08000000\nconst WS_CLIPSIBLINGS: UInt32 = 0x04000000\nconst WS_CLIPCHILDREN: UInt32 = 0x02000000\nconst WS_MAXIMIZE: UInt32 = 0x01000000\nconst WS_CAPTION: UInt32 = 0x00C00000\nconst WS_BORDER: UInt32 = 0x00800000\nconst WS_DLGFRAME: UInt32 = 0x00400000\nconst WS_VSCROLL: UInt32 = 0x00200000\nconst WS_HSCROLL: UInt32 = 0x00100000\nconst WS_SYSMENU: UInt32 = 0x00080000\nconst WS_THICKFRAME: UInt32 = 0x00040000\nconst WS_GROUP: UInt32 = 0x00020000\nconst WS_TABSTOP: UInt32 = 0x00010000\nconst WS_MINIMIZEBOX: UInt32 = 0x00020000\nconst WS_MAXIMIZEBOX: UInt32 = 0x00010000\nconst WS_OVERLAPPEDWINDOW = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU |\n    WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX\nconst WS_POPUPWINDOW = WS_POPUP | WS_BORDER | WS_SYSMENU\n\nconst COLOR_SCROLLBAR: UInt64 = 0\nconst COLOR_BACKGROUND: UInt64 = 1\nconst COLOR_ACTIVECAPTION: UInt64 = 2\nconst COLOR_INACTIVECAPTION: UInt64 = 3\nconst COLOR_MENU: UInt64 = 4\nconst COLOR_WINDOW: UInt64 = 5\nconst COLOR_WINDOWFRAME: UInt64 = 6\nconst COLOR_MENUTEXT: UInt64 = 7\nconst COLOR_WINDOWTEXT: UInt64 = 8\nconst COLOR_CAPTIONTEXT: UInt64 = 9\nconst COLOR_ACTIVEBORDER: UInt64 = 10\nconst COLOR_INACTIVEBORDER: UInt64 = 11\nconst COLOR_APPWORKSPACE: UInt64 = 12\nconst COLOR_HIGHLIGHT: UInt64 = 13\nconst COLOR_HIGHLIGHTTEXT: UInt64 = 14\nconst COLOR_BTNFACE: UInt64 = 15\nconst COLOR_BTNSHADOW: UInt64 = 16\nconst COLOR_GRAYTEXT: UInt64 = 17\nconst COLOR_BTNTEXT: UInt64 = 18\nconst COLOR_INACTIVECAPTIONTEXT: UInt64 = 19\nconst COLOR_BTNHIGHLIGHT: UInt64 = 20\n\n// WinUser.h 头文件中使用条件宏定义，兼容低版本 Windows 消息\n// 本程序中暂不考虑低版本兼容，取 Windows 10 及以上版本支持的部分窗口消息\nconst WM_NULL: UInt32 = 0x0000\nconst WM_CREATE: UInt32 = 0x0001\nconst WM_DESTROY: UInt32 = 0x0002\nconst WM_MOVE: UInt32 = 0x0003\nconst WM_SIZE: UInt32 = 0x0005\nconst WM_ACTIVATE: UInt32 = 0x0006\nconst WM_SETFOCUS: UInt32 = 0x0007\nconst WM_KILLFOCUS: UInt32 = 0x0008\nconst WM_ENABLE: UInt32 = 0x000A\nconst WM_SETREDRAW: UInt32 = 0x000B\nconst WM_SETTEXT: UInt32 = 0x000C\nconst WM_GETTEXT: UInt32 = 0x000D\nconst WM_GETTEXTLENGTH: UInt32 = 0x000E\nconst WM_PAINT: UInt32 = 0x000F\nconst WM_CLOSE: UInt32 = 0x0010\nconst WM_QUERYENDSESSION: UInt32 = 0x0011\nconst WM_QUERYOPEN: UInt32 = 0x0013\nconst WM_ENDSESSION: UInt32 = 0x0016\nconst WM_QUIT: UInt32 = 0x0012\nconst WM_ERASEBKGND: UInt32 = 0x0014\nconst WM_SYSCOLORCHANGE: UInt32 = 0x0015\nconst WM_SHOWWINDOW: UInt32 = 0x0018\nconst WM_WININICHANGE: UInt32 = 0x001A\nconst WM_SETTINGCHANGE: UInt32 = 0x001A\nconst WM_DEVMODECHANGE: UInt32 = 0x001B\nconst WM_ACTIVATEAPP: UInt32 = 0x001C\nconst WM_FONTCHANGE: UInt32 = 0x001D\nconst WM_TIMECHANGE: UInt32 = 0x001E\nconst WM_CANCELMODE: UInt32 = 0x001F\nconst WM_SETCURSOR: UInt32 = 0x0020\nconst WM_MOUSEACTIVATE: UInt32 = 0x0021\nconst WM_CHILDACTIVATE: UInt32 = 0x0022\nconst WM_QUEUESYNC: UInt32 = 0x0023\nconst WM_GETMINMAXINFO: UInt32 = 0x0024\nconst WM_PAINTICON: UInt32 = 0x0026\nconst WM_ICONERASEBKGND: UInt32 = 0x0027\nconst WM_NEXTDLGCTL: UInt32 = 0x0028\nconst WM_SPOOLERSTATUS: UInt32 = 0x002A\nconst WM_DRAWITEM: UInt32 = 0x002B\nconst WM_MEASUREITEM: UInt32 = 0x002C\nconst WM_DELETEITEM: UInt32 = 0x002D\nconst WM_VKEYTOITEM: UInt32 = 0x002E\nconst WM_CHARTOITEM: UInt32 = 0x002F\nconst WM_SETFONT: UInt32 = 0x0030\nconst WM_GETFONT: UInt32 = 0x0031\nconst WM_SETHOTKEY: UInt32 = 0x0032\nconst WM_GETHOTKEY: UInt32 = 0x0033\nconst WM_QUERYDRAGICON: UInt32 = 0x0037\nconst WM_COMPAREITEM: UInt32 = 0x0039\nconst WM_GETOBJECT: UInt32 = 0x003D\nconst WM_COMPACTING: UInt32 = 0x0041\nconst WM_COMMNOTIFY: UInt32 = 0x0044\nconst WM_WINDOWPOSCHANGING: UInt32 = 0x0046\nconst WM_WINDOWPOSCHANGED: UInt32 = 0x0047\nconst WM_POWER: UInt32 = 0x0048\nconst WM_COPYDATA: UInt32 = 0x004A\nconst WM_CANCELJOURNAL: UInt32 = 0x004B\nconst WM_NOTIFY: UInt32 = 0x004E\nconst WM_INPUTLANGCHANGEREQUEST: UInt32 = 0x0050\nconst WM_INPUTLANGCHANGE: UInt32 = 0x0051\nconst WM_TCARD: UInt32 = 0x0052\nconst WM_HELP: UInt32 = 0x0053\nconst WM_USERCHANGED: UInt32 = 0x0054\nconst WM_NOTIFYFORMAT: UInt32 = 0x0055\nconst WM_CONTEXTMENU: UInt32 = 0x007B\nconst WM_STYLECHANGING: UInt32 = 0x007C\nconst WM_STYLECHANGED: UInt32 = 0x007D\nconst WM_DISPLAYCHANGE: UInt32 = 0x007E\nconst WM_GETICON: UInt32 = 0x007F\nconst WM_SETICON: UInt32 = 0x0080\nconst WM_NCCREATE: UInt32 = 0x0081\nconst WM_NCDESTROY: UInt32 = 0x0082\nconst WM_NCCALCSIZE: UInt32 = 0x0083\nconst WM_NCHITTEST: UInt32 = 0x0084\nconst WM_NCPAINT: UInt32 = 0x0085\nconst WM_NCACTIVATE: UInt32 = 0x0086\nconst WM_GETDLGCODE: UInt32 = 0x0087\nconst WM_SYNCPAINT: UInt32 = 0x0088\nconst WM_NCMOUSEMOVE: UInt32 = 0x00A0\nconst WM_NCLBUTTONDOWN: UInt32 = 0x00A1\nconst WM_NCLBUTTONUP: UInt32 = 0x00A2\nconst WM_NCLBUTTONDBLCLK: UInt32 = 0x00A3\nconst WM_NCRBUTTONDOWN: UInt32 = 0x00A4\nconst WM_NCRBUTTONUP: UInt32 = 0x00A5\nconst WM_NCRBUTTONDBLCLK: UInt32 = 0x00A6\nconst WM_NCMBUTTONDOWN: UInt32 = 0x00A7\nconst WM_NCMBUTTONUP: UInt32 = 0x00A8\nconst WM_NCMBUTTONDBLCLK: UInt32 = 0x00A9\nconst WM_NCXBUTTONDOWN: UInt32 = 0x00AB\nconst WM_NCXBUTTONUP: UInt32 = 0x00AC\nconst WM_NCXBUTTONDBLCLK: UInt32 = 0x00AD\nconst WM_INPUT_DEVICE_CHANGE: UInt32 = 0x00FE\nconst WM_INPUT: UInt32 = 0x00FF\nconst WM_KEYFIRST: UInt32 = 0x0100\nconst WM_KEYDOWN: UInt32 = 0x0100\nconst WM_KEYUP: UInt32 = 0x0101\nconst WM_CHAR: UInt32 = 0x0102\nconst WM_DEADCHAR: UInt32 = 0x0103\nconst WM_SYSKEYDOWN: UInt32 = 0x0104\nconst WM_SYSKEYUP: UInt32 = 0x0105\nconst WM_SYSCHAR: UInt32 = 0x0106\nconst WM_SYSDEADCHAR: UInt32 = 0x0107\nconst WM_UNICHAR: UInt32 = 0x0109\nconst WM_KEYLAST: UInt32 = 0x0109\nconst UNICODE_NOCHAR: UInt32 = 0xFFFF\nconst WM_IME_STARTCOMPOSITION: UInt32 = 0x010D\nconst WM_IME_ENDCOMPOSITION: UInt32 = 0x010E\nconst WM_IME_COMPOSITION: UInt32 = 0x010F\nconst WM_IME_KEYLAST: UInt32 = 0x010F\nconst WM_INITDIALOG: UInt32 = 0x0110\nconst WM_COMMAND: UInt32 = 0x0111\nconst WM_SYSCOMMAND: UInt32 = 0x0112\nconst WM_TIMER: UInt32 = 0x0113\nconst WM_HSCROLL: UInt32 = 0x0114\nconst WM_VSCROLL: UInt32 = 0x0115\nconst WM_INITMENU: UInt32 = 0x0116\nconst WM_INITMENUPOPUP: UInt32 = 0x0117\nconst WM_GESTURE: UInt32 = 0x0119\nconst WM_GESTURENOTIFY: UInt32 = 0x011A\nconst WM_MENUSELECT: UInt32 = 0x011F\nconst WM_MENUCHAR: UInt32 = 0x0120\nconst WM_ENTERIDLE: UInt32 = 0x0121\nconst WM_MENURBUTTONUP: UInt32 = 0x0122\nconst WM_MENUDRAG: UInt32 = 0x0123\nconst WM_MENUGETOBJECT: UInt32 = 0x0124\nconst WM_UNINITMENUPOPUP: UInt32 = 0x0125\nconst WM_MENUCOMMAND: UInt32 = 0x0126\nconst WM_CHANGEUISTATE: UInt32 = 0x0127\nconst WM_UPDATEUISTATE: UInt32 = 0x0128\nconst WM_QUERYUISTATE: UInt32 = 0x0129\nconst WM_CTLCOLORMSGBOX: UInt32 = 0x0132\nconst WM_CTLCOLOREDIT: UInt32 = 0x0133\nconst WM_CTLCOLORLISTBOX: UInt32 = 0x0134\nconst WM_CTLCOLORBTN: UInt32 = 0x0135\nconst WM_CTLCOLORDLG: UInt32 = 0x0136\nconst WM_CTLCOLORSCROLLBAR: UInt32 = 0x0137\nconst WM_CTLCOLORSTATIC: UInt32 = 0x0138\nconst MN_GETHMENU: UInt32 = 0x01E1\nconst WM_MOUSEFIRST: UInt32 = 0x0200\nconst WM_MOUSEMOVE: UInt32 = 0x0200\nconst WM_LBUTTONDOWN: UInt32 = 0x0201\nconst WM_LBUTTONUP: UInt32 = 0x0202\nconst WM_LBUTTONDBLCLK: UInt32 = 0x0203\nconst WM_RBUTTONDOWN: UInt32 = 0x0204\nconst WM_RBUTTONUP: UInt32 = 0x0205\nconst WM_RBUTTONDBLCLK: UInt32 = 0x0206\nconst WM_MBUTTONDOWN: UInt32 = 0x0207\nconst WM_MBUTTONUP: UInt32 = 0x0208\nconst WM_MBUTTONDBLCLK: UInt32 = 0x0209\nconst WM_MOUSEWHEEL: UInt32 = 0x020A\nconst WM_XBUTTONDOWN: UInt32 = 0x020B\nconst WM_XBUTTONUP: UInt32 = 0x020C\nconst WM_XBUTTONDBLCLK: UInt32 = 0x020D\nconst WM_MOUSEHWHEEL: UInt32 = 0x020E\nconst WM_MOUSELAST: UInt32 = 0x020E\nconst WM_PARENTNOTIFY: UInt32 = 0x0210\nconst WM_ENTERMENULOOP: UInt32 = 0x0211\nconst WM_EXITMENULOOP: UInt32 = 0x0212\nconst WM_NEXTMENU: UInt32 = 0x0213\nconst WM_SIZING: UInt32 = 0x0214\nconst WM_CAPTURECHANGED: UInt32 = 0x0215\nconst WM_MOVING: UInt32 = 0x0216\nconst WM_POWERBROADCAST: UInt32 = 0x0218\nconst WM_DEVICECHANGE: UInt32 = 0x0219\nconst WM_MDICREATE: UInt32 = 0x0220\nconst WM_MDIDESTROY: UInt32 = 0x0221\nconst WM_MDIACTIVATE: UInt32 = 0x0222\nconst WM_MDIRESTORE: UInt32 = 0x0223\nconst WM_MDINEXT: UInt32 = 0x0224\nconst WM_MDIMAXIMIZE: UInt32 = 0x0225\nconst WM_MDITILE: UInt32 = 0x0226\nconst WM_MDICASCADE: UInt32 = 0x0227\nconst WM_MDIICONARRANGE: UInt32 = 0x0228\nconst WM_MDIGETACTIVE: UInt32 = 0x0229\nconst WM_MDISETMENU: UInt32 = 0x0230\nconst WM_ENTERSIZEMOVE: UInt32 = 0x0231\nconst WM_EXITSIZEMOVE: UInt32 = 0x0232\nconst WM_DROPFILES: UInt32 = 0x0233\nconst WM_MDIREFRESHMENU: UInt32 = 0x0234\nconst WM_POINTERDEVICECHANGE: UInt32 = 0x238\nconst WM_POINTERDEVICEINRANGE: UInt32 = 0x239\nconst WM_POINTERDEVICEOUTOFRANGE: UInt32 = 0x23A\nconst WM_TOUCH: UInt32 = 0x0240\nconst WM_NCPOINTERUPDATE: UInt32 = 0x0241\nconst WM_NCPOINTERDOWN: UInt32 = 0x0242\nconst WM_NCPOINTERUP: UInt32 = 0x0243\nconst WM_POINTERUPDATE: UInt32 = 0x0245\nconst WM_POINTERDOWN: UInt32 = 0x0246\nconst WM_POINTERUP: UInt32 = 0x0247\nconst WM_POINTERENTER: UInt32 = 0x0249\nconst WM_POINTERLEAVE: UInt32 = 0x024A\nconst WM_POINTERACTIVATE: UInt32 = 0x024B\nconst WM_POINTERCAPTURECHANGED: UInt32 = 0x024C\nconst WM_TOUCHHITTESTING: UInt32 = 0x024D\nconst WM_POINTERWHEEL: UInt32 = 0x024E\nconst WM_POINTERHWHEEL: UInt32 = 0x024F\nconst DM_POINTERHITTEST: UInt32 = 0x0250\nconst WM_POINTERROUTEDTO: UInt32 = 0x0251\nconst WM_POINTERROUTEDAWAY: UInt32 = 0x0252\nconst WM_POINTERROUTEDRELEASED: UInt32 = 0x0253\nconst WM_IME_SETCONTEXT: UInt32 = 0x0281\nconst WM_IME_NOTIFY: UInt32 = 0x0282\nconst WM_IME_CONTROL: UInt32 = 0x0283\nconst WM_IME_COMPOSITIONFULL: UInt32 = 0x0284\nconst WM_IME_SELECT: UInt32 = 0x0285\nconst WM_IME_CHAR: UInt32 = 0x0286\nconst WM_IME_REQUEST: UInt32 = 0x0288\nconst WM_IME_KEYDOWN: UInt32 = 0x0290\nconst WM_IME_KEYUP: UInt32 = 0x0291\nconst WM_MOUSEHOVER: UInt32 = 0x02A1\nconst WM_MOUSELEAVE: UInt32 = 0x02A3\nconst WM_NCMOUSEHOVER: UInt32 = 0x02A0\nconst WM_NCMOUSELEAVE: UInt32 = 0x02A2\nconst WM_WTSSESSION_CHANGE: UInt32 = 0x02B1\nconst WM_TABLET_FIRST: UInt32 = 0x02c0\nconst WM_TABLET_LAST: UInt32 = 0x02df\nconst WM_DPICHANGED: UInt32 = 0x02E0\nconst WM_DPICHANGED_BEFOREPARENT: UInt32 = 0x02E2\nconst WM_DPICHANGED_AFTERPARENT: UInt32 = 0x02E3\nconst WM_GETDPISCALEDSIZE: UInt32 = 0x02E4\nconst WM_CUT: UInt32 = 0x0300\nconst WM_COPY: UInt32 = 0x0301\nconst WM_PASTE: UInt32 = 0x0302\nconst WM_CLEAR: UInt32 = 0x0303\nconst WM_UNDO: UInt32 = 0x0304\nconst WM_RENDERFORMAT: UInt32 = 0x0305\nconst WM_RENDERALLFORMATS: UInt32 = 0x0306\nconst WM_DESTROYCLIPBOARD: UInt32 = 0x0307\nconst WM_DRAWCLIPBOARD: UInt32 = 0x0308\nconst WM_PAINTCLIPBOARD: UInt32 = 0x0309\nconst WM_VSCROLLCLIPBOARD: UInt32 = 0x030A\nconst WM_SIZECLIPBOARD: UInt32 = 0x030B\nconst WM_ASKCBFORMATNAME: UInt32 = 0x030C\nconst WM_CHANGECBCHAIN: UInt32 = 0x030D\nconst WM_HSCROLLCLIPBOARD: UInt32 = 0x030E\nconst WM_QUERYNEWPALETTE: UInt32 = 0x030F\nconst WM_PALETTEISCHANGING: UInt32 = 0x0310\nconst WM_PALETTECHANGED: UInt32 = 0x0311\nconst WM_HOTKEY: UInt32 = 0x0312\nconst WM_PRINT: UInt32 = 0x0317\nconst WM_PRINTCLIENT: UInt32 = 0x0318\nconst WM_APPCOMMAND: UInt32 = 0x0319\nconst WM_THEMECHANGED: UInt32 = 0x031A\nconst WM_CLIPBOARDUPDATE: UInt32 = 0x031D\nconst WM_DWMCOMPOSITIONCHANGED: UInt32 = 0x031E\nconst WM_DWMNCRENDERINGCHANGED: UInt32 = 0x031F\nconst WM_DWMCOLORIZATIONCOLORCHANGED: UInt32 = 0x0320\nconst WM_DWMWINDOWMAXIMIZEDCHANGE: UInt32 = 0x0321\nconst WM_DWMSENDICONICTHUMBNAIL: UInt32 = 0x0323\nconst WM_DWMSENDICONICLIVEPREVIEWBITMAP: UInt32 = 0x0326\nconst WM_GETTITLEBARINFOEX: UInt32 = 0x033F\nconst WM_HANDHELDFIRST: UInt32 = 0x0358\nconst WM_HANDHELDLAST: UInt32 = 0x035F\nconst WM_AFXFIRST: UInt32 = 0x0360\nconst WM_AFXLAST: UInt32 = 0x037F\nconst WM_PENWINFIRST: UInt32 = 0x0380\nconst WM_PENWINLAST: UInt32 = 0x038F\nconst WM_APP: UInt32 = 0x8000\nconst WM_USER: UInt32 = 0x0400\n", "llm_cg": {"main": []}, "static_cg": {}}
{"source_code": "// 群聊程序-服务器\n// 仓颉语言团队 刘俊杰 2024/10/21\nimport std.net.*\nimport std.time.*\nimport std.sync.*\nimport std.collection.*\nimport std.collection.concurrent.*\nimport std.console.*\n\nconst PORT: UInt16 = 24621\nconst BUFFER_SIZE = 1024\nvar g_quit = false\n\n// 从控制台读取退出命令\nfunc controller() {\n    spawn {\n        while (!g_quit) {\n            let key = Console.stdIn.read().getOrDefault {r' '}\n            if (key == r'q' || key == r'Q') {\n                g_quit = true\n            }\n        }\n    }\n}\n\nextend TcpSocket {\n    public func tryWrite(data: Array<Byte>) {\n        try { this.write(data) } catch (e: SocketException) {\n            if (!this.isClosed()) { this.close() }\n            return false\n        }\n        return true\n    }\n}\n\nmain() {\n    let messageQueue = NonBlockingQueue<(TcpSocket, Array<Byte>)>()\n    let members = LinkedList<TcpSocket>() // 群聊成员/客户端\n    let server = TcpServerSocket(bindAt: PORT) // 服务端\n    server.bind()\n    controller()\n\n    // 和新的客户端建立连接\n    let mutex = ReentrantMutex()\n    let monitor = Monitor()\n    spawn {\n        while (!g_quit) {\n            let client = server.accept()\n            synchronized (mutex) {\n                members.append(client)\n            }\n            // 每个连接要处理的任务\n            spawn {\n                while (!g_quit) {\n                    let data = Array<Byte>(BUFFER_SIZE, repeat: 0)\n                    try { client.read(data) } catch (e: SocketException) {\n                        return // 遇到异常终止此线程，由转发线程清理资源\n                    }\n                    println(String.fromUtf8(data))\n                    messageQueue.enqueue((client, data))\n                    synchronized (monitor) { monitor.notify() }\n                }\n            }\n        }\n    }\n\n    // 转发消息到所有客户端，实现群聊\n    while (!g_quit) {\n        // 我们使用了并发数据结构，这里 Monitor 不必保护数据，仅用于避免当前 while 空转\n        synchronized (monitor) {\n            monitor.wait(timeout: 100 * Duration.millisecond)            \n        }\n        while (let Some((client, data)) <- messageQueue.dequeue()) {\n            mutex.lock()\n            // 遍历群聊成员，转发消息并清理无效客户端\n            members.removeIf { socket =>\n                if (refEq(client, socket)) { // 不必转发给消息源\n                    return false\n                }\n                !socket.tryWrite(data)\n            }\n            mutex.unlock()\n        }\n    }\n    // 退出时通知所有客户端\n    for (client in members) {\n        if (client.tryWrite(\"Server Exit\".toArray())) {\n            client.close()\n        }\n    }\n    server.close()\n}", "llm_cg": {"main": ["<builtin>.println", "controller", "messageQueue", "NonBlockingQueue", "LinkedList", "TcpServerSocket", "server.bind", "ReentrantMutex", "TcpServerSocket.accept", "synchronized", "TcpSocket.read", "String.fromUtf8", "messageQueue.enqueue", "monitor.notify", "monitor.wait", "messageQueue.dequeue", "members.removeIf", "refEq", "socket.tryWrite", "client.tryWrite", "mutex.lock", "mutex.unlock", "server.close"], "controller": ["spawn", "Console.stdIn.read", "Console.stdIn.read.getOrDefault"], "TcpSocket.tryWrite": ["this.write", "this.isClosed", "this.close"]}, "static_cg": {}}
{"source_code": "// 群聊程序-客户端\n// 仓颉语言团队 刘俊杰 2024/10/21\nimport std.net.*\nimport std.time.*\nimport std.sync.*\nimport std.console.*\n\nconst IP = \"127.0.0.1\"\nconst PORT: UInt16 = 24621\nconst BUFFER_SIZE = 1024\nvar g_quit = false\n\nmain() {\n    let socket = TcpSocket(IP, PORT)\n    socket.connect()\n    // 读取服务器发来的消息\n    spawn {\n        while (!g_quit) {\n            let data = Array<Byte>(BUFFER_SIZE, repeat: 0)\n            var count = 0\n            // 如果对端正常关闭连接，不会抛出异常，read 返回 0\n            try { count = socket.read(data) } catch (e: SocketException) {\n                g_quit = true\n            }\n            if (g_quit || count == 0) { break }\n            println(String.fromUtf8(data))\n        }\n    }\n    // 向服务器发送消息\n    while (!g_quit) {\n        let input = Console.stdIn.readln().getOrDefault {\"\\n\"}\n        try { socket.write(input.toArray()) } catch (e: SocketException) {\n            g_quit = true\n        }\n    }\n    socket.close()\n}", "llm_cg": {"main": ["TcpSocket", "socket.connect", "spawn", "g_quit", "socket.read", "println", "String.fromUtf8", "Console.stdIn.readln", "input.getOrDefault", "socket.write", "socket.close"]}, "static_cg": {}}
{"source_code": "package simple_math_interpreter\n\nimport std.convert.*\nimport simple_math_interpreter.ext.*\n\nenum Token {\n    | Value(Int)\n    | LParen\n    | RParen\n    | Plus\n    | Minus\n    | Multiply\n    | Divide\n}\n\nextend Token {\n    static func fromRunes(runes: List<Rune>): Result<List<Token>, String> {\n        match (tokensFunc(runes).map {t => t[0]}) {\n            case Some(l) => Ok(l)\n            case None => Err(\"Invalid Input!\")\n        }\n    }\n}\n\nextend Token <: ToString {\n    public func toString() {\n        match (this) {\n            case Value(n) => n.toString()\n            case LParen => \"(\"\n            case RParen => \")\"\n            case Plus => \"+\"\n            case Minus => \"-\"\n            case Multiply => \"*\"\n            case Divide => \"/\"\n        }\n    }\n}\n\nlet symbol = Combinator<Rune, Rune>.make {\n    ch => match (ch) {\n        case r'+' | r'-' | r'*' | r'/' | r'(' | r')' => true\n        case _ => false\n    }\n}.map {\n    ch: Rune => match (ch) {\n        case '+' => Plus\n        case '-' => Minus\n        case '*' => Multiply\n        case '/' => Divide\n        case '(' => LParen\n        case ')' => RParen\n        case _ => throw Exception()\n    }\n}\nlet whiteSpace = Combinator<Rune, Rune>.make {ch => ch == r' '}\nlet number = Combinator<Rune, Rune>.make {\n    ch => match (Int64.tryParse(ch.toString())) {\n        case Some(n) where n >= 0 && n <= 9 => true\n        case _ => false\n    }\n}.map {ch => Int64.parse(ch.toString())}\nlet value = number.many(1).map {\n    l => l.reduce<Int64>({acc, x => acc * 10 + x}, 0)\n}.map {v => Value(v)}\nlet tokenAndSpace = value.or(symbol).and(whiteSpace.many(1)).map {s: (Token, List<Rune>) => s[0]}\nlet token = value.or(symbol)\nlet tokens = tokenAndSpace.or(token).many(1)\n\nfunc tokensFunc(input: List<Rune>): Option<(List<Token>, List<Rune>)> {\n    tokens.parseFunc(input)\n}\n\nenum Expression {\n    | Number(Int)\n    | Plus(Expression, Expression)\n    | Minus(Expression, Expression)\n    | Multiply(Expression, Expression)\n    | Divide(Expression, Expression)\n}\n\nextend Expression {\n    static func fromTokens(tokens: List<Token>): Result<Expression, String> {\n        match (expressionFunc(tokens).map {t => t[0]}) {\n            case Some(e) => Ok(e)\n            case None => Err(\"Invalid Expression!\")\n        }\n    }\n}\n\nextend Expression {\n    func eval(): Int64 {\n        match (this) {\n            case Number(n) => n\n            case Plus(e1, e2) => e1.eval() + e2.eval()\n            case Minus(e1, e2) => e1.eval() - e2.eval()\n            case Multiply(e1, e2) => e1.eval() * e2.eval()\n            case Divide(e1, e2) => e1.eval() / e2.eval()\n        }\n    }\n}\n\nextend Expression <: ToString {\n    public func toString(): String {\n        match (this) {\n            case Number(n) => \"${n}\"\n            case Plus(e1, e2) => \"(+ ${e1} ${e2})\"\n            case Minus(e1, e2) => \"(- ${e1} ${e2})\"\n            case Multiply(e1, e2) => \"(* ${e1} ${e2})\"\n            case Divide(e1, e2) => \"(/ ${e1} ${e2})\"\n        }\n    }\n}\n\nlet eNumber = Combinator<Token, Token>.make {\n    token => match (token) {\n        case Value(_) => true\n        case _ => false\n    }\n}.map {\n    token => match (token) {\n        case Value(i) => Number(i)\n        case _ => throw Exception()\n    }\n}\nlet lparen = Combinator<Token, Token>.make {\n    token => match (token) {\n        case LParen => true\n        case _ => false\n    }\n}\nlet rparen = Combinator<Token, Token>.make {\n    token => match (token) {\n        case RParen => true\n        case _ => false\n    }\n}\nlet plus = Combinator<Token, Token>.make {\n    token => match (token) {\n        case Plus => true\n        case _ => false\n    }\n}\nlet minus = Combinator<Token, Token>.make {\n    token => match (token) {\n        case Minus => true\n        case _ => false\n    }\n}\nlet multiply = Combinator<Token, Token>.make {\n    token => match (token) {\n        case Multiply => true\n        case _ => false\n    }\n}\nlet divide = Combinator<Token, Token>.make {\n    token => match (token) {\n        case Divide => true\n        case _ => false\n    }\n}\n\nfunc atomicFunc(input: List<Token>): Option<(Expression, List<Token>)> {\n    let expression = Combinator(expressionFunc)\n    lparen.and(expression).and(rparen).map {t => t[0][1]}.or(eNumber).parseFunc(input)\n}\n\nfunc combineFunc(input: List<Token>): Option<(Expression, List<Token>)> {\n    let atomic = Combinator(atomicFunc)\n    atomic.and(multiply.or(divide).and(atomic).many(0)).map {\n        t => t[1].reduce(\n            {\n                acc, x => match ((acc, x)) {\n                    case (e1, (Multiply, e2)) => Multiply(e1, e2)\n                    case (e1, (_, e2)) => Divide(e1, e2)\n                }\n            },\n            t[0]\n        )\n    }.parseFunc(input)\n}\n\nfunc expressionFunc(input: List<Token>): Option<(Expression, List<Token>)> {\n    let combine = Combinator(combineFunc)\n    combine.and(plus.or(minus).and(combine).many(0)).map {\n        t => t[1].reduce(\n            {\n                acc, x => match ((acc, x)) {\n                    case (e1, (Plus, e2)) => Plus(e1, e2)\n                    case (e1, (_, e2)) => Minus(e1, e2)\n                }\n            },\n            t[0]\n        )\n    }.parseFunc(input)\n}\n\npublic func eval(str: String): Result<Int64, String> {\n    let runes = List<Rune>.fromArray(str.trimAscii().toRuneArray())\n    Token.fromRunes(runes).andThen(Expression.fromTokens).map {e => e.eval()}\n}\n", "llm_cg": {"main": [], "Token.fromRunes": ["tokensFunc", "std.convert.Ok", "std.convert.Err"], "Token.toString": ["std.convert.toString"], "tokensFunc": ["tokens.parseFunc"], "Expression.fromTokens": ["expressionFunc", "std.convert.Ok", "std.convert.Err"], "Expression.eval": [], "Expression.toString": ["std.convert.toString"], "atomicFunc": ["Combinator", "lparen.and", "eNumber.parseFunc"], "combineFunc": ["Combinator", "atomic.and", "multiply.or", "std.convert.reduce"], "expressionFunc": ["Combinator", "combine.and", "plus.or", "std.convert.reduce"], "eval": ["Token.fromRunes", "Expression.fromTokens", "std.convert.andThen", "std.convert.map"]}, "static_cg": {}}
{"source_code": "package simple_math_interpreter\n\nimport std.console.*\nimport simple_math_interpreter.ext.*\n\nmain() {\n    println(\n        \"\"\"\n###################################################\n##  Enter an simple math expression.             ##\n##  e.g.                                         ##\n##  3 + 2 * (99 + 101) + 7                       ##\n##  1+(1 -1) + 6* 30/9                           ##\n##                                               ##\n##  Press Ctrl + C to exit                       ##\n###################################################\n\"\"\"\n    )\n\n    while (true) {\n        Console.stdIn.readln().okOr(\"Invalid Input!\").andThen(eval).map(println).mapErr(println)\n    }\n}\n", "llm_cg": {"main": ["Console.stdIn.readln", "Console.stdIn.readln.okOr", "Console.stdIn.readln.okOr.andThen", "Console.stdIn.readln.okOr.andThen.map", "Console.stdIn.readln.okOr.andThen.mapErr", "<builtin>.println", "eval"]}, "static_cg": {}}
{"source_code": "package simple_math_interpreter\n\npublic enum List<A> {\n    | Nil\n    | Cons(A, List<A>)\n}\n\nextend<A> List<A> {\n    public static func empty(): List<A> {\n        Nil\n    }\n\n    public static func cons(hd: A, tl: List<A>): List<A> {\n        Cons(hd, tl)\n    }\n\n    public static func makeBy(n: Int64, f: (Int64) -> A): List<A> {\n        var acc = List<A>.empty()\n        for (i in 0..n) {\n            acc = acc.add(f(i))\n        }\n        acc.reverse()\n    }\n\n    public static func fromArray(arr: Array<A>): List<A> {\n        List<A>.makeBy(arr.size, {i => arr[i]})\n    }\n\n    public func add(x: A): List<A> {\n        cons(x, this)\n    }\n\n    public func reduce<B>(f: (B, A) -> B, acc: B): B {\n        var accm = acc\n        var x = this\n        while (true) {\n            match (x) {\n                case Nil => break\n                case Cons(hd, tl) =>\n                    accm = f(accm, hd)\n                    x = tl\n            }\n        }\n        accm\n    }\n\n    public func reverse(): List<A> {\n        this.reduce({acc, x => List<A>.cons(x, acc)}, Nil)\n    }\n\n    public func isEmpty(): Bool {\n        match (this) {\n            case Nil => true\n            case _ => false\n        }\n    }\n\n    public func lenth(): Int64 {\n        this.reduce({acc, _ => acc + 1}, 0)\n    }\n\n}\n\nextend<A> List<A> <: ToString where A <: ToString {\n    public func join(sp: String): String {\n        match(this) {\n            case Nil => \"\"\n            case Cons(hd, tl)=> tl.reduce<String>({ acc: String, x: A => \"${acc}${sp}${x}\" }, \"${hd}\")\n        }\n    }\n\n    public func toString() {\n        \"List: [${this.join(\",\")}]\"\n    }\n}\n", "llm_cg": {"main": [], "List.empty": [], "List.cons": [], "List.makeBy": ["List.empty", "<builtin>.add", "List.reverse"], "List.fromArray": ["List.makeBy", "<builtin>.Array.size", "<builtin>.Array.get"], "List.add": ["List.cons"], "List.reduce": ["<builtin>.match", "<builtin>.break"], "List.reverse": ["List.reduce", "List.cons"], "List.isEmpty": ["<builtin>.match"], "List.lenth": ["List.reduce", "<builtin>.add"], "List.join": ["<builtin>.match", "List.reduce"], "List.toString": ["List.join"]}, "static_cg": {}}
{"source_code": "package simple_math_interpreter\n\nimport simple_math_interpreter.ext.*\n\npublic class Combinator<I, O> {\n    public Combinator(public let parseFunc: (List<I>) -> Option<(O, List<I>)>) {}\n}\n\nextend<I, O> Combinator<I, O> {\n    public static func make(predicate: (I) -> Bool): Combinator<I, I> {\n        Combinator {\n            input => match (input) {\n                case Cons(hd, tl) => if (predicate(hd)) {\n                    Some((hd, tl))\n                } else {\n                    None\n                }\n                case Nil => None\n            }\n        }\n    }\n\n    public func map<O2>(f: (O) -> O2): Combinator<I, O2> {\n        Combinator {\n            input => match (this.parseFunc(input)) {\n                case Some((value, rest)) => Some((f(value), rest))\n                case None => None\n            }\n        }\n    }\n\n    public func and<O2>(c2: Combinator<I, O2>): Combinator<I, (O, O2)> {\n        Combinator {\n            input => match (this.parseFunc(input)) {\n                case Some((value1, rest1)) => match (c2.parseFunc(rest1)) {\n                    case Some((value2, rest2)) => Some(((value1, value2), rest2))\n                    case None => None\n                }\n                case None => None\n            }\n        }\n    }\n\n    public func or(c2: Combinator<I, O>): Combinator<I, O> {\n        Combinator {\n            input => match (this.parseFunc(input)) {\n                case Some(a) => Some(a)\n                case None => c2.parseFunc(input)\n            }\n        }\n    }\n\n    public func many(min: Int64): Combinator<I, List<O>> {\n        Combinator {\n            input =>\n            var vlist = List<O>.empty()\n            var rest = input\n            while (true) {\n                match (this.parseFunc(rest)) {\n                    case None => break\n                    case Some((value, _rest)) =>\n                        rest = _rest\n                        vlist = vlist.add(value)\n                }\n            }\n            if (vlist.lenth() < min) {\n                None\n            } else {\n                Some((vlist.reverse(), rest))\n            }\n        }\n    }\n}", "llm_cg": {"Combinator": [], "Combinator.make": ["Combinator", "Some", "None", "None"], "Combinator.map": ["Combinator", "this.parseFunc", "Some", "Some", "None"], "Combinator.and": ["Combinator", "this.parseFunc", "c2.parseFunc", "Some", "Some", "None", "None"], "Combinator.or": ["Combinator", "this.parseFunc", "Some", "c2.parseFunc"], "Combinator.many": ["Combinator", "this.parseFunc", "List.empty", "None", "Some", "vlist.add", "vlist.lenth", "Some", "vlist.reverse"]}, "static_cg": {}}
{"source_code": "package simple_math_interpreter.ext\n\npublic interface OptionExt {}\n\nextend<T> Option<T> <: OptionExt {\n    public func map<U>(f: (T) -> U): Option<U> {\n        match (this) {\n            case Some(v) => Some(f(v))\n            case None => None\n        }\n    }\n\n    public func okOr<E>(e: E): Result<T, E> {\n        match (this) {\n            case Some(v) => Ok(v)\n            case None => Err(e)\n        }\n    }\n}\n", "llm_cg": {}, "static_cg": {}}
{"source_code": "package simple_math_interpreter.ext\n\npublic enum Result<T, E> {\n    | Ok(T)\n    | Err(E)\n}\n\npublic interface ResultExt {}\n\nextend<T, E> Result<T, E> <: ResultExt {\n    public func map<U>(f: (T) -> U): Result<U, E> {\n        match (this) {\n            case Ok(v) => Ok(f(v))\n            case Err(e) => Err(e)\n        }\n    }\n\n    public func mapErr<F>(f: (E) -> F): Result<T, F> {\n        match (this) {\n            case Ok(t) => Ok(t)\n            case Err(e) => Err(f(e))\n        }\n    }\n\n    public func andThen<U>(f: (T) -> Result<U, E>): Result<U, E> {\n        match (this) {\n            case Ok(v) => f(v)\n            case Err(e) => Err(e)\n        }\n    }\n}\n", "llm_cg": {}, "static_cg": {}}
{"source_code": "/**\n * 示例场景：用仓颉语言表达魔方置换群，并进行模拟验证\n *         本例体现了仓颉在代数/符号演算方面的定制能力，以及语言的易用性和灵活性等\n * 涉及特性：enum/构造器/递归定义/模式匹配，操作符重载，接口，类型别名，递归调用，\n *         class，tuple，Array，HashMap，for-in/Range，if-let，lambda\n * 仓颉语言团队 刘俊杰 2024/7/25\n */ \nimport std.collection.*\n\nenum Rotation <: ToString & Hashable & Equatable<Rotation> {\n    // 在魔方研究中，通常用 Front/Back/Left/Right/Up/Down 表示六个面以及对应的原子操作，即正对此面顺时针旋转 90 度\n    F | B | L | R | U | D\n      | X(Rotation, Rotation) // 仓颉支持 enum 构造器和递归定义，此处 X 用于组织复合旋转操作\n      | I(Rotation) // I(r) 用于表示 r 的逆变换，即正对 r 面逆时针旋转 90 度\n\n    // enum 中也可以定义成员函数，这里我们重载 * 运算符以实现旋转操作的组合，由此可生成一个置换群\n    public operator func *(that: Rotation): Rotation {\n        match (this) {\n            case X(x1, x2) => X(x1, X(x2, that)) // 按此顺序分解重组，使得递归时按从左到右的顺序执行变换\n            case _ => X(this, that)\n        }\n    }\n\n    // 重载 ** 运算符实现幂运算，以便表示和验证高阶置换操作，如 (F*F*L*L*B*R)**90 会让魔方回归初态\n    public operator func **(exp: UInt32): Rotation {\n        var result = this\n        for (_ in 0..(exp - 1)) {\n            result = result * this\n        }\n        return result\n    }\n\n    // 实现 ToString 接口以便打印和调试此代数系统\n    private func text(inv: Bool): String {\n        let exp = if (inv) { \"⁻¹\" } else { \"\" }\n        match (this) {\n            case F => \"F${exp}\" case B => \"B${exp}\" case L => \"L${exp}\"\n            case R => \"R${exp}\" case U => \"U${exp}\" case D => \"D${exp}\"\n            case I(r) => r.text(!inv)\n            case X(x1, x2) =>\n                if (inv) { // 逆变换需要反序\n                    x2.text(inv) + x1.text(inv)\n                } else {\n                    x1.text(inv) + x2.text(inv)\n                }\n        }\n    }\n\n    public func toString(): String {\n        text(false)\n    }\n\n    // 下面实现 Hashable 和 Equatable 接口，以便 Rotation 作为 HashMap 的 Key\n    public func hashCode(): Int64 {\n        this.toString().hashCode()\n    }\n\n    public operator func ==(that: Rotation): Bool {\n        this.toString() == that.toString()\n    }\n\n    public operator func !=(that: Rotation): Bool {\n        this.toString() != that.toString()\n    }\n}\n\ntype Face = Rotation\ntype Vector = Array<(Face, Int64)>\ntype Matrix = Array<Vector>\nenum Index {\n    Row(Int64) | Col(Int64) | Inv(Index)\n    // 用于标记向量倒置\n    public operator func -(): Index {\n        match (this) {\n            case Inv(v) => v\n            case _ => Inv(this)\n        }\n    }\n    // 去掉 Inv 符号\n    public func value(): Index {\n        match (this) {\n            case Inv(v) => v\n            case _ => this\n        }\n    }\n}\n\nextend Matrix {\n    // 给指定的魔方面创建初始矩阵\n    public static func create(face: Face) {\n        Matrix(3, { i =>\n            Vector(3, { j => (face, 3 * i + j + 1)})\n        })\n    }\n\n    // 获取矩阵的行或列\n    public operator func [](index: Index): Vector {\n        match (index) {\n            case Row(r) => this[r].clone()\n            case Col(c) => Vector(this.size, { i => this[i][c] })\n            case Inv(i) => this[i] // 应用场景需要，取值时忽略符号、不做倒置\n        }\n    }\n\n    // 给矩阵的行或列赋值\n    public func set(index: Index, value: Vector): Unit {\n        match (index) {\n            case Row(r) => this[r] = value\n            case Col(c) =>\n                for (i in 0..value.size) {\n                    this[i][c] = value[i]\n                }\n            case Inv(i) => // 赋值时根据 index 符号做倒置\n                value.reverse()\n                this.set(i, value)\n        }\n    }\n\n    // 打印矩阵的一行\n    public func print(row: Int64) {\n        for ((face, id) in this[row]) {\n            print(\"${face}${id} \")\n        }\n    }\n\n    // 打印整个矩阵\n    public func print() {\n        for (row in 0..this.size) {\n            print(\"         \")\n            print(row)\n            println()\n        }\n    }\n}\n\n// 直接用以上 enum 表示行列索引还不够优雅，我们为整型扩展两个属性，让索引数值可以直接标记行列\nextend Int64 {\n    public prop r: Index {\n        get() { Index.Row(this) }\n    }\n    public prop c: Index {\n        get() { Index.Col(this) }\n    }\n}\n\n// Permutation 可以表示一个置换序列\n// 如 [(L, 2.c), (U, -0.r)] 表示 L 面第三列和 U 面第一行之间的轮换，且前者在换到后者时需要倒置\ntype Permutation = Array<(Face, Index)>\nextend Permutation {\n    // 获取当前置换的逆变换\n    public func inverse() {\n        let perm = this.clone()\n        for (i in 0..perm.size) {\n            let j = (i + 1) % perm.size\n            let (face, index) = this[i] // 解构元组\n            if (let Inv(_) <- this[j][1]) { // if-let 模式匹配\n                perm[i] = (face, -(index.value()))\n            } else {\n                perm[i] = (face, index.value())\n            }\n        }\n        perm.reverse()\n        return perm\n    }\n}\n\nclass Cube {\n    public let data = HashMap<Face, Matrix>()\n    private var history = ArrayList<Rotation>()\n    private static let permutation = HashMap<Face, Permutation>()\n\n    public init() {\n        reset()\n    }\n\n    static init() {\n        // 每个面顺时针转动 90 度时，相邻四面的置换关系\n        permutation[F] = [(L, 2.c), (U, -2.r), (R, 0.c), (D, -0.r)]\n        permutation[B] = [(L, -0.c), (D, 2.r), (R, -2.c), (U, 0.r)]\n        permutation[L] = [(U, 0.c), (F, 0.c), (D, 0.c), (B, 0.c)]\n        permutation[R] = [(B, 2.c), (D, 2.c), (F, 2.c), (U, 2.c)]\n        permutation[U] = [(L, 0.r), (B, -2.r), (R, -0.r), (F, 0.r)]\n        permutation[D] = [(R, 2.r), (B, -0.r), (L, -2.r), (F, 2.r)]\n    }\n\n    public func reset() {\n        history = ArrayList<Rotation>()\n        for (face in [F, B, L, R, U, D]) {\n            data[face] = Matrix.create(face)\n        }\n    }\n\n    // 对指定面上的矩阵旋转 90 度，inverse = true 代表逆时针方向\n    // 此操作不影响其他面，要配合邻边置换操作才能完成魔方的实际转动\n    private func rotate(face: Face, inverse: Bool) {\n        const N = 3\n        let matrix = Matrix.create(face)\n        let map = if (inverse) {\n            { i: Int64, j: Int64 => (N - 1 - j, i) }\n        } else {\n            { i: Int64, j: Int64 => (j, N - 1 - i) }\n        }\n        for (i in 0..N) {\n            for (j in 0..N) {\n                let (u, v) = map(i, j)\n                matrix[u][v] = data[face][i][j]\n            }\n        }\n        data[face] = matrix\n    }\n\n    // 实现各面行/列之间的置换操作，输入是一个置换序列\n    private func permute(perm: Permutation, inverse: Bool) {\n        let p = if (inverse) { perm.inverse() } else { perm.clone() }\n        p.reverse()\n        var (lastFace, lastIndex) = p[0]\n        let vector = data[lastFace][lastIndex]\n        for (i in 1..p.size) {\n            let (face, index) = p[i]\n            data[lastFace].set(lastIndex, data[face][index])\n            (lastFace, lastIndex) = (face, index)\n        }\n        data[lastFace].set(lastIndex, vector)\n    }\n\n    // 在魔方上按序执行 rotation 中定义的操作序列\n    private func transform(rotation: Rotation, inverse: Bool): Unit {\n        match (rotation) {\n            case I(r) => transform(r, !inverse)\n            case X(r1, r2) => // 对复合操作进行递归分解\n                if (inverse) { // 逆变换需要反序\n                    transform(r2, inverse)\n                    transform(r1, inverse)\n                } else {\n                    transform(r1, inverse)\n                    transform(r2, inverse)\n                }\n            case _ => // 各原子操作对应面先旋转 90 度，然后对相邻四个面执行置换操作\n                rotate(rotation, inverse)\n                permute(permutation[rotation], inverse)\n        }\n    }\n\n    public func transform(rotation: Rotation) {\n        transform(rotation, false)\n        history.append(rotation)\n        print()\n        return this\n    }\n\n    public func print() {\n        var prompt = \">> \"\n        for (rotation in history) {\n            prompt += rotation.toString()\n        }\n        println(prompt)\n        data[U].print()\n        for (i in 0..3) {\n            for (face in [L, F, R]) {\n                data[face].print(i)\n            }\n            println()\n        }\n        data[D].print()\n        data[B].print()\n        println()\n    }\n}\n\nmain() {\n    let cube = Cube()\n    cube.print()\n    // 1.基本操作\n    for (r in [F, B, L, R, U, D]) {\n        cube.transform(r) // 原子操作\n    }\n    Cube().transform(F * R * I(F * R)) // 复合操作\n\n    // 2.置换的阶数\n    // FFRR 是 2,3 阶置换的组合，其最小公倍数是 6，重复 6 次两类置换都会还原\n    Cube().transform((F * F * R * R) ** 6)\n    // FULLR 是 3,4,6,9,18 阶置换的组合，同理可得其阶数为 36\n    Cube().transform((F * U * L * L * R) ** 36)\n    Cube().transform((F * F * L * L * B * R) ** 90)\n\n    // 3.相似变换 UGU⁻¹\n    // 已知 R⁻¹DRFDF⁻¹ 可以翻转 FUR 角块\n    let G = I(R) * D * R * F * D * I(F)\n    Cube().transform(G)\n    // 为了翻转 BUR 角块，可以先执行 U 把 BUR 换到 FUR 位置，然后执行 G 翻转 FUR，最后执行 U⁻¹ 恢复 BUR 位置\n    let H = U * G * I(U)\n    Cube().transform(H)\n\n    // 4.组合子变换 MU⁻¹M⁻¹U\n    // 已知 RL⁻¹FFLR⁻¹D⁻¹RL⁻¹FLR⁻¹ 可以保持顶面其他方块不变、仅翻转 UF 棱块，但下面两层会被打乱\n    let M = R * I(L) * F * F * L * I(R) * I(D) * R * I(L) * F * L * I(R)\n    Cube().transform(M)\n    // 为了同时翻转 UF 和 UL，可以先执行 M 翻转 UF，然后执行 U⁻¹ 把 UL 换到 UF 位置\n    // 再执行 M⁻¹ 翻转 UL 并还原下面两层，最后执行 U 恢复 UF 和 UL 位置，这样整个魔方仅有 UF 和 UL 被翻转\n    let N = M * I(U) * I(M) * U\n    Cube().transform(N)\n    // 在此基础上，如果我们想同时翻转 UL 和 UR，可以按组合子思想执行 NUN⁻¹U⁻¹\n    let P = N * U * I(N) * I(U)\n    Cube().transform(P)\n    ()\n}\n", "llm_cg": {"main": ["Cube", "Cube.print", "Cube.transform", "Cube.transform", "Cube.transform", "Cube.transform", "Cube.transform", "Cube.transform", "Cube.transform", "Cube.transform", "Cube.transform"], "Rotation.*": ["X"], "Rotation.**": ["Rotation.*"], "Rotation.text": ["Rotation.text"], "Rotation.toString": ["Rotation.text"], "Rotation.hashCode": ["Rotation.toString", "<builtin>.hashCode"], "Rotation.==": ["Rotation.toString", "Rotation.toString"], "Rotation.!=": ["Rotation.toString", "Rotation.toString"], "Index.-": ["Index"], "Index.value": ["Index"], "Matrix.create": ["Vector"], "Matrix.[]": ["Vector.clone"], "Matrix.set": ["Vector.reverse"], "Matrix.print": ["<builtin>.print", "<builtin>.print", "<builtin>.println"], "Permutation.inverse": ["Permutation.clone", "Index.value", "Index.value", "Permutation.reverse"], "Cube": ["Cube.reset"], "Cube.reset": ["Matrix.create"], "Cube.rotate": ["Matrix.create"], "Cube.permute": ["Permutation.inverse", "Permutation.clone", "Matrix.set"], "Cube.transform": ["Cube.transform", "ArrayList.append", "Cube.print"], "Cube.print": ["Rotation.toString", "<builtin>.println", "Matrix.print", "Matrix.print", "<builtin>.println", "Matrix.print", "Matrix.print", "<builtin>.println"]}, "static_cg": {}}
{"source_code": "package tokenizer\nimport encoding.json.stream.JsonReader\ninternal import std.collection.ArrayList\ninternal import std.collection.HashMap\ninternal import std.collection.HashSet\nimport std.core.Equatable\nimport std.core.Hashable\nimport std.core.ToString\nimport std.fs.File\nimport std.fs.Path\nimport std.io.ByteArrayStream\nimport std.regex.*\nimport std.math.pow\n\npublic enum TokenizerType {\n  SENTENCEPIECE |\n  TIKTOIKEN |\n  BERT |\n  HUGGINGFACE\n}\n\npublic open class Tokenizer {\n  protected var special_tokens_: ArrayList<UInt32> = ArrayList<UInt32>();\n  protected var stop_tokens_: ArrayList<UInt32> = ArrayList<UInt32>();\n  protected var prefix_tokens_: ArrayList<UInt32> = ArrayList<UInt32>();\n\n  public static const MAGIC_NUMBER:UInt32 = 430;\n  public static func createTokenizer(file_path: String, tokenizer_type: TokenizerType): Tokenizer {\n    match (tokenizer_type) {\n      case TokenizerType.HUGGINGFACE =>\n        let tokenizer = HuggingfaceTokenizer();\n        tokenizer.load_vocab(file_path: file_path);\n        println(\"tokenizer load ok\");\n        return tokenizer;\n      case other => throw Exception(\"unsupport tokenizer type\");\n    }\n  }\n  public func is_stop(token:UInt32): Bool {\n    return stop_tokens_.contains(token)\n  }\n  public func is_special(token:UInt32): Bool {\n    return special_tokens_.contains(token)\n  }\n\n  public open func encode(_: String, add_special_tokens!: Bool): Array<UInt32> {\n    if (add_special_tokens) {\n      // todo\n    }\n    println(\"Waring! encode is virtual function in class Tokenizer, don't to use it!\")\n    return Array<UInt32>()\n  }\n\n  public open func decode(_: Array<UInt32>, skip_special_tokens!: Bool): String {\n    if (skip_special_tokens) {\n      // todo\n    }\n    println(\"Waring! decode is virtual function in class Tokenizer, don't to use it!\")\n    return \"\"\n  }\n\n  protected open func load_special(_: String) {\n    println(\"Waring! load_special is virtual function in class Tokenizer, don't to use it!\")\n  }\n\n  public open func load_vocab(file_path!: String, buffer!:Array<UInt8>) {\n    if (!File.exists(file_path) && buffer.size == 0) {\n      throw Exception(\"${file_path} not exists and buffer is empty\");\n    }\n    println(\"Waring! load_vocab is virtual function in class Tokenizer, don't to use it!\")\n  }\n}\n\n\n\npublic class Tiktoken <: Tokenizer {\n  public override func decode(_: Array<UInt32>, skip_special_tokens!: Bool = false): String {\n    if (skip_special_tokens) {\n      // todo\n    }\n    // todo\n    return \"\";\n  }\n\n  public override func load_vocab(file_path!: String = \"\", buffer!: Array<UInt8> = Array<UInt8>()){\n    if (!File.exists(file_path) && buffer.size == 0) {\n      throw Exception(\"${file_path} not exists and buffer is empty\");\n    }\n    // todo\n  }\n\n  public override func encode(str: String, add_special_tokens!: Bool = false): Array<UInt32> {\n    if (add_special_tokens) {\n      // todo\n    }\n    var token_ids: ArrayList<UInt32> = ArrayList<UInt32>();\n    if (str.isEmpty()) {\n      return token_ids.toArray();\n    }\n    var i: Int64 = 0;\n    // Attempt to match the longest possible symbol\n    var longest_match_len: Int64 = 0;\n    var longest_match: String = \"\";\n    var token: String = \"\";\n    while (i < str.size) {\n      // Check substrings of decreasing length\n      var len = str.size - i;\n      while(len > 0) {\n        token = str[i..i + len];\n        if (this.vocab_.contains(token) && len > longest_match_len) {\n          longest_match_len = len;\n          longest_match = token;\n        }\n        len--;\n      }\n      if (!longest_match.isEmpty()) {\n        token_ids.append(this.vocab_[longest_match]);\n        i += longest_match_len;\n      } else {\n        eprintln(\"Error: No encoding found for the sequence starting at position ${i}\");\n      }\n    }\n    return token_ids.toArray();\n  }\n\n  protected var vocab_: HashMap<String,UInt32> = HashMap<String,UInt32>()\n  protected var decoder_: ArrayList<String> = ArrayList<String>();\n}\n\n\npublic class BertTokenizer <: Tokenizer {\n  public override func encode(_: String, add_special_tokens!: Bool = false): Array<UInt32> {\n    if (add_special_tokens) {\n      // todo\n    }\n    // todo\n    return Array<UInt32>()\n  }\n  // private func word_piece(_: String): ArrayList<UInt32> {\n  //   // todo\n  //   return ArrayList<UInt32>();\n  // }\n}\n\n\nclass HashPairString <: Hashable & Equatable<HashPairString> {\n  public var first: String;\n  public var second: String;\n  public init(p: (String, String)) {\n    this.first = p[0];\n    this.second = p[1]\n  }\n  public func hashCode(): Int64 {\n    let hash1: Int64 = this.first.hashCode()\n    let hash2: Int64 = this.second.hashCode()\n    // If hash1 == hash2, their XOR is zero.\n    if (hash1 != hash2) {\n      return hash1 ^ hash2\n    } else {\n      return hash1  \n    }\n  }\n  public operator func == (other: HashPairString): Bool {\n    if (this.first == other.first && this.second == other.second) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n};\n\n\npublic class HashPairUInt32 <: Hashable & Equatable<HashPairUInt32> & ToString{\n  public var first: UInt32;\n  public var second: UInt32;\n  public init(p: (UInt32, UInt32)) {\n    this.first = p[0];\n    this.second = p[1]\n  }\n  public func toString(): String {\n    return \"(${this.first}, ${this.second})\"\n  }\n  public func hashCode(): Int64 {\n    let hash1: Int64 = this.first.hashCode()\n    let hash2: Int64 = this.second.hashCode()\n    // If hash1 == hash2, their XOR is zero.\n    if (hash1 != hash2) {\n      return hash1 ^ hash2\n    } else {\n      return hash1  \n    }\n  }\n  public operator func == (other: HashPairUInt32): Bool {\n    if (this.first == other.first && this.second == other.second) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n};\n\n\ntype BPERanks = HashMap<HashPairString, UInt32>;\npublic type MergeMap = HashMap<HashPairUInt32, (UInt32, UInt32)>;\n\n// A [Byte Pair Encoding](https://www.aclweb.org/anthology/P16-1162/) model.\npublic class HuggingfaceTokenizer <: Tokenizer {\n  // The vocabulary assigns a number to each token.\n  public var vocab: HashMap<String, UInt32> = HashMap<String, UInt32>();\n  // Reversed vocabulary, to rebuild sentences.\n  public var vocab_r: HashMap<UInt32, String> = HashMap<UInt32, String>();\n  // Contains the mapping between Pairs and their (rank, new_id).\n  public var merges: MergeMap = MergeMap();\n  // todo private cache\n  // Dropout probability for merges. 0.0 = no dropout is the default. At 1.0, tokenization will\n  // perform no merges, so the result will just be characters.\n  public var dropout: Option<Float32> = None;\n  // The unknown token to be used when we encounter an unknown char\n  public var unk_token: Option<String> = None;\n  public var unk_token_id: Option<UInt32> = None;\n  // An optional prefix to use on any subword that exist only behind another one\n  public var continuing_subword_prefix: Option<String> = None\n  // An optional suffix to caracterize and end-of-word subword\n  public var end_of_word_suffix: Option<String> = None\n  /// Do multiple unk tokens get fused\n  public var fuse_unk: Bool = false\n  /// Byte fallback from sentence pieces, instead of UNK, uses `\"<0x00>\"`\n  /// for each byte in the unk token\n  public var byte_fallback: Bool = false\n  /// Whether or not to direct output words if they are part of the vocab.\n  public var ignore_merges: Bool = false;\n  // cache\n  private let cache: HashMap<String, Array<String>> = HashMap<String, Array<String>>();\n  private var bpe_ranks_: BPERanks = BPERanks();\n  private let special_id_set: HashSet<String> = HashSet<String>();\n  private var byte2rune: HashMap<UInt8, Rune> = HashMap<UInt8, Rune>();\n  private var rune2byte: HashMap<Rune, UInt8> = HashMap<Rune, UInt8>();\n  \n\n  public init(\n    vocab! : HashMap<String, UInt32> = HashMap<String, UInt32>(),\n    merge_list!: ArrayList<(String, String)> = ArrayList<(String, String)>(),\n    dropout!: Option<Float32> = None,\n    unk_token!: Option<String> = None,\n    continuing_subword_prefix!: Option<String> = None,\n    end_of_word_suffix!: Option<String> = None,\n    fuse_unk!: Bool = false,\n    byte_fallback!: Bool = false,\n    ignore_merges!: Bool = false\n  ) {\n    this.vocab = vocab;\n    for ((token, id) in this.vocab) {\n      this.vocab_r.put(id, token);\n    }\n    (this.byte2rune, this.rune2byte) = this.get_byte_char();\n    // get merge map from this.merges\n    let prefix_len = continuing_subword_prefix.getOrDefault({=>\"\"}).size;\n    var i: UInt32 = 0;\n    for ((a, b) in merge_list) {\n      // println(\"a = ${a}, b = ${b}\");\n      let a_id: UInt32 = this.vocab.get(a).getOrThrow();\n      let b_id: UInt32 = this.vocab.get(b).getOrThrow();\n      let new_token: String = \"${a}${b[prefix_len..]}\";\n      let new_id: UInt32 = this.vocab.get(new_token).getOrThrow();\n      this.merges.put(HashPairUInt32((a_id, b_id)), (i, new_id));\n      this.bpe_ranks_.put(HashPairString((a, b)), i);\n      i++;\n    }\n    this.merges = merges;\n    this.dropout = dropout;\n    this.unk_token = unk_token;\n    this.continuing_subword_prefix = continuing_subword_prefix;\n    this.end_of_word_suffix = end_of_word_suffix;\n    this.fuse_unk = fuse_unk;\n    this.byte_fallback = byte_fallback;\n    this.ignore_merges = ignore_merges;\n  }\n\n  public func get_byte_char(): (HashMap<UInt8, Rune>, HashMap<Rune, UInt8>) {\n    var bs: ArrayList<UInt8> = ArrayList<UInt8>();\n    var cs: ArrayList<UInt32> = ArrayList<UInt32>();\n    var temp_start: Rune = '!';\n    var temp_end: Rune = '~';\n    for (x in UInt32(temp_start)..=UInt32(temp_end)) {\n      bs.append(UInt8(x));\n      cs.append(x);\n    }\n    temp_start = '\\u{A1}';\n    temp_end = '\\u{AC}';\n    for (x in UInt32(temp_start)..=UInt32(temp_end)) {\n      bs.append(UInt8(x));\n      cs.append(x);\n    }\n    temp_start = '\\u{AE}';\n    temp_end = '\\u{FF}';\n    for (x in UInt32(temp_start)..=UInt32(temp_end)) {\n      bs.append(UInt8(x));\n      cs.append(x);\n    }\n    var n: UInt32 = 0;\n    for (b in 0_u8..=255_u8) {\n      if (!bs.contains(b)) {\n        bs.append(b);\n        cs.append(UInt32(pow(2.0, 8)) + n);\n        n += 1;\n      }\n    }\n    var result: HashMap<UInt8, Rune> = HashMap<UInt8, Rune>();\n    var result_r: HashMap<Rune, UInt8> = HashMap<Rune, UInt8>();\n    for ((k, v) in bs.iterator().zip(cs.iterator())) {\n      result.put(k, Rune(v));\n      result_r.put(Rune(v), k);\n    }\n    return (result, result_r);\n  }\n\n\n  public override func load_vocab(file_path!: String = \"\", buffer!: Array<UInt8> = Array<UInt8>()) {\n    // load vocab from tokenizer.json\n    let json_buffer: Array<UInt8> = if (!File.exists(file_path) && buffer.size == 0) {\n      throw Exception(\"${file_path} not exists and buffer is empty\");\n    } else if (File.exists(file_path)) {\n      let file = File.openRead(file_path);\n      let temp_buffer = file.readToEnd();\n      file.close();\n      temp_buffer\n    } else {\n      buffer\n    };\n    var byte_stream = ByteArrayStream();\n    byte_stream.write(json_buffer);\n    let json_reader = JsonReader(byte_stream);\n    let tokenizer_config = TokenizerJson.fromJson(json_reader);\n    (this.byte2rune, this.rune2byte) = this.get_byte_char();\n    // get vocab\n    this.vocab = tokenizer_config.model.vocab;\n    // add special token\n    for (add_token in tokenizer_config.added_tokens) {\n      this.vocab.put(add_token.content, add_token.id);\n      this.special_id_set.put(add_token.content);\n    }\n    // set unknow token id\n    if (this.unk_token.isSome()) {\n      this.unk_token_id = this.vocab.get(this.unk_token.getOrThrow())\n    }\n    // get reverse vocab\n    for ((token, id) in tokenizer_config.model.vocab) {\n      this.vocab_r.put(id, token);\n    }\n    var str_list: Array<String> = Array<String>();\n    var merge_list: ArrayList<(String, String)> = ArrayList<(String, String)>();\n    for (line in tokenizer_config.model.merges) {\n      str_list = line.split(\" \");\n      if (str_list.size != 2) {\n        throw Exception(\"merge line size must be 2\");\n      }\n      merge_list.append((str_list[0], str_list[1]));\n    }\n    // get merge map from this.merges\n    let prefix_len = tokenizer_config.model.continuing_subword_prefix.size;\n    var i: UInt32 = 0;\n    for ((a, b) in merge_list) {\n      let a_id: UInt32 = this.vocab.get(a).getOrThrow();\n      let b_id: UInt32 = this.vocab.get(b).getOrThrow();\n      let new_token: String = \"${a}${b[prefix_len..]}\";\n      let new_id: UInt32 = this.vocab.get(new_token).getOrThrow();\n      this.merges.put(HashPairUInt32((a_id, b_id)), (i, new_id));\n      this.bpe_ranks_.put(HashPairString((a, b)), i);\n      i++;\n    }\n    // get dropout/unk_token/continuing_subword_prefix/.....\n    this.dropout = tokenizer_config.model.dropout;\n    this.unk_token = tokenizer_config.model.unk_token;\n    this.continuing_subword_prefix = tokenizer_config.model.continuing_subword_prefix;\n    this.end_of_word_suffix = tokenizer_config.model.end_of_word_suffix;\n    this.fuse_unk = tokenizer_config.model.fuse_unk;\n    this.byte_fallback = tokenizer_config.model.byte_fallback;\n  }\n\n\n  public func token_to_id(token: String): Option<UInt32> {\n    return this.vocab.get(token);\n  }\n\n  public func id_to_token(id: UInt32) {\n    return this.vocab_r.get(id);\n  }\n\n  public func apply_chat_template(\n    messages: ArrayList<Message>,\n    add_generation_prompt!: Bool = false\n  ): String {\n    // only support qwen\n    var result_str = \"\";\n    if (messages.size == 0) {\n      return result_str;\n    }\n    // get system message\n    match (messages[0].role) {\n      case RoleType.System =>\n        result_str += \"<|im_start|>system\\n${messages[0].content}<|im_end|>\\n\"\n        messages.remove(0);\n      case _ => ()\n    }\n    // muse be double size\n    if (messages.size % 2 != 1) {\n      throw Exception(\"input times - assistant times must = 1\");\n    }\n    for (i in 0..messages.size) {\n      if (i % 2 == 0) {\n        result_str += \"<|im_start|>user\\n${messages[i].content}<|im_end|>\\n\"\n      } else {\n        result_str += \"<|im_start|>assistant\\n${messages[i].content}<|im_end|>\\n\"\n      }\n    }\n    // add_generation_prompt\n    if (add_generation_prompt) {\n      result_str += \"<|im_start|>assistant\\n\"\n    }\n    return result_str;\n  }\n\n  public override func decode(token_ids: Array<UInt32>, skip_special_tokens!: Bool = false): String {\n    let result_str_list = Array<String>(token_ids.size, {_ => \"\"});\n    for ((i, token_id) in token_ids.iterator().enumerate()) {\n      result_str_list[i] = this.id_to_token(token_id).getOrThrow();\n    }\n    let data_array = ArrayList<UInt8>();\n    for (result_str in result_str_list) {\n      // skip special tokens\n      if (skip_special_tokens && this.special_id_set.contains(result_str)) {\n        continue;\n      }\n      for (rune in result_str.toRuneArray()) {\n        let temp_byte: UInt8 = this.rune2byte[rune];\n        data_array.append(temp_byte);\n      }\n    }\n    return String.fromUtf8(data_array.toArray());\n  }\n\n  public override func encode(str: String, add_special_tokens!: Bool = false): Array<UInt32> {\n    if (add_special_tokens) {\n      // todo\n    }\n    // changes the regex with better\n    var special_pattern: String = \"(\";\n    for ((idx, special_str) in this.special_id_set.iterator().enumerate()) {\n      if (idx < this.special_id_set.size - 1) {\n        special_pattern += special_str.replace(\"|\", \"\\\\|\") + \"|\";\n      } else {\n        special_pattern += special_str.replace(\"|\", \"\\\\|\") + \")\";\n      }\n    }\n    // println(\"special_pattern: ${special_pattern}\");\n    let special_re: Regex = Regex(special_pattern);\n    // find special tokens\n    let special_token_map = HashMap<Int64, UInt32>();\n    let special_index_list = ArrayList<(Int64, Int64)>();\n    let added_special_index = HashSet<Int64>();\n    let special_array = special_re.matcher(str).findAll() ?? Array<MatchData>();\n    var text = str;\n    // replace special tokens with empty blank\n    for (special in special_array) {\n      let special_token = special.matchStr();\n      println(\"special token: ${special_token}\");\n      special_token_map.put(\n        special.matchPosition().start,\n        this.vocab.get(special_token).getOrThrow()\n      );\n      special_index_list.append((\n        special.matchPosition().start,  \n        special.matchPosition().end  \n      ))\n      var empty_token = \"\";\n      var temp_i = 0;\n      while(temp_i < special_token.size) {\n        empty_token += \" \";\n        temp_i++;\n      }\n      text = text.replace(special_token, empty_token);\n    }\n    // println(\"text: ${text}\");\n    // print(\"special index list: [\");\n    // for (xx_index in special_index_list) {\n    //   print(\"(${xx_index[0]}, ${xx_index[1]}), \")\n    // }\n    // println(\"]\")\n    let text_re: Regex = Regex(\"('s|'t|'re|'ve|'m|'ll|'d| ?[[:alpha:]]+| ?[[:digit:]]+| ?[^\\\\s\\\\w]+|\\\\s+)\");\n    let match_array = text_re.matcher(text).findAll() ?? Array<MatchData>();\n    var ids = ArrayList<UInt32>();\n    var special_index = 0;\n    for (token in match_array) {\n      let temp_start = token.matchPosition().start;\n      let temp_end = token.matchPosition().end;\n      // find special\n      var temp_si = special_index;\n      var is_special = false;\n      while (temp_si < special_index_list.size) {\n        let (s_start, s_end) = special_index_list[temp_si];\n        if (temp_end <= s_start) {\n          break;\n        }\n        if (temp_start >= s_start && temp_start < s_end) {\n          if (!added_special_index.contains(temp_si)) {\n            let special_token_id = special_token_map[s_start];\n            ids.append(special_token_id);\n            // change index to last\n            special_index = temp_si - 1;\n            if (special_index < 0) {\n              special_index = 0;\n            }\n            added_special_index.put(temp_si);\n          }\n          is_special = true;\n          break;\n        }\n        temp_si ++;\n      }\n      // println(\"${token.matchStr()}, ${is_special}\");\n      if (is_special) {\n        continue;\n      }\n      let token_str = token.matchStr();\n      var temp_str: String = \"\";\n      var token_list = ArrayList<String>();\n      for (b in token_str.toArray()) {\n        let char = this.byte2rune[b];\n        temp_str += char.toString();\n        token_list.append(char.toString());\n      }\n      // println(\"temp_str: ${temp_str}\");\n      // can use cache?\n      if (this.cache.contains(temp_str)) {\n        let result_str_list = this.cache[temp_str];\n        for (result_str in result_str_list) {\n          ids.append(this.vocab[result_str]);\n        }\n        continue;\n      }\n      // println(\"raw token list ${token_list}\");\n      let str_list = this.bpe(token_list.toArray());\n      // update cache\n      this.cache.put(temp_str, str_list);\n      // println(\"merge token list ${str_list}\");\n      for (temp_str in str_list) {\n        let new_token = this.token_to_id(temp_str).getOrDefault({=>this.unk_token_id.getOrThrow()})\n        ids.append(new_token);\n      }\n    }\n    return ids.toArray();\n  }\n\n  private func get_pairs(tokens: Array<String>): Array<HashPairString> {\n    var pairs: ArrayList<HashPairString> = ArrayList<HashPairString>();\n    if (tokens.size > 1) {\n      var previous: String = tokens[0];\n      var next: String = \" \";\n      var i: Int64 = 1;\n      while (i < tokens.size) {\n        next = tokens[i];\n        pairs.append(HashPairString((previous.toString(), next.toString())))\n        previous = next;\n        i++;\n      }\n    }\n    return pairs.toArray();\n  }\n\n  private func bpe(token_list: Array<String>): Array<String> {\n    var word = token_list;\n    if (word.size == 0) {\n      return word;\n    }\n    let result: ArrayList<String> = ArrayList<String>();\n    // records indices in pairs that were merged.\n    // find from right to left \n    func left_index(data_list: Array<String>, i: Int64, target: String): Int64 {\n      var ii = i;\n      while(ii < data_list.size) {\n        if (data_list[ii] == target) {\n          return ii;\n        }\n        ii++;\n      }\n      return -1;\n    }\n    var pairs: Array<HashPairString> = this.get_pairs(word);\n    while (true) {\n      var merged: HashSet<Int32> = HashSet<Int32>();\n      // can merge?\n      var min_score:UInt32 =UInt32.Max;\n      var to_merge: Int64 = -1;\n      var i: Int64 = 0;\n      // println(\"==========================\");\n      // println(\"pairs size = ${pairs.size}\");\n      while (i < pairs.size) {\n        // if pair i is not merged.\n        if (!merged.contains(Int32(i))) {\n          let score = if (this.bpe_ranks_.contains(pairs[i])) {\n            this.bpe_ranks_[pairs[i]]\n          } else {\n           UInt32.Max\n          };\n          // println(\"pair = (${pairs[i].first} ${pairs[i].second}); score = ${score}\");\n          if (score < min_score) {\n            min_score = score;\n            to_merge = i;\n          }\n        }\n        i++;\n      }\n      // println(\"to_merge = ${to_merge}\");\n      if (to_merge == -1) {\n        break;\n      }\n      merged.put(Int32(to_merge));\n      i = 0;\n      var new_word: ArrayList<String> = ArrayList<String>();\n      let first = pairs[to_merge].first;\n      let second = pairs[to_merge].second;\n      while (i < word.size) {\n        let j = left_index(word, i, first);\n        if (j >= 0) {\n          new_word.appendAll(word[i..j]);\n          i = j;\n        } else {\n          new_word.appendAll(word[i..]);\n          break;\n        }\n        var temp_bool = true;\n        if (word[i] == first && i < word.size - 1) {\n          if (word[i + 1] == second) {\n            new_word.append(first + second);\n            i += 2;\n            temp_bool = false;\n          }\n        }\n        if (temp_bool) {\n          new_word.append(word[i]);\n          i += 1;\n        }\n        \n      } // end while\n      // println(\"new_word: ${new_word}\");\n      word = new_word.toArray();\n      if (word.size == 1) {\n        break;\n      } else {\n        pairs = this.get_pairs(word);\n      }\n    } // end while\n    return word;\n  }\n}", "llm_cg": {"main": [], "TokenizerType": [], "Tokenizer": ["Exception", "<builtin>.println", "HuggingfaceTokenizer.load_vocab", "<builtin>.println", "Exception", "stop_tokens_.contains", "special_tokens_.contains", "<builtin>.println", "<builtin>.println", "File.exists", "Exception", "<builtin>.println"], "Tokenizer.createTokenizer": ["HuggingfaceTokenizer", "Tokenizer.load_vocab", "<builtin>.println", "Exception"], "Tokenizer.is_stop": ["stop_tokens_.contains"], "Tokenizer.is_special": ["special_tokens_.contains"], "Tokenizer.encode": ["<builtin>.println", "Array"], "Tokenizer.decode": ["<builtin>.println", "<builtin>.println"], "Tokenizer.load_special": ["<builtin>.println"], "Tokenizer.load_vocab": ["File.exists", "Exception", "<builtin>.println"], "Tiktoken": ["File.exists", "Exception", "str.isEmpty", "token_ids.toArray", "str.size", "str.size", "<builtin>.eprintln"], "Tiktoken.decode": [], "Tiktoken.load_vocab": ["File.exists", "Exception"], "Tiktoken.encode": ["str.isEmpty", "token_ids.toArray", "<builtin>.eprintln"], "BertTokenizer": [], "BertTokenizer.encode": [], "HashPairString": [], "HashPairString.init": [], "HashPairString.hashCode": ["this.first.hashCode", "this.second.hashCode"], "HashPairString.==": ["this.first", "this.second"], "HashPairUInt32": [], "HashPairUInt32.init": [], "HashPairUInt32.toString": [], "HashPairUInt32.hashCode": ["this.first.hashCode", "this.second.hashCode"], "HashPairUInt32.==": ["this.first", "this.second"], "HuggingfaceTokenizer": ["get_byte_char", "Formatting.fromString", "Formatting.fromString", "HuggingfaceTokenizer.merge_map", "vocab.put", "vocab_r.put", "vocab.put", "bpe_ranks_.put", "Exception", "vocab.getOrThrow", "vocab.getOrThrow", "token_to_id", "id_to_token", "vocab.get", "vocab_r.get", "File.exists", "File.openRead", "File.close", "HashPairUInt32.init", "HashPairString.init", "HashPairString.toString", "bpe_ranks_.contains", "matches.getString"], "HuggingfaceTokenizer.get_byte_char": ["ArrayList", "ArrayList", "ArrayList", "<builtin>.pow", "HashMap", "HashMap"], "HuggingfaceTokenizer.load_vocab": ["File.exists", "Exception", "File.exists", "File.openRead", "File.close", "JsonReader", "JsonReader.read", "tokenizer_config.model", "vocab.put", "special_id_set.put", "vocab_r.put", "HuggingfaceTokenizer.merge_map", "Exception"], "HuggingfaceTokenizer.token_to_id": ["vocab.get"], "HuggingfaceTokenizer.id_to_token": ["vocab_r.get"], "HuggingfaceTokenizer.apply_chat_template": ["messages.remove", "Exception"], "HuggingfaceTokenizer.decode": ["token_to_id", "vocab_r.get", "matches.getString", "Formatting.fromOption"], "HuggingfaceTokenizer.encode": ["vocab.get", "vocab_r.put", "matching.matched", "token_to_id", "array.getOrThrow", "matches.close", "matches.matched", "matches.toArray", "matches.close", "tokenizer_config.modes", "matches.getMatching"], "HuggingfaceTokenizer.get_pairs": ["ArrayList", "<builtin>.println", "pairs.append", "<builtin>.println"], "HuggingfaceTokenizer.bpe": ["get_pairs", "<builtin>.println", "Exception", "<builtin>.println", "Exception", "<builtin>.println", "bpe_ranks_.contains", "<builtin>.println", "HuggingfaceTokenizer.get_left_index", "HuggingfaceTokenizer.get_left_index", "HuggingfaceTokenizer.left_indexContains", "HuggingfaceTokenizer.get_pairs"]}, "static_cg": {}}
{"source_code": "package tokenizer\n\ninternal import encoding.json.stream.*\n\npublic struct TokenJson <: JsonDeserializable<TokenJson> {\n  let id: UInt32;\n  let content: String;\n  let single_word: Bool;\n  let lstrip: Bool;\n  let rstrip: Bool;\n  let normalized: Bool;\n  let special: Bool;\n\n  public init(\n    id: UInt32,\n    content: String,\n    single_word: Bool,\n    lstrip: Bool,\n    rstrip: Bool,\n    normalized: Bool,\n    special: Bool\n  ) {\n    this.id = id;\n    this.content = content;\n    this.single_word = single_word;\n    this.lstrip = lstrip;\n    this.rstrip = rstrip;\n    this.normalized = normalized;\n    this.special = special;\n  }\n\n  public static func fromJson(r: JsonReader): TokenJson {\n    var temp_id: UInt32 = 0;\n    var temp_content: String = \"\";\n    var temp_single_word: Bool = false;\n    var temp_lstrip: Bool = false;\n    var temp_rstrip: Bool = false;\n    var temp_normalized: Bool = false;\n    var temp_special: Bool = false;\n    while (let Some(v) <- r.peek()) {\n      match(v) {\n        case BeginObject =>\n          r.startObject();\n          while(r.peek() != EndObject) {\n            let n = r.readName()\n            match (n) {\n              case \"id\" => temp_id = r.readValue<UInt32>();\n              case \"content\" => temp_content = r.readValue<String>();\n              case \"single_word\" => temp_single_word = r.readValue<Bool>();\n              case \"lstrip\" => temp_lstrip = r.readValue<Bool>();\n              case \"rstrip\" => temp_rstrip = r.readValue<Bool>();\n              case \"normalized\" => temp_normalized = r.readValue<Bool>();\n              case \"special\" => temp_special = r.readValue<Bool>();\n              case unkow => println(\"unkow key ${unkow}\");\n            }\n          }\n          r.endObject();\n          break;\n        case _ => throw Exception(\"can't deserialize for TokenJson\");\n      }\n    }\n    return TokenJson(\n      temp_id,\n      temp_content,\n      temp_single_word,\n      temp_lstrip,\n      temp_rstrip,\n      temp_normalized,\n      temp_special\n    );\n  }\n}\n\npublic struct NormalizerJson <: JsonDeserializable<NormalizerJson> {\n  let p_type: String;\n\n  public init(p_type: String) {\n    this.p_type = p_type;\n  }\n  \n  public static func fromJson(r: JsonReader): NormalizerJson {\n    var temp_p_type: String = \"\";\n    while (let Some(v) <- r.peek()) {\n      match(v) {\n        case BeginObject =>\n          r.startObject();\n          while(r.peek() != EndObject) {\n            let n = r.readName()\n            match (n) {\n              case \"type\" => temp_p_type = r.readValue<String>();\n              case unkow => println(\"unkow key ${unkow}\");\n            }\n          }\n          r.endObject();\n          break;\n        case _ => throw Exception(\"can't deserialize for NormalizerJson\");\n      }\n    }\n    return NormalizerJson(temp_p_type);\n  }\n}\n\npublic struct PatternJson <: JsonDeserializable<PatternJson> {\n  let p_regex: String;\n\n  public init(p_regex: String) {\n    this.p_regex = p_regex;\n  }\n  \n  public static func fromJson(r: JsonReader): PatternJson {\n    var temp_p_regex: String = \"\";\n    while (let Some(v) <- r.peek()) {\n      match(v) {\n        case BeginObject =>\n          r.startObject();\n          while(r.peek() != EndObject) {\n            let n = r.readName()\n            match (n) {\n              case \"Regex\" => temp_p_regex = r.readValue<String>();\n              case unkow => println(\"unkow key ${unkow}\");\n            }\n          }\n          r.endObject();\n          break;\n        case _ => throw Exception(\"can't deserialize for ProcessJson\");\n      }\n    }\n    return PatternJson(temp_p_regex);\n  }\n\n}\n\n\npublic struct ProcessJson <: JsonDeserializable<ProcessJson> {\n  // Union ByteLevel and SplitTokenizer\n  let p_type: String;\n  // use for ByteLevel: decoder/post_processor\n  let add_prefix_space: Option<Bool>;\n  let trim_offsets: Option<Bool>;\n  let use_regex: Option<Bool>;\n  // actived when split tokenizer\n  let pattern: Option<PatternJson>;\n  let behavior: Option<String>;\n  let invert: Option<Bool>;\n\n  // construct for decode/post_preprossor\n  public init(\n    p_type: String,\n    add_prefix_space: Bool,\n    trim_offsets: Bool,\n    use_regex: Bool\n  ) {\n    this.p_type = p_type;\n    if (this.p_type != \"ByteLevel\") {\n      throw Exception(\"this construction function only suppport ByteLevel type\");\n    }\n    this.add_prefix_space = Some(add_prefix_space);\n    this.trim_offsets = Some(trim_offsets);\n    this.use_regex = Some(use_regex);\n    this.pattern = None;\n    this.behavior = None;\n    this.invert = None;\n  }\n\n  public init(\n    p_type: String,\n    pattern: PatternJson,\n    behavior: String,\n    invert: Bool\n  ) {\n    this.p_type = p_type;\n    if (p_type != \"Split\") {\n      throw Exception(\"this construction function only support Split type\")\n    }\n    this.add_prefix_space = None;\n    this.trim_offsets = None;\n    this.use_regex = None;\n    this.pattern = Some(pattern);\n    this.behavior = Some(behavior);\n    this.invert = Some(invert);\n  }\n\n  public static func fromJson(r: JsonReader): ProcessJson {\n    var temp_p_type: String = \"\";\n    var temp_add_prefix_space: Bool = false;\n    var temp_trim_offsets: Bool = false;\n    var temp_use_regex: Bool = false;\n    var temp_pattern: PatternJson = PatternJson(\"\");\n    var temp_behavior: String = \"\";\n    var temp_invert: Bool = false;\n    while (let Some(v) <- r.peek()) {\n      match(v) {\n        case BeginObject =>\n          r.startObject();\n          while(r.peek() != EndObject) {\n            let n = r.readName()\n            match (n) {\n              case \"type\" => temp_p_type = r.readValue<String>();\n              // ByteLevel\n              case \"add_prefix_space\" => temp_add_prefix_space = r.readValue<Bool>();\n              case \"trim_offsets\" => temp_trim_offsets = r.readValue<Bool>();\n              case \"use_regex\" => temp_use_regex = r.readValue<Bool>();\n              // Split\n              case \"pattern\" => temp_pattern = r.readValue<PatternJson>();\n              case \"behavior\" => temp_behavior = r.readValue<String>();\n              case \"invert\" => temp_invert = r.readValue<Bool>();\n              case unkow => println(\"unkow key ${unkow}\");\n            }\n          }\n          r.endObject();\n          break;\n        case _ => throw Exception(\"can't deserialize for ProcessJson\");\n      }\n    }\n    match (temp_p_type) {\n      case \"ByteLevel\" =>\n        ProcessJson(\n          temp_p_type,\n          temp_add_prefix_space,\n          temp_trim_offsets,\n          temp_use_regex,\n        );\n      case \"Split\" => \n        ProcessJson(\n          temp_p_type,\n          temp_pattern,\n          temp_behavior,\n          temp_invert\n        )\n      case other => throw Exception(\"unkonw process type ${other}\")\n    }\n  }\n}\n\npublic struct PreTokenizerJson <: JsonDeserializable<PreTokenizerJson> {\n  let p_type: String;\n  let pretokenizers: ArrayList<ProcessJson>;\n  public init(p_type: String, pretokenizers: ArrayList<ProcessJson>) {\n    this.p_type = p_type;\n    this.pretokenizers = pretokenizers;\n  }\n\n  public init() {\n    // default\n    this.p_type = \"\";\n    this.pretokenizers = ArrayList<ProcessJson>();\n  }\n\n  public static func fromJson(r: JsonReader): PreTokenizerJson {\n    var temp_p_type: String = \"\";\n    var temp_pre_tokenizers: ArrayList<ProcessJson> = ArrayList<ProcessJson>();\n    while (let Some(v) <- r.peek()) {\n      match(v) {\n        case BeginObject =>\n          r.startObject();\n          while(r.peek() != EndObject) {\n            let n = r.readName()\n            match (n) {\n              case \"type\" => temp_p_type = r.readValue<String>();\n              case \"pretokenizers\" => temp_pre_tokenizers = r.readValue<ArrayList<ProcessJson>>();\n              case unkow => println(\"unkow key ${unkow}\");\n            }\n          }\n          r.endObject();\n          break;\n        case _ => throw Exception(\"can't deserialize for ProcessJson\");\n      }\n    }\n    return PreTokenizerJson(temp_p_type, temp_pre_tokenizers);\n  }\n\n}\n\npublic struct ModelJson <: JsonDeserializable<ModelJson> {\n  let p_type: String;\n  let dropout: Option<Float32>;\n  var unk_token: Option<String> = None;\n  var continuing_subword_prefix: String = \"\";\n  var end_of_word_suffix: String = \"\";\n  var fuse_unk: Bool = false;\n  var byte_fallback: Bool = false;\n  let vocab: HashMap<String, UInt32>;\n  let merges: ArrayList<String>;\n  public init(\n    p_type: String,\n    dropout: Option<Float32>,\n    vocab: HashMap<String, UInt32>,\n    merges: ArrayList<String>,\n    unk_token!: Option<String> = None,\n    continuing_subword_prefix!: String = \"\",\n    end_of_word_suffix!: String = \"\",\n    fuse_unk!: Bool = false,\n    byte_fallback!: Bool = false\n  ) {\n    this.p_type = p_type;\n    if (dropout.isSome()) {\n      let dropout_value = dropout.getOrThrow();\n      if (dropout_value < 0.0 || dropout_value > 1.0) {\n        throw Exception(\"dropout can only between 0~1\")\n      }\n    }\n    this.dropout = dropout;\n    this.unk_token = unk_token;\n    this.continuing_subword_prefix = continuing_subword_prefix;\n    this.end_of_word_suffix = end_of_word_suffix;\n    this.fuse_unk = fuse_unk;\n    this.byte_fallback = byte_fallback;\n    this.vocab = vocab;\n    this.merges = merges;\n  }\n\n  public static func fromJson(r: JsonReader): ModelJson {\n    var temp_p_type: String = \"\";\n    var temp_dropout: Option<Float32> = None;\n    var temp_unk_token: Option<String> = None;\n    var temp_continuing_subword_prefix: String = \"\";\n    var temp_end_of_word_suffix: String = \"\";\n    var temp_fuse_unk: Bool = false;\n    var temp_byte_fallback: Bool = false;\n    var temp_vocab: HashMap<String, UInt32> = HashMap<String, UInt32>();\n    var temp_merges: ArrayList<String> = ArrayList<String>();\n    while (let Some(v) <- r.peek()) {\n      match(v) {\n        case BeginObject =>\n          r.startObject();\n          while(r.peek() != EndObject) {\n            let n = r.readName()\n            match (n) {\n              case \"type\" => temp_p_type = r.readValue<String>();\n              case \"dropout\" => temp_dropout = r.readValue<Option<Float32>>();\n              case \"unk_token\" => temp_unk_token = r.readValue<Option<String>>()\n              case \"continuing_subword_prefix\" => temp_continuing_subword_prefix = r.readValue<String>();\n              case \"end_of_word_suffix\" => temp_end_of_word_suffix = r.readValue<String>();\n              case \"fuse_unk\" => temp_fuse_unk = r.readValue<Bool>();\n              case \"byte_fallback\" => temp_byte_fallback = r.readValue<Bool>();\n              case \"vocab\" => temp_vocab = r.readValue<HashMap<String, UInt32>>();\n              case \"merges\" => temp_merges = r.readValue<ArrayList<String>>();\n              case unkow => println(\"unkow key ${unkow}\");\n            }\n          }\n          r.endObject();\n          break;\n        case _ => throw Exception(\"can't deserialize for ModelJson\");\n      }\n    }\n    return ModelJson(\n      temp_p_type,\n      temp_dropout,\n      temp_vocab,\n      temp_merges,\n      unk_token: temp_unk_token,\n      continuing_subword_prefix: temp_continuing_subword_prefix,\n      end_of_word_suffix: temp_end_of_word_suffix,\n      fuse_unk: temp_fuse_unk,\n      byte_fallback: temp_byte_fallback\n    );\n  }\n}\n\npublic struct TokenizerJson <: JsonDeserializable<TokenizerJson> {\n  let version: String;\n  let truncation: Option<String>;\n  let padding: Option<String>;\n  let added_tokens: ArrayList<TokenJson>;\n  let normalizer: NormalizerJson;\n  let pre_tokenizer: PreTokenizerJson;\n  let post_processor: ProcessJson;\n  let decoder: ProcessJson;\n  let model: ModelJson;\n\n  public init(\n    version: String,\n    truncation: Option<String>,\n    padding: Option<String>,\n    added_tokens: ArrayList<TokenJson>,\n    normalizer: NormalizerJson,\n    pre_tokenizer: PreTokenizerJson,\n    post_processor: ProcessJson,\n    decoder: ProcessJson,\n    model: ModelJson\n  ) {\n    this.version = version;\n    this.truncation = truncation;\n    this.padding = padding;\n    this.added_tokens = added_tokens;\n    this.normalizer = normalizer;\n    this.pre_tokenizer = pre_tokenizer;\n    this.post_processor = post_processor;\n    this.decoder = decoder;\n    this.model = model;\n  }\n\n  public static func fromJson(r: JsonReader): TokenizerJson {\n    var temp_version: String = \"\";\n    var temp_truncation: Option<String> = None;\n    var temp_padding: Option<String> = None;\n    var temp_added_tokens: ArrayList<TokenJson> = ArrayList<TokenJson>();\n    var temp_normalizer: NormalizerJson = NormalizerJson(\"\");\n    var temp_pre_tokenizer: PreTokenizerJson = PreTokenizerJson();\n    var temp_post_processor: Option<ProcessJson> = None;\n    var temp_decoder: Option<ProcessJson> = None;\n    var temp_model: Option<ModelJson> = None;\n    while (let Some(v) <- r.peek()) {\n      match(v) {\n        case BeginObject =>\n          r.startObject();\n          while(r.peek() != EndObject) {\n            let n = r.readName()\n            match (n) {\n              case \"version\" => temp_version = r.readValue<String>();\n              case \"truncation\" => temp_truncation = r.readValue<Option<String>>();\n              case \"padding\" => temp_padding = r.readValue<Option<String>>();\n              case \"added_tokens\" => temp_added_tokens = r.readValue<ArrayList<TokenJson>>();\n              case \"normalizer\" => temp_normalizer = r.readValue<NormalizerJson>();\n              case \"pre_tokenizer\" => temp_pre_tokenizer = r.readValue<PreTokenizerJson>();\n              case \"post_processor\" => temp_post_processor = Some(r.readValue<ProcessJson>());\n              case \"decoder\" => temp_decoder = Some(r.readValue<ProcessJson>());\n              case \"model\" => temp_model = Some(r.readValue<ModelJson>());\n              case unkow => println(\"unkow key ${unkow}\");\n            }\n          }\n          r.endObject();\n          break;\n        case _ => throw Exception(\"can't deserialize for ProcessJson\");\n      }\n    }\n    return TokenizerJson(\n      temp_version,\n      temp_truncation,\n      temp_padding,\n      temp_added_tokens,\n      temp_normalizer,\n      temp_pre_tokenizer,\n      temp_post_processor.getOrThrow(),\n      temp_decoder.getOrThrow(),\n      temp_model.getOrThrow(),\n    );\n  }\n}", "llm_cg": {"TokenJson": [], "TokenJson.fromJson": ["r.peek", "r.startObject", "r.peek", "r.readName", "r.readValue", "<builtin>.println", "r.endObject", "<builtin>.throw", "TokenJson"], "NormalizerJson": [], "NormalizerJson.fromJson": ["r.peek", "r.startObject", "r.peek", "r.readName", "r.readValue", "<builtin>.println", "r.endObject", "<builtin>.throw", "NormalizerJson"], "PatternJson": [], "PatternJson.fromJson": ["r.peek", "r.startObject", "r.peek", "r.readName", "r.readValue", "<builtin>.println", "r.endObject", "<builtin>.throw", "PatternJson"], "ProcessJson": ["<builtin>.throw"], "ProcessJson.fromJson": ["r.peek", "r.startObject", "r.peek", "r.readName", "r.readValue", "<builtin>.println", "r.endObject", "<builtin>.throw"], "PreTokenizerJson": [], "PreTokenizerJson.fromJson": ["r.peek", "r.startObject", "r.peek", "r.readName", "r.readValue", "<builtin>.println", "r.endObject", "<builtin>.throw", "PreTokenizerJson"], "ModelJson": [], "ModelJson.fromJson": ["r.peek", "r.startObject", "r.peek", "r.readName", "r.readValue", "<builtin>.println", "r.endObject", "<builtin>.throw", "ModelJson"], "TokenizerJson": [], "TokenizerJson.fromJson": ["r.peek", "r.startObject", "r.peek", "r.readName", "r.readValue", "<builtin>.println", "r.endObject", "<builtin>.throw", "TokenizerJson"]}, "static_cg": {}}
{"source_code": "package tokenizer\n\nmain(): Int64 {\n    let vocab_path = \"./download/Qwen2-0.5B-Instruct/tokenizer.json\";\n    let system_prompt = \"You are a helpful assistant.\";\n    let tokenizer = HuggingfaceTokenizer()\n    tokenizer.load_vocab(file_path: vocab_path);\n    // -- test1 --- //\n    println(\"===== test1 ===== \");\n    let raw_text = \"世界你好，hello world!\";\n    let encode_tokens1 = tokenizer.encode(raw_text);\n    println(\"encode_tokens: ${encode_tokens1}\");\n    let decode_str1 = tokenizer.decode(encode_tokens1, skip_special_tokens: false);\n    println(\"deocode_str: ${decode_str1}\");\n    println(\"===== ===== ===== \");\n\n    // -- test2 -- //\n    println(\"===== test2 ===== \");\n    let raw_text2 = raw_text + \"<|im_end|>\";\n    let encode_tokens2 = tokenizer.encode(raw_text2);\n    println(\"encode_tokens: ${encode_tokens2}\");\n    let decode_str2 = tokenizer.decode(encode_tokens2, skip_special_tokens: false);\n    println(\"deocode_str(with special)    : ${decode_str2}\");\n    let decode_str3 = tokenizer.decode(encode_tokens2, skip_special_tokens: true);\n    println(\"deocode_str(without special) : ${decode_str3}\");\n    println(\"===== ===== ===== \");\n\n    // --- test3 --- //\n    println(\"===== test3 ===== \");\n    let messages = ArrayList<Message>([\n        Message(RoleType.System, system_prompt),\n        Message(RoleType.User, raw_text)\n    ])\n    let new_text = tokenizer.apply_chat_template(messages, add_generation_prompt: true);\n    println(\"new_text:\\n ${new_text}\");\n    return 0\n}", "llm_cg": {"main": ["HuggingfaceTokenizer", "HuggingfaceTokenizer.load_vocab", "<builtin>.println", "HuggingfaceTokenizer.encode", "HuggingfaceTokenizer.decode", "<builtin>.println", "<builtin>.ArrayList", "<builtin>.Message", "HuggingfaceTokenizer.apply_chat_template"]}, "static_cg": {}}
{"source_code": "package tokenizer\nimport encoding.json.stream.*\nimport std.collection.ArrayList\nimport std.io.ByteArrayStream\n\npublic enum SamplingMethod {\n  Greedy | Top_p | Top_k\n}\n\npublic struct ModelState {\n  public var code: Int64;\n  public var is_end: Bool;\n  public var message: String = \"\";\n  public init(\n    code!: Int64 = 200,\n    is_end!: Bool = false,\n    message!: String = \"\"\n  ) {\n    this.code = code;\n    this.is_end = is_end;\n    this.message = message;\n  }\n}\n\npublic struct FunctionCall <: JsonDeserializable<FunctionCall> & JsonSerializable {\n  public let name: String;\n  public let arguments: String;\n\n  public init(name: String, arguments: String) {\n    this.name = name;\n    this.arguments = arguments;\n  }\n\n  public static func fromJson(r: JsonReader): FunctionCall {\n    var temp_name: String = \"\";\n    var temp_arguments: String = \"\";\n    while (let Some(v) <- r.peek()) {\n      match(v) {\n        case BeginObject =>\n          r.startObject();\n          while(r.peek() != EndObject) {\n              let n = r.readName()\n              match (n) {\n                  case \"name\" => temp_name = r.readValue<String>();\n                  case \"arguments\" => temp_arguments = r.readValue<String>();\n                  case unkow => println(\"unkow key ${unkow}\");\n              }\n          }\n          r.endObject();\n          break;\n        case _ => throw Exception(\"can't deserialize for FunctionCall\");\n      }\n    }\n    return FunctionCall(temp_name, temp_arguments);\n  }\n\n  public func toJson(w: JsonWriter) {\n    w.startObject();\n    w.writeName(\"name\").writeValue<String>(this.name);\n    w.writeName(\"arguments\").writeValue<String>(this.arguments);\n    w.endObject();\n    w.flush();\n  }\n}\n\npublic enum RoleType {\n  User | Assistant | System | Function | NULL\n}\n\npublic func role_type_to_str(role: RoleType): Option<String> {\n  return match(role) {\n    case RoleType.User => Some(\"user\")\n    case RoleType.Assistant => Some(\"assistant\")\n    case RoleType.System => Some(\"system\")\n    case RoleType.Function => Some(\"function\")\n    case RoleType.NULL => None\n  }\n}\n\npublic func str_to_role_type(role_option_str: Option<String>): RoleType {\n  return match(role_option_str) {\n    case Some(role_option) => \n      match (role_option) {\n        case \"user\" => RoleType.User\n        case \"assistant\" => RoleType.Assistant\n        case \"system\" => RoleType.System\n        case \"function\" => RoleType.Function\n        case x => throw Exception(\"unknow enum ${x} for RoleType\");\n      }\n    case None => RoleType.NULL\n  }\n}\n\n\npublic struct Message<: JsonDeserializable<Message> & JsonSerializable {\n  public let role: RoleType;\n  public var content: String;\n  public let function_call: Option<FunctionCall>;\n\n  public init(role: RoleType, content: String) {\n    this.role = role;\n    this.content = content;\n    this.function_call = None;\n  }\n\n  public init(role: RoleType, content: String, function_call: Option<FunctionCall>) {\n    this.role = role;\n    this.content = content;\n    this.function_call = function_call;\n  }\n\n  public static func fromJson(r: JsonReader): Message {\n    var temp_role: Option<String> = None; // role may null in stream chat\n    var temp_content: String = \"\";\n    var temp_functional_call: Option<FunctionCall> = None;\n    while (let Some(v) <- r.peek()) {\n      match(v) {\n        case BeginObject =>\n          r.startObject();\n          while(r.peek() != EndObject) {\n              let n = r.readName()\n              match (n) {\n                  case \"role\" => temp_role = r.readValue<Option<String>>();\n                  case \"content\" => temp_content = r.readValue<String>();\n                  case \"function_call\" => temp_functional_call = r.readValue<Option<FunctionCall>>();\n                  case unkow => println(\"unkow key ${unkow}\");\n              }\n          }\n          r.endObject();\n          break;\n        case _ => throw Exception(\"can't deserialize for Message\");\n      }\n    }\n    let role_type: RoleType = str_to_role_type(temp_role);\n    return Message(role_type, temp_content);\n  }\n\n  public func toJson(w: JsonWriter) {\n    w.startObject();\n    w.writeName(\"role\").writeValue<Option<String>>(role_type_to_str(this.role));\n    w.writeName(\"content\").writeValue<String>(this.content);\n    w.endObject();\n    w.flush();\n  }\n}", "llm_cg": {"FunctionCall.fromJson": ["r.peek", "<builtin>.match", "r.startObject", "r.readName", "r.readValue", "<builtin>.println", "r.endObject", "<builtin>.throw", "FunctionCall"], "FunctionCall.toJson": ["w.startObject", "w.writeName", "w.writeValue", "w.writeName", "w.writeValue", "w.endObject", "w.flush"], "str_to_role_type": ["<builtin>.match", "<builtin>.throw"], "Message.fromJson": ["r.peek", "<builtin>.match", "r.startObject", "r.readName", "r.readValue", "<builtin>.println", "r.endObject", "<builtin>.throw", "str_to_role_type", "Message"], "Message.toJson": ["w.startObject", "w.writeName", "role_type_to_str", "w.writeValue", "w.writeName", "w.writeValue", "w.endObject", "w.flush"], "role_type_to_str": ["<builtin>.match"]}, "static_cg": {}}
{"source_code": "// 本示例演示访问 DeepSeek 大模型，可前往以下网址申请 API Key\n// https://platform.deepseek.com/api_keys\n// 仓颉语言团队 刘俊杰 2024.10.24\nimport std.io.*\nimport net.http.*\nimport net.tls.*\nimport encoding.json.*\n\nconst DEEPSEEK_API_KEY = '-------Your DeepSeek Key--------'\n\nextend Client {\n    public func chat(question: String) {\n        let info = \"\"\"\n        {\n            \"model\": \"deepseek-chat\",\n            \"messages\": [\n                {\"role\": \"system\", \"content\": \"你是我的全能助手，你的名字叫仓颉\"},\n                {\"role\": \"user\", \"content\": \"${question}\"}\n            ],\n            \"stream\": false\n        }\n        \"\"\"\n        let request = HttpRequestBuilder()\n            .url('https://api.deepseek.com/chat/completions')\n            .header('Authorization', 'Bearer ${DEEPSEEK_API_KEY}')\n            .header('Content-Type', 'application/json')\n            .body(info)\n            .post()\n            .build()\n        let response = this.send(request)\n        let text = StringReader(response.body).readToEnd()\n        return parse(text) + '\\n---------------------------'\n    }\n}\n\nfunc parse(text: String) {\n    let json = JsonValue.fromStr(text).asObject()\n    let choices = json.getFields()['choices'].asArray()\n    let message = choices[0].asObject().getFields()['message'].asObject()\n    let content = message.getFields()['content'].asString().getValue()\n    return content\n}\n\nmain() {\n    var config = TlsClientConfig()\n    config.verifyMode = TrustAll\n    let client = ClientBuilder()\n        .tlsConfig(config)\n        .readTimeout(Duration.Max) // AI 服务响应有时候比较慢，这里设置为无限等待\n        .build()\n    println(client.chat(\"你好呀，请做个自我介绍吧\"))\n    println(client.chat(\"周杰伦在 2000 到 2010 年之间出过哪些专辑\"))\n    println(client.chat(\"请背诵《卜算子·送鲍浩然之浙东》\"))\n    println(client.chat(\"在编程框架中，网络拦截器的作用是什么\"))\n    client.close()\n}\n", "llm_cg": {"main": ["TlsClientConfig", "ClientBuilder", "ClientBuilder.tlsConfig", "ClientBuilder.readTimeout", "ClientBuilder.build", "Client.chat", "<builtin>.println", "Client.close"], "Client": ["HttpRequestBuilder", "HttpRequestBuilder.url", "HttpRequestBuilder.header", "HttpRequestBuilder.body", "HttpRequestBuilder.post", "HttpRequestBuilder.build", "Client.send", "StringReader", "StringReader.readToEnd", "parse"], "parse": ["JsonValue.fromStr", "JsonValue.asObject", "JsonValue.getFields", "JsonValue.asArray", "JsonValue.asObject", "JsonValue.getFields", "JsonValue.asObject", "JsonValue.getFields", "JsonValue.asString", "JsonValue.getValue"]}, "static_cg": {}}
{"source_code": "package opds_cj\n\nimport net.http.ServerBuilder\n// import std.log.*\nimport opds_cj.router.NaiveDistributor\nimport opds_cj.path.pathLoad\n// import opds_cj.macros.*\n\n// @include(\"./lib/sqlite/sqlite3.h\")\n\nmain() {\n    let router = NaiveDistributor()\n\n    for ((k, v) in pathLoad().paths) {\n        router.register(k, v)\n        println(\"registered ${k}\")\n    }\n\n    let server = ServerBuilder().addr(\"0.0.0.0\").port(8080).distributor(router).build()\n\n    println(\"run at http://127.0.0.1:8080\")\n    // server.logger.level = DEBUG\n    server.serve()\n}\n", "llm_cg": {"main": ["opds_cj.router.NaiveDistributor", "opds_cj.path.pathLoad", "NaiveDistributor.register", "<builtin>.println", "net.http.ServerBuilder", "ServerBuilder.addr", "addr.port", "port.distributor", "distributor.build", "ServerBuilder.serve"]}, "static_cg": {}}
{"source_code": "package opds_cj.sqlite\n\nimport std.database.sql.SqlException\n\n/* sqlite3_step() 还未完成执行 */\npublic let SQLITE_ROW: Int32 = 100\n/* sqlite3_step() 已执行完成 */\npublic let SQLITE_DONE: Int32 = 101\n/* 指针类型占内存字节数 */\nlet POINTER_SIZE: UIntNative = 8\n\nforeign func malloc(size: UIntNative): CPointer<Unit>\nforeign func free(p: CPointer<Unit>): Unit\n\n/* \n * Description: 打开数据库db文件\n */\nforeign func sqlite3_open(path: CString, ppDb: CPointer<CPointer<Unit>>): Int32\n\npublic func sqlOpen(path: String): CPointer<CPointer<Unit>> {\n    let ppDb: CPointer<CPointer<Unit>>\n    unsafe {\n        let ptr = malloc(POINTER_SIZE)\n        ppDb = CPointer<CPointer<Unit>>(ptr)\n        let cPath = LibC.mallocCString(path)\n        let ret = sqlite3_open(cPath, ppDb)\n        LibC.free(cPath)\n        if (ret != 0) {\n            throw SqlException(\"Failed to open database.\")\n        }\n    }\n    return ppDb\n}\n\n/* \n * Description: 预处理sql语句\n */\nforeign func sqlite3_prepare_v2(pDb: CPointer<Unit>, zSql: CString, nBytes: Int32, \n                                ppStmt: CPointer<CPointer<Unit>>, pzTail: CPointer<Unit>): Int32\n\npublic func sqlPrepare(ppDb: CPointer<CPointer<Unit>>, sql: String): CPointer<CPointer<Unit>> {\n    let ppStmt: CPointer<CPointer<Unit>>\n    unsafe {\n        let ptr = malloc(POINTER_SIZE)\n        ppStmt = CPointer<CPointer<Unit>>(ptr)\n        let zSql = LibC.mallocCString(sql)\n        let nullptr = CPointer<Unit>()\n        let ret = sqlite3_prepare_v2(ppDb.read(), zSql, Int32(sql.size), ppStmt, nullptr)\n        LibC.free(zSql)\n        if (ret != 0) {\n            throw SqlException(\"Failed to prepare statement.\")\n        }\n    }\n    return ppStmt\n}\n\n/* \n * Description: 执行sql语句\n */\nforeign func sqlite3_step(pStmt: CPointer<Unit>): Int32\n\npublic func sqlStep(ppStmt: CPointer<CPointer<Unit>>): Int32 {\n    return unsafe { sqlite3_step(ppStmt.read()) }\n}\n\n/* \n * Description: 获取sql结果指定列的数据类型\n */\nforeign func sqlite3_column_type(pStmt: CPointer<Unit>, i: Int32): Int32\n\npublic func sqlColumnType(ppStmt: CPointer<CPointer<Unit>>, i: Int32): Int32 {\n    return unsafe { sqlite3_column_type(ppStmt.read(), i) }\n}\n\n/* \n * Description: 获取sql结果指定文本类型列的值\n */\nforeign func sqlite3_column_text(pStmt: CPointer<Unit>, i: Int32): CString \n\npublic func sqlColumnText(ppStmt: CPointer<CPointer<Unit>>, i: Int32): String {\n    let ret = unsafe { sqlite3_column_text(ppStmt.read(), i) }\n    return ret.toString()\n}\n\n/* \n * Description: 获取sql结果指定列值的字节数\n */\nforeign func sqlite3_column_bytes(pStmt: CPointer<Unit>, i: Int32): Int32\n\npublic func sqlColumnBytes(ppStmt: CPointer<CPointer<Unit>>, i: Int32): Int32 {\n    return unsafe { sqlite3_column_bytes(ppStmt.read(), i) }\n}\n\n/* \n * Description: 获取sql结果指定Int64类型列的值\n */\nforeign func sqlite3_column_int64(pStmt: CPointer<Unit>, i: Int32): Int64\n\npublic func sqlColumnInt64(ppStmt: CPointer<CPointer<Unit>>, i: Int32): Int64 {\n    return unsafe { sqlite3_column_int64(ppStmt.read(), i) }\n}\n\n/* \n * Description: 获取sql结果指定Float64类型列的值\n */\nforeign func sqlite3_column_double(pStmt: CPointer<Unit>, i: Int32): Float64\n\npublic func sqlColumnDouble(ppStmt: CPointer<CPointer<Unit>>, i: Int32): Float64 {\n    return unsafe { sqlite3_column_double(ppStmt.read(), i) }\n}\n\n/* \n * Description: 获取sql结果blob类型列的值\n */\nforeign func sqlite3_column_blob(pStmt: CPointer<Unit>, i: Int32): CPointer<Byte>\n\npublic func sqlColumnBlob(ppStmt: CPointer<CPointer<Unit>>, i: Int32): CPointer<Byte> {\n    return unsafe { sqlite3_column_blob(ppStmt.read(), i) }\n}\n\n/* \n * Description: 获取sql结果列数\n */\nforeign func sqlite3_column_count(pStmt: CPointer<Unit>): Int32 \n\npublic func sqlColumnCount(ppStmt: CPointer<CPointer<Unit>>): Int32 {\n    return unsafe { sqlite3_column_count(ppStmt.read()) }\n}\n\n/* \n * Description: 获取sql结果指定列名\n */\nforeign func sqlite3_column_name(pStmt: CPointer<Unit>, n: Int32): CString\n\npublic func sqlColumnName(ppStmt: CPointer<CPointer<Unit>>, n: Int32): String {\n    let ret = unsafe { sqlite3_column_name(ppStmt.read(), n) }\n    return ret.toString()\n}\n\n/* \n * Description: 获取sql结果指定列声明的数据类型\n */\nforeign func sqlite3_column_decltype(pStmt: CPointer<Unit>, i: Int32): CString\n\npublic func sqlColumnDecltype(ppStmt: CPointer<CPointer<Unit>>, i: Int32): String {\n    let ret = unsafe { sqlite3_column_decltype(ppStmt.read(), i) }\n    return ret.toString()\n}\n\n/* \n * Description: 重置sql语句\n */\nforeign func sqlite3_reset(pStmt: CPointer<Unit>): Int32\n\npublic func sqlReset(ppStmt: CPointer<CPointer<Unit>>): Int32 {\n    return unsafe { sqlite3_reset(ppStmt.read()) }\n}\n\n/* \n * Description: 设置超时毫秒数\n */\nforeign func sqlite3_busy_timeout(pDb: CPointer<Unit>, ms: Int32): Int32 \n\npublic func sqlBusyTimeout(ppDb: CPointer<CPointer<Unit>>, ms: Int32): Int32 {\n    return unsafe { sqlite3_busy_timeout(ppDb.read(), ms) }\n}\n\n/* \n * Description: 获取最近执行的sql语句的修改数量\n */\nforeign func sqlite3_changes(pDb: CPointer<Unit>): Int32\n\npublic func sqlChanges(ppDb: CPointer<CPointer<Unit>>): Int32 {\n    return unsafe { sqlite3_changes(ppDb.read()) }\n}\n\n/* \n * Description: 获取最近插入行的ID\n */\nforeign func sqlite3_last_insert_rowid(pDb: CPointer<Unit>): Int64\n\npublic func sqlLastInsertRowid(ppDb: CPointer<CPointer<Unit>>): Int64 {\n    return unsafe { sqlite3_last_insert_rowid(ppDb.read()) }\n}\n\n/* \n * Description: 设置堆内存上限\n */\nforeign func sqlite3_soft_heap_limit(n: Int32): Unit\n\npublic func sqlSoftHeapLimit(n: Int32): Unit {\n    unsafe { sqlite3_soft_heap_limit(n) }\n}\n\n/* \n * Description: 获取sql语句绑定参数数量\n */\nforeign func sqlite3_bind_parameter_count(pStmt: CPointer<Unit>): Int32\n\npublic func sqlBindParameterCount(ppStmt: CPointer<CPointer<Unit>>): Int32 {\n    return unsafe { sqlite3_bind_parameter_count(ppStmt.read()) }\n}\n\n/* \n * Description: 绑定空值到sql语句指定参数\n */\nforeign func sqlite3_bind_null(pStmt: CPointer<Unit>, i: Int32): Int32\n\npublic func sqlBindNull(ppStmt: CPointer<CPointer<Unit>>, i: Int32): Int32 {\n    return unsafe { sqlite3_bind_null(ppStmt.read(), i) }\n}\n\n/* \n * Description: 绑定Int32值到sql语句指定参数\n */\nforeign func sqlite3_bind_int(pStmt: CPointer<Unit>, i: Int32, iValue: Int32): Int32\n\npublic func sqlBindInt(ppStmt: CPointer<CPointer<Unit>>, i: Int32, iValue: Int32): Int32 {\n    return unsafe { sqlite3_bind_int(ppStmt.read(), i, iValue) }\n}\n\n/* \n * Description: 绑定Int64值到sql语句指定参数\n */\nforeign func sqlite3_bind_int64(pStmt: CPointer<Unit>, i: Int32, iValue: Int64): Int32\n\npublic func sqlBindInt64(ppStmt: CPointer<CPointer<Unit>>, i: Int32, iValue: Int64): Int32 {\n    return unsafe { sqlite3_bind_int64(ppStmt.read(), i, iValue) }\n}\n\n/* \n * Description: 绑定Float64值到sql语句指定参数\n */\nforeign func sqlite3_bind_double(pStmt: CPointer<Unit>, i: Int32, rValue: Float64): Int32\n\npublic func sqlBindDouble(ppStmt: CPointer<CPointer<Unit>>, i: Int32, rValue: Float64): Int32 {\n    return unsafe { sqlite3_bind_double(ppStmt.read(), i, rValue) }\n}\n\n/* \n * Description: 绑定文本值到sql语句指定参数\n */\nforeign func sqlite3_bind_text(pStmt: CPointer<Unit>, i: Int32, zData: CString, \n    nData: Int32, xDel: CPointer<Unit>): Int32\n\npublic func sqlBindText(ppStmt: CPointer<CPointer<Unit>>, i: Int32, data: String) {\n    let ret: Int32\n    unsafe {\n        let zData = LibC.mallocCString(data)\n        let nullptr = CPointer<Unit>()\n        ret = sqlite3_bind_text(ppStmt.read(), i, zData, Int32(data.size), nullptr)\n        LibC.free(zData)\n    }\n    return ret\n}\n\n/* \n * Description: 解除sql语句绑定参数\n */\nforeign func sqlite3_clear_bindings(pStmt: CPointer<Unit>): Int32\n\npublic func sqlClearBindings(ppStmt: CPointer<CPointer<Unit>>): Int32 {\n    return unsafe { sqlite3_clear_bindings(ppStmt.read()) }\n}\n\n/* \n * Description: 指定数据库执行sql命令\n */\nforeign func sqlite3_exec(pDb: CPointer<Unit>, zSql: CString, \n    xCallback: CPointer<Unit>, pArg: CPointer<Unit>, pzErrMsg: CPointer<CString>): Int32\n\npublic func sqlExec(ppDb: CPointer<CPointer<Unit>>, sql: String) {\n    unsafe {\n        let zSql = LibC.mallocCString(sql)\n        let nullptr = CPointer<Unit>()\n        let ptr = malloc(POINTER_SIZE)\n        let pzErrMsg = CPointer<CString>(ptr)\n        let ret = sqlite3_exec(ppDb.read(), zSql, nullptr, nullptr, pzErrMsg)\n        let errMsg = pzErrMsg.read().toString()\n        free(ptr)\n        LibC.free(zSql)\n        if (ret != 0) {\n            throw SqlException(errMsg)\n        }\n    }\n}\n\n/* \n * Description: 关闭数据库连接\n */\nforeign func sqlite3_close(pDb: CPointer<Unit>): Int32\n\npublic func sqlClose(ppDb: CPointer<CPointer<Unit>>): Int32 {\n    let ret: Int32\n    unsafe {\n        ret = sqlite3_close(ppDb.read())\n        free(CPointer<Unit>(ppDb))\n    }\n    return ret\n}\n\n/* \n * Description: 销毁sql语句对象，释放内存\n */\nforeign func sqlite3_finalize(pStmt: CPointer<Unit>): Int32\n\npublic func sqlFinalize(ppStmt: CPointer<CPointer<Unit>>): Int32 {\n    let ret: Int32\n    unsafe {\n        ret = sqlite3_finalize(ppStmt.read())\n        free(CPointer<Unit>(ppStmt))\n    }\n    return ret\n}\n\n", "llm_cg": {"main": [], "sqlOpen": ["malloc", "LibC.mallocCString", "sqlite3_open", "LibC.free", "std.database.sql.SqlException"], "sqlPrepare": ["malloc", "LibC.mallocCString", "CPointer", "sqlite3_prepare_v2", "LibC.free", "std.database.sql.SqlException"], "sqlStep": ["sqlite3_step"], "sqlColumnType": ["sqlite3_column_type"], "sqlColumnText": ["sqlite3_column_text", "UnsafeCString.toString"], "sqlColumnBytes": ["sqlite3_column_bytes"], "sqlColumnInt64": ["sqlite3_column_int64"], "sqlColumnDouble": ["sqlite3_column_double"], "sqlColumnBlob": ["sqlite3_column_blob"], "sqlColumnCount": ["sqlite3_column_count"], "sqlColumnName": ["sqlite3_column_name", "UnsafeCString.toString"], "sqlColumnDecltype": ["sqlite3_column_decltype", "UnsafeCString.toString"], "sqlReset": ["sqlite3_reset"], "sqlBusyTimeout": ["sqlite3_busy_timeout"], "sqlChanges": ["sqlite3_changes"], "sqlLastInsertRowid": ["sqlite3_last_insert_rowid"], "sqlSoftHeapLimit": ["sqlite3_soft_heap_limit"], "sqlBindParameterCount": ["sqlite3_bind_parameter_count"], "sqlBindNull": ["sqlite3_bind_null"], "sqlBindInt": ["sqlite3_bind_int"], "sqlBindInt64": ["sqlite3_bind_int64"], "sqlBindDouble": ["sqlite3_bind_double"], "sqlBindText": ["LibC.mallocCString", "sqlite3_bind_text", "LibC.free"], "sqlClearBindings": ["sqlite3_clear_bindings"], "sqlExec": ["LibC.mallocCString", "malloc", "sqlite3_exec", "CPointer", "UnsafeCString.toString", "free", "LibC.free", "std.database.sql.SqlException"], "sqlClose": ["sqlite3_close", "free"], "sqlFinalize": ["sqlite3_finalize", "free"]}, "static_cg": {}}
{"source_code": "package opds_cj.router\n\nimport net.http.*\nimport std.collection.HashMap\n\npublic class NaiveDistributor <: HttpRequestDistributor {\n    let routerMap = HashMap<String, HttpRequestHandler>()\n    public func register(path: String, handler: HttpRequestHandler): Unit {\n        routerMap.put(path, handler)\n    }\n\n    public func distribute(path: String): HttpRequestHandler {\n        if (routerMap.contains(path)) {\n            return routerMap[path]\n        }\n        for ((routerPath, handler) in routerMap) {\n            var fail = false\n            var partPath = path.trimEnd(\"/\").split(\"/\")\n            var partRouterPath = routerPath.trimEnd(\"/\").split(\"/\")\n            if (partPath.size != partRouterPath.size) {\n                continue\n            }\n            for (i in 0..partPath.size) {\n                if (partRouterPath[i].startsWith(\":\")) {\n                    continue\n                }\n                if (partPath[i] != partRouterPath[i]) {\n                    fail = true\n                    break\n                }\n            }\n            if (!fail) {\n                return handler\n            }\n        }\n        return NotFoundHandler()\n    }\n}\n\nclass NotFoundHandler <: HttpRequestHandler {\n    public func handle(httpContext: HttpContext): Unit {\n        httpContext.responseBuilder.status(404).body(\"404 Not Found\".toArray())\n    }\n}\n\npublic struct PathMap {\n    public var paths = HashMap<String, (HttpContext) -> Unit>()\n\n    public init() {\n    }\n    \n    public init(path: String, handler: (HttpContext) -> Unit) {\n        this.paths.put(path, handler)\n    }\n\n    public func add(path: String, handler: (HttpContext) -> Unit): Unit {\n        this.paths.put(path, handler)\n    }\n\n    public func merge(addPathMap: PathMap): Unit {\n        this.paths.putAll(addPathMap.paths)\n    }\n}", "llm_cg": {"main": [], "NaiveDistributor": [], "NaiveDistributor.register": ["routerMap.put"], "NaiveDistributor.distribute": ["routerMap.contains", "routerMap.trimEnd", "routerMap.split", "routerMap.size", "routerMap.startsWith", "NotFoundHandler"], "NotFoundHandler": [], "NotFoundHandler.handle": ["httpContext.responseBuilder.status", "httpContext.responseBuilder.body", "httpContext.responseBuilder.toArray"], "PathMap": [], "PathMap.init": ["this.paths.put"], "PathMap.init(path: String, handler: (HttpContext) -> Unit)": ["this.paths.put"], "PathMap.add": ["this.paths.put"], "PathMap.merge": ["this.paths.putAll"]}, "static_cg": {}}
{"source_code": "package opds_cj.data_stru\n\nimport encoding.base64.*\nimport opds_cj.sqlite.*\nimport opds_cj.config.baseConfig\n\npublic class User{\n    public var id:String = \"\"\n    public var email:String = \"\"\n    var password:String = \"\"\n    public init(authStr:Option<String>){\n        var auth:String=\"\"\n        match(authStr){\n            case Some(x) => auth = x.trimStart(\"Basic \")\n            case None => return\n        }\n        let decode = String.fromUtf8(fromBase64String(auth).getOrThrow()).split(\":\")\n        this.email = decode[0]\n        this.password = decode[1]\n        this.id = getID(this.email)\n    }\n\n    func getID(email:String):String{\n        var sql = \"SELECT ID FROM USER WHERE EMAIL='${email}';\"\n        var ppDb: CPointer<CPointer<Unit>> = sqlOpen(baseConfig.database)\n        var ppStmt = sqlPrepare(ppDb, sql)\n        var id = \"\"\n        while (sqlStep(ppStmt) != SQLITE_DONE) {\n            id = sqlColumnText(ppStmt, 0)\n        }\n        sqlFinalize(ppStmt)\n        sqlClose(ppDb)\n\n        return id\n    }\n}", "llm_cg": {"User": ["User.getID", "String.fromUtf8", "fromBase64String", "getID", "String.split"], "User.getID": ["baseConfig.database", "sqlOpen", "sqlPrepare", "sqlStep", "sqlColumnText", "sqlFinalize", "sqlClose"]}, "static_cg": {}}
{"source_code": "package opds_cj.data_stru\n\nimport opds_cj.sqlite.*\nimport encoding.json.stream.*\nimport std.{io.*,collection.*}\nimport opds_cj.config.baseConfig\n\nfunc sqlRun(location: String, sql: String): String {\n    var ppDb: CPointer<CPointer<Unit>> = sqlOpen(location)\n    var ppStmt = sqlPrepare(ppDb, sql)\n    var jsonStrList = \"\"\n    while (sqlStep(ppStmt) != SQLITE_DONE) {\n        jsonStrList = sqlColumnText(ppStmt, 0)\n    }\n    sqlFinalize(ppStmt)\n    sqlClose(ppDb)\n    return jsonStrList\n}\n\npublic class BookSeries <: JsonDeserializable<BookSeries> {\n    public var id: String = \"0F00000000000\"\n    public var name: String = \"name\"\n    public var bookCount: Int64 = 0\n    public var url: String = \"\"\n    public var createdDate: String = \"\"\n    public var lastModifiedDate: String = \"\"\n    public var fileLastModified: String = \"\"\n\n    public static func fromJson(r: JsonReader): BookSeries {\n        var res = BookSeries()\n        while (let Some(v) <- r.peek()) {\n            match (v) {\n                case BeginObject =>\n                    r.startObject()\n                    while (r.peek() != EndObject) {\n                        let n = r.readName()\n                        match (n) {\n                            case \"ID\" => res.id = r.readValue<String>()\n                            case \"NAME\" => res.name = r.readValue<String>()\n                            case \"BOOK_COUNT\" => res.bookCount = r.readValue<Int64>()\n                            case \"URL\" => res.url = r.readValue<String>()\n                            case \"CREATED_DATE\" => res.createdDate = r.readValue<String>()\n                            case \"LAST_MODIFIED_DATE\" => res.lastModifiedDate = r.readValue<String>()\n                            case \"FILE_LAST_MODIFIED\" => res.fileLastModified = r.readValue<String>()\n                            case _ => ()\n                        }\n                    }\n                    r.endObject()\n                    break\n                case _ => throw Exception()\n            }\n        }\n        return res\n    }\n\n    public static func fromJsonToArray(r: JsonReader): ArrayList<BookSeries> {\n        var res = ArrayList<BookSeries>()\n        while (let Some(v) <- r.peek()) {\n            match (v) {\n                case BeginArray =>\n                    r.startArray()\n                    while (r.peek() != EndArray) {\n                        res.append(BookSeries.fromJson(r))\n                    }\n                    r.endArray()\n                    break\n                case _ => throw Exception()\n            }\n        }\n        return res\n    }\n\n    public static func query(query:String): ArrayList<BookSeries> {\n        var sql = \"SELECT json_group_array(json_object('ID', ID, 'NAME', NAME,'BOOK_COUNT',BOOK_COUNT,'URL',URL,'CREATED_DATE',CREATED_DATE,'LAST_MODIFIED_DATE',LAST_MODIFIED_DATE,'FILE_LAST_MODIFIED',FILE_LAST_MODIFIED)) FROM SERIES WHERE NAME LIKE '%${query}%';\"\n        var jsonStrList = sqlRun(baseConfig.database, sql)\n\n        var bas = ByteBuffer()\n        unsafe { bas.write(jsonStrList.rawData()) }\n        var reader = JsonReader(bas)\n        return BookSeries.fromJsonToArray(reader)\n    }    \n\n    public static func formDatabase(location: String, page!: Int64 = 0,count!: Int64 = 5,libId!: String = \"\"): ArrayList<BookSeries> {\n        var sql = \"SELECT json_group_array(json_object('ID', ID, 'NAME', NAME,'BOOK_COUNT',BOOK_COUNT,'URL',URL,'CREATED_DATE',CREATED_DATE,'LAST_MODIFIED_DATE',LAST_MODIFIED_DATE,'FILE_LAST_MODIFIED',FILE_LAST_MODIFIED)) FROM ( SELECT * FROM SERIES ORDER BY LAST_MODIFIED_DATE DESC LIMIT ${count} OFFSET ${page * count} )\"\n        if (libId != \"\") {\n            sql = \"SELECT json_group_array(json_object('ID', ID, 'NAME', NAME,'BOOK_COUNT',BOOK_COUNT,'URL',URL,'CREATED_DATE',CREATED_DATE,'LAST_MODIFIED_DATE',LAST_MODIFIED_DATE,'FILE_LAST_MODIFIED',FILE_LAST_MODIFIED)) FROM ( SELECT * FROM SERIES WHERE LIBRARY_ID = '${libId}' ORDER BY LAST_MODIFIED_DATE DESC LIMIT ${count} OFFSET ${page * count} )\"\n        }\n        var jsonStrList = sqlRun(location, sql)\n\n        var bas = ByteBuffer()\n        unsafe { bas.write(jsonStrList.rawData()) }\n        var reader = JsonReader(bas)\n        return BookSeries.fromJsonToArray(reader)\n    }\n\n    public static func formPublisher(publisher: String): ArrayList<BookSeries> {\n        var sql = \"SELECT json_group_array(json_object('ID', ID, 'NAME', NAME,'BOOK_COUNT',BOOK_COUNT,'URL',URL,'CREATED_DATE',CREATED_DATE,'LAST_MODIFIED_DATE',LAST_MODIFIED_DATE,'FILE_LAST_MODIFIED',FILE_LAST_MODIFIED)) FROM SERIES WHERE ID IN ( SELECT SERIES_ID FROM SERIES_METADATA WHERE PUBLISHER = '${publisher}' );\"\n\n        var jsonStrList = sqlRun(baseConfig.database, sql)\n\n        var bas = ByteBuffer()\n        unsafe { bas.write(jsonStrList.rawData()) }\n        var reader = JsonReader(bas)\n        return BookSeries.fromJsonToArray(reader)\n    }\n\n    public static func getCount(id!:String=\"\") {\n        var sql = \"SELECT COUNT(*) FROM SERIES;\"\n        if (id!=\"\"){\n            sql = \"SELECT COUNT(*) FROM SERIES WHERE LIBRARY_ID = '${id}'\";\n        }\n        var ppDb: CPointer<CPointer<Unit>> = sqlOpen(baseConfig.database)\n        var ppStmt = sqlPrepare(ppDb, sql)\n        var number = 1\n        while (sqlStep(ppStmt) != SQLITE_DONE) {\n            number = sqlColumnInt64(ppStmt, 0)\n        }\n        sqlFinalize(ppStmt)\n        sqlClose(ppDb)\n\n        return number\n    }\n\n    public static func getDesc(id: String) {\n        var sql = \"SELECT SUMMARY FROM SERIES_METADATA WHERE SERIES_ID = '${id}'\"\n        var ppDb: CPointer<CPointer<Unit>> = sqlOpen(baseConfig.database)\n        var ppStmt = sqlPrepare(ppDb, sql)\n        var desc = \"\"\n        while (sqlStep(ppStmt) != SQLITE_DONE) {\n            desc = sqlColumnText(ppStmt, 0)\n        }\n        sqlFinalize(ppStmt)\n        sqlClose(ppDb)\n\n        return desc\n    }\n\n    public static func fromId(id: String): BookSeries {\n        var sql = \"SELECT json_object('ID', ID, 'NAME', NAME,'BOOK_COUNT',BOOK_COUNT,'URL',URL,'CREATED_DATE',CREATED_DATE,'LAST_MODIFIED_DATE',LAST_MODIFIED_DATE,'FILE_LAST_MODIFIED',FILE_LAST_MODIFIED) FROM SERIES WHERE ID = '${id}'\"\n        var jsonStrList = sqlRun(baseConfig.database, sql)\n        var bas = ByteBuffer()\n        unsafe { bas.write(jsonStrList.rawData()) }\n        var reader = JsonReader(bas)\n        return BookSeries.fromJson(reader)\n    }\n    public static func getPublishList(): ArrayList<String>{\n        var sql = \"SELECT DISTINCT PUBLISHER FROM SERIES_METADATA;\"\n        var ppDb: CPointer<CPointer<Unit>> = sqlOpen(baseConfig.database)\n        var ppStmt = sqlPrepare(ppDb, sql)\n        var listStr = ArrayList<String>()\n        while (sqlStep(ppStmt) != SQLITE_DONE) {\n            for (i in 0..sqlColumnCount(ppStmt)){\n                listStr.append(sqlColumnText(ppStmt, i))\n            }\n        }\n        sqlFinalize(ppStmt)\n        sqlClose(ppDb)\n\n        return listStr\n    }\n}\n\npublic class Books <: JsonDeserializable<Books> {\n    public var id: String = \"0F00000000000\"\n    public var seriesId: String = \"0F00000000000\"\n    public var libraryId: String = \"0F00000000000\"\n    public var name: String = \"name\"\n    public var number: Int64 = 0\n    public var pageCount: Int64 = 0\n    public var url: String = \"\"\n    public var createdDate: String = \"\"\n    public var lastModifiedDate: String = \"\"\n    public var fileLastModified: String = \"\"\n\n    public static func fromJson(r: JsonReader): Books {\n        var res = Books()\n        while (let Some(v) <- r.peek()) {\n            match (v) {\n                case BeginObject =>\n                    r.startObject()\n                    while (r.peek() != EndObject) {\n                        let n = r.readName()\n                        match (n) {\n                            case \"ID\" => res.id = r.readValue<String>()\n                            case \"SERIES_ID\" => res.seriesId = r.readValue<String>()\n                            case \"LIBRARY_ID\" => res.libraryId = r.readValue<String>()\n                            case \"NAME\" => res.name = r.readValue<String>()\n                            case \"NUMBER\" => res.number = r.readValue<Int64>()\n                            case \"URL\" => res.url = r.readValue<String>()\n                            case \"CREATED_DATE\" => res.createdDate = r.readValue<String>()\n                            case \"LAST_MODIFIED_DATE\" => res.lastModifiedDate = r.readValue<String>()\n                            case \"FILE_LAST_MODIFIED\" => res.fileLastModified = r.readValue<String>()\n                            case _ => ()\n                        }\n                    }\n                    r.endObject()\n                    break\n                case _ => throw Exception()\n            }\n        }\n        res.pageCount = res.getPageCount()\n        return res\n    }\n\n    public static func getCount(libraryId!: String=\"\") {\n        var sql = \"SELECT COUNT(*) FROM BOOK;\"\n        if (libraryId != \"\") {\n            sql = \"SELECT COUNT(*) FROM BOOK WHERE LIBRARY_ID = '${libraryId}';\"\n        }\n        var ppDb: CPointer<CPointer<Unit>> = sqlOpen(baseConfig.database)\n        var ppStmt = sqlPrepare(ppDb, sql)\n        var number = 1\n        while (sqlStep(ppStmt) != SQLITE_DONE) {\n            number = sqlColumnInt64(ppStmt, 0)\n        }\n        sqlFinalize(ppStmt)\n        sqlClose(ppDb)\n\n        return number\n    }\n\n    public func getPageCount() {\n        var sql = \"SELECT PAGE_COUNT FROM MEDIA WHERE BOOK_ID = '${id}'\"\n        var ppDb: CPointer<CPointer<Unit>> = sqlOpen(baseConfig.database)\n        var ppStmt = sqlPrepare(ppDb, sql)\n        var number = 1\n        while (sqlStep(ppStmt) != SQLITE_DONE) {\n            number = sqlColumnInt64(ppStmt, 0)\n        }\n        sqlFinalize(ppStmt)\n        sqlClose(ppDb)\n\n        return number\n    }\n\n    public static func getThumbType(id:String): String {\n        var sql = \"SELECT MEDIA_TYPE FROM THUMBNAIL_BOOK WHERE BOOK_ID = '${id}'\"\n        var ppDb: CPointer<CPointer<Unit>> = sqlOpen(baseConfig.database)\n        var ppStmt = sqlPrepare(ppDb, sql)\n        var type_u = \"\"\n        while (sqlStep(ppStmt) != SQLITE_DONE) {\n            type_u = sqlColumnText(ppStmt, 0)\n        }\n        sqlFinalize(ppStmt)\n        sqlClose(ppDb)\n\n        return type_u\n    }\n\n    public static func getFileType(id:String): String {\n        var sql = \"SELECT MEDIA_TYPE FROM MEDIA WHERE BOOK_ID = '${id}'\"\n        var ppDb: CPointer<CPointer<Unit>> = sqlOpen(baseConfig.database)\n        var ppStmt = sqlPrepare(ppDb, sql)\n        var type_u = \"\"\n        while (sqlStep(ppStmt) != SQLITE_DONE) {\n            type_u = sqlColumnText(ppStmt, 0)\n        }\n        sqlFinalize(ppStmt)\n        sqlClose(ppDb)\n\n        return type_u\n    }\n\n    public static func getFile(id:String): String {\n        var sql = \"SELECT URL FROM BOOK WHERE ID = '${id}'\"\n        var ppDb: CPointer<CPointer<Unit>> = sqlOpen(baseConfig.database)\n        var ppStmt = sqlPrepare(ppDb, sql)\n        var url = \"\"\n        while (sqlStep(ppStmt) != SQLITE_DONE) {\n            url = sqlColumnText(ppStmt, 0)\n        }\n        sqlFinalize(ppStmt)\n        sqlClose(ppDb)\n\n        return url\n    }\n\n    public static func getThumb(id:String): Array<UInt8>{\n        var sql = \"SELECT THUMBNAIL FROM THUMBNAIL_BOOK WHERE BOOK_ID = '${id}'\"\n        var ppDb: CPointer<CPointer<Unit>> = sqlOpen(baseConfig.database)\n        var ppStmt = sqlPrepare(ppDb, sql)\n        var imageData:ArrayList<UInt8>=ArrayList<UInt8>()\n        while (sqlStep(ppStmt) != SQLITE_DONE) {\n            var size:Int64 = sqlColumnBytes(ppStmt, 0).position()\n            imageData.reserve(size)\n            unsafe{\n                var cur = sqlColumnBlob(ppStmt, 0)\n                for (_ in 0..size){\n                    imageData.append(UInt8(cur.read()))\n                    cur = cur +1\n                }\n            }\n        }\n        sqlFinalize(ppStmt)\n        sqlClose(ppDb)\n        return imageData.toArray()\n    }\n\n    public static func fromJsonToArray(r: JsonReader): ArrayList<Books> {\n        var res = ArrayList<Books>()\n        while (let Some(v) <- r.peek()) {\n            match (v) {\n                case BeginArray =>\n                    r.startArray()\n                    while (r.peek() != EndArray) {\n                        res.append(Books.fromJson(r))\n                    }\n                    r.endArray()\n                    break\n                case _ => throw Exception()\n            }\n        }\n        return res\n    }\n\n    public static func formID(id: String): Books {\n        var sql = \"SELECT json_object('ID', ID,'SERIES_ID',SERIES_ID,'LIBRARY_ID',LIBRARY_ID, 'NAME', NAME,'NUMBER',NUMBER,'URL',URL,'CREATED_DATE',CREATED_DATE,'LAST_MODIFIED_DATE',LAST_MODIFIED_DATE,'FILE_LAST_MODIFIED',FILE_LAST_MODIFIED) FROM BOOK WHERE ID = '${id}'\"\n        var jsonStrList = sqlRun(baseConfig.database, sql)\n\n        var bas = ByteBuffer()\n        unsafe { bas.write(jsonStrList.rawData()) }\n        var reader = JsonReader(bas)\n        return Books.fromJson(reader)\n    }\n\n    public static func formDatabase(location: String, page!: Int64 = 0,count!: Int64 = 5,libId!: String = \"\",seriesId!:String = \"\"): ArrayList<Books> {\n        var sql = \"SELECT json_group_array(json_object('ID', ID,'SERIES_ID',SERIES_ID,'LIBRARY_ID',LIBRARY_ID, 'NAME', NAME,'NUMBER',NUMBER,'URL',URL,'CREATED_DATE',CREATED_DATE,'LAST_MODIFIED_DATE',LAST_MODIFIED_DATE,'FILE_LAST_MODIFIED',FILE_LAST_MODIFIED)) FROM ( SELECT * FROM BOOK ORDER BY LAST_MODIFIED_DATE DESC LIMIT ${count} OFFSET ${page * count} )\"\n        if (libId != \"\") {\n            sql = \"SELECT json_group_array(json_object('ID', ID,'SERIES_ID',SERIES_ID,'LIBRARY_ID',LIBRARY_ID, 'NAME', NAME,'NUMBER',NUMBER,'URL',URL,'CREATED_DATE',CREATED_DATE,'LAST_MODIFIED_DATE',LAST_MODIFIED_DATE,'FILE_LAST_MODIFIED',FILE_LAST_MODIFIED)) FROM ( SELECT * FROM BOOK WHERE LIBRARY_ID = '${libId}' ORDER BY LAST_MODIFIED_DATE DESC LIMIT ${count} OFFSET ${page * count} )\"\n        }\n        if (seriesId != \"\") {\n            sql = \"SELECT json_group_array(json_object('ID', ID,'SERIES_ID',SERIES_ID,'LIBRARY_ID',LIBRARY_ID, 'NAME', NAME,'NUMBER',NUMBER,'URL',URL,'CREATED_DATE',CREATED_DATE,'LAST_MODIFIED_DATE',LAST_MODIFIED_DATE,'FILE_LAST_MODIFIED',FILE_LAST_MODIFIED)) FROM ( SELECT * FROM BOOK WHERE SERIES_ID = '${seriesId}' ORDER BY LAST_MODIFIED_DATE DESC LIMIT ${count} OFFSET ${page * count} )\"\n        }\n        var jsonStrList = sqlRun(location, sql)\n\n        var bas = ByteBuffer()\n        unsafe { bas.write(jsonStrList.rawData()) }\n        var reader = JsonReader(bas)\n        return Books.fromJsonToArray(reader)\n    }\n}\n\npublic class Librarys <: JsonDeserializable<Librarys> {\n    public var id: String = \"0F00000000000\"\n    public var name: String = \"name\"\n    public var root: String = \"\"\n    public var createdDate: String = \"\"\n    public var lastModifiedDate: String = \"\"\n\n    public static func fromJson(r: JsonReader): Librarys {\n        var res = Librarys()\n        while (let Some(v) <- r.peek()) {\n            match (v) {\n                case BeginObject =>\n                    r.startObject()\n                    while (r.peek() != EndObject) {\n                        let n = r.readName()\n                        match (n) {\n                            case \"ID\" => res.id = r.readValue<String>()\n                            case \"NAME\" => res.name = r.readValue<String>()\n                            case \"ROOT\" => res.root = r.readValue<String>()\n                            case \"CREATED_DATE\" => res.createdDate = r.readValue<String>()\n                            case \"LAST_MODIFIED_DATE\" => res.lastModifiedDate = r.readValue<String>()\n                            case _ => ()\n                        }\n                    }\n                    r.endObject()\n                    break\n                case _ => throw Exception()\n            }\n        }\n        return res\n    }\n\n    public static func fromJsonToArray(r: JsonReader): ArrayList<Librarys> {\n        var res = ArrayList<Librarys>()\n        while (let Some(v) <- r.peek()) {\n            match (v) {\n                case BeginArray =>\n                    r.startArray()\n                    while (r.peek() != EndArray) {\n                        res.append(Librarys.fromJson(r))\n                    }\n                    r.endArray()\n                    break\n                case _ => throw Exception()\n            }\n        }\n        return res\n    }\n\n    public static func formDatabase(location: String): ArrayList<Librarys> {\n        var sql = \"SELECT json_group_array(json_object('ID', ID, 'NAME', NAME,'ROOT',ROOT,'CREATED_DATE',CREATED_DATE,'LAST_MODIFIED_DATE',LAST_MODIFIED_DATE)) FROM LIBRARY\"\n\n        var jsonStrList = sqlRun(location, sql)\n\n        var bas = ByteBuffer()\n        unsafe { bas.write(jsonStrList.rawData()) }\n        var reader = JsonReader(bas)\n        return Librarys.fromJsonToArray(reader)\n    }\n\n    public static func fromId(id: String): Librarys {\n        var sql = \"SELECT json_object('ID', ID, 'NAME', NAME,'ROOT',ROOT,'CREATED_DATE',CREATED_DATE,'LAST_MODIFIED_DATE',LAST_MODIFIED_DATE) FROM LIBRARY WHERE ID = '${id}'\"\n\n        var jsonStrList = sqlRun(baseConfig.database, sql)\n\n        var bas = ByteBuffer()\n        unsafe { bas.write(jsonStrList.rawData()) }\n        var reader = JsonReader(bas)\n        return Librarys.fromJson(reader)\n    }\n\n    public static func getReadingCount(userID: String,libraryId!: String=\"\"): Int64 {\n        var sql = \"SELECT COUNT(*) FROM READ_PROGRESS WHERE COMPLETED = False AND USER_ID='${userID}';\"\n        if (libraryId != \"\") {\n            sql = \"SELECT COUNT(*) FROM BOOK WHERE ID IN ( SELECT BOOK_ID FROM READ_PROGRESS WHERE COMPLETED = False AND USER_ID='${userID}' ) AND LIBRARY_ID = '${libraryId}'\"\n        }\n        var ppDb: CPointer<CPointer<Unit>> = sqlOpen(baseConfig.database)\n        var ppStmt = sqlPrepare(ppDb, sql)\n        var number = 1\n        while (sqlStep(ppStmt) != SQLITE_DONE) {\n            number = sqlColumnInt64(ppStmt, 0)\n        }\n        sqlFinalize(ppStmt)\n        sqlClose(ppDb)\n        \n        return number\n    }\n\n    public static func getReading(userID: String,libraryId!: String=\"\",  page!: Int64 = 0,count!: Int64 = 5): ArrayList<Books> {\n        var sql = \"SELECT json_group_array(json_object('ID', ID,'SERIES_ID',SERIES_ID,'LIBRARY_ID',LIBRARY_ID, 'NAME', NAME,'NUMBER',NUMBER,'URL',URL,'CREATED_DATE',CREATED_DATE,'LAST_MODIFIED_DATE',LAST_MODIFIED_DATE,'FILE_LAST_MODIFIED',FILE_LAST_MODIFIED)) FROM BOOK WHERE ID IN ( SELECT BOOK_ID FROM READ_PROGRESS WHERE COMPLETED = False AND USER_ID='${userID}' ) LIMIT ${count} OFFSET ${count*page};\"\n        if (libraryId != \"\") {\n            sql = \"SELECT json_group_array(json_object('ID', ID,'SERIES_ID',SERIES_ID,'LIBRARY_ID',LIBRARY_ID, 'NAME', NAME,'NUMBER',NUMBER,'URL',URL,'CREATED_DATE',CREATED_DATE,'LAST_MODIFIED_DATE',LAST_MODIFIED_DATE,'FILE_LAST_MODIFIED',FILE_LAST_MODIFIED)) FROM BOOK WHERE ID IN ( SELECT BOOK_ID FROM READ_PROGRESS WHERE COMPLETED = False AND USER_ID='${userID}' ) AND LIBRARY_ID = '${libraryId}' LIMIT ${count} OFFSET ${count*page};\"\n        }\n        var jsonStrList = sqlRun(baseConfig.database, sql)\n\n        var bas = ByteBuffer()\n        unsafe { bas.write(jsonStrList.rawData()) }\n        var reader = JsonReader(bas)\n        return Books.fromJsonToArray(reader)\n    }\n}\n\npublic class Link <: JsonSerializable {\n    public var title: String\n    public var rel: String\n    public var href: String\n    public var type_u: String\n    public var templated: Bool\n    public init(\n        title!: String = \"\",\n        rel!: String = \"\",\n        href!: String = \"\",\n        type_u!: String = \"\",\n        templated!: Bool = false\n    ) {\n        this.title = title\n        this.rel = rel\n        this.href = href\n        this.type_u = type_u\n        this.templated = templated\n    }\n    public func toJson(w: JsonWriter): Unit {\n        w.startObject()\n        if (href != \"\") {\n            w.writeName(\"href\").writeValue(href)\n        }\n        if (rel != \"\") {\n            w.writeName(\"rel\").writeValue(rel)\n        }\n        if (title != \"\") {\n            w.writeName(\"title\").writeValue(title)\n        }\n        if (type_u != \"\") {\n            w.writeName(\"type\").writeValue(type_u)\n        }\n        if (templated) {\n            w.writeName(\"templated\").writeValue(templated)\n        }\n        w.endObject()\n    }\n}\n\n\npublic class Group <: JsonSerializable{\n    public var metadata:Metadata = Metadata()\n    public var links:ArrayList<Link> = ArrayList<Link>()\n    public var navigation:ArrayList<Link> = ArrayList<Link>()\n    public var publications:ArrayList<Publication> = ArrayList<Publication>()\n\n    public func toJson(w: JsonWriter): Unit {\n        w.startObject()\n        w.writeName(\"metadata\").writeValue(metadata)\n        if(links.size != 0){\n            w.writeName(\"links\").writeValue<ArrayList<Link>>(links)\n        }\n        if(navigation.size != 0){\n            w.writeName(\"navigation\").writeValue<ArrayList<Link>>(navigation)\n        }\n        if(publications.size != 0){\n            w.writeName(\"publications\").writeValue<ArrayList<Publication>>(publications)\n        }\n        w.endObject()\n    }\n}\n\npublic class Links <: JsonSerializable{\n    var self:Link\n    var home:Link\n    var search:Link\n    var searchPage:Bool\n    var pageSwitch:ArrayList<Link> = ArrayList<Link>()\n    public init(host: String, selfPath: String, page!:Int64 = -1,searchPage!:Bool = false){\n        self = Link(rel: \"self\", \n                  href: \"http://${host}/opds/v2/${selfPath}\"\n            )\n        home = Link(\n            title: \"Home\",\n            rel: \"start\",\n            href: \"http://${host}/opds/v2/catalog\",\n            type_u: \"application/opds+json\"\n        )\n        this.searchPage = searchPage\n        search = Link(\n            title: \"Search\",\n            rel: \"search\",\n            href: \"http://${host}/opds/v2/search{?query}\",\n            type_u: \"application/opds+json\",\n            templated: true\n        )\n        if (page != -1){\n            pageSwitch.append(\n                Link(\n                    rel: \"next\",\n                    href: \"http://${host}/opds/v2/${selfPath}?page=${page+1}\"\n                )\n            )\n            if (page != 0){\n                pageSwitch.append(\n                    Link(\n                        rel: \"previous\",\n                        href: \"http://${host}/opds/v2/${selfPath}?page=${page-1}\"\n                    )\n                )\n            }\n        }\n    }\n    public func toJson(w: JsonWriter): Unit {\n        w.startArray()\n        w.writeValue(self)\n        w.writeValue(home)\n        if (!searchPage){\n            w.writeValue(search)\n        }\n        for (i in 0..pageSwitch.size){\n            w.writeValue(pageSwitch[i])\n        }\n        w.endArray()\n    }\n}\n\n\npublic class Navigation <: JsonSerializable{\n    var recommended:Link\n    var browse:Link\n    public init(host: String, selfPath!: String = \"libraries\"){\n        recommended = Link(\n            title: \"Recommended\",\n            rel: \"subsection\",\n            href: \"http://${host}/opds/v2/${selfPath}\",\n            type_u: \"application/opds+json\"\n        )\n        browse = Link(\n            title: \"Browse\",\n            rel: \"subsection\",\n            href: \"http://${host}/opds/v2/${selfPath}/browse\",\n            type_u: \"application/opds+json\",\n        )\n    }\n    public func toJson(w: JsonWriter): Unit {\n        w.startArray()\n        w.writeValue(recommended)\n        w.writeValue(browse)\n        w.endArray()\n    }\n}\n\npublic class Metadata <: JsonSerializable {\n    public var title: String = \"\"\n    public var conformsTo: String = \"\"\n    public var modified: String = \"\"\n    public var description: String = \"\"\n    public var itemsPerPage: Int64 = -1\n    public var currentPage: Int64 = -1\n    public var numberOfItems: Int64 = -1\n    public var numberOfPages: Int64 = -1\n    public var contributor: ArrayList<String> = ArrayList<String>()\n    public var seriesBelongTo: ArrayList<SeriesBelongTo> = ArrayList<SeriesBelongTo>()\n    public init() {\n    }\n    public init(title: String,conformsTo!: String = \"\", modified!: String = \"\", itemsPerPage!: Int64 = -1, currentPage!: Int64 = -1,\n        numberOfItems!: Int64 = -1, numberOfPages!: Int64 = -1, contributor!: ArrayList<String> = ArrayList<String>() ){\n        this.title = title\n        this.conformsTo = conformsTo\n        this.modified = modified\n        this.itemsPerPage = itemsPerPage\n        this.currentPage = currentPage\n        this.numberOfItems = numberOfItems\n        this.numberOfPages = numberOfPages\n        this.contributor = contributor\n        if (this.modified.contains(\" \")){\n            this.timeFormat()\n        }\n    }\n\n    public func timeFormat(){\n        this.modified = this.modified.replace(\" \",\"T\")+\"Z\"\n    }\n\n    public func addBookDesc(id: String) {\n        this.description = BookSeries.getDesc(id)\n    }\n\n    public func addSeriesBelongTo(obj: Books) {\n        this.seriesBelongTo.append(SeriesBelongTo(obj))\n    }\n\n    public func toJson(w: JsonWriter): Unit {\n        w.startObject()\n        w.writeName(\"title\").writeValue(title)\n        if (conformsTo != \"\") {\n            w.writeName(\"conformsTo\").writeValue(conformsTo)\n        }\n        if (modified != \"\") {\n            w.writeName(\"modified\").writeValue(modified)\n        }\n        if (description != \"\") {\n            w.writeName(\"description\").writeValue(description)\n        }\n        if (itemsPerPage != -1) {\n            w.writeName(\"itemsPerPage\").writeValue(itemsPerPage)\n        }\n        if (currentPage != -1) {\n            w.writeName(\"currentPage\").writeValue(currentPage)\n        }\n        if (numberOfItems != -1) {\n            w.writeName(\"numberOfItems\").writeValue(numberOfItems)\n        }\n        if (numberOfPages != -1) {\n            w.writeName(\"numberOfPages\").writeValue(numberOfPages)\n        }\n        if (contributor.size != 0) {\n            w.writeName(\"contributor\").writeValue<ArrayList<String>>(contributor)\n        }\n        if (seriesBelongTo.size != 0) {\n            w.writeName(\"belongsTo\").startObject()\n            w.writeName(\"series\").writeValue<ArrayList<SeriesBelongTo>>(seriesBelongTo)\n            w.endObject()\n        }\n        w.endObject()\n    }\n}\n\npublic class SeriesBelongTo <: JsonSerializable {\n    public var name: String = \"\"\n    public var position: Int64 = -1\n    public var links: ArrayList<Link> = ArrayList<Link>()\n    public init() {\n    }\n    public init(obj: Books) {\n        this.name = obj.name\n        this.position = obj.number\n        this.links.append(\n            Link(\n                href: \"http://192.168.10.86:25600/opds/v2/series/${obj.id}\",\n                type_u: \"application/vnd.comicbook+json\"\n            )\n        )\n    }\n    public func toJson(w: JsonWriter): Unit {\n        w.startObject()\n        if (name != \"\") {\n            w.writeName(\"name\").writeValue(name)\n        }\n        if (position != -1) {\n            w.writeName(\"position\").writeValue(position)\n        }\n        if (links.size != 0) {\n            w.writeName(\"links\").writeValue<ArrayList<Link>>(links)\n        }\n        w.endObject()\n    }\n}\n\npublic class Publication <: JsonSerializable {\n    var context: String = \"\"\n    var metadata: Metadata = Metadata()\n    var links: ArrayList<Link> = ArrayList<Link>()\n    var images: ArrayList<Link> = ArrayList<Link>()\n    var readingOrder: ArrayList<Link> = ArrayList<Link>()\n    var resources: ArrayList<Link> = ArrayList<Link>()\n    var toc: ArrayList<Link> = ArrayList<Link>()\n    var landmarks: ArrayList<Link> = ArrayList<Link>()\n    var pageList: ArrayList<Link> = ArrayList<Link>()\n\n    static func getContibuor(id: String): ArrayList<String> {\n        var sql = \"SELECT NAME FROM BOOK_METADATA_AUTHOR WHERE BOOK_ID = '${id}'\"\n        var ppDb: CPointer<CPointer<Unit>> = sqlOpen(baseConfig.database)\n        var ppStmt = sqlPrepare(ppDb, sql)\n        var listStr = ArrayList<String>()\n        while (sqlStep(ppStmt) != SQLITE_DONE) {\n            for (i in 0..sqlColumnCount(ppStmt)){\n                listStr.append(sqlColumnText(ppStmt, i))\n            }\n        }\n        sqlFinalize(ppStmt)\n        sqlClose(ppDb)\n\n        return listStr\n    }\n\n    public init(obj: Books, host: String) {\n        this.context = \"https://readium.org/webpub-manifest/context.jsonld\"\n        this.metadata = Metadata(\n            obj.name,\n            modified: obj.lastModifiedDate,\n            numberOfPages: obj.pageCount,\n            contributor: getContibuor(obj.id)\n        )\n        this.metadata.addSeriesBelongTo(obj)\n        this.links.append(\n            Link(\n                rel: \"self\",\n                href: \"http://${host}/api/v1/books/${obj.id}/manifest\",\n                type_u: \"application/divina+json\"\n            )\n        )\n        this.links.append(\n            Link(\n                rel: \"http://opds-spec.org/acquisition\",\n                href: \"http://${host}/api/v1/books/${obj.id}/file\",\n                type_u: \"application/vnd.comicbook+zip\"\n            )\n        )\n        this.images.append(\n            Link(\n                href: \"http://${host}/api/v1/books/${obj.id}/thumbnail\",\n                type_u: \"image/jpeg\"\n            )\n        )\n    }\n    public func toJson(w: JsonWriter): Unit {\n        w.startObject()\n        w.writeName(\"context\").writeValue(context)\n        w.writeName(\"metadata\").writeValue(metadata)\n        w.writeName(\"links\").writeValue<ArrayList<Link>>(links)\n        w.writeName(\"images\").writeValue<ArrayList<Link>>(images)\n        w.writeName(\"readingOrder\").writeValue<ArrayList<Link>>(readingOrder)\n        w.writeName(\"resources\").writeValue<ArrayList<Link>>(resources)\n        w.writeName(\"toc\").writeValue<ArrayList<Link>>(toc)\n        w.writeName(\"landmarks\").writeValue<ArrayList<Link>>(landmarks)\n        w.writeName(\"pageList\").writeValue<ArrayList<Link>>(pageList)\n        w.endObject()\n    }\n}", "llm_cg": {"main": [], "sqlRun": ["sqlOpen", "sqlPrepare", "sqlStep", "sqlColumnText", "sqlFinalize", "sqlClose"], "BookSeries": [], "BookSeries.fromJson": ["BookSeries", "r.peek", "r.startObject", "r.peek", "r.readName", "r.readValue", "r.endObject"], "BookSeries.fromJsonToArray": ["ArrayList", "r.peek", "r.startArray", "r.peek", "BookSeries.fromJson", "res.append", "r.endArray"], "BookSeries.query": ["sqlRun", "baseConfig.database", "ByteBuffer", "bas.write", "jsonStrList.rawData", "JsonReader", "BookSeries.fromJsonToArray"], "BookSeries.formDatabase": ["sqlRun", "ByteBuffer", "bas.write", "jsonStrList.rawData", "JsonReader", "BookSeries.fromJsonToArray"], "BookSeries.formPublisher": ["sqlRun", "baseConfig.database", "ByteBuffer", "bas.write", "jsonStrList.rawData", "JsonReader", "BookSeries.fromJsonToArray"], "BookSeries.getCount": ["sqlOpen", "baseConfig.database", "sqlPrepare", "sqlStep", "sqlColumnInt64", "sqlFinalize", "sqlClose"], "BookSeries.getDesc": ["sqlOpen", "baseConfig.database", "sqlPrepare", "sqlStep", "sqlColumnText", "sqlFinalize", "sqlClose"], "BookSeries.fromId": ["sqlRun", "baseConfig.database", "ByteBuffer", "bas.write", "jsonStrList.rawData", "JsonReader", "BookSeries.fromJson"], "BookSeries.getPublishList": ["sqlOpen", "baseConfig.database", "sqlPrepare", "sqlStep", "sqlColumnCount", "sqlColumnText", "res.append", "sqlFinalize", "sqlClose"], "Books": [], "Books.fromJson": ["Books", "r.peek", "r.startObject", "r.peek", "r.readName", "r.readValue", "r.endObject", "getPageCount"], "Books.getCount": ["sqlOpen", "baseConfig.database", "sqlPrepare", "sqlStep", "sqlColumnInt64", "sqlFinalize", "sqlClose"], "Books.getPageCount": ["sqlOpen", "baseConfig.database", "sqlPrepare", "sqlStep", "sqlColumnInt64", "sqlFinalize", "sqlClose"], "Books.getThumbType": ["sqlOpen", "baseConfig.database", "sqlPrepare", "sqlStep", "sqlColumnText", "sqlFinalize", "sqlClose"], "Books.getFileType": ["sqlOpen", "baseConfig.database", "sqlPrepare", "sqlStep", "sqlColumnText", "sqlFinalize", "sqlClose"], "Books.getFile": ["sqlOpen", "baseConfig.database", "sqlPrepare", "sqlStep", "sqlColumnText", "sqlFinalize", "sqlClose"], "Books.getThumb": ["sqlOpen", "baseConfig.database", "sqlPrepare", "sqlStep", "sqlColumnBytes", "imageData.reserve", "sqlColumnBlob", "imageData.append", "sqlFinalize", "sqlClose", "imageData.toArray"], "Books.fromJsonToArray": ["ArrayList", "r.peek", "r.startArray", "r.peek", "Books.fromJson", "res.append", "r.endArray"], "Books.formID": ["sqlRun", "ByteBuffer", "bas.write", "jsonStrList.rawData", "JsonReader", "Books.fromJson"], "Books.formDatabase": ["sqlRun", "ByteBuffer", "bas.write", "jsonStrList.rawData", "JsonReader", "Books.fromJsonToArray"], "Librarys": [], "Librarys.fromJson": ["Librarys", "r.peek", "r.startObject", "r.peek", "r.readName", "r.readValue", "r.endObject"], "Librarys.fromJsonToArray": ["ArrayList", "r.peek", "r.startArray", "r.peek", "Librarys.fromJson", "res.append", "r.endArray"], "Librarys.formDatabase": ["sqlRun", "ByteBuffer", "bas.write", "jsonStrList.rawData", "JsonReader", "Librarys.fromJsonToArray"], "Librarys.fromId": ["sqlRun", "baseConfig.database", "ByteBuffer", "bas.write", "jsonStrList.rawData", "JsonReader", "Librarys.fromJson"], "Librarys.getReadingCount": ["sqlOpen", "baseConfig.database", "sqlPrepare", "sqlStep", "sqlColumnInt64", "sqlFinalize", "sqlClose"], "Librarys.getReading": ["sqlRun", "baseConfig.database", "ByteBuffer", "bas.write", "jsonStrList.rawData", "JsonReader", "Books.fromJsonToArray"], "Link": [], "Link.toJson": ["w.startObject", "w.writeName", "w.writeValue", "w.endObject"], "Group": [], "Group.toJson": ["w.startObject", "w.writeName", "w.writeValue", "w.endObject"], "Links": [], "Links.toJson": ["w.startArray", "w.writeValue", "w.endArray"], "Navigation": [], "Navigation.toJson": ["w.startArray", "w.writeValue", "w.endArray"], "Metadata": [], "Metadata.timeFormat": ["this.modified.replace", "this.modified.contains"], "Metadata.addBookDesc": ["BookSeries.getDesc"], "Metadata.addSeriesBelongTo": ["this.seriesBelongTo.append", "SeriesBelongTo"], "Metadata.toJson": ["w.startObject", "w.writeName", "w.writeValue", "w.endObject"], "SeriesBelongTo": [], "SeriesBelongTo.toJson": ["w.startObject", "w.writeName", "w.writeValue", "w.endObject"], "Publication": [], "Publication.getContibuor": ["sqlOpen", "baseConfig.database", "sqlPrepare", "sqlStep", "sqlColumnCount", "sqlColumnText", "res.append", "sqlFinalize", "sqlClose"], "Publication.toJson": ["w.startObject", "w.writeName", "w.writeValue", "w.endObject"]}, "static_cg": {}}
{"source_code": "package opds_cj.data_stru\n\nimport std.{process.*, fs.*, convert.*, regex.*, collection.*}\nimport opds_cj.config.baseConfig\n\npublic class Page {\n    public var width: Int64 = 0\n    public var height: Int64 = 0\n    public var format: String = \"\"\n    var path: String = \"\"\n    public var data: ArrayList<Byte> = ArrayList<Byte>()\n\n    public static func unzip(file: String, id: String) {\n        let argument: Array<String> = [\"e\", \"-y\", file, \"-o./data/cache/${id}\"]\n        Process.run(\"7z\", argument, stdOut: Discard)\n    }\n\n    public static func identify(path: String) {\n        let output = Process.runOutput(\"identify\", path)\n        return String.fromUtf8(output[1]).split(\" \")\n    }\n\n    public static func getPage(id: String, page: Int64, convert: String) {\n        var pageImage = Page()\n        let url = baseConfig.getFileURL(Books.getFile(id))\n        if (!exists(\"./data/cache/${id}/\")) {\n            unzip(url, id)\n        }\n        for (file in Directory.readFrom(\"data/cache/${id}/\")) {\n            var filename = file.path.fileNameWithoutExtension\n            let r = Regex(\"\\\\d+\")\n            let matchData = r.matcher(filename).find().getOrThrow().matchStr()\n            if (Int64.parse(matchData) == page) {\n                pageImage.path = file.path.toString()\n                let info = identify(pageImage.path)\n                pageImage.format = info[1].toAsciiLower()\n                pageImage.width = Int64.parse(info[2].split(\"x\")[0])\n                pageImage.height = Int64.parse(info[2].split(\"x\")[1])\n                pageImage.convert(convert)\n                return pageImage\n            }\n        }\n        return pageImage\n    }\n    public func readFile() {\n        this.data.appendAll(File.readFrom(this.path))\n    }\n\n    func convert(type_u: String) {\n        if (type_u == \"\") {\n            return\n        }\n        if (this.format != type_u) {\n            if (!exists(this.path.replace(\".${this.format}\", \".${type_u}\"))) {\n                let argument: Array<String> = [this.path, this.path.replace(\".${this.format}\", \".${type_u}\")]\n                Process.run(\"convert\", argument, stdOut: Discard)\n            }\n            this.path = this.path.replace(\".${this.format}\", \".${type_u}\")\n            this.format = type_u\n        }\n    }\n}\n", "llm_cg": {"main": [], "Page": ["<builtin>.ArrayList"], "Page.unzip": ["std.process.Process.run"], "Page.identify": ["std.process.Process.runOutput", "std.convert.String.fromUtf8", "<builtin>.split"], "Page.getPage": ["Page", "opds_cj.config.baseConfig.getFileURL", "Books.getFile", "std.fs.exists", "Page.unzip", "std.fs.Directory.readFrom", "std.regex.Regex", "std.regex.Regex.matcher", "std.regex.Matcher.find", "std.regex.Matcher.getOrThrow", "std.regex.Matcher.matchStr", "std.convert.Int64.parse", "Page.identify", "<builtin>.toAsciiLower", "<builtin>.split", "Page.convert"], "Page.readFile": ["std.fs.File.readFrom", "<builtin>.appendAll"], "Page.convert": ["std.fs.exists", "<builtin>.replace", "std.process.Process.run"]}, "static_cg": {}}
{"source_code": "macro package opds_cj.macros\n\nimport std.ast.*\nimport std.fs.*\nimport std.io.*\nimport std.regex.*\nimport std.collection.HashMap\n\nlet typeMap = HashMap<String, TokenKind>(\n    [\n        (\"void\", TokenKind.UNIT),\n        (\"bool\", TokenKind.BOOLEAN),\n        (\"char\", TokenKind.UINT8),\n        (\"int8_t\", TokenKind.UINT8),\n        (\"uint8_t\", TokenKind.UINT8),\n        (\"int16_t\", TokenKind.INT16),\n        (\"uint16_t\", TokenKind.UINT16),\n        (\"int32_t\", TokenKind.INT32),\n        (\"uint32_t\", TokenKind.UINT32),\n        (\"int64_t\", TokenKind.INT64),\n        (\"uint64_t\", TokenKind.UINT64),\n        (\"ssize_t\", TokenKind.INTNATIVE),\n        (\"size_t\", TokenKind.UINTNATIVE),\n        (\"float\", TokenKind.FLOAT32),\n        (\"double\", TokenKind.FLOAT64), //以上为通用映射表\n        (\"int\", TokenKind.INT32), //根据平台变化\n        (\"sqlite3_int64\", TokenKind.INT64) //以上为当前项目特殊映射\n    ]\n)\n\nfunc parseType(oriType: String, pointerCount: String): Tokens {\n    if (oriType == \"char\" && pointerCount.count(\"*\") == 1) {\n        return Tokens() + Token(TokenKind.IDENTIFIER, \"CString\") //返回CString\n    }\n    var outType = Tokens()\n    if (typeMap.contains(oriType)) {\n        outType += Token(typeMap[oriType])\n    } else {\n        outType += Token(TokenKind.UNIT)\n    }\n    for (_ in 0..pointerCount.count(\"*\")) {\n        outType = quote(CPointer<$(outType)>)\n    }\n    return outType\n}\n\nfunc parseDotH(dotH: String): Tokens {\n    var outTokens = Tokens()\n    let file = File(dotH, Read)\n    let reader = StringReader(file)\n    var content = reader.readToEnd() //StringReader的分段读取未解决，暂时直接全部读完\n    let commentRegex = Regex(##\"/\\*.*\\*/|//.*(\\n|\\r)|\\*/|/\\*|\\*{2}\\s.*(\\n|\\r)\"##) //移除注释\n    content = commentRegex\n        .matcher(content)\n        .replaceAll(\"\")\n        .replace(\"void(*)(void*)\", \"void*\")\n        .replace(\"int (*callback)(void*,int,char**,char**)\", \"void *\")\n    let funcRegex = Regex(##\"\\w+\\s+\\**\\w+\\s*\\([^)]*\\)\\s*;\"##) //获得函数定义的匹配\n    let funcArr = funcRegex.matcher(content).findAll() ?? Array<MatchData>()\n    for (i in funcArr) {\n        var funcDefine = i.matchStr()\n        let funcDefineArray = funcDefine.split(\"(\")\n        let funcPrefix = funcDefineArray[0].split(\" \")\n        var funcReturn = Tokens()\n        if (typeMap.contains(funcPrefix[0])) {\n            funcReturn += Token(typeMap[funcPrefix[0]])\n        }else{\n            funcReturn += Token(TokenKind.UNIT)\n        }\n        var funcName = funcPrefix[1]\n        if (funcName.contains(\"*\")) { //判断是否可能为字符串\n            funcName = funcName.replace(\"*\", \"\")\n            if (funcPrefix[0] == \"char\") {\n                funcReturn = quote(CString)\n            } else {\n                funcReturn = quote(CPointer<Byte>)\n            }\n        }\n        let paramListStr = funcDefineArray[1]\n        let paramRegex = Regex(##\"(\\w+\\s*\\**|\\w+\\s+\\**\\w+|\\.{3})(\\s*,|\\s*\\))\"##) //匹配到参数列表\n        let paramMatchList = paramRegex.matcher(paramListStr).findAll() ?? Array<MatchData>()\n        let paramList = Array<String>(paramMatchList.size,\n            {i => Regex(##\"\\s*,|\\s*\\)|\\n|\\r\"##).matcher(paramMatchList[i].matchStr()).replace(\"\")}) //移除特殊字符并存入数组\n        var paramsToken = Tokens()\n        for (i in 0..paramList.size) {\n            println(\"${funcName}\\n${paramList}\\n${\"void\" == paramList[i]}\")\n            if (let Some(_) <- Regex(##\"\\w+\\s+\\**\\w+\"##).matches(paramList[i])) { //处理诸如int n的函数参数\n                let paramSplit = paramList[i].split(\" \")\n                let type_u = paramSplit[0].replace(\"*\", \"\")\n                let paramToken = Token(TokenKind.IDENTIFIER, paramSplit[1].replace(\"*\", \"\").replace(\"type\",\"type${i}\"))\n                let typeToken = parseType(type_u, paramList[i])\n                paramsToken += quote($(paramToken): $(typeToken))\n            } else if (\"void\" == paramList[i]) { //处理诸如void的函数参数\n                continue\n            } else if (let Some(_) <- Regex(##\"\\w+\\s*\\**\"##).matches(paramList[i])) { // 处理诸如int*的函数参数\n                let type_u = paramList[i].replace(\"*\", \"\")\n                let paramToken = Token(TokenKind.IDENTIFIER, \"param${i}\")\n                let typeToken = parseType(type_u, paramList[i])\n                paramsToken += quote($(paramToken): $(typeToken))\n            } else if (let Some(_) <- Regex(##\"\\.{3}|va_list\"##).matches(paramList[i])) { //处理诸如...的函数参数\n                paramsToken += Token(TokenKind.ELLIPSIS)\n            } else {\n                println(\"unknown param:${paramList[i]}\")\n            }\n            if (i != paramList.size - 1) {\n                paramsToken += Token(TokenKind.COMMA)\n            }\n        }\n        let nameToken = Token(TokenKind.IDENTIFIER, funcName)\n        outTokens += quote(foreign func $(nameToken)($(paramsToken)): $(funcReturn)\n        )\n    }\n    file.close()\n    outTokens\n}\n\npublic macro include(input: Tokens): Tokens {\n    parseDotH(input.toString().replace('\"', \"\"))\n}\n", "llm_cg": {"main": [], "parseType": ["<builtin>.quote", "<builtin>.Token", "<builtin>.var", "<builtin>.if", "<builtin>.return"], "parseDotH": ["<builtin>.Tokens", "<builtin>.File", "<builtin>.StringReader", "<builtin>.Regex", "<builtin>.println", "<builtin>.quote", "<builtin>.Token", "typeMap.contains"], "include": ["parseDotH", "<builtin>.Tokens"]}, "static_cg": {}}
{"source_code": "macro package opds_cj.macros\n\nimport std.ast.*\nimport std.collection.ArrayList\n\nclass VarVisitor <: Visitor {\n    public var varList = ArrayList<VarDecl>()\n    public override func visit(varDecl: VarDecl) {\n        varList.append(varDecl)\n        breakTraverse() // 不会继续遍历 varDecl 的子节点\n        return\n    }\n\n    public override func visit(_: FuncDecl) { //阻止在func函数下查找变量\n        breakTraverse()\n        return\n    }\n}\n\nfunc newField(varDecl: VarDecl): Tokens {\n    let name = varDecl.identifier\n    // let type_u = varDecl.declType\n    quote(\n        w.writeName($(name.value)).writeValue($(name)))\n}\n\nfunc newToString(varList: ArrayList<VarDecl>): Tokens {\n    var newToken = Tokens()\n    for (i in varList) {\n        newToken += newField(i)\n    }\n    quote(\n        extend Series {\n            public func toJson(): String {\n                let stream = ByteBuffer()\n                let w = JsonWriter(stream)\n                w.startObject()\n                $(newToken)\n                w.endObject()\n                w.flush()\n                return String.fromUtf8(readToEnd(stream))\n            }\n        }\n    )\n}\n\npublic macro Json(input: Tokens): Tokens {\n    let s: Decl = parseDecl(input)\n    var toString: Tokens\n    var visitor = VarVisitor()\n    match (s) {\n        case d: ClassDecl =>\n            d.traverse(visitor)\n            toString = newToString(visitor.varList)\n        case _ => throw Exception(\"Json only using for Class\")\n    }\n    input + toString\n}\n", "llm_cg": {"main": [], "VarVisitor": ["ArrayList"], "VarVisitor.visit": ["varList.append", "breakTraverse"], "VarVisitor.visit_1": ["breakTraverse"], "newField": ["quote"], "newToString": ["Tokens", "newField", "quote", "JsonWriter", "newToken", "newToken", "newToken", "ByteBuffer", "String.fromUtf8"], "Json": ["parseDecl", "VarVisitor", "match", "ClassDecl.traverse", "newToString", "Exception", "input"]}, "static_cg": {}}
{"source_code": "package opds_cj.path\n\nimport net.http.*\nimport opds_cj.router.PathMap\nimport opds_cj.path.{api,opds}\n\npublic func pathLoad(): PathMap {\n    var pathMap = PathMap()\n\n    pathMap.merge(api.pathLoad())\n    pathMap.merge(opds.pathLoad())\n\n    return pathMap\n}\n", "llm_cg": {"main": [], "pathLoad": ["PathMap", "api.pathLoad", "opds.pathLoad"]}, "static_cg": {}}
{"source_code": "package opds_cj.path.api\n\nimport net.http.*\nimport opds_cj.router.PathMap\nimport opds_cj.path.api.v1\n\npublic func pathLoad(): PathMap {\n    var pathMap = PathMap()\n    pathMap.merge(v1.pathLoad())\n    return pathMap\n}\n", "llm_cg": {"main": [], "pathLoad": ["PathMap", "v1.pathLoad", "PathMap.merge"]}, "static_cg": {}}
{"source_code": "package opds_cj.path.api.v1\n\nimport net.http.*\nimport opds_cj.router.PathMap\nimport opds_cj.path.api.v1.books\n\npublic func pathLoad(): PathMap {\n    var pathMap = PathMap()\n\n    pathMap.merge(books.pathLoad())\n    return pathMap\n}\n", "llm_cg": {"pathLoad": ["opds_cj.router.PathMap", "opds_cj.path.api.v1.books.pathLoad"]}, "static_cg": {}}
{"source_code": "package opds_cj.path.api.v1.books\n\nimport std.{io.*,fs.*,convert.*}\nimport net.http.*\nimport opds_cj.router.PathMap\nimport opds_cj.config.baseConfig\ninternal import opds_cj.data_stru.*\n\npublic func pathLoad(): PathMap {\n    var pathMap = PathMap(\n        \"/api/v1/books/:id/thumbnail\",\n        {\n            httpContext =>\n            let id = httpContext.request.url.toString().split(\"/\")[4]\n            let data = Books.getThumb(id)\n            httpContext.responseBuilder.header(\"content-type\", Books.getThumbType(id))\n            httpContext.responseBuilder.body(data)\n        }\n    )\n    pathMap.add(\n        \"/api/v1/books/:id/file\",\n        {\n            httpContext =>\n            let id = httpContext.request.url.toString().split(\"/\")[4]\n            let data = baseConfig.getFileURL(Books.getFile(id))\n            let path = data.split(\"/\")\n            httpContext.responseBuilder.header(\"content-disposition\", \"attachment; filename=\" + path[path.size - 1])\n            httpContext.responseBuilder.header(\"content-type\", Books.getFileType(id))\n            httpContext.responseBuilder.body(File.readFrom(data))\n        }\n    )\n\n    pathMap.add(\n        \"/api/v1/books/:id/pages/:page\",\n        {\n            httpContext =>\n            let id = httpContext.request.url.toString().split(\"/\")[4]\n            let page = Int64.parse(httpContext.request.url.path.split(\"/\")[6])\n            var convert = \"\"\n            match (httpContext.request.url.query) {\n                case Some(x) => convert = x.trimStart(\"convert=\")\n                case None => ()\n            }\n            let pageImage = Page.getPage(id, page, convert)\n            pageImage.readFile()\n            httpContext.responseBuilder.header(\"content-type\", \"image/${pageImage.format}\")\n            httpContext.responseBuilder.body(pageImage.data.toArray())\n        }\n    )\n    pathMap.add(\n        \"/api/v1/books/:id/manifest\",\n        {\n            httpContext =>\n            let host = httpContext.request.headers.get(\"host\").toArray()[0]\n            let id = httpContext.request.url.path.split(\"/\")[4]\n            var manifest= Manifest(id, host)\n            httpContext.responseBuilder.header(\"content-type\", \"application/json;charset:utf-8;\")\n            httpContext.responseBuilder.body(manifest.toJson())\n        }\n    )\n    return pathMap\n}\n", "llm_cg": {"pathLoad": ["PathMap", "httpContext.request.url.toString", "<builtin>.split", "Books.getThumb", "httpContext.responseBuilder.header", "Books.getThumbType", "httpContext.responseBuilder.body", "baseConfig.getFileURL", "Books.getFile", "File.readFrom", "Int64.parse", "httpContext.request.url.query", "Page.getPage", "pageImage.readFile", "pageImage.data.toArray", "httpContext.request.headers.get", "Manifest", "manifest.toJson"]}, "static_cg": {}}
{"source_code": "package opds_cj.path.api.v1.books\n\nimport std.{collection.*,io.*}\nimport encoding.json.stream.*\n\nclass Manifest{\n    var metadata: Metadata\n    var links: ArrayList<Link> = ArrayList<Link>()\n    var readingOrder: ReadingOrder\n    var resources: ArrayList<Link> = ArrayList<Link>()\n    public init(id: String,host: String){\n        let book = Books.formID(id)\n        this.metadata = Metadata(book.name,\n                                conformsTo: \"https://readium.org/webpub-manifest/schema/webpub-manifest.jsonld\",\n                                modified: book.lastModifiedDate,\n                                numberOfPages: book.getPageCount())\n        this.metadata.addSeriesBelongTo(book)\n        this.links.append(Link(rel: \"self\", \n                               href: \"http://${host}/api/v1/books/${id}/manifest\", \n                               type_u: \"application/divina+json\"))\n        this.links.append(Link(rel: \"http://opds-spec.org/acquisition\", \n                               href: \"http://${host}/api/v1/books/${id}/file\", \n                               type_u: \"application/vnd.comicbook+zip\"))\n        this.readingOrder = ReadingOrder(id,host,book.getPageCount())\n        this.resources.append(Link(href: \"http://${host}/api/v1/books/${id}/thumbnail\", \n                                   type_u: \"image/jpeg\"))\n    }\n    public func toJson(): String {\n        let stream = ByteBuffer()\n        let w = JsonWriter(stream)\n        w.startObject()\n        w.writeName(\"context\").writeValue(\"https://readium.org/webpub-manifest/context.jsonld\")\n        w.writeName(\"metadata\").writeValue(metadata)\n        w.writeName(\"links\").writeValue<ArrayList<Link>>(links)\n        w.writeName(\"images\").startArray()\n        w.endArray()\n        w.writeName(\"readingOrder\").writeValue(readingOrder)\n        w.writeName(\"resources\").writeValue<ArrayList<Link>>(resources)\n        w.writeName(\"toc\").startArray()\n        w.endArray()\n        w.writeName(\"landmarks\").startArray()\n        w.endArray()\n        w.writeName(\"pageList\").startArray()\n        w.endArray()\n        w.endObject()\n        w.flush()\n        return String.fromUtf8(readToEnd(stream))\n    }        \n}\n\nclass ReadingOrder <: JsonSerializable{\n    var pages: ArrayList<Page> = ArrayList<Page>()\n    var host: String = \"\"\n    var id: String = \"\"\n    init(id: String,host: String,count: Int64) {\n        this.host = host\n        this.id = id\n        for (i in 1..=count) {\n            this.pages.append(Page.getPage(id, i, \"\"))\n        }\n    }\n    public func toJson(w: JsonWriter): Unit {\n        w.startArray()\n        for (i in 0..pages.size) {\n            w.startObject()\n            w.writeName(\"href\").writeValue(\"http://${host}/api/v1/books/${id}/pages/${i+1}\")\n            w.writeName(\"type\").writeValue(\"image/${pages[i].format}\")\n            w.writeName(\"width\").writeValue(pages[i].width)\n            w.writeName(\"height\").writeValue(pages[i].height)\n            if (pages[i].format != \"jpeg\"){\n                w.writeName(\"alternate\").startArray()\n                w.startObject()\n                w.writeName(\"href\").writeValue(\"http://${host}/api/v1/books/${id}/pages/${i+1}?convert=jpeg\")\n                w.writeName(\"type\").writeValue(\"image/jpeg\")\n                w.writeName(\"width\").writeValue(pages[i].width)\n                w.writeName(\"height\").writeValue(pages[i].height)\n                w.endObject()\n                w.endArray()\n            }\n            w.endObject()   \n        }\n        w.endArray()\n    }\n}", "llm_cg": {"Manifest": ["Books.formID", "Metadata", "this.metadata.addSeriesBelongTo", "this.links.append", "ReadingOrder", "this.resources.append"], "Manifest.toJson": ["ByteBuffer", "JsonWriter", "w.startObject", "w.writeName", "w.writeValue", "w.startArray", "w.endArray", "w.endObject", "w.flush", "String.fromUtf8", "readToEnd"], "ReadingOrder": ["this.pages.append", "Page.getPage"], "ReadingOrder.toJson": ["w.startArray", "w.size", "w.startObject", "w.writeName", "w.writeValue", "w.endObject", "w.endArray"]}, "static_cg": {}}
{"source_code": "package opds_cj.path.opds\n\nimport net.http.*\nimport opds_cj.router.PathMap\nimport opds_cj.path.opds.v2\n\npublic func pathLoad(): PathMap {\n    var pathMap = PathMap()\n\n    pathMap.merge(v2.pathLoad())\n    return pathMap\n}\n", "llm_cg": {"pathLoad": ["opds_cj.path.opds.v2.pathLoad"]}, "static_cg": {}}
{"source_code": "package opds_cj.path.opds.v2\n\nimport net.http.*\nimport opds_cj.router.PathMap\nimport opds_cj.path.opds.v2.{catalog,libraries,series,search}\n\npublic func pathLoad(): PathMap {\n    var pathMap = PathMap()\n\n    pathMap.merge(catalog.pathLoad())\n    pathMap.merge(libraries.pathLoad())\n    pathMap.merge(series.pathLoad())\n    pathMap.merge(search.pathLoad())\n    return pathMap\n}\n", "llm_cg": {"main": [], "pathLoad": ["opds_cj.router.PathMap", "catalog.pathLoad", "libraries.pathLoad", "series.pathLoad", "search.pathLoad"]}, "static_cg": {}}
{"source_code": "package opds_cj.path.opds.v2.catalog\n\nimport net.http.*\nimport opds_cj.router.PathMap\nimport opds_cj.path.opds.v2.libraries\n\npublic func pathLoad(): PathMap {\n    var pathMap = PathMap(\n        \"/opds/v2/catalog\",\n        {\n            httpContext =>\n            let host = httpContext.request.headers.get(\"host\").toArray()[0]\n            var cataLog = libraries.CataLog(host:host)\n            httpContext.responseBuilder.header(\"content-type\", \"application/json;charset:utf-8;\")\n            httpContext.responseBuilder.body(cataLog.toJson())\n        }\n    )\n    \n    return pathMap\n}\n", "llm_cg": {"main": [], "pathLoad": ["PathMap", "httpContext.request.headers.get", "libraries.CataLog", "httpContext.responseBuilder.header", "httpContext.responseBuilder.body"]}, "static_cg": {}}
{"source_code": "package opds_cj.path.opds.v2.libraries\n\nclass Brower {\n    var metadata: Metadata\n    var links: Links\n    var navigation: Navigation\n    var groups: ArrayList<Group> = ArrayList<Group>()\n\n    static func initSeries(host: String, publisher: String): Group {\n        var series = Group()\n        series.metadata = Metadata(\"Series\")\n        var obj: ArrayList<BookSeries>\n        if (publisher != \"\") {\n            obj = BookSeries.formPublisher(publisher)\n        } else {\n            let numberOfItems = BookSeries.getCount()\n            obj = BookSeries.formDatabase(baseConfig.database, count: numberOfItems)\n        }\n        for (i in obj) {\n            series.navigation.append(\n                Link(\n                    title: i.name,\n                    href: \"http://${host}/opds/v2/series/${i.id}\",\n                    type_u: \"application/opds+json\"\n                )\n            )\n        }\n        return series\n    }\n\n    static func initSeries(id: String, host: String, publisher: String): Group {\n        var series = Group()\n        series.metadata = Metadata(\"Series\")\n        var obj: ArrayList<BookSeries>\n        if (publisher != \"\") {\n            obj = BookSeries.formPublisher(publisher)\n        } else {\n            let numberOfItems = BookSeries.getCount(id: id)\n            obj = BookSeries.formDatabase(baseConfig.database, count: numberOfItems, libId: id)\n        }\n        for (i in obj) {\n            series.navigation.append(\n                Link(\n                    title: i.name,\n                    href: \"http://${host}/opds/v2/series/${i.id}\",\n                    type_u: \"application/opds+json\"\n                )\n            )\n        }\n        return series\n    }\n\n    static func initPublisher(host: String): Group {\n        var publisher = Group()\n        publisher.metadata = Metadata(\"Publisher\")\n        var obj = BookSeries.getPublishList()\n        for (i in obj) {\n            var arg = Form(\"publisher=${i}\")\n            publisher.navigation.append(\n                Link(\n                    title: i,\n                    href: \"http://${host}/opds/v2/libraries/browse?${arg.toEncodeString()}\",\n                    type_u: \"application/opds+json\"\n                )\n            )\n        }\n        return publisher\n    }\n\n    public init(host!: String = \"127.0.0.1\", publisher!: String = \"\") {\n        var now = DateTime.now()\n        metadata = Metadata(\"All libraries\", modified: now.toString())\n        links = Links(host, \"libraries/browse\")\n        navigation = Navigation(host)\n        groups.append(initSeries(host, publisher))\n        groups.append(initPublisher(host))\n    }\n\n    public init(id: String, host!: String = \"127.0.0.1\", publisher!: String = \"\") {\n        let libr = Librarys.fromId(id)\n        metadata = Metadata(libr.name, modified: libr.lastModifiedDate)\n        links = Links(host, \"libraries/${id}/browse\")\n        navigation = Navigation(host, selfPath: \"libraries/${id}\")\n        groups.append(initSeries(id, host, publisher))\n        groups.append(initPublisher(host))\n    }\n\n    public func toJson(): String {\n        let stream = ByteBuffer()\n        let w = JsonWriter(stream)\n        w.startObject()\n        w.writeName(\"metadata\").writeValue(metadata)\n        w.writeName(\"links\").writeValue(links)\n        w.writeName(\"navigation\").writeValue(navigation)\n        w.writeName(\"groups\").writeValue<ArrayList<Group>>(groups)\n        w.endObject()\n        w.flush()\n        return String.fromUtf8(readToEnd(stream))\n    }\n}", "llm_cg": {"Brower": [], "Brower.initSeries": ["Group", "Metadata", "BookSeries.formPublisher", "BookSeries.getCount", "BookSeries.formDatabase", "series.navigation.append", "Link"], "Brower.initSeries_1": ["Group", "Metadata", "BookSeries.formPublisher", "BookSeries.getCount", "BookSeries.formDatabase", "series.navigation.append", "Link"], "Brower.initPublisher": ["Group", "Metadata", "BookSeries.getPublishList", "Form", "arg.toEncodeString", "publisher.navigation.append", "Link"], "Brower.__init__": ["DateTime.now", "Metadata", "now.toString", "Links", "Navigation", "groups.append", "initSeries", "initPublisher"], "Brower.__init___1": ["Librarys.fromId", "Metadata", "Links", "Navigation", "groups.append", "initSeries", "initPublisher"], "Brower.toJson": ["ByteBuffer", "JsonWriter", "w.startObject", "w.writeName", "w.writeValue", "w.endObject", "w.flush", "String.fromUtf8", "readToEnd"]}, "static_cg": {}}
{"source_code": "package opds_cj.path.opds.v2.libraries\n\nclass Reading {\n    var metadata: Metadata\n    var links: Links\n    var publications: ArrayList<Publication> = ArrayList<Publication>()\n    public init(host!: String = \"127.0.0.1\", userID!: String = \"\", page!: Int64 = 0) {\n        var now = DateTime.now()\n        metadata = Metadata(\"All libraries - Keep Reading\", itemsPerPage: 20, currentPage: page + 1,\n            numberOfItems: Librarys.getReadingCount(userID), modified: now.toString())\n        links = Links(host, \"libraries/keep-reading\", page: page)\n        var obj = Librarys.getReading(userID, page: page + 1, count: 20)\n        for (i in obj) {\n            publications.append(Publication(i, host))\n        }\n    }\n    public init(id: String, host!: String = \"127.0.0.1\", userID!: String = \"\", page!: Int64 = 0) {\n        let library = Librarys.fromId(id)\n        var now = DateTime.now()\n        metadata = Metadata(\"${library.name} - Keep Reading\", itemsPerPage: 20, currentPage: page + 1,\n            numberOfItems: Librarys.getReadingCount(userID), modified: now.toString())\n        links = Links(host, \"libraries/${id}/keep-reading\", page: page)\n        var obj = Librarys.getReading(userID, page: page + 1, count: 20, libraryId: id)\n        for (i in obj) {\n            publications.append(Publication(i, host))\n        }\n    }\n    public func toJson(): String {\n        let stream = ByteBuffer()\n        let w = JsonWriter(stream)\n        w.startObject()\n        w.writeName(\"metadata\").writeValue(metadata)\n        w.writeName(\"links\").writeValue(links)\n        w.writeName(\"publications\").writeValue<ArrayList<Publication>>(publications)\n        w.endObject()\n        w.flush()\n        return String.fromUtf8(readToEnd(stream))\n    }\n}", "llm_cg": {"Reading": ["Librarys.getReadingCount", "Links", "Librarys.getReading", "Publication", "Librarys.fromId", "ByteBuffer", "JsonWriter", "String.fromUtf8", "readToEnd"], "Reading.toJson": ["JsonWriter.startObject", "JsonWriter.writeName", "JsonWriter.writeValue", "JsonWriter.endObject", "JsonWriter.flush"]}, "static_cg": {}}
{"source_code": "package opds_cj.path.opds.v2.libraries\n\nclass Latest {\n    var metadata: Metadata\n    var links: Links\n    var publications: ArrayList<Publication> = ArrayList<Publication>()\n    public init(host!: String = \"127.0.0.1\", page!: Int64 = 0) {\n        var now = DateTime.now()\n        metadata = Metadata(\"All libraries - Latest Books\", itemsPerPage: 20, currentPage: page + 1,\n            numberOfItems: Books.getCount(), modified: now.toString())\n        links = Links(host, \"libraries/books/latest\", page: page)\n        var obj = Books.formDatabase(baseConfig.database, page: page + 1, count: 20)\n        for (i in obj) {\n            publications.append(Publication(i, host))\n        }\n    }\n    public init(id: String, host!: String = \"127.0.0.1\",  page!: Int64 = 0) {\n        let library = Librarys.fromId(id)\n        var now = DateTime.now()\n        metadata = Metadata(\"${library.name} - Latest Books\", itemsPerPage: 20, currentPage: page + 1,\n            numberOfItems: Books.getCount(libraryId: id), modified: now.toString())\n        links = Links(host, \"libraries/${id}/books/latest\", page: page)\n        var obj = Books.formDatabase(baseConfig.database, page: page + 1, count: 20, libId: id)\n        for (i in obj) {\n            publications.append(Publication(i, host))\n        }\n    }\n    public func toJson(): String {\n        let stream = ByteBuffer()\n        let w = JsonWriter(stream)\n        w.startObject()\n        w.writeName(\"metadata\").writeValue(metadata)\n        w.writeName(\"links\").writeValue(links)\n        w.writeName(\"publications\").writeValue<ArrayList<Publication>>(publications)\n        w.endObject()\n        w.flush()\n        return String.fromUtf8(readToEnd(stream))\n    }\n}", "llm_cg": {"main": [], "Latest": ["Metadata", "Links", "Books.getCount", "DateTime.now", "Books.formDatabase", "Librarys.fromId", "Publication", "baseConfig.database", "JsonWriter", "ByteBuffer", "String.fromUtf8", "ArrayList"], "Latest.init": ["DateTime.now", "Metadata", "Books.getCount", "Links", "Books.formDatabase", "Publication", "baseConfig.database"], "Latest.init.1": ["Librarys.fromId", "DateTime.now", "Metadata", "Books.getCount", "Links", "Books.formDatabase", "Publication", "baseConfig.database"], "Latest.toJson": ["ByteBuffer", "JsonWriter.startObject", "JsonWriter.writeName", "JsonWriter.writeValue", "JsonWriter.endObject", "JsonWriter.flush", "String.fromUtf8", "readToEnd"]}, "static_cg": {}}
{"source_code": "package opds_cj.path.opds.v2.libraries\n\npublic class CataLog {\n    var metadata: Metadata\n    var links: Links\n    var navigation: Navigation\n    var groups: ArrayList<Group> = ArrayList<Group>()\n    public init(host!: String = \"127.0.0.1\") {\n        var now = DateTime.now()\n        metadata = Metadata(\"All libraries - Recommended\", modified: now.toString())\n        links = Links(host, \"libraries\")\n        navigation = Navigation(host)\n        groups.append(initLibrarys(host))\n        groups.append(initSeries(host))\n        groups.append(initBooks(host))\n    }\n\n    static func initSeries(host: String): Group {\n        var series = Group()\n        series.metadata = Metadata(\"Latest Series\", itemsPerPage: 5, currentPage: 1,\n            numberOfItems: BookSeries.getCount())\n        series.links.append(\n            Link(\n                title: \"Latest Series\",\n                rel: \"self\",\n                href: \"http://${host}/opds/v2/libraries/series/latest\",\n                type_u: \"application/opds+json\"\n            )\n        )\n        var obj = BookSeries.formDatabase(baseConfig.database)\n        for (i in obj) {\n            series.navigation.append(\n                Link(\n                    title: i.name,\n                    href: \"http://${host}/opds/v2/series/${i.id}\",\n                    type_u: \"application/opds+json\"\n                )\n            )\n        }\n        return series\n    }\n\n    static func initLibrarys(host: String): Group {\n        var libraries = Group()\n        libraries.metadata = Metadata(\"Libraries\")\n        libraries.links.append(\n            Link(\n                rel: \"self\",\n                href: \"http://${host}/opds/v2/libraries\"\n            )\n        )\n        var obj = Librarys.formDatabase(baseConfig.database)\n        for (i in obj) {\n            libraries.navigation.append(\n                Link(\n                    title: i.name,\n                    href: \"http://${host}/opds/v2/libraries/${i.id}\",\n                    type_u: \"application/opds+json\"\n                )\n            )\n        }\n        return libraries\n    }\n\n    static func initBooks(host: String): Group {\n        var series = Group()\n        series.metadata = Metadata(\"Latest Books\", itemsPerPage: 5, currentPage: 1, numberOfItems: Books.getCount())\n        series.links.append(\n            Link(\n                title: \"Latest Books\",\n                rel: \"self\",\n                href: \"http://${host}/opds/v2/libraries/books/latest\",\n                type_u: \"application/opds+json\"\n            )\n        )\n        var obj = Books.formDatabase(baseConfig.database)\n        for (i in obj) {\n            series.publications.append(Publication(i, host))\n        }\n        return series\n    }\n\n    public func toJson(): String {\n        let stream = ByteBuffer()\n        let w = JsonWriter(stream)\n        w.startObject()\n        w.writeName(\"metadata\").writeValue(metadata)\n        w.writeName(\"links\").writeValue(links)\n        w.writeName(\"navigation\").writeValue(navigation)\n        w.writeName(\"groups\").writeValue<ArrayList<Group>>(groups)\n        w.endObject()\n        w.flush()\n        return String.fromUtf8(readToEnd(stream))\n    }\n}", "llm_cg": {"CataLog": ["DateTime.now", "Metadata", "Links", "Navigation", "CataLog.initLibrarys", "CataLog.initSeries", "CataLog.initBooks"], "CataLog.initSeries": ["Group", "Metadata", "BookSeries.getCount", "Link", "BookSeries.formDatabase"], "CataLog.initLibrarys": ["Group", "Metadata", "Link", "Librarys.formDatabase"], "CataLog.initBooks": ["Group", "Metadata", "Books.getCount", "Link", "Books.formDatabase", "Publication"], "CataLog.toJson": ["ByteBuffer", "JsonWriter", "JsonWriter.startObject", "JsonWriter.writeName", "JsonWriter.writeValue", "JsonWriter.writeName", "JsonWriter.writeValue", "JsonWriter.writeName", "JsonWriter.writeValue", "JsonWriter.writeName", "JsonWriter.writeValue<ArrayList<Group>>", "JsonWriter.endObject", "JsonWriter.flush", "String.fromUtf8", "readToEnd"]}, "static_cg": {}}
{"source_code": "package opds_cj.path.opds.v2.libraries\n\npublic class LibrariesDetail {\n    var metadata: Metadata\n    var links: Links\n    var navigation: Navigation\n    var groups: ArrayList<Group> = ArrayList<Group>()\n    public init(host!: String = \"127.0.0.1\", id!: String = \"\") {\n        let libr = Librarys.fromId(id)\n        metadata = Metadata(\"${libr.name} - Recommended\", modified: libr.lastModifiedDate)\n        links = Links(host, \"libraries/${id}\")\n        navigation = Navigation(host, selfPath: \"libraries/${id}\")\n        groups.append(initReading(host, id))\n        groups.append(initSeries(host, id))\n        groups.append(initBooks(host, id))\n    }\n\n    static func initReading(host: String, id: String): Group {\n        var reading = Group()\n        let readingList = Librarys.getReading(id, libraryId: id)\n        reading.metadata = Metadata(\"Keep Reading\", itemsPerPage: 5, currentPage: 1, numberOfItems: readingList.size)\n        reading.links.append(\n            Link(\n                title: \"Keep Reading\",\n                rel: \"self\",\n                href: \"http://${host}/opds/v2/libraries/${id}/keep-reading\",\n                type_u: \"application/opds+json\"\n            )\n        )\n        for (i in readingList) {\n            reading.publications.append(Publication(i, host))\n        }\n        return reading\n    }\n\n    static func initSeries(host: String, id: String): Group {\n        var series = Group()\n        series.metadata = Metadata(\"Latest Series\", itemsPerPage: 5, currentPage: 1,\n            numberOfItems: BookSeries.getCount())\n        series.links.append(\n            Link(\n                title: \"Latest Series\",\n                rel: \"self\",\n                href: \"http://${host}/opds/v2/libraries/${id}/series/latest\",\n                type_u: \"application/opds+json\"\n            )\n        )\n        var obj = BookSeries.formDatabase(baseConfig.database, libId: id)\n        for (i in obj) {\n            series.navigation.append(\n                Link(\n                    title: i.name,\n                    href: \"http://${host}/opds/v2/series/${i.id}\",\n                    type_u: \"application/opds+json\"\n                )\n            )\n        }\n        return series\n    }\n\n    static func initBooks(host: String, id: String): Group {\n        var series = Group()\n        series.metadata = Metadata(\"Latest Books\", itemsPerPage: 5, currentPage: 1, numberOfItems: Books.getCount())\n        series.links.append(\n            Link(\n                title: \"Latest Books\",\n                rel: \"self\",\n                href: \"http://${host}/opds/v2/libraries/${id}/books/latest\",\n                type_u: \"application/opds+json\"\n            )\n        )\n        var obj = Books.formDatabase(baseConfig.database, libId: id)\n        for (i in obj) {\n            series.publications.append(Publication(i, host))\n        }\n        return series\n    }\n\n    public func toJson(): String {\n        let stream = ByteBuffer()\n        let w = JsonWriter(stream)\n        w.startObject()\n        w.writeName(\"metadata\").writeValue(metadata)\n        w.writeName(\"links\").writeValue(links)\n        w.writeName(\"navigation\").writeValue(navigation)\n        w.writeName(\"groups\").writeValue<ArrayList<Group>>(groups)\n        w.endObject()\n        w.flush()\n        return String.fromUtf8(readToEnd(stream))\n    }\n}", "llm_cg": {"LibrariesDetail": ["Librarys.fromId", "Metadata", "Links", "Navigation", "LibrariesDetail.initReading", "LibrariesDetail.initSeries", "LibrariesDetail.initBooks"], "LibrariesDetail.initReading": ["Group", "Librarys.getReading", "Metadata", "Link", "Publication"], "LibrariesDetail.initSeries": ["Group", "Metadata", "BookSeries.getCount", "Link", "BookSeries.formDatabase"], "LibrariesDetail.initBooks": ["Group", "Metadata", "Books.getCount", "Link", "Books.formDatabase", "Publication"], "LibrariesDetail.toJson": ["ByteBuffer", "JsonWriter", "JsonWriter.startObject", "JsonWriter.writeName", "JsonWriter.writeValue", "JsonWriter.endObject", "JsonWriter.flush", "String.fromUtf8", "readToEnd"]}, "static_cg": {}}
{"source_code": "package opds_cj.path.opds.v2.libraries\n\nimport opds_cj.macros.*\n\n@Json\nclass Series {\n    var metadata: Metadata\n    var links: Links\n    var navigation: ArrayList<Link> = ArrayList<Link>()\n    public init(host!: String = \"127.0.0.1\", page!: Int64 = 0) {\n        var now = DateTime.now()\n        metadata = Metadata(\"All libraries - Latest Series\", itemsPerPage: 20, currentPage: page + 1,\n            numberOfItems: BookSeries.getCount(), modified: now.toString())\n        links = Links(host, \"libraries/series/latest\", page: page)\n        var obj = BookSeries.formDatabase(baseConfig.database, page: page, count: 20)\n        for (i in obj) {\n            navigation.append(\n                Link(\n                    title: i.name,\n                    href: \"http://${host}/opds/v2/series/${i.id}\",\n                    type_u: \"application/opds+json\"\n                )\n            )\n        }\n    }\n    public init(id: String, host!: String = \"127.0.0.1\",  page!: Int64 = 0) {\n        let library = Librarys.fromId(id)\n        var now = DateTime.now()\n        metadata = Metadata(\"${library.name} - Latest Series\", itemsPerPage: 20, currentPage: page + 1,\n            numberOfItems: BookSeries.getCount(id: id), modified: now.toString())\n        links = Links(host, \"libraries/${id}/series/latest\", page: page)\n        var obj = BookSeries.formDatabase(baseConfig.database, page: page, count: 20, libId: id)\n        for (i in obj) {\n            navigation.append(\n                Link(\n                    title: i.name,\n                    href: \"http://${host}/opds/v2/series/${i.id}\",\n                    type_u: \"application/opds+json\"\n                )\n            )\n        }\n    }\n}", "llm_cg": {"Series": [], "Series.init": ["DateTime.now", "Metadata", "BookSeries.getCount", "DateTime.now.toString", "Links", "BookSeries.formDatabase", "navigation.append", "Link"]}, "static_cg": {}}
{"source_code": "package opds_cj.path.opds.v2.libraries\n\nimport net.http.*\nimport opds_cj.router.PathMap\ninternal import std.{collection.*, time.*, convert.*, io.ByteBuffer, io.readToEnd}\ninternal import opds_cj.config.baseConfig\ninternal import opds_cj.data_stru.*\ninternal import encoding.{url.*, json.stream.*}\n\npublic func pathLoad(): PathMap {\n    var pathMap = PathMap(\n        \"/opds/v2/libraries\",\n        {\n            httpContext =>\n            let host = httpContext.request.headers.get(\"host\").toArray()[0]\n            var cataLog = CataLog(host: host)\n            httpContext.responseBuilder.header(\"content-type\", \"application/json;charset:utf-8;\")\n            httpContext.responseBuilder.body(cataLog.toJson())\n        }\n    )\n\n    pathMap.add(\n        \"/opds/v2/libraries/browse\",\n        {\n            httpContext =>\n            let host = httpContext.request.headers.get(\"host\").toArray()[0]\n            var publisher = \"\"\n            match (httpContext.request.url.query) {\n                case Some(x) => publisher = x.trimStart(\"publisher=\")\n                case None => ()\n            }\n            var brower = Brower(host: host, publisher: publisher)\n            httpContext.responseBuilder.header(\"content-type\", \"application/json;charset:utf-8;\")\n            httpContext.responseBuilder.body(brower.toJson())\n        }\n    )\n\n    pathMap.add(\n        \"/opds/v2/libraries/:id/browse\",\n        {\n            httpContext =>\n            let id = httpContext.request.url.toString().split(\"/\")[4]\n            let host = httpContext.request.headers.get(\"host\").toArray()[0]\n            var publisher = \"\"\n            match (httpContext.request.url.query) {\n                case Some(x) => publisher = x.trimStart(\"publisher=\")\n                case None => ()\n            }\n            var brower = Brower(id, host: host, publisher: publisher)\n            httpContext.responseBuilder.header(\"content-type\", \"application/json;charset:utf-8;\")\n            httpContext.responseBuilder.body(brower.toJson())\n        }\n    )\n\n    pathMap.add(\n        \"/opds/v2/libraries/:id\",\n        {\n            httpContext =>\n            let host = httpContext.request.headers.get(\"host\").toArray()[0]\n            let id = httpContext.request.url.toString().split(\"/\")[4]\n            var brower = LibrariesDetail(host: host, id: id)\n            httpContext.responseBuilder.header(\"content-type\", \"application/json;charset:utf-8;\")\n            httpContext.responseBuilder.body(brower.toJson())\n        }\n    )\n\n    pathMap.add(\n        \"/opds/v2/libraries/keep-reading\",\n        {\n            httpContext =>\n            let host = httpContext.request.headers.get(\"host\").toArray()[0]\n            var page = 0\n            match (httpContext.request.url.query) {\n                case Some(x) => page = Int64.parse(x.trimStart(\"page=\"))\n                case None => ()\n            }\n            let user = User(httpContext.request.headers.getFirst(\"Authorization\"))\n            if (user.id == \"\") {\n                httpContext.responseBuilder.status(401).body(\"unauthorized\".toArray())\n                return\n            }\n            var brower = Reading(host: host, userID: user.id, page: page)\n            httpContext.responseBuilder.header(\"content-type\", \"application/json;charset:utf-8;\")\n            httpContext.responseBuilder.body(brower.toJson())\n        }\n    )\n\n    pathMap.add(\n        \"/opds/v2/libraries/:id/keep-reading\",\n        {\n            httpContext =>\n            let host = httpContext.request.headers.get(\"host\").toArray()[0]\n            let id = httpContext.request.url.toString().split(\"/\")[4]\n            var page = 0\n            match (httpContext.request.url.query) {\n                case Some(x) => page = Int64.parse(x.trimStart(\"page=\"))\n                case None => ()\n            }\n            let user = User(httpContext.request.headers.getFirst(\"Authorization\"))\n            if (user.id == \"\") {\n                httpContext.responseBuilder.status(401).body(\"unauthorized\".toArray())\n                return\n            }\n            var brower = Reading(id, host: host, userID: user.id, page: page)\n            httpContext.responseBuilder.header(\"content-type\", \"application/json;charset:utf-8;\")\n            httpContext.responseBuilder.body(brower.toJson())\n        }\n    )\n\n    pathMap.add(\n        \"/opds/v2/libraries/:id/books/latest\",\n        {\n            httpContext =>\n            let host = httpContext.request.headers.get(\"host\").toArray()[0]\n            let id = httpContext.request.url.toString().split(\"/\")[4]\n            var page = 0\n            match (httpContext.request.url.query) {\n                case Some(x) => page = Int64.parse(x.trimStart(\"page=\"))\n                case None => ()\n            }\n            var brower = Latest(id, host: host, page: page)\n            httpContext.responseBuilder.header(\"content-type\", \"application/json;charset:utf-8;\")\n            httpContext.responseBuilder.body(brower.toJson())\n        }\n    )\n\n    pathMap.add(\n        \"/opds/v2/libraries/books/latest\",\n        {\n            httpContext =>\n            let host = httpContext.request.headers.get(\"host\").toArray()[0]\n            var page = 0\n            match (httpContext.request.url.query) {\n                case Some(x) => page = Int64.parse(x.trimStart(\"page=\"))\n                case None => ()\n            }\n            var brower = Latest(host: host, page: page)\n            httpContext.responseBuilder.header(\"content-type\", \"application/json;charset:utf-8;\")\n            httpContext.responseBuilder.body(brower.toJson())\n        }\n    )\n\n    pathMap.add(\n        \"/opds/v2/libraries/:id/series/latest\",\n        {\n            httpContext =>\n            let host = httpContext.request.headers.get(\"host\").toArray()[0]\n            let id = httpContext.request.url.toString().split(\"/\")[4]\n            var page = 0\n            match (httpContext.request.url.query) {\n                case Some(x) => page = Int64.parse(x.trimStart(\"page=\"))\n                case None => ()\n            }\n            var brower = Series(id, host: host, page: page)\n            httpContext.responseBuilder.header(\"content-type\", \"application/json;charset:utf-8;\")\n            httpContext.responseBuilder.body(brower.toJson())\n        }\n    )\n\n    pathMap.add(\n        \"/opds/v2/libraries/series/latest\",\n        {\n            httpContext =>\n            let host = httpContext.request.headers.get(\"host\").toArray()[0]\n            var page = 0\n            match (httpContext.request.url.query) {\n                case Some(x) => page = Int64.parse(x.trimStart(\"page=\"))\n                case None => ()\n            }\n            var brower = Series(host: host, page: page)\n            httpContext.responseBuilder.header(\"content-type\", \"application/json;charset:utf-8;\")\n            httpContext.responseBuilder.body(brower.toJson())\n        }\n    )\n    return pathMap\n}\n", "llm_cg": {"pathLoad": ["PathMap", "httpContext.request.headers.get", "<builtin>.toArray", "CataLog", "httpContext.responseBuilder.header", "httpContext.responseBuilder.body", "httpContext.request.url.query", "Brower", "<builtin>.match", "httpContext.request.url.toString", "<builtin>.split", "LibrariesDetail", "Int64.parse", "User", "httpContext.request.headers.getFirst", "<builtin>.return", "httpContext.responseBuilder.status", "Reading", "Latest", "Series"]}, "static_cg": {}}
{"source_code": "package opds_cj.path.opds.v2.search\n\nimport net.http.*\nimport std.{time.*, convert.*, collection.*, io.ByteBuffer, io.readToEnd}\nimport encoding.json.stream.*\nimport opds_cj.config.baseConfig\nimport opds_cj.router.PathMap\nimport opds_cj.data_stru.*\n\nclass Search {\n    var metadata: Metadata\n    var links: Links\n    var groups: ArrayList<Group> = ArrayList<Group>()\n    public init(query: String, host!: String = \"127.0.0.1\") {\n        var now = DateTime.now()\n        metadata = Metadata(\"Search results\", modified: now.toString())\n        links = Links(host, \"catalog\", searchPage: true)\n        initSeries(query, host: host)\n    }\n\n    func initSeries(query: String, host!: String = \"127.0.0.1\") {\n        var group = Group()\n        group.metadata = Metadata(\"Series\")\n        var obj = BookSeries.query(query)\n        for (i in obj) {\n            group\n                .navigation\n                .append(\n                    Link(title: i.name, href: \"http://${host}/opds/v2/series/${i.id}\", type_u: \"application/opds+json\"))\n        }\n        this.groups.append(group)\n    }\n\n    public func toJson(): String {\n        let stream = ByteBuffer()\n        let w = JsonWriter(stream)\n        w.startObject()\n        w.writeName(\"metadata\").writeValue(metadata)\n        w.writeName(\"links\").writeValue(links)\n        w.writeName(\"groups\").writeValue<ArrayList<Group>>(groups)\n        w.endObject()\n        w.flush()\n        return String.fromUtf8(readToEnd(stream))\n    }\n}\n\npublic func pathLoad(): PathMap {\n    var pathMap = PathMap(\n        \"/opds/v2/search\",\n        {\n            httpContext =>\n            let host = httpContext.request.headers.get(\"host\").toArray()[0]\n            var query = \"\"\n            match (httpContext.request.url.query) {\n                case Some(x) => query = x.trimStart(\"query=\")\n                case None => ()\n            }\n            var cataLog = Search(query, host: host)\n            httpContext.responseBuilder.header(\"content-type\", \"application/json;charset:utf-8;\")\n            httpContext.responseBuilder.body(cataLog.toJson())\n        }\n    )\n\n    return pathMap\n}\n", "llm_cg": {"main": [], "Search": ["Metadata", "Links", "DateTime.now", "this.initSeries", "ArrayList", "ByteBuffer", "JsonWriter", "JsonWriter.startObject", "JsonWriter.writeName", "JsonWriter.writeValue", "JsonWriter.endObject", "JsonWriter.flush", "String.fromUtf8", "readToEnd"], "Search.initSeries": ["Group", "Metadata", "BookSeries.query", "this.groups.append", "Link"], "Search.toJson": [], "pathLoad": ["PathMap", "Search"]}, "static_cg": {}}
{"source_code": "package opds_cj.path.opds.v2.series\n\nimport net.http.*\nimport encoding.json.stream.*\nimport std.{io.ByteBuffer, io.readToEnd, collection.*, convert.*}\nimport opds_cj.config.baseConfig\nimport opds_cj.router.PathMap\nimport opds_cj.data_stru.*\n\nclass Series {\n    var metadata: Metadata\n    var links: Links\n    var publications: ArrayList<Publication> = ArrayList<Publication>()\n    public init(id: String, host!: String = \"127.0.0.1\", page!: Int64 = 0) {\n        let series = BookSeries.fromId(id)\n        metadata = Metadata(series.name, itemsPerPage: 20, currentPage: page + 1,\n            numberOfItems: BookSeries.getCount(id: id), modified: series.lastModifiedDate)\n        metadata.addBookDesc(id)\n        links = Links(host, \"series/${id}\", page: page)\n        var obj = Books.formDatabase(baseConfig.database, page: page + 1, count: 20, seriesId: id)\n        for (i in obj) {\n            publications.append(Publication(i, host))\n        }\n    }\n    public func toJson(): String {\n        let stream = ByteBuffer()\n        let w = JsonWriter(stream)\n        w.startObject()\n        w.writeName(\"metadata\").writeValue(metadata)\n        w.writeName(\"links\").writeValue(links)\n        w.writeName(\"publications\").writeValue<ArrayList<Publication>>(publications)\n        w.endObject()\n        w.flush()\n        return String.fromUtf8(readToEnd(stream))\n    }\n}\n\npublic func pathLoad(): PathMap {\n    var pathMap = PathMap(\n        \"/opds/v2/series/:id\",\n        {\n            httpContext =>\n            let host = httpContext.request.headers.get(\"host\").toArray()[0]\n            let id = httpContext.request.url.path.split(\"/\")[4]\n            var page = 0\n            match (httpContext.request.url.query) {\n                case Some(x) => page = Int64.parse(x.trimStart(\"page=\"))\n                case None => ()\n            }\n            var cataLog = Series(id, host: host, page: page)\n            httpContext.responseBuilder.header(\"content-type\", \"application/json;charset:utf-8;\")\n            httpContext.responseBuilder.body(cataLog.toJson())\n        }\n    )\n\n    return pathMap\n}\n", "llm_cg": {"Series": ["BookSeries.fromId", "BookSeries.getCount", "Metadata", "Metadata.addBookDesc", "Links", "Books.formDatabase", "Publication"], "Series.toJson": ["ByteBuffer", "JsonWriter", "JsonWriter.startObject", "JsonWriter.writeName", "JsonWriter.writeValue", "JsonWriter.endObject", "JsonWriter.flush", "<builtin>.String.fromUtf8", "<builtin>.readToEnd"], "pathLoad": ["PathMap", "httpContext.request.headers.get", "httpContext.request.url.path.split", "<builtin>.Int64.parse", "Series", "Series.toJson"]}, "static_cg": {}}
{"source_code": "package opds_cj.config\n\nimport encoding.url.URL\n\npublic class baseConfig {\n    public static let database: String = \"./data/Komga/database.sqlite\"\n    public static func getFileURL(rawURL: String): String {\n        var url = URL.parse(rawURL)\n        return url.path //.replace(\"/books\", \"./data/Komga/books\")\n    }\n}", "llm_cg": {"baseConfig": ["encoding.url.URL.parse"], "baseConfig.getFileURL": ["encoding.url.URL.parse"]}, "static_cg": {}}
{"source_code": "package SimpleJsonReader\n\nimport std.unittest.*\nimport std.unittest.testmacro.*\n\n@Test\nclass JsonBoolTest {\n    @TestCase\n    func testBoolOptionTrue() {\n        @Expect(Json(str: #\"{ \"true\" : true }\"#)[\"true\"].bool, Option.Some(true))\n    }\n\n    @TestCase\n    func testBoolTrue() {\n        @Expect(Json(str: #\"{ \"true\" : true }\"#)[\"true\"].boolValue, true)\n    }\n\n    @TestCase\n    func testBoolFalse() {\n        @Expect(Json(str: #\"{ \"false\" : false }\"#)[\"false\"].boolValue, false)\n    }\n\n    @TestCase\n    func testBoolOptionFalse() {\n        @Expect(Json(str: #\"{ \"false\" : false }\"#)[\"false\"].boolValue, Option.Some(false))\n    }\n\n    @TestCase\n    func testBoolDefault() {\n        @Expect(Json(str: #\"{}\"#)[\"key\"].boolValue, false)\n    }\n\n    @TestCase\n    func testBoolOptionNone() {\n        @Expect(Json(str: #\"{}\"#)[\"key\"].bool, Option.None)\n    }\n}\n", "llm_cg": {"main": [], "JsonBoolTest": ["Expect"], "JsonBoolTest.testBoolOptionTrue": ["Json", "Expect"], "JsonBoolTest.testBoolTrue": ["Json", "Expect"], "JsonBoolTest.testBoolFalse": ["Json", "Expect"], "JsonBoolTest.testBoolOptionFalse": ["Json", "Expect"], "JsonBoolTest.testBoolDefault": ["Json", "Expect"], "JsonBoolTest.testBoolOptionNone": ["Json", "Expect"]}, "static_cg": {}}
{"source_code": "package SimpleJsonReader\n\nimport std.unittest.*\nimport std.unittest.testmacro.*\n\n@Test\nclass JsonChainTest {\n\n    private let json = Json(str: #\"\n    {\n        \"array\": [1, 2, 3],\n        \"struct\": {\n            \"key\": \"value\"\n        }\n    }\"#)\n\n    @TestCase\n    func testExist() {        \n        @Expect(json[\"struct\"][\"key\"].stringValue, \"value\")\n    }\n\n    @TestCase\n    func testNotExist() {        \n        @Expect(json[\"a\"][\"b\"][99][\"c\"][\"*\"][\"@\"][-1].stringValue, \"\")\n    }\n}\n", "llm_cg": {"main": [], "JsonChainTest": ["Json", "JsonChainTest.testExist", "JsonChainTest.testNotExist"], "JsonChainTest.testExist": ["Expect"], "JsonChainTest.testNotExist": ["Expect"]}, "static_cg": {}}
{"source_code": "package SimpleJsonReader\n\nimport std.unittest.*\nimport std.unittest.testmacro.*\nimport encoding.json.*\n\n@Test\nclass JsonArrayTest {\n\n    @TestCase\n    func test() {\n        let jsonStr = #\"\n        {\n            \"array\": [1, \"2\", 3.0, {\"key\": \"value\"}]\n        }\n        \"#\n        let json = Json(str: jsonStr)\n        @Expect(json[\"array\"].arrayValue.size, 4)\n        @Expect(json[\"array\"].arrayValue[3][\"key\"].stringValue, \"value\")\n    }\n}", "llm_cg": {"main": [], "JsonArrayTest": [], "JsonArrayTest.test": ["Json", "json.arrayValue.size", "json.arrayValue.__getitem__", "json.__getitem__", "json.arrayValue.__getitem__.get", "Expect"]}, "static_cg": {}}
{"source_code": "package SimpleJsonReader\n\nimport std.unittest.*\nimport std.unittest.testmacro.*\n\n@Test\nclass JsonStringTest {\n    @TestCase\n    func testStringOption() {\n        @Expect(Json(str: #\"{ \"string\" : \"123\" }\"#)[\"string\"].string, Option.Some(\"123\"))\n    }\n\n    @TestCase\n    func testString() {\n        @Expect(Json(str: #\"{ \"string\" : \"123\" }\"#)[\"string\"].stringValue, \"123\")\n    }\n\n    @TestCase\n    func testStringDefault() {\n        @Expect(Json(str: #\"{}\"#)[\"string\"].stringValue, \"\")\n    }\n\n    @TestCase\n    func testStringOptionNone() {\n        @Expect(Json(str: #\"{}\"#)[\"string\"].string, Option.None)\n    }\n}\n", "llm_cg": {"JsonStringTest.testStringOption": [], "JsonStringTest.testString": [], "JsonStringTest.testStringDefault": [], "JsonStringTest.testStringOptionNone": []}, "static_cg": {}}
{"source_code": "package SimpleJsonReader\n\nimport encoding.json.*\nimport std.collection.*\nimport serialization.serialization.*\n\npublic struct Json {\n    private let value: JsonValue\n\n    private init(value!: JsonValue) {\n        this.value = value\n    }\n\n    public init(str!: String) {\n        var reval: JsonValue\n        try {\n            reval = JsonValue.fromStr(str)\n        } catch (e: Exception) {\n            reval = JsonNull()\n        }\n        this.value = reval\n    }\n\n    public func deserialize<T>(): Option<T> where T <: Serializable<T> {\n        try {\n            return T.deserialize(this.dataModel)\n        } catch (_: Exception) {\n            return Option.None\n        }\n    }\n\n    public operator func [](arg: Int): Json {\n        try {\n            match (this.value.kind()) {\n                case JsonKind.JsArray => Json(value: this.value.asArray()[arg])\n                case _ => return Json(value: JsonNull())\n            }\n        } catch (_: Exception) {\n            return Json(value: JsonNull())\n        }\n    }\n\n    public operator func [](arg: String): Json {\n        try {\n            match (this.value.kind()) {\n                case JsonKind.JsObject => Json(value: this.value.asObject()[arg])\n                case _ => return Json(value: JsonNull())\n            }\n        } catch (_: Exception) {\n            return Json(value: JsonNull())\n        }\n    }\n\n    public prop array: Option<Array<Json>> {\n        get() {\n            match (this.value.kind()) {\n                case JsonKind.JsArray => return collectArray(\n                    this.value.asArray().getItems() |> map {e => Json(value: e)})\n                case _ => return Option.None\n            }\n        }\n    }\n\n    public prop arrayValue: Array<Json> {\n        get() {\n            match (this.array) {\n                case Option.Some(v) => return v\n                case Option.None => return Array()\n            }\n        }\n    }\n\n    public prop dataModel: DataModel {\n        get() {\n            return DataModel.fromJson(this.value)\n        }\n    }\n\n    public prop bool: Option<Bool> {\n        get() {\n            match (this.value.kind()) {\n                case JsonKind.JsBool => return Option.Some(this.value.asBool().getValue())\n                case _ => return Option.None\n            }\n        }\n    }\n\n    public prop boolValue: Bool {\n        get() {\n            match (this.bool) {\n                case Option.Some(v) => return v\n                case Option.None => return false\n            }\n        }\n    }\n\n    public prop int64: Option<Int64> {\n        get() {\n            match (this.value.kind()) {\n                case JsonKind.JsInt => return Option.Some(this.value.asInt().getValue())\n                case _ => return Option.None\n            }\n        }\n    }\n\n    public prop int64Value: Int64 {\n        get() {\n            match (this.int64) {\n                case Option.Some(v) => return v\n                case Option.None => return 0\n            }\n        }\n    }\n\n    public prop float64: Option<Float64> {\n        get() {\n            match (this.value.kind()) {\n                case JsonKind.JsFloat => return Option.Some(this.value.asFloat().getValue())\n                case _ => return Option.None\n            }\n        }\n    }\n\n    public prop float64Value: Float64 {\n        get() {\n            match (this.float64) {\n                case Option.Some(v) => return v\n                case Option.None => return 0.0\n            }\n        }\n    }\n\n    public prop string: Option<String> {\n        get() {\n            match (this.value.kind()) {\n                case JsonKind.JsString => return Option.Some(this.value.asString().getValue())\n                case _ => return Option.None\n            }\n        }\n    }\n\n    public prop stringValue: String {\n        get() {\n            match (this.string) {\n                case Option.Some(v) => return v\n                case Option.None => return \"\"\n            }\n        }\n    }\n}\n", "llm_cg": {"Json": ["JsonValue.fromStr", "JsonNull", "T.deserialize", "Option.None", "JsonValue.kind", "JsonKind.JsArray", "JsonValue.asArray", "JsonKind.JsObject", "JsonValue.asObject", "collectArray", "DataModel.fromJson", "JsonKind.JsBool", "JsonValue.asBool", "Option.Some", "JsonKind.JsInt", "JsonValue.asInt", "JsonKind.JsFloat", "JsonValue.asFloat", "JsonKind.JsString", "JsonValue.asString"], "Json.array.get": ["JsonValue.kind", "JsonKind.JsArray", "JsonValue.asArray", "collectArray", "Option.None"], "Json.arrayValue.get": ["Json.array", "Option.Some", "Option.None"], "Json.dataModel.get": ["DataModel.fromJson"], "Json.bool.get": ["JsonValue.kind", "JsonKind.JsBool", "JsonValue.asBool", "Option.Some", "Option.None"], "Json.boolValue.get": ["Json.bool", "Option.Some", "Option.None"], "Json.int64.get": ["JsonValue.kind", "JsonKind.JsInt", "JsonValue.asInt", "Option.Some", "Option.None"], "Json.int64Value.get": ["Json.int64", "Option.Some", "Option.None"], "Json.float64.get": ["JsonValue.kind", "JsonKind.JsFloat", "JsonValue.asFloat", "Option.Some", "Option.None"], "Json.float64Value.get": ["Json.float64", "Option.Some", "Option.None"], "Json.string.get": ["JsonValue.kind", "JsonKind.JsString", "JsonValue.asString", "Option.Some", "Option.None"], "Json.stringValue.get": ["Json.string", "Option.Some", "Option.None"]}, "static_cg": {}}
{"source_code": "package SimpleJsonReader\n\nimport std.unittest.*\nimport std.unittest.testmacro.*\nimport serialization.serialization.*\n\nprivate struct Person <: Serializable<Person> {\n\n    let name: String\n\n    init(name!: String) {\n        this.name = name\n    }\n\n    static public func deserialize(dm: DataModel): Person {\n        let dms = match(dm) {\n            case d: DataModelStruct => d\n            case _ => throw Exception(\"This data is not DataModelStruct\")\n        }\n        return Person(name: String.deserialize(dms.get(\"name\")))\n    }\n    \n    public func serialize(): DataModel {\n        let dms = DataModelStruct()\n        dms.add(field(\"name\", this.name))\n        return dms\n    }\n}\n\n@Test\nclass JsonDeserializeTest {\n\n    @TestCase\n    func test() {\n        let jsonStr = #\"\n        {\n            \"name\": \"Arror\"\n        }\"#\n        let json = Json(str: jsonStr)\n        let person = json.deserialize<Person>()\n        @Expect(person.isSome())\n    }\n}\n", "llm_cg": {"main": [], "Person": [], "Person.deserialize": ["match", "String.deserialize", "dms.get", "<builtin>.throw"], "Person.serialize": ["DataModelStruct", "dms.add", "field"], "JsonDeserializeTest": [], "JsonDeserializeTest.test": ["Json", "json.deserialize", "person.isSome", "@Expect"]}, "static_cg": {}}
{"source_code": "package SimpleJsonReader\n\nimport std.unittest.*\nimport std.unittest.testmacro.*\n\n@Test\nclass JsonFloat64Test {\n    @TestCase\n    func testFloat64Option() {\n        @Expect(Json(str: #\"{ \"float64\" : 123.0 }\"#)[\"float64\"].float64, Option.Some(123.0))\n    }\n\n    @TestCase\n    func testFloat64() {\n        @Expect(Json(str: #\"{ \"float64\" : 123.0 }\"#)[\"float64\"].float64Value, 123.0)\n    }\n\n    @TestCase\n    func testFloat64Default() {\n        @Expect(Json(str: #\"{}\"#)[\"float64\"].float64Value, 0.0)\n    }\n\n    @TestCase\n    func testFloat64OptionNone() {\n        @Expect(Json(str: #\"{}\"#)[\"float64\"].float64, Option.None)\n    }\n}\n", "llm_cg": {"main": [], "JsonFloat64Test": [], "JsonFloat64Test.testFloat64Option": ["Json", "Option.Some"], "JsonFloat64Test.testFloat64": ["Json"], "JsonFloat64Test.testFloat64Default": ["Json"], "JsonFloat64Test.testFloat64OptionNone": ["Json", "Option.None"]}, "static_cg": {}}
{"source_code": "package SimpleJsonReader\n\nimport std.unittest.*\nimport std.unittest.testmacro.*\n\n@Test\nclass JsonInt64Test {\n    @TestCase\n    func testInt64Option() {\n        @Expect(Json(str: #\"{ \"int64\" : 123 }\"#)[\"int64\"].int64, Option.Some(123))\n    }\n\n    @TestCase\n    func testInt64() {\n        @Expect(Json(str: #\"{ \"int64\" : 123 }\"#)[\"int64\"].int64Value, 123)\n    }\n\n    @TestCase\n    func testInt64Default() {\n        @Expect(Json(str: #\"{}\"#)[\"int64\"].int64Value, 0)\n    }\n\n    @TestCase\n    func testInt64OptionNone() {\n        @Expect(Json(str: #\"{}\"#)[\"int64\"].int64, Option.None)\n    }\n}\n", "llm_cg": {"main": [], "JsonInt64Test": [], "JsonInt64Test.testInt64Option": ["Json", "Option.Some"], "JsonInt64Test.testInt64": ["Json"], "JsonInt64Test.testInt64Default": ["Json"], "JsonInt64Test.testInt64OptionNone": ["Json", "Option.None"]}, "static_cg": {}}
{"source_code": "// 构建一个简单的 HTTP 服务器，可以响应 GET 与 POST 请求，并支持 JSON 数据\n// cjc version: 0.55.3\nimport std.fs.{ File, OpenOption }\nimport net.http.*\nimport encoding.json.{ JsonObject, JsonValue }\n\nclass HttpServer {\n    let server: Server\n    public init(ip: String, port: UInt16) {\n        server = ServerBuilder().addr(ip).port(port).build()\n        println(\"http://${ip}:${port}\")\n    }\n\n    public func route(route: String,\n        callback: (req: HttpRequest, res: HttpResponseBuilder) -> Unit) {\n        server.distributor.register(route, { context => \n            callback(context.request, context.responseBuilder)\n        })\n    }\n\n    public func start() {\n        server.serve()\n    }\n}\n\nfunc readFile(path: String): String {\n    return String.fromUtf8(File.readFrom(path))\n}\n\nmain() {\n    let server = HttpServer(\"127.0.0.1\", 8080)\n    // 响应 GET 请求\n    server.route(\"/\", { req, res => \n        if (req.method == \"GET\") {\n            // 设置 http 响应头\n            let Headers = HttpHeaders()\n            Headers.add(\"Content-Type\", \"text/html;charset=utf-8;\")\n            res.setHeaders(Headers)\n            // 返回读取一个 html 文件，并返回给客户端\n            res.body(readFile(\"./index.html\"))\n        }\n    })\n    // 响应 POST 请求\n    server.route(\"/testApi\", { req, res => \n        if (req.method == \"POST\") {\n            // 读取请求内容\n            let data = Array<UInt8>(1024, repeat: 0)\n            let length = req.body.read(data)\n            let content = String.fromUtf8(data.slice(0, length))\n            println(content)\n            let object = JsonValue.fromStr(content).asObject()\n\n            // 初始化一个空的 JsonObject，并添加键值和信息\n            let response = JsonObject()\n            response.put(\"code\", JsonValue.fromStr(\"\\\"ok\\\"\"))\n            let UserName = object.get(\"name\").getOrThrow().asString().getValue()\n            response.put(\"msg\", JsonValue.fromStr(\"\\\"Cangjie：Hello ${UserName}\\\"\"))\n\n            // 设置 http 响应头\n            let headers = HttpHeaders()\n            headers.add(\"Content-Type\", \"applications/json;charset=utf-8;\")\n            res.setHeaders(headers)\n\n            // 将 JsonObject 转为 Json 字符串文本并响应返回\n            res.body(response.toJsonString())\n        }\n    })\n    server.start()\n}\n", "llm_cg": {"main": ["HttpServer", "HttpServer.route", "readFile", "String.fromUtf8", "File.readFrom", "req.body.read", "JsonValue.fromStr", "JsonObject", "JsonObject.put", "HttpHeaders", "HttpHeaders.add", "res.setHeaders", "response.toJsonString", "JsonValue.fromStr", "<builtin>.println", "HttpServer.start"], "HttpServer": ["ServerBuilder", "ServerBuilder.addr", "ServerBuilder.port", "ServerBuilder.build", "<builtin>.println"], "HttpServer.route": ["server.distributor.register", "callback"], "HttpServer.start": ["server.serve"], "readFile": ["File.readFrom", "String.fromUtf8"]}, "static_cg": {}}
{"source_code": "package cj_debounce_throttle\nimport cj_debounce_throttle.macros.*\n\nfunc debounceAction(action: () -> Unit) {\n    action()\n\n    sleep(Duration.millisecond * 10)\n    action()\n\n    sleep(Duration.millisecond * 20)\n    action()\n\n    sleep(Duration.millisecond * 30)\n    action()\n}\n\nfunc throttleAction(action: () -> Unit) {\n    action()\n\n    sleep(Duration.millisecond * 20)\n    action()\n\n    sleep(Duration.millisecond * 40)\n    action()\n\n    sleep(Duration.millisecond * 80)\n    action()\n}\n\nfunc debounceRepeater() {\n    let start = getNowTime()\n    // let config = RepeaterConfig(interval: Duration.millisecond * 100, leading: false, trailing: true)\n    // Repeater(throttle: false, config: config){}\n    Repeater(throttle: false, mode: Trailing(100)) {\n        println('testDebounce执行间隔 ${getNowTime()-start}')\n    }\n}\n\nfunc throttleRepeater() {\n    let start = getNowTime()\n    Repeater(throttle: true, mode: Trailing(50)) {\n        println('testThrottle执行间隔 ${getNowTime()-start}')\n    }\n}\n\nlet start = getNowTime()\n@Debounce[100]\nfunc debounceFunc() {\n    println('myDebounce执行间隔 ${getNowTime()-start}')\n}\n\n@Throttle[50]\nfunc throttleFunc() {\n    println('myThrottle执行间隔 ${getNowTime()-start}')\n}\n\nclass RepeaterMemberMacro {\n    let start = getNowTime()\n\n    @Debounce[100]\n    func myDebounce() {\n        println('myDebounce执行间隔 ${getNowTime()-start}')\n    }\n\n    @Throttle[50]\n    func myThrottle() {\n        println('myThrottle执行间隔 ${getNowTime()-start}')\n    }\n}\n\nmain(): Int64 {\n    // 直接使用Repeater\n    // debounceAction(debounceRepeater().call)\n    // throttleAction(throttleRepeater().call)\n    // 全局函数 使用宏\n    // debounceAction(debounceFunc)\n    // throttleAction(throttleFunc)\n    // 类的实例成员方法 使用宏\n    // debounceAction(RepeaterMemberMacro().myDebounce)\n    throttleAction(RepeaterMemberMacro().myThrottle)\n\n    sleep(Duration.second * 2)\n    return 0\n}\n", "llm_cg": {"main": ["throttleAction", "RepeaterMemberMacro", "RepeaterMemberMacro.myThrottle", "sleep", "Duration.second"], "debounceAction": ["sleep", "Duration.millisecond", "action"], "throttleAction": ["sleep", "Duration.millisecond", "action"], "debounceRepeater": ["getNowTime", "Trailing", "Repeater", "<builtin>.println", "getNowTime"], "throttleRepeater": ["getNowTime", "Trailing", "Repeater", "<builtin>.println", "getNowTime"], "debounceFunc": ["<builtin>.println", "getNowTime"], "throttleFunc": ["<builtin>.println", "getNowTime"], "RepeaterMemberMacro": ["getNowTime"], "RepeaterMemberMacro.myDebounce": ["<builtin>.println", "getNowTime"], "RepeaterMemberMacro.myThrottle": ["<builtin>.println", "getNowTime"]}, "static_cg": {}}
{"source_code": "package cj_debounce_throttle.repeater\n\npublic import std.time.MonoTime\n\npublic func getNowTime(): MonoTime {\n    MonoTime.now()\n}\n", "llm_cg": {"getNowTime": ["MonoTime.now"]}, "static_cg": {}}
{"source_code": "// cjlint-ignore -start !G.NAM.02 !G.EXP.03\npackage cj_debounce_throttle.repeater\n\npublic import std.sync.Timer\n\npublic class Repeater {\n    private var lastCallTime: MonoTime = getNowTime()\n    private var lastRunTaskTime: MonoTime = getNowTime()\n    private var firstRunTask: Bool = false\n    // 定时器，只有trailing才会使用\n    private var timer: ?Timer = None\n\n    // 配置和任务\n    private let config: RepeaterConfig\n    private let task: RepeaterTask\n    private let throttle: Bool\n\n    public init(throttle!: Bool, mode!: RepeaterMode, task!: RepeaterTask) {\n        this(throttle: throttle, config: mode.config, task: task)\n    }\n\n    public init(throttle!: Bool, config!: RepeaterConfig, task!: RepeaterTask) {\n        this.config = config\n        this.task = task\n        this.throttle = throttle\n        this.verifyConfig()\n    }\n\n    // release条件下为空实现\n    @When[!debug]\n    func verifyConfig() {}\n\n    // debug下实现具体逻辑\n    @When[debug]\n    func verifyConfig() {\n        if (!config.leading && !config.trailing) {\n            throw IllegalArgumentException('leading和trailing需要至少有一项为true')\n        }\n    }\n\n    // 是否可以运行任务\n    private prop canRunTask: Bool {\n        get() {\n            if (throttle) {\n                let delta = getNowTime() - lastRunTaskTime\n                (delta > config.interval) || !this.firstRunTask\n            } else {\n                let delta = getNowTime() - lastCallTime\n                (delta > config.interval) || !this.firstRunTask\n            }\n        }\n    }\n\n    private func dealLeadingCall() {\n        // timer不存在，说明没开启过计时。如果设置了头部执行，则立即执行\n        if (config.leading && canRunTask) {\n            runTask()\n        }\n    }\n\n    private func dealTrailingCall() {\n        if (config.trailing && timer.isNone()) {\n            // 这里置为true，是考虑到只有trailing没有leading的情况。假设任务已执行一次\n            firstRunTask = true\n            lastRunTaskTime = getNowTime()\n            // 启动timer\n            timer = Timer.after(config.interval) {\n                let now = getNowTime()\n\n                if (throttle) {\n                    runTask()\n                    if (now - lastCallTime > config.interval) {\n                        cancel()\n                        return None\n                    } else {\n                        return config.interval\n                    }\n                } else {\n                    if (now - lastCallTime > config.interval) {\n                        runTask()\n                        // Timer置None，重新计时\n                        cancel()\n                        // 返回None，让timer生效\n                        return None\n                    } else {\n                        // 定时器距离上次调用call方法的时间间隔\n                        let delta = now - lastCallTime\n                        // 返回从上次点击后到下一个interval的时间\n                        return config.interval - delta\n                    }\n                }\n            }\n        }\n    }\n\n    public func call(): Unit {\n        this.dealLeadingCall()\n        this.dealTrailingCall()\n        lastCallTime = getNowTime()\n    }\n\n    public func cancel(): Unit {\n        timer?.cancel()\n        timer = None\n    }\n\n    private func runTask() {\n        task()\n        firstRunTask = true\n        lastRunTaskTime = getNowTime()\n    }\n}\n// cjlint-ignore -end\n", "llm_cg": {}, "static_cg": {}}
{"source_code": "// cjlint-ignore -start !G.NAM.02\npackage cj_debounce_throttle.repeater\n\n/**\n * 任务类型\n */\npublic type RepeaterTask = () -> Unit\n\n/**\n * 模式,时间为毫秒\n */\npublic enum RepeaterMode {\n    | Leading(Int)\n    | Trailing(Int)\n    | Both(Int)\n\n    public prop config: RepeaterConfig {\n        get() {\n            match (this) {\n                case Leading(interval) => RepeaterConfig(\n                    interval: Duration.millisecond * interval,\n                    leading: true,\n                    trailing: false\n                )\n                case Trailing(interval) => RepeaterConfig(\n                    interval: Duration.millisecond * interval,\n                    leading: false,\n                    trailing: true\n                )\n                case Both(interval) => RepeaterConfig(\n                    interval: Duration.millisecond * interval,\n                    leading: true,\n                    trailing: true\n                )\n            }\n        }\n    }\n}\n\n/**\n * 属性配置\n */\npublic struct RepeaterConfig {\n    /**\n     * interval 等待间隔时间(毫秒)\n     * leading在开头调用\n     * trailing在最后调用\n     */\n    public RepeaterConfig(\n        var interval!: Duration,\n        var leading!: Bool = false,\n        var trailing!: Bool = true\n    ) {}\n}\n// cjlint-ignore -end\n", "llm_cg": {}, "static_cg": {}}
{"source_code": "// cjlint-ignore -start !G.NAM.02 !G.EXP.03 !G.FUN.01\nmacro package cj_debounce_throttle.macros\n\nimport std.time.MonoTime\nimport std.convert.Parsable\nimport std.collection.ArrayList\ninternal import std.ast.{TokenKind, ToTokens, Tokens, parseDecl, FuncDecl, parseExpr, parseExprFragment, diagReport, \n    DiagReportLevel, LitConstExpr, RefExpr, Token}\npublic import cj_debounce_throttle.repeater.* // cjlint-ignore !G.PKG.01\n\nconst LEADING_STRING: String = 'leading'\nconst TRAILING_STRING: String = 'trailing'\n\n/**\n * 保证必须是一个函数声明，然后执行action动作\n */\nfunc mustBeFunc(\n    input: Tokens,\n    action: (FuncDecl) -> Tokens\n): Tokens {\n    let decl = parseDecl(input)\n    if (let Some(funcDecl) <- (decl as FuncDecl)) {\n        action(funcDecl)\n    } else {\n        diagReport(\n            DiagReportLevel.ERROR,\n            input,\n            '不是函数类型',\n            '只支持函数类型'\n        )\n        input\n    }\n}\n\n/**\n * 解析属性\n */\nfunc parseAttrToConfig(attrs: Tokens): Tokens {\n    var interval = 0\n    var leading = false\n    var trailing = false\n\n    var index: Int64 = 0\n    while (true) {\n        let (litExpr, nextIndex) = parseExprFragment(attrs, startFrom: index)\n        match (litExpr) {\n            case litConstExpr: LitConstExpr =>\n                let literal = litConstExpr.literal\n                if (literal.kind == TokenKind.INTEGER_LITERAL) {\n                    interval = Int64.parse(literal.value)\n                } else if (literal.kind == TokenKind.STRING_LITERAL) {\n                    let value = literal.value\n                    if (value == LEADING_STRING) {\n                        leading = true\n                    } else if (value == TRAILING_STRING) {\n                        trailing = true\n                    }\n                }\n            case refExpr: RefExpr =>\n                let value = refExpr.identifier.value\n                if (value == LEADING_STRING) {\n                    leading = true\n                } else if (value == TRAILING_STRING) {\n                    trailing = true\n                }\n            case _ => diagReport(\n                DiagReportLevel.ERROR,\n                attrs[nextIndex..nextIndex],\n                '这里必须是字面量',\n                '只支持字面量'\n            )\n        }\n\n        if (nextIndex >= attrs.size) {\n            break\n        }\n\n        if (attrs[nextIndex].kind != TokenKind.COMMA) {\n            diagReport(\n                DiagReportLevel.ERROR,\n                attrs[nextIndex..nextIndex + 1],\n                \"必须是逗号分割的多个表达式\",\n                \"改为逗号\"\n            )\n        }\n\n        index = nextIndex + 1\n    }\n\n    // 必须有interval\n    if (interval == 0) {\n        diagReport(\n            DiagReportLevel.ERROR,\n            attrs,\n            \"必须有时间(毫秒)\",\n            \"添加时间属性\"\n        )\n    }\n\n    if (!leading && !trailing) {\n        trailing = true\n    }\n\n    quote(\n        RepeaterConfig(interval: Duration.millisecond * $(interval), leading: $(leading), trailing: $(trailing)))\n}\n\n/**\n * 实现Debounce或者Throttle的宏\n */\nfunc impDebounceOrThrottle(throttle: Bool, attr: Tokens, funcDecl: FuncDecl): Tokens {\n    // 解析参数\n    let config = parseAttrToConfig(attr)\n    // 外层创建一个Debouncer\n    let debouncerName = Token(TokenKind.IDENTIFIER, \"debouncerFor\" + funcDecl.identifier.value.toAsciiTitle())\n    // 将函数体作为debouncer的block\n    let ret = quote(private var $(debouncerName): ?Repeater = None\n        )\n\n    let funcBlockNodes = funcDecl.block.nodes\n    let orgNodes = funcBlockNodes.clone()\n    funcBlockNodes.clear()\n    funcBlockNodes.append(\n        parseExpr(\n        quote(\n            $(debouncerName).getOrDefault {\n            let config = $(config)\n            Repeater(throttle: $(throttle.toTokens()), config: config) {\n                $(orgNodes)\n            }}.call())\n    ))\n    ret.append(funcDecl.toTokens())\n    return ret\n}\n// cjlint-ignore -end\n", "llm_cg": {"main": [], "mustBeFunc": ["parseDecl", "diagReport", "DiagReportLevel.ERROR", "action"], "parseAttrToConfig": ["parseExprFragment", "diagReport", "DiagReportLevel.ERROR", "Int64.parse", "quote", "Duration.millisecond"], "impDebounceOrThrottle": ["parseAttrToConfig", "Token", "quote", "parseExpr", "quote"]}, "static_cg": {}}
{"source_code": "macro package cj_debounce_throttle.macros\n/**\n * Debounce实现\n * @author unravel\n * @description\n\n    debounce简单实现，高频动作连续触发时，实际动作往后顺移\n\n    使用方式如下\n    300毫秒,开始前和结束后都回调\n    300这个数字是必须的，leading和trailing是可选的。他们三个使用逗号分割\n    leading和trailing都没有时，默认为trailing\n    @Debounce[300,leading, trailing]\n */\npublic macro Debounce(attr: Tokens, input: Tokens): Tokens {\n    mustBeFunc(input) {\n        funcDecl: FuncDecl => impDebounceOrThrottle(false, attr, funcDecl)\n    }\n}\n\n/**\n * Throttle实现\n * @author unravel\n * @description\n\n    throttle简单实现，高频动作连续触发时，每隔interval调用一次实际动作\n\n    使用方式和 Debounce 一样\n */\npublic macro Throttle(attr: Tokens, input: Tokens): Tokens {\n    mustBeFunc(input) {\n        funcDecl: FuncDecl => impDebounceOrThrottle(true, attr, funcDecl)\n    }\n}\n", "llm_cg": {"main": [], "Debounce": ["mustBeFunc", "impDebounceOrThrottle"], "Throttle": ["mustBeFunc", "impDebounceOrThrottle"]}, "static_cg": {}}
{"source_code": "package openai_chat\nimport encoding.json.stream.*\nimport net.http.ClientBuilder\nimport net.http.HttpHeaders\nimport net.http.HttpRequestBuilder\nimport net.tls.TlsClientConfig\nimport net.tls.CertificateVerifyMode\nimport std.collection.ArrayList\nimport std.io.ByteArrayStream\nimport std.time.Duration\n\npublic struct FunctionCall <: JsonDeserializable<FunctionCall> & JsonSerializable {\n  public let name: String;\n  public let arguments: String;\n\n  public init(name: String, arguments: String) {\n    this.name = name;\n    this.arguments = arguments;\n  }\n\n  public static func fromJson(r: JsonReader): FunctionCall {\n    var temp_name: String = \"\";\n    var temp_arguments: String = \"\";\n    while (let Some(v) <- r.peek()) {\n      match(v) {\n        case BeginObject =>\n          r.startObject();\n          while(r.peek() != EndObject) {\n              let n = r.readName()\n              match (n) {\n                  case \"name\" => temp_name = r.readValue<String>();\n                  case \"arguments\" => temp_arguments = r.readValue<String>();\n                  case unkow => println(\"unkow key ${unkow}\");\n              }\n          }\n          r.endObject();\n          break;\n        case _ => throw Exception(\"can't deserialize for FunctionCall\");\n      }\n    }\n    return FunctionCall(temp_name, temp_arguments);\n  }\n\n  public func toJson(w: JsonWriter) {\n    w.startObject();\n    w.writeName(\"name\").writeValue<String>(this.name);\n    w.writeName(\"arguments\").writeValue<String>(this.arguments);\n    w.endObject();\n    w.flush();\n  }\n}\n\npublic enum RoleType {\n  User | Assistant | System | Function | NULL\n}\n\npublic func role_type_to_str(role: RoleType): Option<String> {\n  return match(role) {\n    case RoleType.User => Some(\"user\")\n    case RoleType.Assistant => Some(\"assistant\")\n    case RoleType.System => Some(\"system\")\n    case RoleType.Function => Some(\"function\")\n    case RoleType.NULL => None\n  }\n}\n\npublic func str_to_role_type(role_option_str: Option<String>): RoleType {\n  return match(role_option_str) {\n    case Some(role_option) => \n      match (role_option) {\n        case \"user\" => RoleType.User\n        case \"assistant\" => RoleType.Assistant\n        case \"system\" => RoleType.System\n        case \"function\" => RoleType.Function\n        case x => throw Exception(\"unknow enum ${x} for RoleType\");\n      }\n    case None => RoleType.NULL\n  }\n}\n\n\npublic struct Message<: JsonDeserializable<Message> & JsonSerializable {\n  public let role: RoleType;\n  public var content: String;\n  public let function_call: Option<FunctionCall>;\n\n  public init(role: RoleType, content: String) {\n    this.role = role;\n    this.content = content;\n    this.function_call = None;\n  }\n\n  public init(role: RoleType, content: String, function_call: Option<FunctionCall>) {\n    this.role = role;\n    this.content = content;\n    this.function_call = function_call;\n  }\n\n  public static func fromJson(r: JsonReader): Message {\n    var temp_role: Option<String> = None; // role may null in stream chat\n    var temp_content: String = \"\";\n    var temp_functional_call: Option<FunctionCall> = None;\n    while (let Some(v) <- r.peek()) {\n      match(v) {\n        case BeginObject =>\n          r.startObject();\n          while(r.peek() != EndObject) {\n              let n = r.readName()\n              match (n) {\n                  case \"role\" => temp_role = r.readValue<Option<String>>();\n                  case \"content\" => temp_content = r.readValue<String>();\n                  case \"function_call\" => temp_functional_call = r.readValue<Option<FunctionCall>>();\n                  case unkow => println(\"unkow key ${unkow}\");\n              }\n          }\n          r.endObject();\n          break;\n        case _ => throw Exception(\"can't deserialize for Message\");\n      }\n    }\n    let role_type: RoleType = str_to_role_type(temp_role);\n    return Message(role_type, temp_content);\n  }\n\n  public func toJson(w: JsonWriter) {\n    w.startObject();\n    w.writeName(\"role\").writeValue<Option<String>>(role_type_to_str(this.role));\n    w.writeName(\"content\").writeValue<String>(this.content);\n    w.endObject();\n    w.flush();\n  }\n}\n\npublic struct ChatRequest <: JsonSerializable {\n  private let model: String;\n  private let messages: ArrayList<Message>;\n  private let max_tokens: Int64;\n  private let temperature: Float64;\n  private let top_p: Float64;\n  private let n: Int32;\n  private let stream: Bool;\n\n  public init(\n    model: String,\n    messages: ArrayList<Message>,\n    max_tokens: Int64,\n    temperature: Float64,\n    top_p: Float64,\n    n: Int32,\n    stream: Bool\n  ) {\n    // construction function with messages\n    this.model = model;\n    this.messages = messages;\n    this.max_tokens = max_tokens;\n    this.temperature = temperature;\n    this.top_p = top_p;\n    this.n = n;\n    this.stream = stream;\n  }\n\n  public init(\n    model: String,\n    prompt: String,\n    history: ArrayList<(String, String)>,\n    system_prompt: String,\n    max_tokens: Int64,\n    temperature: Float64,\n    top_p: Float64,\n    n: Int32,\n    stream: Bool\n  ){\n    // construction function with prompt and system_prompt\n    this.model = model;\n    this.messages = ArrayList<Message>([\n      Message(RoleType.System, system_prompt)\n    ]);\n    for ((use_msg, bot_msg) in history) {\n      this.messages.append(Message(RoleType.User, use_msg));\n      this.messages.append(Message(RoleType.Assistant, bot_msg));\n    }\n    this.messages.append(Message(RoleType.User, prompt));\n    this.max_tokens = max_tokens;\n    this.temperature = temperature;\n    this.top_p = top_p;\n    this.n = n;\n    this.stream = stream;\n  }\n\n  public init(\n    model: String,\n    prompt: String,\n    history: ArrayList<(String, String)>,\n    system_prompt: String,\n    stream: Bool\n  ){\n    // construction function with prompt and default arguments\n    this.model = model;\n    this.messages = ArrayList<Message>([\n      Message(RoleType.System, system_prompt)\n    ]);\n    for ((use_msg, bot_msg) in history) {\n      this.messages.append(Message(RoleType.User, use_msg));\n      this.messages.append(Message(RoleType.Assistant, bot_msg));\n    }\n    this.messages.append(Message(RoleType.User, prompt));\n    this.max_tokens = 2000;\n    this.temperature = 0.7;\n    this.top_p = 1.0;\n    this.n = 1;\n    this.stream = stream;\n  }\n\n  public func toJson(w: JsonWriter) {\n    w.startObject();\n    w.writeName(\"model\").writeValue<String>(this.model);\n    w.writeName(\"messages\").writeValue<ArrayList<Message>>(this.messages);\n    w.writeName(\"max_tokens\").writeValue<Int64>(this.max_tokens);\n    w.writeName(\"temperature\").writeValue<Float64>(this.temperature);\n    w.writeName(\"top_p\").writeValue<Float64>(this.top_p);\n    w.writeName(\"n\").writeValue<Int32>(this.n);\n    w.writeName(\"stream\").writeValue<Bool>(this.stream);\n    w.endObject();\n    w.flush();\n  }\n}\n\n\npublic struct Choice <: JsonDeserializable<Choice> & JsonSerializable {\n  public let index: Int32;\n  public let message: Option<Message>;\n  public let delta: Option<Message>;\n  public let finish_reason: Option<String>;\n  public let logprobs: Option<Float64>; // dashscope for qwen need\n\n  public init(\n    index: Int32,\n    message: Option<Message>,\n    delta: Option<Message>,\n    finish_reason: Option<String>,\n    logprobs: Option<Float64>\n  ) {\n    this.index = index;\n    this.message = message;\n    this.delta = delta;\n    this.finish_reason = finish_reason;\n    this.logprobs = logprobs\n  }\n\n  public static func fromJson(r: JsonReader): Choice {\n    var temp_index: Int32 = -1;\n    var temp_message: Option<Message> = None;\n    var temp_delta: Option<Message> = None;\n    var temp_finish_reason: Option<String> = None;\n    var temp_logprobs: Option<Float64> = None;\n    while (let Some(v) <- r.peek()) {\n      match(v) {\n        case BeginObject =>\n          r.startObject();\n          while(r.peek() != EndObject) {\n              let n = r.readName()\n              match (n) {\n                  case \"index\" => temp_index = r.readValue<Int32>();\n                  case \"message\" => temp_message = r.readValue<Option<Message>>();\n                  case \"delta\" => temp_delta = r.readValue<Option<Message>>();\n                  case \"finish_reason\" => temp_finish_reason = r.readValue<Option<String>>();\n                  case \"logprobs\" => temp_logprobs = r.readValue<Option<Float64>>();\n                  case unkow => println(\"unkow key ${unkow}\");\n              }\n          }\n          r.endObject();\n          break\n        case _ => throw Exception(\"can't deserialize for Choice\");\n      }\n    }\n    return Choice(temp_index, temp_message, temp_delta, temp_finish_reason, temp_logprobs);\n  }\n\n  public func toJson(w: JsonWriter) {\n    w.startObject();\n    w.writeName(\"index\").writeValue<Int32>(this.index);\n    w.writeName(\"message\").writeValue<Option<Message>>(this.message);\n    w.writeName(\"delta\").writeValue<Option<Message>>(this.delta);\n    w.writeName(\"finish_reason\").writeValue<Option<String>>(this.finish_reason);\n    w.writeName(\"logprobs\").writeValue<Option<Float64>>(this.logprobs);\n    w.endObject();\n    w.flush();\n  }\n}\n\npublic struct Usage <: JsonDeserializable<Usage> & JsonSerializable {\n  public let prompt_tokens: UInt64;\n  public let completion_tokens: UInt64;\n  public let total_tokens: UInt64;\n\n  public init(prompt_tokens: UInt64, completion_tokens: UInt64, total_tokens: UInt64) {\n    this.prompt_tokens = prompt_tokens;\n    this.completion_tokens = completion_tokens;\n    this.total_tokens = total_tokens;\n  }\n\n  public static func fromJson(r: JsonReader): Usage {\n    var temp_prompt_tokens: UInt64 = 0;\n    var temp_completion_tokens: UInt64 = 0;\n    var temp_total_tokens: UInt64 = 0;\n    while (let Some(v) <- r.peek()) {\n      match(v) {\n        case BeginObject =>\n          r.startObject();\n          while(r.peek() != EndObject) {\n              let n = r.readName()\n              match (n) {\n                  case \"prompt_tokens\" => temp_prompt_tokens = r.readValue<UInt64>();\n                  case \"completion_tokens\" => temp_completion_tokens = r.readValue<UInt64>();\n                  case \"total_tokens\" => temp_total_tokens = r.readValue<UInt64>();\n                  case unkow => println(\"unkow key ${unkow}\");\n              }\n          }\n          r.endObject();\n          break\n        case _ => throw Exception(\"can't deserialize for Usage\");\n      }\n    }\n    return Usage(temp_prompt_tokens, temp_completion_tokens, temp_total_tokens);\n  }\n\n  public func toJson(w: JsonWriter) {\n    w.startObject();\n    w.writeName(\"prompt_tokens\").writeValue<UInt64>(this.prompt_tokens);\n    w.writeName(\"completion_tokens\").writeValue<UInt64>(this.completion_tokens);\n    w.writeName(\"total_tokens\").writeValue<UInt64>(this.total_tokens);\n    w.endObject();\n    w.flush();\n  }\n}\n\npublic struct ChatResponse <: JsonDeserializable<ChatResponse> {\n  // some api names `id`, and some names `request_id`\n  public let id: Option<String>;\n  public let request_id: Option<String>;\n  public let system_fingerprint: Option<String>;\n  public let model: String;\n  public let object: String;\n  public let created: UInt64;\n  public let choices: ArrayList<Choice>;\n  public let usage: Option<Usage>;\n\n  public init(\n    id: Option<String>,\n    request_id: Option<String>,\n    system_fingerprint: Option<String>,\n    model: String,\n    object: String,\n    created: UInt64,\n    choices: ArrayList<Choice>,\n    usage: Option<Usage>\n  ) {\n    this.id = id;\n    this.request_id = request_id;\n    this.system_fingerprint = system_fingerprint;\n    this.model = model;\n    this.object = object;\n    this.created = created;\n    this.choices = choices;\n    this.usage = usage;\n  }\n\n  public static func fromJson(r: JsonReader): ChatResponse {\n    var temp_id: Option<String> = None;\n    var temp_request_id: Option<String> = None;\n    var temp_system_fingerprint: Option<String> = None;\n    var temp_model: String = \"\";\n    var temp_object: String = \"\";\n    var temp_created: UInt64 = 0;\n    var temp_choices: ArrayList<Choice> = ArrayList<Choice>([]);\n    var temp_usage: Option<Usage> = None;\n    while (let Some(v) <- r.peek()) {\n      match(v) {\n        case BeginObject =>\n          r.startObject();\n          while(r.peek() != EndObject) {\n              let n = r.readName()\n              match (n) {\n                  case \"id\" => temp_id = r.readValue<Option<String>>();\n                  case \"request_id\" => temp_request_id = r.readValue<Option<String>>();\n                  case \"system_fingerprint\" => temp_system_fingerprint = r.readValue<Option<String>>();\n                  case \"model\" => temp_model = r.readValue<String>();\n                  case \"object\" => temp_object = r.readValue<String>();\n                  case \"created\" => temp_created = r.readValue<UInt64>();\n                  case \"choices\" => temp_choices = r.readValue<ArrayList<Choice>>();\n                  case \"usage\" => temp_usage = r.readValue<Option<Usage>>();\n                  case unkow => println(\"unkow key ${unkow}\");\n              }\n          }\n          r.endObject();\n          break\n        case _ => throw Exception(\"can't deserialize for ChatResponse\")\n      }\n    }\n    return ChatResponse(\n      temp_id,\n      temp_request_id,\n      temp_system_fingerprint,\n      temp_model,\n      temp_object,\n      temp_created,\n      temp_choices,\n      temp_usage\n    );\n  }\n}\n\npublic func get_domain(\n  url: String\n): String {\n  var temp_url = url;\n  if (temp_url.startsWith(\"https://\")) {\n    temp_url = temp_url[\"https://\".size..];\n  } else if (temp_url.startsWith(\"http://\")) {\n    temp_url = temp_url[\"http://\".size..];\n  }\n  let domain: String = temp_url.split(\"?\")[0].split(\"/\")[0];\n  return domain;\n}\n\npublic func build_http_client(\n  prompt: String,\n  env_info: EnvInfo,\n  history: ArrayList<(String, String)>,\n  stream!: Bool\n){\n  // prepare input data\n  var array_stream = ByteArrayStream();\n  let json_writer = JsonWriter(array_stream);\n  let chat_res = ChatRequest(\n    env_info.model,\n    prompt,\n    history,\n    env_info.system_prompt,\n    stream\n  )\n  chat_res.toJson(json_writer);\n  let post_data: Array<UInt8> = array_stream.readToEnd();\n  var headers: HttpHeaders = HttpHeaders();\n  headers.add(\"Authorization\", \"Bearer ${env_info.api_key}\");\n  headers.add(\"Content-Type\", \"application/json\");\n  if (stream) {\n    headers.add(\"Accept\", \"text/event-stream\");\n  }\n  let request = HttpRequestBuilder()\n    .url(env_info.base_url)\n    .method(\"POST\")\n    .body(post_data)\n    .readTimeout(Duration.second * 120)\n    .addHeaders(headers)\n    .build();\n  let client = if (env_info.base_url.startsWith(\"https\")) {\n    var tls_client_config = TlsClientConfig();\n    tls_client_config.verifyMode = CertificateVerifyMode.TrustAll;\n    tls_client_config.domain = get_domain(env_info.base_url);\n    ClientBuilder()\n      .tlsConfig(tls_client_config)\n      .build();\n  } else {\n    ClientBuilder().build();\n  }\n  return (request, client);\n}\n\npublic func chat(\n  prompt: String,\n  env_info: EnvInfo,\n  history: ArrayList<(String, String)>\n): Option<String> {\n  let (request, client) = build_http_client(\n    prompt,\n    env_info,\n    history,\n    stream: false\n  ); \n  var result_message: Option<String> = None;\n  var res_text = \"\";\n  try {\n    // call api\n    let response = client.send(\n      request\n    );\n    // read result (support max revice 100k data)\n    let buffer = Array<Byte>(102400, item: 0);\n    let length = response.body.read(buffer);\n    res_text = String.fromUtf8(buffer[..length]);\n    // println(\"res_text: ${res_text}\");\n    var input_stream = ByteArrayStream();\n    input_stream.write(res_text.toArray());\n    // convert text to ChatResponse object\n    let json_reader = JsonReader(input_stream);\n    let res_object = ChatResponse.fromJson(json_reader);\n    let choices: ArrayList<Choice> = res_object.choices;\n    if (choices.size > 0) {\n      let message = choices[0].message.getOrThrow();\n      // println(\"message: ${message.content}\")\n      result_message = Some(message.content);\n      \n    } else {\n      println(\"can't found any response\");\n    }\n  } catch (e: Exception) {\n    println(\"ERROR: ${e.message}, reviced text is ${res_text}\");\n  }\n  client.close();\n  return result_message;\n}\n\n\npublic func stream_chat(\n  prompt: String,\n  env_info: EnvInfo,\n  history: ArrayList<(String, String)>\n): Option<String> {\n  let (request, client) = build_http_client(\n    prompt,\n    env_info,\n    history,\n    stream: true\n  ); \n  var result_response: String = \"\";\n  var temp_text2 = \"\";\n  try {\n    // call api\n    let response = client.send(\n      request\n    );\n    // read result\n    let buffer = Array<Byte>(10240, item: 0);\n    var finish_reason: Option<String> = None;\n    while(finish_reason.isNone() && temp_text2 != \"[DONE]\") {\n      let length = response.body.read(buffer);\n      let res_text = String.fromUtf8(buffer[..length]);\n\n      for (temp_text in res_text.split(\"\\n\")) {\n        temp_text2 =  if (temp_text.startsWith(\"data: \")) {\n          temp_text[\"data: \".size..];\n        } else {\n          temp_text\n        };\n        if (temp_text2.size == 0) {\n          continue;\n        }\n        if (temp_text2 == \"[DONE]\") {\n          break;\n        }\n        // println(\"========================\");\n        // println(\"temp_text: ${temp_text2}\");\n        // println(\"========================\");\n        var input_stream = ByteArrayStream();\n        input_stream.write(temp_text2.toArray());\n        // convert text to ChatResponse object\n        let json_reader = JsonReader(input_stream);\n        let res_object = ChatResponse.fromJson(json_reader);\n        let choices: ArrayList<Choice> = res_object.choices;\n        if (choices.size > 0) {\n          finish_reason = choices[0].finish_reason;\n          if (finish_reason.isNone()) {\n            let delta = choices[0].delta.getOrThrow();\n            print(\"${delta.content}\", flush: true);\n            result_response += delta.content; \n          }\n        } else {\n          println(\"can't found any response\");\n        }\n      }\n    }\n  } catch (e: Exception) {\n    println(\"ERROR: ${e.message}, reviced text is ${temp_text2}\");\n  }\n  client.close();\n  if (result_response.size > 0) {\n    return Some(result_response);\n  } else {\n    return None;\n  }\n}", "llm_cg": {"main": [], "FunctionCall": [], "FunctionCall.fromJson": ["r.peek", "r.startObject", "r.peek", "r.readName", "r.readValue", "r.readValue", "<builtin>.println", "r.endObject", "<builtin>.throw", "<builtin>.throw", "FunctionCall"], "FunctionCall.toJson": ["w.startObject", "w.writeName", "w.writeName", "w.endObject", "w.flush"], "role_type_to_str": [], "str_to_role_type": ["<builtin>.throw"], "Message": [], "Message.fromJson": ["r.peek", "r.startObject", "r.peek", "r.readName", "r.readValue", "r.readValue", "r.readValue", "<builtin>.println", "r.endObject", "<builtin>.throw", "str_to_role_type", "Message"], "Message.toJson": ["w.startObject", "w.writeName", "role_type_to_str", "w.writeName", "w.endObject", "w.flush"], "ChatRequest": ["ArrayList", "Message"], "ChatRequest.toJson": ["w.startObject", "w.writeName", "w.writeName", "w.writeName", "w.writeName", "w.writeName", "w.writeName", "w.endObject", "w.flush"], "Choice": [], "Choice.fromJson": ["r.peek", "r.startObject", "r.peek", "r.readName", "r.readValue", "r.readValue", "r.readValue", "r.readValue", "r.readValue", "<builtin>.println", "r.endObject", "<builtin>.throw", "Choice"], "Choice.toJson": ["w.startObject", "w.writeName", "w.writeName", "w.writeName", "w.writeName", "w.writeName", "w.endObject", "w.flush"], "Usage": [], "Usage.fromJson": ["r.peek", "r.startObject", "r.peek", "r.readName", "r.readValue", "r.readValue", "r.readValue", "<builtin>.println", "r.endObject", "<builtin>.throw", "Usage"], "Usage.toJson": ["w.startObject", "w.writeName", "w.writeName", "w.writeName", "w.endObject", "w.flush"], "ChatResponse": [], "ChatResponse.fromJson": ["r.peek", "r.startObject", "r.peek", "r.readName", "r.readValue", "r.readValue", "r.readValue", "r.readValue", "r.readValue", "r.readValue", "r.readValue", "r.readValue", "<builtin>.println", "r.endObject", "<builtin>.throw", "ChatResponse"], "get_domain": ["<builtin>.split", "<builtin>.split"], "build_http_client": ["ByteArrayStream", "JsonWriter", "ChatRequest", "ChatRequest.toJson", "array_stream.readToEnd", "HttpHeaders", "headers.add", "headers.add", "headers.add", "HttpRequestBuilder", "Duration.second", "get_domain", "ClientBuilder", "ClientBuilder.build"], "chat": ["build_http_client", "client.send", "response.body.read", "String.fromUtf8", "<builtin>.println", "ByteArrayStream", "input_stream.write", "ChatResponse.fromJson", "ChatResponse.fromJson", "choices[0].message.getOrThrow", "<builtin>.println", "<builtin>.println", "<builtin>.throw", "client.close"], "stream_chat": ["build_http_client", "client.send", "response.body.read", "String.fromUtf8", "<builtin>.println", "ByteArrayStream", "input_stream.write", "ChatResponse.fromJson", "ChatResponse.fromJson", "choices[0].delta.getOrThrow", "<builtin>.print", "println", "<builtin>.println", "<builtin>.println", "<builtin>.throw", "client.close"]}, "static_cg": {}}
{"source_code": "package openai_chat\nimport encoding.json.stream.*\nimport std.fs.File\nimport std.fs.Path\nimport std.io.ByteArrayStream\n\npublic class EnvInfo <: JsonDeserializable<EnvInfo> & JsonSerializable {\n  public let model: String;          // 模型名称\n  public let api_key: String;        // api密钥\n  public let base_url: String;       // 调用接口路径\n  public let system_prompt: String;  // 预置系统提示词\n\n  public init(model: String, api_key: String, base_url: String, system_prompt: String) {\n    this.model = model;\n    this.api_key = api_key;\n    this.base_url = base_url;\n    this.system_prompt = system_prompt\n  }\n  \n  public static func fromJson(r: JsonReader): EnvInfo {\n    var temp_model: String = \"\";\n    var temp_api_key: String = \"sk-xxx\";\n    var temp_base_url: String = \"http://xxx.xxx.xxx/v1\";\n    var temp_system_prompt: String = \"You are a helpful assistant.\";\n    while (let Some(v) <- r.peek()) {\n      match(v) {\n        case BeginObject =>\n          r.startObject()\n          while(r.peek() != EndObject) {\n            let n = r.readName()\n            match (n) {\n                case \"model\" => temp_model = r.readValue<String>()\n                case \"api_key\" => temp_api_key = r.readValue<String>()\n                case \"base_url\" => temp_base_url = r.readValue<String>()\n                case \"system_prompt\" => temp_system_prompt = r.readValue<String>()\n                case _ => ()\n            }\n          }\n          r.endObject()\n          break\n        case _ => throw Exception()\n      }\n    }\n    return EnvInfo(temp_model, temp_api_key, temp_base_url, temp_system_prompt);\n  }\n  \n  public func toJson(w: JsonWriter): Unit {\n      w.startObject();\n      w.writeName(\"model\").writeValue(this.model);\n      w.writeName(\"api_key\").writeValue(this.api_key);\n      w.writeName(\"base_url\").writeValue(this.base_url);\n      w.writeName(\"system_prompt\").writeValue(this.system_prompt);\n      w.endObject();\n      w.flush();\n  }\n}\n\n\npublic func save_env_info(): Unit {\n  // 该函数用于测试EnvInfo类的序列化为json的能力，顺便生成一个env_sample.json样本做为参考\n  let env_path = Path(\"env_sample.json\");\n  if (File.exists(env_path)) {\n    File.delete(env_path);\n  }\n  let file = File.create(env_path);\n  let env_info = EnvInfo(\n    \"xxxx\",\n    \"sk-xxxxxx\",\n    \"http://xxx.xxx.xxx/v1/chat/completions\",\n    \"You are a helpful assistant.\"\n  );\n  var byte_stream = ByteArrayStream();\n  var json_writer = JsonWriter(byte_stream);\n  let write_config = WriteConfig.pretty;\n  json_writer.writeConfig = write_config;\n  env_info.toJson(json_writer);\n  file.write(byte_stream.readToEnd());\n  println(\"`env_sample.json` save ok\")\n  file.close();\n}\n\n\npublic func load_env_info(): EnvInfo {\n  // 用于加载配置文件\n  let env_path = Path(\"env.json\");\n  if (!File.exists(env_path)) {\n    throw Exception(\"`.env` file not exists, please check again\");\n  }\n  let file = File.openRead(env_path);\n  let file_str: Array<UInt8> = file.readToEnd();\n  var byte_stream = ByteArrayStream();\n  byte_stream.write(file_str);\n  let json_reader = JsonReader(byte_stream);\n  let env_info: EnvInfo = EnvInfo.fromJson(json_reader);\n  file.close();\n  // println(\"model: ${env_info.model}\");\n  // println(\"api_key: ${env_info.api_key}\");\n  // println(\"base_url: ${env_info.base_url}\");\n  // println(\"system_prompt: ${env_info.system_prompt}\");\n  return env_info;\n}", "llm_cg": {"main": [], "EnvInfo": [], "EnvInfo.fromJson": ["r.peek", "r.startObject", "r.peek", "r.readName", "r.readValue", "r.endObject", "EnvInfo", "<builtin>.throw"], "EnvInfo.toJson": ["w.startObject", "w.writeName", "w.writeValue", "w.endObject", "w.flush"], "save_env_info": ["Path", "File.exists", "File.delete", "File.create", "EnvInfo", "ByteArrayStream", "JsonWriter", "WriteConfig.pretty", "EnvInfo.toJson", "byte_stream.readToEnd", "file.write", "<builtin>.println", "file.close"], "load_env_info": ["Path", "File.exists", "<builtin>.throw", "File.openRead", "file.readToEnd", "ByteArrayStream", "byte_stream.write", "JsonReader", "EnvInfo.fromJson", "file.close"]}, "static_cg": {}}
{"source_code": "package openai_chat\nimport std.console.Console\nimport std.collection.ArrayList\n\nfunc cli_chat(env_info: EnvInfo, stream!: Bool) {\n  println(\"\\n欢迎使用AI聊天机器人，输入exit或者quit退出，输入clear清空历史记录\");\n  var history: ArrayList<(String, String)> = ArrayList<(String, String)>();\n  while (true) {\n    print(\"Input: \");\n    var prompt: String = \"\";\n    match(Console.stdIn.readln()) {\n      case Some(str1: String) => prompt=str1;\n      case None => continue;\n    }\n    if (prompt == \"exit\" || prompt == \"exit()\") {\n      break;\n    }\n    if (prompt == \"clear\") {\n      history.clear();\n      println(\"Output: 已清理历史对话信息。\");\n      continue;\n    }\n    print(\"ChatBox: \")\n    let response_option: Option<String> = if (stream) {\n      stream_chat(prompt, env_info, history);\n    } else {\n      chat(prompt, env_info, history);\n    }\n    match (response_option) {\n      case Some(response: String) => \n        if (stream) {\n           println(\"\") ;\n        } else {\n            println(\"${response}\");\n        }\n        history.append((prompt, response));\n      case None => println(\"遇到错误，即将退出\"); break;\n    }\n  }\n}\n\n\nmain(args: Array<String>): Int64 {\n  let env_info = load_env_info();\n  var stream: Bool = false;\n  if (args.size == 1) {\n    if (args[0] == \"--stream\") {\n      stream = true;\n    } else {\n      println(\"Warning! you can only use `--stream` to use stream for response.\")\n    }\n  }\n  cli_chat(env_info, stream: stream);\n  return 0\n}", "llm_cg": {"main": ["load_env_info", "cli_chat", "<builtin>.println"], "cli_chat": ["<builtin>.println", "<builtin>.print", "Console.stdIn.readln", "<builtin>.continue", "history.clear", "<builtin>.println", "stream_chat", "chat", "history.append"]}, "static_cg": {}}
{"source_code": "struct Node {\n    public Node(var value: Rune,\n        let left!: ?Node = None,\n        let right!: ?Node = None) {}\n\n    public func traverse(): Unit {\n        left?.traverse()\n        print(value)\n        right?.traverse()\n    }\n}\n\nmain() {\n    var tree = Node('A',\n        left: Node('B', left: Node('C', right: Node('D'))),\n        right: Node('E', left: Node('F'), right: Node('G')))\n    tree.traverse()\n}\n", "llm_cg": {"main": ["Node", "Node.traverse"], "Node": [], "Node.traverse": ["Node.traverse", "<builtin>.print"]}, "static_cg": {}}
{"source_code": "enum Tree {\n    Empty | Leaf(Int64) | Node(Int64, Tree, Tree)\n\n    public func traverse(): Unit {\n        match (this) {\n            case Empty => ()\n            case Leaf(value) => print(value)\n            case Node(value, left, right) =>\n                left.traverse()\n                print(value)\n                right.traverse()\n        }\n    }\n\n    static public func generate(depth: UInt8): Tree {\n        if (depth == 1) {\n            return Leaf(1)\n        }\n        return Node(Int64(depth),\n            generate(depth - 1), generate(depth - 1))\n    }\n}\n\nmain() {\n    let tree = Node(1,\n        Node(2, Node(3, Empty, Leaf(4)), Empty),\n        Node(5, Leaf(6), Leaf(7)))\n    tree.traverse()\n\n    println()\n    let fullTree = Tree.generate(5)\n    fullTree.traverse()\n}", "llm_cg": {"main": ["Node", "tree.traverse", "<builtin>.println", "Tree.generate", "fullTree.traverse"], "Tree.traverse": ["<builtin>.print", "left.traverse", "right.traverse"], "Tree.generate": ["Leaf", "Int64", "Node", "Tree.generate", "Tree.generate"]}, "static_cg": {}}
{"source_code": "open class NodeA {\n    public NodeA(protected var value: Rune,\n        protected let left!: ?NodeA = None,\n        protected let right!: ?NodeA = None) {}\n\n    public open func traverse(): Unit {\n        left?.traverse()\n        print(value)\n        right?.traverse()\n    }\n}\n\nclass NodeB <: NodeA {\n    public init(value: Rune,\n        left!: ?NodeA = None, right!: ?NodeA = None) {\n        super(value, left: left, right: right)\n    }\n\n    public func traverse(): Unit {\n        print(value)\n        left?.traverse()\n        right?.traverse()\n    }\n}\n\nmain() {\n    var tree = NodeA('A',\n        left: NodeA('B', left: NodeA('C', right: NodeA('D'))),\n        right: NodeB('E', left: NodeB('F'), right: NodeB('G')))\n    tree.traverse()\n}\n", "llm_cg": {"main": ["NodeA", "NodeB", "NodeA.traverse"], "NodeA": [], "NodeA.traverse": ["NodeA.traverse", "<builtin>.print", "NodeA.traverse"], "NodeB": ["NodeA"], "NodeB.traverse": ["<builtin>.print", "NodeA.traverse", "NodeA.traverse"]}, "static_cg": {}}
{"source_code": "class Node {\n    private var value: Int64 = 0\n    public Node(private var name: Rune,\n        private let left!: ?Node = None,\n        private let right!: ?Node = None) {}\n\n    public mut prop param: Int64 {\n        set(number) {\n            value = number\n            println(\"${name}: ${value}\")\n            left?.param = number / 2\n            right?.param = number / 2\n        }\n        get() { value }\n    }\n}\n\nmain() {\n    var tree = Node('A',\n        left: Node('B', left: Node('C', right: Node('D'))),\n        right: Node('E', left: Node('F'), right: Node('G')))\n    println(tree.param)\n    tree.param = 128\n}", "llm_cg": {"main": ["<builtin>.println", "Node"], "Node": [], "Node.param.set": ["<builtin>.println"], "Node.param.get": []}, "static_cg": {}}
{"source_code": "func node(value: Rune,\n    left!: () -> Unit = {=>}, right!: () -> Unit = {=>}) {\n    return { =>\n        left()\n        print(value)\n        right()\n    }\n}\n\nmain() {\n    let tree = node('A',\n        left: node('B', left: node('C', right: node('D'))),\n        right: node('E', left: node('F'), right: node('G')))\n    tree()\n}\n", "llm_cg": {"main": ["node"], "node": ["<builtin>.print"]}, "static_cg": {}}
{"source_code": "// 基于 class 实现二叉树\n// cjc version: 0.53.13\nopen class NodeA {\n    public NodeA(protected var value: Rune,\n        protected let left!: ?NodeA = None,\n        protected let right!: ?NodeA = None) {}\n\n    public open func traverse(): Unit {\n        left?.traverse()\n        print(value)\n        right?.traverse()\n    }\n}\n\nclass NodeB <: NodeA {\n    public init(value: Rune,\n        left!: ?NodeA = None, right!: ?NodeA = None) {\n        super(value, left: left, right: right)\n    }\n\n    public func traverse(): Unit {\n        print(value)\n        left?.traverse()\n        right?.traverse()\n    }\n}\n\nmain() {\n    var tree = NodeA(r'A',\n        left: NodeA(r'B', left: NodeA(r'C', right: NodeA(r'D'))),\n        right: NodeB(r'E', left: NodeB(r'F'), right: NodeB(r'G')))\n    tree.traverse()\n}\n", "llm_cg": {"main": ["NodeA", "NodeA.traverse", "NodeB"], "NodeA": ["<builtin>.print", "NodeA.traverse"], "NodeA.traverse": ["<builtin>.print", "NodeA.traverse"], "NodeB": ["NodeA", "<builtin>.print", "NodeA.traverse"], "NodeB.traverse": ["<builtin>.print", "NodeA.traverse"]}, "static_cg": {}}
{"source_code": "// 基于 enum 和模式匹配实现算术表达式表示和计算\n// cjc version: 0.53.13\nenum Expr {\n    Num(Float64) |\n    Add(Expr, Expr) | Sub(Expr, Expr) | Mul(Expr, Expr) | Div(Expr, Expr)\n\n    public func calc(): Float64 {\n        match(this) {\n            case Num(number) => number\n            case Add(a, b) => a.calc() + b.calc()\n            case Sub(a, b) => a.calc() - b.calc()\n            case Mul(a, b) => a.calc() * b.calc()\n            case Div(a, b) => a.calc() / b.calc()\n        }\n    }\n\n    public operator func +(that: Expr): Expr {\n        return Add(this, that)\n    }\n    public operator func -(that: Expr): Expr {\n        return Sub(this, that)\n    }\n    public operator func *(that: Expr): Expr {\n        return Mul(this, that)\n    }\n    public operator func /(that: Expr): Expr {\n        return Div(this, that)\n    }\n}\n\nmain() {\n    let expr = Num(1.2) + Num(3.4) * Num(2.0) - Num(1.0) / Num(2.0)\n    println(expr.calc())\n}", "llm_cg": {"main": ["Num", "Expr.+", "Expr.*", "Expr.-", "Expr./", "Expr.calc", "<builtin>.println"], "Expr.calc": ["Expr.calc", "Expr.calc", "Expr.calc", "Expr.calc"], "Expr.+": ["Add"], "Expr.-": ["Sub"], "Expr.*": ["Mul"], "Expr./": ["Div"]}, "static_cg": {}}
{"source_code": "// 使用 for-in 循环计算输出 2024 年各月干支\n// cjc version: 0.53.13\n\nmain() {\n    let metaArray = [r'甲', r'乙', r'丙', r'丁', r'戊',\n        r'己', r'庚', r'辛', r'壬', r'癸']\n    let noumenonArray = [r'寅', r'卯', r'辰', r'巳', r'午', r'未',\n        r'申', r'酉', r'戌', r'亥', r'子', r'丑']\n    let year = 2024\n    // 年份对应的天干索引\n    let metaOfYear = ((year % 10) + 10 - 4) % 10\n    // 此年首月对应的天干索引\n    var index = (2 * metaOfYear + 3) % 10 - 1\n    println(\"农历 2024 年各月干支：\")\n    for (noumenon in noumenonArray) {\n        print(\"${metaArray[index]}${noumenon} \")\n        index = (index + 1) % 10\n    }\n}\n", "llm_cg": {}, "static_cg": {}}
{"source_code": "// 基于仓颉并发机制，在多线程中随机投点估算圆周率的值\n// cjc version: 0.53.13\nimport std.collection.*\nimport std.random.*\nimport std.math.*\n\nconst M = 200000\nconst N = 16\nfunc task(): Int64 {\n    var n: Int64 = 0\n    let random = Random()\n    for (_ in 0..M) {\n        let x = random.nextFloat64()\n        let y = random.nextFloat64()\n        if ((x - 0.5) ** 2 + (y - 0.5) ** 2 < 0.25) {\n            n++\n        }\n    }\n    return n\n}\n\nmain() {\n    let futures = ArrayList<Future<Int64>>()\n    for (_ in 0..N) {\n        let future = spawn { task() }\n        futures.append(future)\n    }\n    var n = 0\n    for (future in futures) {\n        n += future.get()\n    }\n    let pi = Float64(n) / Float64(M * N) * 4.0\n    println(\"π ≈ ${pi}\")\n    println(\"deviation: ${abs(Float64.PI - pi)}\")\n}", "llm_cg": {"main": ["<builtin>.ArrayList", "task", "<builtin>.println", "abs", "Float64"], "task": ["Random"]}, "static_cg": {}}
{"source_code": "// 基于数组构造 DFA 状态表，解析出一个字符串中的所有整数和小数\n// cjc version: 0.53.13\nimport std.collection.* \n\nclass Parser {\n    static let states = Array(5, {_ => Array(128, item: 0)})\n    static init() {\n        states[0][45..58] = [1, 2, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3] // INIT\n        states[1][45..58] = [0, 2, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3] // -\n        states[2][45..58] = [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4] // . | -. | N. | -N.\n        states[3][45..58] = [0, 2, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3] // N or -N\n        states[4][45..58] = [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4] // ACCEPT\n    }\n\n    static public func parse(text: String) {\n        var i = 0\n        while (i < text.size) {\n            var s = 0\n            while (i < text.size && states[s][Int64(text[i])] == 0) {\n                i++\n            }\n            let j = i\n            while (i < text.size && states[s][Int64(text[i])] != 0) {\n                s = states[s][Int64(text[i])]\n                i++\n            }\n            if (s == 3 || s == 4) {\n                print(text[j..i] + ' ')\n            }\n        }\n        println()\n    } \n}\n\nmain() {\n    Parser.parse(\"1 2 3 456 789\")\n    Parser.parse(\"1ab2c3\")\n    Parser.parse(\"apple 30 banana 45\")\n    Parser.parse(\"1.2 3.4\")\n    Parser.parse(\"9- -3 -2\")\n    Parser.parse(\"3-2\")\n    Parser.parse(\"1 2 3-2\")\n    Parser.parse(\"xxx-3.14. .56-238jk12\")\n}", "llm_cg": {"main": ["Parser.parse"], "Parser": [], "Parser.parse": ["<builtin>.print", "<builtin>.println"]}, "static_cg": {}}
{"source_code": "// 基于 struct 实现二叉树\n// cjc version: 0.53.13\nstruct Node {\n    public Node(var value: Rune,\n        let left!: ?Node = None,\n        let right!: ?Node = None) {}\n\n    public func traverse(): Unit {\n        left?.traverse()\n        print(value)\n        right?.traverse()\n    }\n}\n\nmain() {\n    var tree = Node(r'A',\n        left: Node(r'B', left: Node(r'C', right: Node(r'D'))),\n        right: Node(r'E', left: Node(r'F'), right: Node(r'G')))\n    tree.traverse()\n}\n", "llm_cg": {"main": ["Node", "Node.traverse"], "Node": ["<builtin>.print"], "Node.traverse": ["Node.traverse", "<builtin>.print", "Node.traverse"]}, "static_cg": {}}
{"source_code": "// 为已有类型扩展成员函数\n// cjc version: 0.53.13\nextend String {\n    operator func >>(n: Int64): String {\n        if (n <= 0) {\n            return this.clone()\n        }\n        let size = this.size\n        let offset = size - n % size\n        this[offset..size] + this[0..offset]\n    }\n}\n\nmain() {\n    let text = \"Cangjie2024\"\n    println(text >> 2 >> 2)\n}", "llm_cg": {"main": ["<builtin>.println"], "String.operator>>": ["<builtin>.clone"]}, "static_cg": {}}
{"source_code": "// 从字符串解析整数，演示基于 Option 的异常处理\n// cjc version: 0.53.13\nfunc parseInt(text: String): Option<Int64> {\n    if (text.isEmpty() || text == \"-\") {\n        return None\n    }\n    var sign = if (text[0] == 45u8) { 1 } else { 0 }\n    var sum = 0\n    for (i in sign..text.size) {\n        if (text[i] > 57u8 || text[i] < 48u8) {\n            return None\n        }\n        let digit = Int64(text[i] - 48u8)\n        sum = 10 * sum + digit\n    }\n    return if (sign == 1) { -sum } else { sum }\n}\n\nmain() {\n    let number = parseInt(\"-123456\")\n    println(number.getOrThrow())\n    let result = parseInt(\"123-456\")\n    if (result.isNone()) {\n        println(\"parse failed\")\n    }\n}", "llm_cg": {"main": ["parseInt", "<builtin>.println"], "parseInt": []}, "static_cg": {}}
{"source_code": "// 用给定的分隔符拆分字符串，支持多分隔符，演示常规编码实现和函数式编程实现\nimport std.collection.*\n\n// 常规实现\nfunc split_normal(text: String, sep: String): ArrayList<String> {\n    let indices = ArrayList<Int64>()\n    var last = true\n    for (i in 0..text.size) {\n        let current = sep.indexOf(text[i]).isSome()\n        if (last != current) {\n            indices.append(i)\n        }\n        last = current\n    }\n    if (!last) { indices.append(text.size) }\n\n    let result = ArrayList<String>()\n    for (i in 0..indices.size:2) {\n        result.append(text[indices[i]..indices[i + 1]])\n    }\n    return result\n}\n\n// 函数式编程实现\nfunc split(text: String, sep: String): ArrayList<String> {\n    let indices = ArrayList<Int64>()\n    text |> enumerate |> fold(false) { state, e =>\n        let current = sep.indexOf(e[1]).isNone()\n        if (state != current) { indices.append(e[0]) }\n        current\n    } |> { valid: Bool => if (valid) {\n        indices.append(text.size)\n    }}\n\n    let result = ArrayList<String>()\n    for (i in 0..indices.size:2) {\n        result.append(text[indices[i]..indices[i + 1]])\n    }\n    return result\n}\n\nmain() {\n    let text = \"123, 456 7&89, , 96^3, 567\"\n    let separator = \"&^, \"\n    println(split_normal(text, separator))\n    println(split(text, separator))\n}", "llm_cg": {"main": ["println", "split_normal", "split"], "split_normal": ["ArrayList", "sep.indexOf", "last.isSome", "indices.append", "result.append"], "split": ["ArrayList", "enumerate", "text|>enumerate|>fold", "sep.indexOf", "e[1].isNone", "indices.append", "result.append"]}, "static_cg": {}}
{"source_code": "// 调用 C 标准库中的 rand 和 printf 函数\n// cjc version: 0.53.13\nforeign func rand(): Int32\nforeign func printf(fmt: CString, ...): Int32\n\nunsafe main() {\n    let text = LibC.mallocCString(\"random number: %d\\n\")\n    for (_ in 0..5) {\n        printf(text, rand()) \n    }\n    LibC.free(text)\n}", "llm_cg": {"main": ["LibC.mallocCString", "rand", "printf", "LibC.free"]}, "static_cg": {}}
{"source_code": "// 基于 enum 实现二叉树\n// cjc version: 0.53.13\nenum Tree {\n    Empty | Leaf(Int64) | Node(Int64, Tree, Tree)\n\n    public func traverse(): Unit {\n        match (this) {\n            case Empty => ()\n            case Leaf(value) => print(value)\n            case Node(value, left, right) =>\n                left.traverse()\n                print(value)\n                right.traverse()\n        }\n    }\n\n    static public func generate(depth: UInt8): Tree {\n        if (depth == 1) {\n            return Leaf(1)\n        }\n        return Node(Int64(depth),\n            generate(depth - 1), generate(depth - 1))\n    }\n}\n\nmain() {\n    let tree = Node(1,\n        Node(2, Node(3, Empty, Leaf(4)), Empty),\n        Node(5, Leaf(6), Leaf(7)))\n    tree.traverse()\n\n    println()\n    let fullTree = Tree.generate(5)\n    fullTree.traverse()\n}", "llm_cg": {"main": ["Node", "Node.traverse", "println", "Tree.generate", "Tree.traverse"], "Tree.traverse": ["<builtin>.print", "Tree.traverse"], "Tree.generate": ["Leaf", "Node", "Tree.generate"]}, "static_cg": {}}
{"source_code": "// 一元函数迭代产生伪随机数，演示 lambda 特性\n// cjc version: 0.53.13\nfunc iter(n: Int64, x0: Float64, f: (Float64) -> Float64) {\n    var x = x0\n    for (_ in 0..n) {\n        print(\"${x}, \")\n        x = f(x)\n    }\n    println(\"${x}\")\n}\n\nmain() {\n    iter(5, 0.8, { x: Float64 => 1.0 / (1.0 - x)})\n    iter(10, 0.8, { x: Float64 =>\n        4.0 * x * (1.0 - x)\n    })\n}", "llm_cg": {}, "static_cg": {}}
{"source_code": "// 基于蒙特卡洛算法估算圆周率\n// 涉及特性：常量，变量，可变性，类型转换，幂运算符\n// cjc version: 0.53.13\nimport std.random.*\nimport std.math.*\n\nmain() {\n    // 常量定义是为编译期数据命名，可用于常量表达式中\n    const N = 100000u32\n    // 变量定义是为运行时数据存储单元命名，以便后续程序引用\n    // 如果需要对这份存储单元进行读/写，可使用 var 定义可变变量\n    var n: UInt32 = 0 // 可以显式指定变量的类型\n    let random = Random() // 如果省略类型标注，则以初值表达式的类型确定变量类型\n    for (_ in 0..N) {\n        // 如果对这份存储单元只读不写，可使用 let 定义不可变变量\n        let x = random.nextFloat64()\n        // 不可变变量的初值在运行时确定，这是它和常量的最大区别\n        let y = random.nextFloat64()\n        // 读取不可变变量的值\n        if ((x - 0.5) ** 2 + (y - 0.5) ** 2 < 0.25) {\n            n++ // 修改可变变量的值\n        }\n    }\n    let pi = Float64(n) / Float64(N) * 4.0\n    println(\"π ≈ ${pi}\")\n    println(\"deviation: ${abs(Float64.PI - pi)}\")\n}", "llm_cg": {"main": ["Random", "random.nextFloat64", "<builtin>.println", "abs", "Float64.PI"]}, "static_cg": {}}
{"source_code": "// 基于函数实现二叉树，演示仓颉函数的 first class 及闭包特性\n// cjc version: 0.53.13\nfunc node(value: Rune,\n    left!: () -> Unit = {=>}, right!: () -> Unit = {=>}) {\n    return { =>\n        left()\n        print(value)\n        right()\n    }\n}\n\nmain() {\n    let tree = node(r'A',\n        left: node(r'B', left: node(r'C', right: node(r'D'))),\n        right: node(r'E', left: node(r'F'), right: node(r'G')))\n    tree()\n}\n", "llm_cg": {"main": ["node", "<builtin>.print"], "node": ["<builtin>.print"]}, "static_cg": {}}
{"source_code": "// 基于 class 实现二叉树，基于 prop 特性实现各节点参数同步更新\n// cjc version: 0.53.13\nclass Node {\n    private var value: Int64 = 0\n    public Node(private var name: Rune,\n        private let left!: ?Node = None,\n        private let right!: ?Node = None) {}\n\n    public mut prop param: Int64 {\n        set(number) {\n            value = number\n            println(\"${name}: ${value}\")\n            left?.param = number / 2\n            right?.param = number / 2\n        }\n        get() { value }\n    }\n}\n\nmain() {\n    var tree = Node(r'A',\n        left: Node(r'B', left: Node(r'C', right: Node(r'D'))),\n        right: Node(r'E', left: Node(r'F'), right: Node(r'G')))\n    println(tree.param)\n    tree.param = 128\n}", "llm_cg": {}, "static_cg": {}}
{"source_code": "// 基于 struct 和泛型实现二叉树\n// cjc version: 0.53.13\nstruct Node<T> where T <: ToString {\n    public Node(var value: T,\n        let left!: ?Node<T> = None,\n        let right!: ?Node<T> = None) {}\n\n    public func traverse(): Unit {\n        left?.traverse()\n        print(value)\n        right?.traverse()\n    }\n\n    public mut func set(value: T) {\n        this.value = value\n    }\n}\n\nmain() {\n    var tree1 = Node(r'X',\n        left: Node(r'B', left: Node(r'C', right: Node(r'D'))),\n        right: Node(r'E', left: Node(r'F'), right: Node(r'G')))\n    tree1.set(r'A')\n    tree1.traverse()\n\n    println()\n    var tree2 = Node(0,\n        left: Node(2, left: Node(3, right: Node(4))),\n        right: Node(5, left: Node(6), right: Node(7)))\n    tree2.set(1)\n    tree2.traverse()\n}\n", "llm_cg": {"main": ["Node", "Node.set", "Node.traverse", "<builtin>.println"], "Node": [], "Node.traverse": ["Node.traverse", "<builtin>.print"], "Node.set": []}, "static_cg": {}}
{"source_code": "macro package enum_enhance\n\nimport std.ast.*\nimport std.collection.*\n\npublic macro ToStringEnum(input: Tokens): Tokens {\n    let enumm = EnumDecl(input)\n    // match表达式\n    var matchExprs = Array<MatchExpr>(2, { _ => MatchExpr()})\n    for (expr in matchExprs) {\n        expr.selector = RefExpr(quote(this))\n        expr.lParen = Token(TokenKind.LPAREN)\n        expr.rParen = Token(TokenKind.RPAREN)\n    }\n    // 构造case\n    let matchCaseSet = Array<ArrayList<MatchCase>>(2, {_ => ArrayList<MatchCase>()})\n    for (constr in enumm.constructors) {\n        let matchCases = Array<MatchCase>(2, {_ => MatchCase()}) // 0: case Red => \"Red\" | 1： case Red => \"Enum.Red\"\n        let enumPatt = EnumPattern()\n        let litConstBuilders = Array<StringBuilder>(2, {_ => StringBuilder()})\n        // 添加 \"Enum.\"\n        litConstBuilders[1].append(enumm.identifier.value)\n        litConstBuilders[1].append(r'.')\n\n        litConstBuilders |> forEach{i => i.append(constr.identifier.value)}\n        enumPatt.constructor = parseExpr(constr.identifier.toTokens())\n        // 组装 MatchCase\n        var flag = false\n        let constrArgSize = constr.typeArguments.size\n        for (item in constr.typeArguments |> enumerate) {\n            if (!flag) {\n                litConstBuilders |> forEach{i => i.append(r\"(\")}\n                flag = true\n            }\n            let id = Token(TokenKind.IDENTIFIER, \"v\" + item[0].toString())\n            enumPatt.patterns.append(TypePattern(quote($id: $(item[1]))))\n\n            litConstBuilders[0].append(\"\\${${id.toTokens()}.toString()}\")\n            match (item[1]) {\n                case r: RefType where r.identifier.value == enumm.identifier.value =>\n                litConstBuilders[1].append(\"\\${${id.toTokens()}.toString(true)}\")\n                case p: TypeNode => \n                litConstBuilders[1].append(\"\\${${id.toTokens()}.toString()}\")\n            }\n\n            if (item[0] != constrArgSize - 1) {\n                litConstBuilders |> forEach{i => i.append(\", \")}\n            }\n        }\n        if (flag) {\n            litConstBuilders |> forEach{i => i.append(r')')}\n        }\n        for (((mat, lit), set) in matchCases |> zip(litConstBuilders) |> zip(matchCaseSet)) {\n            mat.patterns.append(enumPatt)\n            mat.block.nodes.append(LitConstExpr(quote($(lit.toString()))))\n            set.append(mat)\n        }\n    }\n    for ((expr, set) in matchExprs |> zip(matchCaseSet)) {\n        set |> forEach{i => expr.matchCases.append(i)}\n    }\n    // toString(): String函数\n    let block = Block()\n    block.nodes.append(matchExprs[0])\n    let toString = FuncDecl(quote(\n        public func toString(): String {\n            $block\n        }))\n    // toString(b: Bool): String函数\n    let block1 = Block()\n    block1.nodes.append(matchExprs[1])\n    let toStringBool = FuncDecl(quote(\n        public func toString(b: Bool): String {\n            if (b) {\n                $block1\n            } else {\n                this.toString()\n            }\n        }))\n    // 将函数加入枚举\n    let funcs = ArrayList<String>()\n    for (decl in enumm.decls) {\n        match (decl) {\n            // case d: FuncDecl => funcSet.put(d.identifier.toTokens().toString())\n            case d: FuncDecl => funcs.append(d.identifier.value)\n            case _ => ()\n        }\n    }\n    if (!funcs.contains(\"toString\")) {\n        enumm.decls.append(toString)\n        enumm.decls.append(toStringBool)\n    }\n    // 继承接口\n    let intfs = ArrayList<String>()\n    for (i in enumm.superTypes) {\n        match (i) {\n            case r: RefType => intfs.append(r.toTokens().toString())\n            case r: TypeNode => ()\n        }\n    }\n    if (!intfs.contains(\"ToString\")) {\n        enumm.superTypes.append(RefType(quote(ToString)))\n    }\n\n    enumm.toTokens()\n}", "llm_cg": {"ToStringEnum": ["<builtin>.Array", "<builtin>.forEach", "<builtin>.ArrayList", "RefExpr", "quote", "Token", "EnumPattern", "StringBuilder", "parseExpr", "<builtin>.enumerate", "TokenKind.LPAREN", "TokenKind.RPAREN", "TokenKind.IDENTIFIER", "TypePattern", "LitConstExpr", "Block", "FuncDecl", "this.toString", "RefType", "quote", "LitConstExpr", "matchCases.append", "LitConstExpr", "enumm.toTokens", "Array", "matchCaseSet.append", "ArrayList", "ArrayList.append", "ArrayList.contains", "quote", "RefType", "quote"]}, "static_cg": {}}
{"source_code": "macro package enum_enhance\n\nimport std.ast.*\nimport std.collection.{ArrayList, enumerate, filter, all}\n\npublic macro EquatableEnum(input: Tokens): Tokens {\n    let enumm = EnumDecl(input)\n    // match表达式\n    let hashMatchExpr = MatchExpr()\n    hashMatchExpr.selector = RefExpr(quote(this))\n    hashMatchExpr.lParen = Token(TokenKind.LPAREN)\n    hashMatchExpr.rParen = Token(TokenKind.RPAREN)\n    // 基础类型无嵌套参数构造器\n    let noNestedPrimConstr = enumm.constructors |>\n        filter {\n        i: Constructor => i.typeArguments |>\n            all {\n            i: TypeNode => match (i) {\n                case a: PrimitiveType => true\n                case _ => throw ASTException(\"All args of Constructor shall be primitive type\")\n            }\n        }\n    }\n    // 构造case\n    let noNestedPrimCases = ArrayList<MatchCase>()\n    var hashIndex = 0i64\n    for (constr in noNestedPrimConstr) {\n        let matchCase = MatchCase()\n        let blockNodes = matchCase.block.nodes\n        let enumPatt = EnumPattern()\n\n        blockNodes.append(VarDecl(quote(var hasher = DefaultHasher(res: $(hashIndex)))))\n        enumPatt.constructor = parseExpr(constr.identifier.toTokens())\n\n        for (item in constr.typeArguments |> enumerate) {\n            let id = Token(TokenKind.IDENTIFIER, \"v\" + item[0].toString())\n            enumPatt.patterns.append(TypePattern(quote($(id): $(item[1]))))\n            blockNodes.append(CallExpr(quote(hasher.write($(id)))))\n        }\n        blockNodes.append(CallExpr(quote(hasher.finish())))\n\n        matchCase.patterns.append(enumPatt)\n        noNestedPrimCases.append(matchCase)\n        hashIndex++\n    }\n    noNestedPrimCases.iterator().forEach {i => hashMatchExpr.matchCases.append(i)}\n    // hashCode函数\n    let block = Block()\n    block.nodes.append(hashMatchExpr)\n    let hashCode = FuncDecl(\n        quote(\n            \n        public func hashCode(): Int64 {\n            $block\n        }))\n    // == 函数\n    let equal = FuncDecl(\n        quote(\n        public operator func ==(that: $(enumm.identifier)): Bool {\n            this.hashCode() == that.hashCode()\n        })\n    )\n    // != 函数\n    let notEqual = FuncDecl(\n        quote(\n        public operator func !=(that: $(enumm.identifier)): Bool {\n            this.hashCode() != that.hashCode()\n        })\n    )\n    // 将函数加入枚举\n    let funcs = ArrayList<String>()\n    for (decl in enumm.decls) {\n        match (decl) {\n            // case d: FuncDecl => funcSet.put(d.identifier.toTokens().toString())\n            case d: FuncDecl => funcs.append(d.identifier.value)\n            case _ => ()\n        }\n    }\n    if (!funcs.contains(\"hashCode\")) {\n        enumm.decls.append(hashCode)\n    }\n    if (!funcs.contains(\"==\")) {\n        enumm.decls.append(equal)\n    }\n    if (!funcs.contains(\"!=\")) {\n        enumm.decls.append(notEqual)\n    }\n    // 继承接口\n    let intfs = ArrayList<String>()\n    for (i in enumm.superTypes) {\n        match (i) {\n            case r: RefType => intfs.append(r.toTokens().toString())\n            case r: TypeNode => ()\n        }\n    }\n    if (!intfs.contains(\"Hashable\")) {\n        enumm.superTypes.append(RefType(quote(Hashable)))\n    }\n    if (!intfs.contains(\"Equatable\")) {\n        enumm.superTypes.append(RefType(quote(Equatable<$(enumm.identifier)>)))\n    }\n\n    enumm.toTokens()\n}\n", "llm_cg": {"EquatableEnum": ["EnumDecl", "MatchExpr", "RefExpr", "Token", "TokenKind.LPAREN", "TokenKind.RPAREN", "all", "Constructor.typeArguments", "PrimitiveType", "ASTException", "ArrayList", "MatchCase", "VarDecl", "quote", "DefaultHasher", "parseExpr", "enumerate", "TokenKind.IDENTIFIER", "TypePattern", "CallExpr", "MethodWrite", "MethodFinish", "MethodAppend", "MethodConstructorPatternsAppend", "MethodNodesAppend", "Block", "FuncDecl", "FuncDeclConstructor", "MethodDeclsAppend", "FuncDecl", "FuncDeclConstructor", "FuncDecl", "FuncDeclConstructor", "ArrayList", "forEach", "FuncDeclIdentifierValue", "MethodSuperTypesAppend", "RefType", "RefType", "enummToTokens"]}, "static_cg": {}}
{"source_code": "package enum_enhance.test\n\n// import std.unittest.testmacro.*\n// import std.unittest.*\nimport enum_enhance.{ToStringEnum, EquatableEnum}\n\n@ToStringEnum\npublic enum Color2 {\n    | Red\n    | Green(Bool)\n    | Blue(Rune)\n    | RGBA(UInt8, UInt8, UInt8, Color2)\n}\n\n\n\n@Test\nclass ToStringEnumTest {\n    @TestCase\n    func noArgTest(): Unit {\n        let red = Color2.Red\n        @Expect(red.toString(true), 'Color2.Red')\n        @Expect(red.toString(), 'Red')\n    }\n\n    @TestCase\n    func runeTest(): Unit {\n        let blue1 = Color2.Blue(r'\\\\')\n        let blue2 = Color2.Blue(r'$')\n        @Expect(blue1.toString(true), 'Color2.Blue(\\\\)')\n        @Expect(blue2.toString(true), 'Color2.Blue($)')\n        @Expect(blue1.toString(), 'Blue(\\\\)')\n        @Expect(blue2.toString(), 'Blue($)')\n    }\n\n    @TestCase\n    func noNestedPrimTest(): Unit {\n        let green1 = Color2.Green(false)\n        let green2 = Color2.Green(true)\n        @Expect(green1.toString(true), 'Color2.Green(false)')\n        @Expect(green2.toString(true), 'Color2.Green(true)')\n        @Expect(green1.toString(), 'Green(false)')\n        @Expect(green2.toString(), 'Green(true)')\n    }\n\n    @TestCase\n    func NestedTest(): Unit {\n        let rgba1 = Color2.RGBA(23, 54, 67, Color2.Red)\n        let rgba2 = Color2.RGBA(2, 4, 6, Green(true))\n        let rgba3 = Color2.RGBA(9, 3, 12, rgba2)\n        @Expect(rgba1.toString(true), 'Color2.RGBA(23, 54, 67, Color2.Red)')\n        @Expect(rgba2.toString(true), 'Color2.RGBA(2, 4, 6, Color2.Green(true))')\n        @Expect(rgba3.toString(true), 'Color2.RGBA(9, 3, 12, Color2.RGBA(2, 4, 6, Color2.Green(true)))')\n        @Expect(rgba1.toString(), 'RGBA(23, 54, 67, Red)')\n        @Expect(rgba2.toString(), 'RGBA(2, 4, 6, Green(true))')\n        @Expect(rgba3.toString(), 'RGBA(9, 3, 12, RGBA(2, 4, 6, Green(true)))')\n    }\n}\n", "llm_cg": {"main": [], "ToStringEnumTest": [], "ToStringEnumTest.noArgTest": [], "ToStringEnumTest.runeTest": [], "ToStringEnumTest.noNestedPrimTest": [], "ToStringEnumTest.NestedTest": []}, "static_cg": {}}
{"source_code": "package enum_enhance.test\n\n// import std.unittest.testmacro.*\n// import std.unittest.*\nimport enum_enhance.{EquatableEnum, ToStringEnum}\n\n@EquatableEnum\npublic enum EquatableColor {\n    | Red\n    | Yellow\n    | Green(Bool)\n    | Orange(Bool)\n    | Blue(Rune)\n    | Pink(Rune)\n    | YCbCr(UInt8, Int32, Float64)\n    | RGBA(Rune, Int32, Bool)\n}\n\n@Test\nclass EqutableEnumTest {\n    @TestCase\n    func noArgTest(): Unit {\n        let red1 = EquatableColor.Red\n        let red2 = EquatableColor.Red\n        let yellow = EquatableColor.Yellow\n\n        @Expect(red1 == red2)\n        @Expect(red1 != yellow)\n    }\n\n    @TestCase\n    func boolTest(): Unit {\n        let green1 = EquatableColor.Green(true)\n        let green2 = EquatableColor.Green(true)\n        let green3 = EquatableColor.Green(false)\n        let orange1 = EquatableColor.Orange(true)\n        let orange2 = EquatableColor.Orange(false)\n\n        @Expect(green1 == green2)\n        @Expect(green1 != green3)\n        @Expect(green1 != orange1)\n        @Expect(green1 != orange2)\n        @Expect(green3 != orange1)\n        @Expect(green3 != orange2)\n        @Expect(orange1 != orange2)\n    }\n\n    @TestCase\n    func runeTest(): Unit {\n        let blue1 = EquatableColor.Blue(r\"A\")\n        let blue2 = EquatableColor.Blue(r\"A\")\n        let blue3 = EquatableColor.Blue(r\"B\")\n        let blue4 = EquatableColor.Blue(r\"\\\\\")\n        let pink1 = EquatableColor.Pink(r\"A\")\n        let pink2 = EquatableColor.Pink(r\"B\")\n        let pink3 = EquatableColor.Pink(r\"\\\\\")\n        \n        @Expect(blue1 == blue2)\n        @Expect(blue1 != blue3)\n        @Expect(blue1 != pink1)\n        @Expect(blue1 != pink2)\n        @Expect(blue1 != blue4)\n        @Expect(blue3 != pink1)\n        @Expect(blue3 != pink2)\n        @Expect(blue4 != pink3)\n        @Expect(pink1 != pink2)\n        @Expect(pink1 != blue4)\n        @Expect(pink3 != blue4)\n    }\n\n    @TestCase\n    func nultiArgTest(): Unit {\n        let ycbcr1 = EquatableColor.YCbCr(255, 1024, 0.5)\n        let ycbcr2 = EquatableColor.YCbCr(255, 1024, 0.5)\n        let ycbcr3 = EquatableColor.YCbCr(128, 2048, 0.75)\n        \n        let rgba1 = EquatableColor.RGBA(r\"A\", 1024, true)\n        let rgba2 = EquatableColor.RGBA(r\"A\", 1024, true)\n        let rgba3 = EquatableColor.RGBA(r\"B\", 2048, false)\n        let rgba4 = EquatableColor.RGBA(r\"A\", 2048, true)\n        \n        @Expect(ycbcr1 == ycbcr2)\n        @Expect(ycbcr1 != ycbcr3)\n        @Expect(ycbcr1 != rgba1)\n        @Expect(ycbcr1 != rgba3)\n        \n        @Expect(rgba1 == rgba2)\n        @Expect(rgba1 != rgba3)\n        @Expect(rgba1 != rgba4)\n        @Expect(rgba1 != ycbcr1)\n    }\n}\n", "llm_cg": {"main": [], "EquatableColor": [], "EqutableEnumTest": [], "EqutableEnumTest.noArgTest": ["EquatableColor.Red", "EquatableColor.Yellow", "Expect"], "EqutableEnumTest.boolTest": ["EquatableColor.Green", "EquatableColor.Orange", "Expect"], "EqutableEnumTest.runeTest": ["EquatableColor.Blue", "EquatableColor.Pink", "Expect"], "EqutableEnumTest.nultiArgTest": ["EquatableColor.YCbCr", "EquatableColor.RGBA", "Expect"]}, "static_cg": {}}
{"source_code": "package csv4cj\npublic class CSVOutFormat {\n    // Header title\n    private var header: Array<String>\n    // array of header column names\n    private var headerComments: Array<String>\n    // Annotation symbols\n    private var commentMarker: Rune\n    // Separator\n    private var delimiter: String\n    // Separator\n    private var delimiterRune: Array<Rune>\n    // Escape character\n    private var escapeCharacter: Rune\n    // Reference symbol\n    private var quoteCharacter: Rune\n    // Record split string\n    private var recordSeparator: String\n    // Ignore records without values\n    private var ignoreEmptyRecord: Bool\n    // Whether to remove white space characters outside the content\n    private var trim: Bool\n    // Add column ordinal for reference symbol\n    private var quotedColsIndex: Array<Int64>\n    // Reference mode of output content\n    private var quoteMode: QuoteMode\n    public static prop DEFAULT: CSVOutFormat {\n        get() {\n            CSVOutFormat(\n                Constants.COMMA_STRING,\n                Constants.DOUBLE_QUOTE_CHAR,\n                QuoteMode.SpecialValue,\n                [],\n                Constants.COMMENT_CHAR,\n                Constants.BACKSLASH,\n                true,\n                true,\n                Constants.CRLF,\n                [],\n                []\n            )\n        }\n    }\n    CSVOutFormat(\n        delimiter: String,\n        quoteChar: Rune,\n        quoteMode: QuoteMode,\n        quotedColsIndex: Array<Int64>,\n        commentStart: Rune,\n        escape: Rune,\n        trim: Bool,\n        ignoreEmptyRecord: Bool,\n        recordSeparator: String,\n        header: Array<String>,\n        headerComments: Array<String>\n    ) {\n        this.delimiter = delimiter\n        this.delimiterRune = delimiter.toRuneArray()\n        this.quoteCharacter = quoteChar\n        this.quoteMode = quoteMode\n        this.quotedColsIndex = quotedColsIndex\n        this.trim = trim\n        this.ignoreEmptyRecord = ignoreEmptyRecord\n        this.recordSeparator = recordSeparator\n        this.commentMarker = commentStart\n        this.escapeCharacter = escape\n        this.header = header\n        this.headerComments = headerComments\n    }\n    public func setEscapeCharacter(escapeCharacter: Rune) {\n        this.escapeCharacter = escapeCharacter\n        return this\n    }\n    public func getEscapeCharacter(): Rune {\n        return escapeCharacter\n    }\n    public func setHeader(headerList: Array<String>) {\n        this.header = headerList\n        return this\n    }\n    public func getHeader() {\n        return header\n    }\n    public func setIgnoreEmptyRecord(ignoreEmptyRecord: Bool) {\n        this.ignoreEmptyRecord = ignoreEmptyRecord\n        return this\n    }\n    public func getIgnoreEmptyRecord(): Bool {\n        return ignoreEmptyRecord\n    }\n    public func setTrim(trim: Bool) {\n        this.trim = trim\n        return this\n    }\n    public func getTrim(): Bool {\n        return trim\n    }\n    public func setQuoteCharacter(quoteCharacter: Rune) {\n        this.quoteCharacter = quoteCharacter\n        return this\n    }\n    public func getQuoteCharacter(): Rune {\n        return quoteCharacter\n    }\n    public func setQuoteMode(quoteMode: QuoteMode) {\n        this.quoteMode = quoteMode\n        return this\n    }\n    public func getQuoteMode(): QuoteMode {\n        return quoteMode\n    }\n    public func setDelimiter(outdelimiter: String) {\n        this.delimiter = outdelimiter\n        this.delimiterRune = outdelimiter.toRuneArray()\n        return this\n    }\n    public func getDelimiterString(): String {\n        return delimiter\n    }\n    public func getDelimiterRune(): Array<Rune> {\n        return delimiterRune\n    }\n    public func setCommentMarker(outcommentMarker: Rune) {\n        this.commentMarker = outcommentMarker\n        return this\n    }\n    public func getCommentMarker(): Rune {\n        return commentMarker\n    }\n    public func getRecordSeparator() {\n        return recordSeparator\n    }\n    public func setQuotedColsIndex(quotedColsIndex: Array<Int64>) {\n        this.quotedColsIndex = quotedColsIndex\n        return this\n    }\n    public func getQuotedColsIndex() {\n        return quotedColsIndex\n    }\n}\npublic enum QuoteMode {\n    // All columns\n    All |\n    // Configure the specified column\n    CfgCols |\n    // Column values with special characters\n    SpecialValue |\n    // No reference, escape if there are special symbols\n    None\n}", "llm_cg": {"main": [], "CSVOutFormat": ["CSVOutFormat.setEscapeCharacter", "CSVOutFormat.getEscapeCharacter", "CSVOutFormat.setHeader", "CSVOutFormat.getHeader", "CSVOutFormat.setIgnoreEmptyRecord", "CSVOutFormat.getIgnoreEmptyRecord", "CSVOutFormat.setTrim", "CSVOutFormat.getTrim", "CSVOutFormat.setQuoteCharacter", "CSVOutFormat.getQuoteCharacter", "CSVOutFormat.setQuoteMode", "CSVOutFormat.getQuoteMode", "CSVOutFormat.setDelimiter", "CSVOutFormat.getDelimiterString", "CSVOutFormat.getDelimiterRune", "CSVOutFormat.setCommentMarker", "CSVOutFormat.getCommentMarker", "CSVOutFormat.getRecordSeparator", "CSVOutFormat.setQuotedColsIndex", "CSVOutFormat.getQuotedColsIndex", "QuoteMode", "delimiter.toRuneArray", "Constants.COMMA_STRING", "Constants.DOUBLE_QUOTE_CHAR", "Constants.COMMENT_CHAR", "Constants.BACKSLASH", "Constants.CRLF"], "CSVOutFormat.setEscapeCharacter": [], "CSVOutFormat.getEscapeCharacter": [], "CSVOutFormat.setHeader": [], "CSVOutFormat.getHeader": [], "CSVOutFormat.setIgnoreEmptyRecord": [], "CSVOutFormat.getIgnoreEmptyRecord": [], "CSVOutFormat.setTrim": [], "CSVOutFormat.getTrim": [], "CSVOutFormat.setQuoteCharacter": [], "CSVOutFormat.getQuoteCharacter": [], "CSVOutFormat.setQuoteMode": [], "CSVOutFormat.getQuoteMode": [], "CSVOutFormat.setDelimiter": ["outdelimiter.toRuneArray"], "CSVOutFormat.getDelimiterString": [], "CSVOutFormat.getDelimiterRune": [], "CSVOutFormat.setCommentMarker": [], "CSVOutFormat.getCommentMarker": [], "CSVOutFormat.getRecordSeparator": [], "CSVOutFormat.setQuotedColsIndex": [], "CSVOutFormat.getQuotedColsIndex": [], "QuoteMode": []}, "static_cg": {}}
{"source_code": "package rpc4cj.http2.proto\ninternal import std.log.*\nlet initialHeaderTableSize: Int64 = 4096\nlet initEnablePush: Int64 = 0\nlet defaultMaxConcurrentStreams = 100\nlet globalinitialWindowSize: Int64 = 65535 // 6.9.2 Initial Flow Control Window Size\nlet initialMaxFrameSize: Int64 = 16384\nlet initialMaxHeadListSize = 1048896\npublic class H2Config {\n    private var headerTableSize: Int64\n    private var enablePush: Int64\n    private var maxConcurrentStreams: Int64\n    private var initialWindowSize: Int64\n    private var maxFrameSize: Int64\n    private var maxHeaderListSize: Int64\n    public mut prop HEADER_TABLE_SIZE: Int64 {\n        get() {\n            return headerTableSize\n        }\n        set(v) {\n            if (v > 0) {\n                headerTableSize = v\n            } else {\n                throw Exception()\n            }\n        }\n    }\n    public mut prop ENABLE_PUSH: Int64 {\n        get () {\n            return enablePush\n        }\n        set (v) {\n            if (v == 0 || v == 1) {\n                enablePush = v\n            } else {\n                throw ProtocolErrorException(\"Any value other than 0 or 1 must be considered PROTOCOL_ ERROR type connection error (Section 5.4.1).\")  //\n            }\n        }\n    }\n    // The value of 0 is prohibit the creation of new streams\n    public mut prop MAX_CONCURRENT_STREAMS: Int64 {\n        get () {\n            return maxConcurrentStreams\n        }\n        set (v) {\n            if (v >= 0) {\n                maxConcurrentStreams = v\n            } else {\n                throw ProtocolErrorException()\n            }\n        }\n    }\n    public mut prop INITIAL_WINDOW_SIZE: Int64 {\n        get () {\n            return initialWindowSize\n        }\n        set (v) {\n            if (v >= 0 && v <= Int64(Int32.Max)) {\n                initialWindowSize = v\n            } else {\n                throw FlowControlErrorException()\n            }\n        }\n    }\n    public mut prop MAX_FRAME_SIZE: Int64 {\n        get () {\n            return maxFrameSize\n        }\n        set (v) {\n            if (v > 16777215 || v < 16384) {\n                throw ProtocolErrorException(\"The value of the endpoint broadcast must be between this initial value and the maximum allowed frame size (2 ^ 24-1 or 16777215 octets), including both. Values outside this range must be considered PROTOCOL_ ERROR type connection error (Section 5.4.1).\")\n            }\n            maxFrameSize = v\n        }\n    }\n    public mut prop MAX_HEADER_LIST_SIZE: Int64 {\n        get () {\n            return maxHeaderListSize\n        }\n        set (v) {\n            if (v > 0) {\n                maxHeaderListSize = v\n            } else {\n                throw ProtocolErrorException()\n            }\n        }\n    }\n    public init (){\n        this.headerTableSize = initialHeaderTableSize\n        this.enablePush = 1\n        this.maxConcurrentStreams = defaultMaxConcurrentStreams\n        this.initialWindowSize = globalinitialWindowSize\n        this.maxFrameSize = initialMaxFrameSize\n        this.maxHeaderListSize = initialMaxHeadListSize\n    }\n    public init(headerTableSize: Int64, enablePush: Int64, maxConcurrentStreams: Int64, initialWindowSize: Int64, maxFrameSize: Int64, maxHeaderListSize: Int64) {\n        this.headerTableSize = if (headerTableSize > 0) {\n            headerTableSize\n        } else {\n            throw Exception()\n        }\n        this.enablePush = if (enablePush == 0 || enablePush == 1) {\n            enablePush\n        } else {\n            throw ProtocolErrorException(\"Any value other than 0 or 1 must be considered PROTOCOL_ ERROR type connection error (Section 5.4.1).\")  //\n        }\n        this.maxConcurrentStreams = if (maxConcurrentStreams >= 0) {\n            maxConcurrentStreams\n        } else {\n            throw ProtocolErrorException()\n        }\n        this.initialWindowSize = if (initialWindowSize >= 0 && initialWindowSize <= Int64(Int32.Max)) {\n            initialWindowSize\n        } else {\n            throw FlowControlErrorException()\n        }\n        this.maxFrameSize = if (maxFrameSize > 16777215 || maxFrameSize < 16384) {\n            throw ProtocolErrorException(\"The value of the endpoint broadcast must be between this initial value and the maximum allowed frame size (2 ^ 24-1 or 16777215 octets), including both. Values outside this range must be considered PROTOCOL_ ERROR type connection error (Section 5.4.1).\")\n        }else {\n            maxFrameSize\n        }\n        this.maxHeaderListSize = if (maxHeaderListSize > 0) {\n            maxHeaderListSize\n        } else {\n            throw ProtocolErrorException()\n        }\n    }\n    public operator func [](key: Int64, value!: Int64): Unit{\n        match (key) {\n            case 0x01 => this.HEADER_TABLE_SIZE = value\n            case 0x02 => this.ENABLE_PUSH = value\n            case 0x03 => this.MAX_CONCURRENT_STREAMS = value\n            case 0x04 => this.INITIAL_WINDOW_SIZE = value\n            case 0x05 => this.MAX_FRAME_SIZE = value\n            case 0x06 => this.MAX_HEADER_LIST_SIZE = value\n            case _ => throw ProtocolErrorException()\n        }\n    }\n    public operator func [](key: Int64): Int64 {\n        return match (key) {\n            case 0x01 => this.HEADER_TABLE_SIZE\n            case 0x02 => this.ENABLE_PUSH\n            case 0x03 => this.MAX_CONCURRENT_STREAMS\n            case 0x04 => this.INITIAL_WINDOW_SIZE\n            case 0x05 => this.MAX_FRAME_SIZE\n            case 0x06 => this.MAX_HEADER_LIST_SIZE\n            case _ => throw ProtocolErrorException()\n        }\n    }\n}\n// PROTOCOL_ERROR\npublic class ProtocolErrorException <: Exception {\n    public init(){\n        super()\n    }\n    public init(string: String) {\n        super(\"ProtocolErrorException: ${string}\")\n    }\n}\n// FLOW_CONTROL_ERROR\npublic class FlowControlErrorException <: Exception {\n    public init(){\n        super()\n    }\n    public init(string: String) {\n        super(\"FlowControlErrorException: ${string}\")\n    }\n}\n// FRAME_SIZE_ERROR\npublic class FrameSizeErrorException <: Exception {\n    public init(){\n        super()\n    }\n    public init(string: String) {\n        super(\"FrameSizeErrorException: ${string}\")\n    }\n}", "llm_cg": {"main": [], "H2Config": [], "H2Config.HEADER_TABLE_SIZE.get": [], "H2Config.HEADER_TABLE_SIZE.set": ["Exception"], "H2Config.ENABLE_PUSH.get": [], "H2Config.ENABLE_PUSH.set": ["ProtocolErrorException"], "H2Config.MAX_CONCURRENT_STREAMS.get": [], "H2Config.MAX_CONCURRENT_STREAMS.set": ["ProtocolErrorException"], "H2Config.INITIAL_WINDOW_SIZE.get": [], "H2Config.INITIAL_WINDOW_SIZE.set": ["FlowControlErrorException", "Int64"], "H2Config.MAX_FRAME_SIZE.get": [], "H2Config.MAX_FRAME_SIZE.set": ["ProtocolErrorException"], "H2Config.MAX_HEADER_LIST_SIZE.get": [], "H2Config.MAX_HEADER_LIST_SIZE.set": ["ProtocolErrorException"], "H2Config.__init__": [], "H2Config.__init__.headerTableSize": ["Exception"], "H2Config.__init__.enablePush": ["ProtocolErrorException"], "H2Config.__init__.maxConcurrentStreams": ["ProtocolErrorException"], "H2Config.__init__.initialWindowSize": ["FlowControlErrorException", "Int64"], "H2Config.__init__.maxFrameSize": ["ProtocolErrorException"], "H2Config.__init__.maxHeaderListSize": ["ProtocolErrorException"], "H2Config.__getitem__": ["ProtocolErrorException"], "H2Config.__setitem__": ["ProtocolErrorException"], "ProtocolErrorException": [], "ProtocolErrorException.__init__": ["super"], "ProtocolErrorException.__init__.string": ["super"], "FlowControlErrorException": [], "FlowControlErrorException.__init__": ["super"], "FlowControlErrorException.__init__.string": ["super"], "FrameSizeErrorException": [], "FrameSizeErrorException.__init__": ["super"], "FrameSizeErrorException.__init__.string": ["super"]}, "static_cg": {}}
{"source_code": "package test\n// main declaration\nclass Simple {\n    let str = \"\"\n    var x: Int64\n    public Simple(x: Int64) {\n        this.x = x\n    }\n    public init(a: String) {\n        this.x = 1\n    }\n    public static func buildDefault() {\n        Simple(0)\n    }\n}\nopen class Base {}\nclass Child <: Base {}\nclass WithGeneric<T> {}\nclass WithThis {\n    public func returnThis(): This {\n        this\n    }\n}\nstruct SimpleStruct {\n    public func funcInStrcut(): Unit {}\n}\nenum SimpleEnum {\n    | EnumA\n    | EnumB\n}\ninterface SimpleInterface {}", "llm_cg": {"main": [], "Simple": [], "Simple.buildDefault": ["Simple"], "WithThis.returnThis": [], "SimpleStruct.funcInStrcut": []}, "static_cg": {}}
{"source_code": "// EXEC: cjc %import-path %L %l %f  %project-path %project-L/protobuf  -l protobuf-cj\n// EXEC: ./main\nfrom rpc4cj import http2.frame.*\nfrom rpc4cj import util.*\nfrom rpc4cj import transport.*\nfrom std import collection.*\nfrom net import http.*\nmain (){\n    try {\n        let er: EmptyResponseWriteStream = EmptyResponseWriteStream()\n        er.header()\n        er.write(Array<UInt8>(16, item: 0))\n        er.writeStatusCode(200)\n        er.flush()\n    } catch (e: Exception) {\n        return -1\n    }\n    return 0\n}\npublic class EmptyResponseWriteStream <: ResponseWriteStream {\n    public func header(): HttpHeaders{ return HttpHeaders() }\n    public func write(_: Array<UInt8>): Unit {}\n    public func writeStatusCode(_: Int64): Unit {}\n    public func flush(): Unit {}\n}", "llm_cg": {"main": ["EmptyResponseWriteStream", "er.header", "er.write", "er.writeStatusCode", "er.flush"], "EmptyResponseWriteStream": [], "EmptyResponseWriteStream.header": [], "EmptyResponseWriteStream.write": [], "EmptyResponseWriteStream.writeStatusCode": [], "EmptyResponseWriteStream.flush": []}, "static_cg": {}}
{"source_code": " from std import collection.*\nfunc f_gold (seq:String):String{\n  let n = seq.size\n  if ( n >= 9 ) {return \"-1\"}\n  let result = Array<Char>(n+1,item:' ')\n  var count:Int32 = 1\n  for(i in 0..n+1){\n    if ( i == n || seq[i] == b'I' ) {\n      for (j in i-1..-2:-1) {\n        result [ j + 1 ] = Char( Int32(b'0') + count)\n        count++\n        if ( j >= 0 && seq[j] == b'I' ) {break}\n      }\n    }\n  }\n  return String(result)\n}\n//TOFILL\nmain(){\n    var n_success = 0\n    let param0 = ArrayList<String>()\n    param0.append(\"D\")\n    param0.append(\"I\")\n    param0.append(\"DD\")\n    param0.append(\"II\")\n    param0.append(\"DIDI\")\n    param0.append(\"IIDDD\")\n    param0.append(\"DDIDDIID\")\n    param0.append(\"176297\")\n    param0.append(\"1\")\n    param0.append(\"XHkhZq\")\n    let param1 = ArrayList<String>()\n    param1.append(\"D\")\n    param1.append(\"I\")\n    param1.append(\"DD\")\n    param1.append(\"II\")\n    param1.append(\"DIDI\")\n    param1.append(\"IIDDD\")\n    param1.append(\"DDIDDIID\")\n    param1.append(\"176297\")\n    param1.append(\"1\")\n    param1.append(\"XHkhZq\")\n    for (i in 0..param0.size){\n        if (f_gold(param0[i]) == f_filled(param1[i])){\n            n_success += 1\n        }\n    }\n    println(\"#Results: ${n_success}, ${param0.size}\\n\")\n}", "llm_cg": {"main": ["ArrayList", "f_gold", "f_filled", "<builtin>.println"], "f_gold": ["seq.size", "Array"]}, "static_cg": {}}
{"source_code": "package rx.observables\nclass ObservableConcatMap<T> <: Observable<T> {\n    private let sources: ArrayList<Observable<T>>\n    init(sources: Collection<Observable<T>>) {\n        this.sources = ArrayList<Observable<T>>(sources)\n    }\n    public func subscribeActual(observer: Observer<T>) {\n        let disposable = ConcatMapObserver(observer, sources)\n        observer.onSubscribe(disposable)\n        disposable.drain()\n    }\n}\nclass ConcatMapObserver<T> <: EquatableDisposable {\n    private let downstream: Observer<T>\n    protected let observer: InnerObserver<T>\n    private let sources: ArrayList<Observable<T>>\n    private var index: Int64 = 0\n    private var cancelled: Bool = false\n    protected var active: Bool = true\n    init(downstream: Observer<T>, sources: ArrayList<Observable<T>>) {\n        this.downstream = downstream\n        this.sources = sources\n        this.observer = InnerObserver<T>(downstream)\n        this.observer.parent = this\n    }\n    func drain() {\n        if (!active || isDisposed()) {\n            return\n        }\n        if (index >= sources.size) {\n            downstream.onComplete()\n            return\n        }\n        let o: Observable<T> = sources[index]\n        index++\n        o.subscribe(observer)\n    }\n    public func dispose(): Unit {\n        cancelled = true\n        observer.dispose()\n    }\n    public func isDisposed(): Bool {\n        return cancelled\n    }\n}\nclass InnerObserver<T> <: Observer<T> {\n    private let downstream: Observer<T>\n    protected var parent: ?ConcatMapObserver<T> = Option.None\n    private var disposableReference: DisposableReference = DisposableReference()\n    init(downstream: Observer<T>) {\n        this.downstream = downstream\n    }\n    public func onSubscribe(disposable: Disposable): Unit {\n        disposableReference.setOnce(disposable)\n    }\n    public func onNext(value: T) {\n        downstream.onNext(value)\n    }\n    public func onError(exception: Exception) {\n        parent?.active = false\n        parent?.drain()\n        downstream.onError(exception)\n    }\n    public func onComplete(): Unit {\n        parent?.drain()\n    }\n    public func dispose(): Unit {\n        DisposableHelper.dispose(disposableReference)\n    }\n}", "llm_cg": {"ObservableConcatMap": [], "ObservableConcatMap.subscribeActual": ["ConcatMapObserver", "observer.onSubscribe", "ConcatMapObserver.drain"], "ConcatMapObserver": ["InnerObserver", "InnerObserver.init"], "ConcatMapObserver.drain": ["ConcatMapObserver.isDisposed", "downstream.onComplete", "Observable.subscribe"], "ConcatMapObserver.dispose": ["observer.dispose"], "ConcatMapObserver.isDisposed": [], "InnerObserver": [], "InnerObserver.onSubscribe": ["disposableReference.setOnce"], "InnerObserver.onNext": ["downstream.onNext"], "InnerObserver.onError": ["downstream.onError", "ConcatMapObserver.drain"], "InnerObserver.onComplete": ["ConcatMapObserver.drain"], "InnerObserver.dispose": ["DisposableHelper.dispose"]}, "static_cg": {}}
{"source_code": "// EXEC: cjc %import-path %L %l %f\n// EXEC: ./main\nimport chardet4cj.*\nimport std.io.*\nmain() {\n    let intput: ByteBuffer = ByteBuffer()\n    let str: EncodingDetectorInputStream = EncodingDetectorInputStream(intput)\n    var temp = Array<Byte>(1,repeat:0)\n    try {\n        str.read(temp)\n    } catch(e: Exception) {\n        return 0\n    }\n    try {\n        str.skip(1)\n    } catch(e: Exception) {\n        return 0\n    }\n    return 1\n}", "llm_cg": {"main": ["EncodingDetectorInputStream.read", "EncodingDetectorInputStream.skip"]}, "static_cg": {}}
{"source_code": "package silo.spirit.dao\nfrom std import collection.*\nfrom std import database.sql.Connection\nfrom cangjie_spirit import spirit.session.Dao\nfrom cangjie_spirit import spirit.runner.SqlRunner\nfrom cangjie_spirit import spirit.exception.{ExceptionContext, wrapException, ResultHandleException}\nfrom cangjie_spirit import spirit.cursor.{Cursor, ProxyCursor, DefaultCursor}\nfrom cangjie_spirit import spirit.configuration.GlobalConfiguration\nfrom crystal import reflection.{Reflectable, Class}\npublic class SiloSpiritDao <: Dao {\n    let sqlRunner: SqlRunner\n    let connection: Connection\n    public var closeFun: () -> Unit = { => }\n    public init(configuration: GlobalConfiguration, sqlRunner: SqlRunner, connection: Connection,\n        closeFun!: () -> Unit = {=>}) {\n        super(configuration)\n        this.sqlRunner = sqlRunner\n        this.connection = connection\n        this.closeFun = closeFun\n    }\n    public func select(sqlID: String, inputParam: Option<Reflectable>, clazz: Class): ArrayList<Reflectable> {\n        try {\n            let sqlStatement = getSqlStatement(sqlID)\n            sqlRunner.query(sqlStatement, inputParam, clazz)\n        } catch (e: Exception) {\n            throw wrapException(e)\n        } finally {\n            ExceptionContext.close()\n            closeFun()\n        }\n    }\n    public func selectCursor(sqlID: String, inputParam: Option<Reflectable>, clazz: Class): Cursor<Reflectable> {\n        try {\n            let sqlStatement = getSqlStatement(sqlID)\n            sqlRunner.queryCursor(sqlStatement, inputParam, clazz)\n        } catch (e: Exception) {\n            throw wrapException(e)\n        } finally {\n            ExceptionContext.close()\n            closeFun()\n        }\n    }\n    public func select(sqlID: String, inputParam: Option<Reflectable>, clazz: Class,\n        resultItemCallback: (Reflectable) -> Bool): Unit {\n        try {\n            let sqlStatement = getSqlStatement(sqlID)\n            sqlRunner.query(sqlStatement, inputParam, clazz, resultItemCallback)\n        } catch (e: Exception) {\n            throw wrapException(e)\n        } finally {\n            ExceptionContext.close()\n            closeFun()\n        }\n    }\n    public func execute(sqlID: String, inputParam: Option<Reflectable>, clazz: Class): Any {\n        try {\n            let sqlStatement = getSqlStatement(sqlID)\n            let updateResult = sqlRunner.update(sqlStatement, inputParam)\n            return adaptUpdateResult(updateResult, clazz)\n        } catch (e: Exception) {\n            throw wrapException(e)\n        } finally {\n            ExceptionContext.close()\n            closeFun()\n        }\n    }\n    public func batchExecute(sqlID: String, inputParam: Option<Reflectable>, _: Class): Any {\n        try {\n            let sqlStatement = getSqlStatement(sqlID)\n            sqlRunner.batchUpdate(sqlStatement, inputParam)\n        } catch (e: Exception) {\n            throw wrapException(e)\n        } finally {\n            ExceptionContext.close()\n            closeFun()\n        }\n    }\n    public func commit(): Unit {\n        sqlRunner.commit()\n    }\n    public func rollback(): Unit {\n        sqlRunner.rollback()\n    }\n    public func beginTransaction(): Unit {\n        sqlRunner.beginTransaction()\n    }\n    public func close(): Unit {\n        sqlRunner.close()\n        connection.close()\n        closeFlag = true\n    }\n    private func adaptUpdateResult(updateResult: Int64, clazz: Class): Any {\n        let instance = clazz.newInstance()\n        if (instance is Bool) {\n            if (updateResult > 0) {\n                return true\n            }\n            return false\n        }\n        return convertNumberToType(updateResult, clazz)\n    }\n    private func convertNumberToType(number: Int64, clazz: Class): Any {\n        match (clazz.getName()) {\n            case \"Int64\" => Int64(number)\n            case \"Int32\" => Int32(number)\n            case \"Int16\" => Int16(number)\n            case \"Int8\" => Int8(number)\n            case \"IntNative\" => IntNative(number)\n            case \"UInt64\" => UInt64(number)\n            case \"UInt32\" => UInt32(number)\n            case \"UInt16\" => UInt16(number)\n            case \"UInt8\" => UInt8(number)\n            case \"UIntNative\" => UIntNative(number)\n            case \"Float64\" => Float64(number)\n            case \"Float32\" => Float32(number)\n            case \"Float16\" => Float16(number)\n            case \"Char\" => Char(number)\n            case \"Bool\" => number != 0\n            case \"String\" => \"${number}\"\n            case _ => throw ResultHandleException(\n                \"update sql result only support Bool and numberic type, not support ${clazz.getName()}, please change it\"\n            )\n        }\n    }\n    public func flushStatements(): Int64 {\n        var result = sqlRunner.flushStatements()\n        return result\n    }\n}", "llm_cg": {"SiloSpiritDao": [], "SiloSpiritDao.init": ["spirit.runner.SqlRunner", "spirit.dao.Dao", "spirit.configuration.GlobalConfiguration"], "SiloSpiritDao.select": ["SiloSpiritDao.getSqlStatement", "spirit.runner.SqlRunner.query", "spirit.exception.wrapException", "spirit.exception.ExceptionContext.close", "SiloSpiritDao.closeFun"], "SiloSpiritDao.selectCursor": ["SiloSpiritDao.getSqlStatement", "spirit.runner.SqlRunner.queryCursor", "spirit.exception.wrapException", "spirit.exception.ExceptionContext.close", "SiloSpiritDao.closeFun"], "SiloSpiritDao.select.Reflectable": ["SiloSpiritDao.getSqlStatement", "spirit.runner.SqlRunner.query", "spirit.exception.wrapException", "spirit.exception.ExceptionContext.close", "SiloSpiritDao.closeFun"], "SiloSpiritDao.execute": ["SiloSpiritDao.getSqlStatement", "spirit.runner.SqlRunner.update", "SiloSpiritDao.adaptUpdateResult", "spirit.exception.wrapException", "spirit.exception.ExceptionContext.close", "SiloSpiritDao.closeFun"], "SiloSpiritDao.batchExecute": ["SiloSpiritDao.getSqlStatement", "spirit.runner.SqlRunner.batchUpdate", "spirit.exception.wrapException", "spirit.exception.ExceptionContext.close", "SiloSpiritDao.closeFun"], "SiloSpiritDao.commit": ["spirit.runner.SqlRunner.commit"], "SiloSpiritDao.rollback": ["spirit.runner.SqlRunner.rollback"], "SiloSpiritDao.beginTransaction": ["spirit.runner.SqlRunner.beginTransaction"], "SiloSpiritDao.close": ["spirit.runner.SqlRunner.close", "spirit.database.sql.Connection.close"], "SiloSpiritDao.adaptUpdateResult": ["spirit.reflection.Class.newInstance", "SiloSpiritDao.convertNumberToType"], "SiloSpiritDao.convertNumberToType": ["spirit.reflection.Class.getName", "spirit.exception.ResultHandleException"], "SiloSpiritDao.flushStatements": ["spirit.runner.SqlRunner.flushStatements"]}, "static_cg": {}}
{"source_code": "package editorkit.language_ruby.lexer\nfunc getRubyTOKENFromStr(str: String): RUBYTOKEN {\n    let rubyTypeStr: String = str\n    var token: RUBYTOKEN = match (rubyTypeStr) {\n        case \"integer\" | \"float\" | \"i\" | \"ri\" => RUBYTOKEN.NUMBER_LITERAL\n        case \"instance_variable\" | \"class_variable\" => RUBYTOKEN.INSTANCE_VARIABLE\n        case \"alias\" => RUBYTOKEN.ALIAS\n        case \"super\" => RUBYTOKEN.SUPER\n        case \"self\" => RUBYTOKEN.SELF\n        case \"undef\" => RUBYTOKEN.UNDEF\n        case \"class\" => RUBYTOKEN.CLASS\n        case \"def\" => RUBYTOKEN.DEF\n        case \"end\" => RUBYTOKEN.END\n        case \"module\" => RUBYTOKEN.MODULE\n        case \"return\" => RUBYTOKEN.RETURN\n        case \"and\" => RUBYTOKEN.AND\n        case \"begin\" | \"BEGIN\" => RUBYTOKEN.BEGIN\n        case \"break\" => RUBYTOKEN.BREAK\n        case \"do\" => RUBYTOKEN.DO\n        case \"ensure\" => RUBYTOKEN.ENSURE\n        case \"for\" => RUBYTOKEN.FOR\n        case \"in\" => RUBYTOKEN.IN\n        case \"next\" => RUBYTOKEN.NEXT\n        case \"not\" => RUBYTOKEN.NOT\n        case \"or\" => RUBYTOKEN.OR\n        case \"redo\" => RUBYTOKEN.REDO\n        case \"rescue\" => RUBYTOKEN.RESCUE\n        case \"retry\" => RUBYTOKEN.RETRY\n        case \"yield\" => RUBYTOKEN.YIELD\n        case \"until\" => RUBYTOKEN.UNTIL\n        case \"unless\" => RUBYTOKEN.UNLESS\n        case \"while\" => RUBYTOKEN.WHILE\n        case \"if\" => RUBYTOKEN.IF\n        case \"case\" => RUBYTOKEN.CASE\n        case \"when\" => RUBYTOKEN.WHEN\n        case \"then\" => RUBYTOKEN.THEN\n        case \"else\" => RUBYTOKEN.ELSE\n        case \"elsif\" => RUBYTOKEN.ELSIF\n        case \"end\" | \"END\" => RUBYTOKEN.END\n        case \"until\" => RUBYTOKEN.UNTIL\n        case \"constant\" => RUBYTOKEN.CONSTANT\n        case \"abort\" |\n           \"catch\" |\n           \"chomp\" |\n           \"chop\" |\n           \"eval\" |\n           \"exec\" |\n           \"exit\" |\n           \"fail\" |\n           \"fork\" |\n           \"format\" |\n           \"gets\" |\n           \"gsub\" |\n           \"Integer\" |\n           \"proc\" |\n           \"lambda\" |\n           \"load\" |\n           \"loop\" |\n           \"open\" |\n           \"p\" |\n           \"print\" |\n           \"proc\" |\n           \"puts\" |\n           \"putc\" |\n           \"pp\" |\n           \"raise\" |\n           \"fail\" |\n           \"rand\" |\n           \"readline\" |\n           \"readlines\" |\n           \"require\" |\n           \"scan\" |\n           \"select\" |\n           \"sleep\" |\n           \"srand\" |\n           \"system\" |\n           \"sub\" |\n           \"throw\" => RUBYTOKEN.METHOD\n        case \"nil\" => RUBYTOKEN.NIL\n        case \"true\" => RUBYTOKEN.TRUE\n        case \"false\" => RUBYTOKEN.FALSE\n        case \"__ENCODING__\" | \"encoding\" => RUBYTOKEN._ENCODING\n        case \"__LINE__\" | \"line\"=> RUBYTOKEN._LINE\n        case \"__FILE__\" | \"file\" => RUBYTOKEN._FILE\n        case \"defined?\" => RUBYTOKEN.DEFINED\n        case \"(\" | \"%w(\" => RUBYTOKEN.LPAREN\n        case \")\" => RUBYTOKEN.RPAREN\n        case \"{\" | \"#{\" => RUBYTOKEN.LBRACE\n        case \"}\" => RUBYTOKEN.RBRACE\n        case \"[\" | \"[]\" | \"[]=\" => RUBYTOKEN.LBRACK\n        case \"]\" => RUBYTOKEN.RBRACK\n        case \"+\" => RUBYTOKEN.PLUS\n        case \"-\" => RUBYTOKEN.MINUS\n        case \"*\" => RUBYTOKEN.MULT\n        case \"**\" => RUBYTOKEN.POW\n        case \"/\" => RUBYTOKEN.DIV\n        case \"%\" | \"%i(\" => RUBYTOKEN.MOD\n        case \"<<\" => RUBYTOKEN.LTLT\n        case \">>\" => RUBYTOKEN.GTGT\n        case \"&\" | \"&.\"=> RUBYTOKEN.AND\n        case \"|\" => RUBYTOKEN.OR\n        case \"!\" => RUBYTOKEN.NOT\n        case \"NOT\" => RUBYTOKEN.NOT_KEYWORD\n        case \"&&\" | \"&&=\" => RUBYTOKEN.ANDAND\n        case \"AND\" => RUBYTOKEN.AND_KEYWORD\n        case \"||\" | \"||=\"=> RUBYTOKEN.OROR\n        case \"OR\" => RUBYTOKEN.OR_KEYWORD\n        case \"^\"  => RUBYTOKEN.XOR\n        case \"~\" | \"~@\" => RUBYTOKEN.TILDE\n        case \"<\"  => RUBYTOKEN.LT\n        case \">\" | \"->\"  => RUBYTOKEN.GT\n        case \"<=\" => RUBYTOKEN.LTEQ\n        case \">=\" | \"=>\" => RUBYTOKEN.GTEQ\n        case \"==\" | \"===\"=> RUBYTOKEN.EQEQ\n        case \"!=\" | \"!~\" => RUBYTOKEN.NOTEQ\n        case \"<>\" | \"<=>\"=> RUBYTOKEN.LTGT\n        case \",\" => RUBYTOKEN.COMMA\n        case \":\" | \"::\" => RUBYTOKEN.COLON\n        case \".\" => RUBYTOKEN.DOT\n        case \"..\" | \"...\" => RUBYTOKEN.RANGE\n        case \"`\"  => RUBYTOKEN.BACKTICK\n        case \"=\" | \"=~\"=> RUBYTOKEN.EQ\n        case \";\" => RUBYTOKEN.SEMICOLON\n        case \"+=\" | \"+@\" => RUBYTOKEN.PLUSEQ\n        case \"-=\" | \"-@\" => RUBYTOKEN.MINUSEQ\n        case \"*=\" => RUBYTOKEN.MULTEQ\n        case \"/=\"  => RUBYTOKEN.DIVEQ\n        case \"%=\"  => RUBYTOKEN.MODEQ\n        case \"&=\"  => RUBYTOKEN.ANDEQ\n        case \"|=\"  => RUBYTOKEN.OREQ\n        case \"^=\"  => RUBYTOKEN.XOREQ\n        case \">>=\"  => RUBYTOKEN.GTGTEQ\n        case \"<<=\"  => RUBYTOKEN.LTLTEQ\n        case \"**=\"  => RUBYTOKEN.POWEQ\n        case \"identifier\" => RUBYTOKEN.IDENTIFIER\n        case \"comment\" => RUBYTOKEN.COMMENT\n        case \"simple_symbol\" | \"string_content\" | \"heredoc_content\" | \"heredoc_beginning\" | \"heredoc_end\" | \"string\" | \"\\\"\"=> RUBYTOKEN.QUOTED_STRING\n        case \"escape_sequence\" => RUBYTOKEN.WHITESPACE\n        case _ => RUBYTOKEN.BAD_CHARACTER\n    }\n    token\n}", "llm_cg": {"main": [], "getRubyTOKENFromStr": []}, "static_cg": {}}
{"source_code": "package glide\nfrom ohos import base.*\nextend File {\n    public func write(s: UInt8): Unit {\n        this.write(Array<UInt8>(1, item: s))\n    }\n}\n    public func unsignedShiftRight64(c: Int64, num: Int64) {\n        let t: Int64 = 0x7fffffffffffffff<<1 | 0x01;\n        // AppLog.error(\"${c}  ${t&c}  ${num}\");\n        Int64(UInt64(t & c) >> num)\n    }\n    public func highestOneBit(i: Int64): Int64 {\n        var i2 = i\n        i2 |= (i2 >>  1);\n        i2 |= i2 | (i2 >>  2);\n        i2 |= (i2 >>  4);\n        i2 |= (i2 >>  8);\n        i2 |= (i2 >> 16);\n        return i2 - unsignedShiftRight64(i2, 1);\n    }", "llm_cg": {"main": [], "File.write": ["Array"], "unsignedShiftRight64": [], "highestOneBit": ["unsignedShiftRight64"]}, "static_cg": {}}
{"source_code": "package zip4cj.util\npublic class RawIO {\n    public let shortBuff = Array<Byte>(2, repeat: 0)\n    public let intBuff = Array<Byte>(4, repeat: 0)\n    public let longBuff = Array<Byte>(8, repeat: 0)\n    public func readLongLittleEndian(randomAccessFile: RandomAccessFile): Int64 {\n        randomAccessFile.readFully(longBuff)\n        return readLongLittleEndian(longBuff, 0)\n    }\n    public func readLongLittleEndian(randomAccessFile: RandomAccessFile, readLen: Int64): Int64 {\n        resetBytes(longBuff)\n        randomAccessFile.readFully(longBuff[0..readLen])\n        return readLongLittleEndian(longBuff, 0)\n    }\n    public func readLongLittleEndian(inputStream: InputStream): Int64 {\n        readFully(inputStream, longBuff, longBuff.size)\n        return readLongLittleEndian(longBuff, 0)\n    }\n    public func readLongLittleEndian(inputStream: InputStream, readLen: Int64): Int64 {\n        resetBytes(longBuff)\n        readFully(inputStream, longBuff, readLen)\n        return readLongLittleEndian(longBuff, 0)\n    }\n    public func readLongLittleEndian(array: Array<Byte>, pos: Int64) {\n        if (array.size - pos < 8) {\n            resetBytes(longBuff)\n        }\n        ArrayCopy(array, pos, longBuff, 0, min(array.size - pos, 8))\n        var temp = 0\n        temp |= Int64(longBuff[7] & 0xff)\n        temp <<= 8\n        temp |= Int64(longBuff[6] & 0xff)\n        temp <<= 8\n        temp |= Int64(longBuff[5] & 0xff)\n        temp <<= 8\n        temp |= Int64(longBuff[4] & 0xff)\n        temp <<= 8\n        temp |= Int64(longBuff[3] & 0xff)\n        temp <<= 8\n        temp |= Int64(longBuff[2] & 0xff)\n        temp <<= 8\n        temp |= Int64(longBuff[1] & 0xff)\n        temp <<= 8\n        temp |= Int64(longBuff[0] & 0xff)\n        return temp\n    }\n    public func readIntLittleEndian(randomAccessFile: RandomAccessFile): Int32 {\n        randomAccessFile.readFully(intBuff)\n        return readIntLittleEndian(intBuff)\n    }\n    public func readIntLittleEndian(inputStream: InputStream): Int32 {\n        readFully(inputStream, intBuff, 4)\n        return readIntLittleEndian(intBuff)\n    }\n    public func readIntLittleEndian(b: Array<Byte>): Int32 {\n        return readIntLittleEndian(b, 0)\n    }\n    public func readIntLittleEndian(b: Array<Byte>, pos: Int64): Int32 {\n        return (Int32(b[pos] & 0xff) | Int32(b[1 + pos] & 0xff) << 8) |\n            (Int32(b[2 + pos] & 0xff) | Int32(b[3 + pos] & 0xff) << 8) << 16\n    }\n    public func readShortLittleEndian(randomAccessFile: RandomAccessFile): Int32 {\n        randomAccessFile.readFully(shortBuff)\n        return readShortLittleEndian(shortBuff, 0)\n    }\n    public func readShortLittleEndian(inputStream: InputStream): Int32 {\n        readFully(inputStream, shortBuff, shortBuff.size)\n        return readShortLittleEndian(shortBuff, 0)\n    }\n    public func readShortLittleEndian(buff: Array<Byte>, position: Int64): Int32 {\n        return Int32(buff[position] & 0xff) | Int32(buff[1 + position] & 0xff) << 8\n    }\n    public func writeShortLittleEndian(outputStream: OutputStream, value: Int32): Unit {\n        writeShortLittleEndian(shortBuff, 0, value)\n        outputStream.write(shortBuff)\n    }\n    @OverflowWrapping\n    public func writeShortLittleEndian(array: Array<Byte>, pos: Int64, value: Int32): Unit {\n        array[pos + 1] = UInt8(value[8])\n        array[pos] = UInt8(value & 0xFF)\n    }\n    public func writeIntLittleEndian(outputStream: OutputStream, value: Int32): Unit {\n        writeIntLittleEndian(intBuff, 0, value)\n        outputStream.write(intBuff)\n    }\n    @OverflowWrapping\n    public func writeIntLittleEndian(array: Array<Byte>, pos: Int64, value: Int32): Unit {\n        array[pos + 3] = UInt8(value[24])\n        array[pos + 2] = UInt8(value[16])\n        array[pos + 1] = UInt8(value[8])\n        array[pos] = UInt8(value & 0xFF)\n    }\n    public func writeLongLittleEndian(outputStream: OutputStream, value: Int64): Unit {\n        writeLongLittleEndian(longBuff, 0, value)\n        outputStream.write(longBuff)\n    }\n    @OverflowWrapping\n    public func writeLongLittleEndian(array: Array<Byte>, pos: Int64, value: Int64): Unit {\n        array[pos + 7] = UInt8(value[56])\n        array[pos + 6] = UInt8(value[48])\n        array[pos + 5] = UInt8(value[40])\n        array[pos + 4] = UInt8(value[32])\n        array[pos + 3] = UInt8(value[24])\n        array[pos + 2] = UInt8(value[16])\n        array[pos + 1] = UInt8(value[8])\n        array[pos] = UInt8(value & 0xFF)\n    }\n    private func readFully(inputStream: InputStream, buff: Array<Byte>, readLen: Int64): Unit {\n        var actualReadLength = Zip4cjUtil.readFully(inputStream, buff, 0, readLen)\n        if (actualReadLength != readLen) {\n            throw ZipException(\"Could not fill buffer\")\n        }\n    }\n    private func resetBytes(b: Array<Byte>) {\n        fill(b, 0)\n    }\n}", "llm_cg": {"main": [], "RawIO": [], "RawIO.readLongLittleEndian": ["randomAccessFile.readFully", "RawIO.readLongLittleEndian", "RawIO.resetBytes", "randomAccessFile.readFully"], "RawIO.readLongLittleEndian.1": ["randomAccessFile.readFully", "RawIO.readLongLittleEndian", "RawIO.readFully"], "RawIO.readLongLittleEndian.2": ["RawIO.readFully", "RawIO.readLongLittleEndian"], "RawIO.readLongLittleEndian.3": ["RawIO.resetBytes", "RawIO.readFully", "RawIO.readLongLittleEndian"], "RawIO.readLongLittleEndian.4": ["RawIO.resetBytes", "ArrayCopy"], "RawIO.readIntLittleEndian": ["randomAccessFile.readFully", "RawIO.readIntLittleEndian"], "RawIO.readIntLittleEndian.1": ["RawIO.readFully", "RawIO.readIntLittleEndian"], "RawIO.readIntLittleEndian.2": [], "RawIO.readIntLittleEndian.3": [], "RawIO.readShortLittleEndian": ["randomAccessFile.readFully", "RawIO.readShortLittleEndian"], "RawIO.readShortLittleEndian.1": ["RawIO.readFully", "RawIO.readShortLittleEndian"], "RawIO.readShortLittleEndian.2": [], "RawIO.writeShortLittleEndian": ["RawIO.writeShortLittleEndian", "outputStream.write"], "RawIO.writeShortLittleEndian.1": [], "RawIO.writeIntLittleEndian": ["RawIO.writeIntLittleEndian", "outputStream.write"], "RawIO.writeIntLittleEndian.1": [], "RawIO.writeLongLittleEndian": ["RawIO.writeLongLittleEndian", "outputStream.write"], "RawIO.writeLongLittleEndian.1": [], "RawIO.readFully": ["Zip4cjUtil.readFully", "ZipException"], "RawIO.resetBytes": ["fill"]}, "static_cg": {}}
{"source_code": "package droplet.droplet\npublic interface Drawable {\n    func getPixelMap(): PixelMap;\n    func draw(isErrorPic:Bool): Unit;\n    func setDrawFunc(drawFunc: (PixelMap) -> Unit): Unit\n    func getType(): Int64\n}\npublic class NoneDrawable <: Drawable {\n    public override func getPixelMap(): PixelMap {\n        let size: Size = Size(width: 1, height: 1)\n        let arr: Array<UInt8> = Array<UInt8>(96, item: 0)\n        return createPixelMap(arr, InitializationOptions(size: size))\n    }\n    public override func draw(isErrorPic:Bool): Unit {}\n    public override func setDrawFunc(drawFunc: (PixelMap) -> Unit): Unit {}\n    public override func getType(): Int64 {\n        return -1\n    }\n}\npublic class PixelMapDrawable <: Drawable {\n    private let pixelMap: PixelMap\n    private var drawFunc: ArrayList<(PixelMap) -> Unit> = ArrayList<(PixelMap) -> Unit>()\n    public init(pixelMap: PixelMap) {\n        this.pixelMap = pixelMap\n    }\n    public override func getType(): Int64 {\n        return 1\n    }\n    public override func getPixelMap(): PixelMap {\n        return this.pixelMap\n    }\n    public override func draw(isErrorPic:Bool): Unit {\n        if(this.drawFunc.size > 0) {\n            for(f in this.drawFunc) {\n                f(this.pixelMap)\n            }\n        }\n    }\n    public override func setDrawFunc(drawFunc: (PixelMap) -> Unit): Unit {\n        this.drawFunc.append(drawFunc)\n    }\n}\npublic class CJResourceDrawable <: Drawable {\n    private let cjResource: CJResource\n    private var drawFunc: ArrayList<(CJResource,Bool) -> Unit> = ArrayList<(CJResource,Bool) -> Unit>()\n     func getCJResource(): CJResource {\n        return cjResource\n    }\n    public init(cjResource: CJResource) {\n        this.cjResource = cjResource\n    }\n    public override func getType(): Int64 {\n        return 3\n    }\n    public override func getPixelMap(): PixelMap {\n        let size: Size = Size(width: 1, height: 1)\n        let arr: Array<UInt8> = Array<UInt8>(96, item: 0)\n        return createPixelMap(arr, InitializationOptions(size: size))\n    }\n    public override func draw(isErrorPic:Bool): Unit {\n        if(this.drawFunc.size > 0) {\n            for(f in this.drawFunc) {\n                f(this.cjResource,isErrorPic)\n            }\n        }\n    }\n    public override func setDrawFunc(drawFunc: (PixelMap) -> Unit): Unit {\n    }\n     func setDrawFuncCJResource(drawFunc: (CJResource,Bool) -> Unit): Unit {\n        this.drawFunc.append(drawFunc)\n    }\n}", "llm_cg": {"main": [], "NoneDrawable": [], "NoneDrawable.getPixelMap": ["Size", "Array", "createPixelMap", "InitializationOptions"], "NoneDrawable.draw": [], "NoneDrawable.setDrawFunc": [], "NoneDrawable.getType": [], "PixelMapDrawable": [], "PixelMapDrawable.init": [], "PixelMapDrawable.getType": [], "PixelMapDrawable.getPixelMap": [], "PixelMapDrawable.draw": ["this.drawFunc.size", "f"], "PixelMapDrawable.setDrawFunc": ["this.drawFunc.append"], "CJResourceDrawable": [], "CJResourceDrawable.getCJResource": [], "CJResourceDrawable.init": [], "CJResourceDrawable.getType": [], "CJResourceDrawable.getPixelMap": ["Size", "Array", "createPixelMap", "InitializationOptions"], "CJResourceDrawable.draw": ["this.drawFunc.size", "f"], "CJResourceDrawable.setDrawFunc": [], "CJResourceDrawable.setDrawFuncCJResource": ["this.drawFunc.append"]}, "static_cg": {}}
{"source_code": "package okhttpprofiler\nfrom std import log.*\nfrom std import io.*\nfrom std import collection.*\nfrom net import http.Header\nfrom okhttp import okhttp.*\npublic class LogDataTransfer <: DataTransfer{\n    private static let LOG_LENGTH = 4000\n    private static let SLOW_DOWN_PARTS_AFTER = 20\n    private static let BODY_BUFFER_SIZE = 1024 * 1024 * 10\n    private static let LOG_PREFIX = \"OKPRFL\"\n    private static let DELIMITER = \"_\"\n    private static let HEADER_DELIMITER = ':'\n    private static let SPACE = ' '\n    private static let KEY_TAG = \"TAG\"\n    private static let KEY_VALUE = \"VALUE\"\n    private static let KEY_PARTS_COUNT = \"PARTS_COUNT\"\n    private static let CONTENT_TYPE = \"Content-Type\"\n    private static let CONTENT_LENGTH = \"Content-Length\"\n    public func sendRequest(id: String, request: Request): Unit {\n        fastLog(id, MessageType.REQUEST_METHOD(\"RQM\"), request.getMethod());\n        let url = request.getUrl().toString();\n        fastLog(id, MessageType.REQUEST_URL(\"RQU\"),url);\n        let nowSjc = Time.now().unixNano()\n        fastLog(id, MessageType.REQUEST_TIME(\"RQT\"), Time.now().toString());\n        let copy = request.newBuilder().build();\n        match(copy.getBody()){\n             case Some(v) => doSomeThingRequestBody(v,id)\n             case _ => ()\n        }\n        let headers = request.getHeaders()\n        for(header in headers){\n            let name: String = header[0]\n            let nameUpper = name.toAsciiUpper();\n            let conentTypeUpper = CONTENT_TYPE.toAsciiUpper();\n            let conentLengthUpper = CONTENT_LENGTH.toAsciiUpper();\n            if (conentTypeUpper.equals(nameUpper) || conentLengthUpper.equals(nameUpper)) {\n                continue\n            }\n            let arrayList: ArrayList<String> = header[1]\n            if(arrayList.size>0){\n                if(arrayList.size == 1){\n                    fastLog(id, MessageType.REQUEST_HEADER(\"RQH\"), name + HEADER_DELIMITER + SPACE + arrayList.get(0).getOrThrow());\n                }else{\n                    var strBuilder = StringBuilder();\n                    for(str in arrayList){\n                        strBuilder.append(str).append(\",\")\n                    }\n                    fastLog(id, MessageType.REQUEST_HEADER(\"RQH\"), name + HEADER_DELIMITER + SPACE + strBuilder.toString());\n                }\n            }\n        }\n    }\n      public func sendResponse(id: String, response: Response): Unit {\n        let optionBody: Option<ResponseBody> = response.getBody()\n        match(optionBody){\n              case Some(v) => doSomeThingResponseBody(v,id)\n              case _ => ()\n        }\n        logWithHandler(id, MessageType.RESPONSE_STATUS(\"RSS\"), response.getCode().toString(), 0);\n        let headers = response.getHeaders()\n        for(header in headers){\n                let name: String = header[0]\n                let arrayList : ArrayList<String> = header[1]\n                if(arrayList.size > 0){\n                    if(arrayList.size == 1){\n                        logWithHandler(id, MessageType.RESPONSE_HEADER(\"RSH\"), name + HEADER_DELIMITER + arrayList.get(0).getOrThrow(), 0);\n                    }else{\n                        var strBuilder = StringBuilder();\n                        for(str in arrayList){\n                            strBuilder.append(str).append(\",\")\n                        }\n                        logWithHandler(id, MessageType.RESPONSE_HEADER(\"RSH\"), name + HEADER_DELIMITER + strBuilder.toString(), 0);\n                    }\n                }\n            }\n    }\n        public func sendException(id: String, ex: Exception): Unit {\n            logWithHandler(id, MessageType.RESPONSE_ERROR(\"REE\"), ex.message, 0);\n        }\n        public func sendDuration(id: String, duration: Int64): Unit {\n            logWithHandler(id, MessageType.RESPONSE_TIME(\"RST\"), duration.toString(), 0);\n            logWithHandler(id, MessageType.RESPONSE_END(\"RSD\"), \"-->\", 0);\n        }\n        private func fastLog(id: String, mType: MessageType, message: String): Unit {\n            let tag = LOG_PREFIX + DELIMITER + id + DELIMITER + mType.getValue();\n            printLog(tag,message)\n        }\n        private func printLog(tag: String, message: String): Unit {\n            let logger: SimpleLogger = SimpleLogger()\n             //var s = File(\"../stdout8.log\", AccessMode.Write, OpenMode.Append)\n             //logger.setOutput(s)\n            logger.log(LogLevel.TRACE, tag+SPACE+SPACE+message)\n            logger.flush()\n            //s.close()\n        }\n        private func doSomeThingResponseBody(body : ResponseBody,id: String): Unit {\n            let source = body.getString() //Array<UInt8>\n            let sourceSize = source.size\n            var strResponse = \"\"\n            if(sourceSize<BODY_BUFFER_SIZE){\n                strResponse = source.substring(0,sourceSize)\n            }else{\n                strResponse = source.substring(0,BODY_BUFFER_SIZE)\n            }\n            largeLog(id, MessageType.RESPONSE_BODY(\"RSB\"), strResponse);\n        }\n        private func logWithHandler(id: String, mType: MessageType, message: String, partsCount: Int64): Unit {\n                 let tag = LOG_PREFIX + DELIMITER + id + DELIMITER + mType.getValue();\n                 let logger: SimpleLogger = SimpleLogger()\n                 //var s = File(\"../stdout8.log\", AccessMode.Write, OpenMode.Append)\n                 //logger.setOutput(s)\n                 logger.log(LogLevel.TRACE, tag+SPACE+SPACE+message+SPACE+partsCount.toString())\n                 logger.flush()\n                 //s.close()\n            }\n    private func doSomeThingRequestBody(body : RequestBody,id: String): Unit {\n         let mediaType = match(body.contentType()) {\n            case Some(m) => \"${m}\"\n            case None => \"\"\n         }\n         let contentLength = body.getContentLength()\n         if (contentLength != -1) {\n                fastLog(id, MessageType.REQUEST_HEADER(\"RQH\"), CONTENT_LENGTH + HEADER_DELIMITER + SPACE + contentLength.toString());\n         }\n        fastLog(id,MessageType.REQUEST_HEADER(\"RQH\"),CONTENT_TYPE + HEADER_DELIMITER + SPACE + mediaType)\n         let inputStream = body.get()\n         let bas = inputStream as ByteArrayStream\n         match(bas){\n            case Some(v) => doSomeThingRequestBodyLog(v,id)\n            case _ => ()\n         }\n    }\n    private func doSomeThingRequestBodyLog(bas :ByteArrayStream, id: String): Unit{\n         largeLog(id, MessageType. REQUEST_BODY(\"RQB\"),String.fromUtf8(bas.readToEnd()));\n    }\n    private func largeLog(id: String, mType: MessageType, content: String): Unit {\n        let contentLength = content.size\n        if (contentLength > LOG_LENGTH) {\n            let parts = contentLength / LOG_LENGTH\n            for (i in 0..parts) {\n                let start = i * LOG_LENGTH\n                var end = start + LOG_LENGTH\n                if (end > contentLength) {\n                    let printLength = contentLength+LOG_LENGTH-end\n                    logWithHandler(id, mType, content.substring(start, printLength), parts);\n                }else{\n                    let printLength  = LOG_LENGTH\n                    logWithHandler(id, mType, content.substring(start, LOG_LENGTH), parts);\n                }\n            }\n        } else {\n            logWithHandler(id, mType, content, 0);\n        }\n    }\n}", "llm_cg": {"main": [], "LogDataTransfer": [], "LogDataTransfer.sendRequest": ["LogDataTransfer.fastLog", "request.getMethod", "request.getUrl", "Time.now", "request.newBuilder", "request.getHeaders", "header.toAsciiUpper", "arrayList.get", "arrayList.size", "StringBuilder", "StringBuilder.append"], "LogDataTransfer.sendResponse": ["response.getBody", "LogDataTransfer.doSomeThingResponseBody", "LogDataTransfer.logWithHandler", "response.getCode", "response.getHeaders", "header.toAsciiUpper", "arrayList.get", "arrayList.size", "StringBuilder", "StringBuilder.append"], "LogDataTransfer.sendException": ["LogDataTransfer.logWithHandler", "ex.message"], "LogDataTransfer.sendDuration": ["LogDataTransfer.logWithHandler"], "LogDataTransfer.fastLog": ["LogDataTransfer.printLog", "MessageType.getValue"], "LogDataTransfer.printLog": ["SimpleLogger", "logger.log", "logger.flush"], "LogDataTransfer.doSomeThingResponseBody": ["body.getString", "source.size", "source.substring", "LogDataTransfer.largeLog"], "LogDataTransfer.logWithHandler": ["SimpleLogger", "logger.log", "logger.flush", "partsCount.toString"], "LogDataTransfer.doSomeThingRequestBody": ["body.contentType", "body.getContentLength", "LogDataTransfer.fastLog", "body.get", "LogDataTransfer.doSomeThingRequestBodyLog"], "LogDataTransfer.doSomeThingRequestBodyLog": ["String.fromUtf8", "bas.readToEnd", "LogDataTransfer.largeLog"], "LogDataTransfer.largeLog": ["content.size", "logWithHandler", "content.substring"]}, "static_cg": {}}
{"source_code": "// EXEC: cjc %import-path %L %l %f\n// EXEC: ./main\nfrom charset import charset.*\nfrom charset import charset.simplechinese.*\nmain (){\n    var charset = Charsets.GB18030\n    charset.newDecoder()\n    var _: Array<UInt8> = Array<UInt8>([0x84, 0x36, 0x81, 0x37, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32])\n    var _: Int64 = 0\n    var _: Int64 = 6\n    var _: Array<Char> = Array<Char>(6, {_ => '\\u{0}'})\n    var _: Int64 = 2\n    return 0\n}", "llm_cg": {"main": ["Charsets.GB18030.newDecoder"]}, "static_cg": {}}
{"source_code": "package mp3tag4cj.mp3tag4cj\npublic class ID3v2ObseleteFrame <: ID3v2Frame {\n    private static let HEADER_LENGTH: Int32 = 6\n    private static let ID_OFFSET: Int32 = 0\n    private static let ID_LENGTH: Int32 = 3\n    private static let DATA_LENGTH_OFFSET_ZI: Int32 = 3\n    public init(buffer: Array<Int8>, offset: Int32) {\n        super(buffer, offset)\n        super.unpackFrame(buffer, offset)\n    }\n    public init(id: String, data: Array<Int8>) {\n        super(id, data)\n    }\n    protected override func unpackHeader(buffer: Array<Int8>, offset: Int32): Int32 {\n        match (BufferTools.byteBufferToStringIgnoringEncodingIssues(\n            buffer,\n            offset + ID_OFFSET,\n            ID_LENGTH\n        )) {\n            case Some(x) => id = x\n            case None => ()\n        }\n        unpackDataLength(buffer, offset)\n        return offset + HEADER_LENGTH\n    }\n    protected override func unpackDataLength(buffer: Array<Int8>, offset: Int32): Unit {\n        dataLength = BufferTools.unpackInteger(\n            Int8(0),\n            buffer[Int64(offset) + Int64(DATA_LENGTH_OFFSET_ZI)],\n            buffer[Int64(offset) + Int64(DATA_LENGTH_OFFSET_ZI) + 1],\n            buffer[Int64(offset) + Int64(DATA_LENGTH_OFFSET_ZI) + 2]\n        )\n    }\n    public override func packFrame(_: Array<Int8>, _: Int32): Unit {\n        throw NotSupportedException(\"Packing Obselete frames is not supported\")\n    }\n    public override func getLength(): Int32 {\n        return dataLength + HEADER_LENGTH\n    }\n}", "llm_cg": {"main": [], "ID3v2ObseleteFrame": [], "ID3v2ObseleteFrame.<init>": ["ID3v2Frame.<init>", "ID3v2Frame.unpackFrame"], "ID3v2ObseleteFrame.<init>_2": ["ID3v2Frame.<init>"], "ID3v2ObseleteFrame.unpackHeader": ["BufferTools.byteBufferToStringIgnoringEncodingIssues", "ID3v2ObseleteFrame.unpackDataLength"], "ID3v2ObseleteFrame.unpackDataLength": ["BufferTools.unpackInteger"], "ID3v2ObseleteFrame.packFrame": ["NotSupportedException.<init>"], "ID3v2ObseleteFrame.getLength": []}, "static_cg": {}}
{"source_code": "package dataorm4cj\nprotected func CursorQueryDataInternalCreate<E>(dao: IAbstractDao, sql: sqlType, initialValues: Array<ValueType>): CursorQuery<E> where E <: EntityType {\n    return CursorQueryDataCreate<E>(dao, sql, initialValues, -1, -1)\n}\nprotected func CursorQueryDataCreate<E>(dao: IAbstractDao, sql: sqlType, initialValues: Array<ValueType>, limitPosition: Int64, offsetPosition: Int64): CursorQuery<E> where E <: EntityType  {\n    let queryData = CursorQueryData<E>(dao, sql, initialValues, limitPosition,\n            offsetPosition)\n    return queryData.forCurrentThread()\n}\npublic class CursorQueryData<T> <: AbstractQueryData<T, CursorQuery<T>> where T <: EntityType {\n    private let limitPosition: Int64\n    private let offsetPosition: Int64\n    protected init(dao: IAbstractDao,sql: sqlType, initialValues: Array<ValueType>, limitPosition: Int64, offsetPosition: Int64) {\n        super(dao, sql, initialValues)\n        this.limitPosition = limitPosition\n        this.offsetPosition = offsetPosition\n    }\n    protected func createQuery(): CursorQuery<T> {\n        CursorQuery<T>(this, this.dao, this.sql, this.initialValues, limitPosition, offsetPosition)\n    }\n}\npublic class CursorQuery<T> <: AbstractQueryWithLimit<T> where T <: EntityType {\n    private let queryData: CursorQueryData<T>\n    init(queryData: CursorQueryData<T>, dao: IAbstractDao, sql: sqlType, initialValues: Array<ValueType>, limitPosition: Int64, offsetPosition: Int64) {\n        super(dao, sql, initialValues, limitPosition, offsetPosition)\n        this.queryData = queryData\n    }\n    public func forCurrentThread(): CursorQuery<T> {\n        return queryData.forCurrentThread(this)\n    }\n    public func query(): ResultSet {\n        checkThread()\n        return match (sql) {\n            case SQL(v) => dao.getDatabase().querySql(v, bindArgs: parameters)\n            case PREDICATES(v) => dao.getDatabase().query(v.rdbPredicates, [])\n        }\n    }\n    // copy setParameter methods to allow easy chaining\n    public override func setParameter(index: Int64, parameter: ValueType ): AbstractQueryWithLimit<T> {\n        return super.setParameter(index, parameter)\n    }\n    public override func setParameter(index: Int64, parameter: ?DateTime): AbstractQuery<T> {\n        return super.setParameter(index, parameter)\n    }\n    public override func setParameter(index: Int64, parameter: ?Bool): AbstractQuery<T> {\n        return super.setParameter(index, parameter)\n    }\n}", "llm_cg": {"CursorQueryDataInternalCreate": ["CursorQueryDataCreate"], "CursorQueryDataCreate": ["CursorQueryData.forCurrentThread"], "CursorQueryData.<init>": ["super"], "CursorQueryData.createQuery": ["CursorQuery.<init>"], "CursorQuery.<init>": ["super"], "CursorQuery.forCurrentThread": ["CursorQueryData.forCurrentThread"], "CursorQuery.query": ["checkThread", "dao.getDatabase.querySql", "dao.getDatabase.query"], "CursorQuery.setParameter": ["super.setParameter"]}, "static_cg": {}}
{"source_code": "macro package bindings.runner.macros\nfrom std import ast.*\nfrom std import collection.HashMap\nfrom std import fs.File\nimport bindings.common.*\nimport bindings.clang.parseForeignCDecls\npublic macro CBindings(attr: Tokens, input: Tokens): Tokens {\n    let filepath = parseExpr(input).checkStringLiteral()\n    if (!File.exists(filepath)) {\n        throw IllegalArgumentException(\"File ${filepath} does not exist\")\n    }\n    let ctx = attr.parseTranslationContext()\n    parseForeignCDecls(filepath, context: ctx)\n}", "llm_cg": {"main": ["parseExpr", "parseForeignCDecls", "File.exists", "attr.parseTranslationContext", "<builtin>.throw"]}, "static_cg": {}}
{"source_code": "package elements\n//TODO: 未完全实现\npublic class CvTextElement <: ITextElement{\n    var textSpans: ArrayList<Object>\n    var yOffset: Int64\n    var fillColorAnim: Bool\n    var strokeColorAnim: Bool\n    var strokeWidthAnim: Bool\n    var stroke: Bool\n    var fill: Bool\n    var justifyOffset: Int64\n    var currentRender: Option<String>\n    var renderType: String\n    var values: valuesData\n    //TODO comp\n    public init(data: Layer, globalData: GlobalData) {\n        super(data, globalData)\n        this.textSpans = ArrayList<Object>()\n        this.yOffset = 0\n        this.fillColorAnim = false\n        this.strokeColorAnim = false\n        this.strokeWidthAnim = false\n        this.stroke = false\n        this.fill = false\n        this.justifyOffset = 0\n        this.currentRender = None\n        this.renderType = \"canvas\"\n        this.values = valuesData(\"rgba(0,0,0,0)\",\"rgba(0,0,0,0)\", 0.0, \"\")\n        //this.initElement(data, globalData, comp)\n    }\n    public func tHelper() { }\n    public func buildNewText() {\n        var documentData = this.textProperty.currentData\n        //this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);\n        var hasFill = false\n        if (!documentData.fc.isEmpty()) {\n            hasFill = true\n            this.values.fill = this.buildColor(documentData.fc)\n        } else {\n            this.values.fill = \"rgba(0,0,0,0)\"\n        }\n        this.fill = hasFill\n        var hasStroke = false\n        if (!documentData.sc.isEmpty()) {\n            hasStroke = true\n            this.values.stroke = this.buildColor(documentData.sc)\n            this.values.sWidth = documentData.sw\n        }\n        var fontData = this.globalData.fontManager.getFontByName(documentData.f)\n        var letters: ArrayList<Letter> = documentData.l\n        //mHelper: new Matrix(),\n        var matrixHelper: Matrix =  Matrix()\n        this.stroke = hasStroke\n        this.values.fValue = \"${documentData.finalSize}\" + \"px \" + this.globalData.fontManager.getFontByName(documentData.f).fFamily\n        var len: Int64 = documentData.finalText.size\n        var xPos = 0\n        var yPos = 0\n        var firstLine = true\n        var cnt = 0\n        for (i in 0..len) {\n            var charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily)\n            //shapeData = (charData && charData.data) || {};\n            var shapeData = charData.data\n            matrixHelper.reset()\n        }\n    }\n}\npublic class valuesData {\n    var fill: String\n    var stroke: String\n    var sWidth: Float64\n    var fValue: String\n    public init(fill: String, stroke: String, sWidth: Float64, fValue: String) {\n        this.fill = fill\n        this.stroke = stroke\n        this.sWidth = sWidth\n        this.fValue = fValue\n    }\n}", "llm_cg": {}, "static_cg": {}}
{"source_code": "package parser\npublic class GIFFrame <: ToString {\n    //This float doesn't have a leading digit/Display frame width, height, top margin, left margin\n    public var dims: Dims = Dims()\n    //The color array pointed to by the pixel data of the current frame. Group of 3 lengths.\n    public var colorTable: Array<UInt8> = Array<UInt8>()\n    //The duration of the interval from the current frame to the next frame\n    public var delay: Int64 = 0\n    public var disposalType: Int32 = 0\n    //The patch information after color conversion is used for drawing\n    public var patch: Array<UInt8> = Array<UInt8>()\n    //PixelMap image generated by patch (not used before UI encapsulation)\n    //public var drawPixelMap: ?PixelMap = None\n    public var drawPixelMap: ?Any = None\n    //Color table lookup index for each pixel in the current frame\n    public var pixels: Array<UInt8> = Array<UInt8>()\n    //Optional color index representing transparency\n    public var transparentIndex: Int32 = -1\n    public func toString(): String {\n        return \"GIFFrame = [(colorTable.size = ${colorTable.size}),  (delay = ${delay}), \\n\" +\n                        \"(dims = ${dims.toString()}), \\n\" +\n                        \"(disposalType = ${disposalType}), (pixels.size = ${pixels.size}), (transparentIndex = ${transparentIndex}), \\n\" +\n                        \"(patch.size = ${patch.size},  (pixels.size = ${pixels.size}]\\n\"\n    }\n}\npublic class Dims <: ToString {\n    //The width of GIF frames.\n    public var width: Int32 = 0\n    //The height of GIF frames.\n    public var height: Int32 = 0\n    //Top margin of GIF frames\n    public var top: Int32 = 0\n    //Left margin of GIF frame.\n    public var left: Int32 = 0\n    public init(){}\n    public init(width!: Int32, height!: Int32, top!: Int32, left!: Int32) {\n        this.width = width\n        this.height = height\n        this.top = top\n        this.left = left\n    }\n    public func toString(): String {\n        return \"Dims = {(top = ${top}), (left = ${left}), (width = ${width}), (height = ${height})}\"\n    }\n}", "llm_cg": {"GIFFrame": ["Dims"], "GIFFrame.toString": [], "Dims": [], "Dims.toString": []}, "static_cg": {}}
{"source_code": "package cjqt.widgets\nimport cjqt.gui.*\nimport cjqt.core.*\nforeign func nativeSplitterHandleCreate(orientation:Int32, parentPtr: Int64): Int64\nforeign func nativeSplitterHandleDelete(ptr: Int64): Unit\nforeign func nativeSplitterHandleSetOrientation(ptr: Int64, orientation: Int32): Unit\nforeign func nativeSplitterHandleOrientation(ptr: Int64): Int32\nforeign func nativeSplitterHandleOpaqueResize(ptr: Int64): Bool\nforeign func nativeSplitterHandleSplitter(ptr: Int64): Int64\nforeign func nativeSplitterHandleSizeHint(ptr: Int64): Int64\npublic class QSplitterHandle <: QWidget {\n    public init(orientation!:Int64 = 1, parent!: QSplitter = QSplitter()) {\n        super(unsafe {\n            nativeSplitterHandleCreate(Int32(orientation), parent.ptr)\n        })\n    }\n    public init(ptr: Int64) {\n        super(ptr)\n    }\n    public override func delete() {\n        unsafe {\n            nativeSplitterHandleDelete(ptr)\n        }\n    }\n    public func setOrientation(orientation:Int64) {\n        unsafe {\n            nativeSplitterHandleSetOrientation(ptr, Int32(orientation))\n        }\n    }\n    public func orientation(): Int64 {\n        let result = unsafe {\n            nativeSplitterHandleOrientation(ptr)\n        }\n        return Int64(result)\n    }\n    public func opaqueResize(): Bool {\n        let result = unsafe {\n            nativeSplitterHandleOpaqueResize(ptr)\n        }\n        return result\n    }\n    public func splitter(): QSplitter {\n        let result = unsafe {\n            nativeSplitterHandleSplitter(ptr)\n        }\n        return QSplitter()\n    }\n    public func sizeHint(): QSize {\n        let result = unsafe {\n            nativeSplitterHandleSizeHint(ptr)\n        }\n        return QSize(result)\n    }\n}", "llm_cg": {"main": [], "QSplitterHandle": ["nativeSplitterHandleCreate", "<builtin>.Int32", "nativeSplitterHandleDelete", "nativeSplitterHandleSetOrientation", "nativeSplitterHandleOrientation", "nativeSplitterHandleOpaqueResize", "nativeSplitterHandleSplitter", "QSplitter", "nativeSplitterHandleSizeHint", "QSize"], "QSplitterHandle.init": [], "QSplitterHandle.delete": [], "QSplitterHandle.setOrientation": [], "QSplitterHandle.orientation": [], "QSplitterHandle.opaqueResize": [], "QSplitterHandle.splitter": [], "QSplitterHandle.sizeHint": []}, "static_cg": {}}
{"source_code": "package maker\n// ----\n// ip2region database v2.0 structure\n//\n// +----------------+-------------------+---------------+--------------+\n// | header space   | speed up index    |  data payload | block index  |\n// +----------------+-------------------+---------------+--------------+\n// | 256 bytes      | 512 KiB (fixed)   | dynamic size  | dynamic size |\n// +----------------+-------------------+---------------+--------------+\n//\n// 1. padding space : for header info like block index ptr, version, release date eg ... or any other temporary needs.\n// -- 2bytes: version number, different version means structure update, it fixed to 2 for now\n// -- 2bytes: index algorithm code.\n// -- 4bytes: generate unix timestamp (version)\n// -- 4bytes: index block start ptr\n// -- 4bytes: index block end ptr\n//\n//\n// 2. data block : region or whatever data info.\n// 3. segment index block : binary index block.\n// 4. vector index block  : fixed index info for block index search speed up.\n// space structure table:\n// -- 0   -> | 1rt super block | 2nd super block | 3rd super block | ... | 255th super block\n// -- 1   -> | 1rt super block | 2nd super block | 3rd super block | ... | 255th super block\n// -- 2   -> | 1rt super block | 2nd super block | 3rd super block | ... | 255th super block\n// -- ...\n// -- 255 -> | 1rt super block | 2nd super block | 3rd super block | ... | 255th super block\n//\n//\n// super block structure:\n// +-----------------------+----------------------+\n// | first index block ptr | last index block ptr |\n// +-----------------------+----------------------+\n//\n// data entry structure:\n// +--------------------+-----------------------+\n// | 2bytes (for desc)\t| dynamic length        |\n// +--------------------+-----------------------+\n//  data length   whatever in bytes\n//\n// index entry structure\n// +------------+-----------+---------------+------------+\n// | 4bytes     | 4bytes    | 2bytes        | 4 bytes    |\n// +------------+-----------+---------------+------------+\n//  start ip \t  end ip\t  data length     data ptr\npublic class Maker {\n    let srcHandle: File\n    let dstHandle: File\n    let indexPolicy: IndexPolicy\n    var segments: Array<Segment> = []\n    let regionPool: HashMap<String, UInt32> = HashMap<String, UInt32>()\n    let vectorIndex: Array<UInt8> = Array<UInt8>(VectorIndexLength, item: 0)\n    let header: Header\n    public init(indexPolicy: IndexPolicy, srcFile: String, dstFile: String) {\n        this.srcHandle = try {\n            let f = File(srcFile, OpenOption.Open(true, false))\n            if (!f.canRead()) {\n                throw Exception(\"file can not read\")\n            }\n            f\n        } catch (e: Exception) {\n            throw Exception(\"open source file `${srcFile}`: ${e.toString()}\")\n        }\n        this.dstHandle = try {\n            let f = File(dstFile, OpenOption.CreateOrTruncate(true))\n            if (!f.canWrite()) {\n                throw Exception(\"file can not write\")\n            }\n            f\n        } catch (e: Exception) {\n            throw Exception(\"open target file `${dstFile}`: ${e.toString()}\")\n        }\n        this.indexPolicy = indexPolicy\n        this.header = Header(UInt16(VersionNo), this.indexPolicy, UInt32(DateTime.now().toUnixTimeStamp().toSeconds()),\n            0, 0)\n        this.initDbHeader()\n    }\n    func initDbHeader() {\n        this.dstHandle.seek(Begin(0))\n        this.header.writeTo(this.dstHandle)\n    }\n    func loadSegments() {\n        let segments = ArrayList<Segment>()\n        let last: Box<?Segment> = Box<?Segment>(None)\n        iterateSegments(\n            this.srcHandle,\n            None,\n            {\n                seg =>\n                seg.afterCheck(last.value)\n                segments.append(seg)\n                last.value = seg\n            }\n        )\n        this.segments = segments.toArray()\n    }\n    func setVectorIndex(ip: UInt32, ptr: UInt32) {\n        let il0 = (ip >> 24) & 0xFF\n        let il1 = (ip >> 16) & 0xFF\n        let idx = Int64(il0 * UInt32(VectorIndexCols) * UInt32(VectorIndexSize) + il1 * UInt32(VectorIndexSize))\n        let sPtr = littleEndianUInt32(this.vectorIndex[idx..(idx + 4)])\n        if (sPtr == 0) {\n            littleEndianPutUInt32(this.vectorIndex[idx..(idx + 4)], ptr)\n            littleEndianPutUInt32(this.vectorIndex[(idx + 4)..(idx + 8)], ptr + UInt32(SegmentIndexBlockSize))\n        } else {\n            littleEndianPutUInt32(this.vectorIndex[(idx + 4)..(idx + 8)], ptr + UInt32(SegmentIndexBlockSize))\n        }\n    }\n    public func start() {\n        this.loadSegments()\n        if (this.segments.size == 0) {\n            throw Exception(\"empty segment list\")\n        }\n        try {\n            this.dstHandle.seek(Begin(HeaderInfoLength + VectorIndexLength))\n        } catch (e: Exception) {\n            throw Exception(\"seek to data first ptr: ${e.toString()}\")\n        }\n        for (seg in this.segments) {\n            if (this.regionPool.contains(seg.region)) {\n                continue\n            }\n            let region = seg.region.toArray()\n            if (region.size > 0xFFFF) {\n                throw Exception(\"too long region info `${seg.region}`: should be less than ${0xFFFF} bytes\")\n            }\n            let pos = try {\n                this.dstHandle.seek(Current(0))\n            } catch (e: Exception) {\n                throw Exception(\"seek to current ptr: ${e.toString()}\")\n            }\n            try {\n                this.dstHandle.write(region)\n            } catch (e: Exception) {\n                throw Exception(\"write region '${seg.region}': ${e.toString()}\")\n            }\n            this.regionPool[seg.region] = UInt32(pos)\n        }\n        let indexBuff = Array<UInt8>(SegmentIndexBlockSize, item: 0)\n        var (counter, startIndexPtr, endIndexPtr) = (0, -1, -1)\n        for (seg in this.segments) {\n            if (!this.regionPool.contains(seg.region)) {\n                throw Exception(\"missing ptr cache for region `${seg.region}`\")\n            }\n            let dataLen = seg.region.size\n            if (dataLen == 0) {\n                throw Exception(\"empty region info for segment '${seg}'\")\n            }\n            let dataPtr = this.regionPool[seg.region]\n            let segList = seg.split()\n            for (s in segList) {\n                let pos = try {\n                    this.dstHandle.seek(Current(0))\n                } catch (e: Exception) {\n                    throw Exception(\"seek to segment index block: ${e.toString()}\")\n                }\n                littleEndianPutUInt32(indexBuff[0..4], s.startIP)\n                littleEndianPutUInt32(indexBuff[4..8], s.endIP)\n                littleEndianPutUInt16(indexBuff[8..10], UInt16(dataLen))\n                littleEndianPutUInt32(indexBuff[10..14], dataPtr)\n                try {\n                    this.dstHandle.write(indexBuff)\n                } catch (e: Exception) {\n                    throw Exception(\"write segment index for '${s}': ${e.toString()}\")\n                }\n                this.setVectorIndex(s.startIP, UInt32(pos))\n                counter++\n                if (startIndexPtr == -1) {\n                    startIndexPtr = pos\n                }\n                endIndexPtr = pos\n            }\n        }\n        try {\n            this.dstHandle.seek(Begin(HeaderInfoLength))\n        } catch (e: Exception) {\n            throw Exception(\"seek vector index first ptr: ${e.toString()}\")\n        }\n        try {\n            this.dstHandle.write(this.vectorIndex)\n        } catch (e: Exception) {\n            throw Exception(\"write vector index: ${e.toString()}\")\n        }\n        try {\n            this.dstHandle.seek(Begin(8))\n        } catch (e: Exception) {\n            throw Exception(\"seek segment index ptr: ${e.toString()}\")\n        }\n        littleEndianPutUInt32(indexBuff[0..4], UInt32(startIndexPtr))\n        littleEndianPutUInt32(indexBuff[4..8], UInt32(endIndexPtr))\n        try {\n            this.dstHandle.write(indexBuff[0..8])\n        } catch (e: Exception) {\n            throw Exception(\"write segment index ptr: ${e.toString()}\")\n        }\n    }\n    public func end() {\n        this.dstHandle.close()\n        this.srcHandle.close()\n    }\n}", "llm_cg": {"main": [], "Maker": ["File", "Exception", "Array", "HashMap", "Header"], "Maker.init": ["File", "OpenOption.Open", "File.canRead", "Exception", "OpenOption.CreateOrTruncate", "File.canWrite", "Exception", "Header", "UInt16", "UInt32", "DateTime.now", "DateTime.toUnixTimeStamp", "DateTime.toSeconds", "Maker.initDbHeader"], "Maker.initDbHeader": ["File.seek", "Header.writeTo"], "Maker.loadSegments": ["ArrayList", "Box", "File.iterateSegments", "Segment.afterCheck", "ArrayList.append", "ArrayList.toArray"], "Maker.setVectorIndex": ["littleEndianUInt32", "littleEndianPutUInt32"], "Maker.start": ["Segment.size", "File.seek", "Exception", "File.contains", "Segment.region.toArray", "Array.size", "File.write", "File.seek", "Segment.split", "Maker.setVectorIndex", "File.write", "File.seek", "File.write"], "Maker.end": ["File.close", "File.close"]}, "static_cg": {}}
{"source_code": "package glide\npublic class LinkedEntry<K, V> <: Equatable<LinkedEntry<K, V>> where K <: Equatable<K> & Hashable & ToString {\n    public var key: Option<K> = None;\n    private var values: ArrayList<V> = ArrayList<V>();\n    public var next: Option<LinkedEntry<K, V>> = None;\n    public var prev: Option<LinkedEntry<K, V>> = None;\n    // Used only for the first item in the list which we will treat specially and which will not\n    // contain a value.\n    public init() {\n      this(Option<K>.None);\n    }\n    public init(key: Option<K>) {\n        this.key = key;\n        this.next = Some(this)\n        this.prev = Some(this)\n    }\n    public func removeLast(): Option<V> {\n      let valueSize: Int64 = size();\n      return if(valueSize > 0) {\n        this.values.remove(valueSize - 1)\n      } else {\n        None\n      };\n    }\n    public func size(): Int64 {\n      return this.values.size\n    }\n    public func add(value: V): Unit {\n      this.values.append(value);\n    }\n    public operator func ==(right: LinkedEntry<K, V>): Bool {\n        return equals(right)\n    }\n    public operator func !=(right: LinkedEntry<K, V>): Bool {\n      return !equals(right)\n    }\n    public func equals(right: LinkedEntry<K, V>): Bool {\n        if(match(this.key) {\n            case Some(x) => true\n            case _ => false\n        } && match(right.key) {\n                case Some(x) => true\n                case _ => false\n            }) {\n            return this.key.getOrThrow() == right.key.getOrThrow()\n        } else if(match(this.key) {\n            case Some(x) => false\n            case _ => true\n        } && match(right.key) {\n                case Some(x) => false\n                case _ => true\n            }) {\n                return true\n        } else {\n            return false\n        }\n    }\n    public func toString(): String {\n        return if(match(this.key) {\n            case Some(x) => true\n            case _ => false\n        }) {\"None\"} else {this.key.getOrThrow().toString()}\n    }\n  }\npublic class GroupedLinkedMap<K, V> where K <: Poolable & Hashable & Equatable<K> & ToString {\n  private let head: LinkedEntry<K, V> = LinkedEntry<K, V>();\n  private let keyToEntry: HashMap<K, LinkedEntry<K, V>>  = HashMap<K, LinkedEntry<K, V>>();\n  public func put(key: K, value: V): Unit {\n    var entry: Option<LinkedEntry<K, V>> = keyToEntry.get(key);\n    if(match(entry) {\n        case Some(x) => false\n        case _ => true\n    }) {\n      entry = Some(LinkedEntry<K, V>(Some(key)));\n      makeTail(entry.getOrThrow());\n      let b = keyToEntry.put(key, entry.getOrThrow());\n    } else {\n      key.offer();\n    }\n    entry.getOrThrow().add(value);\n  }\n  public func get(key: K): Option<V> {\n    var entry: Option<LinkedEntry<K, V>> = keyToEntry.get(key);\n    if (match(entry) {\n        case Some(x) => false\n        case _ => true\n    }) {\n      entry = Some(LinkedEntry<K, V>(Some(key)))\n      let b = keyToEntry.put(key, entry.getOrThrow());\n    } else {\n      key.offer();\n    }\n    let en = entry.getOrThrow()\n    makeHead(en);\n    return en.removeLast();\n  }\n  public func removeLast(): Option<V> {\n    var last: LinkedEntry<K, V> = head.prev.getOrThrow();\n    while (!last.equals(head)) {\n      let removed: Option<V> = last.removeLast();\n      if (match(removed) {\n        case Some(x) => true\n        case _ => false\n      }) {\n        return removed;\n      } else {\n        // We will clean up empty lru entries since they are likely to have been one off or\n        // unusual sizes and\n        // are not likely to be requested again so the gc thrash should be minimal. Doing so will\n        // speed up our\n        // removeLast operation in the future and prevent our linked list from growing to\n        // arbitrarily large\n        // sizes.\n        removeEntry(last);\n        keyToEntry.remove(last.key.getOrThrow());\n        last.key.getOrThrow().offer();\n      }\n      last = last.prev.getOrThrow();\n    }\n    return None;\n  }\n  public func toString(): String {\n    var sb: StringBuilder = StringBuilder(\"GroupedLinkedMap( \");\n    var current: LinkedEntry<K, V> = head.next.getOrThrow();\n    var hadAtLeastOneItem: Bool  = false;\n    while (!current.equals(head)) {\n      hadAtLeastOneItem = true;\n      //适配\n      //sb.append('{').append(current.key.getOrThrow()).append(':').append(current.size()).append(\"}, \");\n      sb.append('{')\n      sb.append(current.key.getOrThrow())\n      sb.append(':')\n      sb.append(current.size())\n      sb.append(\"}, \")\n      current = current.next.getOrThrow();\n    }\n    if (hadAtLeastOneItem) {\n        let r = Range<Int64>(sb.size - 2, sb.size, 1, true, false, true)\n        //适配\n        //sb.remove(r);\n        var strTemp = sb.toString()\n        let r2: Range<Int64> = 0 .. sb.size - 2\n        var subStrTemp = strTemp[r2]\n        sb = StringBuilder(subStrTemp)\n    }\n    return sb.append(\" )\").toString();\n  }\n  // Make the entry the most recently used item.\n  private func makeHead(entry: LinkedEntry<K, V>): Unit {\n    removeEntry<K, V>(entry);\n    entry.prev = head;\n    entry.next = head.next;\n    updateEntry<K, V>(entry);\n  }\n  // Make the entry the least recently used item.\n  private func makeTail(entry: LinkedEntry<K, V>): Unit {\n    removeEntry<K, V>(entry);\n    entry.prev = head.prev;\n    entry.next = head;\n    updateEntry<K, V>(entry);\n  }\n  private static func updateEntry<K, V>(entry: LinkedEntry<K, V>) where K <: Poolable & Hashable & Equatable<K> & ToString {\n    entry.next.getOrThrow().prev = Some(entry);\n    entry.prev.getOrThrow().next = Some(entry);\n  }\n  private static func removeEntry<K, V>(entry: LinkedEntry<K, V>) where K <: Poolable & Hashable & Equatable<K> & ToString  {\n    entry.prev.getOrThrow().next = entry.next;\n    entry.next.getOrThrow().prev = entry.prev;\n  }\n}", "llm_cg": {"main": [], "LinkedEntry": ["LinkedEntry.<init>", "LinkedEntry.<init>", "LinkedEntry.removeLast", "LinkedEntry.size", "LinkedEntry.add", "LinkedEntry.==", "LinkedEntry.!=", "LinkedEntry.equals", "LinkedEntry.toString"], "LinkedEntry.<init>": ["Option.None", "Some"], "LinkedEntry.removeLast": ["LinkedEntry.size", "this.values.remove"], "LinkedEntry.size": [], "LinkedEntry.add": ["this.values.append"], "LinkedEntry.==": ["LinkedEntry.equals"], "LinkedEntry.!=": ["LinkedEntry.equals", "<builtin>."], "LinkedEntry.equals": ["<builtin>.<option>.getOrThrow", "<builtin>.", "<builtin>.<option>.getOrThrow"], "LinkedEntry.toString": ["<builtin>."], "GroupedLinkedMap": ["LinkedEntry.<init>", "HashMap.<init>", "GroupedLinkedMap.put", "GroupedLinkedMap.get", "GroupedLinkedMap.removeLast", "GroupedLinkedMap.toString", "GroupedLinkedMap.makeHead", "GroupedLinkedMap.makeTail"], "GroupedLinkedMap.put": ["HashMap.get", "Some", "LinkedEntry.<init>", "GroupedLinkedMap.makeTail", "HashMap.put", "<builtin>.offer", "LinkedEntry.add", "Option.getOrThrow"], "GroupedLinkedMap.get": ["HashMap.get", "Some", "LinkedEntry.<init>", "HashMap.put", "<builtin>.offer", "Option.getOrThrow", "GroupedLinkedMap.makeHead", "LinkedEntry.removeLast"], "GroupedLinkedMap.removeLast": ["Option.getOrThrow", "LinkedEntry.equals", "LinkedEntry.removeLast", "GroupedLinkedMap.removeEntry", "HashMap.remove", "Option.getOrThrow", "LinkedEntry.equals", "Option.getOrThrow"], "GroupedLinkedMap.toString": ["StringBuilder.<init>", "Option.getOrThrow", "LinkedEntry.equals", "StringBuilder.append", "Option.getOrThrow", "LinkedEntry.size", "<builtin>.toString", "<builtin>.append", "<builtin>.<range>", "<builtin>.remove", "<builtin>.<range>", "StringBuilder.<init>", "StringBuilder.append", "Option.getOrThrow"], "GroupedLinkedMap.makeHead": ["GroupedLinkedMap.removeEntry", "Option.getOrThrow", "Option.getOrThrow", "GroupedLinkedMap.updateEntry"], "GroupedLinkedMap.makeTail": ["GroupedLinkedMap.removeEntry", "Option.getOrThrow", "Option.getOrThrow", "GroupedLinkedMap.updateEntry"], "GroupedLinkedMap.updateEntry": ["Option.getOrThrow", "Option.getOrThrow"], "GroupedLinkedMap.removeEntry": ["Option.getOrThrow", "Option.getOrThrow"]}, "static_cg": {}}
{"source_code": "package datamatrix.encoder\npublic enum SymbolShapeHint <: Equatable<SymbolShapeHint> & ToString {\n    | FORCE_NONE\n    | FORCE_SQUARE\n    | FORCE_RECTANGLE\n    public func GetSymbolShapeHintNum(result: SymbolShapeHint): Int64 {\n        match (result) {\n            case FORCE_NONE => return 0;\n            case FORCE_SQUARE => return 1;\n            case FORCE_RECTANGLE => return 2;\n        }\n    }\n    public operator func ==(right: SymbolShapeHint): Bool {\n        if (GetSymbolShapeHintNum(right) == GetSymbolShapeHintNum(this)) {\n            true;\n        } else {\n            false;\n        }\n    }\n    public operator func !=(right: SymbolShapeHint): Bool {\n        if (GetSymbolShapeHintNum(right) != GetSymbolShapeHintNum(this)) {\n            true;\n        } else {\n            false;\n        }\n    }\n    public func toString() {\n        match (this) {\n            case FORCE_NONE => \"FORCE_NONE\"\n            case FORCE_SQUARE => \"FORCE_SQUARE\"\n            case FORCE_RECTANGLE => \"FORCE_RECTANGLE\"\n        }\n    }\n}", "llm_cg": {"SymbolShapeHint": [], "SymbolShapeHint.GetSymbolShapeHintNum": [], "SymbolShapeHint.==": ["SymbolShapeHint.GetSymbolShapeHintNum", "SymbolShapeHint.GetSymbolShapeHintNum"], "SymbolShapeHint.!=": ["SymbolShapeHint.GetSymbolShapeHintNum", "SymbolShapeHint.GetSymbolShapeHintNum"], "SymbolShapeHint.toString": []}, "static_cg": {}}
{"source_code": "package barcode\npublic class EAN13Reader <: UPCEANReader {\n    static let FIRST_DIGIT_ENCODINGS = [0x00, 0x0B, 0x0D, 0xE, 0x13, 0x19, 0x1C, 0x15, 0x16, 0x1A]\n    let decodeMiddleCounters: Array<Int64> = Array<Int64>(4, item: 0)\n    protected func decodeMiddle(\n        row: BitArray,\n        startRange: Array<Int64>,\n        resultString: StringBuilder\n    ): Int64 {\n        let counters = decodeMiddleCounters\n        counters[0] = 0\n        counters[1] = 0\n        counters[2] = 0\n        counters[3] = 0\n        let end = row.size\n        var rowOffset = startRange[1]\n        var lgPatternFound = 0\n        for (x in 0..6) {\n            if (rowOffset >= end) {\n                break\n            }\n            let bestMatch = decodeDigit(row, counters, rowOffset, L_AND_G_PATTERNS)\n            resultString.append(Char(UInt32('0') + UInt32(bestMatch % 10)))\n            for (counter in counters) {\n                rowOffset += counter\n            }\n            if (bestMatch >= 10) {\n                lgPatternFound |= 1 << (5 - x)\n            }\n        }\n        determineFirstDigit(resultString, lgPatternFound)\n        let middleRange = findGuardPattern(row, rowOffset, true, MIDDLE_PATTERN)\n        rowOffset = middleRange[1]\n        for (x in 0..6) {\n            if (rowOffset >= end) {\n                break\n            }\n            let bestMatch = decodeDigit(row, counters, rowOffset, L_PATTERNS)\n            resultString.append(Char(UInt32('0') + UInt32(bestMatch)))\n            for (counter in counters) {\n                rowOffset += counter\n            }\n        }\n        rowOffset\n    }\n    func getBarcodeFormat(): BarcodeFormat {\n        return BarcodeFormat.EAN_13\n    }\n    static func determineFirstDigit(resultString: StringBuilder, lgPatternFound: Int64) {\n        for (d in 0..10) {\n            if (lgPatternFound == FIRST_DIGIT_ENCODINGS[d]) {\n                resultString.insert(0, Char(UInt32('0') + UInt32(d)))\n                return\n            }\n        }\n        throw NotFoundException()\n    }\n}\npublic class EAN13Writer <: UPCEANWriter {\n    static let CODE_WIDTH = 3 + // start guard\n    (7 * 6) + // left bars\n    5 + // middle guard\n    (7 * 6) + // right bars\n    3\n    protected override func getSupportedWriteFormats(): ?HashSet<BarcodeFormat> {\n        HashSet<BarcodeFormat>([BarcodeFormat.EAN_13])\n    }\n    public func encode(oContents: String): Array<Bool> {\n        var contents = oContents\n        let length = contents.size\n        match (length) {\n            case 12 =>\n                let check = try {\n                    UPCEANReader.getStandardUPCEANChecksum(contents)\n                } catch (e: FormatException) {\n                    throw IllegalArgumentException(e.toString())\n                }\n                contents = \"${contents}${check}\"\n            case 13 =>\n                try {\n                    if (!UPCEANReader.checkStandardUPCEANChecksum(contents)) {\n                        throw IllegalArgumentException(\"Contents do not pass checksum\")\n                    }\n                } catch (_: FormatException) {\n                    throw IllegalArgumentException(\"Illegal contents\")\n                }\n            case _ =>\n                throw IllegalArgumentException(\"Requested contents should be 12 or 13 digits long, but got ${length}\")\n        }\n        checkNumeric(contents)\n        let firstDigit = charDigit(contents.charAt(0), 10)\n        let parities = EAN13Reader.FIRST_DIGIT_ENCODINGS[firstDigit]\n        let result = Array<Bool>(CODE_WIDTH, item: false)\n        var pos = appendPattern(result, 0, UPCEANReader.START_END_PATTERN, true)\n        for (i in 1..7) {\n            var digit = charDigit(contents.charAt(i), 10)\n            if ((parities >> (6 - i) & 1) == 1) {\n                digit += 10\n            }\n            pos += appendPattern(result, pos, UPCEANReader.L_AND_G_PATTERNS[digit], false)\n        }\n        pos += appendPattern(result, pos, UPCEANReader.MIDDLE_PATTERN, false)\n        for (i in 7..13) {\n            let digit = charDigit(contents.charAt(i), 10)\n            pos += appendPattern(result, pos, UPCEANReader.L_PATTERNS[digit], true)\n        }\n        appendPattern(result, pos, UPCEANReader.START_END_PATTERN, true)\n        result\n    }\n}", "llm_cg": {"EAN13Reader": [], "EAN13Reader.decodeMiddle": ["EAN13Reader.decodeDigit", "StringBuilder.append", "EAN13Reader.determineFirstDigit", "EAN13Reader.findGuardPattern", "EAN13Reader.decodeDigit", "StringBuilder.append"], "EAN13Reader.getBarcodeFormat": [], "EAN13Reader.determineFirstDigit": ["StringBuilder.insert", "NotFoundException"], "EAN13Writer": [], "EAN13Writer.getSupportedWriteFormats": ["HashSet"], "EAN13Writer.encode": ["UPCEANReader.getStandardUPCEANChecksum", "IllegalArgumentException", "UPCEANReader.checkStandardUPCEANChecksum", "IllegalArgumentException", "checkNumeric", "charDigit", "charDigit", "EAN13Reader.FIRST_DIGIT_ENCODINGS", "appendPattern", "charDigit", "appendPattern", "appendPattern", "charDigit", "appendPattern", "appendPattern"]}, "static_cg": {}}
{"source_code": "package api.metric\nimport api.resource.Attributes\npublic interface ILongHistogram {\n    //grouping 只允许正值\n    func record(value: Int64): Unit\n    //grouping 只允许正值\n    func record(value: Int64, tags: Attributes): Unit\n}", "llm_cg": {}, "static_cg": {}}
{"source_code": "package compress4cj.compressors.bzip2\npublic interface BZip2Constants {\n    static prop BASEBLOCKSIZE: Int64 {\n        get() {\n            100000\n        }\n    }\n    static prop MAX_ALPHA_SIZE: Int64 {\n        get() {\n            258\n        }\n    }\n    static prop MAX_CODE_LEN: Int64 {\n        get() {\n            23\n        }\n    }\n    static prop RUNA: Int64 {\n        get() {\n            0\n        }\n    }\n    static prop RUNB: Int64 {\n        get() {\n            1\n        }\n    }\n    static prop N_GROUPS: Int64 {\n        get() {\n            6\n        }\n    }\n    static prop G_SIZE: Int64 {\n        get() {\n            50\n        }\n    }\n    static prop N_ITERS: Int64 {\n        get() {\n            4\n        }\n    }\n    static prop MAX_SELECTORS: Int64 {\n        get() {\n            2 + (900000 / G_SIZE)\n        }\n    }\n    static prop NUM_OVERSHOOT_BYTES: Int64 {\n        get() {\n            20\n        }\n    }\n}", "llm_cg": {}, "static_cg": {}}
{"source_code": "package s3client.util\npublic class ToStringUtils {\n    public static func listToString<T>(values: Iterable<T>): String {\n        let str = values |> map<T, String> {v => toString(v)} |> collectString<String>(delimiter: \", \")\n        return \"[\" + str + \"]\"\n    }\n    public static func mapToString<K, V>(kvs: Iterable<(K, V)>): String {\n        let str = kvs |> map<(K, V), String> {\n            kv =>\n            let k = toString(kv[0])\n            let v = toString(kv[1])\n            k + \":\" + v\n        } |> collectString<(String)>(delimiter: \", \")\n        return \"{\" + str + \"}\"\n    }\n    public static func mapToString2<K, V>(kvs: ?Map<K, V>): ?String where K <: ToString & Equatable<K>, V <: ToString {\n        return match (kvs) {\n            case Some(_kvs) => mapToString(_kvs)\n            case None => None\n        }\n    }\n    private static func toString<T>(v: T): String {\n        return match (v) {\n            case v1: ToString => v1.toString()\n            // 主要给 S3MultiValueMap 使用, 现在也都是 Collection<String>\n            case v2: Iterable<String> => \"[\" + (v2 |> collectString<String>(delimiter: \", \")) + \"]\"\n            case _ => \"<!ToString(${TypeInfo.of(v)})>\"\n        }\n    }\n    public static func exceptionToString(ex: Exception): String {\n        var sb = StringBuilder()\n        sb.append(ex.toString())\n        sb.append(IOUtils.LINE_SEPARATOR)\n        let stacks = ex.getStackTrace()\n        for (i in 0..stacks.size) {\n            let stack = stacks[i]\n            sb.append(\"\\t at ${stack.declaringClass} ${stack.methodName} (${stack.fileName}:${stack.lineNumber})\")\n            sb.append(IOUtils.LINE_SEPARATOR)\n        }\n        return sb.toString()\n    }\n}", "llm_cg": {"ToStringUtils": [], "ToStringUtils.listToString": ["ToStringUtils.toString", "collectString", "map"], "ToStringUtils.mapToString": ["ToStringUtils.toString", "collectString", "map"], "ToStringUtils.mapToString2": ["ToStringUtils.mapToString"], "ToStringUtils.toString": ["TypeInfo.of", "collectString"], "ToStringUtils.exceptionToString": ["IOUtils.LINE_SEPARATOR", "<builtin>.range", "ex.getStackTrace", "ex.toString", "sb.append"]}, "static_cg": {}}
{"source_code": "open class Super {}\n// Sub 为Super的子类型\nclass Sub <: Super {}\nmain() {\n}", "llm_cg": {"main": [], "Super": [], "Sub": []}, "static_cg": {}}
{"source_code": "package mimetype\nfunc isShp(raw: Array<UInt8>, _: UInt32): Bool {\n    if (raw.size < 112) {\n        false\n    } else if (!(bigEndianUInt32(raw[0..4]) == 9994 && bigEndianUInt32(raw[4..8]) == 0 && bigEndianUInt32(raw[8..12]) ==\n        0 && bigEndianUInt32(raw[12..16]) == 0 && bigEndianUInt32(raw[16..20]) == 0 && bigEndianUInt32(raw[20..24]) == 0 &&\n        littleEndianUInt32(raw[28..32]) == 1000)) {\n        false\n    } else {\n        let shapeTypes: Array<Int32> = [\n            0, // Null shape\n            1, // Point\n            3, // Polyline\n            5, // Polygon\n            8, // MultiPoint\n            11, // PointZ\n            13, // PolylineZ\n            15, // PolygonZ\n            18, // MultiPointZ\n            21, // PointM\n            23, // PolylineM\n            25, // PolygonM\n            28, // MultiPointM\n            31 // MultiPatch\n        ]\n        for (st in shapeTypes) {\n            if (st == Int32(littleEndianUInt32(raw[108..112]))) {\n                return true\n            }\n        }\n        false\n    }\n}\nfunc isShx(raw: Array<UInt8>, _: UInt32): Bool {\n    hasPrefix(raw, [0x00, 0x00, 0x27, 0x0A])\n}", "llm_cg": {"main": [], "isShp": ["bigEndianUInt32", "littleEndianUInt32", "<builtin>.len", "<builtin>.range"], "isShx": ["hasPrefix"]}, "static_cg": {}}
{"source_code": "package mp4parser\nimport std.os.posix.*\nimport std.collection.*\nimport std.io.*\nimport std.log.*\npublic class FileUtils {\n    public init() {}\n    let logger: SimpleLogger = SimpleLogger()\n    public func isFilePathValid(filePath: String): (String,String) {\n        let con: Option<Int64> = filePath.lastIndexOf(\"/\")\n        var lastSlash: Int64 = 0\n        match (con) {\n           case Some(v) => lastSlash = v\n           case None => throw Exception(\"Invalid filepath\")\n        }\n        let directoryName: String = filePath[0..lastSlash]\n        let fileName: String = filePath[lastSlash + 1..]\n        let confield: Option<Int64> = fileName.lastIndexOf(\".\")\n        var len: Int64 = 0\n        match (confield) {\n           case Some(v) => len = v\n           case None => throw Exception(\"Invalid filepath. Need to include filename\")\n        }\n        let fields: String = fileName[len + 1..]\n        logger.info(\"isFilePathValid lastSlash INDEX : \"+\"${lastSlash}\"+\" directoryName : \"+\"${directoryName}\"+\" fileName : \"+\"${fileName}\")\n        let isFile: Bool = isReg(fileName)\n        let isDir: Bool = isDir(directoryName)\n        if (!isFile) {\n            logger.info(\"isFilePathValid isFile is  \" + \"${isFile}\")\n            throw Exception(\"${fileName}\" + \" not normal file\")\n        }\n        if (!isDir) {\n            logger.info(\"isFilePathValid isDir is  \" + \"${isDir}\")\n            throw Exception(\"isFilePathValid invalid directory\")\n        }\n        logger.info(\"isFilePathValid filePath is valid\")\n        logger.flush()\n        return (fileName,fields)\n    }\n}", "llm_cg": {"FileUtils": [], "FileUtils.isFilePathValid": ["filePath.lastIndexOf", "logger.info", "isReg", "isDir", "logger.flush"]}, "static_cg": {}}
{"source_code": "// EXEC: cjc %import-path %L %l %f\n// EXEC: ./main\nfrom mp3tag4cj import mp3tag4cj.*\nfrom std import io.*\nfrom std import collection.*\nfrom charset import charset.*\nfrom charset import charset.singlebyte.*\nfrom charset import charset.encoding.*\nmain() {\n    var mp3file:Mp3File=Mp3File(\"../../../test/LLT/bugfix/testfiles/v1andv24tags.mp3\")\n    try {\n        mp3file.save(\"../../../test/LLT/nodir/testfiles/save_v1andv24tags.mp3\")\n    } catch(e: Exception){\n        if (e.toString() != \"FSException: The path `../../../test/LLT/nodir/testfiles` does not exist.\"){\n            return 1\n        }\n    }\n    0\n}", "llm_cg": {"main": ["Mp3File", "mp3file.save", "e.toString"]}, "static_cg": {}}
{"source_code": "package qrcode.detector\nimport common.Qrcoder4cjNotFoundException\nimport common.ResultPointCallback\nimport common.BitMatrix\nfrom std import collection.*\npublic class AlignmentPatternFinder {\n    private var image: BitMatrix = BitMatrix();\n    private var possibleCenters: ArrayList<AlignmentPattern> = ArrayList<AlignmentPattern>();\n    private var startX: Int64 = 0;\n    private var startY: Int64 = 0;\n    private var width: Int64 = 0;\n    private var height: Int64 = 0;\n    private var moduleSize: Float32 = 0.0f32;\n    private var crossCheckStateCount: Array<Int64> = Array<Int64>();\n    private var resultPointCallback: ?ResultPointCallback = None\n    init(\n        image: BitMatrix,\n        startX: Int64,\n        startY: Int64,\n        width: Int64,\n        height: Int64,\n        moduleSize: Float32,\n        resultPointCallback: ?ResultPointCallback\n    ) {\n        this.image = image\n        this.possibleCenters = ArrayList<AlignmentPattern>(5)\n        this.startX = startX\n        this.startY = startY\n        this.width = width\n        this.height = height\n        this.moduleSize = moduleSize\n        this.crossCheckStateCount = Array<Int64>(3, item: 0)\n        this.resultPointCallback = resultPointCallback\n    }\n    func find(): AlignmentPattern {\n        let startX: Int64 = this.startX;\n        let height: Int64 = this.height;\n        let maxJ: Int64 = startX + width\n        let middleI: Int64 = startY + (height / 2)\n        // We are looking for black/white/black modules in 1:1:1 ratio;\n        // this tracks the number of black/white/black modules seen so far\n        var stateCount: Array<Int64> = Array<Int64>(3, item: 0);\n        for (iGen in 0..height) {\n            // Search from middle outwards\n            let iGenResult: Int64 = if ((iGen & 0x01) == 0) {\n                (iGen + 1) / 2\n            } else {\n                -(iGen + 1) / 2\n            }\n            var i: Int64 = middleI + iGenResult\n            stateCount[0] = 0\n            stateCount[1] = 0\n            stateCount[2] = 0\n            var j: Int64 = startX\n            // Burn off leading white pixels before anything else; if we start in the middle of\n            // a white run, it doesn't make sense to count its length, since we don't know if the\n            // white run continued to the left of the start point\n            while (j < maxJ && !image.get(j, i)) {\n                j++\n            }\n            var currentState: Int64 = 0;\n            while (j < maxJ) {\n                if (image.get(j, i)) {\n                    // Black pixel\n                    var res: Option<AlignmentPattern>\n                    (currentState, res) = exfind(currentState, stateCount, i, j)\n                    if (let Some(con) <- res) {\n                        return con\n                    }\n                } else { // White pixel\n                    if (currentState == 1) { // Counting black pixels\n                        currentState++\n                    }\n                    //currentState++\n                    stateCount[Int64(currentState)] += 1\n                }\n                j++\n            }\n            if (foundPatternCross(stateCount)) {\n                let confirmed: Option<AlignmentPattern> = handlePossibleCenter(stateCount, i, maxJ);\n                if (let Some(con) <- confirmed) {\n                    return con\n                }\n            }\n        }\n        // Hmm, nothing we saw was observed and confirmed twice. If we had\n        // any guess at all, return it.\n        if (!possibleCenters.isEmpty()) {\n            return possibleCenters[0]\n        }\n        throw Qrcoder4cjNotFoundException.getNotFoundInstance();\n    }\n    func exfind(currentState: Int64, stateCount: Array<Int64>, i: Int64, j: Int64): (Int64, Option<AlignmentPattern>) {\n        var currentState_p = currentState\n        if (currentState == 1) { // Counting black pixels\n            stateCount[1] += 1\n        } else {\n            if (currentState_p == 2) { // A winner?\n                if (foundPatternCross(stateCount)) { // Yes\n                    let confirmed: Option<AlignmentPattern> = handlePossibleCenter(stateCount, i, j);\n                    if (let Some(con) <- confirmed) {\n                        return (0, con)\n                    }\n                }\n                stateCount[0] = stateCount[2]\n                stateCount[1] = 1\n                stateCount[2] = 0\n                currentState_p = 1\n            } else {\n                currentState_p++\n                stateCount[Int64(currentState_p)] += 1\n            }\n        }\n        return (currentState_p, None)\n    }\n    private static func centerFromEnd(stateCount: Array<Int64>, end: Int64): Float32 {\n        return Float32(end - stateCount[2]) - Float32(stateCount[1]) / 2.0f32\n    }\n    private func foundPatternCross(stateCount: Array<Int64>): Bool {\n        let moduleSize: Float32 = this.moduleSize;\n        let maxVariance: Float32 = moduleSize / 2.0f32\n        for (i in 0..3) {\n            if (abs(moduleSize - Float32(stateCount[i])) >= maxVariance) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private func crossCheckVertical(\n        startI: Int64,\n        centerJ: Int64,\n        maxCount: Int64,\n        originalStateCountTotal: Int64\n    ): Float32 {\n        let image: BitMatrix = this.image;\n        let maxI: Int64 = image.getHeight();\n        let stateCount: Array<Int64> = crossCheckStateCount\n        stateCount[0] = 0\n        stateCount[1] = 0\n        stateCount[2] = 0\n        // Start counting up from center\n        var i: Int64 = startI\n        while (i >= 0 && image.get(centerJ, i) && stateCount[1] <= maxCount) {\n            stateCount[1] += 1\n            i--\n        }\n        // If already too many modules in this state or ran off the edge:\n        if (i < 0 || stateCount[1] > maxCount) {\n            return Float32.NaN;\n        }\n        while (i >= 0 && !image.get(centerJ, i) && stateCount[0] <= maxCount) {\n            stateCount[0] += 1\n            i--\n        }\n        if (stateCount[0] > maxCount) {\n            return Float32.NaN;\n        }\n        // Now also count down from center\n        i = startI + 1\n        while (i < maxI && image.get(centerJ, i) && stateCount[1] <= maxCount) {\n            stateCount[1] += 1\n            i++\n        }\n        if (i == maxI || stateCount[1] > maxCount) {\n            return Float32.NaN;\n        }\n        while (i < maxI && !image.get(centerJ, i) && stateCount[2] <= maxCount) {\n            stateCount[2] += 1\n            i++\n        }\n        if (stateCount[2] > maxCount) {\n            return Float32.NaN;\n        }\n        let stateCountTotal: Int64 = stateCount[0] + stateCount[1] + stateCount[2]\n        if (5 * abs(stateCountTotal - originalStateCountTotal) >= 2 * originalStateCountTotal) {\n            return Float32.NaN;\n        }\n        return excrossCheckVertical(stateCount, i)\n    }\n    private func excrossCheckVertical(stateCount: Array<Int64>, i: Int64) {\n        if (foundPatternCross(stateCount)) {\n            centerFromEnd(stateCount, i)\n        } else {\n            Float32.NaN\n        }\n    }\n    private func handlePossibleCenter(stateCount: Array<Int64>, i: Int64, j: Int64): Option<AlignmentPattern> {\n        let stateCountTotal: Int64 = stateCount[0] + stateCount[1] + stateCount[2]\n        let centerJ: Float32 = centerFromEnd(stateCount, j);\n        let centerI: Float32 = crossCheckVertical(i, Int64(centerJ), 2 * stateCount[1], stateCountTotal);\n        if (!centerI.isNaN()) {\n            let estimatedModuleSize: Float32 = Float32(stateCount[0] + stateCount[1] + stateCount[2]) / 3.0f32\n            for (i in 0..possibleCenters.size) {\n                // Look for about the same center and module size:\n                if (possibleCenters[i].aboutEquals(estimatedModuleSize, centerI, centerJ)) {\n                    return possibleCenters[i].combineEstimate(centerI, centerJ, estimatedModuleSize);\n                }\n            }\n            // Hadn't found this before; save it\n            let point: AlignmentPattern = AlignmentPattern(centerJ, centerI, estimatedModuleSize);\n            possibleCenters.append(point);\n            if (let Some(res) <- resultPointCallback) {\n                res.foundPossibleResultPoint(point);\n            }\n        }\n        return None\n    }\n}", "llm_cg": {"main": [], "AlignmentPatternFinder": ["ArrayList", "Array", "common.BitMatrix"], "AlignmentPatternFinder.init": ["ArrayList", "Array"], "AlignmentPatternFinder.find": ["<builtin>.abs", "image.get", "possibleCenters.isEmpty", "foundPatternCross", "handlePossibleCenter", "exfind", "Qrcoder4cjNotFoundException.getNotFoundInstance"], "AlignmentPatternFinder.exfind": ["foundPatternCross", "handlePossibleCenter"], "AlignmentPatternFinder.centerFromEnd": [], "AlignmentPatternFinder.foundPatternCross": ["<builtin>.abs"], "AlignmentPatternFinder.crossCheckVertical": ["image.getHeight", "image.get", "<builtin>.abs", "excrossCheckVertical"], "AlignmentPatternFinder.excrossCheckVertical": ["foundPatternCross", "centerFromEnd"], "AlignmentPatternFinder.handlePossibleCenter": ["centerFromEnd", "crossCheckVertical", "possibleCenters.size", "possibleCenters.append"]}, "static_cg": {}}
{"source_code": "package s3client.core\npublic interface S3MetricCollection <: ToString {\n    prop name: String\n    prop creationTime: DateTime\n    func getRecords(): ArrayList<S3MetricRecord>\n    func getChildren(): ArrayList<S3MetricCollection>\n    func addRecord(metric: String, data: ToString): Unit\n    func createChild(name: String): S3MetricCollection\n    static prop EMPTY_COLLECTION: S3MetricCollection {\n        get() {\n            EmptyS3MetricCollection.INSTANCE\n        }\n    }\n    static func create(name: String): S3MetricCollection {\n        return DefaultS3MetricCollection(name)\n    }\n}\nclass DefaultS3MetricCollection <: S3MetricCollection {\n    private let _name: String\n    private let _metrics: Map<String, ArrayList<S3MetricRecord>>\n    private let _children: ArrayList<S3MetricCollection>\n    private let _creationTime: DateTime\n    public init(name: String) {\n        this._name = name\n        this._creationTime = DateTime.now()\n        this._metrics = HashMap<String, ArrayList<S3MetricRecord>>()\n        this._children = ArrayList<S3MetricCollection>()\n    }\n    public prop name: String {\n        get() {\n            return _name\n        }\n    }\n    public prop creationTime: DateTime {\n        get() {\n            return _creationTime\n        }\n    }\n    public func getRecords(): ArrayList<S3MetricRecord> {\n        let records = ArrayList<S3MetricRecord>()\n        for (v in _metrics.values()) {\n            records.appendAll(v)\n        }\n        return records\n    }\n    public func getChildren(): ArrayList<S3MetricCollection> {\n        return _children\n    }\n    public func addRecord(metric: String, data: ToString): Unit {\n        var records = _metrics.get(metric).getOrDefault() {ArrayList<S3MetricRecord>()}\n        if (records.size == 0) {\n            _metrics.put(metric, records)\n        }\n        records.append(S3MetricRecord(metric, data))\n    }\n    public func createChild(name: String): S3MetricCollection {\n        let child = DefaultS3MetricCollection(name)\n        _children.append(child)\n        return child\n    }\n    public func toString(): String {\n        return \"S3MetricCollection(name=${_name}, creationTime=${creationTime}, records=${ToStringUtils.listToString(getRecords())}, children=${ToStringUtils.listToString(_children)})\"\n    }\n}\nclass EmptyS3MetricCollection <: S3MetricCollection {\n    static let INSTANCE = EmptyS3MetricCollection()\n    private let _creationTime = DateTime.now()\n    private static let EMPTY_RECORDS = ArrayList<S3MetricRecord>(0)\n    private static let EMPTY_COLLECTIONS = ArrayList<S3MetricCollection>(0)\n    public prop name: String {\n        get() {\n            return \"EmptyS3MetricCollection\"\n        }\n    }\n    public prop creationTime: DateTime {\n        get() {\n            return _creationTime\n        }\n    }\n    public func getRecords(): ArrayList<S3MetricRecord> {\n        return EMPTY_RECORDS\n    }\n    public func getChildren(): ArrayList<S3MetricCollection> {\n        return EMPTY_COLLECTIONS\n    }\n    public func addRecord(_: String, _: ToString): Unit {\n        return\n    }\n    public func createChild(_: String): S3MetricCollection {\n        return this\n    }\n    public func toString(): String {\n        return \"EmptyS3MetricCollection()\"\n    }\n}", "llm_cg": {"main": [], "S3MetricCollection.create": ["DefaultS3MetricCollection"], "DefaultS3MetricCollection.<init>": ["DateTime.now", "HashMap", "ArrayList"], "DefaultS3MetricCollection.name": [], "DefaultS3MetricCollection.creationTime": [], "DefaultS3MetricCollection.getRecords": ["ArrayList", "_metrics.values"], "DefaultS3MetricCollection.getChildren": [], "DefaultS3MetricCollection.addRecord": ["_metrics.get", "ArrayList", "S3MetricRecord"], "DefaultS3MetricCollection.createChild": ["DefaultS3MetricCollection"], "DefaultS3MetricCollection.toString": ["ToStringUtils.listToString", "getRecords"], "EmptyS3MetricCollection": [], "EmptyS3MetricCollection.name": [], "EmptyS3MetricCollection.creationTime": ["DateTime.now"], "EmptyS3MetricCollection.getRecords": [], "EmptyS3MetricCollection.getChildren": [], "EmptyS3MetricCollection.addRecord": [], "EmptyS3MetricCollection.createChild": [], "EmptyS3MetricCollection.toString": []}, "static_cg": {}}
{"source_code": "package libclang\npublic enum CXChildVisitResult <: Ordinal<CXChildVisitResult> {\n    CXChildVisit_Break\n    | CXChildVisit_Continue\n    | CXChildVisit_Recurse\n    override public prop ordinal: UInt {\n        get() {\n            match (this) {\n                case CXChildVisit_Break => 0\n                case CXChildVisit_Continue => 1\n                case CXChildVisit_Recurse => 2\n            }\n        }\n    }\n    static redef public func fromOrdinal(ordinal: UInt): CXChildVisitResult {\n        match (ordinal) {\n            case 0 => CXChildVisit_Break\n            case 1 => CXChildVisit_Continue\n            case 2 => CXChildVisit_Recurse\n            case invalid => throw IllegalArgumentException(\"Can't create CXChildVisitResult from ${invalid}\")\n        }\n    }\n}", "llm_cg": {}, "static_cg": {}}
{"source_code": "package util\nfrom std import io.{ByteArrayStream, OutputStream, InputStream, BufferedOutputStream}\nfrom std import collection.{HashMap, Map}\nfrom charset import charset.*\nfrom charset import charset.encoding.*\nimport base.exception.UnreachableException\nimport io.ByteCollectionInputStream\npublic class Base64 {\n    private static let tailSymbol = convertCharToByte('=')\n    private static let toBase64 = [\n        'A',\n        'B',\n        'C',\n        'D',\n        'E',\n        'F',\n        'G',\n        'H',\n        'I',\n        'J',\n        'K',\n        'L',\n        'M',\n        'N',\n        'O',\n        'P',\n        'Q',\n        'R',\n        'S',\n        'T',\n        'U',\n        'V',\n        'W',\n        'X',\n        'Y',\n        'Z',\n        'a',\n        'b',\n        'c',\n        'd',\n        'e',\n        'f',\n        'g',\n        'h',\n        'i',\n        'j',\n        'k',\n        'l',\n        'm',\n        'n',\n        'o',\n        'p',\n        'q',\n        'r',\n        's',\n        't',\n        'u',\n        'v',\n        'w',\n        'x',\n        'y',\n        'z',\n        '0',\n        '1',\n        '2',\n        '3',\n        '4',\n        '5',\n        '6',\n        '7',\n        '8',\n        '9',\n        '+',\n        '/'\n    ]\n    private static let fromBase64: Map<Byte, Byte> = {\n         =>\n        let map = HashMap<Byte, Byte>()\n        var i = 0\n        let size = toBase64.size\n        while (i < size) {\n            map[convertCharToByte(i)] = UInt8(i)\n            i++\n        }\n        map\n    }()\n    private static func convertCharToByte(c: Int64): Byte {\n        convertCharToByte(toBase64[c])\n    }\n    private static func convertCharToByte(c: Char): Byte {\n        UInt8(UInt32(c))\n    }\n    private static func encode(data: Array<Byte>): ByteArrayStream {\n        let bytes = ByteArrayStream()\n        let input: InputStream = ByteCollectionInputStream(data)\n        encode(input, bytes)\n        bytes\n    }\n    public static func encode(input: InputStream, output: OutputStream): Unit {\n        let bufout = BufferedOutputStream(output)\n        let bufsize = 128\n        var buf = Array<Byte>(bufsize, item: 0)\n        var enc = Array<Byte>(4, item: 0)\n        var resultLen = 0\n        var tmp = 0\n        var bufLen = input.read(buf)\n        while (bufLen > 0) {\n            var i = 0\n            while (i < bufLen) {\n                var b = buf[i]\n                match (resultLen % 4) {\n                    case 0 =>\n                        enc[0] = convertCharToByte(Int64(b) >> 2)\n                        tmp = Int64(b << 6) >> 2\n                        resultLen++\n                    case 1 =>\n                        enc[1] = convertCharToByte(tmp | (Int64(b) >> 4))\n                        tmp == Int64(b << 4) >> 2\n                        resultLen++\n                    case 2 =>\n                        enc[2] = convertCharToByte(tmp | (Int64(b) >> 6))\n                        tmp == Int64(b << 2) >> 2\n                        enc[3] = convertCharToByte(tmp)\n                        bufout.write(enc)\n                        resultLen += 2\n                    case _ => throw UnreachableException(\"${resultLen} ${tmp} ${enc}\")\n                }\n                i++\n            }\n            bufLen = input.read(buf)\n        }\n        match (resultLen % 4) {\n            case 0 => ()\n            case 1 =>\n                enc[1] = convertCharToByte(tmp)\n                enc[2] = tailSymbol\n                enc[3] = tailSymbol\n                bufout.write(enc)\n            case 2 =>\n                enc[2] = convertCharToByte(tmp)\n                enc[3] = tailSymbol\n                bufout.write(enc)\n            case _ => throw UnreachableException(\"${resultLen} ${tmp} ${enc}\")\n        }\n        bufout.flush()\n    }\n    private static func charsetEncode(data: String, charset: Charset): Array<Byte> {\n        charset.newEncoder().encode(data)\n    }\n    private static func charsetDecode(data: Array<Byte>, charset: Charset): String {\n        charset.newDecoder().decode(data)\n    }\n    public static func encodeToOutputStream(data: Array<Byte>, output: OutputStream): Unit {\n        encode(ByteCollectionInputStream(data), output)\n    }\n    public static func encodeToBytes(data: Array<Byte>): Array<Byte> {\n        encode(data).readToEnd()\n    }\n    public static func encodeToString(data: Array<Byte>): String {\n        String.fromUtf8(encodeToBytes(data))\n    }\n    public static func encodeToOutputStream(data: String, output: OutputStream, charset!: Charset = Charsets.UTF8): Unit {\n        encodeToOutputStream(charsetEncode(data, charset), output)\n    }\n    public static func encodeToBytes(data: String, charset!: Charset = Charsets.UTF8): Array<Byte> {\n        encodeToBytes(charsetEncode(data, charset))\n    }\n    public static func encodeToString(data: String, charset!: Charset = Charsets.UTF8): String {\n        String.fromUtf8(encodeToBytes(data, charset: charset))\n    }\n    private static func decode(data: Array<Byte>): ByteArrayStream {\n        let bytes = ByteArrayStream()\n        let input: InputStream = ByteCollectionInputStream(data)\n        decode(input, bytes)\n        bytes\n    }\n    public static func decode(input: InputStream, output: OutputStream): Unit {\n        let bufout = BufferedOutputStream(output)\n        let bufsize = 128\n        var buf = Array<Byte>(bufsize, item: 0)\n        var dec = Array<Byte>(3, item: 0)\n        var resultLen = 0\n        var bufLen = input.read(buf)\n        while (bufLen > 0) {\n            var i = 0\n            while (i < bufLen) {\n                var b = buf[i]\n                if (b == tailSymbol) {\n                    let mod = resultLen % 4\n                    if (i + 1 == bufLen && mod == 2) {\n                        input.read(Array<Byte>(1, item: 0))\n                    }\n                    if (mod != 3) {\n                        bufout.write(dec.slice(0, 3 - mod))\n                    }\n                    bufout.flush()\n                    return\n                }\n                let idx = fromBase64[b]\n                match (resultLen % 4) {\n                    case 0 => dec[0] = idx << 2\n                    case 1 =>\n                        dec[0] |= idx >> 4\n                        dec[1] = idx << 4\n                    case 2 =>\n                        dec[1] |= idx >> 2\n                        dec[2] = idx << 6\n                    case 3 =>\n                        dec[2] |= idx\n                        bufout.write(dec)\n                    case _ => throw UnreachableException()\n                }\n                i++\n                resultLen++\n            }\n            bufLen = input.read(buf)\n        }\n        bufout.flush()\n    }\n    public static func decodeToOutputStream(data: Array<Byte>, output: OutputStream): Unit {\n        decode(ByteCollectionInputStream(data), output)\n    }\n    public static func decodeToBytes(data: Array<Byte>): Array<Byte> {\n        decode(data).readToEnd()\n    }\n    public static func decodeToString(data: Array<Byte>, charset!: Charset = Charsets.UTF8): String {\n        charsetDecode(decodeToBytes(data), charset)\n    }\n    public static func decodeToOutputStream(data: String, output: OutputStream): Unit {\n        decodeToOutputStream(data.toArray(), output)\n    }\n    public static func decodeToBytes(data: String): Array<Byte> {\n        decodeToBytes(data.toArray())\n    }\n    public static func decodeToString(data: String, charset!: Charset = Charsets.UTF8): String {\n        charsetDecode(decodeToBytes(data), charset)\n    }\n}", "llm_cg": {"main": [], "Base64": [], "Base64.convertCharToByte": [], "Base64.convertCharToByte_1": [], "Base64.encode": ["io.ByteCollectionInputStream", "Base64.encode", "io.ByteArrayStream"], "Base64.encode_1": ["BufferedOutputStream", "input.read", "convertCharToByte", "convertCharToByte_1", "bufout.write", "base.exception.UnreachableException", "bufout.flush"], "Base64.charsetEncode": ["charset.newEncoder", "charset.newEncoder().encode"], "Base64.charsetDecode": ["charset.newDecoder", "charset.newDecoder().decode"], "Base64.encodeToOutputStream": ["Base64.encode", "io.ByteCollectionInputStream"], "Base64.encodeToBytes": ["Base64.encode", "io.ByteArrayStream.readToEnd"], "Base64.encodeToString": ["Base64.encodeToBytes", "String.fromUtf8"], "Base64.encodeToOutputStream_1": ["Base64.charsetEncode", "Base64.encodeToOutputStream"], "Base64.encodeToBytes_1": ["Base64.charsetEncode", "Base64.encodeToBytes"], "Base64.encodeToString_1": ["Base64.encodeToBytes", "String.fromUtf8"], "Base64.decode": ["io.ByteCollectionInputStream", "Base64.decode", "io.ByteArrayStream"], "Base64.decode_1": ["BufferedOutputStream", "input.read", "bufout.write", "bufout.flush", "base.exception.UnreachableException", "fromBase64.slice"], "Base64.decodeToOutputStream": ["Base64.decode", "io.ByteCollectionInputStream"], "Base64.decodeToBytes": ["Base64.decode", "io.ByteArrayStream.readToEnd"], "Base64.decodeToString": ["Base64.charsetDecode", "Base64.decodeToBytes"], "Base64.decodeToOutputStream_1": ["<builtin>.toArray", "Base64.decodeToOutputStream"], "Base64.decodeToBytes_1": ["<builtin>.toArray", "Base64.decodeToBytes"], "Base64.decodeToString_1": ["Base64.charsetDecode", "Base64.decodeToBytes"]}, "static_cg": {}}
{"source_code": "// DEPENDENCE: ./build.sh\n EXEC: bash build.sh %import-path %L %l ffi-typecast.o\nfrom std import collection.*\nfrom std import io.*\nmain() {\n    var map: MapField<Int64, String> = MapField<Int64, String>()\n    map.put(10, \"10\")\n    map.put(20, \"20\")\n    if(map.isEmpty()) {\n        println(-1)\n        return -1\n    }\n    map.clear()\n    if(!map.isEmpty()) {\n        println(-1)\n        return -1\n    }\n    return 0\n}", "llm_cg": {"main": ["MapField", "MapField.put", "MapField.isEmpty", "<builtin>.println", "MapField.clear"]}, "static_cg": {}}
{"source_code": "package compress4cj.compressors\nimport std.io.InputStream\npublic abstract class CompressorInputStream <: InputStream & Resource {\n    private var bytesRead: Int64 = 0\n    public open prop length: Int64 {\n        get() {\n            -1\n        }\n    }\n    protected func count(read: Int64) {\n        if (read != -1) {\n            bytesRead += read\n        }\n    }\n    protected func pushedBackBytes(pushBack: Int64) {\n        bytesRead -= pushBack\n    }\n    public func getBytesRead(): Int64 {\n        return bytesRead\n    }\n    public func getUncompressedCount(): Int64 {\n        return getBytesRead()\n    }\n    public open func isClosed(): Bool {\n        false\n    }\n    public open func close(): Unit {}\n}", "llm_cg": {"main": [], "compress4cj.compressors.CompressorInputStream": [], "compress4cj.compressors.CompressorInputStream.count": [], "compress4cj.compressors.CompressorInputStream.pushedBackBytes": [], "compress4cj.compressors.CompressorInputStream.getBytesRead": [], "compress4cj.compressors.CompressorInputStream.getUncompressedCount": ["compress4cj.compressors.CompressorInputStream.getBytesRead"], "compress4cj.compressors.CompressorInputStream.isClosed": [], "compress4cj.compressors.CompressorInputStream.close": []}, "static_cg": {}}
{"source_code": "package droplet.droplet\npublic class DropletOption<T> <: AnyDropletOptionKey & Equatable<DropletOption<T>> where T <: AnyDropletOptionValue {\n    private static let EMPTY_UPDATER: EmptyUpdater<T> = EmptyUpdater<T>()\n    private let defaultValue: Option<T>\n    private let cacheKeyUpdater: CacheKeyUpdater<T>\n    private var keyBytes: Array<UInt8>\n    private init(key: String, defaultValue: T, cacheKeyUpdater: CacheKeyUpdater<T>) {\n        super(key)\n        this.defaultValue = Some(defaultValue)\n        this.cacheKeyUpdater = cacheKeyUpdater\n        this.keyBytes = key.toArray()\n    }\n    private init(key: String, cacheKeyUpdater: CacheKeyUpdater<T>) {\n        super(key)\n        this.defaultValue = None\n        this.cacheKeyUpdater = cacheKeyUpdater\n        this.keyBytes = key.toArray()\n    }\n    private func getKeyBytes(): Array<UInt8> {\n        return keyBytes;\n    }\n    public func equals<V>(o: Any): Bool where V <: AnyDropletOptionValue {\n        if (o is DropletOption<V>) {\n            var other: DropletOption<V> = (o as DropletOption<V>).getOrThrow();\n            return key == other.key\n        }\n        return false;\n    }\n    private static func emptyUpdater(): CacheKeyUpdater<T> {\n        return EMPTY_UPDATER\n    }\n     func update(value: T, md5: MD5) {\n        cacheKeyUpdater.update(key, value, md5);\n    }\n     func getDefaultValue(): Option<T> {\n        return defaultValue;\n    }\n    public static func disk<V>(key: String, defaultValue: V, cacheKeyUpdater: CacheKeyUpdater<V>): DropletOption<V> where V <: AnyDropletOptionValue {\n        return DropletOption<V>(key, defaultValue, cacheKeyUpdater);\n    }\n    public static func disk<V>(key: String, cacheKeyUpdater: CacheKeyUpdater<V>): DropletOption<V> where V <: AnyDropletOptionValue {\n        return DropletOption<V>(key, cacheKeyUpdater);\n    }\n    public static func memory(key: String, defaultValue: T): DropletOption<T> {\n        return DropletOption<T>(key, defaultValue, emptyUpdater());\n    }\n    public static func memory(key: String): DropletOption<T> {\n        return DropletOption<T>(key, emptyUpdater());\n    }\n    public operator func ==(that: DropletOption<T>): Bool {\n        return key == that.key\n    }\n    public operator func !=(that: DropletOption<T>): Bool {\n        return key != that.key\n    }\n}", "llm_cg": {"DropletOption": [], "DropletOption.<init>#1": ["Some", "toArray"], "DropletOption.<init>#2": ["toArray"], "DropletOption.getKeyBytes": [], "DropletOption.equals": ["getOrThrow"], "DropletOption.emptyUpdater": [], "DropletOption.update": ["cacheKeyUpdater.update"], "DropletOption.getDefaultValue": [], "DropletOption.disk#1": ["DropletOption"], "DropletOption.disk#2": ["DropletOption"], "DropletOption.memory#1": ["DropletOption", "emptyUpdater"], "DropletOption.memory#2": ["DropletOption", "emptyUpdater"], "DropletOption.==": [], "DropletOption.!=": []}, "static_cg": {}}
{"source_code": "package quartz.org.quartz\npublic interface TriggerListener  {\n    func getName() :String\n    func triggerFired(trigger: Trigger, context: JobExecutionContext) : Unit\n    func vetoJobExecution(trigger: Trigger, context: JobExecutionContext) : Bool\n    func triggerMisfired(trigger: Trigger) : Unit\n    func triggerComplete(trigger: Trigger, context: JobExecutionContext, triggerInstructionCode: CompletedExecutionInstruction) : Unit\n}", "llm_cg": {}, "static_cg": {}}
{"source_code": "package proto3\npublic struct ParseComplete <: BackendMessage & Serializable<ParseComplete> {\n    var kind = b'1'\n    var len: Int32 = 4\n    public init() {}\n    public mut func decode(data: Array<UInt8>): Unit {\n        var buf = ByteBuffer(data)\n    }\n    public func encode(): Array<UInt8> {\n        var buf = ByteBuffer()\n        buf.add(kind)\n        buf.add(len)\n        var arr = Array<UInt8>(buf.getBuf())\n        return arr\n    }\n    public func serialize(): DataModel {\n        let t: Char = Char(UInt32(kind))\n        return DataModelStruct().add(field<Char>(\"type\", t)).add(field<Int32>(\"len\", len))\n    }\n    public static func deserialize(dm: DataModel): ParseComplete {\n        var dms = match (dm) {\n            case data: DataModelStruct => data\n            case _ => throw Exception(\"this data is not DataModelStruct\")\n        }\n        var result = ParseComplete()\n        result.kind = Byte.deserialize(dms.get(\"kind\"))\n        result.len = Int32.deserialize(dms.get(\"len\"))\n        return result\n    }\n    public func toString() {\n        return this.serialize().toJson().toJsonString()\n    }\n}", "llm_cg": {"ParseComplete": [], "ParseComplete.decode": ["ByteBuffer"], "ParseComplete.encode": ["ByteBuffer", "ByteBuffer.add", "ByteBuffer.add", "Array", "buf.getBuf"], "ParseComplete.serialize": ["Char", "DataModelStruct", "field", "Char", "field", "Int32"], "ParseComplete.deserialize": ["match", "Exception", "ParseComplete", "Byte.deserialize", "dms.get", "Int32.deserialize", "dms.get"], "ParseComplete.toString": ["this.serialize", "toJson", "toJsonString"]}, "static_cg": {}}
{"source_code": "package chardet4cj\npublic class CodingStateMachine {\n    protected var model: SMModel\n    protected var currentState: Int32\n    protected var currentCharLen: Int32 = 0\n    protected var currentBytePos: Int32 = 0\n    public init(model: SMModel) {\n        this.model = model\n        this.currentState = SMModel.START\n    }\n    public func nextState(c: Byte): Int32 {\n        let byteCls: Int32 = this.model.getClass(c)\n        if (this.currentState == SMModel.START) {\n            this.currentBytePos = 0\n            this.currentCharLen = this.model.getCharLen(byteCls)\n        }\n        this.currentState = this.model.getNextState(byteCls, this.currentState)\n        this.currentBytePos++\n        return this.currentState\n    }\n    public func getCurrentCharLen(): Int32 {\n        return this.currentCharLen\n    }\n    public func reset() {\n        this.currentState = SMModel.START\n    }\n    public func getCodingStateMachine(): String {\n        return this.model.getName()\n    }\n}", "llm_cg": {"CodingStateMachine": [], "CodingStateMachine.init": ["SMModel.START"], "CodingStateMachine.nextState": ["this.model.getClass", "SMModel.START", "this.model.getCharLen", "this.model.getNextState"], "CodingStateMachine.getCurrentCharLen": [], "CodingStateMachine.reset": ["SMModel.START"], "CodingStateMachine.getCodingStateMachine": ["this.model.getName"]}, "static_cg": {}}
{"source_code": "package services.model\npublic class GetInventoryConfigurationRequest <: BaseBucketRequest {\n    public var configurationId = \"\"\n    public func getConfigurationId() {\n        if (configurationId.isEmpty()) {\n            configurationId = \"\"\n        }\n        return configurationId\n    }\n    public func setConfigurationId(configurationId: String) {\n        this.configurationId = configurationId\n    }\n      public init( bucketName:String,  configurationId:String) {\n        super(bucketName)\n        this.configurationId = configurationId\n    }\n}", "llm_cg": {"services.model.GetInventoryConfigurationRequest": [], "services.model.GetInventoryConfigurationRequest.getConfigurationId": ["configurationId.isEmpty"], "services.model.GetInventoryConfigurationRequest.setConfigurationId": [], "services.model.GetInventoryConfigurationRequest.<init>": ["super"]}, "static_cg": {}}
{"source_code": "//已知限制：无法拓展空间\npublic class Deque<T> {\n    var arr: Array<Any> = Array<Any>(2000000, item: 0)\n    //numbers of value\n    public var size: Int64 = 0\n    var head: Int64 = 1000001\n    var tail: Int64 = 1000000\n    public init() {\n        size = 0\n    }\n    public init(max_size: Int64) {\n        arr = Array<Any>(max_size * 2, item: 0)\n        size = 0\n    }\n    public init(initArr: Array<T>) {\n        size = initArr.size\n        tail = size - 1\n        for (i in 0..arr.size) {\n            this.arr[i + 1000001] = initArr[i]\n        }\n    }\n    public init(maxSize: Int64, initArr: Array<T>) {\n        arr = Array<Any>(maxSize, item: 0)\n        size = initArr.size\n        tail += size\n        for (i in 0..arr.size) {\n            this.arr[i + 1000001] = initArr[i]\n        }\n    }\n    public func pushBack(val: T) {\n        this.tail++\n        arr[tail] = val\n        this.size++\n    }\n    public func popBack() {\n        if (size == 0) {\n            try {\n                var exc: IndexOutOfBoundsException = IndexOutOfBoundsException(\"The queue is empty\")\n                throw (exc)\n            } catch (exc: IndexOutOfBoundsException) {\n                println(\"${exc}\");\n            }\n        } else {\n            this.arr[tail] = 0\n            this.tail--\n            this.size--\n        }\n    }\n    public func pushFront(val: T) {\n        if (this.head == 0) {\n            try {\n                throw IndexOutOfBoundsException(\"There are too many elements in the front end of the deque\")\n            } catch (exc: IndexOutOfBoundsException) {\n                println(\"${exc}\")\n            }\n        } else {\n            this.head--\n            this.arr[head] = val\n            this.size++\n        }\n    }\n    public func popFront()\n    {\n        if (size == 0) {\n            try {\n                var exc: IndexOutOfBoundsException = IndexOutOfBoundsException(\"The queue is empty\")\n                throw (exc)\n            } catch (exc: IndexOutOfBoundsException) {\n                println(\"${exc}\");\n            }\n        } else {\n            this.arr[head] = 0\n            this.head++\n            this.size--\n        }\n    }\n    public func front() {\n        return arr[head]\n    }\n    public func back() {\n        return arr[tail]\n    }\n    public func empty(): Bool {\n        return (this.size == 0)\n    }\n    public operator func [](i: Int64) {\n        return arr[i+1000001]\n    }\n}", "llm_cg": {"Deque": [], "Deque.pushBack": [], "Deque.popBack": ["IndexOutOfBoundsException", "println"], "Deque.pushFront": ["IndexOutOfBoundsException", "println"], "Deque.popFront": ["IndexOutOfBoundsException", "println"], "Deque.front": [], "Deque.back": [], "Deque.empty": [], "Deque.[]": []}, "static_cg": {}}
{"source_code": "package redis_sdk.client.api\npublic enum SentinelKeyWord <: ProtocolKeyword {\n    | MYID\n    | MASTERS\n    | MASTER\n    | SENTINELS\n    | SLAVES\n    | REPLICAS\n    | RESET\n    | FAILOVER\n    | REMOVE\n    | SET\n    | MONITOR\n    | GET_MASTER_ADDR_BY_NAME\n    public func getBytes(): Array<Byte> {\n        return name().toArray()\n    }\n    public func name(): String {\n        match (this) {\n            case MYID => \"MYID\"\n            case MASTERS => \"MASTERS\"\n            case MASTER => \"MASTER\"\n            case SENTINELS => \"SENTINELS\"\n            case SLAVES => \"SLAVES\"\n            case REPLICAS => \"REPLICAS\"\n            case RESET => \"RESET\"\n            case FAILOVER => \"FAILOVER\"\n            case REMOVE => \"REMOVE\"\n            case SET => \"SET\"\n            case MONITOR => \"MONITOR\"\n            // 中划线\n            case GET_MASTER_ADDR_BY_NAME => \"GET-MASTER-ADDR-BY-NAME\"\n        }\n    }\n}", "llm_cg": {}, "static_cg": {}}
{"source_code": "// EXEC: cjc %import-path %L %l %f\n// EXEC: ./main\nfrom std import fs.*\nfrom std import sync.*\nfrom gifdrawable4cj import sparkmd5.*\nmain (){\n    var sum: Int64 = tesSparkMD5_01()\n    if (sum != 0) {\n        println(sum)\n        return sum\n    }\n    sum = tesSparkMD5_02()\n    if (sum != 0) {\n        println(sum)\n        return sum\n    }\n    sum = tesSparkMD5_03()\n    if (sum != 0) {\n        println(sum)\n        return sum\n    }\n    return 0\n}\nfunc tesSparkMD5_01(): Int64 {\n    let sparkMD5: SparkMD5 = SparkMD5()\n    sparkMD5.buff = \"123456789\"\n    let str: String = sparkMD5.buff\n    println(str)\n    println(sparkMD5.length)\n    if (str == \"123456789\") {\n        return 0\n    }\n    return 1\n}\nfunc tesSparkMD5_02(): Int64 {\n    let sparkMD5: SparkMD5 = SparkMD5()\n    sparkMD5.buff = \"20231121:123456789\"\n    sparkMD5.length = 18\n    let str: String = sparkMD5.buff\n    println(str)\n    println(sparkMD5.length)\n    if (str == \"20231121:123456789\" && sparkMD5.length == 18) {\n        return 0\n    }\n    return 2\n}\nfunc tesSparkMD5_03(): Int64 {\n    let sparkMD5: SparkMD5 = SparkMD5()\n    sparkMD5.buff = \"20231121:123456789\"\n    sparkMD5.length = 18\n    sparkMD5.hash = Array<Int32>()\n    let str: String = sparkMD5.buff\n    println(sparkMD5.length)\n    println(sparkMD5.hash)\n    if (str == \"20231121:123456789\" && sparkMD5.length == 18 && sparkMD5.hash.size == 0) {\n        return 0\n    }\n    return 3\n}", "llm_cg": {"main": ["tesSparkMD5_01", "<builtin>.println", "tesSparkMD5_02", "tesSparkMD5_03"], "tesSparkMD5_01": ["SparkMD5", "<builtin>.println"], "tesSparkMD5_02": ["SparkMD5", "<builtin>.println"], "tesSparkMD5_03": ["SparkMD5", "Array", "<builtin>.println"]}, "static_cg": {}}
{"source_code": "package drawer\nfrom std import collection.*\nfrom std import objectpool.*\nimport image.*\nimport color.*\nimport internals.model.*\nimport internals.imageutil.*\nlet m = UInt32((1 << 16) - 1)\npublic interface Quantizer {\n    func quantize(p: color.Palette, m: Image): color.Palette\n}\npublic enum Op <: Hashable {\n    Over | Src\n    public func hashCode(): Int64 {\n        match (this) {\n            case Over => 0\n            case Src => 1\n        }\n    }\n    public operator func ==(op: Op): Bool {\n        this.hashCode() == op.hashCode()\n    }\n    public operator func !=(op: Op): Bool {\n        !(this == op)\n    }\n}\npublic interface Drawer {\n    func drawer(dst: ImageI, r: Rectangle, src: Image, sp: Point): (ImageI, Rectangle)\n}\npublic let FloydSteinberg: Drawer = FloydSteinbergClazz()\npublic class FloydSteinbergClazz <: Drawer {\n    public func drawer(dst: ImageI, r: Rectangle, src: Image, sp: Point): (ImageI, Rectangle) {\n        var (dst0, rect0) = clip(dst, r, src, sp, nilImage, nilPoint)\n        if (rect0.empty()) {\n            return (dst0, rect0)\n        }\n        var mDst: ImageI = dst0\n        var mRect: Rectangle = rect0\n        return drawPaletted(mDst, mRect, src, sp, true)\n    }\n}\nfunc clip(dst: ImageI, r: Rectangle, src: Image, sp: Point, mask: Image, mp: Point): (ImageI, Rectangle) {\n    let orig = r.min.clone()\n    var rect = r.intersect(dst.bounds())\n    rect = rect.intersect(src.bounds() + (orig - sp))\n    if (!(mask is NilImage)) {\n        rect = rect.intersect(mask.bounds() + (orig - mp))\n    }\n    let dx = rect.min.x - orig.x\n    let dy = rect.min.y - orig.y\n    if (dx == 0 && dy == 0) {\n        return (dst, rect)\n    }\n    sp.x += dx\n    sp.y += dy\n    if (!(mp is NilPoint)) {\n        mp.x += dx\n        mp.y += dy\n    }\n    return (dst, rect)\n}\nfunc processBackward(dst: Image, r: Rectangle, src: Image, sp: Point): Bool {\n    dst.eq(src) && r.overlaps(r + (sp - r.min)) && (sp.y < r.min.y || (sp.y == r.min.y && sp.x < r.min.x))\n}\npublic func draw(dst: ImageI, r: Rectangle, src: Image, sp: Point, op: Op): (ImageI, Rectangle) {\n    drawMask(dst, r, src, sp, nilImage, Point(), op)\n}\npublic func drawMask(\n    dst: ImageI,\n    r: Rectangle,\n    src: Image,\n    sp: Point,\n    mask: Image,\n    mp: Point,\n    op: Op\n): (ImageI, Rectangle) {\n    var (dst0, rect0) = clip(dst, r, src, sp, mask, mp)\n    if (rect0.empty()) {\n        return (dst0, rect0)\n    }\n    var mDst: ImageI = dst0\n    var mRect: Rectangle = rect0\n    if (mDst is image.RGBA) {\n        let dstx = (mDst as image.RGBA).getOrThrow()\n        if (op == Over) {\n            if (mask is NilImage) {\n                if (src is image.Uniform) {\n                    let src0 = (src as image.Uniform).getOrThrow()\n                    let (sr, sg, sb, sa) = src0.rgba()\n                    if (sa == 0xffff) {\n                        return drawFillSrc(dstx, mRect, sr, sg, sb, sa)\n                    } else {\n                        return drawFillOver(dstx, mRect, sr, sg, sb, sa)\n                    }\n                } else if (src is image.RGBA) {\n                    let src0 = (src as image.RGBA).getOrThrow()\n                    return drawCopyOver(dstx, mRect, src0, sp)\n                } else if (src is image.NRGBA) {\n                    let src0 = (src as image.NRGBA).getOrThrow()\n                    return drawNRGBAOver(dstx, mRect, src0, sp)\n                } else if (src is image.YCbCr) {\n                    let src0 = (src as image.YCbCr).getOrThrow()\n                    if (drawYCbCr(dstx, mRect, src0, sp)) {\n                        return (dstx, mRect)\n                    }\n                } else if (src is image.Gray) {\n                    let src0 = (src as image.Gray).getOrThrow()\n                    return drawGray(dstx, mRect, src0, sp)\n                } else if (src is image.CMYK) {\n                    let src0 = (src as image.CMYK).getOrThrow()\n                    return drawCMYK(dstx, mRect, src0, sp)\n                }\n            } else if (mask is image.Alpha) {\n                if (src is image.Uniform) {\n                    let mask0 = (mask as image.Alpha).getOrThrow()\n                    let src0 = (src as image.Uniform).getOrThrow()\n                    return drawGlyphOver(dstx, mRect, src0, mask0, mp)\n                }\n            }\n        } else {\n            if (mask is NilImage) {\n                if (src is image.Uniform) {\n                    let src0 = (src as image.Uniform).getOrThrow()\n                    let (sr, sg, sb, sa) = src0.rgba()\n                    return drawFillSrc(dstx, mRect, sr, sg, sb, sa)\n                } else if (src is image.RGBA) {\n                    let src0 = (src as image.RGBA).getOrThrow()\n                    return drawCopySrc(dstx, mRect, src0, sp)\n                } else if (src is image.NRGBA) {\n                    let src0 = (src as image.NRGBA).getOrThrow()\n                    return drawNRGBASrc(dstx, mRect, src0, sp)\n                } else if (src is image.YCbCr) {\n                    let src0 = (src as image.YCbCr).getOrThrow()\n                    if (drawYCbCr(dstx, mRect, src0, sp)) {\n                        return (dstx, mRect)\n                    }\n                } else if (src is image.Gray) {\n                    let src0 = (src as image.Gray).getOrThrow()\n                    return drawGray(dstx, mRect, src0, sp)\n                } else if (src is image.CMYK) {\n                    let src0 = (src as image.CMYK).getOrThrow()\n                    return drawCMYK(dstx, mRect, src0, sp)\n                }\n            }\n        }\n        return drawRGBA(dstx, mRect, src, sp, mask, mp, op)\n    } else if (mDst is image.Paletted) {\n        let dst0 = (mDst as image.Paletted).getOrThrow()\n        if (op == Src && mask is NilImage) {\n            if (src is image.Uniform) {\n                let src0 = (src as image.Uniform).getOrThrow()\n                let colorIndex = UInt8(dst0.palette.index(src0.c))\n                var i0 = dst0.pixOffset(mRect.min.x, mRect.min.y)\n                var i1 = i0 + mRect.dx()\n                for (i in i0..i1) {\n                    dst0.pix[i] = colorIndex\n                }\n                let firstRow = dst0.pix[i0..i1]\n                for (_ in (mRect.min.y + 1)..mRect.max.y) {\n                    i0 += dst0.stride\n                    i1 += dst0.stride\n                    firstRow.copyTo(dst0.pix, 0, i0, i1 - i0)\n                }\n                return (dst0, mRect)\n            } else if (!processBackward(dst0, mRect, src, sp)) {\n                return drawPaletted(dst0, mRect, src, sp, false)\n            }\n        }\n    }\n    var x0 = mRect.min.x\n    var x1 = mRect.max.x\n    var dx = 1\n    var y0 = mRect.min.y\n    var y1 = mRect.max.y\n    var dy = 1\n    if (processBackward(mDst, mRect, src, sp)) {\n        x0 = x1 - 1\n        x1 = x0 - 1\n        dx = -1\n        y0 = y1 - 1\n        y1 = y0 - 1\n        dy = -1\n    }\n    var out: color.RGBA64C = color.RGBA64C()\n    var sy = sp.y + y0 - mRect.min.y\n    var my = mp.y + y0 - mRect.min.y\n    var y = y0\n    while (y != y1) {\n        var sx = sp.x + x0 - mRect.min.x\n        var mx = mp.x + x0 - mRect.min.x\n        var x = x0\n        while (x != x1) {\n            var ma = UInt32(m)\n            if (!(mask is NilImage)) {\n                let (_, _, _, a) = mask.at(mx, my).rgba()\n                ma = a\n            }\n            if (ma == 0) {\n                if (op != Over) {\n                    mDst.set(x, y, color.Transparent)\n                }\n            } else if (ma == m && op == Src) {\n                mDst.set(x, y, src.at(sx, sy))\n            } else {\n                let (sr, sg, sb, sa) = src.at(sx, sy).rgba()\n                if (op == Src) {\n                    let (dr, dg, db, da) = mDst.at(x, y).rgba()\n                    let a = m - (sa * ma / m)\n                    out.r = UInt16((dr * a + sr * ma) / m)\n                    out.g = UInt16((dg * a + sg * ma) / m)\n                    out.b = UInt16((db * a + sb * ma) / m)\n                    out.a = UInt16((da * a + sa * ma) / m)\n                } else {\n                    out.r = UInt16(sr * ma / m)\n                    out.g = UInt16(sg * ma / m)\n                    out.b = UInt16(sb * ma / m)\n                    out.a = UInt16(sa * ma / m)\n                }\n                mDst.set(x, y, out)\n            }\n            x += dx\n            sx += dx\n            mx += dx\n        }\n        y += dy\n        sy += dy\n        my += dy\n    }\n    (mDst, mRect)\n}\n@OverflowWrapping\nfunc drawFillOver(dst: image.RGBA, r: Rectangle, sr: UInt32, sg: UInt32, sb: UInt32, sa: UInt32): (image.RGBA, Rectangle) {\n    // The 0x101 is here for the same reason as in drawRGBA.\n    let a = (m - sa) * 0x101\n    var i0 = dst.pixOffset(r.min.x, r.min.y)\n    var i1 = i0 + r.dx() * 4\n    for (_ in r.min.y..r.max.y) {\n        for (i in i0..i1 : 4) {\n            let dr = dst.pix[i + 0]\n            let dg = dst.pix[i + 1]\n            let db = dst.pix[i + 2]\n            let da = dst.pix[i + 3]\n            dst.pix[i + 0] = UInt8((UInt32(dr) * a / m + sr) >> 8)\n            dst.pix[i + 1] = UInt8((UInt32(dg) * a / m + sg) >> 8)\n            dst.pix[i + 2] = UInt8((UInt32(db) * a / m + sb) >> 8)\n            dst.pix[i + 3] = UInt8((UInt32(da) * a / m + sa) >> 8)\n        }\n        i0 += dst.stride\n        i1 += dst.stride\n    }\n    (dst, r)\n}\n@OverflowWrapping\nfunc drawFillSrc(dst: image.RGBA, r: Rectangle, sr: UInt32, sg: UInt32, sb: UInt32, sa: UInt32): (image.RGBA, Rectangle) {\n    let sr8 = UInt8(sr >> 8)\n    let sg8 = UInt8(sg >> 8)\n    let sb8 = UInt8(sb >> 8)\n    let sa8 = UInt8(sa >> 8)\n    // The built-in copy function is faster than a straightforward for loop to fill the destination with\n    // the color, but copy requires a slice source. We therefore use a for loop to fill the first row, and\n    // then use the first row as the slice source for the remaining rows.\n    var i0 = dst.pixOffset(r.min.x, r.min.y)\n    var i1 = i0 + r.dx() * 4\n    for (i in i0..i1 : 4) {\n        dst.pix[i + 0] = sr8\n        dst.pix[i + 1] = sg8\n        dst.pix[i + 2] = sb8\n        dst.pix[i + 3] = sa8\n    }\n    let firstRow = dst.pix[i0..i1]\n    for (_ in (r.min.y + 1)..r.max.y) {\n        i0 += dst.stride\n        i1 += dst.stride\n        firstRow.copyTo(dst.pix, 0, i0, firstRow.size)\n    }\n    (dst, r)\n}\n@OverflowWrapping\nfunc drawCopyOver(dst: image.RGBA, r: Rectangle, src: image.RGBA, sp: Point): (image.RGBA, Rectangle) {\n    let dx = r.dx()\n    var dy = r.dy()\n    var d0 = dst.pixOffset(r.min.x, r.min.y)\n    var s0 = src.pixOffset(sp.x, sp.y)\n    var ddelta = 0\n    var sdelta = 0\n    var idelta = 0\n    var i0 = 0\n    var i1 = 0\n    if (r.min.y < sp.y || r.min.y == sp.y && r.min.x <= sp.x) {\n        ddelta = dst.stride\n        sdelta = src.stride\n        i0 = 0\n        i1 = dx * 4\n        idelta = 4\n    } else {\n        // If the source start point is higher than the destination start point, or equal height but to the left,\n        // then we compose the rows in right-to-left, bottom-up order instead of left-to-right, top-down.\n        d0 += (dy - 1) * dst.stride\n        s0 += (dy - 1) * src.stride\n        ddelta = -dst.stride\n        sdelta = -src.stride\n        i0 = (dx - 1) * 4\n        i1 = -4\n        idelta = -4\n    }\n    let dpix = dst.pix\n    let spix = src.pix\n    while (dy > 0) {\n        var i = i0\n        while (i != i1) {\n            let sr = UInt32(spix[s0 + i + 0]) * 0x101\n            let sg = UInt32(spix[s0 + i + 1]) * 0x101\n            let sb = UInt32(spix[s0 + i + 2]) * 0x101\n            let sa = UInt32(spix[s0 + i + 3]) * 0x101\n            let a = (m - sa) * 0x101\n            dpix[d0 + i + 0] = UInt8((UInt32(dpix[d0 + i + 0]) * a / m + sr) >> 8)\n            dpix[d0 + i + 1] = UInt8((UInt32(dpix[d0 + i + 1]) * a / m + sg) >> 8)\n            dpix[d0 + i + 2] = UInt8((UInt32(dpix[d0 + i + 2]) * a / m + sb) >> 8)\n            dpix[d0 + i + 3] = UInt8((UInt32(dpix[d0 + i + 3]) * a / m + sa) >> 8)\n            i += idelta\n        }\n        dy--\n    }\n    (dst, r)\n}\nfunc drawCopySrc(dst: image.RGBA, r: Rectangle, src: image.RGBA, sp: Point): (image.RGBA, Rectangle) {\n    let n = 4 * r.dx()\n    var dy = r.dy()\n    var d0 = dst.pixOffset(r.min.x, r.min.y)\n    var s0 = src.pixOffset(sp.x, sp.y)\n    var ddelta = 0\n    var sdelta = 0\n    if (r.min.y <= sp.y) {\n        ddelta = dst.stride\n        sdelta = src.stride\n    } else {\n        d0 += (dy - 1) * dst.stride\n        s0 += (dy - 1) * src.stride\n        ddelta = -dst.stride\n        sdelta = -src.stride\n    }\n    while (dy > 0) {\n        for (i in 0..n) {\n            dst.pix[d0 + i] = src.pix[s0 + i]\n        }\n        d0 += ddelta\n        s0 += sdelta\n        dy--\n    }\n    (dst, r)\n}\n@OverflowWrapping\nfunc drawNRGBAOver(dst: image.RGBA, r: Rectangle, src: image.NRGBA, sp: Point): (image.RGBA, Rectangle) {\n    let i0 = (r.min.x - dst.rect.min.x) * 4\n    let i1 = (r.max.x - dst.rect.min.x) * 4\n    let si0 = (sp.x - src.rect.min.x) * 4\n    let yMax = r.max.y - dst.rect.min.y\n    var y = r.min.y - dst.rect.min.y\n    var sy = sp.y - src.rect.min.y\n    let dpix = dst.pix\n    let spix = src.pix\n    while (y != yMax) {\n        let dpis = y * dst.stride\n        let spis = sy * src.stride\n        var i = i0\n        var si = si0\n        while (i < i1) {\n            let sa = UInt32(spix[spis + i + 3]) * 0x101\n            let sr = UInt32(spix[spis + i + 0]) * sa / 0xff\n            let sg = UInt32(spix[spis + i + 1]) * sa / 0xff\n            let sb = UInt32(spix[spis + i + 2]) * sa / 0xff\n            let a = (m - sa) * 0x101\n            dpix[dpis + i + 0] = UInt8((UInt32(dpix[dpis + i + 0]) * a / m + sr) >> 8)\n            dpix[dpis + i + 1] = UInt8((UInt32(dpix[dpis + i + 1]) * a / m + sg) >> 8)\n            dpix[dpis + i + 2] = UInt8((UInt32(dpix[dpis + i + 2]) * a / m + sb) >> 8)\n            dpix[dpis + i + 3] = UInt8((UInt32(dpix[dpis + i + 3]) * a / m + sa) >> 8)\n            i += 4\n            si += 4\n        }\n        y++\n        sy++\n    }\n    (dst, r)\n}\n@OverflowWrapping\nfunc drawNRGBASrc(dst: image.RGBA, r: Rectangle, src: image.NRGBA, sp: Point): (image.RGBA, Rectangle) {\n    let i0 = (r.min.x - dst.rect.min.x) * 4\n    let i1 = (r.max.x - dst.rect.min.x) * 4\n    let si0 = (sp.x - src.rect.min.x) * 4\n    let yMax = r.max.y - dst.rect.min.y\n    var y = r.min.y - dst.rect.min.y\n    var sy = sp.y - src.rect.min.y\n    let dpix = dst.pix\n    let spix = src.pix\n    while (y != yMax) {\n        let dpis = y * dst.stride\n        let spis = sy * src.stride\n        var i = i0\n        var si = si0\n        while (i < i1) {\n            let sa = UInt32(spix[spis + i + 3]) * 0x101\n            let sr = UInt32(spix[spis + i + 0]) * sa / 0xff\n            let sg = UInt32(spix[spis + i + 1]) * sa / 0xff\n            let sb = UInt32(spix[spis + i + 2]) * sa / 0xff\n            dpix[dpis + i + 0] = UInt8(sr >> 8)\n            dpix[dpis + i + 1] = UInt8(sg >> 8)\n            dpix[dpis + i + 2] = UInt8(sb >> 8)\n            dpix[dpis + i + 3] = UInt8(sa >> 8)\n            i += 4\n            si += 4\n        }\n        y++\n        sy++\n    }\n    (dst, r)\n}\nfunc drawGray(dst: image.RGBA, r: Rectangle, src: image.Gray, sp: Point): (image.RGBA, Rectangle) {\n    let i0 = (r.min.x - dst.rect.min.x) * 4\n    let i1 = (r.max.x - dst.rect.min.x) * 4\n    let si0 = (sp.x - src.rect.min.x) * 1\n    let yMax = r.max.y - dst.rect.min.y\n    var y = r.min.y - dst.rect.min.y\n    var sy = sp.y - src.rect.min.y\n    let dpix = dst.pix\n    let spix = src.pix\n    while (y != yMax) {\n        let dpis = y * dst.stride\n        let spis = sy * src.stride\n        var i = i0\n        var si = si0\n        while (i < i1) {\n            let p = spix[spis + i + si]\n            dpix[dpis + i + 0] = p\n            dpix[dpis + i + 1] = p\n            dpix[dpis + i + 2] = p\n            dpix[dpis + i + 3] = 255\n            i += 4\n            si += 4\n        }\n        y++\n        sy++\n    }\n    (dst, r)\n}\nfunc drawCMYK(dst: image.RGBA, r: Rectangle, src: image.CMYK, sp: Point): (image.RGBA, Rectangle) {\n    let i0 = (r.min.x - dst.rect.min.x) * 4\n    let i1 = (r.max.x - dst.rect.min.x) * 4\n    let si0 = (sp.x - src.rect.min.x) * 4\n    let yMax = r.max.y - dst.rect.min.y\n    var y = r.min.y - dst.rect.min.y\n    var sy = sp.y - src.rect.min.y\n    let dpix = dst.pix\n    let spix = src.pix\n    while (y != yMax) {\n        let dpis = y * dst.stride\n        let spis = sy * src.stride\n        var i = i0\n        var si = si0\n        while (i < i1) {\n            let (sr, sg, sb) = color.CMYKToRGB(\n                spix[spis + i + 0],\n                spix[spis + i + 1],\n                spix[spis + i + 2],\n                spix[spis + i + 3]\n            )\n            dpix[dpis + i + 0] = sr\n            dpix[dpis + i + 1] = sg\n            dpix[dpis + i + 2] = sb\n            dpix[dpis + i + 3] = 255\n            i += 4\n            si += 4\n        }\n        y++\n        sy++\n    }\n    (dst, r)\n}\n@OverflowWrapping\nfunc drawGlyphOver(dst: image.RGBA, r: Rectangle, src: image.Uniform, mask: image.Alpha, mp: Point): (image.RGBA,\n    Rectangle) {\n    var i0 = dst.pixOffset(r.min.y, r.min.y)\n    var i1 = i0 + r.dx() * 4\n    var mi0 = mask.pixOffset(mp.x, mp.y)\n    let (sr, _, _, sa) = src.rgba()\n    var y = r.min.y\n    var my = mp.y\n    let dpix = dst.pix\n    while (y != r.max.y) {\n        var i = i0\n        var mi = mi0\n        while (i < i1) {\n            var ma = UInt32(mask.pix[mi])\n            if (ma == 0) {\n                i += 4\n                mi++\n                continue\n            }\n            ma |= ma << 8\n            let a = (m - (sa * ma / m)) * 0x101\n            dpix[i + 0] = UInt8((UInt32(dpix[i + 0]) * a + sr * ma) >> 8)\n            dpix[i + 1] = UInt8((UInt32(dpix[i + 1]) * a + sr * ma) >> 8)\n            dpix[i + 2] = UInt8((UInt32(dpix[i + 2]) * a + sr * ma) >> 8)\n            dpix[i + 3] = UInt8((UInt32(dpix[i + 3]) * a + sr * ma) >> 8)\n            i += 4\n            mi++\n        }\n        i0 += dst.stride\n        i1 += dst.stride\n        mi0 += mask.stride\n        y++\n        my++\n    }\n    (dst, r)\n}\n@OverflowWrapping\nfunc drawRGBA(dst: image.RGBA, r: Rectangle, src: Image, sp: Point, mask: Image, mp: Point, op: Op): (image.RGBA,\n    Rectangle) {\n    var x0 = r.min.x\n    var x1 = r.max.x\n    var dx = 1\n    var y0 = r.min.y\n    var y1 = r.max.y\n    var dy = 1\n    if (dst.eq(src) && r.overlaps(r + (sp - r.min))) {\n        if (sp.y < r.min.y || sp.y == r.min.y && sp.x < r.min.x) {\n            x0 = x1 - 1\n            x1 = x0 - 1\n            dx = -1\n            y0 = y1 - 1\n            y1 = y0 - 1\n            dy = -1\n        }\n    }\n    var sy = sp.y + y0 - r.min.y\n    var my = mp.y + y0 - r.min.y\n    var sx0 = sp.x + x0 - r.min.x\n    var mx0 = mp.x + x0 - r.min.x\n    var sx1 = sx0 + (x1 - x0)\n    var i0 = dst.pixOffset(x0, y0)\n    var di = dx * 4\n    var y = y0\n    let dpix = dst.pix\n    while (y != y1) {\n        var i = i0\n        var sx = sx0\n        var mx = mx0\n        while (sx != sx1) {\n            var ma = m\n            if (!(mask is NilImage)) {\n                let (_, _, _, a) = mask.at(mx, my).rgba()\n                ma = a\n            }\n            let (sr, sg, sb, sa) = src.at(sx, sy).rgba()\n            if (op == Src) {\n                let a = (m - (sa * ma / m)) * 0x101\n                dpix[i + 0] = UInt8((UInt32(dpix[i + 0]) * a + sr * ma) / m >> 8)\n                dpix[i + 1] = UInt8((UInt32(dpix[i + 1]) * a + sr * ma) / m >> 8)\n                dpix[i + 2] = UInt8((UInt32(dpix[i + 2]) * a + sr * ma) / m >> 8)\n                dpix[i + 3] = UInt8((UInt32(dpix[i + 3]) * a + sr * ma) / m >> 8)\n            } else {\n                dpix[i + 0] = UInt8(sr * ma / m >> 8)\n                dpix[i + 1] = UInt8(sg * ma / m >> 8)\n                dpix[i + 2] = UInt8(sb * ma / m >> 8)\n                dpix[i + 3] = UInt8(sa * ma / m >> 8)\n            }\n            i += di\n            sx += dx\n            mx += dx\n        }\n        y += dy\n        sy += dy\n        my += dy\n        i0 += dy * dst.stride\n    }\n    (dst, r)\n}\nfunc clamp(i: Int32): Int32 {\n    if (i < 0) {\n        0\n    } else if (i > 0xffff) {\n        0xffff\n    } else {\n        i\n    }\n}\n@OverflowWrapping\nfunc sqDiff(x: Int32, y: Int32): UInt32 {\n    let d = UInt32(x - y)\n    (d * d) >> 2\n}\nfunc drawPaletted(dst: ImageI, r: Rectangle, src: Image, sp: Point, floydSteinberg: Bool): (ImageI, Rectangle) {\n    var palette: ?Array<Array<Int32>> = None\n    var pixS = 0\n    var stride = 0\n    if (dst is image.Paletted) {\n        let p = (dst as image.Paletted).getOrThrow()\n        let mPalette = Array<Array<Int32>>(p.palette.size(), {_ => Array<Int32>(4, item: 0)})\n        let buf = p.palette.buf\n        for (i in 0..buf.size) {\n            let (rr, g, b, a) = buf[i].rgba()\n            mPalette[i][0] = Int32(rr)\n            mPalette[i][1] = Int32(g)\n            mPalette[i][2] = Int32(b)\n            mPalette[i][3] = Int32(a)\n        }\n        palette = mPalette\n        pixS = p.pixOffset(r.min.x, r.min.y)\n        stride = p.stride\n    } else {\n        throw Exception(\"dst is not image.Paletted type\")\n    }\n    var quantErrorCurr: Array<Array<Int32>>\n    var quantErrorNext: Array<Array<Int32>>\n    if (floydSteinberg) {\n        quantErrorCurr = Array<Array<Int32>>(r.dx() + 2, {_ => Array<Int32>(4, item: 0)})\n        quantErrorNext = Array<Array<Int32>>(r.dx() + 2, {_ => Array<Int32>(4, item: 0)})\n    } else {\n        quantErrorCurr = Array<Array<Int32>>(0, {_ => Array<Int32>(4, item: 0)})\n        quantErrorNext = Array<Array<Int32>>(0, {_ => Array<Int32>(4, item: 0)})\n    }\n    var pxRGBA: (Int64, Int64) -> (UInt32, UInt32, UInt32, UInt32) = {x, y => src.at(x, y).rgba()}\n    if (src is image.RGBA) {\n        let src0 = (src as image.RGBA).getOrThrow()\n        pxRGBA = {x, y => src0.rgbaAt(x, y).rgba()}\n    } else if (src is image.NRGBA) {\n        let src0 = (src as image.NRGBA).getOrThrow()\n        pxRGBA = {x, y => src0.nrgbaAt(x, y).rgba()}\n    } else if (src is image.YCbCr) {\n        let src0 = (src as image.YCbCr).getOrThrow()\n        pxRGBA = {x, y => src0.ycbcrAt(x, y).rgba()}\n    }\n    // let out = color.RGBA64C(0, 0, 0, 0xffff)\n    var y = 0\n    let pixd = (dst as image.Paletted).getOrThrow().pix\n    while (y != r.dy()) {\n        var x = 0\n        while (x != r.dx()) {\n            var (sr, sg, sb, sa) = pxRGBA(sp.x + x, sp.y + y)\n            var (er, eg, eb, ea) = (Int32(sr), Int32(sg), Int32(sb), Int32(sa))\n            if (floydSteinberg) {\n                er = clamp(er + quantErrorCurr[x + 1][0] / 16)\n                eg = clamp(eg + quantErrorCurr[x + 1][1] / 16)\n                eb = clamp(eb + quantErrorCurr[x + 1][2] / 16)\n                ea = clamp(ea + quantErrorCurr[x + 1][3] / 16)\n            }\n            if (let Some(mPalette) <- palette) {\n                var bestIndex = 0\n                var bestSum = UInt32((1 << 32) - 1)\n                for (index in 0..mPalette.size) {\n                    let p = mPalette[index]\n                    let sum = sqDiff(er, p[0]) + sqDiff(eg, p[1]) + sqDiff(eb, p[2]) + sqDiff(ea, p[3])\n                    if (sum < bestSum) {\n                        bestIndex = index\n                        bestSum = sum\n                        if (sum == 0) {\n                            break\n                        }\n                    }\n                }\n                pixd[y * stride + x + pixS] = UInt8(bestIndex)\n                if (!floydSteinberg) {\n                    x++\n                    continue\n                }\n                er -= mPalette[bestIndex][0]\n                eg -= mPalette[bestIndex][1]\n                eb -= mPalette[bestIndex][2]\n                ea -= mPalette[bestIndex][3]\n            }\n            quantErrorNext[x + 0][0] += er * 3\n            quantErrorNext[x + 0][1] += eg * 3\n            quantErrorNext[x + 0][2] += eb * 3\n            quantErrorNext[x + 0][3] += ea * 3\n            quantErrorNext[x + 1][0] += er * 5\n            quantErrorNext[x + 1][1] += eg * 5\n            quantErrorNext[x + 1][2] += eb * 5\n            quantErrorNext[x + 1][3] += ea * 5\n            quantErrorNext[x + 2][0] += er * 1\n            quantErrorNext[x + 2][1] += eg * 1\n            quantErrorNext[x + 2][2] += eb * 1\n            quantErrorNext[x + 2][3] += ea * 1\n            quantErrorCurr[x + 2][0] += er * 7\n            quantErrorCurr[x + 2][1] += eg * 7\n            quantErrorCurr[x + 2][2] += eb * 7\n            quantErrorCurr[x + 2][3] += ea * 7\n            x++\n        }\n        if (floydSteinberg) {\n            let (qec, qen) = (quantErrorNext, quantErrorCurr)\n            quantErrorCurr = qen\n            quantErrorNext = qec\n            for (i in 0..quantErrorNext.size) {\n                quantErrorNext[i] = Array<Int32>(4, item: 0)\n            }\n        }\n        y++\n    }\n    (dst, r)\n}", "llm_cg": {"main": [], "clip": ["r.min.clone", "r.intersect", "dst.bounds", "src.bounds", "mask.bounds"], "processBackward": ["dst.eq", "r.overlaps"], "FloydSteinbergClazz.drawer": ["clip", "r.empty", "drawPaletted"], "draw": ["drawMask"], "drawMask": ["clip", "r.empty", "drawFillSrc", "drawFillOver", "drawCopyOver", "drawNRGBAOver", "drawYCbCr", "drawGray", "drawCMYK", "drawGlyphOver", "drawCopySrc", "drawNRGBASrc", "drawRGBA", "drawPaletted", "processBackward"], "drawFillOver": [], "drawFillSrc": [], "drawCopyOver": [], "drawCopySrc": [], "drawNRGBAOver": [], "drawNRGBASrc": [], "drawGray": [], "drawCMYK": ["color.CMYKToRGB"], "drawGlyphOver": [], "drawRGBA": [], "clamp": [], "sqDiff": [], "drawPaletted": ["color.RGBA64C", "src.at", "sqDiff", "clamp"]}, "static_cg": {}}
{"source_code": "package ohos_app_cangjie_entry\nimport ohos.base.*\nimport ohos.component.*\nimport ohos.state_manage.*\nimport ohos.state_macro_manage.*\n@Entry\n@Component\nclass ARItalicPage {\n    func render() {\n        Scroll() {\n            Column {\n                MarkdownComponent(mdStr: mdStr)\n            }\n        }\n        // 设置滚动方法\n        .scrollable(ScrollDirection.Vertical)\n    }\n    let mdStr: String = \"\"\"\n### 斜体1\n### *斜体标题*\n### 斜体2\n### _斜体标题_\n### 斜体3\n*斜体文本*\n### 斜体4\n_斜体文本_\n### 斜体5\n# Italicized text is the *cat's meow*.\n### 斜体6\n# Italicized text is the _cat's meow_.\n### 斜体7\n# A*cat*meow\n### 斜体8\n# A_at_meow\n### 斜体9\nItalicized text is the *cat's meow*.\n### 斜体10\nItalicized text is the _cat's meow_.\n### 斜体11\nA*cat*meow\n### 斜体12\nA_cat_meow\n\"\"\"\n}", "llm_cg": {"ARItalicPage": ["ARItalicPage.render"], "ARItalicPage.render": ["Scroll", "Column", "MarkdownComponent", "Scroll.scrollable", "ScrollDirection.Vertical"]}, "static_cg": {}}
{"source_code": "package cbor4cj\npublic class UnicodeString <: ChunkableDataItem {\n    private let string: ?String\n    public init(string: ?String) {\n        super(MajorType.UNICODE_STRING)\n        this.string = string\n    }\n    public func toString(): String {\n        if (string.isNone()) {\n            return \"null\"\n        } else {\n            return string.getOrThrow()\n        }\n    }\n    public func getString(): ?String {\n        return string\n    }\n    public func equals(object: Object): Bool {\n        if (object is UnicodeString && super.equals(object)) {\n            let other = (object as UnicodeString).getOrThrow()\n            if (string.isNone()) {\n                return other.string.isNone()\n            } else {\n                return string == (other.string)\n            }\n        }\n        return false\n    }\n    public func hashCode(): Int64 {\n        var hash = 0\n        if (let Some(v) <- string) {\n            hash = Int64(super.hashCode())\n            hash += Int64(v.hashCode())\n        }\n        return Int64(hash)\n    }\n}", "llm_cg": {"UnicodeString": ["super", "<builtin>.None", "<builtin>.return", "super.equals", "super.hashCode", "<builtin>.Int64", "<builtin>.<-", "<builtin>.<"], "UnicodeString.toString": ["<builtin>.return", "<builtin>.isNone", "<builtin>.getOrThrow"], "UnicodeString.getString": ["<builtin>.return"], "UnicodeString.equals": ["<builtin>.isNone", "super.equals", "<builtin>.getOrThrow", "<builtin>.None", "<builtin>.<", "<builtin>.==", "<builtin>.return", "<builtin>.is"], "UnicodeString.hashCode": ["<builtin>.<-", "super.hashCode", "<builtin>.Int64", "<builtin>.hashCode", "<builtin>.return", "<builtin>.<", "<builtin>.+="]}, "static_cg": {}}
{"source_code": "// DEPENDENCE: ./build.sh\n EXEC: bash build.sh %import-path %L %l ffi-typecast.o\nfrom std import collection.*\nfrom std import io.*\nmain() {\n    let val: Int32 = 368435456\n    let num = varintSize(val)\n    if(num != 5) {\n        return -1\n    }\n    return 0\n}", "llm_cg": {"main": ["varintSize"]}, "static_cg": {}}
{"source_code": "from std import sync.*\nfrom std import time.*\nvar mon = Monitor()\nvar flag: Bool = true\nmain(): Int64 {\n    let fut = spawn { =>\n        mon.lock()\n        while (flag) {\n            println(\"New thread: before wait\")\n            // Monitor 对象执行 wait 时，必须在锁的保护下进行，\n            // 否则 wait 中释放锁的操作会抛出异常。\n            mon.wait()\n            println(\"New thread: after wait\")\n        }\n        mon.unlock()\n    }\n    // sleep for 10ms, make sure the new thread can be executed\n    sleep(10 * Duration.millisecond)\n    mon.lock()\n    println(\"Main thread: set flag\")\n    flag = false\n    mon.unlock()\n    mon.lock()\n    println(\"Main thread: notify\")\n    mon.notify()\n    mon.unlock()\n    // wait for the new thread nished\n    fut.get()\n    return 0\n}", "llm_cg": {"main": ["mon.lock", "mon.unlock", "spawn", "mon.wait", "<builtin>.println", "sleep", "mon.notify", "fut.get"], "main.<spawned_function>": ["mon.lock", "<builtin>.println", "mon.wait", "<builtin>.println", "mon.unlock"]}, "static_cg": {}}
{"source_code": "package utils.nio\npublic func ArrayCopy(src: Array<Byte>, srcPos: Int64, dest: Array<Byte>, destPos: Int64, length: Int64) {\n    if ((srcPos | destPos | length) < 0) {\n        throw IndexOutOfBoundsException()\n    }\n    if (destPos > dest.size) {\n        throw IndexOutOfBoundsException()\n    }\n    src.copyTo(dest, srcPos, destPos, length)\n}\npublic class ByteBuffer <: Buffer & ToString & Hashable & Equatable<Buffer>  {\n    public let hb: Array<Byte>\n    let offset: Int64\n    init (mark: Int64, position: Int64, limits: Int64, capacity: Int64, hbs: Array<Byte>, offsets: Int64) {\n        super(mark, position, limits, capacity)\n        this.hb = hbs\n        this.offset = offsets\n    }\n    init (cap: Int64, lims: Int64) {\n        this (-1, 0, lims, cap, Array<Byte>(cap, item: 0), 0)\n    }\n    init (bufs: Array<Byte>, off: Int64, len: Int64) {\n        this (-1, off, off+len, bufs.size, bufs, 0)\n    }\n    protected init (bufs: Array<Byte>, mark: Int64, pos: Int64, lim: Int64, cap: Int64, off: Int64) {\n        this(mark, pos, lim, cap, bufs, off)\n    }\n    public static func allocate(capacitys: Int64): ByteBuffer {\n        if (capacitys < 0) {\n            throw IllegalArgumentException()\n        }\n        return ByteBuffer(capacitys, capacitys)\n    }\n    public static func wrap(arrays: Array<UInt8>, offset: Int64, length: Int64): ByteBuffer {\n        try{\n            return ByteBuffer(arrays,offset,length)\n        } catch (ex: IllegalArgumentException) {\n            throw IndexOutOfBoundsException()\n        }\n    }\n    public static func wrap(arrays: Array<UInt8>): ByteBuffer {\n        return wrap(arrays, 0, arrays.size)\n    }\n    public func get(dst: Array<UInt8>): ByteBuffer {\n        return get(dst, 0, dst.size)\n    }\n    public func put(srcs: Array<UInt8>): ByteBuffer {\n        return this.put(srcs, 0, srcs.size)\n    }\n    public func hasArray(): Bool {\n        return false\n    }\n    public func array(): Array<UInt8> {\n        return this.hb\n    }\n    public func arrayOffset(): Int64 {\n        return this.offset\n    }\n    public func position(newPosit: Int64): ByteBuffer {\n        super.position(newPosit)\n        return this\n    }\n    public func limit(newLim: Int64): ByteBuffer {\n        super.limit(newLim)\n        return this\n    }\n    public func reset(): ByteBuffer {\n        super.reset()\n        return this\n    }\n    public func clear (): ByteBuffer {\n        super.clear()\n        return this\n    }\n    public func flip(): ByteBuffer {\n        super.flip()\n        return this\n    }\n    public func rewind(): ByteBuffer {\n        super.rewind()\n        return this\n    }\n    public func toString(): String {\n        let sbd = StringBuilder()\n        sbd.append(\"ByteBuffer: [offset=\")\n        sbd.append(this.offset)\n        sbd.append(\" mark=\")\n        sbd.append(this.mar)\n        sbd.append(\" pos=\")\n        sbd.append(position())\n        sbd.append(\" lim=\")\n        sbd.append(limit())\n        sbd.append(\" cap=\")\n        sbd.append(capacity())\n        sbd.append(\"]\")\n        let src = sbd.toString()\n        sbd.reset()\n        return src\n    }\n    @OverflowWrapping\n    public func hashCode(): Int64 {\n        var hc: Int32 = 1\n        var p = position()\n        for (i in limit()-1..=p:-1) {\n            hc = 31 * hc + Int32(get(i))\n        }\n        return Int64(hc)\n    }\n    public operator func == (thats: Buffer): Bool {\n        return refEq(this, thats)\n    }\n    public operator func != (thats: Buffer): Bool {\n        return !refEq(this, thats)\n    }\n    public func slice(): ByteBuffer {\n        return ByteBuffer(this.hb, -1, 0, this.remaining(), this.remaining(), this.position() + offset)\n    }\n    public func slice (pos: Int64, limit: Int64): ByteBuffer {\n        let rem = limit - pos\n        return ByteBuffer(hb, -1, 0, rem, rem, pos + offset)\n    }\n    public func duplicate(): ByteBuffer {\n        return ByteBuffer(hb, this.markValue(), this.position(), this.limit(), this.capacity(), offset)\n    }\n    public func asReadOnlyBuffer(): ByteBuffer {\n        return ByteBuffer(hb, this.markValue(), this.position(), this.limit(), this.capacity(), offset)\n    }\n    protected func ix(ii: Int64): Int64 {\n        return ii + offset\n    }\n    public func get(): Byte {\n        return hb[ix(nextGetIndex())]\n    }\n    public func get(i:Int64) : Byte {\n        return hb[ix(checkIndex(i))]\n    }\n    public func get(dsts: Array<Byte>, offset: Int64, length: Int64): ByteBuffer {\n        checkBounds(offset, length, dsts.size)\n        if (length > this.remaining()) {\n            throw Exception() // BufferUnderflowException\n        }\n        ArrayCopy(hb, ix(position()), dsts, offset, length)\n        position(position() + length)\n        return this\n    }\n    public func put(x: Byte): ByteBuffer {\n        hb[ix(nextGetIndex())] = x\n        return this\n    }\n    public func put(i: Int64, x: Byte): ByteBuffer {\n        hb[ix(checkIndex(i))] = x\n        return this\n    }\n    public func put(src: Array<Byte>, offsets: Int64, length: Int64): ByteBuffer {\n        checkBounds(offsets, length, src.size)\n        if (length > remaining()) {\n            throw Exception() // BufferOverflowException\n        }\n        ArrayCopy(src, offsets, hb, ix(position()), length)\n        position(position() + length)\n        return this\n    }\n    public func put(srcs: ByteBuffer): ByteBuffer {\n        if (srcs is ByteBuffer) {\n            if (srcs == this) {\n                throw createSameBufferException()\n            }\n            let sb: ByteBuffer =(srcs as ByteBuffer).getOrThrow()\n            let n = sb.remaining()\n            if (n > remaining()) {\n                throw BufferOverflowException() // BufferOverflowException\n            }\n            ArrayCopy(sb.hb, sb.ix(sb.position()), hb, ix(position()), n)\n            sb.position(sb.position() + n )\n            position(position() +n)\n        }\n        return this\n    }\n    public func compact(): ByteBuffer {\n        ArrayCopy(hb, ix(position()), hb, ix(0), remaining())\n        position(remaining())\n        limit(capacity())\n        discardMark()\n        return this\n    }\n    @OverflowWrapping\n    public func putLong(val: Int64): ByteBuffer {\n        this.putUInt64(UInt64(val))\n    }\n    @OverflowWrapping\n    public func putInt(val: Int32): ByteBuffer {\n        this.putUInt32(UInt32(val))\n    }\n    @OverflowWrapping\n    public func putShort(val: Int16): ByteBuffer {\n        this.putUInt16(UInt16(val))\n    }\n    @OverflowWrapping\n    public func getLong(): Int64 {\n        return Int64(this.getUInt64())\n    }\n    @OverflowWrapping\n    public func getInt(): Int32 {\n        return Int32(this.getUInt32())\n    }\n    @OverflowWrapping\n    public func getShort(): Int16 {\n        return Int16(this.getUInt16())\n    }\n    @OverflowWrapping\n    public func putUInt64(val: UInt64): ByteBuffer {\n        this.put(UInt8((val >> 56) & 0xff))\n        this.put(UInt8((val >> 48) & 0xff))\n        this.put(UInt8((val >> 40) & 0xff))\n        this.put(UInt8((val >> 32) & 0xff))\n        this.put(UInt8((val >> 24) & 0xff))\n        this.put(UInt8((val >> 16) & 0xff))\n        this.put(UInt8((val >> 8) & 0xff))\n        this.put(UInt8(val & 0xff))\n        return this\n    }\n    @OverflowWrapping\n    public func putUInt32(val: UInt32): ByteBuffer {\n        this.put(UInt8((val >> 24) & 0xff))\n        this.put(UInt8((val >> 16) & 0xff))\n        this.put(UInt8((val >> 8) & 0xff))\n        this.put(UInt8(val & 0xff))\n        return this\n    }\n    @OverflowWrapping\n    public func putUInt16(val: UInt16): ByteBuffer {\n        this.put(UInt8((val >> 8) & 0xff))\n        this.put(UInt8(val & 0xff))\n        return this\n    }\n    @OverflowWrapping\n    public func getUInt64(): UInt64 {\n        return UInt64(this.get()) << 56 |\n                UInt64(this.get()) << 48 |\n                UInt64(this.get()) << 40 |\n                UInt64(this.get()) << 32 |\n                UInt64(this.get()) << 24 |\n                UInt64(this.get()) << 16 |\n                UInt64(this.get()) << 8 |\n                UInt64(this.get())\n    }\n    @OverflowWrapping\n    public func getUInt32(): UInt32 {\n        return UInt32(this.get()) << 24 |\n            UInt32(this.get()) << 16 |\n            UInt32(this.get()) << 8 |\n            UInt32(this.get())\n    }\n    @OverflowWrapping\n    public func getUInt16(): UInt16 {\n        return UInt16(this.get()) << 8 |\n            UInt16(this.get())\n    }\n     func createSameBufferException(): IllegalArgumentException {\n        throw IllegalArgumentException(\"The source buffer is this buffer\")\n    }\n}\npublic class BufferOverflowException <: Exception {\n    public init() {\n        super(\"BufferOverflowException: \\n\")\n    }\n}", "llm_cg": {"main": [], "ArrayCopy": ["IndexOutOfBoundsException", "src.copyTo"], "ByteBuffer": ["ArrayCopy", "IllegalArgumentException", "IndexOutOfBoundsException", "StringBuilder", "position", "limit", "capacity", "checkBounds", "remaining", "BufferOverflowException", "createSameBufferException", "discardMark"], "ByteBuffer.allocate": ["IllegalArgumentException", "ByteBuffer"], "ByteBuffer.wrap": ["IllegalArgumentException", "ByteBuffer", "IndexOutOfBoundsException"], "ByteBuffer.wrap.<overload>": ["wrap", "arrays.size"], "ByteBuffer.get": ["hb", "ix", "nextGetIndex"], "ByteBuffer.put": ["ix", "nextGetIndex"], "ByteBuffer.position": ["super.position"], "ByteBuffer.limit": ["super.limit"], "ByteBuffer.reset": ["super.reset"], "ByteBuffer.clear": ["super.clear"], "ByteBuffer.flip": ["super.flip"], "ByteBuffer.rewind": ["super.rewind"], "ByteBuffer.toString": ["StringBuilder", "sbd.append", "this.offset", "this.mar", "position", "limit", "capacity", "sbd.toString", "sbd.reset"], "ByteBuffer.hashCode": ["position", "limit", "get"], "ByteBuffer.==": ["refEq"], "ByteBuffer.!=": ["refEq"], "ByteBuffer.slice": ["remaining", "position", "ByteBuffer"], "ByteBuffer.slice.<overload>": ["ByteBuffer"], "ByteBuffer.duplicate": ["markValue", "position", "limit", "capacity", "ByteBuffer"], "ByteBuffer.asReadOnlyBuffer": ["markValue", "position", "limit", "capacity", "ByteBuffer"], "ByteBuffer.ix": [], "ByteBuffer.get.<overload>": ["hb", "ix", "checkIndex"], "ByteBuffer.get.<overload2>": ["ArrayCopy", "hb", "ix", "position"], "ByteBuffer.put.<overload>": ["ix", "checkIndex"], "ByteBuffer.put.<overload2>": ["ArrayCopy", "ix", "position"], "ByteBuffer.put.<overload3>": ["this.hb", "ix", "position", "position", "ArrayCopy"], "ByteBuffer.compact": ["ArrayCopy", "ix", "position", "remaining", "limit", "capacity", "discardMark"], "ByteBuffer.putLong": ["putUInt64"], "ByteBuffer.putInt": ["putUInt32"], "ByteBuffer.putShort": ["putUInt16"], "ByteBuffer.getLong": ["getUInt64"], "ByteBuffer.getInt": ["getUInt32"], "ByteBuffer.getShort": ["getUInt16"], "ByteBuffer.putUInt64": ["put"], "ByteBuffer.putUInt32": ["put"], "ByteBuffer.putUInt16": ["put"], "ByteBuffer.getUInt64": ["get"], "ByteBuffer.getUInt32": ["get"], "ByteBuffer.getUInt16": ["get"], "createSameBufferException": ["IllegalArgumentException"], "BufferOverflowException": ["IllegalArgumentException"]}, "static_cg": {}}
{"source_code": "package compress4cj.archivers.rar.unpack\nimport std.log.*\nimport std.io.*\nimport std.fs.*\nimport std.collection.*\nimport compress4cj.archivers.rar.unpack.decode.Compress\nimport compress4cj.utils.internals.URS\nimport compress4cj.archivers.rar.unpack.vm.VMPreparedProgram\npublic class UnpackFilter {\n    private var BlockStart: Int32 = 0\n    private var BlockLength: Int32 = 0\n    private var ExecCount: Int32 = 0\n    private var NextWindow: Bool = false\n    // position of parent filter in Filters array used as prototype for filter\n    // in PrgStack array. Not defined for filters in Filters array.\n    private var ParentFilter: Int32 = 0\n    private var Prg :VMPreparedProgram = VMPreparedProgram()\n    public func getBlockLength(): Int32 {\n        return BlockLength\n    }\n    public func setBlockLength(blockLength: Int32) {\n        BlockLength = blockLength\n    }\n    public func getBlockStart(): Int32 {\n        return BlockStart\n    }\n    public func setBlockStart(blockStart: Int32) {\n        BlockStart = blockStart\n    }\n    public func getExecCount(): Int32 {\n        return ExecCount\n    }\n    public func setExecCount(execCount: Int32) {\n        ExecCount = execCount\n    }\n    public func isNextWindow(): Bool {\n        return NextWindow\n    }\n    public func setNextWindow( nextWindow: Bool) {\n        NextWindow = nextWindow\n    }\n    public func getParentFilter() : Int32{\n        return ParentFilter\n    }\n    public func setParentFilter(parentFilter: Int32) {\n        ParentFilter = parentFilter\n    }\n    public func getPrg(): VMPreparedProgram {\n        return Prg\n    }\n    public func setPrg(prg: VMPreparedProgram) {\n        Prg = prg\n    }\n}", "llm_cg": {"main": [], "UnpackFilter": ["compress4cj.archivers.rar.unpack.vm.VMPreparedProgram"], "UnpackFilter.getBlockLength": [], "UnpackFilter.setBlockLength": [], "UnpackFilter.getBlockStart": [], "UnpackFilter.setBlockStart": [], "UnpackFilter.getExecCount": [], "UnpackFilter.setExecCount": [], "UnpackFilter.isNextWindow": [], "UnpackFilter.setNextWindow": [], "UnpackFilter.getParentFilter": [], "UnpackFilter.setParentFilter": [], "UnpackFilter.getPrg": [], "UnpackFilter.setPrg": []}, "static_cg": {}}
{"source_code": "package okhttp_okcj\npublic enum HttpMethod {\n    GET |\n    POST |\n    PUT |\n    DELETE |\n    HEAD |\n    PATCH |\n    OPTIONS |\n    TRACE\n    public operator func == (that: HttpMethod): Bool {\n        match ((this, that)) {\n            case (GET, GET) => true\n            case (POST, POST) => true\n            case (PUT, PUT) => true\n            case (DELETE, DELETE) => true\n            case (HEAD, HEAD) => true\n            case (PATCH, PATCH) => true\n            case (OPTIONS, OPTIONS) => true\n            case (TRACE, TRACE) => true\n            case _ => false\n        }\n    }\n    public operator func != (that: HttpMethod): Bool {\n        return !(this == that)\n    }\n    public func toString(): String {\n        return match(this) {\n            case GET                => \"GET\"\n            case POST          => \"POST\"\n            case PUT               => \"PUT\"\n            case DELETE   => \"DELETE\"\n            case HEAD            => \"HEAD\"\n            case PATCH       => \"PATCH\"\n            case OPTIONS       => \"OPTIONS\"\n            case TRACE       => \"TRACE\"\n        }\n    }\n}", "llm_cg": {"main": [], "HttpMethod": [], "HttpMethod.==": [], "HttpMethod.!=": ["HttpMethod.=="], "HttpMethod.toString": []}, "static_cg": {}}
{"source_code": "package language_base.model\npublic struct SyntaxHighlightResult {\n    public SyntaxHighlightResult(public var tokenType: TokenType,\n        public var start: UIntNative,\n        public var end: UIntNative) {}\n}", "llm_cg": {}, "static_cg": {}}
{"source_code": "package cjorm.builder\npublic struct IsNull <: Cond {\n    let data: String\n    public init(data: String) {\n        this.data = data\n    }\n    public func writeTo(w: CondWriter): Unit {\n        w.write(\"${this.data} IS NULL\")\n    }\n    public func and(condition: Cond): Cond {\n        buildAnd([this, condition])\n    }\n    public func or(condition: Cond): Cond {\n        buildOr([this, condition])\n    }\n    public func isValid(): Bool {\n        this.data.size > 0\n    }\n}\npublic struct NotNull <: Cond {\n    let data: String\n    public init(data: String) {\n        this.data = data\n    }\n    public func writeTo(w: CondWriter): Unit {\n        w.write(\"${this.data} IS NOT NULL\")\n    }\n    public func and(condition: Cond): Cond {\n        buildAnd([this, condition])\n    }\n    public func or(condition: Cond): Cond {\n        buildOr([this, condition])\n    }\n    public func isValid(): Bool {\n        this.data.size > 0\n    }\n}", "llm_cg": {"IsNull": [], "IsNull.init": [], "IsNull.writeTo": ["w.write"], "IsNull.and": ["buildAnd"], "IsNull.or": ["buildOr"], "IsNull.isValid": [], "NotNull": [], "NotNull.init": [], "NotNull.writeTo": ["w.write"], "NotNull.and": ["buildAnd"], "NotNull.or": ["buildOr"], "NotNull.isValid": []}, "static_cg": {}}
{"source_code": "package access\npublic class UserGroup <: AccessInfo & AccessorContext {\n    public let name: String\n    // 用户\n    let userMap: HashMap<String, User>\n    // 策略\n    let policyMap: HashMap<String, Policy>\n    public init(name: String) {\n        this.name = name\n        this.userMap = HashMap<String, User>()\n        this.policyMap = HashMap<String, Policy>()\n    }\n    public func getName(): String {\n        name\n    }\n    public func addUser(user: User) {\n        this.userMap[user.getName()] = user\n    }\n    func addUser(user: String) {\n        addUser(User(user))\n    }\n    func getUserMap(): Array<User> {\n        userMap.values().toArray()\n    }\n    func removeUser(user: User): ?User {\n        removeUser(user.getName())\n    }\n    func removeUser(user: String): ?User {\n        this.userMap.remove(user)\n    }\n    public func addPolicy(policy: Policy) {\n        this.policyMap[policy.getName()] = policy\n    }\n    func removePolicy(policy: Policy): ?Policy {\n        removePolicy(policy.getName())\n    }\n    func removePolicy(policy: String): ?Policy {\n        this.policyMap.remove(policy)\n    }\n    func checkUser(user: User): Bool {\n        let result = userMap.contains(user.getName())\n        if (!result) {\n            user.removeUserGroup(this)\n        }\n        result\n    }\n    func checkPolicy(policy: Policy): Bool {\n        let result = policyMap.contains(policy.getName())\n        if (!result) {\n            policy.removeUserGroup(this)\n        }\n        result\n    }\n    public func reset() {\n        this.userMap.clear()\n        this.policyMap.clear()\n    }\n    public operator func ==(other: AccessInfo): Bool {\n        if (let Some(o) = (other as UserGroup)) {\n            this.getName() == other.getName() || refEq(this, o)\n        } else {\n            false\n        }\n    }\n    public operator func !=(other: AccessInfo): Bool {\n        !(this == other)\n    }\n    public func toString(): String {\n        \"{\\\"name\\\": \\\"${getName()}\\\", \\\"user-list\\\": ${getUserMap()}}\"\n    }\n    public func addUserGroup(userGroup: UserGroup): Unit {}\n}", "llm_cg": {"UserGroup": ["HashMap", "HashMap"], "UserGroup.getName": [], "UserGroup.addUser": ["User.getName"], "UserGroup.addUser.user": ["User", "UserGroup.addUser"], "UserGroup.getUserMap": ["userMap.values.toArray"], "UserGroup.removeUser": ["User.getName", "UserGroup.removeUser.user"], "UserGroup.removeUser.user": ["this.userMap.remove"], "UserGroup.addPolicy": ["Policy.getName"], "UserGroup.removePolicy": ["Policy.getName", "UserGroup.removePolicy.policy"], "UserGroup.removePolicy.policy": ["this.policyMap.remove"], "UserGroup.checkUser": ["userMap.contains", "User.getName", "User.removeUserGroup"], "UserGroup.checkPolicy": ["policyMap.contains", "Policy.getName", "Policy.removeUserGroup"], "UserGroup.reset": ["this.userMap.clear", "this.policyMap.clear"], "UserGroup.==(other: AccessInfo)": ["UserGroup.getName", "other.getName", "refEq"], "UserGroup.!=(other: AccessInfo)": ["UserGroup.=="], "UserGroup.toString": ["UserGroup.getName", "UserGroup.getUserMap"], "UserGroup.addUserGroup": []}, "static_cg": {}}
{"source_code": "package oauth4cj\npublic interface ServiceBuilderCommon {\n    func setCallback(callback: Option<String>): ServiceBuilderCommon\n    func setApiKey(apiKey: String): ServiceBuilderCommon\n    func setApiSecret(apiSecret: String): ServiceBuilderCommon\n    func setApiSecretIsEmptyStringUnsafe(): ServiceBuilderCommon\n    func setHttpClientConfig(httpClientConfig: Option<HttpClientConfig>): ServiceBuilderCommon\n    func setHttpClient(httpClient: Option<HttpClient>): ServiceBuilderCommon\n    func setHttpClientProvider(httpClientProvider: Option<HttpClientProvider>): ServiceBuilderCommon\n    func setUserAgent(userAgent: String): ServiceBuilderCommon\n}", "llm_cg": {"main": [], "ServiceBuilderCommon": [], "ServiceBuilderCommon.setCallback": [], "ServiceBuilderCommon.setApiKey": [], "ServiceBuilderCommon.setApiSecret": [], "ServiceBuilderCommon.setApiSecretIsEmptyStringUnsafe": [], "ServiceBuilderCommon.setHttpClientConfig": [], "ServiceBuilderCommon.setHttpClient": [], "ServiceBuilderCommon.setHttpClientProvider": [], "ServiceBuilderCommon.setUserAgent": []}, "static_cg": {}}
{"source_code": "package base.exception\npublic class IllegalAccessException <: BaseException {\n    public init() {}\n    public init(message: String) {\n        super(message)\n    }\n    public init(caused: Exception) {\n        super(caused)\n    }\n    public init(message: String, caused: Exception) {\n        super(message, caused)\n    }\n}", "llm_cg": {"IllegalAccessException": [], "IllegalAccessException.init": ["BaseException.init"], "IllegalAccessException.init#1": ["BaseException.init"], "IllegalAccessException.init#2": ["BaseException.init"], "IllegalAccessException.init#3": ["BaseException.init"]}, "static_cg": {}}
{"source_code": "// DEPENDENCE: ../z_test.cj\n// EXEC: cjc %import-path %L %l %f z_test.cj\n// EXEC: ./main\nfrom httpclient4cj import httpclient4cj.*\nfrom std import collection.*\nfrom std import io.*\nfrom std import time.*\nfrom net import http.*\nfrom std import socket.*\nmain() {\n    let soc = TcpSocket(\"okhttp\", portTrans(50066))\n    soc.connect()\n    let sc = SocketClient.SocketC(soc)\n    let socket = OKSocket(sc, Option<Duration>.None, Option<Duration>.None)\n    let h2conn = H2Connection(sc, BufferedOutputStream(socket), OkBuffer(socket))\n    let formBody = FormBody.builder().add(\"username\", \"admin\").add(\"password\", \"123456\").add(\"host\", \"%6D\").build()\n    let request = httpclient4cj.Request.builder()\n        .url(\"http://okhttp:${portTrans(50066)}/cangjie_test-1.0-SNAPSHOT/hello\")\n        .header(\"User-Agent\", \"OkHttp-Example\")\n        .put(formBody)\n        .header(\"content-type\", formBody.contentType().getOrThrow().toString())\n        .build()\n    h2conn.start()\n    let h1 = h2conn.isHealthy()\n    h2conn.close()\n    let h2 = h2conn.isHealthy()\n    if (h1 == true && h2 == false) {\n        return 0\n    }\n    return 1\n}", "llm_cg": {}, "static_cg": {}}
{"source_code": " from std import collection.*\nfunc f_gold (str:Array<UInt8>):Bool{\n  let len = str.size\n  if ( str [ 0 ] < b'A' || str [ 0 ] > b'Z' ) {return false}\n  if ( str [ len - 1 ] != b'.' ) {return false}\n  var prev_state = 0\n  var curr_state = 0\n  var index = 1\n  while ( index <= str . size ) {\n    if ( str [ index ] >= b'A' && str [ index ] <= b'Z' ) {curr_state = 0}\n    else if ( str [ index ] == b' ' ) {curr_state = 1}\n    else if ( str [ index ] >= b'a' && str [ index ] <= b'z' ) {curr_state = 2}\n    else if ( str [ index ] == b'.' ) {curr_state = 3}\n    if ( prev_state == curr_state && curr_state != 2 ) {return false}\n    if ( prev_state == 2 && curr_state == 0 ) {return false}\n    if ( curr_state == 3 && prev_state != 1 ) {return ( index + 1 == str . size )}\n    index ++\n    prev_state = curr_state\n  }\n  return false\n}\n//TOFILL\nmain(){\n    var n_success = 0\n    let param0 = ArrayList<String>([\"I love cinema.\", \"The vertex is S.\",\n                         \"I am single.\", \"My name is KG.\",\n                         \"I lovE cinema.\", \"GeeksQuiz. is a quiz site.\",\n    let param1 = ArrayList<String>([\"I love cinema.\", \"The vertex is S.\",\n                         \"I am single.\", \"My name is KG.\",\n                         \"I lovE cinema.\", \"GeeksQuiz. is a quiz site.\",\n                         \" You are my friend.\", \"I love cinema\", \"Hello world !\"])\n    let param1 = ArrayList<String>([\"I love cinema.\", \"The vertex is S.\",\n                         \"I am single.\", \"My name is KG.\",\n                         \"I lovE cinema.\", \"GeeksQuiz. is a quiz site.\",\n                         \" You are my friend.\", \"I love cinema\", \"Hello world !\"])\n    for (i in 0..param0.size){\n        if (f_gold(param0[i].toArray()) == f_filled(param1[i].toArray())){\n            n_success += 1\n        }\n    }\n    println(\"#Results: ${n_success}, ${param0.size}\\n\")\n}", "llm_cg": {"main": ["ArrayList", "f_gold", "f_filled", "<builtin>.println"], "f_gold": []}, "static_cg": {}}
{"source_code": "package benchmark_client\npublic class PerformanceTask {\n    static let indexGenerator = AtomicUInt64(0)\n    let sessions: Array<Session>\n    private let totalRequestCount: Int64\n    private let executeNum: Int64\n    private let message: String\n    private let barrier: Barrier\n    public init(\n        sessions: Array<Session>,\n        totalRequestCount: Int64,\n        executeNum: Int64,\n        message: String,\n        barrier: Barrier\n    ) {\n        this.sessions = sessions\n        this.totalRequestCount = totalRequestCount\n        this.executeNum = executeNum\n        this.message = message\n        this.barrier = barrier\n    }\n    public func run() {\n        // 等待所有线程一起执行\n        barrier.wait()\n        var i = 0\n        while (TaskController.running.load() && (executeNum == -1 || i < executeNum)) {\n            // 发送消息，并收取对应的响应\n            let echoRequest = EchoRequest(TaskController.requestIdGenerator.fetchAdd(1), message)\n            let session = sessions[nextIndex()]\n            session.writeAndFlushMessage(echoRequest)\n            try {\n                let echoResponse = echoRequest.waitForResponse()\n                if (TaskController.stopTime.load() == 0) {\n                    let totalCount = TaskController.totalInvokeCount.fetchAdd(1)\n                    if (totalCount + 1 >= totalRequestCount) {\n                        // 设置停止时间\n                        TaskController.stopTime.compareAndSwap(0, DateTime.now().toUnixTimeStamp().toMilliseconds());\n                    }\n                }\n                i++\n            } catch (ex: Exception) {\n                ex.printStackTrace()\n                break\n            }\n        }\n    }\n    @OverflowWrapping\n    private func nextIndex(): Int64 {\n        let index = indexGenerator.fetchAdd(1) % UInt64(sessions.size)\n        return Int64(index)\n    }\n}", "llm_cg": {"PerformanceTask": [], "PerformanceTask.init": [], "PerformanceTask.run": ["barrier.wait", "TaskController.running.load", "TaskController.requestIdGenerator.fetchAdd", "sessions.nextIndex", "session.writeAndFlushMessage", "echoRequest.waitForResponse", "TaskController.stopTime.load", "TaskController.totalInvokeCount.fetchAdd", "TaskController.stopTime.compareAndSwap", "DateTime.now", "ex.printStackTrace"], "PerformanceTask.nextIndex": ["indexGenerator.fetchAdd", "sessions.size"]}, "static_cg": {}}
{"source_code": "package droplet.droplet\nextend File {\n     func write(s: UInt8): Unit {\n        this.write(Array<UInt8>(1, item: s))\n    }\n}\n     func unsignedShiftRight64(c: Int64, num: Int64) {\n        let t: Int64 = 0x7fffffffffffffff<<1 | 0x01;\n        Int64(UInt64(t & c) >> num)\n    }\n     func highestOneBit(i: Int64): Int64 {\n        var i2 = i\n        i2 |= (i2 >>  1);\n        i2 |= i2 | (i2 >>  2);\n        i2 |= (i2 >>  4);\n        i2 |= (i2 >>  8);\n        i2 |= (i2 >> 16);\n        return i2 - unsignedShiftRight64(i2, 1);\n    }", "llm_cg": {}, "static_cg": {}}
{"source_code": "// EXEC: cjc %import-path %L %l %f  %project-path %project-L/protobuf  -l protobuf-cj\n// EXEC: ./main\nfrom rpc4cj import grpc.*\nfrom rpc4cj import transport.*\nfrom rpc4cj import exceptions.*\nfrom rpc4cj import util.*\nfrom std import io.*\nfrom std import socket.*\nfrom net import tls.*\nfrom std import time.*\nmain (){\n    try {\n        let arr: Array<Byte> = Array<Byte>(1024, item: 0)\n        OutputStreamConn(ByteArrayStream()).read(arr)\n    } catch (e: Exception) {\n        return 0\n    }\n    return -1\n}", "llm_cg": {"main": ["OutputStreamConn", "ByteArrayStream"]}, "static_cg": {}}
{"source_code": "package barcode\nabstract class AI013x0xReader <: AI01WeightReader {\n    static let HEADER_SIZE = 5 // 4 + 1\n    static let WEIGHT_SIZE = 15\n    init(information: BitArray) {\n        super(information)\n    }\n    public override func parseInformation(): String {\n        if (this.information.size != HEADER_SIZE + GTIN_SIZE + WEIGHT_SIZE) {\n            throw NotFoundException()\n        }\n        let buf = StringBuilder()\n        encodeCompressedGtin(buf, HEADER_SIZE)\n        encodeCompressedWeight(buf, HEADER_SIZE + GTIN_SIZE, WEIGHT_SIZE)\n        buf.toString()\n    }\n}", "llm_cg": {"main": [], "AI013x0xReader": [], "AI013x0xReader.init": ["super"], "AI013x0xReader.parseInformation": ["NotFoundException", "StringBuilder", "encodeCompressedGtin", "encodeCompressedWeight", "buf.toString"]}, "static_cg": {}}
{"source_code": "// EXEC: cjc %import-path %L %l %f\n// EXEC: ./main\nfrom charset import charset.*\nfrom charset import charset.traditionchinese.*\nmain (){\n    var big5 = Charsets.BIG5\n    var encoder = big5.newEncoder()\n    var str: String = \"你號，中國\"\n    var s1 = encoder.encode(str)\n    let dest:Array<UInt8> = [0xA7,0x41,0xB8, 0xB9, 0xA1, 0x41, 0xA4, 0xA4, 0xB0, 0xEA]\n    for(i in 0..dest.size){\n        let a = dest[i]\n        let b = s1[i]\n        if(a != b){\n            return 1\n        }\n    }\n    return 0\n}", "llm_cg": {"main": ["Charsets.BIG5.newEncoder", "encoder.encode", "dest.size"]}, "static_cg": {}}
{"source_code": "import cradle.*\nfrom std import time.*\nfrom std import collection.*\nfrom std import io.*\n@Cradle[console|logfile]\nfunc addUser(userName: String) {\n    println(userName)\n}\n@Cradle[console]\nfunc removeUser(userId: Int64): Int64 {\n    println(userId)\n    return userId\n}\n@Cradle\nfunc login(userName: String, password: String) {\n    println(userName + \" login\")\n}\nmain() {\n    addUser(\"小华\")\n    removeUser(100)\n    login(\"小华\", \"qD@0532\")\n}", "llm_cg": {"main": ["<builtin>.println", "<builtin>.println", "<builtin>.println"], "addUser": ["<builtin>.println"], "removeUser": ["<builtin>.println"], "login": ["<builtin>.println"]}, "static_cg": {}}
{"source_code": "package cjgrapht.graph\npublic class DefaultDirectedWeightedGraph<V, E> <: DefaultDirectedGraph<V, E> where E <: Equatable<E> & ToString & Hashable,\n    V <: Equatable<V> & ToString & Hashable {\n    public DefaultDirectedWeightedGraph(edgeSupplier: () -> E) {\n        super(None, edgeSupplier, true);\n    }\n    public init(vertexSupplier: () -> V, edgeSupplier: () -> E) {\n        super(vertexSupplier, edgeSupplier, true);\n    }\n}", "llm_cg": {}, "static_cg": {}}
{"source_code": "package core.bubble\npublic class BubbleChartModel <: BarLineChartBaseModel<BubbleData, IBubbleDataSet, BubbleEntry> & BubbleDataProvider {\n    public var context2d: ?CanvasRenderingContext2D = None;\n    init() {\n        super();\n    }\n    public static func build(): BubbleChartModel {\n        let model: BubbleChartModel = BubbleChartModel()\n        var mAnimator: ChartAnimator = ChartAnimator(model)\n        model.mRenderer = BubbleChartRenderer(model, mAnimator, model.mViewPortHandler)\n        model.setHighlighter(ChartHighlighter(model))\n        return model\n    }\n    public func invalidate() {\n        if (let Some(context2d) <- this.context2d) {\n            this.onDraw(context2d);\n        }\n    }\n    public func setContext2D(context2d: CanvasRenderingContext2D) {\n        this.context2d = context2d\n    }\n    public func onChartSizeChanged(newWidth: Float64, newHeight: Float64, oldWidth: Float64, oldHeight: Float64) {\n        super.onSizeChanged(newWidth, newHeight, oldWidth, oldHeight);\n    }\n    public func onDraw(c: CanvasRenderingContext2D): Unit {\n        super.onDraw(c);\n    }\n    public func getBubbleData(): ?BubbleData {\n        if (let Some(data: BubbleData) <- this.mData) {\n            return data\n        } else {\n            return None;\n        }\n    }\n}", "llm_cg": {"main": [], "BubbleChartModel": [], "BubbleChartModel.build": ["BubbleChartModel", "ChartAnimator", "BubbleChartRenderer", "model.setHighlighter", "ChartHighlighter"], "BubbleChartModel.invalidate": ["this.onDraw"], "BubbleChartModel.setContext2D": [], "BubbleChartModel.onChartSizeChanged": ["super.onSizeChanged"], "BubbleChartModel.onDraw": ["super.onDraw"], "BubbleChartModel.getBubbleData": []}, "static_cg": {}}
{"source_code": "package ohos_app_cangjie_entry.barPage\nimport ohos.base.*\nimport ohos.component.*\nimport ohos.state_manage.*\nimport ohos.state_macro_manage.*\n@Entry\n@Component\nclass StackedBarChartPage {\n    private var model: BarChartModel = BarChartModel.build()\n    private var leftAxis: ?YAxis = Option<YAxis>.None\n    private var rightAxis: ?YAxis = Option<YAxis>.None\n    private var xAxis: ?XAxis = Option<XAxis>.None\n    private var limitLine1: LimitLine = LimitLine(0.0, \"limit1\")\n    private var limitLine2: LimitLine = LimitLine(0.0, \"limit2\")\n    private var barData: BarData = BarData()\n    protected override func aboutToAppear() {\n        let description: Description = this.model.getDescription()\n        description.setEnabled(false)\n        let l: ?Legend = this.model.getLegend()\n        if (let Some(l) <- l) {\n            l.setEnabled(false)\n        }\n        // if more than 40 entries are displayed in the this.model, no values will be drawn\n        this.model.setMaxVisibleValueCount(40)\n        this.model.setDrawGridBackground(false)\n        this.model.setGridBackgroundColor(0x500000ff)\n        this.model.setDrawBarShadow(false)\n        this.model.setDrawValueAboveBar(false)\n        this.limitLine1 = LimitLine(120.0, \"Upper Limit\")\n        this.limitLine1.setLineWidth(4.0)\n        this.limitLine1.enableDashedLine(10, 10)\n        this.limitLine1.setLabelPosition(LimitLabelPosition.RIGHT_TOP)\n        this.limitLine1.setTextSize(10.0)\n        this.limitLine2 = LimitLine(50.0, \"Lower Limit\")\n        this.limitLine2.setLineWidth(4.0)\n        this.limitLine2.enableDashedLine(10, 10)\n        this.limitLine2.setLineColor(0xFFFF00)\n        this.limitLine2.setLabelPosition(LimitLabelPosition.RIGHT_BOTTOM)\n        this.limitLine2.setTextSize(10.0)\n        this.leftAxis = this.model.getAxisLeft()\n        if (let Some(leftAxis) <- this.leftAxis) {\n            leftAxis.setAxisMinimum(0.0)\n            leftAxis.setDrawLimitLinesBehindData(false)\n            leftAxis.addLimitLine(this.limitLine1)\n            leftAxis.addLimitLine(this.limitLine2)\n        }\n        this.rightAxis = this.model.getAxisRight()\n        if (let Some(rightAxis) <- this.rightAxis) {\n            rightAxis.setEnabled(false)\n            rightAxis.setAxisMinimum(0.0)\n        }\n        this.xAxis = this.model.getXAxis()\n        if (let Some(xAxis) <- this.xAxis) {\n            xAxis.setPosition(XAxisPosition.TOP)\n        }\n        this.barData = this.getStackData()\n        this.model.setData(this.barData)\n        this.model.setVisibleXRangeMaximum(20.0)\n    }\n    private func getStackData(): BarData {\n        let values: ArrayList<BarEntry> = ArrayList<BarEntry>()\n        values.append(BarEntry(1.0, [38.0, 28.0, 39.8]))\n        values.append(BarEntry(2.0, [18.2, 16.1, 16.1]))\n        values.append(BarEntry(3.0, [45.8, 49.8, 26.7]))\n        values.append(BarEntry(4.0, [36.5, 43.8, 15.1]))\n        values.append(BarEntry(5.0, [51.5, 35.4, 24.1]))\n        values.append(BarEntry(6.0, [44.9, 21.4, 15.9]))\n        values.append(BarEntry(7.0, [32.9, 40.4, 32.7]))\n        values.append(BarEntry(8.0, [24.3, 31.0, 47.1]))\n        values.append(BarEntry(9.0, [17.4, 48.4, 49.6]))\n        values.append(BarEntry(10.0, [32.0, 29.8, 20.0]))\n        values.append(BarEntry(11.0, [43.9, 52.7, 27.7]))\n        values.append(BarEntry(12.0, [28.4, 46.2, 51.8]))\n        values.append(BarEntry(13.0, [42.6, 51.9, 44.0]))\n        values.append(BarEntry(14.0, [14.8, 22.4, 31.2]))\n        values.append(BarEntry(15.0, [50.3, 18.7, 18.3]))\n        values.append(BarEntry(16.0, [20.7, 22.9, 40.2]))\n        values.append(BarEntry(17.0, [49.4, 38.3, 41.7]))\n        values.append(BarEntry(18.0, [45.9, 40.7, 29.5]))\n        values.append(BarEntry(19.0, [37.1, 31.8, 42.9]))\n        let set1: BarDataSet\n        set1 = BarDataSet(values, \"Statistics Vienna 2014\")\n        set1.setDrawIcons(false)\n        set1.setColorsByVariable(this.getColors())\n        set1.setStackLabels([\"Births\", \"Divorces\", \"Marriages\"])\n        let dataSets: ArrayList<IBarDataSet> = ArrayList<IBarDataSet>()\n        dataSets.append(set1)\n        let data: BarData = BarData(dataSets)\n        data.setValueTextColor(0xffffff)\n        return data\n    }\n    private func getColors(): Array<UInt32> {\n        let colors: Array<UInt32> = [UInt32(ColorTemplate.MATERIAL_COLORS[0]), UInt32(ColorTemplate.MATERIAL_COLORS[1]),\n        UInt32(ColorTemplate.MATERIAL_COLORS[2])]\n        return colors\n    }\n    func build() {\n        Column {\n            BarChart(model: this.model)\n        }.width(100.percent).height(70.percent).backgroundColor(Color.WHITE)\n    }\n}", "llm_cg": {"main": [], "StackedBarChartPage": ["BarChartModel.build", "LimitLine", "LimitLine", "LimitLine"], "StackedBarChartPage.aboutToAppear": ["this.model.getDescription", "description.setEnabled", "this.model.getLegend", "l.setEnabled", "this.model.setMaxVisibleValueCount", "this.model.setDrawGridBackground", "this.model.setGridBackgroundColor", "this.model.setDrawBarShadow", "this.model.setDrawValueAboveBar", "LimitLine", "this.limitLine1.setLineWidth", "this.limitLine1.enableDashedLine", "this.limitLine1.setLabelPosition", "this.limitLine1.setTextSize", "LimitLine", "this.limitLine2.setLineWidth", "this.limitLine2.enableDashedLine", "this.limitLine2.setLineColor", "this.limitLine2.setLabelPosition", "this.limitLine2.setTextSize", "this.model.getAxisLeft", "leftAxis.setAxisMinimum", "leftAxis.setDrawLimitLinesBehindData", "leftAxis.addLimitLine", "leftAxis.addLimitLine", "this.model.getAxisRight", "rightAxis.setEnabled", "rightAxis.setAxisMinimum", "this.model.getXAxis", "xAxis.setPosition", "this.getStackData", "this.model.setData", "this.model.setVisibleXRangeMaximum"], "StackedBarChartPage.getStackData": ["BarEntry", "BarEntry", "BarEntry", "BarEntry", "BarEntry", "BarEntry", "BarEntry", "BarEntry", "BarEntry", "BarEntry", "BarEntry", "BarEntry", "BarEntry", "BarEntry", "BarEntry", "BarEntry", "BarEntry", "BarEntry", "BarEntry", "BarDataSet", "set1.setDrawIcons", "this.getColors", "set1.setColorsByVariable", "set1.setStackLabels", "BarData", "data.setValueTextColor"], "StackedBarChartPage.getColors": [], "StackedBarChartPage.build": ["BarChart"]}, "static_cg": {}}
{"source_code": "package httpclient\nfrom std import io.*\nfrom std import collection.*\nfrom std import fs.*\npublic class FileDownload {\n    public init () {}\n    public func builder (pathname: String, fileData: String) {\n        var filePathValid = FileUtils().isFilePathValid(pathname)\n        var fs: File = File(pathname,Open(false, true))\n        if (fs.canWrite()) {\n        \tlet toWrite: Array<UInt8> = fileData.toUtf8Array()\n        \tlet writeFile = fs.write(toWrite)\n        \tfs.flush()\n        \tfs.close()\n        } else {\n            throw WriteException(\"Can not write file\")\n        }\n    }\n}", "llm_cg": {"main": [], "FileDownload": [], "FileDownload.init": [], "FileDownload.builder": ["FileUtils.isFilePathValid", "File", "Open", "File.canWrite", "fileData.toUtf8Array", "fs.write", "fs.flush", "fs.close", "WriteException"]}, "static_cg": {}}
{"source_code": "package rewrite\nfunc SplitCurrentState<V, G>(\n    coreEdge : Edge<V, G>,\n    numberOfStateWires : Int64,\n    rewriteStartingElements : HashSet<TraversalElement<V, G>>,\n    rewriteEndingElements : HashSet<TraversalElement<V, G>>\n) : Array<(Vertex<V, G>, Vertex<V, G>)>\n    where V <: ValueSymbol<V>, G <: PrimitiveSymbol<V, G>\n{\n    Array<(Vertex<V, G>, Vertex<V, G>)>(\n        numberOfStateWires,\n        { i : Int64 =>\n            let joinEdge = coreEdge.NextEdgeLeft(i).getOrThrow().GetEdge()\n            let joinSourceLeft = joinEdge.GetSource(0)\n            let (left, right) = joinSourceLeft.SplitVertex()\n            rewriteStartingElements.put(VERTEX(left))\n            rewriteEndingElements.put(EDGE(joinEdge))\n            (left, right)\n        }\n    )\n}\nfunc GetCoreSourceVertices<V, G>(\n    coreEdge : Edge<V, G>,\n    numberOfStateWires : Int64,\n    inputSignals : Array<CycleInput<V>>,\n    splitStateVertices : Array<(Vertex<V, G>, Vertex<V, G>)>,\n    rewriteStartingElements : HashSet<TraversalElement<V, G>>\n) : Array<Vertex<V, G>>\n    where V <: ValueSymbol<V>, G <: PrimitiveSymbol<V, G> {\n    Array<Vertex<V, G>>(\n        coreEdge.GetArity(),\n        { i : Int64 =>\n            // Check which partition of sources this belongs to\n            if(i < numberOfStateWires) {\n                // This is a vertex from the state\n                // We grab the existing state vertex\n                splitStateVertices[i][0]\n            } else {\n                // This is a vertex from the inputs\n                // We create the input edge and grab its target\n                // Get the signal\n                let input = inputSignals[i - numberOfStateWires]\n                let (inputLabel, inputSubgraph) =\n                    match(input) {\n                        case DEFINITE(signal) =>\n                            // Make a label\n                            let signalLabel = GetSignalLabel<V, G>(signal)\n                            let signalSubgraph = if(signal.GetWidth() == 1) {\n                                None<InterfacedHypergraph<V, G>>\n                            } else {\n                                MakeSignal<V, G>(signal)\n                            }\n                            (signalLabel, signalSubgraph)\n                        case PARTIAL(pi) =>\n                            let partialLabel = Label<V, G>.PARTIAL(pi)\n                            let partialSubgraph =\n                                None<InterfacedHypergraph<V, G>>\n                            (partialLabel, partialSubgraph)\n                    }\n                let inputTarget = Vertex<V, G>(input.GetWidth(), None)\n                // Create the signal\n                let inputEdge = Edge(\n                    inputLabel, Array<Vertex<V, G>>(), [inputTarget],\n                    inputSubgraph, coreEdge.GetGraph()\n                )\n                // The target of this edge will need to be traversed\n                // during rewriting\n                rewriteStartingElements.put(VERTEX(inputTarget))\n                inputTarget\n            }\n        }\n    )\n}\nfunc CreateOutputJoinEdges<V, G>(\n    graph : Hypergraph<V, G>,\n    latestDelayVertices : Array<Vertex<V, G>>,\n    latestInstantVertices : Array<Vertex<V, G>>,\n    rewriteEndingElements : HashSet<TraversalElement<V, G>>\n) : Array<Edge<V, G>> where V <: ValueSymbol<V>, G <: PrimitiveSymbol<V, G> {\n    mapi(\n        { v : Vertex<V, G>, i : Int64 =>\n            // Split this vertex, as we are going to insert a register\n            let (leftVertex, rightVertex) = v.SplitVertex()\n            let outputWidth = v.GetWidth()\n            let delayTarget = Vertex<V, G>(outputWidth, Some(graph))\n            let delayEdge = Edge(\n                DELAY(outputWidth), [leftVertex], [delayTarget], None, graph\n            )\n            latestDelayVertices[i] = leftVertex\n            // Create the instant component for this register\n            let outputTarget = Vertex<V, G>(outputWidth, Some(graph))\n            latestInstantVertices[i] = outputTarget\n            // Create the join for this register\n            let joinEdge = Edge(\n                JOIN(outputWidth), [outputTarget, delayTarget],\n                [rightVertex], None, graph\n            )\n            rewriteEndingElements.put(VERTEX(outputTarget))\n            joinEdge\n        }, latestDelayVertices\n    )\n}\npublic func GetCoreTargetVertices<V, G>(\n    coreEdge : Edge<V, G>,\n    numberOfStateWires : Int64,\n    splitStateVertices : Array<(Vertex<V, G>, Vertex<V, G>)>,\n    latestInstantVertices : Array<Vertex<V, G>>\n) : Array<Vertex<V, G>>\n    where V <: ValueSymbol<V>, G <: PrimitiveSymbol<V, G>\n{\n    Array<Vertex<V, G>>(coreEdge.GetCoarity()) {\n        i : Int64 =>\n            // The targets of the cloned core edge are paritioned between\n            // the state transition and the outputs. If we are getting the\n            // target for a state transition, we just use the right vertex\n            // of the split state we made earlier. If we are getting the\n            // target for an output, we split the corresponding output\n            // vertex and insert a register, the instnat component of which\n            // is the target we are getting.\n            if(i < numberOfStateWires) {\n                splitStateVertices[i][1]\n            } else {\n                latestInstantVertices[i - numberOfStateWires]\n            }\n    }\n}\nfunc GetOutputData<V, G>(\n    outputSubgraphs : Array<InterfacedHypergraph<V, G>>\n) : Array<OutputData<V, G>>\n    where V <: ValueSymbol<V>, G <: PrimitiveSymbol<V, G>\n{\n    map(\n        { f =>\n            let term = GetOutputTerm(f.GetOutput(0).GetVertex())\n            OutputData<V, G>(term, f)\n        }, outputSubgraphs\n    )\n}\nfunc UpdateInputOutputHistory<V, G>(\n    graph : InterfacedHypergraph<V, G>,\n    inputSignals : Array<CycleInput<V>>,\n    outputSubgraphs : Array<InterfacedHypergraph<V, G>>,\n    history : InputOutputHistory<V, G>\n) : Unit where V <: ValueSymbol<V>, G <: PrimitiveSymbol<V, G> {\n    let outputData = GetOutputData(outputSubgraphs)\n    history.inputHistoryPerTick.append(inputSignals)\n    history.outputHistoryPerTick.append(outputData)\n    let inputOutput = InputOutput(inputSignals, outputData)\n    history.inputOutputHistoryPerTick.append(inputOutput)\n    for(i in 0..graph.GetArity()) {\n        history.inputHistoryPerPort[i].append(inputSignals[i])\n    }\n    for(i in 0..graph.GetCoarity()) {\n        history.outputHistoryPerPort[i].append(outputData[i])\n    }\n}\nfunc CollapseSingleOutput<V, G>(\n    rootVertex : Vertex<V, G>, label : Label<V, G>, tick : Int64, index : Int64\n) : InterfacedHypergraph<V, G>\n    where V <: ValueSymbol<V>, G <: PrimitiveSymbol<V, G>\n{\n    let (subgraph, _) = rootVertex.GetGraph().CollapseSubgraph(\n        Array<TentacleOrigin<V, G>>(),\n        [FROM_EDGE(rootVertex.GetInEdge().getOrThrow())],\n        \"${label.GetName()}[${index}] @ ${tick}\"\n    )\n    subgraph\n}\nfunc CollapseOutputs<V, G>(\n    joinEdges : Array<Edge<V, G>>, label : Label<V, G>, tick : Int64\n) : Array<InterfacedHypergraph<V, G>>\n    where V <: ValueSymbol<V>, G <: PrimitiveSymbol<V, G>\n{\n    mapi(\n        { e : Edge<V, G>, i : Int64 =>\n            CollapseSingleOutput(e.GetSource(0), label, tick, i)\n        },\n        joinEdges\n    )\n}\nfunc PerformCycle<V, G>(\n    graph : InterfacedHypergraph<V, G>, inputSignals : Array<CycleInput<V>>,\n    signature : Signature<V, G>, coreEdge : Edge<V, G>,\n    numberOfStateWires : Int64, latestInstantVertices : Array<Vertex<V, G>>,\n    latestDelayVertices : Array<Vertex<V, G>>,\n    history : InputOutputHistory<V, G>, debug : Bool, draw!: Bool = false\n) : Unit where V <: ValueSymbol<V>, G <: PrimitiveSymbol<V, G> {\n    // Can only perform a cycle for the right number of inputs\n    AssertHasInputs(graph, inputSignals.size)\n    // Track the elements we will be starting and ending the rewrite later\n    let rewriteStartingElements = HashSet<TraversalElement<V, G>>()\n    let rewriteEndingElements = HashSet<TraversalElement<V, G>>()\n    // Split the state vertices so we can insert the next state\n    let splitJoinVertices = SplitCurrentState(\n        coreEdge, numberOfStateWires,\n        rewriteStartingElements, rewriteEndingElements\n    )\n    let currentJoinEdges = CreateOutputJoinEdges(\n        graph.GetGraph(), latestDelayVertices, latestInstantVertices,\n        rewriteEndingElements\n    )\n    // The next step is to clone the core so we can attach the current state\n    // and input values to it and reduce appropriately.\n    // To do this we need to get or create the vertices that will make up\n    // its inputs and outputs.\n    let coreCopyInputs = GetCoreSourceVertices(\n        coreEdge, numberOfStateWires, inputSignals, splitJoinVertices,\n        rewriteStartingElements\n    )\n    let coreCopyOutputs = GetCoreTargetVertices(\n        coreEdge, numberOfStateWires, splitJoinVertices, latestInstantVertices\n    )\n    // Now we can actually clone the core edge and attach it to the inputs\n    // and outputs we just made\n    let coreCopyEdge = coreEdge.Clone(\n        coreCopyInputs, coreCopyOutputs, graph.GetGraph()\n    )\n    // Rewrite the copy of the combinational core. We want to\n    // force blackboxes as much as possible to the right so that each\n    // element of the state is isolated. Moreover, since the core is\n    // guaranteed to be capped off with values, we can safely apply\n    // instantaneous rules\n    RewriteCombinational(\n        signature, graph, rewriteStartingElements, rewriteEndingElements,\n        copyBlackBoxes: true, allInstantaneous: true, debug: debug, draw: draw\n    )\n    let outputSubgraphs = CollapseOutputs(\n        currentJoinEdges, graph.GetLabel(), history.GetCurrentTick()\n    )\n    // Look at what we've just done and update the input output history\n    UpdateInputOutputHistory(\n        graph, inputSignals, outputSubgraphs, history\n    )\n}\nextend Evaluator<V, G> {\n    public func PerformCycle(\n        inputs : Array<CycleInput<V>>, debug!: Bool = false,  draw!: Bool = false\n    ) : Unit {\n        PerformCycle<V, G>(\n            this.graph, inputs, this.sig, this.coreEdge,\n            this.numberOfStateWires, this.latestInstantVertices,\n            this.latestDelayVertices, this.history, debug, draw: draw\n        )\n        // We're done!\n        this.currentCycle++\n    }\n    public func PerformCycle(\n        signals : Array<Signal<V>>, debug!: Bool = false, draw!: Bool = false\n    ) : Unit {\n        let inputs = map({ s : Signal<V> => DEFINITE(s) }, signals)\n        PerformCycle(inputs, debug: debug, draw: draw)\n    }\n    public func PerformCycle(\n        values : Array<V>, debug!: Bool = false, draw!: Bool = false\n    ) : Unit {\n        let inputSignals = map({ v : V => Signal(v) }, values)\n        this.PerformCycle(inputSignals, debug: debug, draw: draw)\n    }\n    public func PerformCycle(\n        signal : Signal<V>, debug!: Bool = false, draw!: Bool = false\n    ) : Unit {\n        AssertHasInputs(this.graph, 1)\n        this.PerformCycle([signal], debug: debug, draw: draw)\n    }\n    public func PerformCycle(\n        value : V, debug!: Bool = false, draw!: Bool = false\n    ) : Unit {\n        AssertHasInputs(this.graph, 1)\n        this.PerformCycle(Signal(value), debug: debug, draw: draw)\n    }\n    public func PerformCycles(\n        signalsPerTick: Array<Array<CycleInput<V>>>, debug!: Bool = false, draw!: Bool = false\n    ) : Unit {\n        for(signals in signalsPerTick) {\n            this.PerformCycle(signals, debug: debug, draw: draw)\n        }\n    }\n    public func PerformCycles(\n        valuesPerTick: Array<Array<V>>, debug!: Bool = false, draw!: Bool = false) : Unit {\n        for(values in valuesPerTick) {\n            this.PerformCycle(values, debug: debug, draw: draw)\n        }\n    }\n    public func PerformCycles(\n        waveforms: Array<Waveform<V>>, debug!: Bool = false, draw!: Bool = false) : Unit {\n        let signalsPerTick = ArrayOfInputsToArrayOfTicks(waveforms)\n        PerformCycles(signalsPerTick, debug: debug, draw: draw)\n    }\n    public func PerformCycles(\n        waveform: Waveform<V>, debug!: Bool = false, draw!: Bool = false\n    ) : Unit {\n        AssertHasInputs(this.graph, 1)\n        PerformCycles([waveform], debug: debug, draw: draw)\n    }\n    public func PerformCycles(\n        signals: Array<Signal<V>>, ticks!: Int64, debug!: Bool = false, draw!: Bool = false\n    ) : Unit {\n        AssertHasInputs(this.graph, signals.size)\n        for(_ in 0..ticks) {\n            PerformCycle(signals, debug: debug, draw: draw)\n        }\n    }\n    public func PerformCycles(\n        values: Array<V>, ticks!: Int64, debug!: Bool = false, draw!: Bool = false\n    ) : Unit {\n        AssertHasInputs(this.graph, values.size)\n        for(_ in 0..ticks) {\n            PerformCycle(values, debug: debug, draw: draw)\n        }\n    }\n}\nextend Evaluator<V, G> where V <: Decimal<V> {\n    public func PerformCycle(\n        inputs : Array<Int64>, signed!: Bool, debug!: Bool = false, draw!: Bool = false\n    ) : Unit {\n        AssertHasInputs(this.graph, inputs.size)\n        let inputSignals = mapi(\n            { v : Int64, i : Int64 =>\n                V.DecToSignal(\n                    v, width: this.graph.GetInput(i).GetWidth(), signed: signed\n                )\n            },\n            inputs\n        )\n        this.PerformCycle(inputSignals, debug: debug, draw: draw)\n    }\n    public func PerformCycle(\n        input: Int64, signed!: Bool, debug!: Bool = false, draw!: Bool = false\n    ) : Unit {\n        AssertHasInputs(this.graph, 1)\n        this.PerformCycle([input], signed: signed, debug: debug, draw: draw)\n    }\n    public func PerformCycles(\n        inputs : Array<Int64>, signed!: Bool, ticks!: Int64,\n        debug!: Bool = false, draw!: Bool = false\n    ) : Unit {\n        AssertHasInputs(this.graph, inputs.size)\n        for(_ in 0..ticks) {\n            PerformCycle(inputs, signed: signed, debug: debug, draw: draw)\n        }\n    }\n    public func PerformCycles(\n        input : Int64, signed!: Bool, ticks!: Int64, debug!: Bool = false, draw!: Bool = false\n    ) : Unit {\n        AssertHasInputs(this.graph, 1)\n        for(_ in 0..ticks) {\n            PerformCycle(input, signed: signed, debug: debug, draw: draw)\n        }\n    }\n}", "llm_cg": {"main": [], "SplitCurrentState": ["Edge.NextEdgeLeft", "Edge.getOrThrow", "Edge.GetEdge", "Edge.GetSource", "Vertex.SplitVertex", "HashSet.put"], "GetCoreSourceVertices": ["Edge.GetArity", "Array.<constructor>", "CycleInput.GetWidth", "Signal.GetWidth", "GetSignalLabel", "MakeSignal", "HashSet.put", "Label.PARTIAL", "Vertex.<constructor>", "Edge.<constructor>", "HashSet.put"], "CreateOutputJoinEdges": ["Array.mapi", "Vertex.SplitVertex", "Vertex.GetWidth", "Vertex.<constructor>", "Edge.<constructor>", "HashSet.put"], "GetCoreTargetVertices": ["Edge.GetCoarity"], "GetOutputData": ["Array.map", "GetOutputTerm", "OutputData.<constructor>"], "UpdateInputOutputHistory": ["GetOutputData", "InputOutput.<constructor>", "Array.append"], "CollapseSingleOutput": ["Vertex.GetGraph", "Graph.CollapseSubgraph", "Vertex.GetInEdge", "Edge.getOrThrow", "Label.GetName"], "CollapseOutputs": ["Array.mapi", "CollapseSingleOutput", "Edge.GetSource"], "PerformCycle": ["AssertHasInputs", "SplitCurrentState", "CreateOutputJoinEdges", "GetCoreSourceVertices", "GetCoreTargetVertices", "Edge.Clone", "RewriteCombinational", "CollapseOutputs", "UpdateInputOutputHistory"], "Evaluator.PerformCycle": ["PerformCycle"], "Evaluator.PerformCycles": ["PerformCycle", "ArrayOfInputsToArrayOfTicks"], "Evaluator.<with Decimal<V>>.PerformCycle": ["V.DecToSignal", "Array.mapi", "PerformCycle"], "Evaluator.<with Decimal<V>>.PerformCycles": ["PerformCycle"]}, "static_cg": {}}
{"source_code": "package cbor4cj\npublic class MapBuilder<T> <: AbstractBuilder<T> {\n    private let map: CborMap\n    public init(parent: T, map: CborMap) {\n        super(parent)\n        this.map = map\n    }\n    public func put(key: DataItem, value: DataItem): MapBuilder<T> {\n        map.put(key, value)\n        return this\n    }\n    public func put(key: Int64, value: Int64): MapBuilder<T> {\n        put(convert(key), convert(value))\n        return this\n    }\n    public func put(key: Int64, value: Bool): MapBuilder<T> {\n        put(convert(key), convert(value))\n        return this\n    }\n    public func put(key: Int64, value: Float32): MapBuilder<T> {\n        put(convert(key), convert(value))\n        return this\n    }\n    public func put(key: Int64, value: Float64): MapBuilder<T> {\n        put(convert(key), convert(value))\n        return this\n    }\n    public func put(key: Int64, value: Array<UInt8>): MapBuilder<T> {\n        put(convert(key), convert(value))\n        return this\n    }\n    public func put(key: Int64, value: String): MapBuilder<T> {\n        put(convert(key), convert(value))\n        return this\n    }\n    public func put(key: String, value: Int64): MapBuilder<T> {\n        put(convert(key), convert(value))\n        return this\n    }\n    public func put(key: String, value: Bool): MapBuilder<T> {\n        put(convert(key), convert(value))\n        return this\n    }\n    public func put(key: String, value: Float32): MapBuilder<T> {\n        put(convert(key), convert(value))\n        return this\n    }\n    public func put(key: String, value: Float64): MapBuilder<T> {\n        put(convert(key), convert(value))\n        return this\n    }\n    public func put(key: String, value: Array<UInt8>): MapBuilder<T> {\n        map.put(convert(key), convert(value))\n        return this\n    }\n    public func put(key: String, value: String): MapBuilder<T> {\n        put(convert(key), convert(value))\n        return this\n    }\n    public func putArray(key: DataItem): ArrayBuilder<MapBuilder<T>> {\n        let array = CborArray()\n        put(key, array)\n        return ArrayBuilder<MapBuilder<T>>(this, array)\n    }\n    public func putArray(key: Int64): ArrayBuilder<MapBuilder<T>> {\n        let array = CborArray()\n        put(convert(key), array)\n        return ArrayBuilder<MapBuilder<T>>(this, array)\n    }\n    public func putArray(key: String): ArrayBuilder<MapBuilder<T>> {\n        let array = CborArray()\n        put(convert(key), array)\n        return ArrayBuilder<MapBuilder<T>>(this, array)\n    }\n    public func startArray(key: DataItem): ArrayBuilder<MapBuilder<T>> {\n        let array = CborArray()\n        array.setChunked(true)\n        put(key, array)\n        return ArrayBuilder<MapBuilder<T>>(this, array)\n    }\n    public func startArray(key: Int64): ArrayBuilder<MapBuilder<T>> {\n        return startArray(convert(key))\n    }\n    public func startArray(key: String): ArrayBuilder<MapBuilder<T>> {\n        let array = CborArray()\n        array.setChunked(true)\n        put(convert(key), array)\n        return ArrayBuilder<MapBuilder<T>>(this, array)\n    }\n    public func putMap(key: DataItem): MapBuilder<Object> {\n        let nestedMap = CborMap()\n        put(key, nestedMap)\n        return MapBuilder<Object>(this, nestedMap)\n    }\n    public func putMap(key: Int64): MapBuilder<Object> {\n        let nestedMap = CborMap()\n        put(convert(key), nestedMap)\n        return MapBuilder<Object>(this, nestedMap)\n    }\n    public func putMap(key: String): MapBuilder<Object> {\n        let nestedMap = CborMap()\n        put(convert(key), nestedMap)\n        return MapBuilder<Object>(this, nestedMap)\n    }\n    public func startMap(key: DataItem): MapBuilder<Object> {\n        let nestedMap = CborMap()\n        nestedMap.setChunked(true)\n        put(key, nestedMap)\n        return MapBuilder<Object>(this, nestedMap)\n    }\n    public func startMap(key: Int64): MapBuilder<Object> {\n        return startMap(convert(key))\n    }\n    public func startMap(key: String): MapBuilder<Object> {\n        return startMap(convert(key))\n    }\n    public func end(): ?T {\n        return getParent()\n    }\n}", "llm_cg": {"MapBuilder": [], "MapBuilder.init": ["super"], "MapBuilder.put": ["CborMap.put", "convert"], "MapBuilder.putArray": ["CborArray", "convert", "CborMap.put", "ArrayBuilder"], "MapBuilder.startArray": ["CborArray", "CborArray.setChunked", "convert", "CborMap.put", "ArrayBuilder"], "MapBuilder.putMap": ["CborMap", "CborMap.put", "convert", "MapBuilder"], "MapBuilder.startMap": ["CborMap", "CborMap.setChunked", "CborMap.put", "convert", "MapBuilder"], "MapBuilder.end": ["getParent"]}, "static_cg": {}}
{"source_code": "macro package CJson.jsonmacro\npublic macro JsonCust(attr_Tk: Tokens, input_Tk: Tokens): Tokens {\n    var decl = TokenVerifier.verifyVarDecl(input_Tk, Const.JSON_NAME_MARCO_NAME)\n    assertParentContext(\"JsonSerializable\")\n    setItem(\"prop\", decl.identifier.value)\n    setItem(\"serializer\", attr_Tk.toString())\n    return input_Tk\n}", "llm_cg": {"main": [], "JsonCust": ["TokenVerifier.verifyVarDecl", "attr_Tk.toString"]}, "static_cg": {}}
